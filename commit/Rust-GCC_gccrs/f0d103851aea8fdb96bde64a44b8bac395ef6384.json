{"sha": "f0d103851aea8fdb96bde64a44b8bac395ef6384", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBkMTAzODUxYWVhOGZkYjk2YmRlNjRhNDRiOGJhYzM5NWVmNjM4NA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T07:08:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-22T07:08:23Z"}, "message": "[multiple changes]\n\n2010-06-22  Gary Dismukes  <dismukes@adacore.com>\n\n\t* sem_ch3.adb (Build_Discriminal): Set default scopes for newly created\n\tdiscriminals to the current scope.\n\t* sem_util.adb (Find_Body_Discriminal): Remove setting of discriminal's\n\tscope, which could overwrite a different already set value.\n\n2010-06-22  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Valid_Conversion): If expression is a predefined\n\toperator, use sloc of type of interpretation to improve error message\n\twhen operand is of some derived type.\n\t* sem_eval.adb (Is_Mixed_Mode_Operand): New function, use it.\n\n2010-06-22  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-expect-vms.adb (Expect_Internal): No longer raises an exception, so\n\tthat it can set out parameters as well. When a process has died, reset\n\tits Input_Fd to Invalid_Fd, so that when using multiple processes we\n\tcan find out which process has died.\n\nFrom-SVN: r161135", "tree": {"sha": "688882bcccbcc9c373ed6773350213fd15bfa338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/688882bcccbcc9c373ed6773350213fd15bfa338"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0d103851aea8fdb96bde64a44b8bac395ef6384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d103851aea8fdb96bde64a44b8bac395ef6384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0d103851aea8fdb96bde64a44b8bac395ef6384", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0d103851aea8fdb96bde64a44b8bac395ef6384/comments", "author": null, "committer": null, "parents": [{"sha": "d7567964ea0f6ff865f8488a06bc5dff75a0973e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7567964ea0f6ff865f8488a06bc5dff75a0973e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7567964ea0f6ff865f8488a06bc5dff75a0973e"}], "stats": {"total": 271, "additions": 201, "deletions": 70}, "files": [{"sha": "fcc8c886248824445b39defc329ed956e0e34431", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f0d103851aea8fdb96bde64a44b8bac395ef6384", "patch": "@@ -1,3 +1,24 @@\n+2010-06-22  Gary Dismukes  <dismukes@adacore.com>\n+\n+\t* sem_ch3.adb (Build_Discriminal): Set default scopes for newly created\n+\tdiscriminals to the current scope.\n+\t* sem_util.adb (Find_Body_Discriminal): Remove setting of discriminal's\n+\tscope, which could overwrite a different already set value.\n+\n+2010-06-22  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Valid_Conversion): If expression is a predefined\n+\toperator, use sloc of type of interpretation to improve error message\n+\twhen operand is of some derived type.\n+\t* sem_eval.adb (Is_Mixed_Mode_Operand): New function, use it.\n+\n+2010-06-22  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-expect-vms.adb (Expect_Internal): No longer raises an exception, so\n+\tthat it can set out parameters as well. When a process has died, reset\n+\tits Input_Fd to Invalid_Fd, so that when using multiple processes we\n+\tcan find out which process has died.\n+\n 2010-06-22  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_eval.adb (Find_Universal_Operator_Type): New"}, {"sha": "d92e1e7783ef7183838eb04e8c29590c354b1d4c", "filename": "gcc/ada/g-expect-vms.adb", "status": "modified", "additions": 129, "deletions": 67, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fg-expect-vms.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fg-expect-vms.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect-vms.adb?ref=f0d103851aea8fdb96bde64a44b8bac395ef6384", "patch": "@@ -50,18 +50,26 @@ package body GNAT.Expect is\n    Save_Output : File_Descriptor;\n    Save_Error  : File_Descriptor;\n \n+   Expect_Process_Died   : constant Expect_Match := -100;\n+   Expect_Internal_Error : constant Expect_Match := -101;\n+   --  Additional possible outputs of Expect_Internal. These are not visible in\n+   --  the spec because the user will never see them.\n+\n    procedure Expect_Internal\n      (Descriptors : in out Array_Of_Pd;\n       Result      : out Expect_Match;\n       Timeout     : Integer;\n       Full_Buffer : Boolean);\n    --  Internal function used to read from the process Descriptor.\n    --\n-   --  Three outputs are possible:\n+   --  Several outputs are possible:\n    --     Result=Expect_Timeout, if no output was available before the timeout\n    --        expired.\n    --     Result=Expect_Full_Buffer, if Full_Buffer is True and some characters\n    --        had to be discarded from the internal buffer of Descriptor.\n+   --     Result=Express_Process_Died if one of the processes was terminated.\n+   --        That process's Input_Fd is set to Invalid_FD\n+   --     Result=Express_Internal_Error\n    --     Result=<integer>, indicates how many characters were added to the\n    --        internal buffer. These characters are from indexes\n    --        Descriptor.Buffer_Index - Result + 1 .. Descriptor.Buffer_Index\n@@ -209,7 +217,9 @@ package body GNAT.Expect is\n       Status     : out Integer)\n    is\n    begin\n-      Close (Descriptor.Input_Fd);\n+      if Descriptor.Input_Fd /= Invalid_FD then\n+         Close (Descriptor.Input_Fd);\n+      end if;\n \n       if Descriptor.Error_Fd /= Descriptor.Output_Fd then\n          Close (Descriptor.Error_Fd);\n@@ -331,10 +341,17 @@ package body GNAT.Expect is\n \n          Expect_Internal (Descriptors, N, Timeout_Tmp, Full_Buffer);\n \n-         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n-            Result := N;\n-            return;\n-         end if;\n+         case N is\n+            when Expect_Internal_Error | Expect_Process_Died =>\n+               raise Process_Died;\n+\n+            when Expect_Timeout | Expect_Full_Buffer =>\n+               Result := N;\n+               return;\n+\n+            when others =>\n+               null;  --  See below\n+         end case;\n \n          --  Calculate the timeout for the next turn\n \n@@ -478,10 +495,17 @@ package body GNAT.Expect is\n \n          Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n \n-         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n-            Result := N;\n-            return;\n-         end if;\n+         case N is\n+            when Expect_Internal_Error | Expect_Process_Died =>\n+               raise Process_Died;\n+\n+            when Expect_Timeout | Expect_Full_Buffer =>\n+               Result := N;\n+               return;\n+\n+            when others =>\n+               null;  --  Continue\n+         end case;\n       end loop;\n    end Expect;\n \n@@ -500,7 +524,9 @@ package body GNAT.Expect is\n \n       for J in Descriptors'Range loop\n          Descriptors (J) := Regexps (J).Descriptor;\n-         Reinitialize_Buffer (Regexps (J).Descriptor.all);\n+         if Descriptors (J) /= null then\n+            Reinitialize_Buffer (Regexps (J).Descriptor.all);\n+         end if;\n       end loop;\n \n       loop\n@@ -511,25 +537,36 @@ package body GNAT.Expect is\n          --  checking the regexps).\n \n          for J in Regexps'Range loop\n-            Match (Regexps (J).Regexp.all,\n-                   Regexps (J).Descriptor.Buffer\n-                     (1 .. Regexps (J).Descriptor.Buffer_Index),\n-                   Matched);\n-\n-            if Matched (0) /= No_Match then\n-               Result := Expect_Match (J);\n-               Regexps (J).Descriptor.Last_Match_Start := Matched (0).First;\n-               Regexps (J).Descriptor.Last_Match_End := Matched (0).Last;\n-               return;\n+            if Regexps (J).Regexp /= null\n+               and then Regexps (J).Descriptor /= null\n+            then\n+               Match (Regexps (J).Regexp.all,\n+                      Regexps (J).Descriptor.Buffer\n+                        (1 .. Regexps (J).Descriptor.Buffer_Index),\n+                      Matched);\n+\n+               if Matched (0) /= No_Match then\n+                  Result := Expect_Match (J);\n+                  Regexps (J).Descriptor.Last_Match_Start := Matched (0).First;\n+                  Regexps (J).Descriptor.Last_Match_End := Matched (0).Last;\n+                  return;\n+               end if;\n             end if;\n          end loop;\n \n          Expect_Internal (Descriptors, N, Timeout, Full_Buffer);\n \n-         if N = Expect_Timeout or else N = Expect_Full_Buffer then\n-            Result := N;\n-            return;\n-         end if;\n+         case N is\n+            when Expect_Internal_Error | Expect_Process_Died =>\n+               raise Process_Died;\n+\n+            when Expect_Timeout | Expect_Full_Buffer =>\n+               Result := N;\n+               return;\n+\n+            when others =>\n+               null;  --  Continue\n+         end case;\n       end loop;\n    end Expect;\n \n@@ -549,21 +586,30 @@ package body GNAT.Expect is\n       N : Integer;\n \n       type File_Descriptor_Array is\n-        array (Descriptors'Range) of File_Descriptor;\n+        array (0 .. Descriptors'Length - 1) of File_Descriptor;\n       Fds : aliased File_Descriptor_Array;\n+      Fds_Count : Natural := 0;\n+\n+      Fds_To_Descriptor : array (Fds'Range) of Integer;\n+      --  Maps file descriptor entries from Fds to entries in Descriptors.\n+      --  They do not have the same index when entries in Descriptors are null.\n \n-      type Integer_Array is array (Descriptors'Range) of Integer;\n+      type Integer_Array is array (Fds'Range) of Integer;\n       Is_Set : aliased Integer_Array;\n \n    begin\n       for J in Descriptors'Range loop\n-         Fds (J) := Descriptors (J).Output_Fd;\n+         if Descriptors (J) /= null then\n+            Fds (Fds'First + Fds_Count) := Descriptors (J).Output_Fd;\n+            Fds_To_Descriptor (Fds'First + Fds_Count) := J;\n+            Fds_Count := Fds_Count + 1;\n \n-         if Descriptors (J).Buffer_Size = 0 then\n-            Buffer_Size := Integer'Max (Buffer_Size, 4096);\n-         else\n-            Buffer_Size :=\n-              Integer'Max (Buffer_Size, Descriptors (J).Buffer_Size);\n+            if Descriptors (J).Buffer_Size = 0 then\n+               Buffer_Size := Integer'Max (Buffer_Size, 4096);\n+            else\n+               Buffer_Size :=\n+                 Integer'Max (Buffer_Size, Descriptors (J).Buffer_Size);\n+            end if;\n          end if;\n       end loop;\n \n@@ -572,19 +618,23 @@ package body GNAT.Expect is\n          --  Buffer used for input. This is allocated only once, not for\n          --  every iteration of the loop\n \n+         D : Integer;\n+         --  Index in Descriptors\n+\n       begin\n          --  Loop until we match or we have a timeout\n \n          loop\n             Num_Descriptors :=\n-              Poll (Fds'Address, Fds'Length, Timeout, Is_Set'Address);\n+              Poll (Fds'Address, Fds_Count, Timeout, Is_Set'Address);\n \n             case Num_Descriptors is\n \n                --  Error?\n \n                when -1 =>\n-                  raise Process_Died;\n+                  Result := Expect_Internal_Error;\n+                  return;\n \n                --  Timeout?\n \n@@ -595,59 +645,64 @@ package body GNAT.Expect is\n                --  Some input\n \n                when others =>\n-                  for J in Descriptors'Range loop\n-                     if Is_Set (J) = 1 then\n-                        Buffer_Size := Descriptors (J).Buffer_Size;\n+                  for F in Fds'Range loop\n+                     if Is_Set (F) = 1 then\n+                        D := Fds_To_Descriptor (F);\n+\n+                        Buffer_Size := Descriptors (D).Buffer_Size;\n \n                         if Buffer_Size = 0 then\n                            Buffer_Size := 4096;\n                         end if;\n \n-                        N := Read (Descriptors (J).Output_Fd, Buffer'Address,\n+                        N := Read (Descriptors (D).Output_Fd, Buffer'Address,\n                                    Buffer_Size);\n \n                         --  Error or End of file\n \n                         if N <= 0 then\n                            --  ??? Note that ddd tries again up to three times\n                            --  in that case. See LiterateA.C:174\n-                           raise Process_Died;\n+\n+                           Descriptors (D).Input_Fd := Invalid_FD;\n+                           Result := Expect_Process_Died;\n+                           return;\n \n                         else\n                            --  If there is no limit to the buffer size\n \n-                           if Descriptors (J).Buffer_Size = 0 then\n+                           if Descriptors (D).Buffer_Size = 0 then\n \n                               declare\n-                                 Tmp : String_Access := Descriptors (J).Buffer;\n+                                 Tmp : String_Access := Descriptors (D).Buffer;\n \n                               begin\n                                  if Tmp /= null then\n-                                    Descriptors (J).Buffer :=\n+                                    Descriptors (D).Buffer :=\n                                       new String (1 .. Tmp'Length + N);\n-                                    Descriptors (J).Buffer (1 .. Tmp'Length) :=\n+                                    Descriptors (D).Buffer (1 .. Tmp'Length) :=\n                                       Tmp.all;\n-                                    Descriptors (J).Buffer\n+                                    Descriptors (D).Buffer\n                                       (Tmp'Length + 1 .. Tmp'Length + N) :=\n                                       Buffer (1 .. N);\n                                     Free (Tmp);\n-                                    Descriptors (J).Buffer_Index :=\n-                                      Descriptors (J).Buffer'Last;\n+                                    Descriptors (D).Buffer_Index :=\n+                                      Descriptors (D).Buffer'Last;\n \n                                  else\n-                                    Descriptors (J).Buffer :=\n+                                    Descriptors (D).Buffer :=\n                                       new String (1 .. N);\n-                                    Descriptors (J).Buffer.all :=\n+                                    Descriptors (D).Buffer.all :=\n                                       Buffer (1 .. N);\n-                                    Descriptors (J).Buffer_Index := N;\n+                                    Descriptors (D).Buffer_Index := N;\n                                  end if;\n                               end;\n \n                            else\n                               --  Add what we read to the buffer\n \n-                              if Descriptors (J).Buffer_Index + N >\n-                                Descriptors (J).Buffer_Size\n+                              if Descriptors (D).Buffer_Index + N >\n+                                Descriptors (D).Buffer_Size\n                               then\n                                  --  If the user wants to know when we have\n                                  --  read more than the buffer can contain.\n@@ -660,33 +715,33 @@ package body GNAT.Expect is\n                                  --  Keep as much as possible from the buffer,\n                                  --  and forget old characters.\n \n-                                 Descriptors (J).Buffer\n-                                   (1 .. Descriptors (J).Buffer_Size - N) :=\n-                                  Descriptors (J).Buffer\n-                                   (N - Descriptors (J).Buffer_Size +\n-                                    Descriptors (J).Buffer_Index + 1 ..\n-                                    Descriptors (J).Buffer_Index);\n-                                 Descriptors (J).Buffer_Index :=\n-                                   Descriptors (J).Buffer_Size - N;\n+                                 Descriptors (D).Buffer\n+                                   (1 .. Descriptors (D).Buffer_Size - N) :=\n+                                  Descriptors (D).Buffer\n+                                   (N - Descriptors (D).Buffer_Size +\n+                                    Descriptors (D).Buffer_Index + 1 ..\n+                                    Descriptors (D).Buffer_Index);\n+                                 Descriptors (D).Buffer_Index :=\n+                                   Descriptors (D).Buffer_Size - N;\n                               end if;\n \n                               --  Keep what we read in the buffer\n \n-                              Descriptors (J).Buffer\n-                                (Descriptors (J).Buffer_Index + 1 ..\n-                                 Descriptors (J).Buffer_Index + N) :=\n+                              Descriptors (D).Buffer\n+                                (Descriptors (D).Buffer_Index + 1 ..\n+                                 Descriptors (D).Buffer_Index + N) :=\n                                 Buffer (1 .. N);\n-                              Descriptors (J).Buffer_Index :=\n-                                Descriptors (J).Buffer_Index + N;\n+                              Descriptors (D).Buffer_Index :=\n+                                Descriptors (D).Buffer_Index + N;\n                            end if;\n \n                            --  Call each of the output filter with what we\n                            --  read.\n \n                            Call_Filters\n-                             (Descriptors (J).all, Buffer (1 .. N), Output);\n+                             (Descriptors (D).all, Buffer (1 .. N), Output);\n \n-                           Result := Expect_Match (N);\n+                           Result := Expect_Match (D);\n                            return;\n                         end if;\n                      end if;\n@@ -1062,6 +1117,13 @@ package body GNAT.Expect is\n \n          Expect_Internal (Descriptors, Result,\n                           Timeout => 0, Full_Buffer => False);\n+\n+         if Result = Expect_Internal_Error\n+           or else Result = Expect_Process_Died\n+         then\n+            raise Process_Died;\n+         end if;\n+\n          Descriptor.Last_Match_End := Descriptor.Buffer_Index;\n \n          --  Empty the buffer"}, {"sha": "f98b3b1944c9a7d8211adf91a2a3dc5ec9c0badb", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=f0d103851aea8fdb96bde64a44b8bac395ef6384", "patch": "@@ -7710,6 +7710,7 @@ package body Sem_Ch3 is\n       Set_Ekind     (D_Minal, E_In_Parameter);\n       Set_Mechanism (D_Minal, Default_Mechanism);\n       Set_Etype     (D_Minal, Etype (Discrim));\n+      Set_Scope     (D_Minal, Current_Scope);\n \n       Set_Discriminal (Discrim, D_Minal);\n       Set_Discriminal_Link (D_Minal, Discrim);\n@@ -7726,6 +7727,7 @@ package body Sem_Ch3 is\n          Set_Ekind            (CR_Disc, E_In_Parameter);\n          Set_Mechanism        (CR_Disc, Default_Mechanism);\n          Set_Etype            (CR_Disc, Etype (Discrim));\n+         Set_Scope            (CR_Disc, Current_Scope);\n          Set_Discriminal_Link (CR_Disc, Discrim);\n          Set_CR_Discriminant  (Discrim, CR_Disc);\n       end if;"}, {"sha": "fb17144b668ca89a3a8f2d2bca71c0d52d1ea08e", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=f0d103851aea8fdb96bde64a44b8bac395ef6384", "patch": "@@ -4799,6 +4799,24 @@ package body Sem_Eval is\n       Typ1   : Entity_Id := Empty;\n       Priv_E : Entity_Id;\n \n+      function Is_Mixed_Mode_Operand (Op : Node_Id) return Boolean;\n+      --  Check whether one operand is a mixed-mode operation that requires\n+      --  the presence of a fixed-point type. Given that all operands are\n+      --  universal and have been constant-folded, retrieve the original\n+      --  function call.\n+\n+      ---------------------------\n+      -- Is_Mixed_Mode_Operand --\n+      ---------------------------\n+\n+      function Is_Mixed_Mode_Operand (Op : Node_Id) return Boolean is\n+      begin\n+         return Nkind (Original_Node (Op)) = N_Function_Call\n+           and then Present (Next_Actual (First_Actual (Original_Node (Op))))\n+           and then Etype (First_Actual (Original_Node (Op))) /=\n+                    Etype (Next_Actual (First_Actual (Original_Node (Op))));\n+      end Is_Mixed_Mode_Operand;\n+\n    begin\n       if Nkind (Call) /= N_Function_Call\n         or else Nkind (Name (Call)) /= N_Expanded_Name\n@@ -4845,6 +4863,20 @@ package body Sem_Eval is\n                if No (Typ1) then\n                   Typ1 := E;\n \n+                  --  Before emitting an error, check for the presence of a\n+                  --  mixed-mode operation that specifies a fixed point type.\n+\n+               elsif Is_Relational\n+                 and then\n+                   (Is_Mixed_Mode_Operand (Left_Opnd (N))\n+                    or else Is_Mixed_Mode_Operand (Right_Opnd (N)))\n+                 and then Is_Fixed_Point_Type (E) /= Is_Fixed_Point_Type (Typ1)\n+\n+               then\n+                  if Is_Fixed_Point_Type (E) then\n+                     Typ1 := E;\n+                  end if;\n+\n                else\n                   --  More than one type of the proper class declared in P\n "}, {"sha": "fcf5a2c914a2827f87fb9c791183079fc1f7cc11", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=f0d103851aea8fdb96bde64a44b8bac395ef6384", "patch": "@@ -9567,6 +9567,7 @@ package body Sem_Res is\n             It  : Interp;\n             It1 : Interp;\n             N1  : Entity_Id;\n+            T1  : Entity_Id;\n \n          begin\n             --  Remove procedure calls, which syntactically cannot appear in\n@@ -9623,16 +9624,30 @@ package body Sem_Res is\n \n             if Present (It.Typ) then\n                N1  := It1.Nam;\n+               T1  := It1.Typ;\n                It1 :=  Disambiguate (Operand, I1, I, Any_Type);\n \n                if It1 = No_Interp then\n                   Error_Msg_N (\"ambiguous operand in conversion\", Operand);\n \n-                  Error_Msg_Sloc := Sloc (It.Nam);\n+                  --  If the interpretation involves a standard operator, use\n+                  --  the location of the type, which may be user-defined.\n+\n+                  if Sloc (It.Nam) = Standard_Location then\n+                     Error_Msg_Sloc := Sloc (It.Typ);\n+                  else\n+                     Error_Msg_Sloc := Sloc (It.Nam);\n+                  end if;\n+\n                   Error_Msg_N -- CODEFIX\n                     (\"\\\\possible interpretation#!\", Operand);\n \n-                  Error_Msg_Sloc := Sloc (N1);\n+                  if Sloc (N1) = Standard_Location then\n+                     Error_Msg_Sloc := Sloc (T1);\n+                  else\n+                     Error_Msg_Sloc := Sloc (N1);\n+                  end if;\n+\n                   Error_Msg_N -- CODEFIX\n                     (\"\\\\possible interpretation#!\", Operand);\n "}, {"sha": "04f8341f2ad299c10dd49e5f5c11917b5e6c4429", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0d103851aea8fdb96bde64a44b8bac395ef6384/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=f0d103851aea8fdb96bde64a44b8bac395ef6384", "patch": "@@ -3082,7 +3082,6 @@ package body Sem_Util is\n       Disc := First_Discriminant (Tsk);\n       while Present (Disc) loop\n          if Chars (Disc) = Chars (Spec_Discriminant) then\n-            Set_Scope (Discriminal (Disc), Tsk);\n             return Discriminal (Disc);\n          end if;\n "}]}