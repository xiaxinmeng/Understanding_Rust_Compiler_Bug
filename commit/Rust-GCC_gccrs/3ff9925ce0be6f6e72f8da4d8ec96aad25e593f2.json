{"sha": "3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZmOTkyNWNlMGJlNmY2ZTcyZjhkYTRkOGVjOTZhYWQyNWU1OTNmMg==", "commit": {"author": {"name": "Anthony Green", "email": "green@cygnus.com", "date": "2000-02-26T05:12:27Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2000-02-26T05:12:27Z"}, "message": "expr.c (build_class_init): Mark the decl to be ignored by check_init.\n\n2000-02-25  Anthony Green  <green@cygnus.com>\n\n\t* expr.c (build_class_init): Mark the decl to be ignored by\n\tcheck_init.\n\t* java-tree.h (DECL_BIT_INDEX): Move definition from check-init.c\n\t* check-init.c: Move DECL_BIT_INDEX to java-tree.h\n\t* class.c (init_test_hash_newfunc): New function.\n\t(decl_hash): New function.\n\t(decl_compare): New function.\n\t* decl.c (emit_init_test_initialization): New function.\n\t(complete_start_java_method): Traverse the init test hashtable,\n\tcalling emit_init_test_initialization.\n\t(always_initialize_class_p): Define.\n\t* expr.c (build_class_init): Use initialization tests when\n\temitting class initialization code.\n\t(always_initialize_class_p): Declare.\n\t* jcf-parse.c (parse_class_file): Set always_initialize_class_p to\n\t1.\n\t* java-tree.h: Include hash.h.\n\t(DECL_FUNCTION_INIT_TEST_TABLE): Define.\n\t(struct lang_decl): Add init_test_table field.\n\t(init_test_hash_entry): Define.\n\nFrom-SVN: r32166", "tree": {"sha": "cfe8d050a2c658d4be3700810c5e25cbdfe9806d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfe8d050a2c658d4be3700810c5e25cbdfe9806d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/comments", "author": null, "committer": null, "parents": [{"sha": "985dae7cdd18b543af8396c61c5332d685e47745", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/985dae7cdd18b543af8396c61c5332d685e47745", "html_url": "https://github.com/Rust-GCC/gccrs/commit/985dae7cdd18b543af8396c61c5332d685e47745"}], "stats": {"total": 587, "additions": 329, "deletions": 258}, "files": [{"sha": "9e9e877ba66c8a16abf87d33ecd3a9921bab40a3", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -1,3 +1,26 @@\n+2000-02-25  Anthony Green  <green@cygnus.com>\n+\n+\t* expr.c (build_class_init): Mark the decl to be ignored by\n+\tcheck_init.\n+\t* java-tree.h (DECL_BIT_INDEX): Move definition from check-init.c\n+\t* check-init.c: Move DECL_BIT_INDEX to java-tree.h\n+\t* class.c (init_test_hash_newfunc): New function.\n+\t(decl_hash): New function.\n+\t(decl_compare): New function.\n+\t* decl.c (emit_init_test_initialization): New function.\n+\t(complete_start_java_method): Traverse the init test hashtable,\n+\tcalling emit_init_test_initialization.\n+\t(always_initialize_class_p): Define.\n+\t* expr.c (build_class_init): Use initialization tests when\n+\temitting class initialization code.\n+\t(always_initialize_class_p): Declare.\n+\t* jcf-parse.c (parse_class_file): Set always_initialize_class_p to\n+\t1.\n+\t* java-tree.h: Include hash.h.\n+\t(DECL_FUNCTION_INIT_TEST_TABLE): Define.\n+\t(struct lang_decl): Add init_test_table field.\n+\t(init_test_hash_entry): Define.\n+\n Fri Feb 25 18:41:31 2000  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* gjavah.c (main): Avoid using `argi' to report unimplemented"}, {"sha": "63ee697f02947fbec10a48c3a93ab5eb165f8cfa", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -39,11 +39,6 @@ typedef unsigned int word;\n /* Pointer to a bitstring. */\n typedef word *words;\n \n-/* For a local VAR_DECL, holds the index into a words bitstring that\n-   specifies if this decl is definitively assigned.\n-   A DECL_BIT_INDEX of -1 means we no longer care. */\n-#define DECL_BIT_INDEX(DECL) DECL_FIELD_SIZE(DECL)\n-\n /* Number of locals variables currently active. */\n int num_current_locals = 0;\n "}, {"sha": "af56f740ebff6019456bf0036aca14d65030c1c9", "filename": "gcc/java/class.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -389,7 +389,7 @@ set_super_info (access_flags, this_class, super_class, interfaces_count)\n       CLASS_HAS_SUPER (this_class) = 1;\n     }\n   pop_obstacks ();\n-  \n+\n   if (access_flags & ACC_PUBLIC)    CLASS_PUBLIC (class_decl) = 1;\n   if (access_flags & ACC_FINAL)     CLASS_FINAL (class_decl) = 1;\n   if (access_flags & ACC_SUPER)     CLASS_SUPER (class_decl) = 1;\n@@ -548,6 +548,40 @@ build_java_method_type (fntype, this_class, access_flags)\n   return build_method_type (CLASS_TO_HANDLE_TYPE (this_class), fntype);\n }\n \n+static struct hash_entry *\n+init_test_hash_newfunc (entry, table, string)\n+     struct hash_entry *entry;\n+     struct hash_table *table;\n+     hash_table_key string ATTRIBUTE_UNUSED;\n+{\n+  struct init_test_hash_entry *ret = (struct init_test_hash_entry *) entry;\n+  if (ret == NULL)\n+    {\n+      ret = ((struct init_test_hash_entry *)\n+\t     hash_allocate (table, sizeof (struct init_test_hash_entry)));\n+      if (ret == NULL)\n+\treturn NULL;\n+    }\n+  ret->init_test_decl = 0;\n+  return (struct hash_entry *) ret;\n+}\n+\n+static unsigned long\n+decl_hash (k)\n+     hash_table_key k;\n+{\n+  return (long) k;\n+}\n+\n+static boolean\n+decl_compare (k1, k2)\n+     hash_table_key k1;\n+     hash_table_key k2;\n+{\n+  return ((char*) k1 == (char*) k2);\n+}\n+\n+\n tree\n add_method_1 (handle_class, access_flags, name, function_type)\n      tree handle_class;\n@@ -568,6 +602,11 @@ add_method_1 (handle_class, access_flags, name, function_type)\n     = (struct lang_decl *) permalloc (sizeof (struct lang_decl));\n   bzero ((PTR) DECL_LANG_SPECIFIC (fndecl), sizeof (struct lang_decl));\n \n+  /* Initialize the static initializer test table.  */\n+  hash_table_init (&DECL_FUNCTION_INIT_TEST_TABLE (fndecl),\n+\t\t   init_test_hash_newfunc, decl_hash,\n+\t\t   decl_compare);\n+\n   TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n   TYPE_METHODS (handle_class) = fndecl;\n   pop_obstacks ();"}, {"sha": "46d322b62164c18ab374468a617a9e24303a6221", "filename": "gcc/java/decl.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -48,6 +48,10 @@ static tree lookup_name_current_level PARAMS ((tree));\n static tree push_promoted_type PARAMS ((const char *, tree));\n static struct binding_level *make_binding_level PARAMS ((void));\n \n+/* Set to non-zero value in order to emit class initilization code\n+   before static field references.  */\n+extern int always_initialize_class_p;\n+\n #ifndef INT_TYPE_SIZE\n #define INT_TYPE_SIZE BITS_PER_WORD\n #endif\n@@ -1623,6 +1627,24 @@ build_result_decl (fndecl)\n   return (DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, restype));\n }\n \n+\n+/* Called for every element in DECL_FUNCTION_INIT_TEST_TABLE in order\n+   to emit initialization code for each test flag.  */\n+   \n+static boolean\n+emit_init_test_initialization (entry, key)\n+  struct hash_entry *entry;\n+  hash_table_key key;\n+{\n+  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n+  expand_decl (ite->init_test_decl);\n+\n+  expand_expr_stmt (build (MODIFY_EXPR, boolean_type_node, \n+\t\t\t   ite->init_test_decl, boolean_false_node));\n+\n+  return true;\n+}\n+\n void\n complete_start_java_method (fndecl)\n   tree fndecl;\n@@ -1634,6 +1656,11 @@ complete_start_java_method (fndecl)\n \n       /* Set up parameters and prepare for return, for the function.  */\n       expand_function_start (fndecl, 0);\n+\n+      /* Emit initialization code for test flags.  */\n+      if (! always_initialize_class_p)\n+\thash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (fndecl),\n+\t\t       emit_init_test_initialization, 0);\n     }\n \n   /* Allocate further tree nodes temporarily during compilation"}, {"sha": "41a1d3d99b109aa83dcfcc41d33a3f47e147e0eb", "filename": "gcc/java/expr.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -83,6 +83,10 @@ static tree case_identity PARAMS ((tree, tree));\n static tree operand_type[59];\n extern struct obstack permanent_obstack;\n \n+/* Set to non-zero value in order to emit class initilization code\n+   before static field references.  */\n+int always_initialize_class_p;\n+\n void\n init_expr_processing()\n {\n@@ -1490,14 +1494,48 @@ tree\n build_class_init (clas, expr)\n      tree clas, expr;\n {\n-  tree init;\n+  tree init, call;\n+  struct init_test_hash_entry *ite;\n   if (inherits_from_p (current_class, clas))\n     return expr;\n-  init = build (CALL_EXPR, void_type_node,\n-\t\tbuild_address_of (soft_initclass_node),\n-\t\tbuild_tree_list (NULL_TREE, build_class_ref (clas)),\n-\t\tNULL_TREE);\n-  TREE_SIDE_EFFECTS (init) = 1;\n+\n+  if (always_initialize_class_p)\n+    {\n+      init = build (CALL_EXPR, void_type_node,\n+\t\t    build_address_of (soft_initclass_node),\n+\t\t    build_tree_list (NULL_TREE, build_class_ref (clas)),\n+\t\t    NULL_TREE);\n+      TREE_SIDE_EFFECTS (init) = 1;\n+    }\n+  else\n+    {\n+      ite = (struct init_test_hash_entry *)\n+\thash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n+\t\t     (const hash_table_key) clas,\n+\t\t     TRUE, NULL);\n+      \n+      if (ite->init_test_decl == 0)\n+\tite->init_test_decl = build_decl (VAR_DECL, NULL_TREE, \n+\t\t\t\t\t  boolean_type_node);\n+      /* Tell the check-init code to ignore this decl.  */\n+      DECL_BIT_INDEX(ite->init_test_decl) = -1;\n+\n+      init = build (CALL_EXPR, void_type_node,\n+\t\t    build_address_of (soft_initclass_node),\n+\t\t    build_tree_list (NULL_TREE, build_class_ref (clas)),\n+\t\t    NULL_TREE);\n+      TREE_SIDE_EFFECTS (init) = 1;\n+      call = build (COMPOUND_EXPR, TREE_TYPE (expr), init, \n+\t\t    build (MODIFY_EXPR, boolean_type_node,\n+\t\t\t   ite->init_test_decl, boolean_true_node));\n+      TREE_SIDE_EFFECTS (call) = 1;\n+      init = build (COND_EXPR, void_type_node,\n+\t\t    build (EQ_EXPR, boolean_type_node, \n+\t\t\t   ite->init_test_decl, boolean_false_node),\n+\t\t    call, integer_zero_node);\n+      TREE_SIDE_EFFECTS (init) = 1;\n+    }\n+\n   if (expr != NULL_TREE)\n     {\n       expr = build (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);"}, {"sha": "536fdc1868239f0d7c5edc51c3ef27cc64f3e0b0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -25,6 +25,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n /* Hacked by Per Bothner <bothner@cygnus.com> February 1996. */\n \n+#include \"hash.h\"\n+\n /* Java language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n enum java_tree_code {\n@@ -368,6 +370,12 @@ struct lang_identifier\n /* How specific the function is (for method selection - Java source\n    code front-end */\n #define DECL_SPECIFIC_COUNT(DECL) DECL_ARG_SLOT_COUNT(DECL)\n+/* For each function decl, init_test_table contains a hash table whose\n+   entries are keyed on class names, and whose values are local\n+   boolean decls.  The variables are intended to be TRUE when the\n+   class has been initialized in this function, and FALSE otherwise.  */\n+#define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->init_test_table)\n \n /* In a LABEL_DECL, a TREE_VEC that saves the type_map at that point. */\n #define LABEL_TYPE_STATE(NODE) (DECL_INITIAL (NODE))\n@@ -429,6 +437,11 @@ struct lang_identifier\n #define DECL_LOCAL_SLOT_CHAIN(NODE) \\\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->slot_chain)\n \n+/* For a local VAR_DECL, holds the index into a words bitstring that\n+   specifies if this decl is definitively assigned.\n+   A DECL_BIT_INDEX of -1 means we no longer care. */\n+#define DECL_BIT_INDEX(DECL) DECL_FIELD_SIZE(DECL)\n+\n /* DECL_LANG_SPECIFIC for FUNCTION_DECLs. */\n struct lang_decl\n {\n@@ -443,8 +456,18 @@ struct lang_decl\n   tree function_decl_body;\t/* Hold all function's statements */\n   tree called_constructor;\t/* When decl is a constructor, the\n \t\t\t\t   list of other constructor it calls. */\n+  struct hash_table init_test_table;\n+                                /* Class initialization test variables.  */\n+};\n+\n+/* init_test_table hash table entry structure.  */\n+struct init_test_hash_entry\n+{\n+  struct hash_entry root;\n+  tree init_test_decl;\n };\n \n+\n /* DECL_LANG_SPECIFIC for VAR_DECL and PARM_DECL. */\n struct lang_decl_var\n {"}, {"sha": "770cec6bc9b3d8148b7d9e384484e237a1c23c80", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -57,6 +57,10 @@ extern struct obstack *saveable_obstack;\n extern struct obstack temporary_obstack;\n extern struct obstack permanent_obstack;\n \n+/* Set to non-zero value in order to emit class initilization code\n+   before static field references.  */\n+extern int always_initialize_class_p;\n+\n /* The class we are currently processing. */\n tree current_class = NULL_TREE;\n \n@@ -646,6 +650,10 @@ parse_class_file ()\n   debug_start_source_file (input_filename);\n   init_outgoing_cpool ();\n \n+  /* Currently we always have to emit calls to _Jv_InitClass when\n+     compiling from class files.  */\n+  always_initialize_class_p = 1;\n+\n   for ( method = TYPE_METHODS (CLASS_TO_HANDLE_TYPE (current_class));\n \tmethod != NULL_TREE; method = TREE_CHAIN (method))\n     {"}, {"sha": "f8b97b8e4e289224b5249a22e379a2beb5b17907", "filename": "gcc/java/parse.c", "status": "modified", "additions": 164, "deletions": 246, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=3ff9925ce0be6f6e72f8da4d8ec96aad25e593f2", "patch": "@@ -1,6 +1,7 @@\n \n /*  A Bison parser, made from ./parse.y\n-    by GNU Bison version 1.28  */\n+ by  GNU Bison version 1.25\n+  */\n \n #define YYBISON 1  /* Identify Bison output.  */\n \n@@ -11,113 +12,113 @@\n #define yychar java_char\n #define yydebug java_debug\n #define yynerrs java_nerrs\n-#define\tPLUS_TK\t257\n-#define\tMINUS_TK\t258\n-#define\tMULT_TK\t259\n-#define\tDIV_TK\t260\n-#define\tREM_TK\t261\n-#define\tLS_TK\t262\n-#define\tSRS_TK\t263\n-#define\tZRS_TK\t264\n-#define\tAND_TK\t265\n-#define\tXOR_TK\t266\n-#define\tOR_TK\t267\n-#define\tBOOL_AND_TK\t268\n-#define\tBOOL_OR_TK\t269\n-#define\tEQ_TK\t270\n-#define\tNEQ_TK\t271\n-#define\tGT_TK\t272\n-#define\tGTE_TK\t273\n-#define\tLT_TK\t274\n-#define\tLTE_TK\t275\n-#define\tPLUS_ASSIGN_TK\t276\n-#define\tMINUS_ASSIGN_TK\t277\n-#define\tMULT_ASSIGN_TK\t278\n-#define\tDIV_ASSIGN_TK\t279\n-#define\tREM_ASSIGN_TK\t280\n-#define\tLS_ASSIGN_TK\t281\n-#define\tSRS_ASSIGN_TK\t282\n-#define\tZRS_ASSIGN_TK\t283\n-#define\tAND_ASSIGN_TK\t284\n-#define\tXOR_ASSIGN_TK\t285\n-#define\tOR_ASSIGN_TK\t286\n-#define\tPUBLIC_TK\t287\n-#define\tPRIVATE_TK\t288\n-#define\tPROTECTED_TK\t289\n-#define\tSTATIC_TK\t290\n-#define\tFINAL_TK\t291\n-#define\tSYNCHRONIZED_TK\t292\n-#define\tVOLATILE_TK\t293\n-#define\tTRANSIENT_TK\t294\n-#define\tNATIVE_TK\t295\n-#define\tPAD_TK\t296\n-#define\tABSTRACT_TK\t297\n-#define\tMODIFIER_TK\t298\n-#define\tDECR_TK\t299\n-#define\tINCR_TK\t300\n-#define\tDEFAULT_TK\t301\n-#define\tIF_TK\t302\n-#define\tTHROW_TK\t303\n-#define\tBOOLEAN_TK\t304\n-#define\tDO_TK\t305\n-#define\tIMPLEMENTS_TK\t306\n-#define\tTHROWS_TK\t307\n-#define\tBREAK_TK\t308\n-#define\tIMPORT_TK\t309\n-#define\tELSE_TK\t310\n-#define\tINSTANCEOF_TK\t311\n-#define\tRETURN_TK\t312\n-#define\tVOID_TK\t313\n-#define\tCATCH_TK\t314\n-#define\tINTERFACE_TK\t315\n-#define\tCASE_TK\t316\n-#define\tEXTENDS_TK\t317\n-#define\tFINALLY_TK\t318\n-#define\tSUPER_TK\t319\n-#define\tWHILE_TK\t320\n-#define\tCLASS_TK\t321\n-#define\tSWITCH_TK\t322\n-#define\tCONST_TK\t323\n-#define\tTRY_TK\t324\n-#define\tFOR_TK\t325\n-#define\tNEW_TK\t326\n-#define\tCONTINUE_TK\t327\n-#define\tGOTO_TK\t328\n-#define\tPACKAGE_TK\t329\n-#define\tTHIS_TK\t330\n-#define\tBYTE_TK\t331\n-#define\tSHORT_TK\t332\n-#define\tINT_TK\t333\n-#define\tLONG_TK\t334\n-#define\tCHAR_TK\t335\n-#define\tINTEGRAL_TK\t336\n-#define\tFLOAT_TK\t337\n-#define\tDOUBLE_TK\t338\n-#define\tFP_TK\t339\n-#define\tID_TK\t340\n-#define\tREL_QM_TK\t341\n-#define\tREL_CL_TK\t342\n-#define\tNOT_TK\t343\n-#define\tNEG_TK\t344\n-#define\tASSIGN_ANY_TK\t345\n-#define\tASSIGN_TK\t346\n-#define\tOP_TK\t347\n-#define\tCP_TK\t348\n-#define\tOCB_TK\t349\n-#define\tCCB_TK\t350\n-#define\tOSB_TK\t351\n-#define\tCSB_TK\t352\n-#define\tSC_TK\t353\n-#define\tC_TK\t354\n-#define\tDOT_TK\t355\n-#define\tSTRING_LIT_TK\t356\n-#define\tCHAR_LIT_TK\t357\n-#define\tINT_LIT_TK\t358\n-#define\tFP_LIT_TK\t359\n-#define\tTRUE_TK\t360\n-#define\tFALSE_TK\t361\n-#define\tBOOL_LIT_TK\t362\n-#define\tNULL_TK\t363\n+#define\tPLUS_TK\t258\n+#define\tMINUS_TK\t259\n+#define\tMULT_TK\t260\n+#define\tDIV_TK\t261\n+#define\tREM_TK\t262\n+#define\tLS_TK\t263\n+#define\tSRS_TK\t264\n+#define\tZRS_TK\t265\n+#define\tAND_TK\t266\n+#define\tXOR_TK\t267\n+#define\tOR_TK\t268\n+#define\tBOOL_AND_TK\t269\n+#define\tBOOL_OR_TK\t270\n+#define\tEQ_TK\t271\n+#define\tNEQ_TK\t272\n+#define\tGT_TK\t273\n+#define\tGTE_TK\t274\n+#define\tLT_TK\t275\n+#define\tLTE_TK\t276\n+#define\tPLUS_ASSIGN_TK\t277\n+#define\tMINUS_ASSIGN_TK\t278\n+#define\tMULT_ASSIGN_TK\t279\n+#define\tDIV_ASSIGN_TK\t280\n+#define\tREM_ASSIGN_TK\t281\n+#define\tLS_ASSIGN_TK\t282\n+#define\tSRS_ASSIGN_TK\t283\n+#define\tZRS_ASSIGN_TK\t284\n+#define\tAND_ASSIGN_TK\t285\n+#define\tXOR_ASSIGN_TK\t286\n+#define\tOR_ASSIGN_TK\t287\n+#define\tPUBLIC_TK\t288\n+#define\tPRIVATE_TK\t289\n+#define\tPROTECTED_TK\t290\n+#define\tSTATIC_TK\t291\n+#define\tFINAL_TK\t292\n+#define\tSYNCHRONIZED_TK\t293\n+#define\tVOLATILE_TK\t294\n+#define\tTRANSIENT_TK\t295\n+#define\tNATIVE_TK\t296\n+#define\tPAD_TK\t297\n+#define\tABSTRACT_TK\t298\n+#define\tMODIFIER_TK\t299\n+#define\tDECR_TK\t300\n+#define\tINCR_TK\t301\n+#define\tDEFAULT_TK\t302\n+#define\tIF_TK\t303\n+#define\tTHROW_TK\t304\n+#define\tBOOLEAN_TK\t305\n+#define\tDO_TK\t306\n+#define\tIMPLEMENTS_TK\t307\n+#define\tTHROWS_TK\t308\n+#define\tBREAK_TK\t309\n+#define\tIMPORT_TK\t310\n+#define\tELSE_TK\t311\n+#define\tINSTANCEOF_TK\t312\n+#define\tRETURN_TK\t313\n+#define\tVOID_TK\t314\n+#define\tCATCH_TK\t315\n+#define\tINTERFACE_TK\t316\n+#define\tCASE_TK\t317\n+#define\tEXTENDS_TK\t318\n+#define\tFINALLY_TK\t319\n+#define\tSUPER_TK\t320\n+#define\tWHILE_TK\t321\n+#define\tCLASS_TK\t322\n+#define\tSWITCH_TK\t323\n+#define\tCONST_TK\t324\n+#define\tTRY_TK\t325\n+#define\tFOR_TK\t326\n+#define\tNEW_TK\t327\n+#define\tCONTINUE_TK\t328\n+#define\tGOTO_TK\t329\n+#define\tPACKAGE_TK\t330\n+#define\tTHIS_TK\t331\n+#define\tBYTE_TK\t332\n+#define\tSHORT_TK\t333\n+#define\tINT_TK\t334\n+#define\tLONG_TK\t335\n+#define\tCHAR_TK\t336\n+#define\tINTEGRAL_TK\t337\n+#define\tFLOAT_TK\t338\n+#define\tDOUBLE_TK\t339\n+#define\tFP_TK\t340\n+#define\tID_TK\t341\n+#define\tREL_QM_TK\t342\n+#define\tREL_CL_TK\t343\n+#define\tNOT_TK\t344\n+#define\tNEG_TK\t345\n+#define\tASSIGN_ANY_TK\t346\n+#define\tASSIGN_TK\t347\n+#define\tOP_TK\t348\n+#define\tCP_TK\t349\n+#define\tOCB_TK\t350\n+#define\tCCB_TK\t351\n+#define\tOSB_TK\t352\n+#define\tCSB_TK\t353\n+#define\tSC_TK\t354\n+#define\tC_TK\t355\n+#define\tDOT_TK\t356\n+#define\tSTRING_LIT_TK\t357\n+#define\tCHAR_LIT_TK\t358\n+#define\tINT_LIT_TK\t359\n+#define\tFP_LIT_TK\t360\n+#define\tTRUE_TK\t361\n+#define\tFALSE_TK\t362\n+#define\tBOOL_LIT_TK\t363\n+#define\tNULL_TK\t364\n \n #line 48 \"./parse.y\"\n \n@@ -448,7 +449,7 @@ typedef union {\n #define\tYYFLAG\t\t-32768\n #define\tYYNTBASE\t110\n \n-#define YYTRANSLATE(x) ((unsigned)(x) <= 363 ? yytranslate[x] : 267)\n+#define YYTRANSLATE(x) ((unsigned)(x) <= 364 ? yytranslate[x] : 267)\n \n static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n@@ -476,18 +477,18 @@ static const char yytranslate[] = {     0,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n      2,     2,     2,     2,     2,     2,     2,     2,     2,     2,\n-     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,\n-     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,\n-    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,\n-    27,    28,    29,    30,    31,    32,    33,    34,    35,    36,\n-    37,    38,    39,    40,    41,    42,    43,    44,    45,    46,\n-    47,    48,    49,    50,    51,    52,    53,    54,    55,    56,\n-    57,    58,    59,    60,    61,    62,    63,    64,    65,    66,\n-    67,    68,    69,    70,    71,    72,    73,    74,    75,    76,\n-    77,    78,    79,    80,    81,    82,    83,    84,    85,    86,\n-    87,    88,    89,    90,    91,    92,    93,    94,    95,    96,\n-    97,    98,    99,   100,   101,   102,   103,   104,   105,   106,\n-   107,   108,   109\n+     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,\n+     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,\n+    16,    17,    18,    19,    20,    21,    22,    23,    24,    25,\n+    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,\n+    36,    37,    38,    39,    40,    41,    42,    43,    44,    45,\n+    46,    47,    48,    49,    50,    51,    52,    53,    54,    55,\n+    56,    57,    58,    59,    60,    61,    62,    63,    64,    65,\n+    66,    67,    68,    69,    70,    71,    72,    73,    74,    75,\n+    76,    77,    78,    79,    80,    81,    82,    83,    84,    85,\n+    86,    87,    88,    89,    90,    91,    92,    93,    94,    95,\n+    96,    97,    98,    99,   100,   101,   102,   103,   104,   105,\n+   106,   107,   108,   109\n };\n \n #if YYDEBUG != 0\n@@ -2291,8 +2292,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/lib/bison.simple\"\n-/* This file comes from bison-1.28.  */\n+#line 3 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2309,66 +2309,46 @@ static const short yycheck[] = {     3,\n \n    You should have received a copy of the GNU General Public License\n    along with this program; if not, write to the Free Software\n-   Foundation, Inc., 59 Temple Place - Suite 330,\n-   Boston, MA 02111-1307, USA.  */\n+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* As a special exception, when this file is copied by Bison into a\n    Bison output file, you may use that output file without restriction.\n    This special exception was added by the Free Software Foundation\n    in version 1.24 of Bison.  */\n \n-/* This is the parser code that is written into each bison parser\n-  when the %semantic_parser declaration is not specified in the grammar.\n-  It was written by Richard Stallman by simplifying the hairy parser\n-  used when %semantic_parser is specified.  */\n-\n-#ifndef YYSTACK_USE_ALLOCA\n-#ifdef alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* alloca not defined */\n+#ifndef alloca\n #ifdef __GNUC__\n-#define YYSTACK_USE_ALLOCA\n #define alloca __builtin_alloca\n #else /* not GNU C.  */\n-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))\n-#define YYSTACK_USE_ALLOCA\n+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)\n #include <alloca.h>\n #else /* not sparc */\n-/* We think this test detects Watcom and Microsoft C.  */\n-/* This used to test MSDOS, but that is a bad idea\n-   since that symbol is in the user namespace.  */\n-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)\n-#if 0 /* No need for malloc.h, which pollutes the namespace;\n-\t instead, just don't use alloca.  */\n+#if defined (MSDOS) && !defined (__TURBOC__)\n #include <malloc.h>\n-#endif\n #else /* not MSDOS, or __TURBOC__ */\n #if defined(_AIX)\n-/* I don't know what this was needed for, but it pollutes the namespace.\n-   So I turned it off.   rms, 2 May 1997.  */\n-/* #include <malloc.h>  */\n+#include <malloc.h>\n  #pragma alloca\n-#define YYSTACK_USE_ALLOCA\n-#else /* not MSDOS, or __TURBOC__, or _AIX */\n-#if 0\n-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,\n-\t\t and on HPUX 10.  Eventually we can turn this on.  */\n-#define YYSTACK_USE_ALLOCA\n-#define alloca __builtin_alloca\n+#else /* not MSDOS, __TURBOC__, or _AIX */\n+#ifdef __hpux\n+#ifdef __cplusplus\n+extern \"C\" {\n+void *alloca (unsigned int);\n+};\n+#else /* not __cplusplus */\n+void *alloca ();\n+#endif /* not __cplusplus */\n #endif /* __hpux */\n-#endif\n #endif /* not _AIX */\n #endif /* not MSDOS, or __TURBOC__ */\n-#endif /* not sparc */\n-#endif /* not GNU C */\n-#endif /* alloca not defined */\n-#endif /* YYSTACK_USE_ALLOCA not defined */\n+#endif /* not sparc.  */\n+#endif /* not GNU C.  */\n+#endif /* alloca not defined.  */\n \n-#ifdef YYSTACK_USE_ALLOCA\n-#define YYSTACK_ALLOC alloca\n-#else\n-#define YYSTACK_ALLOC malloc\n-#endif\n+/* This is the parser code that is written into each bison parser\n+  when the %semantic_parser declaration is not specified in the grammar.\n+  It was written by Richard Stallman by simplifying the hairy parser\n+  used when %semantic_parser is specified.  */\n \n /* Note: there must be only one dollar sign in this file.\n    It is replaced by the list of actions, each action\n@@ -2378,8 +2358,8 @@ static const short yycheck[] = {     3,\n #define yyclearin\t(yychar = YYEMPTY)\n #define YYEMPTY\t\t-2\n #define YYEOF\t\t0\n-#define YYACCEPT\tgoto yyacceptlab\n-#define YYABORT \tgoto yyabortlab\n+#define YYACCEPT\treturn(0)\n+#define YYABORT \treturn(1)\n #define YYERROR\t\tgoto yyerrlab1\n /* Like YYERROR except do call yyerror.\n    This remains here temporarily to ease the\n@@ -2460,12 +2440,12 @@ int yydebug;\t\t\t/*  nonzero means print parse trace\t*/\n #ifndef YYMAXDEPTH\n #define YYMAXDEPTH 10000\n #endif\n-\f\n-/* Define __yy_memcpy.  Note that the size argument\n-   should be passed with type unsigned int, because that is what the non-GCC\n-   definitions require.  With GCC, __builtin_memcpy takes an arg\n-   of type size_t, but it can handle unsigned int.  */\n \n+/* Prevent warning if -Wstrict-prototypes.  */\n+#ifdef __GNUC__\n+int yyparse (void);\n+#endif\n+\f\n #if __GNUC__ > 1\t\t/* GNU C and GNU C++ define this.  */\n #define __yy_memcpy(TO,FROM,COUNT)\t__builtin_memcpy(TO,FROM,COUNT)\n #else\t\t\t\t/* not GNU C or C++ */\n@@ -2477,7 +2457,7 @@ static void\n __yy_memcpy (to, from, count)\n      char *to;\n      char *from;\n-     unsigned int count;\n+     int count;\n {\n   register char *f = from;\n   register char *t = to;\n@@ -2492,10 +2472,10 @@ __yy_memcpy (to, from, count)\n /* This is the most reliable way to avoid incompatibilities\n    in available built-in functions on various systems.  */\n static void\n-__yy_memcpy (char *to, char *from, unsigned int count)\n+__yy_memcpy (char *to, char *from, int count)\n {\n-  register char *t = to;\n   register char *f = from;\n+  register char *t = to;\n   register int i = count;\n \n   while (i-- > 0)\n@@ -2505,7 +2485,7 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #endif\n #endif\n \f\n-#line 217 \"/usr/lib/bison.simple\"\n+#line 196 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2526,15 +2506,6 @@ __yy_memcpy (char *to, char *from, unsigned int count)\n #define YYPARSE_PARAM_DECL\n #endif /* not YYPARSE_PARAM */\n \n-/* Prevent warning if -Wstrict-prototypes.  */\n-#ifdef __GNUC__\n-#ifdef YYPARSE_PARAM\n-int yyparse (void *);\n-#else\n-int yyparse (void);\n-#endif\n-#endif\n-\n int\n yyparse(YYPARSE_PARAM_ARG)\n      YYPARSE_PARAM_DECL\n@@ -2563,7 +2534,6 @@ yyparse(YYPARSE_PARAM_ARG)\n #endif\n \n   int yystacksize = YYINITDEPTH;\n-  int yyfree_stacks = 0;\n \n #ifdef YYPURE\n   int yychar;\n@@ -2648,32 +2618,18 @@ yyparse(YYPARSE_PARAM_ARG)\n       if (yystacksize >= YYMAXDEPTH)\n \t{\n \t  yyerror(\"parser stack overflow\");\n-\t  if (yyfree_stacks)\n-\t    {\n-\t      free (yyss);\n-\t      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-\t      free (yyls);\n-#endif\n-\t    }\n \t  return 2;\n \t}\n       yystacksize *= 2;\n       if (yystacksize > YYMAXDEPTH)\n \tyystacksize = YYMAXDEPTH;\n-#ifndef YYSTACK_USE_ALLOCA\n-      yyfree_stacks = 1;\n-#endif\n-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));\n-      __yy_memcpy ((char *)yyss, (char *)yyss1,\n-\t\t   size * (unsigned int) sizeof (*yyssp));\n-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));\n-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,\n-\t\t   size * (unsigned int) sizeof (*yyvsp));\n+      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));\n+      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));\n+      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));\n+      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));\n #ifdef YYLSP_NEEDED\n-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));\n-      __yy_memcpy ((char *)yyls, (char *)yyls1,\n-\t\t   size * (unsigned int) sizeof (*yylsp));\n+      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));\n+      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));\n #endif\n #endif /* no yyoverflow */\n \n@@ -4841,7 +4797,7 @@ case 496:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 543 \"/usr/lib/bison.simple\"\n+#line 498 \"/usr/cygnus/gnupro-98r1/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -5036,30 +4992,6 @@ case 496:\n \n   yystate = yyn;\n   goto yynewstate;\n-\n- yyacceptlab:\n-  /* YYACCEPT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 0;\n-\n- yyabortlab:\n-  /* YYABORT comes here.  */\n-  if (yyfree_stacks)\n-    {\n-      free (yyss);\n-      free (yyvs);\n-#ifdef YYLSP_NEEDED\n-      free (yyls);\n-#endif\n-    }\n-  return 1;\n }\n #line 2375 \"./parse.y\"\n \n@@ -9222,7 +9154,7 @@ resolve_expression_name (id, orig)\n       qualify_ambiguous_name (id);\n       /* 15.10.1 Field Access Using a Primary and/or Expression Name */\n       /* 15.10.2: Accessing Superclass Members using super */\n-      return resolve_field_access (id, NULL, NULL);\n+      return resolve_field_access (id, orig, NULL);\n     }\n \n   /* We've got an error here */\n@@ -9295,21 +9227,7 @@ resolve_field_access (qual_wfl, field_decl, field_type)\n \treturn error_mark_node;\n       if (is_static && !static_final_found \n \t  && !flag_emit_class_files && !flag_emit_xref)\n-\t{\n-\t  field_ref = build_class_init (type_found, field_ref);\n-\t  /* If the static field was identified by an expression that\n-\t     needs to be generated, make the field access a compound\n-\t     expression whose first part is the evaluation of the\n-\t     field selector part. */\n-\t  if (where_found && TREE_CODE (where_found) != TYPE_DECL \n-\t      && TREE_CODE (where_found) != RECORD_TYPE)\n-\t    {\n-\t      tree type = QUAL_DECL_TYPE (field_ref);\n-\t      if (TREE_CODE (type) == RECORD_TYPE)\n-\t\ttype = build_pointer_type (type);\n-\t      field_ref = build (COMPOUND_EXPR, type, where_found, field_ref);\n-\t    }\n-\t}\n+\tfield_ref = build_class_init (type_found, field_ref);\n     }\n   else\n     field_ref = decl;"}]}