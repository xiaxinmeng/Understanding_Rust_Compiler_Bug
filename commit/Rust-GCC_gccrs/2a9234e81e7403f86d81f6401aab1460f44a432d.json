{"sha": "2a9234e81e7403f86d81f6401aab1460f44a432d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5MjM0ZTgxZTc0MDNmODZkODFmNjQwMWFhYjE0NjBmNDRhNDMyZA==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2018-08-16T10:39:13Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2018-08-16T10:39:13Z"}, "message": "Update fall through pattern for FP16 patterns in ARM.\n\nThe original issue comes from the fact that the code does\n\n... foo (... bar)\n{\n  return bar;\n}\n\nThe expansion of the return statement causes GCC to try to return the value in\na register.  GCC will try to emit the move then, from MEM to REG (due to the SSA\ntemporary.).  It checks for a mov optab for this which isn't available and\nthen tries to do the move in bits using emit_move_multi_word.\n\nemit_move_multi_word will split the move into sub parts, but then needs to get\nthe sub parts and does this using subregs, but it's told it can't do subregs!\n\nThe compiler is now stuck in an infinite loop.\n\nThe way this is worked around in the back-end is that we have move patterns in\nneon.md that usually just force the register instead of checking with the\nback-end. This prevents emit_move_multi_word from being needed.  However the\npattern for V4HF and V8HF were guarded by TARGET_NEON && TARGET_FP16.\n\nI don't believe the TARGET_FP16 guard to be needed, because the pattern doesn't\nactually generate code and requires another pattern for that, and a reg to reg move\nshould always be possible anyway. So allowing the force to register here is safe\nand it allows the compiler to generate a correct error instead of ICEing in an\ninfinite loop.\n\ngcc/\n2018-08-16  Tamar Christina  <tamar.christina@arm.com>\n\n\tPR target/84711\n\t* config/arm/arm.c (arm_can_change_mode_class): Disallow subreg.\n\t* config/arm/neon.md (movv4hf, movv8hf): Refactored to..\n\t(mov<mov>): ..this and enable unconditionally.\n\nFrom-SVN: r263584", "tree": {"sha": "b5d753149603a093833e3250e8fecd51186de3b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5d753149603a093833e3250e8fecd51186de3b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a9234e81e7403f86d81f6401aab1460f44a432d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9234e81e7403f86d81f6401aab1460f44a432d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a9234e81e7403f86d81f6401aab1460f44a432d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9234e81e7403f86d81f6401aab1460f44a432d/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02e13564acc1984a82e13ecd72542a594ff23a58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e13564acc1984a82e13ecd72542a594ff23a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e13564acc1984a82e13ecd72542a594ff23a58"}], "stats": {"total": 46, "additions": 21, "deletions": 25}, "files": [{"sha": "aaed5d54a4b81f1cb6220f6e42b95493c2029c37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9234e81e7403f86d81f6401aab1460f44a432d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9234e81e7403f86d81f6401aab1460f44a432d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a9234e81e7403f86d81f6401aab1460f44a432d", "patch": "@@ -1,3 +1,10 @@\n+2018-08-16  Tamar Christina  <tamar.christina@arm.com>\n+\n+\tPR target/84711\n+\t* config/arm/arm.c (arm_can_change_mode_class): Disallow subreg.\n+\t* config/arm/neon.md (movv4hf, movv8hf): Refactored to..\n+\t(mov<mov>): ..this and enable unconditionally.\n+\n 2018-08-16  Tamar Christina  <tamar.christina@arm.com>\n \n \t* config/arm/neon.md (*neon_mov<mode>): Remove reg-to-reg alternative."}, {"sha": "1d97db50a28b753505f7666548f8b0ccbde02327", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9234e81e7403f86d81f6401aab1460f44a432d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9234e81e7403f86d81f6401aab1460f44a432d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2a9234e81e7403f86d81f6401aab1460f44a432d", "patch": "@@ -31509,8 +31509,8 @@ arm_can_change_mode_class (machine_mode from, machine_mode to,\n {\n   if (TARGET_BIG_END\n       && !(GET_MODE_SIZE (from) == 16 && GET_MODE_SIZE (to) == 8)\n-      && (GET_MODE_UNIT_SIZE (from) > UNITS_PER_WORD\n-\t  || GET_MODE_UNIT_SIZE (to) > UNITS_PER_WORD)\n+      && (GET_MODE_SIZE (from) > UNITS_PER_WORD\n+\t  || GET_MODE_SIZE (to) > UNITS_PER_WORD)\n       && reg_classes_intersect_p (VFP_REGS, rclass))\n     return false;\n   return true;"}, {"sha": "5aeee4b08c168c5060d2156edfcba40cb25b5f6f", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9234e81e7403f86d81f6401aab1460f44a432d/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9234e81e7403f86d81f6401aab1460f44a432d/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=2a9234e81e7403f86d81f6401aab1460f44a432d", "patch": "@@ -113,6 +113,13 @@\n    (set_attr \"thumb2_pool_range\" \"*,*,*,1018,*,*,*,1018,*\")\n    (set_attr \"neg_pool_range\" \"*,*,*,996,*,*,*,996,*\")])\n \n+/* We define these mov expanders to match the standard mov$a optab to prevent\n+   the mid-end from trying to do a subreg for these modes which is the most\n+   inefficient way to expand the move.  Also big-endian subreg's aren't\n+   allowed for a subset of modes, See TARGET_CAN_CHANGE_MODE_CLASS.\n+   Without these RTL generation patterns the mid-end would attempt to take a\n+   sub-reg and may ICE if it can't.  */\n+\n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:TI 1 \"general_operand\" \"\"))]\n@@ -137,33 +144,15 @@\n     }\n })\n \n-(define_expand \"movv4hf\"\n-  [(set (match_operand:V4HF 0 \"s_register_operand\")\n-\t(match_operand:V4HF 1 \"s_register_operand\"))]\n-  \"TARGET_NEON && TARGET_FP16\"\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VH 0 \"s_register_operand\")\n+\t(match_operand:VH 1 \"s_register_operand\"))]\n+  \"TARGET_NEON\"\n {\n-  /* We need to use force_reg to avoid TARGET_CAN_CHANGE_MODE_CLASS\n-     causing an ICE on big-endian because it cannot extract subregs in\n-     this case.  */\n-  if (can_create_pseudo_p ())\n-    {\n-      if (!REG_P (operands[0]))\n-\toperands[1] = force_reg (V4HFmode, operands[1]);\n-    }\n-})\n-\n-(define_expand \"movv8hf\"\n-  [(set (match_operand:V8HF 0 \"\")\n-\t(match_operand:V8HF 1 \"\"))]\n-  \"TARGET_NEON && TARGET_FP16\"\n-{ \n-  /* We need to use force_reg to avoid TARGET_CAN_CHANGE_MODE_CLASS\n-     causing an ICE on big-endian because it cannot extract subregs in\n-     this case.  */\n   if (can_create_pseudo_p ())\n     {\n       if (!REG_P (operands[0]))\n-\toperands[1] = force_reg (V8HFmode, operands[1]);\n+\toperands[1] = force_reg (<MODE>mode, operands[1]);\n     }\n })\n "}]}