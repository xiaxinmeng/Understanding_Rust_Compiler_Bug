{"sha": "009c026845b2e38657c54c21a32985fab828b76c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA5YzAyNjg0NWIyZTM4NjU3YzU0YzIxYTMyOTg1ZmFiODI4Yjc2Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T13:24:36Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-19T13:24:36Z"}, "message": "[multiple changes]\n\n2016-04-19  Olivier Hainque  <hainque@adacore.com>\n\n\t* par_sco.adb (Traverse_One, case N_Case_Statement):\n\tSkip pragmas before the first alternative.\n\t(Traverse_Handled_Statement_Sequence, Exception_Handlers): Likewise.\n\n2016-04-19  Tristan Gingold  <gingold@adacore.com>\n\n\t* adaint.c (__gnat_lwp_self): New function (for darwin).\n\t* s-osinte-darwin.ads, s-osinte-darwin.adb (lwp_self): Import\n\tof __gnat_lwp_self.\n\nFrom-SVN: r235204", "tree": {"sha": "f49c9951a6849bfcc1afac5742335bbac380f508", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f49c9951a6849bfcc1afac5742335bbac380f508"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/009c026845b2e38657c54c21a32985fab828b76c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009c026845b2e38657c54c21a32985fab828b76c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/009c026845b2e38657c54c21a32985fab828b76c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/009c026845b2e38657c54c21a32985fab828b76c/comments", "author": null, "committer": null, "parents": [{"sha": "65f52ee9b978858ed791162f29a04f2cbcef6dbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65f52ee9b978858ed791162f29a04f2cbcef6dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65f52ee9b978858ed791162f29a04f2cbcef6dbc"}], "stats": {"total": 854, "additions": 452, "deletions": 402}, "files": [{"sha": "5fcbdc62d13b4acd97273adb42e53564ef1e4371", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=009c026845b2e38657c54c21a32985fab828b76c", "patch": "@@ -1,3 +1,15 @@\n+2016-04-19  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* par_sco.adb (Traverse_One, case N_Case_Statement):\n+\tSkip pragmas before the first alternative.\n+\t(Traverse_Handled_Statement_Sequence, Exception_Handlers): Likewise.\n+\n+2016-04-19  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* adaint.c (__gnat_lwp_self): New function (for darwin).\n+\t* s-osinte-darwin.ads, s-osinte-darwin.adb (lwp_self): Import\n+\tof __gnat_lwp_self.\n+\n 2016-04-19  Olivier Hainque  <hainque@adacore.com>\n \n \t* sem_util.adb (Build_Elaboration_Entity): Always request an"}, {"sha": "2c47f006e9c3c788ba60535a3470ef968742d1e5", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=009c026845b2e38657c54c21a32985fab828b76c", "patch": "@@ -3101,6 +3101,30 @@ __gnat_lwp_self (void)\n }\n #endif\n \n+#if defined (__APPLE__)\n+#include <mach/thread_info.h>\n+#include <mach/mach_init.h>\n+#include <mach/thread_act.h>\n+\n+/* System-wide thread identifier.  Note it could be truncated on 32 bit\n+   hosts.\n+   Previously was: pthread_mach_thread_np (pthread_self ()).  */\n+void *\n+__gnat_lwp_self (void)\n+{\n+  thread_identifier_info_data_t data;\n+  mach_msg_type_number_t count = THREAD_IDENTIFIER_INFO_COUNT;\n+  kern_return_t kret;\n+\n+  kret = thread_info (mach_thread_self (), THREAD_IDENTIFIER_INFO,\n+\t\t      (thread_info_t) &data, &count);\n+  if (kret == KERN_SUCCESS)\n+    return (void *)(uintptr_t)data.thread_id;\n+  else\n+    return 0;\n+}\n+#endif\n+\n #if defined (__linux__)\n #include <sched.h>\n "}, {"sha": "1aa4bc9baeb9e6dd9384870494b14459face6e4d", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 414, "deletions": 390, "changes": 804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=009c026845b2e38657c54c21a32985fab828b76c", "patch": "@@ -76,12 +76,12 @@ package body Par_SCO is\n    --  running some steps multiple times (the second pass has to be started\n    --  from multiple places).\n \n-   package SCO_Raw_Table is new GNAT.Table (\n-     Table_Component_Type => SCO_Table_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 500,\n-     Table_Increment      => 300);\n+   package SCO_Raw_Table is new GNAT.Table\n+     (Table_Component_Type => SCO_Table_Entry,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 500,\n+      Table_Increment      => 300);\n \n    -----------------------\n    -- Unit Number Table --\n@@ -95,13 +95,13 @@ package body Par_SCO is\n    --  Note that the zero'th entry is here for convenience in sorting the\n    --  table, the real lower bound is 1.\n \n-   package SCO_Unit_Number_Table is new Table.Table (\n-     Table_Component_Type => Unit_Number_Type,\n-     Table_Index_Type     => SCO_Unit_Index,\n-     Table_Low_Bound      => 0, -- see note above on sort\n-     Table_Initial        => 20,\n-     Table_Increment      => 200,\n-     Table_Name           => \"SCO_Unit_Number_Entry\");\n+   package SCO_Unit_Number_Table is new Table.Table\n+     (Table_Component_Type => Unit_Number_Type,\n+      Table_Index_Type     => SCO_Unit_Index,\n+      Table_Low_Bound      => 0, -- see note above on sort\n+      Table_Initial        => 20,\n+      Table_Increment      => 200,\n+      Table_Name           => \"SCO_Unit_Number_Entry\");\n \n    ------------------------------------------\n    -- Condition/Operator/Pragma Hash Table --\n@@ -120,10 +120,10 @@ package body Par_SCO is\n    function Hash (F : Source_Ptr) return Header_Num;\n    --  Function to Hash source pointer value\n \n-   function Equal (F1, F2 : Source_Ptr) return Boolean;\n+   function Equal (F1 : Source_Ptr; F2 : Source_Ptr) return Boolean;\n    --  Function to test two keys for equality\n \n-   function \"<\" (S1, S2 : Source_Location) return Boolean;\n+   function \"<\" (S1 : Source_Location; S2 : Source_Location) return Boolean;\n    --  Function to test for source locations order\n \n    package SCO_Raw_Hash_Table is new Simple_HTable\n@@ -199,8 +199,8 @@ package body Par_SCO is\n      (L : List_Id;\n       D : Dominant_Info := No_Dominant;\n       P : Node_Id       := Empty);\n-   --  Process L, a list of statements or declarations dominated by D.\n-   --  If P is present, it is processed as though it had been prepended to L.\n+   --  Process L, a list of statements or declarations dominated by D. If P is\n+   --  present, it is processed as though it had been prepended to L.\n \n    function Traverse_Declarations_Or_Statements\n      (L : List_Id;\n@@ -218,20 +218,31 @@ package body Par_SCO is\n    --   the others are not???\n \n    procedure Traverse_Generic_Package_Declaration (N : Node_Id);\n+\n    procedure Traverse_Handled_Statement_Sequence\n      (N : Node_Id;\n       D : Dominant_Info := No_Dominant);\n-   procedure Traverse_Package_Body        (N : Node_Id);\n+\n+   procedure Traverse_Package_Body (N : Node_Id);\n+\n    procedure Traverse_Package_Declaration\n      (N : Node_Id;\n       D : Dominant_Info := No_Dominant);\n+\n    procedure Traverse_Subprogram_Or_Task_Body\n      (N : Node_Id;\n       D : Dominant_Info := No_Dominant);\n \n-   procedure Traverse_Sync_Definition     (N : Node_Id);\n+   procedure Traverse_Sync_Definition (N : Node_Id);\n    --  Traverse a protected definition or task definition\n \n+   --  Note regarding traversals: In a few cases where an Alternatives list is\n+   --  involved, pragmas such as \"pragma Page\" may show up before the first\n+   --  alternative. We skip them because we're out of statement or declaration\n+   --  context, so these can't be pragmas of interest for SCO purposes, and\n+   --  the regular alternative processing typically involves attribute queries\n+   --  which aren't valid for a pragma.\n+\n    procedure Write_SCOs_To_ALI_File is new Put_SCOs;\n    --  Write SCO information to the ALI file using routines in Lib.Util\n \n@@ -366,7 +377,7 @@ package body Par_SCO is\n    -- Equal --\n    -----------\n \n-   function Equal (F1, F2 : Source_Ptr) return Boolean is\n+   function Equal (F1 : Source_Ptr; F2 : Source_Ptr) return Boolean is\n    begin\n       return F1 = F2;\n    end Equal;\n@@ -375,7 +386,7 @@ package body Par_SCO is\n    -- < --\n    -------\n \n-   function \"<\" (S1, S2 : Source_Location) return Boolean is\n+   function \"<\" (S1 : Source_Location; S2 : Source_Location) return Boolean is\n    begin\n       return S1.Line < S2.Line\n         or else (S1.Line = S2.Line and then S1.Col < S2.Col);\n@@ -386,10 +397,9 @@ package body Par_SCO is\n    ------------------\n \n    function Has_Decision (N : Node_Id) return Boolean is\n-\n       function Check_Node (N : Node_Id) return Traverse_Result;\n-      --  Determine if Nkind (N) indicates the presence of a decision (i.e.\n-      --  N is a logical operator, which is a decision in itself, or an\n+      --  Determine if Nkind (N) indicates the presence of a decision (i.e. N\n+      --  is a logical operator, which is a decision in itself, or an\n       --  IF-expression whose Condition attribute is a decision).\n \n       ----------------\n@@ -404,7 +414,7 @@ package body Par_SCO is\n          --  needed in the secord pass.\n \n          if Is_Logical_Operator (N) /= False\n-            or else Nkind (N) = N_If_Expression\n+           or else Nkind (N) = N_If_Expression\n          then\n             return Abandon;\n          else\n@@ -449,7 +459,7 @@ package body Par_SCO is\n \n    function Is_Logical_Operator (N : Node_Id) return Tristate is\n    begin\n-      if Nkind_In (N, N_Op_Not, N_And_Then, N_Or_Else) then\n+      if Nkind_In (N, N_And_Then, N_Op_Not, N_Or_Else) then\n          return True;\n       elsif Nkind_In (N, N_Op_And, N_Op_Or) then\n          return Unknown;\n@@ -470,6 +480,7 @@ package body Par_SCO is\n       Pragma_Sloc : Source_Ptr)\n    is\n       N : Node_Id;\n+\n    begin\n       if L /= No_List then\n          N := First (L);\n@@ -511,13 +522,13 @@ package body Par_SCO is\n       --  This data structure holds the conditions/pragmas to register in\n       --  SCO_Raw_Hash_Table.\n \n-      package Hash_Entries is new Table.Table (\n-        Table_Component_Type => Hash_Entry,\n-        Table_Index_Type     => Nat,\n-        Table_Low_Bound      => 1,\n-        Table_Initial        => 10,\n-        Table_Increment      => 10,\n-        Table_Name           => \"Hash_Entries\");\n+      package Hash_Entries is new Table.Table\n+        (Table_Component_Type => Hash_Entry,\n+         Table_Index_Type     => Nat,\n+         Table_Low_Bound      => 1,\n+         Table_Initial        => 10,\n+         Table_Increment      => 10,\n+         Table_Name           => \"Hash_Entries\");\n       --  Hold temporarily (i.e. free'd before returning) the Hash_Entry before\n       --  they are registered in SCO_Raw_Hash_Table.\n \n@@ -527,10 +538,6 @@ package body Par_SCO is\n       --  The flag will be set False if T is other than X, or if an operator\n       --  other than NOT is in the sequence.\n \n-      function Process_Node (N : Node_Id) return Traverse_Result;\n-      --  Processes one node in the traversal, looking for logical operators,\n-      --  and if one is found, outputs the appropriate table entries.\n-\n       procedure Output_Decision_Operand (N : Node_Id);\n       --  The node N is the top level logical operator of a decision, or it is\n       --  one of the operands of a logical operator belonging to a single\n@@ -556,19 +563,24 @@ package body Par_SCO is\n       --  the complex decision. It process the suboperands of the decision\n       --  looking for nested decisions.\n \n+      function Process_Node (N : Node_Id) return Traverse_Result;\n+      --  Processes one node in the traversal, looking for logical operators,\n+      --  and if one is found, outputs the appropriate table entries.\n+\n       -----------------------------\n       -- Output_Decision_Operand --\n       -----------------------------\n \n       procedure Output_Decision_Operand (N : Node_Id) is\n-         C1, C2 : Character;\n+         C1 : Character;\n+         C2 : Character;\n          --  C1 holds a character that identifies the operation while C2\n          --  indicates whether we are sure (' ') or not ('?') this operation\n          --  belongs to the decision. '?' entries will be filtered out in the\n          --  second (SCO_Record_Filtered) pass.\n \n-         L      : Node_Id;\n-         T      : Tristate;\n+         L : Node_Id;\n+         T : Tristate;\n \n       begin\n          if No (N) then\n@@ -761,7 +773,7 @@ package body Par_SCO is\n                   --  Output header for sequence\n \n                   X_Not_Decision := T = 'X' and then Nkind (N) = N_Op_Not;\n-                  Mark := SCO_Raw_Table.Last;\n+                  Mark      := SCO_Raw_Table.Last;\n                   Mark_Hash := Hash_Entries.Last;\n                   Output_Header (T);\n \n@@ -804,6 +816,7 @@ package body Par_SCO is\n                   Cond : constant Node_Id := First (Expressions (N));\n                   Thnx : constant Node_Id := Next (Cond);\n                   Elsx : constant Node_Id := Next (Thnx);\n+\n                begin\n                   Process_Decisions (Cond, 'I', Pragma_Sloc);\n                   Process_Decisions (Thnx, 'X', Pragma_Sloc);\n@@ -865,7 +878,6 @@ package body Par_SCO is\n    -----------\n \n    procedure pscos is\n-\n       procedure Write_Info_Char (C : Character) renames Write_Char;\n       --  Write one character;\n \n@@ -907,6 +919,7 @@ package body Par_SCO is\n         ((Inst_Dep_Num       => Dependency_Num (Unit (Inst_Src)),\n           Inst_Loc           => To_Source_Location (Inst_Sloc),\n           Enclosing_Instance => SCO_Instance_Index (Instance (Inst_Src))));\n+\n       pragma Assert\n         (SCO_Instance_Table.Last = SCO_Instance_Index (Id));\n    end Record_Instance;\n@@ -918,6 +931,7 @@ package body Par_SCO is\n    procedure SCO_Output is\n       procedure Populate_SCO_Instance_Table is\n         new Sinput.Iterate_On_Instances (Record_Instance);\n+\n    begin\n       pragma Assert (SCO_Generation_State = Filtered);\n \n@@ -930,8 +944,7 @@ package body Par_SCO is\n       --  Sort the unit tables based on dependency numbers\n \n       Unit_Table_Sort : declare\n-\n-         function Lt (Op1, Op2 : Natural) return Boolean;\n+         function Lt (Op1 : Natural; Op2 : Natural) return Boolean;\n          --  Comparison routine for sort call\n \n          procedure Move (From : Natural; To : Natural);\n@@ -941,7 +954,7 @@ package body Par_SCO is\n          -- Lt --\n          --------\n \n-         function Lt (Op1, Op2 : Natural) return Boolean is\n+         function Lt (Op1 : Natural; Op2 : Natural) return Boolean is\n          begin\n             return\n               Dependency_Num\n@@ -978,6 +991,7 @@ package body Par_SCO is\n          declare\n             U   : constant Unit_Number_Type := SCO_Unit_Number_Table.Table (J);\n             UTE : SCO_Unit_Table_Entry renames SCO_Unit_Table.Table (J);\n+\n          begin\n             Get_Name_String (Reference_Name (Source_Index (U)));\n             UTE.File_Name := new String'(Name_Buffer (1 .. Name_Len));\n@@ -1050,9 +1064,6 @@ package body Par_SCO is\n    --------------------\n \n    procedure SCO_Record_Raw (U : Unit_Number_Type) is\n-      Lu   : Node_Id;\n-      From : Nat;\n-\n       procedure Traverse_Aux_Decls (N : Node_Id);\n       --  Traverse the Aux_Decls_Node of compilation unit N\n \n@@ -1062,6 +1073,7 @@ package body Par_SCO is\n \n       procedure Traverse_Aux_Decls (N : Node_Id) is\n          ADN : constant Node_Id := Aux_Decls_Node (N);\n+\n       begin\n          Traverse_Declarations_Or_Statements (Config_Pragmas (ADN));\n          Traverse_Declarations_Or_Statements (Pragmas_After  (ADN));\n@@ -1074,6 +1086,11 @@ package body Par_SCO is\n          pragma Assert (No (Actions (ADN)));\n       end Traverse_Aux_Decls;\n \n+      --  Local variables\n+\n+      From : Nat;\n+      Lu   : Node_Id;\n+\n    --  Start of processing for SCO_Record_Raw\n \n    begin\n@@ -1114,16 +1131,14 @@ package body Par_SCO is\n       Traverse_Aux_Decls (Cunit (U));\n \n       case Nkind (Lu) is\n-         when\n-           N_Package_Declaration         |\n-           N_Package_Body                |\n-           N_Subprogram_Declaration      |\n-           N_Subprogram_Body             |\n-           N_Generic_Package_Declaration |\n-           N_Protected_Body              |\n-           N_Task_Body                   |\n-           N_Generic_Instantiation       =>\n-\n+         when N_Generic_Instantiation       |\n+              N_Generic_Package_Declaration |\n+              N_Package_Body                |\n+              N_Package_Declaration         |\n+              N_Protected_Body              |\n+              N_Subprogram_Body             |\n+              N_Subprogram_Declaration      |\n+              N_Task_Body                   =>\n             Traverse_Declarations_Or_Statements (L => No_List, P => Lu);\n \n          when others =>\n@@ -1157,13 +1172,14 @@ package body Par_SCO is\n \n       pragma Assert (not Generate_SCO or else SCO_Generation_State = Raw);\n \n+      Constant_Condition_Code : constant array (Boolean) of Character :=\n+                                  (False => 'f', True => 't');\n+\n       Orig  : constant Node_Id := Original_Node (Cond);\n+      Dummy : Source_Ptr;\n       Index : Nat;\n       Start : Source_Ptr;\n-      Dummy : Source_Ptr;\n \n-      Constant_Condition_Code : constant array (Boolean) of Character :=\n-                                  (False => 'f', True => 't');\n    begin\n       Sloc_Range (Orig, Start, Dummy);\n       Index := SCO_Raw_Hash_Table.Get (Start);\n@@ -1191,9 +1207,9 @@ package body Par_SCO is\n \n       pragma Assert (not Generate_SCO or else SCO_Generation_State = Raw);\n \n-      Orig      : constant Node_Id := Original_Node (Op);\n+      Orig      : constant Node_Id    := Original_Node (Op);\n       Orig_Sloc : constant Source_Ptr := Sloc (Orig);\n-      Index     : constant Nat := SCO_Raw_Hash_Table.Get (Orig_Sloc);\n+      Index     : constant Nat        := SCO_Raw_Hash_Table.Get (Orig_Sloc);\n \n    begin\n       --  All (putative) logical operators are supposed to have their own entry\n@@ -1333,25 +1349,25 @@ package body Par_SCO is\n    --  the range of entries in the CS line entry, and typ is the type, with\n    --  space meaning that no type letter will accompany the entry.\n \n-   package SC is new Table.Table (\n-     Table_Component_Type => SC_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 1000,\n-     Table_Increment      => 200,\n-     Table_Name           => \"SCO_SC\");\n-      --  Used to store statement components for a CS entry to be output\n-      --  as a result of the call to this procedure. SC.Last is the last\n-      --  entry stored, so the current statement sequence is represented\n-      --  by SC_Array (SC_First .. SC.Last), where SC_First is saved on\n-      --  entry to each recursive call to the routine.\n-      --\n-      --  Extend_Statement_Sequence adds an entry to this array, and then\n-      --  Set_Statement_Entry clears the entries starting with SC_First,\n-      --  copying these entries to the main SCO output table. The reason that\n-      --  we do the temporary caching of results in this array is that we want\n-      --  the SCO table entries for a given CS line to be contiguous, and the\n-      --  processing may output intermediate entries such as decision entries.\n+   package SC is new Table.Table\n+     (Table_Component_Type => SC_Entry,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 1000,\n+      Table_Increment      => 200,\n+      Table_Name           => \"SCO_SC\");\n+   --  Used to store statement components for a CS entry to be output as a\n+   --  result of the call to this procedure. SC.Last is the last entry stored,\n+   --  so the current statement sequence is represented by SC_Array (SC_First\n+   --  .. SC.Last), where SC_First is saved on entry to each recursive call to\n+   --  the routine.\n+   --\n+   --  Extend_Statement_Sequence adds an entry to this array, and then\n+   --  Set_Statement_Entry clears the entries starting with SC_First, copying\n+   --  these entries to the main SCO output table. The reason that we do the\n+   --  temporary caching of results in this array is that we want the SCO table\n+   --  entries for a given CS line to be contiguous, and the processing may\n+   --  output intermediate entries such as decision entries.\n \n    type SD_Entry is record\n       Nod : Node_Id;\n@@ -1366,13 +1382,13 @@ package body Par_SCO is\n    --  argument (in which case Nod is set to Empty). Plo is the sloc of the\n    --  enclosing pragma, if any.\n \n-   package SD is new Table.Table (\n-     Table_Component_Type => SD_Entry,\n-     Table_Index_Type     => Nat,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 1000,\n-     Table_Increment      => 200,\n-     Table_Name           => \"SCO_SD\");\n+   package SD is new Table.Table\n+     (Table_Component_Type => SD_Entry,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 1000,\n+      Table_Increment      => 200,\n+      Table_Name           => \"SCO_SD\");\n    --  Used to store possible decision information. Instead of calling the\n    --  Process_Decisions procedures directly, we call Process_Decisions_Defer,\n    --  which simply stores the arguments in this table. Then when we clear\n@@ -1415,11 +1431,6 @@ package body Par_SCO is\n       --  is the letter that identifies the type of statement/declaration that\n       --  is being added to the sequence.\n \n-      procedure Set_Statement_Entry;\n-      --  Output CS entries for all statements saved in table SC, and end the\n-      --  current CS sequence. Then output entries for all decisions nested in\n-      --  these statements, which have been deferred so far.\n-\n       procedure Process_Decisions_Defer (N : Node_Id; T : Character);\n       pragma Inline (Process_Decisions_Defer);\n       --  This routine is logically the same as Process_Decisions, except that\n@@ -1431,12 +1442,95 @@ package body Par_SCO is\n       pragma Inline (Process_Decisions_Defer);\n       --  Same case for list arguments, deferred call to Process_Decisions\n \n+      procedure Set_Statement_Entry;\n+      --  Output CS entries for all statements saved in table SC, and end the\n+      --  current CS sequence. Then output entries for all decisions nested in\n+      --  these statements, which have been deferred so far.\n+\n       procedure Traverse_One (N : Node_Id);\n       --  Traverse one declaration or statement\n \n       procedure Traverse_Aspects (N : Node_Id);\n       --  Helper for Traverse_One: traverse N's aspect specifications\n \n+      -------------------------------\n+      -- Extend_Statement_Sequence --\n+      -------------------------------\n+\n+      procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character) is\n+         Dummy   : Source_Ptr;\n+         F       : Source_Ptr;\n+         T       : Source_Ptr;\n+         To_Node : Node_Id := Empty;\n+\n+      begin\n+         Sloc_Range (N, F, T);\n+\n+         case Nkind (N) is\n+            when N_Accept_Statement =>\n+               if Present (Parameter_Specifications (N)) then\n+                  To_Node := Last (Parameter_Specifications (N));\n+               elsif Present (Entry_Index (N)) then\n+                  To_Node := Entry_Index (N);\n+               end if;\n+\n+            when N_Case_Statement =>\n+               To_Node := Expression (N);\n+\n+            when N_If_Statement | N_Elsif_Part =>\n+               To_Node := Condition (N);\n+\n+            when N_Extended_Return_Statement =>\n+               To_Node := Last (Return_Object_Declarations (N));\n+\n+            when N_Loop_Statement =>\n+               To_Node := Iteration_Scheme (N);\n+\n+            when N_Asynchronous_Select          |\n+                 N_Conditional_Entry_Call       |\n+                 N_Selective_Accept             |\n+                 N_Single_Protected_Declaration |\n+                 N_Single_Task_Declaration      |\n+                 N_Timed_Entry_Call             =>\n+               T := F;\n+\n+            when N_Protected_Type_Declaration | N_Task_Type_Declaration =>\n+               if Has_Aspects (N) then\n+                  To_Node := Last (Aspect_Specifications (N));\n+\n+               elsif Present (Discriminant_Specifications (N)) then\n+                  To_Node := Last (Discriminant_Specifications (N));\n+\n+               else\n+                  To_Node := Defining_Identifier (N);\n+               end if;\n+\n+            when others =>\n+               null;\n+\n+         end case;\n+\n+         if Present (To_Node) then\n+            Sloc_Range (To_Node, Dummy, T);\n+         end if;\n+\n+         SC.Append ((N, F, T, Typ));\n+      end Extend_Statement_Sequence;\n+\n+      -----------------------------\n+      -- Process_Decisions_Defer --\n+      -----------------------------\n+\n+      procedure Process_Decisions_Defer (N : Node_Id; T : Character) is\n+      begin\n+         SD.Append ((N, No_List, T, Current_Pragma_Sloc));\n+      end Process_Decisions_Defer;\n+\n+      procedure Process_Decisions_Defer (L : List_Id; T : Character) is\n+      begin\n+         SD.Append ((Empty, L, T, Current_Pragma_Sloc));\n+      end Process_Decisions_Defer;\n+\n       -------------------------\n       -- Set_Statement_Entry --\n       -------------------------\n@@ -1453,12 +1547,16 @@ package body Par_SCO is\n \n                if Current_Dominant /= No_Dominant then\n                   declare\n-                     From, To : Source_Ptr;\n+                     From : Source_Ptr;\n+                     To   : Source_Ptr;\n+\n                   begin\n                      Sloc_Range (Current_Dominant.N, From, To);\n+\n                      if Current_Dominant.K /= 'E' then\n                         To := No_Location;\n                      end if;\n+\n                      Set_Raw_Table_Entry\n                        (C1                 => '>',\n                         C2                 => Current_Dominant.K,\n@@ -1475,6 +1573,7 @@ package body Par_SCO is\n                SCE                : SC_Entry renames SC.Table (J);\n                Pragma_Sloc        : Source_Ptr := No_Location;\n                Pragma_Aspect_Name : Name_Id    := No_Name;\n+\n             begin\n                --  For the case of a statement SCO for a pragma controlled by\n                --  Set_SCO_Pragma_Enabled, set Pragma_Sloc so that the SCO (and\n@@ -1520,6 +1619,7 @@ package body Par_SCO is\n          for J in SD_First .. SD_Last loop\n             declare\n                SDE : SD_Entry renames SD.Table (J);\n+\n             begin\n                if Present (SDE.Nod) then\n                   Process_Decisions (SDE.Nod, SDE.Typ, SDE.Plo);\n@@ -1534,91 +1634,13 @@ package body Par_SCO is\n          SD.Set_Last (SD_First - 1);\n       end Set_Statement_Entry;\n \n-      -------------------------------\n-      -- Extend_Statement_Sequence --\n-      -------------------------------\n-\n-      procedure Extend_Statement_Sequence (N : Node_Id; Typ : Character) is\n-         F       : Source_Ptr;\n-         T       : Source_Ptr;\n-         Dummy   : Source_Ptr;\n-         To_Node : Node_Id := Empty;\n-\n-      begin\n-         Sloc_Range (N, F, T);\n-\n-         case Nkind (N) is\n-            when N_Accept_Statement =>\n-               if Present (Parameter_Specifications (N)) then\n-                  To_Node := Last (Parameter_Specifications (N));\n-               elsif Present (Entry_Index (N)) then\n-                  To_Node := Entry_Index (N);\n-               end if;\n-\n-            when N_Case_Statement =>\n-               To_Node := Expression (N);\n-\n-            when N_If_Statement | N_Elsif_Part =>\n-               To_Node := Condition (N);\n-\n-            when N_Extended_Return_Statement =>\n-               To_Node := Last (Return_Object_Declarations (N));\n-\n-            when N_Loop_Statement =>\n-               To_Node := Iteration_Scheme (N);\n-\n-            when N_Selective_Accept             |\n-                 N_Timed_Entry_Call             |\n-                 N_Conditional_Entry_Call       |\n-                 N_Asynchronous_Select          |\n-                 N_Single_Protected_Declaration |\n-                 N_Single_Task_Declaration      =>\n-               T := F;\n-\n-            when N_Protected_Type_Declaration | N_Task_Type_Declaration =>\n-               if Has_Aspects (N) then\n-                  To_Node := Last (Aspect_Specifications (N));\n-\n-               elsif Present (Discriminant_Specifications (N)) then\n-                  To_Node := Last (Discriminant_Specifications (N));\n-\n-               else\n-                  To_Node := Defining_Identifier (N);\n-               end if;\n-\n-            when others =>\n-               null;\n-\n-         end case;\n-\n-         if Present (To_Node) then\n-            Sloc_Range (To_Node, Dummy, T);\n-         end if;\n-\n-         SC.Append ((N, F, T, Typ));\n-      end Extend_Statement_Sequence;\n-\n-      -----------------------------\n-      -- Process_Decisions_Defer --\n-      -----------------------------\n-\n-      procedure Process_Decisions_Defer (N : Node_Id; T : Character) is\n-      begin\n-         SD.Append ((N, No_List, T, Current_Pragma_Sloc));\n-      end Process_Decisions_Defer;\n-\n-      procedure Process_Decisions_Defer (L : List_Id; T : Character) is\n-      begin\n-         SD.Append ((Empty, L, T, Current_Pragma_Sloc));\n-      end Process_Decisions_Defer;\n-\n       ----------------------\n       -- Traverse_Aspects --\n       ----------------------\n \n       procedure Traverse_Aspects (N : Node_Id) is\n-         AN : Node_Id;\n          AE : Node_Id;\n+         AN : Node_Id;\n          C1 : Character;\n \n       begin\n@@ -1640,13 +1662,12 @@ package body Par_SCO is\n                --  specification. The corresponding pragma will have the same\n                --  sloc.\n \n-               when Aspect_Pre            |\n-                    Aspect_Precondition   |\n+               when Aspect_Invariant      |\n                     Aspect_Post           |\n                     Aspect_Postcondition  |\n-                    Aspect_Type_Invariant |\n-                    Aspect_Invariant      =>\n-\n+                    Aspect_Pre            |\n+                    Aspect_Precondition   |\n+                    Aspect_Type_Invariant =>\n                   C1 := 'a';\n \n                --  Aspects whose checks are generated in client units,\n@@ -1659,17 +1680,15 @@ package body Par_SCO is\n                --  Pre/post can have checks in client units too because of\n                --  inheritance, so should they be moved here???\n \n-               when Aspect_Predicate         |\n-                    Aspect_Static_Predicate  |\n-                    Aspect_Dynamic_Predicate =>\n-\n+               when Aspect_Dynamic_Predicate |\n+                    Aspect_Predicate         |\n+                    Aspect_Static_Predicate  =>\n                   C1 := 'A';\n \n                --  Other aspects: just process any decision nested in the\n                --  aspect expression.\n \n                when others =>\n-\n                   if Has_Decision (AE) then\n                      C1 := 'X';\n                   end if;\n@@ -1901,7 +1920,7 @@ package body Par_SCO is\n                declare\n                   Alt : Node_Id;\n                begin\n-                  Alt := First (Alternatives (N));\n+                  Alt := First_Non_Pragma (Alternatives (N));\n                   while Present (Alt) loop\n                      Traverse_Declarations_Or_Statements\n                        (L => Statements (Alt),\n@@ -2043,8 +2062,7 @@ package body Par_SCO is\n \n             when N_Extended_Return_Statement =>\n                Extend_Statement_Sequence (N, 'R');\n-               Process_Decisions_Defer\n-                 (Return_Object_Declarations (N), 'X');\n+               Process_Decisions_Defer (Return_Object_Declarations (N), 'X');\n                Set_Statement_Entry;\n \n                Traverse_Handled_Statement_Sequence\n@@ -2126,8 +2144,8 @@ package body Par_SCO is\n                           Name_Assume         |\n                           Name_Check          |\n                           Name_Loop_Invariant |\n-                          Name_Precondition   |\n-                          Name_Postcondition  =>\n+                          Name_Postcondition  |\n+                          Name_Precondition   =>\n \n                         --  For Assert/Check/Precondition/Postcondition, we\n                         --  must generate a P entry for the decision. Note\n@@ -2224,8 +2242,8 @@ package body Par_SCO is\n                   case NK is\n                      when N_Full_Type_Declaration         |\n                           N_Incomplete_Type_Declaration   |\n-                          N_Private_Type_Declaration      |\n-                          N_Private_Extension_Declaration =>\n+                          N_Private_Extension_Declaration |\n+                          N_Private_Type_Declaration      =>\n                         Typ := 't';\n \n                      when N_Subtype_Declaration           =>\n@@ -2237,12 +2255,12 @@ package body Par_SCO is\n                      when N_Generic_Instantiation         =>\n                         Typ := 'i';\n \n-                     when N_Representation_Clause         |\n-                          N_Use_Package_Clause            |\n-                          N_Use_Type_Clause               |\n-                          N_Package_Body_Stub             |\n+                     when N_Package_Body_Stub             |\n+                          N_Protected_Body_Stub           |\n+                          N_Representation_Clause         |\n                           N_Task_Body_Stub                |\n-                          N_Protected_Body_Stub           =>\n+                          N_Use_Package_Clause            |\n+                          N_Use_Type_Clause               =>\n                         Typ := ASCII.NUL;\n \n                      when N_Procedure_Call_Statement =>\n@@ -2338,7 +2356,7 @@ package body Par_SCO is\n          Traverse_Declarations_Or_Statements (Statements (N), D);\n \n          if Present (Exception_Handlers (N)) then\n-            Handler := First (Exception_Handlers (N));\n+            Handler := First_Non_Pragma (Exception_Handlers (N));\n             while Present (Handler) loop\n                Traverse_Declarations_Or_Statements\n                  (L => Statements (Handler),\n@@ -2397,15 +2415,18 @@ package body Par_SCO is\n       Sync_Def : Node_Id;\n       --  N's protected or task definition\n \n-      Vis_Decl, Priv_Decl : List_Id;\n+      Priv_Decl : List_Id;\n+      Vis_Decl  : List_Id;\n       --  Sync_Def's Visible_Declarations and Private_Declarations\n \n    begin\n       case Nkind (N) is\n-         when N_Single_Protected_Declaration | N_Protected_Type_Declaration =>\n+         when N_Protected_Type_Declaration   |\n+              N_Single_Protected_Declaration =>\n             Sync_Def := Protected_Definition (N);\n \n-         when N_Single_Task_Declaration      | N_Task_Type_Declaration      =>\n+         when N_Single_Task_Declaration      |\n+              N_Task_Type_Declaration        =>\n             Sync_Def := Task_Definition (N);\n \n          when others =>\n@@ -2416,10 +2437,10 @@ package body Par_SCO is\n       --  Querying Visible or Private_Declarations is invalid in this case.\n \n       if Present (Sync_Def) then\n-         Vis_Decl := Visible_Declarations (Sync_Def);\n+         Vis_Decl  := Visible_Declarations (Sync_Def);\n          Priv_Decl := Private_Declarations (Sync_Def);\n       else\n-         Vis_Decl := No_List;\n+         Vis_Decl  := No_List;\n          Priv_Decl := No_List;\n       end if;\n \n@@ -2444,7 +2465,8 @@ package body Par_SCO is\n       D : Dominant_Info := No_Dominant)\n    is\n       Decls    : constant List_Id := Declarations (N);\n-      Dom_Info : Dominant_Info := D;\n+      Dom_Info : Dominant_Info    := D;\n+\n    begin\n       --  If declarations are present, the first statement is dominated by the\n       --  last declaration.\n@@ -2484,23 +2506,9 @@ package body Par_SCO is\n          Table_Name           => \"Filter_Pending_Decisions\");\n       --  Table used to hold decisions to process during the collection pass\n \n-      function Is_Decision (Idx : Nat) return Boolean;\n-      --  Return if the expression tree starting at Idx has adjacent nested\n-      --  nodes that make a decision.\n-\n-      procedure Search_Nested_Decisions (Idx : in out Nat);\n-      --  Collect decisions to add to the filtered SCO table starting at the\n-      --  node at Idx in the SCO raw table. This node must not be part of an\n-      --  already-processed decision. Set Idx to the first node index passed\n-      --  the whole expression tree.\n-\n-      procedure Skip_Decision\n-        (Idx                      : in out Nat;\n-         Process_Nested_Decisions : Boolean);\n-      --  Skip all the nodes that belong to the decision starting at Idx. If\n-      --  Process_Nested_Decision, call Search_Nested_Decisions on the first\n-      --  nested nodes that do not belong to the decision. Set Idx to the first\n-      --  node index passed the whole expression tree.\n+      procedure Add_Expression_Tree (Idx : in out Nat);\n+      --  Add SCO raw table entries for the decision controlling expression\n+      --  tree starting at Idx to the filtered SCO table.\n \n       procedure Collect_Decisions\n         (D    : Decision;\n@@ -2516,149 +2524,87 @@ package body Par_SCO is\n       --  Compute the source location range for the expression tree starting at\n       --  Idx in the SCO raw table. Store its bounds in From and To.\n \n-      procedure Add_Expression_Tree (Idx : in out Nat);\n-      --  Add SCO raw table entries for the decision controlling expression\n-      --  tree starting at Idx to the filtered SCO table.\n+      function Is_Decision (Idx : Nat) return Boolean;\n+      --  Return if the expression tree starting at Idx has adjacent nested\n+      --  nodes that make a decision.\n \n       procedure Process_Pending_Decisions\n         (Original_Decision : SCO_Table_Entry);\n       --  Complete the filtered SCO table using collected decisions. Output\n       --  decisions inherit the pragma information from the original decision.\n \n-      -----------------\n-      -- Is_Decision --\n-      -----------------\n-\n-      function Is_Decision (Idx : Nat) return Boolean is\n-         Index : Nat := Idx;\n+      procedure Search_Nested_Decisions (Idx : in out Nat);\n+      --  Collect decisions to add to the filtered SCO table starting at the\n+      --  node at Idx in the SCO raw table. This node must not be part of an\n+      --  already-processed decision. Set Idx to the first node index passed\n+      --  the whole expression tree.\n \n-      begin\n-         loop\n-            declare\n-               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Index);\n-\n-            begin\n-               case T.C1 is\n-                  when ' ' =>\n-                     return False;\n-\n-                  when '!' =>\n-\n-                     --  This is a decision iff the only operand of the NOT\n-                     --  operator could be a standalone decision.\n-\n-                     Index := Idx + 1;\n-\n-                  when others =>\n-\n-                     --  This node is a logical operator (and thus could be a\n-                     --  standalone decision) iff it is a short circuit\n-                     --  operator.\n-\n-                     return T.C2 /= '?';\n+      procedure Skip_Decision\n+        (Idx                      : in out Nat;\n+         Process_Nested_Decisions : Boolean);\n+      --  Skip all the nodes that belong to the decision starting at Idx. If\n+      --  Process_Nested_Decision, call Search_Nested_Decisions on the first\n+      --  nested nodes that do not belong to the decision. Set Idx to the first\n+      --  node index passed the whole expression tree.\n \n-               end case;\n-            end;\n-         end loop;\n-      end Is_Decision;\n+      -------------------------\n+      -- Add_Expression_Tree --\n+      -------------------------\n \n-      -----------------------------\n-      -- Search_Nested_Decisions --\n-      -----------------------------\n+      procedure Add_Expression_Tree (Idx : in out Nat) is\n+         Node_Idx : constant Nat := Idx;\n+         T        : SCO_Table_Entry renames SCO_Raw_Table.Table (Node_Idx);\n+         From     : Source_Location;\n+         To       : Source_Location;\n \n-      procedure Search_Nested_Decisions (Idx : in out Nat)\n-      is\n       begin\n-         loop\n-            declare\n-               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n-\n-            begin\n-               case T.C1 is\n-                  when ' ' =>\n-                     Idx := Idx + 1;\n-                     exit;\n-\n-                  when '!' =>\n-                     Collect_Decisions\n-                       ((Kind => 'X',\n-                         Sloc => T.From,\n-                         Top  => Idx),\n-                        Idx);\n-                     exit;\n-\n-                  when others =>\n-                     if T.C2 = '?' then\n-\n-                        --  This in not a logical operator: start looking for\n-                        --  nested decisions from here. Recurse over the left\n-                        --  child and let the loop take care of the right one.\n-\n-                        Idx := Idx + 1;\n-                        Search_Nested_Decisions (Idx);\n+         case T.C1 is\n+            when ' ' =>\n \n-                     else\n-                        --  We found a nested decision\n+               --  This is a single condition. Add an entry for it and move on\n \n-                        Collect_Decisions\n-                          ((Kind => 'X',\n-                            Sloc => T.From,\n-                            Top  => Idx),\n-                            Idx);\n-                        exit;\n-                     end if;\n-               end case;\n-            end;\n-         end loop;\n-      end Search_Nested_Decisions;\n+               SCO_Table.Append (T);\n+               Idx := Idx + 1;\n \n-      -------------------\n-      -- Skip_Decision --\n-      -------------------\n+            when '!' =>\n \n-      procedure Skip_Decision\n-        (Idx                      : in out Nat;\n-         Process_Nested_Decisions : Boolean)\n-      is\n-      begin\n-         loop\n-            declare\n-               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n+               --  This is a NOT operator: add an entry for it and browse its\n+               --  only child.\n \n-            begin\n+               SCO_Table.Append (T);\n                Idx := Idx + 1;\n+               Add_Expression_Tree (Idx);\n \n-               case T.C1 is\n-                  when ' ' =>\n-                     exit;\n-\n-                  when '!' =>\n-\n-                     --  This NOT operator belongs to the outside decision:\n-                     --  just skip it.\n+            when others =>\n \n-                     null;\n+               --  This must be an AND/OR/AND THEN/OR ELSE operator\n \n-                  when others =>\n-                     if T.C2 = '?' and then Process_Nested_Decisions then\n+               if T.C2 = '?' then\n \n-                        --  This in not a logical operator: start looking for\n-                        --  nested decisions from here. Recurse over the left\n-                        --  child and let the loop take care of the right one.\n+                  --  This is not a short circuit operator: consider this one\n+                  --  and all its children as a single condition.\n \n-                        Search_Nested_Decisions (Idx);\n+                  Compute_Range (Idx, From, To);\n+                  SCO_Table.Append\n+                    ((From               => From,\n+                      To                 => To,\n+                      C1                 => ' ',\n+                      C2                 => 'c',\n+                      Last               => False,\n+                      Pragma_Sloc        => No_Location,\n+                      Pragma_Aspect_Name => No_Name));\n \n-                     else\n-                        --  This is a logical operator, so it belongs to the\n-                        --  outside decision: skip its left child, then let the\n-                        --  loop take care of the right one.\n+               else\n+                  --  This is a real short circuit operator: add an entry for\n+                  --  it and browse its children.\n \n-                        Skip_Decision (Idx, Process_Nested_Decisions);\n-                     end if;\n-               end case;\n-            end;\n-         end loop;\n-      end Skip_Decision;\n+                  SCO_Table.Append (T);\n+                  Idx := Idx + 1;\n+                  Add_Expression_Tree (Idx);\n+                  Add_Expression_Tree (Idx);\n+               end if;\n+         end case;\n+      end Add_Expression_Tree;\n \n       -----------------------\n       -- Collect_Decisions --\n@@ -2669,6 +2615,7 @@ package body Par_SCO is\n          Next : out Nat)\n       is\n          Idx : Nat := D.Top;\n+\n       begin\n          if D.Kind /= 'X' or else Is_Decision (D.Top) then\n             Pending_Decisions.Append (D);\n@@ -2687,7 +2634,8 @@ package body Par_SCO is\n          From : out Source_Location;\n          To   : out Source_Location)\n       is\n-         Sloc_F, Sloc_T : Source_Location := No_Source_Location;\n+         Sloc_F : Source_Location := No_Source_Location;\n+         Sloc_T : Source_Location := No_Source_Location;\n \n          procedure Process_One;\n          --  Process one node of the tree, and recurse over children. Update\n@@ -2705,6 +2653,7 @@ package body Par_SCO is\n             then\n                Sloc_F := SCO_Raw_Table.Table (Idx).From;\n             end if;\n+\n             if Sloc_T = No_Source_Location\n                  or else\n                Sloc_T < SCO_Raw_Table.Table (Idx).To\n@@ -2741,67 +2690,45 @@ package body Par_SCO is\n       begin\n          Process_One;\n          From := Sloc_F;\n-         To := Sloc_T;\n+         To   := Sloc_T;\n       end Compute_Range;\n \n-      -------------------------\n-      -- Add_Expression_Tree --\n-      -------------------------\n+      -----------------\n+      -- Is_Decision --\n+      -----------------\n \n-      procedure Add_Expression_Tree (Idx : in out Nat)\n-      is\n-         Node_Idx : constant Nat := Idx;\n-         T        : SCO_Table_Entry renames SCO_Raw_Table.Table (Node_Idx);\n-         From, To : Source_Location;\n+      function Is_Decision (Idx : Nat) return Boolean is\n+         Index : Nat := Idx;\n \n       begin\n-         case T.C1 is\n-            when ' ' =>\n-\n-               --  This is a single condition. Add an entry for it and move on\n-\n-               SCO_Table.Append (T);\n-               Idx := Idx + 1;\n-\n-            when '!' =>\n-\n-               --  This is a NOT operator: add an entry for it and browse its\n-               --  only child.\n+         loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Index);\n \n-               SCO_Table.Append (T);\n-               Idx := Idx + 1;\n-               Add_Expression_Tree (Idx);\n+            begin\n+               case T.C1 is\n+                  when ' ' =>\n+                     return False;\n \n-            when others =>\n+                  when '!' =>\n \n-               --  This must be an AND/OR/AND THEN/OR ELSE operator\n+                     --  This is a decision iff the only operand of the NOT\n+                     --  operator could be a standalone decision.\n \n-               if T.C2 = '?' then\n+                     Index := Idx + 1;\n \n-                  --  This is not a short circuit operator: consider this one\n-                  --  and all its children as a single condition.\n+                  when others =>\n \n-                  Compute_Range (Idx, From, To);\n-                  SCO_Table.Append\n-                    ((From               => From,\n-                      To                 => To,\n-                      C1                 => ' ',\n-                      C2                 => 'c',\n-                      Last               => False,\n-                      Pragma_Sloc        => No_Location,\n-                      Pragma_Aspect_Name => No_Name));\n+                     --  This node is a logical operator (and thus could be a\n+                     --  standalone decision) iff it is a short circuit\n+                     --  operator.\n \n-               else\n-                  --  This is a real short circuit operator: add an entry for\n-                  --  it and browse its children.\n+                     return T.C2 /= '?';\n \n-                  SCO_Table.Append (T);\n-                  Idx := Idx + 1;\n-                  Add_Expression_Tree (Idx);\n-                  Add_Expression_Tree (Idx);\n-               end if;\n-         end case;\n-      end Add_Expression_Tree;\n+               end case;\n+            end;\n+         end loop;\n+      end Is_Decision;\n \n       -------------------------------\n       -- Process_Pending_Decisions --\n@@ -2843,6 +2770,103 @@ package body Par_SCO is\n          Pending_Decisions.Set_Last (0);\n       end Process_Pending_Decisions;\n \n+      -----------------------------\n+      -- Search_Nested_Decisions --\n+      -----------------------------\n+\n+      procedure Search_Nested_Decisions (Idx : in out Nat) is\n+      begin\n+         loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n+\n+            begin\n+               case T.C1 is\n+                  when ' ' =>\n+                     Idx := Idx + 1;\n+                     exit;\n+\n+                  when '!' =>\n+                     Collect_Decisions\n+                       ((Kind => 'X',\n+                         Sloc => T.From,\n+                         Top  => Idx),\n+                        Idx);\n+                     exit;\n+\n+                  when others =>\n+                     if T.C2 = '?' then\n+\n+                        --  This in not a logical operator: start looking for\n+                        --  nested decisions from here. Recurse over the left\n+                        --  child and let the loop take care of the right one.\n+\n+                        Idx := Idx + 1;\n+                        Search_Nested_Decisions (Idx);\n+\n+                     else\n+                        --  We found a nested decision\n+\n+                        Collect_Decisions\n+                          ((Kind => 'X',\n+                            Sloc => T.From,\n+                            Top  => Idx),\n+                            Idx);\n+                        exit;\n+                     end if;\n+               end case;\n+            end;\n+         end loop;\n+      end Search_Nested_Decisions;\n+\n+      -------------------\n+      -- Skip_Decision --\n+      -------------------\n+\n+      procedure Skip_Decision\n+        (Idx                      : in out Nat;\n+         Process_Nested_Decisions : Boolean)\n+      is\n+      begin\n+         loop\n+            declare\n+               T : SCO_Table_Entry renames SCO_Raw_Table.Table (Idx);\n+\n+            begin\n+               Idx := Idx + 1;\n+\n+               case T.C1 is\n+                  when ' ' =>\n+                     exit;\n+\n+                  when '!' =>\n+\n+                     --  This NOT operator belongs to the outside decision:\n+                     --  just skip it.\n+\n+                     null;\n+\n+                  when others =>\n+                     if T.C2 = '?' and then Process_Nested_Decisions then\n+\n+                        --  This in not a logical operator: start looking for\n+                        --  nested decisions from here. Recurse over the left\n+                        --  child and let the loop take care of the right one.\n+\n+                        Search_Nested_Decisions (Idx);\n+\n+                     else\n+                        --  This is a logical operator, so it belongs to the\n+                        --  outside decision: skip its left child, then let the\n+                        --  loop take care of the right one.\n+\n+                        Skip_Decision (Idx, Process_Nested_Decisions);\n+                     end if;\n+               end case;\n+            end;\n+         end loop;\n+      end Skip_Decision;\n+\n    --  Start of processing for SCO_Record_Filtered\n \n    begin\n@@ -2861,7 +2885,7 @@ package body Par_SCO is\n       for Unit_Idx in 1 .. SCO_Unit_Table.Last loop\n          declare\n             Unit : SCO_Unit_Table_Entry\n-               renames SCO_Unit_Table.Table (Unit_Idx);\n+                     renames SCO_Unit_Table.Table (Unit_Idx);\n \n             Idx : Nat := Unit.From;\n             --  Index of the current SCO raw table entry\n@@ -2921,7 +2945,7 @@ package body Par_SCO is\n             --  Now, update the SCO entry indexes in the unit entry\n \n             Unit.From := New_From;\n-            Unit.To := SCO_Table.Last;\n+            Unit.To   := SCO_Table.Last;\n          end;\n       end loop;\n "}, {"sha": "4998e8359a6bd05796abd9ce230169e5432b3895", "filename": "gcc/ada/s-osinte-darwin.adb", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fs-osinte-darwin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fs-osinte-darwin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.adb?ref=009c026845b2e38657c54c21a32985fab828b76c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  B o d y                                 --\n --                                                                          --\n---          Copyright (C) 1999-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -172,17 +172,6 @@ package body System.OS_Interface is\n       return 0;\n    end sched_yield;\n \n-   --------------\n-   -- lwp_self --\n-   --------------\n-\n-   function lwp_self return Address is\n-      function pthread_mach_thread_np (thread : pthread_t) return Address;\n-      pragma Import (C, pthread_mach_thread_np, \"pthread_mach_thread_np\");\n-   begin\n-      return pthread_mach_thread_np (pthread_self);\n-   end lwp_self;\n-\n    ------------------\n    -- pthread_init --\n    ------------------"}, {"sha": "946373c2f26d4b3d7e8b35f9e31665add7b93e6a", "filename": "gcc/ada/s-osinte-darwin.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fs-osinte-darwin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/009c026845b2e38657c54c21a32985fab828b76c/gcc%2Fada%2Fs-osinte-darwin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-darwin.ads?ref=009c026845b2e38657c54c21a32985fab828b76c", "patch": "@@ -228,6 +228,7 @@ package System.OS_Interface is\n    ---------\n \n    function lwp_self return System.Address;\n+   pragma Import (C, lwp_self, \"__gnat_lwp_self\");\n    --  Return the mach thread bound to the current thread.  The value is not\n    --  used by the run-time library but made available to debuggers.\n "}]}