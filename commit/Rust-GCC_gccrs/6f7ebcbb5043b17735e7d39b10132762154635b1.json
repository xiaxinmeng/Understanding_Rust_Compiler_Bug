{"sha": "6f7ebcbb5043b17735e7d39b10132762154635b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3ZWJjYmI1MDQzYjE3NzM1ZTdkMzliMTAxMzI3NjIxNTQ2MzViMQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-12-22T18:22:03Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-12-22T18:22:03Z"}, "message": "Prevent LR from being used by 2nd cond exec pass.\n\nFrom-SVN: r38467", "tree": {"sha": "d5ec2ba16f6c16dbdb3da1dcf8a8c8a9d3448e92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5ec2ba16f6c16dbdb3da1dcf8a8c8a9d3448e92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f7ebcbb5043b17735e7d39b10132762154635b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7ebcbb5043b17735e7d39b10132762154635b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f7ebcbb5043b17735e7d39b10132762154635b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f7ebcbb5043b17735e7d39b10132762154635b1/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b53ef1a25fb257dac1b951f9f1c440a97ce39bbc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53ef1a25fb257dac1b951f9f1c440a97ce39bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b53ef1a25fb257dac1b951f9f1c440a97ce39bbc"}], "stats": {"total": 71, "additions": 50, "deletions": 21}, "files": [{"sha": "eebb4aae1d4449ba0b90aa068f294ec43df8114b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7ebcbb5043b17735e7d39b10132762154635b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7ebcbb5043b17735e7d39b10132762154635b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f7ebcbb5043b17735e7d39b10132762154635b1", "patch": "@@ -1,5 +1,18 @@\n 2000-12-22  Nick Clifton  <nickc@redhat.com>\n \n+\t* config/arm/arm.h (struct machine_function): Add new field\n+\t'lr_save_eliminated'.\n+\t* config/arm/arm.c (arm_compute_save_reg_mask): Do not include the\n+\tlink register if its save has been eliminated.\n+\t(output_arm_prologue): Mention if the save of the link register\n+\thas been eliminated.\n+\t(output_arm_epilogue): Rename 'live_regs_mask' to\n+\t'saved_regs_mask'.\n+\tTest 'saved_regs_mask' for the link register, not regs_ever_live.\n+\t(arm_expand_prologue): If the link register has not been saved set\n+\tlr_save_eliminated and emit a USE to prevent later passes from\n+\tscavenging it.\n+\t\n \t* dwarf2out_frame_debug_expr: Allow the (scratch) frame\n \tpointer to be initialised from the stack pointer plus a\n \tconstant."}, {"sha": "7e092c4f8524a9b869975f0a0e7e0a34bde94803", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7ebcbb5043b17735e7d39b10132762154635b1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7ebcbb5043b17735e7d39b10132762154635b1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6f7ebcbb5043b17735e7d39b10132762154635b1", "patch": "@@ -587,13 +587,13 @@ arm_override_options ()\n   arm_arch4         = (insn_flags & FL_ARCH4) != 0;\n   arm_arch5         = (insn_flags & FL_ARCH5) != 0;\n   arm_is_xscale     = (insn_flags & FL_XSCALE) != 0;\n-  \n+\n   arm_ld_sched      = (tune_flags & FL_LDSCHED) != 0;\n   arm_is_strong     = (tune_flags & FL_STRONG) != 0;\n   thumb_code\t    = (TARGET_ARM == 0);\n   arm_is_6_or_7     = (((tune_flags & (FL_MODE26 | FL_MODE32))\n \t\t       && !(tune_flags & FL_ARCH4))) != 0;\n-  \n+\n   /* Default value for floating point code... if no co-processor\n      bus, then schedule for emulated floating point.  Otherwise,\n      assume the user has an FPA.\n@@ -1647,7 +1647,7 @@ arm_return_in_memory (type)\n \t a register are not allowed.  */\n       if (RETURN_IN_MEMORY (TREE_TYPE (field)))\n \treturn 1;\n-      \n+\n       /* Now check the remaining fields, if any.  Only bitfields are allowed,\n \t since they are not addressable.  */\n       for (field = TREE_CHAIN (field);\n@@ -6906,6 +6906,9 @@ arm_compute_save_reg_mask ()\n \t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)))\n     save_reg_mask |= 1 << LR_REGNUM;\n \n+  if (cfun->machine->lr_save_eliminated)\n+    save_reg_mask &= ~ (1 << LR_REGNUM);\n+\n   return save_reg_mask;\n }\n \n@@ -7204,6 +7207,9 @@ output_arm_prologue (f, frame_size)\n \t       frame_pointer_needed,\n \t       current_function_anonymous_args);\n \n+  if (cfun->machine->lr_save_eliminated)\n+    asm_fprintf (f, \"\\t%@ link register save eliminated.\\n\");\n+\n #ifdef AOF_ASSEMBLER\n   if (flag_pic)\n     asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", IP_REGNUM, PIC_OFFSET_TABLE_REGNUM);\n@@ -7217,7 +7223,7 @@ arm_output_epilogue (really_return)\n      int really_return;\n {\n   int reg;\n-  unsigned long live_regs_mask;\n+  unsigned long saved_regs_mask;\n   unsigned long func_type;\n   /* If we need this, then it will always be at least this much.  */\n   int floats_offset = 12;\n@@ -7255,11 +7261,11 @@ arm_output_epilogue (really_return)\n        be doing a return,  so we can't tail-call.  */\n     abort ();\n   \n-  live_regs_mask = arm_compute_save_reg_mask ();\n+  saved_regs_mask = arm_compute_save_reg_mask ();\n   \n   /* Compute how far away the floats will be.  */\n   for (reg = 0; reg <= LAST_ARM_REGNUM; reg ++)\n-    if (live_regs_mask & (1 << reg))\n+    if (saved_regs_mask & (1 << reg))\n       floats_offset += 4;\n   \n   if (frame_pointer_needed)\n@@ -7309,27 +7315,27 @@ arm_output_epilogue (really_return)\n \t\t\t FP_REGNUM, floats_offset);\n \t}\n \n-      /* live_regs_mask should contain the IP, which at the time of stack\n+      /* saved_regs_mask should contain the IP, which at the time of stack\n \t frame generation actually contains the old stack pointer.  So a\n \t quick way to unwind the stack is just pop the IP register directly\n \t into the stack pointer.  */\n-      if ((live_regs_mask & (1 << IP_REGNUM)) == 0)\n+      if ((saved_regs_mask & (1 << IP_REGNUM)) == 0)\n \tabort ();\n-      live_regs_mask &= ~ (1 << IP_REGNUM);\n-      live_regs_mask |=   (1 << SP_REGNUM);\n+      saved_regs_mask &= ~ (1 << IP_REGNUM);\n+      saved_regs_mask |=   (1 << SP_REGNUM);\n \n-      /* There are two registers left in live_regs_mask - LR and PC.  We\n+      /* There are two registers left in saved_regs_mask - LR and PC.  We\n \t only need to restore the LR register (the return address), but to\n \t save time we can load it directly into the PC, unless we need a\n \t special function exit sequence, or we are not really returning.  */\n       if (really_return && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)\n \t/* Delete the LR from the register mask, so that the LR on\n \t   the stack is loaded into the PC in the register mask.  */\n-\tlive_regs_mask &= ~ (1 << LR_REGNUM);\n+\tsaved_regs_mask &= ~ (1 << LR_REGNUM);\n       else\n-\tlive_regs_mask &= ~ (1 << PC_REGNUM);\n+\tsaved_regs_mask &= ~ (1 << PC_REGNUM);\n       \n-      print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask);\n+      print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, saved_regs_mask);\n     }\n   else\n     {\n@@ -7385,15 +7391,15 @@ arm_output_epilogue (really_return)\n       if (ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n \t  && really_return\n \t  && current_function_pretend_args_size == 0\n-\t  && regs_ever_live [LR_REGNUM])\n+\t  && saved_regs_mask & (1 << LR_REGNUM))\n \t{\n-\t  live_regs_mask &= ~ (1 << LR_REGNUM);\n-\t  live_regs_mask |=   (1 << PC_REGNUM);\n+\t  saved_regs_mask &= ~ (1 << LR_REGNUM);\n+\t  saved_regs_mask |=   (1 << PC_REGNUM);\n \t}\n \n       /* Load the registers off the stack.  If we only have one register\n \t to load use the LDR instruction - it is faster.  */\n-      if (live_regs_mask == (1 << LR_REGNUM))\n+      if (saved_regs_mask == (1 << LR_REGNUM))\n \t{\n \t  /* The excpetion handler ignores the LR, so we do\n \t     not really need to load it off the stack.  */\n@@ -7402,8 +7408,8 @@ arm_output_epilogue (really_return)\n \t  else\n \t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n \t}\n-      else if (live_regs_mask)\n-\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask);\n+      else if (saved_regs_mask)\n+\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, saved_regs_mask);\n \n       if (current_function_pretend_args_size)\n \t{\n@@ -7452,7 +7458,7 @@ arm_output_epilogue (really_return)\n \t   here.  */\n \t;\n       else if (current_function_pretend_args_size == 0\n-\t       && regs_ever_live [LR_REGNUM])\n+\t       && (saved_regs_mask & (1 << LR_REGNUM)))\n \t/* Similarly we may have been able to load LR into the PC\n \t   even if we did not create a stack frame.  */\n \t;\n@@ -7879,6 +7885,14 @@ arm_expand_prologue ()\n      scheduling in the prolog.  */\n   if (profile_flag || profile_block_flag || TARGET_NO_SCHED_PRO)\n     emit_insn (gen_blockage ());\n+\n+  /* If the link register is being kept alive, with the return address in it,\n+     then make sure that it does not get reused by the ce2 pass.  */\n+  if ((live_regs_mask & (1 << LR_REGNUM)) == 0)\n+    {\n+      emit_insn (gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, LR_REGNUM)));\n+      cfun->machine->lr_save_eliminated = 1;\n+    }\n }\n \f\n /* If CODE is 'd', then the X is a condition operand and the instruction"}, {"sha": "68affb42b5a7b645365c6ad9bb29c527b874c386", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f7ebcbb5043b17735e7d39b10132762154635b1/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f7ebcbb5043b17735e7d39b10132762154635b1/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6f7ebcbb5043b17735e7d39b10132762154635b1", "patch": "@@ -1444,6 +1444,8 @@ typedef struct machine_function\n   int far_jump_used;\n   /* Records if ARG_POINTER was ever live.  */\n   int arg_pointer_live;\n+  /* Records if the save of LR has been eliminated.  */\n+  int lr_save_eliminated;\n   /* Records the type of the current function.  */\n   unsigned long func_type;\n }"}]}