{"sha": "245fc6392879dd2493d4be97cbd01c64d0a61adf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ1ZmM2MzkyODc5ZGQyNDkzZDRiZTk3Y2JkMDFjNjRkMGE2MWFkZg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-01-23T15:14:59Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2006-01-23T15:14:59Z"}, "message": "r110122@banpei: zack | 2006-01-22 14:41:17 -0800\n\n r110122@banpei:  zack | 2006-01-22 14:41:17 -0800\n \t* genextract.c: Don't include insn-config.h.  Do include vec.h.\n         Declare vectors of int, char, and locstr.\n         (locstr): New typedef.\n         (struct extraction): Make all array fields into bare pointers.\n         (insn_name_ptr, insn_name_ptr_size): Move down by get_insn_name.\n         (insn_code_number): Delete.\n         (accum_extract): New struct.\n         (VEC_safe_set_locstr, VEC_char_to_string): New functions.\n         (gen_insn): Take insn_code_number as an argument.  Use an\n         accum_extract structure instead of loading data directly into\n         a struct extraction, and having to know how big it might get.\n         (walk_rtx): Operate entirely on an accum_extract structure.\n         (print_path): Avoid unnecessary use of printf.\n         (print_header): New function, split out of main.  Distinguish\n         more carefully between an unrecognizable insn and an insn that\n         has the code number of a define_expand.\n         (main): Pass insn_code_number to gen_insn.  Call print_header\n         only after parsing.  Avoid unnecessary use of printf.\n         * Makefile.in (build/vec.o): New rule.\n         (build/genextract): Depend on build/vec.o.\n         (build/genextract.o): Don't depend on insn-config.h.\n\nFrom-SVN: r110118", "tree": {"sha": "44bbde76abf99e1ceeb5bf0420cf8e1a2d685e6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44bbde76abf99e1ceeb5bf0420cf8e1a2d685e6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/245fc6392879dd2493d4be97cbd01c64d0a61adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245fc6392879dd2493d4be97cbd01c64d0a61adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245fc6392879dd2493d4be97cbd01c64d0a61adf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245fc6392879dd2493d4be97cbd01c64d0a61adf/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbbbdc2cccf6ab0d0cc7eaeae4ce6b64338c51a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbbbdc2cccf6ab0d0cc7eaeae4ce6b64338c51a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbbbdc2cccf6ab0d0cc7eaeae4ce6b64338c51a1"}], "stats": {"total": 453, "additions": 246, "deletions": 207}, "files": [{"sha": "8f01cd23c135dea2ce20c7e4ceb62885e6bf428d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=245fc6392879dd2493d4be97cbd01c64d0a61adf", "patch": "@@ -1,3 +1,27 @@\n+2006-01-22  Zack Weinberg  <zackw@panix.com>\n+\n+\t* genextract.c: Don't include insn-config.h.  Do include vec.h.\n+\tDeclare vectors of int, char, and locstr.\n+\t(locstr): New typedef.\n+\t(struct extraction): Make all array fields into bare pointers.\n+\t(insn_name_ptr, insn_name_ptr_size): Move down by get_insn_name.\n+\t(insn_code_number): Delete.\n+\t(accum_extract): New struct.\n+\t(VEC_safe_set_locstr, VEC_char_to_string): New functions.\n+\t(gen_insn): Take insn_code_number as an argument.  Use an\n+\taccum_extract structure instead of loading data directly into\n+\ta struct extraction, and having to know how big it might get.\n+\t(walk_rtx): Operate entirely on an accum_extract structure.\n+\t(print_path): Avoid unnecessary use of printf.\n+\t(print_header): New function, split out of main.  Distinguish\n+\tmore carefully between an unrecognizable insn and an insn that\n+\thas the code number of a define_expand.\n+\t(main): Pass insn_code_number to gen_insn.  Call print_header\n+\tonly after parsing.  Avoid unnecessary use of printf.\n+\t* Makefile.in (build/vec.o): New rule.\n+\t(build/genextract): Depend on build/vec.o.\n+\t(build/genextract.o): Don't depend on insn-config.h.\n+\n 2006-01-22  Zack Weinberg  <zackw@panix.com>\n \n \t* Makefile.in: Consolidate most rules that use $(CC_FOR_BUILD) and/or"}, {"sha": "68bbb698f3cfa0bd87f1adfcaad6ad3c2cf134f2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=245fc6392879dd2493d4be97cbd01c64d0a61adf", "patch": "@@ -2876,6 +2876,8 @@ build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(RTL_H) real.h $(GGC_H) errors.h\n build/varray.o: varray.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(VARRAY_H) $(RTL_BASE_H) $(GGC_H) $(TREE_H) bitmap.h errors.h\n+build/vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h \\\n+   $(GGC_H) toplev.h\n build/insn-conditions.o : insn-conditions.c $(CONFIG_H) $(SYSTEM_H)\t\\\n   $(GTM_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) $(RECOG_H) real.h\t\\\n   output.h $(FLAGS_H) hard-reg-set.h $(RESOURCE_H) toplev.h reload.h\t\\\n@@ -2904,7 +2906,7 @@ build/genconstants.o : genconstants.c $(RTL_BASE_H) $(BCONFIG_H)\t\\\n build/genemit.o : genemit.c $(RTL_BASE_H) $(BCONFIG_H) $(SYSTEM_H)\t\\\n   coretypes.h $(GTM_H) errors.h gensupport.h\n build/genextract.o : genextract.c $(RTL_BASE_H) $(BCONFIG_H)\t\t\\\n-  $(SYSTEM_H) coretypes.h $(GTM_H) insn-config.h errors.h gensupport.h\n+  $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h\n build/genflags.o : genflags.c $(RTL_BASE_H) $(OBSTACK_H) $(BCONFIG_H)\t\\\n   $(SYSTEM_H) coretypes.h $(GTM_H) errors.h gensupport.h\n build/gengenrtl.o : gengenrtl.c $(BCONFIG_H) $(SYSTEM_H) rtl.def\n@@ -2952,6 +2954,7 @@ build/genpreds$(build_exeext) : $(BUILD_PRINT)\n \n build/gengenrtl$(build_exeext) : $(BUILD_ERRORS)\n build/genmodes$(build_exeext) : $(BUILD_ERRORS)\n+build/genextract$(build_exeext): build/vec.o\n \n # These programs are made from more than one source file.\n # The primary source file comes from the pattern rule above."}, {"sha": "1fd684228cf4323d2fdb969f188b66a614e6ce74", "filename": "gcc/genextract.c", "status": "modified", "additions": 218, "deletions": 206, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=245fc6392879dd2493d4be97cbd01c64d0a61adf", "patch": "@@ -27,9 +27,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"errors.h\"\n-#include \"insn-config.h\"\n #include \"gensupport.h\"\n-\n+#include \"vec.h\"\n \n /* This structure contains all the information needed to describe one\n    set of extractions methods.  Each method may be used by more than\n@@ -41,160 +40,192 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    of an rtl expression is a vector.  genrecog.c makes the same assumption\n    (and uses the same representation) and it is currently true.  */\n \n+typedef char *locstr;\n+\n struct extraction\n {\n-  int op_count;\n-  char *oplocs[MAX_RECOG_OPERANDS];\n-  int dup_count;\n-  char *duplocs[MAX_DUP_OPERANDS];\n-  int dupnums[MAX_DUP_OPERANDS];\n+  unsigned int op_count;\n+  unsigned int dup_count;\n+  locstr *oplocs;\n+  locstr *duplocs;\n+  int *dupnums;\n   struct code_ptr *insns;\n   struct extraction *next;\n };\n \n-/* Holds a single insn code that use an extraction method.  */\n-\n+/* Holds a single insn code that uses an extraction method.  */\n struct code_ptr\n {\n   int insn_code;\n   struct code_ptr *next;\n };\n \n+/* All extractions needed for this machine description.  */\n static struct extraction *extractions;\n \n-/* Holds an array of names indexed by insn_code_number.  */\n-static char **insn_name_ptr = 0;\n-static int insn_name_ptr_size = 0;\n-\n-/* Number instruction patterns handled, starting at 0 for first one.  */\n-\n-static int insn_code_number;\n-\n-/* Records the large operand number in this insn.  */\n-\n-static int op_count;\n-\n-/* Records the location of any operands using the string format described\n-   above.  */\n-\n-static char *oplocs[MAX_RECOG_OPERANDS];\n-\n-/* Number the occurrences of MATCH_DUP in each instruction,\n-   starting at 0 for the first occurrence.  */\n-\n-static int dup_count;\n-\n-/* Records the location of any MATCH_DUP operands.  */\n-\n-static char *duplocs[MAX_DUP_OPERANDS];\n-\n-/* Record the operand number of any MATCH_DUPs.  */\n+/* All insn codes for old-style peepholes.  */\n+static struct code_ptr *peepholes;\n \n-static int dupnums[MAX_DUP_OPERANDS];\n+/* This structure is used by gen_insn and walk_rtx to accumulate the\n+   data that will be used to produce an extractions structure.  */\n \n-/* Record the list of insn_codes for peepholes.  */\n+DEF_VEC_I(int);\n+DEF_VEC_I(char);\n+DEF_VEC_P(locstr);\n+DEF_VEC_ALLOC_I(int,heap);\n+DEF_VEC_ALLOC_I(char,heap);\n+DEF_VEC_ALLOC_P(locstr,heap);\n \n-static struct code_ptr *peepholes;\n+struct accum_extract\n+{\n+  VEC(locstr,heap) *oplocs;\n+  VEC(locstr,heap) *duplocs;\n+  VEC(int,heap)    *dupnums;\n+  VEC(char,heap)   *pathstr;\n+};\n \n-static void gen_insn (rtx);\n-static void walk_rtx (rtx, const char *);\n-static void print_path (const char *);\n+/* Forward declarations.  */\n+static void walk_rtx (rtx, struct accum_extract *);\n static void record_insn_name (int, const char *);\n \n static void\n-gen_insn (rtx insn)\n+gen_insn (rtx insn, int insn_code_number)\n {\n   int i;\n+  unsigned int op_count, dup_count, j;\n   struct extraction *p;\n   struct code_ptr *link;\n+  struct accum_extract acc;\n \n-  op_count = 0;\n-  dup_count = 0;\n-\n-  /* No operands seen so far in this pattern.  */\n-  memset (oplocs, 0, sizeof oplocs);\n+  acc.oplocs  = VEC_alloc (locstr,heap, 10);\n+  acc.duplocs = VEC_alloc (locstr,heap, 10);\n+  acc.dupnums = VEC_alloc (int,heap,    10);\n+  acc.pathstr = VEC_alloc (char,heap,   20);\n \n   /* Walk the insn's pattern, remembering at all times the path\n      down to the walking point.  */\n \n   if (XVECLEN (insn, 1) == 1)\n-    walk_rtx (XVECEXP (insn, 1, 0), \"\");\n+    walk_rtx (XVECEXP (insn, 1, 0), &acc);\n   else\n     for (i = XVECLEN (insn, 1) - 1; i >= 0; i--)\n       {\n-\tchar path[2];\n-\n-\tpath[0] = 'a' + i;\n-\tpath[1] = 0;\n-\n-\twalk_rtx (XVECEXP (insn, 1, i), path);\n+\tVEC_safe_push (char,heap, acc.pathstr, 'a' + i);\n+\twalk_rtx (XVECEXP (insn, 1, i), &acc);\n+\tVEC_pop (char, acc.pathstr);\n       }\n \n-  link = xmalloc (sizeof (struct code_ptr));\n+  link = XNEW (struct code_ptr);\n   link->insn_code = insn_code_number;\n \n   /* See if we find something that already had this extraction method.  */\n \n+  op_count = VEC_length (locstr, acc.oplocs);\n+  dup_count = VEC_length (locstr, acc.duplocs);\n+  gcc_assert (dup_count == VEC_length (int, acc.dupnums));\n+\n   for (p = extractions; p; p = p->next)\n     {\n       if (p->op_count != op_count || p->dup_count != dup_count)\n \tcontinue;\n \n-      for (i = 0; i < op_count; i++)\n-\tif (p->oplocs[i] != oplocs[i]\n-\t    && ! (p->oplocs[i] != 0 && oplocs[i] != 0\n-\t\t  && ! strcmp (p->oplocs[i], oplocs[i])))\n-\t  break;\n+      for (j = 0; j < op_count; j++)\n+\t{\n+\t  char *a = p->oplocs[j];\n+\t  char *b = VEC_index (locstr, acc.oplocs, j);\n+\t  if (a != b && (!a || !b || strcmp (a, b)))\n+\t    break;\n+\t}\n \n-      if (i != op_count)\n+      if (j != op_count)\n \tcontinue;\n \n-      for (i = 0; i < dup_count; i++)\n-\tif (p->dupnums[i] != dupnums[i]\n-\t    || strcmp (p->duplocs[i], duplocs[i]))\n+      for (j = 0; j < dup_count; j++)\n+\tif (p->dupnums[j] != VEC_index (int, acc.dupnums, j)\n+\t    || strcmp (p->duplocs[j], VEC_index (locstr, acc.duplocs, j)))\n \t  break;\n \n-      if (i != dup_count)\n+      if (j != dup_count)\n \tcontinue;\n \n       /* This extraction is the same as ours.  Just link us in.  */\n       link->next = p->insns;\n       p->insns = link;\n-      return;\n+      goto done;\n     }\n \n-  /* Otherwise, make a new extraction method.  */\n+  /* Otherwise, make a new extraction method.  We stash the arrays\n+     after the extraction structure in memory.  */\n \n-  p = xmalloc (sizeof (struct extraction));\n+  p = xmalloc (sizeof (struct extraction)\n+\t       + op_count*sizeof (char *)\n+\t       + dup_count*sizeof (char *)\n+\t       + dup_count*sizeof (int));\n   p->op_count = op_count;\n   p->dup_count = dup_count;\n   p->next = extractions;\n   extractions = p;\n   p->insns = link;\n   link->next = 0;\n \n-  for (i = 0; i < op_count; i++)\n-    p->oplocs[i] = oplocs[i];\n+  p->oplocs = (char **)((char *)p + sizeof (struct extraction));\n+  p->duplocs = p->oplocs + op_count;\n+  p->dupnums = (int *)(p->duplocs + dup_count);\n \n-  for (i = 0; i < dup_count; i++)\n-    p->dupnums[i] = dupnums[i], p->duplocs[i] = duplocs[i];\n+  memcpy(p->oplocs,  VEC_address(locstr,acc.oplocs),   op_count*sizeof(locstr));\n+  memcpy(p->duplocs, VEC_address(locstr,acc.duplocs), dup_count*sizeof(locstr));\n+  memcpy(p->dupnums, VEC_address(int,   acc.dupnums), dup_count*sizeof(int));\n+\n+ done:\n+  VEC_free (locstr,heap, acc.oplocs);\n+  VEC_free (locstr,heap, acc.duplocs);\n+  VEC_free (int,heap,    acc.dupnums);\n+  VEC_free (char,heap,   acc.pathstr);\n }\n \f\n+/* Helper subroutine of walk_rtx: given a VEC(locstr), an index, and a\n+   string, insert the string at the index, which should either already\n+   exist and be NULL, or not yet exist within the vector.  In the latter\n+   case the vector is enlarged as appropriate.  */\n static void\n-walk_rtx (rtx x, const char *path)\n+VEC_safe_set_locstr (VEC(locstr,heap) *v, unsigned int ix, char *str)\n+{\n+  if (ix < VEC_length (locstr, v))\n+    {\n+      gcc_assert (VEC_index (locstr, v, ix) == 0);\n+      VEC_replace (locstr, v, ix, str);\n+    }\n+  else\n+    {\n+      while (ix > VEC_length (locstr, v))\n+\tVEC_safe_push (locstr,heap, v, 0);\n+      VEC_safe_push (locstr,heap, v, str);\n+    }\n+}\n+\n+/* Another helper subroutine of walk_rtx: given a VEC(char), convert it\n+   to a NUL-terminated string in malloc memory.  */\n+static char *\n+VEC_char_to_string (VEC(char,heap) *v)\n+{\n+  size_t n = VEC_length (char, v);\n+  char *s = xmalloc (n + 1);\n+  memcpy (s, VEC_address (char, v), n);\n+  s[n] = '\\0';\n+  return s;\n+}\n+\n+static void\n+walk_rtx (rtx x, struct accum_extract *acc)\n {\n   RTX_CODE code;\n-  int i;\n-  int len;\n+  int i, len, base;\n   const char *fmt;\n-  int depth = strlen (path);\n-  char *newpath;\n \n   if (x == 0)\n     return;\n \n   code = GET_CODE (x);\n-\n   switch (code)\n     {\n     case PC:\n@@ -205,98 +236,68 @@ walk_rtx (rtx x, const char *path)\n \n     case MATCH_OPERAND:\n     case MATCH_SCRATCH:\n-      oplocs[XINT (x, 0)] = xstrdup (path);\n-      op_count = MAX (op_count, XINT (x, 0) + 1);\n+      VEC_safe_set_locstr (acc->oplocs, XINT (x, 0),\n+\t\t\t   VEC_char_to_string (acc->pathstr));\n       break;\n \n-    case MATCH_DUP:\n-      duplocs[dup_count] = xstrdup (path);\n-      dupnums[dup_count] = XINT (x, 0);\n-      dup_count++;\n-      break;\n-\n-    case MATCH_PAR_DUP:\n-    case MATCH_OP_DUP:\n-      duplocs[dup_count] = xstrdup (path);\n-      dupnums[dup_count] = XINT (x, 0);\n-      dup_count++;\n-\n-      newpath = xmalloc (depth + 2);\n-      strcpy (newpath, path);\n-      newpath[depth + 1] = 0;\n-\n-      for (i = XVECLEN (x, 1) - 1; i >= 0; i--)\n-        {\n-\t  newpath[depth] = (code == MATCH_OP_DUP ? '0' : 'a') + i;\n-\t  walk_rtx (XVECEXP (x, 1, i), newpath);\n-        }\n-      free (newpath);\n-      return;\n-\n     case MATCH_OPERATOR:\n-      oplocs[XINT (x, 0)] = xstrdup (path);\n-      op_count = MAX (op_count, XINT (x, 0) + 1);\n-\n-      newpath = xmalloc (depth + 2);\n-      strcpy (newpath, path);\n-      newpath[depth + 1] = 0;\n+    case MATCH_PARALLEL:\n+      VEC_safe_set_locstr (acc->oplocs, XINT (x, 0),\n+\t\t\t   VEC_char_to_string (acc->pathstr));\n \n+      base = (code == MATCH_OPERATOR ? '0' : 'a');\n       for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n \t{\n-\t  newpath[depth] = '0' + i;\n-\t  walk_rtx (XVECEXP (x, 2, i), newpath);\n-\t}\n-      free (newpath);\n+\t  VEC_safe_push (char,heap, acc->pathstr, base + i);\n+\t  walk_rtx (XVECEXP (x, 2, i), acc);\n+\t  VEC_pop (char, acc->pathstr);\n+        }\n       return;\n \n-    case MATCH_PARALLEL:\n-      oplocs[XINT (x, 0)] = xstrdup (path);\n-      op_count = MAX (op_count, XINT (x, 0) + 1);\n-\n-      newpath = xmalloc (depth + 2);\n-      strcpy (newpath, path);\n-      newpath[depth + 1] = 0;\n+    case MATCH_DUP:\n+    case MATCH_PAR_DUP:\n+    case MATCH_OP_DUP:\n+      VEC_safe_push (locstr,heap, acc->duplocs,\n+\t\t     VEC_char_to_string (acc->pathstr));\n+      VEC_safe_push (int,heap, acc->dupnums, XINT (x, 0));\n \n-      for (i = XVECLEN (x, 2) - 1; i >= 0; i--)\n-\t{\n-\t  newpath[depth] = 'a' + i;\n-\t  walk_rtx (XVECEXP (x, 2, i), newpath);\n-\t}\n-      free (newpath);\n-      return;\n+      if (code == MATCH_DUP)\n+\tbreak;\n \n-    case ADDRESS:\n-      walk_rtx (XEXP (x, 0), path);\n+      base = (code == MATCH_OP_DUP ? '0' : 'a');\n+      for (i = XVECLEN (x, 1) - 1; i >= 0; i--)\n+        {\n+\t  VEC_safe_push (char,heap, acc->pathstr, base + i);\n+\t  walk_rtx (XVECEXP (x, 1, i), acc);\n+\t  VEC_pop (char, acc->pathstr);\n+        }\n       return;\n \n     default:\n       break;\n     }\n \n-  newpath = xmalloc (depth + 2);\n-  strcpy (newpath, path);\n-  newpath[depth + 1] = 0;\n-\n   fmt = GET_RTX_FORMAT (code);\n   len = GET_RTX_LENGTH (code);\n   for (i = 0; i < len; i++)\n     {\n       if (fmt[i] == 'e' || fmt[i] == 'u')\n \t{\n-\t  newpath[depth] = '0' + i;\n-\t  walk_rtx (XEXP (x, i), newpath);\n+\t  VEC_safe_push (char,heap, acc->pathstr, '0' + i);\n+\t  walk_rtx (XEXP (x, i), acc);\n+\t  VEC_pop (char, acc->pathstr);\n \t}\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n-\t      newpath[depth] = 'a' + j;\n-\t      walk_rtx (XVECEXP (x, i, j), newpath);\n+\t      VEC_safe_push (char,heap, acc->pathstr, 'a' + j);\n+\t      walk_rtx (XVECEXP (x, i, j), acc);\n+\t      VEC_pop (char, acc->pathstr);\n \t    }\n \t}\n     }\n-  free (newpath);\n }\n \n /* Given a PATH, representing a path down the instruction's\n@@ -313,28 +314,28 @@ print_path (const char *path)\n     {\n       /* Don't emit \"pat\", since we may try to take the address of it,\n \t which isn't what is intended.  */\n-      printf(\"PATTERN (insn)\");\n+      fputs (\"PATTERN (insn)\", stdout);\n       return;\n     }\n \n   /* We first write out the operations (XEXP or XVECEXP) in reverse\n-     order, then write \"insn\", then the indices in forward order.  */\n+     order, then write \"pat\", then the indices in forward order.  */\n \n   for (i = len - 1; i >= 0 ; i--)\n     {\n-      if (ISLOWER(path[i]))\n-\tprintf (\"XVECEXP (\");\n-      else if (ISDIGIT(path[i]))\n-\tprintf (\"XEXP (\");\n+      if (ISLOWER (path[i]))\n+\tfputs (\"XVECEXP (\", stdout);\n+      else if (ISDIGIT (path[i]))\n+\tfputs (\"XEXP (\", stdout);\n       else\n \tgcc_unreachable ();\n     }\n \n-  printf (\"pat\");\n+  fputs (\"pat\", stdout);\n \n   for (i = 0; i < len; i++)\n     {\n-      if (ISLOWER(path[i]))\n+      if (ISLOWER (path[i]))\n \tprintf (\", 0, %d)\", path[i] - 'a');\n       else if (ISDIGIT(path[i]))\n \tprintf (\", %d)\", path[i] - '0');\n@@ -343,71 +344,81 @@ print_path (const char *path)\n     }\n }\n \f\n+static void\n+print_header (void)\n+{\n+  /* N.B. Code below avoids putting squiggle braces in column 1 inside\n+     a string, because this confuses some editors' syntax highlighting\n+     engines.  */\n+\n+  puts (\"\\\n+/* Generated automatically by the program `genextract'\\n\\\n+   from the machine description file `md'.  */\\n\\\n+\\n\\\n+#include \\\"config.h\\\"\\n\\\n+#include \\\"system.h\\\"\\n\\\n+#include \\\"coretypes.h\\\"\\n\\\n+#include \\\"tm.h\\\"\\n\\\n+#include \\\"rtl.h\\\"\\n\\\n+#include \\\"insn-config.h\\\"\\n\\\n+#include \\\"recog.h\\\"\\n\\\n+#include \\\"toplev.h\\\"\\n\\\n+\\n\\\n+/* This variable is used as the \\\"location\\\" of any missing operand\\n\\\n+   whose numbers are skipped by a given pattern.  */\\n\\\n+static rtx junk ATTRIBUTE_UNUSED;\\n\");\n+\n+  puts (\"\\\n+void\\n\\\n+insn_extract (rtx insn)\\n{\\n\\\n+  rtx *ro = recog_data.operand;\\n\\\n+  rtx **ro_loc = recog_data.operand_loc;\\n\\\n+  rtx pat = PATTERN (insn);\\n\\\n+  int i ATTRIBUTE_UNUSED; /* only for peepholes */\\n\\\n+\\n\\\n+#ifdef ENABLE_CHECKING\\n\\\n+  memset (ro, 0xab, sizeof (*ro) * MAX_RECOG_OPERANDS);\\n\\\n+  memset (ro_loc, 0xab, sizeof (*ro_loc) * MAX_RECOG_OPERANDS);\\n\\\n+#endif\\n\");\n+\n+  puts (\"\\\n+  switch (INSN_CODE (insn))\\n\\\n+    {\\n\\\n+    default:\\n\\\n+      /* Control reaches here if insn_extract has been called with an\\n\\\n+         unrecognizable insn (code -1), or an insn whose INSN_CODE\\n\\\n+         corresponds to a DEFINE_EXPAND in the machine description;\\n\\\n+         either way, a bug.  */\\n\\\n+      if (INSN_CODE (insn) < 0)\\n\\\n+        fatal_insn (\\\"unrecognizable insn:\\\", insn);\\n\\\n+      else\\n\\\n+        fatal_insn (\\\"insn with invalid code number:\\\", insn);\\n\");\n+}\n \n int\n main (int argc, char **argv)\n {\n   rtx desc;\n-  int i;\n+  unsigned int i;\n   struct extraction *p;\n   struct code_ptr *link;\n   const char *name;\n+  int insn_code_number;\n+  int line_no;\n \n   progname = \"genextract\";\n \n   if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n-  /* Assign sequential codes to all entries in the machine description\n-     in parallel with the tables in insn-output.c.  */\n-\n-  insn_code_number = 0;\n-\n-  printf (\"/* Generated automatically by the program `genextract'\\n\\\n-from the machine description file `md'.  */\\n\\n\");\n-\n-  printf (\"#include \\\"config.h\\\"\\n\");\n-  printf (\"#include \\\"system.h\\\"\\n\");\n-  printf (\"#include \\\"coretypes.h\\\"\\n\");\n-  printf (\"#include \\\"tm.h\\\"\\n\");\n-  printf (\"#include \\\"rtl.h\\\"\\n\");\n-  printf (\"#include \\\"insn-config.h\\\"\\n\");\n-  printf (\"#include \\\"recog.h\\\"\\n\");\n-  printf (\"#include \\\"toplev.h\\\"\\n\\n\");\n-\n-  /* This variable exists only so it can be the \"location\"\n-     of any missing operand whose numbers are skipped by a given pattern.  */\n-  printf (\"static rtx junk ATTRIBUTE_UNUSED;\\n\");\n-\n-  printf (\"void\\ninsn_extract (rtx insn)\\n\");\n-  printf (\"{\\n\");\n-  printf (\"  rtx *ro = recog_data.operand;\\n\");\n-  printf (\"  rtx **ro_loc = recog_data.operand_loc;\\n\");\n-  printf (\"  rtx pat = PATTERN (insn);\\n\");\n-  printf (\"  int i ATTRIBUTE_UNUSED;\\n\\n\");\n-#ifdef ENABLE_CHECKING\n-  printf (\"  memset (ro, 0xab, sizeof (*ro) * MAX_RECOG_OPERANDS);\\n\");\n-  printf (\"  memset (ro_loc, 0xab, sizeof (*ro_loc) * MAX_RECOG_OPERANDS);\\n\");\n-#endif\n-  printf (\"  switch (INSN_CODE (insn))\\n\");\n-  printf (\"    {\\n\");\n-  printf (\"    case -1:\\n\");\n-  printf (\"      fatal_insn_not_found (insn);\\n\\n\");\n-\n   /* Read the machine description.  */\n \n-  while (1)\n+  while ((desc = read_md_rtx (&line_no, &insn_code_number)) != NULL)\n     {\n-      int line_no;\n-\n-      desc = read_md_rtx (&line_no, &insn_code_number);\n-      if (desc == NULL)\n-\tbreak;\n-\n        if (GET_CODE (desc) == DEFINE_INSN)\n \t{\n \t  record_insn_name (insn_code_number, XSTR (desc, 0));\n-\t  gen_insn (desc);\n+\t  gen_insn (desc, insn_code_number);\n \t}\n \n       else if (GET_CODE (desc) == DEFINE_PEEPHOLE)\n@@ -420,6 +431,8 @@ from the machine description file `md'.  */\\n\\n\");\n \t}\n     }\n \n+  print_header ();\n+\n   /* Write out code to handle peepholes and the insn_codes that it should\n      be called for.  */\n   if (peepholes)\n@@ -432,9 +445,9 @@ from the machine description file `md'.  */\\n\\n\");\n \t created just for the sake of this function.  We need to set the\n \t location of the operands for sake of simplifications after\n \t extraction, like eliminating subregs.  */\n-      printf (\"      for (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\\n\");\n-      printf (\"          ro[i] = *(ro_loc[i] = &XVECEXP (pat, 0, i));\\n\");\n-      printf (\"      break;\\n\\n\");\n+      puts (\"      for (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\\n\"\n+\t    \"          ro[i] = *(ro_loc[i] = &XVECEXP (pat, 0, i));\\n\"\n+\t    \"      break;\\n\");\n     }\n \n   /* Write out all the ways to extract insn operands.  */\n@@ -461,33 +474,32 @@ from the machine description file `md'.  */\\n\\n\");\n \t    {\n \t      printf (\"      ro[%d] = *(ro_loc[%d] = &\", i, i);\n \t      print_path (p->oplocs[i]);\n-\t      printf (\");\\n\");\n+\t      puts (\");\");\n \t    }\n \t}\n \n       for (i = 0; i < p->dup_count; i++)\n \t{\n \t  printf (\"      recog_data.dup_loc[%d] = &\", i);\n \t  print_path (p->duplocs[i]);\n-\t  printf (\";\\n\");\n+\t  puts (\";\");\n \t  printf (\"      recog_data.dup_num[%d] = %d;\\n\", i, p->dupnums[i]);\n \t}\n \n-      printf (\"      break;\\n\\n\");\n+      puts (\"      break;\\n\");\n     }\n \n-  /* This should never be reached.  Note that we would also reach here\n-     if we tried to extract something whose INSN_CODE was a\n-     DEFINE_EXPAND or DEFINE_SPLIT, but that is correct.  */\n-  printf (\"    default:\\n      gcc_unreachable ();\\n\");\n-\n-  printf (\"    }\\n}\\n\");\n-\n+  puts (\"    }\\n}\");\n   fflush (stdout);\n   return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\n }\n \n /* Define this so we can link with print-rtl.o to get debug_rtx function.  */\n+\n+/* Holds an array of names indexed by insn_code_number.  */\n+static char **insn_name_ptr = 0;\n+static int insn_name_ptr_size = 0;\n+\n const char *\n get_insn_name (int code ATTRIBUTE_UNUSED)\n {"}]}