{"sha": "2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiNzc0MWZiZWVlMmY0ZmQ0NzJjZDdlOTc5MWFlMGI1NGU3YTJiNA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2020-07-07T21:29:44Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-19T09:53:39Z"}, "message": "[Ada] Expanded names in ghost assignments\n\ngcc/ada/\n\n\t* ghost.adb (Whole_Object_Ref): New function to compute the name\n\tof the whole object.\n\t(Mark_And_Set_Ghost_Assignment): Rewrite to use\n\tWhole_Object_Ref.  We need to partly analyze the left-hand side\n\tin order to distinguish expanded names and record components.\n\t* lib-xref.ads, lib-xref.adb (Deferred_References): Move table\n\tto body, and add Defer_Reference to update the table, avoiding\n\tduplicates.\n\t(Generate_Reference): Avoid duplicates.\n\t* sem_ch8.ads, sem_ch8.adb (Find_Direct_Name): Remove _OK\n\tparameters, which are no longer needed. Ignore errors in\n\tIgnore_Errors mode.\n\t* sem_util.ads, sem_util.adb (Preanalyze_Without_Errors): Make\n\tthis public, so we can call it from Ghost.\n\t* errout.ads, scng.adb, sem_prag.adb: Minor.", "tree": {"sha": "e44af8ff8c94c46657a321a5050f7c367f367855", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e44af8ff8c94c46657a321a5050f7c367f367855"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08b0a5e2002f7f43d7f5aa3b55e7c6c22ec3926d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b0a5e2002f7f43d7f5aa3b55e7c6c22ec3926d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b0a5e2002f7f43d7f5aa3b55e7c6c22ec3926d"}], "stats": {"total": 448, "additions": 246, "deletions": 202}, "files": [{"sha": "e46433fdf98105c568806faa764b7b1783157cf1", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -112,8 +112,8 @@ package Errout is\n    --        already placed an error (not warning) message at that location,\n    --        then we assume this is cascaded junk and delete the message.\n \n-   --  This normal suppression action may be overridden in cases 2-5 (but not\n-   --  in case 1 or 7 by setting All_Errors mode, or by setting the special\n+   --  This normal suppression action may be overridden in cases 2-5 (but\n+   --  not in case 1 or 7) by setting All_Errors mode, or by setting the\n    --  unconditional message insertion character (!) as described below.\n \n    ---------------------------------------------------------"}, {"sha": "866f7f78197623bfbd4c3a39caeb74f683525acc", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 85, "deletions": 50, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -34,7 +34,6 @@ with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Prag; use Sem_Prag;\n@@ -65,6 +64,12 @@ package body Ghost is\n    -- Local subprograms --\n    -----------------------\n \n+   function Whole_Object_Ref (Ref : Node_Id) return Node_Id;\n+   --  For a name that denotes an object, returns a name that denotes the whole\n+   --  object, declared by an object declaration, formal parameter declaration,\n+   --  etc. For example, for P.X.Comp (J), if P is a package X is a record\n+   --  object, this returns P.X.\n+\n    function Ghost_Entity (Ref : Node_Id) return Entity_Id;\n    pragma Inline (Ghost_Entity);\n    --  Obtain the entity of a Ghost entity from reference Ref. Return Empty if\n@@ -1009,10 +1014,8 @@ package body Ghost is\n       ----------------------------\n \n       function Ultimate_Original_Node (Nod : Node_Id) return Node_Id is\n-         Res : Node_Id;\n-\n+         Res : Node_Id := Nod;\n       begin\n-         Res := Nod;\n          while Original_Node (Res) /= Res loop\n             Res := Original_Node (Res);\n          end loop;\n@@ -1176,61 +1179,73 @@ package body Ghost is\n    -----------------------------------\n \n    procedure Mark_And_Set_Ghost_Assignment (N : Node_Id) is\n-      Orig_Lhs : constant Node_Id := Name (N);\n-      Orig_Ref : constant Node_Id := Ultimate_Prefix (Orig_Lhs);\n-\n-      Id  : Entity_Id;\n-      Ref : Node_Id;\n+      --  A ghost assignment is an assignment whose left-hand side denotes a\n+      --  ghost object. Subcomponents are not marked \"ghost\", so we need to\n+      --  find the containing \"whole\" object. So, for \"P.X.Comp (J) := ...\",\n+      --  where P is a package, X is a record, and Comp is an array, we need\n+      --  to check the ghost flags of X.\n \n+      Orig_Lhs : constant Node_Id := Name (N);\n    begin\n-      --  A reference to a whole Ghost object (SPARK RM 6.9(1)) appears as an\n-      --  identifier. If the reference has not been analyzed yet, preanalyze a\n-      --  copy of the reference to discover the nature of its entity.\n-\n-      if Nkind (Orig_Ref) = N_Identifier and then not Analyzed (Orig_Ref) then\n-         Ref := New_Copy_Tree (Orig_Ref);\n-\n-         --  Alter the assignment statement by setting its left-hand side to\n-         --  the copy.\n-\n-         Set_Name   (N, Ref);\n-         Set_Parent (Ref, N);\n-\n-         --  Preanalysis is carried out by looking for a Ghost entity while\n-         --  suppressing all possible side effects.\n-\n-         Find_Direct_Name\n-           (N            => Ref,\n-            Errors_OK    => False,\n-            Marker_OK    => False,\n-            Reference_OK => False);\n-\n-         --  Restore the original state of the assignment statement\n-\n-         Set_Name (N, Orig_Lhs);\n+      --  Ghost assignments are irrelevant when the expander is inactive, and\n+      --  processing them in that mode can lead to spurious errors.\n+\n+      if Expander_Active then\n+         if not Analyzed (Orig_Lhs)\n+           and then Nkind (Orig_Lhs) = N_Indexed_Component\n+           and then Nkind (Prefix (Orig_Lhs)) = N_Selected_Component\n+           and then Nkind (Prefix (Prefix (Orig_Lhs))) =\n+           N_Indexed_Component\n+         then\n+            Analyze (Orig_Lhs);\n+         end if;\n \n-      --  A potential reference to a Ghost entity is already properly resolved\n-      --  when the left-hand side is analyzed.\n+         --  Make sure Lhs is at least preanalyzed, so we can tell whether\n+         --  it denotes a ghost variable. In some cases we need to do a full\n+         --  analysis, or else the back end gets confused. Note that in the\n+         --  preanalysis case, we are preanalyzing a copy of the left-hand\n+         --  side name, temporarily attached to the tree.\n \n-      else\n-         Ref := Orig_Ref;\n-      end if;\n+         declare\n+            Lhs : constant Node_Id :=\n+              (if Analyzed (Orig_Lhs) then Orig_Lhs\n+               else New_Copy_Tree (Orig_Lhs));\n+         begin\n+            if not Analyzed (Lhs) then\n+               Set_Name   (N, Lhs);\n+               Set_Parent (Lhs, N);\n+               Preanalyze_Without_Errors (Lhs);\n+               Set_Name (N, Orig_Lhs);\n+            end if;\n \n-      --  An assignment statement becomes Ghost when its target denotes a Ghost\n-      --  object. Install the Ghost mode of the target.\n+            declare\n+               Whole : constant Node_Id := Whole_Object_Ref (Lhs);\n+               Id    : Entity_Id;\n+            begin\n+               if Is_Entity_Name (Whole) then\n+                  Id := Entity (Whole);\n \n-      Id := Ghost_Entity (Ref);\n+                  if Present (Id) then\n+                     --  Left-hand side denotes a Checked ghost entity, so\n+                     --  install the region.\n \n-      if Present (Id) then\n-         if Is_Checked_Ghost_Entity (Id) then\n-            Install_Ghost_Region (Check, N);\n+                     if Is_Checked_Ghost_Entity (Id) then\n+                        Install_Ghost_Region (Check, N);\n \n-         elsif Is_Ignored_Ghost_Entity (Id) then\n-            Install_Ghost_Region (Ignore, N);\n+                     --  Left-hand side denotes an Ignored ghost entity, so\n+                     --  install the region, and mark the assignment statement\n+                     --  as an ignored ghost assignment, so it will be removed\n+                     --  later.\n \n-            Set_Is_Ignored_Ghost_Node (N);\n-            Record_Ignored_Ghost_Node (N);\n-         end if;\n+                     elsif Is_Ignored_Ghost_Entity (Id) then\n+                        Install_Ghost_Region (Ignore, N);\n+                        Set_Is_Ignored_Ghost_Node (N);\n+                        Record_Ignored_Ghost_Node (N);\n+                     end if;\n+                  end if;\n+               end if;\n+            end;\n+         end;\n       end if;\n    end Mark_And_Set_Ghost_Assignment;\n \n@@ -1855,4 +1870,24 @@ package body Ghost is\n       end if;\n    end Set_Is_Ghost_Entity;\n \n+   ----------------------\n+   -- Whole_Object_Ref --\n+   ----------------------\n+\n+   function Whole_Object_Ref (Ref : Node_Id) return Node_Id is\n+   begin\n+      if Nkind (Ref) in N_Indexed_Component | N_Slice\n+        or else (Nkind (Ref) = N_Selected_Component\n+                   and then Is_Object_Reference (Prefix (Ref)))\n+      then\n+         if Is_Access_Type (Etype (Prefix (Ref))) then\n+            return Ref;\n+         else\n+            return Whole_Object_Ref (Prefix (Ref));\n+         end if;\n+      else\n+         return Ref;\n+      end if;\n+   end Whole_Object_Ref;\n+\n end Ghost;"}, {"sha": "64b9683a784000e084890fc118aabf41d9d86d23", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -53,6 +53,14 @@ package body Lib.Xref is\n    -- Declarations --\n    ------------------\n \n+   package Deferred_References is new Table.Table (\n+     Table_Component_Type => Deferred_Reference_Entry,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => 512,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Name_Deferred_References\");\n+\n    --  The Xref table is used to record references. The Loc field is set\n    --  to No_Location for a definition entry.\n \n@@ -199,6 +207,21 @@ package body Lib.Xref is\n       end if;\n    end Add_Entry;\n \n+   ---------------------\n+   -- Defer_Reference --\n+   ---------------------\n+\n+   procedure Defer_Reference (Deferred_Reference : Deferred_Reference_Entry) is\n+   begin\n+      --  If Get_Ignore_Errors, then we are in Preanalyze_Without_Errors, and\n+      --  we should not record cross references, because that will cause\n+      --  duplicates when we call Analyze.\n+\n+      if not Get_Ignore_Errors then\n+         Deferred_References.Append (Deferred_Reference);\n+      end if;\n+   end Defer_Reference;\n+\n    -----------\n    -- Equal --\n    -----------\n@@ -595,6 +618,14 @@ package body Lib.Xref is\n    --  Start of processing for Generate_Reference\n \n    begin\n+      --  If Get_Ignore_Errors, then we are in Preanalyze_Without_Errors, and\n+      --  we should not record cross references, because that will cause\n+      --  duplicates when we call Analyze.\n+\n+      if Get_Ignore_Errors then\n+         return;\n+      end if;\n+\n       --  May happen in case of severe errors\n \n       if Nkind (E) not in N_Entity then"}, {"sha": "6a7a9e5deb3dfbac72e9af3509ad3272251ec1a0", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -591,22 +591,17 @@ package Lib.Xref is\n \n    --  What we do in such cases is to gather nodes, where we would have liked\n    --  to call Generate_Reference but we couldn't because we didn't know enough\n-   --  into this table, then we deal with generating references later on when\n-   --  we have sufficient information to do it right.\n+   --  into a table, then we deal with generating references later on when we\n+   --  have sufficient information to do it right.\n \n    type Deferred_Reference_Entry is record\n       E : Entity_Id;\n       N : Node_Id;\n    end record;\n    --  One entry, E, N are as required for Generate_Reference call\n \n-   package Deferred_References is new Table.Table (\n-     Table_Component_Type => Deferred_Reference_Entry,\n-     Table_Index_Type     => Int,\n-     Table_Low_Bound      => 0,\n-     Table_Initial        => 512,\n-     Table_Increment      => 200,\n-     Table_Name           => \"Name_Deferred_References\");\n+   procedure Defer_Reference (Deferred_Reference : Deferred_Reference_Entry);\n+   --  Add one entry to the deferred reference table\n \n    procedure Process_Deferred_References;\n    --  This procedure is called from Frontend to process these table entries."}, {"sha": "162d8829fa73dd249e7014fdd77036e51b0f11ad", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -2574,7 +2574,7 @@ package body Scng is\n \n          Token := Tok_Identifier;\n \n-         --  Here is where we check if it was a keyword\n+         --  Check if it is a keyword\n \n          if Is_Keyword_Name (Token_Name) then\n             Accumulate_Token_Checksum;"}, {"sha": "19fa81d8dc08b208e49af9031b886b9ea0d60885", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 106, "deletions": 118, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -5013,12 +5013,7 @@ package body Sem_Ch8 is\n    -- Find_Direct_Name --\n    ----------------------\n \n-   procedure Find_Direct_Name\n-     (N            : Node_Id;\n-      Errors_OK    : Boolean := True;\n-      Marker_OK    : Boolean := True;\n-      Reference_OK : Boolean := True)\n-   is\n+   procedure Find_Direct_Name (N : Node_Id) is\n       E   : Entity_Id;\n       E2  : Entity_Id;\n       Msg : Boolean;\n@@ -5285,10 +5280,6 @@ package body Sem_Ch8 is\n          Item      : Node_Id;\n \n       begin\n-         if not Errors_OK then\n-            return;\n-         end if;\n-\n          --  Ada 2005 (AI-262): Generate a precise error concerning the\n          --  Beaujolais effect that was previously detected\n \n@@ -5456,8 +5447,7 @@ package body Sem_Ch8 is\n \n          --  Named aggregate should also be handled similarly ???\n \n-         if Errors_OK\n-           and then Nkind (N) = N_Identifier\n+         if Nkind (N) = N_Identifier\n            and then Nkind (Parent (N)) = N_Case_Statement_Alternative\n          then\n             declare\n@@ -5493,122 +5483,119 @@ package body Sem_Ch8 is\n          Set_Entity (N, Any_Id);\n          Set_Etype  (N, Any_Type);\n \n-         if Errors_OK then\n-\n-            --  We use the table Urefs to keep track of entities for which we\n-            --  have issued errors for undefined references. Multiple errors\n-            --  for a single name are normally suppressed, however we modify\n-            --  the error message to alert the programmer to this effect.\n-\n-            for J in Urefs.First .. Urefs.Last loop\n-               if Chars (N) = Chars (Urefs.Table (J).Node) then\n-                  if Urefs.Table (J).Err /= No_Error_Msg\n-                    and then Sloc (N) /= Urefs.Table (J).Loc\n-                  then\n-                     Error_Msg_Node_1 := Urefs.Table (J).Node;\n+         --  We use the table Urefs to keep track of entities for which we\n+         --  have issued errors for undefined references. Multiple errors\n+         --  for a single name are normally suppressed, however we modify\n+         --  the error message to alert the programmer to this effect.\n \n-                     if Urefs.Table (J).Nvis then\n-                        Change_Error_Text (Urefs.Table (J).Err,\n-                          \"& is not visible (more references follow)\");\n-                     else\n-                        Change_Error_Text (Urefs.Table (J).Err,\n-                          \"& is undefined (more references follow)\");\n-                     end if;\n+         for J in Urefs.First .. Urefs.Last loop\n+            if Chars (N) = Chars (Urefs.Table (J).Node) then\n+               if Urefs.Table (J).Err /= No_Error_Msg\n+                 and then Sloc (N) /= Urefs.Table (J).Loc\n+               then\n+                  Error_Msg_Node_1 := Urefs.Table (J).Node;\n \n-                     Urefs.Table (J).Err := No_Error_Msg;\n+                  if Urefs.Table (J).Nvis then\n+                     Change_Error_Text (Urefs.Table (J).Err,\n+                       \"& is not visible (more references follow)\");\n+                  else\n+                     Change_Error_Text (Urefs.Table (J).Err,\n+                       \"& is undefined (more references follow)\");\n                   end if;\n \n-                  --  Although we will set Msg False, and thus suppress the\n-                  --  message, we also set Error_Posted True, to avoid any\n-                  --  cascaded messages resulting from the undefined reference.\n-\n-                  Msg := False;\n-                  Set_Error_Posted (N);\n-                  return;\n+                  Urefs.Table (J).Err := No_Error_Msg;\n                end if;\n-            end loop;\n \n-            --  If entry not found, this is first undefined occurrence\n+               --  Although we will set Msg False, and thus suppress the\n+               --  message, we also set Error_Posted True, to avoid any\n+               --  cascaded messages resulting from the undefined reference.\n \n-            if Nvis then\n-               Error_Msg_N (\"& is not visible!\", N);\n-               Emsg := Get_Msg_Id;\n+               Msg := False;\n+               Set_Error_Posted (N);\n+               return;\n+            end if;\n+         end loop;\n \n-            else\n-               Error_Msg_N (\"& is undefined!\", N);\n-               Emsg := Get_Msg_Id;\n+         --  If entry not found, this is first undefined occurrence\n \n-               --  A very bizarre special check, if the undefined identifier\n-               --  is Put or Put_Line, then add a special error message (since\n-               --  this is a very common error for beginners to make).\n+         if Nvis then\n+            Error_Msg_N (\"& is not visible!\", N);\n+            Emsg := Get_Msg_Id;\n \n-               if Chars (N) in Name_Put | Name_Put_Line then\n-                  Error_Msg_N -- CODEFIX\n-                    (\"\\\\possible missing `WITH Ada.Text_'I'O; \" &\n-                     \"USE Ada.Text_'I'O`!\", N);\n+         else\n+            Error_Msg_N (\"& is undefined!\", N);\n+            Emsg := Get_Msg_Id;\n \n-               --  Another special check if N is the prefix of a selected\n-               --  component which is a known unit: add message complaining\n-               --  about missing with for this unit.\n+            --  A very bizarre special check, if the undefined identifier\n+            --  is Put or Put_Line, then add a special error message (since\n+            --  this is a very common error for beginners to make).\n \n-               elsif Nkind (Parent (N)) = N_Selected_Component\n-                 and then N = Prefix (Parent (N))\n-                 and then Is_Known_Unit (Parent (N))\n-               then\n-                  Error_Msg_Node_2 := Selector_Name (Parent (N));\n-                  Error_Msg_N -- CODEFIX\n-                    (\"\\\\missing `WITH &.&;`\", Prefix (Parent (N)));\n-               end if;\n+            if Chars (N) in Name_Put | Name_Put_Line then\n+               Error_Msg_N -- CODEFIX\n+                 (\"\\\\possible missing `WITH Ada.Text_'I'O; \" &\n+                  \"USE Ada.Text_'I'O`!\", N);\n \n-               --  Now check for possible misspellings\n+            --  Another special check if N is the prefix of a selected\n+            --  component which is a known unit: add message complaining\n+            --  about missing with for this unit.\n \n-               declare\n-                  E      : Entity_Id;\n-                  Ematch : Entity_Id := Empty;\n+            elsif Nkind (Parent (N)) = N_Selected_Component\n+              and then N = Prefix (Parent (N))\n+              and then Is_Known_Unit (Parent (N))\n+            then\n+               Error_Msg_Node_2 := Selector_Name (Parent (N));\n+               Error_Msg_N -- CODEFIX\n+                 (\"\\\\missing `WITH &.&;`\", Prefix (Parent (N)));\n+            end if;\n \n-                  Last_Name_Id : constant Name_Id :=\n-                                   Name_Id (Nat (First_Name_Id) +\n-                                              Name_Entries_Count - 1);\n+            --  Now check for possible misspellings\n \n-               begin\n-                  for Nam in First_Name_Id .. Last_Name_Id loop\n-                     E := Get_Name_Entity_Id (Nam);\n+            declare\n+               E      : Entity_Id;\n+               Ematch : Entity_Id := Empty;\n \n-                     if Present (E)\n-                        and then (Is_Immediately_Visible (E)\n-                                    or else\n-                                  Is_Potentially_Use_Visible (E))\n-                     then\n-                        if Is_Bad_Spelling_Of (Chars (N), Nam) then\n-                           Ematch := E;\n-                           exit;\n-                        end if;\n-                     end if;\n-                  end loop;\n+               Last_Name_Id : constant Name_Id :=\n+                                Name_Id (Nat (First_Name_Id) +\n+                                           Name_Entries_Count - 1);\n \n-                  if Present (Ematch) then\n-                     Error_Msg_NE -- CODEFIX\n-                       (\"\\possible misspelling of&\", N, Ematch);\n+            begin\n+               for Nam in First_Name_Id .. Last_Name_Id loop\n+                  E := Get_Name_Entity_Id (Nam);\n+\n+                  if Present (E)\n+                     and then (Is_Immediately_Visible (E)\n+                                 or else\n+                               Is_Potentially_Use_Visible (E))\n+                  then\n+                     if Is_Bad_Spelling_Of (Chars (N), Nam) then\n+                        Ematch := E;\n+                        exit;\n+                     end if;\n                   end if;\n-               end;\n-            end if;\n+               end loop;\n \n-            --  Make entry in undefined references table unless the full errors\n-            --  switch is set, in which case by refraining from generating the\n-            --  table entry we guarantee that we get an error message for every\n-            --  undefined reference. The entry is not added if we are ignoring\n-            --  errors.\n-\n-            if not All_Errors_Mode and then Ignore_Errors_Enable = 0 then\n-               Urefs.Append (\n-                 (Node => N,\n-                  Err  => Emsg,\n-                  Nvis => Nvis,\n-                  Loc  => Sloc (N)));\n-            end if;\n+               if Present (Ematch) then\n+                  Error_Msg_NE -- CODEFIX\n+                    (\"\\possible misspelling of&\", N, Ematch);\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Make entry in undefined references table unless the full errors\n+         --  switch is set, in which case by refraining from generating the\n+         --  table entry we guarantee that we get an error message for every\n+         --  undefined reference. The entry is not added if we are ignoring\n+         --  errors.\n \n-            Msg := True;\n+         if not All_Errors_Mode and then Ignore_Errors_Enable = 0 then\n+            Urefs.Append (\n+              (Node => N,\n+               Err  => Emsg,\n+               Nvis => Nvis,\n+               Loc  => Sloc (N)));\n          end if;\n+\n+         Msg := True;\n       end Undefined;\n \n       --  Local variables\n@@ -5731,6 +5718,12 @@ package body Sem_Ch8 is\n          E := Homonym (E);\n       end loop;\n \n+      --  If we are ignoring errors, skip the error processing\n+\n+      if Get_Ignore_Errors then\n+         return;\n+      end if;\n+\n       --  If no entries on homonym chain that were potentially visible,\n       --  and no entities reasonably considered as non-visible, then\n       --  we have a plain undefined reference, with no additional\n@@ -6050,7 +6043,7 @@ package body Sem_Ch8 is\n             --  If no homonyms were visible, the entity is unambiguous\n \n             if not Is_Overloaded (N) then\n-               if Reference_OK and then not Is_Actual_Parameter then\n+               if not Is_Actual_Parameter then\n                   Generate_Reference (E, N);\n                end if;\n             end if;\n@@ -6069,8 +6062,7 @@ package body Sem_Ch8 is\n             --  in SPARK mode where renamings are traversed for generating\n             --  local effects of subprograms.\n \n-            if Reference_OK\n-              and then Is_Object (E)\n+            if Is_Object (E)\n               and then Present (Renamed_Object (E))\n               and then not GNATprove_Mode\n             then\n@@ -6100,7 +6092,7 @@ package body Sem_Ch8 is\n                   --  Generate reference unless this is an actual parameter\n                   --  (see comment below).\n \n-                  if Reference_OK and then not Is_Actual_Parameter then\n+                  if not Is_Actual_Parameter then\n                      Generate_Reference (E, N);\n                      Set_Referenced (E, R);\n                   end if;\n@@ -6109,7 +6101,7 @@ package body Sem_Ch8 is\n             --  Normal case, not a label: generate reference\n \n             else\n-               if Reference_OK and then not Is_Actual_Parameter then\n+               if not Is_Actual_Parameter then\n \n                   --  Package or generic package is always a simple reference\n \n@@ -6129,7 +6121,7 @@ package body Sem_Ch8 is\n                         --  If we don't know now, generate reference later\n \n                         when Unknown =>\n-                           Deferred_References.Append ((E, N));\n+                           Defer_Reference ((E, N));\n                      end case;\n                   end if;\n                end if;\n@@ -6178,11 +6170,7 @@ package body Sem_Ch8 is\n       --  reference is a write when it appears on the left hand side of an\n       --  assignment.\n \n-      if Marker_OK\n-        and then Needs_Variable_Reference_Marker\n-                   (N        => N,\n-                    Calls_OK => False)\n-      then\n+      if Needs_Variable_Reference_Marker (N => N, Calls_OK => False) then\n          declare\n             Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n \n@@ -6746,7 +6734,7 @@ package body Sem_Ch8 is\n                Generate_Reference (Id, N, 'r');\n \n             when Unknown =>\n-               Deferred_References.Append ((Id, N));\n+               Defer_Reference ((Id, N));\n          end case;\n       end if;\n "}, {"sha": "fe5d5ee389f0a74076f8cc4d8b3ff9f9adb45cdf", "filename": "gcc/ada/sem_ch8.ads", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_ch8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_ch8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.ads?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -82,11 +82,7 @@ package Sem_Ch8 is\n    --  Subsidiaries of End_Use_Clauses. Also called directly for use clauses\n    --  appearing in context clauses.\n \n-   procedure Find_Direct_Name\n-     (N            : Node_Id;\n-      Errors_OK    : Boolean := True;\n-      Marker_OK    : Boolean := True;\n-      Reference_OK : Boolean := True);\n+   procedure Find_Direct_Name (N : Node_Id);\n    --  Given a direct name (Identifier or Operator_Symbol), this routine scans\n    --  the homonym chain for the name, searching for corresponding visible\n    --  entities to find the referenced entity (or in the case of overloading,"}, {"sha": "d9d957bc977d7afe44c19839b3fcbe13b54d1510", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -17021,7 +17021,7 @@ package body Sem_Prag is\n                      return;\n                   end if;\n \n-               --  Otherwie the expression is not static\n+               --  Otherwise the expression is not static\n \n                else\n                   Error_Pragma_Arg"}, {"sha": "d9a96c6cfccbb28960482bf55c48816229dc1c8c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -2544,10 +2544,6 @@ package body Sem_Util is\n       --  second occurrence, the error is reported, and the tree traversal\n       --  is abandoned.\n \n-      procedure Preanalyze_Without_Errors (N : Node_Id);\n-      --  Preanalyze N without reporting errors. Very dubious, you can't just\n-      --  go analyzing things more than once???\n-\n       -------------------------\n       -- Collect_Identifiers --\n       -------------------------\n@@ -2774,18 +2770,6 @@ package body Sem_Util is\n          Do_Traversal (N);\n       end Collect_Identifiers;\n \n-      -------------------------------\n-      -- Preanalyze_Without_Errors --\n-      -------------------------------\n-\n-      procedure Preanalyze_Without_Errors (N : Node_Id) is\n-         Status : constant Boolean := Get_Ignore_Errors;\n-      begin\n-         Set_Ignore_Errors (True);\n-         Preanalyze (N);\n-         Set_Ignore_Errors (Status);\n-      end Preanalyze_Without_Errors;\n-\n    --  Start of processing for Check_Function_Writable_Actuals\n \n    begin\n@@ -25057,6 +25041,18 @@ package body Sem_Util is\n       return Kind;\n    end Policy_In_Effect;\n \n+   -------------------------------\n+   -- Preanalyze_Without_Errors --\n+   -------------------------------\n+\n+   procedure Preanalyze_Without_Errors (N : Node_Id) is\n+      Status : constant Boolean := Get_Ignore_Errors;\n+   begin\n+      Set_Ignore_Errors (True);\n+      Preanalyze (N);\n+      Set_Ignore_Errors (Status);\n+   end Preanalyze_Without_Errors;\n+\n    -----------------------\n    -- Predicate_Enabled --\n    -----------------------"}, {"sha": "19116947a31a5443d5387ca211c3bb9732c1cac6", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2bb7741fbeee2f4fd472cd7e9791ae0b54e7a2b4", "patch": "@@ -3156,6 +3156,9 @@ package Sem_Util is\n    function Yields_Universal_Type (N : Node_Id) return Boolean;\n    --  Determine whether unanalyzed node N yields a universal type\n \n+   procedure Preanalyze_Without_Errors (N : Node_Id);\n+   --  Preanalyze N without reporting errors\n+\n    package Interval_Lists is\n       type Discrete_Interval is\n          record"}]}