{"sha": "b7244ccba711298c906d4c7ca51f9f49bf2438c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjcyNDRjY2JhNzExMjk4YzkwNmQ0YzdjYTUxZjlmNDliZjI0MzhjNw==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2018-05-03T12:59:43Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2018-05-03T12:59:43Z"}, "message": "[tree-complex.c] PR tree-optimization/70291: Inline floating-point complex multiplication more aggressively\n\nWe can improve the performance of complex floating-point multiplications by inlining the expansion a bit more aggressively.\nWe can inline complex x = a * b as:\nx = (ar*br - ai*bi) + i(ar*bi + br*ai);\nif (isunordered (__real__ x, __imag__ x))\n  x = __muldc3 (a, b); //Or __mulsc3 for single-precision\n\nThat way the common case where no NaNs are produced we can avoid the libgcc call and fall back to the\nNaN handling stuff in libgcc if either components of the expansion are NaN.\n\nThe implementation is done in expand_complex_multiplication in tree-complex.c and the above expansion\nwill be done when optimising for -O1 and greater and when not optimising for size.\nAt -O0 and -Os the single call to libgcc will be emitted.\n\nFor the code:\n__complex double\nfoo (__complex double a, __complex double b)\n{\n  return a * b;\n}\n\nWe will now emit at -O2 for aarch64:\nfoo:\n        fmul    d16, d1, d3\n        fmul    d6, d1, d2\n        fnmsub  d5, d0, d2, d16\n        fmadd   d4, d0, d3, d6\n        fcmp    d5, d4\n        bvs     .L8\n        fmov    d1, d4\n        fmov    d0, d5\n        ret\n.L8:\n        stp     x29, x30, [sp, -16]!\n        mov     x29, sp\n        bl      __muldc3\n        ldp     x29, x30, [sp], 16\n        ret\n\nInstead of just a branch to __muldc3.\n\n\tPR tree-optimization/70291\n\t* tree-complex.c (expand_complex_libcall): Add type, inplace_p\n\targuments.  Change return type to tree.  Emit libcall as a new\n\tstatement rather than replacing existing one when inplace_p is true.\n\t(expand_complex_multiplication_components): New function.\n\t(expand_complex_multiplication): Expand floating-point complex\n\tmultiplication using the above.\n\t(expand_complex_division): Rename inner_type parameter to type.\n\tUpdate expand_complex_libcall call-site.\n\t(expand_complex_operations_1): Update expand_complex_multiplication\n\tand expand_complex_division call-sites.\n\n\t* gcc.dg/complex-6.c: New test.\n\t* gcc.dg/complex-7.c: Likewise.\n\nFrom-SVN: r259889", "tree": {"sha": "73a4a069ba83bba17e9149be02963239df4d3d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73a4a069ba83bba17e9149be02963239df4d3d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7244ccba711298c906d4c7ca51f9f49bf2438c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7244ccba711298c906d4c7ca51f9f49bf2438c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7244ccba711298c906d4c7ca51f9f49bf2438c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7244ccba711298c906d4c7ca51f9f49bf2438c7/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9e3ef542877ac62a46e21703ca105f733c47bb64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e3ef542877ac62a46e21703ca105f733c47bb64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e3ef542877ac62a46e21703ca105f733c47bb64"}], "stats": {"total": 226, "additions": 184, "deletions": 42}, "files": [{"sha": "3ce8273a4995e0037b7e1c7508df6c2056561bd0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b7244ccba711298c906d4c7ca51f9f49bf2438c7", "patch": "@@ -1,3 +1,17 @@\n+2018-05-03  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR tree-optimization/70291\n+\t* tree-complex.c (expand_complex_libcall): Add type, inplace_p\n+\targuments.  Change return type to tree.  Emit libcall as a new\n+\tstatement rather than replacing existing one when inplace_p is true.\n+\t(expand_complex_multiplication_components): New function.\n+\t(expand_complex_multiplication): Expand floating-point complex\n+\tmultiplication using the above.\n+\t(expand_complex_division): Rename inner_type parameter to type.\n+\tUpdate expand_complex_libcall call-site.\n+\t(expand_complex_operations_1): Update expand_complex_multiplication\n+\tand expand_complex_division call-sites.\n+\n 2018-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/85582"}, {"sha": "3a69665dd6990209a6ea228fd79040723f779c3b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b7244ccba711298c906d4c7ca51f9f49bf2438c7", "patch": "@@ -1,3 +1,9 @@\n+2018-05-03  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\n+\tPR tree-optimization/70291\n+\t* gcc.dg/complex-6.c: New test.\n+\t* gcc.dg/complex-7.c: Likewise.\n+\n 2018-05-03  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/85579"}, {"sha": "e70322bf6f378d1d6947de4c10f671bc0a7ded49", "filename": "gcc/testsuite/gcc.dg/complex-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcomplex-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcomplex-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcomplex-6.c?ref=b7244ccba711298c906d4c7ca51f9f49bf2438c7", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/70291.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cplxlower\" } */\n+\n+__complex float\n+foo (__complex float a, __complex float b)\n+{\n+  return a * b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unord\" 1 \"cplxlower1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__mulsc3\" 1 \"cplxlower1\" } } */"}, {"sha": "78f1a290e34af0c092a00639d979bc32b332b1da", "filename": "gcc/testsuite/gcc.dg/complex-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcomplex-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftestsuite%2Fgcc.dg%2Fcomplex-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcomplex-7.c?ref=b7244ccba711298c906d4c7ca51f9f49bf2438c7", "patch": "@@ -0,0 +1,13 @@\n+/* PR tree-optimization/70291.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-cplxlower\" } */\n+\n+__complex double\n+foo (__complex double a, __complex double b)\n+{\n+  return a * b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unord\" 1 \"cplxlower1\" } } */\n+/* { dg-final { scan-tree-dump-times \"__muldc3\" 1 \"cplxlower1\" } } */"}, {"sha": "87e27aacb517c52924edafb8fd0916a08b1589fd", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 138, "deletions": 42, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7244ccba711298c906d4c7ca51f9f49bf2438c7/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=b7244ccba711298c906d4c7ca51f9f49bf2438c7", "patch": "@@ -978,22 +978,22 @@ expand_complex_addition (gimple_stmt_iterator *gsi, tree inner_type,\n }\n \n /* Expand a complex multiplication or division to a libcall to the c99\n-   compliant routines.  */\n+   compliant routines.  TYPE is the complex type of the operation.\n+   If INPLACE_P replace the statement at GSI with\n+   the libcall and return NULL_TREE.  Else insert the call, assign its\n+   result to an output variable and return that variable.  If INPLACE_P\n+   is true then the statement being replaced should be an assignment\n+   statement.  */\n \n-static void\n-expand_complex_libcall (gimple_stmt_iterator *gsi, tree ar, tree ai,\n-\t\t\ttree br, tree bi, enum tree_code code)\n+static tree\n+expand_complex_libcall (gimple_stmt_iterator *gsi, tree type, tree ar, tree ai,\n+\t\t\ttree br, tree bi, enum tree_code code, bool inplace_p)\n {\n   machine_mode mode;\n   enum built_in_function bcode;\n-  tree fn, type, lhs;\n-  gimple *old_stmt;\n+  tree fn, lhs;\n   gcall *stmt;\n \n-  old_stmt = gsi_stmt (*gsi);\n-  lhs = gimple_assign_lhs (old_stmt);\n-  type = TREE_TYPE (lhs);\n-\n   mode = TYPE_MODE (type);\n   gcc_assert (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT);\n \n@@ -1008,33 +1008,78 @@ expand_complex_libcall (gimple_stmt_iterator *gsi, tree ar, tree ai,\n   fn = builtin_decl_explicit (bcode);\n \n   stmt = gimple_build_call (fn, 4, ar, ai, br, bi);\n-  gimple_call_set_lhs (stmt, lhs);\n-  update_stmt (stmt);\n-  gsi_replace (gsi, stmt, false);\n \n-  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n-    gimple_purge_dead_eh_edges (gsi_bb (*gsi));\n \n-  if (gimple_in_ssa_p (cfun))\n+  if (inplace_p)\n     {\n+      gimple *old_stmt = gsi_stmt (*gsi);\n+      lhs = gimple_assign_lhs (old_stmt);\n+      gimple_call_set_lhs (stmt, lhs);\n+      update_stmt (stmt);\n+      gsi_replace (gsi, stmt, false);\n+\n+      if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n+\tgimple_purge_dead_eh_edges (gsi_bb (*gsi));\n+\n       type = TREE_TYPE (type);\n       update_complex_components (gsi, stmt,\n-\t\t\t\t build1 (REALPART_EXPR, type, lhs),\n-\t\t\t\t build1 (IMAGPART_EXPR, type, lhs));\n+\t\t\t\t  build1 (REALPART_EXPR, type, lhs),\n+\t\t\t\t  build1 (IMAGPART_EXPR, type, lhs));\n       SSA_NAME_DEF_STMT (lhs) = stmt;\n+      return NULL_TREE;\n     }\n+\n+  lhs = create_tmp_var (type);\n+  gimple_call_set_lhs (stmt, lhs);\n+\n+  lhs = make_ssa_name (lhs, stmt);\n+  gimple_call_set_lhs (stmt, lhs);\n+\n+  update_stmt (stmt);\n+  gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n+  return lhs;\n+}\n+\n+/* Perform a complex multiplication on two complex constants A, B represented\n+   by AR, AI, BR, BI of type TYPE.\n+   The operation we want is: a * b = (ar*br - ai*bi) + i(ar*bi + br*ai).\n+   Insert the GIMPLE statements into GSI.  Store the real and imaginary\n+   components of the result into RR and RI.  */\n+\n+static void\n+expand_complex_multiplication_components (gimple_stmt_iterator *gsi,\n+\t\t\t\t\t     tree type, tree ar, tree ai,\n+\t\t\t\t\t     tree br, tree bi,\n+\t\t\t\t\t     tree *rr, tree *ri)\n+{\n+  tree t1, t2, t3, t4;\n+\n+  t1 = gimplify_build2 (gsi, MULT_EXPR, type, ar, br);\n+  t2 = gimplify_build2 (gsi, MULT_EXPR, type, ai, bi);\n+  t3 = gimplify_build2 (gsi, MULT_EXPR, type, ar, bi);\n+\n+  /* Avoid expanding redundant multiplication for the common\n+     case of squaring a complex number.  */\n+  if (ar == br && ai == bi)\n+    t4 = t3;\n+  else\n+    t4 = gimplify_build2 (gsi, MULT_EXPR, type, ai, br);\n+\n+  *rr = gimplify_build2 (gsi, MINUS_EXPR, type, t1, t2);\n+  *ri = gimplify_build2 (gsi, PLUS_EXPR, type, t3, t4);\n }\n \n /* Expand complex multiplication to scalars:\n \ta * b = (ar*br - ai*bi) + i(ar*bi + br*ai)\n */\n \n static void\n-expand_complex_multiplication (gimple_stmt_iterator *gsi, tree inner_type,\n+expand_complex_multiplication (gimple_stmt_iterator *gsi, tree type,\n \t\t\t       tree ar, tree ai, tree br, tree bi,\n \t\t\t       complex_lattice_t al, complex_lattice_t bl)\n {\n   tree rr, ri;\n+  tree inner_type = TREE_TYPE (type);\n \n   if (al < bl)\n     {\n@@ -1080,27 +1125,77 @@ expand_complex_multiplication (gimple_stmt_iterator *gsi, tree inner_type,\n     case PAIR (VARYING, VARYING):\n       if (flag_complex_method == 2 && SCALAR_FLOAT_TYPE_P (inner_type))\n \t{\n-\t  expand_complex_libcall (gsi, ar, ai, br, bi, MULT_EXPR);\n-\t  return;\n-\t}\n-      else\n-\t{\n-\t  tree t1, t2, t3, t4;\n-\n-\t  t1 = gimplify_build2 (gsi, MULT_EXPR, inner_type, ar, br);\n-\t  t2 = gimplify_build2 (gsi, MULT_EXPR, inner_type, ai, bi);\n-\t  t3 = gimplify_build2 (gsi, MULT_EXPR, inner_type, ar, bi);\n-\n-\t  /* Avoid expanding redundant multiplication for the common\n-\t     case of squaring a complex number.  */\n-\t  if (ar == br && ai == bi)\n-\t    t4 = t3;\n-\t  else\n-\t    t4 = gimplify_build2 (gsi, MULT_EXPR, inner_type, ai, br);\n+\t  /* If optimizing for size or not at all just do a libcall.\n+\t     Same if there are exception-handling edges or signaling NaNs.  */\n+\t  if (optimize == 0 || optimize_bb_for_size_p (gsi_bb (*gsi))\n+\t     || stmt_can_throw_internal (gsi_stmt (*gsi))\n+\t     || flag_signaling_nans)\n+\t    {\n+\t      expand_complex_libcall (gsi, type, ar, ai, br, bi,\n+\t\t\t\t      MULT_EXPR, true);\n+\t      return;\n+\t    }\n \n-\t  rr = gimplify_build2 (gsi, MINUS_EXPR, inner_type, t1, t2);\n-\t  ri = gimplify_build2 (gsi, PLUS_EXPR, inner_type, t3, t4);\n+\t  /* Else, expand x = a * b into\n+\t     x = (ar*br - ai*bi) + i(ar*bi + br*ai);\n+\t     if (isunordered (__real__ x, __imag__ x))\n+\t\tx = __muldc3 (a, b);  */\n+\n+\t  tree tmpr, tmpi;\n+\t  expand_complex_multiplication_components (gsi, inner_type, ar, ai,\n+\t\t\t\t\t\t     br, bi, &tmpr, &tmpi);\n+\n+\t  gimple *check\n+\t    = gimple_build_cond (UNORDERED_EXPR, tmpr, tmpi,\n+\t\t\t\t NULL_TREE, NULL_TREE);\n+\n+\t  basic_block orig_bb = gsi_bb (*gsi);\n+\t  /* We want to keep track of the original complex multiplication\n+\t     statement as we're going to modify it later in\n+\t     update_complex_assignment.  Make sure that insert_cond_bb leaves\n+\t     that statement in the join block.  */\n+\t  gsi_prev (gsi);\n+\t  basic_block cond_bb\n+\t    = insert_cond_bb (gsi_bb (*gsi), gsi_stmt (*gsi), check,\n+\t\t\t      profile_probability::very_unlikely ());\n+\n+\n+\t  gimple_stmt_iterator cond_bb_gsi = gsi_last_bb (cond_bb);\n+\t  gsi_insert_after (&cond_bb_gsi, gimple_build_nop (), GSI_NEW_STMT);\n+\n+\t  tree libcall_res\n+\t    = expand_complex_libcall (&cond_bb_gsi, type, ar, ai, br,\n+\t\t\t\t       bi, MULT_EXPR, false);\n+\t  tree cond_real = gimplify_build1 (&cond_bb_gsi, REALPART_EXPR,\n+\t\t\t\t\t    inner_type, libcall_res);\n+\t  tree cond_imag = gimplify_build1 (&cond_bb_gsi, IMAGPART_EXPR,\n+\t\t\t\t\t    inner_type, libcall_res);\n+\n+\t  basic_block join_bb = single_succ_edge (cond_bb)->dest;\n+\t  *gsi = gsi_start_nondebug_after_labels_bb (join_bb);\n+\n+\t  /* We have a conditional block with some assignments in cond_bb.\n+\t     Wire up the PHIs to wrap up.  */\n+\t  rr = make_ssa_name (inner_type);\n+\t  ri = make_ssa_name (inner_type);\n+\t  edge cond_to_join = single_succ_edge (cond_bb);\n+\t  edge orig_to_join = find_edge (orig_bb, join_bb);\n+\n+\t  gphi *real_phi = create_phi_node (rr, gsi_bb (*gsi));\n+\t  add_phi_arg (real_phi, cond_real, cond_to_join,\n+\t\t\tUNKNOWN_LOCATION);\n+\t  add_phi_arg (real_phi, tmpr, orig_to_join, UNKNOWN_LOCATION);\n+\n+\t  gphi *imag_phi = create_phi_node (ri, gsi_bb (*gsi));\n+\t  add_phi_arg (imag_phi, cond_imag, cond_to_join,\n+\t\t\tUNKNOWN_LOCATION);\n+\t  add_phi_arg (imag_phi, tmpi, orig_to_join, UNKNOWN_LOCATION);\n \t}\n+      else\n+\t/* If we are not worrying about NaNs expand to\n+\t  (ar*br - ai*bi) + i(ar*bi + br*ai) directly.  */\n+\texpand_complex_multiplication_components (gsi, inner_type, ar, ai,\n+\t\t\t\t\t\t      br, bi, &rr, &ri);\n       break;\n \n     default:\n@@ -1308,13 +1403,14 @@ expand_complex_div_wide (gimple_stmt_iterator *gsi, tree inner_type,\n /* Expand complex division to scalars.  */\n \n static void\n-expand_complex_division (gimple_stmt_iterator *gsi, tree inner_type,\n+expand_complex_division (gimple_stmt_iterator *gsi, tree type,\n \t\t\t tree ar, tree ai, tree br, tree bi,\n \t\t\t enum tree_code code,\n \t\t\t complex_lattice_t al, complex_lattice_t bl)\n {\n   tree rr, ri;\n \n+  tree inner_type = TREE_TYPE (type);\n   switch (PAIR (al, bl))\n     {\n     case PAIR (ONLY_REAL, ONLY_REAL):\n@@ -1362,7 +1458,7 @@ expand_complex_division (gimple_stmt_iterator *gsi, tree inner_type,\n \tcase 2:\n \t  if (SCALAR_FLOAT_TYPE_P (inner_type))\n \t    {\n-\t      expand_complex_libcall (gsi, ar, ai, br, bi, code);\n+\t      expand_complex_libcall (gsi, type, ar, ai, br, bi, code, true);\n \t      break;\n \t    }\n \t  /* FALLTHRU */\n@@ -1630,15 +1726,15 @@ expand_complex_operations_1 (gimple_stmt_iterator *gsi)\n       break;\n \n     case MULT_EXPR:\n-      expand_complex_multiplication (gsi, inner_type, ar, ai, br, bi, al, bl);\n+      expand_complex_multiplication (gsi, type, ar, ai, br, bi, al, bl);\n       break;\n \n     case TRUNC_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case RDIV_EXPR:\n-      expand_complex_division (gsi, inner_type, ar, ai, br, bi, code, al, bl);\n+      expand_complex_division (gsi, type, ar, ai, br, bi, code, al, bl);\n       break;\n \n     case NEGATE_EXPR:"}]}