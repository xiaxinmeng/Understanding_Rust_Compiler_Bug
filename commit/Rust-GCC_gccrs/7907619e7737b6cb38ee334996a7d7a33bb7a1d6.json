{"sha": "7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkwNzYxOWU3NzM3YjZjYjM4ZWUzMzQ5OTZhN2Q3YTMzYmI3YTFkNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-02-10T20:18:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-08T07:51:04Z"}, "message": "[Ada] Remove processing of SPARK_05 restriction\n\n2020-06-08  Arnaud Charlet  <charlet@adacore.com>\n\ngcc/ada/\n\n\t* exp_aggr.adb, exp_ch6.adb, par-ch11.adb, par-ch6.adb,\n\tpar-ch7.adb, par-prag.adb, restrict.adb, restrict.ads,\n\tscans.ads, scng.adb, sem_aggr.adb, sem_attr.adb, sem_ch11.adb,\n\tsem_ch12.adb, sem_ch3.adb, sem_ch3.ads, sem_ch4.adb,\n\tsem_ch5.adb, sem_ch6.adb, sem_ch7.adb, sem_ch8.adb, sem_ch9.adb,\n\tsem_res.adb, sem_util.adb, sem_util.ads, snames.ads-tmpl,\n\tgnatbind.adb, libgnat/s-rident.ads,\n\tdoc/gnat_rm/standard_and_implementation_defined_restrictions.rst:\n\tRemove processing of SPARK_05 restriction.\n\t* gnat_rm.texi: Regenerate.\n\t* opt.ads: Remove processing of old checksum which is now\n\thandled by gprbuild directly.", "tree": {"sha": "8ee3827a254799a2e8f3be6fdbe405ee077451a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ee3827a254799a2e8f3be6fdbe405ee077451a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4aa6e2978408f0f45fe1074481cfd4044947ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4aa6e2978408f0f45fe1074481cfd4044947ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4aa6e2978408f0f45fe1074481cfd4044947ab9"}], "stats": {"total": 2623, "additions": 36, "deletions": 2587}, "files": [{"sha": "b0f59cfb5e0195145a1d8c955198610cc8def0e3", "filename": "gcc/ada/doc/gnat_rm/standard_and_implementation_defined_restrictions.rst", "status": "modified", "additions": 1, "deletions": 144, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fstandard_and_implementation_defined_restrictions.rst?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -1000,8 +1000,7 @@ SPARK_05\n --------\n .. index:: SPARK_05\n \n-[GNAT] This restriction checks at compile time that some constructs forbidden\n-in SPARK 2005 are not present. Note that SPARK 2005 has been superseded by\n+[GNAT] This restriction no longer has any effect and is superseded by\n SPARK 2014, whose restrictions are checked by the tool GNATprove. To check that\n a codebase respects SPARK 2014 restrictions, mark the code with pragma or\n aspect ``SPARK_Mode``, and run the tool GNATprove at Stone assurance level, as\n@@ -1013,145 +1012,3 @@ or equivalently::\n \n   gnatprove -P project.gpr --mode=check_all\n \n-With restriction ``SPARK_05``, error messages related to SPARK 2005 restriction\n-have the form:\n-\n-::\n-\n-  violation of restriction \"SPARK_05\" at <source-location>\n-   <error message>\n-\n-.. index:: SPARK\n-\n-The restriction ``SPARK`` is recognized as a synonym for ``SPARK_05``. This is\n-retained for historical compatibility purposes (and an unconditional warning\n-will be generated for its use, advising replacement by ``SPARK_05``).\n-\n-This is not a replacement for the semantic checks performed by the\n-SPARK Examiner tool, as the compiler currently only deals with code,\n-not SPARK 2005 annotations, and does not guarantee catching all\n-cases of constructs forbidden by SPARK 2005.\n-\n-Thus it may well be the case that code which passes the compiler with\n-the SPARK 2005 restriction is rejected by the SPARK Examiner, e.g. due to\n-the different visibility rules of the Examiner based on SPARK 2005\n-``inherit`` annotations.\n-\n-This restriction can be useful in providing an initial filter for code\n-developed using SPARK 2005, or in examining legacy code to see how far\n-it is from meeting SPARK 2005 restrictions.\n-\n-The list below summarizes the checks that are performed when this\n-restriction is in force:\n-\n-* No block statements\n-* No case statements with only an others clause\n-* Exit statements in loops must respect the SPARK 2005 language restrictions\n-* No goto statements\n-* Return can only appear as last statement in function\n-* Function must have return statement\n-* Loop parameter specification must include subtype mark\n-* Prefix of expanded name cannot be a loop statement\n-* Abstract subprogram not allowed\n-* User-defined operators not allowed\n-* Access type parameters not allowed\n-* Default expressions for parameters not allowed\n-* Default expressions for record fields not allowed\n-* No tasking constructs allowed\n-* Label needed at end of subprograms and packages\n-* No mixing of positional and named parameter association\n-* No access types as result type\n-* No unconstrained arrays as result types\n-* No null procedures\n-* Initial and later declarations must be in correct order (declaration can't come after body)\n-* No attributes on private types if full declaration not visible\n-* No package declaration within package specification\n-* No controlled types\n-* No discriminant types\n-* No overloading\n-* Selector name cannot be operator symbol (i.e. operator symbol cannot be prefixed)\n-* Access attribute not allowed\n-* Allocator not allowed\n-* Result of catenation must be String\n-* Operands of catenation must be string literal, static char or another catenation\n-* No conditional expressions\n-* No explicit dereference\n-* Quantified expression not allowed\n-* Slicing not allowed\n-* No exception renaming\n-* No generic renaming\n-* No object renaming\n-* No use clause\n-* Aggregates must be qualified\n-* Nonstatic choice in array aggregates not allowed\n-* The only view conversions which are allowed as in-out parameters are conversions of a tagged type to an ancestor type\n-* No mixing of positional and named association in aggregate, no multi choice\n-* AND, OR and XOR for arrays only allowed when operands have same static bounds\n-* Fixed point operands to * or / must be qualified or converted\n-* Comparison operators not allowed for Booleans or arrays (except strings)\n-* Equality not allowed for arrays with non-matching static bounds (except strings)\n-* Conversion / qualification not allowed for arrays with non-matching static bounds\n-* Subprogram declaration only allowed in package spec (unless followed by import)\n-* Access types not allowed\n-* Incomplete type declaration not allowed\n-* Object and subtype declarations must respect SPARK 2005 restrictions\n-* Digits or delta constraint not allowed\n-* Decimal fixed point type not allowed\n-* Aliasing of objects not allowed\n-* Modular type modulus must be power of 2\n-* Base not allowed on subtype mark\n-* Unary operators not allowed on modular types (except not)\n-* Untagged record cannot be null\n-* No class-wide operations\n-* Initialization expressions must respect SPARK 2005 restrictions\n-* Nonstatic ranges not allowed except in iteration schemes\n-* String subtypes must have lower bound of 1\n-* Subtype of Boolean cannot have constraint\n-* At most one tagged type or extension per package\n-* Interface is not allowed\n-* Character literal cannot be prefixed (selector name cannot be character literal)\n-* Record aggregate cannot contain 'others'\n-* Component association in record aggregate must contain a single choice\n-* Ancestor part cannot be a type mark\n-* Attributes 'Image, 'Width and 'Value not allowed\n-* Functions may not update globals\n-* Subprograms may not contain direct calls to themselves (prevents recursion within unit)\n-* Call to subprogram not allowed in same unit before body has been seen (prevents recursion within unit)\n-\n-The following restrictions are enforced, but note that they are actually more\n-strict that the latest SPARK 2005 language definition:\n-\n-* No derived types other than tagged type extensions\n-* Subtype of unconstrained array must have constraint\n-\n-This list summarises the main SPARK 2005 language rules that are not\n-currently checked by the SPARK_05 restriction:\n-\n-* SPARK 2005 annotations are treated as comments so are not checked at all\n-* Based real literals not allowed\n-* Objects cannot be initialized at declaration by calls to user-defined functions\n-* Objects cannot be initialized at declaration by assignments from variables\n-* Objects cannot be initialized at declaration by assignments from indexed/selected components\n-* Ranges shall not be null\n-* A fixed point delta expression must be a simple expression\n-* Restrictions on where renaming declarations may be placed\n-* Externals of mode 'out' cannot be referenced\n-* Externals of mode 'in' cannot be updated\n-* Loop with no iteration scheme or exits only allowed as last statement in main program or task\n-* Subprogram cannot have parent unit name\n-* SPARK 2005 inherited subprogram must be prefixed with overriding\n-* External variables (or functions that reference them) may not be passed as actual parameters\n-* Globals must be explicitly mentioned in contract\n-* Deferred constants cannot be completed by pragma Import\n-* Package initialization cannot read/write variables from other packages\n-* Prefix not allowed for entities that are directly visible\n-* Identifier declaration can't override inherited package name\n-* Cannot use Standard or other predefined packages as identifiers\n-* After renaming, cannot use the original name\n-* Subprograms can only be renamed to remove package prefix\n-* Pragma import must be immediately after entity it names\n-* No mutual recursion between multiple units (this can be checked with gnatcheck)\n-\n-Note that if a unit is compiled in Ada 95 mode with the SPARK 2005 restriction,\n-violations will be reported for constructs forbidden in SPARK 95,\n-instead of SPARK 2005."}, {"sha": "d945fdbcefc979393cb01fc64908c0ac8c8b31d5", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -6333,10 +6333,6 @@ package body Exp_Aggr is\n       --  object. (Note: we don't use a block statement because this would\n       --  cause generated freeze nodes to be elaborated in the wrong scope).\n \n-      --  Do not perform in-place expansion for SPARK 05 because aggregates are\n-      --  expected to appear in qualified form. In-place expansion eliminates\n-      --  the qualification and eventually violates this SPARK 05 restiction.\n-\n       --  Arrays of limited components must be built in place. The code\n       --  previously excluded controlled components but this is an old\n       --  oversight: the rules in 7.6 (17) are clear.\n@@ -6347,7 +6343,6 @@ package body Exp_Aggr is\n         and then not\n           Must_Slide (Etype (Defining_Identifier (Parent_Node)), Typ)\n         and then not Is_Bit_Packed_Array (Typ)\n-        and then not Restriction_Check_Required (SPARK_05)\n       then\n          In_Place_Assign_OK_For_Declaration := True;\n          Tmp := Defining_Identifier (Parent_Node);"}, {"sha": "4f8b47170c649337a23a096e1fec4f161dcaa343", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -6244,33 +6244,7 @@ package body Exp_Ch6 is\n       Prot_Decl : Node_Id;\n       Prot_Id   : Entity_Id;\n \n-   --  Start of processing for Expand_N_Subprogram_Declaration\n-\n    begin\n-      --  In SPARK, subprogram declarations are only allowed in package\n-      --  specifications.\n-\n-      if Nkind (Parent (N)) /= N_Package_Specification then\n-         if Nkind (Parent (N)) = N_Compilation_Unit then\n-            Check_SPARK_05_Restriction\n-              (\"subprogram declaration is not a library item\", N);\n-\n-         elsif Present (Next (N))\n-           and then Nkind (Next (N)) = N_Pragma\n-           and then Get_Pragma_Id (Next (N)) = Pragma_Import\n-         then\n-            --  In SPARK, subprogram declarations are also permitted in\n-            --  declarative parts when immediately followed by a corresponding\n-            --  pragma Import. We only check here that there is some pragma\n-            --  Import.\n-\n-            null;\n-         else\n-            Check_SPARK_05_Restriction\n-              (\"subprogram declaration is not allowed here\", N);\n-         end if;\n-      end if;\n-\n       --  Deal with case of protected subprogram. Do not generate protected\n       --  operation if operation is flagged as eliminated.\n "}, {"sha": "f012e754f1ed40a4f519e96c10a046c93a60abce", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1, "deletions": 352, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -13307,8 +13307,7 @@ associated with dispatch tables can be placed in read-only memory.\n \n @geindex SPARK_05\n \n-[GNAT] This restriction checks at compile time that some constructs forbidden\n-in SPARK 2005 are not present. Note that SPARK 2005 has been superseded by\n+[GNAT] This restriction no longer has any effect and is superseded by\n SPARK 2014, whose restrictions are checked by the tool GNATprove. To check that\n a codebase respects SPARK 2014 restrictions, mark the code with pragma or\n aspect @code{SPARK_Mode}, and run the tool GNATprove at Stone assurance level, as\n@@ -13324,356 +13323,6 @@ or equivalently:\n gnatprove -P project.gpr --mode=check_all\n @end example\n \n-With restriction @code{SPARK_05}, error messages related to SPARK 2005 restriction\n-have the form:\n-\n-@example\n-violation of restriction \"SPARK_05\" at <source-location>\n- <error message>\n-@end example\n-\n-@geindex SPARK\n-\n-The restriction @code{SPARK} is recognized as a synonym for @code{SPARK_05}. This is\n-retained for historical compatibility purposes (and an unconditional warning\n-will be generated for its use, advising replacement by @code{SPARK_05}).\n-\n-This is not a replacement for the semantic checks performed by the\n-SPARK Examiner tool, as the compiler currently only deals with code,\n-not SPARK 2005 annotations, and does not guarantee catching all\n-cases of constructs forbidden by SPARK 2005.\n-\n-Thus it may well be the case that code which passes the compiler with\n-the SPARK 2005 restriction is rejected by the SPARK Examiner, e.g. due to\n-the different visibility rules of the Examiner based on SPARK 2005\n-@code{inherit} annotations.\n-\n-This restriction can be useful in providing an initial filter for code\n-developed using SPARK 2005, or in examining legacy code to see how far\n-it is from meeting SPARK 2005 restrictions.\n-\n-The list below summarizes the checks that are performed when this\n-restriction is in force:\n-\n-\n-@itemize *\n-\n-@item \n-No block statements\n-\n-@item \n-No case statements with only an others clause\n-\n-@item \n-Exit statements in loops must respect the SPARK 2005 language restrictions\n-\n-@item \n-No goto statements\n-\n-@item \n-Return can only appear as last statement in function\n-\n-@item \n-Function must have return statement\n-\n-@item \n-Loop parameter specification must include subtype mark\n-\n-@item \n-Prefix of expanded name cannot be a loop statement\n-\n-@item \n-Abstract subprogram not allowed\n-\n-@item \n-User-defined operators not allowed\n-\n-@item \n-Access type parameters not allowed\n-\n-@item \n-Default expressions for parameters not allowed\n-\n-@item \n-Default expressions for record fields not allowed\n-\n-@item \n-No tasking constructs allowed\n-\n-@item \n-Label needed at end of subprograms and packages\n-\n-@item \n-No mixing of positional and named parameter association\n-\n-@item \n-No access types as result type\n-\n-@item \n-No unconstrained arrays as result types\n-\n-@item \n-No null procedures\n-\n-@item \n-Initial and later declarations must be in correct order (declaration can't come after body)\n-\n-@item \n-No attributes on private types if full declaration not visible\n-\n-@item \n-No package declaration within package specification\n-\n-@item \n-No controlled types\n-\n-@item \n-No discriminant types\n-\n-@item \n-No overloading\n-\n-@item \n-Selector name cannot be operator symbol (i.e. operator symbol cannot be prefixed)\n-\n-@item \n-Access attribute not allowed\n-\n-@item \n-Allocator not allowed\n-\n-@item \n-Result of catenation must be String\n-\n-@item \n-Operands of catenation must be string literal, static char or another catenation\n-\n-@item \n-No conditional expressions\n-\n-@item \n-No explicit dereference\n-\n-@item \n-Quantified expression not allowed\n-\n-@item \n-Slicing not allowed\n-\n-@item \n-No exception renaming\n-\n-@item \n-No generic renaming\n-\n-@item \n-No object renaming\n-\n-@item \n-No use clause\n-\n-@item \n-Aggregates must be qualified\n-\n-@item \n-Nonstatic choice in array aggregates not allowed\n-\n-@item \n-The only view conversions which are allowed as in-out parameters are conversions of a tagged type to an ancestor type\n-\n-@item \n-No mixing of positional and named association in aggregate, no multi choice\n-\n-@item \n-AND, OR and XOR for arrays only allowed when operands have same static bounds\n-\n-@item \n-Fixed point operands to * or / must be qualified or converted\n-\n-@item \n-Comparison operators not allowed for Booleans or arrays (except strings)\n-\n-@item \n-Equality not allowed for arrays with non-matching static bounds (except strings)\n-\n-@item \n-Conversion / qualification not allowed for arrays with non-matching static bounds\n-\n-@item \n-Subprogram declaration only allowed in package spec (unless followed by import)\n-\n-@item \n-Access types not allowed\n-\n-@item \n-Incomplete type declaration not allowed\n-\n-@item \n-Object and subtype declarations must respect SPARK 2005 restrictions\n-\n-@item \n-Digits or delta constraint not allowed\n-\n-@item \n-Decimal fixed point type not allowed\n-\n-@item \n-Aliasing of objects not allowed\n-\n-@item \n-Modular type modulus must be power of 2\n-\n-@item \n-Base not allowed on subtype mark\n-\n-@item \n-Unary operators not allowed on modular types (except not)\n-\n-@item \n-Untagged record cannot be null\n-\n-@item \n-No class-wide operations\n-\n-@item \n-Initialization expressions must respect SPARK 2005 restrictions\n-\n-@item \n-Nonstatic ranges not allowed except in iteration schemes\n-\n-@item \n-String subtypes must have lower bound of 1\n-\n-@item \n-Subtype of Boolean cannot have constraint\n-\n-@item \n-At most one tagged type or extension per package\n-\n-@item \n-Interface is not allowed\n-\n-@item \n-Character literal cannot be prefixed (selector name cannot be character literal)\n-\n-@item \n-Record aggregate cannot contain 'others'\n-\n-@item \n-Component association in record aggregate must contain a single choice\n-\n-@item \n-Ancestor part cannot be a type mark\n-\n-@item \n-Attributes 'Image, 'Width and 'Value not allowed\n-\n-@item \n-Functions may not update globals\n-\n-@item \n-Subprograms may not contain direct calls to themselves (prevents recursion within unit)\n-\n-@item \n-Call to subprogram not allowed in same unit before body has been seen (prevents recursion within unit)\n-@end itemize\n-\n-The following restrictions are enforced, but note that they are actually more\n-strict that the latest SPARK 2005 language definition:\n-\n-\n-@itemize *\n-\n-@item \n-No derived types other than tagged type extensions\n-\n-@item \n-Subtype of unconstrained array must have constraint\n-@end itemize\n-\n-This list summarises the main SPARK 2005 language rules that are not\n-currently checked by the SPARK_05 restriction:\n-\n-\n-@itemize *\n-\n-@item \n-SPARK 2005 annotations are treated as comments so are not checked at all\n-\n-@item \n-Based real literals not allowed\n-\n-@item \n-Objects cannot be initialized at declaration by calls to user-defined functions\n-\n-@item \n-Objects cannot be initialized at declaration by assignments from variables\n-\n-@item \n-Objects cannot be initialized at declaration by assignments from indexed/selected components\n-\n-@item \n-Ranges shall not be null\n-\n-@item \n-A fixed point delta expression must be a simple expression\n-\n-@item \n-Restrictions on where renaming declarations may be placed\n-\n-@item \n-Externals of mode 'out' cannot be referenced\n-\n-@item \n-Externals of mode 'in' cannot be updated\n-\n-@item \n-Loop with no iteration scheme or exits only allowed as last statement in main program or task\n-\n-@item \n-Subprogram cannot have parent unit name\n-\n-@item \n-SPARK 2005 inherited subprogram must be prefixed with overriding\n-\n-@item \n-External variables (or functions that reference them) may not be passed as actual parameters\n-\n-@item \n-Globals must be explicitly mentioned in contract\n-\n-@item \n-Deferred constants cannot be completed by pragma Import\n-\n-@item \n-Package initialization cannot read/write variables from other packages\n-\n-@item \n-Prefix not allowed for entities that are directly visible\n-\n-@item \n-Identifier declaration can't override inherited package name\n-\n-@item \n-Cannot use Standard or other predefined packages as identifiers\n-\n-@item \n-After renaming, cannot use the original name\n-\n-@item \n-Subprograms can only be renamed to remove package prefix\n-\n-@item \n-Pragma import must be immediately after entity it names\n-\n-@item \n-No mutual recursion between multiple units (this can be checked with gnatcheck)\n-@end itemize\n-\n-Note that if a unit is compiled in Ada 95 mode with the SPARK 2005 restriction,\n-violations will be reported for constructs forbidden in SPARK 95,\n-instead of SPARK 2005.\n-\n @node Implementation Advice,Implementation Defined Characteristics,Standard and Implementation Defined Restrictions,Top\n @anchor{gnat_rm/implementation_advice doc}@anchor{210}@anchor{gnat_rm/implementation_advice implementation-advice}@anchor{a}@anchor{gnat_rm/implementation_advice id1}@anchor{211}\n @chapter Implementation Advice"}, {"sha": "4907082a42cd0ca332f1ef498efb1a84cf702fb0", "filename": "gcc/ada/gnatbind.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fgnatbind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fgnatbind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatbind.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -221,6 +221,9 @@ procedure Gnatbind is\n          No_Use_Of_Pragma                => False,\n          --  Requires a parameter value, not a count\n \n+         SPARK_05                        => False,\n+         --  Obsolete restriction\n+\n          others                          => True);\n \n       Additional_Restrictions_Listed : Boolean := False;"}, {"sha": "73a0450b4586099c4f3cb5cec0cd5b4f840ddec6", "filename": "gcc/ada/libgnat/s-rident.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Flibgnat%2Fs-rident.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Flibgnat%2Fs-rident.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-rident.ads?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -232,7 +232,6 @@ package System.Rident is\n    No_Dynamic_Interrupts  : Restriction_Id renames No_Dynamic_Attachment;\n    No_Requeue             : Restriction_Id renames No_Requeue_Statements;\n    No_Task_Attributes     : Restriction_Id renames No_Task_Attributes_Package;\n-   SPARK                  : Restriction_Id renames SPARK_05;\n \n    subtype All_Restrictions is Restriction_Id range\n      Simple_Barriers .. Max_Storage_At_Blocking;"}, {"sha": "8987f83957216cc55f3f851655561e9de5eab2eb", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -57,50 +57,6 @@ package Opt is\n    --  from a compilation point of view (e.g. spelling of identifiers and\n    --  white space layout do not count in this computation).\n \n-   --  The way the checksum is computed has evolved across the various versions\n-   --  of GNAT. When gprbuild is called with -m, the checksums must be computed\n-   --  the same way in gprbuild as it was in the GNAT version of the compiler.\n-   --  The different ways are\n-\n-   --    Version 6.4 and later:\n-\n-   --      The Accumulate_Token_Checksum procedure is called after each numeric\n-   --      literal and each identifier/keyword. For keywords, Tok_Identifier is\n-   --      used in the call to Accumulate_Token_Checksum.\n-\n-   --    Versions 5.04 to 6.3:\n-\n-   --      For keywords, the token value were used in the call to procedure\n-   --      Accumulate_Token_Checksum. Type Token_Type did not include Tok_Some.\n-\n-   --    Versions 5.03:\n-\n-   --      For keywords, the token value were used in the call to\n-   --      Accumulate_Token_Checksum. Type Token_Type did not include\n-   --      Tok_Interface, Tok_Overriding, Tok_Synchronized and Tok_Some.\n-\n-   --    Versions 5.02 and before:\n-\n-   --      No calls to procedure Accumulate_Token_Checksum (the checksum\n-   --      mechanism was introduced in version 5.03).\n-\n-   --  To signal to the scanner whether Accumulate_Token_Checksum needs to be\n-   --  called and what versions to call, the following Boolean flags are used:\n-\n-   Checksum_Accumulate_Token_Checksum : Boolean := True;\n-   --  GPRBUILD\n-   --  Set to False by gprbuild when the version of GNAT is 5.02 or before. If\n-   --  this switch is False, then we do not call Accumulate_Token_Checksum, so\n-   --  the setting of the following two flags is irrelevant.\n-\n-   Checksum_GNAT_6_3 : Boolean := False;\n-   --  GPRBUILD\n-   --  Set to True by gprbuild when the version of GNAT is 6.3 or before.\n-\n-   Checksum_GNAT_5_03 : Boolean := False;\n-   --  GPRBUILD\n-   --  Set to True by gprbuild when the version of GNAT is 5.03 or before.\n-\n    Checksum_Accumulate_Limited_Checksum : Boolean := False;\n    --  Used to control the computation of the limited view of a package.\n    --  (Not currently used, possible optimization for ALI files of units"}, {"sha": "468ba03a93966c94ce9af72b466198f3a6d17424", "filename": "gcc/ada/par-ch11.adb", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch11.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -57,27 +57,9 @@ package body Ch11 is\n \n    function P_Handled_Sequence_Of_Statements return Node_Id is\n       Handled_Stmt_Seq_Node  : Node_Id;\n-      Seq_Is_Hidden_In_SPARK : Boolean;\n-      Hidden_Region_Start    : Source_Ptr;\n-\n    begin\n       Handled_Stmt_Seq_Node :=\n         New_Node (N_Handled_Sequence_Of_Statements, Token_Ptr);\n-\n-      --  In SPARK, a HIDE directive can be placed at the beginning of a\n-      --  package initialization, thus hiding the sequence of statements (and\n-      --  possible exception handlers) from SPARK tool-set. No violation of the\n-      --  SPARK restriction should be issued on nodes in a hidden part, which\n-      --  is obtained by marking such hidden parts.\n-\n-      if Token = Tok_SPARK_Hide then\n-         Seq_Is_Hidden_In_SPARK := True;\n-         Hidden_Region_Start    := Token_Ptr;\n-         Scan; -- past HIDE directive\n-      else\n-         Seq_Is_Hidden_In_SPARK := False;\n-      end if;\n-\n       Set_Statements\n         (Handled_Stmt_Seq_Node, P_Sequence_Of_Statements (SS_Extm_Sreq));\n \n@@ -87,10 +69,6 @@ package body Ch11 is\n            (Handled_Stmt_Seq_Node, Parse_Exception_Handlers);\n       end if;\n \n-      if Seq_Is_Hidden_In_SPARK then\n-         Set_Hidden_Part_In_SPARK (Hidden_Region_Start, Token_Ptr);\n-      end if;\n-\n       return Handled_Stmt_Seq_Node;\n    end P_Handled_Sequence_Of_Statements;\n \n@@ -282,24 +260,8 @@ package body Ch11 is\n    function Parse_Exception_Handlers return List_Id is\n       Handler                    : Node_Id;\n       Handlers_List              : List_Id;\n-      Handler_Is_Hidden_In_SPARK : Boolean;\n-      Hidden_Region_Start        : Source_Ptr;\n \n    begin\n-      --  In SPARK, a HIDE directive can be placed at the beginning of a\n-      --  sequence of exception handlers for a subprogram implementation, thus\n-      --  hiding the exception handlers from SPARK tool-set. No violation of\n-      --  the SPARK restriction should be issued on nodes in a hidden part,\n-      --  which is obtained by marking such hidden parts.\n-\n-      if Token = Tok_SPARK_Hide then\n-         Handler_Is_Hidden_In_SPARK := True;\n-         Hidden_Region_Start        := Token_Ptr;\n-         Scan; -- past HIDE directive\n-      else\n-         Handler_Is_Hidden_In_SPARK := False;\n-      end if;\n-\n       Handlers_List := New_List;\n       P_Pragmas_Opt (Handlers_List);\n \n@@ -320,10 +282,6 @@ package body Ch11 is\n          end loop;\n       end if;\n \n-      if Handler_Is_Hidden_In_SPARK then\n-         Set_Hidden_Part_In_SPARK (Hidden_Region_Start, Token_Ptr);\n-      end if;\n-\n       return Handlers_List;\n    end Parse_Exception_Handlers;\n "}, {"sha": "2cc3f08f94a27103e3f6094694afb1cc5c68615b", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -707,9 +707,6 @@ package body Ch6 is\n          else\n             Scan_Body_Or_Expression_Function : declare\n \n-               Body_Is_Hidden_In_SPARK : Boolean;\n-               Hidden_Region_Start     : Source_Ptr;\n-\n                function Likely_Expression_Function return Boolean;\n                --  Returns True if we have a probable case of an expression\n                --  function omitting the parentheses, if so, returns True\n@@ -942,25 +939,7 @@ package body Ch6 is\n                      Set_Aspect_Specifications (Body_Node, Aspects);\n                   end if;\n \n-                  --  In SPARK, a HIDE directive can be placed at the beginning\n-                  --  of a subprogram implementation, thus hiding the\n-                  --  subprogram body from SPARK tool-set. No violation of the\n-                  --  SPARK restriction should be issued on nodes in a hidden\n-                  --  part, which is obtained by marking such hidden parts.\n-\n-                  if Token = Tok_SPARK_Hide then\n-                     Body_Is_Hidden_In_SPARK := True;\n-                     Hidden_Region_Start     := Token_Ptr;\n-                     Scan; -- past HIDE directive\n-                  else\n-                     Body_Is_Hidden_In_SPARK := False;\n-                  end if;\n-\n                   Parse_Decls_Begin_End (Body_Node);\n-\n-                  if Body_Is_Hidden_In_SPARK then\n-                     Set_Hidden_Part_In_SPARK (Hidden_Region_Start, Token_Ptr);\n-                  end if;\n                end if;\n \n                return Body_Node;"}, {"sha": "e057daa52c520b4d6b9dee0eae1e072daedaecdf", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -115,10 +115,6 @@ package body Ch7 is\n       --  Dummy node to attach aspect specifications to until we properly\n       --  figure out where they eventually belong.\n \n-      Body_Is_Hidden_In_SPARK         : Boolean;\n-      Private_Part_Is_Hidden_In_SPARK : Boolean;\n-      Hidden_Region_Start             : Source_Ptr;\n-\n    begin\n       Push_Scope_Stack;\n       Scopes (Scope.Last).Etyp := E_Name;\n@@ -185,25 +181,7 @@ package body Ch7 is\n                Move_Aspects (From => Dummy_Node, To => Package_Node);\n             end if;\n \n-            --  In SPARK, a HIDE directive can be placed at the beginning of a\n-            --  package implementation, thus hiding the package body from SPARK\n-            --  tool-set. No violation of the SPARK restriction should be\n-            --  issued on nodes in a hidden part, which is obtained by marking\n-            --  such hidden parts.\n-\n-            if Token = Tok_SPARK_Hide then\n-               Body_Is_Hidden_In_SPARK := True;\n-               Hidden_Region_Start     := Token_Ptr;\n-               Scan; -- past HIDE directive\n-            else\n-               Body_Is_Hidden_In_SPARK := False;\n-            end if;\n-\n             Parse_Decls_Begin_End (Package_Node);\n-\n-            if Body_Is_Hidden_In_SPARK then\n-               Set_Hidden_Part_In_SPARK (Hidden_Region_Start, Token_Ptr);\n-            end if;\n          end if;\n \n       --  Cases other than Package_Body\n@@ -303,27 +281,9 @@ package body Ch7 is\n \n                   Scan; -- past PRIVATE\n \n-                  if Token = Tok_SPARK_Hide then\n-                     Private_Part_Is_Hidden_In_SPARK := True;\n-                     Hidden_Region_Start             := Token_Ptr;\n-                     Scan; -- past HIDE directive\n-                  else\n-                     Private_Part_Is_Hidden_In_SPARK := False;\n-                  end if;\n-\n                   Set_Private_Declarations\n                     (Specification_Node, P_Basic_Declarative_Items);\n \n-                  --  In SPARK, a HIDE directive can be placed at the beginning\n-                  --  of a private part, thus hiding all declarations in the\n-                  --  private part from SPARK tool-set. No violation of the\n-                  --  SPARK restriction should be issued on nodes in a hidden\n-                  --  part, which is obtained by marking such hidden parts.\n-\n-                  if Private_Part_Is_Hidden_In_SPARK then\n-                     Set_Hidden_Part_In_SPARK (Hidden_Region_Start, Token_Ptr);\n-                  end if;\n-\n                   --  Deal gracefully with multiple PRIVATE parts\n \n                   while Token = Tok_Private loop"}, {"sha": "0a1905affee40896d7552d6dbc5762c99f560d51", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -102,10 +102,6 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n    --    are some obsolescent features (e.g. character replacements) which are\n    --    handled at parse time.\n    --\n-   --    SPARK must be processed at parse time, since this restriction controls\n-   --    whether the scanner recognizes a spark HIDE directive formatted as an\n-   --    Ada comment (and generates a Tok_SPARK_Hide token for the directive).\n-   --\n    --    No_Dependence must be processed at parse time, since otherwise it gets\n    --    handled too late.\n    --\n@@ -257,12 +253,11 @@ function Prag (Pragma_Node : Node_Id; Semi : Source_Ptr) return Node_Id is\n                   Restriction_Warnings (No_Obsolescent_Features) :=\n                     Prag_Id = Pragma_Restriction_Warnings;\n \n-               when Name_SPARK\n-                  | Name_SPARK_05\n-               =>\n-                  Set_Restriction (SPARK_05, Pragma_Node);\n-                  Restriction_Warnings (SPARK_05) :=\n-                    Prag_Id = Pragma_Restriction_Warnings;\n+               when Name_SPARK_05 =>\n+                  Error_Msg_Name_1 := Chars (Expr);\n+                  Error_Msg_N\n+                    (\"??% restriction is obsolete and ignored, consider \" &\n+                     \"using 'S'P'A'R'K_'Mode and gnatprove instead\", Arg);\n \n                when others =>\n                   null;"}, {"sha": "2c812e81d149811e39c7a3be933f103f6c156837", "filename": "gcc/ada/restrict.adb", "status": "modified", "additions": 3, "deletions": 173, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Frestrict.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Frestrict.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -39,34 +39,6 @@ with Uname;    use Uname;\n \n package body Restrict is\n \n-   -------------------------------\n-   -- SPARK Restriction Control --\n-   -------------------------------\n-\n-   --  SPARK HIDE directives allow the effect of the SPARK_05 restriction to be\n-   --  turned off for a specified region of code, and the following tables are\n-   --  the data structures used to keep track of these regions.\n-\n-   --  The table contains pairs of source locations, the first being the start\n-   --  location for hidden region, and the second being the end location.\n-\n-   --  Note that the start location is included in the hidden region, while\n-   --  the end location is excluded from it. (It typically corresponds to the\n-   --  next token during scanning.)\n-\n-   type SPARK_Hide_Entry is record\n-      Start : Source_Ptr;\n-      Stop  : Source_Ptr;\n-   end record;\n-\n-   package SPARK_Hides is new Table.Table (\n-     Table_Component_Type => SPARK_Hide_Entry,\n-     Table_Index_Type     => Natural,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 100,\n-     Table_Increment      => 200,\n-     Table_Name           => \"SPARK Hides\");\n-\n    --------------------------------\n    -- Package Local Declarations --\n    --------------------------------\n@@ -511,13 +483,6 @@ package body Restrict is\n          return;\n       end if;\n \n-      --  In SPARK 05 mode, issue an error for any use of class-wide, even if\n-      --  the No_Dispatch restriction is not set.\n-\n-      if R = No_Dispatch then\n-         Check_SPARK_05_Restriction (\"class-wide is not allowed\", N);\n-      end if;\n-\n       if UI_Is_In_Int_Range (V) then\n          VV := Integer (UI_To_Int (V));\n       else\n@@ -846,94 +811,6 @@ package body Restrict is\n       end if;\n    end Check_Restriction_No_Use_Of_Pragma;\n \n-   --------------------------------\n-   -- Check_SPARK_05_Restriction --\n-   --------------------------------\n-\n-   procedure Check_SPARK_05_Restriction\n-     (Msg   : String;\n-      N     : Node_Id;\n-      Force : Boolean := False)\n-   is\n-      Msg_Issued          : Boolean;\n-      Save_Error_Msg_Sloc : Source_Ptr;\n-      Onode               : constant Node_Id := Original_Node (N);\n-\n-   begin\n-      --  Output message if Force set\n-\n-      if Force\n-\n-        --  Or if this node comes from source\n-\n-        or else Comes_From_Source (N)\n-\n-        --  Or if this is a range node which rewrites a range attribute and\n-        --  the range attribute comes from source.\n-\n-        or else (Nkind (N) = N_Range\n-                  and then Nkind (Onode) = N_Attribute_Reference\n-                  and then Attribute_Name (Onode) = Name_Range\n-                  and then Comes_From_Source (Onode))\n-\n-        --  Or this is an expression that does not come from source, which is\n-        --  a rewriting of an expression that does come from source.\n-\n-        or else (Nkind (N) in N_Subexpr and then Comes_From_Source (Onode))\n-      then\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n-         then\n-            return;\n-         end if;\n-\n-         --  Since the call to Restriction_Msg from Check_Restriction may set\n-         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n-         --  restore the previous value of the global variable around the call.\n-\n-         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n-         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n-         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n-\n-         if Msg_Issued then\n-            Error_Msg_F (\"\\\\| \" & Msg, N);\n-         end if;\n-      end if;\n-   end Check_SPARK_05_Restriction;\n-\n-   procedure Check_SPARK_05_Restriction\n-     (Msg1 : String;\n-      Msg2 : String;\n-      N    : Node_Id)\n-   is\n-      Msg_Issued          : Boolean;\n-      Save_Error_Msg_Sloc : Source_Ptr;\n-\n-   begin\n-      pragma Assert (Msg2'Length /= 0 and then Msg2 (Msg2'First) = '\\');\n-\n-      if Comes_From_Source (Original_Node (N)) then\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Is_In_Hidden_Part_In_SPARK (Sloc (N))\n-         then\n-            return;\n-         end if;\n-\n-         --  Since the call to Restriction_Msg from Check_Restriction may set\n-         --  Error_Msg_Sloc to the location of the pragma restriction, save and\n-         --  restore the previous value of the global variable around the call.\n-\n-         Save_Error_Msg_Sloc := Error_Msg_Sloc;\n-         Check_Restriction (Msg_Issued, SPARK_05, First_Node (N));\n-         Error_Msg_Sloc := Save_Error_Msg_Sloc;\n-\n-         if Msg_Issued then\n-            Error_Msg_F (\"\\\\| \" & Msg1, N);\n-            Error_Msg_F (Msg2, N);\n-         end if;\n-      end if;\n-   end Check_SPARK_05_Restriction;\n-\n    --------------------------------------\n    -- Check_Wide_Character_Restriction --\n    --------------------------------------\n@@ -1021,25 +898,6 @@ package body Restrict is\n       return Not_A_Restriction_Id;\n    end Get_Restriction_Id;\n \n-   --------------------------------\n-   -- Is_In_Hidden_Part_In_SPARK --\n-   --------------------------------\n-\n-   function Is_In_Hidden_Part_In_SPARK (Loc : Source_Ptr) return Boolean is\n-   begin\n-      --  Loop through table of hidden ranges\n-\n-      for J in SPARK_Hides.First .. SPARK_Hides.Last loop\n-         if SPARK_Hides.Table (J).Start <= Loc\n-           and then Loc < SPARK_Hides.Table (J).Stop\n-         then\n-            return True;\n-         end if;\n-      end loop;\n-\n-      return False;\n-   end Is_In_Hidden_Part_In_SPARK;\n-\n    -------------------------------\n    -- No_Exception_Handlers_Set --\n    -------------------------------\n@@ -1134,21 +992,11 @@ package body Restrict is\n          when Name_No_Task_Attributes =>\n             New_Name := Name_No_Task_Attributes_Package;\n \n-         --  SPARK is special in that we unconditionally warn\n-\n-         when Name_SPARK =>\n-            Error_Msg_Name_1 := Name_SPARK;\n-            Error_Msg_N (\"restriction identifier % is obsolescent??\", N);\n-            Error_Msg_Name_1 := Name_SPARK_05;\n-            Error_Msg_N (\"|use restriction identifier % instead??\", N);\n-            return Name_SPARK_05;\n-\n          when others =>\n             return Old_Name;\n       end case;\n \n-      --  Output warning if we are warning on obsolescent features for all\n-      --  cases other than SPARK.\n+      --  Output warning if we are warning on obsolescent features.\n \n       if Warn_On_Obsolescent_Feature then\n          Error_Msg_Name_1 := Old_Name;\n@@ -1250,8 +1098,7 @@ package body Restrict is\n       --  Append given string to Msg, bumping Len appropriately\n \n       procedure Id_Case (S : String; Quotes : Boolean := True);\n-      --  Given a string S, case it according to current identifier casing,\n-      --  except for SPARK_05 (an acronym) which is set all upper case, and\n+      --  Given a string S, case it according to current identifier casing, and\n       --  store in Error_Msg_String. Then append `~` to the message buffer\n       --  to output the string unchanged surrounded in quotes. The quotes\n       --  are suppressed if Quotes = False.\n@@ -1284,13 +1131,7 @@ package body Restrict is\n       begin\n          Name_Buffer (1 .. S'Last) := S;\n          Name_Len := S'Length;\n-\n-         if R = SPARK_05 then\n-            Set_All_Upper_Case;\n-         else\n-            Set_Casing (Identifier_Casing (Get_Source_File_Index (Sloc (N))));\n-         end if;\n-\n+         Set_Casing (Identifier_Casing (Get_Source_File_Index (Sloc (N))));\n          Error_Msg_Strlen := Name_Len;\n          Error_Msg_String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n \n@@ -1443,17 +1284,6 @@ package body Restrict is\n       Config_Cunit_Boolean_Restrictions := Cunit_Boolean_Restrictions_Save;\n    end Save_Config_Cunit_Boolean_Restrictions;\n \n-   ------------------------------\n-   -- Set_Hidden_Part_In_SPARK --\n-   ------------------------------\n-\n-   procedure Set_Hidden_Part_In_SPARK (Loc1, Loc2 : Source_Ptr) is\n-   begin\n-      SPARK_Hides.Increment_Last;\n-      SPARK_Hides.Table (SPARK_Hides.Last).Start := Loc1;\n-      SPARK_Hides.Table (SPARK_Hides.Last).Stop  := Loc2;\n-   end Set_Hidden_Part_In_SPARK;\n-\n    ------------------------------\n    -- Set_Profile_Restrictions --\n    ------------------------------"}, {"sha": "e0c6bbacf10af415d6abdb55e82ae3d04133a43d", "filename": "gcc/ada/restrict.ads", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Frestrict.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Frestrict.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frestrict.ads?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -310,22 +310,6 @@ package Restrict is\n \n    --  WARNING: There is a matching C declaration of this subprogram in fe.h\n \n-   procedure Check_SPARK_05_Restriction\n-     (Msg   : String;\n-      N     : Node_Id;\n-      Force : Boolean := False);\n-   --  Node N represents a construct not allowed in SPARK_05 mode. If this is\n-   --  a source node, or if the restriction is forced (Force = True), and\n-   --  the SPARK_05 restriction is set, then an error is issued on N. Msg\n-   --  is appended to the restriction failure message.\n-\n-   procedure Check_SPARK_05_Restriction\n-     (Msg1 : String;\n-      Msg2 : String;\n-      N    : Node_Id);\n-   --  Same as Check_SPARK_05_Restriction except there is a continuation\n-   --  message Msg2 following the initial message Msg1.\n-\n    procedure Check_No_Implicit_Aliasing (Obj : Node_Id);\n    --  Obj is a node for which Is_Aliased_View is True, which is being used in\n    --  a context (e.g. 'Access) where no implicit aliasing is allowed if the\n@@ -392,10 +376,6 @@ package Restrict is\n    --  pragma Restrictions_Warning, or attribute Restriction_Set. Returns\n    --  True if N has the proper form for an entity name, False otherwise.\n \n-   function Is_In_Hidden_Part_In_SPARK (Loc : Source_Ptr) return Boolean;\n-   --  Determine if given location is covered by a hidden region range in the\n-   --  SPARK hides table.\n-\n    function No_Exception_Handlers_Set return Boolean;\n    --  Test to see if current restrictions settings specify that no exception\n    --  handlers are present. This function is called by Gigi when it needs to\n@@ -442,11 +422,6 @@ package Restrict is\n    --  of individual Restrictions pragmas). Returns True only if all the\n    --  required restrictions are set.\n \n-   procedure Set_Hidden_Part_In_SPARK (Loc1, Loc2 : Source_Ptr);\n-   --  Insert a new hidden region range in the SPARK hides table. The effect\n-   --  is to hide any SPARK violation messages which are in the range Loc1 to\n-   --  Loc2-1 (i.e. Loc2 is the first location for reenabling checks).\n-\n    procedure Set_Profile_Restrictions\n      (P    : Profile_Name;\n       N    : Node_Id;"}, {"sha": "746d337f576e66048643594544dbab7408a3d264", "filename": "gcc/ada/scans.ads", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fscans.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fscans.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscans.ads?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -226,9 +226,6 @@ package Scans is\n       --  the characters '#', '$', '?', '@', '`', '\\', '^', '~', or '_'. The\n       --  character value itself is stored in Scans.Special_Character.\n \n-      Tok_SPARK_Hide,\n-      --  HIDE directive in SPARK\n-\n       No_Token);\n       --  No_Token is used for initializing Token values to indicate that\n       --  no value has been set yet."}, {"sha": "46d1f8ef5a77544a6cc0bf8af3c9914234354ccb", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 4, "deletions": 382, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -28,8 +28,6 @@ with Csets;    use Csets;\n with Hostparm; use Hostparm;\n with Namet;    use Namet;\n with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n with Scans;    use Scans;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n@@ -70,19 +68,6 @@ package body Scng is\n    --  the token used is Tok_Identifier. This allows detection of additional\n    --  spaces added in sources when using the builder switch -m.\n \n-   procedure Accumulate_Token_Checksum_GNAT_6_3;\n-   --  Used in place of Accumulate_Token_Checksum for GNAT versions 5.04 to\n-   --  6.3, when Tok_Some was not included in Token_Type and the actual\n-   --  Token_Type was used for keywords. This procedure is never used in the\n-   --  compiler or gnatmake, only in gprbuild.\n-\n-   procedure Accumulate_Token_Checksum_GNAT_5_03;\n-   --  Used in place of Accumulate_Token_Checksum for GNAT version 5.03, when\n-   --  Tok_Interface, Tok_Some, Tok_Synchronized and Tok_Overriding were not\n-   --  included in Token_Type and the actual Token_Type was used for keywords.\n-   --  This procedure is never used in the compiler or gnatmake, only in\n-   --  gprbuild.\n-\n    procedure Accumulate_Checksum (C : Character);\n    pragma Inline (Accumulate_Checksum);\n    --  This routine accumulates the checksum given character C. During the\n@@ -138,307 +123,6 @@ package body Scng is\n          Character'Val (Token_Type'Pos (Token)));\n    end Accumulate_Token_Checksum;\n \n-   ----------------------------------------\n-   -- Accumulate_Token_Checksum_GNAT_6_3 --\n-   ----------------------------------------\n-\n-   procedure Accumulate_Token_Checksum_GNAT_6_3 is\n-   begin\n-      --  Individual values of Token_Type are used, instead of subranges, so\n-      --  that additions or suppressions of enumerated values in type\n-      --  Token_Type are detected by the compiler.\n-\n-      case Token is\n-         when Tok_Abs\n-            | Tok_Abstract\n-            | Tok_Access\n-            | Tok_Aliased\n-            | Tok_All\n-            | Tok_Ampersand\n-            | Tok_And\n-            | Tok_Apostrophe\n-            | Tok_Array\n-            | Tok_Asterisk\n-            | Tok_At\n-            | Tok_At_Sign\n-            | Tok_Body\n-            | Tok_Box\n-            | Tok_Char_Literal\n-            | Tok_Colon\n-            | Tok_Colon_Equal\n-            | Tok_Comma\n-            | Tok_Constant\n-            | Tok_Delta\n-            | Tok_Digits\n-            | Tok_Do\n-            | Tok_Dot\n-            | Tok_Double_Asterisk\n-            | Tok_Equal\n-            | Tok_Greater\n-            | Tok_Greater_Equal\n-            | Tok_Greater_Greater\n-            | Tok_Identifier\n-            | Tok_In\n-            | Tok_Integer_Literal\n-            | Tok_Interface\n-            | Tok_Is\n-            | Tok_Left_Bracket\n-            | Tok_Left_Paren\n-            | Tok_Less\n-            | Tok_Less_Equal\n-            | Tok_Limited\n-            | Tok_Minus\n-            | Tok_Mod\n-            | Tok_New\n-            | Tok_Not\n-            | Tok_Not_Equal\n-            | Tok_Null\n-            | Tok_Of\n-            | Tok_Operator_Symbol\n-            | Tok_Or\n-            | Tok_Others\n-            | Tok_Out\n-            | Tok_Plus\n-            | Tok_Range\n-            | Tok_Real_Literal\n-            | Tok_Record\n-            | Tok_Rem\n-            | Tok_Renames\n-            | Tok_Reverse\n-            | Tok_Right_Bracket\n-            | Tok_Right_Paren\n-            | Tok_Slash\n-            | Tok_String_Literal\n-            | Tok_Xor\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Token)));\n-\n-         when Tok_Some =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Tok_Identifier)));\n-\n-         when No_Token\n-            | Tok_Abort\n-            | Tok_Accept\n-            | Tok_Arrow\n-            | Tok_Begin\n-            | Tok_Case\n-            | Tok_Comment\n-            | Tok_Declare\n-            | Tok_Delay\n-            | Tok_Dot_Dot\n-            | Tok_Else\n-            | Tok_Elsif\n-            | Tok_End\n-            | Tok_End_Of_Line\n-            | Tok_Entry\n-            | Tok_EOF\n-            | Tok_Exception\n-            | Tok_Exit\n-            | Tok_Extends\n-            | Tok_External\n-            | Tok_External_As_List\n-            | Tok_For\n-            | Tok_Function\n-            | Tok_Generic\n-            | Tok_Goto\n-            | Tok_If\n-            | Tok_Less_Less\n-            | Tok_Loop\n-            | Tok_Overriding\n-            | Tok_Package\n-            | Tok_Pragma\n-            | Tok_Private\n-            | Tok_Procedure\n-            | Tok_Project\n-            | Tok_Protected\n-            | Tok_Raise\n-            | Tok_Requeue\n-            | Tok_Return\n-            | Tok_Select\n-            | Tok_Semicolon\n-            | Tok_Separate\n-            | Tok_SPARK_Hide\n-            | Tok_Special\n-            | Tok_Subtype\n-            | Tok_Synchronized\n-            | Tok_Tagged\n-            | Tok_Task\n-            | Tok_Terminate\n-            | Tok_Then\n-            | Tok_Type\n-            | Tok_Until\n-            | Tok_Use\n-            | Tok_Vertical_Bar\n-            | Tok_When\n-            | Tok_While\n-            | Tok_With\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Token_Type'Pred (Token))));\n-      end case;\n-   end Accumulate_Token_Checksum_GNAT_6_3;\n-\n-   -----------------------------------------\n-   -- Accumulate_Token_Checksum_GNAT_5_03 --\n-   -----------------------------------------\n-\n-   procedure Accumulate_Token_Checksum_GNAT_5_03 is\n-   begin\n-      --  Individual values of Token_Type are used, instead of subranges, so\n-      --  that additions or suppressions of enumerated values in type\n-      --  Token_Type are detected by the compiler.\n-\n-      case Token is\n-         when Tok_Abs\n-            | Tok_Abstract\n-            | Tok_Access\n-            | Tok_Aliased\n-            | Tok_All\n-            | Tok_Ampersand\n-            | Tok_And\n-            | Tok_Apostrophe\n-            | Tok_Array\n-            | Tok_Asterisk\n-            | Tok_At\n-            | Tok_At_Sign\n-            | Tok_Body\n-            | Tok_Box\n-            | Tok_Char_Literal\n-            | Tok_Colon\n-            | Tok_Colon_Equal\n-            | Tok_Comma\n-            | Tok_Constant\n-            | Tok_Delta\n-            | Tok_Digits\n-            | Tok_Do\n-            | Tok_Dot\n-            | Tok_Double_Asterisk\n-            | Tok_Equal\n-            | Tok_Greater\n-            | Tok_Greater_Equal\n-            | Tok_Greater_Greater\n-            | Tok_Identifier\n-            | Tok_In\n-            | Tok_Integer_Literal\n-            | Tok_Is\n-            | Tok_Left_Bracket\n-            | Tok_Left_Paren\n-            | Tok_Less\n-            | Tok_Less_Equal\n-            | Tok_Minus\n-            | Tok_Mod\n-            | Tok_New\n-            | Tok_Not\n-            | Tok_Not_Equal\n-            | Tok_Null\n-            | Tok_Operator_Symbol\n-            | Tok_Or\n-            | Tok_Others\n-            | Tok_Plus\n-            | Tok_Range\n-            | Tok_Real_Literal\n-            | Tok_Rem\n-            | Tok_Right_Bracket\n-            | Tok_Right_Paren\n-            | Tok_Slash\n-            | Tok_String_Literal\n-            | Tok_Xor\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Token)));\n-\n-         when Tok_Interface\n-            | Tok_Overriding\n-            | Tok_Some\n-            | Tok_Synchronized\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Tok_Identifier)));\n-\n-         when Tok_Limited\n-            | Tok_Of\n-            | Tok_Out\n-            | Tok_Record\n-            | Tok_Renames\n-            | Tok_Reverse\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Token) - 1));\n-\n-         when Tok_Abort\n-            | Tok_Accept\n-            | Tok_Begin\n-            | Tok_Case\n-            | Tok_Declare\n-            | Tok_Delay\n-            | Tok_Else\n-            | Tok_Elsif\n-            | Tok_End\n-            | Tok_Entry\n-            | Tok_Exception\n-            | Tok_Exit\n-            | Tok_For\n-            | Tok_Goto\n-            | Tok_If\n-            | Tok_Less_Less\n-            | Tok_Loop\n-            | Tok_Pragma\n-            | Tok_Protected\n-            | Tok_Raise\n-            | Tok_Requeue\n-            | Tok_Return\n-            | Tok_Select\n-            | Tok_Subtype\n-            | Tok_Tagged\n-            | Tok_Task\n-            | Tok_Terminate\n-            | Tok_Then\n-            | Tok_Type\n-            | Tok_Until\n-            | Tok_When\n-            | Tok_While\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Token) - 2));\n-\n-         when No_Token\n-            | Tok_Arrow\n-            | Tok_Comment\n-            | Tok_Dot_Dot\n-            | Tok_End_Of_Line\n-            | Tok_EOF\n-            | Tok_Extends\n-            | Tok_External\n-            | Tok_External_As_List\n-            | Tok_Function\n-            | Tok_Generic\n-            | Tok_Package\n-            | Tok_Private\n-            | Tok_Procedure\n-            | Tok_Project\n-            | Tok_Semicolon\n-            | Tok_Separate\n-            | Tok_SPARK_Hide\n-            | Tok_Special\n-            | Tok_Use\n-            | Tok_Vertical_Bar\n-            | Tok_With\n-         =>\n-            System.CRC32.Update\n-              (System.CRC32.CRC32 (Checksum),\n-               Character'Val (Token_Type'Pos (Token) - 4));\n-      end case;\n-   end Accumulate_Token_Checksum_GNAT_5_03;\n-\n    -----------------------\n    -- Check_End_Of_Line --\n    -----------------------\n@@ -1058,11 +742,7 @@ package body Scng is\n             end if;\n          end if;\n \n-         if Checksum_Accumulate_Token_Checksum then\n-            Accumulate_Token_Checksum;\n-         end if;\n-\n-         return;\n+         Accumulate_Token_Checksum;\n       end Nlit;\n \n       ----------\n@@ -1980,47 +1660,6 @@ package body Scng is\n                   Token := Tok_Comment;\n                   return;\n                end if;\n-\n-               --  If the SPARK restriction is set for this unit, then generate\n-               --  a token Tok_SPARK_Hide for a SPARK HIDE directive.\n-\n-               if Restriction_Check_Required (SPARK_05)\n-                 and then Source (Start_Of_Comment) = '#'\n-               then\n-                  declare\n-                     Scan_SPARK_Ptr : Source_Ptr;\n-\n-                  begin\n-                     Scan_SPARK_Ptr := Start_Of_Comment + 1;\n-\n-                     --  Scan out blanks\n-\n-                     while Source (Scan_SPARK_Ptr) = ' '\n-                       or else Source (Scan_SPARK_Ptr) = HT\n-                     loop\n-                        Scan_SPARK_Ptr := Scan_SPARK_Ptr + 1;\n-                     end loop;\n-\n-                     --  Recognize HIDE directive. SPARK input cannot be\n-                     --  encoded as wide characters, so only deal with\n-                     --  lower/upper case.\n-\n-                     if (Source (Scan_SPARK_Ptr) = 'h'\n-                          or else Source (Scan_SPARK_Ptr) = 'H')\n-                       and then (Source (Scan_SPARK_Ptr + 1) = 'i'\n-                                  or else Source (Scan_SPARK_Ptr + 1) = 'I')\n-                       and then (Source (Scan_SPARK_Ptr + 2) = 'd'\n-                                  or else Source (Scan_SPARK_Ptr + 2) = 'D')\n-                       and then (Source (Scan_SPARK_Ptr + 3) = 'e'\n-                                  or else Source (Scan_SPARK_Ptr + 3) = 'E')\n-                       and then (Source (Scan_SPARK_Ptr + 4) = ' '\n-                                  or else Source (Scan_SPARK_Ptr + 4) = HT)\n-                     then\n-                        Token := Tok_SPARK_Hide;\n-                        return;\n-                     end if;\n-                  end;\n-               end if;\n             end if;\n          end Minus_Case;\n \n@@ -2926,21 +2565,8 @@ package body Scng is\n          --  Here is where we check if it was a keyword\n \n          if Is_Keyword_Name (Token_Name) then\n-            if Opt.Checksum_GNAT_6_3 then\n-               Token := Token_Type'Val (Get_Name_Table_Byte (Token_Name));\n-\n-               if Checksum_Accumulate_Token_Checksum then\n-                  if Checksum_GNAT_5_03 then\n-                     Accumulate_Token_Checksum_GNAT_5_03;\n-                  else\n-                     Accumulate_Token_Checksum_GNAT_6_3;\n-                  end if;\n-               end if;\n-\n-            else\n-               Accumulate_Token_Checksum;\n-               Token := Token_Type'Val (Get_Name_Table_Byte (Token_Name));\n-            end if;\n+            Accumulate_Token_Checksum;\n+            Token := Token_Type'Val (Get_Name_Table_Byte (Token_Name));\n \n             --  Keyword style checks\n \n@@ -2997,12 +2623,8 @@ package body Scng is\n          --  It is an identifier after all\n \n          else\n-            if Checksum_Accumulate_Token_Checksum then\n-               Accumulate_Token_Checksum;\n-            end if;\n-\n+            Accumulate_Token_Checksum;\n             Post_Scan;\n-            return;\n          end if;\n    end Scan;\n "}, {"sha": "a3ac7caf6f75360f5ac55c8043bc2ad38c7fb478", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -117,15 +117,6 @@ package body Sem_Aggr is\n    --  Expression is also OK in an instance or inlining context, because we\n    --  have already preanalyzed and it is known to be type correct.\n \n-   procedure Check_Qualified_Aggregate (Level : Nat; Expr : Node_Id);\n-   --  Given aggregate Expr, check that sub-aggregates of Expr that are nested\n-   --  at Level are qualified. If Level = 0, this applies to Expr directly.\n-   --  Only issue errors in formal verification mode.\n-\n-   function Is_Top_Level_Aggregate (Expr : Node_Id) return Boolean;\n-   --  Return True of Expr is an aggregate not contained directly in another\n-   --  aggregate.\n-\n    ------------------------------------------------------\n    -- Subprograms used for RECORD AGGREGATE Processing --\n    ------------------------------------------------------\n@@ -731,43 +722,6 @@ package body Sem_Aggr is\n       end if;\n    end Check_Expr_OK_In_Limited_Aggregate;\n \n-   -------------------------------\n-   -- Check_Qualified_Aggregate --\n-   -------------------------------\n-\n-   procedure Check_Qualified_Aggregate (Level : Nat; Expr : Node_Id) is\n-      Comp_Expr : Node_Id;\n-      Comp_Assn : Node_Id;\n-\n-   begin\n-      if Level = 0 then\n-         if Nkind (Parent (Expr)) /= N_Qualified_Expression then\n-            Check_SPARK_05_Restriction (\"aggregate should be qualified\", Expr);\n-         end if;\n-\n-      else\n-         Comp_Expr := First (Expressions (Expr));\n-         while Present (Comp_Expr) loop\n-            if Nkind (Comp_Expr) = N_Aggregate then\n-               Check_Qualified_Aggregate (Level - 1, Comp_Expr);\n-            end if;\n-\n-            Comp_Expr := Next (Comp_Expr);\n-         end loop;\n-\n-         Comp_Assn := First (Component_Associations (Expr));\n-         while Present (Comp_Assn) loop\n-            Comp_Expr := Expression (Comp_Assn);\n-\n-            if Nkind (Comp_Expr) = N_Aggregate then\n-               Check_Qualified_Aggregate (Level - 1, Comp_Expr);\n-            end if;\n-\n-            Comp_Assn := Next (Comp_Assn);\n-         end loop;\n-      end if;\n-   end Check_Qualified_Aggregate;\n-\n    ----------------------------------------\n    -- Check_Static_Discriminated_Subtype --\n    ----------------------------------------\n@@ -853,17 +807,6 @@ package body Sem_Aggr is\n         and then No (Next (First (Choice_List (First (Assoc)))));\n    end Is_Single_Aggregate;\n \n-   ----------------------------\n-   -- Is_Top_Level_Aggregate --\n-   ----------------------------\n-\n-   function Is_Top_Level_Aggregate (Expr : Node_Id) return Boolean is\n-   begin\n-      return Nkind (Parent (Expr)) /= N_Aggregate\n-        and then (Nkind (Parent (Expr)) /= N_Component_Association\n-                   or else Nkind (Parent (Parent (Expr))) /= N_Aggregate);\n-   end Is_Top_Level_Aggregate;\n-\n    --------------------------------\n    -- Make_String_Into_Aggregate --\n    --------------------------------\n@@ -948,41 +891,6 @@ package body Sem_Aggr is\n          end;\n       end if;\n \n-      --  An unqualified aggregate is restricted in SPARK to:\n-\n-      --    An aggregate item inside an aggregate for a multi-dimensional array\n-\n-      --    An expression being assigned to an unconstrained array, but only if\n-      --    the aggregate specifies a value for OTHERS only.\n-\n-      if Nkind (Parent (N)) = N_Qualified_Expression then\n-         if Is_Array_Type (Typ) then\n-            Check_Qualified_Aggregate (Number_Dimensions (Typ), N);\n-         else\n-            Check_Qualified_Aggregate (1, N);\n-         end if;\n-      else\n-         if Is_Array_Type (Typ)\n-           and then Nkind (Parent (N)) = N_Assignment_Statement\n-           and then not Is_Constrained (Etype (Name (Parent (N))))\n-         then\n-            if not Is_Others_Aggregate (N) then\n-               Check_SPARK_05_Restriction\n-                 (\"array aggregate should have only OTHERS\", N);\n-            end if;\n-\n-         elsif Is_Top_Level_Aggregate (N) then\n-            Check_SPARK_05_Restriction (\"aggregate should be qualified\", N);\n-\n-         --  The legality of this unqualified aggregate is checked by calling\n-         --  Check_Qualified_Aggregate from one of its enclosing aggregate,\n-         --  unless one of these already causes an error to be issued.\n-\n-         else\n-            null;\n-         end if;\n-      end if;\n-\n       --  Check for aggregates not allowed in configurable run-time mode.\n       --  We allow all cases of aggregates that do not come from source, since\n       --  these are all assumed to be small (e.g. bounds of a string literal).\n@@ -2069,16 +1977,6 @@ package body Sem_Aggr is\n                      --  bounds of the array aggregate are within range.\n \n                      Set_Do_Range_Check (Choice, False);\n-\n-                     --  In SPARK, the choice must be static\n-\n-                     if not (Is_OK_Static_Expression (Choice)\n-                              or else (Nkind (Choice) = N_Range\n-                                        and then Is_OK_Static_Range (Choice)))\n-                     then\n-                        Check_SPARK_05_Restriction\n-                          (\"choice should be static\", Choice);\n-                     end if;\n                   end if;\n \n                   --  If we could not resolve the discrete choice stop here\n@@ -3257,7 +3155,6 @@ package body Sem_Aggr is\n       --  In SPARK, the ancestor part cannot be a type mark\n \n       if Is_Entity_Name (A) and then Is_Type (Entity (A)) then\n-         Check_SPARK_05_Restriction (\"ancestor part cannot be a type mark\", A);\n \n          --  AI05-0115: if the ancestor part is a subtype mark, the ancestor\n          --  must not have unknown discriminants.\n@@ -4332,12 +4229,6 @@ package body Sem_Aggr is\n       if Present (Component_Associations (N))\n         and then Present (First (Component_Associations (N)))\n       then\n-         if Present (Expressions (N)) then\n-            Check_SPARK_05_Restriction\n-              (\"named association cannot follow positional one\",\n-               First (Choices (First (Component_Associations (N)))));\n-         end if;\n-\n          declare\n             Assoc : Node_Id;\n \n@@ -4349,18 +4240,6 @@ package body Sem_Aggr is\n                     (\"iterated component association can only appear in an \"\n                      & \"array aggregate\", N);\n                   raise Unrecoverable_Error;\n-\n-               else\n-                  if List_Length (Choices (Assoc)) > 1 then\n-                     Check_SPARK_05_Restriction\n-                       (\"component association in record aggregate must \"\n-                        & \"contain a single choice\", Assoc);\n-                  end if;\n-\n-                  if Nkind (First (Choices (Assoc))) = N_Others_Choice then\n-                     Check_SPARK_05_Restriction\n-                       (\"record aggregate cannot contain OTHERS\", Assoc);\n-                  end if;\n                end if;\n \n                Assoc := Next (Assoc);"}, {"sha": "c59c0595547d311a669481c95baed154e4a7594a", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 72, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -359,9 +359,6 @@ package body Sem_Attr is\n       --  Verify that prefix of attribute N is a float type and that\n       --  two attribute expressions are present\n \n-      procedure Check_SPARK_05_Restriction_On_Attribute;\n-      --  Issue an error in formal mode because attribute N is allowed\n-\n       procedure Check_Integer_Type;\n       --  Verify that prefix of attribute N is an integer type\n \n@@ -813,7 +810,6 @@ package body Sem_Attr is\n       --  Start of processing for Analyze_Access_Attribute\n \n       begin\n-         Check_SPARK_05_Restriction_On_Attribute;\n          Check_E0;\n \n          if Nkind (P) = N_Character_Literal then\n@@ -1428,8 +1424,6 @@ package body Sem_Attr is\n \n       procedure Analyze_Image_Attribute (Str_Typ : Entity_Id) is\n       begin\n-         Check_SPARK_05_Restriction_On_Attribute;\n-\n          --  AI12-0124: The ARG has adopted the GNAT semantics of 'Img for\n          --  scalar types, so that the prefix can be an object, a named value,\n          --  or a type. If the prefix is an object, there is no argument.\n@@ -2312,16 +2306,6 @@ package body Sem_Attr is\n          end if;\n       end Check_Scalar_Type;\n \n-      ------------------------------------------\n-      -- Check_SPARK_05_Restriction_On_Attribute --\n-      ------------------------------------------\n-\n-      procedure Check_SPARK_05_Restriction_On_Attribute is\n-      begin\n-         Error_Msg_Name_1 := Aname;\n-         Check_SPARK_05_Restriction (\"attribute % is not allowed\", P);\n-      end Check_SPARK_05_Restriction_On_Attribute;\n-\n       ---------------------------\n       -- Check_Standard_Prefix --\n       ---------------------------\n@@ -3056,21 +3040,6 @@ package body Sem_Attr is\n          end if;\n       end if;\n \n-      --  In SPARK, attributes of private types are only allowed if the full\n-      --  type declaration is visible.\n-\n-      --  Note: the check for Present (Entity (P)) defends against some error\n-      --  conditions where the Entity field is not set.\n-\n-      if Is_Entity_Name (P) and then Present (Entity (P))\n-        and then Is_Type (Entity (P))\n-        and then Is_Private_Type (P_Type)\n-        and then not In_Open_Scopes (Scope (P_Type))\n-        and then not In_Spec_Expression\n-      then\n-         Check_SPARK_05_Restriction (\"invisible attribute of type\", N);\n-      end if;\n-\n       --  Remaining processing depends on attribute\n \n       case Attr_Id is\n@@ -3239,12 +3208,6 @@ package body Sem_Attr is\n               (\"?r?redundant attribute, & is its own base type\", N, Typ);\n          end if;\n \n-         if Nkind (Parent (N)) /= N_Attribute_Reference then\n-            Error_Msg_Name_1 := Aname;\n-            Check_SPARK_05_Restriction\n-              (\"attribute% is only allowed as prefix of another attribute\", P);\n-         end if;\n-\n          Set_Etype (N, Base_Type (Entity (P)));\n          Set_Entity (N, Base_Type (Entity (P)));\n          Rewrite (N, New_Occurrence_Of (Entity (N), Loc));\n@@ -5230,14 +5193,6 @@ package body Sem_Attr is\n       when Attribute_Pos =>\n          Check_Discrete_Type;\n          Check_E1;\n-\n-         if Is_Boolean_Type (P_Type) then\n-            Error_Msg_Name_1 := Aname;\n-            Error_Msg_Name_2 := Chars (P_Type);\n-            Check_SPARK_05_Restriction\n-              (\"attribute% is not allowed for type%\", P);\n-         end if;\n-\n          Resolve (E1, P_Base_Type);\n          Set_Etype (N, Universal_Integer);\n \n@@ -5256,14 +5211,6 @@ package body Sem_Attr is\n       when Attribute_Pred =>\n          Check_Scalar_Type;\n          Check_E1;\n-\n-         if Is_Real_Type (P_Type) or else Is_Boolean_Type (P_Type) then\n-            Error_Msg_Name_1 := Aname;\n-            Error_Msg_Name_2 := Chars (P_Type);\n-            Check_SPARK_05_Restriction\n-              (\"attribute% is not allowed for type%\", P);\n-         end if;\n-\n          Resolve (E1, P_Base_Type);\n          Set_Etype (N, P_Base_Type);\n \n@@ -6175,14 +6122,6 @@ package body Sem_Attr is\n       when Attribute_Succ =>\n          Check_Scalar_Type;\n          Check_E1;\n-\n-         if Is_Real_Type (P_Type) or else Is_Boolean_Type (P_Type) then\n-            Error_Msg_Name_1 := Aname;\n-            Error_Msg_Name_2 := Chars (P_Type);\n-            Check_SPARK_05_Restriction\n-              (\"attribute% is not allowed for type%\", P);\n-         end if;\n-\n          Resolve (E1, P_Base_Type);\n          Set_Etype (N, P_Base_Type);\n \n@@ -6982,13 +6921,6 @@ package body Sem_Attr is\n          Check_E1;\n          Check_Discrete_Type;\n \n-         if Is_Boolean_Type (P_Type) then\n-            Error_Msg_Name_1 := Aname;\n-            Error_Msg_Name_2 := Chars (P_Type);\n-            Check_SPARK_05_Restriction\n-              (\"attribute% is not allowed for type%\", P);\n-         end if;\n-\n          --  Note, we need a range check in general, but we wait for the\n          --  Resolve call to do this, since we want to let Eval_Attribute\n          --  have a chance to find an static illegality first.\n@@ -7090,7 +7022,6 @@ package body Sem_Attr is\n       -----------\n \n       when Attribute_Value =>\n-         Check_SPARK_05_Restriction_On_Attribute;\n          Check_E1;\n          Check_Scalar_Type;\n \n@@ -7181,7 +7112,6 @@ package body Sem_Attr is\n       ----------------\n \n       when Attribute_Wide_Value =>\n-         Check_SPARK_05_Restriction_On_Attribute;\n          Check_E1;\n          Check_Scalar_Type;\n \n@@ -7235,7 +7165,6 @@ package body Sem_Attr is\n       ----------------\n \n       when Attribute_Wide_Width =>\n-         Check_SPARK_05_Restriction_On_Attribute;\n          Check_E0;\n          Check_Scalar_Type;\n          Set_Etype (N, Universal_Integer);\n@@ -7245,7 +7174,6 @@ package body Sem_Attr is\n       -----------\n \n       when Attribute_Width =>\n-         Check_SPARK_05_Restriction_On_Attribute;\n          Check_E0;\n          Check_Scalar_Type;\n          Set_Etype (N, Universal_Integer);\n@@ -11316,6 +11244,7 @@ package body Sem_Attr is\n                --  will be reported when resolving the call.\n \n                if Attr_Id /= Attribute_Unrestricted_Access then\n+                  Error_Msg_Name_1 := Aname;\n                   Error_Msg_N (\"prefix of % attribute must be aliased\", P);\n \n                --  Check for unrestricted access where expected type is a thin"}, {"sha": "ea7f3641ada4702b5bc63a920cb9904d3453ee3d", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -460,8 +460,6 @@ package body Sem_Ch11 is\n          Check_Compiler_Unit (\"raise expression\", N);\n       end if;\n \n-      Check_SPARK_05_Restriction (\"raise expression is not allowed\", N);\n-\n       --  Check exception restrictions on the original source\n \n       if Comes_From_Source (N) then\n@@ -517,10 +515,6 @@ package body Sem_Ch11 is\n       Par            : Node_Id;\n \n    begin\n-      if Comes_From_Source (N) then\n-         Check_SPARK_05_Restriction (\"raise statement is not allowed\", N);\n-      end if;\n-\n       Check_Unreachable_Code (N);\n \n       --  Check exception restrictions on the original source\n@@ -722,10 +716,6 @@ package body Sem_Ch11 is\n    --  Start of processing for Analyze_Raise_xxx_Error\n \n    begin\n-      if Nkind (Original_Node (N)) = N_Raise_Statement then\n-         Check_SPARK_05_Restriction (\"raise statement is not allowed\", N);\n-      end if;\n-\n       if No (Etype (N)) then\n          Set_Etype (N, Standard_Void_Type);\n       end if;"}, {"sha": "91c86feade67f7a1db77f6a168a8636c0167c31a", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -3576,8 +3576,6 @@ package body Sem_Ch12 is\n       Save_Parent : Node_Id;\n \n    begin\n-      Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n-\n       --  A generic may grant access to its private enclosing context depending\n       --  on the placement of its corresponding body. From elaboration point of\n       --  view, the flow of execution may enter this private context, and then\n@@ -3782,8 +3780,6 @@ package body Sem_Ch12 is\n       Typ         : Entity_Id;\n \n    begin\n-      Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n-\n       --  A generic may grant access to its private enclosing context depending\n       --  on the placement of its corresponding body. From elaboration point of\n       --  view, the flow of execution may enter this private context, and then\n@@ -4115,8 +4111,6 @@ package body Sem_Ch12 is\n          Modes    => True,\n          Warnings => True);\n \n-      Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n-\n       --  Very first thing: check for Text_IO special unit in case we are\n       --  instantiating one of the children of [[Wide_]Wide_]Text_IO.\n \n@@ -5562,8 +5556,6 @@ package body Sem_Ch12 is\n          Modes    => True,\n          Warnings => True);\n \n-      Check_SPARK_05_Restriction (\"generic is not allowed\", N);\n-\n       --  Very first thing: check for special Text_IO unit in case we are\n       --  instantiating one of the children of [[Wide_]Wide_]Text_IO. Of course\n       --  such an instantiation is bogus (these are packages, not subprograms),"}, {"sha": "9cd1b35d5b49090f803be83798cab1c3079fd505", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 9, "deletions": 266, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -725,8 +725,6 @@ package body Sem_Ch3 is\n       Enclosing_Prot_Type : Entity_Id := Empty;\n \n    begin\n-      Check_SPARK_05_Restriction (\"access type is not allowed\", N);\n-\n       if Is_Entry (Current_Scope)\n         and then Is_Task_Type (Etype (Scope (Current_Scope)))\n       then\n@@ -1059,8 +1057,6 @@ package body Sem_Ch3 is\n    --  Start of processing for Access_Subprogram_Declaration\n \n    begin\n-      Check_SPARK_05_Restriction (\"access type is not allowed\", T_Def);\n-\n       --  Associate the Itype node with the inner full-type declaration or\n       --  subprogram spec or entry body. This is required to handle nested\n       --  anonymous declarations. For example:\n@@ -1320,8 +1316,6 @@ package body Sem_Ch3 is\n       Full_Desig : Entity_Id;\n \n    begin\n-      Check_SPARK_05_Restriction (\"access type is not allowed\", Def);\n-\n       --  Check for permissible use of incomplete type\n \n       if Nkind (S) /= N_Subtype_Indication then\n@@ -1932,10 +1926,6 @@ package body Sem_Ch3 is\n          T := Find_Type_Of_Object\n                 (Subtype_Indication (Component_Definition (N)), N);\n \n-         if not Nkind_In (Typ, N_Identifier, N_Expanded_Name) then\n-            Check_SPARK_05_Restriction (\"subtype mark required\", Typ);\n-         end if;\n-\n       --  Ada 2005 (AI-230): Access Definition case\n \n       else\n@@ -1986,7 +1976,6 @@ package body Sem_Ch3 is\n       --  package Sem).\n \n       if Present (E) then\n-         Check_SPARK_05_Restriction (\"default expression is not allowed\", E);\n          Preanalyze_Default_Expression (E, T);\n          Check_Initialization (T, E);\n \n@@ -2611,23 +2600,9 @@ package body Sem_Ch3 is\n    --  Start of processing for Analyze_Declarations\n \n    begin\n-      if Restriction_Check_Required (SPARK_05) then\n-         Check_Later_Vs_Basic_Declarations (L, During_Parsing => False);\n-      end if;\n-\n       Decl := First (L);\n       while Present (Decl) loop\n \n-         --  Package spec cannot contain a package declaration in SPARK\n-\n-         if Nkind (Decl) = N_Package_Declaration\n-           and then Nkind (Parent (L)) = N_Package_Specification\n-         then\n-            Check_SPARK_05_Restriction\n-              (\"package specification cannot contain a package declaration\",\n-               Decl);\n-         end if;\n-\n          --  Complete analysis of declaration\n \n          Analyze (Decl);\n@@ -3091,16 +3066,10 @@ package body Sem_Ch3 is\n          when N_Derived_Type_Definition =>\n             null;\n \n-         --  For record types, discriminants are allowed, unless we are in\n-         --  SPARK.\n+         --  For record types, discriminants are allowed.\n \n          when N_Record_Definition =>\n-            if Present (Discriminant_Specifications (N)) then\n-               Check_SPARK_05_Restriction\n-                 (\"discriminant type is not allowed\",\n-                  Defining_Identifier\n-                    (First (Discriminant_Specifications (N))));\n-            end if;\n+            null;\n \n          when others =>\n             if Present (Discriminant_Specifications (N)) then\n@@ -3211,12 +3180,6 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n-      --  Controlled type is not allowed in SPARK\n-\n-      if Is_Visibly_Controlled (T) then\n-         Check_SPARK_05_Restriction (\"controlled type is not allowed\", N);\n-      end if;\n-\n       --  Some common processing for all types\n \n       Set_Depends_On_Private (T, Has_Private_Component (T));\n@@ -3358,8 +3321,6 @@ package body Sem_Ch3 is\n       T : Entity_Id;\n \n    begin\n-      Check_SPARK_05_Restriction (\"incomplete type is not allowed\", N);\n-\n       Generate_Definition (Defining_Identifier (N));\n \n       --  Process an incomplete declaration. The identifier must not have been\n@@ -4170,38 +4131,10 @@ package body Sem_Ch3 is\n \n       Act_T := T;\n \n-      --  These checks should be performed before the initialization expression\n-      --  is considered, so that the Object_Definition node is still the same\n-      --  as in source code.\n-\n-      --  In SPARK, the nominal subtype is always given by a subtype mark\n-      --  and must not be unconstrained. (The only exception to this is the\n-      --  acceptance of declarations of constants of type String.)\n-\n-      if not Nkind_In (Object_Definition (N), N_Expanded_Name, N_Identifier)\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"subtype mark required\", Object_Definition (N));\n-\n-      elsif Is_Array_Type (T)\n-        and then not Is_Constrained (T)\n-        and then T /= Standard_String\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"subtype mark of constrained type expected\",\n-            Object_Definition (N));\n-      end if;\n-\n       if Is_Library_Level_Entity (Id) then\n          Check_Dynamic_Object (T);\n       end if;\n \n-      --  There are no aliased objects in SPARK\n-\n-      if Aliased_Present (N) then\n-         Check_SPARK_05_Restriction (\"aliased object is not allowed\", N);\n-      end if;\n-\n       --  Process initialization expression if present and not in error\n \n       if Present (E) and then E /= Error then\n@@ -4396,18 +4329,6 @@ package body Sem_Ch3 is\n          Apply_Scalar_Range_Check (E, T);\n          Apply_Static_Length_Check (E, T);\n \n-         if Nkind (Original_Node (N)) = N_Object_Declaration\n-           and then Comes_From_Source (Original_Node (N))\n-\n-           --  Only call test if needed\n-\n-           and then Restriction_Check_Required (SPARK_05)\n-           and then not Is_SPARK_05_Initialization_Expr (Original_Node (E))\n-         then\n-            Check_SPARK_05_Restriction\n-              (\"initialization expression is not appropriate\", E);\n-         end if;\n-\n          --  A formal parameter of a specific tagged type whose related\n          --  subprogram is subject to pragma Extensions_Visible with value\n          --  \"False\" cannot be implicitly converted to a class-wide type by\n@@ -4505,14 +4426,6 @@ package body Sem_Ch3 is\n \n       if not Is_Definite_Subtype (T) then\n \n-         --  In SPARK, a declaration of unconstrained type is allowed\n-         --  only for constants of type string.\n-\n-         if Is_String_Type (T) and then not Constant_Present (N) then\n-            Check_SPARK_05_Restriction\n-              (\"declaration of object of unconstrained type not allowed\", N);\n-         end if;\n-\n          --  Nothing to do in deferred constant case\n \n          if Constant_Present (N) and then No (E) then\n@@ -5410,73 +5323,13 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n-      --  Subtype of Boolean cannot have a constraint in SPARK\n-\n-      if Is_Boolean_Type (T)\n-        and then Nkind (Subtype_Indication (N)) = N_Subtype_Indication\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"subtype of Boolean cannot have constraint\", N);\n-      end if;\n-\n-      if Nkind (Subtype_Indication (N)) = N_Subtype_Indication then\n-         declare\n-            Cstr     : constant Node_Id := Constraint (Subtype_Indication (N));\n-            One_Cstr : Node_Id;\n-            Low      : Node_Id;\n-            High     : Node_Id;\n-\n-         begin\n-            if Nkind (Cstr) = N_Index_Or_Discriminant_Constraint then\n-               One_Cstr := First (Constraints (Cstr));\n-               while Present (One_Cstr) loop\n-\n-                  --  Index or discriminant constraint in SPARK must be a\n-                  --  subtype mark.\n-\n-                  if not\n-                    Nkind_In (One_Cstr, N_Identifier, N_Expanded_Name)\n-                  then\n-                     Check_SPARK_05_Restriction\n-                       (\"subtype mark required\", One_Cstr);\n-\n-                  --  String subtype must have a lower bound of 1 in SPARK.\n-                  --  Note that we do not need to test for the nonstatic case\n-                  --  here, since that was already taken care of in\n-                  --  Process_Range_Expr_In_Decl.\n-\n-                  elsif Base_Type (T) = Standard_String then\n-                     Get_Index_Bounds (One_Cstr, Low, High);\n-\n-                     if Is_OK_Static_Expression (Low)\n-                       and then Expr_Value (Low) /= 1\n-                     then\n-                        Check_SPARK_05_Restriction\n-                          (\"String subtype must have lower bound of 1\", N);\n-                     end if;\n-                  end if;\n-\n-                  Next (One_Cstr);\n-               end loop;\n-            end if;\n-         end;\n-      end if;\n-\n       --  In the case where there is no constraint given in the subtype\n       --  indication, Process_Subtype just returns the Subtype_Mark, so its\n       --  semantic attributes must be established here.\n \n       if Nkind (Subtype_Indication (N)) /= N_Subtype_Indication then\n          Set_Etype (Id, Base_Type (T));\n \n-         --  Subtype of unconstrained array without constraint is not allowed\n-         --  in SPARK.\n-\n-         if Is_Array_Type (T) and then not Is_Constrained (T) then\n-            Check_SPARK_05_Restriction\n-              (\"subtype of unconstrained array must have constraint\", N);\n-         end if;\n-\n          case Ekind (T) is\n             when Array_Kind =>\n                Set_Ekind                     (Id, E_Array_Subtype);\n@@ -6140,12 +5993,6 @@ package body Sem_Ch3 is\n             Set_Etype (Index, Standard_Boolean);\n          end if;\n \n-         --  Check SPARK restriction requiring a subtype mark\n-\n-         if not Nkind_In (Index, N_Identifier, N_Expanded_Name) then\n-            Check_SPARK_05_Restriction (\"subtype mark required\", Index);\n-         end if;\n-\n          --  Add a subtype declaration for each index of private array type\n          --  declaration whose type is also private. For example:\n \n@@ -6221,14 +6068,8 @@ package body Sem_Ch3 is\n \n       if Present (Component_Typ) then\n          Element_Type := Process_Subtype (Component_Typ, P, Related_Id, 'C');\n-\n          Set_Etype (Component_Typ, Element_Type);\n \n-         if not Nkind_In (Component_Typ, N_Identifier, N_Expanded_Name) then\n-            Check_SPARK_05_Restriction\n-              (\"subtype mark required\", Component_Typ);\n-         end if;\n-\n       --  Ada 2005 (AI-230): Access Definition case\n \n       else pragma Assert (Present (Access_Definition (Component_Def)));\n@@ -6339,8 +6180,6 @@ package body Sem_Ch3 is\n       Set_Packed_Array_Impl_Type (T, Empty);\n \n       if Aliased_Present (Component_Definition (Def)) then\n-         Check_SPARK_05_Restriction\n-           (\"aliased is not allowed\", Component_Definition (Def));\n          Set_Has_Aliased_Components (Etype (T));\n \n          --  AI12-001: All aliased objects are considered to be specified as\n@@ -13855,8 +13694,6 @@ package body Sem_Ch3 is\n       else\n          pragma Assert (Nkind (C) = N_Digits_Constraint);\n \n-         Check_SPARK_05_Restriction (\"digits constraint is not allowed\", S);\n-\n          Digits_Expr := Digits_Expression (C);\n          Analyze_And_Resolve (Digits_Expr, Any_Integer);\n \n@@ -14098,8 +13935,6 @@ package body Sem_Ch3 is\n       --  Digits constraint present\n \n       if Nkind (C) = N_Digits_Constraint then\n-\n-         Check_SPARK_05_Restriction (\"digits constraint is not allowed\", S);\n          Check_Restriction (No_Obsolescent_Features, C);\n \n          if Warn_On_Obsolescent_Feature then\n@@ -14332,8 +14167,6 @@ package body Sem_Ch3 is\n       --  Delta constraint present\n \n       if Nkind (C) = N_Delta_Constraint then\n-\n-         Check_SPARK_05_Restriction (\"delta constraint is not allowed\", S);\n          Check_Restriction (No_Obsolescent_Features, C);\n \n          if Warn_On_Obsolescent_Feature then\n@@ -14979,8 +14812,6 @@ package body Sem_Ch3 is\n       Bound_Val     : Ureal;\n \n    begin\n-      Check_SPARK_05_Restriction\n-        (\"decimal fixed point type is not allowed\", Def);\n       Check_Restriction (No_Fixed_Point, Def);\n \n       --  Create implicit base type\n@@ -16622,8 +16453,6 @@ package body Sem_Ch3 is\n       --  parent is also an interface.\n \n       if Interface_Present (Def) then\n-         Check_SPARK_05_Restriction (\"interface is not allowed\", Def);\n-\n          if not Is_Interface (Parent_Type) then\n             Diagnose_Interface (Indic, Parent_Type);\n \n@@ -16869,11 +16698,6 @@ package body Sem_Ch3 is\n             if Is_Type (T) then\n                Set_Has_Discriminants (T, False);\n             end if;\n-\n-         --  The type is allowed to have discriminants\n-\n-         else\n-            Check_SPARK_05_Restriction (\"discriminant type is not allowed\", N);\n          end if;\n       end if;\n \n@@ -17060,14 +16884,6 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n       end if;\n-\n-      --  In SPARK, there are no derived type definitions other than type\n-      --  extensions of tagged record types.\n-\n-      if No (Extension) then\n-         Check_SPARK_05_Restriction\n-           (\"derived type is not allowed\", Original_Node (N));\n-      end if;\n    end Derived_Type_Declaration;\n \n    ------------------------\n@@ -19184,8 +19000,7 @@ package body Sem_Ch3 is\n      (N            : Node_Id;\n       Related_Nod  : Node_Id;\n       Related_Id   : Entity_Id := Empty;\n-      Suffix_Index : Nat       := 1;\n-      In_Iter_Schm : Boolean   := False)\n+      Suffix_Index : Nat       := 1)\n    is\n       R      : Node_Id;\n       T      : Entity_Id;\n@@ -19297,7 +19112,7 @@ package body Sem_Ch3 is\n          end if;\n \n          R := N;\n-         Process_Range_Expr_In_Decl (R, T, In_Iter_Schm => In_Iter_Schm);\n+         Process_Range_Expr_In_Decl (R, T);\n \n       elsif Nkind (N) = N_Subtype_Indication then\n \n@@ -19314,8 +19129,7 @@ package body Sem_Ch3 is\n          R := Range_Expression (Constraint (N));\n \n          Resolve (R, T);\n-         Process_Range_Expr_In_Decl\n-           (R, Entity (Subtype_Mark (N)), In_Iter_Schm => In_Iter_Schm);\n+         Process_Range_Expr_In_Decl (R, Entity (Subtype_Mark (N)));\n \n       elsif Nkind (N) = N_Attribute_Reference then\n \n@@ -19576,7 +19390,6 @@ package body Sem_Ch3 is\n          --  Nonbinary case\n \n          elsif M_Val < 2 ** Bits then\n-            Check_SPARK_05_Restriction (\"modulus should be a power of 2\", T);\n             Set_Non_Binary_Modulus (T);\n \n             if Bits > System_Max_Nonbinary_Modulus_Power then\n@@ -20584,15 +20397,6 @@ package body Sem_Ch3 is\n          --  ELSE.\n \n          else\n-            --  In formal mode, when completing a private extension the type\n-            --  named in the private part must be exactly the same as that\n-            --  named in the visible part.\n-\n-            if Priv_Parent /= Full_Parent then\n-               Error_Msg_Name_1 := Chars (Priv_Parent);\n-               Check_SPARK_05_Restriction (\"% expected\", Full_Indic);\n-            end if;\n-\n             --  Check the rules of 7.3(10): if the private extension inherits\n             --  known discriminants, then the full type must also inherit those\n             --  discriminants from the same (ancestor) type, and the parent\n@@ -21225,8 +21029,7 @@ package body Sem_Ch3 is\n       T            : Entity_Id;\n       Subtyp       : Entity_Id := Empty;\n       Check_List   : List_Id   := No_List;\n-      R_Check_Off  : Boolean   := False;\n-      In_Iter_Schm : Boolean   := False)\n+      R_Check_Off  : Boolean   := False)\n    is\n       Lo, Hi      : Node_Id;\n       R_Checks    : Check_Result;\n@@ -21237,16 +21040,6 @@ package body Sem_Ch3 is\n       Analyze_And_Resolve (R, Base_Type (T));\n \n       if Nkind (R) = N_Range then\n-\n-         --  In SPARK, all ranges should be static, with the exception of the\n-         --  discrete type definition of a loop parameter specification.\n-\n-         if not In_Iter_Schm\n-           and then not Is_OK_Static_Range (R)\n-         then\n-            Check_SPARK_05_Restriction (\"range should be static\", R);\n-         end if;\n-\n          Lo := Low_Bound (R);\n          Hi := High_Bound (R);\n \n@@ -21967,14 +21760,6 @@ package body Sem_Ch3 is\n       --  Normal case\n \n       if Ada_Version < Ada_2005 or else not Interface_Present (Def) then\n-         if Limited_Present (Def) then\n-            Check_SPARK_05_Restriction (\"limited is not allowed\", N);\n-         end if;\n-\n-         if Abstract_Present (Def) then\n-            Check_SPARK_05_Restriction (\"abstract is not allowed\", N);\n-         end if;\n-\n          --  The flag Is_Tagged_Type might have already been set by\n          --  Find_Type_Name if it detected an error for declaration T. This\n          --  arises in the case of private tagged types where the full view\n@@ -21998,8 +21783,6 @@ package body Sem_Ch3 is\n                                       or else Abstract_Present (Def));\n \n       else\n-         Check_SPARK_05_Restriction (\"interface is not allowed\", N);\n-\n          Is_Tagged := True;\n          Analyze_Interface_Declaration (T, Def);\n \n@@ -22141,40 +21924,6 @@ package body Sem_Ch3 is\n          T := Prev_T;\n       end if;\n \n-      --  In SPARK, tagged types and type extensions may only be declared in\n-      --  the specification of library unit packages.\n-\n-      if Present (Def) and then Is_Tagged_Type (T) then\n-         declare\n-            Typ  : Node_Id;\n-            Ctxt : Node_Id;\n-\n-         begin\n-            if Nkind (Parent (Def)) = N_Full_Type_Declaration then\n-               Typ := Parent (Def);\n-            else\n-               pragma Assert\n-                 (Nkind (Parent (Def)) = N_Derived_Type_Definition);\n-               Typ := Parent (Parent (Def));\n-            end if;\n-\n-            Ctxt := Parent (Typ);\n-\n-            if Nkind (Ctxt) = N_Package_Body\n-              and then Nkind (Parent (Ctxt)) = N_Compilation_Unit\n-            then\n-               Check_SPARK_05_Restriction\n-                 (\"type should be defined in package specification\", Typ);\n-\n-            elsif Nkind (Ctxt) /= N_Package_Specification\n-              or else Nkind (Parent (Parent (Ctxt))) /= N_Compilation_Unit\n-            then\n-               Check_SPARK_05_Restriction\n-                 (\"type should be defined in library unit package\", Typ);\n-            end if;\n-         end;\n-      end if;\n-\n       Final_Storage_Only := not Is_Controlled (T);\n \n       --  Ada 2005: Check whether an explicit Limited is present in a derived\n@@ -22193,19 +21942,13 @@ package body Sem_Ch3 is\n       --  record extension, in which case the current scope may have inherited\n       --  components.\n \n-      if No (Def)\n-        or else No (Component_List (Def))\n-        or else Null_Present (Component_List (Def))\n+      if Present (Def)\n+        and then Present (Component_List (Def))\n+        and then not Null_Present (Component_List (Def))\n       then\n-         if not Is_Tagged_Type (T) then\n-            Check_SPARK_05_Restriction (\"untagged record cannot be null\", Def);\n-         end if;\n-\n-      else\n          Analyze_Declarations (Component_Items (Component_List (Def)));\n \n          if Present (Variant_Part (Component_List (Def))) then\n-            Check_SPARK_05_Restriction (\"variant part is not allowed\", Def);\n             Analyze (Variant_Part (Component_List (Def)));\n          end if;\n       end if;"}, {"sha": "02fe39ba76c275db30f7343033b87f6ea7f8085b", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -195,17 +195,15 @@ package Sem_Ch3 is\n      (N            : Node_Id;\n       Related_Nod  : Node_Id;\n       Related_Id   : Entity_Id := Empty;\n-      Suffix_Index : Nat       := 1;\n-      In_Iter_Schm : Boolean   := False);\n+      Suffix_Index : Nat       := 1);\n    --  Process an index that is given in an array declaration, an entry\n    --  family declaration or a loop iteration. The index is given by an index\n    --  declaration (a 'box'), or by a discrete range. The later can be the name\n    --  of a discrete type, or a subtype indication.\n    --\n    --  Related_Nod is the node where the potential generated implicit types\n    --  will be inserted. The next last parameters are used for creating the\n-   --  name. In_Iter_Schm is True if Make_Index is called on the discrete\n-   --  subtype definition in an iteration scheme.\n+   --  name.\n \n    procedure Make_Class_Wide_Type (T : Entity_Id);\n    --  A Class_Wide_Type is created for each tagged type definition. The\n@@ -265,8 +263,7 @@ package Sem_Ch3 is\n       T            : Entity_Id;\n       Subtyp       : Entity_Id := Empty;\n       Check_List   : List_Id   := No_List;\n-      R_Check_Off  : Boolean   := False;\n-      In_Iter_Schm : Boolean   := False);\n+      R_Check_Off  : Boolean   := False);\n    --  Process a range expression that appears in a declaration context. The\n    --  range is analyzed and resolved with the base type of the given type, and\n    --  an appropriate check for expressions in non-static contexts made on the\n@@ -277,8 +274,7 @@ package Sem_Ch3 is\n    --  when the subprogram is called from Build_Record_Init_Proc and is used to\n    --  return a set of constraint checking statements generated by the Checks\n    --  package. R_Check_Off is set to True when the call to Range_Check is to\n-   --  be skipped. In_Iter_Schm is True if Process_Range_Expr_In_Decl is called\n-   --  on the discrete subtype definition in an iteration scheme.\n+   --  be skipped.\n    --\n    --  If Subtyp is given, then the range is for the named subtype Subtyp, and\n    --  in this case the bounds are captured if necessary using this name."}, {"sha": "4a80ff085be8b0bc899d8eff6bd7f4db6f352ef2", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -469,8 +469,6 @@ package body Sem_Ch4 is\n       Onode    : Node_Id;\n \n    begin\n-      Check_SPARK_05_Restriction (\"allocator is not allowed\", N);\n-\n       --  Deal with allocator restrictions\n \n       --  In accordance with H.4(7), the No_Allocators restriction only applies\n@@ -997,10 +995,6 @@ package body Sem_Ch4 is\n       --  Flag indicates whether an interpretation of the prefix is a\n       --  parameterless call that returns an access_to_subprogram.\n \n-      procedure Check_Mixed_Parameter_And_Named_Associations;\n-      --  Check that parameter and named associations are not mixed. This is\n-      --  a restriction in SPARK mode.\n-\n       procedure Check_Writable_Actuals (N : Node_Id);\n       --  If the call has out or in-out parameters then mark its outermost\n       --  enclosing construct as a node on which the writable actuals check\n@@ -1016,36 +1010,6 @@ package body Sem_Ch4 is\n       procedure No_Interpretation;\n       --  Output error message when no valid interpretation exists\n \n-      --------------------------------------------------\n-      -- Check_Mixed_Parameter_And_Named_Associations --\n-      --------------------------------------------------\n-\n-      procedure Check_Mixed_Parameter_And_Named_Associations is\n-         Actual     : Node_Id;\n-         Named_Seen : Boolean;\n-\n-      begin\n-         Named_Seen := False;\n-\n-         Actual := First (Actuals);\n-         while Present (Actual) loop\n-            case Nkind (Actual) is\n-               when N_Parameter_Association =>\n-                  if Named_Seen then\n-                     Check_SPARK_05_Restriction\n-                       (\"named association cannot follow positional one\",\n-                        Actual);\n-                     exit;\n-                  end if;\n-\n-               when others =>\n-                  Named_Seen := True;\n-            end case;\n-\n-            Next (Actual);\n-         end loop;\n-      end Check_Mixed_Parameter_And_Named_Associations;\n-\n       ----------------------------\n       -- Check_Writable_Actuals --\n       ----------------------------\n@@ -1187,10 +1151,6 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Call\n \n    begin\n-      if Restriction_Check_Required (SPARK_05) then\n-         Check_Mixed_Parameter_And_Named_Associations;\n-      end if;\n-\n       --  Initialize the type of the result of the call to the error type,\n       --  which will be reset if the type is successfully resolved.\n \n@@ -2092,13 +2052,6 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Explicit_Dereference\n \n    begin\n-      --  If source node, check SPARK restriction. We guard this with the\n-      --  source node check, because ???\n-\n-      if Comes_From_Source (N) then\n-         Check_SPARK_05_Restriction (\"explicit dereference is not allowed\", N);\n-      end if;\n-\n       --  In formal verification mode, keep track of all reads and writes\n       --  through explicit dereferences.\n \n@@ -2317,10 +2270,6 @@ package body Sem_Ch4 is\n \n       Else_Expr := Next (Then_Expr);\n \n-      if Comes_From_Source (N) then\n-         Check_SPARK_05_Restriction (\"if expression is not allowed\", N);\n-      end if;\n-\n       if Comes_From_Source (N) then\n          Check_Compiler_Unit (\"if expression\", N);\n       end if;\n@@ -3182,8 +3131,6 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Null (N : Node_Id) is\n    begin\n-      Check_SPARK_05_Restriction (\"null is not allowed\", N);\n-\n       Set_Etype (N, Any_Access);\n    end Analyze_Null;\n \n@@ -4131,8 +4078,6 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Quantified_Expression\n \n    begin\n-      Check_SPARK_05_Restriction (\"quantified expression is not allowed\", N);\n-\n       --  Create a scope to emulate the loop-like behavior of the quantified\n       --  expression. The scope is needed to provide proper visibility of the\n       --  loop variable.\n@@ -5499,10 +5444,6 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Slice\n \n    begin\n-      if Comes_From_Source (N) then\n-         Check_SPARK_05_Restriction (\"slice is not allowed\", N);\n-      end if;\n-\n       Analyze (P);\n       Analyze (D);\n "}, {"sha": "e6766c756852c5e51a00d9a819952280040e8e62", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 5, "deletions": 81, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -39,8 +39,6 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Case; use Sem_Case;\n@@ -1263,13 +1261,6 @@ package body Sem_Ch5 is\n    --  Start of processing for Analyze_Block_Statement\n \n    begin\n-      --  In SPARK mode, we reject block statements. Note that the case of\n-      --  block statements generated by the expander is fine.\n-\n-      if Nkind (Original_Node (N)) = N_Block_Statement then\n-         Check_SPARK_05_Restriction (\"block statement is not allowed\", N);\n-      end if;\n-\n       --  If no handled statement sequence is present, things are really messed\n       --  up, and we just return immediately (defence against previous errors).\n \n@@ -1583,13 +1574,6 @@ package body Sem_Ch5 is\n       Analyze_Choices (Alternatives (N), Exp_Type);\n       Check_Choices (N, Alternatives (N), Exp_Type, Others_Present);\n \n-      --  Case statement with single OTHERS alternative not allowed in SPARK\n-\n-      if Others_Present and then List_Length (Alternatives (N)) = 1 then\n-         Check_SPARK_05_Restriction\n-           (\"OTHERS as unique case alternative is not allowed\", N);\n-      end if;\n-\n       if Exp_Type = Universal_Integer and then not Others_Present then\n          Error_Msg_N (\"case on universal integer requires OTHERS choice\", Exp);\n       end if;\n@@ -1672,11 +1656,6 @@ package body Sem_Ch5 is\n             return;\n \n          else\n-            if Has_Loop_In_Inner_Open_Scopes (U_Name) then\n-               Check_SPARK_05_Restriction\n-                 (\"exit label must name the closest enclosing loop\", N);\n-            end if;\n-\n             Set_Has_Exit (U_Name);\n          end if;\n \n@@ -1712,42 +1691,6 @@ package body Sem_Ch5 is\n          Check_Unset_Reference (Cond);\n       end if;\n \n-      --  In SPARK mode, verify that the exit statement respects the SPARK\n-      --  restrictions.\n-\n-      if Present (Cond) then\n-         if Nkind (Parent (N)) /= N_Loop_Statement then\n-            Check_SPARK_05_Restriction\n-              (\"exit with when clause must be directly in loop\", N);\n-         end if;\n-\n-      else\n-         if Nkind (Parent (N)) /= N_If_Statement then\n-            if Nkind (Parent (N)) = N_Elsif_Part then\n-               Check_SPARK_05_Restriction\n-                 (\"exit must be in IF without ELSIF\", N);\n-            else\n-               Check_SPARK_05_Restriction (\"exit must be directly in IF\", N);\n-            end if;\n-\n-         elsif Nkind (Parent (Parent (N))) /= N_Loop_Statement then\n-            Check_SPARK_05_Restriction\n-              (\"exit must be in IF directly in loop\", N);\n-\n-         --  First test the presence of ELSE, so that an exit in an ELSE leads\n-         --  to an error mentioning the ELSE.\n-\n-         elsif Present (Else_Statements (Parent (N))) then\n-            Check_SPARK_05_Restriction (\"exit must be in IF without ELSE\", N);\n-\n-         --  An exit in an ELSIF does not reach here, as it would have been\n-         --  detected in the case (Nkind (Parent (N)) /= N_If_Statement).\n-\n-         elsif Present (Elsif_Parts (Parent (N))) then\n-            Check_SPARK_05_Restriction (\"exit must be in IF without ELSIF\", N);\n-         end if;\n-      end if;\n-\n       --  Chain exit statement to associated loop entity\n \n       Set_Next_Exit_Statement  (N, First_Exit_Statement (Scope_Id));\n@@ -1772,8 +1715,6 @@ package body Sem_Ch5 is\n       Label_Ent   : Entity_Id;\n \n    begin\n-      Check_SPARK_05_Restriction (\"goto statement is not allowed\", N);\n-\n       --  Actual semantic checks\n \n       Check_Unreachable_Code (N);\n@@ -3015,13 +2956,6 @@ package body Sem_Ch5 is\n          end if;\n       end;\n \n-      --  Loop parameter specification must include subtype mark in SPARK\n-\n-      if Nkind (DS) = N_Range then\n-         Check_SPARK_05_Restriction\n-           (\"loop parameter specification must include subtype mark\", N);\n-      end if;\n-\n       --  Analyze the subtype definition and create temporaries for the bounds.\n       --  Do not evaluate the range when preanalyzing a quantified expression\n       --  because bounds expressed as function calls with side effects will be\n@@ -3160,7 +3094,7 @@ package body Sem_Ch5 is\n          Check_Predicate_Use (Entity (Subtype_Mark (DS)));\n       end if;\n \n-      Make_Index (DS, N, In_Iter_Schm => True);\n+      Make_Index (DS, N);\n       Set_Ekind (Id, E_Loop_Parameter);\n \n       --  A quantified expression which appears in a pre- or post-condition may\n@@ -4139,12 +4073,9 @@ package body Sem_Ch5 is\n             end loop;\n \n             --  If a label follows us, then we never have dead code, since\n-            --  someone could branch to the label, so we just ignore it, unless\n-            --  we are in formal mode where goto statements are not allowed.\n+            --  someone could branch to the label, so we just ignore it.\n \n-            if Nkind (Nxt) = N_Label\n-              and then not Restriction_Check_Required (SPARK_05)\n-            then\n+            if Nkind (Nxt) = N_Label then\n                return;\n \n             --  Otherwise see if we have a real statement following us\n@@ -4203,15 +4134,8 @@ package body Sem_Ch5 is\n                      end loop;\n                   end if;\n \n-                  --  Now issue the warning (or error in formal mode)\n-\n-                  if Restriction_Check_Required (SPARK_05) then\n-                     Check_SPARK_05_Restriction\n-                       (\"unreachable code is not allowed\", Error_Node);\n-                  else\n-                     Error_Msg\n-                       (\"??unreachable code!\", Sloc (Error_Node), Error_Node);\n-                  end if;\n+                  Error_Msg\n+                    (\"??unreachable code!\", Sloc (Error_Node), Error_Node);\n                end if;\n \n             --  If the unconditional transfer of control instruction is the"}, {"sha": "860db03f78eae24d1572488ea72a0f2473269565", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -225,8 +225,6 @@ package body Sem_Ch6 is\n                   Analyze_Subprogram_Specification (Specification (N));\n \n    begin\n-      Check_SPARK_05_Restriction (\"abstract subprogram is not allowed\", N);\n-\n       Generate_Definition (Subp_Id);\n \n       --  Set the SPARK mode from the current context (may be overwritten later\n@@ -1122,20 +1120,7 @@ package body Sem_Ch6 is\n \n             Check_Return_Construct_Accessibility (N);\n          end if;\n-\n-         --  RETURN only allowed in SPARK as the last statement in function\n-\n-         if Nkind (Parent (N)) /= N_Handled_Sequence_Of_Statements\n-           and then\n-             (Nkind (Parent (Parent (N))) /= N_Subprogram_Body\n-               or else Present (Next (N)))\n-         then\n-            Check_SPARK_05_Restriction\n-              (\"RETURN should be the last statement in function\", N);\n-         end if;\n-\n       else\n-         Check_SPARK_05_Restriction (\"extended RETURN is not allowed\", N);\n          Obj_Decl := Last (Return_Object_Declarations (N));\n \n          --  Analyze parts specific to extended_return_statement:\n@@ -2223,8 +2208,6 @@ package body Sem_Ch6 is\n \n       if Result_Definition (N) /= Error then\n          if Nkind (Result_Definition (N)) = N_Access_Definition then\n-            Check_SPARK_05_Restriction\n-              (\"access result is not allowed\", Result_Definition (N));\n \n             --  Ada 2005 (AI-254): Handle anonymous access to subprograms\n \n@@ -2254,14 +2237,6 @@ package body Sem_Ch6 is\n             Typ := Entity (Result_Definition (N));\n             Set_Etype (Designator, Typ);\n \n-            --  Unconstrained array as result is not allowed in SPARK\n-\n-            if Is_Array_Type (Typ) and then not Is_Constrained (Typ) then\n-               Check_SPARK_05_Restriction\n-                 (\"returning an unconstrained array is not allowed\",\n-                  Result_Definition (N));\n-            end if;\n-\n             --  Ada 2005 (AI-231): Ensure proper usage of null exclusion\n \n             Null_Exclusion_Static_Checks (N);\n@@ -3073,42 +3048,6 @@ package body Sem_Ch6 is\n                Check_Returns (HSS, 'P', Missing_Ret, Id);\n             end if;\n          end if;\n-\n-         --  Special checks in SPARK mode\n-\n-         if Nkind (Body_Spec) = N_Function_Specification then\n-\n-            --  In SPARK mode, last statement of a function should be a return\n-\n-            declare\n-               Stat : constant Node_Id := Last_Source_Statement (HSS);\n-            begin\n-               if Present (Stat)\n-                 and then not Nkind_In (Stat, N_Simple_Return_Statement,\n-                                              N_Extended_Return_Statement)\n-               then\n-                  Check_SPARK_05_Restriction\n-                    (\"last statement in function should be RETURN\", Stat);\n-               end if;\n-            end;\n-\n-         --  In SPARK mode, verify that a procedure has no return\n-\n-         elsif Nkind (Body_Spec) = N_Procedure_Specification then\n-            if Present (Spec_Id) then\n-               Id := Spec_Id;\n-            else\n-               Id := Body_Id;\n-            end if;\n-\n-            --  Would be nice to point to return statement here, can we\n-            --  borrow the Check_Returns procedure here ???\n-\n-            if Return_Present (Id) then\n-               Check_SPARK_05_Restriction\n-                 (\"procedure should not have RETURN\", N);\n-            end if;\n-         end if;\n       end Check_Missing_Return;\n \n       -----------------------\n@@ -4930,8 +4869,6 @@ package body Sem_Ch6 is\n       if Nkind (Specification (N)) = N_Procedure_Specification\n         and then Null_Present (Specification (N))\n       then\n-         Check_SPARK_05_Restriction (\"null procedure is not allowed\", N);\n-\n          --  Null procedures are allowed in protected types, following the\n          --  recent AI12-0147.\n \n@@ -5195,15 +5132,6 @@ package body Sem_Ch6 is\n    --  Start of processing for Analyze_Subprogram_Specification\n \n    begin\n-      --  User-defined operator is not allowed in SPARK, except as a renaming\n-\n-      if Nkind (Defining_Unit_Name (N)) = N_Defining_Operator_Symbol\n-        and then Nkind (Parent (N)) /= N_Subprogram_Renaming_Declaration\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"user-defined operator is not allowed\", N);\n-      end if;\n-\n       --  Proceed with analysis. Do not emit a cross-reference entry if the\n       --  specification comes from an expression function, because it may be\n       --  the completion of a previous declaration. If it is not, the cross-\n@@ -11563,14 +11491,6 @@ package body Sem_Ch6 is\n \n          Check_Ghost_Overriding (S, Overridden_Subp);\n \n-         --  Overloading is not allowed in SPARK, except for operators\n-\n-         if Nkind (S) /= N_Defining_Operator_Symbol then\n-            Error_Msg_Sloc := Sloc (Homonym (S));\n-            Check_SPARK_05_Restriction\n-              (\"overloading not allowed with entity#\", S);\n-         end if;\n-\n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent\n          --  operation was dispatching), so Check_Dispatching_Operation is not\n@@ -11902,9 +11822,6 @@ package body Sem_Ch6 is\n          Default := Expression (Param_Spec);\n \n          if Present (Default) then\n-            Check_SPARK_05_Restriction\n-              (\"default expression is not allowed\", Default);\n-\n             if Out_Present (Param_Spec) then\n                Error_Msg_N\n                  (\"default initialization only allowed for IN parameters\","}, {"sha": "fa17c8b5cbfe46fa4ce863926b599c2b230dbc88", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -47,7 +47,6 @@ with Nmake;     use Nmake;\n with Nlists;    use Nlists;\n with Opt;       use Opt;\n with Output;    use Output;\n-with Restrict;  use Restrict;\n with Rtsfind;   use Rtsfind;\n with Sem;       use Sem;\n with Sem_Aux;   use Sem_Aux;\n@@ -1271,10 +1270,6 @@ package body Sem_Ch7 is\n       --  private_with_clauses, and remove them at the end of the nested\n       --  package.\n \n-      procedure Check_One_Tagged_Type_Or_Extension_At_Most;\n-      --  Issue an error in SPARK mode if a package specification contains\n-      --  more than one tagged type or type extension.\n-\n       procedure Clear_Constants (Id : Entity_Id; FE : Entity_Id);\n       --  Clears constant indications (Never_Set_In_Source, Constant_Value, and\n       --  Is_True_Constant) on all variables that are entities of Id, and on\n@@ -1301,58 +1296,6 @@ package body Sem_Ch7 is\n       --  private part rather than being done in Sem_Ch12.Install_Parent\n       --  (which is where the parents' visible declarations are installed).\n \n-      ------------------------------------------------\n-      -- Check_One_Tagged_Type_Or_Extension_At_Most --\n-      ------------------------------------------------\n-\n-      procedure Check_One_Tagged_Type_Or_Extension_At_Most is\n-         Previous : Node_Id;\n-\n-         procedure Check_Decls (Decls : List_Id);\n-         --  Check that either Previous is Empty and Decls does not contain\n-         --  more than one tagged type or type extension, or Previous is\n-         --  already set and Decls contains no tagged type or type extension.\n-\n-         -----------------\n-         -- Check_Decls --\n-         -----------------\n-\n-         procedure Check_Decls (Decls : List_Id) is\n-            Decl : Node_Id;\n-\n-         begin\n-            Decl := First (Decls);\n-            while Present (Decl) loop\n-               if Nkind (Decl) = N_Full_Type_Declaration\n-                 and then Is_Tagged_Type (Defining_Identifier (Decl))\n-               then\n-                  if No (Previous) then\n-                     Previous := Decl;\n-\n-                  else\n-                     Error_Msg_Sloc := Sloc (Previous);\n-                     Check_SPARK_05_Restriction\n-                       (\"at most one tagged type or type extension allowed\",\n-                        \"\\\\ previous declaration#\",\n-                        Decl);\n-                  end if;\n-               end if;\n-\n-               Next (Decl);\n-            end loop;\n-         end Check_Decls;\n-\n-      --  Start of processing for Check_One_Tagged_Type_Or_Extension_At_Most\n-\n-      begin\n-         Previous := Empty;\n-         Check_Decls (Vis_Decls);\n-\n-         if Present (Priv_Decls) then\n-            Check_Decls (Priv_Decls);\n-         end if;\n-      end Check_One_Tagged_Type_Or_Extension_At_Most;\n-\n       ---------------------\n       -- Clear_Constants --\n       ---------------------\n@@ -1889,11 +1832,6 @@ package body Sem_Ch7 is\n          Clear_Constants (Id, First_Private_Entity (Id));\n       end if;\n \n-      --  Issue an error in SPARK mode if a package specification contains\n-      --  more than one tagged type or type extension.\n-\n-      Check_One_Tagged_Type_Or_Extension_At_Most;\n-\n       --  Output relevant information as to why the package requires a body.\n       --  Do not consider generated packages as this exposes internal symbols\n       --  and leads to confusing messages."}, {"sha": "709a83939852aa0a3907ca0f7f0133f2025b9886", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -568,8 +568,6 @@ package body Sem_Ch8 is\n       Nam : constant Node_Id   := Name (N);\n \n    begin\n-      Check_SPARK_05_Restriction (\"exception renaming is not allowed\", N);\n-\n       Enter_Name (Id);\n       Analyze (Nam);\n \n@@ -682,8 +680,6 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n-      Check_SPARK_05_Restriction (\"generic renaming is not allowed\", N);\n-\n       Generate_Definition (New_P);\n \n       if Current_Scope /= Standard_Standard then\n@@ -872,8 +868,6 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n-      Check_SPARK_05_Restriction (\"object renaming is not allowed\", N);\n-\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n       Enter_Name (Id);\n \n@@ -3898,8 +3892,6 @@ package body Sem_Ch8 is\n    --  Start of processing for Analyze_Use_Package\n \n    begin\n-      Check_SPARK_05_Restriction (\"use clause is not allowed\", N);\n-\n       Set_Hidden_By_Use_Clause (N, No_Elist);\n \n       --  Use clause not allowed in a spec of a predefined package declaration\n@@ -7240,21 +7232,6 @@ package body Sem_Ch8 is\n          return;\n       end if;\n \n-      --  Selector name cannot be a character literal or an operator symbol in\n-      --  SPARK, except for the operator symbol in a renaming.\n-\n-      if Restriction_Check_Required (SPARK_05) then\n-         if Nkind (Selector_Name (N)) = N_Character_Literal then\n-            Check_SPARK_05_Restriction\n-              (\"character literal cannot be prefixed\", N);\n-         elsif Nkind (Selector_Name (N)) = N_Operator_Symbol\n-           and then Nkind (Parent (N)) /= N_Subprogram_Renaming_Declaration\n-         then\n-            Check_SPARK_05_Restriction\n-              (\"operator symbol cannot be prefixed\", N);\n-         end if;\n-      end if;\n-\n       --  If the selector already has an entity, the node has been constructed\n       --  in the course of expansion, and is known to be valid. Do not verify\n       --  that it is defined for the type (it may be a private component used\n@@ -7709,21 +7686,6 @@ package body Sem_Ch8 is\n                Error_Msg_N (\"invalid prefix in selected component\", P);\n             end if;\n          end if;\n-\n-         --  Selector name is restricted in SPARK\n-\n-         if Nkind (N) = N_Expanded_Name\n-           and then Restriction_Check_Required (SPARK_05)\n-         then\n-            if Is_Subprogram (P_Name) then\n-               Check_SPARK_05_Restriction\n-                 (\"prefix of expanded name cannot be a subprogram\", P);\n-            elsif Ekind (P_Name) = E_Loop then\n-               Check_SPARK_05_Restriction\n-                 (\"prefix of expanded name cannot be a loop statement\", P);\n-            end if;\n-         end if;\n-\n       else\n          --  If prefix is not the name of an entity, it must be an expression,\n          --  whose type is appropriate for a record. This is determined by\n@@ -7881,10 +7843,6 @@ package body Sem_Ch8 is\n          --  Base attribute, not allowed in Ada 83\n \n          elsif Attribute_Name (N) = Name_Base then\n-            Error_Msg_Name_1 := Name_Base;\n-            Check_SPARK_05_Restriction\n-              (\"attribute% is only allowed as prefix of another attribute\", N);\n-\n             if Ada_Version = Ada_83 and then Comes_From_Source (N) then\n                Error_Msg_N\n                  (\"(Ada 83) Base attribute not allowed in subtype mark\", N);"}, {"sha": "5a7e3841804fb8d77d8636a38dfe1e798f7ecc8e", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -706,7 +706,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"abort statement is not allowed\", N);\n \n       T_Name := First (Names (N));\n       while Present (T_Name) loop\n@@ -777,7 +776,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"accept statement is not allowed\", N);\n \n       --  Entry name is initialized to Any_Id. It should get reset to the\n       --  matching entry entity. An error is signalled if it is not reset.\n@@ -1019,7 +1017,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"select statement is not allowed\", N);\n       Check_Restriction (Max_Asynchronous_Select_Nesting, N);\n       Check_Restriction (No_Select_Statements, N);\n \n@@ -1065,7 +1062,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"select statement is not allowed\", N);\n       Check_Restriction (No_Select_Statements, N);\n \n       --  Ada 2005 (AI-345): The trigger may be a dispatching call\n@@ -1163,7 +1159,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"delay statement is not allowed\", N);\n       Check_Restriction (No_Relative_Delay, N);\n       Check_Restriction (No_Delay, N);\n       Check_Potentially_Blocking_Operation (N);\n@@ -1189,7 +1184,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"delay statement is not allowed\", N);\n       Check_Restriction (No_Delay, N);\n       Check_Potentially_Blocking_Operation (N);\n       Analyze_And_Resolve (E);\n@@ -1505,7 +1499,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"entry call is not allowed\", N);\n \n       if Present (Pragmas_Before (N)) then\n          Analyze_List (Pragmas_Before (N));\n@@ -1956,7 +1949,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"protected definition is not allowed\", N);\n       Analyze_Declarations (Visible_Declarations (N));\n \n       if Present (Private_Declarations (N))\n@@ -2312,7 +2304,6 @@ package body Sem_Ch9 is\n          Warnings => True);\n \n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"requeue statement is not allowed\", N);\n       Check_Restriction (No_Requeue_Statements, N);\n       Check_Unreachable_Code (N);\n \n@@ -2606,7 +2597,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"select statement is not allowed\", N);\n       Check_Restriction (No_Select_Statements, N);\n \n       --  Loop to analyze alternatives\n@@ -3068,7 +3058,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"task definition is not allowed\", N);\n \n       if Present (Visible_Declarations (N)) then\n          Analyze_Declarations (Visible_Declarations (N));\n@@ -3310,7 +3299,6 @@ package body Sem_Ch9 is\n \n    begin\n       Tasking_Used := True;\n-      Check_SPARK_05_Restriction (\"select statement is not allowed\", N);\n       Check_Restriction (No_Select_Statements, N);\n \n       --  Ada 2005 (AI-345): The trigger may be a dispatching call"}, {"sha": "83cd20d7d9ad34747e49e980d8c29358399cf048", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 0, "deletions": 268, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -4276,71 +4276,6 @@ package body Sem_Res is\n                  (\"invalid use of untagged formal incomplete type\", A);\n             end if;\n \n-            if Comes_From_Source (Original_Node (N))\n-              and then Nkind_In (Original_Node (N), N_Function_Call,\n-                                                    N_Procedure_Call_Statement)\n-            then\n-               --  In formal mode, check that actual parameters matching\n-               --  formals of tagged types are objects (or ancestor type\n-               --  conversions of objects), not general expressions.\n-\n-               if Is_Actual_Tagged_Parameter (A) then\n-                  if Is_SPARK_05_Object_Reference (A) then\n-                     null;\n-\n-                  elsif Nkind (A) = N_Type_Conversion then\n-                     declare\n-                        Operand     : constant Node_Id   := Expression (A);\n-                        Operand_Typ : constant Entity_Id := Etype (Operand);\n-                        Target_Typ  : constant Entity_Id := A_Typ;\n-\n-                     begin\n-                        if not Is_SPARK_05_Object_Reference (Operand) then\n-                           Check_SPARK_05_Restriction\n-                             (\"object required\", Operand);\n-\n-                        --  In formal mode, the only view conversions are those\n-                        --  involving ancestor conversion of an extended type.\n-\n-                        elsif not\n-                          (Is_Tagged_Type (Target_Typ)\n-                           and then not Is_Class_Wide_Type (Target_Typ)\n-                           and then Is_Tagged_Type (Operand_Typ)\n-                           and then not Is_Class_Wide_Type (Operand_Typ)\n-                           and then Is_Ancestor (Target_Typ, Operand_Typ))\n-                        then\n-                           if Ekind_In\n-                             (F, E_Out_Parameter, E_In_Out_Parameter)\n-                           then\n-                              Check_SPARK_05_Restriction\n-                                (\"ancestor conversion is the only permitted \"\n-                                 & \"view conversion\", A);\n-                           else\n-                              Check_SPARK_05_Restriction\n-                                (\"ancestor conversion required\", A);\n-                           end if;\n-\n-                        else\n-                           null;\n-                        end if;\n-                     end;\n-\n-                  else\n-                     Check_SPARK_05_Restriction (\"object required\", A);\n-                  end if;\n-\n-               --  In formal mode, the only view conversions are those\n-               --  involving ancestor conversion of an extended type.\n-\n-               elsif Nkind (A) = N_Type_Conversion\n-                 and then Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter)\n-               then\n-                  Check_SPARK_05_Restriction\n-                    (\"ancestor conversion is the only permitted view \"\n-                     & \"conversion\", A);\n-               end if;\n-            end if;\n-\n             --  has warnings suppressed, then we reset Never_Set_In_Source for\n             --  the calling entity. The reason for this is to catch cases like\n             --  GNAT.Spitbol.Patterns.Vstring_Var where the called subprogram\n@@ -5916,20 +5851,6 @@ package body Sem_Res is\n       Analyze_Dimension (N);\n       Eval_Arithmetic_Op (N);\n \n-      --  In SPARK, a multiplication or division with operands of fixed point\n-      --  types must be qualified or explicitly converted to identify the\n-      --  result type.\n-\n-      if (Is_Fixed_Point_Type (Etype (L))\n-           or else Is_Fixed_Point_Type (Etype (R)))\n-        and then Nkind_In (N, N_Op_Multiply, N_Op_Divide)\n-        and then\n-          not Nkind_In (Parent (N), N_Qualified_Expression, N_Type_Conversion)\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"operation should be qualified or explicitly converted\", N);\n-      end if;\n-\n       --  Set overflow and division checking bit\n \n       if Nkind (N) in N_Op then\n@@ -6308,30 +6229,6 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      --  If the SPARK_05 restriction is active, we are not allowed\n-      --  to have a call to a subprogram before we see its completion.\n-\n-      if not Has_Completion (Nam)\n-        and then Restriction_Check_Required (SPARK_05)\n-\n-        --  Don't flag strange internal calls\n-\n-        and then Comes_From_Source (N)\n-        and then Comes_From_Source (Nam)\n-\n-        --  Only flag calls in extended main source\n-\n-        and then In_Extended_Main_Source_Unit (Nam)\n-        and then In_Extended_Main_Source_Unit (N)\n-\n-        --  Exclude enumeration literals from this processing\n-\n-        and then Ekind (Nam) /= E_Enumeration_Literal\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"call to subprogram cannot appear before its body\", N);\n-      end if;\n-\n       --  Check that this is not a call to a protected procedure or entry from\n       --  within a protected function.\n \n@@ -6566,16 +6463,6 @@ package body Sem_Res is\n       if Comes_From_Source (N) then\n          Scop := Current_Scope;\n \n-         --  Check violation of SPARK_05 restriction which does not permit\n-         --  a subprogram body to contain a call to the subprogram directly.\n-\n-         if Restriction_Check_Required (SPARK_05)\n-           and then Same_Or_Aliased_Subprograms (Nam, Scop)\n-         then\n-            Check_SPARK_05_Restriction\n-              (\"subprogram may not contain direct call to itself\", N);\n-         end if;\n-\n          --  Issue warning for possible infinite recursion in the absence\n          --  of the No_Recursion restriction.\n \n@@ -6933,17 +6820,6 @@ package body Sem_Res is\n \n       Check_For_Eliminated_Subprogram (Subp, Nam);\n \n-      --  In formal mode, the primitive operations of a tagged type or type\n-      --  extension do not include functions that return the tagged type.\n-\n-      if Nkind (N) = N_Function_Call\n-        and then Is_Tagged_Type (Etype (N))\n-        and then Is_Entity_Name (Name (N))\n-        and then Is_Inherited_Operation_For_Type (Entity (Name (N)), Etype (N))\n-      then\n-         Check_SPARK_05_Restriction (\"function not inherited\", N);\n-      end if;\n-\n       --  Implement rule in 12.5.1 (23.3/2): In an instance, if the actual is\n       --  class-wide and the call dispatches on result in a context that does\n       --  not provide a tag, the call raises Program_Error.\n@@ -7376,20 +7252,6 @@ package body Sem_Res is\n       Generate_Operator_Reference (N, T);\n       Check_Low_Bound_Tested (N);\n \n-      --  In SPARK, ordering operators <, <=, >, >= are not defined for Boolean\n-      --  types or array types except String.\n-\n-      if Is_Boolean_Type (T) then\n-         Check_SPARK_05_Restriction\n-           (\"comparison is not defined on Boolean type\", N);\n-\n-      elsif Is_Array_Type (T)\n-        and then Base_Type (T) /= Standard_String\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"comparison is not defined on array types other than String\", N);\n-      end if;\n-\n       --  Check comparison on unordered enumeration\n \n       if Bad_Unordered_Enumeration_Reference (N, Etype (L)) then\n@@ -8462,27 +8324,6 @@ package body Sem_Res is\n          Resolve (L, T);\n          Resolve (R, T);\n \n-         --  In SPARK, equality operators = and /= for array types other than\n-         --  String are only defined when, for each index position, the\n-         --  operands have equal static bounds.\n-\n-         if Is_Array_Type (T) then\n-\n-            --  Protect call to Matching_Static_Array_Bounds to avoid costly\n-            --  operation if not needed.\n-\n-            if Restriction_Check_Required (SPARK_05)\n-              and then Base_Type (T) /= Standard_String\n-              and then Base_Type (Etype (L)) = Base_Type (Etype (R))\n-              and then Etype (L) /= Any_Composite  --  or else L in error\n-              and then Etype (R) /= Any_Composite  --  or else R in error\n-              and then not Matching_Static_Array_Bounds (Etype (L), Etype (R))\n-            then\n-               Check_SPARK_05_Restriction\n-                 (\"array types should have matching static bounds\", N);\n-            end if;\n-         end if;\n-\n          --  If the unique type is a class-wide type then it will be expanded\n          --  into a dispatching call to the predefined primitive. Therefore we\n          --  check here for potential violation of such restriction.\n@@ -9322,34 +9163,6 @@ package body Sem_Res is\n       Set_Etype (N, B_Typ);\n       Generate_Operator_Reference (N, B_Typ);\n       Eval_Logical_Op (N);\n-\n-      --  In SPARK, logical operations AND, OR and XOR for arrays are defined\n-      --  only when both operands have same static lower and higher bounds. Of\n-      --  course the types have to match, so only check if operands are\n-      --  compatible and the node itself has no errors.\n-\n-      if Is_Array_Type (B_Typ)\n-        and then Nkind (N) in N_Binary_Op\n-      then\n-         declare\n-            Left_Typ  : constant Node_Id := Etype (Left_Opnd (N));\n-            Right_Typ : constant Node_Id := Etype (Right_Opnd (N));\n-\n-         begin\n-            --  Protect call to Matching_Static_Array_Bounds to avoid costly\n-            --  operation if not needed.\n-\n-            if Restriction_Check_Required (SPARK_05)\n-              and then Base_Type (Left_Typ) = Base_Type (Right_Typ)\n-              and then Left_Typ /= Any_Composite  --  or Left_Opnd in error\n-              and then Right_Typ /= Any_Composite  --  or Right_Opnd in error\n-              and then not Matching_Static_Array_Bounds (Left_Typ, Right_Typ)\n-            then\n-               Check_SPARK_05_Restriction\n-                 (\"array types should have matching static bounds\", N);\n-            end if;\n-         end;\n-      end if;\n    end Resolve_Logical_Op;\n \n    ---------------------------\n@@ -9707,11 +9520,6 @@ package body Sem_Res is\n          exit when NN = N;\n          NN := Parent (NN);\n       end loop;\n-\n-      if Base_Type (Etype (N)) /= Standard_String then\n-         Check_SPARK_05_Restriction\n-           (\"result of concatenation should have type String\", N);\n-      end if;\n    end Resolve_Op_Concat;\n \n    ---------------------------\n@@ -9836,34 +9644,6 @@ package body Sem_Res is\n          Resolve (Arg, Btyp);\n       end if;\n \n-      --  Concatenation is restricted in SPARK: each operand must be either a\n-      --  string literal, the name of a string constant, a static character or\n-      --  string expression, or another concatenation. Arg cannot be a\n-      --  concatenation here as callers of Resolve_Op_Concat_Arg call it\n-      --  separately on each final operand, past concatenation operations.\n-\n-      if Is_Character_Type (Etype (Arg)) then\n-         if not Is_OK_Static_Expression (Arg) then\n-            Check_SPARK_05_Restriction\n-              (\"character operand for concatenation should be static\", Arg);\n-         end if;\n-\n-      elsif Is_String_Type (Etype (Arg)) then\n-         if not (Nkind_In (Arg, N_Identifier, N_Expanded_Name)\n-                  and then Is_Constant_Object (Entity (Arg)))\n-           and then not Is_OK_Static_Expression (Arg)\n-         then\n-            Check_SPARK_05_Restriction\n-              (\"string operand for concatenation should be static\", Arg);\n-         end if;\n-\n-      --  Do not issue error on an operand that is neither a character nor a\n-      --  string, as the error is issued in Resolve_Op_Concat.\n-\n-      else\n-         null;\n-      end if;\n-\n       Check_Unset_Reference (Arg);\n    end Resolve_Op_Concat_Arg;\n \n@@ -10189,19 +9969,6 @@ package body Sem_Res is\n    begin\n       Resolve (Expr, Target_Typ);\n \n-      --  Protect call to Matching_Static_Array_Bounds to avoid costly\n-      --  operation if not needed.\n-\n-      if Restriction_Check_Required (SPARK_05)\n-        and then Is_Array_Type (Target_Typ)\n-        and then Is_Array_Type (Etype (Expr))\n-        and then Etype (Expr) /= Any_Composite  --  or else Expr in error\n-        and then not Matching_Static_Array_Bounds (Target_Typ, Etype (Expr))\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"array types should have matching static bounds\", N);\n-      end if;\n-\n       --  A qualified expression requires an exact match of the type, class-\n       --  wide matching is not allowed. However, if the qualifying type is\n       --  specific and the expression has a class-wide type, it may still be\n@@ -11524,35 +11291,6 @@ package body Sem_Res is\n \n       Resolve (Operand);\n \n-      --  In SPARK, a type conversion between array types should be restricted\n-      --  to types which have matching static bounds.\n-\n-      --  Protect call to Matching_Static_Array_Bounds to avoid costly\n-      --  operation if not needed.\n-\n-      if Restriction_Check_Required (SPARK_05)\n-        and then Is_Array_Type (Target_Typ)\n-        and then Is_Array_Type (Operand_Typ)\n-        and then Operand_Typ /= Any_Composite  --  or else Operand in error\n-        and then not Matching_Static_Array_Bounds (Target_Typ, Operand_Typ)\n-      then\n-         Check_SPARK_05_Restriction\n-           (\"array types should have matching static bounds\", N);\n-      end if;\n-\n-      --  In formal mode, the operand of an ancestor type conversion must be an\n-      --  object (not an expression).\n-\n-      if Is_Tagged_Type (Target_Typ)\n-        and then not Is_Class_Wide_Type (Target_Typ)\n-        and then Is_Tagged_Type (Operand_Typ)\n-        and then not Is_Class_Wide_Type (Operand_Typ)\n-        and then Is_Ancestor (Target_Typ, Operand_Typ)\n-        and then not Is_SPARK_05_Object_Reference (Operand)\n-      then\n-         Check_SPARK_05_Restriction (\"object required\", Operand);\n-      end if;\n-\n       Analyze_Dimension (N);\n \n       --  Note: we do the Eval_Type_Conversion call before applying the\n@@ -11871,12 +11609,6 @@ package body Sem_Res is\n       Hi    : Uint;\n \n    begin\n-      if Is_Modular_Integer_Type (Typ) and then Nkind (N) /= N_Op_Not then\n-         Error_Msg_Name_1 := Chars (Typ);\n-         Check_SPARK_05_Restriction\n-           (\"unary operator not defined for modular type%\", N);\n-      end if;\n-\n       --  Deal with intrinsic unary operators\n \n       if Comes_From_Source (N)"}, {"sha": "4f7d2d0594bd5370b736618543dfd5dd40d07b4a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -3342,10 +3342,6 @@ package body Sem_Util is\n                         Error_Msg_N\n                           (\"(Ada 83) decl cannot appear after body#\", Decl);\n                      end if;\n-                  else\n-                     Error_Msg_Sloc := Body_Sloc;\n-                     Check_SPARK_05_Restriction\n-                       (\"decl cannot appear after body#\", Decl);\n                   end if;\n                end if;\n \n@@ -7537,52 +7533,6 @@ package body Sem_Util is\n       Append_Entity     (Def_Id, S);\n       Set_Public_Status (Def_Id);\n \n-      --  Declaring a homonym is not allowed in SPARK ...\n-\n-      if Present (C) and then Restriction_Check_Required (SPARK_05) then\n-         declare\n-            Enclosing_Subp : constant Node_Id := Enclosing_Subprogram (Def_Id);\n-            Enclosing_Pack : constant Node_Id := Enclosing_Package (Def_Id);\n-            Other_Scope    : constant Node_Id := Enclosing_Dynamic_Scope (C);\n-\n-         begin\n-            --  ... unless the new declaration is in a subprogram, and the\n-            --  visible declaration is a variable declaration or a parameter\n-            --  specification outside that subprogram.\n-\n-            if Present (Enclosing_Subp)\n-              and then Nkind_In (Parent (C), N_Object_Declaration,\n-                                             N_Parameter_Specification)\n-              and then not Scope_Within_Or_Same (Other_Scope, Enclosing_Subp)\n-            then\n-               null;\n-\n-            --  ... or the new declaration is in a package, and the visible\n-            --  declaration occurs outside that package.\n-\n-            elsif Present (Enclosing_Pack)\n-              and then not Scope_Within_Or_Same (Other_Scope, Enclosing_Pack)\n-            then\n-               null;\n-\n-            --  ... or the new declaration is a component declaration in a\n-            --  record type definition.\n-\n-            elsif Nkind (Parent (Def_Id)) = N_Component_Declaration then\n-               null;\n-\n-            --  Don't issue error for non-source entities\n-\n-            elsif Comes_From_Source (Def_Id)\n-              and then Comes_From_Source (C)\n-            then\n-               Error_Msg_Sloc := Sloc (C);\n-               Check_SPARK_05_Restriction\n-                 (\"redeclaration of identifier &#\", Def_Id);\n-            end if;\n-         end;\n-      end if;\n-\n       --  Warn if new entity hides an old one\n \n       if Warn_On_Hiding and then Present (C)\n@@ -17800,158 +17750,6 @@ package body Sem_Util is\n           and then Is_Single_Concurrent_Type (Etype (Id));\n    end Is_Single_Task_Object;\n \n-   -------------------------------------\n-   -- Is_SPARK_05_Initialization_Expr --\n-   -------------------------------------\n-\n-   function Is_SPARK_05_Initialization_Expr (N : Node_Id) return Boolean is\n-      Is_Ok     : Boolean;\n-      Expr      : Node_Id;\n-      Comp_Assn : Node_Id;\n-      Orig_N    : constant Node_Id := Original_Node (N);\n-\n-   begin\n-      Is_Ok := True;\n-\n-      if not Comes_From_Source (Orig_N) then\n-         goto Done;\n-      end if;\n-\n-      pragma Assert (Nkind (Orig_N) in N_Subexpr);\n-\n-      case Nkind (Orig_N) is\n-         when N_Character_Literal\n-            | N_Integer_Literal\n-            | N_Real_Literal\n-            | N_String_Literal\n-         =>\n-            null;\n-\n-         when N_Expanded_Name\n-            | N_Identifier\n-         =>\n-            if Is_Entity_Name (Orig_N)\n-              and then Present (Entity (Orig_N))  --  needed in some cases\n-            then\n-               case Ekind (Entity (Orig_N)) is\n-                  when E_Constant\n-                     | E_Enumeration_Literal\n-                     | E_Named_Integer\n-                     | E_Named_Real\n-                  =>\n-                     null;\n-\n-                  when others =>\n-                     if Is_Type (Entity (Orig_N)) then\n-                        null;\n-                     else\n-                        Is_Ok := False;\n-                     end if;\n-               end case;\n-            end if;\n-\n-         when N_Qualified_Expression\n-            | N_Type_Conversion\n-         =>\n-            Is_Ok := Is_SPARK_05_Initialization_Expr (Expression (Orig_N));\n-\n-         when N_Unary_Op =>\n-            Is_Ok := Is_SPARK_05_Initialization_Expr (Right_Opnd (Orig_N));\n-\n-         when N_Binary_Op\n-            | N_Membership_Test\n-            | N_Short_Circuit\n-         =>\n-            Is_Ok := Is_SPARK_05_Initialization_Expr (Left_Opnd (Orig_N))\n-                       and then\n-                         Is_SPARK_05_Initialization_Expr (Right_Opnd (Orig_N));\n-\n-         when N_Aggregate\n-            | N_Extension_Aggregate\n-         =>\n-            if Nkind (Orig_N) = N_Extension_Aggregate then\n-               Is_Ok :=\n-                 Is_SPARK_05_Initialization_Expr (Ancestor_Part (Orig_N));\n-            end if;\n-\n-            Expr := First (Expressions (Orig_N));\n-            while Present (Expr) loop\n-               if not Is_SPARK_05_Initialization_Expr (Expr) then\n-                  Is_Ok := False;\n-                  goto Done;\n-               end if;\n-\n-               Next (Expr);\n-            end loop;\n-\n-            Comp_Assn := First (Component_Associations (Orig_N));\n-            while Present (Comp_Assn) loop\n-               Expr := Expression (Comp_Assn);\n-\n-               --  Note: test for Present here needed for box assocation\n-\n-               if Present (Expr)\n-                 and then not Is_SPARK_05_Initialization_Expr (Expr)\n-               then\n-                  Is_Ok := False;\n-                  goto Done;\n-               end if;\n-\n-               Next (Comp_Assn);\n-            end loop;\n-\n-         when N_Attribute_Reference =>\n-            if Nkind (Prefix (Orig_N)) in N_Subexpr then\n-               Is_Ok := Is_SPARK_05_Initialization_Expr (Prefix (Orig_N));\n-            end if;\n-\n-            Expr := First (Expressions (Orig_N));\n-            while Present (Expr) loop\n-               if not Is_SPARK_05_Initialization_Expr (Expr) then\n-                  Is_Ok := False;\n-                  goto Done;\n-               end if;\n-\n-               Next (Expr);\n-            end loop;\n-\n-         --  Selected components might be expanded named not yet resolved, so\n-         --  default on the safe side. (Eg on sparklex.ads)\n-\n-         when N_Selected_Component =>\n-            null;\n-\n-         when others =>\n-            Is_Ok := False;\n-      end case;\n-\n-   <<Done>>\n-      return Is_Ok;\n-   end Is_SPARK_05_Initialization_Expr;\n-\n-   ----------------------------------\n-   -- Is_SPARK_05_Object_Reference --\n-   ----------------------------------\n-\n-   function Is_SPARK_05_Object_Reference (N : Node_Id) return Boolean is\n-   begin\n-      if Is_Entity_Name (N) then\n-         return Present (Entity (N))\n-           and then\n-             (Ekind_In (Entity (N), E_Constant, E_Variable)\n-               or else Ekind (Entity (N)) in Formal_Kind);\n-\n-      else\n-         case Nkind (N) is\n-            when N_Selected_Component =>\n-               return Is_SPARK_05_Object_Reference (Prefix (N));\n-\n-            when others =>\n-               return False;\n-         end case;\n-      end if;\n-   end Is_SPARK_05_Object_Reference;\n-\n    --------------------------------------\n    -- Is_Special_Aliased_Formal_Access --\n    --------------------------------------\n@@ -24050,19 +23848,6 @@ package body Sem_Util is\n \n          Get_Decoded_Name_String (Chars (Endl));\n          Set_Sloc (Endl, Sloc (Endl) + Source_Ptr (Name_Len));\n-\n-      else\n-         --  In SPARK mode, no missing label is allowed for packages and\n-         --  subprogram bodies. Detect those cases by testing whether\n-         --  Process_End_Label was called for a body (Typ = 't') or a package.\n-\n-         if Restriction_Check_Required (SPARK_05)\n-           and then (Typ = 't' or else Ekind (Ent) = E_Package)\n-         then\n-            Error_Msg_Node_1 := Endl;\n-            Check_SPARK_05_Restriction\n-              (\"`END &` required\", Endl, Force => True);\n-         end if;\n       end if;\n \n       --  Now generate the e/t reference"}, {"sha": "ba4c289847645ec78d6567f75257629cfcab7f6e", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -1977,17 +1977,6 @@ package Sem_Util is\n    --  Determine whether arbitrary entity Id denotes the anonymous object\n    --  created for a single task type.\n \n-   function Is_SPARK_05_Initialization_Expr (N : Node_Id) return Boolean;\n-   --  Determines if the tree referenced by N represents an initialization\n-   --  expression in SPARK 2005, suitable for initializing an object in an\n-   --  object declaration.\n-\n-   function Is_SPARK_05_Object_Reference (N : Node_Id) return Boolean;\n-   --  Determines if the tree referenced by N represents an object in SPARK\n-   --  2005. This differs from Is_Object_Reference in that only variables,\n-   --  constants, formal parameters, and selected_components of those are\n-   --  valid objects in SPARK 2005.\n-\n    function Is_Special_Aliased_Formal_Access\n      (Exp  : Node_Id;\n       Scop : Entity_Id) return Boolean;"}, {"sha": "094f7221c83150c0ac8a4361d024e702021b67d2", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7907619e7737b6cb38ee334996a7d7a33bb7a1d6/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=7907619e7737b6cb38ee334996a7d7a33bb7a1d6", "patch": "@@ -835,7 +835,6 @@ package Snames is\n    Name_Section                        : constant Name_Id := N + $;\n    Name_Semaphore                      : constant Name_Id := N + $;\n    Name_Simple_Barriers                : constant Name_Id := N + $;\n-   Name_SPARK                          : constant Name_Id := N + $;\n    Name_SPARK_05                       : constant Name_Id := N + $;\n    Name_Spec_File_Name                 : constant Name_Id := N + $;\n    Name_State                          : constant Name_Id := N + $;"}]}