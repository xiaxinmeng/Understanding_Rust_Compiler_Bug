{"sha": "04939ee6fd997de2278445a5092f5e1fd20dc486", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ5MzllZTZmZDk5N2RlMjI3ODQ0NWE1MDkyZjVlMWZkMjBkYzQ4Ng==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-06-07T11:29:37Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-06-07T11:29:37Z"}, "message": "graphds.c (add_edge): Intitialize edge's attached data.\n\n\t* graphds.c (add_edge): Intitialize edge's attached data.\n\t(foll_in_subgraph, dfs_fst_edge, dfs_next_edge): New function\n\tpointer parameter.  Call pointed function on each edge during\n\tgraph traversing.  Skip traversing the edge when the function\n\treturns true.\n\t(graphds_dfs, graphds_scc): Ditto.\n\t(for_each_edge): New parameter.  Pass the new parameter to callback\n\tfunction.\n\t* graphds.h (skip_edge_callback): New function pointer type.\n\t(graphds_dfs, graphds_scc): New function pointer parameter.\n\t(graphds_edge_callback, for_each_edge): New parameter.\n\nFrom-SVN: r248964", "tree": {"sha": "a6e964f97c27b5d2e834a16f6f0a116e4f7b2ab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6e964f97c27b5d2e834a16f6f0a116e4f7b2ab3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04939ee6fd997de2278445a5092f5e1fd20dc486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04939ee6fd997de2278445a5092f5e1fd20dc486", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04939ee6fd997de2278445a5092f5e1fd20dc486", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04939ee6fd997de2278445a5092f5e1fd20dc486/comments", "author": null, "committer": null, "parents": [{"sha": "6355150f585e2d746a62df19ae89df7c93e8c3c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6355150f585e2d746a62df19ae89df7c93e8c3c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6355150f585e2d746a62df19ae89df7c93e8c3c7"}], "stats": {"total": 90, "additions": 63, "deletions": 27}, "files": [{"sha": "d15eccedc9d35f99ebdd0eb5cbcfd92fecc3cff2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04939ee6fd997de2278445a5092f5e1fd20dc486/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04939ee6fd997de2278445a5092f5e1fd20dc486/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=04939ee6fd997de2278445a5092f5e1fd20dc486", "patch": "@@ -1,3 +1,17 @@\n+2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* graphds.c (add_edge): Intitialize edge's attached data.\n+\t(foll_in_subgraph, dfs_fst_edge, dfs_next_edge): New function\n+\tpointer parameter.  Call pointed function on each edge during\n+\tgraph traversing.  Skip traversing the edge when the function\n+\treturns true.\n+\t(graphds_dfs, graphds_scc): Ditto.\n+\t(for_each_edge): New parameter.  Pass the new parameter to callback\n+\tfunction.\n+\t* graphds.h (skip_edge_callback): New function pointer type.\n+\t(graphds_dfs, graphds_scc): New function pointer parameter.\n+\t(graphds_edge_callback, for_each_edge): New parameter.\n+\n 2017-06-07  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test): Factor"}, {"sha": "29513497abdebc2b95fbec12300ba45a552a822f", "filename": "gcc/graphds.c", "status": "modified", "additions": 43, "deletions": 23, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04939ee6fd997de2278445a5092f5e1fd20dc486/gcc%2Fgraphds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04939ee6fd997de2278445a5092f5e1fd20dc486/gcc%2Fgraphds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.c?ref=04939ee6fd997de2278445a5092f5e1fd20dc486", "patch": "@@ -81,6 +81,7 @@ add_edge (struct graph *g, int f, int t)\n   e->succ_next = vf->succ;\n   vf->succ = e;\n \n+  e->data = NULL;\n   return e;\n }\n \n@@ -133,20 +134,28 @@ dfs_edge_dest (struct graph_edge *e, bool forward)\n }\n \n /* Helper function for graphds_dfs.  Returns the first edge after E (including\n-   E), in the graph direction given by FORWARD, that belongs to SUBGRAPH.  */\n+   E), in the graph direction given by FORWARD, that belongs to SUBGRAPH.  If\n+   SKIP_EDGE_P is not NULL, it points to a callback function.  Edge E will be\n+   skipped if callback function returns true.  */\n \n static inline struct graph_edge *\n-foll_in_subgraph (struct graph_edge *e, bool forward, bitmap subgraph)\n+foll_in_subgraph (struct graph_edge *e, bool forward, bitmap subgraph,\n+\t\t  skip_edge_callback skip_edge_p)\n {\n   int d;\n \n-  if (!subgraph)\n+  if (!e)\n+    return e;\n+\n+  if (!subgraph && (!skip_edge_p || !skip_edge_p (e)))\n     return e;\n \n   while (e)\n     {\n       d = dfs_edge_dest (e, forward);\n-      if (bitmap_bit_p (subgraph, d))\n+      /* Return edge if it belongs to subgraph and shouldn't be skipped.  */\n+      if ((!subgraph || bitmap_bit_p (subgraph, d))\n+\t  && (!skip_edge_p || !skip_edge_p (e)))\n \treturn e;\n \n       e = forward ? e->succ_next : e->pred_next;\n@@ -156,36 +165,45 @@ foll_in_subgraph (struct graph_edge *e, bool forward, bitmap subgraph)\n }\n \n /* Helper function for graphds_dfs.  Select the first edge from V in G, in the\n-   direction given by FORWARD, that belongs to SUBGRAPH.  */\n+   direction given by FORWARD, that belongs to SUBGRAPH.  If SKIP_EDGE_P is not\n+   NULL, it points to a callback function.  Edge E will be skipped if callback\n+   function returns true.  */\n \n static inline struct graph_edge *\n-dfs_fst_edge (struct graph *g, int v, bool forward, bitmap subgraph)\n+dfs_fst_edge (struct graph *g, int v, bool forward, bitmap subgraph,\n+\t      skip_edge_callback skip_edge_p)\n {\n   struct graph_edge *e;\n \n   e = (forward ? g->vertices[v].succ : g->vertices[v].pred);\n-  return foll_in_subgraph (e, forward, subgraph);\n+  return foll_in_subgraph (e, forward, subgraph, skip_edge_p);\n }\n \n /* Helper function for graphds_dfs.  Returns the next edge after E, in the\n-   graph direction given by FORWARD, that belongs to SUBGRAPH.  */\n+   graph direction given by FORWARD, that belongs to SUBGRAPH.  If SKIP_EDGE_P\n+   is not NULL, it points to a callback function.  Edge E will be skipped if\n+   callback function returns true.  */\n \n static inline struct graph_edge *\n-dfs_next_edge (struct graph_edge *e, bool forward, bitmap subgraph)\n+dfs_next_edge (struct graph_edge *e, bool forward, bitmap subgraph,\n+\t       skip_edge_callback skip_edge_p)\n {\n   return foll_in_subgraph (forward ? e->succ_next : e->pred_next,\n-\t\t\t   forward, subgraph);\n+\t\t\t   forward, subgraph, skip_edge_p);\n }\n \n /* Runs dfs search over vertices of G, from NQ vertices in queue QS.\n    The vertices in postorder are stored into QT.  If FORWARD is false,\n    backward dfs is run.  If SUBGRAPH is not NULL, it specifies the\n    subgraph of G to run DFS on.  Returns the number of the components\n-   of the graph (number of the restarts of DFS).  */\n+   of the graph (number of the restarts of DFS).  If SKIP_EDGE_P is not\n+   NULL, it points to a callback function.  Edge E will be skipped if\n+   callback function returns true.  */\n \n int\n graphds_dfs (struct graph *g, int *qs, int nq, vec<int> *qt,\n-\t     bool forward, bitmap subgraph)\n+\t     bool forward, bitmap subgraph,\n+\t     skip_edge_callback skip_edge_p)\n {\n   int i, tick = 0, v, comp = 0, top;\n   struct graph_edge *e;\n@@ -217,7 +235,7 @@ graphds_dfs (struct graph *g, int *qs, int nq, vec<int> *qt,\n \tcontinue;\n \n       g->vertices[v].component = comp++;\n-      e = dfs_fst_edge (g, v, forward, subgraph);\n+      e = dfs_fst_edge (g, v, forward, subgraph, skip_edge_p);\n       top = 0;\n \n       while (1)\n@@ -227,7 +245,7 @@ graphds_dfs (struct graph *g, int *qs, int nq, vec<int> *qt,\n \t      if (g->vertices[dfs_edge_dest (e, forward)].component\n \t\t  == -1)\n \t\tbreak;\n-\t      e = dfs_next_edge (e, forward, subgraph);\n+\t      e = dfs_next_edge (e, forward, subgraph, skip_edge_p);\n \t    }\n \n \t  if (!e)\n@@ -241,13 +259,13 @@ graphds_dfs (struct graph *g, int *qs, int nq, vec<int> *qt,\n \n \t      e = stack[--top];\n \t      v = dfs_edge_src (e, forward);\n-\t      e = dfs_next_edge (e, forward, subgraph);\n+\t      e = dfs_next_edge (e, forward, subgraph, skip_edge_p);\n \t      continue;\n \t    }\n \n \t  stack[top++] = e;\n \t  v = dfs_edge_dest (e, forward);\n-\t  e = dfs_fst_edge (g, v, forward, subgraph);\n+\t  e = dfs_fst_edge (g, v, forward, subgraph, skip_edge_p);\n \t  g->vertices[v].component = comp - 1;\n \t}\n     }\n@@ -262,14 +280,16 @@ graphds_dfs (struct graph *g, int *qs, int nq, vec<int> *qt,\n    then run the dfs on the original graph in the order given by decreasing\n    numbers assigned by the previous pass.  If SUBGRAPH is not NULL, it\n    specifies the subgraph of G whose strongly connected components we want\n-   to determine.\n+   to determine.  If SKIP_EDGE_P is not NULL, it points to a callback function.\n+   Edge E will be skipped if callback function returns true.\n \n    After running this function, v->component is the number of the strongly\n    connected component for each vertex of G.  Returns the number of the\n    sccs of G.  */\n \n int\n-graphds_scc (struct graph *g, bitmap subgraph)\n+graphds_scc (struct graph *g, bitmap subgraph,\n+\t     skip_edge_callback skip_edge_p)\n {\n   int *queue = XNEWVEC (int, g->n_vertices);\n   vec<int> postorder = vNULL;\n@@ -292,30 +312,30 @@ graphds_scc (struct graph *g, bitmap subgraph)\n       nq = g->n_vertices;\n     }\n \n-  graphds_dfs (g, queue, nq, &postorder, false, subgraph);\n+  graphds_dfs (g, queue, nq, &postorder, false, subgraph, skip_edge_p);\n   gcc_assert (postorder.length () == (unsigned) nq);\n \n   for (i = 0; i < nq; i++)\n     queue[i] = postorder[nq - i - 1];\n-  comp = graphds_dfs (g, queue, nq, NULL, true, subgraph);\n+  comp = graphds_dfs (g, queue, nq, NULL, true, subgraph, skip_edge_p);\n \n   free (queue);\n   postorder.release ();\n \n   return comp;\n }\n \n-/* Runs CALLBACK for all edges in G.  */\n+/* Runs CALLBACK for all edges in G.  DATA is private data for CALLBACK.  */\n \n void\n-for_each_edge (struct graph *g, graphds_edge_callback callback)\n+for_each_edge (struct graph *g, graphds_edge_callback callback, void *data)\n {\n   struct graph_edge *e;\n   int i;\n \n   for (i = 0; i < g->n_vertices; i++)\n     for (e = g->vertices[i].succ; e; e = e->succ_next)\n-      callback (g, e);\n+      callback (g, e, data);\n }\n \n /* Releases the memory occupied by G.  */"}, {"sha": "9f9fc1055e560243e20b32390fc4fe28980a00e4", "filename": "gcc/graphds.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04939ee6fd997de2278445a5092f5e1fd20dc486/gcc%2Fgraphds.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04939ee6fd997de2278445a5092f5e1fd20dc486/gcc%2Fgraphds.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphds.h?ref=04939ee6fd997de2278445a5092f5e1fd20dc486", "patch": "@@ -55,12 +55,14 @@ struct graph *new_graph (int);\n void dump_graph (FILE *, struct graph *);\n struct graph_edge *add_edge (struct graph *, int, int);\n void identify_vertices (struct graph *, int, int);\n+typedef bool (*skip_edge_callback) (struct graph_edge *);\n int graphds_dfs (struct graph *, int *, int,\n-\t\t vec<int> *, bool, bitmap);\n-int graphds_scc (struct graph *, bitmap);\n+\t\t vec<int> *, bool, bitmap, skip_edge_callback = NULL);\n+int graphds_scc (struct graph *, bitmap, skip_edge_callback = NULL);\n void graphds_domtree (struct graph *, int, int *, int *, int *);\n-typedef void (*graphds_edge_callback) (struct graph *, struct graph_edge *);\n-void for_each_edge (struct graph *, graphds_edge_callback);\n+typedef void (*graphds_edge_callback) (struct graph *,\n+\t\t\t\t       struct graph_edge *, void *);\n+void for_each_edge (struct graph *, graphds_edge_callback, void *);\n void free_graph (struct graph *g);\n \n #endif /* GCC_GRAPHDS_H */"}]}