{"sha": "794cb45e0be66af6533262e255dd276a1cfb3bd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzk0Y2I0NWUwYmU2NmFmNjUzMzI2MmUyNTVkZDI3NmExY2ZiM2JkOA==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2008-05-31T15:01:16Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2008-05-31T15:01:16Z"}, "message": "avr.md (UNSPECV_WRITE_SP_IRQ_ON): New constants.\n\n\t* config/avr/avr.md (UNSPECV_WRITE_SP_IRQ_ON): New constants.\n\t(UNSPECV_WRITE_SP_IRQ_OFF): (Ditto.).\n\t(movhi_sp_r_irq_off, movhi_sp_r_irq_on): New insn.\n\t* config/avr/avr.c (expand_prologue, expand_epilogue): Use \n\tmovhi_sp_r_irq_off and movhi_sp_r_irq_on insns for writing to the \n\tstack pointer register.\n\t(output_movhi): Remove code for interrupt specific writing to the \n\tstack pointer register.\n\nFrom-SVN: r136238", "tree": {"sha": "73ff27f3d67fad9fc3708299409936b8bb768ea0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73ff27f3d67fad9fc3708299409936b8bb768ea0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/794cb45e0be66af6533262e255dd276a1cfb3bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794cb45e0be66af6533262e255dd276a1cfb3bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794cb45e0be66af6533262e255dd276a1cfb3bd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794cb45e0be66af6533262e255dd276a1cfb3bd8/comments", "author": null, "committer": null, "parents": [{"sha": "39f8a3b00c99fff50a211449cd10e326eabca8f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39f8a3b00c99fff50a211449cd10e326eabca8f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39f8a3b00c99fff50a211449cd10e326eabca8f4"}], "stats": {"total": 117, "additions": 87, "deletions": 30}, "files": [{"sha": "e50465a7631b2e462773dd67165aaacf06132791", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794cb45e0be66af6533262e255dd276a1cfb3bd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794cb45e0be66af6533262e255dd276a1cfb3bd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=794cb45e0be66af6533262e255dd276a1cfb3bd8", "patch": "@@ -1,3 +1,14 @@\n+2008-05-31  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/avr/avr.md (UNSPECV_WRITE_SP_IRQ_ON): New constants.\n+\t(UNSPECV_WRITE_SP_IRQ_OFF): (Ditto.).\n+\t(movhi_sp_r_irq_off, movhi_sp_r_irq_on): New insn.\n+\t* config/avr/avr.c (expand_prologue, expand_epilogue): Use \n+\tmovhi_sp_r_irq_off and movhi_sp_r_irq_on insns for writing to the \n+\tstack pointer register.\n+\t(output_movhi): Remove code for interrupt specific writing to the \n+\tstack pointer register.\n+\n 2008-05-31  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/34244"}, {"sha": "bde58f029b60c4b1e4f211cd0bd76bf89599c8d3", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794cb45e0be66af6533262e255dd276a1cfb3bd8/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794cb45e0be66af6533262e255dd276a1cfb3bd8/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=794cb45e0be66af6533262e255dd276a1cfb3bd8", "patch": "@@ -763,8 +763,32 @@ expand_prologue (void)\n \t\t\t\t\t\t\t    GET_MODE(myfp))));\n               RTX_FRAME_RELATED_P (insn) = 1;\n \n-              insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-              RTX_FRAME_RELATED_P (insn) = 1;\n+\t      /* Copy to stack pointer.  */\n+\t      if (TARGET_TINY_STACK)\n+\t\t{\n+\t\t  insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n+\t      else if (TARGET_NO_INTERRUPTS \n+\t\t       || cfun->machine->is_signal\n+\t\t       || cfun->machine->is_OS_main)\n+\t\t{\n+\t\t  insn = \n+\t\t    emit_insn (gen_movhi_sp_r_irq_off (stack_pointer_rtx, \n+\t\t\t\t\t\t       frame_pointer_rtx));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\t\t\n+\t\t}\n+\t      else if (cfun->machine->is_interrupt)\n+\t\t{\n+\t\t  insn = emit_insn (gen_movhi_sp_r_irq_on (stack_pointer_rtx, \n+\t\t\t\t\t\t\t   frame_pointer_rtx));\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  insn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t}\n \n \t      fp_plus_insns = get_insns ();\n \t      end_sequence ();\n@@ -915,7 +939,25 @@ expand_epilogue (void)\n \t\t\t\t\t\t\t  GET_MODE(myfp))));\n \n \t      /* Copy to stack pointer.  */\n-\t      emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t      if (TARGET_TINY_STACK)\n+\t\t{\n+\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t\t}\n+\t      else if (TARGET_NO_INTERRUPTS \n+\t\t       || cfun->machine->is_signal)\n+\t\t{\n+\t\t  emit_insn (gen_movhi_sp_r_irq_off (stack_pointer_rtx, \n+\t\t\t\t\t\t     frame_pointer_rtx));\n+\t\t}\n+\t      else if (cfun->machine->is_interrupt)\n+\t\t{\n+\t\t  emit_insn (gen_movhi_sp_r_irq_on (stack_pointer_rtx, \n+\t\t\t\t\t\t    frame_pointer_rtx));\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+\t\t}\n \n \t      fp_plus_insns = get_insns ();\n \t      end_sequence ();\t      \n@@ -1708,32 +1750,12 @@ output_movhi (rtx insn, rtx operands[], int *l)\n \t  if (test_hard_reg_class (STACK_REG, dest))\n \t    {\n \t      if (TARGET_TINY_STACK)\n-\t\t{\n-\t\t  *l = 1;\n-\t\t  return AS2 (out,__SP_L__,%A1);\n-\t\t}\n-              /*  Use simple load of stack pointer if no interrupts are used\n-              or inside main or signal function prologue where they disabled.  */\n-\t      else if (TARGET_NO_INTERRUPTS \n-                        || (reload_completed \n-                            && cfun->machine->is_signal \n-                            && prologue_epilogue_contains (insn)))\n-                {\n-                  *l = 2;\n-                  return (AS2 (out,__SP_H__,%B1) CR_TAB\n-                          AS2 (out,__SP_L__,%A1));\n-                }\n-              /*  In interrupt prolog we know interrupts are enabled.  */\n-              else if (reload_completed \n-                        && cfun->machine->is_interrupt\n-                        && prologue_epilogue_contains (insn))\n-                {\n-                  *l = 4;\n-\t           return (\"cli\"                   CR_TAB\n-                           AS2 (out,__SP_H__,%B1) CR_TAB\n-                           \"sei\"                   CR_TAB\n-                           AS2 (out,__SP_L__,%A1));\n-                }\n+\t\treturn *l = 1, AS2 (out,__SP_L__,%A1);\n+              /* Use simple load of stack pointer if no interrupts are \n+\t\t used.  */\n+\t      else if (TARGET_NO_INTERRUPTS)\n+\t\treturn *l = 2, (AS2 (out,__SP_H__,%B1) CR_TAB\n+\t\t\t\tAS2 (out,__SP_L__,%A1));\n \t      *l = 5;\n \t      return (AS2 (in,__tmp_reg__,__SREG__)  CR_TAB\n \t\t      \"cli\"                          CR_TAB"}, {"sha": "a4914c4aa6185729a517d35a7bf07ce47f378bff", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/794cb45e0be66af6533262e255dd276a1cfb3bd8/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/794cb45e0be66af6533262e255dd276a1cfb3bd8/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=794cb45e0be66af6533262e255dd276a1cfb3bd8", "patch": "@@ -56,7 +56,9 @@\n    (UNSPEC_CLI\t\t3)\n \n    (UNSPECV_PROLOGUE_SAVES\t0)\n-   (UNSPECV_EPILOGUE_RESTORES\t1)])\n+   (UNSPECV_EPILOGUE_RESTORES\t1)\n+   (UNSPECV_WRITE_SP_IRQ_ON\t2)\n+   (UNSPECV_WRITE_SP_IRQ_OFF\t3)])\n \n (include \"predicates.md\")\n (include \"constraints.md\")\n@@ -230,6 +232,28 @@\n   [(set_attr \"length\" \"5,2\")\n    (set_attr \"cc\" \"none,none\")])\n \n+(define_insn \"movhi_sp_r_irq_off\"\n+  [(set (match_operand:HI 0 \"stack_register_operand\" \"=q\")\n+        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r\")] \n+\t\t\t    UNSPECV_WRITE_SP_IRQ_OFF))]\n+  \"\"\n+  \"out __SP_H__, %B1\n+\tout __SP_L__, %A1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"movhi_sp_r_irq_on\"\n+  [(set (match_operand:HI 0 \"stack_register_operand\" \"=q\")\n+        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r\")] \n+\t\t\t    UNSPECV_WRITE_SP_IRQ_ON))]\n+  \"\"\n+  \"cli\n+        out __SP_H__, %B1\n+\tsei\n+\tout __SP_L__, %A1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none\")])\n+\n (define_peephole2\n   [(match_scratch:QI 2 \"d\")\n    (set (match_operand:HI 0 \"l_register_operand\" \"\")"}]}