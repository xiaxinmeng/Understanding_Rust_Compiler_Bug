{"sha": "12ea3302e694f467891a1ff072d5906d266413fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJlYTMzMDJlNjk0ZjQ2Nzg5MWExZmYwNzJkNTkwNmQyNjY0MTNmYw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-08-25T19:10:50Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-08-25T19:10:50Z"}, "message": "pretty-print.h (pp_maybe_newline_and_indent): New macro.\n\n\t* pretty-print.h (pp_maybe_newline_and_indent): New macro.\n\t* c-pretty-print.h (c_pretty_printer): Now typedef to the\n\tstructure.  Be consistent with pretty-print.h abd cxx-pretty-print.h\n\t(struct c_pretty_print_info): Document.  Add new fields.\n\t(pp_type_specifier_seq): Rename from pp_c_type_specifier.\n\t(pp_direct_abstract_declarator): New macro.\n\t(pp_ptr_operator): Likewise.\n\t(pp_simple_type_specifier): Likewise.\n\t(pp_expression): Likewise.\n\t(pp_parameter_list): Rename from pp_parameter_declaration.\n\t* c-pretty-print.c (pp_c_whitespace): Now a function.\n\t(pp_c_left_paren): Likewise.\n\t(pp_c_right_paren): Likewise.\n\t(pp_c_dot): Likewise.\n\t(pp_c_ampersand): Likewise.\n\t(pp_c_arrow): Likewise.\n\t(pp_c_semicolon): Likewise.\n\t(pp_c_type_cast): New function.\n\t(pp_c_space_for_pointer_operator): Likewise.\n\t(pp_c_call_argument_list): Likewise.\n\t(pp_c_cv_qualifier): Adjust prototype.\n\t(pp_c_type_qualifier_list): Likewise.\n\t(pp_c_pointer): Likewise.  Handle REFERENCE_TYPE here.\n\t(pp_c_type_specifier): Rename from pp_c_simple_type_specifier.\n\tAdjust to follow standard grammar.\n\t(pp_c_specifier_qualifier_list): Adjusr prototype.  Handle\n\tREFERENCE_TYPE.  Tidy.\n\t(pp_c_parameter_type_list): Adjust prototype.  Tidy.\n\t(pp_c_parameter_declaration): Remove.\n\t(pp_c_abstract_declarator): Adjust prototype.\n\t(pp_c_direct_abstract_declarator): Likewise.\n\t(pp_c_type_id): Likewise.\n\t(pp_c_storage_class_specifier): Likewise.\n\t(pp_c_function_specifier): Likewise.\n\t(pp_c_declaration_specifiers): Likewise.\n\t(pp_c_direct_declarator): Likewise.\n\t(pp_c_declarator): Likewise.\n\t(pp_c_declarator): Likewise.\n\t(pp_c_declaration): Likewise.\n\t(pp_c_attributes): Likewise.  Tidy.\n\t(pp_c_function_definition): Adjust prototype.\n\t(pp_c_char): Likewise.\n\t(pp_c_string_literal): Likewise.\n\t(pp_c_integer_constant): Likewise.\n\t(pp_c_character_constant): Likewise.\n\t(pp_c_bool_constant): Likewise.\n\t(pp_c_enumeration_constant): Likewise.\n\t(pp_c_floating_constant): Likewise.\n\t(pp_c_constant): Likewise.\n\t(pp_c_identifier): Likewise.\n\t(pp_c_primary_expression): Likewise.  Remove TARGET_EXPR case.  Tidy.\n\t(pp_c_initializer): Adjust prototype.\n\t(pp_c_init_declarator): Likewise.\n\t(pp_c_initializer_list): Likewise.\n\t(pp_c_id_expression): Likewise.\n\t(pp_c_postfix_expression): Likewise.\n\t(pp_c_expression_list): Likewise.\n\t(pp_c_unary_expression): Likewise.\n\t(pp_c_cast_expression): Likewise.\n\t(pp_c_multiplicative_expression): Likewise.\n\t(pp_c_additive_expression): Likewise.\n\t(pp_c_shift_expression): Likewise.\n\t(pp_c_relational_expression): Likewise.\n\t(pp_c_equality_expression): Likewise.\n\t(pp_c_and_expression): Likewise.\n\t(pp_c_exclusive_or_expression): Likewise.\n\t(pp_c_inclusive_or_expression): Likewise.\n\t(pp_c_logical_and_expression): Likewise.\n\t(pp_c_logical_or_expression): Likewise.\n\t(pp_c_conditional_expression): Likewise.\n\t(pp_c_assignment_expression): Likewise.\n\t(pp_c_expression): Likewise.  Tidy.\n\t(pp_c_statement): Likewise.  Document.\n\t(pp_c_pretty_printer_init): Adjust prototype. Tidy.\n\n\t* c-lang.c (c_initialize_diagnostics): Update.\n\t* c-common.h (strip_pointer_operator): Declare.\n\t* c-common.c (strip_pointer_operator): Define.\n\ncp/\n\t* cxx-pretty-print.h (pp_cxx_flag_default_argument): New flag.\n\t(cxx_pretty_printer): Adjust base type.\n\t(pp_cxx_function_specifier): Declare.\n\t* cxx-pretty-print.c (pp_cxx_whitespace): New macro.\n\t(pp_cxx_left_paren): Likewise.\n\t(pp_cxx_right_paren): Likewise.\n\t(pp_cxx_dot): Likewise.\n\t(pp_cxx_arrow): Likewise.\n\t(pp_cxx_semicolon): Likewise.\n\t(pp_cxx_identifier): Likewise.\n\t(pp_cxx_cv_qualifier_seq): Likewise.\n\t(pp_cxx_storage_class_specifier): Likewise.\n\t(pp_cxx_expression_list): Likewise.\n\t(pp_cxx_space_for_pointer_operator): Likewise.\n\t(pp_cxx_init_declarator): Likewise.\n\t(pp_cxx_call_argument_list): Likewise.\n\t(pp_cxx_nonconsecutive_character): Tidy.\n\t(pp_cxx_conversion_function_id): New function.\n\t(pp_cxx_template_id): Likewise.\n\t(pp_cxx_class_name): Likewise.\n\t(pp_cxx_template_keyword_if_needed): Likewise.\n\t(pp_cxx_nested_name_specifier): Likewise.\n\t(pp_cxx_unqualified_id): Tidy\n\t(pp_cxx_qualified_id): Handle more nodes.\n\t(pp_cxx_primary_expression): Tidy.\n\t(pp_cxx_postfix_expression): Likewise.\n\t(pp_cxx_new_expression): Tidy.\n\t(pp_cxx_delete_expression): Likewise.\n\t(pp_cxx_cast_expression): New function.\n\t(pp_cxx_pm_expression): Tidy.\n\t(pp_cxx_conditional_expression): Likewise.\n\t(pp_cxx_assignment_operator): New function.\n\t(pp_cxx_assignment_expression): Tidy.\n\t(pp_cxx_expression): New function.\n\t(pp_cxx_function_specifier): Likewise.\n\t(pp_cxx_decl_specifier_seq): Likewise.\n\t(pp_cxx_simple_type_specifier): Tidy.\n\t(pp_cxx_type_specifier_seq): Likewise.\n\t(pp_cxx_ptr_operator): New function.\n\t(pp_cxx_implicit_parameter_type): Likewise.\n\t(pp_cxx_parameter_declaration): Tidy.\n\t(pp_cxx_parameter_declaration_clause): New function.\n\t(pp_cxx_exception_specification): Likewise.\n\t(pp_cxx_direct_declarator): Tidy.\n\t(pp_cxx_declarator): Likewise.\n\t(pp_cxx_ctor_initializer): New function.\n\t(pp_cxx_function_definition): Likewise.\n\t(pp_cxx_abstract_declarator): Tidy.\n\t(pp_cxx_direct_abstract_declarator): Likewise.\n\t(pp_cxx_type_id): Likewise.\n\t(pp_cxx_exception_declaration): New function.\n\t(pp_cxx_statement): Likewise.\n\t(pp_cxx_simple_declaration): Likewise.\n\t(pp_cxx_template_parameter_list): Likewise.\n\t(pp_cxx_template_parameter): Likewise.\n\t(pp_cxx_template_declaration): Likewise.\n\t(pp_cxx_explicit_specialization): Likewise.\n\t(pp_cxx_explicit_instantiation): Likewise.\n\t(pp_cxx_declaration): Tidy.\n\t(pp_cxx_pretty_printer_init): Initialize more fields.\n\nFrom-SVN: r70777", "tree": {"sha": "288d0b8f94a131ce00ffd87de8db46e6bffbbee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/288d0b8f94a131ce00ffd87de8db46e6bffbbee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12ea3302e694f467891a1ff072d5906d266413fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ea3302e694f467891a1ff072d5906d266413fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12ea3302e694f467891a1ff072d5906d266413fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12ea3302e694f467891a1ff072d5906d266413fc/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81f7282f978588f883d8363e8cd5e69d090bc331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f7282f978588f883d8363e8cd5e69d090bc331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f7282f978588f883d8363e8cd5e69d090bc331"}], "stats": {"total": 3064, "additions": 2182, "deletions": 882}, "files": [{"sha": "ff2e17591a384f5921e93c31d63137c11aeadad1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -1,3 +1,84 @@\n+2003-08-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* pretty-print.h (pp_maybe_newline_and_indent): New macro.\n+\t* c-pretty-print.h (c_pretty_printer): Now typedef to the\n+\tstructure.  Be consistent with pretty-print.h abd cxx-pretty-print.h\n+\t(struct c_pretty_print_info): Document.  Add new fields.\n+\t(pp_type_specifier_seq): Rename from pp_c_type_specifier.\n+\t(pp_direct_abstract_declarator): New macro.\n+\t(pp_ptr_operator): Likewise.\n+\t(pp_simple_type_specifier): Likewise.\n+\t(pp_expression): Likewise.\n+\t(pp_parameter_list): Rename from pp_parameter_declaration.\n+\t* c-pretty-print.c (pp_c_whitespace): Now a function.\n+\t(pp_c_left_paren): Likewise.\n+\t(pp_c_right_paren): Likewise.\n+\t(pp_c_dot): Likewise.\n+\t(pp_c_ampersand): Likewise.\n+\t(pp_c_arrow): Likewise.\n+\t(pp_c_semicolon): Likewise.\n+\t(pp_c_type_cast): New function.\n+\t(pp_c_space_for_pointer_operator): Likewise.\n+\t(pp_c_call_argument_list): Likewise.\n+\t(pp_c_cv_qualifier): Adjust prototype.\n+\t(pp_c_type_qualifier_list): Likewise.\n+\t(pp_c_pointer): Likewise.  Handle REFERENCE_TYPE here.\n+\t(pp_c_type_specifier): Rename from pp_c_simple_type_specifier.\n+\tAdjust to follow standard grammar.\n+\t(pp_c_specifier_qualifier_list): Adjusr prototype.  Handle\n+\tREFERENCE_TYPE.  Tidy.\n+\t(pp_c_parameter_type_list): Adjust prototype.  Tidy.\n+\t(pp_c_parameter_declaration): Remove.\n+\t(pp_c_abstract_declarator): Adjust prototype.\n+\t(pp_c_direct_abstract_declarator): Likewise.\n+\t(pp_c_type_id): Likewise.\n+\t(pp_c_storage_class_specifier): Likewise. \n+\t(pp_c_function_specifier): Likewise.\n+\t(pp_c_declaration_specifiers): Likewise.\n+\t(pp_c_direct_declarator): Likewise.\n+\t(pp_c_declarator): Likewise.\n+\t(pp_c_declarator): Likewise.\n+\t(pp_c_declaration): Likewise.\n+\t(pp_c_attributes): Likewise.  Tidy.\n+\t(pp_c_function_definition): Adjust prototype.\n+\t(pp_c_char): Likewise.\n+\t(pp_c_string_literal): Likewise.\n+\t(pp_c_integer_constant): Likewise.\n+\t(pp_c_character_constant): Likewise.\n+\t(pp_c_bool_constant): Likewise.\n+\t(pp_c_enumeration_constant): Likewise.\n+\t(pp_c_floating_constant): Likewise.\n+\t(pp_c_constant): Likewise.\n+\t(pp_c_identifier): Likewise.\n+\t(pp_c_primary_expression): Likewise.  Remove TARGET_EXPR case.  Tidy.\n+\t(pp_c_initializer): Adjust prototype.\n+\t(pp_c_init_declarator): Likewise.\n+\t(pp_c_initializer_list): Likewise.\n+\t(pp_c_id_expression): Likewise.\n+\t(pp_c_postfix_expression): Likewise.\n+\t(pp_c_expression_list): Likewise.\n+\t(pp_c_unary_expression): Likewise.\n+\t(pp_c_cast_expression): Likewise.\n+\t(pp_c_multiplicative_expression): Likewise.\n+\t(pp_c_additive_expression): Likewise.\n+\t(pp_c_shift_expression): Likewise.\n+\t(pp_c_relational_expression): Likewise.\n+\t(pp_c_equality_expression): Likewise.\n+\t(pp_c_and_expression): Likewise.\n+\t(pp_c_exclusive_or_expression): Likewise.\n+\t(pp_c_inclusive_or_expression): Likewise.\n+\t(pp_c_logical_and_expression): Likewise.\n+\t(pp_c_logical_or_expression): Likewise.\n+\t(pp_c_conditional_expression): Likewise.\n+\t(pp_c_assignment_expression): Likewise.\n+\t(pp_c_expression): Likewise.  Tidy.\n+\t(pp_c_statement): Likewise.  Document.\n+\t(pp_c_pretty_printer_init): Adjust prototype. Tidy.\n+\n+\t* c-lang.c (c_initialize_diagnostics): Update.\n+\t* c-common.h (strip_pointer_operator): Declare.\n+\t* c-common.c (strip_pointer_operator): Define.\n+\n 2003-08-25  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/8795"}, {"sha": "9dd18264ff60aa7b6b964b19fbf49fe5885fbb9a", "filename": "gcc/c-common.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -3547,6 +3547,15 @@ strip_array_types (tree type)\n   return type;\n }\n \n+/* Recursively remove any '*' or '&' operator from TYPE.  */\n+tree\n+strip_pointer_operator (tree t)\n+{\n+  while (POINTER_TYPE_P (t))\n+    t = TREE_TYPE (t);\n+  return t;\n+}\n+\n static tree expand_unordered_cmp (tree, tree, enum tree_code, enum tree_code);\n \n /* Expand a call to an unordered comparison function such as"}, {"sha": "e7dabd3965144809a468d7483455fb61d8ef7f55", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -951,6 +951,7 @@ extern HOST_WIDE_INT c_common_get_alias_set (tree);\n extern bool c_promoting_integer_type_p (tree);\n extern int self_promoting_args_p (tree);\n extern tree strip_array_types (tree);\n+extern tree strip_pointer_operator (tree);\n \n /* This function resets the parsers' state in preparation for parsing\n    a new file.  */"}, {"sha": "93437a3733d339eb9047fea34e8edaf62e773402", "filename": "gcc/c-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -230,7 +230,7 @@ static void\n c_initialize_diagnostics (diagnostic_context *context)\n {\n   pretty_printer *base = context->printer;\n-  c_pretty_printer pp = xmalloc (sizeof *pp);\n+  c_pretty_printer *pp = xmalloc (sizeof (c_pretty_printer));\n   memcpy (pp_base (pp), base, sizeof (pretty_printer));\n   pp_c_pretty_printer_init (pp);\n   context->printer = (pretty_printer *) pp;"}, {"sha": "922d987ab28153d3321aa832c67b57e42acfeade", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 746, "deletions": 624, "changes": 1370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -35,29 +35,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    takes expression or declaration contexts into account.  */\n \n \n-#define pp_c_whitespace(PP)           \\\n-   do {                               \\\n-     pp_space (PP);                   \\\n-     pp_base (PP)->padding = pp_none; \\\n-   } while (0)\n #define pp_c_maybe_whitespace(PP)            \\\n    do {                                      \\\n      if (pp_base (PP)->padding == pp_before) \\\n        pp_c_whitespace (PP);                 \\\n    } while (0)\n \n-#define pp_c_left_paren(PP)           \\\n-  do {                                \\\n-    pp_left_paren (PP);               \\\n-    pp_base (PP)->padding = pp_none;  \\\n-  } while (0)\n-\n-#define pp_c_right_paren(PP)          \\\n-  do {                                \\\n-    pp_right_paren (PP);              \\\n-    pp_base (PP)->padding = pp_none;  \\\n-  } while (0)\n-\n #define pp_c_left_brace(PP)           \\\n   do {                                \\\n     pp_left_brace (PP);               \\\n@@ -82,81 +65,132 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n     pp_base (PP)->padding = pp_none;  \\\n   } while (0)\n \n-#define pp_c_arrow(PP)                \\\n-  do {                                \\\n-    pp_arrow (PP);                    \\\n-    pp_base (PP)->padding = pp_none;  \\\n-  } while (0)\n-\n #define pp_c_star(PP)                 \\\n   do {                                \\\n     pp_star (PP);                     \\\n     pp_base (PP)->padding = pp_none;  \\\n   } while (0)\n \n-#define pp_c_dot(PP)                  \\\n-  do {                                \\\n-    pp_dot (PP);                      \\\n-    pp_base (PP)->padding = pp_none;  \\\n-  } while (0)\n-\n-#define pp_c_semicolon(PP)            \\\n-  do {                                \\\n-    pp_semicolon (PP);                \\\n-    pp_base (PP)->padding = pp_none;  \\\n-  } while (0)\n-\n /* literal  */\n-static void pp_c_char (c_pretty_printer, int);\n-static void pp_c_primary_expression (c_pretty_printer, tree);\n+static void pp_c_char (c_pretty_printer *, int);\n \n /* postfix-expression  */\n-static void pp_c_initializer_list (c_pretty_printer, tree);\n-\n-static void pp_c_multiplicative_expression (c_pretty_printer, tree);\n-static void pp_c_additive_expression (c_pretty_printer, tree);\n-static void pp_c_shift_expression (c_pretty_printer, tree);\n-static void pp_c_relational_expression (c_pretty_printer, tree);\n-static void pp_c_equality_expression (c_pretty_printer, tree);\n-static void pp_c_and_expression (c_pretty_printer, tree);\n-static void pp_c_exclusive_or_expression (c_pretty_printer, tree);\n-static void pp_c_inclusive_or_expression (c_pretty_printer, tree);\n-static void pp_c_logical_and_expression (c_pretty_printer, tree);\n-static void pp_c_conditional_expression (c_pretty_printer, tree);\n-static void pp_c_assignment_expression (c_pretty_printer, tree);\n+static void pp_c_initializer_list (c_pretty_printer *, tree);\n+\n+static void pp_c_multiplicative_expression (c_pretty_printer *, tree);\n+static void pp_c_additive_expression (c_pretty_printer *, tree);\n+static void pp_c_shift_expression (c_pretty_printer *, tree);\n+static void pp_c_relational_expression (c_pretty_printer *, tree);\n+static void pp_c_equality_expression (c_pretty_printer *, tree);\n+static void pp_c_and_expression (c_pretty_printer *, tree);\n+static void pp_c_exclusive_or_expression (c_pretty_printer *, tree);\n+static void pp_c_inclusive_or_expression (c_pretty_printer *, tree);\n+static void pp_c_logical_and_expression (c_pretty_printer *, tree);\n+static void pp_c_conditional_expression (c_pretty_printer *, tree);\n+static void pp_c_assignment_expression (c_pretty_printer *, tree);\n \n /* declarations.  */\n-static void pp_c_declaration_specifiers (c_pretty_printer, tree);\n-static void pp_c_direct_abstract_declarator (c_pretty_printer, tree);\n-static void pp_c_init_declarator (c_pretty_printer, tree);\n-static void pp_c_simple_type_specifier (c_pretty_printer, tree);\n-static void pp_c_parameter_declaration (c_pretty_printer, tree);\n-static void pp_c_storage_class_specifier (c_pretty_printer, tree);\n-static void pp_c_function_specifier (c_pretty_printer, tree);\n-\n \n \f\n-/* Declarations.  */\n+/* Helper functions. */\n+\n+void\n+pp_c_whitespace (c_pretty_printer *pp)\n+{\n+  pp_space (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n+\n+void\n+pp_c_left_paren (c_pretty_printer *pp)\n+{\n+  pp_left_paren (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n+\n+void\n+pp_c_right_paren (c_pretty_printer *pp)\n+{\n+  pp_right_paren (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n+\n+void\n+pp_c_dot (c_pretty_printer *pp)\n+{\n+  pp_dot (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n+\n+void\n+pp_c_ampersand (c_pretty_printer *pp)\n+{\n+  pp_ampersand (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n+\n+void\n+pp_c_arrow (c_pretty_printer *pp)\n+{\n+  pp_arrow (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n+\n+void\n+pp_c_semicolon(c_pretty_printer *pp)\n+{\n+  pp_semicolon (pp);\n+  pp_base (pp)->padding = pp_none;\n+}\n \n static void\n-pp_c_cv_qualifier (c_pretty_printer pp, const char *cv)\n+pp_c_cv_qualifier (c_pretty_printer *pp, const char *cv)\n {\n   const char *p = pp_last_position_in_text (pp);\n   if (p != NULL && *p == '*')\n     pp_c_whitespace (pp);\n   pp_c_identifier (pp, cv);\n }\n \n+/* Pretty-print T using the type-cast notation '( type-name )'.  */\n+static inline void\n+pp_c_type_cast (c_pretty_printer *pp, tree t)\n+{\n+  pp_c_left_paren (pp);\n+  pp_type_id (pp, t);\n+  pp_c_right_paren (pp);\n+}\n+\n+void\n+pp_c_space_for_pointer_operator (c_pretty_printer *pp, tree t)\n+{\n+  if (POINTER_TYPE_P (t))\n+    {\n+      tree pointee = strip_pointer_operator (TREE_TYPE (t));\n+      if (TREE_CODE (pointee) != ARRAY_TYPE\n+          && TREE_CODE (pointee) != FUNCTION_TYPE)\n+        pp_c_whitespace (pp);\n+    }\n+}\n+\n+\f\n+/* Declarations.  */\n+\n /* C++ cv-qualifiers are called type-qualifiers in C.  Print out the\n    cv-qualifiers of T.  If T is a declaration then it is the cv-qualifier\n    of its type.  Take care of possible extensions.\n-   cv-qualifier:\n+\n+   type-qualifier-list:\n+       type-qualifier\n+       type-qualifier-list type-qualifier\n+\n+   type-qualifier:\n        const\n-       volatile\n-       restrict\n-       __restrict__   */\n+       restrict                              -- C99\n+       __restrict__                          -- GNU C\n+       volatile    */\n void\n-pp_c_type_qualifier_list (c_pretty_printer pp, tree t)\n+pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)\n {\n    int qualifiers;\n    \n@@ -176,16 +210,21 @@ pp_c_type_qualifier_list (c_pretty_printer pp, tree t)\n       * type-qualifier-list(opt)\n       * type-qualifier-list(opt) pointer  */\n static void\n-pp_c_pointer (c_pretty_printer pp, tree t)\n+pp_c_pointer (c_pretty_printer *pp, tree t)\n {\n   if (!TYPE_P (t) && TREE_CODE (t) != TYPE_DECL)\n     t = TREE_TYPE (t);\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n+      /* It is easier to handle C++ reference types here. */\n+    case REFERENCE_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n         pp_c_pointer (pp, TREE_TYPE (t));\n-      pp_c_star (pp);\n+      if (TREE_CODE (t) == POINTER_TYPE)\n+        pp_c_star (pp);\n+      else\n+        pp_c_ampersand (pp);\n       pp_c_type_qualifier_list (pp, t);\n       break;\n \n@@ -194,108 +233,83 @@ pp_c_pointer (c_pretty_printer pp, tree t)\n     }\n }\n \n-/*\n-  simple-type-specifier:\n-     void\n-     char\n-     short\n-     int\n-     long\n-     float\n-     double\n-     signed\n-     unsigned\n-     _Bool                          -- C99\n-     _Complex                       -- C99\n-     _Imaginary                     -- C99\n-     typedef-name.\n+/* type-specifier:\n+      void\n+      char\n+      short\n+      int\n+      long\n+      float\n+      double\n+      signed\n+      unsigned\n+      _Bool                          -- C99\n+      _Complex                       -- C99\n+      _Imaginary                     -- C99\n+      struct-or-union-specifier\n+      enum-specifier\n+      typedef-name.\n \n   GNU extensions.\n   simple-type-specifier:\n       __complex__\n       __vector__   */\n-static void\n-pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n+void\n+pp_c_type_specifier (c_pretty_printer *pp, tree t)\n {\n-  enum tree_code code;\n-\n-  if (DECL_P (t) && TREE_CODE (t) != TYPE_DECL)\n-    t = TREE_TYPE (t);\n-\n-  code = TREE_CODE (t);\n+  const enum tree_code code = TREE_CODE (t);\n   switch (code)\n     {\n     case ERROR_MARK:\n-      pp_c_identifier (ppi, \"<type-error>\");\n-      break;\n-\n-#if 0\n-    case UNKNOWN_TYPE:\n-      pp_c_identifier (ppi, \"<unkown-type>\");\n+      pp_c_identifier (pp, \"<type-error>\");\n       break;\n-#endif\n \n     case IDENTIFIER_NODE:\n-      pp_c_tree_identifier (ppi, t);\n+      pp_c_tree_identifier (pp, t);\n       break;\n \n     case VOID_TYPE:\n     case BOOLEAN_TYPE:\n     case CHAR_TYPE:\n     case INTEGER_TYPE:\n     case REAL_TYPE:\n-      pp_c_simple_type_specifier (ppi, TYPE_NAME (t));\n-      break;\n-\n-    case COMPLEX_TYPE:\n-    case VECTOR_TYPE:\n-      pp_c_simple_type_specifier (ppi, TYPE_MAIN_VARIANT (TREE_TYPE (t)));\n-      if (code == COMPLEX_TYPE)\n-\tpp_c_identifier (ppi, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n-      else if (code == VECTOR_TYPE)\n-\tpp_c_identifier (ppi, \"__vector__\");\n+      pp_c_type_specifier (pp, TYPE_NAME (t));\n       break;\n \n     case TYPE_DECL:\n       if (DECL_NAME (t))\n-\tpp_id_expression (ppi, t);\n+\tpp_id_expression (pp, t);\n       else\n-\tpp_c_identifier (ppi, \"<typedef-error>\");\n+\tpp_c_identifier (pp, \"<typedef-error>\");\n       break;\n \n     case UNION_TYPE:\n     case RECORD_TYPE:\n     case ENUMERAL_TYPE:\n       if (code == UNION_TYPE)\n-\tpp_c_identifier (ppi, \"union\");\n+\tpp_c_identifier (pp, \"union\");\n       else if (code == RECORD_TYPE)\n-\tpp_c_identifier (ppi, \"struct\");\n+\tpp_c_identifier (pp, \"struct\");\n       else if (code == ENUMERAL_TYPE)\n-\tpp_c_identifier (ppi, \"enum\");\n+\tpp_c_identifier (pp, \"enum\");\n       else\n-\tpp_c_identifier (ppi, \"<tag-error>\");\n+\tpp_c_identifier (pp, \"<tag-error>\");\n \n       if (TYPE_NAME (t))\n-\tpp_id_expression (ppi, TYPE_NAME (t));\n+\tpp_id_expression (pp, TYPE_NAME (t));\n       else\n-\tpp_c_identifier (ppi, \"<anonymous>\");\n-      break;\n-\n-    case POINTER_TYPE:\n-    case ARRAY_TYPE:\n-    case FUNCTION_TYPE:\n-      pp_c_simple_type_specifier (ppi, TREE_TYPE (t));\n+\tpp_c_identifier (pp, \"<anonymous>\");\n       break;\n \n     default:\n-      pp_unsupported_tree (ppi, t);\n+      pp_unsupported_tree (pp, t);\n       break;\n     }\n }\n \n /* specifier-qualifier-list:\n       type-specifier specifier-qualifier-list-opt\n-      cv-qualifier specifier-qualifier-list-opt\n+      type-qualifier specifier-qualifier-list-opt\n \n \n   Implementation note:  Because of the non-linearities in array or\n@@ -304,29 +318,27 @@ pp_c_simple_type_specifier (c_pretty_printer ppi, tree t)\n   but also the 'pointer' production part of their declarators.  The\n   remaining part is done by pp_declarator or pp_c_abstract_declarator.  */\n void\n-pp_c_specifier_qualifier_list (c_pretty_printer pp, tree t)\n+pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n {\n+  const enum tree_code code = TREE_CODE (t);\n+\n   if (TREE_CODE (t) != POINTER_TYPE)\n     pp_c_type_qualifier_list (pp, t);\n-  switch (TREE_CODE (t))\n+  switch (code)\n     {\n+    case REFERENCE_TYPE:\n     case POINTER_TYPE:\n       {\n         /* Get the types-specifier of this type.  */\n-        tree pointee = TREE_TYPE (t);\n-        while (TREE_CODE (pointee) == POINTER_TYPE)\n-          pointee = TREE_TYPE (pointee);\n+        tree pointee = strip_pointer_operator (TREE_TYPE (t));\n         pp_c_specifier_qualifier_list (pp, pointee);\n         if (TREE_CODE (pointee) == ARRAY_TYPE\n             || TREE_CODE (pointee) == FUNCTION_TYPE)\n           {\n             pp_c_whitespace (pp);\n             pp_c_left_paren (pp);\n           }\n-        pp_c_pointer (pp, t);\n-        if (TREE_CODE (pointee) != FUNCTION_TYPE\n-            && TREE_CODE (pointee) != ARRAY_TYPE)\n-          pp_c_whitespace (pp);\n+        pp_ptr_operator (pp, t);\n       }\n       break;\n \n@@ -338,12 +350,14 @@ pp_c_specifier_qualifier_list (c_pretty_printer pp, tree t)\n     case VECTOR_TYPE:\n     case COMPLEX_TYPE:\n       pp_c_specifier_qualifier_list (pp, TREE_TYPE (t));\n-      pp_space (pp);\n-      pp_c_simple_type_specifier (pp, t);\n+      if (code == COMPLEX_TYPE)\n+\tpp_c_identifier (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n+      else if (code == VECTOR_TYPE)\n+\tpp_c_identifier (pp, \"__vector__\");\n       break;\n \n     default:\n-      pp_c_simple_type_specifier (pp, t);\n+      pp_simple_type_specifier (pp, t);\n       break;\n     }\n }\n@@ -359,26 +373,28 @@ pp_c_specifier_qualifier_list (c_pretty_printer pp, tree t)\n    parameter-declaration:\n       declaration-specifiers declarator\n       declaration-specifiers abstract-declarator(opt)   */\n-static void\n-pp_c_parameter_type_list (c_pretty_printer pp, tree t)\n+void\n+pp_c_parameter_type_list (c_pretty_printer *pp, tree t)\n {\n+  bool want_parm_decl = DECL_P (t) && !(pp->flags & pp_c_flag_abstract);\n+  tree parms = want_parm_decl ? DECL_ARGUMENTS (t) :  TYPE_ARG_TYPES (t);\n   pp_c_left_paren (pp);\n-  if (t == void_list_node)\n+  if (parms == void_list_node)\n     pp_c_identifier (pp, \"void\");\n   else\n     {\n       bool first = true;\n-      bool want_parm_decl = t && DECL_P (t);\n-      for ( ; t != NULL && t != void_list_node; t = TREE_CHAIN (t))\n+      for ( ; parms && parms != void_list_node; parms = TREE_CHAIN (parms))\n         {\n           if (!first)\n             pp_separate_with (pp, ',');\n           first = false;\n-          pp_declaration_specifiers (pp, want_parm_decl ? t : TREE_VALUE (t));\n+          pp_declaration_specifiers\n+            (pp, want_parm_decl ? parms : TREE_VALUE (parms));\n           if (want_parm_decl)\n-            pp_declarator (pp, t);\n+            pp_declarator (pp, parms);\n           else\n-            pp_abstract_declarator (pp, TREE_VALUE (t));\n+            pp_abstract_declarator (pp, TREE_VALUE (parms));\n         }\n     }\n   pp_c_right_paren (pp);\n@@ -388,7 +404,7 @@ pp_c_parameter_type_list (c_pretty_printer pp, tree t)\n       pointer\n       pointer(opt) direct-abstract-declarator  */\n static inline void\n-pp_c_abstract_declarator (c_pretty_printer pp, tree t)\n+pp_c_abstract_declarator (c_pretty_printer *pp, tree t)\n {\n   if (TREE_CODE (t) == POINTER_TYPE)\n     {\n@@ -398,34 +414,34 @@ pp_c_abstract_declarator (c_pretty_printer pp, tree t)\n       t = TREE_TYPE (t);\n     }\n \n-  pp_c_direct_abstract_declarator (pp, t);\n+  pp_direct_abstract_declarator (pp, t);\n }\n \n /* direct-abstract-declarator:\n       ( abstract-declarator )\n       direct-abstract-declarator(opt) [ assignment-expression(opt) ]\n       direct-abstract-declarator(opt) [ * ]\n       direct-abstract-declarator(opt) ( parameter-type-list(opt) )  */\n-static void\n-pp_c_direct_abstract_declarator (c_pretty_printer pp, tree t)\n+void\n+pp_c_direct_abstract_declarator (c_pretty_printer *pp, tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case POINTER_TYPE:\n-      pp_c_abstract_declarator (pp, t);\n+      pp_abstract_declarator (pp, t);\n       break;\n       \n     case FUNCTION_TYPE:\n-      pp_c_parameter_type_list (pp, TYPE_ARG_TYPES (t));\n-      pp_c_direct_abstract_declarator (pp, TREE_TYPE (t));\n+      pp_c_parameter_type_list (pp, t);\n+      pp_direct_abstract_declarator (pp, TREE_TYPE (t));\n       break;\n \n     case ARRAY_TYPE:\n       pp_c_left_bracket (pp);\n       if (TYPE_DOMAIN (t))\n-        pp_c_expression (pp, TYPE_MAX_VALUE (TYPE_DOMAIN (t)));\n+        pp_expression (pp, TYPE_MAX_VALUE (TYPE_DOMAIN (t)));\n       pp_c_right_bracket (pp);\n-      pp_c_direct_abstract_declarator (pp, TREE_TYPE (t));\n+      pp_direct_abstract_declarator (pp, TREE_TYPE (t));\n       break;\n \n     case IDENTIFIER_NODE:\n@@ -447,15 +463,23 @@ pp_c_direct_abstract_declarator (c_pretty_printer pp, tree t)\n     }\n }\n \n+/* type-name:\n+      specifier-qualifier-list  abstract-declarator(opt)  */\n void\n-pp_c_type_id (c_pretty_printer ppi, tree t)\n+pp_c_type_id (c_pretty_printer *pp, tree t)\n {\n-  pp_c_specifier_qualifier_list (ppi, t);\n-  pp_abstract_declarator (ppi, t);\n+  pp_c_specifier_qualifier_list (pp, t);\n+  pp_abstract_declarator (pp, t);\n }\n \n-static inline void\n-pp_c_storage_class_specifier (c_pretty_printer pp, tree t)\n+/* storage-class-specifier:\n+      typedef\n+      extern\n+      static\n+      auto\n+      register  */\n+void\n+pp_c_storage_class_specifier (c_pretty_printer *pp, tree t)\n {\n   if (TREE_CODE (t) == TYPE_DECL)\n     pp_c_identifier (pp, \"typedef\");\n@@ -468,8 +492,10 @@ pp_c_storage_class_specifier (c_pretty_printer pp, tree t)\n     }\n }\n \n-static inline void\n-pp_c_function_specifier (c_pretty_printer pp, tree t)\n+/* function-specifier:\n+      inline   */\n+void\n+pp_c_function_specifier (c_pretty_printer *pp, tree t)\n {\n   if (TREE_CODE (t) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (t))\n     pp_c_identifier (pp, \"inline\");\n@@ -480,8 +506,8 @@ pp_c_function_specifier (c_pretty_printer pp, tree t)\n       type-specifier declaration-specifiers(opt)\n       type-qualifier declaration-specifiers(opt)\n       function-specifier declaration-specifiers(opt)  */\n-static inline void\n-pp_c_declaration_specifiers (c_pretty_printer pp, tree t)\n+void\n+pp_c_declaration_specifiers (c_pretty_printer *pp, tree t)\n {\n   pp_storage_class_specifier (pp, t);\n   pp_function_specifier (pp, t);\n@@ -498,7 +524,7 @@ pp_c_declaration_specifiers (c_pretty_printer pp, tree t)\n       direct-declaratpr ( parameter-type-list )\n       direct-declarator ( identifier-list(opt) )  */\n void\n-pp_c_direct_declarator (c_pretty_printer pp, tree t)\n+pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -507,25 +533,30 @@ pp_c_direct_declarator (c_pretty_printer pp, tree t)\n     case TYPE_DECL:\n     case FIELD_DECL:\n     case LABEL_DECL:\n-      pp_c_tree_identifier (pp, DECL_NAME (t));\n+      if (DECL_NAME (t))\n+        {\n+          pp_c_space_for_pointer_operator (pp, TREE_TYPE (t));\n+          pp_c_tree_identifier (pp, DECL_NAME (t));\n+        }\n     case ARRAY_TYPE:\n     case POINTER_TYPE:\n       pp_abstract_declarator (pp, TREE_TYPE (t));\n       break;\n \n     case FUNCTION_TYPE:\n-      pp_c_parameter_type_list (pp, TYPE_ARG_TYPES (t));\n-      pp_c_abstract_declarator (pp, TREE_TYPE (t));\n+      pp_parameter_list (pp, t);\n+      pp_abstract_declarator (pp, TREE_TYPE (t));\n       break;\n \n     case FUNCTION_DECL:\n+      pp_c_space_for_pointer_operator (pp, TREE_TYPE (TREE_TYPE (t)));\n       pp_c_tree_identifier (pp, DECL_NAME (t));\n       if (pp_c_base (pp)->flags & pp_c_flag_abstract)\n-        pp_c_abstract_declarator (pp, TREE_TYPE (t));\n+        pp_abstract_declarator (pp, TREE_TYPE (t));\n       else\n         {\n-          pp_c_parameter_type_list (pp, DECL_ARGUMENTS (t));\n-          pp_c_abstract_declarator (pp, TREE_TYPE (TREE_TYPE (t)));\n+          pp_parameter_list (pp, t);\n+          pp_abstract_declarator (pp, TREE_TYPE (TREE_TYPE (t)));\n         }\n       break;\n \n@@ -546,7 +577,7 @@ pp_c_direct_declarator (c_pretty_printer pp, tree t)\n /* declarator:\n       pointer(opt)  direct-declarator   */\n void\n-pp_c_declarator (c_pretty_printer pp, tree t)\n+pp_c_declarator (c_pretty_printer *pp, tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -574,41 +605,18 @@ pp_c_declarator (c_pretty_printer pp, tree t)\n     }\n }\n \n-/* init-declarator:\n-      declarator:\n-      declarator = initializer   */\n-static inline void\n-pp_c_init_declarator (c_pretty_printer pp, tree t)\n-{\n-  pp_declarator (pp, t);\n-  if (DECL_INITIAL (t))\n-    {\n-      pp_space (pp);\n-      pp_equal (pp);\n-      pp_space (pp);\n-      pp_c_initializer (pp, DECL_INITIAL (t));\n-    }\n-}\n-\n /* declaration:\n       declaration-specifiers init-declarator-list(opt) ;  */\n-\n void\n-pp_c_declaration (c_pretty_printer pp, tree t)\n+pp_c_declaration (c_pretty_printer *pp, tree t)\n {\n   pp_declaration_specifiers (pp, t);\n   pp_c_init_declarator (pp, t);\n }\n \n-static void\n-pp_c_parameter_declaration (c_pretty_printer pp, tree t)\n-{\n-  pp_unsupported_tree (pp, t);\n-}\n-\n /* Pretty-print ATTRIBUTES using GNU C extension syntax.  */\n void\n-pp_c_attributes (c_pretty_printer pp, tree attributes)\n+pp_c_attributes (c_pretty_printer *pp, tree attributes)\n {\n   if (attributes == NULL_TREE)\n     return;\n@@ -620,11 +628,7 @@ pp_c_attributes (c_pretty_printer pp, tree attributes)\n     {\n       pp_tree_identifier (pp, TREE_PURPOSE (attributes));\n       if (TREE_VALUE (attributes))\n-\t{\n-\t  pp_c_left_paren (pp);\n-\t  pp_c_expression_list (pp, TREE_VALUE (attributes));\n-\t  pp_c_right_paren (pp);\n-\t}\n+        pp_c_call_argument_list (pp, TREE_VALUE (attributes));\n \n       if (TREE_CHAIN (attributes))\n \tpp_separate_with (pp, ',');\n@@ -636,7 +640,7 @@ pp_c_attributes (c_pretty_printer pp, tree attributes)\n /* function-definition:\n       declaration-specifiers declarator compound-statement  */\n void\n-pp_c_function_definition (c_pretty_printer pp, tree t)\n+pp_c_function_definition (c_pretty_printer *pp, tree t)\n {\n   pp_declaration_specifiers (pp, t);\n   pp_declarator (pp, t);\n@@ -651,64 +655,64 @@ pp_c_function_definition (c_pretty_printer pp, tree t)\n \n /* Print out a c-char.  */\n static void\n-pp_c_char (c_pretty_printer ppi, int c)\n+pp_c_char (c_pretty_printer *pp, int c)\n {\n   switch (c)\n     {\n     case TARGET_NEWLINE:\n-      pp_string (ppi, \"\\\\n\");\n+      pp_string (pp, \"\\\\n\");\n       break;\n     case TARGET_TAB:\n-      pp_string (ppi, \"\\\\t\");\n+      pp_string (pp, \"\\\\t\");\n       break;\n     case TARGET_VT:\n-      pp_string (ppi, \"\\\\v\");\n+      pp_string (pp, \"\\\\v\");\n       break;\n     case TARGET_BS:\n-      pp_string (ppi, \"\\\\b\");\n+      pp_string (pp, \"\\\\b\");\n       break;\n     case TARGET_CR:\n-      pp_string (ppi, \"\\\\r\");\n+      pp_string (pp, \"\\\\r\");\n       break;\n     case TARGET_FF:\n-      pp_string (ppi, \"\\\\f\");\n+      pp_string (pp, \"\\\\f\");\n       break;\n     case TARGET_BELL:\n-      pp_string (ppi, \"\\\\a\");\n+      pp_string (pp, \"\\\\a\");\n       break;\n     case '\\\\':\n-      pp_string (ppi, \"\\\\\\\\\");\n+      pp_string (pp, \"\\\\\\\\\");\n       break;\n     case '\\'':\n-      pp_string (ppi, \"\\\\'\");\n+      pp_string (pp, \"\\\\'\");\n       break;\n     case '\\\"':\n-      pp_string (ppi, \"\\\\\\\"\");\n+      pp_string (pp, \"\\\\\\\"\");\n       break;\n     default:\n       if (ISPRINT (c))\n-\tpp_character (ppi, c);\n+\tpp_character (pp, c);\n       else\n-\tpp_scalar (ppi, \"\\\\%03o\", (unsigned) c);\n+\tpp_scalar (pp, \"\\\\%03o\", (unsigned) c);\n       break;\n     }\n }\n \n /* Print out a STRING literal.  */\n void\n-pp_c_string_literal (c_pretty_printer ppi, tree s)\n+pp_c_string_literal (c_pretty_printer *pp, tree s)\n {\n   const char *p = TREE_STRING_POINTER (s);\n   int n = TREE_STRING_LENGTH (s) - 1;\n   int i;\n-  pp_doublequote (ppi);\n+  pp_doublequote (pp);\n   for (i = 0; i < n; ++i)\n-    pp_c_char (ppi, p[i]);\n-  pp_doublequote (ppi);\n+    pp_c_char (pp, p[i]);\n+  pp_doublequote (pp);\n }\n \n static void\n-pp_c_integer_constant (c_pretty_printer pp, tree i)\n+pp_c_integer_constant (c_pretty_printer *pp, tree i)\n {\n   if (host_integerp (i, 0))\n     pp_wide_integer (pp, TREE_INT_CST_LOW (i));\n@@ -729,7 +733,7 @@ pp_c_integer_constant (c_pretty_printer pp, tree i)\n \n /* Print out a CHARACTER literal.  */\n static inline void\n-pp_c_character_constant (c_pretty_printer pp, tree c)\n+pp_c_character_constant (c_pretty_printer *pp, tree c)\n {\n   tree type = TREE_TYPE (c);\n   if (type == wchar_type_node)\n@@ -744,7 +748,7 @@ pp_c_character_constant (c_pretty_printer pp, tree c)\n \n /* Print out a BOOLEAN literal.  */\n static void\n-pp_c_bool_constant (c_pretty_printer pp, tree b)\n+pp_c_bool_constant (c_pretty_printer *pp, tree b)\n {\n   if (b == boolean_false_node)\n     {\n@@ -775,7 +779,7 @@ pp_c_bool_constant (c_pretty_printer pp, tree b)\n    print out the type-id part of the cast-expression -- the casted value\n    is then printed by pp_c_integer_literal.  */\n static bool\n-pp_c_enumeration_constant (c_pretty_printer ppi, tree e)\n+pp_c_enumeration_constant (c_pretty_printer *pp, tree e)\n {\n   bool value_is_named = true;\n   tree type = TREE_TYPE (e);\n@@ -788,13 +792,11 @@ pp_c_enumeration_constant (c_pretty_printer ppi, tree e)\n     ;\n \n   if (value != NULL_TREE)\n-    pp_id_expression (ppi, TREE_PURPOSE (value));\n+    pp_id_expression (pp, TREE_PURPOSE (value));\n   else\n     {\n       /* Value must have been cast.  */\n-      pp_c_left_paren (ppi);\n-      pp_type_id (ppi, type);\n-      pp_c_right_paren (ppi);\n+      pp_c_type_cast (pp, type);\n       value_is_named = false;\n     }\n \n@@ -803,7 +805,7 @@ pp_c_enumeration_constant (c_pretty_printer ppi, tree e)\n \n /* Print out a REAL value.  */\n static inline void\n-pp_c_floating_constant (c_pretty_printer pp, tree r)\n+pp_c_floating_constant (c_pretty_printer *pp, tree r)\n {\n   real_to_decimal (pp_buffer (pp)->digit_buffer, &TREE_REAL_CST (r),\n \t\t   sizeof (pp_buffer (pp)->digit_buffer), 0, 1);\n@@ -816,7 +818,7 @@ pp_c_floating_constant (c_pretty_printer pp, tree r)\n       enumeration-constant\n       chatracter-constant   */\n void\n-pp_c_constant (c_pretty_printer pp, tree e)\n+pp_c_constant (c_pretty_printer *pp, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n@@ -850,7 +852,7 @@ pp_c_constant (c_pretty_printer pp, tree e)\n }\n \n void\n-pp_c_identifier (c_pretty_printer pp, const char *id)\n+pp_c_identifier (c_pretty_printer *pp, const char *id)\n {\n   pp_c_maybe_whitespace (pp);            \n   pp_identifier (pp, id);  \n@@ -863,8 +865,8 @@ pp_c_identifier (c_pretty_printer pp, const char *id)\n       constant\n       string-literal\n       ( expression )   */\n-static void\n-pp_c_primary_expression (c_pretty_printer ppi, tree e)\n+void\n+pp_c_primary_expression (c_pretty_printer *pp, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n@@ -877,50 +879,34 @@ pp_c_primary_expression (c_pretty_printer ppi, tree e)\n       e = DECL_NAME (e);\n       /* Fall through.  */\n     case IDENTIFIER_NODE:\n-      pp_c_tree_identifier (ppi, e);\n+      pp_c_tree_identifier (pp, e);\n       break;\n \n     case ERROR_MARK:\n-      pp_c_identifier (ppi, \"<erroneous-expression>\");\n+      pp_c_identifier (pp, \"<erroneous-expression>\");\n       break;\n \n     case RESULT_DECL:\n-      pp_c_identifier (ppi, \"<return-value>\");\n+      pp_c_identifier (pp, \"<return-value>\");\n       break;\n \n     case INTEGER_CST:\n     case REAL_CST:\n     case STRING_CST:\n-      pp_c_constant (ppi, e);\n+      pp_c_constant (pp, e);\n       break;\n \n-    case TARGET_EXPR:\n-      pp_c_left_paren (ppi);\n-      pp_c_identifier (ppi, \"__builtin_memcpy\");\n-      pp_c_left_paren (ppi);\n-      pp_ampersand (ppi);\n-      pp_primary_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_separate_with (ppi, ',');\n-      pp_ampersand (ppi);\n-      pp_initializer (ppi, TREE_OPERAND (e, 1));\n-      if (TREE_OPERAND (e, 2))\n-\t{\n-\t  pp_separate_with (ppi, ',');\n-\t  pp_c_expression (ppi, TREE_OPERAND (e, 2));\n-\t}\n-      pp_c_right_paren (ppi);\n-\n     case STMT_EXPR:\n-      pp_c_left_paren (ppi);\n-      pp_statement (ppi, STMT_EXPR_STMT (e));\n-      pp_c_right_paren (ppi);\n+      pp_c_left_paren (pp);\n+      pp_statement (pp, STMT_EXPR_STMT (e));\n+      pp_c_right_paren (pp);\n       break;\n \n     default:\n       /* FIXME:  Make sure we won't get into an infinie loop.  */\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, e);\n-      pp_c_right_paren (ppi);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, e);\n+      pp_c_right_paren (pp);\n       break;\n     }\n }\n@@ -931,23 +917,53 @@ pp_c_primary_expression (c_pretty_printer ppi, tree e)\n       { initializer-list }\n       { initializer-list , }   */\n \n-void\n-pp_c_initializer (c_pretty_printer ppi, tree e)\n+static void\n+pp_c_initializer (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == CONSTRUCTOR)\n     {\n       enum tree_code code = TREE_CODE (TREE_TYPE (e));\n       if (code == RECORD_TYPE || code == UNION_TYPE || code == ARRAY_TYPE)\n \t{\n-\t  pp_c_left_brace (ppi);\n-\t  pp_c_initializer_list (ppi, e);\n-\t  pp_c_right_brace (ppi);\n+\t  pp_c_left_brace (pp);\n+\t  pp_c_initializer_list (pp, e);\n+\t  pp_c_right_brace (pp);\n \t}\n       else\n-\tpp_unsupported_tree (ppi, TREE_OPERAND (e, 1));\n+\tpp_unsupported_tree (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_assignment_expression (ppi, e);\n+    pp_expression (pp, e);\n+}\n+\n+/* init-declarator:\n+      declarator:\n+      declarator = initializer   */\n+void\n+pp_c_init_declarator (c_pretty_printer *pp, tree t)\n+{\n+  pp_declarator (pp, t);\n+  if (DECL_INITIAL (t))\n+    {\n+      tree init = DECL_INITIAL (t);\n+      /* This C++ bit is handled here because it is easier to do so.\n+         In templates, the C++ parser builds a TREE_LIST for a\n+         direct-initialization; the TREE_PURPOSE is the variable to\n+         initialize and the TREE_VALUE is the initializer.  */\n+      if (TREE_CODE (init) == TREE_LIST)\n+        {\n+          pp_c_left_paren (pp);\n+          pp_expression (pp, TREE_VALUE (init));\n+          pp_right_paren (pp);\n+        }\n+      else\n+        {\n+          pp_space (pp);\n+          pp_equal (pp);\n+          pp_space (pp);\n+          pp_c_initializer (pp, init);\n+        }\n+    }\n }\n \n /* initializer-list:\n@@ -965,7 +981,7 @@ pp_c_initializer (c_pretty_printer ppi, tree e)\n       [ constant-expression ]\n       identifier   */\n static void\n-pp_c_initializer_list (c_pretty_printer ppi, tree e)\n+pp_c_initializer_list (c_pretty_printer *pp, tree e)\n {\n   tree type = TREE_TYPE (e);\n   const enum tree_code code = TREE_CODE (type);\n@@ -977,26 +993,26 @@ pp_c_initializer_list (c_pretty_printer ppi, tree e)\n \t{\n \t  if (code == RECORD_TYPE || code == UNION_TYPE)\n \t    {\n-\t      pp_c_dot (ppi);\n-\t      pp_c_primary_expression (ppi, TREE_PURPOSE (init));\n+\t      pp_c_dot (pp);\n+\t      pp_c_primary_expression (pp, TREE_PURPOSE (init));\n \t    }\n \t  else\n \t    {\n-\t      pp_c_left_bracket (ppi);\n+\t      pp_c_left_bracket (pp);\n \t      if (TREE_PURPOSE (init))\n-\t\tpp_c_constant (ppi, TREE_PURPOSE (init));\n-\t      pp_c_right_bracket (ppi);\n+\t\tpp_c_constant (pp, TREE_PURPOSE (init));\n+\t      pp_c_right_bracket (pp);\n \t    }\n-\t  pp_c_whitespace (ppi);\n-\t  pp_equal (ppi);\n-\t  pp_c_whitespace (ppi);\n-\t  pp_initializer (ppi, TREE_VALUE (init));\n+\t  pp_c_whitespace (pp);\n+\t  pp_equal (pp);\n+\t  pp_c_whitespace (pp);\n+\t  pp_initializer (pp, TREE_VALUE (init));\n \t  if (TREE_CHAIN (init))\n-\t    pp_separate_with (ppi, ',');\n+\t    pp_separate_with (pp, ',');\n \t}\n     }\n   else\n-    pp_unsupported_tree (ppi, type);\n+    pp_unsupported_tree (pp, type);\n }\n \n /*  This is a convenient function, used to bridge gap between C and C++\n@@ -1005,7 +1021,7 @@ pp_c_initializer_list (c_pretty_printer ppi, tree e)\n     id-expression:\n        identifier  */\n void\n-pp_c_id_expression (c_pretty_printer pp, tree t)\n+pp_c_id_expression (c_pretty_printer *pp, tree t)\n {\n   switch (TREE_CODE (t))\n     {\n@@ -1038,130 +1054,136 @@ pp_c_id_expression (c_pretty_printer pp, tree t)\n       ( type-name ) { initializer-list }\n       ( type-name ) { initializer-list , }  */\n void\n-pp_c_postfix_expression (c_pretty_printer ppi, tree e)\n+pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n-      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_identifier (ppi, code == POSTINCREMENT_EXPR ? \"++\" : \"--\");\n+      pp_postfix_expression (pp, TREE_OPERAND (e, 0));\n+      pp_identifier (pp, code == POSTINCREMENT_EXPR ? \"++\" : \"--\");\n       break;\n \n     case ARROW_EXPR:\n-      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_arrow (ppi);\n+      pp_postfix_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_arrow (pp);\n       break;\n \n     case ARRAY_REF:\n-      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_left_bracket (ppi);\n-      pp_c_expression (ppi, TREE_OPERAND (e, 1));\n-      pp_c_right_bracket (ppi);\n+      pp_postfix_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_left_bracket (pp);\n+      pp_expression (pp, TREE_OPERAND (e, 1));\n+      pp_c_right_bracket (pp);\n       break;\n \n     case CALL_EXPR:\n-      pp_postfix_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_left_paren (ppi);\n-      pp_c_expression_list (ppi, TREE_OPERAND (e, 1));\n-      pp_c_right_paren (ppi);\n+      pp_postfix_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_call_argument_list (pp, TREE_OPERAND (e, 1));\n       break;\n \n     case ABS_EXPR:\n     case FFS_EXPR:\n-      pp_c_identifier (ppi,\n+      pp_c_identifier (pp,\n \t\t       code == ABS_EXPR ? \"__builtin_abs\" : \"__builtin_ffs\");\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_right_paren (ppi);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_right_paren (pp);\n       break;\n \n     case COMPONENT_REF:\n       {\n \ttree object = TREE_OPERAND (e, 0);\n \tif (TREE_CODE (object) == INDIRECT_REF)\n \t  {\n-\t    pp_postfix_expression (ppi, TREE_OPERAND (object, 0));\n-\t    pp_c_arrow (ppi);\n+\t    pp_postfix_expression (pp, TREE_OPERAND (object, 0));\n+\t    pp_c_arrow (pp);\n \t  }\n \telse\n \t  {\n-\t    pp_postfix_expression (ppi, object);\n-\t    pp_c_dot (ppi);\n+\t    pp_postfix_expression (pp, object);\n+\t    pp_c_dot (pp);\n \t  }\n-\tpp_c_expression (ppi, TREE_OPERAND (e, 1));\n+\tpp_expression (pp, TREE_OPERAND (e, 1));\n       }\n       break;\n \n     case COMPLEX_CST:\n     case VECTOR_CST:\n     case COMPLEX_EXPR:\n-      pp_c_left_paren (ppi);\n-      pp_type_id (ppi, TREE_TYPE (e));\n-      pp_c_right_paren (ppi);\n-      pp_c_left_brace (ppi);\n+      pp_c_type_cast (pp, TREE_TYPE (e));\n+      pp_c_left_brace (pp);\n \n       if (code == COMPLEX_CST)\n \t{\n-\t  pp_c_expression (ppi, TREE_REALPART (e));\n-\t  pp_separate_with (ppi, ',');\n-\t  pp_c_expression (ppi, TREE_IMAGPART (e));\n+\t  pp_expression (pp, TREE_REALPART (e));\n+\t  pp_separate_with (pp, ',');\n+\t  pp_expression (pp, TREE_IMAGPART (e));\n \t}\n       else if (code == VECTOR_CST)\n-\tpp_c_expression_list (ppi, TREE_VECTOR_CST_ELTS (e));\n+\tpp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n       else if (code == COMPLEX_EXPR)\n \t{\n-\t  pp_c_expression (ppi, TREE_OPERAND (e, 0));\n-\t  pp_separate_with (ppi, ',');\n-\t  pp_c_expression (ppi, TREE_OPERAND (e, 1));\n+\t  pp_expression (pp, TREE_OPERAND (e, 0));\n+\t  pp_separate_with (pp, ',');\n+\t  pp_expression (pp, TREE_OPERAND (e, 1));\n \t}\n \n-      pp_c_right_brace (ppi);\n+      pp_c_right_brace (pp);\n       break;\n \n     case COMPOUND_LITERAL_EXPR:\n       e = DECL_INITIAL (e);\n       /* Fall through.  */\n     case CONSTRUCTOR:\n-      pp_initializer (ppi, e);\n+      pp_initializer (pp, e);\n       break;\n \n     case VA_ARG_EXPR:\n-      pp_c_identifier (ppi, \"__builtin_va_arg\");\n-      pp_c_left_paren (ppi);\n-      pp_assignment_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_separate_with (ppi, ',');\n-      pp_type_id (ppi, TREE_TYPE (e));\n-      pp_c_right_paren (ppi);\n+      pp_c_identifier (pp, \"__builtin_va_arg\");\n+      pp_c_left_paren (pp);\n+      pp_assignment_expression (pp, TREE_OPERAND (e, 0));\n+      pp_separate_with (pp, ',');\n+      pp_type_id (pp, TREE_TYPE (e));\n+      pp_c_right_paren (pp);\n       break;\n \n     case ADDR_EXPR:\n       if (TREE_CODE (TREE_OPERAND (e, 0)) == FUNCTION_DECL)\n         {\n-          pp_c_id_expression (ppi, TREE_OPERAND (e, 0));\n+          pp_c_id_expression (pp, TREE_OPERAND (e, 0));\n           break;\n         }\n       /* else fall through.  */\n \n     default:\n-      pp_primary_expression (ppi, e);\n+      pp_primary_expression (pp, e);\n       break;\n     }\n }\n \n /* Print out an expression-list; E is expected to be a TREE_LIST  */\n void\n-pp_c_expression_list (c_pretty_printer ppi, tree e)\n+pp_c_expression_list (c_pretty_printer *pp, tree e)\n {\n   for (; e != NULL_TREE; e = TREE_CHAIN (e))\n     {\n-      pp_c_assignment_expression (ppi, TREE_VALUE (e));\n+      pp_expression (pp, TREE_VALUE (e));\n       if (TREE_CHAIN (e))\n-\tpp_separate_with (ppi, ',');\n+\tpp_separate_with (pp, ',');\n     }\n }\n \n+/* Print out an expression-list in parens, as in a function call.   */\n+void\n+pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n+{\n+  pp_c_left_paren (pp);\n+  if (t && TREE_CODE (t) == TREE_LIST)\n+    pp_c_expression_list (pp, t);\n+  pp_c_right_paren (pp);\n+}\n+\n /* unary-expression:\n       postfix-expression\n       ++ cast-expression\n@@ -1180,15 +1202,15 @@ pp_c_expression_list (c_pretty_printer ppi, tree e)\n       __real__ unary-expression\n       __imag__ unary-expression  */\n void\n-pp_c_unary_expression (c_pretty_printer ppi, tree e)\n+pp_c_unary_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case PREINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n-      pp_identifier (ppi, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n-      pp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_identifier (pp, code == PREINCREMENT_EXPR ? \"++\" : \"--\");\n+      pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     case ADDR_EXPR:\n@@ -1199,137 +1221,153 @@ pp_c_unary_expression (c_pretty_printer ppi, tree e)\n     case CONJ_EXPR:\n       /* String literal are used by address.  */\n       if (code == ADDR_EXPR && TREE_CODE (TREE_OPERAND (e, 0)) != STRING_CST)\n-\tpp_ampersand (ppi);\n+\tpp_ampersand (pp);\n       else if (code == INDIRECT_REF)\n-\tpp_c_star (ppi);\n+\tpp_c_star (pp);\n       else if (code == NEGATE_EXPR)\n-\tpp_minus (ppi);\n+\tpp_minus (pp);\n       else if (code == BIT_NOT_EXPR || code == CONJ_EXPR)\n-\tpp_complement (ppi);\n+\tpp_complement (pp);\n       else if (code == TRUTH_NOT_EXPR)\n-\tpp_exclamation (ppi);\n-      pp_c_cast_expression (ppi, TREE_OPERAND (e, 0));\n+\tpp_exclamation (pp);\n+      pp_c_cast_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n-      pp_c_identifier (ppi, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n-      pp_c_whitespace (ppi);\n+      pp_c_identifier (pp, code == SIZEOF_EXPR ? \"sizeof\" : \"__alignof__\");\n+      pp_c_whitespace (pp);\n       if (TYPE_P (TREE_OPERAND (e, 0)))\n-\t{\n-\t  pp_c_left_paren (ppi);\n-\t  pp_type_id (ppi, TREE_OPERAND (e, 0));\n-\t  pp_c_right_paren (ppi);\n-\t}\n+        pp_c_type_cast (pp, TREE_OPERAND (e, 0));\n       else\n-\tpp_unary_expression (ppi, TREE_OPERAND (e, 0));\n+\tpp_unary_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_c_identifier (ppi, code == REALPART_EXPR ? \"__real__\" : \"__imag__\");\n-      pp_c_whitespace (ppi);\n-      pp_unary_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_identifier (pp, code == REALPART_EXPR ? \"__real__\" : \"__imag__\");\n+      pp_c_whitespace (pp);\n+      pp_unary_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     default:\n-      pp_postfix_expression (ppi, e);\n+      pp_postfix_expression (pp, e);\n       break;\n     }\n }\n \n+/* cast-expression:\n+      unary-expression\n+      ( type-name ) cast-expression  */\n void\n-pp_c_cast_expression (c_pretty_printer ppi, tree e)\n+pp_c_cast_expression (c_pretty_printer *pp, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case FLOAT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case CONVERT_EXPR:\n-      pp_c_left_paren (ppi);\n-      pp_type_id (ppi, TREE_TYPE (e));\n-      pp_c_right_paren (ppi);\n-      pp_c_cast_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_c_type_cast (pp, TREE_TYPE (e));\n+      pp_c_cast_expression (pp, TREE_OPERAND (e, 0));\n       break;\n \n     default:\n-      pp_unary_expression (ppi, e);\n+      pp_unary_expression (pp, e);\n     }\n }\n \n+/* multiplicative-expression:\n+      cast-expression\n+      multiplicative-expression * cast-expression\n+      multiplicative-expression / cast-expression\n+      multiplicative-expression % cast-expression   */\n static void\n-pp_c_multiplicative_expression (c_pretty_printer ppi, tree e)\n+pp_c_multiplicative_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case MULT_EXPR:\n     case TRUNC_DIV_EXPR:\n     case TRUNC_MOD_EXPR:\n-      pp_multiplicative_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n+      pp_multiplicative_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n       if (code == MULT_EXPR)\n-\tpp_c_star (ppi);\n+\tpp_c_star (pp);\n       else if (code == TRUNC_DIV_EXPR)\n-\tpp_slash (ppi);\n+\tpp_slash (pp);\n       else\n-\tpp_modulo (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_cast_expression (ppi, TREE_OPERAND (e, 1));\n+\tpp_modulo (pp);\n+      pp_c_whitespace (pp);\n+      pp_c_cast_expression (pp, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n-      pp_c_cast_expression (ppi, e);\n+      pp_c_cast_expression (pp, e);\n       break;\n     }\n }\n \n+/* additive-expression:\n+      multiplicative-expression\n+      additive-expression + multiplicative-expression\n+      additive-expression - multiplicative-expression   */\n static inline void\n-pp_c_additive_expression (c_pretty_printer ppi, tree e)\n+pp_c_additive_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      pp_c_additive_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n+      pp_c_additive_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n       if (code == PLUS_EXPR)\n-\tpp_plus (ppi);\n+\tpp_plus (pp);\n       else\n-\tpp_minus (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_multiplicative_expression (ppi, TREE_OPERAND (e, 1)); \n+\tpp_minus (pp);\n+      pp_c_whitespace (pp);\n+      pp_multiplicative_expression (pp, TREE_OPERAND (e, 1)); \n       break;\n \n     default:\n-      pp_multiplicative_expression (ppi, e);\n+      pp_multiplicative_expression (pp, e);\n       break;\n     }\n }\n \n+/* additive-expression:\n+      additive-expression\n+      shift-expression << additive-expression\n+      shift-expression >> additive-expression   */\n static inline void\n-pp_c_shift_expression (c_pretty_printer ppi, tree e)\n+pp_c_shift_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n-      pp_c_shift_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_identifier (ppi, code == LSHIFT_EXPR ? \"<<\" : \">>\");\n-      pp_c_whitespace (ppi);\n-      pp_c_additive_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_shift_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_identifier (pp, code == LSHIFT_EXPR ? \"<<\" : \">>\");\n+      pp_c_whitespace (pp);\n+      pp_c_additive_expression (pp, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n-      pp_c_additive_expression (ppi, e);\n+      pp_c_additive_expression (pp, e);\n     }\n }\n \n+/* relational-expression:\n+      shift-expression\n+      relational-expression < shift-expression\n+      relational-expression > shift-expression\n+      relational-expression <= shift-expression\n+      relational-expression >= shift-expression   */\n static void\n-pp_c_relational_expression (c_pretty_printer ppi, tree e)\n+pp_c_relational_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n@@ -1338,176 +1376,212 @@ pp_c_relational_expression (c_pretty_printer ppi, tree e)\n     case GT_EXPR:\n     case LE_EXPR:\n     case GE_EXPR:\n-      pp_c_relational_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n+      pp_c_relational_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n       if (code == LT_EXPR)\n-\tpp_less (ppi);\n+\tpp_less (pp);\n       else if (code == GT_EXPR)\n-\tpp_greater (ppi);\n+\tpp_greater (pp);\n       else if (code == LE_EXPR)\n-\tpp_identifier (ppi, \"<=\");\n+\tpp_identifier (pp, \"<=\");\n       else if (code == GE_EXPR)\n-\tpp_identifier (ppi, \">=\");\n-      pp_c_whitespace (ppi);\n-      pp_c_shift_expression (ppi, TREE_OPERAND (e, 1));\n+\tpp_identifier (pp, \">=\");\n+      pp_c_whitespace (pp);\n+      pp_c_shift_expression (pp, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n-      pp_c_shift_expression (ppi, e);\n+      pp_c_shift_expression (pp, e);\n       break;\n     }\n }\n \n+/* equality-expression:\n+      relational-expression\n+      equality-expression == relational-expression\n+      equality-equality != relational-expression  */\n static inline void\n-pp_c_equality_expression (c_pretty_printer ppi, tree e)\n+pp_c_equality_expression (c_pretty_printer *pp, tree e)\n {\n   enum tree_code code = TREE_CODE (e);\n   switch (code)\n     {\n     case EQ_EXPR:\n     case NE_EXPR:\n-      pp_c_equality_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_identifier (ppi, code == EQ_EXPR ? \"==\" : \"!=\");\n-      pp_c_whitespace (ppi);\n-      pp_c_relational_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_equality_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_identifier (pp, code == EQ_EXPR ? \"==\" : \"!=\");\n+      pp_c_whitespace (pp);\n+      pp_c_relational_expression (pp, TREE_OPERAND (e, 1));\n       break;\n \n     default:\n-      pp_c_relational_expression (ppi, e);\n+      pp_c_relational_expression (pp, e);\n       break;\n     }\n }\n \n+/* AND-expression:\n+      equality-expression\n+      AND-expression & equality-equality   */\n static inline void\n-pp_c_and_expression (c_pretty_printer ppi, tree e)\n+pp_c_and_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == BIT_AND_EXPR)\n     {\n-      pp_c_and_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_ampersand (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_equality_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_and_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_ampersand (pp);\n+      pp_c_whitespace (pp);\n+      pp_c_equality_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_equality_expression (ppi, e);\n+    pp_c_equality_expression (pp, e);\n }\n \n+/* exclusive-OR-expression:\n+     AND-expression\n+     exclusive-OR-expression ^ AND-expression  */\n static inline void\n-pp_c_exclusive_or_expression (c_pretty_printer ppi, tree e)\n+pp_c_exclusive_or_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == BIT_XOR_EXPR)\n     {\n-      pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n-      pp_carret (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_and_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_exclusive_or_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_maybe_whitespace (pp);\n+      pp_carret (pp);\n+      pp_c_whitespace (pp);\n+      pp_c_and_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_and_expression (ppi, e);\n+    pp_c_and_expression (pp, e);\n }\n \n+/* inclusive-OR-expression:\n+     exclusive-OR-expression\n+     inclusive-OR-expression | exclusive-OR-expression  */\n static inline void\n-pp_c_inclusive_or_expression (c_pretty_printer ppi, tree e)\n+pp_c_inclusive_or_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == BIT_IOR_EXPR)\n     {\n-      pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_bar (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_exclusive_or_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_exclusive_or_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_bar (pp);\n+      pp_c_whitespace (pp);\n+      pp_c_exclusive_or_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_exclusive_or_expression (ppi, e);\n+    pp_c_exclusive_or_expression (pp, e);\n }\n \n+/* logical-AND-expression:\n+      inclusive-OR-expression\n+      logical-AND-expression && inclusive-OR-expression  */\n static inline void\n-pp_c_logical_and_expression (c_pretty_printer ppi, tree e)\n+pp_c_logical_and_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == TRUTH_ANDIF_EXPR)\n     {\n-      pp_c_logical_and_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_identifier (ppi, \"&&\");\n-      pp_c_whitespace (ppi);\n-      pp_c_inclusive_or_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_logical_and_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_identifier (pp, \"&&\");\n+      pp_c_whitespace (pp);\n+      pp_c_inclusive_or_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_inclusive_or_expression (ppi, e);\n+    pp_c_inclusive_or_expression (pp, e);\n }\n \n+/* logical-OR-expression:\n+      logical-AND-expression\n+      logical-OR-expression || logical-AND-expression  */\n void\n-pp_c_logical_or_expression (c_pretty_printer ppi, tree e)\n+pp_c_logical_or_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == TRUTH_ORIF_EXPR)\n     {\n-      pp_c_logical_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_identifier (ppi, \"||\");\n-      pp_c_whitespace (ppi);\n-      pp_c_logical_and_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_identifier (pp, \"||\");\n+      pp_c_whitespace (pp);\n+      pp_c_logical_and_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_logical_and_expression (ppi, e);\n+    pp_c_logical_and_expression (pp, e);\n }\n \n+/* conditional-expression:\n+      logical-OR-expression\n+      logical-OR-expression ? expression : conditional-expression  */\n static void\n-pp_c_conditional_expression (c_pretty_printer ppi, tree e)\n+pp_c_conditional_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == COND_EXPR)\n     {\n-      pp_c_logical_or_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_whitespace (ppi);\n-      pp_question (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_expression (ppi, TREE_OPERAND (e, 1));\n-      pp_c_maybe_whitespace (ppi);\n-      pp_colon (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_conditional_expression (ppi, TREE_OPERAND (e, 2));\n+      pp_c_logical_or_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_question (pp);\n+      pp_c_whitespace (pp);\n+      pp_expression (pp, TREE_OPERAND (e, 1));\n+      pp_c_whitespace (pp);\n+      pp_colon (pp);\n+      pp_c_whitespace (pp);\n+      pp_c_conditional_expression (pp, TREE_OPERAND (e, 2));\n     }\n   else\n-    pp_c_logical_or_expression (ppi, e);\n+    pp_c_logical_or_expression (pp, e);\n }\n \n \n-/* Pretty-print a C assignment-expression.  */\n+/* assignment-expression:\n+      conditional-expression\n+      unary-expression assignment-operator  assignment-expression \n+\n+   assignment-expression: one of\n+      =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n static void\n-pp_c_assignment_expression (c_pretty_printer ppi, tree e)\n+pp_c_assignment_expression (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == MODIFY_EXPR || TREE_CODE (e) == INIT_EXPR)\n     {\n-      pp_c_unary_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_c_maybe_whitespace (ppi);\n-      pp_equal (ppi);\n-      pp_space (ppi);\n-      pp_c_assignment_expression (ppi, TREE_OPERAND (e, 1));\n+      pp_c_unary_expression (pp, TREE_OPERAND (e, 0));\n+      pp_c_whitespace (pp);\n+      pp_equal (pp);\n+      pp_space (pp);\n+      pp_c_expression (pp, TREE_OPERAND (e, 1));\n     }\n   else\n-    pp_c_conditional_expression (ppi, e);\n+    pp_c_conditional_expression (pp, e);\n }\n \n-/* Pretty-print an expression.  */\n+/* expression:\n+       assignment-expression\n+       expression , assignment-expression\n+\n+  Implementation note:  instead of going through the usual recursion\n+  chain, I take the liberty of dispatching nodes to the appropriate\n+  functions.  This makes some redundancy, but it worths it. That also\n+  prevents a possible infinite recursion between pp_c_primary_expression ()\n+  and pp_c_expression ().  */\n void\n-pp_c_expression (c_pretty_printer ppi, tree e)\n+pp_c_expression (c_pretty_printer *pp, tree e)\n {\n   switch (TREE_CODE (e))\n     {\n     case INTEGER_CST:\n-      pp_c_integer_constant (ppi, e);\n+      pp_c_integer_constant (pp, e);\n       break;\n \n     case REAL_CST:\n-      pp_c_floating_constant (ppi, e);\n+      pp_c_floating_constant (pp, e);\n       break;\n \n     case STRING_CST:\n-      pp_c_string_literal (ppi, e);\n+      pp_c_string_literal (pp, e);\n       break;\n \n+    case IDENTIFIER_NODE:\n     case FUNCTION_DECL:\n     case VAR_DECL:\n     case CONST_DECL:\n@@ -1516,9 +1590,8 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n     case FIELD_DECL:\n     case LABEL_DECL:\n     case ERROR_MARK:\n-    case TARGET_EXPR:\n     case STMT_EXPR:\n-      pp_primary_expression (ppi, e);\n+      pp_primary_expression (pp, e);\n       break;\n \n     case POSTINCREMENT_EXPR:\n@@ -1535,7 +1608,7 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n     case COMPOUND_LITERAL_EXPR:\n     case COMPLEX_EXPR:\n     case VA_ARG_EXPR:\n-      pp_postfix_expression (ppi, e);\n+      pp_postfix_expression (pp, e);\n       break;\n \n     case CONJ_EXPR:\n@@ -1550,98 +1623,110 @@ pp_c_expression (c_pretty_printer ppi, tree e)\n     case ALIGNOF_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      pp_c_unary_expression (ppi, e);\n+      pp_c_unary_expression (pp, e);\n       break;\n \n     case FLOAT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case CONVERT_EXPR:\n-      pp_c_cast_expression (ppi, e);\n+      pp_c_cast_expression (pp, e);\n       break;\n \n     case MULT_EXPR:\n     case TRUNC_MOD_EXPR:\n     case TRUNC_DIV_EXPR:\n-      pp_multiplicative_expression (ppi, e);\n+      pp_multiplicative_expression (pp, e);\n       break;\n \n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n-      pp_c_shift_expression (ppi, e);\n+      pp_c_shift_expression (pp, e);\n       break;\n \n     case LT_EXPR:\n     case GT_EXPR:\n     case LE_EXPR:\n     case GE_EXPR:\n-      pp_c_relational_expression (ppi, e);\n+      pp_c_relational_expression (pp, e);\n       break;\n \n     case BIT_AND_EXPR:\n-      pp_c_and_expression (ppi, e);\n+      pp_c_and_expression (pp, e);\n       break;\n \n     case BIT_XOR_EXPR:\n-      pp_c_exclusive_or_expression (ppi, e);\n+      pp_c_exclusive_or_expression (pp, e);\n       break;\n \n     case BIT_IOR_EXPR:\n-      pp_c_inclusive_or_expression (ppi, e);\n+      pp_c_inclusive_or_expression (pp, e);\n       break;\n \n     case TRUTH_ANDIF_EXPR:\n-      pp_c_logical_and_expression (ppi, e);\n+      pp_c_logical_and_expression (pp, e);\n       break;\n \n     case TRUTH_ORIF_EXPR:\n-      pp_c_logical_or_expression (ppi, e);\n+      pp_c_logical_or_expression (pp, e);\n       break;\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      pp_c_equality_expression (ppi, e);\n+      pp_c_equality_expression (pp, e);\n       break;\n       \n     case COND_EXPR:\n-      pp_conditional_expression (ppi, e);\n+      pp_conditional_expression (pp, e);\n       break;\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n-      pp_c_additive_expression (ppi, e);\n+      pp_c_additive_expression (pp, e);\n       break;\n \n     case MODIFY_EXPR:\n     case INIT_EXPR:\n-      pp_assignment_expression (ppi, e);\n+      pp_assignment_expression (pp, e);\n       break;\n \n     case COMPOUND_EXPR:\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n-      pp_separate_with (ppi, ',');\n-      pp_assignment_expression (ppi, TREE_OPERAND (e, 1));\n-      pp_c_right_paren (ppi);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, TREE_OPERAND (e, 0));\n+      pp_separate_with (pp, ',');\n+      pp_assignment_expression (pp, TREE_OPERAND (e, 1));\n+      pp_c_right_paren (pp);\n       break;\n \n     case NOP_EXPR:\n     case NON_LVALUE_EXPR:\n     case SAVE_EXPR:\n     case UNSAVE_EXPR:\n-      pp_c_expression (ppi, TREE_OPERAND (e, 0));\n+      pp_expression (pp, TREE_OPERAND (e, 0));\n+      break;\n+\n+    case TARGET_EXPR:\n+      pp_postfix_expression (pp, TREE_OPERAND (e, 1));\n       break;\n       \n     default:\n-      pp_unsupported_tree (ppi, e);\n+      pp_unsupported_tree (pp, e);\n       break;\n     }\n }\n \n \n \f\n /* Statements.  */\n+\n+/* statement:\n+      labeled-statement\n+      coumpound-statement\n+      expression-statement\n+      selection-statement\n+      iteration-statement\n+      jump-statement   */\n void\n-pp_c_statement (c_pretty_printer ppi, tree stmt)\n+pp_c_statement (c_pretty_printer *pp, tree stmt)\n {\n   enum tree_code code;\n \n@@ -1651,164 +1736,193 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n   code = TREE_CODE (stmt);\n   switch (code)\n     {\n+       /* labeled-statement:\n+             identifier : statement\n+             case constant-expression : statement\n+             default : statement   */\n     case LABEL_STMT:\n     case CASE_LABEL:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, -3);\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, -3);\n       else\n-        pp_indentation (ppi) -= 3;\n+        pp_indentation (pp) -= 3;\n       if (code == LABEL_STMT)\n-\tpp_tree_identifier (ppi, DECL_NAME (LABEL_STMT_LABEL (stmt)));\n+\tpp_tree_identifier (pp, DECL_NAME (LABEL_STMT_LABEL (stmt)));\n       else if (code == CASE_LABEL)\n \t{\n \t  if (CASE_LOW (stmt) == NULL_TREE)\n-\t    pp_identifier (ppi, \"default\");\n+\t    pp_identifier (pp, \"default\");\n \t  else\n \t    {\n-\t      pp_c_identifier (ppi, \"case\");\n-\t      pp_c_whitespace (ppi);\n-\t      pp_conditional_expression (ppi, CASE_LOW (stmt));\n+\t      pp_c_identifier (pp, \"case\");\n+\t      pp_c_whitespace (pp);\n+\t      pp_conditional_expression (pp, CASE_LOW (stmt));\n \t      if (CASE_HIGH (stmt))\n \t\t{\n-\t\t  pp_identifier (ppi, \"...\");\n-\t\t  pp_conditional_expression (ppi, CASE_HIGH (stmt));\n+\t\t  pp_identifier (pp, \"...\");\n+\t\t  pp_conditional_expression (pp, CASE_HIGH (stmt));\n \t\t}\n \t    }\n \t}\n-      pp_colon (ppi);\n-      pp_indentation (ppi) += 3;\n-      pp_needs_newline (ppi) = true;\n+      pp_colon (pp);\n+      pp_indentation (pp) += 3;\n+      pp_needs_newline (pp) = true;\n       break;\n \n+      /* coumpound-statement:\n+            {  block-item-list(opt) }\n+\n+         block-item-list:\n+            block-item\n+            block-item-list block-item\n+\n+         block-item:\n+            declaration\n+            statement   */\n     case COMPOUND_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_c_left_brace (ppi);\n-      pp_newline_and_indent (ppi, 3);\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_c_left_brace (pp);\n+      pp_newline_and_indent (pp, 3);\n       for (stmt = COMPOUND_BODY (stmt); stmt; stmt = TREE_CHAIN (stmt))\n-\tpp_c_statement (ppi, stmt);\n-      pp_newline_and_indent (ppi, -3);\n-      pp_c_right_brace (ppi);\n-      pp_needs_newline (ppi) = true;\n+\tpp_statement (pp, stmt);\n+      pp_newline_and_indent (pp, -3);\n+      pp_c_right_brace (pp);\n+      pp_needs_newline (pp) = true;\n       break;\n \n+      /* expression-statement:\n+            expression(opt) ;  */\n     case EXPR_STMT:\n     case CLEANUP_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n       {\n         tree e = code == EXPR_STMT\n           ? EXPR_STMT_EXPR (stmt)\n           : CLEANUP_EXPR (stmt);\n         if (e)\n-          pp_c_expression (ppi, e);\n+          pp_expression (pp, e);\n       }\n-      pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = true;\n+      pp_c_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n       break;\n \n+      /* selection-statement:\n+            if ( expression ) statement\n+            if ( expression ) statement else statement\n+            switch ( expression ) statement   */\n     case IF_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_c_identifier (ppi, \"if\");\n-      pp_c_whitespace (ppi);\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, IF_COND (stmt));\n-      pp_c_right_paren (ppi);\n-      pp_newline_and_indent (ppi, 3);\n-      pp_statement (ppi, THEN_CLAUSE (stmt));\n-      pp_newline_and_indent (ppi, -3);\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_c_identifier (pp, \"if\");\n+      pp_c_whitespace (pp);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, IF_COND (stmt));\n+      pp_c_right_paren (pp);\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, THEN_CLAUSE (stmt));\n+      pp_newline_and_indent (pp, -3);\n       if (ELSE_CLAUSE (stmt))\n \t{\n \t  tree else_clause = ELSE_CLAUSE (stmt);\n-\t  pp_c_identifier (ppi, \"else\");\n+\t  pp_c_identifier (pp, \"else\");\n \t  if (TREE_CODE (else_clause) == IF_STMT)\n-\t    pp_c_whitespace (ppi);\n+\t    pp_c_whitespace (pp);\n \t  else\n-\t    pp_newline_and_indent (ppi, 3);\n-\t  pp_statement (ppi, else_clause);\n+\t    pp_newline_and_indent (pp, 3);\n+\t  pp_statement (pp, else_clause);\n \t  if (TREE_CODE (else_clause) != IF_STMT)\n-\t    pp_newline_and_indent (ppi, -3);\n+\t    pp_newline_and_indent (pp, -3);\n \t}\n       break;\n \n     case SWITCH_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_c_identifier (ppi, \"switch\");\n-      pp_space (ppi);\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, SWITCH_COND (stmt));\n-      pp_c_right_paren (ppi);\n-      pp_indentation (ppi) += 3;\n-      pp_needs_newline (ppi) = true;\n-      pp_statement (ppi, SWITCH_BODY (stmt));\n-      pp_newline_and_indent (ppi, -3);\n-      break;\n-\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_c_identifier (pp, \"switch\");\n+      pp_space (pp);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, SWITCH_COND (stmt));\n+      pp_c_right_paren (pp);\n+      pp_indentation (pp) += 3;\n+      pp_needs_newline (pp) = true;\n+      pp_statement (pp, SWITCH_BODY (stmt));\n+      pp_newline_and_indent (pp, -3);\n+      break;\n+\n+      /* iteration-statement:\n+            while ( expression ) statement\n+            do statement while ( expression ) ;\n+            for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n+            for ( declaration expression(opt) ; expression(opt) ) statement  */\n     case WHILE_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_c_identifier (ppi, \"while\");\n-      pp_space (ppi);\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, WHILE_COND (stmt));\n-      pp_c_right_paren (ppi);\n-      pp_newline_and_indent (ppi, 3);\n-      pp_statement (ppi, WHILE_BODY (stmt));\n-      pp_indentation (ppi) -= 3;\n-      pp_needs_newline (ppi) = true;\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_c_identifier (pp, \"while\");\n+      pp_space (pp);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, WHILE_COND (stmt));\n+      pp_c_right_paren (pp);\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, WHILE_BODY (stmt));\n+      pp_indentation (pp) -= 3;\n+      pp_needs_newline (pp) = true;\n       break;\n \n     case DO_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_c_identifier (ppi, \"do\");\n-      pp_newline_and_indent (ppi, 3);\n-      pp_statement (ppi, DO_BODY (stmt));\n-      pp_newline_and_indent (ppi, -3);\n-      pp_c_identifier (ppi, \"while\");\n-      pp_space (ppi);\n-      pp_c_left_paren (ppi);\n-      pp_c_expression (ppi, DO_COND (stmt));\n-      pp_c_right_paren (ppi);\n-      pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = true;\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_c_identifier (pp, \"do\");\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, DO_BODY (stmt));\n+      pp_newline_and_indent (pp, -3);\n+      pp_c_identifier (pp, \"while\");\n+      pp_space (pp);\n+      pp_c_left_paren (pp);\n+      pp_expression (pp, DO_COND (stmt));\n+      pp_c_right_paren (pp);\n+      pp_c_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n       break;\n \n     case FOR_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_c_identifier (ppi, \"for\");\n-      pp_space (ppi);\n-      pp_c_left_paren (ppi);\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_c_identifier (pp, \"for\");\n+      pp_space (pp);\n+      pp_c_left_paren (pp);\n       if (FOR_INIT_STMT (stmt))\n-        pp_statement (ppi, FOR_INIT_STMT (stmt));\n+        pp_statement (pp, FOR_INIT_STMT (stmt));\n       else\n-        pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = false;\n-      pp_c_whitespace (ppi);\n+        pp_c_semicolon (pp);\n+      pp_needs_newline (pp) = false;\n+      pp_c_whitespace (pp);\n       if (FOR_COND (stmt))\n-\tpp_c_expression (ppi, FOR_COND (stmt));\n-      pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = false;\n-      pp_c_whitespace (ppi);\n+\tpp_expression (pp, FOR_COND (stmt));\n+      pp_c_semicolon (pp);\n+      pp_needs_newline (pp) = false;\n+      pp_c_whitespace (pp);\n       if (FOR_EXPR (stmt))\n-\tpp_c_expression (ppi, FOR_EXPR (stmt));\n-      pp_c_right_paren (ppi);\n-      pp_newline_and_indent (ppi, 3);\n-      pp_statement (ppi, FOR_BODY (stmt));\n-      pp_indentation (ppi) -= 3;\n-      pp_needs_newline (ppi) = true;\n-      break;\n-\n+\tpp_expression (pp, FOR_EXPR (stmt));\n+      pp_c_right_paren (pp);\n+      pp_newline_and_indent (pp, 3);\n+      pp_statement (pp, FOR_BODY (stmt));\n+      pp_indentation (pp) -= 3;\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n+      /* jump-statement:\n+            goto identifier;\n+            continue ;\n+            return expression(opt) ;  */\n     case BREAK_STMT:\n     case CONTINUE_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_identifier (ppi, code == BREAK_STMT ? \"break\" : \"continue\");\n-      pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = true;\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_identifier (pp, code == BREAK_STMT ? \"break\" : \"continue\");\n+      pp_c_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n       break;\n \n     case RETURN_STMT:\n@@ -1817,107 +1931,114 @@ pp_c_statement (c_pretty_printer ppi, tree stmt)\n \ttree e = code == RETURN_STMT\n \t  ? RETURN_STMT_EXPR (stmt)\n \t  : GOTO_DESTINATION (stmt);\n-        if (pp_needs_newline (ppi))\n-          pp_newline_and_indent (ppi, 0);\n-\tpp_c_identifier (ppi, code == RETURN_STMT ? \"return\" : \"goto\");\n+        if (pp_needs_newline (pp))\n+          pp_newline_and_indent (pp, 0);\n+\tpp_c_identifier (pp, code == RETURN_STMT ? \"return\" : \"goto\");\n+        pp_c_whitespace (pp);\n \tif (e)\n-\t  pp_c_expression (ppi, e);\n-\tpp_c_semicolon (ppi);\n-\tpp_needs_newline (ppi) = true;\n+          {\n+            if (TREE_CODE (e) == INIT_EXPR\n+                && TREE_CODE (TREE_OPERAND (e, 0)) == RESULT_DECL)\n+              e = TREE_OPERAND (e, 1);\n+            pp_expression (pp, e);\n+          }\n+\tpp_c_semicolon (pp);\n+\tpp_needs_newline (pp) = true;\n       }\n       break;\n \n     case SCOPE_STMT:\n       if (!SCOPE_NULLIFIED_P (stmt) && SCOPE_NO_CLEANUPS_P (stmt))\n         {\n           int i = 0;\n-          if (pp_needs_newline (ppi))\n-            pp_newline_and_indent (ppi, 0);\n+          if (pp_needs_newline (pp))\n+            pp_newline_and_indent (pp, 0);\n           if (SCOPE_BEGIN_P (stmt))\n             {\n-              pp_left_brace (ppi);\n+              pp_left_brace (pp);\n               i = 3;\n             }\n           else if (SCOPE_END_P (stmt))\n             {\n-              pp_right_brace (ppi);\n+              pp_right_brace (pp);\n               i = -3;\n             }\n-          pp_indentation (ppi) += i;\n-          pp_needs_newline (ppi) = true;\n+          pp_indentation (pp) += i;\n+          pp_needs_newline (pp) = true;\n         }\n       break;\n \n     case DECL_STMT:\n-      if (pp_needs_newline (ppi))\n-        pp_newline_and_indent (ppi, 0);\n-      pp_declaration (ppi, DECL_STMT_DECL (stmt));\n-      pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = true;\n+      if (pp_needs_newline (pp))\n+        pp_newline_and_indent (pp, 0);\n+      pp_declaration (pp, DECL_STMT_DECL (stmt));\n+      pp_needs_newline (pp) = true;\n       break;\n \n     case ASM_STMT:\n       {\n \tbool has_volatile_p = ASM_VOLATILE_P (stmt);\n \tbool is_extended = has_volatile_p || ASM_INPUTS (stmt)\n \t  || ASM_OUTPUTS (stmt) || ASM_CLOBBERS (stmt);\n-\tpp_c_identifier (ppi, is_extended ? \"__asm__\" : \"asm\");\n+\tpp_c_identifier (pp, is_extended ? \"__asm__\" : \"asm\");\n \tif (has_volatile_p)\n-\t  pp_c_identifier (ppi, \"__volatile__\");\n-\tpp_space (ppi);\n-\tpp_c_left_paren (ppi);\n-\tpp_c_string_literal (ppi, ASM_STRING (stmt));\n+\t  pp_c_identifier (pp, \"__volatile__\");\n+\tpp_space (pp);\n+\tpp_c_left_paren (pp);\n+\tpp_c_string_literal (pp, ASM_STRING (stmt));\n \tif (is_extended)\n \t  {\n-\t    pp_space (ppi);\n-\t    pp_separate_with (ppi, ':');\n+\t    pp_space (pp);\n+\t    pp_separate_with (pp, ':');\n \t    if (ASM_OUTPUTS (stmt))\n-\t      pp_c_expression (ppi, ASM_OUTPUTS (stmt));\n-\t    pp_space (ppi);\n-\t    pp_separate_with (ppi, ':');\n+\t      pp_expression (pp, ASM_OUTPUTS (stmt));\n+\t    pp_space (pp);\n+\t    pp_separate_with (pp, ':');\n \t    if (ASM_INPUTS (stmt))\n-\t      pp_c_expression (ppi, ASM_INPUTS (stmt));\n-\t    pp_space (ppi);\n-\t    pp_separate_with (ppi, ':');\n+\t      pp_expression (pp, ASM_INPUTS (stmt));\n+\t    pp_space (pp);\n+\t    pp_separate_with (pp, ':');\n \t    if (ASM_CLOBBERS (stmt))\n-\t      pp_c_expression (ppi, ASM_CLOBBERS (stmt));\n+\t      pp_expression (pp, ASM_CLOBBERS (stmt));\n \t  }\n-\tpp_c_right_paren (ppi);\n-\tpp_newline (ppi);\n+\tpp_c_right_paren (pp);\n+\tpp_newline (pp);\n       }\n       break;\n \n     case FILE_STMT:\n-      pp_c_identifier (ppi, \"__FILE__\");\n-      pp_space (ppi);\n-      pp_equal (ppi);\n-      pp_c_whitespace (ppi);\n-      pp_c_identifier (ppi, FILE_STMT_FILENAME (stmt));\n-      pp_c_semicolon (ppi);\n-      pp_needs_newline (ppi) = true;\n+      pp_c_identifier (pp, \"__FILE__\");\n+      pp_space (pp);\n+      pp_equal (pp);\n+      pp_c_whitespace (pp);\n+      pp_c_identifier (pp, FILE_STMT_FILENAME (stmt));\n+      pp_c_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n       break;\n \n     default:\n-      pp_unsupported_tree (ppi, stmt);\n+      pp_unsupported_tree (pp, stmt);\n     }\n-\n }\n \n \f\n /* Initialize the PRETTY-PRINTER for handling C codes.  */\n void\n-pp_c_pretty_printer_init (c_pretty_printer pp)\n+pp_c_pretty_printer_init (c_pretty_printer *pp)\n {\n   pp->offset_list               = 0;\n \n   pp->declaration               = pp_c_declaration;\n   pp->declaration_specifiers    = pp_c_declaration_specifiers;\n   pp->declarator                = pp_c_declarator;\n   pp->direct_declarator         = pp_c_direct_declarator;\n-  pp->type_specifier            = pp_c_simple_type_specifier;\n+  pp->type_specifier_seq        = pp_c_specifier_qualifier_list;\n   pp->abstract_declarator       = pp_c_abstract_declarator;\n-  pp->parameter_declaration     = pp_c_parameter_declaration;\n+  pp->direct_abstract_declarator = pp_c_direct_abstract_declarator;\n+  pp->ptr_operator              = pp_c_pointer;\n+  pp->parameter_list            = pp_c_parameter_type_list;\n   pp->type_id                   = pp_c_type_id;\n+  pp->simple_type_specifier     = pp_c_type_specifier;\n   pp->function_specifier        = pp_c_function_specifier;\n   pp->storage_class_specifier   = pp_c_storage_class_specifier;\n \n@@ -1931,4 +2052,5 @@ pp_c_pretty_printer_init (c_pretty_printer pp)\n   pp->multiplicative_expression = pp_c_multiplicative_expression;\n   pp->conditional_expression    = pp_c_conditional_expression;\n   pp->assignment_expression     = pp_c_assignment_expression;\n+  pp->expression                = pp_c_expression;\n }"}, {"sha": "66ca33c7d5e08eb5e9fc73f1b7e38c2dfeb7a740", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 73, "deletions": 33, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -36,14 +36,25 @@ typedef enum\n \n /* The data type used to bundle information necessary for pretty-printing\n    a C or C++ entity.  */\n-typedef struct c_pretty_print_info *c_pretty_printer;\n+typedef struct c_pretty_print_info c_pretty_printer;\n \n /* The type of a C pretty-printer 'member' function.  */\n-typedef void (*c_pretty_print_fn) (c_pretty_printer, tree);\n-\n+typedef void (*c_pretty_print_fn) (c_pretty_printer *, tree);\n+\n+/* The datatype that contains information necessary for pretty-printing\n+   a tree that represents a C construct.  Any pretty-printer for a\n+   language using C/c++ syntax can derive from this datatype and reuse\n+   facilities provided here.  It can do so by having a subobject of type\n+   c_pretty_printer and override the macro pp_c_base to return a pointer\n+   to that subobject.  Such a pretty-printer has the responsability to\n+   initialize the pp_base() part, then call pp_c_pretty_printer_init\n+   to set up the components that are specific to the C pretty-printer.\n+   A derived pretty-printer can override any function listed in the\n+   vtable below.  See cp/cxx-pretty-print.h and cp/cxx-pretty-print.c\n+   for an example of derivation.  */\n struct c_pretty_print_info\n {\n-  struct pretty_print_info base;\n+  pretty_printer base;\n   /* Points to the first element of an array of offset-list.\n      Not used yet.  */\n   int *offset_list;\n@@ -56,25 +67,31 @@ struct c_pretty_print_info\n   c_pretty_print_fn declaration_specifiers;\n   c_pretty_print_fn declarator;\n   c_pretty_print_fn abstract_declarator;\n-  c_pretty_print_fn type_specifier;\n+  c_pretty_print_fn direct_abstract_declarator;\n+  c_pretty_print_fn type_specifier_seq;\n   c_pretty_print_fn direct_declarator;\n-  c_pretty_print_fn parameter_declaration;\n+  c_pretty_print_fn ptr_operator;\n+  c_pretty_print_fn parameter_list;\n   c_pretty_print_fn type_id;\n+  c_pretty_print_fn simple_type_specifier;\n   c_pretty_print_fn function_specifier;\n   c_pretty_print_fn storage_class_specifier;\n+  c_pretty_print_fn initializer;\n \n   c_pretty_print_fn statement;\n \n   c_pretty_print_fn id_expression;\n   c_pretty_print_fn primary_expression;\n   c_pretty_print_fn postfix_expression;\n   c_pretty_print_fn unary_expression;\n-  c_pretty_print_fn initializer;\n   c_pretty_print_fn multiplicative_expression;\n   c_pretty_print_fn conditional_expression;\n   c_pretty_print_fn assignment_expression;\n+  c_pretty_print_fn expression;\n };\n \n+/* Override the pp_base macro.  Derived pretty-printers should not\n+   touch this macro.  Instead they should override pp_c_base instead.  */\n #undef pp_base\n #define pp_base(PP)  (&pp_c_base (PP)->base)\n \n@@ -88,16 +105,22 @@ struct c_pretty_print_info\n    pp_c_base (PPI)->declaration_specifiers (pp_c_base (PPI), D)\n #define pp_abstract_declarator(PP, D)             \\\n    pp_c_base (PP)->abstract_declarator (pp_c_base (PP), D)\n-#define pp_type_specifier(PPI, D)                 \\\n-   pp_c_base (PPI)->type_specifier (pp_c_base (PPI), D)\n+#define pp_type_specifier_seq(PPI, D)             \\\n+   pp_c_base (PPI)->type_specifie_seqr (pp_c_base (PPI), D)\n #define pp_declarator(PPI, D)                     \\\n    pp_c_base (PPI)->declarator (pp_c_base (PPI), D)\n #define pp_direct_declarator(PPI, D)              \\\n    pp_c_base (PPI)->direct_declarator (pp_c_base (PPI), D)\n-#define pp_parameter_declaration(PPI, T)          \\\n-  pp_c_base (PPI)->parameter_declaration (pp_c_base (PPI), T)\n+#define pp_direct_abstract_declarator(PP, D)      \\\n+   pp_c_base (PP)->direct_abstract_declarator (pp_c_base (PP), D)\n+#define pp_ptr_operator(PP, D)                    \\\n+   pp_c_base (PP)->ptr_operator (pp_c_base (PP), D)\n+#define pp_parameter_list(PPI, T)                 \\\n+  pp_c_base (PPI)->parameter_list (pp_c_base (PPI), T)\n #define pp_type_id(PPI, D)                        \\\n   pp_c_base (PPI)->type_id (pp_c_base (PPI), D)\n+#define pp_simple_type_specifier(PP, T)           \\\n+  pp_c_base (PP)->simple_type_specifier (pp_c_base (PP), T)\n #define pp_function_specifier(PP, D)              \\\n   pp_c_base (PP)->function_specifier (pp_c_base (PP), D)\n #define pp_storage_class_specifier(PP, D)         \\\n@@ -122,37 +145,54 @@ struct c_pretty_print_info\n   pp_c_base (PPI)->conditional_expression (pp_c_base (PPI), E)\n #define pp_assignment_expression(PPI, E)          \\\n    pp_c_base (PPI)->assignment_expression (pp_c_base (PPI), E)\n+#define pp_expression(PP, E)                      \\\n+   pp_c_base (PP)->expression (pp_c_base (PP), E)\n \n \n /* Returns the c_pretty_printer base object of PRETTY-PRINTER.  This\n    macro must be overridden by any subclass of c_pretty_print_info.  */\n #define pp_c_base(PP)  (PP)\n \n-extern void pp_c_pretty_printer_init (c_pretty_printer);\n+extern void pp_c_pretty_printer_init (c_pretty_printer *);\n+void pp_c_whitespace (c_pretty_printer *);\n+void pp_c_left_paren (c_pretty_printer *);\n+void pp_c_right_paren (c_pretty_printer *);\n+void pp_c_dot (c_pretty_printer *);\n+void pp_c_ampersand (c_pretty_printer *);\n+void pp_c_arrow (c_pretty_printer *);\n+void pp_c_semicolon (c_pretty_printer *);\n+void pp_c_space_for_pointer_operator (c_pretty_printer *, tree);\n \n /* Declarations.  */\n-void pp_c_function_definition (c_pretty_printer, tree);\n-void pp_c_attributes (c_pretty_printer, tree);\n-void pp_c_type_qualifier_list (c_pretty_printer, tree);\n-void pp_c_parameter_declaration_clause (c_pretty_printer, tree);\n-void pp_c_declaration (c_pretty_printer, tree);\n-void pp_c_declarator (c_pretty_printer, tree);\n-void pp_c_direct_declarator (c_pretty_printer, tree);\n-void pp_c_specifier_qualifier_list (c_pretty_printer, tree);\n-void pp_c_type_id (c_pretty_printer, tree);\n+void pp_c_function_definition (c_pretty_printer *, tree);\n+void pp_c_attributes (c_pretty_printer *, tree);\n+void pp_c_type_qualifier_list (c_pretty_printer *, tree);\n+void pp_c_parameter_type_list (c_pretty_printer *, tree);\n+void pp_c_declaration (c_pretty_printer *, tree);\n+void pp_c_declaration_specifiers (c_pretty_printer *, tree);\n+void pp_c_declarator (c_pretty_printer *, tree);\n+void pp_c_direct_declarator (c_pretty_printer *, tree);\n+void pp_c_specifier_qualifier_list (c_pretty_printer *, tree);\n+void pp_c_function_specifier (c_pretty_printer *, tree);\n+void pp_c_type_id (c_pretty_printer *, tree);\n+void pp_c_direct_abstract_declarator (c_pretty_printer *, tree);\n+void pp_c_type_specifier (c_pretty_printer *, tree);\n+void pp_c_storage_class_specifier (c_pretty_printer *, tree);\n /* Statements.  */\n-void pp_c_statement (c_pretty_printer, tree);\n+void pp_c_statement (c_pretty_printer *, tree);\n /* Expressions.  */\n-void pp_c_expression (c_pretty_printer, tree);\n-void pp_c_logical_or_expression (c_pretty_printer, tree);\n-void pp_c_expression_list (c_pretty_printer, tree);\n-void pp_c_unary_expression (c_pretty_printer, tree);\n-void pp_c_cast_expression (c_pretty_printer, tree);\n-void pp_c_postfix_expression (c_pretty_printer, tree);\n-void pp_c_initializer (c_pretty_printer, tree);\n-void pp_c_constant (c_pretty_printer, tree);\n-void pp_c_id_expression (c_pretty_printer, tree);\n-void pp_c_identifier (c_pretty_printer, const char *);\n-void pp_c_string_literal (c_pretty_printer, tree);\n+void pp_c_expression (c_pretty_printer *, tree);\n+void pp_c_logical_or_expression (c_pretty_printer *, tree);\n+void pp_c_expression_list (c_pretty_printer *, tree);\n+void pp_c_call_argument_list (c_pretty_printer *, tree);\n+void pp_c_unary_expression (c_pretty_printer *, tree);\n+void pp_c_cast_expression (c_pretty_printer *, tree);\n+void pp_c_postfix_expression (c_pretty_printer *, tree);\n+void pp_c_primary_expression (c_pretty_printer *, tree);\n+void pp_c_init_declarator (c_pretty_printer *, tree);\n+void pp_c_constant (c_pretty_printer *, tree);\n+void pp_c_id_expression (c_pretty_printer *, tree);\n+void pp_c_identifier (c_pretty_printer *, const char *);\n+void pp_c_string_literal (c_pretty_printer *, tree);\n \n #endif /* GCC_C_PRETTY_PRINTER */"}, {"sha": "d56c7a5753fc783934d3918da90f8bde0600414c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -1,3 +1,66 @@\n+2003-08-25  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* cxx-pretty-print.h (pp_cxx_flag_default_argument): New flag.\n+\t(cxx_pretty_printer): Adjust base type.\n+\t(pp_cxx_function_specifier): Declare.\n+\t* cxx-pretty-print.c (pp_cxx_whitespace): New macro.\n+\t(pp_cxx_left_paren): Likewise.\n+\t(pp_cxx_right_paren): Likewise.\n+\t(pp_cxx_dot): Likewise.\n+\t(pp_cxx_arrow): Likewise.\n+\t(pp_cxx_semicolon): Likewise.\n+\t(pp_cxx_identifier): Likewise.\n+\t(pp_cxx_cv_qualifier_seq): Likewise.\n+\t(pp_cxx_storage_class_specifier): Likewise.\n+\t(pp_cxx_expression_list): Likewise.\n+\t(pp_cxx_space_for_pointer_operator): Likewise.\n+\t(pp_cxx_init_declarator): Likewise.\n+\t(pp_cxx_call_argument_list): Likewise.\n+\t(pp_cxx_nonconsecutive_character): Tidy.\n+\t(pp_cxx_conversion_function_id): New function.\n+\t(pp_cxx_template_id): Likewise.\n+\t(pp_cxx_class_name): Likewise.\n+\t(pp_cxx_template_keyword_if_needed): Likewise.\n+\t(pp_cxx_nested_name_specifier): Likewise.\n+\t(pp_cxx_unqualified_id): Tidy\n+\t(pp_cxx_qualified_id): Handle more nodes.\n+\t(pp_cxx_primary_expression): Tidy.\n+\t(pp_cxx_postfix_expression): Likewise.\n+\t(pp_cxx_new_expression): Tidy.\n+\t(pp_cxx_delete_expression): Likewise.\n+\t(pp_cxx_cast_expression): New function.\n+\t(pp_cxx_pm_expression): Tidy.\n+\t(pp_cxx_conditional_expression): Likewise.\n+\t(pp_cxx_assignment_operator): New function.\n+\t(pp_cxx_assignment_expression): Tidy.\n+\t(pp_cxx_expression): New function.\n+\t(pp_cxx_function_specifier): Likewise.\n+\t(pp_cxx_decl_specifier_seq): Likewise.\n+\t(pp_cxx_simple_type_specifier): Tidy.\n+\t(pp_cxx_type_specifier_seq): Likewise.\n+\t(pp_cxx_ptr_operator): New function.\n+\t(pp_cxx_implicit_parameter_type): Likewise.\n+\t(pp_cxx_parameter_declaration): Tidy.\n+\t(pp_cxx_parameter_declaration_clause): New function.\n+\t(pp_cxx_exception_specification): Likewise.\n+\t(pp_cxx_direct_declarator): Tidy.\n+\t(pp_cxx_declarator): Likewise.\n+\t(pp_cxx_ctor_initializer): New function.\n+\t(pp_cxx_function_definition): Likewise.\n+\t(pp_cxx_abstract_declarator): Tidy.\n+\t(pp_cxx_direct_abstract_declarator): Likewise.\n+\t(pp_cxx_type_id): Likewise.\n+\t(pp_cxx_exception_declaration): New function.\n+\t(pp_cxx_statement): Likewise.\n+\t(pp_cxx_simple_declaration): Likewise.\n+\t(pp_cxx_template_parameter_list): Likewise.\n+\t(pp_cxx_template_parameter): Likewise.\n+\t(pp_cxx_template_declaration): Likewise.\n+\t(pp_cxx_explicit_specialization): Likewise.\n+\t(pp_cxx_explicit_instantiation): Likewise.\n+\t(pp_cxx_declaration): Tidy.\n+\t(pp_cxx_pretty_printer_init): Initialize more fields.\n+\n 2003-08-25  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/8795"}, {"sha": "a8e931c856b548f4bf5e47832b72ee0cf2bf6380", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 1202, "deletions": 222, "changes": 1424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -26,186 +26,107 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"cxx-pretty-print.h\"\n #include \"cp-tree.h\"\n+#include \"toplev.h\"\n \n static void pp_cxx_unqualified_id (cxx_pretty_printer *, tree);\n+static void pp_cxx_nested_name_specifier (cxx_pretty_printer *, tree);\n static void pp_cxx_qualified_id (cxx_pretty_printer *, tree);\n static void pp_cxx_assignment_expression (cxx_pretty_printer *, tree);\n+static void pp_cxx_expression (cxx_pretty_printer *, tree);\n static void pp_cxx_template_argument_list (cxx_pretty_printer *, tree);\n+static void pp_cxx_type_specifier_seq (cxx_pretty_printer *, tree);\n+static void pp_cxx_ptr_operator (cxx_pretty_printer *, tree);\n+static void pp_cxx_type_id (cxx_pretty_printer *, tree);\n+static void pp_cxx_direct_abstract_declarator (cxx_pretty_printer *, tree);\n+static void pp_cxx_declarator (cxx_pretty_printer *, tree);\n+static void pp_cxx_abstract_declarator (cxx_pretty_printer *, tree);\n+static void pp_cxx_template_parameter (cxx_pretty_printer *, tree);\n \f\n+#define pp_cxx_whitespace(PP)  pp_c_whitespace (pp_c_base (PP))\n+#define pp_cxx_left_paren(PP)  pp_c_left_paren (pp_c_base (PP))\n+#define pp_cxx_right_paren(PP) pp_c_right_paren (pp_c_base (PP))\n+#define pp_cxx_dot(PP)         pp_c_dot (pp_c_base (PP))\n+#define pp_cxx_arrow(PP)       pp_c_arrow (pp_c_base (PP))\n+#define pp_cxx_semicolon(PP)   pp_c_semicolon (pp_c_base (PP))\n \n static inline void\n pp_cxx_nonconsecutive_character (cxx_pretty_printer *pp, int c)\n {\n   const char *p = pp_last_position_in_text (pp);\n \n   if (p != NULL && *p == c)\n-    pp_space (pp);\n+    pp_cxx_whitespace (pp);\n   pp_character (pp, c);\n+  pp_base (pp)->padding = pp_none;\n }\n \n #define pp_cxx_begin_template_argument_list(PP) \\\n   pp_cxx_nonconsecutive_character (PP, '<')\n #define pp_cxx_end_template_argument_list(PP) \\\n   pp_cxx_nonconsecutive_character (PP, '>')\n \n-/* Declarations.  */\n-\n-void\n-pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_unsupported_tree (pp, t);\n-}\n-\n-static void\n-pp_cxx_declaration_specifiers (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_unsupported_tree (pp, t);\n-}\n-/* type-specifier:\n-      simple-type-specifier\n-      class-specifier\n-      enum-specifier\n-      elaborated-type-specifier\n-      cv-qualifer   */\n+#define pp_cxx_identifier(PP, ID) pp_c_identifier (pp_c_base (PP), ID)\n+#define pp_cxx_tree_identifier(PP, T) pp_c_tree_identifier (pp_c_base (PP), T)\n+\n+#define pp_cxx_cv_qualifier_seq(PP, T)   \\\n+   pp_c_type_qualifier_list (pp_c_base (PP), T)\n+#define pp_cxx_storage_class_specifier(PP, T) \\\n+   pp_c_storage_class_specifier (pp_c_base (PP), T)\n+#define pp_cxx_expression_list(PP, T)    \\\n+   pp_c_expression_list (pp_c_base (PP), T)\n+#define pp_cxx_space_for_pointer_operator(PP, T)  \\\n+   pp_c_space_for_pointer_operator (pp_c_base (PP), T)\n+#define pp_cxx_init_declarator(PP, T)    \\\n+   pp_c_init_declarator (pp_c_base (PP), T)\n+#define pp_cxx_call_argument_list(PP, T) \\\n+   pp_c_call_argument_list (pp_c_base (PP), T)\n \n static void\n-pp_cxx_type_specifier (cxx_pretty_printer *pp, tree t)\n+pp_cxx_colon_colon (cxx_pretty_printer *pp)\n {\n-  pp_c_type_qualifier_list (pp_c_base (pp), t);\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case TEMPLATE_DECL:\n-    case TYPE_DECL:\n-      if (pp->enclosing_scope != DECL_CONTEXT (t))\n-        pp_cxx_qualified_id (pp, t);\n-      else\n-        pp_cxx_unqualified_id (pp, t);\n-      break;\n-\n-    case TYPEOF_TYPE:\n-      pp_c_identifier (pp_c_base (pp), \"__typeof__\");\n-      pp_left_paren (pp);\n-      pp_c_expression (pp_c_base (pp), TYPE_FIELDS (t));\n-      pp_right_paren (pp);\n-      break;\n-\n-    default:\n-      pp_c_specifier_qualifier_list (pp_c_base (pp), t);\n-    }\n+  pp_colon_colon (pp);\n+  pp_base (pp)->padding = pp_none;\n }\n \n-static void\n-pp_cxx_declarator (cxx_pretty_printer *pp, tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    default:\n-      pp_c_declarator (pp_c_base (pp), t);\n-      break;\n-    }\n-}\n \n-static void\n-pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_c_direct_declarator (pp_c_base (pp), t);\n-}\n+/* Expressions. */\n \n-static void\n-pp_cxx_parameter_declaration (cxx_pretty_printer *pp, tree t)\n+static inline bool\n+is_destructor_name (tree name)\n {\n-  pp_unsupported_tree (pp, t);\n+  return name == complete_dtor_identifier\n+    || name == base_dtor_identifier\n+    || name == deleting_dtor_identifier;\n }\n \n+/* conversion-function-id:\n+      operator conversion-type-id\n \n+   conversion-type-id:\n+      type-specifier-seq conversion-declarator(opt)\n \n-/* type-id:\n-     type-specifier-seq abstract-declarator(opt) */\n-static void\n-pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n+   conversion-declarator:\n+      ptr-operator conversion-declarator(opt)  */\n+static inline void\n+pp_cxx_conversion_function_id (cxx_pretty_printer *pp, tree t)\n {\n-  pp_flags saved_flags = pp_c_base (pp)->flags;\n-  pp_c_base (pp)->flags |= pp_c_flag_abstract;\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case TYPE_DECL:\n-    case UNION_TYPE:\n-    case RECORD_TYPE:\n-    case ENUMERAL_TYPE:\n-    case TYPENAME_TYPE:\n-    case BOUND_TEMPLATE_TEMPLATE_PARM:\n-    case UNBOUND_CLASS_TEMPLATE:\n-    case TEMPLATE_TEMPLATE_PARM:\n-    case TEMPLATE_TYPE_PARM:\n-    case TEMPLATE_PARM_INDEX:\n-    case TEMPLATE_DECL:\n-    case TYPEOF_TYPE:\n-    case TEMPLATE_ID_EXPR:\n-      /* FIXME: Should be pp_cxx_type_specifier_seq.  */\n-      pp_cxx_type_specifier (pp, t);\n-      pp_cxx_declarator (pp, t);\n-      break;\n-\n-    default:\n-      pp_c_type_id (pp_c_base (pp), t);\n-      break;\n-    }\n-\n-  pp_c_base (pp)->flags = saved_flags;\n+  pp_cxx_identifier (pp, \"operator\");\n+  pp_cxx_type_specifier_seq (pp, TREE_TYPE (t));\n }\n \n-static void\n-pp_cxx_initializer (cxx_pretty_printer *pp, tree t)\n+static inline void\n+pp_cxx_template_id (cxx_pretty_printer *pp, tree t)\n {\n-  pp_unsupported_tree (pp, t);\n+  pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 0));\n+  pp_cxx_begin_template_argument_list (pp);\n+  pp_cxx_template_argument_list (pp, TREE_OPERAND (t, 1));\n+  pp_cxx_end_template_argument_list (pp);\n }\n \n-/* template-argument-list:\n-      template-argument\n-      template-argument-list, template-argument\n-\n-   template-argument:\n-      assignment-expression\n-      type-id\n-      template-name   */\n static void\n-pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n-{\n-  int i;\n-  if (t == NULL)\n-    return;\n-  for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n-    {\n-      tree arg = TREE_VEC_ELT (t, i);\n-      if (i != 0)\n-        pp_separate_with (pp, ',');\n-      if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n-                           && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n-        pp_cxx_type_id (pp, arg);\n-      else\n-        pp_c_expression (pp_c_base (pp), arg);\n-    }\n-}\n-\n-\n-/* Statements.  */\n-\n-void\n-pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n-{\n-  pp_unsupported_tree (pp, t);\n-}\n-\n-/* Expressions. */\n-\n-static inline bool\n-is_destructor_name (tree name)\n+pp_cxx_class_name (cxx_pretty_printer *pp, tree t)\n {\n-  return name == complete_dtor_identifier\n-    || name == base_dtor_identifier\n-    || name == deleting_dtor_identifier;\n+  pp_cxx_unqualified_id (pp, TYPE_NAME (t));\n }\n \n /* unqualified-id:\n@@ -220,6 +141,12 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n   enum tree_code code = TREE_CODE (t);\n   switch (code)\n     {\n+    case RESULT_DECL:\n+      pp_cxx_identifier (pp, \"<return-value>\");\n+      break;\n+\n+    case OVERLOAD:\n+      t = OVL_CURRENT (t);      \n     case VAR_DECL:\n     case PARM_DECL:\n     case CONST_DECL:\n@@ -229,46 +156,70 @@ pp_cxx_unqualified_id (cxx_pretty_printer *pp, tree t)\n     case FIELD_DECL:\n     case LABEL_DECL:\n     case USING_DECL:\n+    case TEMPLATE_DECL:\n       t = DECL_NAME (t);\n       \n     case IDENTIFIER_NODE:\n-      if (IDENTIFIER_TYPENAME_P (t))\n-        {\n-          pp_c_identifier (pp_c_base (pp), \"operator\");\n-          /* FIXME: should be pp_cxx_type_specifier_seq */\n-          pp_cxx_type_specifier (pp, TREE_TYPE (t));\n-          /* FIXME:  should be pp_cxx_conversion_declarator. */\n-          pp_cxx_type_id (pp, TREE_TYPE (t));\n-        }\n-      else if (IDENTIFIER_OPNAME_P (t))\n-        {\n-          const char *name = operator_name_info[TREE_CODE (t)].name;\n-          pp_c_identifier (pp_c_base (pp), \"operator\");\n-          if (ISALPHA (name[0]))\n-            pp_space (pp);\n-          pp_base (pp)->padding = pp_none;\n-          pp_c_identifier (pp_c_base (pp), name);\n-        }\n+      if (t == NULL)\n+        pp_cxx_identifier (pp, \"<anonymous>\");\n+      else if (IDENTIFIER_TYPENAME_P (t))\n+        pp_cxx_conversion_function_id (pp, t);\n       else\n         {\n           if (is_destructor_name (t))\n             {\n               pp_complement (pp);\n-              t = constructor_name (TREE_TYPE (t));\n+              /* FIXME: Why is this necessary? */\n+              if (TREE_TYPE (t))\n+                t = constructor_name (TREE_TYPE (t));\n             }\n-          pp_c_tree_identifier (pp_c_base (pp), t);\n+          pp_cxx_tree_identifier (pp, t);\n         }\n       break;\n \n     case TEMPLATE_ID_EXPR:\n-      pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 0));\n-      pp_less (pp);\n-      pp_cxx_template_argument_list (pp, TREE_OPERAND (t, 1));\n-      pp_greater (pp);\n+      pp_cxx_template_id (pp, t);\n+      break;\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      pp_cxx_unqualified_id (pp, TYPE_NAME (t));\n+      break;\n+\n+    case TEMPLATE_TYPE_PARM:\n+      t = TYPE_FIELDS (t);\n+    case TEMPLATE_PARM_INDEX:\n+      pp_cxx_unqualified_id (pp, TEMPLATE_PARM_DECL (t));\n       break;\n \n     default:\n       pp_unsupported_tree (pp, t);\n+      break;\n+    }\n+}\n+\n+static inline void\n+pp_cxx_template_keyword_if_needed (cxx_pretty_printer *pp, tree scope, tree t)\n+{\n+  if (TREE_CODE (t) == TEMPLATE_ID_EXPR\n+      && TYPE_P (scope) && dependent_type_p (scope))\n+    pp_cxx_identifier (pp, \"template\");\n+}\n+\n+/* nested-name-specifier:\n+      class-or-namespace-name :: nested-name-specifier(opt)\n+      class-or-namespace-name :: template nested-name-specifier   */\n+static void\n+pp_cxx_nested_name_specifier (cxx_pretty_printer *pp, tree t)\n+{\n+  if (t != NULL && t != pp->enclosing_scope)\n+    {\n+      tree scope = TYPE_P (t) ? TYPE_CONTEXT (t) : DECL_CONTEXT (t);\n+      pp_cxx_nested_name_specifier (pp, scope);\n+      pp_cxx_template_keyword_if_needed (pp, scope, t);\n+      pp_cxx_unqualified_id (pp, t);\n+      pp_cxx_colon_colon (pp);\n     }\n }\n \n@@ -280,32 +231,34 @@ pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n   switch (TREE_CODE (t))\n     {\n     case PTRMEM_CST:\n-      pp_cxx_qualified_id (pp, PTRMEM_CST_CLASS (t));\n-      pp_colon_colon (pp);\n+      pp_cxx_nested_name_specifier (pp, PTRMEM_CST_CLASS (t));\n       pp_cxx_unqualified_id (pp, PTRMEM_CST_MEMBER (t));\n       break;\n \n+    case OVERLOAD:\n+      t = OVL_CURRENT (t);\n+    case FUNCTION_DECL:\n+      if (DECL_FUNCTION_MEMBER_P (t))\n+        pp_cxx_nested_name_specifier (pp, DECL_CONTEXT (t));\n+      pp_cxx_unqualified_id\n+        (pp, DECL_CONSTRUCTOR_P (t) ? DECL_CONTEXT (t) : t);\n+      break;\n+\n     case OFFSET_REF:\n     case SCOPE_REF:\n-      pp_cxx_qualified_id (pp, TREE_OPERAND (t, 0));\n-      pp_colon_colon (pp);\n+      pp_cxx_nested_name_specifier (pp, TREE_OPERAND (t, 0));\n       pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 1));\n       break;\n \n     default:\n       {\n-        tree scope = DECL_CONTEXT (t);\n-        if (scope == pp->enclosing_scope)\n-          pp_cxx_unqualified_id (pp, t);\n-        else\n+        tree scope = TYPE_P (t) ? TYPE_CONTEXT (t) : DECL_CONTEXT (t);\n+        if (scope != pp->enclosing_scope)\n           {\n-            pp_cxx_qualified_id (pp, scope);\n-            pp_colon_colon (pp);\n-            if (TYPE_P (scope) && dependent_type_p (scope)\n-                && TREE_CODE (t) == TEMPLATE_DECL)\n-              pp_c_identifier (pp_c_base (pp), \"template\");\n-            pp_cxx_unqualified_id (pp, t);\n+            pp_cxx_nested_name_specifier (pp, scope);\n+            pp_cxx_template_keyword_if_needed (pp, scope, t);\n           }\n+        pp_cxx_unqualified_id (pp, t);\n       }\n       break;\n     }\n@@ -317,8 +270,11 @@ pp_cxx_qualified_id (cxx_pretty_printer *pp, tree t)\n static inline void\n pp_cxx_id_expression (cxx_pretty_printer *pp, tree t)\n {\n-  if (pp_c_base (pp)->flags\n-      & (pp_cxx_flag_qualified_id | pp_cxx_flag_global_scope))\n+  if (TREE_CODE (t) == OVERLOAD)\n+    t = OVL_CURRENT (t);\n+  if ((TREE_CODE (t) == FUNCTION_DECL && DECL_FUNCTION_MEMBER_P (t))\n+      || (pp_c_base (pp)->flags\n+          & (pp_cxx_flag_qualified_id | pp_cxx_flag_global_scope)))\n     pp_cxx_qualified_id (pp, t);\n   else\n     pp_cxx_unqualified_id (pp, t);\n@@ -343,15 +299,26 @@ pp_cxx_primary_expression (cxx_pretty_printer *pp, tree t)\n       pp_c_constant (pp_c_base (pp), t);\n       break;\n \n+    case BASELINK:\n+      t = BASELINK_FUNCTIONS (t);\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case FUNCTION_DECL:\n+    case OVERLOAD:\n+    case CONST_DECL:\n+    case TEMPLATE_DECL:\n+      pp_cxx_id_expression (pp, t);\n+      break;\n+\n+    case RESULT_DECL:\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+      pp_cxx_unqualified_id (pp, t);\n+      break;\n+\n     default:\n-      if (pp_c_base (pp)->flags & pp_cxx_flag_qualified_id)\n-        pp_cxx_qualified_id (pp, t);\n-      else\n-        {\n-          if (pp_c_base (pp)->flags & pp_cxx_flag_global_scope)\n-            pp_colon_colon (pp);\n-          pp_cxx_unqualified_id (pp, t);\n-        }\n+      pp_c_primary_expression (pp_c_base (pp), t);\n       break;\n     }\n }\n@@ -384,6 +351,71 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n   \n   switch (code)\n     {\n+    case AGGR_INIT_EXPR:\n+    case CALL_EXPR:\n+      {\n+        tree fun = TREE_OPERAND (t, 0);\n+        tree args = TREE_OPERAND (t, 1);\n+        tree saved_scope = pp->enclosing_scope;\n+\n+        if (TREE_CODE (fun) == ADDR_EXPR)\n+          fun = TREE_OPERAND (fun, 0);\n+\n+        /* In templates, where there is no way to tell whether a given\n+           call uses an actual member function.  So the parser builds\n+           FUN as a COMPONENT_REF or a plain IDENTIFIER_NODE until\n+           instantiation time.  */\n+        if (TREE_CODE (fun) != FUNCTION_DECL)\n+          ;\n+        else if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fun))\n+          {\n+            tree object = code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t)\n+              ? TREE_OPERAND (t, 2)\n+              : TREE_VALUE (args);\n+            \n+            while (TREE_CODE (object) == NOP_EXPR)\n+              object = TREE_OPERAND (object, 0);\n+\n+            if (TREE_CODE (object) == ADDR_EXPR)\n+              object = TREE_OPERAND (object, 0);\n+            \n+            if (TREE_CODE (TREE_TYPE (object)) != POINTER_TYPE)\n+              {\n+                pp_cxx_postfix_expression (pp, object);\n+                pp_cxx_dot (pp);\n+              }\n+            else \n+              {\n+                pp_cxx_postfix_expression (pp, object);\n+                pp_cxx_arrow (pp);\n+              }\n+            args = TREE_CHAIN (args);\n+            pp->enclosing_scope = strip_pointer_operator (TREE_TYPE (object));\n+          }\n+\n+        pp_cxx_postfix_expression (pp, fun);\n+        pp->enclosing_scope = saved_scope;\n+        pp_cxx_call_argument_list (pp, args);\n+      }\n+      if (code == AGGR_INIT_EXPR && AGGR_INIT_VIA_CTOR_P (t))\n+        {\n+          pp_separate_with (pp, ',');\n+          pp_cxx_postfix_expression (pp, TREE_OPERAND (t, 2));\n+        }\n+      break;\n+\n+    case BASELINK:\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case FUNCTION_DECL:\n+    case OVERLOAD:\n+    case CONST_DECL:\n+    case TEMPLATE_DECL:\n+    case RESULT_DECL:\n+      pp_cxx_primary_expression (pp, t);\n+      break;\n+\n     case DYNAMIC_CAST_EXPR:\n     case STATIC_CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n@@ -400,7 +432,7 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_type_id (pp, TREE_TYPE (t));\n       pp_cxx_end_template_argument_list (pp);\n       pp_left_paren (pp);\n-      pp_c_expression (pp_c_base (pp), TREE_OPERAND (t, 0));\n+      pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n       pp_right_paren (pp);\n       break;\n \n@@ -412,20 +444,20 @@ pp_cxx_postfix_expression (cxx_pretty_printer *pp, tree t)\n \n     case TYPEID_EXPR:\n       t = TREE_OPERAND (t, 0);\n-      pp_c_identifier (pp_c_base (pp), \"typeid\");\n+      pp_cxx_identifier (pp, \"typeid\");\n       pp_left_paren (pp);\n       if (TYPE_P (t))\n         pp_cxx_type_id (pp, t);\n       else\n-        pp_c_expression (pp_c_base (pp), t);\n+        pp_cxx_expression (pp, t);\n       pp_right_paren (pp);\n       break;\n \n     case PSEUDO_DTOR_EXPR:\n       pp_cxx_postfix_expression (pp, TREE_OPERAND (t, 0));\n-      pp_dot (pp);\n+      pp_cxx_dot (pp);\n       pp_cxx_qualified_id (pp, TREE_OPERAND (t, 1));\n-      pp_colon_colon (pp);\n+      pp_cxx_colon_colon (pp);\n       pp_complement (pp);\n       pp_cxx_unqualified_id (pp, TREE_OPERAND (t, 2));\n       break;\n@@ -465,13 +497,11 @@ pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n       if (NEW_EXPR_USE_GLOBAL (t))\n-        pp_colon_colon (pp);\n-      pp_c_identifier (pp_c_base (pp), \"new\");\n+        pp_cxx_colon_colon (pp);\n+      pp_cxx_identifier (pp, \"new\");\n       if (TREE_OPERAND (t, 0))\n         {\n-          pp_left_paren (pp);\n-          pp_c_expression_list (pp_c_base (pp), TREE_OPERAND (t, 0));\n-          pp_right_paren (pp);\n+          pp_cxx_call_argument_list (pp, TREE_OPERAND (t, 0));\n           pp_space (pp);\n         }\n       /* FIXME: array-types are built with one more element.  */\n@@ -485,7 +515,7 @@ pp_cxx_new_expression (cxx_pretty_printer *pp, tree t)\n           else if (t == void_zero_node)\n             ;                   /* OK, empty initializer list.  */\n           else\n-            pp_c_expression (pp_c_base (pp), t);\n+            pp_cxx_expression (pp, t);\n           pp_right_paren (pp);\n         }\n       break;\n@@ -507,8 +537,8 @@ pp_cxx_delete_expression (cxx_pretty_printer *pp, tree t)\n     case DELETE_EXPR:\n     case VEC_DELETE_EXPR:\n       if (DELETE_EXPR_USE_GLOBAL (t))\n-        pp_colon_colon (pp);\n-      pp_c_identifier (pp_c_base (pp), \"delete\");\n+        pp_cxx_colon_colon (pp);\n+      pp_cxx_identifier (pp, \"delete\");\n       if (code == VEC_DELETE_EXPR)\n         {\n           pp_left_bracket (pp);\n@@ -560,6 +590,25 @@ pp_cxx_unary_expression (cxx_pretty_printer *pp, tree t)\n     }\n }\n \n+/* cast-expression:\n+      unary-expression\n+      ( type-id ) cast-expression  */\n+static void\n+pp_cxx_cast_expression (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case CAST_EXPR:\n+      pp_cxx_type_id (pp, TREE_TYPE (t));\n+      pp_cxx_call_argument_list (pp, TREE_OPERAND (t, 0));\n+      break;\n+\n+    default:\n+      pp_c_cast_expression (pp_c_base (pp), t);\n+      break;\n+    }\n+}\n+\n /* pm-expression:\n       cast-expression\n       pm-expression .* cast-expression\n@@ -580,14 +629,14 @@ pp_cxx_pm_expression (cxx_pretty_printer *pp, tree t)\n     case MEMBER_REF:\n     case DOTSTAR_EXPR:\n       pp_cxx_pm_expression (pp, TREE_OPERAND (t, 0));\n-      pp_dot (pp);\n+      pp_cxx_dot (pp);\n       pp_star(pp);\n-      pp_c_cast_expression (pp_c_base (pp), TREE_OPERAND (t, 1));\n+      pp_cxx_cast_expression (pp, TREE_OPERAND (t, 1));\n       break;\n \n \n     default:\n-      pp_c_cast_expression (pp_c_base (pp), t);\n+      pp_cxx_cast_expression (pp, t);\n       break;\n     }\n }\n@@ -624,7 +673,6 @@ pp_cxx_multiplicative_expression (cxx_pretty_printer *pp, tree e)\n     }\n }\n \n-\n /* conditional-expression:\n       logical-or-expression\n       logical-or-expression ?  expression  : assignment-expression  */\n@@ -637,59 +685,991 @@ pp_cxx_conditional_expression (cxx_pretty_printer *pp, tree e)\n       pp_space (pp);\n       pp_question (pp);\n       pp_space (pp);\n-      pp_c_expression (pp_c_base (pp), TREE_OPERAND (e, 1));\n+      pp_cxx_expression (pp, TREE_OPERAND (e, 1));\n       pp_space (pp);\n       pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 2));\n     }\n   else\n     pp_c_logical_or_expression (pp_c_base (pp), e);\n }\n \n+static void\n+pp_cxx_assignment_operator (cxx_pretty_printer *pp, tree t)\n+{\n+  const char *op;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case NOP_EXPR:\n+      op = \"=\";\n+      break;\n+\n+    case PLUS_EXPR:\n+      op = \"+=\";\n+      break;\n+\n+    case MINUS_EXPR:\n+      op = \"-=\";\n+      break;\n+\n+    case TRUNC_DIV_EXPR:\n+      op = \"/=\";\n+      break;\n+\n+    case TRUNC_MOD_EXPR:\n+      op = \"%=\";\n+      break;\n+\n+    default:\n+      op = tree_code_name[TREE_CODE (t)];\n+      break;\n+    }\n+\n+  pp_cxx_identifier (pp, op);\n+}\n+\n+\n /* assignment-expression:\n       conditional-expression\n       logical-or-expression assignment-operator assignment-expression\n+      throw-expression\n+\n+   throw-expression:\n+       throw assignment-expression(opt)\n \n-   assignment-expression: one of\n+   assignment-operator: one of\n       =    *=    /=    %=    +=    -=    >>=    <<=    &=    ^=    |=  */\n static void\n pp_cxx_assignment_expression (cxx_pretty_printer *pp, tree e)\n {\n-  if (TREE_CODE (e) == MODIFY_EXPR)\n+  switch (TREE_CODE (e))\n     {\n+    case MODIFY_EXPR:\n+    case INIT_EXPR:\n       pp_c_logical_or_expression (pp_c_base (pp), TREE_OPERAND (e, 0));\n       pp_space (pp);\n       pp_equal (pp);\n       pp_space (pp);\n       pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 1));\n-    }\n-  else\n-    pp_cxx_conditional_expression (pp, e);\n-}\n+      break;\n \n+    case THROW_EXPR:\n+      pp_cxx_identifier (pp, \"throw\");\n+      if (TREE_OPERAND (e, 0))\n+        pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 0));\n+      break;\n \n-\f\n-typedef c_pretty_print_fn pp_fun;\n+    case MODOP_EXPR:\n+      pp_c_logical_or_expression (pp_c_base (pp), TREE_OPERAND (e, 0));\n+      pp_cxx_assignment_operator (pp, TREE_OPERAND (e, 1));\n+      pp_cxx_assignment_expression (pp, TREE_OPERAND (e, 2));\n+      break;\n \n-void\n-pp_cxx_pretty_printer_init (cxx_pretty_printer *pp)\n-{\n-  pp_c_pretty_printer_init (pp_c_base (pp));\n+    default:\n+      pp_cxx_conditional_expression (pp, e);\n+      break;\n+    }\n+}\n+\n+static void\n+pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case STRING_CST:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+      pp_c_constant (pp_c_base (pp), t);\n+      break;\n+\n+    case RESULT_DECL:\n+      pp_cxx_unqualified_id (pp, t);\n+      break;\n+\n+#if 0      \n+    case OFFSET_REF:\n+#endif       \n+    case SCOPE_REF:\n+    case PTRMEM_CST:\n+      pp_cxx_qualified_id (pp, t);\n+      break;\n+\n+    case OVERLOAD:\n+      t = OVL_CURRENT (t);\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case FIELD_DECL:\n+    case CONST_DECL:\n+    case FUNCTION_DECL:\n+    case BASELINK:\n+    case TEMPLATE_DECL:\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+      pp_cxx_primary_expression (pp, t);\n+      break;\n+\n+    case CALL_EXPR:\n+    case DYNAMIC_CAST_EXPR:\n+    case STATIC_CAST_EXPR:\n+    case REINTERPRET_CAST_EXPR:\n+    case CONST_CAST_EXPR:\n+#if 0      \n+    case MEMBER_REF:\n+#endif      \n+    case EMPTY_CLASS_EXPR:\n+    case TYPEID_EXPR:\n+    case PSEUDO_DTOR_EXPR:\n+    case AGGR_INIT_EXPR:\n+      pp_cxx_postfix_expression (pp, t);\n+      break;\n+\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+      pp_cxx_new_expression (pp, t);\n+      break;\n+\n+    case DELETE_EXPR:\n+    case VEC_DELETE_EXPR:\n+      pp_cxx_delete_expression (pp, t);\n+      break;\n+\n+    case CAST_EXPR:\n+      pp_cxx_cast_expression (pp, t);\n+      break;\n+\n+    case OFFSET_REF:\n+    case MEMBER_REF:\n+    case DOTSTAR_EXPR:\n+      pp_cxx_pm_expression (pp, t);\n+      break;\n+\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+      pp_cxx_multiplicative_expression (pp, t);\n+      break;\n+\n+    case COND_EXPR:\n+      pp_cxx_conditional_expression (pp, t);\n+      break;\n+\n+    case MODIFY_EXPR:\n+    case INIT_EXPR:\n+    case THROW_EXPR:\n+    case MODOP_EXPR:\n+      pp_cxx_assignment_expression (pp, t);\n+      break;\n+\n+    default:\n+      pp_c_expression (pp_c_base (pp), t);\n+      break;      \n+    }\n+}\n+\n+\n+/* Declarations.  */\n+\n+/* function-specifier:\n+      inline\n+      virtual\n+      explicit   */\n+static void\n+pp_cxx_function_specifier (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case FUNCTION_DECL:\n+      if (DECL_VIRTUAL_P (t))\n+        pp_cxx_identifier (pp, \"virtual\");\n+      else if (DECL_CONSTRUCTOR_P (t) && DECL_NONCONVERTING_P (t))\n+        pp_cxx_identifier (pp, \"explicit\");\n+      else\n+        pp_c_function_specifier (pp_c_base (pp), t);\n+\n+    default:\n+      break;\n+    }\n+}\n+\n+/* decl-specifier-seq:\n+      decl-specifier-seq(opt) decl-specifier\n+\n+   decl-specifier:\n+      storage-class-specifier\n+      type-specifier\n+      function-specifier\n+      friend\n+      typedef  */\n+static void\n+pp_cxx_decl_specifier_seq (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case CONST_DECL:\n+    case FIELD_DECL:\n+      pp_cxx_storage_class_specifier (pp, t);\n+      pp_cxx_decl_specifier_seq (pp, TREE_TYPE (t));\n+      break;\n+      \n+    case TYPE_DECL:\n+      pp_cxx_identifier (pp, \"typedef\");\n+      pp_cxx_decl_specifier_seq (pp, TREE_TYPE (t));\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+        {\n+          tree pfm = TYPE_PTRMEMFUNC_FN_TYPE (t);\n+          pp_cxx_decl_specifier_seq (pp, TREE_TYPE (TREE_TYPE (pfm)));\n+          pp_cxx_whitespace (pp);\n+          pp_cxx_ptr_operator (pp, t);\n+        }\n+      break;\n+\n+    case FUNCTION_DECL:\n+      /* Constructors don't have return types.  And conversion functions\n+         do not have a type-specifier in their return types.  */\n+      if (DECL_CONSTRUCTOR_P (t) || DECL_CONV_FN_P (t))\n+        pp_cxx_function_specifier (pp, t);\n+      else if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n+        pp_cxx_decl_specifier_seq (pp, TREE_TYPE (TREE_TYPE (t)));\n+      else\n+        default:\n+      pp_c_declaration_specifiers (pp_c_base (pp), t);\n+      break;\n+    }\n+}\n+\n+/* simple-type-specifier:\n+      ::(opt) nested-name-specifier(opt) type-name\n+      ::(opt) nested-name-specifier(opt) template(opt) template-id\n+      char\n+      wchar_t\n+      bool\n+      short\n+      int\n+      long\n+      signed\n+      unsigned\n+      float\n+      double\n+      void  */\n+static void\n+pp_cxx_simple_type_specifier (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      pp_cxx_qualified_id (pp, t);\n+      break;\n+\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+      pp_cxx_unqualified_id (pp, t);\n+      break;\n+\n+    case TYPENAME_TYPE:\n+      pp_cxx_identifier (pp, \"typename\");\n+      pp_cxx_nested_name_specifier (pp, TYPE_CONTEXT (t));\n+      pp_cxx_unqualified_id (pp, TYPE_NAME (t));\n+      break;\n+\n+    default:\n+      pp_c_type_specifier (pp_c_base (pp), t);\n+      break;\n+    }\n+}\n+\n+/* type-specifier-seq:\n+      type-specifier type-specifier-seq(opt)\n+\n+   type-specifier:\n+      simple-type-specifier\n+      class-specifier\n+      enum-specifier\n+      elaborated-type-specifier\n+      cv-qualifer   */\n+\n+static void\n+pp_cxx_type_specifier_seq (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_c_type_qualifier_list (pp_c_base (pp), t);\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case TEMPLATE_DECL:\n+    case TEMPLATE_TYPE_PARM:\n+    case TYPE_DECL:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+      pp_cxx_simple_type_specifier (pp, t);\n+      break;\n+\n+    case METHOD_TYPE:\n+      pp_cxx_type_specifier_seq (pp, TREE_TYPE (t));\n+      pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (t));\n+      pp_cxx_nested_name_specifier (pp, TYPE_METHOD_BASETYPE (t));\n+      break;\n+\n+    default:\n+      if (!(TREE_CODE (t) == FUNCTION_DECL && DECL_CONSTRUCTOR_P (t)))\n+        pp_c_specifier_qualifier_list (pp_c_base (pp), t);\n+    }\n+}\n+\n+/* ptr-operator:\n+      * cv-qualifier-seq(opt)\n+      &\n+      ::(opt) nested-name-specifier * cv-qualifier-seq(opt)  */\n+\n+static void\n+pp_cxx_ptr_operator (cxx_pretty_printer *pp, tree t)\n+{\n+  if (!TYPE_P (t) && TREE_CODE (t) != TYPE_DECL)\n+    t = TREE_TYPE (t);\n+  switch (TREE_CODE (t))\n+    {\n+    case REFERENCE_TYPE:\n+    case POINTER_TYPE:\n+      if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE\n+          || TYPE_PTR_TO_MEMBER_P (TREE_TYPE (t)))\n+        pp_cxx_ptr_operator (pp, TREE_TYPE (t));\n+      if (TREE_CODE (t) == POINTER_TYPE)\n+        {\n+          pp_star (pp);\n+          pp_cxx_cv_qualifier_seq (pp, t);\n+        }\n+      else\n+        pp_ampersand (pp);\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+        {\n+          pp_cxx_left_paren (pp);\n+          pp_cxx_nested_name_specifier (pp, TYPE_PTRMEMFUNC_OBJECT_TYPE (t));\n+          pp_star (pp);\n+          break;\n+        }\n+    case OFFSET_TYPE:\n+      if (TYPE_PTR_TO_MEMBER_P (t))\n+        {\n+          pp_cxx_nested_name_specifier (pp, TYPE_PTRMEM_CLASS_TYPE (t));\n+          pp_star (pp);\n+          pp_cxx_cv_qualifier_seq (pp, t);\n+          break;\n+        }\n+      /* else fall trhough.  */\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n+}\n+\n+static inline tree\n+pp_cxx_implicit_parameter_type (tree mf)\n+{\n+  return TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (mf))));\n+}\n+\n+/*\n+   parameter-declaration:\n+      decl-specifier-seq declarator\n+      decl-specifier-seq declarator = assignment-expression\n+      decl-specifier-seq abstract-declarator(opt)\n+      decl-specifier-seq abstract-declarator(opt) assignment-expression  */\n+static inline void\n+pp_cxx_parameter_declaration (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_decl_specifier_seq (pp, t);\n+  if (TYPE_P (t))\n+    pp_cxx_abstract_declarator (pp, t);\n+  else\n+    pp_cxx_declarator (pp, t);\n+}\n+\n+/* parameter-declaration-clause:\n+      parameter-declaration-list(opt) ...(opt)\n+      parameter-declaration-list , ...\n+\n+   parameter-declaration-list:\n+      parameter-declaration\n+      parameter-declaration-list , parameter-declaration  */\n+static void\n+pp_cxx_parameter_declaration_clause (cxx_pretty_printer *pp, tree t)\n+{\n+  tree args = TYPE_P (t) ? NULL : FUNCTION_FIRST_USER_PARM (t);\n+  tree types = TYPE_P (t) ? TYPE_ARG_TYPES (t) : FUNCTION_FIRST_USER_PARMTYPE (t);\n+  const bool abstract = args == NULL\n+    || pp_c_base (pp)->flags & pp_c_flag_abstract;\n+  bool first = true;\n+\n+  /* Skip artificial parameter for nonstatic member functions.  */\n+  if (TREE_CODE (t) == METHOD_TYPE)\n+    types = TREE_CHAIN (types);\n+\n+  pp_cxx_left_paren (pp);\n+  for (; args; args = TREE_CHAIN (args), types = TREE_CHAIN (types))\n+    {\n+      if (!first)\n+        pp_separate_with (pp, ',');\n+      first = false;\n+      pp_cxx_parameter_declaration (pp, abstract ? TREE_VALUE (types) : args);\n+      if (!abstract && pp_c_base (pp)->flags & pp_cxx_flag_default_argument)\n+        {\n+          pp_cxx_whitespace (pp);\n+          pp_equal (pp);\n+          pp_cxx_whitespace (pp);\n+          pp_cxx_assignment_expression (pp, TREE_PURPOSE (types));\n+        }\n+    }\n+  pp_cxx_right_paren (pp);\n+}\n+\n+/* exception-specification:\n+      throw ( type-id-list(opt) )\n+\n+   type-id-list\n+      type-id\n+      type-id-list , type-id   */\n+static void\n+pp_cxx_exception_specification (cxx_pretty_printer *pp, tree t)\n+{\n+  tree ex_spec = TYPE_RAISES_EXCEPTIONS (t);\n+\n+  if (!TYPE_NOTHROW_P (t) && ex_spec == NULL)\n+    return;\n+  pp_cxx_identifier (pp, \"throw\");\n+  pp_cxx_left_paren (pp);\n+  for (; ex_spec && TREE_VALUE (ex_spec); ex_spec = TREE_CHAIN (ex_spec))\n+    {\n+      pp_cxx_type_id (pp, TREE_VALUE (ex_spec));\n+      if (TREE_CHAIN (ex_spec))\n+        pp_separate_with (pp, ',');\n+    }\n+  pp_cxx_right_paren (pp);\n+}\n+\n+/* direct-declarator:\n+      declarator-id\n+      direct-declarator ( parameter-declaration-clause ) cv-qualifier-seq(opt)\n+                                            exception-specification(opt)\n+      direct-declaration [ constant-expression(opt) ]\n+      ( declarator )  */\n+static void\n+pp_cxx_direct_declarator (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case CONST_DECL:\n+    case FIELD_DECL:\n+      if (DECL_NAME (t))\n+        {\n+          pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (t));\n+          pp_cxx_id_expression (pp, DECL_NAME (t));\n+        }\n+      pp_cxx_abstract_declarator (pp, TREE_TYPE (t));\n+      break;\n+      \n+    case FUNCTION_DECL:\n+      pp_cxx_space_for_pointer_operator (pp, TREE_TYPE (TREE_TYPE (t)));\n+      pp_cxx_id_expression (pp, t);\n+      pp_cxx_parameter_declaration_clause (pp, t);\n+      \n+      if (DECL_NONSTATIC_MEMBER_FUNCTION_P (t))\n+        {\n+          pp_base (pp)->padding = pp_before;\n+          pp_cxx_cv_qualifier_seq (pp, pp_cxx_implicit_parameter_type (t));\n+        }\n+\n+      pp_cxx_exception_specification (pp, TREE_TYPE (t));\n+      break;\n+\n+    case TYPENAME_TYPE:\n+    case TEMPLATE_DECL:\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+      break;\n+\n+    default:\n+      pp_c_direct_declarator (pp_c_base (pp), t);\n+      break;\n+    }\n+}\n+\n+/* declarator:\n+   direct-declarator\n+   ptr-operator declarator  */\n+static void\n+pp_cxx_declarator (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_direct_declarator (pp, t);\n+}\n+\n+/* ctor-initializer:\n+      : mem-initializer-list\n+\n+   mem-initializer-list:\n+      mem-initializer\n+      mem-initializer , mem-initializer-list\n+\n+   mem-initializer:\n+      mem-initializer-id ( expression-list(opt) )\n+\n+   mem-initializer-id:\n+      ::(opt) nested-name-specifier(opt) class-name\n+      identifier   */\n+static void\n+pp_cxx_ctor_initializer (cxx_pretty_printer *pp, tree t)\n+{\n+  t = TREE_OPERAND (t, 0);\n+  pp_cxx_whitespace (pp);\n+  pp_colon (pp);\n+  pp_cxx_whitespace (pp);\n+  for (; t; t = TREE_CHAIN (t))\n+    {\n+      pp_cxx_primary_expression (pp, TREE_PURPOSE (t));\n+      pp_cxx_call_argument_list (pp, TREE_VALUE (t));\n+      if (TREE_CHAIN (t))\n+        pp_separate_with (pp, ',');\n+    }\n+}\n+\n+/* function-definition:\n+      decl-specifier-seq(opt) declarator ctor-initializer(opt) function-body\n+      decl-specifier-seq(opt) declarator function-try-block  */\n+\n+void\n+pp_cxx_function_definition (cxx_pretty_printer *pp, tree t)\n+{\n+  tree saved_scope = pp->enclosing_scope;\n+  pp_cxx_decl_specifier_seq (pp, t);\n+  pp_cxx_declarator (pp, t);\n+  pp_needs_newline (pp) = true;\n+  pp->enclosing_scope = DECL_CONTEXT (t);\n+  if (DECL_SAVED_TREE (t))\n+    {\n+      tree body = DECL_SAVED_TREE (t);\n+      if (TREE_CODE (body) == COMPOUND_STMT\n+          && TREE_CODE (COMPOUND_BODY (body)) == CTOR_INITIALIZER)\n+        {\n+          body = COMPOUND_BODY (body);\n+          pp_cxx_ctor_initializer (pp, body);\n+          body = TREE_CHAIN (body);\n+        }\n+      pp_cxx_statement (pp, body);\n+    }\n+  else\n+    {\n+      pp_cxx_semicolon (pp);\n+      pp_needs_newline (pp) = true;\n+    }\n+  pp_flush (pp);\n+  pp->enclosing_scope = saved_scope;\n+}\n+\n+/* abstract-declarator:\n+      ptr-operator abstract-declarator(opt)\n+      direct-abstract-declarator  */\n+static void\n+pp_cxx_abstract_declarator (cxx_pretty_printer *pp, tree t)\n+{\n+  if (TYPE_PTRMEM_P (t) || TYPE_PTRMEMFUNC_P (t))\n+    pp_cxx_right_paren (pp);\n+  else if (POINTER_TYPE_P (t))\n+    {\n+      if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n+          || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+        pp_cxx_right_paren (pp);\n+      t = TREE_TYPE (t);\n+    }\n+  pp_cxx_direct_abstract_declarator (pp, t);\n+}\n+\n+/* direct-abstract-declarator:\n+      direct-abstract-declarator(opt) ( parameter-declaration-clause )\n+                           cv-quafilier-seq(opt) exception-specification(opt)\n+      direct-abstract-declarator(opt) [ constant-expression(opt) ]\n+      ( abstract-declarator )  */\n+static void\n+pp_cxx_direct_abstract_declarator (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case REFERENCE_TYPE:\n+      pp_cxx_abstract_declarator (pp, t);\n+      break;\n+\n+    case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_P (t))\n+        pp_cxx_direct_abstract_declarator (pp, TYPE_PTRMEMFUNC_FN_TYPE (t));\n+      break;\n+\n+    case METHOD_TYPE:\n+    case FUNCTION_TYPE:\n+      pp_cxx_parameter_declaration_clause (pp, t);\n+      pp_cxx_direct_abstract_declarator (pp, TREE_TYPE (t));\n+      if (TREE_CODE (t) == METHOD_TYPE)\n+        {\n+          pp_base (pp)->padding = pp_before;\n+          pp_cxx_cv_qualifier_seq\n+            (pp, TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))));\n+        }\n+      pp_cxx_exception_specification (pp, t);\n+      break;\n+\n+    case TYPENAME_TYPE:\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+    case UNBOUND_CLASS_TEMPLATE:\n+      break;\n+\n+    default:\n+      pp_c_direct_abstract_declarator (pp_c_base (pp), t);\n+      break;      \n+    }\n+}\n+\n+/* type-id:\n+     type-specifier-seq abstract-declarator(opt) */\n+static void\n+pp_cxx_type_id (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_flags saved_flags = pp_c_base (pp)->flags;\n+  pp_c_base (pp)->flags |= pp_c_flag_abstract;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case TYPE_DECL:\n+    case UNION_TYPE:\n+    case RECORD_TYPE:\n+    case ENUMERAL_TYPE:\n+    case TYPENAME_TYPE:\n+    case BOUND_TEMPLATE_TEMPLATE_PARM:\n+    case UNBOUND_CLASS_TEMPLATE:\n+    case TEMPLATE_TEMPLATE_PARM:\n+    case TEMPLATE_TYPE_PARM:\n+    case TEMPLATE_PARM_INDEX:\n+    case TEMPLATE_DECL:\n+    case TYPEOF_TYPE:\n+    case TEMPLATE_ID_EXPR:\n+      /* FIXME: Should be pp_cxx_type_specifier_seq.  */\n+      pp_cxx_type_specifier_seq (pp, t);\n+      pp_cxx_declarator (pp, t);\n+      break;\n+\n+    default:\n+      pp_c_type_id (pp_c_base (pp), t);\n+      break;\n+    }\n+\n+  pp_c_base (pp)->flags = saved_flags;\n+}\n+\n+/* template-argument-list:\n+      template-argument\n+      template-argument-list, template-argument\n+\n+   template-argument:\n+      assignment-expression\n+      type-id\n+      template-name   */\n+static void\n+pp_cxx_template_argument_list (cxx_pretty_printer *pp, tree t)\n+{\n+  int i;\n+  if (t == NULL)\n+    return;\n+  for (i = 0; i < TREE_VEC_LENGTH (t); ++i)\n+    {\n+      tree arg = TREE_VEC_ELT (t, i);\n+      if (i != 0)\n+        pp_separate_with (pp, ',');\n+      if (TYPE_P (arg) || (TREE_CODE (arg) == TEMPLATE_DECL\n+                           && TYPE_P (DECL_TEMPLATE_RESULT (arg))))\n+        pp_cxx_type_id (pp, arg);\n+      else\n+        pp_cxx_expression (pp, arg);\n+    }\n+}\n+\n+\n+static void\n+pp_cxx_exception_declaration (cxx_pretty_printer *pp, tree t)\n+{\n+  t = DECL_STMT_DECL (t);\n+  pp_cxx_type_specifier_seq (pp, t);\n+  if (TYPE_P (t))\n+    pp_cxx_abstract_declarator (pp, t);\n+  else\n+    pp_cxx_declarator (pp, t);\n+}\n+\n+/* Statements.  */\n+\n+void\n+pp_cxx_statement (cxx_pretty_printer *pp, tree t)\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case USING_STMT:\n+      pp_cxx_identifier (pp, \"using\");\n+      pp_cxx_identifier (pp, \"namespace\");\n+      pp_cxx_qualified_id (pp, USING_STMT_NAMESPACE (t));\n+      break;\n+\n+    case USING_DECL:\n+      pp_cxx_identifier (pp, \"using\");\n+      pp_cxx_nested_name_specifier (pp, DECL_INITIAL (t));\n+      pp_cxx_unqualified_id (pp, DECL_NAME (t));\n+      break;\n+\n+    case EH_SPEC_BLOCK:\n+      break;\n+\n+      /* try-block:\n+            try compound-statement handler-seq  */\n+    case TRY_BLOCK:\n+      pp_maybe_newline_and_indent (pp, 0);\n+      pp_cxx_identifier (pp, \"try\");\n+      pp_newline_and_indent (pp, 3);\n+      pp_cxx_statement (pp, TRY_STMTS (t));\n+      pp_newline_and_indent (pp, -3);\n+      if (CLEANUP_P (t))\n+        ;\n+      else\n+        pp_cxx_statement (pp, TRY_HANDLERS (t));\n+      break;\n+\n+      /*\n+         handler-seq:\n+            handler handler-seq(opt)\n+\n+         handler:\n+         catch ( exception-declaration ) compound-statement \n+\n+         exception-declaration:\n+            type-specifier-seq declarator\n+            type-specifier-seq abstract-declarator\n+            ...   */\n+    case HANDLER:\n+      pp_cxx_identifier (pp, \"catch\");\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_exception_declaration (pp, HANDLER_PARMS (t));\n+      pp_cxx_right_paren (pp);\n+      pp_indentation (pp) += 3;\n+      pp_needs_newline (pp) = true;\n+      pp_cxx_statement (pp, HANDLER_BODY (t));\n+      pp_indentation (pp) -= 3;\n+      pp_needs_newline (pp) = true;\n+      break;\n+\n+    default:\n+      pp_c_statement (pp_c_base (pp), t);\n+      break;\n+    }\n+}\n+\n+/* simple-declaration:\n+      decl-specifier-seq(opt) init-declarator-list(opt)  */\n+static void\n+pp_cxx_simple_declaration (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_cxx_decl_specifier_seq (pp, t);\n+  pp_cxx_init_declarator (pp, t);\n+  pp_cxx_semicolon (pp);\n+  pp_needs_newline (pp) = true;\n+}\n+\n+/*\n+  template-parameter-list:\n+     template-parameter\n+     template-parameter-list , template-parameter  */\n+\n+static inline void\n+pp_cxx_template_parameter_list (cxx_pretty_printer *pp, tree t)\n+{\n+  const int n = TREE_VEC_LENGTH (t);\n+  int i;\n+  for (i = 0; i < n; ++i)\n+    {\n+      if (i)\n+        pp_separate_with (pp, ',');\n+      pp_cxx_template_parameter (pp, TREE_VEC_ELT (t, i));\n+    }\n+}\n+\n+/* template-parameter:\n+      type-parameter\n+      parameter-declaration\n+\n+   type-parameter:\n+     class identifier(opt)\n+     class identifier(op) = type-id\n+     typename identifier(opt)\n+     typename identifier(opt) = type-id\n+     template < template-parameter-list > class identifier(opt)\n+     template < template-parameter-list > class identifier(opt) = template-name\n+*/\n+static void\n+pp_cxx_template_parameter (cxx_pretty_printer *pp, tree t)\n+{\n+  tree parameter =  TREE_VALUE (t);\n+  switch (TREE_CODE (parameter))\n+    {\n+    case TYPE_DECL:\n+      pp_cxx_identifier (pp, \"class\");\n+      if (DECL_NAME (parameter))\n+        pp_cxx_tree_identifier (pp, DECL_NAME (parameter));\n+      /* FIXME: Chech if we should print also default argument.  */\n+      break;\n+\n+    case PARM_DECL:\n+      pp_cxx_parameter_declaration (pp, parameter);\n+      break;\n+\n+    case TEMPLATE_DECL:\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n+}\n+\n+/*\n+  template-declaration:\n+     export(opt) template < template-parameter-list > declaration   */\n+static void\n+pp_cxx_template_declaration (cxx_pretty_printer *pp, tree t)\n+{\n+  tree tmpl = most_general_template (t);\n+  tree level;\n+  int i = 0;\n+\n+  pp_maybe_newline_and_indent (pp, 0);\n+  for (level = DECL_TEMPLATE_PARMS (tmpl); level; level = TREE_CHAIN (level))\n+    {\n+      pp_cxx_identifier (pp, \"template\");\n+      pp_cxx_begin_template_argument_list (pp);\n+      pp_cxx_template_parameter_list (pp, TREE_VALUE (level));\n+      pp_cxx_end_template_argument_list (pp);\n+      pp_newline_and_indent (pp, 3);\n+      i += 3;\n+    }\n+  if (TREE_CODE (t) == FUNCTION_DECL && DECL_SAVED_TREE (t))\n+    pp_cxx_function_definition (pp, t);\n+  else\n+    pp_cxx_simple_declaration (pp, t);\n+}\n+\n+static void\n+pp_cxx_explicit_specialization (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_unsupported_tree (pp, t);\n+}\n+\n+static void\n+pp_cxx_explicit_instantiation (cxx_pretty_printer *pp, tree t)\n+{\n+  pp_unsupported_tree (pp, t);\n+}\n+\n+/*\n+    declaration:\n+       block-declaration\n+       function-definition\n+       template-declaration\n+       explicit-instantiation\n+       explicit-specialization\n+       linkage-specification\n+       namespace-definition\n+\n+    block-declaration:\n+       simple-declaration\n+       asm-definition\n+       namespace-alias-definition\n+       using-declaration\n+       using-directive  */\n+void\n+pp_cxx_declaration (cxx_pretty_printer *pp, tree t)\n+{\n+  if (!DECL_LANG_SPECIFIC (t))\n+    pp_cxx_simple_declaration (pp, t);\n+  else if (DECL_USE_TEMPLATE (t) > 1)\n+    switch (DECL_USE_TEMPLATE (t))\n+      {\n+      case 2:\n+        pp_cxx_explicit_specialization (pp, t);\n+        break;\n+\n+      case 3:\n+        pp_cxx_explicit_instantiation (pp, t);\n+        break;\n+\n+      default:\n+        break;\n+      }\n+  else if (DECL_TEMPLATE_INFO (t))\n+    pp_cxx_template_declaration (pp, t);\n+  else switch (TREE_CODE (t))\n+    {\n+    case VAR_DECL:\n+    case TYPE_DECL:\n+      pp_cxx_simple_declaration (pp, t);\n+      break;\n+      \n+    case FUNCTION_DECL:\n+      if (DECL_SAVED_TREE (t))\n+        pp_cxx_function_definition (pp, t);\n+      else\n+        pp_cxx_simple_declaration (pp, t);\n+      break;\n+\n+    default:\n+      pp_unsupported_tree (pp, t);\n+      break;\n+    }\n+}\n+\n+\f\n+typedef c_pretty_print_fn pp_fun;\n+\n+void\n+pp_cxx_pretty_printer_init (cxx_pretty_printer *pp)\n+{\n+  pp_c_pretty_printer_init (pp_c_base (pp));\n+  pp_set_line_maximum_length (pp, 0);\n \n   pp->c_base.declaration = (pp_fun) pp_cxx_declaration;\n-  pp->c_base.declaration_specifiers = (pp_fun) pp_cxx_declaration_specifiers;\n-  pp->c_base.type_specifier = (pp_fun) pp_cxx_type_specifier;\n+  pp->c_base.declaration_specifiers = (pp_fun) pp_cxx_decl_specifier_seq;\n+  pp->c_base.function_specifier = (pp_fun) pp_cxx_function_specifier;\n+  pp->c_base.type_specifier_seq = (pp_fun) pp_cxx_type_specifier_seq;\n   pp->c_base.declarator = (pp_fun) pp_cxx_declarator;\n   pp->c_base.direct_declarator = (pp_fun) pp_cxx_direct_declarator;\n-  pp->c_base.parameter_declaration = (pp_fun) pp_cxx_parameter_declaration;\n+  pp->c_base.parameter_list = (pp_fun) pp_cxx_parameter_declaration_clause;\n   pp->c_base.type_id = (pp_fun) pp_cxx_type_id;\n-  pp->c_base.statement = (pp_fun) pp_cxx_statement;\n+  pp->c_base.abstract_declarator = (pp_fun) pp_cxx_abstract_declarator;\n+  pp->c_base.direct_abstract_declarator =\n+    (pp_fun) pp_cxx_direct_abstract_declarator;\n+  pp->c_base.simple_type_specifier = (pp_fun)pp_cxx_simple_type_specifier;\n+\n+  /* pp->c_base.statement = (pp_fun) pp_cxx_statement;  */\n+\n   pp->c_base.id_expression = (pp_fun) pp_cxx_id_expression;\n   pp->c_base.primary_expression = (pp_fun) pp_cxx_primary_expression;\n   pp->c_base.postfix_expression = (pp_fun) pp_cxx_postfix_expression;\n   pp->c_base.unary_expression = (pp_fun) pp_cxx_unary_expression;\n-  pp->c_base.initializer = (pp_fun) pp_cxx_initializer;\n   pp->c_base.multiplicative_expression = (pp_fun) pp_cxx_multiplicative_expression;\n   pp->c_base.conditional_expression = (pp_fun) pp_cxx_conditional_expression;\n   pp->c_base.assignment_expression = (pp_fun) pp_cxx_assignment_expression;\n-  pp->enclosing_scope = NULL;\n+  pp->c_base.expression = (pp_fun) pp_cxx_expression;\n+  pp->enclosing_scope = global_namespace;\n }"}, {"sha": "1fa0b99b6ff76c90da189670b9a3dd8afba7b8d2", "filename": "gcc/cp/cxx-pretty-print.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fcp%2Fcxx-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fcp%2Fcxx-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.h?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -31,20 +31,22 @@ typedef enum\n {\n   /* Ask for an qualified-id.  */\n   pp_cxx_flag_qualified_id = 1 << pp_c_flag_last_bit,\n-  pp_cxx_flag_global_scope = 1 << (pp_c_flag_last_bit + 1)\n+  pp_cxx_flag_global_scope = 1 << (pp_c_flag_last_bit + 1),\n+  pp_cxx_flag_default_argument = 1 << (pp_c_flag_last_bit + 2)\n   \n } cxx_pretty_printer_flags;\n \n typedef struct\n {\n-  struct c_pretty_print_info c_base;\n+  c_pretty_printer c_base;\n   /* This is the enclosing scope of the entity being pretty-printed.  */\n   tree enclosing_scope;\n } cxx_pretty_printer;\n \n void pp_cxx_pretty_printer_init (cxx_pretty_printer *);\n \n void pp_cxx_declaration (cxx_pretty_printer *, tree);\n+void pp_cxx_function_definition (cxx_pretty_printer *, tree);\n void pp_cxx_statement (cxx_pretty_printer *, tree);\n \n "}, {"sha": "80affe83e6faddb32669536ce9b2ea9f0c248a63", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12ea3302e694f467891a1ff072d5906d266413fc/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=12ea3302e694f467891a1ff072d5906d266413fc", "patch": "@@ -203,6 +203,8 @@ struct pretty_print_info\n     pp_base_indent (pp_base (PP));   \\\n     pp_needs_newline (PP) = false;   \\\n   } while (0)\n+#define pp_maybe_newline_and_indent(PP, N) \\\n+  if (pp_needs_newline (PP)) pp_newline_and_indent (PP, N)\n #define pp_separate_with(PP, C)     \\\n    do {                             \\\n      pp_character (PP, C);          \\"}]}