{"sha": "094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk0ZjA1NDQwNzA0NDQ5YmNmYWExM2ZhMWRhNmM2ZDgwZWQ2ZGRjNA==", "commit": {"author": {"name": "Vasiliy Fofanov", "email": "fofanov@adacore.com", "date": "2007-09-10T12:48:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-09-10T12:48:24Z"}, "message": "adaint.c (__gnat_translate_vms): new function.\n\n2007-09-10  Vasiliy Fofanov  <fofanov@adacore.com>\n\n\t* adaint.c (__gnat_translate_vms): new function.\n\nFrom-SVN: r128334", "tree": {"sha": "3d79afd81984840910bbbdced38e80c35cc54cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d79afd81984840910bbbdced38e80c35cc54cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/094f05440704449bcfaa13fa1da6c6d80ed6ddc4/comments", "author": {"login": "t-14", "id": 18482303, "node_id": "MDQ6VXNlcjE4NDgyMzAz", "avatar_url": "https://avatars.githubusercontent.com/u/18482303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/t-14", "html_url": "https://github.com/t-14", "followers_url": "https://api.github.com/users/t-14/followers", "following_url": "https://api.github.com/users/t-14/following{/other_user}", "gists_url": "https://api.github.com/users/t-14/gists{/gist_id}", "starred_url": "https://api.github.com/users/t-14/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/t-14/subscriptions", "organizations_url": "https://api.github.com/users/t-14/orgs", "repos_url": "https://api.github.com/users/t-14/repos", "events_url": "https://api.github.com/users/t-14/events{/privacy}", "received_events_url": "https://api.github.com/users/t-14/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36df551d433f5e505c7366b50c12d54ca33750b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36df551d433f5e505c7366b50c12d54ca33750b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36df551d433f5e505c7366b50c12d54ca33750b4"}], "stats": {"total": 130, "additions": 128, "deletions": 2}, "files": [{"sha": "dcc7c130c25a9114caa48a4d419646eb55895847", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 128, "deletions": 2, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/094f05440704449bcfaa13fa1da6c6d80ed6ddc4/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/094f05440704449bcfaa13fa1da6c6d80ed6ddc4/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=094f05440704449bcfaa13fa1da6c6d80ed6ddc4", "patch": "@@ -2356,6 +2356,132 @@ __gnat_to_canonical_file_list_free ()\n   new_canonical_filelist = 0;\n }\n \n+/* The functional equivalent of decc$translate_vms routine.\n+   Designed to produce the same output, but is protected against\n+   malformed paths (original version ACCVIOs in this case) and\n+   does not require VMS-specific DECC RTL */\n+\n+#define NAM$C_MAXRSS 1024\n+\n+char *\n+__gnat_translate_vms (char *src)\n+{\n+  static char retbuf [NAM$C_MAXRSS+1];\n+  char *srcendpos, *pos1, *pos2, *retpos;\n+  int disp, path_present = 0;\n+\n+  if (!src) return NULL;\n+\n+  srcendpos = strchr (src, '\\0');\n+  retpos = retbuf;\n+\n+  /* Look for the node and/or device in front of the path */\n+  pos1 = src;\n+  pos2 = strchr (pos1, ':');\n+\n+  if (pos2 && (pos2 < srcendpos) && (*(pos2 + 1) == ':')) {\n+    /* There is a node name. \"node_name::\" becomes \"node_name!\" */\n+    disp = pos2 - pos1;\n+    strncpy (retbuf, pos1, disp);\n+    retpos [disp] = '!';\n+    retpos = retpos + disp + 1;\n+    pos1 = pos2 + 2;\n+    pos2 = strchr (pos1, ':');\n+  }\n+\n+  if (pos2) {\n+    /* There is a device name. \"dev_name:\" becomes \"/dev_name/\" */\n+    *(retpos++) = '/';\n+    disp = pos2 - pos1;\n+    strncpy (retpos, pos1, disp);\n+    retpos = retpos + disp;\n+    pos1 = pos2 + 1;\n+    *(retpos++) = '/';\n+  }\n+  else\n+    /* No explicit device; we must look ahead and prepend /sys$disk/ if\n+       the path is absolute */\n+    if ((*pos1 == '[' || *pos1 == '<') && (pos1 < srcendpos)\n+        && !strchr (\".-]>\", *(pos1 + 1))) {\n+      strncpy (retpos, \"/sys$disk/\", 10);\n+      retpos += 10;\n+    }\n+\n+  /* Process the path part */\n+  while (*pos1 == '[' || *pos1 == '<') {\n+    path_present++;\n+    pos1++;\n+    if (*pos1 == ']' || *pos1 == '>') {\n+      /* Special case, [] translates to '.' */\n+      *(retpos++) = '.';\n+      pos1++;\n+    }\n+    else {\n+      /* '[000000' means root dir. It can be present in the middle of\n+         the path due to expansion of logical devices, in which case\n+         we skip it */\n+      if (!strncmp (pos1, \"000000\", 6) && path_present > 1 &&\n+         (*(pos1 + 6) == ']' || *(pos1 + 6) == '>' || *(pos1 + 6) == '.')) {\n+          pos1 += 6;\n+          if (*pos1 == '.') pos1++;\n+        }\n+      else if (*pos1 == '.') {\n+        /* Relative path */\n+        *(retpos++) = '.';\n+      }\n+\n+      /* There is qualified path */\n+      while (*pos1 != ']' && *pos1 != '>') {\n+        switch (*pos1) {\n+          case '.':\n+            /* '.' is used to separate directories. Replace it with '/' but\n+               only if there isn't already '/' just before */\n+            if (*(retpos - 1) != '/') *(retpos++) = '/';\n+            pos1++;\n+            if (pos1 + 1 < srcendpos && *pos1 == '.' && *(pos1 + 1) == '.') {\n+              /* ellipsis refers to entire subtree; replace with '**' */\n+              *(retpos++) = '*'; *(retpos++) = '*'; *(retpos++) = '/';\n+              pos1 += 2;\n+            }\n+            break;\n+          case '-' :\n+            /* Equivalent to Unix .. but there may be several in a row */\n+            while (*pos1 == '-') {\n+              pos1++;\n+              *(retpos++) = '.'; *(retpos++) = '.'; *(retpos++) = '/';\n+            }\n+            retpos--;\n+            break;\n+          default:\n+            *(retpos++) = *(pos1++);\n+        }\n+      }\n+      pos1++;\n+    }\n+  }\n+\n+  if (pos1 < srcendpos) {\n+    /* Now add the actual file name, until the version suffix if any */\n+    if (path_present) *(retpos++) = '/';\n+    pos2 = strchr (pos1, ';');\n+    disp = pos2? (pos2 - pos1) : (srcendpos - pos1);\n+    strncpy (retpos, pos1, disp);\n+    retpos += disp;\n+    if (pos2 && pos2 < srcendpos) {\n+      /* There is a non-empty version suffix. \";<ver>\" becomes \".<ver>\" */\n+      *retpos++ = '.';\n+      disp = srcendpos - pos2 - 1;\n+      strncpy (retpos, pos2 + 1, disp);\n+      retpos += disp;\n+    }\n+  }\n+\n+  *retpos = '\\0';\n+\n+  return retbuf;\n+\n+}\n+\n /* Translate a VMS syntax directory specification in to Unix syntax.  If\n    PREFIXFLAG is set, append an underscore \"/\". If no indicators of VMS syntax\n    found, return input string. Also translate a dirname that contains no\n@@ -2374,13 +2500,13 @@ __gnat_to_canonical_dir_spec (char *dirspec, int prefixflag)\n       if (strchr (dirspec, ']') || strchr (dirspec, ':'))\n \t{\n \t  strncpy (new_canonical_dirspec,\n-\t\t   (char *) decc$translate_vms (dirspec),\n+\t\t   __gnat_translate_vms (dirspec),\n \t\t   MAXPATH);\n \t}\n       else if (!strchr (dirspec, '/') && (dirspec1 = getenv (dirspec)) != 0)\n \t{\n \t  strncpy (new_canonical_dirspec,\n-\t\t  (char *) decc$translate_vms (dirspec1),\n+\t\t  __gnat_translate_vms (dirspec1),\n \t\t  MAXPATH);\n \t}\n       else"}]}