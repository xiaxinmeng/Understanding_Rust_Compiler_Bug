{"sha": "01a8cacc96f2b5c1df5be8af746f758006c11511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFhOGNhY2M5NmYyYjVjMWRmNWJlOGFmNzQ2Zjc1ODAwNmMxMTUxMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-06-09T09:40:45Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-06-09T09:40:45Z"}, "message": "re PR tree-optimization/66623 (Unsafe FP math reduction used in strict math mode)\n\n2017-06-09  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/66623\n\t* tree-vect-loop.c (vect_is_simple_reduction): Cleanup,\n\trefactor check_reduction into two parts, properly computing\n\twhether we have to check reduction validity for outer loop\n\tvectorization.\n\n\t* gcc.dg/vect/pr66623.c: New testcase.\n\nFrom-SVN: r249053", "tree": {"sha": "339497528e7d1d89348c234988e91391b5c9c97b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/339497528e7d1d89348c234988e91391b5c9c97b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01a8cacc96f2b5c1df5be8af746f758006c11511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a8cacc96f2b5c1df5be8af746f758006c11511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01a8cacc96f2b5c1df5be8af746f758006c11511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01a8cacc96f2b5c1df5be8af746f758006c11511/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6d1115c545d673a55f481425049ab263b58311eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d1115c545d673a55f481425049ab263b58311eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d1115c545d673a55f481425049ab263b58311eb"}], "stats": {"total": 212, "additions": 161, "deletions": 51}, "files": [{"sha": "05e6fbfdbdbc7204a8f88ef20e31a9a94e813f96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01a8cacc96f2b5c1df5be8af746f758006c11511", "patch": "@@ -1,3 +1,11 @@\n+2017-06-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66623\n+\t* tree-vect-loop.c (vect_is_simple_reduction): Cleanup,\n+\trefactor check_reduction into two parts, properly computing\n+\twhether we have to check reduction validity for outer loop\n+\tvectorization.\n+\n 2017-06-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/79483"}, {"sha": "7bef1b5435ee3d7fe2bce1b07e99f34f4145169b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=01a8cacc96f2b5c1df5be8af746f758006c11511", "patch": "@@ -1,3 +1,8 @@\n+2017-06-09  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/66623\n+\t* gcc.dg/vect/pr66623.c: New testcase.\n+\n 2017-06-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/79483"}, {"sha": "f90c673f82d330e5ebf77b20be8d98b34b6f6b05", "filename": "gcc/testsuite/gcc.dg/vect/pr66623.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66623.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66623.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr66623.c?ref=01a8cacc96f2b5c1df5be8af746f758006c11511", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+\n+#define OP *\n+#define INIT 1.0\n+\n+float __attribute__((noinline,noclone))\n+foo (float *__restrict__ i)\n+{\n+  float l = INIT;\n+  int a;\n+  int b;\n+\n+  for (a = 0; a < 4; a++)\n+    for (b = 0; b < 4; b++)\n+      l = l OP i[b];\n+\n+  return l;\n+}\n+\n+float __attribute__((noinline,noclone))\n+foo_ref (float *__restrict__ i)\n+{\n+  float l = INIT;\n+\n+  l = l OP i[0];\n+  l = l OP i[1];\n+  l = l OP i[2];\n+  l = l OP i[3];\n+\n+  l = l OP i[0];\n+  l = l OP i[1];\n+  l = l OP i[2];\n+  l = l OP i[3];\n+\n+  l = l OP i[0];\n+  l = l OP i[1];\n+  l = l OP i[2];\n+  l = l OP i[3];\n+\n+  l = l OP i[0];\n+  l = l OP i[1];\n+  l = l OP i[2];\n+  l = l OP i[3];\n+\n+  return l;\n+}\n+\n+union u\n+{\n+  float f;\n+  unsigned int u;\n+};\n+\n+int\n+main (void)\n+{\n+  union u res, res2;\n+  float a[4];\n+\n+  if (sizeof (float) != sizeof (unsigned int))\n+    return 0;\n+\n+  check_vect ();\n+\n+  a[0] = 0.01;\n+  a[1] = 0.01;\n+  a[2] = 0.01;\n+  a[3] = 1.0;\n+\n+  res.f = foo_ref (a);\n+\n+  res2.f = foo (a);\n+\n+  if (res.u != res2.u)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* need -ffast-math to vectorize this loop.  */\n+/* ARM NEON passes -ffast-math to these tests, so expect this to fail.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 0 loops\" 1 \"vect\" { xfail arm_neon_ok } } } */"}, {"sha": "64cf05dea577b139162289707c0ff224f12ea3ef", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01a8cacc96f2b5c1df5be8af746f758006c11511/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=01a8cacc96f2b5c1df5be8af746f758006c11511", "patch": "@@ -2727,8 +2727,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n {\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n-  edge latch_e = loop_latch_edge (loop);\n-  tree loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n   gimple *def_stmt, *def1 = NULL, *def2 = NULL, *phi_use_stmt = NULL;\n   enum tree_code orig_code, code;\n   tree op1, op2, op3 = NULL_TREE, op4 = NULL_TREE;\n@@ -2742,11 +2740,6 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n   *double_reduc = false;\n   *v_reduc_type = TREE_CODE_REDUCTION;\n \n-  /* Check validity of the reduction only for the innermost loop.  */\n-  bool check_reduction = ! flow_loop_nested_p (vect_loop, loop);\n-  gcc_assert ((check_reduction && loop == vect_loop)\n-              || (!check_reduction && flow_loop_nested_p (vect_loop, loop)));\n-\n   name = PHI_RESULT (phi);\n   /* ???  If there are no uses of the PHI result the inner loop reduction\n      won't be detected as possibly double-reduction by vectorizable_reduction\n@@ -2775,13 +2768,15 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"reduction used in loop.\\n\");\n+\t\t\t     \"reduction value used in loop.\\n\");\n           return NULL;\n         }\n \n       phi_use_stmt = use_stmt;\n     }\n \n+  edge latch_e = loop_latch_edge (loop);\n+  tree loop_arg = PHI_ARG_DEF_FROM_EDGE (phi, latch_e);\n   if (TREE_CODE (loop_arg) != SSA_NAME)\n     {\n       if (dump_enabled_p ())\n@@ -2795,18 +2790,22 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n     }\n \n   def_stmt = SSA_NAME_DEF_STMT (loop_arg);\n-  if (!def_stmt)\n+  if (gimple_nop_p (def_stmt))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"reduction: no def_stmt.\\n\");\n+\t\t\t \"reduction: no def_stmt\\n\");\n       return NULL;\n     }\n \n   if (!is_gimple_assign (def_stmt) && gimple_code (def_stmt) != GIMPLE_PHI)\n     {\n       if (dump_enabled_p ())\n-\tdump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t   \"reduction: unhandled reduction operation: \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, def_stmt, 0);\n+\t}\n       return NULL;\n     }\n \n@@ -2822,13 +2821,17 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n     }\n \n   nloop_uses = 0;\n+  auto_vec<gphi *, 3> lcphis;\n   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, name)\n     {\n       gimple *use_stmt = USE_STMT (use_p);\n       if (is_gimple_debug (use_stmt))\n \tcontinue;\n       if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n \tnloop_uses++;\n+      else\n+\t/* We can have more than one loop-closed PHI.  */\n+\tlcphis.safe_push (as_a <gphi *> (use_stmt));\n       if (nloop_uses > 1)\n \t{\n \t  if (dump_enabled_p ())\n@@ -2873,6 +2876,27 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n       return NULL;\n     }\n \n+  /* If we are vectorizing an inner reduction we are executing that\n+     in the original order only in case we are not dealing with a\n+     double reduction.  */\n+  bool check_reduction = true;\n+  if (flow_loop_nested_p (vect_loop, loop))\n+    {\n+      gphi *lcphi;\n+      unsigned i;\n+      check_reduction = false;\n+      FOR_EACH_VEC_ELT (lcphis, i, lcphi)\n+\tFOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_phi_result (lcphi))\n+\t  {\n+\t    gimple *use_stmt = USE_STMT (use_p);\n+\t    if (is_gimple_debug (use_stmt))\n+\t      continue;\n+\t    if (! flow_bb_inside_loop_p (vect_loop, gimple_bb (use_stmt)))\n+\t      check_reduction = true;\n+\t  }\n+    }\n+\n+  bool nested_in_vect_loop = flow_loop_nested_p (vect_loop, loop);\n   code = orig_code = gimple_assign_rhs_code (def_stmt);\n \n   /* We can handle \"res -= x[i]\", which is non-associative by\n@@ -2887,27 +2911,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n \n   if (code == COND_EXPR)\n     {\n-      if (check_reduction)\n+      if (! nested_in_vect_loop)\n \t*v_reduc_type = COND_REDUCTION;\n-    }\n-  else if (!commutative_tree_code (code) || !associative_tree_code (code))\n-    {\n-      if (dump_enabled_p ())\n-\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t\"reduction: not commutative/associative: \");\n-      return NULL;\n-    }\n-\n-  if (get_gimple_rhs_class (code) != GIMPLE_BINARY_RHS)\n-    {\n-      if (code != COND_EXPR)\n-        {\n-\t  if (dump_enabled_p ())\n-\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"reduction: not binary operation: \");\n-\n-          return NULL;\n-        }\n \n       op3 = gimple_assign_rhs1 (def_stmt);\n       if (COMPARISON_CLASS_P (op3))\n@@ -2918,30 +2923,35 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n \n       op1 = gimple_assign_rhs2 (def_stmt);\n       op2 = gimple_assign_rhs3 (def_stmt);\n-\n-      if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n-        {\n-          if (dump_enabled_p ())\n-            report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"reduction: uses not ssa_names: \");\n-\n-          return NULL;\n-        }\n     }\n-  else\n+  else if (!commutative_tree_code (code) || !associative_tree_code (code))\n+    {\n+      if (dump_enabled_p ())\n+\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\"reduction: not commutative/associative: \");\n+      return NULL;\n+    }\n+  else if (get_gimple_rhs_class (code) == GIMPLE_BINARY_RHS)\n     {\n       op1 = gimple_assign_rhs1 (def_stmt);\n       op2 = gimple_assign_rhs2 (def_stmt);\n+    }\n+  else\n+    {\n+      if (dump_enabled_p ())\n+\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\"reduction: not handled operation: \");\n+      return NULL;\n+    }\n \n-      if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n-        {\n-          if (dump_enabled_p ())\n-\t    report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n-\t\t\t    \"reduction: uses not ssa_names: \");\n+  if (TREE_CODE (op1) != SSA_NAME && TREE_CODE (op2) != SSA_NAME)\n+    {\n+      if (dump_enabled_p ())\n+\treport_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,\n+\t\t\t\"reduction: both uses not ssa_names: \");\n \n-          return NULL;\n-        }\n-   }\n+      return NULL;\n+    }\n \n   type = TREE_TYPE (gimple_assign_lhs (def_stmt));\n   if ((TREE_CODE (op1) == SSA_NAME\n@@ -3091,7 +3101,7 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n \t\t\t   == vect_internal_def\n \t\t      && !is_loop_header_bb_p (gimple_bb (def2)))))))\n     {\n-      if (check_reduction && orig_code != MINUS_EXPR)\n+      if (! nested_in_vect_loop && orig_code != MINUS_EXPR)\n \t{\n \t  /* Check if we can swap operands (just for simplicity - so that\n \t     the rest of the code can assume that the reduction variable\n@@ -3145,7 +3155,8 @@ vect_is_simple_reduction (loop_vec_info loop_info, gimple *phi,\n     }\n \n   /* Try to find SLP reduction chain.  */\n-  if (check_reduction && code != COND_EXPR\n+  if (! nested_in_vect_loop\n+      && code != COND_EXPR\n       && vect_is_slp_reduction (loop_info, phi, def_stmt))\n     {\n       if (dump_enabled_p ())"}]}