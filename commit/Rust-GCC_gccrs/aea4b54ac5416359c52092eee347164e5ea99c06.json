{"sha": "aea4b54ac5416359c52092eee347164e5ea99c06", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhNGI1NGFjNTQxNjM1OWM1MjA5MmVlZTM0NzE2NGU1ZWE5OWMwNg==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2017-11-14T14:09:57Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2017-11-14T14:09:57Z"}, "message": "[Patch AArch64] Stop generating BSL for simple integer code\n\nTurn aarch64_simd_bsldi_internal in to an insn_and_split that\nknows to split back to integer operations if the register allocation\nfalls that way. Do this to avoid having to move between integer and\nAdvanced SIMD register files just for a single BSL.\n\n---\ngcc/\n\n\t* config/aarch64/aarch64-simd.md\n\t(aarch64_simd_bsl<mode>_internal): Remove DImode.\n\t(*aarch64_simd_bsl<mode>_alt): Likewise.\n\t(aarch64_simd_bsldi_internal): New.\n\t(aarch64_simd_bsldi_alt): Likewise.\n\ngcc/testsuite/\n\n\t* gcc.target/aarch64/bsl-idiom.c: New.\n\t* gcc.target/aarch64/copysign-bsl.c: New.\n\nFrom-SVN: r254727", "tree": {"sha": "ef79035422c96dff4aca96d83145a4a57504faa6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef79035422c96dff4aca96d83145a4a57504faa6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aea4b54ac5416359c52092eee347164e5ea99c06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea4b54ac5416359c52092eee347164e5ea99c06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea4b54ac5416359c52092eee347164e5ea99c06", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea4b54ac5416359c52092eee347164e5ea99c06/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fee234f10fa45066a0a50a3312a642fe8c6c17b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fee234f10fa45066a0a50a3312a642fe8c6c17b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fee234f10fa45066a0a50a3312a642fe8c6c17b5"}], "stats": {"total": 236, "additions": 222, "deletions": 14}, "files": [{"sha": "af60aedf97a43f0e48b34ab969b37449f71f6030", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aea4b54ac5416359c52092eee347164e5ea99c06", "patch": "@@ -1,3 +1,11 @@\n+2017-11-14  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-simd.md\n+\t(aarch64_simd_bsl<mode>_internal): Remove DImode.\n+\t(*aarch64_simd_bsl<mode>_alt): Likewise.\n+\t(aarch64_simd_bsldi_internal): New.\n+\t(aarch64_simd_bsldi_alt): Likewise.\n+\n 2017-11-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tracer.c (better_p): Do not compare frequencies."}, {"sha": "9e7e557ee9eb85de5f3ce611cb37e551367e14ac", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 108, "deletions": 14, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=aea4b54ac5416359c52092eee347164e5ea99c06", "patch": "@@ -2419,13 +2419,13 @@\n ;; in *aarch64_simd_bsl<mode>_alt.\n \n (define_insn \"aarch64_simd_bsl<mode>_internal\"\n-  [(set (match_operand:VSDQ_I_DI 0 \"register_operand\" \"=w,w,w\")\n-\t(xor:VSDQ_I_DI\n-\t   (and:VSDQ_I_DI\n-\t     (xor:VSDQ_I_DI\n+  [(set (match_operand:VDQ_I 0 \"register_operand\" \"=w,w,w\")\n+\t(xor:VDQ_I\n+\t   (and:VDQ_I\n+\t     (xor:VDQ_I\n \t       (match_operand:<V_INT_EQUIV> 3 \"register_operand\" \"w,0,w\")\n-\t       (match_operand:VSDQ_I_DI 2 \"register_operand\" \"w,w,0\"))\n-\t     (match_operand:VSDQ_I_DI 1 \"register_operand\" \"0,w,w\"))\n+\t       (match_operand:VDQ_I 2 \"register_operand\" \"w,w,0\"))\n+\t     (match_operand:VDQ_I 1 \"register_operand\" \"0,w,w\"))\n \t  (match_dup:<V_INT_EQUIV> 3)\n \t))]\n   \"TARGET_SIMD\"\n@@ -2443,14 +2443,14 @@\n ;; permutations of commutative operations, we have to have a separate pattern.\n \n (define_insn \"*aarch64_simd_bsl<mode>_alt\"\n-  [(set (match_operand:VSDQ_I_DI 0 \"register_operand\" \"=w,w,w\")\n-\t(xor:VSDQ_I_DI\n-\t   (and:VSDQ_I_DI\n-\t     (xor:VSDQ_I_DI\n-\t       (match_operand:VSDQ_I_DI 3 \"register_operand\" \"w,w,0\")\n-\t       (match_operand:VSDQ_I_DI 2 \"register_operand\" \"w,0,w\"))\n-\t      (match_operand:VSDQ_I_DI 1 \"register_operand\" \"0,w,w\"))\n-\t  (match_dup:VSDQ_I_DI 2)))]\n+  [(set (match_operand:VDQ_I 0 \"register_operand\" \"=w,w,w\")\n+\t(xor:VDQ_I\n+\t   (and:VDQ_I\n+\t     (xor:VDQ_I\n+\t       (match_operand:VDQ_I 3 \"register_operand\" \"w,w,0\")\n+\t       (match_operand:<V_INT_EQUIV> 2 \"register_operand\" \"w,0,w\"))\n+\t      (match_operand:VDQ_I 1 \"register_operand\" \"0,w,w\"))\n+\t  (match_dup:<V_INT_EQUIV> 2)))]\n   \"TARGET_SIMD\"\n   \"@\n   bsl\\\\t%0.<Vbtype>, %3.<Vbtype>, %2.<Vbtype>\n@@ -2459,6 +2459,100 @@\n   [(set_attr \"type\" \"neon_bsl<q>\")]\n )\n \n+;; DImode is special, we want to avoid computing operations which are\n+;; more naturally computed in general purpose registers in the vector\n+;; registers.  If we do that, we need to move all three operands from general\n+;; purpose registers to vector registers, then back again.  However, we\n+;; don't want to make this pattern an UNSPEC as we'd lose scope for\n+;; optimizations based on the component operations of a BSL.\n+;;\n+;; That means we need a splitter back to the individual operations, if they\n+;; would be better calculated on the integer side.\n+\n+(define_insn_and_split \"aarch64_simd_bsldi_internal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w,w,w,&r\")\n+\t(xor:DI\n+\t   (and:DI\n+\t     (xor:DI\n+\t       (match_operand:DI 3 \"register_operand\" \"w,0,w,r\")\n+\t       (match_operand:DI 2 \"register_operand\" \"w,w,0,r\"))\n+\t     (match_operand:DI 1 \"register_operand\" \"0,w,w,r\"))\n+\t  (match_dup:DI 3)\n+\t))]\n+  \"TARGET_SIMD\"\n+  \"@\n+  bsl\\\\t%0.8b, %2.8b, %3.8b\n+  bit\\\\t%0.8b, %2.8b, %1.8b\n+  bif\\\\t%0.8b, %3.8b, %1.8b\n+  #\"\n+  \"&& GP_REGNUM_P (REGNO (operands[0]))\"\n+  [(match_dup 1) (match_dup 1) (match_dup 2) (match_dup 3)]\n+{\n+  /* Split back to individual operations.  If we're before reload, and\n+     able to create a temporary register, do so.  If we're after reload,\n+     we've got an early-clobber destination register, so use that.\n+     Otherwise, we can't create pseudos and we can't yet guarantee that\n+     operands[0] is safe to write, so FAIL to split.  */\n+\n+  rtx scratch;\n+  if (reload_completed)\n+    scratch = operands[0];\n+  else if (can_create_pseudo_p ())\n+    scratch = gen_reg_rtx (DImode);\n+  else\n+    FAIL;\n+\n+  emit_insn (gen_xordi3 (scratch, operands[2], operands[3]));\n+  emit_insn (gen_anddi3 (scratch, scratch, operands[1]));\n+  emit_insn (gen_xordi3 (operands[0], scratch, operands[3]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"neon_bsl,neon_bsl,neon_bsl,multiple\")\n+   (set_attr \"length\" \"4,4,4,12\")]\n+)\n+\n+(define_insn_and_split \"aarch64_simd_bsldi_alt\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=w,w,w,&r\")\n+\t(xor:DI\n+\t   (and:DI\n+\t     (xor:DI\n+\t       (match_operand:DI 3 \"register_operand\" \"w,w,0,r\")\n+\t       (match_operand:DI 2 \"register_operand\" \"w,0,w,r\"))\n+\t     (match_operand:DI 1 \"register_operand\" \"0,w,w,r\"))\n+\t  (match_dup:DI 2)\n+\t))]\n+  \"TARGET_SIMD\"\n+  \"@\n+  bsl\\\\t%0.8b, %3.8b, %2.8b\n+  bit\\\\t%0.8b, %3.8b, %1.8b\n+  bif\\\\t%0.8b, %2.8b, %1.8b\n+  #\"\n+  \"&& GP_REGNUM_P (REGNO (operands[0]))\"\n+  [(match_dup 0) (match_dup 1) (match_dup 2) (match_dup 3)]\n+{\n+  /* Split back to individual operations.  If we're before reload, and\n+     able to create a temporary register, do so.  If we're after reload,\n+     we've got an early-clobber destination register, so use that.\n+     Otherwise, we can't create pseudos and we can't yet guarantee that\n+     operands[0] is safe to write, so FAIL to split.  */\n+\n+  rtx scratch;\n+  if (reload_completed)\n+    scratch = operands[0];\n+  else if (can_create_pseudo_p ())\n+    scratch = gen_reg_rtx (DImode);\n+  else\n+    FAIL;\n+\n+  emit_insn (gen_xordi3 (scratch, operands[2], operands[3]));\n+  emit_insn (gen_anddi3 (scratch, scratch, operands[1]));\n+  emit_insn (gen_xordi3 (operands[0], scratch, operands[2]));\n+  DONE;\n+}\n+  [(set_attr \"type\" \"neon_bsl,neon_bsl,neon_bsl,multiple\")\n+   (set_attr \"length\" \"4,4,4,12\")]\n+)\n+\n (define_expand \"aarch64_simd_bsl<mode>\"\n   [(match_operand:VALLDIF 0 \"register_operand\")\n    (match_operand:<V_INT_EQUIV> 1 \"register_operand\")"}, {"sha": "825623e989213353aea6126bc91734eeaddd1130", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aea4b54ac5416359c52092eee347164e5ea99c06", "patch": "@@ -1,3 +1,8 @@\n+2017-11-14  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* gcc.target/aarch64/bsl-idiom.c: New.\n+\t* gcc.target/aarch64/copysign-bsl.c: New.\n+\n 2017-11-14  Tom de Vries  <tom@codesourcery.com>\n \n \t* c-c++-common/Wstringop-truncation.c: Require effective target alloca."}, {"sha": "8151387600f108d5da9c8a244aea916d7474a2b0", "filename": "gcc/testsuite/gcc.target/aarch64/bsl-idiom.c", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbsl-idiom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbsl-idiom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fbsl-idiom.c?ref=aea4b54ac5416359c52092eee347164e5ea99c06", "patch": "@@ -0,0 +1,88 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-rtl-combine --save-temps\" } */\n+\n+/* Test that we don't generate BSL when in DImode with values in integer\n+   registers, and do generate it where we have values in floating-point\n+   registers.  This is useful, as it allows us to avoid register moves\n+   in the general case.\n+\n+   We want:\n+\teor\tx0, x0, x1\n+\tand\tx0, x0, x2\n+\teor\tx0, x0, x1\n+\tret\n+\n+   Rather than:\n+\tfmov\td2, x0\n+\tfmov\td0, x2\n+\tfmov\td1, x1\n+\tbsl\tv0.8b, v2.8b, v1.8b\n+\tfmov\tx0, d0\n+\tret  */\n+\n+extern void abort (void);\n+\n+unsigned long long __attribute__ ((noinline))\n+foo (unsigned long long a, unsigned long long b, unsigned long long c)\n+{\n+  return ((a ^ b) & c) ^ b;\n+}\n+\n+unsigned long long __attribute__ ((noinline))\n+foo2 (unsigned long long a, unsigned long long b, unsigned long long c)\n+{\n+  return ((a ^ b) & c) ^ a;\n+}\n+\n+#define force_simd(V1)   asm volatile (\"mov %d0, %1.d[0]\"\t\\\n+\t   : \"=w\"(V1)\t\t\t\t\t\t\\\n+\t   : \"w\"(V1)\t\t\t\t\t\t\\\n+\t   : /* No clobbers */);\n+\n+unsigned long long __attribute__ ((noinline))\n+bar (unsigned long long a, unsigned long long b, unsigned long long c)\n+{\n+  force_simd (a);\n+  force_simd (b);\n+  force_simd (c);\n+  c = ((a ^ b) & c) ^ b;\n+  force_simd (c);\n+  return c;\n+}\n+\n+unsigned long long __attribute__ ((noinline))\n+bar2 (unsigned long long a, unsigned long long b, unsigned long long c)\n+{\n+  force_simd (a);\n+  force_simd (b);\n+  force_simd (c);\n+  c = ((a ^ b) & c) ^ a;\n+  force_simd (c);\n+  return c;\n+}\n+\n+int\n+main (int argc, char** argv)\n+{\n+  unsigned long long a = 0x0123456789abcdefULL;\n+  unsigned long long b = 0xfedcba9876543210ULL;\n+  unsigned long long c = 0xaabbccddeeff7777ULL;\n+  if (foo (a, b, c) != bar (a, b, c))\n+    abort ();\n+  if (foo2 (a, b, c) != bar2 (a, b, c))\n+    abort ();\n+  return 0;\n+}\n+\n+/* 2 BSL, 6 FMOV (to floating-point registers), and 2 FMOV (to general\n+purpose registers) for the \"bar\" tests, which should still use BSL.  */\n+/* { dg-final { scan-assembler-times \"bsl\\tv\\[0-9\\]\" 2 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\td\\[0-9\\]\" 6 } } */\n+/* { dg-final { scan-assembler-times \"fmov\\tx\\[0-9\\]\" 2 } } */\n+\n+/* { dg-final { scan-assembler-not \"bif\\tv\\[0-9\\]\" } } */\n+/* { dg-final { scan-assembler-not \"bit\\tv\\[0-9\\]\" } } */\n+\n+/* We always match the idiom during combine.  */\n+/* { dg-final { scan-rtl-dump-times \"aarch64_simd_bsldi_internal\" 2 \"combine\" } } */\n+/* { dg-final { scan-rtl-dump-times \"aarch64_simd_bsldi_alt\" 2 \"combine\" } } */"}, {"sha": "0ec7109c7387794d198f2a5b1a6fb5c6e98d73c9", "filename": "gcc/testsuite/gcc.target/aarch64/copysign-bsl.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcopysign-bsl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea4b54ac5416359c52092eee347164e5ea99c06/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcopysign-bsl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fcopysign-bsl.c?ref=aea4b54ac5416359c52092eee347164e5ea99c06", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+/* Test that we can generate DImode BSL when we are using\n+   copysign.  */\n+\n+double\n+foo (double a, double b)\n+{\n+  return __builtin_copysign (a, b);\n+}\n+\n+/* { dg-final { scan-assembler \"b\\(sl|it|if\\)\\tv\\[0-9\\]\" } } */"}]}