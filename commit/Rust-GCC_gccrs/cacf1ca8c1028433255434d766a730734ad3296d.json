{"sha": "cacf1ca8c1028433255434d766a730734ad3296d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FjZjFjYThjMTAyODQzMzI1NTQzNGQ3NjZhNzMwNzM0YWQzMjk2ZA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2009-06-23T20:15:15Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2009-06-23T20:15:15Z"}, "message": "Step 1 of VSX changes: Powerpc infrstructure changes\n\nCo-Authored-By: Pat Haugen <pthaugen@us.ibm.com>\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r148869", "tree": {"sha": "f2c6a26e3f34541a7cb8bbb7704f8c0bef5bb674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2c6a26e3f34541a7cb8bbb7704f8c0bef5bb674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cacf1ca8c1028433255434d766a730734ad3296d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacf1ca8c1028433255434d766a730734ad3296d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cacf1ca8c1028433255434d766a730734ad3296d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cacf1ca8c1028433255434d766a730734ad3296d/comments", "author": null, "committer": null, "parents": [{"sha": "59ab92d2918a7e7ee914bf86cff5bcbabb68d9b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ab92d2918a7e7ee914bf86cff5bcbabb68d9b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ab92d2918a7e7ee914bf86cff5bcbabb68d9b9"}], "stats": {"total": 1581, "additions": 1327, "deletions": 254}, "files": [{"sha": "ea2ca5304ca073796b1181bca116af8246a0a3be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,3 +1,181 @@\n+2009-06-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\t    Pat Haugen  <pthaugen@us.ibm.com>\n+\t    Revital1 Eres <ERES@il.ibm.com>\n+\n+\t* config.in (HAVE_AS_POPCNTD): Add default definition.\n+\t(HAVE_AS_LWSYNC): Ditto.\n+\n+\t* configure.ac (gcc_cv_as_powerpc_mfpgpr): Provide real binutils\n+\trelease number.\n+\t(gcc_cv_as_powerpc_cmpb): Ditto.\n+\t(gcc_cv_as_powerpc_dfp): Ditto.\n+\t(gcc_cv_as_powerpc_vsx): Ditto.\n+\t(gcc_cv_as_powerpc_popcntd): Add feature test for assembler\n+\tsupporting the popcntd/lwsync instructions.\n+\t(gcc_cv_as_powerpc_lwsync): Ditto.\n+\t* configure: Regenerate.\n+\n+\t* config/rs6000/aix53.h (ASM_CPU_SPEC): Add support for\n+\t-mcpu=native and -mcpu=power7.\n+\t* config/rs6000/aix61.h (ASM_CPU_SPEC): Ditto.\n+\n+\t* config/rs6000/linux64.opt (-mprofile-kernel): Move switch to be\n+\ta variable instead of a mask to reduce the number of mask bits.\n+\t* config/rs6000/sysv4.opt (-mbit-align): Ditto.\n+\t(-mbit-word): Ditto.\n+\t(-mregnames): Ditto.\n+\t* config/rs6000/rs6000.opt (-mupdate): Ditto.\n+\t(-mfused-madd): Ditto.\n+\n+\t* config/rs6000/rs6000.opt (-mpopcntd): New switch for non-VSX ISA\n+\t2.06 instructions.\n+\t(-mvsx): New switch for VSX instructions.\n+\t(-misel): Move from a variable to a mask to allow it to be set by\n+\t-mcpu=.\n+\n+\t* config/rs6000/rs6000-protos.h (rs6000_hard_regno_nregs): Change\n+\tfunction declaration to an array declaration.\n+\t(rs6000_hard_regno_nregs): New external array declaration.\n+\n+\t* config/rs6000/t-rs6000 (MD_INCLUDES): Define, add all of the .md\n+\tfiles included by rs6000.md.\n+\n+\t* config/rs6000/linux64.h (SUBSUBTARGET_OVERRIDE_OPTIONS): Use\n+\tSET_PROFILE_KERNEL macro to reset the -mprofile-kernel switch.\n+\n+\t* config/rs6000/rs6000.c (rs6000_isel): Delete, -misel moved to be\n+\ta target mask.\n+\t(rs6000_debug_reg): New -mdebug= variables.\n+\t(rs6000_debug_addr): Ditto.\n+\t(rs6000_debug_cost): Ditto.\n+\t(rs6000_pmode): New variable to hold Pmode.\n+\t(rs6000_pointer_size): New variable to hold POINTER_SIZE.\n+\t(rs6000_class_max_nregs): New array to hold CLASS_MAX_NREGS\n+\tcalculated at compiler start.\n+\t(rs6000_hard_regno_nregs): Change function to an array which holds\n+\tHARD_REGNO_NREGS calculated at compiler start.\n+\t(rs6000_explicit_options): Delete isel field.\n+\t(rs6000_vector_unit): New array to hold which vector unit\n+\tsupports arithmetic options for a given type.\n+\t(rs6000_vector_mem): New array to hold which vector unit supports\n+\tmemory reference operations for a given type.\n+\t(rs6000_vector_align): New array to given the alignment of each\n+\tvector type.\n+\t(power7_cost): New basic costs for power7.\n+\t(SET_PROFILE_KERNEL): New macro for resetting -mprofile-kernel.\n+\t(rs6000_hard_regno_nregs_internal): New function, moved from\n+\tHARD_REGNO_NREGS, to calculate the number of registers each hard\n+\tregister takes for each type.\n+\t(rs6000_debug_reg_print): New function for -mdebug=reg support.\n+\t(rs6000_debug_vector_unit): New array, map rs6000_vector to\n+\tstring.\n+\t(+rs6000_init_hard_regno_mode_ok): New function, move calculation\n+\tof HARD_REGNO_NREGS, CLASS_MAX_NREGS, REGNO_REG_CLASS, and vector\n+\tunit information here so it is calculated once at compiler startup\n+\ttime.\n+\t(rs6000_override_options): Make -misel a target mask.  Add more\n+\tpower7 target masks.  Setup Pmode and POINTER_SIZE.  Add initial\n+\tVSX support.  Add support for -mdebug=reg, -mdebug=addr, and\n+\t-mdebug=cost.\n+\t(POWERPC_MASKS): Add MASK_POPCNTD, MASK_VSX, and MASK_ISEL.\n+\t(rs6000_handle_option): Move -misel from variable to target mask.\n+\t(rs6000_builtin_mask_for_load): Add VSX support.\n+\t(rs6000_conditional_register_usage): Ditto.\n+\t(USE_ALTIVEC_FOR_ARG_P): Ditto.\n+\t(function_arg_boundary): Ditto.\n+\t(rs6000_expand_builtin): Ditto.\n+\t(def_builtin): Make abort message a little friendlier.\n+\t(rs6000_emit_int_cmove): Add support for 64-bit isel.\n+\n+\t* config/rs6000/rs6000.h (ASM_CPU_POWER7_SPEC): Depend on the\n+\tassembler support the popcntd instruction instead of a vsx\n+\tinstruction to enable power7 support.\n+\t(ASM_CPU_SPEC): Add support for -mcpu=native and -mcpu=power7.\n+\t(EXTRA_SPECS): Add ASM_CPU_NATIVE_SPEC to allow passing the right\n+\toption to the assembler if -mcpu=native.\n+\t(ASM_CPU_NATIVE_SPEC): Ditto.\n+\t(TARGET_POPCNTD): If assembler doesn't support popcntd, turn off\n+\tISA 2.06 features.\n+\t(TARGET_LWSYNC_INSTRUCTION): Define whether it is safe to issue\n+\tthe lwsync instruction.\n+\t(enum processor_type): Add PROCESSOR_POWER7.\n+\t(rs6000_debug_reg): New -mdebug= options.\n+\t(rs6000_debug_addr): Ditto.\n+\t(rs6000_debug_cost): Ditto.\n+\t(rs6000_isel): Delete.\n+\t(enum rs6000_vector): New enum to say what vector unit we have.\n+\t(VECTOR_UNIT_*): New macros to say which vector unit has\n+\tarithmetic operations for a given type.\n+\t(VECTOR_MEM_*): New macros to say which vector unit has memory\n+\toperations for a given type.\n+\t(TARGET_LDBRX): Whether the machine supports the ldbrx\n+\tinstruction.\n+\t(TARGET_ISEL): Delete, -misel moved to be a mask.\n+\t(TARGET_ISEL64): New macro for 64-bit isel support.\n+\t(UNITS_PER_VSX_WORD): New macro.\n+\t(POINTER_SIZE): Move to be an external variable, rather than\n+\tcalculating whether we are generating 32 ot 64-bit code.\n+\t(Pmode): Ditto.\n+\t(STACK_BOUNDARY): Add VSX support.\n+\t(LOCAL_ALIGNMENT): Ditto.\n+\t(SLOW_UNALIGNED_ACCESS): Ditto.\n+\t(VSX_REGNO_P): New macro for VSX support.\n+\t(VFLOAT_REGNO_P): Ditto.\n+\t(VINT_REGNO_P): Ditto.\n+\t(VLOGICAL_REGNO_P): Ditto.\n+\t(VSX_VECTOR_MODE): Ditto.\n+\t(VSX_SCALAR_MODE): Ditto.\n+\t(VSX_MODE): Ditto.\n+\t(VSX_MOVE_MODE): Ditto.\n+\t(VSX_REG_CLASS_P): Ditto.\n+\t(HARD_REGNO_NREGS): Instead of calling a function, use an array\n+\tlookup.\n+\t(UNITS_PER_SIMD_WORD): Add VSX support.\n+\t(MODES_TIEABLE_P): Ditto.\n+\t(STARTING_FRAME_OFFSET): Ditto.\n+\t(STACK_DYNAMIC_OFFSET): Ditto.\n+\t(EPILOGUE_USES): Ditto.\n+\t(REGNO_REG_CLASS): Move to array lookup.\n+\t(CLASS_MAX_NREGS): Ditto.\n+\t(rs6000_vector_reg_class): Add declaration.\n+\t(ADDITIONAL_REGISTER_NAMES): Add VSX names for the registers that\n+\toverlap with the floating point and Altivec registers.\n+\n+\t* config/rs6000/e500.h (CHECK_E500_OPTIONS): Disallow -mvsx.\n+\n+\t* config/rs6000/driver-rs6000.c (asm_names): New static array to\n+\tgive the appropriate asm switches if -mcpu=native.\n+\t(host_detect_local_cpu): Add support for \"asm\".\n+\t(host_detect_local_cpu): Follow GNU code guidelines for name.\n+\n+\t* config/rs6000/sysv4.h (SUBTARGET_OVERRIDE_OPTIONS): Move\n+\t-mbit-word to a variable instead of being a target mask.\n+\n+\t* config/rs6000/sync.md (lwsync): If the assembler supports it,\n+\temit the lwsync instruction instead of emitting the instruction as\n+\tan integer constant.\n+\n+\t* config/rs6000/spe.md (spe_fixuns_truncdfsi2): Rename from\n+\tfixuns_trundfsi2, move expander into rs6000.md.\n+\n+\t* config/rs6000/rs6000.md (cpu): Add power7.\n+\t(sel, *ptrsize): New mode attributes for 32/64-bit isel.\n+\t(logical predicate patterns): Change the single instruction\n+\tprimitives that set CR0 to be fast_compare instead of compare.\n+\t(norsi*): Ditto.\n+\t(popcntwsi2): Add support for ISA 2.06 popcount instructions.\n+\t(popcntddi2): Ditto.\n+\t(popcount<mode>): Ditto.\n+\t(floating multiply/add insns): Name the floating point\n+\tmultiply/add insns.\n+\t(isel_signed_<mode>): Add support for -misel on 64-bit systems.\n+\t(isel_unsigned_<mode>): Ditto.\n+\t(fixuns_trundfsi2): Move expander here from spe.md.\n+\t(smindi3): Define if we have -misel on 64-bit systems.\n+\t(smaxdi3): Ditto.\n+\t(umindi3): Ditto.\n+\t(umaxdi3): Ditto.\n+\n 2009-06-23  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config.gcc (avr-*-rtems*, avr-*-*): Set extra_gcc_objs and"}, {"sha": "cc0202beec27258658853331cd5adf0ae73a4b8c", "filename": "gcc/config.in", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -351,12 +351,23 @@\n #endif\n \n \n-/* Define if your assembler supports popcntb field. */\n+/* Define if your assembler supports popcntb instruction. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_POPCNTB\n #endif\n \n \n+/* Define if your assembler supports popcntd instruction. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_POPCNTD\n+#endif\n+\n+/* Define if your assembler supports lwsync instruction. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_LWSYNC\n+#endif\n+\n+\n /* Define if your assembler supports .register. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_REGISTER_PSEUDO_OP"}, {"sha": "b7b1eec9adf952e296233d3932c9527c70b92d16", "filename": "gcc/config/rs6000/aix53.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Faix53.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Faix53.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix53.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for IBM RS/6000 POWER running AIX V5.3.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by David Edelsohn (edelsohn@gnu.org).\n \n@@ -57,20 +57,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef ASM_SPEC\n #define ASM_SPEC \"-u %{maix64:-a64 %{!mcpu*:-mppc64}} %(asm_cpu)\"\n \n-/* Common ASM definitions used by ASM_SPEC amongst the various targets\n-   for handling -mcpu=xxx switches.  */\n+/* Common ASM definitions used by ASM_SPEC amongst the various targets for\n+   handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to\n+   provide the default assembler options if the user uses -mcpu=native, so if\n+   you make changes here, make them there also.  */\n #undef ASM_CPU_SPEC\n #define ASM_CPU_SPEC \\\n \"%{!mcpu*: %{!maix64: \\\n   %{mpowerpc64: -mppc64} \\\n   %{maltivec: -m970} \\\n   %{!maltivec: %{!mpower64: %(asm_default)}}}} \\\n+%{mcpu=native: %(asm_cpu_native)} \\\n %{mcpu=power3: -m620} \\\n %{mcpu=power4: -mpwr4} \\\n %{mcpu=power5: -mpwr5} \\\n %{mcpu=power5+: -mpwr5x} \\\n %{mcpu=power6: -mpwr6} \\\n %{mcpu=power6x: -mpwr6} \\\n+%{mcpu=power7: -mpwr7} \\\n %{mcpu=powerpc: -mppc} \\\n %{mcpu=rs64a: -mppc} \\\n %{mcpu=603: -m603} \\"}, {"sha": "048486b108b78ee6fdcb746d2eda072268283693", "filename": "gcc/config/rs6000/aix61.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Faix61.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Faix61.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix61.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler,\n    for IBM RS/6000 POWER running AIX V6.1.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by David Edelsohn (edelsohn@gnu.org).\n \n@@ -57,20 +57,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n #undef ASM_SPEC\n #define ASM_SPEC \"-u %{maix64:-a64 %{!mcpu*:-mppc64}} %(asm_cpu)\"\n \n-/* Common ASM definitions used by ASM_SPEC amongst the various targets\n-   for handling -mcpu=xxx switches.  */\n+/* Common ASM definitions used by ASM_SPEC amongst the various targets for\n+   handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to\n+   provide the default assembler options if the user uses -mcpu=native, so if\n+   you make changes here, make them there also.  */\n #undef ASM_CPU_SPEC\n #define ASM_CPU_SPEC \\\n \"%{!mcpu*: %{!maix64: \\\n   %{mpowerpc64: -mppc64} \\\n   %{maltivec: -m970} \\\n   %{!maltivec: %{!mpower64: %(asm_default)}}}} \\\n+%{mcpu=native: %(asm_cpu_native)} \\\n %{mcpu=power3: -m620} \\\n %{mcpu=power4: -mpwr4} \\\n %{mcpu=power5: -mpwr5} \\\n %{mcpu=power5+: -mpwr5x} \\\n %{mcpu=power6: -mpwr6} \\\n %{mcpu=power6x: -mpwr6} \\\n+%{mcpu=power7: -mpwr7} \\\n %{mcpu=powerpc: -mppc} \\\n %{mcpu=rs64a: -mppc} \\\n %{mcpu=603: -m603} \\"}, {"sha": "11e76ea968f83886633b9de1814b68ff858b5e25", "filename": "gcc/config/rs6000/driver-rs6000.c", "status": "modified", "additions": 135, "deletions": 14, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fdriver-rs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fdriver-rs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdriver-rs6000.c?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for the gcc driver.\n-   Copyright (C) 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -343,47 +343,156 @@ detect_processor_aix (void)\n #endif /* _AIX */\n \n \n+/*\n+ * Array to map -mcpu=native names to the switches passed to the assembler.\n+ * This list mirrors the specs in ASM_CPU_SPEC, and any changes made here\n+ * should be made there as well.\n+ */\n+\n+struct asm_name {\n+  const char *cpu;\n+  const char *asm_sw;\n+};\n+\n+static const struct asm_name asm_names[] = {\n+#if defined (_AIX)\n+  { \"power3\",\t\"-m620\" },\n+  { \"power4\",\t\"-mpwr4\" },\n+  { \"power5\",\t\"-mpwr5\" },\n+  { \"power5+\",\t\"-mpwr5x\" },\n+  { \"power6\",\t\"-mpwr6\" },\n+  { \"power6x\",\t\"-mpwr6\" },\n+  { \"power7\",\t\"-mpwr7\" },\n+  { \"powerpc\",\t\"-mppc\" },\n+  { \"rs64a\",\t\"-mppc\" },\n+  { \"603\",\t\"-m603\" },\n+  { \"603e\",\t\"-m603\" },\n+  { \"604\",\t\"-m604\" },\n+  { \"604e\",\t\"-m604\" },\n+  { \"620\",\t\"-m620\" },\n+  { \"630\",\t\"-m620\" },\n+  { \"970\",\t\"-m970\" },\n+  { \"G5\",\t\"-m970\" },\n+  { NULL,\t\"\\\n+%{!maix64: \\\n+%{mpowerpc64: -mppc64} \\\n+%{maltivec: -m970} \\\n+%{!maltivec: %{!mpower64: %(asm_default)}}}\" },\n+\n+#else\n+  { \"common\",\t\"-mcom\" },\n+  { \"cell\",\t\"-mcell\" },\n+  { \"power\",\t\"-mpwr\" },\n+  { \"power2\",\t\"-mpwrx\" },\n+  { \"power3\",\t\"-mppc64\" },\n+  { \"power4\",\t\"-mpower4\" },\n+  { \"power5\",\t\"%(asm_cpu_power5)\" },\n+  { \"power5+\",\t\"%(asm_cpu_power5)\" },\n+  { \"power6\",\t\"%(asm_cpu_power6) -maltivec\" },\n+  { \"power6x\",\t\"%(asm_cpu_power6) -maltivec\" },\n+  { \"power7\",\t\"%(asm_cpu_power7)\" },\n+  { \"powerpc\",\t\"-mppc\" },\n+  { \"rios\",\t\"-mpwr\" },\n+  { \"rios1\",\t\"-mpwr\" },\n+  { \"rios2\",\t\"-mpwrx\" },\n+  { \"rsc\",\t\"-mpwr\" },\n+  { \"rsc1\",\t\"-mpwr\" },\n+  { \"rs64a\",\t\"-mppc64\" },\n+  { \"401\",\t\"-mppc\" },\n+  { \"403\",\t\"-m403\" },\n+  { \"405\",\t\"-m405\" },\n+  { \"405fp\",\t\"-m405\" },\n+  { \"440\",\t\"-m440\" },\n+  { \"440fp\",\t\"-m440\" },\n+  { \"464\",\t\"-m440\" },\n+  { \"464fp\",\t\"-m440\" },\n+  { \"505\",\t\"-mppc\" },\n+  { \"601\",\t\"-m601\" },\n+  { \"602\",\t\"-mppc\" },\n+  { \"603\",\t\"-mppc\" },\n+  { \"603e\",\t\"-mppc\" },\n+  { \"ec603e\",\t\"-mppc\" },\n+  { \"604\",\t\"-mppc\" },\n+  { \"604e\",\t\"-mppc\" },\n+  { \"620\",\t\"-mppc64\" },\n+  { \"630\",\t\"-mppc64\" },\n+  { \"740\",\t\"-mppc\" },\n+  { \"750\",\t\"-mppc\" },\n+  { \"G3\",\t\"-mppc\" },\n+  { \"7400\",\t\"-mppc -maltivec\" },\n+  { \"7450\",\t\"-mppc -maltivec\" },\n+  { \"G4\",\t\"-mppc -maltivec\" },\n+  { \"801\",\t\"-mppc\" },\n+  { \"821\",\t\"-mppc\" },\n+  { \"823\",\t\"-mppc\" },\n+  { \"860\",\t\"-mppc\" },\n+  { \"970\",\t\"-mpower4 -maltivec\" },\n+  { \"G5\",\t\"-mpower4 -maltivec\" },\n+  { \"8540\",\t\"-me500\" },\n+  { \"8548\",\t\"-me500\" },\n+  { \"e300c2\",\t\"-me300\" },\n+  { \"e300c3\",\t\"-me300\" },\n+  { \"e500mc\",\t\"-me500mc\" },\n+  { NULL,\t\"\\\n+%{mpower: %{!mpower2: -mpwr}} \\\n+%{mpower2: -mpwrx} \\\n+%{mpowerpc64*: -mppc64} \\\n+%{!mpowerpc64*: %{mpowerpc*: -mppc}} \\\n+%{mno-power: %{!mpowerpc*: -mcom}} \\\n+%{!mno-power: %{!mpower*: %(asm_default)}}\" },\n+#endif\n+};\n+\n /* This will be called by the spec parser in gcc.c when it sees\n    a %:local_cpu_detect(args) construct.  Currently it will be called\n    with either \"arch\" or \"tune\" as argument depending on if -march=native\n    or -mtune=native is to be substituted.\n \n+   Additionally it will be called with \"asm\" to select the appropriate flags\n+   for the assembler.\n+\n    It returns a string containing new command line parameters to be\n    put at the place of the above two options, depending on what CPU\n    this is executed.\n \n    ARGC and ARGV are set depending on the actual arguments given\n    in the spec.  */\n-const char\n-*host_detect_local_cpu (int argc, const char **argv)\n+const char *\n+host_detect_local_cpu (int argc, const char **argv)\n {\n   const char *cpu = NULL;\n   const char *cache = \"\";\n   const char *options = \"\";\n   bool arch;\n+  bool assembler;\n+  size_t i;\n \n   if (argc < 1)\n     return NULL;\n \n   arch = strcmp (argv[0], \"cpu\") == 0;\n-  if (!arch && strcmp (argv[0], \"tune\"))\n+  assembler = (!arch && strcmp (argv[0], \"asm\") == 0);\n+  if (!arch && !assembler && strcmp (argv[0], \"tune\"))\n     return NULL;\n \n+  if (! assembler)\n+    {\n #if defined (_AIX)\n-  cache = detect_caches_aix ();\n+      cache = detect_caches_aix ();\n #elif defined (__APPLE__)\n-  cache = detect_caches_darwin ();\n+      cache = detect_caches_darwin ();\n #elif defined (__FreeBSD__)\n-  cache = detect_caches_freebsd ();\n-  /* FreeBSD PPC does not provide any cache information yet.  */\n-  cache = \"\";\n+      cache = detect_caches_freebsd ();\n+      /* FreeBSD PPC does not provide any cache information yet.  */\n+      cache = \"\";\n #elif defined (__linux__)\n-  cache = detect_caches_linux ();\n-  /* PPC Linux does not provide any cache information yet.  */\n-  cache = \"\";\n+      cache = detect_caches_linux ();\n+      /* PPC Linux does not provide any cache information yet.  */\n+      cache = \"\";\n #else\n-  cache = \"\";\n+      cache = \"\";\n #endif\n+    }\n \n #if defined (_AIX)\n   cpu = detect_processor_aix ();\n@@ -397,14 +506,26 @@ const char\n   cpu = \"powerpc\";\n #endif\n \n+  if (assembler)\n+    {\n+      for (i = 0; i < sizeof (asm_names) / sizeof (asm_names[0]); i++)\n+\t{\n+\t  if (!asm_names[i].cpu || !strcmp (asm_names[i].cpu, cpu))\n+\t    return asm_names[i].asm_sw;\n+\t}\n+\n+      return NULL;\n+    }\n+\n   return concat (cache, \"-m\", argv[0], \"=\", cpu, \" \", options, NULL);\n }\n \n #else /* GCC_VERSION */\n \n /* If we aren't compiling with GCC we just provide a minimal\n    default value.  */\n-const char *host_detect_local_cpu (int argc, const char **argv)\n+const char *\n+host_detect_local_cpu (int argc, const char **argv)\n {\n   const char *cpu;\n   bool arch;"}, {"sha": "05b20ad1139571dd8c7108754bab0952dc69761e", "filename": "gcc/config/rs6000/e500.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fe500.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fe500.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fe500.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,5 +1,6 @@\n /* Enable E500 support.\n-   Copyright (C) 2003, 2004, 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2006, 2007, 2008, 2009 Free Software\n+   Foundation, Inc.\n    This file is part of GCC.\n \n    GCC is free software; you can redistribute it and/or modify it\n@@ -37,6 +38,8 @@\n       {\t\t\t\t\t\t\t\t\t\\\n \tif (TARGET_ALTIVEC)\t\t\t\t\t\t\\\n \t  error (\"AltiVec and E500 instructions cannot coexist\");\t\\\n+\tif (TARGET_VSX)\t\t\t\t\t\t\t\\\n+\t  error (\"VSX and E500 instructions cannot coexist\");\t\t\\\n \tif (TARGET_64BIT)\t\t\t\t\t\t\\\n \t  error (\"64-bit E500 not supported\");\t\t\t\t\\\n \tif (TARGET_HARD_FLOAT && TARGET_FPRS)\t\t\t\t\\"}, {"sha": "94d18aee1dafdec8c02386c7665815fe357762b0", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -119,7 +119,7 @@ extern int dot_symbols;\n \t    error (INVALID_32BIT, \"32\");\t\t\t\\\n \t  if (TARGET_PROFILE_KERNEL)\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\\\n-\t      target_flags &= ~MASK_PROFILE_KERNEL;\t\t\\\n+\t      SET_PROFILE_KERNEL (0);\t\t\t\t\\\n \t      error (INVALID_32BIT, \"profile-kernel\");\t\t\\\n \t    }\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\\"}, {"sha": "1eac7382aa022b50833e48c91da53922bd63e724", "filename": "gcc/config/rs6000/linux64.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Flinux64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Flinux64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.opt?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,6 +1,6 @@\n ; Options for 64-bit PowerPC Linux.\n ;\n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n ; Contributed by Aldy Hernandez <aldy@quesejoda.com>.\n ;\n ; This file is part of GCC.\n@@ -20,5 +20,5 @@\n ; <http://www.gnu.org/licenses/>.\n \n mprofile-kernel\n-Target Report Mask(PROFILE_KERNEL)\n+Target Report Var(TARGET_PROFILE_KERNEL)\n Call mcount for profiling before a function prologue"}, {"sha": "d1ab9da9b2932ddc9c4ee0b54b762805a4ca15d3", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -284,6 +284,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n     builtin_define (\"_ARCH_PWR6X\");\n   if (! TARGET_POWER && ! TARGET_POWER2 && ! TARGET_POWERPC)\n     builtin_define (\"_ARCH_COM\");\n+  if (TARGET_POPCNTD)\n+    builtin_define (\"_ARCH_PWR7\");\n   if (TARGET_ALTIVEC)\n     {\n       builtin_define (\"__ALTIVEC__\");\n@@ -326,6 +328,8 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n   /* Used by libstdc++.  */\n   if (TARGET_NO_LWSYNC)\n     builtin_define (\"__NO_LWSYNC__\");\n+  if (TARGET_VSX)\n+    builtin_define (\"__VSX__\");\n \n   /* May be overridden by target configuration.  */\n   RS6000_CPU_CPP_ENDIAN_BUILTINS();"}, {"sha": "731349e04d23609edec5634a9b573ead4c8b2c52", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -168,7 +168,6 @@ extern int rs6000_register_move_cost (enum machine_mode,\n \t\t\t\t      enum reg_class, enum reg_class);\n extern int rs6000_memory_move_cost (enum machine_mode, enum reg_class, int);\n extern bool rs6000_tls_referenced_p (rtx);\n-extern int rs6000_hard_regno_nregs (int, enum machine_mode);\n extern void rs6000_conditional_register_usage (void);\n \n /* Declare functions in rs6000-c.c */\n@@ -187,4 +186,6 @@ const char * rs6000_xcoff_strip_dollar (const char *);\n void rs6000_final_prescan_insn (rtx, rtx *operand, int num_operands);\n \n extern bool rs6000_hard_regno_mode_ok_p[][FIRST_PSEUDO_REGISTER];\n+extern unsigned char rs6000_class_max_nregs[][LIM_REG_CLASSES];\n+extern unsigned char rs6000_hard_regno_nregs[][FIRST_PSEUDO_REGISTER];\n #endif  /* rs6000-protos.h */"}, {"sha": "0263f91cc2f1596e94a08232aaee74e7eaa49e4e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 463, "deletions": 87, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -178,9 +178,6 @@ int rs6000_spe;\n /* Nonzero if we want SPE ABI extensions.  */\n int rs6000_spe_abi;\n \n-/* Nonzero to use isel instructions.  */\n-int rs6000_isel;\n-\n /* Nonzero if floating point operations are done in the GPRs.  */\n int rs6000_float_gprs = 0;\n \n@@ -222,12 +219,33 @@ int dot_symbols;\n const char *rs6000_debug_name;\n int rs6000_debug_stack;\t\t/* debug stack applications */\n int rs6000_debug_arg;\t\t/* debug argument handling */\n+int rs6000_debug_reg;\t\t/* debug register classes */\n+int rs6000_debug_addr;\t\t/* debug memory addressing */\n+int rs6000_debug_cost;\t\t/* debug rtx_costs */\n+\n+/* Specify the machine mode that pointers have.  After generation of rtl, the\n+   compiler makes no further distinction between pointers and any other objects\n+   of this machine mode.  The type is unsigned since not all things that\n+   include rs6000.h also include machmode.h.  */\n+unsigned rs6000_pmode;\n+\n+/* Width in bits of a pointer.  */\n+unsigned rs6000_pointer_size;\n+\n \n /* Value is TRUE if register/mode pair is acceptable.  */\n bool rs6000_hard_regno_mode_ok_p[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n \n-/* Built in types.  */\n+/* Maximum number of registers needed for a given register class and mode.  */\n+unsigned char rs6000_class_max_nregs[NUM_MACHINE_MODES][LIM_REG_CLASSES];\n+\n+/* How many registers are needed for a given register and mode.  */\n+unsigned char rs6000_hard_regno_nregs[NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];\n \n+/* Map register number to register class.  */\n+enum reg_class rs6000_regno_regclass[FIRST_PSEUDO_REGISTER];\n+\n+/* Built in types.  */\n tree rs6000_builtin_types[RS6000_BTI_MAX];\n tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n \n@@ -265,7 +283,6 @@ static struct {\n   bool altivec_abi;\t\t/* True if -mabi=altivec/no-altivec used.  */\n   bool spe;\t\t\t/* True if -mspe= was used.  */\n   bool float_gprs;\t\t/* True if -mfloat-gprs= was used.  */\n-  bool isel;\t\t\t/* True if -misel was used. */\n   bool long_double;\t        /* True if -mlong-double- was used.  */\n   bool ieee;\t\t\t/* True if -mabi=ieee/ibmlongdouble used.  */\n   bool vrsave;\t\t\t/* True if -mvrsave was used.  */\n@@ -281,6 +298,14 @@ struct builtin_description\n   const char *const name;\n   const enum rs6000_builtins code;\n };\n+\n+/* Describe the vector unit used for modes.  */\n+enum rs6000_vector rs6000_vector_unit[NUM_MACHINE_MODES];\n+enum rs6000_vector rs6000_vector_mem[NUM_MACHINE_MODES];\n+enum reg_class rs6000_vector_reg_class[NUM_MACHINE_MODES];\n+\n+/* Describe the alignment of a vector.  */\n+int rs6000_vector_align[NUM_MACHINE_MODES];\n \f\n /* Target cpu costs.  */\n \n@@ -744,6 +769,25 @@ struct processor_costs power6_cost = {\n   16,\t\t\t/* prefetch streams */\n };\n \n+/* Instruction costs on POWER7 processors.  */\n+static const\n+struct processor_costs power7_cost = {\n+  COSTS_N_INSNS (2),\t/* mulsi */\n+  COSTS_N_INSNS (2),\t/* mulsi_const */\n+  COSTS_N_INSNS (2),\t/* mulsi_const9 */\n+  COSTS_N_INSNS (2),\t/* muldi */\n+  COSTS_N_INSNS (18),\t/* divsi */\n+  COSTS_N_INSNS (34),\t/* divdi */\n+  COSTS_N_INSNS (3),\t/* fp */\n+  COSTS_N_INSNS (3),\t/* dmul */\n+  COSTS_N_INSNS (13),\t/* sdiv */\n+  COSTS_N_INSNS (16),\t/* ddiv */\n+  128,\t\t\t/* cache line size */\n+  32,\t\t\t/* l1 cache */\n+  256,\t\t\t/* l2 cache */\n+  12,\t\t\t/* prefetch streams */\n+};\n+\n \f\n static bool rs6000_function_ok_for_sibcall (tree, tree);\n static const char *rs6000_invalid_within_doloop (const_rtx);\n@@ -1055,6 +1099,9 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #endif\n #ifndef TARGET_PROFILE_KERNEL\n #define TARGET_PROFILE_KERNEL 0\n+#define SET_PROFILE_KERNEL(N)\n+#else\n+#define SET_PROFILE_KERNEL(N) TARGET_PROFILE_KERNEL = (N)\n #endif\n \n /* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */\n@@ -1312,6 +1359,46 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+\n+   For the SPE, GPRs are 64 bits but only 32 bits are visible in\n+   scalar instructions.  The upper 32 bits are only available to the\n+   SIMD instructions.\n+\n+   POWER and PowerPC GPRs hold 32 bits worth;\n+   PowerPC64 GPRs and FPRs point register holds 64 bits worth.  */\n+\n+static int\n+rs6000_hard_regno_nregs_internal (int regno, enum machine_mode mode)\n+{\n+  unsigned HOST_WIDE_INT reg_size;\n+\n+  if (FP_REGNO_P (regno))\n+    reg_size = UNITS_PER_FP_WORD;\n+\n+  else if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n+    reg_size = UNITS_PER_SPE_WORD;\n+\n+  else if (ALTIVEC_REGNO_P (regno))\n+    reg_size = UNITS_PER_ALTIVEC_WORD;\n+\n+  /* The value returned for SCmode in the E500 double case is 2 for\n+     ABI compatibility; storing an SCmode value in a single register\n+     would require function_arg and rs6000_spe_function_arg to handle\n+     SCmode so as to pass the value correctly in a pair of\n+     registers.  */\n+  else if (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode) && mode != SCmode\n+\t   && !DECIMAL_FLOAT_MODE_P (mode))\n+    reg_size = UNITS_PER_FP_WORD;\n+\n+  else\n+    reg_size = UNITS_PER_WORD;\n+\n+  return (GET_MODE_SIZE (mode) + reg_size - 1) / reg_size;\n+}\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode\n    MODE.  */\n@@ -1356,16 +1443,267 @@ rs6000_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   return GET_MODE_SIZE (mode) <= UNITS_PER_WORD;\n }\n \n-/* Initialize rs6000_hard_regno_mode_ok_p table.  */\n+/* Print interesting facts about registers.  */\n static void\n-rs6000_init_hard_regno_mode_ok (void)\n+rs6000_debug_reg_print (int first_regno, int last_regno, const char *reg_name)\n {\n   int r, m;\n \n+  for (r = first_regno; r <= last_regno; ++r)\n+    {\n+      const char *comma = \"\";\n+      int len;\n+\n+      if (first_regno == last_regno)\n+\tfprintf (stderr, \"%s:\\t\", reg_name);\n+      else\n+\tfprintf (stderr, \"%s%d:\\t\", reg_name, r - first_regno);\n+\n+      len = 8;\n+      for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+\tif (rs6000_hard_regno_mode_ok_p[m][r] && rs6000_hard_regno_nregs[m][r])\n+\t  {\n+\t    if (len > 70)\n+\t      {\n+\t\tfprintf (stderr, \",\\n\\t\");\n+\t\tlen = 8;\n+\t\tcomma = \"\";\n+\t      }\n+\n+\t    if (rs6000_hard_regno_nregs[m][r] > 1)\n+\t      len += fprintf (stderr, \"%s%s/%d\", comma, GET_MODE_NAME (m),\n+\t\t\t     rs6000_hard_regno_nregs[m][r]);\n+\t    else\n+\t      len += fprintf (stderr, \"%s%s\", comma, GET_MODE_NAME (m));\n+\n+\t    comma = \", \";\n+\t  }\n+\n+      if (call_used_regs[r])\n+\t{\n+\t  if (len > 70)\n+\t    {\n+\t      fprintf (stderr, \",\\n\\t\");\n+\t      len = 8;\n+\t      comma = \"\";\n+\t    }\n+\n+\t  len += fprintf (stderr, \"%s%s\", comma, \"call-used\");\n+\t  comma = \", \";\n+\t}\n+\n+      if (fixed_regs[r])\n+\t{\n+\t  if (len > 70)\n+\t    {\n+\t      fprintf (stderr, \",\\n\\t\");\n+\t      len = 8;\n+\t      comma = \"\";\n+\t    }\n+\n+\t  len += fprintf (stderr, \"%s%s\", comma, \"fixed\");\n+\t  comma = \", \";\n+\t}\n+\n+      if (len > 70)\n+\t{\n+\t  fprintf (stderr, \",\\n\\t\");\n+\t  comma = \"\";\n+\t}\n+\n+      fprintf (stderr, \"%sregno = %d\\n\", comma, r);\n+    }\n+}\n+\n+/* Map enum rs6000_vector to string.  */\n+static const char *\n+rs6000_debug_vector_unit[] = {\n+  \"none\",\n+  \"altivec\",\n+  \"vsx\",\n+  \"paired\",\n+  \"spe\",\n+  \"other\"\n+};\n+\n+/* Initialize the various global tables that are based on register size.  */\n+static void\n+rs6000_init_hard_regno_mode_ok (void)\n+{\n+  int r, m, c;\n+  bool float_p = (TARGET_HARD_FLOAT && TARGET_FPRS);\n+\n+  /* Precalculate REGNO_REG_CLASS.  */\n+  rs6000_regno_regclass[0] = GENERAL_REGS;\n+  for (r = 1; r < 32; ++r)\n+    rs6000_regno_regclass[r] = BASE_REGS;\n+\n+  for (r = 32; r < 64; ++r)\n+    rs6000_regno_regclass[r] = FLOAT_REGS;\n+\n+  for (r = 64; r < FIRST_PSEUDO_REGISTER; ++r)\n+    rs6000_regno_regclass[r] = NO_REGS;\n+\n+  for (r = FIRST_ALTIVEC_REGNO; r <= LAST_ALTIVEC_REGNO; ++r)\n+    rs6000_regno_regclass[r] = ALTIVEC_REGS;\n+\n+  rs6000_regno_regclass[CR0_REGNO] = CR0_REGS;\n+  for (r = CR1_REGNO; r <= CR7_REGNO; ++r)\n+    rs6000_regno_regclass[r] = CR_REGS;\n+\n+  rs6000_regno_regclass[MQ_REGNO] = MQ_REGS;\n+  rs6000_regno_regclass[LR_REGNO] = LINK_REGS;\n+  rs6000_regno_regclass[CTR_REGNO] = CTR_REGS;\n+  rs6000_regno_regclass[XER_REGNO] = XER_REGS;\n+  rs6000_regno_regclass[VRSAVE_REGNO] = VRSAVE_REGS;\n+  rs6000_regno_regclass[VSCR_REGNO] = VRSAVE_REGS;\n+  rs6000_regno_regclass[SPE_ACC_REGNO] = SPE_ACC_REGS;\n+  rs6000_regno_regclass[SPEFSCR_REGNO] = SPEFSCR_REGS;\n+  rs6000_regno_regclass[ARG_POINTER_REGNUM] = BASE_REGS;\n+  rs6000_regno_regclass[FRAME_POINTER_REGNUM] = BASE_REGS;\n+\n+  /* Precalculate vector information, this must be set up before the\n+     rs6000_hard_regno_nregs_internal below.  */\n+  for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+    {\n+      rs6000_vector_unit[m] = rs6000_vector_mem[m] = VECTOR_NONE;\n+      rs6000_vector_reg_class[m] = NO_REGS;\n+    }\n+\n+  /* V4SF mode, Altivec only.  */\n+  if (float_p && TARGET_ALTIVEC)\n+    {\n+      rs6000_vector_unit[V4SFmode] = VECTOR_ALTIVEC;\n+      rs6000_vector_mem[V4SFmode] = VECTOR_ALTIVEC;\n+      rs6000_vector_align[V4SFmode] = 128;\n+    }\n+\n+  /* V16QImode, V8HImode, V4SImode are Altivec only.  */\n+  if (TARGET_ALTIVEC)\n+    {\n+      rs6000_vector_unit[V4SImode] = VECTOR_ALTIVEC;\n+      rs6000_vector_unit[V8HImode] = VECTOR_ALTIVEC;\n+      rs6000_vector_unit[V16QImode] = VECTOR_ALTIVEC;\n+\n+      rs6000_vector_reg_class[V16QImode] = ALTIVEC_REGS;\n+      rs6000_vector_reg_class[V8HImode] = ALTIVEC_REGS;\n+      rs6000_vector_reg_class[V4SImode] = ALTIVEC_REGS;\n+\n+      rs6000_vector_mem[V4SImode] = VECTOR_ALTIVEC;\n+      rs6000_vector_mem[V8HImode] = VECTOR_ALTIVEC;\n+      rs6000_vector_mem[V16QImode] = VECTOR_ALTIVEC;\n+      rs6000_vector_align[V4SImode] = 128;\n+      rs6000_vector_align[V8HImode] = 128;\n+      rs6000_vector_align[V16QImode] = 128;\n+    }\n+\n+  /* V2DImode, prefer vsx over altivec, since the main use will be for\n+     vectorized floating point conversions.  */\n+  if (TARGET_ALTIVEC)\n+    {\n+      rs6000_vector_mem[V2DImode] = VECTOR_ALTIVEC;\n+      rs6000_vector_unit[V2DImode] = VECTOR_NONE;\n+      rs6000_vector_reg_class[V2DImode] = ALTIVEC_REGS;\n+      rs6000_vector_align[V2DImode] = 128;\n+    }\n+\n+  /* TODO add SPE and paired floating point vector support.  */\n+\n+  /* Set the VSX register classes.  */\n+  rs6000_vector_reg_class[V4SFmode]\n+    = (VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\n+       ? ALTIVEC_REGS\n+       : NO_REGS);\n+\n+  rs6000_vector_reg_class[V2DFmode] = NO_REGS;\n+\n+  rs6000_vector_reg_class[DFmode] = (!float_p ? NO_REGS : FLOAT_REGS);\n+\n+  /* Precalculate HARD_REGNO_NREGS.  */\n+  for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n+    for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+      rs6000_hard_regno_nregs[m][r]\n+\t= rs6000_hard_regno_nregs_internal (r, (enum machine_mode)m);\n+\n+  /* Precalculate HARD_REGNO_MODE_OK.  */\n   for (r = 0; r < FIRST_PSEUDO_REGISTER; ++r)\n     for (m = 0; m < NUM_MACHINE_MODES; ++m)\n-      if (rs6000_hard_regno_mode_ok (r, (enum machine_mode) m))\n+      if (rs6000_hard_regno_mode_ok (r, (enum machine_mode)m))\n \trs6000_hard_regno_mode_ok_p[m][r] = true;\n+\n+  /* Precalculate CLASS_MAX_NREGS sizes.  */\n+  for (c = 0; c < LIM_REG_CLASSES; ++c)\n+    {\n+      int reg_size;\n+\n+      if (c == ALTIVEC_REGS)\n+\treg_size = UNITS_PER_ALTIVEC_WORD;\n+\n+      else if (c == FLOAT_REGS)\n+\treg_size = UNITS_PER_FP_WORD;\n+\n+      else\n+\treg_size = UNITS_PER_WORD;\n+\n+      for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+\trs6000_class_max_nregs[m][c]\n+\t  = (GET_MODE_SIZE (m) + reg_size - 1) / reg_size;\n+    }\n+\n+  if (TARGET_E500_DOUBLE)\n+    rs6000_class_max_nregs[DFmode][GENERAL_REGS] = 1;\n+\n+  if (TARGET_DEBUG_REG)\n+    {\n+      const char *nl = (const char *)0;\n+\n+      fprintf (stderr, \"Register information: (last virtual reg = %d)\\n\",\n+\t       LAST_VIRTUAL_REGISTER);\n+      rs6000_debug_reg_print (0, 31, \"gr\");\n+      rs6000_debug_reg_print (32, 63, \"fp\");\n+      rs6000_debug_reg_print (FIRST_ALTIVEC_REGNO,\n+\t\t\t      LAST_ALTIVEC_REGNO,\n+\t\t\t      \"vs\");\n+      rs6000_debug_reg_print (LR_REGNO, LR_REGNO, \"lr\");\n+      rs6000_debug_reg_print (CTR_REGNO, CTR_REGNO, \"ctr\");\n+      rs6000_debug_reg_print (CR0_REGNO, CR7_REGNO, \"cr\");\n+      rs6000_debug_reg_print (MQ_REGNO, MQ_REGNO, \"mq\");\n+      rs6000_debug_reg_print (XER_REGNO, XER_REGNO, \"xer\");\n+      rs6000_debug_reg_print (VRSAVE_REGNO, VRSAVE_REGNO, \"vrsave\");\n+      rs6000_debug_reg_print (VSCR_REGNO, VSCR_REGNO, \"vscr\");\n+      rs6000_debug_reg_print (SPE_ACC_REGNO, SPE_ACC_REGNO, \"spe_a\");\n+      rs6000_debug_reg_print (SPEFSCR_REGNO, SPEFSCR_REGNO, \"spe_f\");\n+\n+      fprintf (stderr,\n+\t       \"\\n\"\n+\t       \"V16QI reg_class = %s\\n\"\n+\t       \"V8HI  reg_class = %s\\n\"\n+\t       \"V4SI  reg_class = %s\\n\"\n+\t       \"V2DI  reg_class = %s\\n\"\n+\t       \"V4SF  reg_class = %s\\n\"\n+\t       \"V2DF  reg_class = %s\\n\"\n+\t       \"DF    reg_class = %s\\n\\n\",\n+\t       reg_class_names[rs6000_vector_reg_class[V16QImode]],\n+\t       reg_class_names[rs6000_vector_reg_class[V8HImode]],\n+\t       reg_class_names[rs6000_vector_reg_class[V4SImode]],\n+\t       reg_class_names[rs6000_vector_reg_class[V2DImode]],\n+\t       reg_class_names[rs6000_vector_reg_class[V4SFmode]],\n+\t       reg_class_names[rs6000_vector_reg_class[V2DFmode]],\n+\t       reg_class_names[rs6000_vector_reg_class[DFmode]]);\n+\n+      for (m = 0; m < NUM_MACHINE_MODES; ++m)\n+\tif (rs6000_vector_unit[m] || rs6000_vector_mem[m])\n+\t  {\n+\t    nl = \"\\n\";\n+\t    fprintf (stderr, \"Vector mode: %-5s arithmetic: %-8s move: %-8s\\n\",\n+\t\t     GET_MODE_NAME (m),\n+\t\t     rs6000_debug_vector_unit[ rs6000_vector_unit[m] ],\n+\t\t     rs6000_debug_vector_unit[ rs6000_vector_mem[m] ]);\n+\t  }\n+\n+      if (nl)\n+\tfputs (nl, stderr);\n+    }\n }\n \n #if TARGET_MACHO\n@@ -1495,12 +1833,15 @@ rs6000_override_options (const char *default_cpu)\n \t {\"801\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"821\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"823\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n-\t {\"8540\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN},\n+\t {\"8540\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN\n+\t  | MASK_ISEL},\n \t /* 8548 has a dummy entry for now.  */\n-\t {\"8548\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN},\n+\t {\"8548\", PROCESSOR_PPC8540, POWERPC_BASE_MASK | MASK_STRICT_ALIGN\n+\t  | MASK_ISEL},\n \t {\"e300c2\", PROCESSOR_PPCE300C2, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"e300c3\", PROCESSOR_PPCE300C3, POWERPC_BASE_MASK},\n-\t {\"e500mc\", PROCESSOR_PPCE500MC, POWERPC_BASE_MASK | MASK_PPC_GFXOPT},\n+\t {\"e500mc\", PROCESSOR_PPCE500MC, POWERPC_BASE_MASK | MASK_PPC_GFXOPT\n+\t  | MASK_ISEL},\n \t {\"860\", PROCESSOR_MPCCORE, POWERPC_BASE_MASK | MASK_SOFT_FLOAT},\n \t {\"970\", PROCESSOR_POWER4,\n \t  POWERPC_7400_MASK | MASK_PPC_GPOPT | MASK_MFCRF | MASK_POWERPC64},\n@@ -1533,9 +1874,10 @@ rs6000_override_options (const char *default_cpu)\n \t  POWERPC_BASE_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_PPC_GFXOPT\n \t  | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP\n \t  | MASK_MFPGPR},\n-\t {\"power7\", PROCESSOR_POWER5,\n+\t {\"power7\", PROCESSOR_POWER7,\n \t  POWERPC_7400_MASK | MASK_POWERPC64 | MASK_PPC_GPOPT | MASK_MFCRF\n-\t  | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP},\n+\t  | MASK_POPCNTB | MASK_FPRND | MASK_CMPB | MASK_DFP | MASK_POPCNTD\n+\t  | MASK_VSX},\t/* Don't add MASK_ISEL by default */\n \t {\"powerpc\", PROCESSOR_POWERPC, POWERPC_BASE_MASK},\n \t {\"powerpc64\", PROCESSOR_POWERPC64,\n \t  POWERPC_BASE_MASK | MASK_PPC_GFXOPT | MASK_POWERPC64},\n@@ -1562,9 +1904,22 @@ rs6000_override_options (const char *default_cpu)\n     POWERPC_MASKS = (POWERPC_BASE_MASK | MASK_PPC_GPOPT | MASK_STRICT_ALIGN\n \t\t     | MASK_PPC_GFXOPT | MASK_POWERPC64 | MASK_ALTIVEC\n \t\t     | MASK_MFCRF | MASK_POPCNTB | MASK_FPRND | MASK_MULHW\n-\t\t     | MASK_DLMZB | MASK_CMPB | MASK_MFPGPR | MASK_DFP)\n+\t\t     | MASK_DLMZB | MASK_CMPB | MASK_MFPGPR | MASK_DFP\n+\t\t     | MASK_POPCNTD | MASK_VSX | MASK_ISEL)\n   };\n \n+  /* Set the pointer size.  */\n+  if (TARGET_POWERPC64)\n+    {\n+      rs6000_pmode = (int)DImode;\n+      rs6000_pointer_size = 64;\n+    }\n+  else\n+    {\n+      rs6000_pmode = (int)SImode;\n+      rs6000_pointer_size = 32;\n+    }\n+\n   set_masks = POWER_MASKS | POWERPC_MASKS | MASK_SOFT_FLOAT;\n #ifdef OS_MISSING_POWERPC64\n   if (OS_MISSING_POWERPC64)\n@@ -1607,10 +1962,6 @@ rs6000_override_options (const char *default_cpu)\n \t}\n     }\n \n-  if ((TARGET_E500 || rs6000_cpu == PROCESSOR_PPCE500MC)\n-      && !rs6000_explicit_options.isel)\n-    rs6000_isel = 1;\n-\n   if (rs6000_cpu == PROCESSOR_PPCE300C2 || rs6000_cpu == PROCESSOR_PPCE300C3\n       || rs6000_cpu == PROCESSOR_PPCE500MC)\n     {\n@@ -1655,15 +2006,55 @@ rs6000_override_options (const char *default_cpu)\n \t}\n     }\n \n+  /* Add some warnings for VSX.  Enable -maltivec unless the user explicitly\n+     used -mno-altivec  */\n+  if (TARGET_VSX)\n+    {\n+      const char *msg = NULL;\n+      if (!TARGET_HARD_FLOAT || !TARGET_FPRS\n+\t  || !TARGET_SINGLE_FLOAT || !TARGET_DOUBLE_FLOAT)\n+\t{\n+\t  if (target_flags_explicit & MASK_VSX)\n+\t    msg = N_(\"-mvsx requires hardware floating point\");\n+\t  else\n+\t    target_flags &= ~ MASK_VSX;\n+\t}\n+      else if (TARGET_PAIRED_FLOAT)\n+\tmsg = N_(\"-mvsx and -mpaired are incompatible\");\n+      /* The hardware will allow VSX and little endian, but until we make sure\n+\t things like vector select, etc. work don't allow VSX on little endian\n+\t systems at this point.  */\n+      else if (!BYTES_BIG_ENDIAN)\n+\tmsg = N_(\"-mvsx used with little endian code\");\n+      else if (TARGET_AVOID_XFORM > 0)\n+\tmsg = N_(\"-mvsx needs indexed addressing\");\n+\n+      if (msg)\n+\t{\n+\t  warning (0, msg);\n+\t  target_flags &= ~ MASK_VSX;\n+\t}\n+      else if (TARGET_VSX && !TARGET_ALTIVEC\n+\t       && (target_flags_explicit & MASK_ALTIVEC) == 0)\n+\ttarget_flags |= MASK_ALTIVEC;\n+    }\n+\n   /* Set debug flags */\n   if (rs6000_debug_name)\n     {\n       if (! strcmp (rs6000_debug_name, \"all\"))\n-\trs6000_debug_stack = rs6000_debug_arg = 1;\n+\trs6000_debug_stack = rs6000_debug_arg = rs6000_debug_reg\n+\t  = rs6000_debug_addr = rs6000_debug_cost = 1;\n       else if (! strcmp (rs6000_debug_name, \"stack\"))\n \trs6000_debug_stack = 1;\n       else if (! strcmp (rs6000_debug_name, \"arg\"))\n \trs6000_debug_arg = 1;\n+      else if (! strcmp (rs6000_debug_name, \"reg\"))\n+\trs6000_debug_reg = 1;\n+      else if (! strcmp (rs6000_debug_name, \"addr\"))\n+\trs6000_debug_addr = 1;\n+      else if (! strcmp (rs6000_debug_name, \"cost\"))\n+\trs6000_debug_cost = 1;\n       else\n \terror (\"unknown -mdebug-%s switch\", rs6000_debug_name);\n     }\n@@ -1690,7 +2081,7 @@ rs6000_override_options (const char *default_cpu)\n #endif\n \n   /* Enable Altivec ABI for AIX -maltivec.  */\n-  if (TARGET_XCOFF && TARGET_ALTIVEC)\n+  if (TARGET_XCOFF && (TARGET_ALTIVEC || TARGET_VSX))\n     rs6000_altivec_abi = 1;\n \n   /* The AltiVec ABI is the default for PowerPC-64 GNU/Linux.  For\n@@ -1699,7 +2090,7 @@ rs6000_override_options (const char *default_cpu)\n   if (TARGET_ELF)\n     {\n       if (!rs6000_explicit_options.altivec_abi\n-\t  && (TARGET_64BIT || TARGET_ALTIVEC))\n+\t  && (TARGET_64BIT || TARGET_ALTIVEC || TARGET_VSX))\n \trs6000_altivec_abi = 1;\n \n       /* Enable VRSAVE for AltiVec ABI, unless explicitly overridden.  */\n@@ -1754,22 +2145,24 @@ rs6000_override_options (const char *default_cpu)\n \trs6000_spe = 0;\n       if (!rs6000_explicit_options.float_gprs)\n \trs6000_float_gprs = 0;\n-      if (!rs6000_explicit_options.isel)\n-\trs6000_isel = 0;\n+      if (!(target_flags_explicit & MASK_ISEL))\n+\ttarget_flags &= ~MASK_ISEL;\n     }\n \n   /* Detect invalid option combinations with E500.  */\n   CHECK_E500_OPTIONS;\n \n   rs6000_always_hint = (rs6000_cpu != PROCESSOR_POWER4\n \t\t\t&& rs6000_cpu != PROCESSOR_POWER5\n-                        && rs6000_cpu != PROCESSOR_POWER6\n+\t\t\t&& rs6000_cpu != PROCESSOR_POWER6\n+\t\t\t&& rs6000_cpu != PROCESSOR_POWER7\n \t\t\t&& rs6000_cpu != PROCESSOR_CELL);\n   rs6000_sched_groups = (rs6000_cpu == PROCESSOR_POWER4\n \t\t\t || rs6000_cpu == PROCESSOR_POWER5);\n   rs6000_align_branch_targets = (rs6000_cpu == PROCESSOR_POWER4\n-                                 || rs6000_cpu == PROCESSOR_POWER5\n-                                 || rs6000_cpu == PROCESSOR_POWER6);\n+\t\t\t\t || rs6000_cpu == PROCESSOR_POWER5\n+\t\t\t\t || rs6000_cpu == PROCESSOR_POWER6\n+\t\t\t\t || rs6000_cpu == PROCESSOR_POWER7);\n \n   rs6000_sched_restricted_insns_priority\n     = (rs6000_sched_groups ? 1 : 0);\n@@ -1966,6 +2359,10 @@ rs6000_override_options (const char *default_cpu)\n \trs6000_cost = &power6_cost;\n \tbreak;\n \n+      case PROCESSOR_POWER7:\n+\trs6000_cost = &power7_cost;\n+\tbreak;\n+\n       default:\n \tgcc_unreachable ();\n       }\n@@ -2016,7 +2413,7 @@ rs6000_override_options (const char *default_cpu)\n static tree\n rs6000_builtin_mask_for_load (void)\n {\n-  if (TARGET_ALTIVEC)\n+  if (TARGET_ALTIVEC || TARGET_VSX)\n     return altivec_builtin_mask_for_load;\n   else\n     return 0;\n@@ -2246,6 +2643,7 @@ static bool\n rs6000_handle_option (size_t code, const char *arg, int value)\n {\n   enum fpu_type_t fpu_type = FPU_NONE;\n+  int isel;\n \n   switch (code)\n     {\n@@ -2353,14 +2751,14 @@ rs6000_handle_option (size_t code, const char *arg, int value)\n       rs6000_parse_yes_no_option (\"vrsave\", arg, &(TARGET_ALTIVEC_VRSAVE));\n       break;\n \n-    case OPT_misel:\n-      rs6000_explicit_options.isel = true;\n-      rs6000_isel = value;\n-      break;\n-\n     case OPT_misel_:\n-      rs6000_explicit_options.isel = true;\n-      rs6000_parse_yes_no_option (\"isel\", arg, &(rs6000_isel));\n+      target_flags_explicit |= MASK_ISEL;\n+      isel = 0;\n+      rs6000_parse_yes_no_option (\"isel\", arg, &isel);\n+      if (isel)\n+\ttarget_flags |= MASK_ISEL;\n+      else\n+\ttarget_flags &= ~MASK_ISEL;\n       break;\n \n     case OPT_mspe:\n@@ -4584,43 +4982,6 @@ rs6000_offsettable_memref_p (rtx op)\n   return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0), 1);\n }\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   For the SPE, GPRs are 64 bits but only 32 bits are visible in\n-   scalar instructions.  The upper 32 bits are only available to the\n-   SIMD instructions.\n-\n-   POWER and PowerPC GPRs hold 32 bits worth;\n-   PowerPC64 GPRs and FPRs point register holds 64 bits worth.  */\n-\n-int\n-rs6000_hard_regno_nregs (int regno, enum machine_mode mode)\n-{\n-  if (FP_REGNO_P (regno))\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;\n-\n-  if (SPE_SIMD_REGNO_P (regno) && TARGET_SPE && SPE_VECTOR_MODE (mode))\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_SPE_WORD - 1) / UNITS_PER_SPE_WORD;\n-\n-  if (ALTIVEC_REGNO_P (regno))\n-    return\n-      (GET_MODE_SIZE (mode) + UNITS_PER_ALTIVEC_WORD - 1) / UNITS_PER_ALTIVEC_WORD;\n-\n-  /* The value returned for SCmode in the E500 double case is 2 for\n-     ABI compatibility; storing an SCmode value in a single register\n-     would require function_arg and rs6000_spe_function_arg to handle\n-     SCmode so as to pass the value correctly in a pair of\n-     registers.  */\n-  if (TARGET_E500_DOUBLE && FLOAT_MODE_P (mode) && mode != SCmode\n-      && !DECIMAL_FLOAT_MODE_P (mode))\n-    return (GET_MODE_SIZE (mode) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD;\n-\n-  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n-}\n-\n /* Change register usage conditional on target flags.  */\n void\n rs6000_conditional_register_usage (void)\n@@ -4685,14 +5046,14 @@ rs6000_conditional_register_usage (void)\n \t= call_really_used_regs[14] = 1;\n     }\n \n-  if (!TARGET_ALTIVEC)\n+  if (!TARGET_ALTIVEC && !TARGET_VSX)\n     {\n       for (i = FIRST_ALTIVEC_REGNO; i <= LAST_ALTIVEC_REGNO; ++i)\n \tfixed_regs[i] = call_used_regs[i] = call_really_used_regs[i] = 1;\n       call_really_used_regs[VRSAVE_REGNO] = 1;\n     }\n \n-  if (TARGET_ALTIVEC)\n+  if (TARGET_ALTIVEC || TARGET_VSX)\n     global_regs[VSCR_REGNO] = 1;\n \n   if (TARGET_ALTIVEC_ABI)\n@@ -5310,10 +5671,10 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n    && TARGET_HARD_FLOAT && TARGET_FPRS)\n \n /* Nonzero if we can use an AltiVec register to pass this arg.  */\n-#define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE,NAMED)\t\\\n-  (ALTIVEC_VECTOR_MODE (MODE)\t\t\t\t\\\n-   && (CUM)->vregno <= ALTIVEC_ARG_MAX_REG\t\t\\\n-   && TARGET_ALTIVEC_ABI\t\t\t\t\\\n+#define USE_ALTIVEC_FOR_ARG_P(CUM,MODE,TYPE,NAMED)\t\t\\\n+  ((ALTIVEC_VECTOR_MODE (MODE) || VSX_VECTOR_MODE (MODE))\t\\\n+   && (CUM)->vregno <= ALTIVEC_ARG_MAX_REG\t\t\t\\\n+   && TARGET_ALTIVEC_ABI\t\t\t\t\t\\\n    && (NAMED))\n \n /* Return a nonzero value to say to return the function value in\n@@ -5554,7 +5915,7 @@ function_arg_boundary (enum machine_mode mode, tree type)\n \t       && int_size_in_bytes (type) >= 8\n \t       && int_size_in_bytes (type) < 16))\n     return 64;\n-  else if (ALTIVEC_VECTOR_MODE (mode)\n+  else if ((ALTIVEC_VECTOR_MODE (mode) || VSX_VECTOR_MODE (mode))\n \t   || (type && TREE_CODE (type) == VECTOR_TYPE\n \t       && int_size_in_bytes (type) >= 16))\n     return 128;\n@@ -5700,6 +6061,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   if (TARGET_ALTIVEC_ABI\n       && (ALTIVEC_VECTOR_MODE (mode)\n+\t  || VSX_VECTOR_MODE (mode)\n \t  || (type && TREE_CODE (type) == VECTOR_TYPE\n \t      && int_size_in_bytes (type) == 16)))\n     {\n@@ -6294,6 +6656,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       return gen_rtx_REG (mode, cum->vregno);\n   else if (TARGET_ALTIVEC_ABI\n \t   && (ALTIVEC_VECTOR_MODE (mode)\n+\t       || VSX_VECTOR_MODE (mode)\n \t       || (type && TREE_CODE (type) == VECTOR_TYPE\n \t\t   && int_size_in_bytes (type) == 16)))\n     {\n@@ -7192,7 +7555,8 @@ def_builtin (int mask, const char *name, tree type, int code)\n   if ((mask & target_flags) || TARGET_PAIRED_FLOAT)\n     {\n       if (rs6000_builtin_decls[code])\n-\tabort ();\n+\tfatal_error (\"internal error: builtin function to %s already processed.\",\n+\t\t     name);\n \n       rs6000_builtin_decls[code] =\n         add_builtin_function (name, type, code, BUILT_IN_MD,\n@@ -9342,7 +9706,7 @@ rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \treturn ret;\n     }  \n \n-  gcc_assert (TARGET_ALTIVEC || TARGET_SPE || TARGET_PAIRED_FLOAT);\n+  gcc_assert (TARGET_ALTIVEC || TARGET_VSX || TARGET_SPE || TARGET_PAIRED_FLOAT);\n \n   /* Handle simple unary operations.  */\n   d = (struct builtin_description *) bdesc_1arg;\n@@ -13770,9 +14134,9 @@ static int\n rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   rtx condition_rtx, cr;\n+  enum machine_mode mode = GET_MODE (XEXP (op, 0));\n \n-  /* All isel implementations thus far are 32-bits.  */\n-  if (GET_MODE (XEXP (op, 0)) != SImode)\n+  if (mode != SImode && (!TARGET_POWERPC64 || mode != DImode))\n     return 0;\n \n   /* We still have to do the compare, because isel doesn't do a\n@@ -13781,12 +14145,24 @@ rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n   condition_rtx = rs6000_generate_compare (op, SImode);\n   cr = XEXP (condition_rtx, 0);\n \n-  if (GET_MODE (cr) == CCmode)\n-    emit_insn (gen_isel_signed (dest, condition_rtx,\n-\t\t\t\ttrue_cond, false_cond, cr));\n+  if (mode == SImode)\n+    {\n+      if (GET_MODE (cr) == CCmode)\n+\temit_insn (gen_isel_signed_si (dest, condition_rtx,\n+\t\t\t\t       true_cond, false_cond, cr));\n+      else\n+\temit_insn (gen_isel_unsigned_si (dest, condition_rtx,\n+\t\t\t\t\t true_cond, false_cond, cr));\n+    }\n   else\n-    emit_insn (gen_isel_unsigned (dest, condition_rtx,\n-\t\t\t\t  true_cond, false_cond, cr));\n+    {\n+      if (GET_MODE (cr) == CCmode)\n+\temit_insn (gen_isel_signed_di (dest, condition_rtx,\n+\t\t\t\t       true_cond, false_cond, cr));\n+      else\n+\temit_insn (gen_isel_unsigned_di (dest, condition_rtx,\n+\t\t\t\t\t true_cond, false_cond, cr));\n+    }\n \n   return 1;\n }"}, {"sha": "f4a5401670f9bf0acd9a61c3a51df79fa2b0d7b5", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 198, "deletions": 56, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -77,14 +77,16 @@\n #define ASM_CPU_POWER6_SPEC \"-mpower4 -maltivec\"\n #endif\n \n-#ifdef HAVE_AS_VSX\n+#ifdef HAVE_AS_POPCNTD\n #define ASM_CPU_POWER7_SPEC \"-mpower7\"\n #else\n #define ASM_CPU_POWER7_SPEC \"-mpower4 -maltivec\"\n #endif\n \n-/* Common ASM definitions used by ASM_SPEC among the various targets\n-   for handling -mcpu=xxx switches.  */\n+/* Common ASM definitions used by ASM_SPEC among the various targets for\n+   handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to\n+   provide the default assembler options if the user uses -mcpu=native, so if\n+   you make changes here, make them also there.  */\n #define ASM_CPU_SPEC \\\n \"%{!mcpu*: \\\n   %{mpower: %{!mpower2: -mpwr}} \\\n@@ -93,6 +95,7 @@\n   %{!mpowerpc64*: %{mpowerpc*: -mppc}} \\\n   %{mno-power: %{!mpowerpc*: -mcom}} \\\n   %{!mno-power: %{!mpower*: %(asm_default)}}} \\\n+%{mcpu=native: %(asm_cpu_native)} \\\n %{mcpu=common: -mcom} \\\n %{mcpu=cell: -mcell} \\\n %{mcpu=power: -mpwr} \\\n@@ -168,6 +171,7 @@\n #define EXTRA_SPECS\t\t\t\t\t\t\t\\\n   { \"cpp_default\",\t\tCPP_DEFAULT_SPEC },\t\t\t\\\n   { \"asm_cpu\",\t\t\tASM_CPU_SPEC },\t\t\t\t\\\n+  { \"asm_cpu_native\",\t\tASM_CPU_NATIVE_SPEC },\t\t\t\\\n   { \"asm_default\",\t\tASM_DEFAULT_SPEC },\t\t\t\\\n   { \"cc1_cpu\",\t\t\tCC1_CPU_SPEC },\t\t\t\t\\\n   { \"asm_cpu_power5\",\t\tASM_CPU_POWER5_SPEC },\t\t\t\\\n@@ -184,6 +188,10 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define EXTRA_SPEC_FUNCTIONS \\\n   { \"local_cpu_detect\", host_detect_local_cpu },\n #define HAVE_LOCAL_CPU_DETECT\n+#define ASM_CPU_NATIVE_SPEC \"%:local_cpu_detect(asm)\"\n+\n+#else\n+#define ASM_CPU_NATIVE_SPEC \"%(asm_default)\"\n #endif\n \n #ifndef CC1_CPU_SPEC\n@@ -245,6 +253,22 @@ extern const char *host_detect_local_cpu (int argc, const char **argv);\n #define TARGET_DFP 0\n #endif\n \n+/* Define TARGET_POPCNTD if the target assembler does not support the\n+   popcount word and double word instructions.  */\n+\n+#ifndef HAVE_AS_POPCNTD\n+#undef  TARGET_POPCNTD\n+#define TARGET_POPCNTD 0\n+#endif\n+\n+/* Define TARGET_LWSYNC_INSTRUCTION if the assembler knows about lwsync.  If\n+   not, generate the lwsync code as an integer constant.  */\n+#ifdef HAVE_AS_LWSYNC\n+#define TARGET_LWSYNC_INSTRUCTION 1\n+#else\n+#define TARGET_LWSYNC_INSTRUCTION 0\n+#endif\n+\n /* Define TARGET_TLS_MARKERS if the target assembler does not support\n    arg markers for __tls_get_addr calls.  */\n #ifndef HAVE_AS_TLS_MARKERS\n@@ -309,6 +333,7 @@ enum processor_type\n    PROCESSOR_POWER4,\n    PROCESSOR_POWER5,\n    PROCESSOR_POWER6,\n+   PROCESSOR_POWER7,\n    PROCESSOR_CELL\n };\n \n@@ -392,9 +417,15 @@ extern struct rs6000_cpu_select rs6000_select[];\n extern const char *rs6000_debug_name;\t/* Name for -mdebug-xxxx option */\n extern int rs6000_debug_stack;\t\t/* debug stack applications */\n extern int rs6000_debug_arg;\t\t/* debug argument handling */\n+extern int rs6000_debug_reg;\t\t/* debug register handling */\n+extern int rs6000_debug_addr;\t\t/* debug memory addressing */\n+extern int rs6000_debug_cost;\t\t/* debug rtx_costs */\n \n #define\tTARGET_DEBUG_STACK\trs6000_debug_stack\n #define\tTARGET_DEBUG_ARG\trs6000_debug_arg\n+#define TARGET_DEBUG_REG\trs6000_debug_reg\n+#define TARGET_DEBUG_ADDR\trs6000_debug_addr\n+#define TARGET_DEBUG_COST\trs6000_debug_cost\n \n extern const char *rs6000_traceback_name; /* Type of traceback table.  */\n \n@@ -405,13 +436,65 @@ extern int rs6000_ieeequad;\n extern int rs6000_altivec_abi;\n extern int rs6000_spe_abi;\n extern int rs6000_spe;\n-extern int rs6000_isel;\n extern int rs6000_float_gprs;\n extern int rs6000_alignment_flags;\n extern const char *rs6000_sched_insert_nops_str;\n extern enum rs6000_nop_insertion rs6000_sched_insert_nops;\n extern int rs6000_xilinx_fpu;\n \n+/* Describe which vector unit to use for a given machine mode.  */\n+enum rs6000_vector {\n+  VECTOR_NONE,\t\t\t/* Type is not  a vector or not supported */\n+  VECTOR_ALTIVEC,\t\t/* Use altivec for vector processing */\n+  VECTOR_VSX,\t\t\t/* Use VSX for vector processing */\n+  VECTOR_PAIRED,\t\t/* Use paired floating point for vectors */\n+  VECTOR_SPE,\t\t\t/* Use SPE for vector processing */\n+  VECTOR_OTHER\t\t\t/* Some other vector unit */\n+};\n+\n+extern enum rs6000_vector rs6000_vector_unit[];\n+\n+#define VECTOR_UNIT_NONE_P(MODE)\t\t\t\\\n+  (rs6000_vector_unit[(MODE)] == VECTOR_NONE)\n+\n+#define VECTOR_UNIT_VSX_P(MODE)\t\t\t\t\\\n+  (rs6000_vector_unit[(MODE)] == VECTOR_VSX)\n+\n+#define VECTOR_UNIT_ALTIVEC_P(MODE)\t\t\t\\\n+  (rs6000_vector_unit[(MODE)] == VECTOR_ALTIVEC)\n+\n+#define VECTOR_UNIT_ALTIVEC_OR_VSX_P(MODE)\t\t\\\n+  (rs6000_vector_unit[(MODE)] == VECTOR_ALTIVEC \t\\\n+   || rs6000_vector_unit[(MODE)] == VECTOR_VSX)\n+\n+/* Describe whether to use VSX loads or Altivec loads.  For now, just use the\n+   same unit as the vector unit we are using, but we may want to migrate to\n+   using VSX style loads even for types handled by altivec.  */\n+extern enum rs6000_vector rs6000_vector_mem[];\n+\n+#define VECTOR_MEM_NONE_P(MODE)\t\t\t\t\\\n+  (rs6000_vector_mem[(MODE)] == VECTOR_NONE)\n+\n+#define VECTOR_MEM_VSX_P(MODE)\t\t\t\t\\\n+  (rs6000_vector_mem[(MODE)] == VECTOR_VSX)\n+\n+#define VECTOR_MEM_ALTIVEC_P(MODE)\t\t\t\\\n+  (rs6000_vector_mem[(MODE)] == VECTOR_ALTIVEC)\n+\n+#define VECTOR_MEM_ALTIVEC_OR_VSX_P(MODE)\t\t\\\n+  (rs6000_vector_mem[(MODE)] == VECTOR_ALTIVEC \t\\\n+   || rs6000_vector_mem[(MODE)] == VECTOR_VSX)\n+\n+/* Return the alignment of a given vector type, which is set based on the\n+   vector unit use.  VSX for instance can load 32 or 64 bit aligned words\n+   without problems, while Altivec requires 128-bit aligned vectors.  */\n+extern int rs6000_vector_align[];\n+\n+#define VECTOR_ALIGN(MODE)\t\t\t\t\t\t\\\n+  ((rs6000_vector_align[(MODE)] != 0)\t\t\t\t\t\\\n+   ? rs6000_vector_align[(MODE)]\t\t\t\t\t\\\n+   : (int)GET_MODE_BITSIZE ((MODE)))\n+\n /* Alignment options for fields in structures for sub-targets following\n    AIX-like ABI.\n    ALIGN_POWER word-aligns FP doubles (default AIX ABI).\n@@ -432,11 +515,12 @@ extern int rs6000_xilinx_fpu;\n #define TARGET_LONG_DOUBLE_128 (rs6000_long_double_type_size == 128)\n #define TARGET_IEEEQUAD rs6000_ieeequad\n #define TARGET_ALTIVEC_ABI rs6000_altivec_abi\n+#define TARGET_LDBRX (TARGET_POPCNTD || rs6000_cpu == PROCESSOR_CELL)\n \n #define TARGET_SPE_ABI 0\n #define TARGET_SPE 0\n #define TARGET_E500 0\n-#define TARGET_ISEL rs6000_isel\n+#define TARGET_ISEL64 (TARGET_ISEL && TARGET_POWERPC64)\n #define TARGET_FPRS 1\n #define TARGET_E500_SINGLE 0\n #define TARGET_E500_DOUBLE 0\n@@ -534,6 +618,7 @@ extern int rs6000_xilinx_fpu;\n #endif\n #define UNITS_PER_FP_WORD 8\n #define UNITS_PER_ALTIVEC_WORD 16\n+#define UNITS_PER_VSX_WORD 16\n #define UNITS_PER_SPE_WORD 8\n #define UNITS_PER_PAIRED_WORD 8\n \n@@ -598,14 +683,16 @@ extern int rs6000_xilinx_fpu;\n \n /* Width in bits of a pointer.\n    See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE (TARGET_32BIT ? 32 : 64)\n+extern unsigned rs6000_pointer_size;\n+#define POINTER_SIZE rs6000_pointer_size\n \n /* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n #define PARM_BOUNDARY (TARGET_32BIT ? 32 : 64)\n \n /* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY \\\n-  ((TARGET_32BIT && !TARGET_ALTIVEC && !TARGET_ALTIVEC_ABI) ? 64 : 128)\n+#define STACK_BOUNDARY\t\\\n+  ((TARGET_32BIT && !TARGET_ALTIVEC && !TARGET_ALTIVEC_ABI && !TARGET_VSX) \\\n+    ? 64 : 128)\n \n /* Allocation boundary (in *bits*) for the code of a function.  */\n #define FUNCTION_BOUNDARY 32\n@@ -617,10 +704,11 @@ extern int rs6000_xilinx_fpu;\n    local store.  TYPE is the data type, and ALIGN is the alignment\n    that the object would ordinarily have.  */\n #define LOCAL_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\\\n-  ((TARGET_ALTIVEC && TREE_CODE (TYPE) == VECTOR_TYPE) ? 128 :\t\\\n+  (((TARGET_ALTIVEC || TARGET_VSX)\t\t\t\t\\\n+    && TREE_CODE (TYPE) == VECTOR_TYPE) ? 128 :\t\t\t\\\n     (TARGET_E500_DOUBLE\t\t\t\t\t\t\\\n-     && TYPE_MODE (TYPE) == DFmode) ? 64 : \\\n-    ((TARGET_SPE && TREE_CODE (TYPE) == VECTOR_TYPE \\\n+     && TYPE_MODE (TYPE) == DFmode) ? 64 :\t\t\t\\\n+    ((TARGET_SPE && TREE_CODE (TYPE) == VECTOR_TYPE\t\t\\\n      && SPE_VECTOR_MODE (TYPE_MODE (TYPE))) || (TARGET_PAIRED_FLOAT \\\n         && TREE_CODE (TYPE) == VECTOR_TYPE \\\n         && PAIRED_VECTOR_MODE (TYPE_MODE (TYPE)))) ? 64 : ALIGN)\n@@ -678,15 +766,17 @@ extern int rs6000_xilinx_fpu;\n /* Define this macro to be the value 1 if unaligned accesses have a cost\n    many times greater than aligned accesses, for example if they are\n    emulated in a trap handler.  */\n-/* Altivec vector memory instructions simply ignore the low bits; SPE\n-   vector memory instructions trap on unaligned accesses.  */\n+/* Altivec vector memory instructions simply ignore the low bits; SPE vector\n+   memory instructions trap on unaligned accesses; VSX memory instructions are\n+   aligned to 4 or 8 bytes.  */\n #define SLOW_UNALIGNED_ACCESS(MODE, ALIGN)\t\t\t\t\\\n   (STRICT_ALIGNMENT\t\t\t\t\t\t\t\\\n    || (((MODE) == SFmode || (MODE) == DFmode || (MODE) == TFmode\t\\\n \t|| (MODE) == SDmode || (MODE) == DDmode || (MODE) == TDmode\t\\\n \t|| (MODE) == DImode)\t\t\t\t\t\t\\\n        && (ALIGN) < 32)\t\t\t\t\t\t\t\\\n-   || (VECTOR_MODE_P ((MODE)) && (ALIGN) < GET_MODE_BITSIZE ((MODE))))\n+   || (VECTOR_MODE_P ((MODE)) && (((int)(ALIGN)) < VECTOR_ALIGN (MODE))))\n+\n \f\n /* Standard register usage.  */\n \n@@ -913,16 +1003,49 @@ extern int rs6000_xilinx_fpu;\n /* True if register is an AltiVec register.  */\n #define ALTIVEC_REGNO_P(N) ((N) >= FIRST_ALTIVEC_REGNO && (N) <= LAST_ALTIVEC_REGNO)\n \n+/* True if register is a VSX register.  */\n+#define VSX_REGNO_P(N) (FP_REGNO_P (N) || ALTIVEC_REGNO_P (N))\n+\n+/* Alternate name for any vector register supporting floating point, no matter\n+   which instruction set(s) are available.  */\n+#define VFLOAT_REGNO_P(N) \\\n+  (ALTIVEC_REGNO_P (N) || (TARGET_VSX && FP_REGNO_P (N)))\n+\n+/* Alternate name for any vector register supporting integer, no matter which\n+   instruction set(s) are available.  */\n+#define VINT_REGNO_P(N) ALTIVEC_REGNO_P (N)\n+\n+/* Alternate name for any vector register supporting logical operations, no\n+   matter which instruction set(s) are available.  */\n+#define VLOGICAL_REGNO_P(N) VFLOAT_REGNO_P (N)\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.  */\n \n-#define HARD_REGNO_NREGS(REGNO, MODE) rs6000_hard_regno_nregs ((REGNO), (MODE))\n+#define HARD_REGNO_NREGS(REGNO, MODE) rs6000_hard_regno_nregs[(MODE)][(REGNO)]\n \n #define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\\\n   ((TARGET_32BIT && TARGET_POWERPC64\t\t\t\\\n     && (GET_MODE_SIZE (MODE) > 4)  \\\n     && INT_REGNO_P (REGNO)) ? 1 : 0)\n \n+#define VSX_VECTOR_MODE(MODE)\t\t\\\n+\t ((MODE) == V4SFmode\t\t\\\n+\t  || (MODE) == V2DFmode)\t\\\n+\n+#define VSX_SCALAR_MODE(MODE)\t\t\\\n+\t((MODE) == DFmode)\n+\n+#define VSX_MODE(MODE)\t\t\t\\\n+\t(VSX_VECTOR_MODE (MODE)\t\t\\\n+\t || VSX_SCALAR_MODE (MODE))\n+\n+#define VSX_MOVE_MODE(MODE)\t\t\\\n+\t(VSX_VECTOR_MODE (MODE)\t\t\\\n+\t || VSX_SCALAR_MODE (MODE)\t\\\n+\t || ALTIVEC_VECTOR_MODE (MODE)\t\\\n+\t || (MODE) == TImode)\n+\n #define ALTIVEC_VECTOR_MODE(MODE)\t\\\n \t ((MODE) == V16QImode\t\t\\\n \t  || (MODE) == V8HImode\t\t\\\n@@ -938,10 +1061,12 @@ extern int rs6000_xilinx_fpu;\n #define PAIRED_VECTOR_MODE(MODE)        \\\n          ((MODE) == V2SFmode)            \n \n-#define UNITS_PER_SIMD_WORD(MODE)\t\t\t\t     \\\n-\t(TARGET_ALTIVEC ? UNITS_PER_ALTIVEC_WORD\t\t     \\\n-\t : (TARGET_SPE ? UNITS_PER_SPE_WORD : (TARGET_PAIRED_FLOAT ? \\\n-\t UNITS_PER_PAIRED_WORD : UNITS_PER_WORD)))\n+#define UNITS_PER_SIMD_WORD(MODE)\t\t\t\t\t\\\n+\t(TARGET_VSX ? UNITS_PER_VSX_WORD\t\t\t\t\\\n+\t : (TARGET_ALTIVEC ? UNITS_PER_ALTIVEC_WORD\t\t\t\\\n+\t : (TARGET_SPE ? UNITS_PER_SPE_WORD\t\t\t\t\\\n+\t : (TARGET_PAIRED_FLOAT ? UNITS_PER_PAIRED_WORD\t\t\t\\\n+\t : UNITS_PER_WORD))))\n \n /* Value is TRUE if hard register REGNO can hold a value of\n    machine-mode MODE.  */\n@@ -969,6 +1094,10 @@ extern int rs6000_xilinx_fpu;\n    ? ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n    : ALTIVEC_VECTOR_MODE (MODE2)\t\t\\\n    ? ALTIVEC_VECTOR_MODE (MODE1)\t\t\\\n+   : VSX_VECTOR_MODE (MODE1)\t\t\t\\\n+   ? VSX_VECTOR_MODE (MODE2)\t\t\t\\\n+   : VSX_VECTOR_MODE (MODE2)\t\t\t\\\n+   ? VSX_VECTOR_MODE (MODE1)\t\t\t\\\n    : 1)\n \n /* Post-reload, we can't use any new AltiVec registers, as we already\n@@ -1054,9 +1183,10 @@ extern int rs6000_xilinx_fpu;\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-/* The RS/6000 has three types of registers, fixed-point, floating-point,\n-   and condition registers, plus three special registers, MQ, CTR, and the\n-   link register.  AltiVec adds a vector register class.\n+/* The RS/6000 has three types of registers, fixed-point, floating-point, and\n+   condition registers, plus three special registers, MQ, CTR, and the link\n+   register.  AltiVec adds a vector register class.  VSX registers overlap the\n+   FPR registers and the Altivec registers.\n \n    However, r0 is special in that it cannot be used as a base register.\n    So make a class for registers valid as base registers.\n@@ -1169,29 +1299,28 @@ enum reg_class\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO)\t\t\t\\\n- ((REGNO) == 0 ? GENERAL_REGS\t\t\t\\\n-  : (REGNO) < 32 ? BASE_REGS\t\t\t\\\n-  : FP_REGNO_P (REGNO) ? FLOAT_REGS\t\t\\\n-  : ALTIVEC_REGNO_P (REGNO) ? ALTIVEC_REGS\t\\\n-  : (REGNO) == CR0_REGNO ? CR0_REGS\t\t\\\n-  : CR_REGNO_P (REGNO) ? CR_REGS\t\t\\\n-  : (REGNO) == MQ_REGNO ? MQ_REGS\t\t\\\n-  : (REGNO) == LR_REGNO ? LINK_REGS\t\\\n-  : (REGNO) == CTR_REGNO ? CTR_REGS\t\\\n-  : (REGNO) == ARG_POINTER_REGNUM ? BASE_REGS\t\\\n-  : (REGNO) == XER_REGNO ? XER_REGS\t\t\\\n-  : (REGNO) == VRSAVE_REGNO ? VRSAVE_REGS\t\\\n-  : (REGNO) == VSCR_REGNO ? VRSAVE_REGS\t\t\\\n-  : (REGNO) == SPE_ACC_REGNO ? SPE_ACC_REGS\t\\\n-  : (REGNO) == SPEFSCR_REGNO ? SPEFSCR_REGS\t\\\n-  : (REGNO) == FRAME_POINTER_REGNUM ? BASE_REGS\t\\\n-  : NO_REGS)\n+extern enum reg_class rs6000_regno_regclass[FIRST_PSEUDO_REGISTER];\n+\n+#if ENABLE_CHECKING\n+#define REGNO_REG_CLASS(REGNO) \t\t\t\t\t\t\\\n+  (gcc_assert (IN_RANGE ((REGNO), 0, FIRST_PSEUDO_REGISTER-1)),\t\t\\\n+   rs6000_regno_regclass[(REGNO)])\n+\n+#else\n+#define REGNO_REG_CLASS(REGNO) rs6000_regno_regclass[(REGNO)]\n+#endif\n+\n+/* VSX register classes.  */\n+extern enum reg_class rs6000_vector_reg_class[];\n \n /* The class value for index registers, and the one for base regs.  */\n #define INDEX_REG_CLASS GENERAL_REGS\n #define BASE_REG_CLASS BASE_REGS\n \n+/* Return whether a given register class can hold VSX objects.  */\n+#define VSX_REG_CLASS_P(CLASS)\t\t\t\\\n+  ((CLASS) == VSX_REGS || (CLASS) == FLOAT_REGS || (CLASS) == ALTIVEC_REGS)\n+\n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n@@ -1255,15 +1384,10 @@ enum reg_class\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n \n-   On RS/6000, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is enough for two words.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n- (((CLASS) == FLOAT_REGS) \t\t\t\t\t\t\\\n-  ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n-  : (TARGET_E500_DOUBLE && (CLASS) == GENERAL_REGS\t\t\t\\\n-     && (MODE) == DFmode)\t\t\t\t\\\n-  ? 1                                                                   \\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+   On RS/6000, this is the size of MODE in words, except in the FP regs, where\n+   a single reg is enough for two words, unless we have VSX, where the FP\n+   registers can hold 128 bits.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE) rs6000_class_max_nregs[(MODE)][(CLASS)]\n \n /* Return nonzero if for CLASS a mode change from FROM to TO is invalid.  */\n \n@@ -1341,8 +1465,8 @@ extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n   (FRAME_GROWS_DOWNWARD\t\t\t\t\t\t\t\\\n    ? 0\t\t\t\t\t\t\t\t\t\\\n-   : (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\\\n-\t\t    TARGET_ALTIVEC ? 16 : 8)\t\t\t\t\\\n+   : (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\t\\\n+\t\t    (TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\t\t\\\n       + RS6000_SAVE_AREA))\n \n /* Offset from the stack pointer register to an item dynamically\n@@ -1352,8 +1476,8 @@ extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n    length of the outgoing arguments.  The default is correct for most\n    machines.  See `function.c' for details.  */\n #define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\\\n-\t\t TARGET_ALTIVEC ? 16 : 8)\t\t\t\t\\\n+  (RS6000_ALIGN (crtl->outgoing_args_size,\t\t\t\t\\\n+\t\t (TARGET_ALTIVEC || TARGET_VSX) ? 16 : 8)\t\t\\\n    + (STACK_POINTER_OFFSET))\n \n /* If we generate an insn to push BYTES bytes,\n@@ -1603,7 +1727,7 @@ typedef struct rs6000_args\n #define\tEPILOGUE_USES(REGNO)\t\t\t\t\t\\\n   ((reload_completed && (REGNO) == LR_REGNO)\t\t\t\\\n    || (TARGET_ALTIVEC && (REGNO) == VRSAVE_REGNO)\t\t\\\n-   || (crtl->calls_eh_return\t\t\t\t\\\n+   || (crtl->calls_eh_return\t\t\t\t\t\\\n        && TARGET_AIX\t\t\t\t\t\t\\\n        && (REGNO) == 2))\n \n@@ -1892,7 +2016,8 @@ do {\t\t\t\t\t\t\t\t\\\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-#define Pmode (TARGET_32BIT ? SImode : DImode)\n+extern unsigned rs6000_pmode;\n+#define Pmode ((enum machine_mode)rs6000_pmode)\n \n /* Supply definition of STACK_SIZE_MODE for allocate_dynamic_stack_space.  */\n #define STACK_SIZE_MODE (TARGET_32BIT ? SImode : DImode)\n@@ -2233,7 +2358,24 @@ extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0).  */\n   /* no additional names for: mq, lr, ctr, ap */\t\t\\\n   {\"cr0\",  68}, {\"cr1\",  69}, {\"cr2\",  70}, {\"cr3\",  71},\t\\\n   {\"cr4\",  72}, {\"cr5\",  73}, {\"cr6\",  74}, {\"cr7\",  75},\t\\\n-  {\"cc\",   68}, {\"sp\",    1}, {\"toc\",   2} }\n+  {\"cc\",   68}, {\"sp\",    1}, {\"toc\",   2},\t\t\t\\\n+  /* VSX registers overlaid on top of FR, Altivec registers */\t\\\n+  {\"vs0\",  32}, {\"vs1\",  33}, {\"vs2\",  34}, {\"vs3\",  35},\t\\\n+  {\"vs4\",  36}, {\"vs5\",  37}, {\"vs6\",  38}, {\"vs7\",  39},\t\\\n+  {\"vs8\",  40}, {\"vs9\",  41}, {\"vs10\", 42}, {\"vs11\", 43},\t\\\n+  {\"vs12\", 44}, {\"vs13\", 45}, {\"vs14\", 46}, {\"vs15\", 47},\t\\\n+  {\"vs16\", 48}, {\"vs17\", 49}, {\"vs18\", 50}, {\"vs19\", 51},\t\\\n+  {\"vs20\", 52}, {\"vs21\", 53}, {\"vs22\", 54}, {\"vs23\", 55},\t\\\n+  {\"vs24\", 56}, {\"vs25\", 57}, {\"vs26\", 58}, {\"vs27\", 59},\t\\\n+  {\"vs28\", 60}, {\"vs29\", 61}, {\"vs30\", 62}, {\"vs31\", 63},\t\\\n+  {\"vs32\", 77}, {\"vs33\", 78}, {\"vs34\", 79}, {\"vs35\", 80},       \\\n+  {\"vs36\", 81}, {\"vs37\", 82}, {\"vs38\", 83}, {\"vs39\", 84},       \\\n+  {\"vs40\", 85}, {\"vs41\", 86}, {\"vs42\", 87}, {\"vs43\", 88},       \\\n+  {\"vs44\", 89}, {\"vs45\", 90}, {\"vs46\", 91}, {\"vs47\", 92},       \\\n+  {\"vs48\", 93}, {\"vs49\", 94}, {\"vs50\", 95}, {\"vs51\", 96},       \\\n+  {\"vs52\", 97}, {\"vs53\", 98}, {\"vs54\", 99}, {\"vs55\", 100},\t\\\n+  {\"vs56\", 101},{\"vs57\", 102},{\"vs58\", 103},{\"vs59\", 104},      \\\n+  {\"vs60\", 105},{\"vs61\", 106},{\"vs62\", 107},{\"vs63\", 108} }\n \n /* Text to write out after a CALL that may be replaced by glue code by\n    the loader.  This depends on the AIX version.  */"}, {"sha": "9a4079c4fbc7ab8f52160bd4dd81dd0ba475f65d", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 142, "deletions": 58, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -138,7 +138,7 @@\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in rs6000.h.\n \n-(define_attr \"cpu\" \"rios1,rios2,rs64a,mpccore,ppc403,ppc405,ppc440,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,ppce300c2,ppce300c3,ppce500mc,power4,power5,power6,cell\"\n+(define_attr \"cpu\" \"rios1,rios2,rs64a,mpccore,ppc403,ppc405,ppc440,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc630,ppc750,ppc7400,ppc7450,ppc8540,ppce300c2,ppce300c3,ppce500mc,power4,power5,power6,power7,cell\"\n   (const (symbol_ref \"rs6000_cpu_attr\")))\n \n \n@@ -218,6 +218,19 @@\n ; DImode bits\n (define_mode_attr dbits [(QI \"56\") (HI \"48\") (SI \"32\")])\n \n+;; ISEL/ISEL64 target selection\n+(define_mode_attr sel [(SI \"\") (DI \"64\")])\n+\n+;; Suffix for reload patterns\n+(define_mode_attr ptrsize [(SI \"32bit\")\n+\t\t\t   (DI \"64bit\")])\n+\n+(define_mode_attr tptrsize [(SI \"TARGET_32BIT\")\n+\t\t\t    (DI \"TARGET_64BIT\")])\n+\n+(define_mode_attr mptrsize [(SI \"si\")\n+\t\t\t    (DI \"di\")])\n+\n \f\n ;; Start with fixed-point load and store insns.  Here we put only the more\n ;; complex forms.  Basic data transfer is done later.\n@@ -520,7 +533,7 @@\n   \"@\n    {andil.|andi.} %2,%1,0xff\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -546,7 +559,7 @@\n   \"@\n    {andil.|andi.} %0,%1,0xff\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -687,7 +700,7 @@\n   \"@\n    {andil.|andi.} %2,%1,0xff\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -713,7 +726,7 @@\n   \"@\n    {andil.|andi.} %0,%1,0xff\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -856,7 +869,7 @@\n   \"@\n    {andil.|andi.} %2,%1,0xffff\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -882,7 +895,7 @@\n   \"@\n    {andil.|andi.} %0,%1,0xffff\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -1670,7 +1683,7 @@\n   \"@\n    nor. %2,%1,%1\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -1696,7 +1709,7 @@\n   \"@\n    nor. %0,%1,%1\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -2221,10 +2234,22 @@\n   \"TARGET_POPCNTB\"\n   \"popcntb %0,%1\")\n \n+(define_insn \"popcntwsi2\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(popcount:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POPCNTD\"\n+  \"popcntw %0,%1\")\n+\n+(define_insn \"popcntddi2\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(popcount:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_POPCNTD && TARGET_POWERPC64\"\n+  \"popcntd %0,%1\")\n+\n (define_expand \"popcount<mode>2\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n \t(popcount:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_POPCNTB\"\n+  \"TARGET_POPCNTB || TARGET_POPCNTD\"\n   {\n     rs6000_emit_popcount (operands[0], operands[1]);\n     DONE;\n@@ -2852,7 +2877,7 @@\n    {rlinm|rlwinm} %0,%1,0,%m2,%M2\n    {andil.|andi.} %0,%1,%b2\n    {andiu.|andis.} %0,%1,%u2\"\n-  [(set_attr \"type\" \"*,*,compare,compare\")])\n+  [(set_attr \"type\" \"*,*,fast_compare,fast_compare\")])\n \n (define_insn \"andsi3_nomc\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n@@ -2895,7 +2920,8 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n+  [(set_attr \"type\" \"fast_compare,fast_compare,fast_compare,delayed_compare,\\\n+\t\t     compare,compare,compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n \n (define_insn \"*andsi3_internal3_mc\"\n@@ -2915,7 +2941,8 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n+  [(set_attr \"type\" \"compare,fast_compare,fast_compare,delayed_compare,compare,\\\n+\t\t     compare,compare,compare\")\n    (set_attr \"length\" \"8,4,4,4,8,8,8,8\")])\n \n (define_split\n@@ -2974,7 +3001,8 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n+  [(set_attr \"type\" \"fast_compare,fast_compare,fast_compare,delayed_compare,\\\n+\t\t     compare,compare,compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,8,8,8,8\")])\n \n (define_insn \"*andsi3_internal5_mc\"\n@@ -2996,7 +3024,8 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"compare,compare,compare,delayed_compare,compare,compare,compare,compare\")\n+  [(set_attr \"type\" \"compare,fast_compare,fast_compare,delayed_compare,compare,\\\n+\t\t     compare,compare,compare\")\n    (set_attr \"length\" \"8,4,4,4,8,8,8,8\")])\n \n (define_split\n@@ -3127,7 +3156,7 @@\n   \"@\n    %q4. %3,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -3156,7 +3185,7 @@\n   \"@\n    %q4. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -3281,7 +3310,7 @@\n   \"@\n    %q4. %3,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -3310,7 +3339,7 @@\n   \"@\n    %q4. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -5303,7 +5332,7 @@\n   \"fres %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"\"\n+(define_insn \"*fmaddsf4_powerpc\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5314,7 +5343,7 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n \n-(define_insn \"\"\n+(define_insn \"*fmaddsf4_power\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5323,7 +5352,7 @@\n   \"{fma|fmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n-(define_insn \"\"\n+(define_insn \"*fmsubsf4_powerpc\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5334,7 +5363,7 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n \n-(define_insn \"\"\n+(define_insn \"*fmsubsf4_power\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5343,7 +5372,7 @@\n   \"{fms|fmsub} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmaddsf4_powerpc_1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5354,7 +5383,7 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmaddsf4_powerpc_2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (mult:SF (neg:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\"))\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5365,7 +5394,7 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmaddsf4_power_1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t  (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5374,7 +5403,7 @@\n   \"{fnma|fnmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmaddsf4_power_2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (mult:SF (neg:SF (match_operand:SF 1 \"gpc_reg_operand\" \"f\"))\n \t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5384,7 +5413,7 @@\n   \"{fnma|fnmadd} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmsubsf4_powerpc_1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(neg:SF (minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5395,7 +5424,7 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmsubsf4_powerpc_2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (match_operand:SF 3 \"gpc_reg_operand\" \"f\")\n \t\t  (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n@@ -5406,7 +5435,7 @@\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_type\" \"fp_maddsub_s\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmsubsf4_power_1\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(neg:SF (minus:SF (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n \t\t\t\t   (match_operand:SF 2 \"gpc_reg_operand\" \"f\"))\n@@ -5415,7 +5444,7 @@\n   \"{fnms|fnmsub} %0,%1,%2,%3\"\n   [(set_attr \"type\" \"dmul\")])\n \n-(define_insn \"\"\n+(define_insn \"*fnmsubsf4_power_2\"\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"=f\")\n \t(minus:SF (match_operand:SF 3 \"gpc_reg_operand\" \"f\")\n \t\t  (mult:SF (match_operand:SF 1 \"gpc_reg_operand\" \"%f\")\n@@ -5542,12 +5571,12 @@\n   DONE;\n }\")\n \n-(define_expand \"movsicc\"\n-   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t (if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t  (match_operand:SI 2 \"gpc_reg_operand\" \"\")\n-\t\t\t  (match_operand:SI 3 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_ISEL\"\n+(define_expand \"mov<mode>cc\"\n+   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+\t (if_then_else:GPR (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t   (match_operand:GPR 2 \"gpc_reg_operand\" \"\")\n+\t\t\t   (match_operand:GPR 3 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_ISEL<sel>\"\n   \"\n {\n   if (rs6000_emit_cmove (operands[0], operands[1], operands[2], operands[3]))\n@@ -5564,28 +5593,28 @@\n ;; leave out the mode in operand 4 and use one pattern, but reload can\n ;; change the mode underneath our feet and then gets confused trying\n ;; to reload the value.\n-(define_insn \"isel_signed\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(if_then_else:SI\n+(define_insn \"isel_signed_<mode>\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:GPR\n \t (match_operator 1 \"comparison_operator\"\n \t\t\t [(match_operand:CC 4 \"cc_reg_operand\" \"y\")\n \t\t\t  (const_int 0)])\n-\t (match_operand:SI 2 \"gpc_reg_operand\" \"b\")\n-\t (match_operand:SI 3 \"gpc_reg_operand\" \"b\")))]\n-  \"TARGET_ISEL\"\n+\t (match_operand:GPR 2 \"gpc_reg_operand\" \"b\")\n+\t (match_operand:GPR 3 \"gpc_reg_operand\" \"b\")))]\n+  \"TARGET_ISEL<sel>\"\n   \"*\n { return output_isel (operands); }\"\n   [(set_attr \"length\" \"4\")])\n \n-(define_insn \"isel_unsigned\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(if_then_else:SI\n+(define_insn \"isel_unsigned_<mode>\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(if_then_else:GPR\n \t (match_operator 1 \"comparison_operator\"\n \t\t\t [(match_operand:CCUNS 4 \"cc_reg_operand\" \"y\")\n \t\t\t  (const_int 0)])\n-\t (match_operand:SI 2 \"gpc_reg_operand\" \"b\")\n-\t (match_operand:SI 3 \"gpc_reg_operand\" \"b\")))]\n-  \"TARGET_ISEL\"\n+\t (match_operand:GPR 2 \"gpc_reg_operand\" \"b\")\n+\t (match_operand:GPR 3 \"gpc_reg_operand\" \"b\")))]\n+  \"TARGET_ISEL<sel>\"\n   \"*\n { return output_isel (operands); }\"\n   [(set_attr \"length\" \"4\")])\n@@ -5898,6 +5927,12 @@\n  \"TARGET_HARD_FLOAT && !TARGET_FPRS && TARGET_SINGLE_FLOAT\"\n  \"\")\n \n+(define_expand \"fixuns_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\"\n+  \"\")\n+\n ; For each of these conversions, there is a define_expand, a define_insn\n ; with a '#' template, and a define_split (with C code).  The idea is\n ; to allow constant folding with the template of the define_insn,\n@@ -7609,7 +7644,7 @@\n    andi. %0,%1,%b2\n    andis. %0,%1,%u2\n    #\"\n-  [(set_attr \"type\" \"*,*,*,compare,compare,*\")\n+  [(set_attr \"type\" \"*,*,*,fast_compare,fast_compare,*\")\n    (set_attr \"length\" \"4,4,4,4,4,8\")])\n \n (define_insn \"anddi3_nomc\"\n@@ -7667,7 +7702,9 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"compare,compare,delayed_compare,compare,compare,compare,compare,compare,compare,compare,compare,compare\")\n+  [(set_attr \"type\" \"fast_compare,compare,delayed_compare,fast_compare,\\\n+\t\t     fast_compare,compare,compare,compare,compare,compare,\\\n+\t\t     compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,4,8,8,8,8,8,8,12\")])\n \n (define_split\n@@ -7718,7 +7755,9 @@\n    #\n    #\n    #\"\n-  [(set_attr \"type\" \"compare,compare,delayed_compare,compare,compare,compare,compare,compare,compare,compare,compare,compare\")\n+  [(set_attr \"type\" \"fast_compare,compare,delayed_compare,fast_compare,\\\n+\t\t     fast_compare,compare,compare,compare,compare,compare,\\\n+\t\t     compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,4,8,8,8,8,8,8,12\")])\n \n (define_split\n@@ -7858,7 +7897,7 @@\n   \"@\n    %q4. %3,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -7887,7 +7926,7 @@\n   \"@\n    %q4. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -7958,7 +7997,7 @@\n   \"@\n    %q4. %3,%2,%1\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -7987,7 +8026,7 @@\n   \"@\n    %q4. %0,%2,%1\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -8024,7 +8063,7 @@\n   \"@\n    %q4. %3,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -8053,7 +8092,7 @@\n   \"@\n    %q4. %0,%1,%2\n    #\"\n-  [(set_attr \"type\" \"compare\")\n+  [(set_attr \"type\" \"fast_compare,compare\")\n    (set_attr \"length\" \"4,8\")])\n \n (define_split\n@@ -8070,6 +8109,51 @@\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n+\n+(define_expand \"smindi3\"\n+  [(match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 2 \"gpc_reg_operand\" \"\")]\n+  \"TARGET_ISEL64\"\n+  \"\n+{\n+  rs6000_emit_minmax (operands[0], SMIN, operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n+(define_expand \"smaxdi3\"\n+  [(match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 2 \"gpc_reg_operand\" \"\")]\n+  \"TARGET_ISEL64\"\n+  \"\n+{\n+  rs6000_emit_minmax (operands[0], SMAX, operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n+(define_expand \"umindi3\"\n+  [(match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 2 \"gpc_reg_operand\" \"\")]\n+  \"TARGET_ISEL64\"\n+  \"\n+{\n+  rs6000_emit_minmax (operands[0], UMIN, operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n+(define_expand \"umaxdi3\"\n+  [(match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+   (match_operand:DI 2 \"gpc_reg_operand\" \"\")]\n+  \"TARGET_ISEL64\"\n+  \"\n+{\n+  rs6000_emit_minmax (operands[0], UMAX, operands[1], operands[2]);\n+  DONE;\n+}\")\n+\n \f\n ;; Now define ways of moving data around.\n "}, {"sha": "00bd1b0e7a0d084b6212f38ae6ef031ac7d26dd7", "filename": "gcc/config/rs6000/rs6000.opt", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Frs6000.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.opt?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -111,24 +111,24 @@ mhard-float\n Target Report RejectNegative InverseMask(SOFT_FLOAT, HARD_FLOAT)\n Use hardware floating point\n \n-mno-update\n-Target Report RejectNegative Mask(NO_UPDATE)\n-Do not generate load/store with update instructions\n+mpopcntd\n+Target Report Mask(POPCNTD)\n+Use PowerPC V2.06 popcntd instruction\n+\n+mvsx\n+Target Report Mask(VSX)\n+Use vector/scalar (VSX) instructions\n \n mupdate\n-Target Report RejectNegative InverseMask(NO_UPDATE, UPDATE)\n+Target Report Var(TARGET_UPDATE) Init(1)\n Generate load/store with update instructions\n \n mavoid-indexed-addresses\n Target Report Var(TARGET_AVOID_XFORM) Init(-1)\n Avoid generation of indexed load/store instructions when possible\n \n-mno-fused-madd\n-Target Report RejectNegative Mask(NO_FUSED_MADD)\n-Do not generate fused multiply/add instructions\n-\n mfused-madd\n-Target Report RejectNegative InverseMask(NO_FUSED_MADD, FUSED_MADD)\n+Target Report Var(TARGET_FUSED_MADD) Init(1)\n Generate fused multiply/add instructions\n \n mtls-markers\n@@ -198,7 +198,7 @@ Target RejectNegative Joined\n -mvrsave=yes/no\tDeprecated option.  Use -mvrsave/-mno-vrsave instead\n \n misel\n-Target\n+Target Report Mask(ISEL)\n Generate isel instructions\n \n misel="}, {"sha": "917f817c2bf1fb3bef6b4925e8df22d92de80fd6", "filename": "gcc/config/rs6000/spe.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fspe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fspe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fspe.md?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,5 +1,5 @@\n ;; e500 SPE description\n-;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+;; Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n ;; Free Software Foundation, Inc.\n ;; Contributed by Aldy Hernandez (aldy@quesejoda.com)\n \n@@ -99,7 +99,7 @@\n \n ;; Floating point conversion instructions.\n \n-(define_insn \"fixuns_truncdfsi2\"\n+(define_insn \"spe_fixuns_truncdfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n \t(unsigned_fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_HARD_FLOAT && TARGET_E500_DOUBLE\""}, {"sha": "f6cc91d3d56add23b3c0bb4faf73057982cb2e48", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -616,7 +616,7 @@\n   if (TARGET_NO_LWSYNC)\n     return \"sync\";\n   else\n-    return \".long 0x7c2004ac\";\n+    return (TARGET_LWSYNC_INSTRUCTION) ? \"lwsync\" : \".long 0x7c2004ac\";\n }\n   [(set_attr \"type\" \"sync\")])\n "}, {"sha": "4d28e375363939dc8a888cafa475e8119221cca4", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -125,9 +125,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n   else if (!strcmp (rs6000_abi_name, \"i960-old\"))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rs6000_current_abi = ABI_V4;\t\t\t\t\t\\\n-      target_flags |= (MASK_LITTLE_ENDIAN | MASK_EABI\t\t\t\\\n-\t\t       | MASK_NO_BITFIELD_WORD);\t\t\t\\\n+      target_flags |= (MASK_LITTLE_ENDIAN | MASK_EABI);\t\t\t\\\n       target_flags &= ~MASK_STRICT_ALIGN;\t\t\t\t\\\n+      TARGET_NO_BITFIELD_WORD = 1;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\"}, {"sha": "428417ec4a8fc33a097d5dc7cbe199046832b214", "filename": "gcc/config/rs6000/sysv4.opt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Fsysv4.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.opt?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -1,6 +1,6 @@\n ; SYSV4 options for PPC port.\n ;\n-; Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.\n+; Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.\n ; Contributed by Aldy Hernandez <aldy@quesejoda.com>.\n ;\n ; This file is part of GCC.\n@@ -32,7 +32,7 @@ Target RejectNegative Joined\n Specify bit size of immediate TLS offsets\n \n mbit-align\n-Target Report Mask(NO_BITFIELD_TYPE)\n+Target Report Var(TARGET_NO_BITFIELD_TYPE)\n Align to the base type of the bit-field\n \n mstrict-align\n@@ -87,11 +87,11 @@ Target Report Mask(EABI)\n Use EABI\n \n mbit-word\n-Target Report Mask(NO_BITFIELD_WORD)\n+Target Report Var(TARGET_NO_BITFIELD_WORD)\n Allow bit-fields to cross word boundaries\n \n mregnames\n-Target Mask(REGNAMES)\n+Target Var(TARGET_REGNAMES)\n Use alternate register names\n \n ;; This option does nothing and only exists because the compiler"}, {"sha": "695f5799f11afbb78cbf009bfe713a5c23e48588", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -36,3 +36,30 @@ rs6000-c.o: $(srcdir)/config/rs6000/rs6000-c.c \\\n \n # The rs6000 backend doesn't cause warnings in these files.\n insn-conditions.o-warn =\n+\n+MD_INCLUDES = $(srcdir)/config/rs6000/rios1.md \\\n+\t$(srcdir)/config/rs6000/rios2.md \\\n+\t$(srcdir)/config/rs6000/rs64.md \\\n+\t$(srcdir)/config/rs6000/mpc.md \\\n+\t$(srcdir)/config/rs6000/40x.md \\\n+\t$(srcdir)/config/rs6000/440.md \\\n+\t$(srcdir)/config/rs6000/603.md \\\n+\t$(srcdir)/config/rs6000/6xx.md \\\n+\t$(srcdir)/config/rs6000/7xx.md \\\n+\t$(srcdir)/config/rs6000/7450.md \\\n+\t$(srcdir)/config/rs6000/8540.md \\\n+\t$(srcdir)/config/rs6000/e300c2c3.md \\\n+\t$(srcdir)/config/rs6000/e500mc.md \\\n+\t$(srcdir)/config/rs6000/power4.md \\\n+\t$(srcdir)/config/rs6000/power5.md \\\n+\t$(srcdir)/config/rs6000/power6.md \\\n+\t$(srcdir)/config/rs6000/cell.md \\\n+\t$(srcdir)/config/rs6000/xfpu.md \\\n+\t$(srcdir)/config/rs6000/predicates.md \\\n+\t$(srcdir)/config/rs6000/constraints.md \\\n+\t$(srcdir)/config/rs6000/darwin.md \\\n+\t$(srcdir)/config/rs6000/sync.md \\\n+\t$(srcdir)/config/rs6000/altivec.md \\\n+\t$(srcdir)/config/rs6000/spe.md \\\n+\t$(srcdir)/config/rs6000/dfp.md \\\n+\t$(srcdir)/config/rs6000/paired.md"}, {"sha": "8fc162dd2ef649ea46c94d1bee0b294a9b878cf3", "filename": "gcc/configure", "status": "modified", "additions": 94, "deletions": 4, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -23234,7 +23234,7 @@ if test \"${gcc_cv_as_powerpc_mfpgpr+set}\" = set; then\n else\n   gcc_cv_as_powerpc_mfpgpr=no\n     if test $in_tree_gas = yes; then\n-    if test $gcc_cv_gas_vers -ge `expr \\( \\( 9 \\* 1000 \\) + 99 \\) \\* 1000 + 0`\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 19 \\) \\* 1000 + 2`\n   then gcc_cv_as_powerpc_mfpgpr=yes\n fi\n   elif test x$gcc_cv_as != x; then\n@@ -23330,7 +23330,7 @@ if test \"${gcc_cv_as_powerpc_cmpb+set}\" = set; then\n else\n   gcc_cv_as_powerpc_cmpb=no\n     if test $in_tree_gas = yes; then\n-    if test $gcc_cv_gas_vers -ge `expr \\( \\( 9 \\* 1000 \\) + 99 \\) \\* 1000 + 0`\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 19 \\) \\* 1000 + 2`\n   then gcc_cv_as_powerpc_cmpb=yes\n fi\n   elif test x$gcc_cv_as != x; then\n@@ -23376,7 +23376,7 @@ if test \"${gcc_cv_as_powerpc_dfp+set}\" = set; then\n else\n   gcc_cv_as_powerpc_dfp=no\n     if test $in_tree_gas = yes; then\n-    if test $gcc_cv_gas_vers -ge `expr \\( \\( 9 \\* 1000 \\) + 99 \\) \\* 1000 + 0`\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 19 \\) \\* 1000 + 2`\n   then gcc_cv_as_powerpc_dfp=yes\n fi\n   elif test x$gcc_cv_as != x; then\n@@ -23422,7 +23422,7 @@ if test \"${gcc_cv_as_powerpc_vsx+set}\" = set; then\n else\n   gcc_cv_as_powerpc_vsx=no\n     if test $in_tree_gas = yes; then\n-    if test $gcc_cv_gas_vers -ge `expr \\( \\( 9 \\* 1000 \\) + 99 \\) \\* 1000 + 0`\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 19 \\) \\* 1000 + 2`\n   then gcc_cv_as_powerpc_vsx=yes\n fi\n   elif test x$gcc_cv_as != x; then\n@@ -23450,6 +23450,96 @@ cat >>confdefs.h <<\\_ACEOF\n #define HAVE_AS_VSX 1\n _ACEOF\n \n+fi\n+\n+    case $target in\n+      *-*-aix*) conftest_s='\t.machine \"pwr7\"\n+\t.csect .text[PR]\n+\tpopcntd 3,3';;\n+      *) conftest_s='\t.machine power7\n+\t.text\n+\tpopcntd 3,3';;\n+    esac\n+\n+    echo \"$as_me:$LINENO: checking assembler for popcntd support\" >&5\n+echo $ECHO_N \"checking assembler for popcntd support... $ECHO_C\" >&6\n+if test \"${gcc_cv_as_powerpc_popcntd+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  gcc_cv_as_powerpc_popcntd=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 19 \\) \\* 1000 + 2`\n+  then gcc_cv_as_powerpc_popcntd=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    echo \"$conftest_s\" > conftest.s\n+    if { ac_try='$gcc_cv_as -a32 -o conftest.o conftest.s >&5'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }\n+    then\n+\tgcc_cv_as_powerpc_popcntd=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+echo \"$as_me:$LINENO: result: $gcc_cv_as_powerpc_popcntd\" >&5\n+echo \"${ECHO_T}$gcc_cv_as_powerpc_popcntd\" >&6\n+if test $gcc_cv_as_powerpc_popcntd = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_AS_POPCNTD 1\n+_ACEOF\n+\n+fi\n+\n+    case $target in\n+      *-*-aix*) conftest_s='\t.csect .text[PR]\n+\tlwsync';;\n+      *) conftest_s='\t.text\n+\tlwsync';;\n+    esac\n+\n+    echo \"$as_me:$LINENO: checking assembler for lwsync support\" >&5\n+echo $ECHO_N \"checking assembler for lwsync support... $ECHO_C\" >&6\n+if test \"${gcc_cv_as_powerpc_lwsync+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  gcc_cv_as_powerpc_lwsync=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 19 \\) \\* 1000 + 2`\n+  then gcc_cv_as_powerpc_lwsync=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    echo \"$conftest_s\" > conftest.s\n+    if { ac_try='$gcc_cv_as -a32 -o conftest.o conftest.s >&5'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }\n+    then\n+\tgcc_cv_as_powerpc_lwsync=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+echo \"$as_me:$LINENO: result: $gcc_cv_as_powerpc_lwsync\" >&5\n+echo \"${ECHO_T}$gcc_cv_as_powerpc_lwsync\" >&6\n+if test $gcc_cv_as_powerpc_lwsync = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_AS_LWSYNC 1\n+_ACEOF\n+\n fi\n \n     echo \"$as_me:$LINENO: checking assembler for .gnu_attribute support\" >&5"}, {"sha": "341571ccdf69d04caf0aafa6b43df9ee5cfd6ad1", "filename": "gcc/configure.ac", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cacf1ca8c1028433255434d766a730734ad3296d/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=cacf1ca8c1028433255434d766a730734ad3296d", "patch": "@@ -3125,7 +3125,7 @@ foo:\tnop\n     esac\n \n     gcc_GAS_CHECK_FEATURE([move fp gpr support],\n-      gcc_cv_as_powerpc_mfpgpr, [9,99,0],,\n+      gcc_cv_as_powerpc_mfpgpr, [2,19,2],,\n       [$conftest_s],,\n       [AC_DEFINE(HAVE_AS_MFPGPR, 1,\n \t  [Define if your assembler supports mffgpr and mftgpr.])])\n@@ -3159,7 +3159,7 @@ LCF0:\n     esac\n \n     gcc_GAS_CHECK_FEATURE([compare bytes support],\n-      gcc_cv_as_powerpc_cmpb, [9,99,0], -a32,\n+      gcc_cv_as_powerpc_cmpb, [2,19,2], -a32,\n       [$conftest_s],,\n       [AC_DEFINE(HAVE_AS_CMPB, 1,\n \t  [Define if your assembler supports cmpb.])])\n@@ -3174,7 +3174,7 @@ LCF0:\n     esac\n \n     gcc_GAS_CHECK_FEATURE([decimal float support],\n-      gcc_cv_as_powerpc_dfp, [9,99,0], -a32,\n+      gcc_cv_as_powerpc_dfp, [2,19,2], -a32,\n       [$conftest_s],,\n       [AC_DEFINE(HAVE_AS_DFP, 1,\n \t  [Define if your assembler supports DFP instructions.])])\n@@ -3189,11 +3189,39 @@ LCF0:\n     esac\n \n     gcc_GAS_CHECK_FEATURE([vector-scalar support],\n-      gcc_cv_as_powerpc_vsx, [9,99,0], -a32,\n+      gcc_cv_as_powerpc_vsx, [2,19,2], -a32,\n       [$conftest_s],,\n       [AC_DEFINE(HAVE_AS_VSX, 1,\n \t  [Define if your assembler supports VSX instructions.])])\n \n+    case $target in\n+      *-*-aix*) conftest_s='\t.machine \"pwr7\"\n+\t.csect .text[[PR]]\n+\tpopcntd 3,3';;\n+      *) conftest_s='\t.machine power7\n+\t.text\n+\tpopcntd 3,3';;\n+    esac\n+\n+    gcc_GAS_CHECK_FEATURE([popcntd support],\n+      gcc_cv_as_powerpc_popcntd, [2,19,2], -a32,\n+      [$conftest_s],,\n+      [AC_DEFINE(HAVE_AS_POPCNTD, 1,\n+\t  [Define if your assembler supports POPCNTD instructions.])])\n+\n+    case $target in\n+      *-*-aix*) conftest_s='\t.csect .text[[PR]]\n+\tlwsync';;\n+      *) conftest_s='\t.text\n+\tlwsync';;\n+    esac\n+\n+    gcc_GAS_CHECK_FEATURE([lwsync support],\n+      gcc_cv_as_powerpc_lwsync, [2,19,2], -a32,\n+      [$conftest_s],,\n+      [AC_DEFINE(HAVE_AS_LWSYNC, 1,\n+\t  [Define if your assembler supports LWSYNC instructions.])])\n+\n     gcc_GAS_CHECK_FEATURE([.gnu_attribute support],\n       gcc_cv_as_powerpc_gnu_attribute, [2,18,0],,\n       [.gnu_attribute 4,1],,"}]}