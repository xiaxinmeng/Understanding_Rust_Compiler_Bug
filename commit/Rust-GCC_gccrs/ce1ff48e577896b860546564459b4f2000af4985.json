{"sha": "ce1ff48e577896b860546564459b4f2000af4985", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxZmY0OGU1Nzc4OTZiODYwNTQ2NTY0NDU5YjRmMjAwMGFmNDk4NQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-02-20T18:26:59Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2016-02-20T18:26:59Z"}, "message": "re PR fortran/69423 (Invalid optimization with deferred-length character)\n\n2016-02-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/69423\n\t* trans-decl.c (create_function_arglist): Deferred character\n\tlength functions, with and without declared results, address\n\tthe passed reference type as '.result' and the local string\n\tlength as '..result'.\n\t(gfc_null_and_pass_deferred_len): Helper function to null and\n\treturn deferred string lengths, as needed.\n\t(gfc_trans_deferred_vars): Call it, thereby reducing repeated\n\tcode, add call for deferred arrays and reroute pointer function\n\tresults. Avoid using 'tmp' for anything other that a temporary\n\ttree by introducing 'type_of_array' for the arrayspec type.\n\n2016-02-20  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/69423\n\t* gfortran.dg/deferred_character_15.f90 : New test.\n\nFrom-SVN: r233589", "tree": {"sha": "5affc9fbd102413c5ceed1275a056bb5d8a342d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5affc9fbd102413c5ceed1275a056bb5d8a342d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce1ff48e577896b860546564459b4f2000af4985", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1ff48e577896b860546564459b4f2000af4985", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce1ff48e577896b860546564459b4f2000af4985", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce1ff48e577896b860546564459b4f2000af4985/comments", "author": null, "committer": null, "parents": [{"sha": "bbf27208564cdf8fb583f958ec5d910c3a7d9718", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbf27208564cdf8fb583f958ec5d910c3a7d9718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbf27208564cdf8fb583f958ec5d910c3a7d9718"}], "stats": {"total": 311, "additions": 201, "deletions": 110}, "files": [{"sha": "99d13666804ba5065a646d0707be4e6a1827b290", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ce1ff48e577896b860546564459b4f2000af4985", "patch": "@@ -1,3 +1,17 @@\n+2016-02-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/69423\n+\t* trans-decl.c (create_function_arglist): Deferred character\n+\tlength functions, with and without declared results, address\n+\tthe passed reference type as '.result' and the local string\n+\tlength as '..result'.\n+\t(gfc_null_and_pass_deferred_len): Helper function to null and\n+\treturn deferred string lengths, as needed.\n+\t(gfc_trans_deferred_vars): Call it, thereby reducing repeated\n+\tcode, add call for deferred arrays and reroute pointer function\n+\tresults. Avoid using 'tmp' for anything other that a temporary\n+\ttree by introducing 'type_of_array' for the arrayspec type.\n+\n 2015-02-16  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/69742"}, {"sha": "4e7129e150a92f9a3c254764a02f63b54fa3883a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 138, "deletions": 110, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=ce1ff48e577896b860546564459b4f2000af4985", "patch": "@@ -2234,7 +2234,12 @@ create_function_arglist (gfc_symbol * sym)\n \t\t\t       PARM_DECL,\n \t\t\t       get_identifier (\".__result\"),\n \t\t\t       len_type);\n-\t  if (!sym->ts.u.cl->length)\n+\t  if (POINTER_TYPE_P (len_type))\n+\t    {\n+\t      sym->ts.u.cl->passed_length = length;\n+\t      TREE_USED (length) = 1;\n+\t    }\n+\t  else if (!sym->ts.u.cl->length)\n \t    {\n \t      sym->ts.u.cl->backend_decl = length;\n \t      TREE_USED (length) = 1;\n@@ -2271,13 +2276,6 @@ create_function_arglist (gfc_symbol * sym)\n \t      type = gfc_sym_type (arg);\n \t      arg->backend_decl = backend_decl;\n \t      type = build_reference_type (type);\n-\n-\t      if (POINTER_TYPE_P (len_type))\n-\t\t{\n-\t\t  sym->ts.u.cl->passed_length = length;\n-\t\t  sym->ts.u.cl->backend_decl =\n-\t\t    build_fold_indirect_ref_loc (input_location, length);\n-\t\t}\n \t    }\n \t}\n \n@@ -3917,6 +3915,62 @@ init_intent_out_dt (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n }\n \n \n+/* Helper function to manage deferred string lengths.  */\n+\n+static tree\n+gfc_null_and_pass_deferred_len (gfc_symbol *sym, stmtblock_t *init,\n+\t\t\t        locus *loc)\n+{\n+  tree tmp;\n+\n+  /* Character length passed by reference.  */\n+  tmp = sym->ts.u.cl->passed_length;\n+  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n+  tmp = fold_convert (gfc_charlen_type_node, tmp);\n+\n+  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)\n+    /* Zero the string length when entering the scope.  */\n+    gfc_add_modify (init, sym->ts.u.cl->backend_decl,\n+\t\t    build_int_cst (gfc_charlen_type_node, 0));\n+  else\n+    {\n+      tree tmp2;\n+\n+      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t      gfc_charlen_type_node,\n+\t\t\t      sym->ts.u.cl->backend_decl, tmp);\n+      if (sym->attr.optional)\n+\t{\n+\t  tree present = gfc_conv_expr_present (sym);\n+\t  tmp2 = build3_loc (input_location, COND_EXPR,\n+\t\t\t     void_type_node, present, tmp2,\n+\t\t\t     build_empty_stmt (input_location));\n+\t}\n+      gfc_add_expr_to_block (init, tmp2);\n+    }\n+\n+  gfc_restore_backend_locus (loc);\n+\n+  /* Pass the final character length back.  */\n+  if (sym->attr.intent != INTENT_IN)\n+    {\n+      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n+\t\t\t     gfc_charlen_type_node, tmp,\n+\t\t\t     sym->ts.u.cl->backend_decl);\n+      if (sym->attr.optional)\n+\t{\n+\t  tree present = gfc_conv_expr_present (sym);\n+\t  tmp = build3_loc (input_location, COND_EXPR,\n+\t\t\t    void_type_node, present, tmp,\n+\t\t\t    build_empty_stmt (input_location));\n+\t}\n+    }\n+  else\n+    tmp = NULL_TREE;\n+\n+  return tmp;\n+}\n+\n /* Generate function entry and exit code, and add it to the function body.\n    This includes:\n     Allocation and initialization of array variables.\n@@ -3966,7 +4020,19 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t  /* An automatic character length, pointer array result.  */\n \t  if (proc_sym->ts.type == BT_CHARACTER\n \t\t&& TREE_CODE (proc_sym->ts.u.cl->backend_decl) == VAR_DECL)\n-\t    gfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);\n+\t    {\n+\t      tmp = NULL;\n+\t      if (proc_sym->ts.deferred)\n+\t\t{\n+\t\t  gfc_save_backend_locus (&loc);\n+\t\t  gfc_set_backend_locus (&proc_sym->declared_at);\n+\t\t  gfc_start_block (&init);\n+\t\t  tmp = gfc_null_and_pass_deferred_len (proc_sym, &init, &loc);\n+\t\t  gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n+\t\t}\n+\t      else\n+\t\tgfc_trans_dummy_character (proc_sym, proc_sym->ts.u.cl, block);\n+\t    }\n \t}\n       else if (proc_sym->ts.type == BT_CHARACTER)\n \t{\n@@ -3993,7 +4059,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n \t      /* Pass back the string length on exit.  */\n \t      tmp = proc_sym->ts.u.cl->backend_decl;\n-\t      if (TREE_CODE (tmp) != INDIRECT_REF)\n+\t      if (TREE_CODE (tmp) != INDIRECT_REF\n+\t\t  && proc_sym->ts.u.cl->passed_length)\n \t\t{\n \t\t  tmp = proc_sym->ts.u.cl->passed_length;\n \t\t  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n@@ -4072,21 +4139,21 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t= gfc_class_set_static_fields (sym->backend_decl, vptr, tmp);\n \t  TREE_CONSTANT (DECL_INITIAL (sym->backend_decl)) = 1;\n \t}\n-      else if (sym->attr.dimension || sym->attr.codimension\n-\t       || (IS_CLASS_ARRAY (sym) && !CLASS_DATA (sym)->attr.allocatable))\n+      else if ((sym->attr.dimension || sym->attr.codimension\n+\t       || (IS_CLASS_ARRAY (sym) && !CLASS_DATA (sym)->attr.allocatable)))\n \t{\n \t  bool is_classarray = IS_CLASS_ARRAY (sym);\n \t  symbol_attribute *array_attr;\n \t  gfc_array_spec *as;\n-\t  array_type tmp;\n+\t  array_type type_of_array;\n \n \t  array_attr = is_classarray ? &CLASS_DATA (sym)->attr : &sym->attr;\n \t  as = is_classarray ? CLASS_DATA (sym)->as : sym->as;\n \t  /* Assumed-size Cray pointees need to be treated as AS_EXPLICIT.  */\n-\t  tmp = as->type;\n-\t  if (tmp == AS_ASSUMED_SIZE && as->cp_was_assumed)\n-\t    tmp = AS_EXPLICIT;\n-\t  switch (tmp)\n+\t  type_of_array = as->type;\n+\t  if (type_of_array == AS_ASSUMED_SIZE && as->cp_was_assumed)\n+\t    type_of_array = AS_EXPLICIT;\n+\t  switch (type_of_array)\n \t    {\n \t    case AS_EXPLICIT:\n \t      if (sym->attr.dummy || sym->attr.result)\n@@ -4169,6 +4236,15 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t    case AS_DEFERRED:\n \t      seen_trans_deferred_array = true;\n \t      gfc_trans_deferred_array (sym, block);\n+\t      if (sym->ts.type == BT_CHARACTER && sym->ts.deferred\n+\t\t  && sym->attr.result)\n+\t\t{\n+\t\t  gfc_start_block (&init);\n+\t\t  gfc_save_backend_locus (&loc);\n+\t\t  gfc_set_backend_locus (&sym->declared_at);\n+\t\t  tmp = gfc_null_and_pass_deferred_len (sym, &init, &loc);\n+\t\t  gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n+\t\t}\n \t      break;\n \n \t    default:\n@@ -4183,120 +4259,80 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \tcontinue;\n       else if ((!sym->attr.dummy || sym->ts.deferred)\n \t\t&& (sym->attr.allocatable\n+\t\t    || (sym->attr.pointer && sym->attr.result)\n \t\t    || (sym->ts.type == BT_CLASS\n \t\t\t&& CLASS_DATA (sym)->attr.allocatable)))\n \t{\n \t  if (!sym->attr.save && flag_max_stack_var_size != 0)\n \t    {\n \t      tree descriptor = NULL_TREE;\n \n-\t      /* Nullify and automatic deallocation of allocatable\n-\t\t scalars.  */\n-\t      e = gfc_lval_expr_from_sym (sym);\n-\t      if (sym->ts.type == BT_CLASS)\n-\t\tgfc_add_data_component (e);\n-\n-\t      gfc_init_se (&se, NULL);\n-\t      if (sym->ts.type != BT_CLASS\n-\t\t  || sym->ts.u.derived->attr.dimension\n-\t\t  || sym->ts.u.derived->attr.codimension)\n-\t\t{\n-\t\t  se.want_pointer = 1;\n-\t\t  gfc_conv_expr (&se, e);\n-\t\t}\n-\t      else if (sym->ts.type == BT_CLASS\n-\t\t       && !CLASS_DATA (sym)->attr.dimension\n-\t\t       && !CLASS_DATA (sym)->attr.codimension)\n-\t\t{\n-\t\t  se.want_pointer = 1;\n-\t\t  gfc_conv_expr (&se, e);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  se.descriptor_only = 1;\n-\t\t  gfc_conv_expr (&se, e);\n-\t\t  descriptor = se.expr;\n-\t\t  se.expr = gfc_conv_descriptor_data_addr (se.expr);\n-\t\t  se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n-\t\t}\n-\t      gfc_free_expr (e);\n-\n \t      gfc_save_backend_locus (&loc);\n \t      gfc_set_backend_locus (&sym->declared_at);\n \t      gfc_start_block (&init);\n \n-\t      if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)\n+\t      if (!sym->attr.pointer)\n \t\t{\n-\t\t  /* Nullify when entering the scope.  */\n-\t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t TREE_TYPE (se.expr), se.expr,\n-\t\t\t\t\t fold_convert (TREE_TYPE (se.expr),\n-\t\t\t\t\t\t       null_pointer_node));\n-\t\t  if (sym->attr.optional)\n+\t\t  /* Nullify and automatic deallocation of allocatable\n+\t\t     scalars.  */\n+\t\t  e = gfc_lval_expr_from_sym (sym);\n+\t\t  if (sym->ts.type == BT_CLASS)\n+\t\t    gfc_add_data_component (e);\n+\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  if (sym->ts.type != BT_CLASS\n+\t\t      || sym->ts.u.derived->attr.dimension\n+\t\t      || sym->ts.u.derived->attr.codimension)\n \t\t    {\n-\t\t      tree present = gfc_conv_expr_present (sym);\n-\t\t      tmp = build3_loc (input_location, COND_EXPR,\n-\t\t\t\t\tvoid_type_node, present, tmp,\n-\t\t\t\t\tbuild_empty_stmt (input_location));\n+\t\t      se.want_pointer = 1;\n+\t\t      gfc_conv_expr (&se, e);\n+\t\t    }\n+\t\t  else if (sym->ts.type == BT_CLASS\n+\t\t\t   && !CLASS_DATA (sym)->attr.dimension\n+\t\t\t   && !CLASS_DATA (sym)->attr.codimension)\n+\t\t    {\n+\t\t      se.want_pointer = 1;\n+\t\t      gfc_conv_expr (&se, e);\n \t\t    }\n-\t\t  gfc_add_expr_to_block (&init, tmp);\n-\t\t}\n-\n-\t      if ((sym->attr.dummy || sym->attr.result)\n-\t\t    && sym->ts.type == BT_CHARACTER\n-\t\t    && sym->ts.deferred)\n-\t\t{\n-\t\t  /* Character length passed by reference.  */\n-\t\t  tmp = sym->ts.u.cl->passed_length;\n-\t\t  tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-\t\t  tmp = fold_convert (gfc_charlen_type_node, tmp);\n-\n-\t\t  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)\n-\t\t    /* Zero the string length when entering the scope.  */\n-\t\t    gfc_add_modify (&init, sym->ts.u.cl->backend_decl,\n-\t\t\t\tbuild_int_cst (gfc_charlen_type_node, 0));\n \t\t  else\n \t\t    {\n-\t\t      tree tmp2;\n-\n-\t\t      tmp2 = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t      gfc_charlen_type_node,\n-\t\t\t\t\t      sym->ts.u.cl->backend_decl, tmp);\n-\t\t      if (sym->attr.optional)\n-\t\t\t{\n-\t\t\t  tree present = gfc_conv_expr_present (sym);\n-\t\t\t  tmp2 = build3_loc (input_location, COND_EXPR,\n-\t\t\t\t\t     void_type_node, present, tmp2,\n-\t\t\t\t\t     build_empty_stmt (input_location));\n-\t\t\t}\n-\t\t      gfc_add_expr_to_block (&init, tmp2);\n+\t\t      se.descriptor_only = 1;\n+\t\t      gfc_conv_expr (&se, e);\n+\t\t      descriptor = se.expr;\n+\t\t      se.expr = gfc_conv_descriptor_data_addr (se.expr);\n+\t\t      se.expr = build_fold_indirect_ref_loc (input_location, se.expr);\n \t\t    }\n+\t\t  gfc_free_expr (e);\n \n-\t\t  gfc_restore_backend_locus (&loc);\n-\n-\t\t  /* Pass the final character length back.  */\n-\t\t  if (sym->attr.intent != INTENT_IN)\n+\t\t  if (!sym->attr.dummy || sym->attr.intent == INTENT_OUT)\n \t\t    {\n+\t\t      /* Nullify when entering the scope.  */\n \t\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t\t     gfc_charlen_type_node, tmp,\n-\t\t\t\t\t     sym->ts.u.cl->backend_decl);\n+\t\t\t\t\t     TREE_TYPE (se.expr), se.expr,\n+\t\t\t\t\t     fold_convert (TREE_TYPE (se.expr),\n+\t\t\t\t\t\t\t   null_pointer_node));\n \t\t      if (sym->attr.optional)\n \t\t\t{\n \t\t\t  tree present = gfc_conv_expr_present (sym);\n \t\t\t  tmp = build3_loc (input_location, COND_EXPR,\n \t\t\t\t\t    void_type_node, present, tmp,\n \t\t\t\t\t    build_empty_stmt (input_location));\n \t\t\t}\n+\t\t      gfc_add_expr_to_block (&init, tmp);\n \t\t    }\n-\t\t  else\n-\t\t    tmp = NULL_TREE;\n \t\t}\n+\n+\t      if ((sym->attr.dummy || sym->attr.result)\n+\t\t    && sym->ts.type == BT_CHARACTER\n+\t\t    && sym->ts.deferred\n+\t\t    && sym->ts.u.cl->passed_length)\n+\t\ttmp = gfc_null_and_pass_deferred_len (sym, &init, &loc);\n \t      else\n \t\tgfc_restore_backend_locus (&loc);\n \n \t      /* Deallocate when leaving the scope. Nullifying is not\n \t\t needed.  */\n-\t      if (!sym->attr.result && !sym->attr.dummy\n+\t      if (!sym->attr.result && !sym->attr.dummy && !sym->attr.pointer\n \t\t  && !sym->ns->proc_name->attr.is_main_program)\n \t\t{\n \t\t  if (sym->ts.type == BT_CLASS\n@@ -4313,6 +4349,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t      gfc_free_expr (expr);\n \t\t    }\n \t\t}\n+\n \t      if (sym->ts.type == BT_CLASS)\n \t\t{\n \t\t  /* Initialize _vptr to declared type.  */\n@@ -4353,19 +4390,9 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t  if (sym->attr.dummy)\n \t    {\n \t      gfc_start_block (&init);\n-\n-\t      /* Character length passed by reference.  */\n-\t      tmp = sym->ts.u.cl->passed_length;\n-\t      tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-\t      tmp = fold_convert (gfc_charlen_type_node, tmp);\n-\t      gfc_add_modify (&init, sym->ts.u.cl->backend_decl, tmp);\n-\t      /* Pass the final character length back.  */\n-\t      if (sym->attr.intent != INTENT_IN)\n-\t\ttmp = fold_build2_loc (input_location, MODIFY_EXPR,\n-\t\t\t\t       gfc_charlen_type_node, tmp,\n-\t\t\t\t       sym->ts.u.cl->backend_decl);\n-\t      else\n-\t\ttmp = NULL_TREE;\n+\t      gfc_save_backend_locus (&loc);\n+\t      gfc_set_backend_locus (&sym->declared_at);\n+\t      tmp = gfc_null_and_pass_deferred_len (sym, &init, &loc);\n \t      gfc_add_init_cleanup (block, gfc_finish_block (&init), tmp);\n \t    }\n \t}\n@@ -4427,6 +4454,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n   gfc_add_init_cleanup (block, gfc_finish_block (&tmpblock), NULL_TREE);\n }\n \n+\n struct module_hasher : ggc_ptr_hash<module_htab_entry>\n {\n   typedef const char *compare_type;"}, {"sha": "6c730519121a066a06baf3364a83a239e18d3a7c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ce1ff48e577896b860546564459b4f2000af4985", "patch": "@@ -1,3 +1,8 @@\n+2016-02-20  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/69423\n+\t* gfortran.dg/deferred_character_15.f90 : New test.\n+\n 2016-02-20  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR fortran/57365"}, {"sha": "c641c1fb87bb9d74c12a83c76f3589c9ecccc58c", "filename": "gcc/testsuite/gfortran.dg/deferred_character_15.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce1ff48e577896b860546564459b4f2000af4985/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_15.f90?ref=ce1ff48e577896b860546564459b4f2000af4985", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR69423.\n+!\n+! Contributed by Antony Lewis  <antony@cosmologist.info>\n+!\n+program tester\n+  character(LEN=:), allocatable :: S\n+  S= test(2)\n+  if (len(S) .ne. 4) call abort\n+  if (S .ne. \"test\") call abort\n+  if (allocated (S)) deallocate (S)\n+\n+  S= test2(2)\n+  if (len(S) .ne. 4) call abort\n+  if (S .ne. \"test\") call abort\n+  if (allocated (S)) deallocate (S)\n+contains\n+  function test(alen)\n+    character(LEN=:), allocatable :: test\n+    integer alen, i\n+    do i = alen, 1, -1\n+      test = 'test'\n+      exit\n+    end do\n+!       This line would print nothing when compiled with -O1 and higher.\n+!       print *, len(test),test\n+    if (len(test) .ne. 4) call abort\n+    if (test .ne. \"test\") call abort\n+  end function test\n+\n+  function test2(alen) result (test)\n+    character(LEN=:), allocatable :: test\n+    integer alen, i\n+    do i = alen, 1, -1\n+      test = 'test'\n+      exit\n+    end do\n+!       This worked before the fix.\n+!       print *, len(test),test\n+    if (len(test) .ne. 4) call abort\n+    if (test .ne. \"test\") call abort\n+  end function test2\n+end program tester"}]}