{"sha": "aaae53ce0201febb4f9545c7d0e8068aa9fe6090", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFhZTUzY2UwMjAxZmViYjRmOTU0NWM3ZDBlODA2OGFhOWZlNjA5MA==", "commit": {"author": {"name": "Roland Illig", "email": "roland.illig@gmx.de", "date": "2019-04-30T16:14:40Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-04-30T16:14:40Z"}, "message": "* check-internal-format-escaping.py: New version using polib.\n\nFrom-SVN: r270704", "tree": {"sha": "4f83aba1b018dd5036e5ff36c0680affc0f90889", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f83aba1b018dd5036e5ff36c0680affc0f90889"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaae53ce0201febb4f9545c7d0e8068aa9fe6090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaae53ce0201febb4f9545c7d0e8068aa9fe6090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaae53ce0201febb4f9545c7d0e8068aa9fe6090", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaae53ce0201febb4f9545c7d0e8068aa9fe6090/comments", "author": {"login": "rillig", "id": 3233724, "node_id": "MDQ6VXNlcjMyMzM3MjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3233724?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rillig", "html_url": "https://github.com/rillig", "followers_url": "https://api.github.com/users/rillig/followers", "following_url": "https://api.github.com/users/rillig/following{/other_user}", "gists_url": "https://api.github.com/users/rillig/gists{/gist_id}", "starred_url": "https://api.github.com/users/rillig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rillig/subscriptions", "organizations_url": "https://api.github.com/users/rillig/orgs", "repos_url": "https://api.github.com/users/rillig/repos", "events_url": "https://api.github.com/users/rillig/events{/privacy}", "received_events_url": "https://api.github.com/users/rillig/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7df942516727f9043403090ad0e3319afbc11adc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df942516727f9043403090ad0e3319afbc11adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df942516727f9043403090ad0e3319afbc11adc"}], "stats": {"total": 296, "additions": 249, "deletions": 47}, "files": [{"sha": "835c5c4c6187ad444af0e841bf0c92c44b0fc10f", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaae53ce0201febb4f9545c7d0e8068aa9fe6090/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaae53ce0201febb4f9545c7d0e8068aa9fe6090/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=aaae53ce0201febb4f9545c7d0e8068aa9fe6090", "patch": "@@ -1,3 +1,7 @@\n+2019-04-30  Roland Illig  <roland.illig@gmx.de>\n+\n+\t* check-internal-format-escaping.py: New version using polib.\n+\n 2019-04-19  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tPR translation/90118"}, {"sha": "e06752666b83057198f73d5f3534bf1cd0ade346", "filename": "contrib/check-internal-format-escaping.py", "status": "modified", "additions": 245, "deletions": 47, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaae53ce0201febb4f9545c7d0e8068aa9fe6090/contrib%2Fcheck-internal-format-escaping.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaae53ce0201febb4f9545c7d0e8068aa9fe6090/contrib%2Fcheck-internal-format-escaping.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcheck-internal-format-escaping.py?ref=aaae53ce0201febb4f9545c7d0e8068aa9fe6090", "patch": "@@ -1,7 +1,8 @@\n #!/usr/bin/env python3\n #\n-# Check gcc.pot file for gcc-internal-format and print all strings\n-# that contain an option that is not wrapped by %<-option_name%>.\n+# Check gcc.pot file for stylistic issues as described in\n+# https://gcc.gnu.org/onlinedocs/gccint/Guidelines-for-Diagnostics.html,\n+# especially in gcc-internal-format messages.\n #\n # This file is part of GCC.\n #\n@@ -17,52 +18,249 @@\n #\n # You should have received a copy of the GNU General Public License\n # along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.  */\n-#\n-#\n-#\n+# <http://www.gnu.org/licenses/>.\n \n import argparse\n import re\n+from collections import Counter\n+from typing import Dict, Match\n+\n+import polib\n+\n+seen_warnings = Counter()\n+\n+\n+def location(msg: polib.POEntry):\n+    if msg.occurrences:\n+        occ = msg.occurrences[0]\n+        return f'{occ[0]}:{occ[1]}'\n+    return '<unknown location>'\n+\n+\n+def warn(msg: polib.POEntry,\n+         diagnostic_id: str, diagnostic: str, include_msgid=True):\n+    \"\"\"\n+    To suppress a warning for a particular message,\n+    add a line \"#, gcclint:ignore:{diagnostic_id}\" to the message.\n+    \"\"\"\n+\n+    if f'gcclint:ignore:{diagnostic_id}' in msg.flags:\n+        return\n+\n+    seen_warnings[diagnostic] += 1\n+\n+    if include_msgid:\n+        print(f'{location(msg)}: {diagnostic} in {repr(msg.msgid)}')\n+    else:\n+        print(f'{location(msg)}: {diagnostic}')\n+\n+\n+def lint_gcc_internal_format(msg: polib.POEntry):\n+    \"\"\"\n+    Checks a single message that has the gcc-internal-format. These\n+    messages use a variety of placeholders like %qs, %<quotes%> and\n+    %q#E.\n+    \"\"\"\n+\n+    msgid: str = msg.msgid\n+\n+    def outside_quotes(m: Match[str]):\n+        before = msgid[:m.start(0)]\n+        return before.count(\"%<\") == before.count(\"%>\")\n+\n+    def lint_matching_placeholders():\n+        \"\"\"\n+        Warns when literal values in placeholders are not exactly equal\n+        in the translation. This can happen when doing copy-and-paste\n+        translations of similar messages.\n+\n+        To avoid these mismatches in the first place,\n+        structurally equal messages are found by\n+        lint_diagnostics_differing_only_in_placeholders.\n+\n+        This check only applies when checking a finished translation\n+        such as de.po, not gcc.pot.\n+        \"\"\"\n+\n+        if not msg.translated():\n+            return\n+\n+        in_msgid = re.findall('%<[^%]+%>', msgid)\n+        in_msgstr = re.findall('%<[^%]+%>', msg.msgstr)\n+\n+        if set(in_msgid) != set(in_msgstr):\n+            warn(msg,\n+                 'placeholder-mismatch',\n+                 f'placeholder mismatch: msgid has {in_msgid}, '\n+                 f'msgstr has {in_msgstr}',\n+                 include_msgid=False)\n+\n+    def lint_option_outside_quotes():\n+        for match in re.finditer(r'\\S+', msgid):\n+            part = match.group()\n+            if not outside_quotes(match):\n+                continue\n+\n+            if part.startswith('-'):\n+                if len(part) >= 2 and part[1].isalpha():\n+                    if part == '-INF':\n+                        continue\n+\n+                    warn(msg,\n+                         'option-outside-quotes',\n+                         'command line option outside %<quotes%>')\n+\n+            if part.startswith('__builtin_'):\n+                warn(msg,\n+                     'builtin-outside-quotes',\n+                     'builtin function outside %<quotes%>')\n+\n+    def lint_plain_apostrophe():\n+        for match in re.finditer(\"[^%]'\", msgid):\n+            if outside_quotes(match):\n+                warn(msg, 'apostrophe', 'apostrophe without leading %')\n+\n+    def lint_space_before_quote():\n+        \"\"\"\n+        A space before %< is often the result of string literals that\n+        are joined by the C compiler and neither literal has a space\n+        to separate the words.\n+        \"\"\"\n+\n+        for match in re.finditer(\"(.?[a-zA-Z0-9])%<\", msgid):\n+            if match.group(1) != '%s':\n+                warn(msg,\n+                     'no-space-before-quote',\n+                     '%< directly following a letter or digit')\n+\n+    def lint_underscore_outside_quotes():\n+        \"\"\"\n+        An underscore outside of quotes is used in several contexts,\n+        and many of them violate the GCC Guidelines for Diagnostics:\n+\n+        * names of GCC-internal compiler functions\n+        * names of GCC-internal data structures\n+        * static_cast and the like (which are legitimate)\n+        \"\"\"\n+\n+        for match in re.finditer(\"_\", msgid):\n+            if outside_quotes(match):\n+                warn(msg,\n+                     'underscore-outside-quotes',\n+                     'underscore outside of %<quotes%>')\n+                return\n+\n+    def lint_may_not():\n+        \"\"\"\n+        The term \"may not\" may either mean \"it could be the case\"\n+        or \"should not\". These two different meanings are sometimes\n+        hard to tell apart.\n+        \"\"\"\n+\n+        if re.search(r'\\bmay not\\b', msgid):\n+            warn(msg,\n+                 'ambiguous-may-not',\n+                 'the term \"may not\" is ambiguous')\n+\n+    def lint_unbalanced_quotes():\n+        if msgid.count(\"%<\") != msgid.count(\"%>\"):\n+            warn(msg,\n+                 'unbalanced-quotes',\n+                 'unbalanced %< and %> quotes')\n+\n+        if msg.translated():\n+            if msg.msgstr.count(\"%<\") != msg.msgstr.count(\"%>\"):\n+                warn(msg,\n+                     'unbalanced-quotes',\n+                     'unbalanced %< and %> quotes')\n+\n+    def lint_single_space_after_sentence():\n+        \"\"\"\n+        After a sentence there should be two spaces.\n+        \"\"\"\n+\n+        if re.search(r'[.] [A-Z]', msgid):\n+            warn(msg,\n+                 'single-space-after-sentence',\n+                 'single space after sentence')\n+\n+    def lint_non_canonical_quotes():\n+        \"\"\"\n+        Catches %<%s%>, which can be written in the shorter form %qs.\n+        \"\"\"\n+        match = re.search(\"%<%s%>|'%s'|\\\"%s\\\"|`%s'\", msgid)\n+        if match:\n+            warn(msg,\n+                 'non-canonical-quotes',\n+                 f'placeholder {match.group()} should be written as %qs')\n+\n+    lint_option_outside_quotes()\n+    lint_plain_apostrophe()\n+    lint_space_before_quote()\n+    lint_underscore_outside_quotes()\n+    lint_may_not()\n+    lint_unbalanced_quotes()\n+    lint_matching_placeholders()\n+    lint_single_space_after_sentence()\n+    lint_non_canonical_quotes()\n+\n+\n+def lint_diagnostics_differing_only_in_placeholders(po: polib.POFile):\n+    \"\"\"\n+    Detects messages that are structurally the same, except that they\n+    use different plain strings inside %<quotes%>. These messages can\n+    be merged in order to prevent copy-and-paste mistakes by the\n+    translators.\n+\n+    See bug 90119.\n+    \"\"\"\n+\n+    seen: Dict[str, polib.POEntry] = {}\n+\n+    for msg in po:\n+        msg: polib.POEntry\n+        msgid = msg.msgid\n+\n+        normalized = re.sub('%<[^%]+%>', '%qs', msgid)\n+        if normalized not in seen:\n+            seen[normalized] = msg\n+            seen[msgid] = msg\n+            continue\n+\n+        prev = seen[normalized]\n+        warn(msg,\n+             'same-pattern',\n+             f'same pattern for {repr(msgid)} and '\n+             f'{repr(prev.msgid)} in {location(prev)}',\n+             include_msgid=False)\n+\n+\n+def lint_file(po: polib.POFile):\n+    for msg in po:\n+        msg: polib.POEntry\n+\n+        if not msg.obsolete and not msg.fuzzy:\n+            if 'gcc-internal-format' in msg.flags:\n+                lint_gcc_internal_format(msg)\n+\n+    lint_diagnostics_differing_only_in_placeholders(po)\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description='')\n+    parser.add_argument('file', help='pot file')\n+\n+    args = parser.parse_args()\n+\n+    po = polib.pofile(args.file)\n+    lint_file(po)\n+\n+    print()\n+    print('summary:')\n+    for entry in seen_warnings.most_common():\n+        if entry[1] > 1:\n+            print(f'{entry[1]}\\t{entry[0]}')\n+\n \n-parser = argparse.ArgumentParser(description='')\n-parser.add_argument('file', help = 'pot file')\n-\n-args = parser.parse_args()\n-\n-origin = None\n-internal = False\n-\n-lines = open(args.file).readlines()\n-for i, l in enumerate(lines):\n-    l = l.strip()\n-    s = 'msgid '\n-    if l.startswith('#: '):\n-        origin = l\n-    elif '#, gcc-internal-format' in l:\n-        internal = True\n-    if l.startswith(s) and origin and internal:\n-        j = 0\n-        while not lines[i + j].startswith('msgstr'):\n-            l = lines[i + j]\n-            if l.startswith(s):\n-                l = l[len(s):]\n-            text = l.strip('\"').strip()\n-            if text:\n-                parts = text.split(' ')\n-                for p in parts:\n-                    if p.startswith('-'):\n-                        if len(p) >= 2 and (p[1].isalpha() and p != '-INF'):\n-                            print('%s: %s' % (origin, text))\n-                    elif p.startswith('__builtin_'):\n-                        print('%s: %s' % (origin, text))\n-                    if re.search(\"[^%]'\", p):\n-                        print('%s: %s' % (origin, text))\n-                    # %< should not be preceded by a non-punctuation\n-                    # %character.\n-                    if re.search(\"[a-zA-Z0-9]%<\", p):\n-                        print('%s: %s' % (origin, text))\n-            j += 1\n-\n-        origin = None\n-        internal = False\n+if __name__ == '__main__':\n+    main()"}]}