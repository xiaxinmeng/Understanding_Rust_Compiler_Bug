{"sha": "daaed0199ee57013ae011421a7e90b7bdd295373", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFhZWQwMTk5ZWU1NzAxM2FlMDExNDIxYTdlOTBiN2JkZDI5NTM3Mw==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-27T07:18:34Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2020-06-27T08:43:54Z"}, "message": "coroutines: Handle awaiters that are sub-objects [PR95736]\n\nMove deciding on initializers for awaitables to the build of the\nco_await, this allows us to analyse cases that do not need\na temporary at that point.\n\nAs the PR shows, the late analysis meant that we  were not\nchecking properly for the case that an awaiter is a sub-object\nof an existing variable outside the current function scope (and\ntherefore does not need to be duplicated in the frame).\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95736\n\t* coroutines.cc (get_awaitable_var): New helper.\n\t(build_co_await): Check more carefully before\n\tcopying an awaitable.\n\t(expand_one_await_expression): No initializer\n\tis required when the awaitable is not a temp.\n\t(register_awaits): Remove handling that is now\n\tcompleted when the await expression is built.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95736\n\t* g++.dg/coroutines/pr95736.C: New test.", "tree": {"sha": "3c3047efa45a9dfa3f8f3b9e178fea691f99deb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c3047efa45a9dfa3f8f3b9e178fea691f99deb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daaed0199ee57013ae011421a7e90b7bdd295373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daaed0199ee57013ae011421a7e90b7bdd295373", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daaed0199ee57013ae011421a7e90b7bdd295373", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daaed0199ee57013ae011421a7e90b7bdd295373/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c5ca11a33fa91345fe813d449ddc4a821fc72d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c5ca11a33fa91345fe813d449ddc4a821fc72d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c5ca11a33fa91345fe813d449ddc4a821fc72d5"}], "stats": {"total": 196, "additions": 166, "deletions": 30}, "files": [{"sha": "bab03d448637291d1a62b252589bb2a89bd3fab5", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 82, "deletions": 30, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daaed0199ee57013ae011421a7e90b7bdd295373/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daaed0199ee57013ae011421a7e90b7bdd295373/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=daaed0199ee57013ae011421a7e90b7bdd295373", "patch": "@@ -740,6 +740,30 @@ enum suspend_point_kind {\n   FINAL_SUSPEND_POINT\n };\n \n+/* Helper function to build a named variable for the temps we use for each\n+   await point.  The root of the name is determined by SUSPEND_KIND, and\n+   the variable is of type V_TYPE.  The awaitable number is reset each time\n+   we encounter a final suspend.  */\n+\n+static tree\n+get_awaitable_var (suspend_point_kind suspend_kind, tree v_type)\n+{\n+  static int awn = 0;\n+  char *buf;\n+  switch (suspend_kind)\n+    {\n+      default: buf = xasprintf (\"Aw%d\", awn++); break;\n+      case CO_YIELD_SUSPEND_POINT: buf =  xasprintf (\"Yd%d\", awn++); break;\n+      case INITIAL_SUSPEND_POINT: buf =  xasprintf (\"Is\"); break;\n+      case FINAL_SUSPEND_POINT: buf =  xasprintf (\"Fs\"); awn = 0; break;\n+  }\n+  tree ret = get_identifier (buf);\n+  free (buf);\n+  ret = build_lang_decl (VAR_DECL, ret, v_type);\n+  DECL_ARTIFICIAL (ret) = true;\n+  return ret;\n+}\n+\n /*  This performs [expr.await] bullet 3.3 and validates the interface obtained.\n     It is also used to build the initial and final suspend points.\n \n@@ -798,23 +822,57 @@ build_co_await (location_t loc, tree a, suspend_point_kind suspend_kind)\n     return error_mark_node;\n \n   /* To complete the lookups, we need an instance of 'e' which is built from\n-     'o' according to [expr.await] 3.4.  However, we don't want to materialize\n-     'e' here (it might need to be placed in the coroutine frame) so we will\n-     make a temp placeholder instead.  If 'o' is a parameter or a local var,\n-     then we do not need an additional var (parms and local vars are already\n-     copied into the frame and will have lifetimes according to their original\n-     scope).  */\n+     'o' according to [expr.await] 3.4.\n+\n+     If we need to materialize this as a temporary, then that will have to be\n+     'promoted' to a coroutine frame var.  However, if the awaitable is a\n+     user variable, parameter or comes from a scope outside this function,\n+     then we must use it directly - or we will see unnecessary copies.\n+\n+     If o is a variable, find the underlying var.  */\n   tree e_proxy = STRIP_NOPS (o);\n   if (INDIRECT_REF_P (e_proxy))\n     e_proxy = TREE_OPERAND (e_proxy, 0);\n+  while (TREE_CODE (e_proxy) == COMPONENT_REF)\n+    {\n+      e_proxy = TREE_OPERAND (e_proxy, 0);\n+      if (INDIRECT_REF_P (e_proxy))\n+\te_proxy = TREE_OPERAND (e_proxy, 0);\n+      if (TREE_CODE (e_proxy) == CALL_EXPR)\n+\t{\n+\t  /* We could have operator-> here too.  */\n+\t  tree op = TREE_OPERAND (CALL_EXPR_FN (e_proxy), 0);\n+\t  if (DECL_OVERLOADED_OPERATOR_P (op)\n+\t      && DECL_OVERLOADED_OPERATOR_IS (op, COMPONENT_REF))\n+\t    {\n+\t      e_proxy = CALL_EXPR_ARG (e_proxy, 0);\n+\t      STRIP_NOPS (e_proxy);\n+\t      gcc_checking_assert (TREE_CODE (e_proxy) == ADDR_EXPR);\n+\t      e_proxy = TREE_OPERAND (e_proxy, 0);\n+\t    }\n+\t}\n+      STRIP_NOPS (e_proxy);\n+    }\n+\n+  /* Only build a temporary if we need it.  */\n   if (TREE_CODE (e_proxy) == PARM_DECL\n-      || (VAR_P (e_proxy) && (!DECL_ARTIFICIAL (e_proxy)\n-\t\t\t      || DECL_HAS_VALUE_EXPR_P (e_proxy))))\n-    e_proxy = o;\n+      || (VAR_P (e_proxy) && !is_local_temp (e_proxy)))\n+    {\n+      e_proxy = o;\n+      o = NULL_TREE; /* The var is already present.  */\n+    }\n+  else if (CLASS_TYPE_P (o_type) || TYPE_NEEDS_CONSTRUCTING (o_type))\n+    {\n+      e_proxy = get_awaitable_var (suspend_kind, o_type);\n+      releasing_vec arg (make_tree_vector_single (rvalue (o)));\n+      o = build_special_member_call (e_proxy, complete_ctor_identifier,\n+\t\t\t\t     &arg, o_type, LOOKUP_NORMAL,\n+\t\t\t\t     tf_warning_or_error);\n+    }\n   else\n     {\n-      e_proxy = build_lang_decl (VAR_DECL, NULL_TREE, o_type);\n-      DECL_ARTIFICIAL (e_proxy) = true;\n+      e_proxy = get_awaitable_var (suspend_kind, o_type);\n+      o = build2 (INIT_EXPR, o_type, e_proxy, rvalue (o));\n     }\n \n   /* I suppose we could check that this is contextually convertible to bool.  */\n@@ -1531,16 +1589,14 @@ expand_one_await_expression (tree *stmt, tree *await_expr, void *d)\n \n   tree await_type = TREE_TYPE (var);\n   tree stmt_list = NULL;\n-  tree t_expr = STRIP_NOPS (expr);\n   tree r;\n   tree *await_init = NULL;\n-  if (t_expr == var)\n-    needs_dtor = false;\n+\n+  if (!expr)\n+    needs_dtor = false; /* No need, the var's lifetime is managed elsewhere.  */\n   else\n     {\n-      /* Initialize the var from the provided 'o' expression.  */\n-      r = build2 (INIT_EXPR, await_type, var, expr);\n-      r = coro_build_cvt_void_expr_stmt (r, loc);\n+      r = coro_build_cvt_void_expr_stmt (expr, loc);\n       append_to_statement_list_force (r, &stmt_list);\n       /* We have an initializer, which might itself contain await exprs.  */\n       await_init = tsi_stmt_ptr (tsi_last (stmt_list));\n@@ -2840,29 +2896,25 @@ register_awaits (tree *stmt, int *do_subtree ATTRIBUTE_UNUSED, void *d)\n   /* If the awaitable is a parm or a local variable, then we already have\n      a frame copy, so don't make a new one.  */\n   tree aw = TREE_OPERAND (aw_expr, 1);\n+  tree o = TREE_OPERAND (aw_expr, 2); /* Initializer for the frame var.  */\n+  /* If we have an initializer, then the var is a temp and we need to make\n+     it in the frame.  */\n   tree aw_field_type = TREE_TYPE (aw);\n   tree aw_field_nam = NULL_TREE;\n-  if (INDIRECT_REF_P (aw))\n-    aw = TREE_OPERAND (aw, 0);\n-  if (TREE_CODE (aw) == PARM_DECL\n-      || (VAR_P (aw) && (!DECL_ARTIFICIAL (aw)\n-\t\t\t || DECL_HAS_VALUE_EXPR_P (aw))))\n-    ; /* Don't make an additional copy.  */\n-  else\n+  if (o)\n     {\n       /* The required field has the same type as the proxy stored in the\n \t await expr.  */\n       char *nam = xasprintf (\"__aw_s.%d\", data->await_number);\n       aw_field_nam = coro_make_frame_entry (data->field_list, nam,\n \t\t\t\t\t    aw_field_type, aw_loc);\n       free (nam);\n-    }\n \n-  tree o = TREE_OPERAND (aw_expr, 2); /* Initialiser for the frame var.  */\n-  /* If this is a target expression, then we need to remake it to strip off\n-     any extra cleanups added.  */\n-  if (TREE_CODE (o) == TARGET_EXPR)\n-    TREE_OPERAND (aw_expr, 2) = get_target_expr (TREE_OPERAND (o, 1));\n+      /* If the init is a target expression, then we need to remake it to\n+\t strip off any extra cleanups added.  */\n+      if (o && TREE_CODE (o) == TARGET_EXPR)\n+\tTREE_OPERAND (aw_expr, 2) = get_target_expr (TREE_OPERAND (o, 1));\n+    }\n \n   tree v = TREE_OPERAND (aw_expr, 3);\n   o = TREE_VEC_ELT (v, 1);"}, {"sha": "0be5168a8d227c3af19fdcd6c6e32ec58e7262e7", "filename": "gcc/testsuite/g++.dg/coroutines/pr95736.C", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daaed0199ee57013ae011421a7e90b7bdd295373/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95736.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daaed0199ee57013ae011421a7e90b7bdd295373/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95736.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Fpr95736.C?ref=daaed0199ee57013ae011421a7e90b7bdd295373", "patch": "@@ -0,0 +1,84 @@\n+#include <iostream>\n+#include <exception>\n+#include <cassert>\n+\n+#if __has_include(\"coroutine\")\n+#include <coroutine>\n+namespace stdcoro = std;\n+#else\n+#include <experimental/coroutine>\n+namespace stdcoro = std::experimental;\n+#endif\n+\n+struct footable : stdcoro::suspend_always {\n+\tfootable() noexcept = default;\n+\t~footable() { assert(released); }\n+\tfootable(const footable&) = delete;\n+\n+\tusing coro_handle = stdcoro::coroutine_handle<>;\n+\n+\tvoid await_suspend(coro_handle awaiter) noexcept {\n+\t\tstd::cout << \"suspending to footable \" << this << std::endl;\n+\t\tassert(!handle);\n+\t\thandle = awaiter;\n+\t}\n+\tvoid await_resume() noexcept {\n+\t\tstd::cout << \"resuming from footable \" << this << std::endl;\n+\t\tassert(handle);\n+\t\thandle = {};\n+\t}\n+\n+\tvoid operator()() noexcept {\n+\t\tstd::cout << \"operator() on \" << this << std::endl;\n+\t\tassert(handle);\n+\t\thandle.resume();\n+\t\thandle = {};\n+\t}\n+\n+\tvoid release() noexcept { released = true; }\n+private:\n+\tcoro_handle handle;\n+\tbool released = false;\n+};\n+\n+struct footask {\n+\tstruct promise_type {\n+\t\tusing coro_handle = stdcoro::coroutine_handle<promise_type>;\n+\n+\t\tstdcoro::suspend_never initial_suspend() noexcept { return {}; }\n+\t\tstdcoro::suspend_never final_suspend() noexcept { std::cout << \"final suspend\" << std::endl; return {}; }\n+\t\tvoid unhandled_exception() {}\n+\t\tvoid return_void() noexcept { std::cout << \"coro returns\" << std::endl; }\n+\n+\t\tfootask get_return_object() { return footask{ coro_handle::from_promise(*this) }; }\n+\t};\n+\n+\tfootask(promise_type::coro_handle handle) : handle(handle) {}\n+\t~footask() { assert(handle.done()); }\n+\n+\tpromise_type::coro_handle handle;\n+};\n+\n+struct bar {\n+\tbar() = default;\n+\tbar(const bar&) = delete;\n+\n+\tfootable foo{};\n+\tfootask task = taskfun();\n+\n+\tfootask taskfun() noexcept {\n+\t\tstd::cout << \"coro begin\" << std::endl;\n+\t\tco_await foo;\n+\t\tstd::cout << \"coro end\" << std::endl;\n+\t}\n+};\n+\n+int main() {\n+\tbar foobar;\n+\tfoobar.foo();\n+\tassert(foobar.task.handle.done());\n+\tstd::cout << \"releasing\" << std::endl;\n+\tfoobar.foo.release();\n+\tstd::cout << \"done\" << std::endl;\n+\treturn 0;\n+}"}]}