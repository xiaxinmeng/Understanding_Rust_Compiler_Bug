{"sha": "ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0NjQxYTNiNTM2YzkzMDFhNmRjYjZjYjJlMjZiZDQ3MTdiNDdkOQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T15:10:58Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-04-08T15:10:58Z"}, "message": "libstdc++: Address remaining to_chars/long_double.cc FAILs [PR98384]\n\nThis works around the remaining reported execution FAILs of this test on\nAIX, Solaris and Darwin.  Eventually we should rewrite this test to be\nless fragile, but there's not enough time to do that for GCC 11.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/98384\n\t* testsuite/20_util/to_chars/long_double.cc: Don't run the test\n\ton targets without a large long double.  XFAIL the execution on\n\ttargets with a non-conforming printf.", "tree": {"sha": "4999e4c0545fd7d1df37289e78455acb855ddf5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4999e4c0545fd7d1df37289e78455acb855ddf5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9/comments", "author": null, "committer": null, "parents": [{"sha": "d6cc745cb87aa62f9e17699aedf5aa2d9831fbd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6cc745cb87aa62f9e17699aedf5aa2d9831fbd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6cc745cb87aa62f9e17699aedf5aa2d9831fbd8"}], "stats": {"total": 18, "additions": 17, "deletions": 1}, "files": [{"sha": "22d42067d658e27fbd48cf2a6c4d5ee64eec83a6", "filename": "libstdc++-v3/testsuite/20_util/to_chars/long_double.cc", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2Flong_double.cc?ref=ca4641a3b536c9301a6dcb6cb2e26bd4717b47d9", "patch": "@@ -17,7 +17,23 @@\n \n // <charconv> is supported in C++14 as a GNU extension, but this test uses C++17\n // hexadecimal floating-point literals.\n-// { dg-do run { target c++17 } }\n+\n+// When long double is larger than double, the long double to_chars overloads\n+// are partially implemented in terms of printf, so this test in turn uses\n+// printf to verify correctness these overloads.\n+// When long double == double, the long double to_chars overloads are simple\n+// wrappers around the corresponding double overloads.  Since they don't go\n+// through printf, we can't portably verify their output by comparing it with\n+// that of printf, so it's simplest to just not run this test on such targets;\n+// correctness of these overloads is already implied by that of the double\n+// overloads.\n+// { dg-do run { target { c++17 && large_long_double } } }\n+// { dg-do compile { target { c++17 && { ! large_long_double } } } }\n+\n+// The system printf on these targets appear to be buggy.  FIXME: Make this test\n+// more portable and robust to differences in system printf behavior.\n+// { dg-xfail-run-if \"Non-conforming printf (see PR98384)\" { *-*-solaris* *-*-darwin* } }\n+\n // { dg-require-effective-target ieee-floats }\n \n #include <charconv>"}]}