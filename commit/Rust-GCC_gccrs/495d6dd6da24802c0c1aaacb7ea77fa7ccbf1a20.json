{"sha": "495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk1ZDZkZDZkYTI0ODAyYzBjMWFhYWNiN2VhNzdmYTdjY2JmMWEyMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-06-06T10:44:24Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:44:24Z"}, "message": "sem_ch7.adb (Check_Anonymous_Access_Types): Fix error for null body\n\n2007-04-20  Robert Dewar  <dewar@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* sem_ch7.adb (Check_Anonymous_Access_Types): Fix error for null body\n\t(Derive_Inherited_Private_Subprogram): Code cleanup. In case of explicit\n\toverriding of an inherited private subprogram now there is no need to\n\tinherit its dispatching slot and reduce the size of the dispatch table.\n\tSet_All_DT_Position now ensures that the same slot is now assigned to\n\tboth entities. This is required to statically build the dispatch table.\n\t(Declare_Inherited_Private_Subprograms): Rewriten to avoid the need\n\tof calling Set_All_DT_Position to re-evaluate the position of the\n\tentries in the dispatch table. Such reevaluation is not desired if\n\tthe tagged type is already frozen.\n\nFrom-SVN: r125452", "tree": {"sha": "09521dd48625650a14a9d01f2817d323df8ff41c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09521dd48625650a14a9d01f2817d323df8ff41c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20/comments", "author": null, "committer": null, "parents": [{"sha": "b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7d1f17ff2605ae0dda0f3568136ff76cfcb879e"}], "stats": {"total": 145, "additions": 79, "deletions": 66}, "files": [{"sha": "4bf3e490c211ea7d2154f8cca46a798b436aa4b5", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 79, "deletions": 66, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=495d6dd6da24802c0c1aaacb7ea77fa7ccbf1a20", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,6 +59,7 @@ with Stand;    use Stand;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Style;\n+with Uintp;    use Uintp;\n \n package body Sem_Ch7 is\n \n@@ -311,7 +312,7 @@ package body Sem_Ch7 is\n       Set_Has_Completion (Spec_Id);\n       Last_Spec_Entity := Last_Entity (Spec_Id);\n \n-      New_Scope (Spec_Id);\n+      Push_Scope (Spec_Id);\n \n       Set_Categorization_From_Pragmas (N);\n \n@@ -676,7 +677,7 @@ package body Sem_Ch7 is\n       Set_Ekind (Id, E_Package);\n       Set_Etype (Id, Standard_Void_Type);\n \n-      New_Scope (Id);\n+      Push_Scope (Id);\n \n       PF := Is_Pure (Enclosing_Lib_Unit_Entity);\n       Set_Is_Pure (Id, PF);\n@@ -1039,7 +1040,7 @@ package body Sem_Ch7 is\n         and then Nkind (Orig_Decl) = N_Generic_Package_Declaration\n       then\n          declare\n-            Orig_Spec : constant Node_Id    := Specification (Orig_Decl);\n+            Orig_Spec : constant Node_Id := Specification (Orig_Decl);\n             Save_Priv : constant List_Id := Private_Declarations (Orig_Spec);\n \n          begin\n@@ -1292,10 +1293,10 @@ package body Sem_Ch7 is\n             Set_Itype (IR, E);\n \n             if No (Declarations (P_Body)) then\n-               Set_Declarations (P_Body, New_List);\n+               Set_Declarations (P_Body, New_List (IR));\n+            else\n+               Prepend (IR, Declarations (P_Body));\n             end if;\n-\n-            Insert_Before (First (Declarations (P_Body)), IR);\n          end if;\n \n          Next_Entity (E);\n@@ -1307,15 +1308,6 @@ package body Sem_Ch7 is\n    -------------------------------------------\n \n    procedure Declare_Inherited_Private_Subprograms (Id : Entity_Id) is\n-      E              : Entity_Id;\n-      Op_List        : Elist_Id;\n-      Op_Elmt        : Elmt_Id;\n-      Op_Elmt_2      : Elmt_Id;\n-      Prim_Op        : Entity_Id;\n-      New_Op         : Entity_Id := Empty;\n-      Parent_Subp    : Entity_Id;\n-      Found_Explicit : Boolean;\n-      Decl_Privates  : Boolean;\n \n       function Is_Primitive_Of (T : Entity_Id; S : Entity_Id) return Boolean;\n       --  Check whether an inherited subprogram is an operation of an\n@@ -1346,6 +1338,17 @@ package body Sem_Ch7 is\n          end if;\n       end Is_Primitive_Of;\n \n+      --  Local variables\n+\n+      E           : Entity_Id;\n+      Op_List     : Elist_Id;\n+      Op_Elmt     : Elmt_Id;\n+      Op_Elmt_2   : Elmt_Id;\n+      Prim_Op     : Entity_Id;\n+      New_Op      : Entity_Id := Empty;\n+      Parent_Subp : Entity_Id;\n+      Tag         : Entity_Id;\n+\n    --  Start of processing for Declare_Inherited_Private_Subprograms\n \n    begin\n@@ -1365,19 +1368,16 @@ package body Sem_Ch7 is\n            and then E = Base_Type (E)\n          then\n             if Is_Tagged_Type (E) then\n-               Op_List       := Primitive_Operations (E);\n-               New_Op        := Empty;\n-               Decl_Privates := False;\n+               Op_List := Primitive_Operations (E);\n+               New_Op  := Empty;\n+               Tag     := First_Tag_Component (E);\n \n                Op_Elmt := First_Elmt (Op_List);\n                while Present (Op_Elmt) loop\n                   Prim_Op := Node (Op_Elmt);\n \n-                  --  If the primitive operation is an implicit operation\n-                  --  with an internal name whose parent operation has\n-                  --  a normal name, then we now need to either declare the\n-                  --  operation (i.e., make it visible), or replace it\n-                  --  by an overriding operation if one exists.\n+                  --  Search primitives that are implicit operations with an\n+                  --  internal name whose parent operation has a normal name.\n \n                   if Present (Alias (Prim_Op))\n                     and then Find_Dispatching_Type (Alias (Prim_Op)) /= E\n@@ -1387,72 +1387,85 @@ package body Sem_Ch7 is\n                   then\n                      Parent_Subp := Alias (Prim_Op);\n \n-                     Found_Explicit := False;\n+                     --  Case 1: Check if the type has also an explicit\n+                     --  overriding for this primitive.\n+\n                      Op_Elmt_2 := Next_Elmt (Op_Elmt);\n                      while Present (Op_Elmt_2) loop\n                         if Chars (Node (Op_Elmt_2)) = Chars (Parent_Subp)\n                           and then Type_Conformant (Prim_Op, Node (Op_Elmt_2))\n                         then\n                            --  The private inherited operation has been\n-                           --  overridden by an explicit subprogram, so\n-                           --  change the private op's list element to\n-                           --  designate the explicit so the explicit\n-                           --  one will get the right dispatching slot.\n+                           --  overridden by an explicit subprogram: replace\n+                           --  the former by the latter.\n \n                            New_Op := Node (Op_Elmt_2);\n                            Replace_Elmt (Op_Elmt, New_Op);\n-                           Remove_Elmt (Op_List, Op_Elmt_2);\n-                           Found_Explicit := True;\n+                           Remove_Elmt  (Op_List, Op_Elmt_2);\n                            Set_Is_Overriding_Operation (New_Op);\n-                           Decl_Privates  := True;\n \n-                           exit;\n+                           --  We don't need to inherit its dispatching slot.\n+                           --  Set_All_DT_Position has previously ensured that\n+                           --  the same slot was assigned to the two primitives\n+\n+                           if Present (Tag)\n+                             and then Present (DTC_Entity (New_Op))\n+                             and then Present (DTC_Entity (Prim_Op))\n+                           then\n+                              pragma Assert (DT_Position (New_Op)\n+                                              = DT_Position (Prim_Op));\n+                              null;\n+                           end if;\n+\n+                           goto Next_Primitive;\n                         end if;\n \n                         Next_Elmt (Op_Elmt_2);\n                      end loop;\n \n-                     if not Found_Explicit then\n-                        Derive_Subprogram\n-                          (New_Op, Alias (Prim_Op), E, Etype (E));\n-\n-                        pragma Assert\n-                          (Is_Dispatching_Operation (New_Op)\n-                            and then Node (Last_Elmt (Op_List)) = New_Op);\n+                     --   Case 2: We have not found any explicit overriding and\n+                     --   hence we need to declare the operation (i.e., make it\n+                     --   visible).\n \n-                        --  Substitute the new operation for the old one\n-                        --  in the type's primitive operations list. Since\n-                        --  the new operation was also just added to the end\n-                        --  of list, the last element must be removed.\n+                     Derive_Subprogram (New_Op, Alias (Prim_Op), E, Etype (E));\n \n-                        --  (Question: is there a simpler way of declaring\n-                        --  the operation, say by just replacing the name\n-                        --  of the earlier operation, reentering it in the\n-                        --  in the symbol table (how?), and marking it as\n-                        --  private???)\n+                     --  Inherit the dispatching slot if E is already frozen\n \n-                        Replace_Elmt (Op_Elmt, New_Op);\n-                        Remove_Last_Elmt (Op_List);\n-                        Decl_Privates := True;\n+                     if Is_Frozen (E)\n+                       and then Present (DTC_Entity (Alias (Prim_Op)))\n+                     then\n+                        Set_DTC_Entity_Value (E, New_Op);\n+                        Set_DT_Position (New_Op,\n+                          DT_Position (Alias (Prim_Op)));\n                      end if;\n+\n+                     pragma Assert\n+                       (Is_Dispatching_Operation (New_Op)\n+                         and then Node (Last_Elmt (Op_List)) = New_Op);\n+\n+                     --  Substitute the new operation for the old one\n+                     --  in the type's primitive operations list. Since\n+                     --  the new operation was also just added to the end\n+                     --  of list, the last element must be removed.\n+\n+                     --  (Question: is there a simpler way of declaring\n+                     --  the operation, say by just replacing the name\n+                     --  of the earlier operation, reentering it in the\n+                     --  in the symbol table (how?), and marking it as\n+                     --  private???)\n+\n+                     Replace_Elmt (Op_Elmt, New_Op);\n+                     Remove_Last_Elmt (Op_List);\n                   end if;\n \n+                  <<Next_Primitive>>\n                   Next_Elmt (Op_Elmt);\n                end loop;\n \n-               --  The type's DT attributes need to be recalculated\n-               --  in the case where private dispatching operations\n-               --  have been added or overridden. Normally this action\n-               --  occurs during type freezing, but we force it here\n-               --  since the type may already have been frozen (e.g.,\n-               --  if the type's package has an empty private part).\n-               --  This can only be done if expansion is active, otherwise\n-               --  Tag may not be present.\n-\n-               if Decl_Privates\n-                 and then Expander_Active\n-               then\n-                  Set_All_DT_Position (E);\n+               --  Generate listing showing the contents of the dispatch table\n+\n+               if Debug_Flag_ZZ then\n+                  Write_DT (E);\n                end if;\n \n             else\n@@ -1825,7 +1838,7 @@ package body Sem_Ch7 is\n       Set_Stored_Constraint (Id, No_Elist);\n \n       if Present (Discriminant_Specifications (N)) then\n-         New_Scope (Id);\n+         Push_Scope (Id);\n          Process_Discriminants (N);\n          End_Scope;\n "}]}