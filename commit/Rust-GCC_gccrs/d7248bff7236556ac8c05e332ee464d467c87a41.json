{"sha": "d7248bff7236556ac8c05e332ee464d467c87a41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcyNDhiZmY3MjM2NTU2YWM4YzA1ZTMzMmVlNDY0ZDQ2N2M4N2E0MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-04T21:22:19Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-10-04T21:22:19Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r12903", "tree": {"sha": "6134e61e301ed3d89832eb0d44e29e3344be4809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6134e61e301ed3d89832eb0d44e29e3344be4809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7248bff7236556ac8c05e332ee464d467c87a41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7248bff7236556ac8c05e332ee464d467c87a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7248bff7236556ac8c05e332ee464d467c87a41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7248bff7236556ac8c05e332ee464d467c87a41/comments", "author": null, "committer": null, "parents": [{"sha": "af6d53df71f7f6d21c022f4e437aafa7df7598e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af6d53df71f7f6d21c022f4e437aafa7df7598e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af6d53df71f7f6d21c022f4e437aafa7df7598e7"}], "stats": {"total": 81, "additions": 35, "deletions": 46}, "files": [{"sha": "1f83237c872957f92e4d56082cdadb9a07414d62", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7248bff7236556ac8c05e332ee464d467c87a41/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7248bff7236556ac8c05e332ee464d467c87a41/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=d7248bff7236556ac8c05e332ee464d467c87a41", "patch": "@@ -6282,37 +6282,22 @@ gen_subprogram_die (decl, context_die)\n      (if it has one - it may be just a declaration).  */\n   outer_scope = DECL_INITIAL (decl);\n \n+  /* Note that here, `outer_scope' is a pointer to the outermost BLOCK\n+     node created to represent a function. This outermost BLOCK actually\n+     represents the outermost binding contour for the function, i.e. the\n+     contour in which the function's formal parameters and labels get\n+     declared. Curiously, it appears that the front end doesn't actually\n+     put the PARM_DECL nodes for the current function onto the BLOCK_VARS\n+     list for this outer scope.  (They are strung off of the DECL_ARGUMENTS\n+     list for the function instead.) The BLOCK_VARS list for the\n+     `outer_scope' does provide us with a list of the LABEL_DECL nodes for\n+     the function however, and we output DWARF info for those in\n+     decls_for_scope.  Just within the `outer_scope' there will be a BLOCK\n+     node representing the function's outermost pair of curly braces, and\n+     any blocks used for the base and member initializers of a C++\n+     constructor function.  */\n   if (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n-    {\n-      /* Note that here, `outer_scope' is a pointer to the outermost BLOCK\n-         node created to represent a function. This outermost BLOCK actually\n-         represents the outermost binding contour for the function, i.e. the\n-         contour in which the function's formal parameters and labels get\n-         declared. Curiously, it appears that the front end doesn't actually\n-         put the PARM_DECL nodes for the current function onto the BLOCK_VARS \n-         list for this outer scope.  (They are strung off of the\n-         DECL_ARGUMENTS list for the function instead.) The BLOCK_VARS list\n-         for the `outer_scope' does provide us with a list of the LABEL_DECL\n-         nodes for the function however, and we output DWARF info for those\n-         here. Just within the `outer_scope' there will be another BLOCK node\n-         representing the function's outermost pair of curly braces.  We\n-         musn't generate a lexical_block DIE for this outermost pair of curly\n-         braces because that is not really an independent scope according to\n-         ANSI C rules.  Rather, it is the same scope in which the parameters\n-         were declared.  */\n-      for (label = BLOCK_VARS (outer_scope);\n-\t   label;\n-\t   label = TREE_CHAIN (label))\n-\t{\n-\t  gen_decl_die (label, subr_die);\n-\t}\n-\n-      /* Note here that `BLOCK_SUBBLOCKS (outer_scope)' points to a list of\n-         BLOCK nodes which is always only one element long. That one element\n-         represents the outermost pair of curley braces for the function\n-         body.  */\n-      decls_for_scope (BLOCK_SUBBLOCKS (outer_scope), subr_die);\n-    }\n+    decls_for_scope (outer_scope, subr_die, 0);\n }\n \n /* Generate a DIE to represent a declared data object.  */\n@@ -6418,9 +6403,10 @@ gen_label_die (decl, context_die)\n \n /* Generate a DIE for a lexical block.  */\n static void\n-gen_lexical_block_die (stmt, context_die)\n+gen_lexical_block_die (stmt, context_die, depth)\n      register tree stmt;\n      register dw_die_ref context_die;\n+     int depth;\n {\n   register dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die);\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -6431,27 +6417,28 @@ gen_lexical_block_die (stmt, context_die)\n       sprintf (label, BLOCK_END_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (stmt_die, DW_AT_high_pc, label);\n     }\n-  decls_for_scope (stmt, stmt_die);\n+  decls_for_scope (stmt, stmt_die, depth);\n }\n \n /* Generate a DIE for an inlined subprogram.  */\n static void\n-gen_inlined_subroutine_die (stmt, context_die)\n+gen_inlined_subroutine_die (stmt, context_die, depth)\n      register tree stmt;\n      register dw_die_ref context_die;\n+     int depth;\n {\n-  register dw_die_ref subr_die = new_die (DW_TAG_inlined_subroutine,\n-\t\t\t\t\t  context_die);\n-  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  add_abstract_origin_attribute (subr_die, block_ultimate_origin (stmt));\n   if (!BLOCK_ABSTRACT (stmt))\n     {\n+      register dw_die_ref subr_die = new_die (DW_TAG_inlined_subroutine,\n+\t\t\t\t\t  context_die);\n+      char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+      add_abstract_origin_attribute (subr_die, block_ultimate_origin (stmt));\n       sprintf (label, BLOCK_BEGIN_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_low_pc, label);\n       sprintf (label, BLOCK_END_LABEL_FMT, next_block_number);\n       add_AT_lbl_id (subr_die, DW_AT_high_pc, label);\n+      decls_for_scope (stmt, subr_die, depth);\n     }\n-  decls_for_scope (stmt, subr_die);\n }\n \n /* Generate a DIE for a field in a record, or structure.  */\n@@ -6921,9 +6908,10 @@ gen_tagged_type_instantiation_die (type, context_die)\n /* Generate a DW_TAG_lexical_block DIE followed by DIEs to represent all of the\n    things which are local to the given block.  */\n static void\n-gen_block_die (stmt, context_die)\n+gen_block_die (stmt, context_die, depth)\n      register tree stmt;\n      register dw_die_ref context_die;\n+     int depth;\n {\n   register int must_output_die = 0;\n   register tree origin;\n@@ -6963,7 +6951,7 @@ gen_block_die (stmt, context_die)\n          rules.  So we check here to make sure that this block does not\n          represent a \"body block inlining\" before trying to set the\n          `must_output_die' flag.  */\n-      if (origin == NULL || !is_body_block (origin))\n+      if (! is_body_block (origin ? origin : stmt))\n \t{\n \t  /* Determine if this block directly contains any \"significant\"\n \t     local declarations which we will need to output DIEs for.  */\n@@ -7002,23 +6990,24 @@ gen_block_die (stmt, context_die)\n     {\n       if (origin_code == FUNCTION_DECL)\n \t{\n-\t  gen_inlined_subroutine_die (stmt, context_die);\n+\t  gen_inlined_subroutine_die (stmt, context_die, depth);\n \t}\n       else\n \t{\n-\t  gen_lexical_block_die (stmt, context_die);\n+\t  gen_lexical_block_die (stmt, context_die, depth);\n \t}\n     }\n   else\n-    decls_for_scope (stmt, context_die);\n+    decls_for_scope (stmt, context_die, depth);\n }\n \n /* Generate all of the decls declared within a given scope and (recursively)\n    all of it's sub-blocks.  */\n static void\n-decls_for_scope (stmt, context_die)\n+decls_for_scope (stmt, context_die, depth)\n      register tree stmt;\n      register dw_die_ref context_die;\n+     int depth;\n {\n   register tree decl;\n   register tree subblocks;\n@@ -7027,7 +7016,7 @@ decls_for_scope (stmt, context_die)\n     {\n       return;\n     }\n-  if (!BLOCK_ABSTRACT (stmt))\n+  if (!BLOCK_ABSTRACT (stmt) && depth > 0)\n     {\n       next_block_number++;\n     }\n@@ -7047,7 +7036,7 @@ decls_for_scope (stmt, context_die)\n        subblocks != NULL;\n        subblocks = BLOCK_CHAIN (subblocks))\n     {\n-      gen_block_die (subblocks, context_die);\n+      gen_block_die (subblocks, context_die, depth + 1);\n     }\n }\n "}]}