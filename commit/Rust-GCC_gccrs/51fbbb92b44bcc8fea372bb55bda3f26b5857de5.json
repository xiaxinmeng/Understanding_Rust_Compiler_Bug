{"sha": "51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFmYmJiOTJiNDRiY2M4ZmVhMzcyYmI1NWJkYTNmMjZiNTg1N2RlNQ==", "commit": {"author": {"name": "David Edelsohn", "email": "dje.gcc@gmail.com", "date": "2015-09-26T15:31:35Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2015-09-26T15:31:35Z"}, "message": "dwarf2out.c (XCOFF_DEBUGGING_INFO): Default 0 definition.\n\n        * dwarf2out.c (XCOFF_DEBUGGING_INFO): Default 0 definition.\n        (HAVE_XCOFF_DWARF_EXTRAS): Default to 0 definition.\n        (output_fde): Don't output length for debug_frame on AIX.\n        (output_call_frame_info): Don't output length for debug_frame on AIX.\n        (have_macinfo): Force to False for XCOFF_DEBUGGING_INFO and not\n        HAVE_XCOFF_DWARF_EXTRAS.\n        (add_AT_loc_list): Return early if XCOFF_DEBUGGING_INFO and not\n        HAVE_XCOFF_DWARF_EXTRAS.\n        (output_compilation_unit_header): Don't output length on AIX.\n        (output_pubnames): Don't output length on AIX.\n        (output_aranges): Delete argument. Compute length locally. Don't\n        output length on AIX.\n        (output_line_info): Don't output length on AIX.\n        (dwarf2out_finish): Don't compute aranges_length.\n        * dwarf2asm.c (XCOFF_DEBUGGING_INFO): Default 0 definition.\n        (dw2_asm_output_nstring): Emit .byte not .ascii on AIX.\n        * config/rs6000/rs6000.c (rs6000_output_dwarf_dtprel): Emit correct\n        symbol decoration for AIX.\n        (rs6000_xcoff_debug_unwind_info): New.\n        (rs6000_xcoff_asm_named_section): Emit .dwsect pseudo-op\n        for SECTION_DEBUG.\n        (rs6000_xcoff_declare_function_name): Emit different\n        .function pseudo-op when DWARF2_DEBUG. Don't call\n        xcoffout_declare_function for DWARF2_DEBUG.\n        * config/rs6000/xcoff.h (TARGET_DEBUG_UNWIND_INFO):\n        Redefine.\n        * config/rs6000/aix71.h: New.\n        * configure.ac (gcc_cv_as_aix_dwloc): Check AIX as for DWARF\n        locations support.\n        * configure: Regenerate.\n        * config.gcc (powerpc-ibm-aix[789]+): New stanza for AIX 7.1+ with\n        DWARF support.\n\nFrom-SVN: r228167", "tree": {"sha": "151eda3614294dd725f7e21fe506c0967056f0a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/151eda3614294dd725f7e21fe506c0967056f0a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/comments", "author": {"login": "edelsohn", "id": 667700, "node_id": "MDQ6VXNlcjY2NzcwMA==", "avatar_url": "https://avatars.githubusercontent.com/u/667700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edelsohn", "html_url": "https://github.com/edelsohn", "followers_url": "https://api.github.com/users/edelsohn/followers", "following_url": "https://api.github.com/users/edelsohn/following{/other_user}", "gists_url": "https://api.github.com/users/edelsohn/gists{/gist_id}", "starred_url": "https://api.github.com/users/edelsohn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edelsohn/subscriptions", "organizations_url": "https://api.github.com/users/edelsohn/orgs", "repos_url": "https://api.github.com/users/edelsohn/repos", "events_url": "https://api.github.com/users/edelsohn/events{/privacy}", "received_events_url": "https://api.github.com/users/edelsohn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c419f71c820766fc733c75a9455cf62d5c9260a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c419f71c820766fc733c75a9455cf62d5c9260a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c419f71c820766fc733c75a9455cf62d5c9260a9"}], "stats": {"total": 528, "additions": 477, "deletions": 51}, "files": [{"sha": "d45eb70235a0b6c16bcee385166f5061c4765288", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -1,3 +1,38 @@\n+2015-09-26  David Edelsohn  <dje.gcc@gmail.com>\n+\n+\t* dwarf2out.c (XCOFF_DEBUGGING_INFO): Default 0 definition.\n+\t(HAVE_XCOFF_DWARF_EXTRAS): Default to 0 definition.\n+\t(output_fde): Don't output length for debug_frame on AIX.\n+\t(output_call_frame_info): Don't output length for debug_frame on AIX.\n+\t(have_macinfo): Force to False for XCOFF_DEBUGGING_INFO and not\n+\tHAVE_XCOFF_DWARF_EXTRAS.\n+\t(add_AT_loc_list): Return early if XCOFF_DEBUGGING_INFO and not\n+\tHAVE_XCOFF_DWARF_EXTRAS.\n+\t(output_compilation_unit_header): Don't output length on AIX.\n+\t(output_pubnames): Don't output length on AIX.\n+\t(output_aranges): Delete argument. Compute length locally. Don't\n+\toutput length on AIX.\n+\t(output_line_info): Don't output length on AIX.\n+\t(dwarf2out_finish): Don't compute aranges_length.\n+\t* dwarf2asm.c (XCOFF_DEBUGGING_INFO): Default 0 definition.\n+\t(dw2_asm_output_nstring): Emit .byte not .ascii on AIX.\n+\t* config/rs6000/rs6000.c (rs6000_output_dwarf_dtprel): Emit correct\n+\tsymbol decoration for AIX.\n+\t(rs6000_xcoff_debug_unwind_info): New.\n+\t(rs6000_xcoff_asm_named_section): Emit .dwsect pseudo-op\n+\tfor SECTION_DEBUG.\n+\t(rs6000_xcoff_declare_function_name): Emit different\n+\t.function pseudo-op when DWARF2_DEBUG. Don't call\n+\txcoffout_declare_function for DWARF2_DEBUG.\n+\t* config/rs6000/xcoff.h (TARGET_DEBUG_UNWIND_INFO):\n+\tRedefine.\n+\t* config/rs6000/aix71.h: New.\n+\t* configure.ac (gcc_cv_as_aix_dwloc): Check AIX as for DWARF\n+\tlocations support.\n+\t* configure: Regenerate.\n+\t* config.gcc (powerpc-ibm-aix[789]+): New stanza for AIX 7.1+ with\n+\tDWARF support.\n+\n 2015-09-26  Jeff Law  <law@redhat.com>\n \n \t* config/arc/arc.c (arc_output_addsi): Fix left shift undefined"}, {"sha": "c52f5a8975a20c8a798cd6793c9f0b477cfcafef", "filename": "gcc/config.gcc", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -2527,7 +2527,7 @@ rs6000-ibm-aix5.3.* | powerpc-ibm-aix5.3.*)\n \tuse_gcc_stdint=wrap\n \textra_headers=altivec.h\n \t;;\n-rs6000-ibm-aix[6789].* | powerpc-ibm-aix[6789].*)\n+rs6000-ibm-aix6.* | powerpc-ibm-aix6.*)\n \ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix61.h rs6000/xcoff.h rs6000/aix-stdint.h\"\n \ttmake_file=\"rs6000/t-aix52 t-slibgcc\"\n \textra_options=\"${extra_options} rs6000/aix64.opt\"\n@@ -2536,6 +2536,15 @@ rs6000-ibm-aix[6789].* | powerpc-ibm-aix[6789].*)\n \tuse_gcc_stdint=wrap\n \textra_headers=altivec.h\n \t;;\n+rs6000-ibm-aix[789].* | powerpc-ibm-aix[789].*)\n+\ttm_file=\"${tm_file} rs6000/aix.h rs6000/aix71.h rs6000/xcoff.h rs6000/aix-stdint.h\"\n+\ttmake_file=\"rs6000/t-aix52 t-slibgcc\"\n+\textra_options=\"${extra_options} rs6000/aix64.opt\"\n+\tuse_collect2=yes\n+\tthread_file='aix'\n+\tuse_gcc_stdint=wrap\n+\textra_headers=altivec.h\n+\t;;\n rl78-*-elf*)\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n \ttarget_has_targetm_common=no"}, {"sha": "2e676b0f3e03b41971ed0f6e0935ccc84044789e", "filename": "gcc/config/rs6000/aix71.h", "status": "added", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig%2Frs6000%2Faix71.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig%2Frs6000%2Faix71.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix71.h?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -0,0 +1,231 @@\n+/* Definitions of target machine for GNU compiler,\n+   for IBM RS/6000 POWER running AIX V7.1.\n+   Copyright (C) 2002-2015 Free Software Foundation, Inc.\n+   Contributed by David Edelsohn (edelsohn@gnu.org).\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to\n+   get control in TARGET_OPTION_OVERRIDE.  */\n+\n+#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_64BIT && ! TARGET_POWERPC64)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rs6000_isa_flags |= OPTION_MASK_POWERPC64;\t\t\t\\\n+      warning (0, \"-maix64 requires PowerPC64 architecture remain enabled\"); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_SOFT_FLOAT && TARGET_LONG_DOUBLE_128)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rs6000_long_double_type_size = 64;\t\t\t\t\\\n+      if (global_options_set.x_rs6000_long_double_type_size)\t\t\\\n+\twarning (0, \"soft-float and long-double-128 are incompatible\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_POWERPC64 && ! TARGET_64BIT)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      error (\"-maix64 required: 64-bit computation with 32-bit addressing not yet supported\"); \\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if ((rs6000_isa_flags_explicit\t\t\t\t\t\\\n+       & OPTION_MASK_MINIMAL_TOC) != 0)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (global_options_set.x_rs6000_current_cmodel\t\t\t\\\n+\t  && rs6000_current_cmodel != CMODEL_SMALL)\t\t\t\\\n+\terror (\"-mcmodel incompatible with other toc options\"); \t\\\n+      SET_CMODEL (CMODEL_SMALL);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (rs6000_current_cmodel != CMODEL_SMALL)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TARGET_NO_FP_IN_TOC = 0;\t\t\t\t\t\t\\\n+      TARGET_NO_SUM_IN_TOC = 0;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (rs6000_current_cmodel == CMODEL_MEDIUM)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rs6000_current_cmodel = CMODEL_LARGE;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0);\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"-u %{maix64:-a64 %{!mcpu*:-mppc64}} %(asm_cpu)\"\n+\n+/* Common ASM definitions used by ASM_SPEC amongst the various targets for\n+   handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to\n+   provide the default assembler options if the user uses -mcpu=native, so if\n+   you make changes here, make them there also.  */\n+#undef ASM_CPU_SPEC\n+#define ASM_CPU_SPEC \\\n+\"%{!mcpu*: %{!maix64: \\\n+  %{mpowerpc64: -mppc64} \\\n+  %{maltivec: -m970} \\\n+  %{!maltivec: %{!mpowerpc64: %(asm_default)}}}} \\\n+%{mcpu=native: %(asm_cpu_native)} \\\n+%{mcpu=power3: -m620} \\\n+%{mcpu=power4: -mpwr4} \\\n+%{mcpu=power5: -mpwr5} \\\n+%{mcpu=power5+: -mpwr5x} \\\n+%{mcpu=power6: -mpwr6} \\\n+%{mcpu=power6x: -mpwr6} \\\n+%{mcpu=power7: -mpwr7} \\\n+%{mcpu=power8: -mpwr8} \\\n+%{mcpu=powerpc: -mppc} \\\n+%{mcpu=rs64a: -mppc} \\\n+%{mcpu=603: -m603} \\\n+%{mcpu=603e: -m603} \\\n+%{mcpu=604: -m604} \\\n+%{mcpu=604e: -m604} \\\n+%{mcpu=620: -m620} \\\n+%{mcpu=630: -m620} \\\n+%{mcpu=970: -m970} \\\n+%{mcpu=G5: -m970} \\\n+%{mvsx: %{!mcpu*: -mpwr6}} \\\n+-many\"\n+\n+#undef\tASM_DEFAULT_SPEC\n+#define ASM_DEFAULT_SPEC \"-mpwr4\"\n+\n+#undef TARGET_OS_CPP_BUILTINS\n+#define TARGET_OS_CPP_BUILTINS()     \\\n+  do                                 \\\n+    {                                \\\n+      builtin_define (\"_AIX43\");     \\\n+      builtin_define (\"_AIX51\");     \\\n+      builtin_define (\"_AIX52\");     \\\n+      builtin_define (\"_AIX53\");     \\\n+      builtin_define (\"_AIX61\");     \\\n+      builtin_define (\"_AIX71\");     \\\n+      TARGET_OS_AIX_CPP_BUILTINS (); \\\n+    }                                \\\n+  while (0)\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE}\t\\\n+  %{ansi: -D_ANSI_C_SOURCE}\t\t\t\\\n+  %{maix64: -D__64BIT__}\t\t\t\\\n+  %{mpe: -I%R/usr/lpp/ppe.poe/include}\t\t\\\n+  %{pthread: -D_THREAD_SAFE}\"\n+\n+/* The GNU C++ standard library requires that these macros be \n+   defined.  Synchronize with libstdc++ os_defines.h.  */\n+#undef CPLUSPLUS_CPP_SPEC                       \n+#define CPLUSPLUS_CPP_SPEC\t\t\t\\\n+  \"-D_ALL_SOURCE -D__COMPATMATH__\t\t\\\n+   %{maix64: -D__64BIT__}\t\t\t\\\n+   %{mpe: -I%R/usr/lpp/ppe.poe/include}\t\t\\\n+   %{pthread: -D_THREAD_SAFE}\"\n+\n+#undef  TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_PPC_GPOPT | MASK_PPC_GFXOPT | MASK_MFCRF)\n+\n+#undef  PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_POWER7\n+#undef  PROCESSOR_DEFAULT64\n+#define PROCESSOR_DEFAULT64 PROCESSOR_POWER7\n+\n+/* AIX 7.1 kernel and assembler have necessary support for Altivec and VSX.  */\n+#undef OS_MISSING_ALTIVEC\n+\n+/* Define this macro as a C expression for the initializer of an\n+   array of string to tell the driver program which options are\n+   defaults for this target and thus do not need to be handled\n+   specially when using `MULTILIB_OPTIONS'.\n+\n+   Do not define this macro if `MULTILIB_OPTIONS' is not defined in\n+   the target makefile fragment or if none of the options listed in\n+   `MULTILIB_OPTIONS' are set by default.  *Note Target Fragment::.  */\n+\n+#undef\tMULTILIB_DEFAULTS\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{pg:-L%R/lib/profiled -L%R/usr/lib/profiled}\\\n+   %{p:-L%R/lib/profiled -L%R/usr/lib/profiled}\\\n+   %{!maix64:%{!shared:%{g*:-lg}}}\\\n+   %{fprofile-arcs|fprofile-generate*|coverage:-lpthreads}\\\n+   %{mpe:-L%R/usr/lpp/ppe.poe/lib -lmpi -lvtd}\\\n+   %{pthread:-lpthreads} -lc\"\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"-bpT:0x10000000 -bpD:0x20000000 %{!r:-btextro}\\\n+   %{static:-bnso %(link_syscalls) } %{shared:-bM:SRE %{!e:-bnoentry}}\\\n+   %{!maix64:%{!shared:%{g*: %(link_libg) }}} %{maix64:-b64}\\\n+   %{mpe:-binitfini:poe_remote_main}\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{!shared:\\\n+   %{maix64:%{pg:gcrt0_64%O%s;:%{p:mcrt0_64%O%s;:crt0_64%O%s}};:\\\n+     %{pthread:%{pg:gcrt0_r%O%s;:%{p:mcrt0_r%O%s;:crt0_r%O%s}};:\\\n+       %{pg:gcrt0%O%s;:%{p:mcrt0%O%s;:crt0%O%s}}}}}\\\n+   %{shared:crtcxa_s%O%s;:crtcxa%O%s} crtdbase%O%s\"\n+\n+/* AIX V5 typedefs ptrdiff_t as \"long\" while earlier releases used \"int\".  */\n+\n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"long int\"\n+\n+/* Type used for wchar_t, as a string used in a declaration.  */\n+#undef  WCHAR_TYPE\n+#define WCHAR_TYPE (!TARGET_64BIT ? \"short unsigned int\" : \"unsigned int\")\n+\n+/* Width of wchar_t in bits.  */\n+#undef  WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE (!TARGET_64BIT ? 16 : 32)\n+\n+/* AIX 4.2 and above provides initialization and finalization function\n+   support from linker command line.  */\n+#undef HAS_INIT_SECTION\n+#define HAS_INIT_SECTION\n+\n+#undef LD_INIT_SWITCH\n+#define LD_INIT_SWITCH \"-binitfini\"\n+\n+#ifndef _AIX52\n+extern long long int    atoll(const char *);  \n+#endif\n+\n+/* This target uses the aix64.opt file.  */\n+#define TARGET_USES_AIX64_OPT 1\n+\n+/* Large TOC Support */\n+#ifdef HAVE_LD_LARGE_TOC\n+#undef TARGET_CMODEL\n+#define TARGET_CMODEL rs6000_current_cmodel\n+#define SET_CMODEL(opt) rs6000_current_cmodel = opt\n+#else\n+#define SET_CMODEL(opt) do {} while (0)\n+#endif\n+\n+/* This target defines SUPPORTS_WEAK and TARGET_ASM_NAMED_SECTION,\n+   but does not have crtbegin/end.  */\n+\n+#define TARGET_USE_JCR_SECTION 0\n+\n+#define TARGET_AIX_VERSION 71\n+\n+/* AIX 7.1 supports DWARF3 debugging, but XCOFF remains the default.  */\n+#define DWARF2_DEBUGGING_INFO 1\n+#define PREFERRED_DEBUGGING_TYPE XCOFF_DEBUG\n+#define DEBUG_INFO_SECTION\t\"0x10000\"\n+#define DEBUG_LINE_SECTION\t\"0x20000\"\n+#define DEBUG_PUBNAMES_SECTION\t\"0x30000\"\n+#define DEBUG_PUBTYPES_SECTION\t\"0x40000\"\n+#define DEBUG_ARANGES_SECTION\t\"0x50000\"\n+#define DEBUG_ABBREV_SECTION\t\"0x60000\"\n+#define DEBUG_STR_SECTION\t\"0x70000\"\n+#define DEBUG_RANGES_SECTION\t\"0x80000\"\n+#define DEBUG_LOC_SECTION\t\"0x90000\"\n+#define DEBUG_FRAME_SECTION\t\"0xA0000\"\n+#define DEBUG_MACINFO_SECTION\t\"0xB0000\"\n+#define DEBUG_MACRO_SECTION\t\"0xB0000\"\n+"}, {"sha": "34b1d32f8f86feeaeccf8583a876b38efc22d6de", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 67, "deletions": 12, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -7204,7 +7204,28 @@ rs6000_output_dwarf_dtprel (FILE *file, int size, rtx x)\n       gcc_unreachable ();\n     }\n   output_addr_const (file, x);\n-  fputs (\"@dtprel+0x8000\", file);\n+  if (TARGET_ELF)\n+    fputs (\"@dtprel+0x8000\", file);\n+  else if (TARGET_XCOFF && GET_CODE (x) == SYMBOL_REF)\n+    {\n+      switch (SYMBOL_REF_TLS_MODEL (x))\n+\t{\n+\tcase 0:\n+\t  break;\n+\tcase TLS_MODEL_LOCAL_EXEC:\n+\t  fputs (\"@le\", file);\n+\t  break;\n+\tcase TLS_MODEL_INITIAL_EXEC:\n+\t  fputs (\"@ie\", file);\n+\t  break;\n+\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n+\tcase TLS_MODEL_LOCAL_DYNAMIC:\n+\t  fputs (\"@m\", file);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n }\n \n /* Return true if X is a symbol that refers to real (rather than emulated)\n@@ -27316,24 +27337,31 @@ output_toc (FILE *file, rtx x, int labelno, machine_mode mode)\n     output_addr_const (file, x);\n \n #if HAVE_AS_TLS\n-  if (TARGET_XCOFF && GET_CODE (base) == SYMBOL_REF\n-      && SYMBOL_REF_TLS_MODEL (base) != 0)\n+  if (TARGET_XCOFF && GET_CODE (base) == SYMBOL_REF)\n     {\n-      if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_LOCAL_EXEC)\n-\tfputs (\"@le\", file);\n-      else if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_INITIAL_EXEC)\n-\tfputs (\"@ie\", file);\n-      /* Use global-dynamic for local-dynamic.  */\n-      else if (SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_GLOBAL_DYNAMIC\n-\t       || SYMBOL_REF_TLS_MODEL (base) == TLS_MODEL_LOCAL_DYNAMIC)\n+      switch (SYMBOL_REF_TLS_MODEL (base))\n \t{\n+\tcase 0:\n+\t  break;\n+\tcase TLS_MODEL_LOCAL_EXEC:\n+\t  fputs (\"@le\", file);\n+\t  break;\n+\tcase TLS_MODEL_INITIAL_EXEC:\n+\t  fputs (\"@ie\", file);\n+\t  break;\n+\t/* Use global-dynamic for local-dynamic.  */\n+\tcase TLS_MODEL_GLOBAL_DYNAMIC:\n+\tcase TLS_MODEL_LOCAL_DYNAMIC:\n \t  putc ('\\n', file);\n \t  (*targetm.asm_out.internal_label) (file, \"LCM\", labelno);\n \t  fputs (\"\\t.tc .\", file);\n \t  RS6000_OUTPUT_BASENAME (file, name);\n \t  fputs (\"[TC],\", file);\n \t  output_addr_const (file, x);\n \t  fputs (\"@m\", file);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n     }\n #endif\n@@ -30684,6 +30712,20 @@ rs6000_elf_file_end (void)\n #endif\n \n #if TARGET_XCOFF\n+\n+#ifndef HAVE_XCOFF_DWARF_EXTRAS\n+#define HAVE_XCOFF_DWARF_EXTRAS 0\n+#endif\n+\n+static enum unwind_info_type\n+rs6000_xcoff_debug_unwind_info (void)\n+{\n+  if (HAVE_XCOFF_DWARF_EXTRAS)\n+    return UI_DWARF2;\n+  else\n+    return UI_NONE;\n+}\n+\n static void\n rs6000_xcoff_asm_output_anchor (rtx symbol)\n {\n@@ -30805,6 +30847,11 @@ rs6000_xcoff_asm_named_section (const char *name, unsigned int flags,\n   int smclass;\n   static const char * const suffix[4] = { \"PR\", \"RO\", \"RW\", \"TL\" };\n \n+  if (flags & SECTION_DEBUG)\n+    {\n+      fprintf (asm_out_file, \"\\t.dwsect %s\\n\", name);\n+      return;\n+    }\n   if (flags & SECTION_CODE)\n     smclass = 0;\n   else if (flags & SECTION_TLS)\n@@ -31140,8 +31187,16 @@ rs6000_xcoff_declare_function_name (FILE *file, const char *name, tree decl)\n   fputs (\":\\n\", file);\n   data.function_descriptor = true;\n   symtab_node::get (decl)->call_for_symbol_and_aliases (rs6000_declare_alias, &data, true);\n-  if (write_symbols != NO_DEBUG && !DECL_IGNORED_P (decl))\n-    xcoffout_declare_function (file, decl, buffer);\n+  if (!DECL_IGNORED_P (decl))\n+    {\n+      if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n+\txcoffout_declare_function (file, decl, buffer);\n+      else if (write_symbols == DWARF2_DEBUG)\n+\t{\n+\t  name = (*targetm.strip_name_encoding) (name);\n+\t  fprintf (file, \"\\t.function .%s,.%s,2,0\\n\", name, name);\n+\t}\n+    }\n   return;\n }\n "}, {"sha": "5cdf87ce2c5b349c072421fddd47382e480a7666", "filename": "gcc/config/rs6000/xcoff.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfig%2Frs6000%2Fxcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxcoff.h?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -86,6 +86,8 @@\n \t       || (SCALAR_FLOAT_MODE_P (GET_MODE (X))\t\t\t\\\n \t\t   && ! TARGET_NO_FP_IN_TOC)))))\n \n+#undef TARGET_DEBUG_UNWIND_INFO\n+#define TARGET_DEBUG_UNWIND_INFO  rs6000_xcoff_debug_unwind_info\n #define TARGET_ASM_OUTPUT_ANCHOR  rs6000_xcoff_asm_output_anchor\n #define TARGET_ASM_GLOBALIZE_LABEL  rs6000_xcoff_asm_globalize_label\n #define TARGET_ASM_INIT_SECTIONS  rs6000_xcoff_asm_init_sections"}, {"sha": "4d6e153e2952f90c19f8ff5ba6869dbbe1162e6a", "filename": "gcc/configure", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -26452,6 +26452,46 @@ $as_echo \"#define HAVE_AS_REF 1\" >>confdefs.h\n fi\n \t;;\n     esac\n+\n+    case $target in\n+      *-*-aix*)\n+        { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for dwarf location lists section support\" >&5\n+$as_echo_n \"checking assembler for dwarf location lists section support... \" >&6; }\n+if test \"${gcc_cv_as_aix_dwloc+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_aix_dwloc=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 21 \\) \\* 1000 + 0`\n+  then gcc_cv_as_aix_dwloc=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo '\t.dwsect 0xB0000\n+          ' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags  -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+        gcc_cv_as_aix_dwloc=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_aix_dwloc\" >&5\n+$as_echo \"$gcc_cv_as_aix_dwloc\" >&6; }\n+if test $gcc_cv_as_aix_dwloc = yes; then\n+\n+$as_echo \"#define HAVE_XCOFF_DWARF_EXTRAS 1\" >>confdefs.h\n+\n+fi\n+        ;;\n+    esac\n     ;;\n \n   mips*-*-*)"}, {"sha": "451acfa0cd748e9dcefc58fd19af303e5165a9e6", "filename": "gcc/configure.ac", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -4328,6 +4328,18 @@ LCF0:\n     esac\n     ;;\n \n+    case $target in\n+      *-*-aix*)\n+\tgcc_GAS_CHECK_FEATURE([dwarf location lists section support],\n+\t  gcc_cv_as_aix_dwloc, [2,21,0],,\n+\t  [\t.dwsect 0xB0000\n+\t  ],,\n+\t  [AC_DEFINE(HAVE_XCOFF_DWARF_EXTRAS, 1,\n+\t    [Define if your assembler supports .dwsect 0xB0000])])\n+\t;;\n+    esac\n+    ;;\n+\n   mips*-*-*)\n     gcc_GAS_CHECK_FEATURE([explicit relocation support],\n       gcc_cv_as_mips_explicit_relocs, [2,14,0],,\n@@ -4336,6 +4348,7 @@ LCF0:\n        then target_cpu_default=MASK_EXPLICIT_RELOCS\n        else target_cpu_default=\"($target_cpu_default)|MASK_EXPLICIT_RELOCS\"\n        fi])\n+\n     gcc_GAS_CHECK_FEATURE([-mno-shared support],\n       gcc_cv_as_mips_no_shared, [2,16,0], [-mno-shared], [nop],,\n       [AC_DEFINE(HAVE_AS_NO_SHARED, 1,"}, {"sha": "53140253f8dc4a9f7262d9b72cc40fcad5b8593f", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -34,6 +34,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dwarf2.h\"\n #include \"tm_p.h\"\n \n+#ifndef XCOFF_DEBUGGING_INFO\n+#define XCOFF_DEBUGGING_INFO 0\n+#endif\n+\n \f\n /* Output an unaligned integer with the given value and size.  Prefer not\n    to print a newline, since the caller may want to add a comment.  */\n@@ -306,7 +310,11 @@ dw2_asm_output_nstring (const char *str, size_t orig_len,\n \n   if (flag_debug_asm && comment)\n     {\n-      fputs (\"\\t.ascii \\\"\", asm_out_file);\n+      if (XCOFF_DEBUGGING_INFO)\n+\tfputs (\"\\t.byte \\\"\", asm_out_file);\n+      else\n+\tfputs (\"\\t.ascii \\\"\", asm_out_file);\n+\n       for (i = 0; i < len; i++)\n \t{\n \t  int c = str[i];"}, {"sha": "4edc2ae19e46c4d29fd9d7e2e19670ddb933190b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 70, "deletions": 37, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51fbbb92b44bcc8fea372bb55bda3f26b5857de5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=51fbbb92b44bcc8fea372bb55bda3f26b5857de5", "patch": "@@ -108,6 +108,14 @@ static rtx_insn *last_var_location_insn;\n static rtx_insn *cached_next_real_insn;\n static void dwarf2out_decl (tree);\n \n+#ifndef XCOFF_DEBUGGING_INFO\n+#define XCOFF_DEBUGGING_INFO 0\n+#endif\n+\n+#ifndef HAVE_XCOFF_DWARF_EXTRAS\n+#define HAVE_XCOFF_DWARF_EXTRAS 0\n+#endif\n+\n #ifdef VMS_DEBUGGING_INFO\n int vms_file_stats_name (const char *, long long *, long *, char *, int *);\n \n@@ -594,11 +602,14 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n \t\t\t\t  for_eh + j);\n   ASM_GENERATE_INTERNAL_LABEL (l1, FDE_AFTER_SIZE_LABEL, for_eh + j);\n   ASM_GENERATE_INTERNAL_LABEL (l2, FDE_END_LABEL, for_eh + j);\n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n-    dw2_asm_output_data (4, 0xffffffff, \"Initial length escape value\"\n-\t\t\t \" indicating 64-bit DWARF extension\");\n-  dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n-\t\t\t\"FDE Length\");\n+  if (!XCOFF_DEBUGGING_INFO || for_eh)\n+    {\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n+\tdw2_asm_output_data (4, 0xffffffff, \"Initial length escape value\"\n+\t\t\t     \" indicating 64-bit DWARF extension\");\n+      dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t    \"FDE Length\");\n+    }\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   if (for_eh)\n@@ -794,11 +805,14 @@ output_call_frame_info (int for_eh)\n   /* Output the CIE.  */\n   ASM_GENERATE_INTERNAL_LABEL (l1, CIE_AFTER_SIZE_LABEL, for_eh);\n   ASM_GENERATE_INTERNAL_LABEL (l2, CIE_END_LABEL, for_eh);\n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n-    dw2_asm_output_data (4, 0xffffffff,\n-      \"Initial length escape value indicating 64-bit DWARF extension\");\n-  dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n-\t\t\t\"Length of Common Information Entry\");\n+  if (!XCOFF_DEBUGGING_INFO || for_eh)\n+    {\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4 && !for_eh)\n+\tdw2_asm_output_data (4, 0xffffffff,\n+\t  \"Initial length escape value indicating 64-bit DWARF extension\");\n+      dw2_asm_output_delta (for_eh ? 4 : DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t    \"Length of Common Information Entry\");\n+    }\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   /* Now that the CIE pointer is PC-relative for EH,\n@@ -2995,7 +3009,8 @@ static GTY (()) vec<macinfo_entry, va_gc> *macinfo_table;\n /* True if .debug_macinfo or .debug_macros section is going to be\n    emitted.  */\n #define have_macinfo \\\n-  (debug_info_level >= DINFO_LEVEL_VERBOSE \\\n+  ((!XCOFF_DEBUGGING_INFO || HAVE_XCOFF_DWARF_EXTRAS) \\\n+   && debug_info_level >= DINFO_LEVEL_VERBOSE \\\n    && !macinfo_table->is_empty ())\n \n /* Array of dies for which we should generate .debug_ranges info.  */\n@@ -3202,7 +3217,7 @@ static void add_enumerator_pubname (const char *, dw_die_ref);\n static void add_pubname_string (const char *, dw_die_ref);\n static void add_pubtype (tree, dw_die_ref);\n static void output_pubnames (vec<pubname_entry, va_gc> *);\n-static void output_aranges (unsigned long);\n+static void output_aranges (void);\n static unsigned int add_ranges_num (int);\n static unsigned int add_ranges (const_tree);\n static void add_ranges_by_labels (dw_die_ref, const char *, const char *,\n@@ -4236,6 +4251,9 @@ add_AT_loc_list (dw_die_ref die, enum dwarf_attribute attr_kind, dw_loc_list_ref\n {\n   dw_attr_node attr;\n \n+  if (XCOFF_DEBUGGING_INFO && !HAVE_XCOFF_DWARF_EXTRAS)\n+    return;\n+\n   attr.dw_attr = attr_kind;\n   attr.dw_attr_val.val_class = dw_val_class_loc_list;\n   attr.dw_attr_val.val_entry = NULL;\n@@ -9197,12 +9215,16 @@ output_compilation_unit_header (void)\n      DWARFv5 draft DIE tags in DWARFv4 format.  */\n   int ver = dwarf_version < 5 ? dwarf_version : 4;\n \n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n-    dw2_asm_output_data (4, 0xffffffff,\n-      \"Initial length escape value indicating 64-bit DWARF extension\");\n-  dw2_asm_output_data (DWARF_OFFSET_SIZE,\n-\t\t       next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n-\t\t       \"Length of Compilation Unit Info\");\n+  if (!XCOFF_DEBUGGING_INFO)\n+    {\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\tdw2_asm_output_data (4, 0xffffffff,\n+\t  \"Initial length escape value indicating 64-bit DWARF extension\");\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE,\n+\t\t\t   next_die_offset - DWARF_INITIAL_LENGTH_SIZE,\n+\t\t\t   \"Length of Compilation Unit Info\");\n+    }\n+\n   dw2_asm_output_data (2, ver, \"DWARF version number\");\n   dw2_asm_output_offset (DWARF_OFFSET_SIZE, abbrev_section_label,\n \t\t\t debug_abbrev_section,\n@@ -9632,10 +9654,14 @@ output_pubnames (vec<pubname_entry, va_gc> *names)\n   unsigned long pubnames_length = size_of_pubnames (names);\n   pubname_entry *pub;\n \n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n-    dw2_asm_output_data (4, 0xffffffff,\n-      \"Initial length escape value indicating 64-bit DWARF extension\");\n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length, \"Pub Info Length\");\n+  if (!XCOFF_DEBUGGING_INFO)\n+    {\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\tdw2_asm_output_data (4, 0xffffffff,\n+\t  \"Initial length escape value indicating 64-bit DWARF extension\");\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n+\t\t\t   \"Pub Info Length\");\n+    }\n \n   /* Version number for pubnames/pubtypes is independent of dwarf version.  */\n   dw2_asm_output_data (2, 2, \"DWARF Version\");\n@@ -9705,15 +9731,20 @@ output_pubtables (void)\n    text section generated for this compilation unit.  */\n \n static void\n-output_aranges (unsigned long aranges_length)\n+output_aranges (void)\n {\n   unsigned i;\n+  unsigned long aranges_length = size_of_aranges ();\n+  \n+  if (!XCOFF_DEBUGGING_INFO)\n+    {\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\tdw2_asm_output_data (4, 0xffffffff,\n+\t  \"Initial length escape value indicating 64-bit DWARF extension\");\n+      dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,\n+\t\t\t   \"Length of Address Ranges Info\");\n+    }\n \n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n-    dw2_asm_output_data (4, 0xffffffff,\n-      \"Initial length escape value indicating 64-bit DWARF extension\");\n-  dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,\n-\t\t       \"Length of Address Ranges Info\");\n   /* Version number for aranges is still 2, even up to DWARF5.  */\n   dw2_asm_output_data (2, 2, \"DWARF Version\");\n   if (dwarf_split_debug_info)\n@@ -10397,11 +10428,15 @@ output_line_info (bool prologue_only)\n   ASM_GENERATE_INTERNAL_LABEL (p1, LN_PROLOG_AS_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (p2, LN_PROLOG_END_LABEL, 0);\n \n-  if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n-    dw2_asm_output_data (4, 0xffffffff,\n-      \"Initial length escape value indicating 64-bit DWARF extension\");\n-  dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n-\t\t\t\"Length of Source Line Info\");\n+  if (!XCOFF_DEBUGGING_INFO)\n+    {\n+      if (DWARF_INITIAL_LENGTH_SIZE - DWARF_OFFSET_SIZE == 4)\n+\tdw2_asm_output_data (4, 0xffffffff,\n+\t  \"Initial length escape value indicating 64-bit DWARF extension\");\n+      dw2_asm_output_delta (DWARF_OFFSET_SIZE, l2, l1,\n+\t\t\t    \"Length of Source Line Info\");\n+    }\n+\n   ASM_OUTPUT_LABEL (asm_out_file, l1);\n \n   dw2_asm_output_data (2, ver, \"DWARF Version\");\n@@ -22031,7 +22066,7 @@ dwarf_file_hasher::hash (dwarf_file_data *p)\n    just a unique number which is associated with only that one filename.  We\n    need such numbers for the sake of generating labels (in the .debug_sfnames\n    section) and references to those files numbers (in the .debug_srcinfo\n-   and.debug_macinfo sections).  If the filename given as an argument is not\n+   and .debug_macinfo sections).  If the filename given as an argument is not\n    found in our current list, add it to the list and assign it the next\n    available unique index number.  */\n \n@@ -25502,10 +25537,8 @@ dwarf2out_finish (const char *filename)\n      generate a table that would have contained data.  */\n   if (info_section_emitted)\n     {\n-      unsigned long aranges_length = size_of_aranges ();\n-\n       switch_to_section (debug_aranges_section);\n-      output_aranges (aranges_length);\n+      output_aranges ();\n     }\n \n   /* Output ranges section if necessary.  */"}]}