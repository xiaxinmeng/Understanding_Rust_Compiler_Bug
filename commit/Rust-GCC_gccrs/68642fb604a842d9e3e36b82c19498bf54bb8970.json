{"sha": "68642fb604a842d9e3e36b82c19498bf54bb8970", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg2NDJmYjYwNGE4NDJkOWUzZTM2YjgyYzE5NDk4YmY1NGJiODk3MA==", "commit": {"author": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2000-01-03T21:33:10Z"}, "committer": {"name": "Ulrich Drepper", "email": "drepper@gcc.gnu.org", "date": "2000-01-03T21:33:10Z"}, "message": "(flag_isoc9x): New variable to be able to use code in c-common.c.\n\nFor now always zero.\n\nFrom-SVN: r31185", "tree": {"sha": "7d33d862618a7cb58a5d92fba3b6143244656c2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d33d862618a7cb58a5d92fba3b6143244656c2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68642fb604a842d9e3e36b82c19498bf54bb8970", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68642fb604a842d9e3e36b82c19498bf54bb8970", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68642fb604a842d9e3e36b82c19498bf54bb8970", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68642fb604a842d9e3e36b82c19498bf54bb8970/comments", "author": null, "committer": null, "parents": [{"sha": "4b3b53287de4c2ff7d8105b4045157a8b886737b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b3b53287de4c2ff7d8105b4045157a8b886737b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b3b53287de4c2ff7d8105b4045157a8b886737b"}], "stats": {"total": 597, "additions": 300, "deletions": 297}, "files": [{"sha": "83b3b9ea69ec6fbbc4cc0abe6475a2691d03ce8e", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 300, "deletions": 297, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68642fb604a842d9e3e36b82c19498bf54bb8970/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68642fb604a842d9e3e36b82c19498bf54bb8970/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=68642fb604a842d9e3e36b82c19498bf54bb8970", "patch": "@@ -191,7 +191,7 @@ static void indent PROTO((void));\n tree error_mark_list;\n \n /* The following symbols are subsumed in the cp_global_trees array, and\n-   listed here individually for documentation purposes. \n+   listed here individually for documentation purposes.\n \n    C++ extensions\n \ttree wchar_decl_node;\n@@ -322,6 +322,10 @@ tree current_function_decl;\n \n tree current_function_return_value;\n \n+/* Nonzero means use the ISO C9x dialect of C.  */\n+\n+int flag_isoc9x;\n+\n /* Nonzero means give `double' the same size as `float'.  */\n \n extern int flag_short_double;\n@@ -490,7 +494,7 @@ struct binding_level\n   };\n \n #define NULL_BINDING_LEVEL ((struct binding_level *) NULL)\n-  \n+\n /* The binding level currently in effect.  */\n \n #define current_binding_level\t\t\t\\\n@@ -1022,13 +1026,13 @@ push_class_binding (id, decl)\n /* Remove the binding for DECL which should be the innermost binding\n    for ID.  */\n \n-static void \n-pop_binding (id, decl) \n+static void\n+pop_binding (id, decl)\n      tree id;\n      tree decl;\n {\n   tree binding;\n-    \n+\n   if (id == NULL_TREE)\n     /* It's easiest to write the loops that call this function without\n        checking whether or not the entities involved have names.  We\n@@ -1081,7 +1085,7 @@ pop_label (link)\n }\n \n /* At the end of a function, all labels declared within the fucntion\n-   go out of scope.  BLOCK is the top-level block for the \n+   go out of scope.  BLOCK is the top-level block for the\n    function.  */\n \n static void\n@@ -1248,15 +1252,15 @@ poplevel (keep, reverse, functionbody)\n      in a for-init statement were in scope after the for-statement\n      ended.  We only use the new rules in flag_new_for_scope is\n      nonzero.  */\n-  leaving_for_scope \n+  leaving_for_scope\n     = current_binding_level->is_for_scope && flag_new_for_scope == 1;\n \n   /* Remove declarations for all the DECLs in this level.  */\n   for (link = decls; link; link = TREE_CHAIN (link))\n     {\n       if (leaving_for_scope && TREE_CODE (link) == VAR_DECL)\n \t{\n-\t  tree outer_binding \n+\t  tree outer_binding\n \t    = TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (link)));\n \t  tree ns_binding;\n \n@@ -1265,21 +1269,21 @@ poplevel (keep, reverse, functionbody)\n \t  else\n \t    ns_binding = NULL_TREE;\n \n-\t  if (outer_binding \n-\t      && (BINDING_LEVEL (outer_binding) \n+\t  if (outer_binding\n+\t      && (BINDING_LEVEL (outer_binding)\n \t\t  == current_binding_level->level_chain))\n \t    /* We have something like:\n-\t       \n+\n \t         int i;\n \t         for (int i; ;);\n-\t\t \n+\n \t       and we are leaving the `for' scope.  There's no reason to\n \t       keep the binding of the inner `i' in this case.  */\n \t    pop_binding (DECL_NAME (link), link);\n-\t  else if ((outer_binding \n-\t\t    && (TREE_CODE (BINDING_VALUE (outer_binding)) \n+\t  else if ((outer_binding\n+\t\t    && (TREE_CODE (BINDING_VALUE (outer_binding))\n \t\t\t== TYPE_DECL))\n-\t\t   || (ns_binding \n+\t\t   || (ns_binding\n \t\t       && TREE_CODE (ns_binding) == TYPE_DECL))\n \t    /* Here, we have something like:\n \n@@ -1297,11 +1301,11 @@ poplevel (keep, reverse, functionbody)\n \t      /* Mark this VAR_DECL as dead so that we can tell we left it\n \t\t there only for backward compatibility.  */\n \t      DECL_DEAD_FOR_LOCAL (link) = 1;\n-\t      \n+\n \t      /* Keep track of what should of have happenned when we\n \t\t popped the binding.  */\n \t      if (outer_binding && BINDING_VALUE (outer_binding))\n-\t\tDECL_SHADOWED_FOR_VAR (link) \n+\t\tDECL_SHADOWED_FOR_VAR (link)\n \t\t  = BINDING_VALUE (outer_binding);\n \n \t      /* Add it to the list of dead variables in the next\n@@ -1318,7 +1322,7 @@ poplevel (keep, reverse, functionbody)\n \t\t= 0;\n \t    }\n \t}\n-      else \n+      else\n \t{\n \t  /* Remove the binding.  */\n \t  decl = link;\n@@ -1328,7 +1332,7 @@ poplevel (keep, reverse, functionbody)\n \t    pop_binding (DECL_NAME (decl), decl);\n \t  else if (TREE_CODE (decl) == OVERLOAD)\n \t    pop_binding (DECL_NAME (OVL_FUNCTION (decl)), decl);\n-\t  else \n+\t  else\n \t    my_friendly_abort (0);\n \t}\n     }\n@@ -1346,7 +1350,7 @@ poplevel (keep, reverse, functionbody)\n \n   /* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */\n   for (link = current_binding_level->shadowed_labels;\n-       link; \n+       link;\n        link = TREE_CHAIN (link))\n     pop_label (link);\n \n@@ -1429,7 +1433,7 @@ poplevel (keep, reverse, functionbody)\n     {\n       tree scope_stmts;\n \n-      scope_stmts \n+      scope_stmts\n \t= add_scope_stmt (/*begin_p=*/0, /*partial_p=*/1);\n       if (block)\n \t{\n@@ -1529,7 +1533,7 @@ poplevel_class ()\n   tree shadowed;\n \n   my_friendly_assert (level != 0, 354);\n-  \n+\n   /* If we're leaving a toplevel class, don't bother to do the setting\n      of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot\n      shouldn't even be used when current_class_type isn't set, and second,\n@@ -1544,26 +1548,26 @@ poplevel_class ()\n \t   shadowed;\n \t   shadowed = TREE_CHAIN (shadowed))\n \tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) = NULL_TREE;\n-\t\n+\n       /* Find the next enclosing class, and recreate\n \t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n       b = level->level_chain;\n       while (b && b->parm_flag != 2)\n \tb = b->level_chain;\n \n       if (b)\n-\tfor (shadowed = b->class_shadowed; \n-\t     shadowed; \n+\tfor (shadowed = b->class_shadowed;\n+\t     shadowed;\n \t     shadowed = TREE_CHAIN (shadowed))\n \t  {\n \t    tree t;\n \n \t    t = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n \t    while (t && BINDING_LEVEL (t) != b)\n \t      t = TREE_CHAIN (t);\n-      \n+\n \t    if (t)\n-\t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) \n+\t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed))\n \t\t= BINDING_VALUE (t);\n \t  }\n     }\n@@ -1580,8 +1584,8 @@ poplevel_class ()\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n \n   /* Remove the bindings for all of the class-level declarations.  */\n-  for (shadowed = level->class_shadowed; \n-       shadowed; \n+  for (shadowed = level->class_shadowed;\n+       shadowed;\n        shadowed = TREE_CHAIN (shadowed))\n     pop_binding (TREE_PURPOSE (shadowed), TREE_TYPE (shadowed));\n \n@@ -1705,7 +1709,7 @@ struct walk_globals_data {\n    for which P returns non-zero, call F with its address.  If any call\n    to F returns a non-zero value, return a non-zero value.  */\n \n-static int \n+static int\n walk_globals_r (namespace, data)\n      tree namespace;\n      void *data;\n@@ -1776,10 +1780,10 @@ wrapup_globals_for_namespace (namespace, data)\n \n   /* Process the decls in reverse order--earliest first.\n      Put them into VEC from back to front, then take out from front.  */\n-  \n+\n   for (i = 0, decl = globals; i < len; i++, decl = TREE_CHAIN (decl))\n     vec[len - i - 1] = decl;\n-  \n+\n   if (last_time)\n     {\n       check_global_declarations (vec, len);\n@@ -1865,7 +1869,7 @@ print_binding_level (lvl)\n       /* We can probably fit 3 names to a line?  */\n       for (t = lvl->names; t; t = TREE_CHAIN (t))\n \t{\n-\t  if (no_print_functions && (TREE_CODE (t) == FUNCTION_DECL)) \n+\t  if (no_print_functions && (TREE_CODE (t) == FUNCTION_DECL))\n \t    continue;\n \t  if (no_print_builtins\n \t      && (TREE_CODE (t) == TYPE_DECL)\n@@ -2004,7 +2008,7 @@ find_binding (name, scope)\n   tree iter, prev = NULL_TREE;\n \n   scope = ORIGINAL_NAMESPACE (scope);\n-  \n+\n   for (iter = IDENTIFIER_NAMESPACE_BINDINGS (name); iter;\n        iter = TREE_CHAIN (iter))\n     {\n@@ -2039,7 +2043,7 @@ binding_for_name (name, scope)\n   tree result;\n \n   scope = ORIGINAL_NAMESPACE (scope);\n-  \n+\n   if (b && TREE_CODE (b) != CPLUS_BINDING)\n     {\n       /* Get rid of optimization for global scope. */\n@@ -2093,7 +2097,7 @@ set_namespace_binding (name, scope, val)\n \n   if (scope == NULL_TREE)\n     scope = global_namespace;\n-  \n+\n   if (scope == global_namespace)\n     {\n       b = IDENTIFIER_NAMESPACE_BINDINGS (name);\n@@ -2158,7 +2162,7 @@ push_namespace (name)\n             }\n         }\n     }\n-  \n+\n   if (need_new)\n     {\n       /* Make a new namespace, binding the name to it. */\n@@ -2216,7 +2220,7 @@ push_nested_namespace (ns)\n \n /* Pop back from the scope of the namespace NS, which was previously\n    entered with push_nested_namespace.  */\n-     \n+\n void\n pop_nested_namespace (ns)\n      tree ns;\n@@ -2293,7 +2297,7 @@ store_bindings (names, old_bindings)\n       else\n \tid = DECL_NAME (t);\n \n-      if (!id \n+      if (!id\n \t  /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n \t     we have no IDENTIFIER_BINDING if we have left the class\n \t     scope, but cached the class-level declarations.  */\n@@ -2433,7 +2437,7 @@ pop_from_top_level ()\n }\n \f\n /* Push a definition of struct, union or enum tag \"name\".\n-   into binding_level \"b\".   \"type\" should be the type node, \n+   into binding_level \"b\".   \"type\" should be the type node,\n    We assume that the tag \"name\" is not already defined.\n \n    Note that the definition may really be just a forward reference.\n@@ -2530,30 +2534,30 @@ pop_everything ()\n    Returns the TYPE_DECL for TYPE, which may have been altered by this\n    processing.  */\n \n-static tree \n+static tree\n maybe_process_template_type_declaration (type, globalize, b)\n      tree type;\n      int globalize;\n      struct binding_level* b;\n {\n   tree decl = TYPE_NAME (type);\n- \n+\n   if (processing_template_parmlist)\n     /* You can't declare a new template type in a template parameter\n        list.  But, you can declare a non-template type:\n-       \n+\n          template <class A*> struct S;\n-       \n+\n        is a forward-declaration of `A'.  */\n     ;\n-  else \n+  else\n     {\n       maybe_check_template_type (type);\n \n-      my_friendly_assert (IS_AGGR_TYPE (type) \n+      my_friendly_assert (IS_AGGR_TYPE (type)\n \t\t\t  || TREE_CODE (type) == ENUMERAL_TYPE, 0);\n-\t\t\t  \n-\t\t\t  \n+\n+\n       if (processing_template_decl)\n \t{\n \t  /* This may change after the call to\n@@ -2576,7 +2580,7 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t      /* Put this tag on the list of tags for the class, since\n \t\t that won't happen below because B is not the class\n \t\t binding level, but is instead the pseudo-global level.  */\n-\t      b->level_chain->tags = \n+\t      b->level_chain->tags =\n \t\ttree_cons (name, type, b->level_chain->tags);\n \t      if (TYPE_SIZE (current_class_type) == NULL_TREE)\n \t\tCLASSTYPE_TAGS (current_class_type) = b->level_chain->tags;\n@@ -2644,7 +2648,7 @@ pushtag (name, type, globalize)\n \n \t      if (! globalize)\n \t\tcontext = cs;\n-\t      else if (cs != NULL_TREE \n+\t      else if (cs != NULL_TREE\n \t\t       && TREE_CODE_CLASS (TREE_CODE (cs)) == 't')\n \t\t/* When declaring a friend class of a local class, we want\n \t\t   to inject the newly named class into the scope\n@@ -2846,7 +2850,7 @@ decls_match (newdecl, olddecl)\n       if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),\n \t\t\t\tDECL_TEMPLATE_PARMS (olddecl)))\n \treturn 0;\n-      \n+\n       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)\n \ttypes_match = 1;\n       else\n@@ -2890,10 +2894,10 @@ warn_extern_redeclared_static (newdecl, olddecl)\n \n   tree name;\n \n-  if (TREE_CODE (newdecl) == TYPE_DECL \n+  if (TREE_CODE (newdecl) == TYPE_DECL\n       || TREE_CODE (newdecl) == TEMPLATE_DECL)\n     return;\n-  \n+\n   /* Don't get confused by static member functions; that's a different\n      use of `static'.  */\n   if (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -2945,7 +2949,7 @@ duplicate_decls (newdecl, olddecl)\n   if (TREE_TYPE (newdecl) == error_mark_node\n       || TREE_TYPE (olddecl) == error_mark_node)\n     types_match = 1;\n- \n+\n   /* Check for redeclaration and other discrepancies. */\n   if (TREE_CODE (olddecl) == FUNCTION_DECL\n       && DECL_ARTIFICIAL (olddecl))\n@@ -3001,7 +3005,7 @@ duplicate_decls (newdecl, olddecl)\n \t    /* Discard the old built-in function.  */\n \t    return 0;\n \t}\n-      \n+\n       if (DECL_THIS_STATIC (newdecl) && !DECL_THIS_STATIC (olddecl))\n \t{\n \t  /* If a builtin function is redeclared as `static', merge\n@@ -3113,14 +3117,14 @@ duplicate_decls (newdecl, olddecl)\n \t  cp_error_at (\"previous declaration as `%#D'\", olddecl);\n \t}\n     }\n-  else if (TREE_CODE (newdecl) == FUNCTION_DECL \n+  else if (TREE_CODE (newdecl) == FUNCTION_DECL\n \t    && ((DECL_TEMPLATE_SPECIALIZATION (olddecl)\n \t\t && (!DECL_TEMPLATE_INFO (newdecl)\n-\t\t     || (DECL_TI_TEMPLATE (newdecl) \n+\t\t     || (DECL_TI_TEMPLATE (newdecl)\n \t\t\t != DECL_TI_TEMPLATE (olddecl))))\n \t\t|| (DECL_TEMPLATE_SPECIALIZATION (newdecl)\n \t\t    && (!DECL_TEMPLATE_INFO (olddecl)\n-\t\t\t|| (DECL_TI_TEMPLATE (olddecl) \n+\t\t\t|| (DECL_TI_TEMPLATE (olddecl)\n \t\t\t    != DECL_TI_TEMPLATE (newdecl))))))\n     /* It's OK to have a template specialization and a non-template\n        with the same type, or to have specializations of two\n@@ -3131,8 +3135,8 @@ duplicate_decls (newdecl, olddecl)\n        specialize one of its methods.  This situation is legal, but\n        the declarations must be merged in the usual way.  */\n     return 0;\n-  else if (TREE_CODE (newdecl) == FUNCTION_DECL \n-\t   && ((DECL_TEMPLATE_INSTANTIATION (olddecl) \n+  else if (TREE_CODE (newdecl) == FUNCTION_DECL\n+\t   && ((DECL_TEMPLATE_INSTANTIATION (olddecl)\n \t\t&& !DECL_USE_TEMPLATE (newdecl))\n \t       || (DECL_TEMPLATE_INSTANTIATION (newdecl)\n \t\t   && !DECL_USE_TEMPLATE (olddecl))))\n@@ -3193,7 +3197,7 @@ duplicate_decls (newdecl, olddecl)\n \n \t  if (TREE_CODE (TREE_TYPE (newdecl)) == METHOD_TYPE)\n \t    t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2);\n-\t\n+\n \t  for (; t1 && t1 != void_list_node;\n \t       t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2), i++)\n \t    if (TREE_PURPOSE (t1) && TREE_PURPOSE (t2))\n@@ -3255,7 +3259,7 @@ duplicate_decls (newdecl, olddecl)\n       DECL_NEEDS_FINAL_OVERRIDER_P (newdecl) |= DECL_NEEDS_FINAL_OVERRIDER_P (olddecl);\n       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);\n       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;\n-      \n+\n       /* Optionally warn about more than one declaration for the same\n          name, but don't warn about a function declaration followed by a\n          definition.  */\n@@ -3288,7 +3292,7 @@ duplicate_decls (newdecl, olddecl)\n \n   /* Copy all the DECL_... slots specified in the new decl\n      except for any that we copy here from the old type.  */\n-  DECL_MACHINE_ATTRIBUTES (newdecl) \n+  DECL_MACHINE_ATTRIBUTES (newdecl)\n     = merge_machine_decl_attributes (olddecl, newdecl);\n \n   if (TREE_CODE (newdecl) == TEMPLATE_DECL)\n@@ -3297,13 +3301,13 @@ duplicate_decls (newdecl, olddecl)\n \t\t\t     DECL_TEMPLATE_RESULT (olddecl)))\n \tcp_error (\"invalid redeclaration of %D\", newdecl);\n       TREE_TYPE (olddecl) = TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl));\n-      DECL_TEMPLATE_SPECIALIZATIONS (olddecl) \n+      DECL_TEMPLATE_SPECIALIZATIONS (olddecl)\n \t= chainon (DECL_TEMPLATE_SPECIALIZATIONS (olddecl),\n \t\t   DECL_TEMPLATE_SPECIALIZATIONS (newdecl));\n- \n+\n       return 1;\n     }\n-    \n+\n   if (types_match)\n     {\n       /* Automatically handles default parameters.  */\n@@ -3415,13 +3419,13 @@ duplicate_decls (newdecl, olddecl)\n   TREE_STATIC (olddecl) = TREE_STATIC (newdecl) |= TREE_STATIC (olddecl);\n   if (! DECL_EXTERNAL (olddecl))\n     DECL_EXTERNAL (newdecl) = 0;\n-  \n+\n   if (DECL_LANG_SPECIFIC (newdecl) && DECL_LANG_SPECIFIC (olddecl))\n     {\n       DECL_INTERFACE_KNOWN (newdecl) |= DECL_INTERFACE_KNOWN (olddecl);\n       DECL_NOT_REALLY_EXTERN (newdecl) |= DECL_NOT_REALLY_EXTERN (olddecl);\n       DECL_COMDAT (newdecl) |= DECL_COMDAT (olddecl);\n-      DECL_TEMPLATE_INSTANTIATED (newdecl) \n+      DECL_TEMPLATE_INSTANTIATED (newdecl)\n \t|= DECL_TEMPLATE_INSTANTIATED (olddecl);\n       /* Don't really know how much of the language-specific\n \t values we should copy from old to new.  */\n@@ -3441,25 +3445,25 @@ duplicate_decls (newdecl, olddecl)\n \n   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n     {\n-      if (DECL_TEMPLATE_INSTANTIATION (olddecl) \n-\t  && !DECL_TEMPLATE_INSTANTIATION (newdecl)) \n+      if (DECL_TEMPLATE_INSTANTIATION (olddecl)\n+\t  && !DECL_TEMPLATE_INSTANTIATION (newdecl))\n \t{\n \t  /* If newdecl is not a specialization, then it is not a\n \t     template-related function at all.  And that means that we\n \t     shoud have exited above, returning 0.  */\n \t  my_friendly_assert (DECL_TEMPLATE_SPECIALIZATION (newdecl),\n \t\t\t      0);\n \n-\t  if (TREE_USED (olddecl)) \n+\t  if (TREE_USED (olddecl))\n \t    /* From [temp.expl.spec]:\n-\t       \n+\n \t       If a template, a member template or the member of a class\n \t       template is explicitly specialized then that\n \t       specialization shall be declared before the first use of\n \t       that specialization that would cause an implicit\n \t       instantiation to take place, in every translation unit in\n \t       which such a use occurs.  */\n-\t    cp_error (\"explicit specialization of %D after first use\", \n+\t    cp_error (\"explicit specialization of %D after first use\",\n \t\t      olddecl);\n \n \t  SET_DECL_TEMPLATE_SPECIALIZATION (olddecl);\n@@ -3545,16 +3549,16 @@ duplicate_decls (newdecl, olddecl)\n \t     the following sequence of events has occurred:\n \n \t     o A friend function was declared in a class template.  The\n-\t     class template was instantiated.  \n+\t     class template was instantiated.\n \n-\t     o The instantiation of the friend declaration was \n-\t     recorded on the instantiation list, and is newdecl.  \n+\t     o The instantiation of the friend declaration was\n+\t     recorded on the instantiation list, and is newdecl.\n \n \t     o Later, however, instantiate_class_template called pushdecl\n \t     on the newdecl to perform name injection.  But, pushdecl in\n \t     turn called duplicate_decls when it discovered that another\n \t     declaration of a global function with the same name already\n-\t     existed. \n+\t     existed.\n \n \t     o Here, in duplicate_decls, we decided to clobber newdecl.\n \n@@ -3563,8 +3567,8 @@ duplicate_decls (newdecl, olddecl)\n \t     instantiations so that if we try to do the instantiation\n \t     again we won't get the clobbered declaration.  */\n \n-\t  tree tmpl = DECL_TI_TEMPLATE (newdecl); \n-\t  tree decls = DECL_TEMPLATE_SPECIALIZATIONS (tmpl); \n+\t  tree tmpl = DECL_TI_TEMPLATE (newdecl);\n+\t  tree decls = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n \n \t  for (; decls; decls = TREE_CHAIN (decls))\n \t    if (TREE_VALUE (decls) == newdecl)\n@@ -3638,7 +3642,7 @@ pushdecl (x)\n       /* If this is the declaration for a namespace-scope function,\n \t but the declaration itself is in a local scope, mark the\n \t declaration.  */\n-      if (TREE_CODE (x) == FUNCTION_DECL \n+      if (TREE_CODE (x) == FUNCTION_DECL\n \t  && DECL_NAMESPACE_SCOPE_P (x)\n \t  && current_function_decl\n \t  && x != current_function_decl)\n@@ -3660,7 +3664,7 @@ pushdecl (x)\n #endif\n       if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n \tname = TREE_OPERAND (name, 0);\n-      \n+\n       /* Namespace-scoped variables are not found in the current level. */\n       if (TREE_CODE (x) == VAR_DECL && DECL_NAMESPACE_SCOPE_P (x))\n \tt = namespace_binding (name, DECL_CONTEXT (x));\n@@ -3749,7 +3753,7 @@ pushdecl (x)\n \t  else if (DECL_MAIN_P (x))\n \t    {\n \t      /* A redeclaration of main, but not a duplicate of the\n-\t\t previous one. \n+\t\t previous one.\n \n \t\t [basic.start.main]\n \n@@ -3807,7 +3811,7 @@ pushdecl (x)\n \t\t   /* We don't want to copy the type when all we're\n \t\t      doing is making a TYPE_DECL for the purposes of\n \t\t      inlining.  */\n-\t\t   && (!TYPE_NAME (type) \n+\t\t   && (!TYPE_NAME (type)\n \t\t       || TYPE_NAME (type) != DECL_ABSTRACT_ORIGIN (x)))\n             {\n \t      DECL_ORIGINAL_TYPE (x) = type;\n@@ -3820,7 +3824,7 @@ pushdecl (x)\n \t  if (type != error_mark_node\n \t      && TYPE_NAME (type)\n \t      && TYPE_IDENTIFIER (type))\n-            set_identifier_type_value_with_scope (DECL_NAME (x), type, \n+            set_identifier_type_value_with_scope (DECL_NAME (x), type,\n \t\t\t\t\t\t  current_binding_level);\n \n \t}\n@@ -3829,7 +3833,7 @@ pushdecl (x)\n \n \t We get warnings about inline functions where they are defined.\n \t We get warnings about other functions from push_overloaded_decl.\n-\t \n+\n \t Avoid duplicate warnings where they are used.  */\n       if (TREE_PUBLIC (x) && TREE_CODE (x) != FUNCTION_DECL)\n \t{\n@@ -3869,11 +3873,11 @@ pushdecl (x)\n \t\t the mangled name (i.e., NAME) to the DECL.  But, for\n \t\t an `extern \"C\"' function, the mangled name and the\n \t\t ordinary name are the same so we need not do this.  */\n-\t      && !(TREE_CODE (x) == FUNCTION_DECL && \n+\t      && !(TREE_CODE (x) == FUNCTION_DECL &&\n \t\t   DECL_LANGUAGE (x) == lang_c))\n \t    {\n \t      if (TREE_CODE (x) == FUNCTION_DECL)\n-\t\tmy_friendly_assert \n+\t\tmy_friendly_assert\n \t\t  ((IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE)\n \t\t  || (IDENTIFIER_GLOBAL_VALUE (name) == x), 378);\n \t      SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n@@ -3919,14 +3923,14 @@ pushdecl (x)\n \n \t  /* If this is a TYPE_DECL, push it into the type value slot.  */\n \t  if (TREE_CODE (x) == TYPE_DECL)\n-\t    set_identifier_type_value_with_scope (name, TREE_TYPE (x), \n+\t    set_identifier_type_value_with_scope (name, TREE_TYPE (x),\n \t\t\t\t\t\t  current_binding_level);\n \n \t  /* Clear out any TYPE_DECL shadowed by a namespace so that\n \t     we won't think this is a type.  The C struct hack doesn't\n \t     go through namespaces.  */\n \t  if (TREE_CODE (x) == NAMESPACE_DECL)\n-\t    set_identifier_type_value_with_scope (name, NULL_TREE, \n+\t    set_identifier_type_value_with_scope (name, NULL_TREE,\n \t\t\t\t\t\t  current_binding_level);\n \n \t  /* If this is an extern function declaration, see if we\n@@ -3983,7 +3987,7 @@ pushdecl (x)\n \t      warning (\"variable `%s' shadows local\",\n \t\t       IDENTIFIER_POINTER (name));\n \t      cp_warning_at (\"  this is the shadowed declaration\", oldlocal);\n-\t    }\t\t   \n+\t    }\n \t  /* Maybe warn if shadowing something else.  */\n \t  else if (warn_shadow && !DECL_EXTERNAL (x)\n \t\t   /* No shadow warnings for internally generated vars.  */\n@@ -4020,12 +4024,12 @@ pushdecl (x)\n \t      /* RTTI TD entries are created while defining the type_info.  */\n \t      || (TYPE_LANG_SPECIFIC (TREE_TYPE (x))\n \t\t  && TYPE_BEING_DEFINED (TREE_TYPE (x)))))\n-\tcurrent_binding_level->incomplete \n+\tcurrent_binding_level->incomplete\n \t  = tree_cons (NULL_TREE, x, current_binding_level->incomplete);\n     }\n \n   if (need_new_binding)\n-    add_decl_to_level (x, \n+    add_decl_to_level (x,\n \t\t       DECL_NAMESPACE_SCOPE_P (x)\n \t\t       ? NAMESPACE_LEVEL (CP_DECL_CONTEXT (x))\n \t\t       : current_binding_level);\n@@ -4165,8 +4169,8 @@ maybe_push_decl (decl)\n   /* Add this decl to the current binding level, but not if it comes\n      from another scope, e.g. a static member variable.  TEM may equal\n      DECL or it may be a previous decl of the same name.  */\n-  if ((TREE_CODE (decl) != PARM_DECL \n-       && DECL_CONTEXT (decl) != NULL_TREE \n+  if ((TREE_CODE (decl) != PARM_DECL\n+       && DECL_CONTEXT (decl) != NULL_TREE\n        /* Definitions of namespace members outside their namespace are\n \t  possible. */\n        && TREE_CODE (DECL_CONTEXT (decl)) != NAMESPACE_DECL)\n@@ -4214,7 +4218,7 @@ push_class_level_binding (name, x)\n      tree x;\n {\n   tree binding;\n-  /* The class_binding_level will be NULL if x is a template \n+  /* The class_binding_level will be NULL if x is a template\n      parameter name in a member template.  */\n   if (!class_binding_level)\n     return;\n@@ -4228,7 +4232,7 @@ push_class_level_binding (name, x)\n      class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n      we leave this class.  Record the shadowed declaration here.  */\n   binding = IDENTIFIER_BINDING (name);\n-  if (binding \n+  if (binding\n       && ((TREE_CODE (x) == OVERLOAD\n \t   && BINDING_VALUE (binding)\n \t   && is_overloaded_fn (BINDING_VALUE (binding)))\n@@ -4295,7 +4299,7 @@ push_using_decl (scope, name)\n      tree name;\n {\n   tree decl;\n-  \n+\n   my_friendly_assert (TREE_CODE (scope) == NAMESPACE_DECL, 383);\n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 384);\n   for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n@@ -4320,7 +4324,7 @@ push_using_directive (used)\n {\n   tree ud = current_binding_level->using_directives;\n   tree iter, ancestor;\n-  \n+\n   /* Check if we already have this. */\n   if (purpose_member (used, ud) != NULL_TREE)\n     return NULL_TREE;\n@@ -4349,7 +4353,7 @@ push_using_directive (used)\n      PUSH_LOCAL: Bind DECL in the current scope, rather than at\n                  namespace scope.\n      PUSH_USING: DECL is being pushed as the result of a using\n-                 declaration. \n+                 declaration.\n \n    The value returned may be a previous declaration if we guessed wrong\n    about what language DECL should belong to (C or C++).  Otherwise,\n@@ -4384,7 +4388,7 @@ push_overloaded_decl (decl, flags)\n       else if (is_overloaded_fn (old))\n         {\n           tree tmp;\n-\t  \n+\n \t  for (tmp = old; tmp; tmp = OVL_NEXT (tmp))\n \t    {\n \t      tree fn = OVL_CURRENT (tmp);\n@@ -4395,7 +4399,7 @@ push_overloaded_decl (decl, flags)\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (decl))))\n \t\tcp_error (\"`%#D' conflicts with previous using declaration `%#D'\",\n \t\t\t  decl, fn);\n-\t      \n+\n \t      if (duplicate_decls (decl, fn))\n \t\treturn fn;\n \t    }\n@@ -4434,7 +4438,7 @@ push_overloaded_decl (decl, flags)\n       if (TREE_CODE (new_binding) == OVERLOAD && old)\n \t{\n \t  tree *d;\n-\t  \n+\n \t  for (d = &BINDING_LEVEL (IDENTIFIER_BINDING (name))->names;\n \t       *d;\n \t       d = &TREE_CHAIN (*d))\n@@ -4447,7 +4451,7 @@ push_overloaded_decl (decl, flags)\n \t\t  TREE_VALUE (*d) = new_binding;\n \t\telse\n \t\t  /* Build a TREE_LIST to wrap the OVERLOAD.  */\n-\t\t  *d = tree_cons (NULL_TREE, new_binding, \n+\t\t  *d = tree_cons (NULL_TREE, new_binding,\n \t\t\t\t  TREE_CHAIN (*d));\n \n \t\t/* And update the CPLUS_BINDING node.  */\n@@ -4633,7 +4637,7 @@ make_label_decl (id, local_p)\n    be found, create one.  (We keep track of used, but undefined,\n    labels, and complain about them at the end of a function.)  */\n \n-tree \n+tree\n lookup_label (id)\n      tree id;\n {\n@@ -4646,7 +4650,7 @@ lookup_label (id)\n \t     IDENTIFIER_POINTER (id));\n       return NULL_TREE;\n     }\n-  \n+\n   /* See if we've already got this label.  */\n   decl = IDENTIFIER_LABEL_VALUE (id);\n   if (decl != NULL_TREE && DECL_CONTEXT (decl) == current_function_decl)\n@@ -4676,14 +4680,14 @@ declare_local_label (id)\n   /* Add a new entry to the SHADOWED_LABELS list so that when we leave\n      this scope we can restore the old value of\n      IDENTIFIER_TYPE_VALUE.  */\n-  current_binding_level->shadowed_labels \n+  current_binding_level->shadowed_labels\n     = tree_cons (IDENTIFIER_LABEL_VALUE (id), NULL_TREE,\n \t\t current_binding_level->shadowed_labels);\n   /* Look for the label.  */\n   decl = make_label_decl (id, /*local_p=*/1);\n   /* Now fill in the information we didn't have before.  */\n   TREE_VALUE (current_binding_level->shadowed_labels) = decl;\n-  \n+\n   return decl;\n }\n \n@@ -4853,7 +4857,7 @@ define_case_label ()\n   if (! switch_stack)\n     /* Don't crash; we'll complain in do_case.  */\n     return;\n-  \n+\n   if (cleanup)\n     {\n       static int explained = 0;\n@@ -4982,10 +4986,10 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t       declaration, then we use the _TYPE node for the\n \t       template.  See the example below.  */\n \t    if (thislevel_only && !allow_pseudo_global\n-\t\t&& old && BINDING_VALUE (old) \n+\t\t&& old && BINDING_VALUE (old)\n \t\t&& DECL_CLASS_TEMPLATE_P (BINDING_VALUE (old)))\n \t      old = TREE_TYPE (BINDING_VALUE (old));\n-\t    else \n+\t    else\n \t      old = BINDING_TYPE (old);\n \n \t    /* If it has an original type, it is a typedef, and we\n@@ -5027,10 +5031,10 @@ lookup_tag (form, name, binding_level, thislevel_only)\n \t  if (level->pseudo_global && allow_pseudo_global)\n \t    {\n \t      /* We must deal with cases like this:\n-\t\t \n+\n \t           template <class T> struct S;\n \t\t   template <class T> struct S {};\n-\t\t   \n+\n \t\t When looking up `S', for the second declaration, we\n \t\t would like to find the first declaration.  But, we\n \t\t are in the pseudo-global level created for the\n@@ -5121,7 +5125,7 @@ lookup_namespace_name (namespace, name)\n     }\n \n   my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n-  \n+\n   val = make_node (CPLUS_BINDING);\n   if (!qualified_lookup_using_namespace (name, namespace, val, 0))\n     return error_mark_node;\n@@ -5133,14 +5137,14 @@ lookup_namespace_name (namespace, name)\n       if (template_id)\n \t{\n \t  if (DECL_CLASS_TEMPLATE_P (val))\n-\t    val = lookup_template_class (val, \n+\t    val = lookup_template_class (val,\n \t\t\t\t\t TREE_OPERAND (template_id, 1),\n \t\t\t\t\t /*in_decl=*/NULL_TREE,\n \t\t\t\t\t /*context=*/NULL_TREE,\n \t\t\t\t\t /*entering_scope=*/0);\n \t  else if (DECL_FUNCTION_TEMPLATE_P (val)\n \t\t   || TREE_CODE (val) == OVERLOAD)\n-\t    val = lookup_template_function (val, \n+\t    val = lookup_template_function (val,\n \t\t\t\t\t    TREE_OPERAND (template_id, 1));\n \t  else\n \t    {\n@@ -5192,10 +5196,10 @@ typename_compare (k1, k2)\n   t2 = (tree) k2;\n   d1 = TYPE_NAME (t1);\n   d2 = TYPE_NAME (t2);\n-  \n+\n   return (DECL_NAME (d1) == DECL_NAME (d2)\n \t  && same_type_p (TYPE_CONTEXT (t1), TYPE_CONTEXT (t2))\n-\t  && ((TREE_TYPE (t1) != NULL_TREE) \n+\t  && ((TREE_TYPE (t1) != NULL_TREE)\n \t      == (TREE_TYPE (t2) != NULL_TREE))\n \t  && same_type_p (TREE_TYPE (t1), TREE_TYPE (t2))\n \t  && TYPENAME_TYPE_FULLNAME (t1) == TYPENAME_TYPE_FULLNAME (t2));\n@@ -5205,7 +5209,7 @@ typename_compare (k1, k2)\n    the type of `T', NAME is the IDENTIFIER_NODE for `t'.  If BASE_TYPE\n    is non-NULL, this type is being created by the implicit typename\n    extension, and BASE_TYPE is a type named `t' in some base class of\n-   `T' which depends on template parameters.  \n+   `T' which depends on template parameters.\n \n    Returns the new TYPENAME_TYPE.  */\n \n@@ -5225,7 +5229,7 @@ build_typename_type (context, name, fullname, base_type)\n   if (!ht.table)\n     {\n       static struct hash_table *h = &ht;\n-      if (!hash_table_init (&ht, &hash_newfunc, &typename_hash, \n+      if (!hash_table_init (&ht, &hash_newfunc, &typename_hash,\n \t\t\t    &typename_compare))\n \tfatal (\"virtual memory exhausted\");\n       ggc_add_tree_hash_table_root (&h, 1);\n@@ -5268,8 +5272,8 @@ make_typename_type (context, name, complain)\n \n   if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n     {\n-      if (!(TYPE_LANG_SPECIFIC (name) \n-\t    && (CLASSTYPE_IS_TEMPLATE (name) \n+      if (!(TYPE_LANG_SPECIFIC (name)\n+\t    && (CLASSTYPE_IS_TEMPLATE (name)\n \t\t|| CLASSTYPE_USE_TEMPLATE (name))))\n \tname = TYPE_IDENTIFIER (name);\n       else\n@@ -5318,15 +5322,15 @@ make_typename_type (context, name, complain)\n \t      return error_mark_node;\n \t    }\n \n-\t  return lookup_template_class (tmpl, \n+\t  return lookup_template_class (tmpl,\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n-\t\t\t\t\tNULL_TREE, context, \n+\t\t\t\t\tNULL_TREE, context,\n \t\t\t\t\t/*entering_scope=*/0);\n \t}\n       else\n \t{\n           tree t;\n-          \n+\n \t  if (!IS_AGGR_TYPE (context))\n \t    {\n \t      if (complain)\n@@ -5348,8 +5352,8 @@ make_typename_type (context, name, complain)\n \tcp_error (\"no type named `%#T' in `%#T'\", name, context);\n       return error_mark_node;\n     }\n-    \n-  \n+\n+\n   return build_typename_type (context, name, fullname,  NULL_TREE);\n }\n \n@@ -5369,7 +5373,7 @@ select_decl (binding, flags)\n         return val;\n       return NULL_TREE;\n     }\n-  \n+\n   /* If we could have a type and\n      we have nothing or we need a type and have none.  */\n   if (BINDING_TYPE (binding)\n@@ -5416,7 +5420,7 @@ unqualified_namespace_lookup (name, flags, spacesp)\n       BINDING_TYPE (b) = BINDING_TYPE (val);\n \n       /* Add all _DECLs seen through local using-directives. */\n-      for (level = current_binding_level; \n+      for (level = current_binding_level;\n \t   !level->namespace_p;\n \t   level = level->level_chain)\n \tif (!lookup_using_namespace (name, b, level->using_directives,\n@@ -5429,7 +5433,7 @@ unqualified_namespace_lookup (name, flags, spacesp)\n       siter = initial;\n       while (1)\n \t{\n-\t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter), \n+\t  if (!lookup_using_namespace (name, b, DECL_NAMESPACE_USING (siter),\n \t\t\t\t       scope, flags, spacesp))\n \t    /* Give up because of error. */\n \t    return error_mark_node;\n@@ -5498,7 +5502,7 @@ warn_about_implicit_typename_lookup (typename, binding)\n       && ! (TREE_CODE (binding) == TYPE_DECL\n \t    && same_type_p (TREE_TYPE (binding), subtype)))\n     {\n-      cp_warning (\"lookup of `%D' finds `%#D'\", \n+      cp_warning (\"lookup of `%D' finds `%#D'\",\n \t\t  name, binding);\n       cp_warning (\"  instead of `%D' from dependent base class\",\n \t\t  typename);\n@@ -5516,7 +5520,7 @@ warn_about_implicit_typename_lookup (typename, binding)\n    If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n    If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n    If PREFER_TYPE is -2, we're being called from yylex(). (UGLY)\n-   Otherwise we prefer non-TYPE_DECLs.  \n+   Otherwise we prefer non-TYPE_DECLs.\n \n    If NONCLASS is non-zero, we don't look for the NAME in class scope,\n    using IDENTIFIER_CLASS_VALUE.  */\n@@ -5558,7 +5562,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \ttype = got_scope;\n       else if (got_object != error_mark_node)\n \ttype = got_object;\n-      \n+\n       if (type)\n \t{\n \t  if (type == error_mark_node)\n@@ -5617,11 +5621,11 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n       if (!LOCAL_BINDING_P (t) && nonclass)\n \t/* We're not looking for class-scoped bindings, so keep going.  */\n \tcontinue;\n-      \n+\n       /* If this is the kind of thing we're looking for, we're done.  */\n       if (qualify_lookup (BINDING_VALUE (t), flags))\n \tbinding = BINDING_VALUE (t);\n-      else if ((flags & LOOKUP_PREFER_TYPES) \n+      else if ((flags & LOOKUP_PREFER_TYPES)\n \t       && qualify_lookup (BINDING_TYPE (t), flags))\n \tbinding = BINDING_TYPE (t);\n       else\n@@ -5633,7 +5637,7 @@ lookup_name_real (name, prefer_type, nonclass, namespaces_only)\n \t  if (val_is_implicit_typename && !yylex)\n \t    warn_about_implicit_typename_lookup (val, binding);\n \t  val = binding;\n-\t  val_is_implicit_typename \n+\t  val_is_implicit_typename\n \t    = IMPLICIT_TYPENAME_TYPE_DECL_P (val);\n \t  if (!val_is_implicit_typename)\n \t    break;\n@@ -5738,14 +5742,14 @@ lookup_name_current_level (name)\n       if (t != NULL_TREE && TREE_CODE (t) == TREE_LIST)\n \tt = TREE_VALUE (t);\n     }\n-  else if (IDENTIFIER_BINDING (name) \n+  else if (IDENTIFIER_BINDING (name)\n \t   && LOCAL_BINDING_P (IDENTIFIER_BINDING (name)))\n     {\n       while (1)\n \t{\n \t  if (BINDING_LEVEL (IDENTIFIER_BINDING (name)) == b)\n \t    return IDENTIFIER_VALUE (name);\n-\t  \n+\n \t  if (b->keep == 2)\n \t    b = b->level_chain;\n \t  else\n@@ -5843,7 +5847,7 @@ record_builtin_type (rid_index, name, type)\n     tname = get_identifier (name);\n \n   TYPE_BUILT_IN (type) = 1;\n-  \n+\n   if (tname)\n     {\n       tdecl = pushdecl (build_decl (TYPE_DECL, tname, type));\n@@ -5917,7 +5921,7 @@ record_unknown_type (type, name)\n   TYPE_SIZE (type) = TYPE_SIZE (void_type_node);\n   TYPE_ALIGN (type) = 1;\n   TYPE_MODE (type) = TYPE_MODE (void_type_node);\n-} \n+}\n \n /* Push overloaded decl, in global scope, with one argument so it\n    can be used as a callback from define_function.  */\n@@ -6070,11 +6074,11 @@ init_decl_processing ()\n \n   /* Create the widest literal types. */\n   widest_integer_literal_type_node = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n \t\t\twidest_integer_literal_type_node));\n \n   widest_unsigned_literal_type_node = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  pushdecl (build_decl (TYPE_DECL, NULL_TREE, \n+  pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n \t\t\twidest_unsigned_literal_type_node));\n \n   /* These are types that type_for_size and type_for_mode use.  */\n@@ -6145,7 +6149,7 @@ init_decl_processing ()\n \n   string_type_node = build_pointer_type (char_type_node);\n   const_string_type_node\n-    = build_pointer_type (build_qualified_type (char_type_node, \n+    = build_pointer_type (build_qualified_type (char_type_node,\n \t\t\t\t\t\tTYPE_QUAL_CONST));\n   empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);\n #if 0\n@@ -6273,7 +6277,7 @@ init_decl_processing ()\n   layout_type (vtbl_ptr_type_node);\n   record_builtin_type (RID_MAX, NULL_PTR, vtbl_ptr_type_node);\n \n-  std_node = build_decl (NAMESPACE_DECL, \n+  std_node = build_decl (NAMESPACE_DECL,\n \t\t\t get_identifier (flag_honor_std ? \"fake std\":\"std\"),\n \t\t\t void_type_node);\n   pushdecl (std_node);\n@@ -6414,7 +6418,7 @@ define_function (name, type, pfn, library_name)\n }\n \n \n-/* Wrapper around define_function, for the benefit of \n+/* Wrapper around define_function, for the benefit of\n    c_common_nodes_and_builtins.\n    FUNCTION_CODE tells later passes how to compile calls to this function.\n    See tree.h for its possible values.  */\n@@ -6664,7 +6668,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \n   decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,\n \t\t\t attrlist);\n-\t\t\t \n+\n   if (decl == NULL_TREE || TREE_CODE (decl) == VOID_TYPE)\n     return NULL_TREE;\n \n@@ -6735,7 +6739,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n #ifdef SET_DEFAULT_DECL_ATTRIBUTES\n   SET_DEFAULT_DECL_ATTRIBUTES (decl, attributes);\n #endif\n-  \n+\n   /* Set attributes here so if duplicate decl, will have proper attributes.  */\n   cplus_decl_attributes (decl, attributes, prefix_attributes);\n \n@@ -6777,7 +6781,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n \n       /* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */\n       DECL_IN_AGGR_P (decl) = 0;\n-      if ((DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl)) \n+      if ((DECL_LANG_SPECIFIC (decl) && DECL_USE_TEMPLATE (decl))\n \t  || CLASSTYPE_USE_TEMPLATE (context))\n \t{\n \t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n@@ -6810,7 +6814,7 @@ start_decl (declarator, declspecs, initialized, attributes, prefix_attributes)\n      data segment.  */\n   DECL_COMMON (tem) = flag_conserve_space || ! TREE_PUBLIC (tem);\n #endif\n-  \n+\n   if (! processing_template_decl)\n     start_decl_1 (tem);\n \n@@ -6936,7 +6940,7 @@ grok_reference_init (decl, type, init)\n       /* Note: default conversion is only called in very special cases.  */\n       init = default_conversion (init);\n     }\n-  \n+\n   /* Convert INIT to the reference type TYPE.  This may involve the\n      creation of a temporary, whose lifetime must be the same as that\n      of the reference.  If so, a DECL_STMT for the temporary will be\n@@ -7067,7 +7071,7 @@ layout_var_decl (decl)\n   /* If we haven't already layed out this declaration, do so now.\n      Note that we must not call complete type for an external object\n      because it's type might involve templates that we are not\n-     supposed to isntantiate yet.  (And it's perfectly legal to say \n+     supposed to isntantiate yet.  (And it's perfectly legal to say\n      `extern X x' for some incomplete type `X'.)  */\n   if (!DECL_EXTERNAL (decl))\n     complete_type (type);\n@@ -7306,7 +7310,7 @@ check_initializer (decl, init)\n     }\n   else\n     check_for_uninitialized_const_var (decl);\n-  \n+\n   return init;\n }\n \n@@ -7419,7 +7423,7 @@ maybe_inject_for_scope_var (decl)\n {\n   if (current_binding_level->is_for_scope)\n     {\n-      struct binding_level *outer \n+      struct binding_level *outer\n \t= current_binding_level->level_chain;\n \n       /* Check to see if the same name is already bound at the outer\n@@ -7431,11 +7435,11 @@ maybe_inject_for_scope_var (decl)\n \t Otherwise, we need to preserve the temp slot for decl to last\n \t into the outer binding level.  */\n \n-      tree outer_binding \n+      tree outer_binding\n \t= TREE_CHAIN (IDENTIFIER_BINDING (DECL_NAME (decl)));\n-\t      \n+\n       if (outer_binding && BINDING_LEVEL (outer_binding) == outer\n-\t  && (TREE_CODE (BINDING_VALUE (outer_binding)) \n+\t  && (TREE_CODE (BINDING_VALUE (outer_binding))\n \t      == VAR_DECL)\n \t  && DECL_DEAD_FOR_LOCAL (BINDING_VALUE (outer_binding)))\n \t{\n@@ -7482,7 +7486,7 @@ initialize_local_var (decl, init, flags)\n   if (DECL_SIZE (decl) && type != error_mark_node)\n     {\n       int already_used;\n-  \n+\n       /* Compute and store the initial value.  */\n       already_used = TREE_USED (decl) || TREE_USED (type);\n \n@@ -7506,7 +7510,7 @@ initialize_local_var (decl, init, flags)\n \t marked used. (see TREE_USED, above.)  */\n       if (TYPE_NEEDS_CONSTRUCTING (type)\n \t  && ! already_used\n-\t  && !TYPE_NEEDS_DESTRUCTOR (type) \n+\t  && !TYPE_NEEDS_DESTRUCTOR (type)\n \t  && DECL_NAME (decl))\n \tTREE_USED (decl) = 0;\n       else if (already_used)\n@@ -7516,7 +7520,7 @@ initialize_local_var (decl, init, flags)\n \n /* Generate code to destroy DECL (a local variable).  */\n \n-static void \n+static void\n destroy_local_var (decl)\n      tree decl;\n {\n@@ -7526,7 +7530,7 @@ destroy_local_var (decl)\n   /* Only variables get cleaned up.  */\n   if (TREE_CODE (decl) != VAR_DECL)\n     return;\n-  \n+\n   /* And only things with destructors need cleaning up.  */\n   if (!TYPE_NEEDS_DESTRUCTOR (type))\n     return;\n@@ -7537,7 +7541,7 @@ destroy_local_var (decl)\n        translation unit, or that need a static cleanup.  The latter\n        are handled by finish_file.  */\n     return;\n-  \n+\n   /* Compute the cleanup.  */\n   cleanup = maybe_build_cleanup (decl);\n \n@@ -7557,14 +7561,14 @@ emit_local_var (decl)\n   if (DECL_RTL (decl))\n     /* Only a RESULT_DECL should have non-NULL RTL when arriving here.\n        All other local variables are assigned RTL in this function.  */\n-    my_friendly_assert (TREE_CODE (decl) == RESULT_DECL, \n+    my_friendly_assert (TREE_CODE (decl) == RESULT_DECL,\n \t\t\t19990828);\n   else\n     {\n       if (DECL_ASSEMBLER_NAME (decl) != DECL_NAME (decl))\n \t/* The user must have specified an assembler name for this\n \t   variable.  Set that up now.  */\n-\trest_of_decl_compilation \n+\trest_of_decl_compilation\n \t  (decl, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n \t   /*top_level=*/0, /*at_end=*/0);\n       else\n@@ -7619,7 +7623,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n   /* Handling __FUNCTION__ and its ilk in a template-function requires\n      some special processing because we are called from\n      language-independent code.  */\n-  if (cfun && processing_template_decl \n+  if (cfun && processing_template_decl\n       && current_function_name_declared == 2)\n     {\n       /* Since we're in a template function, we need to\n@@ -7628,7 +7632,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       retrofit_lang_decl (decl);\n       decl = push_template_decl (decl);\n \n-      if (strcmp (IDENTIFIER_POINTER (DECL_NAME (decl)), \n+      if (strcmp (IDENTIFIER_POINTER (DECL_NAME (decl)),\n \t\t  \"__PRETTY_FUNCTION__\") == 0)\n \t{\n \t  init = build (FUNCTION_NAME, const_string_type_node);\n@@ -7653,7 +7657,7 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n       && (DECL_INITIAL (decl) || init))\n     DECL_DEFINED_IN_CLASS_P (decl) = 1;\n \n-  if (TREE_CODE (decl) == VAR_DECL \n+  if (TREE_CODE (decl) == VAR_DECL\n       && DECL_CONTEXT (decl)\n       && TREE_CODE (DECL_CONTEXT (decl)) == NAMESPACE_DECL\n       && DECL_CONTEXT (decl) != current_namespace\n@@ -7759,11 +7763,11 @@ cp_finish_decl (decl, init, asmspec_tree, flags)\n \n       make_rtl_for_nonlocal_decl (decl, init, asmspec);\n \n-      if (TREE_CODE (type) == FUNCTION_TYPE \n+      if (TREE_CODE (type) == FUNCTION_TYPE\n \t  || TREE_CODE (type) == METHOD_TYPE)\n-\tabstract_virtuals_error (decl, \n+\tabstract_virtuals_error (decl,\n \t\t\t\t strip_array_types (TREE_TYPE (type)));\n-      else \n+      else\n \tabstract_virtuals_error (decl, strip_array_types (type));\n \n       if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -7913,7 +7917,7 @@ get_atexit_node ()\n \n \t We build up the argument types and then then function type\n \t itself.  */\n-      \n+\n       /* First, build the pointer-to-function type for the first\n \t argument.  */\n       arg_types = tree_cons (NULL_TREE, ptr_type_node, void_list_node);\n@@ -7931,7 +7935,7 @@ get_atexit_node ()\n   else\n     {\n       /* The declaration for `atexit' is:\n-\t  \n+\n            int atexit (void (*)());\n \n \t We build up the argument types and then then function type\n@@ -8127,7 +8131,7 @@ expand_static_init (decl, init)\n \t initialization is complete.  This ensures that an exception,\n \t thrown during the construction, will cause the variable to\n \t reinitialized when we pass through this code again, as per:\n-\t \n+\n \t   [stmt.dcl]\n \n \t   If the initialization exits by throwing an exception, the\n@@ -8143,7 +8147,7 @@ expand_static_init (decl, init)\n       /* Begin the conditional initialization.  */\n       if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (build_binary_op (EQ_EXPR, temp,\n-\t\t\t\t\t    integer_zero_node), \n+\t\t\t\t\t    integer_zero_node),\n \t\t\t   if_stmt);\n       then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n@@ -8170,7 +8174,7 @@ expand_static_init (decl, init)\n       if (assignment)\n \t{\n \t  assignment = tree_cons (NULL_TREE, assignment,\n-\t\t\t\t  build_tree_list (NULL_TREE, \n+\t\t\t\t  build_tree_list (NULL_TREE,\n \t\t\t\t\t\t   temp_init));\n \t  assignment = build_compound_expr (assignment);\n \t}\n@@ -8232,7 +8236,7 @@ complete_array_type (type, initial_value, do_default)\n {\n   register tree maxindex = NULL_TREE;\n   int value = 0;\n-  \n+\n   if (initial_value)\n     {\n       /* Note MAXINDEX  is really the maximum index,\n@@ -8358,7 +8362,7 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    or `volatile'.\n    RAISES is a list of exceptions that this function can raise.\n    CHECK is 1 if we must find this method in CTYPE, 0 if we should\n-   not look, and -1 if we should not call `grokclassfn' at all.  \n+   not look, and -1 if we should not call `grokclassfn' at all.\n \n    Returns `NULL_TREE' if something goes wrong, after issuing\n    applicable error messages.  */\n@@ -8511,7 +8515,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t    {\n \t      /* Something like `template <class T> friend void f<T>()'.  */\n-\t      cp_error (\"template-id `%D' in declaration of primary template\", \n+\t      cp_error (\"template-id `%D' in declaration of primary template\",\n \t\t\torig_declarator);\n \t      return NULL_TREE;\n \t    }\n@@ -8534,7 +8538,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n \t  if (inlinep)\n \t    {\n-\t      cp_error (\"`inline' is not allowed in declaration of friend template specialization `%D'\", \n+\t      cp_error (\"`inline' is not allowed in declaration of friend template specialization `%D'\",\n \t\t\tdecl);\n \t      return NULL_TREE;\n \t    }\n@@ -8572,8 +8576,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       grokclassfn (ctype, decl, flags, quals);\n \n       decl = check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t\t    template_count, \n-\t\t\t\t\t    2 * (funcdef_flag != 0) + \n+\t\t\t\t\t    template_count,\n+\t\t\t\t\t    2 * (funcdef_flag != 0) +\n \t\t\t\t\t    4 * (friendp != 0));\n       if (decl == error_mark_node)\n \treturn NULL_TREE;\n@@ -8605,8 +8609,8 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \tgrokclassfn (ctype, decl, flags, quals);\n \n       decl = check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t\t    template_count, \n-\t\t\t\t\t    2 * (funcdef_flag != 0) + \n+\t\t\t\t\t    template_count,\n+\t\t\t\t\t    2 * (funcdef_flag != 0) +\n \t\t\t\t\t    4 * (friendp != 0));\n       if (decl == error_mark_node)\n \treturn NULL_TREE;\n@@ -8619,7 +8623,7 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n \t  if (tmp && TREE_CODE (tmp) == TEMPLATE_DECL)\n \t    tmp = DECL_TEMPLATE_RESULT (tmp);\n-\t      \n+\n \t  if (tmp && DECL_STATIC_FUNCTION_P (tmp)\n \t      && TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n \t    {\n@@ -8691,7 +8695,7 @@ grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n       else\n \tcontext = NULL_TREE;\n \n-      if (processing_template_decl) \n+      if (processing_template_decl)\n \t/* If we're in a template, we need DECL_LANG_SPECIFIC so that\n \t   we can call push_template_decl.  */\n \tdecl = build_lang_decl (VAR_DECL, declarator, type);\n@@ -8781,7 +8785,7 @@ build_ptrmemfunc_type (type)\n   /* Make sure that we always have the unqualified pointer-to-member\n      type first.  */\n   if (CP_TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n-    unqualified_variant \n+    unqualified_variant\n       = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));\n \n   u = make_aggr_type (UNION_TYPE);\n@@ -8850,7 +8854,7 @@ check_static_variable_definition (decl, type)\n      required.  */\n   if (CLASS_TYPE_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      cp_error (\"in-class initialization of static data member of non-integral type `%T'\", \n+      cp_error (\"in-class initialization of static data member of non-integral type `%T'\",\n \t\ttype);\n       /* If we just return the declaration, crashes will sometimes\n \t occur.  We therefore return void_type_node, as if this was a\n@@ -8941,7 +8945,7 @@ compute_array_index_type (name, size)\n \t  size = integer_one_node;\n \t}\n       /* Except that an extension we allow zero-sized arrays.  We\n-\t always allow them in system headers because glibc uses \n+\t always allow them in system headers because glibc uses\n \t them.  */\n       else if (integer_zerop (size) && pedantic && !in_system_header)\n \t{\n@@ -8959,7 +8963,7 @@ compute_array_index_type (name, size)\n \t\t\t     cp_convert (ssizetype, size),\n \t\t\t     cp_convert (ssizetype,\n \t\t\t\t\t integer_one_node)));\n-  \n+\n   /* Check for variable-sized arrays.  We allow such things as an\n      extension, even though they are not allowed in ANSI/ISO C++.  */\n   if (!TREE_CONSTANT (itype))\n@@ -8984,7 +8988,7 @@ compute_array_index_type (name, size)\n       error (\"overflow in array dimension\");\n       TREE_OVERFLOW (itype) = 0;\n     }\n-  \n+\n   /* Create and return the appropriate index type.  */\n   return build_index_type (itype);\n }\n@@ -9048,7 +9052,7 @@ create_array_type_for_decl (name, type, size)\n     }\n \n   /* [dcl.array]\n-     \n+\n      The constant expressions that specify the bounds of the arrays\n      can be omitted only for the first member of the sequence.  */\n   if (TREE_CODE (type) == ARRAY_TYPE && !TYPE_DOMAIN (type))\n@@ -9320,7 +9324,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \t    ctype = NULL_TREE;\n \t    break;\n-\t    \n+\n \t  case TEMPLATE_ID_EXPR:\n \t      {\n \t\ttree fns = TREE_OPERAND (decl, 0);\n@@ -9513,7 +9517,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   if (name == NULL)\n     name = decl_context == PARM ? \"parameter\" : \"type name\";\n-  \n+\n   /* Look through the decl specs and record which ones appear.\n      Some typespecs are defined as built-in typenames.\n      Others, the ones that are modifiers of other types,\n@@ -9716,7 +9720,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       && TYPE_MAIN_VARIANT (type) == double_type_node)\n     {\n       RIDBIT_RESET (RID_LONG, specbits);\n-      type = build_qualified_type (long_double_type_node, \n+      type = build_qualified_type (long_double_type_node,\n \t\t\t\t   CP_TYPE_QUALS (type));\n     }\n \n@@ -9785,15 +9789,15 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t It is implementation-defined whether a plain (neither\n \t explicitly signed or unsigned) char, short, int, or long\n \t bit-field is signed or unsigned.\n-\t     \n+\n \t Naturally, we extend this to long long as well.  Note that\n \t this does not include wchar_t.  */\n       || (bitfield && !flag_signed_bitfields\n \t  && RIDBIT_NOTSETP (RID_SIGNED, specbits)\n \t  /* A typedef for plain `int' without `signed' can be\n \t     controlled just like plain `int', but a typedef for\n \t     `signed int' cannot be so controlled.  */\n-\t  && !(typedef_decl \n+\t  && !(typedef_decl\n \t       && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl))\n \t  && (TREE_CODE (type) == INTEGER_TYPE\n \t      || TREE_CODE (type) == CHAR_TYPE)\n@@ -9847,7 +9851,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \ttype = build_complex_type (type);\n     }\n \n-  if (return_type == return_conversion \n+  if (return_type == return_conversion\n       && (RIDBIT_SETP (RID_CONST, specbits)\n \t  || RIDBIT_SETP (RID_VOLATILE, specbits)\n \t  || RIDBIT_SETP (RID_RESTRICT, specbits)))\n@@ -9859,9 +9863,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      Likewise for VOLATILEP.  */\n \n   constp = !! RIDBIT_SETP (RID_CONST, specbits) + CP_TYPE_CONST_P (type);\n-  restrictp = \n+  restrictp =\n     !! RIDBIT_SETP (RID_RESTRICT, specbits) + CP_TYPE_RESTRICT_P (type);\n-  volatilep = \n+  volatilep =\n     !! RIDBIT_SETP (RID_VOLATILE, specbits) + CP_TYPE_VOLATILE_P (type);\n   type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n \t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n@@ -9946,7 +9950,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t      if (declarator)\n \t\t{\n-\t\t  /* Avoid trying to get an operand off an identifier node.  */ \n+\t\t  /* Avoid trying to get an operand off an identifier node.  */\n \t\t  if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n \t\t    tmp = declarator;\n \t\t  else\n@@ -9998,7 +10002,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      the declared identifier (or NULL_TREE, in an absolute declarator).  */\n \n   inner_attrs = NULL_TREE;\n-  ignore_attrs = 0;  \n+  ignore_attrs = 0;\n \n   while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE\n \t && TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n@@ -10121,7 +10125,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    if (inner_decl && TREE_CODE (inner_decl) == SCOPE_REF)\n \t      inner_decl = TREE_OPERAND (inner_decl, 1);\n \n-\t    if (inner_decl && TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR) \n+\t    if (inner_decl && TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR)\n \t      inner_decl = dname;\n \n \t    /* Pick up type qualifiers which should be applied to `this'.  */\n@@ -10133,11 +10137,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* Say it's a definition only for the CALL_EXPR\n \t       closest to the identifier.  */\n \t    funcdecl_p\n-\t      = inner_decl \n+\t      = inner_decl\n \t      && (TREE_CODE (inner_decl) == IDENTIFIER_NODE\n-\t\t  || TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR \n+\t\t  || TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR\n \t\t  || TREE_CODE (inner_decl) == BIT_NOT_EXPR);\n-\t    \n+\n \t    if (ctype == NULL_TREE\n \t\t&& decl_context == FIELD\n \t\t&& funcdecl_p\n@@ -10250,7 +10254,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t   want the underlying IDENTIFIER.  */\n \t\tif (TREE_CODE (declarator) == BIT_NOT_EXPR)\n \t\t  declarator = TREE_OPERAND (declarator, 0);\n-\t\t\n+\n \t\tif (strict_prototype == 0 && arg_types == NULL_TREE)\n \t\t  arg_types = void_list_node;\n \t\telse if (arg_types == NULL_TREE\n@@ -10437,7 +10441,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    ctype = TREE_OPERAND (declarator, 0);\n \n \t    t = ctype;\n-\t    while (t != NULL_TREE && CLASS_TYPE_P (t)) \n+\t    while (t != NULL_TREE && CLASS_TYPE_P (t))\n \t      {\n \t\tif (CLASSTYPE_TEMPLATE_INFO (t) &&\n \t\t    !CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n@@ -10673,10 +10677,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t     type is a (non-primary) template.  The name for the\n \t     template needs updating as well.  */\n \t  if (TYPE_LANG_SPECIFIC (type) && CLASSTYPE_TEMPLATE_INFO (type))\n-\t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)) \n+\t    DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))\n \t      = TYPE_IDENTIFIER (type);\n \n-\t  /* XXX Temporarily set the scope. \n+\t  /* XXX Temporarily set the scope.\n \t     When returning, start_decl expects it as NULL_TREE,\n \t     and will then then set it using pushdecl. */\n \t  my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 980404);\n@@ -10845,7 +10849,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  return NULL_TREE;\n \t}\n     }\n-  \n+\n   {\n     register tree decl;\n \n@@ -10930,11 +10934,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n-\t    function_context = (ctype != NULL_TREE) ? \n+\t    function_context = (ctype != NULL_TREE) ?\n \t      hack_decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;\n \t    publicp = (! friendp || ! staticp)\n \t      && function_context == NULL_TREE;\n-\t    decl = grokfndecl (ctype, type, \n+\t    decl = grokfndecl (ctype, type,\n \t\t\t       TREE_CODE (declarator) != TEMPLATE_ID_EXPR\n \t\t\t       ? declarator : dname,\n \t\t\t       declarator,\n@@ -10966,16 +10970,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t   We don't look at the first parameter, which is\n \t\t   really just the `this' parameter for the new\n \t\t   object.  */\n-\t\ttree arg_types = \n+\t\ttree arg_types =\n \t\t  TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (decl)));\n \n \t\t/* Skip the `in_chrg' argument too, if present.  */\n \t\tif (TYPE_USES_VIRTUAL_BASECLASSES (DECL_CONTEXT (decl)))\n \t\t  arg_types = TREE_CHAIN (arg_types);\n \n \t\tif (arg_types == void_list_node\n-\t\t    || (arg_types \n-\t\t\t&& TREE_CHAIN (arg_types) \n+\t\t    || (arg_types\n+\t\t\t&& TREE_CHAIN (arg_types)\n \t\t\t&& TREE_CHAIN (arg_types) != void_list_node\n \t\t\t&& !TREE_PURPOSE (TREE_CHAIN (arg_types))))\n \t\t  DECL_NONCONVERTING_P (decl) = 1;\n@@ -11039,8 +11043,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  {\n \t\t    if (template_class_depth (current_class_type) == 0)\n \t\t      {\n-\t\t\tdecl \n-\t\t\t  = check_explicit_specialization \n+\t\t\tdecl\n+\t\t\t  = check_explicit_specialization\n \t\t\t  (declarator, decl,\n \t\t\t   template_count, 2 * (funcdef_flag != 0) + 4);\n \t\t\tif (decl == error_mark_node)\n@@ -11053,7 +11057,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  }\n \t\tif (t && funcdef_flag)\n \t\t  return t;\n-\t\t\n+\n \t\treturn void_type_node;\n \t      }\n \t  }\n@@ -11068,11 +11072,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  {\n \t\t    /* An attempt is being made to initialize a non-static\n \t\t       member.  But, from [class.mem]:\n-\t\t       \n+\n \t\t       4 A member-declarator can contain a\n \t\t       constant-initializer only if it declares a static\n \t\t       member (_class.static_) of integral or enumeration\n-\t\t       type, see _class.static.data_.  \n+\t\t       type, see _class.static.data_.\n \n \t\t       This used to be relatively common practice, but\n \t\t       the rest of the compiler does not correctly\n@@ -11160,7 +11164,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    else\n \t      pedwarn (\"storage class `inline' invalid for function `%s' declared out of global scope\", name);\n \t  }\n-\t\n+\n \tif (ctype == NULL_TREE)\n \t  {\n \t    if (virtualp)\n@@ -11181,7 +11185,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \tdecl = grokfndecl (ctype, type, original_name, declarator,\n \t\t\t   virtualp, flags, quals, raises,\n \t\t\t   1, friendp,\n-\t\t\t   publicp, inlinep, funcdef_flag, \n+\t\t\t   publicp, inlinep, funcdef_flag,\n \t\t\t   template_count, in_namespace);\n \tif (decl == NULL_TREE)\n \t  return NULL_TREE;\n@@ -11216,9 +11220,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t/* It's a variable.  */\n \n \t/* An uninitialized decl with `extern' is a reference.  */\n-\tdecl = grokvardecl (type, declarator, &specbits, \n-\t\t\t    initialized, \n-\t\t\t    (type_quals & TYPE_QUAL_CONST) != 0, \n+\tdecl = grokvardecl (type, declarator, &specbits,\n+\t\t\t    initialized,\n+\t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n \t\t\t    in_namespace);\n \tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n@@ -11330,7 +11334,7 @@ int\n local_variable_p (t)\n      tree t;\n {\n-  if ((TREE_CODE (t) == VAR_DECL \n+  if ((TREE_CODE (t) == VAR_DECL\n        /* A VAR_DECL with a context that is a _TYPE is a static data\n \t  member.  */\n        && !TYPE_P (CP_DECL_CONTEXT (t))\n@@ -11364,7 +11368,7 @@ local_variable_p_walkfn (tp, walk_subtrees, data)\n      int *walk_subtrees ATTRIBUTE_UNUSED;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  return ((local_variable_p (*tp) && !DECL_ARTIFICIAL (*tp)) \n+  return ((local_variable_p (*tp) && !DECL_ARTIFICIAL (*tp))\n \t  ? *tp : NULL_TREE);\n }\n \n@@ -11402,7 +11406,7 @@ check_default_argument (decl, arg)\n   else\n     decl_type = TREE_TYPE (decl);\n \n-  if (arg == error_mark_node \n+  if (arg == error_mark_node\n       || decl == error_mark_node\n       || TREE_TYPE (arg) == error_mark_node\n       || decl_type == error_mark_node)\n@@ -11411,14 +11415,14 @@ check_default_argument (decl, arg)\n     return error_mark_node;\n \n   /* [dcl.fct.default]\n-     \n+\n      A default argument expression is implicitly converted to the\n      parameter type.  */\n   if (!TREE_TYPE (arg)\n       || !can_convert_arg (decl_type, TREE_TYPE (arg), arg))\n     {\n       if (decl)\n-\tcp_error (\"default argument for `%#D' has type `%T'\", \n+\tcp_error (\"default argument for `%#D' has type `%T'\",\n \t\t  decl, TREE_TYPE (arg));\n       else\n \tcp_error (\"default argument for parameter of type `%T' has type `%T'\",\n@@ -11430,7 +11434,7 @@ check_default_argument (decl, arg)\n   /* [dcl.fct.default]\n \n      Local variables shall not be used in default argument\n-     expressions. \n+     expressions.\n \n      The keyword `this' shall not be used in a default argument of a\n      member function.  */\n@@ -11521,7 +11525,7 @@ grokparms (first_parm, funcdef_flag)\n \n \t      chain = TREE_CHAIN (parm);\n \t      /* @@ weak defense against parse errors.  */\n-\t      if (TREE_CODE (decl) != VOID_TYPE \n+\t      if (TREE_CODE (decl) != VOID_TYPE\n \t\t  && TREE_CODE (decl) != TREE_LIST)\n \t\t{\n \t\t  /* Give various messages as the need arises.  */\n@@ -11738,7 +11742,7 @@ grok_ctor_properties (ctype, decl)\n      A declaration of a constructor for a class X is ill-formed if its\n      first parameter is of type (optionally cv-qualified) X and either\n      there are no other parameters or else all other parameters have\n-     default arguments.  \n+     default arguments.\n \n      We *don't* complain about member template instantiations that\n      have this form, though; they can occur as we try to decide what\n@@ -11843,7 +11847,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t doesn't look at the class declaration to find out if it's static.  */\n       if (methodp)\n \trevert_static_member_fn (&decl, NULL, NULL);\n-     \n+\n       /* Take care of function decl if we had syntax errors.  */\n       if (argtypes == NULL_TREE)\n \tTREE_TYPE (decl)\n@@ -11858,7 +11862,7 @@ grok_op_properties (decl, virtualp, friendp)\n     {\n       if (methodp)\n \trevert_static_member_fn (&decl, NULL, NULL);\n-     \n+\n       if (argtypes == NULL_TREE)\n \tTREE_TYPE (decl)\n \t  = build_function_type (void_type_node,\n@@ -11915,7 +11919,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t      ;\n \t    }\n \t}\n-      \n+\n       if (name == ansi_opname[(int) CALL_EXPR])\n \treturn;\t\t\t/* No restrictions on args. */\n \n@@ -11969,7 +11973,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t{\n \t  /* 13.4.0.3 */\n \t  cp_error (\"ANSI C++ prohibits overloading operator ?:\");\n-\t}\t  \n+\t}\n       else if (ambi_op_p (name))\n \t{\n \t  if (list_length (argtypes) == 2)\n@@ -12190,11 +12194,11 @@ xref_tag (code_type_node, name, globalize)\n \t}\n       else\n \tref = lookup_tag (code, name, b, 0);\n-\t  \n+\n       if (! ref)\n \t{\n \t  /* Try finding it as a type declaration.  If that wins,\n-\t     use it.  */ \n+\t     use it.  */\n \t  ref = lookup_name (name, 1);\n \n \t  if (ref != NULL_TREE\n@@ -12212,9 +12216,9 @@ xref_tag (code_type_node, name, globalize)\n \t    ref = NULL_TREE;\n \t}\n \n-      if (ref && current_class_type \n-\t  && template_class_depth (current_class_type) \n-\t  && PROCESSING_REAL_TEMPLATE_DECL_P ()) \n+      if (ref && current_class_type\n+\t  && template_class_depth (current_class_type)\n+\t  && PROCESSING_REAL_TEMPLATE_DECL_P ())\n \t{\n \t  /* Since GLOBALIZE is non-zero, we are not looking at a\n \t     definition of this tag.  Since, in addition, we are currently\n@@ -12303,7 +12307,7 @@ xref_tag (code_type_node, name, globalize)\n   else\n     {\n       /* If it no longer looks like a nested type, make sure it's\n-\t in global scope.  \n+\t in global scope.\n          If it is not an IDENTIFIER, this is not a declaration */\n       if (b->namespace_p && !class_binding_level\n \t  && TREE_CODE (name) == IDENTIFIER_NODE\n@@ -12444,7 +12448,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t    }\n \n \t  if (TYPE_FOR_JAVA (basetype)\n-\t      && (current_lang_stack \n+\t      && (current_lang_stack\n \t\t  == &VARRAY_TREE (current_lang_base, 0)))\n \t    TYPE_FOR_JAVA (ref) = 1;\n \n@@ -12455,14 +12459,14 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t     derived classes.  (Each BINFO record describing an\n \t     individual inheritance contains flags which say what\n \t     the `accessibility' of that particular inheritance is.)  */\n-  \n-\t  base_binfo \n+\n+\t  base_binfo\n \t    = make_binfo (integer_zero_node, basetype,\n \t\t\t  CLASS_TYPE_P (basetype)\n \t\t\t  ? TYPE_BINFO_VTABLE (basetype) : NULL_TREE,\n \t\t\t  CLASS_TYPE_P (basetype)\n \t\t\t  ? TYPE_BINFO_VIRTUALS (basetype) : NULL_TREE);\n- \n+\n \t  TREE_VEC_ELT (binfos, i) = base_binfo;\n \t  TREE_VIA_PUBLIC (base_binfo) = via_public;\n \t  TREE_VIA_PROTECTED (base_binfo) = via_protected;\n@@ -12490,12 +12494,12 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \t      TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n \t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n \t      /* If the base-class uses multiple inheritance, so do we.  */\n-\t      TYPE_USES_MULTIPLE_INHERITANCE (ref) \n+\t      TYPE_USES_MULTIPLE_INHERITANCE (ref)\n \t\t|= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n \t      /* Likewise, if converting to a base of the base may require\n \t\t code, then we may need to generate code to convert to a\n \t\t base as well.  */\n-\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) \n+\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n \t\t|= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n \t    }\n \n@@ -12524,7 +12528,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n      bases.  */\n   get_vbase_types (ref);\n }\n-  \n+\n \f\n /* Begin compiling the definition of an enumeration type.\n    NAME is its name (or null if anonymous).\n@@ -12614,7 +12618,7 @@ finish_enum (enumtype)\n \t\t reason to do that when processing_template_decl.\n \t\t And, if the expression is something like a\n \t\t TEMPLATE_PARM_INDEX or a CAST_EXPR doing so will\n-\t\t wreak havoc on the intended type of the expression.  \n+\t\t wreak havoc on the intended type of the expression.\n \n \t         Of course, there's also no point in trying to compute\n \t\t minimum or maximum values if we're in a template.  */\n@@ -12628,7 +12632,7 @@ finish_enum (enumtype)\n \t\tminnode = value;\n \t    }\n \n-\t  if (processing_template_decl) \n+\t  if (processing_template_decl)\n \t    /* If this is just a template, leave the CONST_DECL\n \t       alone.  That way tsubst_copy will find CONST_DECLs for\n \t       CONST_DECLs, and not INTEGER_CSTs.  */\n@@ -12670,15 +12674,15 @@ finish_enum (enumtype)\n \n       if (flag_short_enums || (precision > TYPE_PRECISION (integer_type_node)))\n \t/* Use the width of the narrowest normal C type which is wide\n-\t   enough.  */ \n+\t   enough.  */\n \tTYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size\n \t\t\t\t\t\t    (precision, 1));\n       else\n \tTYPE_PRECISION (enumtype) = TYPE_PRECISION (integer_type_node);\n \n       TYPE_SIZE (enumtype) = 0;\n       layout_type (enumtype);\n-    \n+\n       /* Fix up all variant types of this enum type.  */\n       for (tem = TYPE_MAIN_VARIANT (enumtype); tem;\n \t   tem = TYPE_NEXT_VARIANT (tem))\n@@ -12754,7 +12758,7 @@ build_enumerator (name, value, enumtype)\n \t\t\t\t\t\t prev_value,\n \t\t\t\t\t\t integer_one_node,\n \t\t\t\t\t\t PLUS_EXPR);\n-\t      \n+\n \t      if (tree_int_cst_lt (value, prev_value))\n \t\tcp_error (\"overflow in enumeration values at `%D'\", name);\n \t    }\n@@ -12861,7 +12865,7 @@ check_function_type (decl)\n \tTREE_TYPE (decl)\n \t  = build_function_type (void_type_node,\n \t\t\t\t TYPE_ARG_TYPES (TREE_TYPE (decl)));\n-      TREE_TYPE (decl) \n+      TREE_TYPE (decl)\n \t= build_exception_variant (fntype,\n \t\t\t\t   TYPE_RAISES_EXCEPTIONS (fntype));\n     }\n@@ -12879,8 +12883,8 @@ check_function_type (decl)\n    process and that DECLSPECS should be ignored), SF_INCLASS_INLINE\n    indicating that the function is an inline defined in-class, and\n    SF_EXPAND indicating that we should generate RTL for this\n-   function.  \n-   \n+   function.\n+\n    This function creates a binding context for the function body\n    as well as setting up the FUNCTION_DECL in current_function_decl.\n \n@@ -12983,7 +12987,7 @@ start_function (declspecs, declarator, attrs, flags)\n \t    }\n \t}\n     }\n-  \n+\n   /* Sometimes we don't notice that a function is a static member, and\n      build a METHOD_TYPE for it.  Fix that up now.  */\n   if (ctype != NULL_TREE && DECL_STATIC_FUNCTION_P (decl1)\n@@ -13030,7 +13034,7 @@ start_function (declspecs, declarator, attrs, flags)\n #ifdef SET_DEFAULT_DECL_ATTRIBUTES\n   SET_DEFAULT_DECL_ATTRIBUTES (decl1, attrs);\n #endif\n-  \n+\n   /* This function exists in static storage.\n      (This does not mean `static' in the C sense!)  */\n   TREE_STATIC (decl1) = 1;\n@@ -13064,8 +13068,8 @@ start_function (declspecs, declarator, attrs, flags)\n \t{\n \t  DECL_RESULT (decl1)\n \t    = build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (restype));\n-\t  c_apply_type_quals_to_decl (CP_TYPE_QUALS (restype), \n-\t\t\t\t      DECL_RESULT (decl1)); \n+\t  c_apply_type_quals_to_decl (CP_TYPE_QUALS (restype),\n+\t\t\t\t      DECL_RESULT (decl1));\n \t}\n     }\n   else\n@@ -13102,7 +13106,7 @@ start_function (declspecs, declarator, attrs, flags)\n   if (!processing_template_decl && !(flags & SF_PRE_PARSED))\n     {\n       /* A specialization is not used to guide overload resolution.  */\n-      if ((flag_guiding_decls \n+      if ((flag_guiding_decls\n \t   || !DECL_TEMPLATE_SPECIALIZATION (decl1))\n \t  && ! DECL_FUNCTION_MEMBER_P (decl1))\n \tdecl1 = pushdecl (decl1);\n@@ -13151,13 +13155,13 @@ start_function (declspecs, declarator, attrs, flags)\n \t never get us to that point.  Here we keep the consistency\n \t between `current_class_type' and `current_class_ptr'.  */\n       tree t = DECL_ARGUMENTS (decl1);\n-\t      \n-      my_friendly_assert (t != NULL_TREE && TREE_CODE (t) == PARM_DECL, \n+\n+      my_friendly_assert (t != NULL_TREE && TREE_CODE (t) == PARM_DECL,\n \t\t\t  162);\n       my_friendly_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE,\n \t\t\t  19990811);\n-\t  \n-      cp_function_chain->x_current_class_ref \n+\n+      cp_function_chain->x_current_class_ref\n \t= build_indirect_ref (t, NULL_PTR);\n       cp_function_chain->x_current_class_ptr = t;\n \n@@ -13180,7 +13184,7 @@ start_function (declspecs, declarator, attrs, flags)\n       if (DECL_NOT_REALLY_EXTERN (decl1))\n \tDECL_EXTERNAL (decl1) = 0;\n \n-      if (ctx != NULL_TREE && DECL_THIS_INLINE (ctx) \n+      if (ctx != NULL_TREE && DECL_THIS_INLINE (ctx)\n \t  && TREE_PUBLIC (ctx))\n \t/* This is a function in a local class in an extern inline\n \t   function.  */\n@@ -13246,7 +13250,7 @@ start_function (declspecs, declarator, attrs, flags)\n \n   if (attrs)\n     cplus_decl_attributes (decl1, NULL_TREE, attrs);\n-  \n+\n   if (!building_stmt_tree ())\n     {\n       GNU_xref_function (decl1, current_function_parms);\n@@ -13353,15 +13357,15 @@ store_parm_decls ()\n \t      if (doing_semantic_analysis_p ())\n \t\t{\n \t\t  tree cleanup;\n-\t      \n+\n \t\t  if (DECL_NAME (parm) == NULL_TREE\n \t\t      || TREE_CODE (parm) != VOID_TYPE)\n \t\t    pushdecl (parm);\n \t\t  else\n \t\t    cp_error (\"parameter `%D' declared void\", parm);\n \n \t\t  cleanup = maybe_build_cleanup (parm);\n-\t\t  \n+\n \t\t  if (cleanup)\n \t\t    cleanups = tree_cons (parm, cleanup, cleanups);\n \t\t}\n@@ -13414,7 +13418,7 @@ store_parm_decls ()\n      should not be called before the parm can be used.  */\n   while (cleanups)\n     {\n-      finish_decl_cleanup (TREE_PURPOSE (cleanups), \n+      finish_decl_cleanup (TREE_PURPOSE (cleanups),\n \t\t\t   TREE_VALUE (cleanups));\n       cleanups = TREE_CHAIN (cleanups);\n     }\n@@ -13430,8 +13434,8 @@ store_parm_decls ()\n     }\n \n   /* Do the starting of the exception specifications, if we have any.  */\n-  if (flag_exceptions && !processing_template_decl \n-      && building_stmt_tree () \n+  if (flag_exceptions && !processing_template_decl\n+      && building_stmt_tree ()\n       && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n     current_eh_spec_try_block = expand_start_eh_spec ();\n }\n@@ -13474,9 +13478,9 @@ save_function_data (decl)\n      get it back when we really expand this function.  */\n   my_friendly_assert (!DECL_PENDING_INLINE_P (decl),\n \t\t      19990908);\n-      \n+\n   /* Make a copy.  */\n-  f = ((struct language_function *) \n+  f = ((struct language_function *)\n        xmalloc (sizeof (struct language_function)));\n   bcopy ((char *) cp_function_chain, (char *) f,\n \t sizeof (struct language_function));\n@@ -13555,9 +13559,9 @@ finish_destructor_body ()\n     in_charge = current_in_charge_parm;\n \n   exprstmt = build_delete (current_class_type,\n-\t\t\t   current_class_ref, \n+\t\t\t   current_class_ref,\n \t\t\t   in_charge,\n-\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL, \n+\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL,\n \t\t\t   0);\n \n   if (exprstmt != error_mark_node\n@@ -13576,7 +13580,7 @@ finish_destructor_body ()\n \t  tree vbases = nreverse (copy_list (CLASSTYPE_VBASECLASSES (current_class_type)));\n \t  tree if_stmt = begin_if_stmt ();\n \t  finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n-\t\t\t\t      current_in_charge_parm, \n+\t\t\t\t      current_in_charge_parm,\n \t\t\t\t      integer_two_node),\n \t\t\t       if_stmt);\n \n@@ -13599,16 +13603,16 @@ finish_destructor_body ()\n \t  finish_if_stmt ();\n \t}\n     }\n-  \n+\n   virtual_size = c_sizeof (current_class_type);\n \n   /* At the end, call delete if that's what's requested.  */\n-  \n+\n   /* FDIS sez: At the point of definition of a virtual destructor\n      (including an implicit definition), non-placement operator delete\n      shall be looked up in the scope of the destructor's class and if\n      found shall be accessible and unambiguous.\n-     \n+\n      This is somewhat unclear, but I take it to mean that if the class\n      only defines placement deletes we don't do anything here.  So we\n      pass LOOKUP_SPECULATIVELY; delete_sanity will complain for us if\n@@ -13643,8 +13647,8 @@ finish_destructor_body ()\n    This is called after parsing the body of the function definition.\n    LINENO is the current line number.\n \n-   FLAGS is a bitwise or of the following values: \n-     1 - CALL_POPLEVEL \n+   FLAGS is a bitwise or of the following values:\n+     1 - CALL_POPLEVEL\n        An extra call to poplevel (and expand_end_bindings) must be\n        made to take care of the binding contour for the base\n        initializers.  This is only relevant for constructors.\n@@ -13709,7 +13713,7 @@ finish_function (lineno, flags)\n       /* Finish dealing with exception specifiers.  */\n       if (flag_exceptions && !processing_template_decl\n \t  && TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n-\texpand_end_eh_spec (TYPE_RAISES_EXCEPTIONS \n+\texpand_end_eh_spec (TYPE_RAISES_EXCEPTIONS\n \t\t\t    (TREE_TYPE (current_function_decl)),\n \t\t\t    current_eh_spec_try_block);\n     }\n@@ -13760,7 +13764,7 @@ finish_function (lineno, flags)\n       /* If this function is supposed to return a value, ensure that\n \t we do not fall into the cleanups by mistake.  The end of our\n \t function will look like this:\n-\t \n+\n \t user code (may have return stmt somewhere)\n \t goto no_return_label\n \t cleanup_label:\n@@ -13770,7 +13774,7 @@ finish_function (lineno, flags)\n \t NOTE_INSN_FUNCTION_END\n \t return_label:\n \t things for return\n-\t \n+\n \t If the user omits a return stmt in the USER CODE section, we\n \t will have a control path which reaches NOTE_INSN_FUNCTION_END.\n \t Otherwise, we won't.  */\n@@ -13825,7 +13829,7 @@ finish_function (lineno, flags)\n      maybe_end_member_template_processing decides to pop all the\n      template parameters.  */\n   expand_p = !building_stmt_tree ();\n-  \n+\n   /* If we're saving up tree structure, tie off the function now.  */\n   if (!expand_p)\n     finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n@@ -14067,7 +14071,7 @@ start_method (declspecs, declarator, attrlist)\n     {\n       if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (fndecl)) != current_class_type)\n \t{\n-\t  if (DECL_CONTEXT (fndecl) \n+\t  if (DECL_CONTEXT (fndecl)\n \t      && TREE_CODE( DECL_CONTEXT (fndecl)) != NAMESPACE_DECL)\n \t    cp_error (\"`%D' is already defined in class %s\", fndecl,\n \t\t\t     TYPE_NAME_STRING (DECL_CONTEXT (fndecl)));\n@@ -14114,7 +14118,7 @@ start_method (declspecs, declarator, attrlist)\n   /* Make a place for the parms */\n   pushlevel (0);\n   current_binding_level->parm_flag = 1;\n-  \n+\n   DECL_IN_AGGR_P (fndecl) = 1;\n   return fndecl;\n }\n@@ -14307,7 +14311,7 @@ cplus_expand_expr_stmt (exp)\n {\n   if (stmts_are_full_exprs_p)\n     exp = convert_to_void (exp, \"statement\");\n-  \n+\n #if 0\n   /* We should do this eventually, but right now this causes regex.o from\n      libg++ to miscompile, and tString to core dump.  */\n@@ -14347,9 +14351,9 @@ revert_static_member_fn (decl, fn, argtypes)\n   tree function = fn ? *fn : TREE_TYPE (*decl);\n   tree args = argtypes ? *argtypes : TYPE_ARG_TYPES (function);\n \n-  if (CP_TYPE_QUALS (TREE_TYPE (TREE_VALUE (args))) \n+  if (CP_TYPE_QUALS (TREE_TYPE (TREE_VALUE (args)))\n       != TYPE_UNQUALIFIED)\n-    cp_error (\"static member function `%#D' declared with type qualifiers\", \n+    cp_error (\"static member function `%#D' declared with type qualifiers\",\n \t      *decl);\n \n   args = TREE_CHAIN (args);\n@@ -14367,15 +14371,15 @@ revert_static_member_fn (decl, fn, argtypes)\n     *argtypes = args;\n }\n \n-/* Initialize the variables used during compilation of a C++ \n-   function.  */ \n+/* Initialize the variables used during compilation of a C++\n+   function.  */\n \n static void\n push_cp_function_context (f)\n      struct function *f;\n {\n-  struct language_function *p \n-    = ((struct language_function *) \n+  struct language_function *p\n+    = ((struct language_function *)\n        xcalloc (1, sizeof (struct language_function)));\n   f->language = p;\n \n@@ -14513,7 +14517,7 @@ lang_mark_tree (t)\n     {\n       struct lang_type *lt = TYPE_LANG_SPECIFIC (t);\n \n-      if (lt && !(TREE_CODE (t) == POINTER_TYPE \n+      if (lt && !(TREE_CODE (t) == POINTER_TYPE\n \t\t  && TREE_CODE (TREE_TYPE (t)) == METHOD_TYPE))\n \t{\n \t  ggc_mark (lt);\n@@ -14535,4 +14539,3 @@ lang_mark_tree (t)\n \tggc_mark_tree ((tree) lt);\n     }\n }\n-"}]}