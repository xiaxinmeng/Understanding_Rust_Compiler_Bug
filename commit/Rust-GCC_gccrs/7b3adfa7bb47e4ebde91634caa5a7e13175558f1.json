{"sha": "7b3adfa7bb47e4ebde91634caa5a7e13175558f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IzYWRmYTdiYjQ3ZTRlYmRlOTE2MzRjYWE1YTdlMTMxNzU1NThmMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-26T09:18:19Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-07-01T11:32:27Z"}, "message": "tree-optimization/95839 - teach SLP vectorization about vector inputs\n\nThis teaches SLP analysis about vector typed externals that are\nfed into the SLP operations via lane extracting BIT_FIELD_REFs.\nIt shows that there's currently no good representation for\nvector code on the SLP side so I went a half way and represent\nsuch vector externals uses always using a SLP permutation node\nwith a single external SLP child which has a non-standard\nrepresentation of no scalar defs but only a vector def.  That\nworks best for shielding the rest of the vectorizer from it.\n\n2020-06-26  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/95839\n\t* tree-vect-slp.c (vect_slp_tree_uniform_p): Pre-existing\n\tvectors are not uniform.\n\t(vect_build_slp_tree_1): Handle BIT_FIELD_REFs of\n\tvector registers.\n\t(vect_build_slp_tree_2): For groups of lane extracts\n\tfrom a vector register generate a permute node\n\twith a special child representing the pre-existing vector.\n\t(vect_prologue_cost_for_slp): Pre-existing vectors cost nothing.\n\t(vect_slp_analyze_node_operations): Use SLP_TREE_LANES.\n\t(vectorizable_slp_permutation): Do not generate or cost identity\n\tpermutes.\n\t(vect_schedule_slp_instance): Handle pre-existing vector\n\tthat are function arguments.\n\n\t* gcc.dg/vect/bb-slp-pr95839-2.c: New testcase.", "tree": {"sha": "70cc56f23e32eab5cefbb65a7600b2a43e6c026b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70cc56f23e32eab5cefbb65a7600b2a43e6c026b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b3adfa7bb47e4ebde91634caa5a7e13175558f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3adfa7bb47e4ebde91634caa5a7e13175558f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b3adfa7bb47e4ebde91634caa5a7e13175558f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3adfa7bb47e4ebde91634caa5a7e13175558f1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deda4625f1befb55a52409de2c7eda325b58e195", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deda4625f1befb55a52409de2c7eda325b58e195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deda4625f1befb55a52409de2c7eda325b58e195"}], "stats": {"total": 139, "additions": 124, "deletions": 15}, "files": [{"sha": "49e75d8c95cbb977c8d64e9bfeca981bb5c322ed", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr95839-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3adfa7bb47e4ebde91634caa5a7e13175558f1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr95839-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3adfa7bb47e4ebde91634caa5a7e13175558f1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr95839-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr95839-2.c?ref=7b3adfa7bb47e4ebde91634caa5a7e13175558f1", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-additional-options \"-w -Wno-psabi\" } */\n+\n+typedef double __attribute__((vector_size(16))) v2df;\n+\n+v2df f(v2df a, v2df b)\n+{\n+  return (v2df){a[0] + b[0], a[1] + b[1]};\n+}\n+\n+v2df g(v2df a, v2df b)\n+{\n+  return (v2df){a[0] + b[1], a[1] + b[0]};\n+}\n+\n+/* Verify we manage to vectorize this with using the original vectors\n+   and do not end up with any vector CTORs.  */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 2 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-not \"vect_cst\" \"slp2\" } } */"}, {"sha": "532809d2667efd7cd943cf3f61ebf7f62b6bdb33", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 104, "deletions": 15, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3adfa7bb47e4ebde91634caa5a7e13175558f1/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3adfa7bb47e4ebde91634caa5a7e13175558f1/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7b3adfa7bb47e4ebde91634caa5a7e13175558f1", "patch": "@@ -247,6 +247,10 @@ vect_slp_tree_uniform_p (slp_tree node)\n   gcc_assert (SLP_TREE_DEF_TYPE (node) == vect_constant_def\n \t      || SLP_TREE_DEF_TYPE (node) == vect_external_def);\n \n+  /* Pre-exsting vectors.  */\n+  if (SLP_TREE_SCALAR_OPS (node).is_empty ())\n+    return false;\n+\n   unsigned i;\n   tree op, first = NULL_TREE;\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_OPS (node), i, op)\n@@ -838,7 +842,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       else\n \t{\n \t  rhs_code = gimple_assign_rhs_code (stmt);\n-\t  load_p = TREE_CODE_CLASS (rhs_code) == tcc_reference;\n+\t  load_p = gimple_vuse (stmt);\n \t}\n \n       /* Check the operation.  */\n@@ -899,6 +903,22 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n               need_same_oprnds = true;\n               first_op1 = gimple_assign_rhs2 (stmt);\n             }\n+\t  else if (!load_p\n+\t\t   && rhs_code == BIT_FIELD_REF)\n+\t    {\n+\t      tree vec = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n+\t      if (TREE_CODE (vec) != SSA_NAME\n+\t\t  || !types_compatible_p (vectype, TREE_TYPE (vec)))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t     \"Build SLP failed: \"\n+\t\t\t\t     \"BIT_FIELD_REF not supported\\n\");\n+\t\t  /* Fatal mismatch.  */\n+\t\t  matches[0] = false;\n+\t\t  return false;\n+\t\t}\n+\t    }\n \t  else if (call_stmt\n \t\t   && gimple_call_internal_p (call_stmt, IFN_DIV_POW2))\n \t    {\n@@ -957,6 +977,18 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t  continue;\n \t\t}\n \t    }\n+\t  if (!load_p\n+\t      && first_stmt_code == BIT_FIELD_REF\n+\t      && (TREE_OPERAND (gimple_assign_rhs1 (first_stmt_info->stmt), 0)\n+\t\t  != TREE_OPERAND (gimple_assign_rhs1 (stmt_info->stmt), 0)))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"Build SLP failed: different BIT_FIELD_REF \"\n+\t\t\t\t \"arguments in %G\", stmt);\n+\t      /* Mismatch.  */\n+\t      continue;\n+\t    }\n \n \t  if (!load_p && rhs_code == CALL_EXPR)\n \t    {\n@@ -1026,7 +1058,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_expression\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_comparison\n \t      && rhs_code != VIEW_CONVERT_EXPR\n-\t      && rhs_code != CALL_EXPR)\n+\t      && rhs_code != CALL_EXPR\n+\t      && rhs_code != BIT_FIELD_REF)\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -1287,6 +1320,45 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  return node;\n \t}\n     }\n+  else if (gimple_assign_single_p (stmt_info->stmt)\n+\t   && !gimple_vuse (stmt_info->stmt)\n+\t   && gimple_assign_rhs_code (stmt_info->stmt) == BIT_FIELD_REF)\n+    {\n+      /* vect_build_slp_tree_2 determined all BIT_FIELD_REFs reference\n+\t the same SSA name vector of a compatible type to vectype.  */\n+      vec<std::pair<unsigned, unsigned> > lperm = vNULL;\n+      tree vec = TREE_OPERAND (gimple_assign_rhs1 (stmt_info->stmt), 0);\n+      stmt_vec_info estmt_info;\n+      FOR_EACH_VEC_ELT (stmts, i, estmt_info)\n+\t{\n+\t  gassign *estmt = as_a <gassign *> (estmt_info->stmt);\n+\t  tree bfref = gimple_assign_rhs1 (estmt);\n+\t  HOST_WIDE_INT lane;\n+\t  if (!known_eq (bit_field_size (bfref),\n+\t\t\t tree_to_poly_uint64 (TYPE_SIZE (TREE_TYPE (vectype))))\n+\t      || !constant_multiple_p (bit_field_offset (bfref),\n+\t\t\t\t       bit_field_size (bfref), &lane))\n+\t    {\n+\t      lperm.release ();\n+\t      return NULL;\n+\t    }\n+\t  lperm.safe_push (std::make_pair (0, (unsigned)lane));\n+\t}\n+      slp_tree vnode = vect_create_new_slp_node (vNULL);\n+      SLP_TREE_VECTYPE (vnode) = TREE_TYPE (vec);\n+      SLP_TREE_VEC_DEFS (vnode).safe_push (vec);\n+      /* We are always building a permutation node even if it is an identity\n+\t permute to shield the rest of the vectorizer from the odd node\n+\t representing an actual vector without any scalar ops.\n+\t ???  We could hide it completely with making the permute node\n+\t external?  */\n+      node = vect_create_new_slp_node (stmts, 1);\n+      SLP_TREE_CODE (node) = VEC_PERM_EXPR;\n+      SLP_TREE_LANE_PERMUTATION (node) = lperm;\n+      SLP_TREE_VECTYPE (node) = vectype;\n+      SLP_TREE_CHILDREN (node).quick_push (vnode);\n+      return node;\n+    }\n \n   /* Get at the operands, verifying they are compatible.  */\n   vec<slp_oprnd_info> oprnds_info = vect_create_oprnd_info (nops, group_size);\n@@ -2744,6 +2816,10 @@ static void\n vect_prologue_cost_for_slp (slp_tree node,\n \t\t\t    stmt_vector_for_cost *cost_vec)\n {\n+  /* There's a special case of an existing vector, that costs nothing.  */\n+  if (SLP_TREE_SCALAR_OPS (node).length () == 0\n+      && !SLP_TREE_VEC_DEFS (node).is_empty ())\n+    return;\n   /* Without looking at the actual initializer a vector of\n      constants can be implemented as load from the constant pool.\n      When all elements are the same we can use a splat.  */\n@@ -2857,7 +2933,7 @@ vect_slp_analyze_node_operations (vec_info *vinfo, slp_tree node,\n \t\t\t  && j == 1);\n \t      continue;\n \t    }\n-\t  unsigned group_size = SLP_TREE_SCALAR_OPS (child).length ();\n+\t  unsigned group_size = SLP_TREE_LANES (child);\n \t  poly_uint64 vf = 1;\n \t  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n \t    vf = loop_vinfo->vectorization_factor;\n@@ -4139,7 +4215,9 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t{\n \t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2,\n \t\t\t      const_nunits);\n-\t  if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+\t  bool identity_p = indices.series_p (0, 1, 0, 1);\n+\t  if (!identity_p\n+\t      && !can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -4157,26 +4235,33 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t      return false;\n \t    }\n \n-\t  nperms++;\n+\t  if (!identity_p)\n+\t    nperms++;\n \t  if (gsi)\n \t    {\n-\t      tree mask_vec = vect_gen_perm_mask_checked (vectype, indices);\n-\n \t      if (second_vec.first == -1U)\n \t\tsecond_vec = first_vec;\n \n \t      /* Generate the permute statement if necessary.  */\n \t      slp_tree first_node = SLP_TREE_CHILDREN (node)[first_vec.first];\n \t      tree first_def\n \t\t= vect_get_slp_vect_def (first_node, first_vec.second);\n-\t      slp_tree second_node = SLP_TREE_CHILDREN (node)[second_vec.first];\n-\t      tree second_def\n-\t\t= vect_get_slp_vect_def (second_node, second_vec.second);\n+\t      gassign *perm_stmt;\n \t      tree perm_dest = make_ssa_name (vectype);\n-\t      gassign *perm_stmt\n-\t\t= gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n-\t\t\t\t       first_def, second_def,\n-\t\t\t\t       mask_vec);\n+\t      if (!identity_p)\n+\t\t{\n+\t\t  slp_tree second_node\n+\t\t    = SLP_TREE_CHILDREN (node)[second_vec.first];\n+\t\t  tree second_def\n+\t\t    = vect_get_slp_vect_def (second_node, second_vec.second);\n+\t\t  tree mask_vec = vect_gen_perm_mask_checked (vectype, indices);\n+\t\t  perm_stmt = gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n+\t\t\t\t\t\t   first_def, second_def,\n+\t\t\t\t\t\t   mask_vec);\n+\t\t}\n+\t      else\n+\t\t/* We need a copy here in case the def was external.  */\n+\t\tperm_stmt = gimple_build_assign (perm_dest, first_def);\n \t      vect_finish_stmt_generation (vinfo, NULL, perm_stmt, gsi);\n \t      /* Store the vector statement in NODE.  */\n \t      SLP_TREE_VEC_STMTS (node).quick_push (perm_stmt);\n@@ -4315,13 +4400,17 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t    unsigned j;\n \t    tree vdef;\n \t    FOR_EACH_VEC_ELT (SLP_TREE_VEC_DEFS (child), j, vdef)\n-\t      if (TREE_CODE (vdef) == SSA_NAME)\n+\t      if (TREE_CODE (vdef) == SSA_NAME\n+\t\t  && !SSA_NAME_IS_DEFAULT_DEF (vdef))\n \t\t{\n \t\t  gimple *vstmt = SSA_NAME_DEF_STMT (vdef);\n \t\t  if (!last_stmt\n \t\t      || vect_stmt_dominates_stmt_p (last_stmt, vstmt))\n \t\t    last_stmt = vstmt;\n \t\t}\n+\t    /* This can happen when all children are pre-existing vectors.  */\n+\t    if (!last_stmt)\n+\t      last_stmt = vect_find_first_scalar_stmt_in_slp (node)->stmt;\n \t  }\n       if (is_a <gphi *> (last_stmt))\n \tsi = gsi_after_labels (gimple_bb (last_stmt));"}]}