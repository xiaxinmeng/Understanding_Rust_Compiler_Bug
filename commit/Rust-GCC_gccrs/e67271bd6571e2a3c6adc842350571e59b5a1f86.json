{"sha": "e67271bd6571e2a3c6adc842350571e59b5a1f86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY3MjcxYmQ2NTcxZTJhM2M2YWRjODQyMzUwNTcxZTU5YjVhMWY4Ng==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2010-01-06T18:34:31Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2010-01-06T18:34:31Z"}, "message": "re PR middle-end/41883 (ICE from '-O  -fprofile-arcs -fsched2-use-superblocks -ftree-vrp -fschedule-insns2 -freorder-blocks')\n\n\tPR middle-end/41883\n\t* haifa-sched.c (add_to_note_list): Merge into ...\n\t(concat_note_lists): ... here, and ...\n\t(unlink_other_notes, rm_other_notes): Merge into...\n\t(remove_notes): ... here.  Create REG_SAVE_NOTEs for\n\tNOTE_INSN_EPILOGUE_BEG.\n\nFrom-SVN: r155680", "tree": {"sha": "690ad37d4cb1af3217c4867f5546cc48b0c4e34a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/690ad37d4cb1af3217c4867f5546cc48b0c4e34a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e67271bd6571e2a3c6adc842350571e59b5a1f86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67271bd6571e2a3c6adc842350571e59b5a1f86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e67271bd6571e2a3c6adc842350571e59b5a1f86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e67271bd6571e2a3c6adc842350571e59b5a1f86/comments", "author": null, "committer": null, "parents": [{"sha": "6209a13e202b97e040f91e57281a2c23e0022bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6209a13e202b97e040f91e57281a2c23e0022bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6209a13e202b97e040f91e57281a2c23e0022bea"}], "stats": {"total": 182, "additions": 69, "deletions": 113}, "files": [{"sha": "e8aa64b4127e806ee39d9c03ddd259bf86cea461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67271bd6571e2a3c6adc842350571e59b5a1f86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67271bd6571e2a3c6adc842350571e59b5a1f86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e67271bd6571e2a3c6adc842350571e59b5a1f86", "patch": "@@ -1,3 +1,12 @@\n+2010-01-06  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/41883\n+\t* haifa-sched.c (add_to_note_list): Merge into ...\n+\t(concat_note_lists): ... here, and ...\n+\t(unlink_other_notes, rm_other_notes): Merge into...\n+\t(remove_notes): ... here.  Create REG_SAVE_NOTEs for\n+\tNOTE_INSN_EPILOGUE_BEG.  \n+\n 2010-01-06  Richard Guenther  <rguenther@suse.de>\n \n \t* ipa-inline.c (cgraph_decide_inlining_incrementally): Do"}, {"sha": "de75286ef282c757962bfb2a773115554797d387", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 53, "deletions": 113, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67271bd6571e2a3c6adc842350571e59b5a1f86/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67271bd6571e2a3c6adc842350571e59b5a1f86/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=e67271bd6571e2a3c6adc842350571e59b5a1f86", "patch": "@@ -1,6 +1,6 @@\n /* Instruction scheduling pass.\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) Enhanced by,\n    and currently maintained by, Jim Wilson (wilson@cygnus.com)\n@@ -1803,89 +1803,87 @@ schedule_insn (rtx insn)\n \n /* Functions for handling of notes.  */\n \n-/* Insert the INSN note at the end of the notes list.  */\n-static void\n-add_to_note_list (rtx insn, rtx *note_list_end_p)\n-{\n-  PREV_INSN (insn) = *note_list_end_p;\n-  if (*note_list_end_p)\n-    NEXT_INSN (*note_list_end_p) = insn;\n-  *note_list_end_p = insn;\n-}\n-\n /* Add note list that ends on FROM_END to the end of TO_ENDP.  */\n void\n concat_note_lists (rtx from_end, rtx *to_endp)\n {\n   rtx from_start;\n \n+  /* It's easy when have nothing to concat.  */\n   if (from_end == NULL)\n-    /* It's easy when have nothing to concat.  */\n     return;\n \n+  /* It's also easy when destination is empty.  */\n   if (*to_endp == NULL)\n-    /* It's also easy when destination is empty.  */\n     {\n       *to_endp = from_end;\n       return;\n     }\n \n   from_start = from_end;\n-  /* A note list should be traversed via PREV_INSN.  */\n   while (PREV_INSN (from_start) != NULL)\n     from_start = PREV_INSN (from_start);\n \n-  add_to_note_list (from_start, to_endp);\n+  PREV_INSN (from_start) = *to_endp;\n+  NEXT_INSN (*to_endp) = from_start;\n   *to_endp = from_end;\n }\n \n-/* Delete notes beginning with INSN and put them in the chain\n-   of notes ended by NOTE_LIST.\n-   Returns the insn following the notes.  */\n-static rtx\n-unlink_other_notes (rtx insn, rtx tail)\n+/* Delete notes between HEAD and TAIL and put them in the chain\n+   of notes ended by NOTE_LIST.  */\n+void\n+remove_notes (rtx head, rtx tail)\n {\n-  rtx prev = PREV_INSN (insn);\n+  rtx next_tail, prev, insn, next;\n \n-  while (insn != tail && NOTE_NOT_BB_P (insn))\n-    {\n-      rtx next = NEXT_INSN (insn);\n-      basic_block bb = BLOCK_FOR_INSN (insn);\n-\n-      /* Delete the note from its current position.  */\n-      if (prev)\n-\tNEXT_INSN (prev) = next;\n-      if (next)\n-\tPREV_INSN (next) = prev;\n+  note_list = 0;\n+  if (head == tail && !INSN_P (head))\n+    return;\n \n-      if (bb)\n-        {\n-          /* Basic block can begin with either LABEL or\n-             NOTE_INSN_BASIC_BLOCK.  */\n-          gcc_assert (BB_HEAD (bb) != insn);\n+  next_tail = NEXT_INSN (tail);\n+  prev = PREV_INSN (head);\n+  for (insn = head; insn != next_tail; insn = next)\n+    {\n+      next = NEXT_INSN (insn);\n+      if (!NOTE_P (insn))\n+\t{\n+\t  prev = insn;\n+\t  continue;\n+\t}\n \n-          /* Check if we are removing last insn in the BB.  */\n-          if (BB_END (bb) == insn)\n-            BB_END (bb) = prev;\n-        }\n+      switch (NOTE_KIND (insn))\n+\t{\n+\tcase NOTE_INSN_BASIC_BLOCK:\n+\t  prev = insn;\n+\t  continue;\n \n-      /* See sched_analyze to see how these are handled.  */\n-      if (NOTE_KIND (insn) != NOTE_INSN_EH_REGION_BEG\n-\t  && NOTE_KIND (insn) != NOTE_INSN_EH_REGION_END)\n-        add_to_note_list (insn, &note_list);\n+\tcase NOTE_INSN_EPILOGUE_BEG:\n+\t  if (insn != tail)\n+\t    {\n+\t      remove_insn (insn);\n+\t      add_reg_note (next, REG_SAVE_NOTE,\n+\t\t\t    GEN_INT (NOTE_INSN_EPILOGUE_BEG));\n+\t      break;\n+\t    }\n+\t  /* FALLTHRU */\n \n-      insn = next;\n-    }\n+\tdefault:\n+\t  remove_insn (insn);\n+\n+\t  /* Add the note to list that ends at NOTE_LIST.  */\n+\t  PREV_INSN (insn) = note_list;\n+\t  NEXT_INSN (insn) = NULL_RTX;\n+\t  if (note_list)\n+\t    NEXT_INSN (note_list) = insn;\n+\t  note_list = insn;\n+\t  break;\n+\t}\n \n-  if (insn == tail)\n-    {\n-      gcc_assert (sel_sched_p ());\n-      return prev;\n+      gcc_assert ((sel_sched_p () || insn != tail) && insn != head);\n     }\n-\n-  return insn;\n }\n \n+\n /* Return the head and tail pointers of ebb starting at BEG and ending\n    at END.  */\n void\n@@ -1939,62 +1937,6 @@ no_real_insns_p (const_rtx head, const_rtx tail)\n   return 1;\n }\n \n-/* Delete notes between HEAD and TAIL and put them in the chain\n-   of notes ended by NOTE_LIST.  */\n-static void\n-rm_other_notes (rtx head, rtx tail)\n-{\n-  rtx next_tail;\n-  rtx insn;\n-\n-  note_list = 0;\n-  if (head == tail && (! INSN_P (head)))\n-    return;\n-\n-  next_tail = NEXT_INSN (tail);\n-  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n-    {\n-      rtx prev;\n-\n-      /* Farm out notes, and maybe save them in NOTE_LIST.\n-         This is needed to keep the debugger from\n-         getting completely deranged.  */\n-      if (NOTE_NOT_BB_P (insn))\n-\t{\n-\t  prev = insn;\n-\t  insn = unlink_other_notes (insn, next_tail);\n-\n-\t  gcc_assert ((sel_sched_p ()\n-\t\t       || prev != tail) && prev != head && insn != next_tail);\n-\t}\n-    }\n-}\n-\n-/* Same as above, but also process REG_SAVE_NOTEs of HEAD.  */\n-void\n-remove_notes (rtx head, rtx tail)\n-{\n-  /* rm_other_notes only removes notes which are _inside_ the\n-     block---that is, it won't remove notes before the first real insn\n-     or after the last real insn of the block.  So if the first insn\n-     has a REG_SAVE_NOTE which would otherwise be emitted before the\n-     insn, it is redundant with the note before the start of the\n-     block, and so we have to take it out.  */\n-  if (INSN_P (head))\n-    {\n-      rtx note;\n-\n-      for (note = REG_NOTES (head); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_SAVE_NOTE)\n-\t  remove_note (head, note);\n-    }\n-\n-  /* Remove remaining note insns from the block, save them in\n-     note_list.  These notes are restored at the end of\n-     schedule_block ().  */\n-  rm_other_notes (head, tail);\n-}\n-\n /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n    previously found among the insns.  Insert them just before HEAD.  */\n rtx\n@@ -2315,11 +2257,9 @@ debug_ready_list (struct ready_list *ready)\n   fprintf (sched_dump, \"\\n\");\n }\n \n-/* Search INSN for REG_SAVE_NOTE note pairs for\n-   NOTE_INSN_EHREGION_{BEG,END}; and convert them back into\n-   NOTEs.  The REG_SAVE_NOTE note following first one is contains the\n-   saved value for NOTE_BLOCK_NUMBER which is useful for\n-   NOTE_INSN_EH_REGION_{BEG,END} NOTEs.  */\n+/* Search INSN for REG_SAVE_NOTE notes and convert them back into insn\n+   NOTEs.  This is used for NOTE_INSN_EPILOGUE_BEG, so that sched-ebb\n+   replaces the epilogue note in the correct basic block.  */\n void\n reemit_notes (rtx insn)\n {"}, {"sha": "b3b7e4e2c00de7e0289d35e60d45556f765b277d", "filename": "gcc/testsuite/gcc.dg/pr42396.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e67271bd6571e2a3c6adc842350571e59b5a1f86/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42396.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e67271bd6571e2a3c6adc842350571e59b5a1f86/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42396.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr42396.c?ref=e67271bd6571e2a3c6adc842350571e59b5a1f86", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g -ftracer -fsched2-use-superblocks\" } */\n+\n+static int i;\n+extern void baz(int);\n+void foo() { i = 3; }\n+void bar() { baz(i ? 2 : 1); }"}]}