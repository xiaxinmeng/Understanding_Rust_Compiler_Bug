{"sha": "081fdda62b19bed707a53c32819a871fcedb29b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgxZmRkYTYyYjE5YmVkNzA3YTUzYzMyODE5YTg3MWZjZWRiMjliNw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2016-05-24T16:57:48Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-05-24T16:57:48Z"}, "message": "tree-ssa-threadbackwards.c (convert_and_register_jump_thread_path): New function, extracted from...\n\n\t* tree-ssa-threadbackwards.c (convert_and_register_jump_thread_path):\n\tNew function, extracted from...\n\t(fsm_find_control_statement_thread_paths): Here.  Use the new function.\n\tAllow simple copies and constant initializations in the SSA chain.\n\nFrom-SVN: r236653", "tree": {"sha": "71e520a8c876336440c0c56d288980d928461073", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71e520a8c876336440c0c56d288980d928461073"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/081fdda62b19bed707a53c32819a871fcedb29b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081fdda62b19bed707a53c32819a871fcedb29b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/081fdda62b19bed707a53c32819a871fcedb29b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081fdda62b19bed707a53c32819a871fcedb29b7/comments", "author": null, "committer": null, "parents": [{"sha": "72f382fbb85a77a75e839077a7df59197799e2f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72f382fbb85a77a75e839077a7df59197799e2f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72f382fbb85a77a75e839077a7df59197799e2f4"}], "stats": {"total": 108, "additions": 75, "deletions": 33}, "files": [{"sha": "9442109e44867c411a13390ed9243e23533f80a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081fdda62b19bed707a53c32819a871fcedb29b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081fdda62b19bed707a53c32819a871fcedb29b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=081fdda62b19bed707a53c32819a871fcedb29b7", "patch": "@@ -1,3 +1,10 @@\n+2016-05-24  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadbackwards.c (convert_and_register_jump_thread_path):\n+\tNew function, extracted from...\n+\t(fsm_find_control_statement_thread_paths): Here.  Use the new function.\n+\tAllow simple copies and constant initializations in the SSA chain.\n+\n 2016-05-24  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/71249"}, {"sha": "4d0fd9cac57da84e5195a34005d4d85806be6ca5", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 68, "deletions": 33, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081fdda62b19bed707a53c32819a871fcedb29b7/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081fdda62b19bed707a53c32819a871fcedb29b7/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=081fdda62b19bed707a53c32819a871fcedb29b7", "patch": "@@ -356,6 +356,44 @@ profitable_jump_thread_path (vec<basic_block, va_gc> *&path,\n   return taken_edge;\n }\n \n+/* PATH is vector of blocks forming a jump threading path in reverse\n+   order.  TAKEN_EDGE is the edge taken from path[0].\n+\n+   Convert that path into the form used by register_jump_thread and\n+   register the path.   */\n+\n+static void\n+convert_and_register_jump_thread_path (vec<basic_block, va_gc> *&path,\n+\t\t\t\t       edge taken_edge)\n+{\n+  vec<jump_thread_edge *> *jump_thread_path = new vec<jump_thread_edge *> ();\n+\n+  /* Record the edges between the blocks in PATH.  */\n+  for (unsigned int j = 0; j < path->length () - 1; j++)\n+    {\n+      basic_block bb1 = (*path)[path->length () - j - 1];\n+      basic_block bb2 = (*path)[path->length () - j - 2];\n+      if (bb1 == bb2)\n+\tcontinue;\n+\n+      edge e = find_edge (bb1, bb2);\n+      gcc_assert (e);\n+      jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);\n+      jump_thread_path->safe_push (x);\n+    }\n+\n+  /* Add the edge taken when the control variable has value ARG.  */\n+  jump_thread_edge *x\n+    = new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n+  jump_thread_path->safe_push (x);\n+\n+  register_jump_thread (jump_thread_path);\n+  --max_threaded_paths;\n+\n+  /* Remove BBI from the path.  */\n+  path->pop ();\n+}\n+\n /* We trace the value of the SSA_NAME NAME back through any phi nodes looking\n    for places where it gets a constant value and save the path.  Stop after\n    having recorded MAX_PATHS jump threading paths.  */\n@@ -377,24 +415,30 @@ fsm_find_control_statement_thread_paths (tree name,\n   if (var_bb == NULL)\n     return;\n \n-  /* For the moment we assume that an SSA chain only contains phi nodes, and\n-     eventually one of the phi arguments will be an integer constant.  In the\n-     future, this could be extended to also handle simple assignments of\n-     arithmetic operations.  */\n+  /* We allow the SSA chain to contains PHIs and simple copies and constant\n+     initializations.  */\n   if (gimple_code (def_stmt) != GIMPLE_PHI\n-      || (gimple_phi_num_args (def_stmt)\n+      && gimple_code (def_stmt) != GIMPLE_ASSIGN)\n+    return;\n+\n+  if (gimple_code (def_stmt) == GIMPLE_PHI\n+      && (gimple_phi_num_args (def_stmt)\n \t  >= (unsigned) PARAM_VALUE (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS)))\n     return;\n \n+  if (gimple_code (def_stmt) == GIMPLE_ASSIGN\n+      && gimple_assign_rhs_code (def_stmt) != INTEGER_CST\n+      && gimple_assign_rhs_code (def_stmt) != SSA_NAME)\n+    return;\n+\n   /* Avoid infinite recursion.  */\n   if (visited_bbs->add (var_bb))\n     return;\n \n-  gphi *phi = as_a <gphi *> (def_stmt);\n   int next_path_length = 0;\n   basic_block last_bb_in_path = path->last ();\n \n-  if (loop_containing_stmt (phi)->header == gimple_bb (phi))\n+  if (loop_containing_stmt (def_stmt)->header == gimple_bb (def_stmt))\n     {\n       /* Do not walk through more than one loop PHI node.  */\n       if (seen_loop_phi)\n@@ -469,9 +513,9 @@ fsm_find_control_statement_thread_paths (tree name,\n \n   /* Iterate over the arguments of PHI.  */\n   unsigned int i;\n-  if (gimple_phi_num_args (phi)\n-      < (unsigned) PARAM_VALUE (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS))\n+  if (gimple_code (def_stmt) == GIMPLE_PHI)\n     {\n+      gphi *phi = as_a <gphi *> (def_stmt);\n       for (i = 0; i < gimple_phi_num_args (phi); i++)\n \t{\n \t  tree arg = gimple_phi_arg_def (phi, i);\n@@ -500,32 +544,23 @@ fsm_find_control_statement_thread_paths (tree name,\n \t     into the canonical form and register it.  */\n \t  edge taken_edge = profitable_jump_thread_path (path, bbi, name, arg);\n \t  if (taken_edge)\n-\t    {\n-\t      vec<jump_thread_edge *> *jump_thread_path\n-\t\t= new vec<jump_thread_edge *> ();\n-\n-\t      /* Record the edges between the blocks in PATH.  */\n-\t      for (unsigned int j = 0; j < path->length () - 1; j++)\n-\t\t{\n-\t\t  edge e = find_edge ((*path)[path->length () - j - 1],\n-\t\t\t\t      (*path)[path->length () - j - 2]);\n-\t\t  gcc_assert (e);\n-\t\t  jump_thread_edge *x\n-\t\t    = new jump_thread_edge (e, EDGE_FSM_THREAD);\n-\t\t  jump_thread_path->safe_push (x);\n-\t\t}\n-\n-\t      /* Add the edge taken when the control variable has value ARG.  */\n-\t      jump_thread_edge *x\n-\t\t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n-\t      jump_thread_path->safe_push (x);\n+\t    convert_and_register_jump_thread_path (path, taken_edge);\n+\t}\n+    }\n+  else if (gimple_code (def_stmt) == GIMPLE_ASSIGN)\n+    {\n+      tree arg = gimple_assign_rhs1 (def_stmt);\n \n-\t      register_jump_thread (jump_thread_path);\n-\t      --max_threaded_paths;\n+      if (TREE_CODE (arg) == SSA_NAME)\n+\tfsm_find_control_statement_thread_paths (arg, visited_bbs,\n+\t\t\t\t\t\t path, seen_loop_phi);\n \n-\t      /* Remove BBI from the path.  */\n-\t      path->pop ();\n-\t    }\n+      else\n+\t{\n+\t  edge taken_edge = profitable_jump_thread_path (path, var_bb,\n+\t\t\t\t\t\t     name, arg);\n+\t  if (taken_edge)\n+\t    convert_and_register_jump_thread_path (path, taken_edge);\n \t}\n     }\n "}]}