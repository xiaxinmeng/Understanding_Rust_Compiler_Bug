{"sha": "b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0NmM1ZGM2NzhmMzRhN2MyZTIyMGRjZWNiMmNkZTY3NzllNDdjNA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2002-12-28T14:38:38Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2002-12-28T14:38:38Z"}, "message": "Remove traditional C constructs 3/n.\n\n\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n\tbuild_up_reference, warn_ref_binding, convert_to_reference,\n\tconvert_from_reference, convert_lvalue, cp_convert, ocp_convert,\n\tconvert_to_void, convert, convert_force, build_type_conversion,\n\tbuild_expr_type_conversion, type_promotes_to,\n\tperform_qualification_conversions): Use C90 prototyping style.\n\t* decl2.c (grok_array_decl): Use boolean constant.\n\t(delete_sanity): Likewise.\n\t* typeck.c (build_unary_op): Likewise.\n\t* semantics.c (finish_switch_cond): Likewise.\n\t* parser.c (cp_parser_direct_new_declarator): Likewise.\n\t* init.c (build_new): Likewise.\n\nFrom-SVN: r60574", "tree": {"sha": "798389e1c9e87736c3b030d05961a50cd04312e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/798389e1c9e87736c3b030d05961a50cd04312e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9b21a05ce3adb28478fad5ab27cfc8c6d7661a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b21a05ce3adb28478fad5ab27cfc8c6d7661a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b21a05ce3adb28478fad5ab27cfc8c6d7661a9"}], "stats": {"total": 190, "additions": 90, "deletions": 100}, "files": [{"sha": "a2651e84f77cf88b800fc81093360df287fce3ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -1,3 +1,19 @@\n+2002-12-28  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tRemove traditional C constructs 3/n.\n+\t* cvt.c (cp_convert_to_pointer, convert_to_pointer_force,\n+\tbuild_up_reference, warn_ref_binding, convert_to_reference,\n+\tconvert_from_reference, convert_lvalue, cp_convert, ocp_convert,\n+\tconvert_to_void, convert, convert_force, build_type_conversion,\n+\tbuild_expr_type_conversion, type_promotes_to,\n+\tperform_qualification_conversions): Use C90 prototyping style.\n+\t* decl2.c (grok_array_decl): Use boolean constant.\n+\t(delete_sanity): Likewise.\n+\t* typeck.c (build_unary_op): Likewise.\n+\t* semantics.c (finish_switch_cond): Likewise.\n+\t* parser.c (cp_parser_direct_new_declarator): Likewise.\n+\t* init.c (build_new): Likewise.\n+\n 2002-12-27  Mark Mitchell  <mark@codesourcery.com>\n \n \t* Make-lang.in (po-generated): Remove parse.c.\n@@ -196,29 +212,30 @@\n \n 2002-12-23  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n-\t* call.c (tourney, build_field_call, equal_functions, joust) \n-\t(compare_ics, build_over_call, build_java_interface_fn_ref) \n-\t(convert_like_real, op_error, build_object_call, resolve_args) \n-\t(build_vfield_ref, check_dtor_name, build_scoped_method_call) \n-\t(build_addr_func, build_call, build_method_call, null_ptr_cst_p) \n-\t(sufficient_parms_p, build_conv, non_reference, strip_top_quals) \n-\t(standard_conversion, reference_related_p) \n-\t(reference_compatible_p, convert_class_to_reference) \n-\t(direct_reference_binding, reference_binding) \n-\t(implicit_conversion, is_complete, promoted_arithmetic_type_p) \n-\t(add_template_conv_candidate, any_viable, any_strictly_viable) \n-\t(build_this, splice_viable, print_z_candidates) \n-\t(build_user_type_conversion, build_new_function_call) \n-\t(conditional_conversion, build_conditional_expr, build_new_op) \n-\t(build_op_delete_call, enforce_access, call_builtin_trap) \n-\t(convert_arg_to_ellipsis, build_x_va_arg, cxx_type_promotes_to) \n-\t(convert_default_arg, type_passed_as, convert_for_arg_passing) \n-\t(in_charge_arg_for_name, is_properly_derived_from) \n-\t(maybe_handle_implicit_object, maybe_handle_ref_bind) \n-\t(source_type, add_warning, can_convert, can_convert_arg) \n-\t(perform_implicit_conversion, can_convert_arg_bad) \n-\t(initialize_reference, add_conv_candidate) \n-\t(add_template_candidate_real, add_template_candidate): Ansify.\n+\tRemove traditional C constructs 2/n.\n+\t* call.c (tourney, build_field_call, equal_functions, joust,\n+\tcompare_ics, build_over_call, build_java_interface_fn_ref,\n+\tconvert_like_real, op_error, build_object_call, resolve_args,\n+\tbuild_vfield_ref, check_dtor_name, build_scoped_method_call,\n+\tbuild_addr_func, build_call, build_method_call, null_ptr_cst_p,\n+\tsufficient_parms_p, build_conv, non_reference, strip_top_quals,\n+\tstandard_conversion, reference_related_p,\n+\treference_compatible_p, convert_class_to_reference,\n+\tdirect_reference_binding, reference_binding,\n+\t,implicit_conversion, is_complete, promoted_arithmetic_type_p,\n+\tadd_template_conv_candidate, any_viable, any_strictly_viable,\n+\tbuild_this, splice_viable, print_z_candidates,\n+\tbuild_user_type_conversion, build_new_function_call,\n+\tconditional_conversion, build_conditional_expr, build_new_op,\n+\tbuild_op_delete_call, enforce_access, call_builtin_trap,\n+\tconvert_arg_to_ellipsis, build_x_va_arg, cxx_type_promotes_to,\n+\tconvert_default_arg, type_passed_as, convert_for_arg_passing,\n+\tin_charge_arg_for_name, is_properly_derived_from,\n+\tmaybe_handle_implicit_object, maybe_handle_ref_bind,\n+\tsource_type, add_warning, can_convert, can_convert_arg,\n+\tperform_implicit_conversion, can_convert_arg_bad,\n+\tinitialize_reference, add_conv_candidate,\n+\tadd_template_candidate_real, add_template_candidate): Ansify.\n \n 2002-12-22  Nathan Sidwell  <nathan@codesourcery.com>\n "}, {"sha": "7ce3a3c333d79626a0eee7e95d1e2a08fe8d6aec", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -3641,17 +3641,17 @@ extern tree get_vtt_name                        PARAMS ((tree));\n extern tree get_primary_binfo                   PARAMS ((tree));\n \n /* in cvt.c */\n-extern tree convert_to_reference\t\tPARAMS ((tree, tree, int, int, tree));\n-extern tree convert_from_reference\t\tPARAMS ((tree));\n-extern tree convert_lvalue\t\t\tPARAMS ((tree, tree));\n-extern tree ocp_convert\t\t\t\tPARAMS ((tree, tree, int, int));\n-extern tree cp_convert\t\t\t\tPARAMS ((tree, tree));\n-extern tree convert_to_void\t\t\tPARAMS ((tree, const char */*implicit context*/));\n-extern tree convert_force\t\t\tPARAMS ((tree, tree, int));\n-extern tree build_type_conversion\t\tPARAMS ((tree, tree, int));\n-extern tree build_expr_type_conversion\t\tPARAMS ((int, tree, int));\n-extern tree type_promotes_to\t\t\tPARAMS ((tree));\n-extern tree perform_qualification_conversions   PARAMS ((tree, tree));\n+extern tree convert_to_reference (tree, tree, int, int, tree);\n+extern tree convert_from_reference (tree);\n+extern tree convert_lvalue (tree, tree);\n+extern tree ocp_convert (tree, tree, int, int);\n+extern tree cp_convert (tree, tree);\n+extern tree convert_to_void (tree, const char */*implicit context*/);\n+extern tree convert_force (tree, tree, int);\n+extern tree build_type_conversion (tree, tree, int);\n+extern tree build_expr_type_conversion (int, tree, bool);\n+extern tree type_promotes_to (tree);\n+extern tree perform_qualification_conversions (tree, tree);\n extern void clone_function_decl                 PARAMS ((tree, int));\n extern void adjust_clone_args\t\t\tPARAMS ((tree));\n "}, {"sha": "9f2da200f9a73765827fcf3e3d18676295476704", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 25, "deletions": 52, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -37,10 +37,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"toplev.h\"\n #include \"decl.h\"\n \n-static tree cp_convert_to_pointer PARAMS ((tree, tree, int));\n-static tree convert_to_pointer_force PARAMS ((tree, tree));\n-static tree build_up_reference PARAMS ((tree, tree, int, tree));\n-static void warn_ref_binding PARAMS ((tree, tree, tree));\n+static tree cp_convert_to_pointer (tree, tree, bool);\n+static tree convert_to_pointer_force (tree, tree);\n+static tree build_up_reference (tree, tree, int, tree);\n+static void warn_ref_binding (tree, tree, tree);\n \n /* Change of width--truncation and extension of integers or reals--\n    is represented with NOP_EXPR.  Proper functioning of many things\n@@ -74,9 +74,7 @@ static void warn_ref_binding PARAMS ((tree, tree, tree));\n    but not static_cast).  */\n \n static tree\n-cp_convert_to_pointer (type, expr, force)\n-     tree type, expr;\n-     int force;\n+cp_convert_to_pointer (tree type, tree expr, bool force)\n {\n   register tree intype = TREE_TYPE (expr);\n   register enum tree_code form;\n@@ -92,7 +90,7 @@ cp_convert_to_pointer (type, expr, force)\n \t  return error_mark_node;\n \t}\n \n-      rval = build_type_conversion (type, expr, 1);\n+      rval = build_type_conversion (type, expr, true);\n       if (rval)\n \t{\n \t  if (rval == error_mark_node)\n@@ -292,8 +290,7 @@ cp_convert_to_pointer (type, expr, force)\n    (such as conversion from sub-type to private super-type).  */\n \n static tree\n-convert_to_pointer_force (type, expr)\n-     tree type, expr;\n+convert_to_pointer_force (tree type, tree expr)\n {\n   register tree intype = TREE_TYPE (expr);\n   register enum tree_code form = TREE_CODE (intype);\n@@ -340,7 +337,7 @@ convert_to_pointer_force (type, expr)\n \t}\n     }\n \n-  return cp_convert_to_pointer (type, expr, 1);\n+  return cp_convert_to_pointer (type, expr, true);\n }\n \n /* We are passing something to a function which requires a reference.\n@@ -352,9 +349,7 @@ convert_to_pointer_force (type, expr)\n      If DIRECT_BIND is set, DECL is the reference we're binding to.  */\n \n static tree\n-build_up_reference (type, arg, flags, decl)\n-     tree type, arg, decl;\n-     int flags;\n+build_up_reference (tree type, tree arg, int flags, tree decl)\n {\n   tree rval;\n   tree argtype = TREE_TYPE (arg);\n@@ -441,8 +436,7 @@ build_up_reference (type, arg, flags, decl)\n    non-volatile const type.  */\n \n static void\n-warn_ref_binding (reftype, intype, decl)\n-     tree reftype, intype, decl;\n+warn_ref_binding (tree reftype, tree intype, tree decl)\n {\n   tree ttl = TREE_TYPE (reftype);\n   \n@@ -471,10 +465,8 @@ warn_ref_binding (reftype, intype, decl)\n    we know it's an initialization.  */\n \n tree\n-convert_to_reference (reftype, expr, convtype, flags, decl)\n-     tree reftype, expr;\n-     int convtype, flags;\n-     tree decl;\n+convert_to_reference (tree reftype, tree expr, int convtype,\n+                      int flags, tree decl)\n {\n   register tree type = TYPE_MAIN_VARIANT (TREE_TYPE (reftype));\n   register tree intype;\n@@ -591,8 +583,7 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n    way down to its lowest form.  */\n \n tree\n-convert_from_reference (val)\n-     tree val;\n+convert_from_reference (tree val)\n {\n   tree type = TREE_TYPE (val);\n \n@@ -607,8 +598,7 @@ convert_from_reference (val)\n    preserving cv-qualification.  */\n \n tree\n-convert_lvalue (totype, expr)\n-     tree totype, expr;\n+convert_lvalue (tree totype, tree expr)\n {\n   totype = cp_build_qualified_type (totype, TYPE_QUALS (TREE_TYPE (expr)));\n   totype = build_reference_type (totype);\n@@ -620,8 +610,7 @@ convert_lvalue (totype, expr)\n /* C++ conversions, preference to static cast conversions.  */\n \n tree\n-cp_convert (type, expr)\n-     tree type, expr;\n+cp_convert (tree type, tree expr)\n {\n   return ocp_convert (type, expr, CONV_OLD_CONVERT, LOOKUP_NORMAL);\n }\n@@ -631,9 +620,7 @@ cp_convert (type, expr)\n    FLAGS indicates how we should behave.  */\n \n tree\n-ocp_convert (type, expr, convtype, flags)\n-     tree type, expr;\n-     int convtype, flags;\n+ocp_convert (tree type, tree expr, int convtype, int flags)\n {\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n@@ -732,7 +719,7 @@ ocp_convert (type, expr, convtype, flags)\n     }\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE\n       || TYPE_PTRMEMFUNC_P (type))\n-    return fold (cp_convert_to_pointer (type, e, 0));\n+    return fold (cp_convert_to_pointer (type, e, false));\n   if (code == VECTOR_TYPE)\n     return fold (convert_to_vector (type, e));\n   if (code == REAL_TYPE || code == COMPLEX_TYPE)\n@@ -817,9 +804,7 @@ ocp_convert (type, expr, convtype, flags)\n    IMPLICIT is tells us the context of an implicit void conversion.  */\n \n tree\n-convert_to_void (expr, implicit)\n-     tree expr;\n-     const char *implicit;\n+convert_to_void (tree expr, const char *implicit)\n {\n   if (expr == error_mark_node \n       || TREE_TYPE (expr) == error_mark_node)\n@@ -957,8 +942,7 @@ convert_to_void (expr, implicit)\n    do a little bit more work.  */\n \n tree\n-convert (type, expr)\n-     tree type, expr;\n+convert (tree type, tree expr)\n {\n   tree intype;\n \n@@ -982,10 +966,7 @@ convert (type, expr)\n    (such as conversion from sub-type to private super-type).  */\n \n tree\n-convert_force (type, expr, convtype)\n-     tree type;\n-     tree expr;\n-     int convtype;\n+convert_force (tree type, tree expr, int convtype)\n {\n   register tree e = expr;\n   register enum tree_code code = TREE_CODE (type);\n@@ -1032,9 +1013,7 @@ convert_force (type, expr, convtype)\n    (jason 8/9/95)  */\n \n tree\n-build_type_conversion (xtype, expr, for_sure)\n-     tree xtype, expr;\n-     int for_sure;\n+build_type_conversion (tree xtype, tree expr, int for_sure)\n {\n   /* C++: check to see if we can convert this aggregate type\n      into the required type.  */\n@@ -1044,14 +1023,11 @@ build_type_conversion (xtype, expr, for_sure)\n \n /* Convert the given EXPR to one of a group of types suitable for use in an\n    expression.  DESIRES is a combination of various WANT_* flags (q.v.)\n-   which indicates which types are suitable.  If COMPLAIN is 1, complain\n+   which indicates which types are suitable.  If COMPLAIN is true, complain\n    about ambiguity; otherwise, the caller will deal with it.  */\n \n tree\n-build_expr_type_conversion (desires, expr, complain)\n-     int desires;\n-     tree expr;\n-     int complain;\n+build_expr_type_conversion (int desires, tree expr, bool complain)\n {\n   tree basetype = TREE_TYPE (expr);\n   tree conv = NULL_TREE;\n@@ -1162,8 +1138,7 @@ build_expr_type_conversion (desires, expr, complain)\n /* Implements integral promotion (4.1) and float->double promotion.  */\n \n tree\n-type_promotes_to (type)\n-     tree type;\n+type_promotes_to (tree type)\n {\n   int type_quals;\n \n@@ -1217,9 +1192,7 @@ type_promotes_to (type)\n    the conversion was impossible.  */\n \n tree \n-perform_qualification_conversions (type, expr)\n-     tree type;\n-     tree expr;\n+perform_qualification_conversions (tree type, tree expr)\n {\n   if (TREE_CODE (type) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE"}, {"sha": "2ca89c196e249480362cdcd23dcb29f05cc0e47f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -448,15 +448,15 @@ grok_array_decl (array_expr, index_exp)\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     p1 = array_expr;\n   else\n-    p1 = build_expr_type_conversion (WANT_POINTER, array_expr, 0);\n+    p1 = build_expr_type_conversion (WANT_POINTER, array_expr, false);\n \n   if (TREE_CODE (TREE_TYPE (index_exp)) == ARRAY_TYPE)\n     p2 = index_exp;\n   else\n-    p2 = build_expr_type_conversion (WANT_POINTER, index_exp, 0);\n+    p2 = build_expr_type_conversion (WANT_POINTER, index_exp, false);\n \n-  i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr, 0);\n-  i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, 0);\n+  i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr, false);\n+  i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, false);\n \n   if ((p1 && i2) && (i1 && p2))\n     error (\"ambiguous conversion for array subscript\");\n@@ -511,7 +511,7 @@ delete_sanity (exp, size, doing_vec, use_global_delete)\n     exp = resolve_offset_ref (exp);\n   exp = convert_from_reference (exp);\n   t = stabilize_reference (exp);\n-  t = build_expr_type_conversion (WANT_POINTER, t, 1);\n+  t = build_expr_type_conversion (WANT_POINTER, t, true);\n \n   if (t == NULL_TREE || t == error_mark_node)\n     {"}, {"sha": "629271574b76176b93220c7974a5c8ab2630c1b9", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -1958,7 +1958,7 @@ build_new (placement, decl, init, use_global_new)\n \t      else\n \t\t{\n \t\t  if (build_expr_type_conversion (WANT_INT | WANT_ENUM, \n-\t\t\t\t\t\t  this_nelts, 0)\n+\t\t\t\t\t\t  this_nelts, false)\n \t\t      == NULL_TREE)\n \t\t    pedwarn (\"size in array new must have integral type\");\n "}, {"sha": "00a5a08c5bb5b776f2358625fc31a2f791a79971", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -4863,7 +4863,7 @@ cp_parser_direct_new_declarator (parser)\n \t      expression \n \t\t= build_expr_type_conversion (WANT_INT | WANT_ENUM,\n \t\t\t\t\t      expression,\n-\t\t\t\t\t      /*complain=*/1);\n+\t\t\t\t\t      /*complain=*/true);\n \t      if (!expression)\n \t\t{\n \t\t  error (\"expression in new-declarator must have integral or enumeration type\");"}, {"sha": "e4624e38b1f127d9490b7fe2559ee0098d874fba", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -553,7 +553,7 @@ finish_switch_cond (cond, switch_stmt)\n       tree index;\n \n       /* Convert the condition to an integer or enumeration type.  */\n-      cond = build_expr_type_conversion (WANT_INT | WANT_ENUM, cond, 1);\n+      cond = build_expr_type_conversion (WANT_INT | WANT_ENUM, cond, true);\n       if (cond == NULL_TREE)\n \t{\n \t  error (\"switch quantity not an integer\");"}, {"sha": "dabf347f37b9e2de8c495d08d34b4fe513e28dc1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b746c5dc678f34a7c2e220dcecb2cde6779e47c4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b746c5dc678f34a7c2e220dcecb2cde6779e47c4", "patch": "@@ -3951,7 +3951,7 @@ build_unary_op (code, xarg, noconvert)\n \t is enough to prevent anybody from looking inside for\n \t associativity, but won't generate any code.  */\n       if (!(arg = build_expr_type_conversion\n-\t    (WANT_ARITH | WANT_ENUM | WANT_POINTER, arg, 1)))\n+\t    (WANT_ARITH | WANT_ENUM | WANT_POINTER, arg, true)))\n \terrstring = \"wrong type argument to unary plus\";\n       else\n \t{\n@@ -3963,7 +3963,7 @@ build_unary_op (code, xarg, noconvert)\n       break;\n \n     case NEGATE_EXPR:\n-      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, 1)))\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n \terrstring = \"wrong type argument to unary minus\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n@@ -3977,22 +3977,22 @@ build_unary_op (code, xarg, noconvert)\n \t    arg = default_conversion (arg);\n \t}\n       else if (!(arg = build_expr_type_conversion (WANT_INT | WANT_ENUM,\n-\t\t\t\t\t\t   arg, 1)))\n+\t\t\t\t\t\t   arg, true)))\n \terrstring = \"wrong type argument to bit-complement\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case ABS_EXPR:\n-      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, 1)))\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n \terrstring = \"wrong type argument to abs\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case CONJ_EXPR:\n       /* Conjugating a real value is a no-op, but allow it anyway.  */\n-      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, 1)))\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, true)))\n \terrstring = \"wrong type argument to conjugation\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n@@ -4052,7 +4052,7 @@ build_unary_op (code, xarg, noconvert)\n       /* Report invalid types.  */\n \n       if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_POINTER,\n-\t\t\t\t\t      arg, 1)))\n+\t\t\t\t\t      arg, true)))\n \t{\n \t  if (code == PREINCREMENT_EXPR)\n \t    errstring =\"no pre-increment operator for type\";"}]}