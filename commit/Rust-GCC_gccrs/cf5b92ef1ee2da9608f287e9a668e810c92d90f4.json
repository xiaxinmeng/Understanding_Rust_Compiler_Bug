{"sha": "cf5b92ef1ee2da9608f287e9a668e810c92d90f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Y1YjkyZWYxZWUyZGE5NjA4ZjI4N2U5YTY2OGU4MTBjOTJkOTBmNA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-11-20T09:05:08Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-11-20T09:05:08Z"}, "message": "re PR tree-optimization/52272 (Performance regression of 410.bwaves on x86.)\n\n\n\tPR tree-optimization/52272\n\t* tree-ssa-loop-ivopts.c (struct iv_common_cand): New struct.\n\t(struct iv_common_cand_hasher): New struct.\n\t(iv_common_cand_hasher::hash): New function.\n\t(iv_common_cand_hasher::equal): New function.\n\t(struct ivopts_data): New fields, iv_common_cand_tab and\n\tiv_common_cands.\n\t(tree_ssa_iv_optimize_init): Initialize above fields.\n\t(record_common_cand, common_cand_cmp): New functions.\n\t(add_iv_candidate_derived_from_uses): New function.\n\t(add_iv_candidate_for_use): Record iv_common_cands derived from\n\tiv use in hash table, instead of adding candidates directly.\n\t(add_iv_candidate_for_uses): Call add_iv_candidate_derived_from_uses.\n\t(record_important_candidates): Add important candidates to iv uses'\n\trelated_cands.  Always keep related_cands for future use.\n\t(try_add_cand_for): Use iv uses' related_cands.\n\t(free_loop_data, tree_ssa_iv_optimize_finalize): Release new fields\n\tin struct ivopts_data, iv_common_cand_tab and iv_common_cands.\n\nFrom-SVN: r230647", "tree": {"sha": "a0eaeaabd9ad7f71b77adb0cf347dee329391c0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0eaeaabd9ad7f71b77adb0cf347dee329391c0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf5b92ef1ee2da9608f287e9a668e810c92d90f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5b92ef1ee2da9608f287e9a668e810c92d90f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf5b92ef1ee2da9608f287e9a668e810c92d90f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf5b92ef1ee2da9608f287e9a668e810c92d90f4/comments", "author": null, "committer": null, "parents": [{"sha": "ec5a0fe0422d6f472d75528a14bd22511914e240", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec5a0fe0422d6f472d75528a14bd22511914e240", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec5a0fe0422d6f472d75528a14bd22511914e240"}], "stats": {"total": 249, "additions": 220, "deletions": 29}, "files": [{"sha": "01fe78f167d9531d9154c3d5d025cb88b762df7d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5b92ef1ee2da9608f287e9a668e810c92d90f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5b92ef1ee2da9608f287e9a668e810c92d90f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf5b92ef1ee2da9608f287e9a668e810c92d90f4", "patch": "@@ -1,3 +1,24 @@\n+2015-11-20  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/52272\n+\t* tree-ssa-loop-ivopts.c (struct iv_common_cand): New struct.\n+\t(struct iv_common_cand_hasher): New struct.\n+\t(iv_common_cand_hasher::hash): New function.\n+\t(iv_common_cand_hasher::equal): New function.\n+\t(struct ivopts_data): New fields, iv_common_cand_tab and\n+\tiv_common_cands.\n+\t(tree_ssa_iv_optimize_init): Initialize above fields.\n+\t(record_common_cand, common_cand_cmp): New functions.\n+\t(add_iv_candidate_derived_from_uses): New function.\n+\t(add_iv_candidate_for_use): Record iv_common_cands derived from\n+\tiv use in hash table, instead of adding candidates directly.\n+\t(add_iv_candidate_for_uses): Call add_iv_candidate_derived_from_uses.\n+\t(record_important_candidates): Add important candidates to iv uses'\n+\trelated_cands.  Always keep related_cands for future use.\n+\t(try_add_cand_for): Use iv uses' related_cands.\n+\t(free_loop_data, tree_ssa_iv_optimize_finalize): Release new fields\n+\tin struct ivopts_data, iv_common_cand_tab and iv_common_cands.\n+\n 2015-11-20  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (\"bswaphi2\"): New pattern."}, {"sha": "98dc4518fa375d8270ff58097efa52d96d19694c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 199, "deletions": 29, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf5b92ef1ee2da9608f287e9a668e810c92d90f4/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf5b92ef1ee2da9608f287e9a668e810c92d90f4/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=cf5b92ef1ee2da9608f287e9a668e810c92d90f4", "patch": "@@ -247,6 +247,45 @@ struct iv_cand\n \t\t\t   smaller type.  */\n };\n \n+/* Hashtable entry for common candidate derived from iv uses.  */\n+struct iv_common_cand\n+{\n+  tree base;\n+  tree step;\n+  /* IV uses from which this common candidate is derived.  */\n+  vec<iv_use *> uses;\n+  hashval_t hash;\n+};\n+\n+/* Hashtable helpers.  */\n+\n+struct iv_common_cand_hasher : free_ptr_hash <iv_common_cand>\n+{\n+  static inline hashval_t hash (const iv_common_cand *);\n+  static inline bool equal (const iv_common_cand *, const iv_common_cand *);\n+};\n+\n+/* Hash function for possible common candidates.  */\n+\n+inline hashval_t\n+iv_common_cand_hasher::hash (const iv_common_cand *ccand)\n+{\n+  return ccand->hash;\n+}\n+\n+/* Hash table equality function for common candidates.  */\n+\n+inline bool\n+iv_common_cand_hasher::equal (const iv_common_cand *ccand1,\n+\t\t\t      const iv_common_cand *ccand2)\n+{\n+  return (ccand1->hash == ccand2->hash\n+\t  && operand_equal_p (ccand1->base, ccand2->base, 0)\n+\t  && operand_equal_p (ccand1->step, ccand2->step, 0)\n+\t  && (TYPE_PRECISION (TREE_TYPE (ccand1->base))\n+\t      == TYPE_PRECISION (TREE_TYPE (ccand2->base))));\n+}\n+\n /* Loop invariant expression hashtable entry.  */\n struct iv_inv_expr_ent\n {\n@@ -255,8 +294,6 @@ struct iv_inv_expr_ent\n   hashval_t hash;\n };\n \n-/* The data used by the induction variable optimizations.  */\n-\n /* Hashtable helpers.  */\n \n struct iv_inv_expr_hasher : free_ptr_hash <iv_inv_expr_ent>\n@@ -323,6 +360,12 @@ struct ivopts_data\n   /* Cache used by tree_to_aff_combination_expand.  */\n   hash_map<tree, name_expansion *> *name_expansion_cache;\n \n+  /* The hashtable of common candidates derived from iv uses.  */\n+  hash_table<iv_common_cand_hasher> *iv_common_cand_tab;\n+\n+  /* The common candidates.  */\n+  vec<iv_common_cand *> iv_common_cands;\n+\n   /* The maximum invariant id.  */\n   unsigned max_inv_id;\n \n@@ -894,6 +937,8 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n   data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);\n   data->inv_expr_id = 0;\n   data->name_expansion_cache = NULL;\n+  data->iv_common_cand_tab = new hash_table<iv_common_cand_hasher> (10);\n+  data->iv_common_cands.create (20);\n   decl_rtl_to_reset.create (20);\n   gcc_obstack_init (&data->iv_obstack);\n }\n@@ -3063,6 +3108,96 @@ add_iv_candidate_for_bivs (struct ivopts_data *data)\n     }\n }\n \n+/* Record common candidate {BASE, STEP} derived from USE in hashtable.  */\n+\n+static void\n+record_common_cand (struct ivopts_data *data, tree base,\n+\t\t    tree step, struct iv_use *use)\n+{\n+  struct iv_common_cand ent;\n+  struct iv_common_cand **slot;\n+\n+  gcc_assert (use != NULL);\n+\n+  ent.base = base;\n+  ent.step = step;\n+  ent.hash = iterative_hash_expr (base, 0);\n+  ent.hash = iterative_hash_expr (step, ent.hash);\n+\n+  slot = data->iv_common_cand_tab->find_slot (&ent, INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = XNEW (struct iv_common_cand);\n+      (*slot)->base = base;\n+      (*slot)->step = step;\n+      (*slot)->uses.create (8);\n+      (*slot)->hash = ent.hash;\n+      data->iv_common_cands.safe_push ((*slot));\n+    }\n+  (*slot)->uses.safe_push (use);\n+  return;\n+}\n+\n+/* Comparison function used to sort common candidates.  */\n+\n+static int\n+common_cand_cmp (const void *p1, const void *p2)\n+{\n+  unsigned n1, n2;\n+  const struct iv_common_cand *const *const ccand1\n+    = (const struct iv_common_cand *const *)p1;\n+  const struct iv_common_cand *const *const ccand2\n+    = (const struct iv_common_cand *const *)p2;\n+\n+  n1 = (*ccand1)->uses.length ();\n+  n2 = (*ccand2)->uses.length ();\n+  return n2 - n1;\n+}\n+\n+/* Adds IV candidates based on common candidated recorded.  */\n+\n+static void\n+add_iv_candidate_derived_from_uses (struct ivopts_data *data)\n+{\n+  unsigned i, j;\n+  struct iv_cand *cand_1, *cand_2;\n+\n+  data->iv_common_cands.qsort (common_cand_cmp);\n+  for (i = 0; i < data->iv_common_cands.length (); i++)\n+    {\n+      struct iv_common_cand *ptr = data->iv_common_cands[i];\n+\n+      /* Only add IV candidate if it's derived from multiple uses.  */\n+      if (ptr->uses.length () <= 1)\n+\tbreak;\n+\n+      cand_1 = NULL;\n+      cand_2 = NULL;\n+      if (ip_normal_pos (data->current_loop))\n+\tcand_1 = add_candidate_1 (data, ptr->base, ptr->step,\n+\t\t\t\t  false, IP_NORMAL, NULL, NULL);\n+\n+      if (ip_end_pos (data->current_loop)\n+\t  && allow_ip_end_pos_p (data->current_loop))\n+\tcand_2 = add_candidate_1 (data, ptr->base, ptr->step,\n+\t\t\t\t  false, IP_END, NULL, NULL);\n+\n+      /* Bind deriving uses and the new candidates.  */\n+      for (j = 0; j < ptr->uses.length (); j++)\n+\t{\n+\t  struct iv_use *use = ptr->uses[j];\n+\t  if (cand_1)\n+\t    bitmap_set_bit (use->related_cands, cand_1->id);\n+\t  if (cand_2)\n+\t    bitmap_set_bit (use->related_cands, cand_2->id);\n+\t}\n+    }\n+\n+  /* Release data since it is useless from this point.  */\n+  data->iv_common_cand_tab->empty ();\n+  data->iv_common_cands.truncate (0);\n+}\n+\n /* Adds candidates based on the value of USE's iv.  */\n \n static void\n@@ -3075,19 +3210,59 @@ add_iv_candidate_for_use (struct ivopts_data *data, struct iv_use *use)\n \n   add_candidate (data, iv->base, iv->step, false, use);\n \n-  /* The same, but with initial value zero.  Make such variable important,\n-     since it is generic enough so that possibly many uses may be based\n-     on it.  */\n+  /* Record common candidate for use in case it can be shared by others.  */\n+  record_common_cand (data, iv->base, iv->step, use);\n+\n+  /* Record common candidate with initial value zero.  */\n   basetype = TREE_TYPE (iv->base);\n   if (POINTER_TYPE_P (basetype))\n     basetype = sizetype;\n-  add_candidate (data, build_int_cst (basetype, 0), iv->step, true, use);\n+  record_common_cand (data, build_int_cst (basetype, 0), iv->step, use);\n+\n+  /* Record common candidate with constant offset stripped in base.  */\n+    {\n+      base = strip_offset (iv->base, &offset);\n+      if (offset || base != iv->base)\n+\trecord_common_cand (data, base, iv->step, use);\n+    }\n+\n+  /* Record common candidate with base_object removed in base.  */\n+  if (iv->base_object != NULL)\n+    {\n+      unsigned i;\n+      aff_tree aff_base;\n+      tree step, base_object = iv->base_object;\n \n-  /* Third, try removing the constant offset.  Make sure to even\n-     add a candidate for &a[0] vs. (T *)&a.  */\n-  base = strip_offset (iv->base, &offset);\n-  if (offset || base != iv->base)\n-    add_candidate (data, base, iv->step, false, use);\n+      base = iv->base;\n+      step = iv->step;\n+      STRIP_NOPS (base);\n+      STRIP_NOPS (step);\n+      STRIP_NOPS (base_object);\n+      tree_to_aff_combination (base, TREE_TYPE (base), &aff_base);\n+      for (i = 0; i < aff_base.n; i++)\n+\t{\n+\t  if (aff_base.elts[i].coef != 1)\n+\t    continue;\n+\n+\t  if (operand_equal_p (aff_base.elts[i].val, base_object, 0))\n+\t    break;\n+\t}\n+      if (i < aff_base.n)\n+\t{\n+\t  aff_combination_remove_elt (&aff_base, i);\n+\t  base = aff_combination_to_tree (&aff_base);\n+\t  basetype = TREE_TYPE (base);\n+\t  if (POINTER_TYPE_P (basetype))\n+\t    basetype = sizetype;\n+\n+\t  step = fold_convert (basetype, step);\n+\t  record_common_cand (data, base, step, use);\n+\t  /* Also record common candidate with offset stripped.  */\n+\t  base = strip_offset (base, &offset);\n+\t  if (offset)\n+\t    record_common_cand (data, base, step, use);\n+\t}\n+    }\n \n   /* At last, add auto-incremental candidates.  Make such variables\n      important since other iv uses with same base object may be based\n@@ -3123,10 +3298,10 @@ add_iv_candidate_for_uses (struct ivopts_data *data)\n \t  gcc_unreachable ();\n \t}\n     }\n+  add_iv_candidate_derived_from_uses (data);\n }\n \n-/* Record important candidates and add them to related_cands bitmaps\n-   if needed.  */\n+/* Record important candidates and add them to related_cands bitmaps.  */\n \n static void\n record_important_candidates (struct ivopts_data *data)\n@@ -3145,22 +3320,11 @@ record_important_candidates (struct ivopts_data *data)\n   data->consider_all_candidates = (n_iv_cands (data)\n \t\t\t\t   <= CONSIDER_ALL_CANDIDATES_BOUND);\n \n-  if (data->consider_all_candidates)\n-    {\n-      /* We will not need \"related_cands\" bitmaps in this case,\n-\t so release them to decrease peak memory consumption.  */\n-      for (i = 0; i < n_iv_uses (data); i++)\n-\t{\n-\t  use = iv_use (data, i);\n-\t  BITMAP_FREE (use->related_cands);\n-\t}\n-    }\n-  else\n+  /* Add important candidates to uses' related_cands bitmaps.  */\n+  for (i = 0; i < n_iv_uses (data); i++)\n     {\n-      /* Add important candidates to the related_cands bitmaps.  */\n-      for (i = 0; i < n_iv_uses (data); i++)\n-\tbitmap_ior_into (iv_use (data, i)->related_cands,\n-\t\t\t data->important_candidates);\n+      use = iv_use (data, i);\n+      bitmap_ior_into (use->related_cands, data->important_candidates);\n     }\n }\n \n@@ -6532,7 +6696,7 @@ try_add_cand_for (struct ivopts_data *data, struct iv_ca *ivs,\n      too many ivs.  The approach from few ivs to more seems more likely to be\n      successful -- starting from few ivs, replacing an expensive use by a\n      specific iv should always be a win.  */\n-  EXECUTE_IF_SET_IN_BITMAP (data->important_candidates, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, i, bi)\n     {\n       cand = iv_cand (data, i);\n \n@@ -7441,6 +7605,9 @@ free_loop_data (struct ivopts_data *data)\n \n   data->inv_expr_tab->empty ();\n   data->inv_expr_id = 0;\n+\n+  data->iv_common_cand_tab->empty ();\n+  data->iv_common_cands.truncate (0);\n }\n \n /* Finalizes data structures used by the iv optimization pass.  LOOPS is the\n@@ -7460,6 +7627,9 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   delete data->inv_expr_tab;\n   data->inv_expr_tab = NULL;\n   free_affine_expand_cache (&data->name_expansion_cache);\n+  delete data->iv_common_cand_tab;\n+  data->iv_common_cand_tab = NULL;\n+  data->iv_common_cands.release ();\n   obstack_free (&data->iv_obstack, NULL);\n }\n "}]}