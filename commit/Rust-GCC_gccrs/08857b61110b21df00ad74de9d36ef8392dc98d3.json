{"sha": "08857b61110b21df00ad74de9d36ef8392dc98d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDg4NTdiNjExMTBiMjFkZjAwYWQ3NGRlOWQzNmVmODM5MmRjOThkMw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-08-15T16:04:49Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-08-15T16:04:49Z"}, "message": "trans-expr.c (gfc_conv_expr_present): Regard nullified pointer arrays as absent.\n\n2010-08-15  Tobias Burnus  <burnus@net-b.de>\n\n        * trans-expr.c (gfc_conv_expr_present): Regard nullified\n        pointer arrays as absent.\n        (gfc_conv_procedure_call): Handle EXPR_NULL for non-pointer\n        dummys as absent argument.\n        * interface.c (compare_actual_formal,compare_parameter):\n        Ditto.\n\n2010-08-15  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.dg/optional_absent_1.f90: New.\n        * gfortran.dg/null_actual.f90: New.\n\nFrom-SVN: r163263", "tree": {"sha": "a4cb2857a24f9fc0a97c5791a6cc3f3c2d51f227", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4cb2857a24f9fc0a97c5791a6cc3f3c2d51f227"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08857b61110b21df00ad74de9d36ef8392dc98d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08857b61110b21df00ad74de9d36ef8392dc98d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08857b61110b21df00ad74de9d36ef8392dc98d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08857b61110b21df00ad74de9d36ef8392dc98d3/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7d54ef80fef93c68354ffa09448ad9c6e32c1545", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d54ef80fef93c68354ffa09448ad9c6e32c1545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d54ef80fef93c68354ffa09448ad9c6e32c1545"}], "stats": {"total": 130, "additions": 127, "deletions": 3}, "files": [{"sha": "4bddcb43aaa7be8136da97ca2d98031bc6ff9e63", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=08857b61110b21df00ad74de9d36ef8392dc98d3", "patch": "@@ -1,3 +1,12 @@\n+2010-08-15  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* trans-expr.c (gfc_conv_expr_present): Regard nullified\n+\tpointer arrays as absent.\n+\t(gfc_conv_procedure_call): Handle EXPR_NULL for non-pointer\n+\tdummys as absent argument.\n+\t* interface.c (compare_actual_formal,compare_parameter):\n+\tDitto.\n+\n 2010-08-15  Tobias Burnus  <burnus@net-b.de>\n \n \t* interface.c (compare_pointer, ): Allow passing TARGETs to pointers"}, {"sha": "e9d310a24443dee0735490e3a51749ae16a84b71", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=08857b61110b21df00ad74de9d36ef8392dc98d3", "patch": "@@ -1589,7 +1589,8 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n   if (rank_check || ranks_must_agree\n       || (formal->attr.pointer && actual->expr_type != EXPR_NULL)\n       || (actual->rank != 0 && !(is_elemental || formal->attr.dimension))\n-      || (actual->rank == 0 && formal->as->type == AS_ASSUMED_SHAPE)\n+      || (actual->rank == 0 && formal->as->type == AS_ASSUMED_SHAPE\n+\t  && actual->expr_type != EXPR_NULL)\n       || (actual->rank == 0 && formal->attr.dimension\n \t  && gfc_is_coindexed (actual)))\n     {\n@@ -2004,6 +2005,20 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"call at %L\", where);\n \t  return 0;\n \t}\n+\n+      if (a->expr->expr_type == EXPR_NULL && !f->sym->attr.pointer\n+\t  && (f->sym->attr.allocatable || !f->sym->attr.optional\n+\t      || (gfc_option.allow_std & GFC_STD_F2008) == 0))\n+\t{\n+\t  if (where && (f->sym->attr.allocatable || !f->sym->attr.optional))\n+\t    gfc_error (\"Unexpected NULL() intrinsic at %L to dummy '%s'\",\n+\t\t       where, f->sym->name);\n+\t  else if (where)\n+\t    gfc_error (\"Fortran 2008: Null pointer at %L to non-pointer \"\n+\t\t       \"dummy '%s'\", where, f->sym->name);\n+\n+\t  return 0;\n+\t}\n       \n       if (!compare_parameter (f->sym, a->expr, ranks_must_agree,\n \t\t\t      is_elemental, where))"}, {"sha": "82f67fb9c277ca85c8983add6dc97330e2ebb447", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=08857b61110b21df00ad74de9d36ef8392dc98d3", "patch": "@@ -123,7 +123,7 @@ gfc_make_safe_expr (gfc_se * se)\n tree\n gfc_conv_expr_present (gfc_symbol * sym)\n {\n-  tree decl;\n+  tree decl, cond;\n \n   gcc_assert (sym->attr.dummy);\n \n@@ -136,8 +136,26 @@ gfc_conv_expr_present (gfc_symbol * sym)\n              || GFC_ARRAY_TYPE_P (TREE_TYPE (decl)));\n       decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n     }\n-  return fold_build2 (NE_EXPR, boolean_type_node, decl,\n+\n+  cond = fold_build2 (NE_EXPR, boolean_type_node, decl,\n \t\t      fold_convert (TREE_TYPE (decl), null_pointer_node));\n+\n+  /* Fortran 2008 allows to pass null pointers and non-associated pointers\n+     as actual argument to denote absent dummies. For array descriptors,\n+     we thus also need to check the array descriptor.  */\n+  if (!sym->attr.pointer && !sym->attr.allocatable\n+      && sym->as && sym->as->type == AS_ASSUMED_SHAPE\n+      && (gfc_option.allow_std & GFC_STD_F2008) != 0)\n+    {\n+      tree tmp;\n+      tmp = build_fold_indirect_ref_loc (input_location, decl);\n+      tmp = gfc_conv_array_data (tmp);\n+      tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n+\t\t\t fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+      cond = fold_build2 (TRUTH_ANDIF_EXPR, boolean_type_node, cond, tmp);\n+    }\n+\n+  return cond;\n }\n \n \n@@ -2850,6 +2868,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tparmse.string_length = build_int_cst (gfc_charlen_type_node, 0);\n \t    }\n \t}\n+      else if (arg->expr->expr_type == EXPR_NULL && fsym && !fsym->attr.pointer)\n+\t{\n+\t  /* Pass a NULL pointer to denote an absent arg.  */\n+\t  gcc_assert (fsym->attr.optional && !fsym->attr.allocatable);\n+\t  gfc_init_se (&parmse, NULL);\n+\t  parmse.expr = null_pointer_node;\n+\t  if (arg->missing_arg_type == BT_CHARACTER)\n+\t    parmse.string_length = build_int_cst (gfc_charlen_type_node, 0);\n+\t}\n       else if (fsym && fsym->ts.type == BT_CLASS\n \t\t && e->ts.type == BT_DERIVED)\n \t{"}, {"sha": "1065b33757f32bf2dd6a4b131b2101485d1f0a71", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08857b61110b21df00ad74de9d36ef8392dc98d3", "patch": "@@ -1,3 +1,8 @@\n+2010-08-15  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.dg/optional_absent_1.f90: New.\n+\t* gfortran.dg/null_actual.f90: New.\n+\n 2010-08-15  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/pointer_target_1.f90: New."}, {"sha": "b29e89d489880572b3253a4721b8f0a0ece85834", "filename": "gcc/testsuite/gfortran.dg/null_actual.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ftestsuite%2Fgfortran.dg%2Fnull_actual.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ftestsuite%2Fgfortran.dg%2Fnull_actual.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnull_actual.f90?ref=08857b61110b21df00ad74de9d36ef8392dc98d3", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! NULL() actual argument to non-pointer dummies\n+!\n+\n+call f(null()) ! { dg-error \"Fortran 2008: Null pointer at .1. to non-pointer dummy\" }\n+call g(null()) ! { dg-error \"Unexpected NULL.. intrinsic at .1. to dummy\" }\n+call h(null()) ! { dg-error \"Unexpected NULL.. intrinsic at .1. to dummy\" }\n+contains\n+subroutine f(x)\n+  integer, optional  :: x\n+end subroutine f\n+subroutine g(x)\n+  integer, optional, allocatable  :: x\n+end subroutine g\n+subroutine h(x)\n+  integer :: x\n+end subroutine h\n+end"}, {"sha": "690c30fa214da4317dc108e43b5a6685ca58d941", "filename": "gcc/testsuite/gfortran.dg/optional_absent_1.f90", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_absent_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08857b61110b21df00ad74de9d36ef8392dc98d3/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_absent_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Foptional_absent_1.f90?ref=08857b61110b21df00ad74de9d36ef8392dc98d3", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do run }\n+! { dg-options \"-std=f2008 -fall-intrinsics\" }\n+!\n+! Passing a null pointer or deallocated variable to an\n+! optional, non-pointer, non-allocatable dummy.\n+!\n+program test\n+  implicit none\n+  integer, pointer :: ps => NULL(), pa(:) => NULL()\n+  integer, allocatable :: as, aa(:)\n+\n+  call scalar(ps) \n+  call scalar(as) \n+  call scalar() \n+  call scalar(NULL())\n+\n+  call assumed_size(pa) \n+  call assumed_size(aa) \n+  call assumed_size() \n+  call assumed_size(NULL(pa))\n+\n+  call assumed_shape(pa)\n+  call assumed_shape(aa)\n+  call assumed_shape()\n+  call assumed_shape(NULL())\n+\n+  call ptr_func(.true., ps)\n+  call ptr_func(.true., null())\n+  call ptr_func(.false.)\n+contains\n+  subroutine scalar(a)\n+    integer, optional :: a\n+    if (present(a)) call abort()\n+  end subroutine scalar\n+  subroutine assumed_size(a)\n+    integer, optional :: a(*)\n+    if (present(a)) call abort()\n+  end subroutine assumed_size\n+  subroutine assumed_shape(a)\n+    integer, optional :: a(:)\n+    if (present(a)) call abort()\n+  end subroutine assumed_shape\n+  subroutine ptr_func(is_psnt, a)\n+    integer, optional, pointer :: a\n+    logical :: is_psnt\n+    if (is_psnt .neqv. present(a)) call abort()\n+  end subroutine ptr_func\n+end program test"}]}