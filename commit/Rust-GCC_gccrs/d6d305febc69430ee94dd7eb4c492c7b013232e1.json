{"sha": "d6d305febc69430ee94dd7eb4c492c7b013232e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkMzA1ZmViYzY5NDMwZWU5NGRkN2ViNGM0OTJjN2IwMTMyMzJlMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-20T09:06:24Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-20T09:06:24Z"}, "message": "tree-ssa-structalias.c (struct variable_info): Add pointer to the first field of an aggregate with sub-vars.\n\n2013-03-20  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (struct variable_info): Add pointer\n\tto the first field of an aggregate with sub-vars.  Make\n\tthis and the pointer to the next subfield its ID.\n\t(vi_next): New function.\n\t(nothing_id, anything_id, readonly_id, escaped_id, nonlocal_id,\n\tstoredanything_id, integer_id): Increment by one.\n\t(new_var_info, get_call_vi, lookup_call_clobber_vi,\n\tget_call_clobber_vi): Adjust.\n\t(solution_set_expand): Simplify and speedup.\n\t(solution_set_add): Inline into ...\n\t(set_union_with_increment): ... this.  Adjust accordingly.\n\t(do_sd_constraint): Likewise.\n\t(do_ds_constraint): Likewise.\n\t(do_complex_constraint): Simplify.\n\t(build_pred_graph): Adjust.\n\t(solve_graph): Likewise.  Simplify and speedup.\n\t(get_constraint_for_ssa_var, get_constraint_for_ptr_offset,\n\tget_constraint_for_component_ref, get_constraint_for_1,\n\tfirst_vi_for_offset, first_or_preceding_vi_for_offset,\n\tcreate_function_info_for, create_variable_info_for_1,\n\tcreate_variable_info_for, intra_create_variable_infos): Adjust.\n\t(init_base_vars): Push NULL for ID zero.\n\t(compute_points_to_sets): Adjust.\n\nFrom-SVN: r196812", "tree": {"sha": "8c4a1129d685ab05b135c1cdc73c1e85e637e608", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c4a1129d685ab05b135c1cdc73c1e85e637e608"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6d305febc69430ee94dd7eb4c492c7b013232e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d305febc69430ee94dd7eb4c492c7b013232e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d305febc69430ee94dd7eb4c492c7b013232e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d305febc69430ee94dd7eb4c492c7b013232e1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a271b42dfb37eba7e6e4c567496d5b58d9f2e012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a271b42dfb37eba7e6e4c567496d5b58d9f2e012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a271b42dfb37eba7e6e4c567496d5b58d9f2e012"}], "stats": {"total": 315, "additions": 178, "deletions": 137}, "files": [{"sha": "a01123060a160a24b18a0fd053632d1da60c8707", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d305febc69430ee94dd7eb4c492c7b013232e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d305febc69430ee94dd7eb4c492c7b013232e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6d305febc69430ee94dd7eb4c492c7b013232e1", "patch": "@@ -1,3 +1,29 @@\n+2013-03-20  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Add pointer\n+\tto the first field of an aggregate with sub-vars.  Make\n+\tthis and the pointer to the next subfield its ID.\n+\t(vi_next): New function.\n+\t(nothing_id, anything_id, readonly_id, escaped_id, nonlocal_id,\n+\tstoredanything_id, integer_id): Increment by one.\n+\t(new_var_info, get_call_vi, lookup_call_clobber_vi,\n+\tget_call_clobber_vi): Adjust.\n+\t(solution_set_expand): Simplify and speedup.\n+\t(solution_set_add): Inline into ...\n+\t(set_union_with_increment): ... this.  Adjust accordingly.\n+\t(do_sd_constraint): Likewise.\n+\t(do_ds_constraint): Likewise.\n+\t(do_complex_constraint): Simplify.\n+\t(build_pred_graph): Adjust.\n+\t(solve_graph): Likewise.  Simplify and speedup.\n+\t(get_constraint_for_ssa_var, get_constraint_for_ptr_offset,\n+\tget_constraint_for_component_ref, get_constraint_for_1,\n+\tfirst_vi_for_offset, first_or_preceding_vi_for_offset,\n+\tcreate_function_info_for, create_variable_info_for_1,\n+\tcreate_variable_info_for, intra_create_variable_infos): Adjust.\n+\t(init_base_vars): Push NULL for ID zero.\n+\t(compute_points_to_sets): Adjust.\n+\n 2013-03-20  Richard Biener  <rguenther@suse.de>\n \n \t* cfgloop.c (verify_loop_structure): Streamline and avoid"}, {"sha": "236b86a9bdd472f6c30ed9403d18d4669cf1f921", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 152, "deletions": 137, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6d305febc69430ee94dd7eb4c492c7b013232e1/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6d305febc69430ee94dd7eb4c492c7b013232e1/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=d6d305febc69430ee94dd7eb4c492c7b013232e1", "patch": "@@ -268,8 +268,12 @@ struct variable_info\n   /* True if this represents a IPA function info.  */\n   unsigned int is_fn_info : 1;\n \n-  /* A link to the variable for the next field in this structure.  */\n-  struct variable_info *next;\n+  /* The ID of the variable for the next field in this structure\n+     or zero for the last field in this structure.  */\n+  unsigned next;\n+\n+  /* The ID of the variable for the first field in this structure.  */\n+  unsigned head;\n \n   /* Offset of this variable, in bits, from the base variable  */\n   unsigned HOST_WIDE_INT offset;\n@@ -319,10 +323,20 @@ get_varinfo (unsigned int n)\n   return varmap[n];\n }\n \n-/* Static IDs for the special variables.  */\n-enum { nothing_id = 0, anything_id = 1, readonly_id = 2,\n-       escaped_id = 3, nonlocal_id = 4,\n-       storedanything_id = 5, integer_id = 6 };\n+/* Return the next variable in the list of sub-variables of VI\n+   or NULL if VI is the last sub-variable.  */\n+\n+static inline varinfo_t\n+vi_next (varinfo_t vi)\n+{\n+  return get_varinfo (vi->next);\n+}\n+\n+/* Static IDs for the special variables.  Variable ID zero is unused\n+   and used as terminator for the sub-variable chain.  */\n+enum { nothing_id = 1, anything_id = 2, readonly_id = 3,\n+       escaped_id = 4, nonlocal_id = 5,\n+       storedanything_id = 6, integer_id = 7 };\n \n /* Return a new variable info structure consisting for a variable\n    named NAME, and using constraint graph node NODE.  Append it\n@@ -355,7 +369,8 @@ new_var_info (tree t, const char *name)\n \t\t\t      && DECL_HARD_REGISTER (t)));\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n   ret->oldsolution = NULL;\n-  ret->next = NULL;\n+  ret->next = 0;\n+  ret->head = ret->id;\n \n   stats.total_vars++;\n \n@@ -387,12 +402,14 @@ get_call_vi (gimple call)\n   vi->fullsize = 2;\n   vi->is_full_var = true;\n \n-  vi->next = vi2 = new_var_info (NULL_TREE, \"CALLCLOBBERED\");\n+  vi2 = new_var_info (NULL_TREE, \"CALLCLOBBERED\");\n   vi2->offset = 1;\n   vi2->size = 1;\n   vi2->fullsize = 2;\n   vi2->is_full_var = true;\n \n+  vi->next = vi2->id;\n+\n   *slot_p = (void *) vi;\n   return vi;\n }\n@@ -422,7 +439,7 @@ lookup_call_clobber_vi (gimple call)\n   if (!uses)\n     return NULL;\n \n-  return uses->next;\n+  return vi_next (uses);\n }\n \n /* Lookup or create the variable for the call statement CALL representing\n@@ -440,7 +457,7 @@ get_call_use_vi (gimple call)\n static varinfo_t ATTRIBUTE_UNUSED\n get_call_clobber_vi (gimple call)\n {\n-  return get_call_vi (call)->next;\n+  return vi_next (get_call_vi (call));\n }\n \n \n@@ -701,8 +718,10 @@ dump_constraint_graph (FILE *file)\n \n   /* The next lines print the nodes in the graph together with the\n      complex constraints attached to them.  */\n-  for (i = 0; i < graph->size; i++)\n+  for (i = 1; i < graph->size; i++)\n     {\n+      if (i == FIRST_REF_NODE)\n+\tcontinue;\n       if (find (i) != i)\n \tcontinue;\n       if (i < FIRST_REF_NODE)\n@@ -726,7 +745,7 @@ dump_constraint_graph (FILE *file)\n \n   /* Go over the edges.  */\n   fprintf (file, \"\\n  // Edges in the constraint graph:\\n\");\n-  for (i = 0; i < graph->size; i++)\n+  for (i = 1; i < graph->size; i++)\n     {\n       unsigned j;\n       bitmap_iterator bi;\n@@ -881,63 +900,71 @@ constraint_set_union (vec<constraint_t> *to,\n     }\n }\n \n-/* Expands the solution in SET to all sub-fields of variables included.\n-   Union the expanded result into RESULT.  */\n+/* Expands the solution in SET to all sub-fields of variables included.  */\n \n static void\n-solution_set_expand (bitmap result, bitmap set)\n+solution_set_expand (bitmap set)\n {\n   bitmap_iterator bi;\n-  bitmap vars = NULL;\n   unsigned j;\n \n-  /* In a first pass record all variables we need to add all\n-     sub-fields off.  This avoids quadratic behavior.  */\n+  /* In a first pass expand to the head of the variables we need to\n+     add all sub-fields off.  This avoids quadratic behavior.  */\n   EXECUTE_IF_SET_IN_BITMAP (set, 0, j, bi)\n     {\n       varinfo_t v = get_varinfo (j);\n       if (v->is_artificial_var\n \t  || v->is_full_var)\n \tcontinue;\n-      v = lookup_vi_for_tree (v->decl);\n-      if (vars == NULL)\n-\tvars = BITMAP_ALLOC (NULL);\n-      bitmap_set_bit (vars, v->id);\n+      bitmap_set_bit (set, v->head);\n     }\n \n-  /* In the second pass now do the addition to the solution and\n-     to speed up solving add it to the delta as well.  */\n-  if (vars != NULL)\n+  /* In the second pass now expand all head variables with subfields.  */\n+  EXECUTE_IF_SET_IN_BITMAP (set, 0, j, bi)\n     {\n-      EXECUTE_IF_SET_IN_BITMAP (vars, 0, j, bi)\n-\t{\n-\t  varinfo_t v = get_varinfo (j);\n-\t  for (; v != NULL; v = v->next)\n-\t    bitmap_set_bit (result, v->id);\n-\t}\n-      BITMAP_FREE (vars);\n+      varinfo_t v = get_varinfo (j);\n+      if (v->is_artificial_var\n+\t  || v->is_full_var\n+\t  || v->head != j)\n+\tcontinue;\n+      for (v = vi_next (v); v != NULL; v = vi_next (v))\n+\tbitmap_set_bit (set, v->id);\n     }\n }\n \n-/* Take a solution set SET, add OFFSET to each member of the set, and\n-   overwrite SET with the result when done.  */\n+/* Union solution sets TO and FROM, and add INC to each member of FROM in the\n+   process.  */\n \n-static void\n-solution_set_add (bitmap set, HOST_WIDE_INT offset)\n+static bool\n+set_union_with_increment  (bitmap to, bitmap from, HOST_WIDE_INT inc)\n {\n-  bitmap result = BITMAP_ALLOC (&iteration_obstack);\n-  unsigned int i;\n+  bool changed = false;\n   bitmap_iterator bi;\n+  unsigned int i;\n+\n+  /* If the solution of FROM contains anything it is good enough to transfer\n+     this to TO.  */\n+  if (bitmap_bit_p (from, anything_id))\n+    return bitmap_set_bit (to, anything_id);\n+\n+  /* For zero offset simply union the solution into the destination.  */\n+  if (inc == 0)\n+    return bitmap_ior_into (to, from);\n \n   /* If the offset is unknown we have to expand the solution to\n      all subfields.  */\n-  if (offset == UNKNOWN_OFFSET)\n+  if (inc == UNKNOWN_OFFSET)\n     {\n-      solution_set_expand (set, set);\n-      return;\n+      bitmap tmp = BITMAP_ALLOC (&iteration_obstack);\n+      bitmap_copy (tmp, from);\n+      solution_set_expand (tmp);\n+      changed |= bitmap_ior_into (to, tmp);\n+      BITMAP_FREE (tmp);\n+      return changed;\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (set, 0, i, bi)\n+  /* For non-zero offset union the offsetted solution into the destination.  */\n+  EXECUTE_IF_SET_IN_BITMAP (from, 0, i, bi)\n     {\n       varinfo_t vi = get_varinfo (i);\n \n@@ -946,54 +973,30 @@ solution_set_add (bitmap set, HOST_WIDE_INT offset)\n       if (vi->is_artificial_var\n \t  || vi->is_unknown_size_var\n \t  || vi->is_full_var)\n-\tbitmap_set_bit (result, i);\n+\tchanged |= bitmap_set_bit (to, i);\n       else\n \t{\n-\t  unsigned HOST_WIDE_INT fieldoffset = vi->offset + offset;\n+\t  unsigned HOST_WIDE_INT fieldoffset = vi->offset + inc;\n \n \t  /* If the offset makes the pointer point to before the\n \t     variable use offset zero for the field lookup.  */\n-\t  if (offset < 0\n+\t  if (inc < 0\n \t      && fieldoffset > vi->offset)\n \t    fieldoffset = 0;\n \n-\t  if (offset != 0)\n-\t    vi = first_or_preceding_vi_for_offset (vi, fieldoffset);\n+\t  vi = first_or_preceding_vi_for_offset (vi, fieldoffset);\n \n-\t  bitmap_set_bit (result, vi->id);\n+\t  changed |= bitmap_set_bit (to, vi->id);\n \t  /* If the result is not exactly at fieldoffset include the next\n \t     field as well.  See get_constraint_for_ptr_offset for more\n \t     rationale.  */\n \t  if (vi->offset != fieldoffset\n-\t      && vi->next != NULL)\n-\t    bitmap_set_bit (result, vi->next->id);\n+\t      && vi->next != 0)\n+\t    changed |= bitmap_set_bit (to, vi->next);\n \t}\n     }\n \n-  bitmap_copy (set, result);\n-  BITMAP_FREE (result);\n-}\n-\n-/* Union solution sets TO and FROM, and add INC to each member of FROM in the\n-   process.  */\n-\n-static bool\n-set_union_with_increment  (bitmap to, bitmap from, HOST_WIDE_INT inc)\n-{\n-  if (inc == 0)\n-    return bitmap_ior_into (to, from);\n-  else\n-    {\n-      bitmap tmp;\n-      bool res;\n-\n-      tmp = BITMAP_ALLOC (&iteration_obstack);\n-      bitmap_copy (tmp, from);\n-      solution_set_add (tmp, inc);\n-      res = bitmap_ior_into (to, tmp);\n-      BITMAP_FREE (tmp);\n-      return res;\n-    }\n+  return changed;\n }\n \n /* Insert constraint C into the list of complex constraints for graph\n@@ -1190,7 +1193,7 @@ build_pred_graph (void)\n   graph->address_taken = BITMAP_ALLOC (&predbitmap_obstack);\n   bitmap_clear (graph->direct_nodes);\n \n-  for (j = 0; j < FIRST_REF_NODE; j++)\n+  for (j = 1; j < FIRST_REF_NODE; j++)\n     {\n       if (!get_varinfo (j)->is_special_var)\n \tbitmap_set_bit (graph->direct_nodes, j);\n@@ -1244,11 +1247,11 @@ build_pred_graph (void)\n           v = get_varinfo (rhsvar);\n           if (!v->is_full_var)\n             {\n-              v = lookup_vi_for_tree (v->decl);\n+              v = get_varinfo (v->head);\n               do\n                 {\n                   bitmap_clear_bit (graph->direct_nodes, v->id);\n-                  v = v->next;\n+                  v = vi_next (v);\n                 }\n               while (v != NULL);\n             }\n@@ -1578,7 +1581,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n      dereferenced at all valid offsets.  */\n   if (roffset == UNKNOWN_OFFSET)\n     {\n-      solution_set_expand (delta, delta);\n+      solution_set_expand (delta);\n       /* No further offset processing is necessary.  */\n       roffset = 0;\n     }\n@@ -1618,10 +1621,10 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n \t  /* If the variable is not exactly at the requested offset\n \t     we have to include the next one.  */\n \t  if (v->offset == (unsigned HOST_WIDE_INT)fieldoffset\n-\t      || v->next == NULL)\n+\t      || v->next == 0)\n \t    break;\n \n-\t  v = v->next;\n+\t  v = vi_next (v);\n \t  fieldoffset = v->offset;\n \t}\n       while (1);\n@@ -1676,7 +1679,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n      dereferenced at all valid offsets.  */\n   if (loff == UNKNOWN_OFFSET)\n     {\n-      solution_set_expand (delta, delta);\n+      solution_set_expand (delta);\n       loff = 0;\n     }\n \n@@ -1724,10 +1727,10 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  /* If the variable is not exactly at the requested offset\n \t     we have to include the next one.  */\n \t  if (v->offset == (unsigned HOST_WIDE_INT)fieldoffset\n-\t      || v->next == NULL)\n+\t      || v->next == 0)\n \t    break;\n \n-\t  v = v->next;\n+\t  v = vi_next (v);\n \t  fieldoffset = v->offset;\n \t}\n       while (1);\n@@ -1771,10 +1774,7 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       flag = set_union_with_increment (tmp, solution, c->rhs.offset);\n \n       if (flag)\n-\t{\n-\t  get_varinfo (c->lhs.var)->solution = tmp;\n-\t  bitmap_set_bit (changed, c->lhs.var);\n-\t}\n+\tbitmap_set_bit (changed, c->lhs.var);\n     }\n }\n \n@@ -2160,8 +2160,10 @@ dump_pred_graph (struct scc_info *si, FILE *file)\n \n   /* The next lines print the nodes in the graph together with the\n      complex constraints attached to them.  */\n-  for (i = 0; i < graph->size; i++)\n+  for (i = 1; i < graph->size; i++)\n     {\n+      if (i == FIRST_REF_NODE)\n+\tcontinue;\n       if (si->node_mapping[i] != i)\n \tcontinue;\n       if (i < FIRST_REF_NODE)\n@@ -2183,7 +2185,7 @@ dump_pred_graph (struct scc_info *si, FILE *file)\n \n   /* Go over the edges.  */\n   fprintf (file, \"\\n  // Edges in the constraint graph:\\n\");\n-  for (i = 0; i < graph->size; i++)\n+  for (i = 1; i < graph->size; i++)\n     {\n       unsigned j;\n       bitmap_iterator bi;\n@@ -2229,7 +2231,7 @@ perform_var_substitution (constraint_graph_t graph)\n \n   /* Condense the nodes, which means to find SCC's, count incoming\n      predecessors, and unite nodes in SCC's.  */\n-  for (i = 0; i < FIRST_REF_NODE; i++)\n+  for (i = 1; i < FIRST_REF_NODE; i++)\n     if (!bitmap_bit_p (si->visited, si->node_mapping[i]))\n       condense_visit (graph, si, si->node_mapping[i]);\n \n@@ -2243,12 +2245,12 @@ perform_var_substitution (constraint_graph_t graph)\n \n   bitmap_clear (si->visited);\n   /* Actually the label the nodes for pointer equivalences  */\n-  for (i = 0; i < FIRST_REF_NODE; i++)\n+  for (i = 1; i < FIRST_REF_NODE; i++)\n     if (!bitmap_bit_p (si->visited, si->node_mapping[i]))\n       label_visit (graph, si, si->node_mapping[i]);\n \n   /* Calculate location equivalence labels.  */\n-  for (i = 0; i < FIRST_REF_NODE; i++)\n+  for (i = 1; i < FIRST_REF_NODE; i++)\n     {\n       bitmap pointed_by;\n       bitmap_iterator bi;\n@@ -2286,7 +2288,7 @@ perform_var_substitution (constraint_graph_t graph)\n     }\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    for (i = 0; i < FIRST_REF_NODE; i++)\n+    for (i = 1; i < FIRST_REF_NODE; i++)\n       {\n \tunsigned j = si->node_mapping[i];\n \tif (j != i)\n@@ -2306,7 +2308,7 @@ perform_var_substitution (constraint_graph_t graph)\n \n   /* Quickly eliminate our non-pointer variables.  */\n \n-  for (i = 0; i < FIRST_REF_NODE; i++)\n+  for (i = 1; i < FIRST_REF_NODE; i++)\n     {\n       unsigned int node = si->node_mapping[i];\n \n@@ -2393,7 +2395,7 @@ unite_pointer_equivalences (constraint_graph_t graph)\n \n   /* Go through the pointer equivalences and unite them to their\n      representative, if they aren't already.  */\n-  for (i = 0; i < FIRST_REF_NODE; i++)\n+  for (i = 1; i < FIRST_REF_NODE; i++)\n     {\n       unsigned int label = graph->pe[i];\n       if (label)\n@@ -2570,7 +2572,7 @@ solve_graph (constraint_graph_t graph)\n   changed = BITMAP_ALLOC (NULL);\n \n   /* Mark all initial non-collapsed nodes as changed.  */\n-  for (i = 0; i < size; i++)\n+  for (i = 1; i < size; i++)\n     {\n       varinfo_t ivi = get_varinfo (i);\n       if (find (i) == i && !bitmap_empty_p (ivi->solution)\n@@ -2617,8 +2619,19 @@ solve_graph (constraint_graph_t graph)\n \t      varinfo_t vi = get_varinfo (i);\n \t      bool solution_empty;\n \n-\t      /* Compute the changed set of solution bits.  */\n-\t      if (vi->oldsolution)\n+\t      /* Compute the changed set of solution bits.  If anything\n+\t         is in the solution just propagate that.  */\n+\t      if (bitmap_bit_p (vi->solution, anything_id))\n+\t\t{\n+\t\t  /* If anything is also in the old solution there is\n+\t\t     nothing to do.\n+\t\t     ???  But we shouldn't ended up with \"changed\" set ...  */\n+\t\t  if (vi->oldsolution\n+\t\t      && bitmap_bit_p (vi->oldsolution, anything_id))\n+\t\t    continue;\n+\t\t  bitmap_copy (pts, get_varinfo (find (anything_id))->solution);\n+\t\t}\n+\t      else if (vi->oldsolution)\n \t\tbitmap_and_compl (pts, vi->solution, vi->oldsolution);\n \t      else\n \t\tbitmap_copy (pts, vi->solution);\n@@ -2682,13 +2695,10 @@ solve_graph (constraint_graph_t graph)\n \t\t      if (i == eff_escaped_id)\n \t\t\tflag = bitmap_set_bit (tmp, escaped_id);\n \t\t      else\n-\t\t\tflag = set_union_with_increment (tmp, pts, 0);\n+\t\t\tflag = bitmap_ior_into (tmp, pts);\n \n \t\t      if (flag)\n-\t\t\t{\n-\t\t\t  get_varinfo (to)->solution = tmp;\n-\t\t\t  bitmap_set_bit (changed, to);\n-\t\t\t}\n+\t\t\tbitmap_set_bit (changed, to);\n \t\t    }\n \t\t}\n \t    }\n@@ -2866,7 +2876,7 @@ get_constraint_for_ssa_var (tree t, vec<ce_s> *results, bool address_p)\n   if (!address_p\n       && !vi->is_full_var)\n     {\n-      for (; vi; vi = vi->next)\n+      for (; vi; vi = vi_next (vi))\n \t{\n \t  cexpr.var = vi->id;\n \t  results->safe_push (cexpr);\n@@ -3013,7 +3023,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t       /* If we do not know the offset add all subfields.  */\n \t       && rhsoffset == UNKNOWN_OFFSET)\n \t{\n-\t  varinfo_t temp = lookup_vi_for_tree (curr->decl);\n+\t  varinfo_t temp = get_varinfo (curr->head);\n \t  do\n \t    {\n \t      struct constraint_expr c2;\n@@ -3022,7 +3032,7 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t      c2.offset = 0;\n \t      if (c2.var != c.var)\n \t\tresults->safe_push (c2);\n-\t      temp = temp->next;\n+\t      temp = vi_next (temp);\n \t    }\n \t  while (temp);\n \t}\n@@ -3050,10 +3060,10 @@ get_constraint_for_ptr_offset (tree ptr, tree offset,\n \t     do not result in the same or a conservative superset\n \t     solution.  */\n \t  if (temp->offset != offset\n-\t      && temp->next != NULL)\n+\t      && temp->next != 0)\n \t    {\n \t      struct constraint_expr c2;\n-\t      c2.var = temp->next->id;\n+\t      c2.var = temp->next;\n \t      c2.type = ADDRESSOF;\n \t      c2.offset = 0;\n \t      results->safe_push (c2);\n@@ -3156,7 +3166,7 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n \t  varinfo_t curr;\n \t  results->pop ();\n \t  cexpr.offset = 0;\n-\t  for (curr = get_varinfo (cexpr.var); curr; curr = curr->next)\n+\t  for (curr = get_varinfo (cexpr.var); curr; curr = vi_next (curr))\n \t    {\n \t      if (ranges_overlap_p (curr->offset, curr->size,\n \t\t\t\t    bitpos, bitmaxsize))\n@@ -3173,8 +3183,8 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n \t  if (address_p && results->length () == 0)\n \t    {\n \t      curr = get_varinfo (cexpr.var);\n-\t      while (curr->next != NULL)\n-\t\tcurr = curr->next;\n+\t      while (curr->next != 0)\n+\t\tcurr = vi_next (curr);\n \t      cexpr.var = curr->id;\n \t      results->safe_push (cexpr);\n \t    }\n@@ -3370,7 +3380,7 @@ get_constraint_for_1 (tree t, vec<ce_s> *results, bool address_p,\n \t\treturn;\n \n \t      vi = get_varinfo (cs.var);\n-\t      curr = vi->next;\n+\t      curr = vi_next (vi);\n \t      if (!vi->is_full_var\n \t\t  && curr)\n \t\t{\n@@ -3379,7 +3389,7 @@ get_constraint_for_1 (tree t, vec<ce_s> *results, bool address_p,\n \t\t    size = TREE_INT_CST_LOW (TYPE_SIZE (TREE_TYPE (t)));\n \t\t  else\n \t\t    size = -1;\n-\t\t  for (; curr; curr = curr->next)\n+\t\t  for (; curr; curr = vi_next (curr))\n \t\t    {\n \t\t      if (curr->offset - vi->offset < size)\n \t\t\t{\n@@ -5075,7 +5085,7 @@ first_vi_for_offset (varinfo_t start, unsigned HOST_WIDE_INT offset)\n   /* If we cannot reach offset from start, lookup the first field\n      and start from there.  */\n   if (start->offset > offset)\n-    start = lookup_vi_for_tree (start->decl);\n+    start = get_varinfo (start->head);\n \n   while (start)\n     {\n@@ -5087,7 +5097,7 @@ first_vi_for_offset (varinfo_t start, unsigned HOST_WIDE_INT offset)\n \t  && (offset - start->offset) < start->size)\n \treturn start;\n \n-      start= start->next;\n+      start = vi_next (start);\n     }\n \n   return NULL;\n@@ -5104,7 +5114,7 @@ first_or_preceding_vi_for_offset (varinfo_t start,\n   /* If we cannot reach offset from start, lookup the first field\n      and start from there.  */\n   if (start->offset > offset)\n-    start = lookup_vi_for_tree (start->decl);\n+    start = get_varinfo (start->head);\n \n   /* We may not find a variable in the field list with the actual\n      offset when when we have glommed a structure to a variable.\n@@ -5115,7 +5125,7 @@ first_or_preceding_vi_for_offset (varinfo_t start,\n   while (start->next\n \t && offset >= start->offset\n \t && !((offset - start->offset) < start->size))\n-    start = start->next;\n+    start = vi_next (start);\n \n   return start;\n }\n@@ -5398,7 +5408,7 @@ create_function_info_for (tree decl, const char *name)\n       clobbervi->is_full_var = true;\n       clobbervi->is_global_var = false;\n       gcc_assert (prev_vi->offset < clobbervi->offset);\n-      prev_vi->next = clobbervi;\n+      prev_vi->next = clobbervi->id;\n       prev_vi = clobbervi;\n \n       asprintf (&tempname, \"%s.use\", name);\n@@ -5412,7 +5422,7 @@ create_function_info_for (tree decl, const char *name)\n       usevi->is_full_var = true;\n       usevi->is_global_var = false;\n       gcc_assert (prev_vi->offset < usevi->offset);\n-      prev_vi->next = usevi;\n+      prev_vi->next = usevi->id;\n       prev_vi = usevi;\n     }\n \n@@ -5434,7 +5444,7 @@ create_function_info_for (tree decl, const char *name)\n       chainvi->is_full_var = true;\n       chainvi->is_global_var = false;\n       gcc_assert (prev_vi->offset < chainvi->offset);\n-      prev_vi->next = chainvi;\n+      prev_vi->next = chainvi->id;\n       prev_vi = chainvi;\n       insert_vi_for_tree (fn->static_chain_decl, chainvi);\n     }\n@@ -5463,7 +5473,7 @@ create_function_info_for (tree decl, const char *name)\n       if (DECL_RESULT (decl))\n \tresultvi->may_have_pointers = true;\n       gcc_assert (prev_vi->offset < resultvi->offset);\n-      prev_vi->next = resultvi;\n+      prev_vi->next = resultvi->id;\n       prev_vi = resultvi;\n       if (DECL_RESULT (decl))\n \tinsert_vi_for_tree (DECL_RESULT (decl), resultvi);\n@@ -5493,7 +5503,7 @@ create_function_info_for (tree decl, const char *name)\n       if (arg)\n \targvi->may_have_pointers = true;\n       gcc_assert (prev_vi->offset < argvi->offset);\n-      prev_vi->next = argvi;\n+      prev_vi->next = argvi->id;\n       prev_vi = argvi;\n       if (arg)\n \t{\n@@ -5524,7 +5534,7 @@ create_function_info_for (tree decl, const char *name)\n       argvi->is_heap_var = true;\n       argvi->fullsize = vi->fullsize;\n       gcc_assert (prev_vi->offset < argvi->offset);\n-      prev_vi->next = argvi;\n+      prev_vi->next = argvi->id;\n       prev_vi = argvi;\n     }\n \n@@ -5638,7 +5648,7 @@ create_variable_info_for_1 (tree decl, const char *name)\n   vi->fullsize = TREE_INT_CST_LOW (declsize);\n   for (i = 0, newvi = vi;\n        fieldstack.iterate (i, &fo);\n-       ++i, newvi = newvi->next)\n+       ++i, newvi = vi_next (newvi))\n     {\n       const char *newname = \"NULL\";\n       char *tempname;\n@@ -5657,7 +5667,11 @@ create_variable_info_for_1 (tree decl, const char *name)\n       newvi->may_have_pointers = fo->may_have_pointers;\n       newvi->only_restrict_pointers = fo->only_restrict_pointers;\n       if (i + 1 < fieldstack.length ())\n-\tnewvi->next = new_var_info (decl, name);\n+\t{\n+\t  varinfo_t tem = new_var_info (decl, name);\n+\t  newvi->next = tem->id;\n+\t  tem->head = vi->id;\n+\t}\n     }\n \n   fieldstack.release ();\n@@ -5677,7 +5691,7 @@ create_variable_info_for (tree decl, const char *name)\n     return id;\n \n   /* Create initial constraints for globals.  */\n-  for (; vi; vi = vi->next)\n+  for (; vi; vi = vi_next (vi))\n     {\n       if (!vi->may_have_pointers\n \t  || !vi->is_global_var)\n@@ -5807,7 +5821,7 @@ intra_create_variable_infos (void)\n \t  rhsc.type = ADDRESSOF;\n \t  rhsc.offset = 0;\n \t  process_constraint (new_constraint (lhsc, rhsc));\n-\t  for (; vi; vi = vi->next)\n+\t  for (; vi; vi = vi_next (vi))\n \t    if (vi->may_have_pointers)\n \t      {\n \t\tif (vi->only_restrict_pointers)\n@@ -5823,7 +5837,7 @@ intra_create_variable_infos (void)\n \tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\");\n       else\n \t{\n-\t  for (; p; p = p->next)\n+\t  for (; p; p = vi_next (p))\n \t    {\n \t      if (p->only_restrict_pointers)\n \t\tmake_constraint_from_global_restrict (p, \"PARM_RESTRICT\");\n@@ -5839,7 +5853,7 @@ intra_create_variable_infos (void)\n     {\n       varinfo_t p, result_vi = get_vi_for_tree (DECL_RESULT (cfun->decl));\n \n-      for (p = result_vi; p; p = p->next)\n+      for (p = result_vi; p; p = vi_next (p))\n \tmake_constraint_from (p, nonlocal_id);\n     }\n \n@@ -5848,7 +5862,7 @@ intra_create_variable_infos (void)\n     {\n       varinfo_t p, chain_vi = get_vi_for_tree (cfun->static_chain_decl);\n \n-      for (p = chain_vi; p; p = p->next)\n+      for (p = chain_vi; p; p = vi_next (p))\n \tmake_constraint_from (p, nonlocal_id);\n     }\n }\n@@ -6363,7 +6377,7 @@ dump_sa_points_to_info (FILE *outfile)\n \t       stats.num_implicit_edges);\n     }\n \n-  for (i = 0; i < varmap.length (); i++)\n+  for (i = 1; i < varmap.length (); i++)\n     {\n       varinfo_t vi = get_varinfo (i);\n       if (!vi->may_have_pointers)\n@@ -6397,6 +6411,9 @@ init_base_vars (void)\n   varinfo_t var_storedanything;\n   varinfo_t var_integer;\n \n+  /* Variable ID zero is reserved and should be NULL.  */\n+  varmap.safe_push (NULL);\n+\n   /* Create the NULL variable, used to represent that a variable points\n      to NULL.  */\n   var_nothing = new_var_info (NULL_TREE, \"NULL\");\n@@ -6416,7 +6433,6 @@ init_base_vars (void)\n   var_anything->is_artificial_var = 1;\n   var_anything->size = ~0;\n   var_anything->offset = 0;\n-  var_anything->next = NULL;\n   var_anything->fullsize = ~0;\n   var_anything->is_special_var = 1;\n \n@@ -6443,7 +6459,6 @@ init_base_vars (void)\n   var_readonly->offset = 0;\n   var_readonly->size = ~0;\n   var_readonly->fullsize = ~0;\n-  var_readonly->next = NULL;\n   var_readonly->is_special_var = 1;\n \n   /* readonly memory points to anything, in order to make deref\n@@ -6540,7 +6555,6 @@ init_base_vars (void)\n   var_integer->size = ~0;\n   var_integer->fullsize = ~0;\n   var_integer->offset = 0;\n-  var_integer->next = NULL;\n   var_integer->is_special_var = 1;\n \n   /* INTEGER = ANYTHING, because we don't know where a dereference of\n@@ -6595,15 +6609,15 @@ remove_preds_and_fake_succs (constraint_graph_t graph)\n \n   /* Clear the implicit ref and address nodes from the successor\n      lists.  */\n-  for (i = 0; i < FIRST_REF_NODE; i++)\n+  for (i = 1; i < FIRST_REF_NODE; i++)\n     {\n       if (graph->succs[i])\n \tbitmap_clear_range (graph->succs[i], FIRST_REF_NODE,\n \t\t\t    FIRST_REF_NODE * 2);\n     }\n \n   /* Free the successor list for the non-ref nodes.  */\n-  for (i = FIRST_REF_NODE; i < graph->size; i++)\n+  for (i = FIRST_REF_NODE + 1; i < graph->size; i++)\n     {\n       if (graph->succs[i])\n \tBITMAP_FREE (graph->succs[i]);\n@@ -6750,7 +6764,8 @@ compute_points_to_sets (void)\n \n   /* Mark escaped HEAP variables as global.  */\n   FOR_EACH_VEC_ELT (varmap, i, vi)\n-    if (vi->is_heap_var\n+    if (vi\n+\t&& vi->is_heap_var\n \t&& !vi->is_global_var)\n       DECL_EXTERNAL (vi->decl) = vi->is_global_var\n \t= pt_solution_includes (&cfun->gimple_df->escaped, vi->decl);"}]}