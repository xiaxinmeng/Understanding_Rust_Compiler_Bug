{"sha": "b3967ec43eafa885d2d346c407958151a548fa08", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM5NjdlYzQzZWFmYTg4NWQyZDM0NmM0MDc5NTgxNTFhNTQ4ZmEwOA==", "commit": {"author": {"name": "Anthony Green", "email": "green@cygnus.com", "date": "1999-08-09T06:35:56Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "1999-08-09T06:35:56Z"}, "message": "Primes.java: New file.\n\n\t* libjava.lang/Primes.java: New file.\n\t* libjava.lang/Primes.out: New file.\n\nFrom-SVN: r28613", "tree": {"sha": "4d94ff9fe054210ba5c1191601149f288de7aee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d94ff9fe054210ba5c1191601149f288de7aee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3967ec43eafa885d2d346c407958151a548fa08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3967ec43eafa885d2d346c407958151a548fa08", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3967ec43eafa885d2d346c407958151a548fa08", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3967ec43eafa885d2d346c407958151a548fa08/comments", "author": null, "committer": null, "parents": [{"sha": "8d25f6084d5a8180596a0c5ab71b4407e4ddb21f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d25f6084d5a8180596a0c5ab71b4407e4ddb21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d25f6084d5a8180596a0c5ab71b4407e4ddb21f"}], "stats": {"total": 269, "additions": 269, "deletions": 0}, "files": [{"sha": "7b35bc19c89dda033e2d5a72f3d7314c16f9fa28", "filename": "libjava/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3967ec43eafa885d2d346c407958151a548fa08/libjava%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3967ec43eafa885d2d346c407958151a548fa08/libjava%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FChangeLog?ref=b3967ec43eafa885d2d346c407958151a548fa08", "patch": "@@ -1,3 +1,8 @@\n+1999-08-09  Anthony Green  <green@cygnus.com>\n+\n+\t* libjava.lang/Primes.java: New file.\n+\t* libjava.lang/Primes.out: New file.\n+\n 1999-07-31  Alexandre Oliva  <oliva@dcc.unicamp.br>\n \n \t* lib/libjava.exp (bytecompile_file): Use `env(SUN_JAVAC)', that"}, {"sha": "d6e4336726a4c10aa4173a22ed859789c7173b22", "filename": "libjava/testsuite/libjava.lang/Primes.java", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3967ec43eafa885d2d346c407958151a548fa08/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3967ec43eafa885d2d346c407958151a548fa08/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.java?ref=b3967ec43eafa885d2d346c407958151a548fa08", "patch": "@@ -0,0 +1,213 @@\n+// Primes.java\r\n+\r\n+/** Copyright 1998\r\n+ * Roedy Green\r\n+ * Canadian Mind Products\r\n+ * 5317 Barker Avenue\r\n+ * Burnaby, BC Canada V5H 2N6\r\n+ * tel: (604) 435-3016\r\n+ * mailto:roedy@mindprod.com\r\n+ * http://mindprod.com\r\n+ */\r\n+// May be freely distributed for any purpose but military\r\n+\r\n+import java.util.BitSet;\r\n+\r\n+/**\r\n+  * @author Roedy Green\r\n+  * @version 1.10 1998 November 10\r\n+  * Calculate primes using Eratostheses Sieve.\r\n+  * Tell if a given number is prime.\r\n+  * Find a prime just below a given number.\r\n+  * Find a prime just above a given number.\r\n+  */\r\n+  \r\n+/* \r\n+ * version 1.1 1998 November 10 - new address and phone.  \r\n+ */\r\n+class Primes\r\n+    {\r\n+\r\n+    /**\r\n+      * constructors\r\n+      */\r\n+    Primes()\r\n+        {\r\n+        ensureCapacity(1000);\r\n+        }\r\n+\r\n+    /**\r\n+      * @param capacity - largest number you will be asking if prime.\r\n+      * If give too small a number, it will automatically grow by\r\n+      * recomputing the sieve array.\r\n+      */\r\n+    Primes (int capacity)\r\n+        {\r\n+        ensureCapacity(capacity);\r\n+        }\r\n+\r\n+    /**\r\n+      * @param candidate - is this a prime?\r\n+      */\r\n+    public boolean isPrime(int candidate)\r\n+        {\r\n+        ensureCapacity(candidate);\r\n+        if (candidate < 3) return candidate != 0;\r\n+        if (candidate % 2 == 0 ) return false;\r\n+        return !b.get(candidate/2);\r\n+        }\r\n+\r\n+    /**\r\n+      * @return first prime higher than candidate\r\n+      */\r\n+    public int above(int candidate)\r\n+    {\r\n+        do\r\n+            {\r\n+            // see what we can find in the existing sieve\r\n+            for (int i=candidate+1; i<= sieveCapacity; i++)\r\n+                {\r\n+                if (isPrime(i)) return i;\r\n+                }\r\n+            // Keep building ever bigger sieves till we succeed.\r\n+            // The next prime P' is between P+2 and P^2 - 2.\r\n+            // However that is a rather pessimistic upper bound.\r\n+            // Ideally some theorem would tell us how big we need to build\r\n+            // to find one.\r\n+            ensureCapacity(Math.max(candidate*2, sieveCapacity*2));\r\n+            } // end do\r\n+        while (true);\r\n+        } // end above\r\n+\r\n+    /**\r\n+      * @param return first prime less than candidate\r\n+      */\r\n+    public int below (int candidate)\r\n+    {\r\n+        for (candidate--; candidate > 0; candidate--)\r\n+            {\r\n+            if (isPrime(candidate)) return candidate;\r\n+            }\r\n+        // candidate was 1 or 0 or -ve\r\n+        return 0;\r\n+        }\r\n+\r\n+    /**\r\n+      * calc all primes in the range 1..n,\r\n+      * not the first n primes.\r\n+      * @param n, highest candidate, not necessarily prime.\r\n+      * @return list of primes 1..n in an array\r\n+      */\r\n+    public final int[] getPrimes(int n)\r\n+        {\r\n+        // calculate the primes\r\n+        ensureCapacity(n);\r\n+\r\n+        // pass 1: count primes\r\n+        int countPrimes = 0;\r\n+        for (int i = 0; i <= n; i++)\r\n+            {\r\n+            if (isPrime(i)) countPrimes++;\r\n+            }\r\n+\r\n+        // pass 2: construct array of primes\r\n+        int [] primes = new int[countPrimes];\r\n+        countPrimes = 0;\r\n+        for (int i = 0; i <= n; i++)\r\n+            {\r\n+            if (isPrime(i)) primes[countPrimes++] = i;\r\n+            }\r\n+        return primes;\r\n+        } // end getPrimes\r\n+\r\n+    /**\r\n+      * calculate the sieve, bit map of all primes 0..n\r\n+      * @param n highest number evalutated by the sieve, not necessarily prime.\r\n+      */\r\n+    private final void sieve ( int n )\r\n+        {\r\n+        // Presume BitSet b set is big enough for our purposes.\r\n+        // Presume all even numbers are already marked composite, effectively.\r\n+        // Presume all odd numbers are already marked prime (0 in bit map).\r\n+        int last = (int)(Math.sqrt(n))+1;\r\n+        for (int candidate = 3; candidate <= last; candidate += 2)\r\n+            {\r\n+            // only look at odd numbers\r\n+            if (!b.get(candidate/2) /* if candidate is prime */)\r\n+                {\r\n+                // Our candidate is prime.\r\n+                // Only bother to mark multiples of primes. Others already done.\r\n+                // no need to mark even multiples, already done\r\n+                int incr = candidate*2;\r\n+                for ( int multiple = candidate + incr; multiple < n; multiple += incr)\r\n+                    {\r\n+                    b.set(multiple/2); // mark multiple as composite\r\n+                    } // end for multiple\r\n+                } // end if\r\n+            } // end for candidate\r\n+        // at this point our sieve b is correct, except for 0..2\r\n+        } // end sieve\r\n+\r\n+    /**\r\n+      * Ensure have a sieve to tackle primes as big as n.\r\n+      * If we don't allocate a sieve big enough and calculate it.\r\n+      * @param n - ensure sieve big enough to evaluate n for primality.\r\n+      */\r\n+    private void ensureCapacity (int n)\r\n+        {\r\n+        if ( n > sieveCapacity )\r\n+            {\r\n+            b = new BitSet((n+1)/2);\r\n+            // starts out all 0, presume all numbers prime\r\n+            sieveCapacity = n;\r\n+            sieve(n);\r\n+            }\r\n+        // otherwise existing sieve is fine\r\n+        } // end ensureCapacity\r\n+\r\n+    private int sieveCapacity;\r\n+    // biggest number we have computed in our sieve.\r\n+    // our BitSet array is indexed 0..N (odd only)\r\n+\r\n+    private BitSet b; /* true for each odd number if is composite */\r\n+\r\n+    /**\r\n+      * Demonstrate and test the methods\r\n+      */\r\n+    public static void main (String[] args)\r\n+        {\r\n+        // print primes 1..101\r\n+        Primes calc = new Primes(106);\r\n+        int[] primes = calc.getPrimes(101);\r\n+        for (int i=0; i<primes.length; i++)\r\n+            {\r\n+            System.out.println(primes[i]);\r\n+            }\r\n+\r\n+        // demonstrate isPrime, above, below\r\n+        System.out.println(calc.isPrime(149));\r\n+        System.out.println(calc.below(149));\r\n+        System.out.println(calc.above(149));\r\n+\r\n+        // print all the primes just greater than powers of 2\r\n+        calc = new Primes(10000000);\r\n+        for (int pow=8; pow < 10000000; pow*=2)\r\n+            System.out.println(calc.above(pow));\r\n+\r\n+        // Validate that isPrime works by comparing it with brute force\r\n+        for (int i=3; i<=151; i++)\r\n+            {\r\n+            boolean prime = true;\r\n+            for (int j=2; j<i; j++)\r\n+                {\r\n+                if (i % j == 0 )\r\n+                    {\r\n+                    prime = false;\r\n+                    break;\r\n+                    }\r\n+                } // end for j\r\n+            if ( calc.isPrime(i) != prime ) System.out.println(i + \" oops\");\r\n+            } // end for i\r\n+\r\n+        } // end main\r\n+} // end Primes\r"}, {"sha": "279398b6233bb897ede4744beb625285482e870c", "filename": "libjava/testsuite/libjava.lang/Primes.out", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3967ec43eafa885d2d346c407958151a548fa08/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3967ec43eafa885d2d346c407958151a548fa08/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FPrimes.out?ref=b3967ec43eafa885d2d346c407958151a548fa08", "patch": "@@ -0,0 +1,51 @@\n+1\n+2\n+3\n+5\n+7\n+11\n+13\n+17\n+19\n+23\n+29\n+31\n+37\n+41\n+43\n+47\n+53\n+59\n+61\n+67\n+71\n+73\n+79\n+83\n+89\n+97\n+101\n+true\n+139\n+151\n+11\n+17\n+37\n+67\n+131\n+257\n+521\n+1031\n+2053\n+4099\n+8209\n+16411\n+32771\n+65537\n+131101\n+262147\n+524309\n+1048583\n+2097169\n+4194319\n+8388617"}]}