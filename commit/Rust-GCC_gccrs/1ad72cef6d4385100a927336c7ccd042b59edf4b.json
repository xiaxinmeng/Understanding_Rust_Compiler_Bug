{"sha": "1ad72cef6d4385100a927336c7ccd042b59edf4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFkNzJjZWY2ZDQzODUxMDBhOTI3MzM2YzdjY2QwNDJiNTllZGY0Yg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-08-05T16:44:38Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-08-05T16:44:38Z"}, "message": "Fix gen_nop_type abort\n\nFrom-SVN: r44647", "tree": {"sha": "499d2f78fbf0cf915ed24453ea8594b71b11a9d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/499d2f78fbf0cf915ed24453ea8594b71b11a9d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ad72cef6d4385100a927336c7ccd042b59edf4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad72cef6d4385100a927336c7ccd042b59edf4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ad72cef6d4385100a927336c7ccd042b59edf4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ad72cef6d4385100a927336c7ccd042b59edf4b/comments", "author": null, "committer": null, "parents": [{"sha": "703cf2116b305e872abdc5728e6034af629817bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/703cf2116b305e872abdc5728e6034af629817bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/703cf2116b305e872abdc5728e6034af629817bf"}], "stats": {"total": 49, "additions": 35, "deletions": 14}, "files": [{"sha": "f81f01d91f0e6d706f638f1a30f1e256c4d53bbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad72cef6d4385100a927336c7ccd042b59edf4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad72cef6d4385100a927336c7ccd042b59edf4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ad72cef6d4385100a927336c7ccd042b59edf4b", "patch": "@@ -12,6 +12,9 @@\n \t(do_spill, do_restore): Use it to add REG_INC note.\n \t* config/ia64/ia64.md (movti_internal): Add REG_INC notes as needed.\n \n+\t* config/ia64/ia64.c (ia64_sched_reorder): Defer scheduling of\n+\tasms if other insns are available.\n+\n 2001-08-04  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \t* config/sh/sh.c (sh_asm_named_section): Fix typo in align"}, {"sha": "8ff1c8fc201f4ac8218940621a9f2c6804d00723", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ad72cef6d4385100a927336c7ccd042b59edf4b/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ad72cef6d4385100a927336c7ccd042b59edf4b/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=1ad72cef6d4385100a927336c7ccd042b59edf4b", "patch": "@@ -5982,10 +5982,10 @@ ia64_sched_reorder (dump, sched_verbose, ready, pn_ready,\n      int *pn_ready;\n      int reorder_type, clock_var;\n {\n+  int n_asms;\n   int n_ready = *pn_ready;\n   rtx *e_ready = ready + n_ready;\n   rtx *insnp;\n-  rtx highest;\n \n   if (sched_verbose)\n     {\n@@ -6029,32 +6029,50 @@ ia64_sched_reorder (dump, sched_verbose, ready, pn_ready,\n     maybe_rotate (sched_verbose ? dump : NULL);\n \n   /* First, move all USEs, CLOBBERs and other crud out of the way.  */\n-  highest = ready[n_ready - 1];\n+  n_asms = 0;\n   for (insnp = ready; insnp < e_ready; insnp++)\n     if (insnp < e_ready)\n       {\n \trtx insn = *insnp;\n \tenum attr_type t = ia64_safe_type (insn);\n \tif (t == TYPE_UNKNOWN)\n \t  {\n-\t    highest = ready[n_ready - 1];\n-\t    ready[n_ready - 1] = insn;\n-\t    *insnp = highest;\n-\t    if (ia64_final_schedule && group_barrier_needed_p (insn))\n+\t    if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t\t|| asm_noperands (PATTERN (insn)) >= 0)\n \t      {\n-\t\tschedule_stop (sched_verbose ? dump : NULL);\n-\t\tsched_data.last_was_stop = 1;\n-\t\tmaybe_rotate (sched_verbose ? dump : NULL);\n+\t\trtx lowest = ready[0];\n+\t\tready[0] = insn;\n+\t\t*insnp = lowest;\n+\t\tn_asms++;\n \t      }\n-\t    else if (GET_CODE (PATTERN (insn)) == ASM_INPUT\n-\t\t     || asm_noperands (PATTERN (insn)) >= 0)\n+\t    else\n \t      {\n-\t\t/* It must be an asm of some kind.  */\n-\t\tcycle_end_fill_slots (sched_verbose ? dump : NULL);\n+\t\trtx highest = ready[n_ready - 1];\n+\t\tready[n_ready - 1] = insn;\n+\t\t*insnp = highest;\n+\t\tif (ia64_final_schedule && group_barrier_needed_p (insn))\n+\t\t  {\n+\t\t    schedule_stop (sched_verbose ? dump : NULL);\n+\t\t    sched_data.last_was_stop = 1;\n+\t\t    maybe_rotate (sched_verbose ? dump : NULL);\n+\t\t  }\n+\n+\t\treturn 1;\n \t      }\n-\t    return 1;\n \t  }\n       }\n+  if (n_asms < n_ready)\n+    {\n+      /* Some normal insns to process.  Skip the asms.  */\n+      ready += n_asms;\n+      n_ready -= n_asms;\n+    }\n+  else if (n_ready > 0)\n+    {\n+      /* Only asm insns left.  */\n+      cycle_end_fill_slots (sched_verbose ? dump : NULL);\n+      return 1;\n+    }\n \n   if (ia64_final_schedule)\n     {"}]}