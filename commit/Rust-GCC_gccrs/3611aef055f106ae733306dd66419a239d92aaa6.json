{"sha": "3611aef055f106ae733306dd66419a239d92aaa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYxMWFlZjA1NWYxMDZhZTczMzMwNmRkNjY0MTlhMjM5ZDkyYWFhNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-10-30T21:46:57Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-10-30T21:46:57Z"}, "message": "alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Call secondary_reload_class.\n\n        * alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Call secondary_reload_class.\n        (SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n        (PREDICATE_CODES): Add addition_operation.\n        * alpha-protos.h (addition_operation): Declare.\n        (secondary_reload_class): Likewise.\n        * alpha.c (addition_operation): New.\n        (secondary_reload_class): New, from old SECONDARY_INPUT_RELOAD_CLASS.\n        * alpha.md (adddi3): Turn into expander.\n        (*lda, *adddi_2): New.\n        (movsf, movdf patterns): Don't preference integer regs.\n        (movsi, movdi patterns): Don't preference fp regs.\n\nFrom-SVN: r30277", "tree": {"sha": "55102708bebcf895b99da75dfa5a7703462b2ddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55102708bebcf895b99da75dfa5a7703462b2ddd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3611aef055f106ae733306dd66419a239d92aaa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3611aef055f106ae733306dd66419a239d92aaa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3611aef055f106ae733306dd66419a239d92aaa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3611aef055f106ae733306dd66419a239d92aaa6/comments", "author": null, "committer": null, "parents": [{"sha": "1e1933372608930414255b4f5124713d227f2f9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e1933372608930414255b4f5124713d227f2f9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e1933372608930414255b4f5124713d227f2f9c"}], "stats": {"total": 241, "additions": 151, "deletions": 90}, "files": [{"sha": "1a41457dcbf106f7525c673ad0366824e62d2ca5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3611aef055f106ae733306dd66419a239d92aaa6", "patch": "@@ -1,3 +1,17 @@\n+Sat Oct 30 14:41:40 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.h (SECONDARY_INPUT_RELOAD_CLASS): Call secondary_reload_class.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS): Likewise.\n+\t(PREDICATE_CODES): Add addition_operation.\n+\t* alpha-protos.h (addition_operation): Declare.\n+\t(secondary_reload_class): Likewise.\n+\t* alpha.c (addition_operation): New.\n+\t(secondary_reload_class): New, from old SECONDARY_INPUT_RELOAD_CLASS.\n+\t* alpha.md (adddi3): Turn into expander.\n+\t(*lda, *adddi_2): New.\n+\t(movsf, movdf patterns): Don't preference integer regs.\n+\t(movsi, movdi patterns): Don't preference fp regs.\n+\n Sat Oct 30 14:38:22 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* genrecog.c (write_switch): Check for duplicate CODE cases."}, {"sha": "9a47854b1d1e1383ecfa5207eacdd08c31f7161e", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=3611aef055f106ae733306dd66419a239d92aaa6", "patch": "@@ -66,10 +66,13 @@ extern int any_memory_operand PROTO ((rtx, enum machine_mode));\n extern int reg_not_elim_operand PROTO ((rtx, enum machine_mode));\n extern int normal_memory_operand PROTO ((rtx, enum machine_mode));\n extern int reg_no_subreg_operand PROTO ((rtx, enum machine_mode));\n+extern int addition_operation PROTO ((rtx, enum machine_mode));\n \n extern void get_aligned_mem PROTO ((rtx, rtx *, rtx *));\n extern rtx get_unaligned_address PROTO ((rtx, int));\n-\n+extern enum reg_class secondary_reload_class PROTO ((enum reg_class,\n+\t\t\t\t\t\t     enum machine_mode, \n+\t\t\t\t\t\t     rtx, int));\n extern void alpha_set_memflags PROTO ((rtx, rtx));\n extern rtx alpha_emit_set_const PROTO ((rtx, enum machine_mode,\n \t\t\t\t\tHOST_WIDE_INT, int));"}, {"sha": "07e70612b5fa56a6b53aad63bfe507d64065fea9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=3611aef055f106ae733306dd66419a239d92aaa6", "patch": "@@ -939,7 +939,26 @@ reg_no_subreg_operand (op, mode)\n     return 0;\n   return register_operand (op, mode);\n }\n-\f\n+\n+/* Recognize a addition operation that includes a constant.  Used to\n+   convince reload to canonize (plus (plus reg c1) c2) during register\n+   elimination.  */\n+\n+int\n+addition_operation (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode && mode != VOIDmode)\n+    return 0;\n+  if (GET_CODE (op) == PLUS\n+      && register_operand (XEXP (op, 0), mode)\n+      && GET_CODE (XEXP (op, 1)) == CONST_INT\n+      && CONST_OK_FOR_LETTER_P (INTVAL (XEXP (op, 1)), 'K'))\n+    return 1;\n+  return 0;\n+}\n+\n /* Return 1 if this function can directly return via $26.  */\n \n int\n@@ -950,7 +969,7 @@ direct_return ()\n \t  && current_function_outgoing_args_size == 0\n \t  && current_function_pretend_args_size == 0);\n }\n-\n+\f\n /* REF is an alignable memory location.  Place an aligned SImode\n    reference into *PALIGNED_MEM and the number of bits to shift into\n    *PBITNUM.  SCRATCH is a free register for use in reloading out\n@@ -1026,6 +1045,53 @@ get_unaligned_address (ref, extra_offset)\n \n   return plus_constant (base, offset + extra_offset);\n }\n+\n+/* Loading and storing HImode or QImode values to and from memory\n+   usually requires a scratch register.  The exceptions are loading\n+   QImode and HImode from an aligned address to a general register\n+   unless byte instructions are permitted. \n+\n+   We also cannot load an unaligned address or a paradoxical SUBREG\n+   into an FP register. \n+\n+   We also cannot do integral arithmetic into FP regs, as might result\n+   from register elimination into a DImode fp register.  */\n+\n+enum reg_class\n+secondary_reload_class (class, mode, x, in)\n+     enum reg_class class;\n+     enum machine_mode mode;\n+     rtx x;\n+     int in;\n+{\n+  if ((GET_CODE (x) == MEM\n+       || (GET_CODE (x) == REG && REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+       || (GET_CODE (x) == SUBREG\n+\t   && (GET_CODE (SUBREG_REG (x)) == MEM\n+\t       || (GET_CODE (SUBREG_REG (x)) == REG\n+\t\t   && REGNO (SUBREG_REG (x)) >= FIRST_PSEUDO_REGISTER))))\n+      && ((class == FLOAT_REGS\n+\t   && (mode == SImode || mode == HImode || mode == QImode))\n+\t  || ((mode == QImode || mode == HImode)\n+\t      && ! TARGET_BWX && ! aligned_memory_operand (x, mode))))\n+    return GENERAL_REGS;\n+\n+  if (class == FLOAT_REGS)\n+    {\n+      if (GET_CODE (x) == MEM && GET_CODE (XEXP (x, 0)) == AND)\n+\treturn GENERAL_REGS;\n+\n+      if (GET_CODE (x) == SUBREG\n+\t  && (GET_MODE_SIZE (GET_MODE (x))\n+\t      > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n+\treturn GENERAL_REGS;\n+\n+      if (in && INTEGRAL_MODE_P (mode) && ! general_operand (x, mode))\n+\treturn GENERAL_REGS;\n+    }\n+\n+  return NO_REGS;\n+}\n \f\n /* Subfunction of the following function.  Update the flags of any MEM\n    found in part of X.  */"}, {"sha": "2266f50009d298cc283444a7d44b667876340e02", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 7, "deletions": 37, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=3611aef055f106ae733306dd66419a239d92aaa6", "patch": "@@ -815,42 +815,11 @@ enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    We also cannot load an unaligned address or a paradoxical SUBREG into an\n    FP register.   */\n \n-#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN)\t\t\t\\\n-(((GET_CODE (IN) == MEM \t\t\t\t\t\t\\\n-   || (GET_CODE (IN) == REG && REGNO (IN) >= FIRST_PSEUDO_REGISTER)\t\\\n-   || (GET_CODE (IN) == SUBREG\t\t\t\t\t\t\\\n-       && (GET_CODE (SUBREG_REG (IN)) == MEM\t\t\t\t\\\n-\t   || (GET_CODE (SUBREG_REG (IN)) == REG\t\t\t\\\n-\t       && REGNO (SUBREG_REG (IN)) >= FIRST_PSEUDO_REGISTER))))\t\\\n-  && (((CLASS) == FLOAT_REGS\t\t\t\t\t\t\\\n-       && ((MODE) == SImode || (MODE) == HImode || (MODE) == QImode))\t\\\n-      || (((MODE) == QImode || (MODE) == HImode)\t\t\t\\\n-\t  && ! TARGET_BWX && ! aligned_memory_operand (IN, MODE))))\t\\\n- ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n- : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == MEM\t\t\t\\\n-    && GET_CODE (XEXP (IN, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n- : ((CLASS) == FLOAT_REGS && GET_CODE (IN) == SUBREG\t\t\t\\\n-    && (GET_MODE_SIZE (GET_MODE (IN))\t\t\t\t\t\\\n-\t> GET_MODE_SIZE (GET_MODE (SUBREG_REG (IN))))) ? GENERAL_REGS\t\\\n- : NO_REGS)\n-\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT)\t\t\t\\\n-(((GET_CODE (OUT) == MEM \t\t\t\t\t\t\\\n-   || (GET_CODE (OUT) == REG && REGNO (OUT) >= FIRST_PSEUDO_REGISTER)\t\\\n-   || (GET_CODE (OUT) == SUBREG\t\t\t\t\t\t\\\n-       && (GET_CODE (SUBREG_REG (OUT)) == MEM\t\t\t\t\\\n-\t   || (GET_CODE (SUBREG_REG (OUT)) == REG\t\t\t\\\n-\t       && REGNO (SUBREG_REG (OUT)) >= FIRST_PSEUDO_REGISTER)))) \\\n-  && ((((MODE) == HImode || (MODE) == QImode)\t\t\t\t\\\n-       && (! TARGET_BWX || (CLASS) == FLOAT_REGS))\t\t\t\\\n-      || ((MODE) == SImode && (CLASS) == FLOAT_REGS)))\t\t\t\\\n- ? GENERAL_REGS\t\t\t\t\t\t\t\t\\\n- : ((CLASS) == FLOAT_REGS && GET_CODE (OUT) == MEM\t\t\t\\\n-    && GET_CODE (XEXP (OUT, 0)) == AND) ? GENERAL_REGS\t\t\t\\\n- : ((CLASS) == FLOAT_REGS && GET_CODE (OUT) == SUBREG\t\t\t\\\n-    && (GET_MODE_SIZE (GET_MODE (OUT))\t\t\t\t\t\\\n-\t> GET_MODE_SIZE (GET_MODE (SUBREG_REG (OUT))))) ? GENERAL_REGS\t\\\n- : NO_REGS)\n+#define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class((CLASS), (MODE), (IN), 1)\n+\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,OUT) \\\n+  secondary_reload_class((CLASS), (MODE), (OUT), 0)\n \n /* If we are copying between general and FP registers, we need a memory\n    location unless the FIX extension is available.  */\n@@ -2340,7 +2309,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"any_memory_operand\", {MEM}},\t\t\t\t\t\\\n   {\"hard_fp_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"reg_not_elim_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"reg_no_subreg_operand\", {REG}},\n+  {\"reg_no_subreg_operand\", {REG}},\t\t\t\t\t\\\n+  {\"addition_operation\", {PLUS}},\n \f\n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\"}, {"sha": "c5a0db1264da6ececc985055c6b0f3fc153285b6", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3611aef055f106ae733306dd66419a239d92aaa6/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=3611aef055f106ae733306dd66419a239d92aaa6", "patch": "@@ -542,39 +542,47 @@\n   operands[7] = gen_lowpart (SImode, operands[5]);\n }\")\n \n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(plus:DI (match_operand:DI 1 \"reg_or_0_operand\" \"%rJ,rJ,rJ,rJ\")\n-\t\t (match_operand:DI 2 \"add_operand\" \"rI,O,K,L\")))]\n+(define_expand \"adddi3\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n+\t\t (match_operand:DI 2 \"add_operand\" \"\")))]\n   \"\"\n-  \"*\n-{\n-  static const char * const pattern[4] = {\n-    \\\"addq %r1,%2,%0\\\",\n-    \\\"subq %r1,%n2,%0\\\",\n-    \\\"lda %0,%2(%r1)\\\",\n-    \\\"ldah %0,%h2(%r1)\\\"\n-  };\n-\n-  /* The NT stack unwind code can't handle a subq to adjust the stack\n-     (that's a bug, but not one we can do anything about).  As of NT4.0 SP3,\n-     the exception handling code will loop if a subq is used and an\n-     exception occurs.\n-\n-     The 19980616 change to emit prologues as RTL also confused some\n-     versions of GDB, which also interprets prologues.  This has been\n-     fixed as of GDB 4.18, but it does not harm to unconditionally\n-     use lda here.  */\n-\n-  int which = which_alternative;\n-\n-  if (operands[0] == stack_pointer_rtx\n-      && GET_CODE (operands[2]) == CONST_INT\n-      && CONST_OK_FOR_LETTER_P (INTVAL (operands[2]), 'K'))\n-    which = 2;\n-\n-  return pattern[which];\n-}\")\n+  \"\")\n+\n+;; This pattern exists so that register elimination tries to canonize\n+;; (plus (plus reg c1) c2).\n+\n+(define_insn \"*lda\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (match_operand:DI 1 \"addition_operation\" \"p\"))]\n+  \"\"\n+  \"lda %0,%a1\")\n+\n+;; We used to expend quite a lot of effort choosing addq/subq/lda.\n+;; With complications like\n+;;\n+;;   The NT stack unwind code can't handle a subq to adjust the stack\n+;;   (that's a bug, but not one we can do anything about).  As of NT4.0 SP3,\n+;;   the exception handling code will loop if a subq is used and an\n+;;   exception occurs.\n+;;  \n+;;   The 19980616 change to emit prologues as RTL also confused some\n+;;   versions of GDB, which also interprets prologues.  This has been\n+;;   fixed as of GDB 4.18, but it does not harm to unconditionally\n+;;   use lda here.\n+;;\n+;; and the fact that the three insns schedule exactly the same, it's\n+;; just not worth the effort.\n+\n+(define_insn \"*adddi_2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%r,r,r\")\n+\t\t (match_operand:DI 2 \"add_operand\" \"r,K,L\")))]\n+  \"\"\n+  \"@\n+   addq %1,%2,%0\n+   lda %0,%2(%1)\n+   ldah %0,%h2(%1)\")\n \n ;; ??? Allow large constants when basing off the frame pointer or some\n ;; virtual register that may eliminate to the frame pointer.  This is\n@@ -4004,8 +4012,8 @@\n ;; they are simpler.\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,r,r,m,m\")\n-\t(match_operand:SF 1 \"input_operand\" \"fG,m,rG,m,fG,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m\")\n+\t(match_operand:SF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r\"))]\n   \"! TARGET_FIX\n    && (register_operand (operands[0], SFmode)\n        || reg_or_fp0_operand (operands[1], SFmode))\"\n@@ -4019,8 +4027,8 @@\n   [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,r,r,m,m,f,*r\")\n-\t(match_operand:SF 1 \"input_operand\" \"fG,m,rG,m,fG,r,r,*f\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m,f,*r\")\n+\t(match_operand:SF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r,*r,f\"))]\n   \"TARGET_FIX\n    && (register_operand (operands[0], SFmode)\n        || reg_or_fp0_operand (operands[1], SFmode))\"\n@@ -4036,8 +4044,8 @@\n   [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist,itof,ftoi\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,r,r,m,m\")\n-\t(match_operand:DF 1 \"input_operand\" \"fG,m,rG,m,fG,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m\")\n+\t(match_operand:DF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r\"))]\n   \"! TARGET_FIX\n    && (register_operand (operands[0], DFmode)\n        || reg_or_fp0_operand (operands[1], DFmode))\"\n@@ -4051,8 +4059,8 @@\n   [(set_attr \"type\" \"fcpys,fld,ilog,ild,fst,ist\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,r,r,m,m,f,*r\")\n-\t(match_operand:DF 1 \"input_operand\" \"fG,m,rG,m,fG,r,r,*f\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,f,*r,*r,m,m,f,*r\")\n+\t(match_operand:DF 1 \"input_operand\" \"fG,m,*rG,m,fG,*r,*r,f\"))]\n   \"TARGET_FIX\n    && (register_operand (operands[0], DFmode)\n        || reg_or_fp0_operand (operands[1], DFmode))\"\n@@ -4090,8 +4098,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,f,f,m\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,fJ,m,f\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*f,*f,m\")\n+\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,*fJ,m,*f\"))]\n   \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && ! TARGET_FIX\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n@@ -4107,8 +4115,8 @@\n   [(set_attr \"type\" \"ilog,iadd,iadd,ild,ist,fcpys,fld,fst\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,f,f,m,r,*f\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,fJ,m,f,f,*r\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*f,*f,m,r,*f\")\n+\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,*fJ,m,*f,*f,r\"))]\n   \"! TARGET_WINDOWS_NT && ! TARGET_OPEN_VMS && TARGET_FIX\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n@@ -4126,8 +4134,8 @@\n   [(set_attr \"type\" \"ilog,iadd,iadd,ild,ist,fcpys,fld,fst,ftoi,itof\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,f,f,m\")\n-\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,fJ,m,f\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,m\")\n+\t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,m,*f\"))]\n   \"(TARGET_WINDOWS_NT || TARGET_OPEN_VMS)\n     && (register_operand (operands[0], SImode)\n         || reg_or_0_operand (operands[1], SImode))\"\n@@ -4235,8 +4243,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,f,f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,fJ,Q,f\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,Q,*f\"))]\n   \"! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n@@ -4253,8 +4261,8 @@\n   [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,f,f,Q,r,*f\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,fJ,Q,f,f,*r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q,r,*f\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,Q,*f,*f,r\"))]\n   \"TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\""}]}