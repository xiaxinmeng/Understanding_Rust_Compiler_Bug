{"sha": "465a9c51e7d5bafa7a81195b5af20f2a54f22210", "node_id": "C_kwDOANBUbNoAKDQ2NWE5YzUxZTdkNWJhZmE3YTgxMTk1YjVhZjIwZjJhNTRmMjIyMTA", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-02-02T12:52:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2023-02-02T12:52:45Z"}, "message": "sched-deps, cselib: Fix up some -fcompare-debug issues and regressions [PR108463]\n\nOn Sat, Jan 14, 2023 at 08:26:00AM -0300, Alexandre Oliva via Gcc-patches wrote:\n> The testcase used to get scheduled differently depending on the\n> presence of debug insns with MEMs.  It's not clear to me why those\n> MEMs affected scheduling, but the cselib pre-canonicalization of the\n> MEM address is not used at all when analyzing debug insns, so the\n> memory allocation and lookup are pure waste.  Somehow, avoiding that\n> waste fixes the problem, or makes it go latent.\n\nUnfortunately, this patch breaks the following testcase.\nThe code in sched_analyze_2 did 2 things:\n1) cselib_lookup_from_insn\n2) shallow_copy_rtx + cselib_subst_to_values_from_insn\nNow, 1) is precondition of 2), we can only subst the VALUEs if we\nhave actually looked the address up, but as can be seen on that testcase,\nwe are relying on at least the 1) to be done because we subst the values\nlater on even on DEBUG_INSNs and actually use those when needed.\ncselib_subst_to_values_from_insn mostly just replaces stuff in the\nreturned rtx, except for:\n      /* This used to happen for autoincrements, but we deal with them\n         properly now.  Remove the if stmt for the next release.  */\n      if (! e)\n        {\n          /* Assign a value that doesn't match any other.  */\n          e = new_cselib_val (next_uid, GET_MODE (x), x);\n        }\nwhich is like that since 2011, I hope it is never reachable and we should\nin stage1 replace that with gcc_assert or just remove (then it will\nsegfault on following\n      return e->val_rtx;\n).\n\nSo, I (as done in the patch below) reinstalled the 1) and not 2) for\nDEBUG_INSNs.  This fixed the new testcase, but broke again the PR106746\ntestcases.\n\nI've spent a day debugging that and found the problem is that as documented\nin a large comment in cselib.cc above n_useless_values variable definition,\nwe spend quite a few effort on making sure that VALUEs created on\nDEBUG_INSNs don't affect the cselib decisions for non-DEBUG_INSNs such as\npruning of useless values etc., but if a VALUE created that way is then\nlooked up/needed from non-DEBUG_INSNs, we promote it to non-debug.\n\nThe reason for -fcompare-debug failure is that there is one large DEBUG_INSN\nwith 16 MEMs in it mostly with addresses that so far didn't appear in the IL\notherwise.  Later on, we see an instruction storing into MEM destination\nand invalidate that MEM.  Unfortunately, there is a bug caused by the\nintroduction of SP_DERIVED_VALUE_P where alias.cc isn't able to disambiguate\nMEMs with sp + optional offset in address vs. MEMs with address being a\nVALUE having SP_DERIVED_VALUE_P + constant (or the SP_DERIVED_VALUE_P\nitself), which ought to be possible when REG_VALUES (REGNO\n(stack_pointer_rtx)) has SP_DERIVED_VALUE_P + constant location.  Not sure\nif I should try to fix that in stage4 or defer for stage1.\nAnyway, the cselib_invalidate_mem call because of this invalidates basically\nall MEMs with the exception of 5 which have MEM_EXPRs that guarantee\nnon-aliasing with the sp based store.\nUnfortunately, n_useless_values which in my understanding should be always\nthe same between -g and -g0 compilations diverges, has 3 more useless values\nfor -g.\n\nNow, these were initially VALUEs created for DEBUG_INSN lookups.  As I said,\ncselib.cc has code to promote such VALUEs (well, their location elements) to\nnon-debug if they are looked up from non-DEBUG_INSNs.  The problem is that\nwhen looking some completely unrelated MEM from a non-DEBUG_INSN we run into\na hash collision and so call cselib_hasher::equal to check if the unrelated\nMEM is equal to the one from DEBUG_INSN only element.  The equal static\nmember function calls rtx_equal_for_cselib_1 and if that returns true,\npromotes the location to non-DEBUG, otherwise returns false.  So far so\ngood.  But rtx_equal_for_cselib_1 internally performs various other cselib\nlookups, all done with the non-DEBUG_INSN cselib_current_insn, so they\nall promote to non-debug.  And that is wrong, because if it was -g0\ncompilation, such hashtable entry wouldn't be there at all (or would be\nbut wouldn't contain that locs element), so with -g0 we wouldn't call\nthat rtx_equal_for_cselib_1 at all.  So, I think we need to pretend\nthat such lookup which only happens with -g and not -g0 actually comes\nfrom some DEBUG_INSN (note, the lookups rtx_equal_for_cselib_1 does\nare always with create = 0).\nThe cselib.cc part of the patch does that.\n\nBTW, I'm not really sure how:\n          if (num_mems < param_max_cselib_memory_locations\n              && ! canon_anti_dependence (x, false, mem_rtx,\n                                          GET_MODE (mem_rtx), mem_addr))\n            {\n              has_mem = true;\n              num_mems++;\n              p = &(*p)->next;\n              continue;\n            }\nnum_mems cap can actually work correctly for -fcompare-debug,\nI'd think we would need to differentiate between num_debug_mems and\nnum_mems depending on if setting_insn is non-NULL DEBUG_INSN or not.\nThat was one of my suspicions on this testcase, but the number of MEMs\nwas small enough for the param in either case (especially because of\nthe above mentioned missed non-aliasings).  But as implemented, I think\nif we have tons of non-aliased MEMs from DEBUG_INSN setting_insns,\nwe could unchain lots more non-DEBUG MEMs with -g than with -g0.\n\n2023-02-02  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR debug/106746\n\tPR rtl-optimization/108463\n\tPR target/108484\n\t* cselib.cc (cselib_current_insn): Move declaration earlier.\n\t(cselib_hasher::equal): For debug only locs, temporarily override\n\tcselib_current_insn to their l->setting_insn for the\n\trtx_equal_for_cselib_1 call, so that unsuccessful comparisons don't\n\tpromote some debug locs.\n\t* sched-deps.cc (sched_analyze_2) <case MEM>: For MEMs in DEBUG_INSNs\n\twhen using cselib call cselib_lookup_from_insn on the address but\n\tdon't substitute it.\n\n\t* gcc.dg/pr108463.c: New test.", "tree": {"sha": "e08ac72154ceb09da7b75efea3c3afdab6008f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e08ac72154ceb09da7b75efea3c3afdab6008f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/465a9c51e7d5bafa7a81195b5af20f2a54f22210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/465a9c51e7d5bafa7a81195b5af20f2a54f22210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/465a9c51e7d5bafa7a81195b5af20f2a54f22210", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/465a9c51e7d5bafa7a81195b5af20f2a54f22210/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "605d1297b91c2c7c23ccfe669e66dda5791d1f55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/605d1297b91c2c7c23ccfe669e66dda5791d1f55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/605d1297b91c2c7c23ccfe669e66dda5791d1f55"}], "stats": {"total": 50, "additions": 42, "deletions": 8}, "files": [{"sha": "065867b4a84adc611585702bb4274e51564dd465", "filename": "gcc/cselib.cc", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465a9c51e7d5bafa7a81195b5af20f2a54f22210/gcc%2Fcselib.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465a9c51e7d5bafa7a81195b5af20f2a54f22210/gcc%2Fcselib.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.cc?ref=465a9c51e7d5bafa7a81195b5af20f2a54f22210", "patch": "@@ -80,6 +80,10 @@ struct expand_value_data\n \n static rtx cselib_expand_value_rtx_1 (rtx, struct expand_value_data *, int);\n \n+/* This is a global so we don't have to pass this through every function.\n+   It is used in new_elt_loc_list to set SETTING_INSN.  */\n+static rtx_insn *cselib_current_insn;\n+\n /* There are three ways in which cselib can look up an rtx:\n    - for a REG, the reg_values table (which is indexed by regno) is used\n    - for a MEM, we recursively look up its address and then follow the\n@@ -143,11 +147,25 @@ cselib_hasher::equal (const cselib_val *v, const key *x_arg)\n   /* We don't guarantee that distinct rtx's have different hash values,\n      so we need to do a comparison.  */\n   for (l = v->locs; l; l = l->next)\n-    if (rtx_equal_for_cselib_1 (l->loc, x, memmode, 0))\n+    if (l->setting_insn && DEBUG_INSN_P (l->setting_insn)\n+\t&& (!cselib_current_insn || !DEBUG_INSN_P (cselib_current_insn)))\n       {\n-\tpromote_debug_loc (l);\n-\treturn true;\n+\trtx_insn *save_cselib_current_insn = cselib_current_insn;\n+\t/* If l is so far a debug only loc, without debug stmts it\n+\t   would never be compared to x at all, so temporarily pretend\n+\t   current instruction is that DEBUG_INSN so that we don't\n+\t   promote other debug locs even for unsuccessful comparison.  */\n+\tcselib_current_insn = l->setting_insn;\n+\tbool match = rtx_equal_for_cselib_1 (l->loc, x, memmode, 0);\n+\tcselib_current_insn = save_cselib_current_insn;\n+\tif (match)\n+\t  {\n+\t    promote_debug_loc (l);\n+\t    return true;\n+\t  }\n       }\n+    else if (rtx_equal_for_cselib_1 (l->loc, x, memmode, 0))\n+      return true;\n \n   return false;\n }\n@@ -158,10 +176,6 @@ static hash_table<cselib_hasher> *cselib_hash_table;\n /* A table to hold preserved values.  */\n static hash_table<cselib_hasher> *cselib_preserved_hash_table;\n \n-/* This is a global so we don't have to pass this through every function.\n-   It is used in new_elt_loc_list to set SETTING_INSN.  */\n-static rtx_insn *cselib_current_insn;\n-\n /* The unique id that the next create value will take.  */\n static unsigned int next_uid;\n "}, {"sha": "2aa6623ad2ea264300748e705d79ccb41e9cbed1", "filename": "gcc/sched-deps.cc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465a9c51e7d5bafa7a81195b5af20f2a54f22210/gcc%2Fsched-deps.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465a9c51e7d5bafa7a81195b5af20f2a54f22210/gcc%2Fsched-deps.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.cc?ref=465a9c51e7d5bafa7a81195b5af20f2a54f22210", "patch": "@@ -2605,7 +2605,14 @@ sched_analyze_2 (class deps_desc *deps, rtx x, rtx_insn *insn)\n \n     case MEM:\n       {\n-\tif (!DEBUG_INSN_P (insn))\n+\tif (DEBUG_INSN_P (insn) && sched_deps_info->use_cselib)\n+\t  {\n+\t    machine_mode address_mode = get_address_mode (x);\n+\n+\t    cselib_lookup_from_insn (XEXP (x, 0), address_mode, 1,\n+\t\t\t\t     GET_MODE (x), insn);\n+\t  }\n+\telse if (!DEBUG_INSN_P (insn))\n \t  {\n \t    /* Reading memory.  */\n \t    rtx_insn_list *u;"}, {"sha": "6e94e7daed9867f4cb605c3cd329c54b937c3f15", "filename": "gcc/testsuite/gcc.dg/pr108463.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/465a9c51e7d5bafa7a81195b5af20f2a54f22210/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108463.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/465a9c51e7d5bafa7a81195b5af20f2a54f22210/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108463.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr108463.c?ref=465a9c51e7d5bafa7a81195b5af20f2a54f22210", "patch": "@@ -0,0 +1,13 @@\n+/* PR rtl-optimization/108463 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fsched2-use-superblocks -fcompare-debug -Wno-psabi\" } */\n+\n+typedef int __attribute__((__vector_size__ (32))) V;\n+int a;\n+\n+void\n+foo (V v)\n+{\n+  a--;\n+  v = (V) v;\n+}"}]}