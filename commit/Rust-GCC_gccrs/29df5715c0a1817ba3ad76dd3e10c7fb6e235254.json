{"sha": "29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkZjU3MTVjMGExODE3YmEzYWQ3NmRkM2UxMGM3ZmI2ZTIzNTI1NA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-12-10T18:25:58Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-12-10T18:25:58Z"}, "message": "Document libgccjit++.h\n\ngcc/jit/ChangeLog:\n\t* docs/cp/index.rst: New file.\n\t* docs/cp/intro/index.rst: New file.\n\t* docs/cp/intro/tutorial01.rst: New file.\n\t* docs/cp/intro/tutorial02.rst: New file.\n\t* docs/cp/intro/tutorial03.rst: New file.\n\t* docs/cp/intro/tutorial04.rst: New file.\n\t* docs/cp/topics/contexts.rst: New file.\n\t* docs/cp/topics/expressions.rst: New file.\n\t* docs/cp/topics/functions.rst: New file.\n\t* docs/cp/topics/index.rst: New file.\n\t* docs/cp/topics/locations.rst: New file.\n\t* docs/cp/topics/objects.rst: New file.\n\t* docs/cp/topics/results.rst: New file.\n\t* docs/cp/topics/types.rst: New file.\n\t* docs/examples/tut01-hello-world.cc: New file.\n\t* docs/examples/tut02-square.c: Fix missing newline in output.\n\t* docs/examples/tut02-square.cc: New file.\n\t* docs/examples/tut03-sum-of-squares.cc: New file.\n\t* docs/examples/tut04-toyvm/toyvm.cc: New file.\n\t* docs/index.rst: Move summary to above the table of contents.\n\tAdd text about the C vs C++ APIs.\n\t* docs/topics/contexts.rst: Fix a typo.\n\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\t* docs/_build/texinfo/factorial1.png: New file.\n\t* docs/_build/texinfo/sum-of-squares1.png: New file.\n\nFrom-SVN: r218588", "tree": {"sha": "7d2b3665134ff461d2c6383fbbadeb7c15357953", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d2b3665134ff461d2c6383fbbadeb7c15357953"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e56e603b72a8a878da237b3119a6dfb80e966524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56e603b72a8a878da237b3119a6dfb80e966524", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56e603b72a8a878da237b3119a6dfb80e966524"}], "stats": {"total": 10449, "additions": 10289, "deletions": 160}, "files": [{"sha": "1eb31a11722f0ef32368144295f0b1bc4d86a8b3", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -1,3 +1,32 @@\n+2014-12-10  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/cp/index.rst: New file.\n+\t* docs/cp/intro/index.rst: New file.\n+\t* docs/cp/intro/tutorial01.rst: New file.\n+\t* docs/cp/intro/tutorial02.rst: New file.\n+\t* docs/cp/intro/tutorial03.rst: New file.\n+\t* docs/cp/intro/tutorial04.rst: New file.\n+\t* docs/cp/topics/contexts.rst: New file.\n+\t* docs/cp/topics/expressions.rst: New file.\n+\t* docs/cp/topics/functions.rst: New file.\n+\t* docs/cp/topics/index.rst: New file.\n+\t* docs/cp/topics/locations.rst: New file.\n+\t* docs/cp/topics/objects.rst: New file.\n+\t* docs/cp/topics/results.rst: New file.\n+\t* docs/cp/topics/types.rst: New file.\n+\t* docs/examples/tut01-hello-world.cc: New file.\n+\t* docs/examples/tut02-square.c: Fix missing newline in output.\n+\t* docs/examples/tut02-square.cc: New file.\n+\t* docs/examples/tut03-sum-of-squares.cc: New file.\n+\t* docs/examples/tut04-toyvm/toyvm.cc: New file.\n+\t* docs/index.rst: Move summary to above the table of contents.\n+\tAdd text about the C vs C++ APIs.\n+\t* docs/topics/contexts.rst: Fix a typo.\n+\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\t* docs/_build/texinfo/factorial1.png: New file.\n+\t* docs/_build/texinfo/sum-of-squares1.png: New file.\n+\n 2014-12-09  David Malcolm  <dmalcolm@redhat.com>\n \n \t* docs/examples/tut04-toyvm/toyvm.c (toyvm_function_compile): Move"}, {"sha": "dff47ce276721746c2b1f1ae4059ea77c7bf5b75", "filename": "gcc/jit/docs/_build/texinfo/factorial1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Ffactorial1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Ffactorial1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Ffactorial1.png?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254"}, {"sha": "3f13219af7ae36f5208fe3834246d8e2eda7719f", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 5630, "deletions": 151, "changes": 5781, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254"}, {"sha": "7a3b4afff38e2f365ef2a09df997cb98d032fbcb", "filename": "gcc/jit/docs/_build/texinfo/sum-of-squares1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Fsum-of-squares1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Fsum-of-squares1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Fsum-of-squares1.png?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254"}, {"sha": "9483f14611fc0e680ec58eb20c11388e54984933", "filename": "gcc/jit/docs/cp/index.rst", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Findex.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,41 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+C++ bindings for libgccjit\n+==========================\n+\n+This document describes the C++ bindings to\n+`libgccjit <http://gcc.gnu.org/wiki/JIT>`_, an API for embedding GCC\n+inside programs and libraries.\n+\n+The C++ bindings consist of a single header file ``libgccjit++.h``.\n+\n+This is a collection of \"thin\" wrapper classes around the C API.\n+Everything is an inline function, implemented in terms of the C API,\n+so there is nothing extra to link against.\n+\n+Note that libgccjit is currently of \"Alpha\" quality;\n+the APIs are not yet set in stone, and they shouldn't be used in\n+production yet.\n+\n+Contents:\n+\n+.. toctree::\n+   :maxdepth: 2\n+\n+   intro/index.rst\n+   topics/index.rst"}, {"sha": "d3bcec93c75dbf21ecdc5276f54368a06b8e84bc", "filename": "gcc/jit/docs/cp/intro/index.rst", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Findex.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,27 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Tutorial\n+========\n+\n+.. toctree::\n+   :maxdepth: 2\n+\n+   tutorial01.rst\n+   tutorial02.rst\n+   tutorial03.rst\n+   tutorial04.rst"}, {"sha": "f9348ebbfdee5a5b1be62371e99d90cb6b0ceae1", "filename": "gcc/jit/docs/cp/intro/tutorial01.rst", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial01.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial01.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial01.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,52 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Tutorial part 1: \"Hello world\"\n+==============================\n+\n+Before we look at the details of the API, let's look at building and\n+running programs that use the library.\n+\n+Here's a toy \"hello world\" program that uses the library's C++ API to\n+synthesize a call to `printf` and uses it to write a message to stdout.\n+\n+Don't worry about the content of the program for now; we'll cover\n+the details in later parts of this tutorial.\n+\n+   .. literalinclude:: ../../examples/tut01-hello-world.cc\n+    :language: c++\n+\n+Copy the above to `tut01-hello-world.cc`.\n+\n+Assuming you have the jit library installed, build the test program\n+using:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut01-hello-world.cc \\\n+      -o tut01-hello-world \\\n+      -lgccjit\n+\n+You should then be able to run the built program:\n+\n+.. code-block:: console\n+\n+  $ ./tut01-hello-world\n+  hello world"}, {"sha": "97f001fdb6232a0e505f1d30f897f496b13cb73d", "filename": "gcc/jit/docs/cp/intro/tutorial02.rst", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial02.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial02.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial02.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,344 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Tutorial part 2: Creating a trivial machine code function\n+---------------------------------------------------------\n+\n+Consider this C function:\n+\n+.. code-block:: c\n+\n+   int square (int i)\n+   {\n+     return i * i;\n+   }\n+\n+How can we construct this at run-time using libgccjit's C++ API?\n+\n+First we need to include the relevant header:\n+\n+.. code-block:: c++\n+\n+  #include <libgccjit++.h>\n+\n+All state associated with compilation is associated with a\n+:type:`gccjit::context`, which is a thin C++ wrapper around the C API's\n+:c:type:`gcc_jit_context *`.\n+\n+Create one using :func:`gccjit::context::acquire`:\n+\n+.. code-block:: c++\n+\n+  gccjit::context ctxt;\n+  ctxt = gccjit::context::acquire ();\n+\n+The JIT library has a system of types.  It is statically-typed: every\n+expression is of a specific type, fixed at compile-time.  In our example,\n+all of the expressions are of the C `int` type, so let's obtain this from\n+the context, as a :type:`gccjit::type`, using\n+:func:`gccjit::context::get_type`:\n+\n+.. code-block:: c++\n+\n+  gccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n+\n+:type:`gccjit::type` is an example of a \"contextual\" object: every\n+entity in the API is associated with a :type:`gccjit::context`.\n+\n+Memory management is easy: all such \"contextual\" objects are automatically\n+cleaned up for you when the context is released, using\n+:func:`gccjit::context::release`:\n+\n+.. code-block:: c++\n+\n+  ctxt.release ();\n+\n+so you don't need to manually track and cleanup all objects, just the\n+contexts.\n+\n+All of the C++ classes in the API are thin wrappers around pointers to\n+types in the C API.\n+\n+The C++ class hierarchy within the ``gccjit`` namespace looks like this::\n+\n+  +- object\n+      +- location\n+      +- type\n+         +- struct\n+      +- field\n+      +- function\n+      +- block\n+      +- rvalue\n+          +- lvalue\n+             +- param\n+\n+One thing you can do with a :type:`gccjit::object` is\n+to ask it for a human-readable description as a :type:`std::string`, using\n+:func:`gccjit::object::get_debug_string`:\n+\n+.. code-block:: c++\n+\n+   printf (\"obj: %s\\n\", obj.get_debug_string ().c_str ());\n+\n+giving this text on stdout:\n+\n+.. code-block:: bash\n+\n+   obj: int\n+\n+This is invaluable when debugging.\n+\n+Let's create the function.  To do so, we first need to construct\n+its single parameter, specifying its type and giving it a name,\n+using :func:`gccjit::context::new_param`:\n+\n+.. code-block:: c++\n+\n+  gccjit::param param_i = ctxt.new_param (int_type, \"i\");\n+\n+and we can then make a vector of all of the params of the function,\n+in this case just one:\n+\n+.. code-block:: c++\n+\n+  std::vector<gccjit::param> params;\n+  params.push_back (param_i);\n+\n+Now we can create the function, using\n+:c:func:`gccjit::context::new_function`:\n+\n+.. code-block:: c++\n+\n+  gccjit::function func =\n+    ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                       int_type,\n+                       \"square\",\n+                       params,\n+                       0);\n+\n+To define the code within the function, we must create basic blocks\n+containing statements.\n+\n+Every basic block contains a list of statements, eventually terminated\n+by a statement that either returns, or jumps to another basic block.\n+\n+Our function has no control-flow, so we just need one basic block:\n+\n+.. code-block:: c++\n+\n+  gccjit::block block = func.new_block ();\n+\n+Our basic block is relatively simple: it immediately terminates by\n+returning the value of an expression.\n+\n+We can build the expression using :func:`gccjit::context::new_binary_op`:\n+\n+.. code-block:: c++\n+\n+   gccjit::rvalue expr =\n+     ctxt.new_binary_op (\n+       GCC_JIT_BINARY_OP_MULT, int_type,\n+       param_i, param_i);\n+\n+A :type:`gccjit::rvalue` is another example of a\n+:type:`gccjit::object` subclass.  As before, we can print it with\n+:func:`gccjit::object::get_debug_string`.\n+\n+.. code-block:: c++\n+\n+   printf (\"expr: %s\\n\", expr.get_debug_string ().c_str ());\n+\n+giving this output:\n+\n+.. code-block:: bash\n+\n+   expr: i * i\n+\n+Note that :type:`gccjit::rvalue` provides numerous overloaded operators\n+which can be used to dramatically reduce the amount of typing needed.\n+We can build the above binary operation more directly with this one-liner:\n+\n+.. code-block:: c++\n+\n+   gccjit::rvalue expr = param_i * param_i;\n+\n+Creating the expression in itself doesn't do anything; we have to add\n+this expression to a statement within the block.  In this case, we use it\n+to build a return statement, which terminates the basic block:\n+\n+.. code-block:: c++\n+\n+  block.end_with_return (expr);\n+\n+OK, we've populated the context.  We can now compile it using\n+:func:`gccjit::context::compile`:\n+\n+.. code-block:: c++\n+\n+   gcc_jit_result *result;\n+   result = ctxt.compile ();\n+\n+and get a :c:type:`gcc_jit_result *`.\n+\n+We can now use :c:func:`gcc_jit_result_get_code` to look up a specific\n+machine code routine within the result, in this case, the function we\n+created above.\n+\n+.. code-block:: c++\n+\n+   void *fn_ptr = gcc_jit_result_get_code (result, \"square\");\n+   if (!fn_ptr)\n+     {\n+       fprintf (stderr, \"NULL fn_ptr\");\n+       goto error;\n+     }\n+\n+We can now cast the pointer to an appropriate function pointer type, and\n+then call it:\n+\n+.. code-block:: c++\n+\n+  typedef int (*fn_type) (int);\n+  fn_type square = (fn_type)fn_ptr;\n+  printf (\"result: %d\", square (5));\n+\n+.. code-block:: bash\n+\n+  result: 25\n+\n+\n+Options\n+*******\n+\n+To get more information on what's going on, you can set debugging flags\n+on the context using :func:`gccjit::context::set_bool_option`.\n+\n+.. (I'm deliberately not mentioning\n+    :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE` here since I think\n+    it's probably more of use to implementors than to users)\n+\n+Setting :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE` will dump a\n+C-like representation to stderr when you compile (GCC's \"GIMPLE\"\n+representation):\n+\n+.. code-block:: c++\n+\n+   ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE, 1);\n+   result = ctxt.compile ();\n+\n+.. code-block:: c\n+\n+  square (signed int i)\n+  {\n+    signed int D.260;\n+\n+    entry:\n+    D.260 = i * i;\n+    return D.260;\n+  }\n+\n+We can see the generated machine code in assembler form (on stderr) by\n+setting :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE` on the context\n+before compiling:\n+\n+.. code-block:: c++\n+\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 1);\n+  result = ctxt.compile ();\n+\n+.. code-block:: gas\n+\n+        .file   \"fake.c\"\n+        .text\n+        .globl  square\n+        .type   square, @function\n+  square:\n+  .LFB6:\n+        .cfi_startproc\n+        pushq   %rbp\n+        .cfi_def_cfa_offset 16\n+        .cfi_offset 6, -16\n+        movq    %rsp, %rbp\n+        .cfi_def_cfa_register 6\n+        movl    %edi, -4(%rbp)\n+  .L14:\n+        movl    -4(%rbp), %eax\n+        imull   -4(%rbp), %eax\n+        popq    %rbp\n+        .cfi_def_cfa 7, 8\n+        ret\n+        .cfi_endproc\n+  .LFE6:\n+        .size   square, .-square\n+        .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n+        .section       .note.GNU-stack,\"\",@progbits\n+\n+By default, no optimizations are performed, the equivalent of GCC's\n+`-O0` option.  We can turn things up to e.g. `-O3` by calling\n+:func:`gccjit::context::set_int_option` with\n+:c:macro:`GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL`:\n+\n+.. code-block:: c++\n+\n+  ctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);\n+\n+.. code-block:: gas\n+\n+        .file   \"fake.c\"\n+        .text\n+        .p2align 4,,15\n+        .globl  square\n+        .type   square, @function\n+  square:\n+  .LFB7:\n+        .cfi_startproc\n+  .L16:\n+        movl    %edi, %eax\n+        imull   %edi, %eax\n+        ret\n+        .cfi_endproc\n+  .LFE7:\n+        .size   square, .-square\n+        .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-0.5.1920c315ff984892399893b380305ab36e07b455.fc20)\"\n+        .section        .note.GNU-stack,\"\",@progbits\n+\n+Naturally this has only a small effect on such a trivial function.\n+\n+\n+Full example\n+************\n+\n+Here's what the above looks like as a complete program:\n+\n+   .. literalinclude:: ../../examples/tut02-square.cc\n+    :lines: 1-\n+    :language: c++\n+\n+Building and running it:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut02-square.cc \\\n+      -o tut02-square \\\n+      -lgccjit\n+\n+  # Run the built program:\n+  $ ./tut02-square\n+  result: 25"}, {"sha": "c72d78f24159f1b56153515ea135b8758d4920a4", "filename": "gcc/jit/docs/cp/intro/tutorial03.rst", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial03.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial03.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial03.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,392 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Tutorial part 3: Loops and variables\n+------------------------------------\n+Consider this C function:\n+\n+ .. code-block:: c\n+\n+  int loop_test (int n)\n+  {\n+    int sum = 0;\n+    for (int i = 0; i < n; i++)\n+      sum += i * i;\n+    return sum;\n+  }\n+\n+This example demonstrates some more features of libgccjit, with local\n+variables and a loop.\n+\n+To break this down into libgccjit terms, it's usually easier to reword\n+the `for` loop as a `while` loop, giving:\n+\n+ .. code-block:: c\n+\n+  int loop_test (int n)\n+  {\n+    int sum = 0;\n+    int i = 0;\n+    while (i < n)\n+    {\n+      sum += i * i;\n+      i++;\n+    }\n+    return sum;\n+  }\n+\n+Here's what the final control flow graph will look like:\n+\n+    .. figure:: ../../intro/sum-of-squares.png\n+      :alt: image of a control flow graph\n+\n+As before, we include the libgccjit++ header and make a\n+:type:`gccjit::context`.\n+\n+.. code-block:: c++\n+\n+  #include <libgccjit++.h>\n+\n+  void test (void)\n+  {\n+    gccjit::context ctxt;\n+    ctxt = gccjit::context::acquire ();\n+\n+The function works with the C `int` type.\n+\n+In the previous tutorial we acquired this via\n+\n+.. code-block:: c++\n+\n+  gccjit::type the_type = ctxt.get_type (ctxt, GCC_JIT_TYPE_INT);\n+\n+though we could equally well make it work on, say, `double`:\n+\n+.. code-block:: c++\n+\n+  gccjit::type the_type = ctxt.get_type (ctxt, GCC_JIT_TYPE_DOUBLE);\n+\n+For integer types we can use :func:`gccjit::context::get_int_type<T>`\n+to directly bind a specific type:\n+\n+.. code-block:: c++\n+\n+  gccjit::type the_type = ctxt.get_int_type <int> ();\n+\n+Let's build the function:\n+\n+.. code-block:: c++\n+\n+  gcc_jit_param n = ctxt.new_param (the_type, \"n\");\n+  std::vector<gccjit::param> params;\n+  params.push_back (n);\n+  gccjit::function func =\n+    ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                       return_type,\n+                       \"loop_test\",\n+                       params, 0);\n+\n+Expressions: lvalues and rvalues\n+********************************\n+\n+The base class of expression is the :type:`gccjit::rvalue`,\n+representing an expression that can be on the *right*-hand side of\n+an assignment: a value that can be computed somehow, and assigned\n+*to* a storage area (such as a variable).  It has a specific\n+:type:`gccjit::type`.\n+\n+Anothe important class is :type:`gccjit::lvalue`.\n+A :type:`gccjit::lvalue`. is something that can of the *left*-hand\n+side of an assignment: a storage area (such as a variable).\n+\n+In other words, every assignment can be thought of as:\n+\n+.. code-block:: c\n+\n+   LVALUE = RVALUE;\n+\n+Note that :type:`gccjit::lvalue` is a subclass of\n+:type:`gccjit::rvalue`, where in an assignment of the form:\n+\n+.. code-block:: c\n+\n+   LVALUE_A = LVALUE_B;\n+\n+the `LVALUE_B` implies reading the current value of that storage\n+area, assigning it into the `LVALUE_A`.\n+\n+So far the only expressions we've seen are from the previous tutorial:\n+\n+1. the multiplication `i * i`:\n+\n+  .. code-block:: c++\n+\n+     gccjit::rvalue expr =\n+       ctxt.new_binary_op (\n+         GCC_JIT_BINARY_OP_MULT, int_type,\n+         param_i, param_i);\n+\n+     /* Alternatively, using operator-overloading: */\n+     gccjit::rvalue expr = param_i * param_i;\n+\n+  which is a :type:`gccjit::rvalue`, and\n+\n+2. the various function parameters: `param_i` and `param_n`, instances of\n+   :type:`gccjit::param`, which is a subclass of :type:`gccjit::lvalue`\n+   (and, in turn, of :type:`gccjit::rvalue`):\n+   we can both read from and write to function parameters within the\n+   body of a function.\n+\n+Our new example has a new kind of expression: we have two local\n+variables.  We create them by calling\n+:func:`gccjit::function::new_local`, supplying a type and a name:\n+\n+.. code-block:: c++\n+\n+  /* Build locals:  */\n+  gccjit::lvalue i = func.new_local (the_type, \"i\");\n+  gccjit::lvalue sum = func.new_local (the_type, \"sum\");\n+\n+These are instances of :type:`gccjit::lvalue` - they can be read from\n+and written to.\n+\n+Note that there is no precanned way to create *and* initialize a variable\n+like in C:\n+\n+.. code-block:: c\n+\n+   int i = 0;\n+\n+Instead, having added the local to the function, we have to separately add\n+an assignment of `0` to `local_i` at the beginning of the function.\n+\n+Control flow\n+************\n+\n+This function has a loop, so we need to build some basic blocks to\n+handle the control flow.  In this case, we need 4 blocks:\n+\n+1. before the loop (initializing the locals)\n+2. the conditional at the top of the loop (comparing `i < n`)\n+3. the body of the loop\n+4. after the loop terminates (`return sum`)\n+\n+so we create these as :type:`gccjit::block` instances within the\n+:type:`gccjit::function`:\n+\n+.. code-block:: c++\n+\n+  gccjit::block b_initial = func.new_block (\"initial\");\n+  gccjit::block b_loop_cond = func.new_block (\"loop_cond\");\n+  gccjit::block b_loop_body = func.new_block (\"loop_body\");\n+  gccjit::block b_after_loop = func.new_block (\"after_loop\");\n+\n+We now populate each block with statements.\n+\n+The entry block `b_initial` consists of initializations followed by a jump\n+to the conditional.  We assign `0` to `i` and to `sum`, using\n+:func:`gccjit::block::add_assignment` to add\n+an assignment statement, and using :func:`gccjit::context::zero` to get\n+the constant value `0` for the relevant type for the right-hand side of\n+the assignment:\n+\n+.. code-block:: c++\n+\n+  /* sum = 0; */\n+  b_initial.add_assignment (sum, ctxt.zero (the_type));\n+\n+  /* i = 0; */\n+  b_initial.add_assignment (i, ctxt.zero (the_type));\n+\n+We can then terminate the entry block by jumping to the conditional:\n+\n+.. code-block:: c++\n+\n+  b_initial.end_with_jump (b_loop_cond);\n+\n+The conditional block is equivalent to the line `while (i < n)` from our\n+C example. It contains a single statement: a conditional, which jumps to\n+one of two destination blocks depending on a boolean\n+:type:`gccjit::rvalue`, in this case the comparison of `i` and `n`.\n+\n+We could build the comparison using :func:`gccjit::context::new_comparison`:\n+\n+.. code-block:: c++\n+\n+   gccjit::rvalue guard =\n+     ctxt.new_comparison (GCC_JIT_COMPARISON_GE,\n+                          i, n);\n+\n+and can then use this to add `b_loop_cond`'s sole statement, via\n+:func:`gccjit::block::end_with_conditional`:\n+\n+.. code-block:: c++\n+\n+  b_loop_cond.end_with_conditional (guard);\n+\n+However :type:`gccjit::rvalue` has overloaded operators for this, so we\n+express the conditional as\n+\n+.. code-block:: c++\n+\n+   gccjit::rvalue guard = (i >= n);\n+\n+and hence write the block more concisely as:\n+\n+.. code-block:: c++\n+\n+  b_loop_cond.end_with_conditional (\n+    i >= n,\n+    b_after_loop,\n+    b_loop_body);\n+\n+Next, we populate the body of the loop.\n+\n+The C statement `sum += i * i;` is an assignment operation, where an\n+lvalue is modified \"in-place\".  We use\n+:func:`gccjit::block::add_assignment_op` to handle these operations:\n+\n+.. code-block:: c++\n+\n+  /* sum += i * i */\n+  b_loop_body.add_assignment_op (sum,\n+                                 GCC_JIT_BINARY_OP_PLUS,\n+                                 i * i);\n+\n+The `i++` can be thought of as `i += 1`, and can thus be handled in\n+a similar way.  We use :c:func:`gcc_jit_context_one` to get the constant\n+value `1` (for the relevant type) for the right-hand side\n+of the assignment.\n+\n+.. code-block:: c++\n+\n+  /* i++ */\n+  b_loop_body.add_assignment_op (i,\n+                                 GCC_JIT_BINARY_OP_PLUS,\n+                                 ctxt.one (the_type));\n+\n+.. note::\n+\n+  For numeric constants other than 0 or 1, we could use\n+  :func:`gccjit::context::new_rvalue`, which has overloads\n+  for both ``int`` and ``double``.\n+\n+The loop body completes by jumping back to the conditional:\n+\n+.. code-block:: c++\n+\n+  b_loop_body.end_with_jump (b_loop_cond);\n+\n+Finally, we populate the `b_after_loop` block, reached when the loop\n+conditional is false.  We want to generate the equivalent of:\n+\n+.. code-block:: c++\n+\n+   return sum;\n+\n+so the block is just one statement:\n+\n+.. code-block:: c++\n+\n+  /* return sum */\n+  b_after_loop.end_with_return (sum);\n+\n+.. note::\n+\n+   You can intermingle block creation with statement creation,\n+   but given that the terminator statements generally include references\n+   to other blocks, I find it's clearer to create all the blocks,\n+   *then* all the statements.\n+\n+We've finished populating the function.  As before, we can now compile it\n+to machine code:\n+\n+.. code-block:: c++\n+\n+   gcc_jit_result *result;\n+   result = ctxt.compile ();\n+\n+   ctxt.release ();\n+\n+   if (!result)\n+     {\n+       fprintf (stderr, \"NULL result\");\n+       return 1;\n+     }\n+\n+   typedef int (*loop_test_fn_type) (int);\n+   loop_test_fn_type loop_test =\n+    (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\n+   if (!loop_test)\n+     {\n+       fprintf (stderr, \"NULL loop_test\");\n+       gcc_jit_result_release (result);\n+       return 1;\n+     }\n+   printf (\"result: %d\", loop_test (10));\n+\n+.. code-block:: bash\n+\n+   result: 285\n+\n+\n+Visualizing the control flow graph\n+**********************************\n+\n+You can see the control flow graph of a function using\n+:func:`gccjit::function::dump_to_dot`:\n+\n+.. code-block:: c++\n+\n+  func.dump_to_dot (\"/tmp/sum-of-squares.dot\");\n+\n+giving a .dot file in GraphViz format.\n+\n+You can convert this to an image using `dot`:\n+\n+.. code-block:: bash\n+\n+   $ dot -Tpng /tmp/sum-of-squares.dot -o /tmp/sum-of-squares.png\n+\n+or use a viewer (my preferred one is xdot.py; see\n+https://github.com/jrfonseca/xdot.py; on Fedora you can\n+install it with `yum install python-xdot`):\n+\n+    .. figure:: ../../intro/sum-of-squares.png\n+      :alt: image of a control flow graph\n+\n+Full example\n+************\n+\n+   .. literalinclude:: ../../examples/tut03-sum-of-squares.cc\n+    :lines: 1-\n+    :language: c++\n+\n+Building and running it:\n+\n+.. code-block:: console\n+\n+  $ gcc \\\n+      tut03-sum-of-squares.cc \\\n+      -o tut03-sum-of-squares \\\n+      -lgccjit\n+\n+  # Run the built program:\n+  $ ./tut03-sum-of-squares\n+  loop_test returned: 285"}, {"sha": "9244195ac6c720d66bf4a52755e32033eac653d6", "filename": "gcc/jit/docs/cp/intro/tutorial04.rst", "status": "added", "additions": 1092, "deletions": 0, "changes": 1092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial04.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial04.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Fintro%2Ftutorial04.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,1092 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Tutorial part 4: Adding JIT-compilation to a toy interpreter\n+------------------------------------------------------------\n+In this example we construct a \"toy\" interpreter, and add JIT-compilation\n+to it.\n+\n+Our toy interpreter\n+*******************\n+\n+It's a stack-based interpreter, and is intended as a (very simple) example\n+of the kind of bytecode interpreter seen in dynamic languages such as\n+Python, Ruby etc.\n+\n+For the sake of simplicity, our toy virtual machine is very limited:\n+\n+  * The only data type is `int`\n+\n+  * It can only work on one function at a time (so that the only\n+    function call that can be made is to recurse).\n+\n+  * Functions can only take one parameter.\n+\n+  * Functions have a stack of `int` values.\n+\n+  * We'll implement function call within the interpreter by calling a\n+    function in our implementation, rather than implementing our own\n+    frame stack.\n+\n+  * The parser is only good enough to get the examples to work.\n+\n+Naturally, a real interpreter would be much more complicated that this.\n+\n+The following operations are supported:\n+\n+====================== ======================== =============== ==============\n+Operation              Meaning                  Old Stack       New Stack\n+====================== ======================== =============== ==============\n+DUP                    Duplicate top of stack.  ``[..., x]``    ``[..., x, x]``\n+ROT                    Swap top two elements    ``[..., x, y]`` ``[..., y, x]``\n+                       of stack.\n+BINARY_ADD             Add the top two elements ``[..., x, y]`` ``[..., (x+y)]``\n+                       on the stack.\n+BINARY_SUBTRACT        Likewise, but subtract.  ``[..., x, y]`` ``[..., (x-y)]``\n+BINARY_MULT            Likewise, but multiply.  ``[..., x, y]`` ``[..., (x*y)]``\n+BINARY_COMPARE_LT      Compare the top two      ``[..., x, y]`` ``[..., (x<y)]``\n+                       elements on the stack\n+                       and push a nonzero/zero\n+                       if (x<y).\n+RECURSE                Recurse, passing the top ``[..., x]``    ``[..., fn(x)]``\n+                       of the stack, and\n+                       popping the result.\n+RETURN                 Return the top of the    ``[x]``         ``[]``\n+                       stack.\n+PUSH_CONST `arg`       Push an int const.       ``[...]``       ``[..., arg]``\n+JUMP_ABS_IF_TRUE `arg` Pop; if top of stack was ``[..., x]``    ``[...]``\n+                       nonzero, jump to\n+                       ``arg``.\n+====================== ======================== =============== ==============\n+\n+Programs can be interpreted, disassembled, and compiled to machine code.\n+\n+The interpreter reads ``.toy`` scripts.  Here's what a simple recursive\n+factorial program looks like, the script ``factorial.toy``.\n+The parser ignores lines beginning with a `#`.\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/factorial.toy\n+    :lines: 1-\n+    :language: c\n+\n+The interpreter is a simple infinite loop with a big ``switch`` statement\n+based on what the next opcode is:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Execute the given function.  */\n+    :end-before: /* JIT compilation.  */\n+    :language: c++\n+\n+Compiling to machine code\n+*************************\n+We want to generate machine code that can be cast to this type and\n+then directly executed in-process:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Functions are compiled to this function ptr type.  */\n+    :end-before: enum opcode\n+    :language: c++\n+\n+Our compiler isn't very sophisticated; it takes the implementation of\n+each opcode above, and maps it directly to the operations supported by\n+the libgccjit API.\n+\n+How should we handle the stack?  In theory we could calculate what the\n+stack depth will be at each opcode, and optimize away the stack\n+manipulation \"by hand\".  We'll see below that libgccjit is able to do\n+this for us, so we'll implement stack manipulation\n+in a direct way, by creating a ``stack`` array and ``stack_depth``\n+variables, local within the generated function, equivalent to this C code:\n+\n+.. code-block:: c\n+\n+  int stack_depth;\n+  int stack[MAX_STACK_DEPTH];\n+\n+We'll also have local variables ``x`` and ``y`` for use when implementing\n+the opcodes, equivalent to this:\n+\n+.. code-block:: c\n+\n+  int x;\n+  int y;\n+\n+This means our compiler has the following state:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after:   /* State.  */\n+    :end-before: };\n+    :language: c++\n+\n+Setting things up\n+*****************\n+\n+First we create our types:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Create types.  */\n+    :end-before: /* The constant value 1.  */\n+    :language: c++\n+\n+along with extracting a useful `int` constant:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* The constant value 1.  */\n+    :end-before: /* Create locations.  */\n+    :language: c++\n+\n+We'll implement push and pop in terms of the ``stack`` array and\n+``stack_depth``.  Here are helper functions for adding statements to\n+a block, implementing pushing and popping values:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Stack manipulation.  */\n+    :end-before: /* Create the context. */\n+    :language: c++\n+\n+We will support single-stepping through the generated code in the\n+debugger, so we need to create :type:`gccjit::location` instances, one\n+per operation in the source code.  These will reference the lines of\n+e.g. ``factorial.toy``.\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Create locations.  */\n+    :end-before: /* Creating the function.  */\n+    :language: c++\n+\n+Let's create the function itself.  As usual, we create its parameter\n+first, then use the parameter to create the function:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Creating the function.  */\n+    :end-before: /* Create stack lvalues.  */\n+    :language: c++\n+\n+We create the locals within the function.\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Create stack lvalues.  */\n+    :end-before: /* 1st pass: create blocks, one per opcode.\n+    :language: c++\n+\n+Populating the function\n+***********************\n+\n+There's some one-time initialization, and the API treats the first block\n+you create as the entrypoint of the function, so we need to create that\n+block first:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: first.  */\n+    :end-before: /* Create a block per operation.  */\n+    :language: c++\n+\n+We can now create blocks for each of the operations.  Most of these will\n+be consolidated into larger blocks when the optimizer runs.\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Create a block per operation.  */\n+    :end-before: /* Populate the initial block.  */\n+    :language: c++\n+\n+Now that we have a block it can jump to when it's done, we can populate\n+the initial block:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Populate the initial block.  */\n+    :end-before: /* 2nd pass: fill in instructions.  */\n+    :language: c++\n+\n+We can now populate the blocks for the individual operations.  We loop\n+through them, adding instructions to their blocks:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* 2nd pass: fill in instructions.  */\n+    :end-before: /* Helper macros.  */\n+    :language: c++\n+\n+We're going to have another big ``switch`` statement for implementing\n+the opcodes, this time for compiling them, rather than interpreting\n+them.  It's helpful to have macros for implementing push and pop, so that\n+we can make the ``switch`` statement that's coming up look as much as\n+possible like the one above within the interpreter:\n+\n+.. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Helper macros.  */\n+    :end-before: block.add_comment\n+    :language: c++\n+\n+.. note::\n+\n+   A particularly clever implementation would have an *identical*\n+   ``switch`` statement shared by the interpreter and the compiler, with\n+   some preprocessor \"magic\".  We're not doing that here, for the sake\n+   of simplicity.\n+\n+When I first implemented this compiler, I accidentally missed an edit\n+when copying and pasting the ``Y_EQUALS_POP`` macro, so that popping the\n+stack into ``y`` instead erroneously assigned it to ``x``, leaving ``y``\n+uninitialized.\n+\n+To track this kind of thing down, we can use\n+:func:`gccjit::block::add_comment` to add descriptive comments\n+to the internal representation.  This is invaluable when looking through\n+the generated IR for, say ``factorial``:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: PUSH_RVALUE (y)\n+    :end-before: /* Handle the individual opcodes.  */\n+    :language: c++\n+\n+We can now write the big ``switch`` statement that implements the\n+individual opcodes, populating the relevant block with statements:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Handle the individual opcodes.  */\n+    :end-before: /* Go to the next block.  */\n+    :language: c++\n+\n+Every block must be terminated, via a call to one of the\n+``gccjit::block::end_with_`` entrypoints.  This has been done for two\n+of the opcodes, but we need to do it for the other ones, by jumping\n+to the next block.\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* Go to the next block.  */\n+    :end-before: /* end of loop on PC locations.  */\n+    :language: c++\n+\n+This is analogous to simply incrementing the program counter.\n+\n+Verifying the control flow graph\n+********************************\n+Having finished looping over the blocks, the context is complete.\n+\n+As before, we can verify that the control flow and statements are sane by\n+using :func:`gccjit::function::dump_to_dot`:\n+\n+.. code-block:: c++\n+\n+  fn.dump_to_dot (\"/tmp/factorial.dot\");\n+\n+and viewing the result.  Note how the label names, comments, and\n+variable names show up in the dump, to make it easier to spot\n+errors in our compiler.\n+\n+  .. figure:: ../../intro/factorial.png\n+    :alt: image of a control flow graph\n+\n+Compiling the context\n+*********************\n+Having finished looping over the blocks and populating them with\n+statements, the context is complete.\n+\n+We can now compile it, and extract machine code from the result:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* We've now finished populating the context.  Compile it.  */\n+    :end-before: /* (this leaks \"result\" and \"funcname\") */\n+    :language: c++\n+\n+We can now run the result:\n+\n+   .. literalinclude:: ../../examples/tut04-toyvm/toyvm.cc\n+    :start-after: /* JIT-compilation.  */\n+    :end-before: return 0;\n+    :language: c++\n+\n+Single-stepping through the generated code\n+******************************************\n+\n+It's possible to debug the generated code.  To do this we need to both:\n+\n+  * Set up source code locations for our statements, so that we can\n+    meaningfully step through the code.  We did this above by\n+    calling :func:`gccjit::context::new_location` and using the\n+    results.\n+\n+  * Enable the generation of debugging information, by setting\n+    :c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` on the\n+    :type:`gccjit::context` via\n+    :func:`gccjit::context::set_bool_option`:\n+\n+    .. code-block:: c++\n+\n+      ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DEBUGINFO, 1);\n+\n+Having done this, we can put a breakpoint on the generated function:\n+\n+.. code-block:: console\n+\n+  $ gdb --args ./toyvm factorial.toy 10\n+  (gdb) break factorial\n+  Function \"factorial\" not defined.\n+  Make breakpoint pending on future shared library load? (y or [n]) y\n+  Breakpoint 1 (factorial) pending.\n+  (gdb) run\n+  Breakpoint 1, factorial (arg=10) at factorial.toy:14\n+  14\tDUP\n+\n+We've set up location information, which references ``factorial.toy``.\n+This allows us to use e.g. ``list`` to see where we are in the script:\n+\n+.. code-block:: console\n+\n+  (gdb) list\n+  9\n+  10    # Initial state:\n+  11    # stack: [arg]\n+  12\n+  13    # 0:\n+  14    DUP\n+  15    # stack: [arg, arg]\n+  16\n+  17    # 1:\n+  18    PUSH_CONST 2\n+\n+and to step through the function, examining the data:\n+\n+.. code-block:: console\n+\n+  (gdb) n\n+  18    PUSH_CONST 2\n+  (gdb) n\n+  22    BINARY_COMPARE_LT\n+  (gdb) print stack\n+  $5 = {10, 10, 2, 0, -7152, 32767, 0, 0}\n+  (gdb) print stack_depth\n+  $6 = 3\n+\n+You'll see that the parts of the ``stack`` array that haven't been\n+touched yet are uninitialized.\n+\n+.. note::\n+\n+   Turning on optimizations may lead to unpredictable results when\n+   stepping through the generated code: the execution may appear to\n+   \"jump around\" the source code.  This is analogous to turning up the\n+   optimization level in a regular compiler.\n+\n+Examining the generated code\n+****************************\n+\n+How good is the optimized code?\n+\n+We can turn up optimizations, by calling\n+:cpp:func:`gccjit::context::set_int_option` with\n+:c:macro:`GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL`:\n+\n+.. code-block:: c++\n+\n+  ctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 3);\n+\n+One of GCC's internal representations is called \"gimple\".  A dump of the\n+initial gimple representation of the code can be seen by setting:\n+\n+.. code-block:: c++\n+\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE, 1);\n+\n+With optimization on and source locations displayed, this gives:\n+\n+.. We'll use \"c\" for gimple dumps\n+\n+.. code-block:: c\n+\n+  factorial (signed int arg)\n+  {\n+    <unnamed type> D.80;\n+    signed int D.81;\n+    signed int D.82;\n+    signed int D.83;\n+    signed int D.84;\n+    signed int D.85;\n+    signed int y;\n+    signed int x;\n+    signed int stack_depth;\n+    signed int stack[8];\n+\n+    try\n+      {\n+        initial:\n+        stack_depth = 0;\n+        stack[stack_depth] = arg;\n+        stack_depth = stack_depth + 1;\n+        goto instr0;\n+        instr0:\n+        /* DUP */:\n+        stack_depth = stack_depth + -1;\n+        x = stack[stack_depth];\n+        stack[stack_depth] = x;\n+        stack_depth = stack_depth + 1;\n+        stack[stack_depth] = x;\n+        stack_depth = stack_depth + 1;\n+        goto instr1;\n+        instr1:\n+        /* PUSH_CONST */:\n+        stack[stack_depth] = 2;\n+        stack_depth = stack_depth + 1;\n+        goto instr2;\n+\n+        /* etc */\n+\n+You can see the generated machine code in assembly form via:\n+\n+.. code-block:: c++\n+\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 1);\n+  result = ctxt.compile ();\n+\n+which shows that (on this x86_64 box) the compiler has unrolled the loop\n+and is using MMX instructions to perform several multiplications\n+simultaneously:\n+\n+.. code-block:: gas\n+\n+          .file   \"fake.c\"\n+          .text\n+  .Ltext0:\n+          .p2align 4,,15\n+          .globl  factorial\n+          .type   factorial, @function\n+  factorial:\n+  .LFB0:\n+          .file 1 \"factorial.toy\"\n+          .loc 1 14 0\n+          .cfi_startproc\n+  .LVL0:\n+  .L2:\n+          .loc 1 26 0\n+          cmpl    $1, %edi\n+          jle     .L13\n+          leal    -1(%rdi), %edx\n+          movl    %edx, %ecx\n+          shrl    $2, %ecx\n+          leal    0(,%rcx,4), %esi\n+          testl   %esi, %esi\n+          je      .L14\n+          cmpl    $9, %edx\n+          jbe     .L14\n+          leal    -2(%rdi), %eax\n+          movl    %eax, -16(%rsp)\n+          leal    -3(%rdi), %eax\n+          movd    -16(%rsp), %xmm0\n+          movl    %edi, -16(%rsp)\n+          movl    %eax, -12(%rsp)\n+          movd    -16(%rsp), %xmm1\n+          xorl    %eax, %eax\n+          movl    %edx, -16(%rsp)\n+          movd    -12(%rsp), %xmm4\n+          movd    -16(%rsp), %xmm6\n+          punpckldq       %xmm4, %xmm0\n+          movdqa  .LC1(%rip), %xmm4\n+          punpckldq       %xmm6, %xmm1\n+          punpcklqdq      %xmm0, %xmm1\n+          movdqa  .LC0(%rip), %xmm0\n+          jmp     .L5\n+          # etc - edited for brevity\n+\n+This is clearly overkill for a function that will likely overflow the\n+``int`` type before the vectorization is worthwhile - but then again, this\n+is a toy example.\n+\n+Turning down the optimization level to 2:\n+\n+.. code-block:: c++\n+\n+  ctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL, 2);\n+\n+yields this code, which is simple enough to quote in its entirety:\n+\n+.. code-block:: gas\n+\n+          .file   \"fake.c\"\n+          .text\n+          .p2align 4,,15\n+          .globl  factorial\n+          .type   factorial, @function\n+  factorial:\n+  .LFB0:\n+          .cfi_startproc\n+  .L2:\n+          cmpl    $1, %edi\n+          jle     .L8\n+          movl    $1, %edx\n+          jmp     .L4\n+          .p2align 4,,10\n+          .p2align 3\n+  .L6:\n+          movl    %eax, %edi\n+  .L4:\n+  .L5:\n+          leal    -1(%rdi), %eax\n+          imull   %edi, %edx\n+          cmpl    $1, %eax\n+          jne     .L6\n+  .L3:\n+  .L7:\n+          imull   %edx, %eax\n+          ret\n+  .L8:\n+          movl    %edi, %eax\n+          movl    $1, %edx\n+          jmp     .L7\n+          .cfi_endproc\n+  .LFE0:\n+          .size   factorial, .-factorial\n+          .ident  \"GCC: (GNU) 4.9.0 20131023 (Red Hat 0.2-%{gcc_release})\"\n+          .section        .note.GNU-stack,\"\",@progbits\n+\n+Note that the stack pushing and popping have been eliminated, as has the\n+recursive call (in favor of an iteration).\n+\n+Putting it all together\n+***********************\n+\n+The complete example can be seen in the source tree at\n+``gcc/jit/docs/examples/tut04-toyvm/toyvm.cc``\n+\n+along with a Makefile and a couple of sample .toy scripts:\n+\n+.. code-block:: console\n+\n+  $ ls -al\n+  drwxrwxr-x. 2 david david   4096 Sep 19 17:46 .\n+  drwxrwxr-x. 3 david david   4096 Sep 19 15:26 ..\n+  -rw-rw-r--. 1 david david    615 Sep 19 12:43 factorial.toy\n+  -rw-rw-r--. 1 david david    834 Sep 19 13:08 fibonacci.toy\n+  -rw-rw-r--. 1 david david    238 Sep 19 14:22 Makefile\n+  -rw-rw-r--. 1 david david  16457 Sep 19 17:07 toyvm.cc\n+\n+  $ make toyvm\n+  g++ -Wall -g -o toyvm toyvm.cc -lgccjit\n+\n+  $ ./toyvm factorial.toy 10\n+  interpreter result: 3628800\n+  compiler result: 3628800\n+\n+  $ ./toyvm fibonacci.toy 10\n+  interpreter result: 55\n+  compiler result: 55\n+\n+Behind the curtain: How does our code get optimized?\n+****************************************************\n+\n+Our example is done, but you may be wondering about exactly how the\n+compiler turned what we gave it into the machine code seen above.\n+\n+We can examine what the compiler is doing in detail by setting:\n+\n+.. code-block:: c++\n+\n+  state.ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING, 1);\n+  state.ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES, 1);\n+\n+This will dump detailed information about the compiler's state to a\n+directory under ``/tmp``, and keep it from being cleaned up.\n+\n+The precise names and their formats of these files is subject to change.\n+Higher optimization levels lead to more files.\n+Here's what I saw (edited for brevity; there were almost 200 files):\n+\n+.. code-block:: console\n+\n+  intermediate files written to /tmp/libgccjit-KPQbGw\n+  $ ls /tmp/libgccjit-KPQbGw/\n+  fake.c.000i.cgraph\n+  fake.c.000i.type-inheritance\n+  fake.c.004t.gimple\n+  fake.c.007t.omplower\n+  fake.c.008t.lower\n+  fake.c.011t.eh\n+  fake.c.012t.cfg\n+  fake.c.014i.visibility\n+  fake.c.015i.early_local_cleanups\n+  fake.c.016t.ssa\n+  # etc\n+\n+The gimple code is converted into Static Single Assignment form,\n+with annotations for use when generating the debuginfo:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-KPQbGw/fake.c.016t.ssa\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+    signed int _56;\n+\n+  initial:\n+    stack_depth_3 = 0;\n+    # DEBUG stack_depth => stack_depth_3\n+    stack[stack_depth_3] = arg_5(D);\n+    stack_depth_7 = stack_depth_3 + 1;\n+    # DEBUG stack_depth => stack_depth_7\n+    # DEBUG instr0 => NULL\n+    # DEBUG /* DUP */ => NULL\n+    stack_depth_8 = stack_depth_7 + -1;\n+    # DEBUG stack_depth => stack_depth_8\n+    x_9 = stack[stack_depth_8];\n+    # DEBUG x => x_9\n+    stack[stack_depth_8] = x_9;\n+    stack_depth_11 = stack_depth_8 + 1;\n+    # DEBUG stack_depth => stack_depth_11\n+    stack[stack_depth_11] = x_9;\n+    stack_depth_13 = stack_depth_11 + 1;\n+    # DEBUG stack_depth => stack_depth_13\n+    # DEBUG instr1 => NULL\n+    # DEBUG /* PUSH_CONST */ => NULL\n+    stack[stack_depth_13] = 2;\n+\n+    /* etc; edited for brevity */\n+\n+We can perhaps better see the code by turning off\n+:c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` to suppress all those ``DEBUG``\n+statements, giving:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.016t.ssa\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+    signed int _56;\n+\n+  initial:\n+    stack_depth_3 = 0;\n+    stack[stack_depth_3] = arg_5(D);\n+    stack_depth_7 = stack_depth_3 + 1;\n+    stack_depth_8 = stack_depth_7 + -1;\n+    x_9 = stack[stack_depth_8];\n+    stack[stack_depth_8] = x_9;\n+    stack_depth_11 = stack_depth_8 + 1;\n+    stack[stack_depth_11] = x_9;\n+    stack_depth_13 = stack_depth_11 + 1;\n+    stack[stack_depth_13] = 2;\n+    stack_depth_15 = stack_depth_13 + 1;\n+    stack_depth_16 = stack_depth_15 + -1;\n+    y_17 = stack[stack_depth_16];\n+    stack_depth_18 = stack_depth_16 + -1;\n+    x_19 = stack[stack_depth_18];\n+    _20 = x_19 < y_17;\n+    _21 = (signed int) _20;\n+    stack[stack_depth_18] = _21;\n+    stack_depth_23 = stack_depth_18 + 1;\n+    stack_depth_24 = stack_depth_23 + -1;\n+    x_25 = stack[stack_depth_24];\n+    if (x_25 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    stack_depth_26 = stack_depth_24 + -1;\n+    x_27 = stack[stack_depth_26];\n+    stack[stack_depth_26] = x_27;\n+    stack_depth_29 = stack_depth_26 + 1;\n+    stack[stack_depth_29] = x_27;\n+    stack_depth_31 = stack_depth_29 + 1;\n+    stack[stack_depth_31] = 1;\n+    stack_depth_33 = stack_depth_31 + 1;\n+    stack_depth_34 = stack_depth_33 + -1;\n+    y_35 = stack[stack_depth_34];\n+    stack_depth_36 = stack_depth_34 + -1;\n+    x_37 = stack[stack_depth_36];\n+    _38 = x_37 - y_35;\n+    stack[stack_depth_36] = _38;\n+    stack_depth_40 = stack_depth_36 + 1;\n+    stack_depth_41 = stack_depth_40 + -1;\n+    x_42 = stack[stack_depth_41];\n+    _44 = factorial (x_42);\n+    stack[stack_depth_41] = _44;\n+    stack_depth_46 = stack_depth_41 + 1;\n+    stack_depth_47 = stack_depth_46 + -1;\n+    y_48 = stack[stack_depth_47];\n+    stack_depth_49 = stack_depth_47 + -1;\n+    x_50 = stack[stack_depth_49];\n+    _51 = x_50 * y_48;\n+    stack[stack_depth_49] = _51;\n+    stack_depth_53 = stack_depth_49 + 1;\n+\n+    # stack_depth_1 = PHI <stack_depth_24(2), stack_depth_53(3)>\n+  instr9:\n+  /* RETURN */:\n+    stack_depth_54 = stack_depth_1 + -1;\n+    x_55 = stack[stack_depth_54];\n+    _56 = x_55;\n+    stack ={v} {CLOBBER};\n+    return _56;\n+\n+  }\n+\n+Note in the above how all the :type:`gccjit::block` instances we\n+created have been consolidated into just 3 blocks in GCC's internal\n+representation: ``initial``, ``instr4`` and ``instr9``.\n+\n+Optimizing away stack manipulation\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+Recall our simple implementation of stack operations.  Let's examine\n+how the stack operations are optimized away.\n+\n+After a pass of constant-propagation, the depth of the stack at each\n+opcode can be determined at compile-time:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.021t.ccp1\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+\n+  initial:\n+    stack[0] = arg_5(D);\n+    x_9 = stack[0];\n+    stack[0] = x_9;\n+    stack[1] = x_9;\n+    stack[2] = 2;\n+    y_17 = stack[2];\n+    x_19 = stack[1];\n+    _20 = x_19 < y_17;\n+    _21 = (signed int) _20;\n+    stack[1] = _21;\n+    x_25 = stack[1];\n+    if (x_25 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    x_27 = stack[0];\n+    stack[0] = x_27;\n+    stack[1] = x_27;\n+    stack[2] = 1;\n+    y_35 = stack[2];\n+    x_37 = stack[1];\n+    _38 = x_37 - y_35;\n+    stack[1] = _38;\n+    x_42 = stack[1];\n+    _44 = factorial (x_42);\n+    stack[1] = _44;\n+    y_48 = stack[1];\n+    x_50 = stack[0];\n+    _51 = x_50 * y_48;\n+    stack[0] = _51;\n+\n+  instr9:\n+  /* RETURN */:\n+    x_55 = stack[0];\n+    x_56 = x_55;\n+    stack ={v} {CLOBBER};\n+    return x_56;\n+\n+  }\n+\n+Note how, in the above, all those ``stack_depth`` values are now just\n+constants: we're accessing specific stack locations at each opcode.\n+\n+The \"esra\" pass (\"Early Scalar Replacement of Aggregates\") breaks\n+out our \"stack\" array into individual elements:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.024t.esra\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  Created a replacement for stack offset: 0, size: 32: stack$0\n+  Created a replacement for stack offset: 32, size: 32: stack$1\n+  Created a replacement for stack offset: 64, size: 32: stack$2\n+\n+  Symbols to be put in SSA form\n+  { D.89 D.90 D.91 }\n+  Incremental SSA update started at block: 0\n+  Number of blocks in CFG: 5\n+  Number of blocks to update: 4 ( 80%)\n+\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack$2;\n+    signed int stack$1;\n+    signed int stack$0;\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+\n+  initial:\n+    stack$0_45 = arg_5(D);\n+    x_9 = stack$0_45;\n+    stack$0_39 = x_9;\n+    stack$1_32 = x_9;\n+    stack$2_30 = 2;\n+    y_17 = stack$2_30;\n+    x_19 = stack$1_32;\n+    _20 = x_19 < y_17;\n+    _21 = (signed int) _20;\n+    stack$1_28 = _21;\n+    x_25 = stack$1_28;\n+    if (x_25 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    x_27 = stack$0_39;\n+    stack$0_22 = x_27;\n+    stack$1_14 = x_27;\n+    stack$2_12 = 1;\n+    y_35 = stack$2_12;\n+    x_37 = stack$1_14;\n+    _38 = x_37 - y_35;\n+    stack$1_10 = _38;\n+    x_42 = stack$1_10;\n+    _44 = factorial (x_42);\n+    stack$1_6 = _44;\n+    y_48 = stack$1_6;\n+    x_50 = stack$0_22;\n+    _51 = x_50 * y_48;\n+    stack$0_1 = _51;\n+\n+    # stack$0_52 = PHI <stack$0_39(2), stack$0_1(3)>\n+  instr9:\n+  /* RETURN */:\n+    x_55 = stack$0_52;\n+    x_56 = x_55;\n+    stack ={v} {CLOBBER};\n+    return x_56;\n+\n+  }\n+\n+Hence at this point, all those pushes and pops of the stack are now\n+simply assignments to specific temporary variables.\n+\n+After some copy propagation, the stack manipulation has been completely\n+optimized away:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.026t.copyprop1\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack$2;\n+    signed int stack$1;\n+    signed int stack$0;\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int _44;\n+    signed int _51;\n+\n+  initial:\n+    stack$0_39 = arg_5(D);\n+    _20 = arg_5(D) <= 1;\n+    _21 = (signed int) _20;\n+    if (_21 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    _38 = arg_5(D) + -1;\n+    _44 = factorial (_38);\n+    _51 = arg_5(D) * _44;\n+    stack$0_1 = _51;\n+\n+    # stack$0_52 = PHI <arg_5(D)(2), _51(3)>\n+  instr9:\n+  /* RETURN */:\n+    stack ={v} {CLOBBER};\n+    return stack$0_52;\n+\n+  }\n+\n+Later on, another pass finally eliminated ``stack_depth`` local and the\n+unused parts of the `stack`` array altogether:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.036t.release_ssa\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+  Released 44 names, 314.29%, removed 44 holes\n+  factorial (signed int arg)\n+  {\n+    signed int stack$0;\n+    signed int mult_acc_1;\n+    <unnamed type> _5;\n+    signed int _6;\n+    signed int _7;\n+    signed int mul_tmp_10;\n+    signed int mult_acc_11;\n+    signed int mult_acc_13;\n+\n+    # arg_9 = PHI <arg_8(D)(0)>\n+    # mult_acc_13 = PHI <1(0)>\n+  initial:\n+\n+    <bb 5>:\n+    # arg_4 = PHI <arg_9(2), _7(3)>\n+    # mult_acc_1 = PHI <mult_acc_13(2), mult_acc_11(3)>\n+    _5 = arg_4 <= 1;\n+    _6 = (signed int) _5;\n+    if (_6 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    _7 = arg_4 + -1;\n+    mult_acc_11 = mult_acc_1 * arg_4;\n+    goto <bb 5>;\n+\n+    # stack$0_12 = PHI <arg_4(5)>\n+  instr9:\n+  /* RETURN */:\n+    mul_tmp_10 = mult_acc_1 * stack$0_12;\n+    return mul_tmp_10;\n+\n+  }\n+\n+\n+Elimination of tail recursion\n+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+Another significant optimization is the detection that the call to\n+``factorial`` is tail recursion, which can be eliminated in favor of\n+an iteration:\n+\n+.. code-block:: console\n+\n+  $ less /tmp/libgccjit-1Hywc0/fake.c.030t.tailr1\n+\n+.. code-block:: c\n+\n+  ;; Function factorial (factorial, funcdef_no=0, decl_uid=53, symbol_order=0)\n+\n+\n+  Symbols to be put in SSA form\n+  { D.88 }\n+  Incremental SSA update started at block: 0\n+  Number of blocks in CFG: 5\n+  Number of blocks to update: 4 ( 80%)\n+\n+\n+  factorial (signed int arg)\n+  {\n+    signed int stack$2;\n+    signed int stack$1;\n+    signed int stack$0;\n+    signed int stack[8];\n+    signed int stack_depth;\n+    signed int x;\n+    signed int y;\n+    signed int mult_acc_1;\n+    <unnamed type> _20;\n+    signed int _21;\n+    signed int _38;\n+    signed int mul_tmp_44;\n+    signed int mult_acc_51;\n+\n+    # arg_5 = PHI <arg_39(D)(0), _38(3)>\n+    # mult_acc_1 = PHI <1(0), mult_acc_51(3)>\n+  initial:\n+    _20 = arg_5 <= 1;\n+    _21 = (signed int) _20;\n+    if (_21 != 0)\n+      goto <bb 4> (instr9);\n+    else\n+      goto <bb 3> (instr4);\n+\n+  instr4:\n+  /* DUP */:\n+    _38 = arg_5 + -1;\n+    mult_acc_51 = mult_acc_1 * arg_5;\n+    goto <bb 2> (initial);\n+\n+    # stack$0_52 = PHI <arg_5(2)>\n+  instr9:\n+  /* RETURN */:\n+    stack ={v} {CLOBBER};\n+    mul_tmp_44 = mult_acc_1 * stack$0_52;\n+    return mul_tmp_44;\n+\n+  }"}, {"sha": "72815fbd35cf7ebdf12c55ab9aa355ebc2804366", "filename": "gcc/jit/docs/cp/topics/contexts.rst", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fcontexts.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,179 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Compilation contexts\n+====================\n+\n+.. class:: gccjit::context\n+\n+The top-level of the C++ API is the :class:`gccjit::context` type.\n+\n+A :class:`gccjit::context` instance encapsulates the state of a\n+compilation.\n+\n+You can set up options on it, and add types, functions and code.\n+Invoking :func:`gccjit::context::compile` on it gives you a\n+:c:type:`gcc_jit_result *`.\n+\n+It is a thin wrapper around the C API's :c:type:`gcc_jit_context *`.\n+\n+Lifetime-management\n+-------------------\n+Contexts are the unit of lifetime-management within the API: objects\n+have their lifetime bounded by the context they are created within, and\n+cleanup of such objects is done for you when the context is released.\n+\n+.. function:: gccjit::context gccjit::context::acquire ()\n+\n+  This function acquires a new :class:`gccjit::context` instance,\n+  which is independent of any others that may be present within this\n+  process.\n+\n+.. function:: void gccjit::context::release ()\n+\n+  This function releases all resources associated with the given context.\n+  Both the context itself and all of its :c:type:`gccjit::object *`\n+  instances are cleaned up.  It should be called exactly once on a given\n+  context.\n+\n+  It is invalid to use the context or any of its \"contextual\" objects\n+  after calling this.\n+\n+  .. code-block:: c++\n+\n+    ctxt.release ();\n+\n+.. function:: gccjit::context \\\n+              gccjit::context::new_child_context ()\n+\n+   Given an existing JIT context, create a child context.\n+\n+   The child inherits a copy of all option-settings from the parent.\n+\n+   The child can reference objects created within the parent, but not\n+   vice-versa.\n+\n+   The lifetime of the child context must be bounded by that of the\n+   parent: you should release a child context before releasing the parent\n+   context.\n+\n+   If you use a function from a parent context within a child context,\n+   you have to compile the parent context before you can compile the\n+   child context, and the gccjit::result of the parent context must\n+   outlive the gccjit::result of the child context.\n+\n+   This allows caching of shared initializations.  For example, you could\n+   create types and declarations of global functions in a parent context\n+   once within a process, and then create child contexts whenever a\n+   function or loop becomes hot. Each such child context can be used for\n+   JIT-compiling just one function or loop, but can reference types\n+   and helper functions created within the parent context.\n+\n+   Contexts can be arbitrarily nested, provided the above rules are\n+   followed, but it's probably not worth going above 2 or 3 levels, and\n+   there will likely be a performance hit for such nesting.\n+\n+\n+Thread-safety\n+-------------\n+Instances of :class:`gccjit::context` created via\n+:func:`gccjit::context::acquire` are independent from each other:\n+only one thread may use a given context at once, but multiple threads\n+could each have their own contexts without needing locks.\n+\n+Contexts created via :func:`gccjit::context::new_child_context` are\n+related to their parent context.  They can be partitioned by their\n+ultimate ancestor into independent \"family trees\".   Only one thread\n+within a process may use a given \"family tree\" of such contexts at once,\n+and if you're using multiple threads you should provide your own locking\n+around entire such context partitions.\n+\n+\n+Error-handling\n+--------------\n+.. FIXME: How does error-handling work for C++ API?\n+\n+You can only compile and get code from a context if no errors occur.\n+\n+In general, if an error occurs when using an API entrypoint, it returns\n+NULL.  You don't have to check everywhere for NULL results, since the\n+API gracefully handles a NULL being passed in for any argument.\n+\n+Errors are printed on stderr and can be queried using\n+:func:`gccjit::context::get_first_error`.\n+\n+.. function:: const char *\\\n+              gccjit::context::get_first_error (gccjit::context *ctxt)\n+\n+   Returns the first error message that occurred on the context.\n+\n+   The returned string is valid for the rest of the lifetime of the\n+   context.\n+\n+   If no errors occurred, this will be NULL.\n+\n+Debugging\n+---------\n+\n+.. function:: void\\\n+              gccjit::context::dump_to_file (const std::string &path, \\\n+                                             int update_locations)\n+\n+   To help with debugging: dump a C-like representation to the given path,\n+   describing what's been set up on the context.\n+\n+   If \"update_locations\" is true, then also set up :class:`gccjit::location`\n+   information throughout the context, pointing at the dump file as if it\n+   were a source file.  This may be of use in conjunction with\n+   :c:macro:`GCCJIT::BOOL_OPTION_DEBUGINFO` to allow stepping through the\n+   code in a debugger.\n+\n+\n+Options\n+-------\n+\n+..\n+  FIXME: gccjit::context::set_str_option doesn't seem to exist yet in the\n+  C++ API\n+\n+Boolean options\n+***************\n+\n+.. function:: void \\\n+              gccjit::context::set_bool_option(enum gcc_jit_bool_option, \\\n+                                               int value)\n+\n+  Set a boolean option of the context.\n+\n+  This is a thin wrapper around the C API\n+  :c:func:`gcc_jit_context_set_bool_option`; the options have the same\n+  meaning.\n+\n+Integer options\n+***************\n+\n+.. function:: void \\\n+              gccjit::context::set_int_option (enum gcc_jit_int_option, \\\n+                                               int value)\n+\n+  Set an integer option of the context.\n+\n+  This is a thin wrapper around the C API\n+  :c:func:`gcc_jit_context_set_int_option`; the options have the same\n+  meaning."}, {"sha": "6d9e53b7aa484890f8ac288b37048359d4d9ead9", "filename": "gcc/jit/docs/cp/topics/expressions.rst", "status": "added", "additions": 606, "deletions": 0, "changes": 606, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fexpressions.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,606 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Expressions\n+===========\n+\n+Rvalues\n+-------\n+.. class:: gccjit::rvalue\n+\n+A :class:`gccjit::rvalue` is an expression that can be computed.  It is a\n+subclass of :class:`gccjit::object`, and is a thin wrapper around\n+:c:type:`gcc_jit_rvalue *` from the C API.\n+\n+It can be simple, e.g.:\n+\n+  * an integer value e.g. `0` or `42`\n+  * a string literal e.g. `\"Hello world\"`\n+  * a variable e.g. `i`.  These are also lvalues (see below).\n+\n+or compound e.g.:\n+\n+  * a unary expression e.g. `!cond`\n+  * a binary expression e.g. `(a + b)`\n+  * a function call e.g. `get_distance (&player_ship, &target)`\n+  * etc.\n+\n+Every rvalue has an associated type, and the API will check to ensure\n+that types match up correctly (otherwise the context will emit an error).\n+\n+.. function:: gccjit::type gccjit::rvalue::get_type ()\n+\n+  Get the type of this rvalue.\n+\n+\n+Simple expressions\n+******************\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_rvalue (gccjit::type numeric_type, \\\n+                                           int value) const\n+\n+   Given a numeric type (integer or floating point), build an rvalue for\n+   the given constant ``int`` value.\n+\n+.. function::  gccjit::rvalue \\\n+               gccjit::context::zero (gccjit::type numeric_type) const\n+\n+   Given a numeric type (integer or floating point), get the rvalue for\n+   zero.  Essentially this is just a shortcut for:\n+\n+   .. code-block:: c++\n+\n+      ctxt.new_rvalue (numeric_type, 0)\n+\n+.. function::  gccjit::rvalue \\\n+               gccjit::context::one (gccjit::type numeric_type) const\n+\n+   Given a numeric type (integer or floating point), get the rvalue for\n+   zero.  Essentially this is just a shortcut for:\n+\n+   .. code-block:: c++\n+\n+      ctxt.new_rvalue (numeric_type, 1)\n+\n+.. function::  gccjit::rvalue \\\n+               gccjit::context::new_rvalue (gccjit::type numeric_type, \\\n+                                            double value) const\n+\n+   Given a numeric type (integer or floating point), build an rvalue for\n+   the given constant value.\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_rvalue (gccjit::type pointer_type, \\\n+                                           void *value) const\n+\n+   Given a pointer type, build an rvalue for the given address.\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_rvalue (const std::string &value) const\n+\n+   Generate an rvalue of type :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR` for\n+   the given string.  This is akin to a string literal.\n+\n+\n+Unary Operations\n+****************\n+\n+.. function:: gccjit::rvalue  \\\n+              gccjit::context::new_unary_op (enum gcc_jit_unary_op, \\\n+                                             gccjit::type result_type, \\\n+                                             gccjit::rvalue rvalue, \\\n+                                             gccjit::location loc)\n+\n+   Build a unary operation out of an input rvalue.\n+\n+   Parameter ``loc`` is optional.\n+\n+   This is a thin wrapper around the C API's\n+   :c:func:`gcc_jit_context_new_unary_op` and the available unary\n+   operations are documented there.\n+\n+There are shorter ways to spell the various specific kinds of unary\n+operation:\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_minus (gccjit::type result_type, \\\n+                                          gccjit::rvalue a, \\\n+                                          gccjit::location loc)\n+\n+   Negate an arithmetic value; for example:\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue negpi = ctxt.new_minus (t_double, pi);\n+\n+   builds the equivalent of this C expression:\n+\n+   .. code-block:: c\n+\n+      -pi\n+\n+.. function:: gccjit::rvalue \\\n+              new_bitwise_negate (gccjit::type result_type, \\\n+                                  gccjit::rvalue a, \\\n+                                  gccjit::location loc)\n+\n+   Bitwise negation of an integer value (one's complement); for example:\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue mask = ctxt.new_bitwise_negate (t_int, a);\n+\n+   builds the equivalent of this C expression:\n+\n+   .. code-block:: c\n+\n+      ~a\n+\n+.. function:: gccjit::rvalue \\\n+              new_logical_negate (gccjit::type result_type, \\\n+                                  gccjit::rvalue a, \\\n+                                  gccjit::location loc)\n+\n+   Logical negation of an arithmetic or pointer value; for example:\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue guard = ctxt.new_logical_negate (t_bool, cond);\n+\n+   builds the equivalent of this C expression:\n+\n+   .. code-block:: c\n+\n+      !cond\n+\n+\n+The most concise way to spell them is with overloaded operators:\n+\n+.. function:: gccjit::rvalue operator- (gccjit::rvalue a)\n+\n+   .. code-block:: c++\n+\n+     gccjit::rvalue negpi = -pi;\n+\n+\n+.. function:: gccjit::rvalue operator~ (gccjit::rvalue a)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue mask = ~a;\n+\n+.. function:: gccjit::rvalue operator! (gccjit::rvalue a)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue guard = !cond;\n+\n+\n+Binary Operations\n+*****************\n+\n+.. function:: gccjit::rvalue\\\n+              gccjit::context::new_binary_op (enum gcc_jit_binary_op, \\\n+                                              gccjit::type result_type, \\\n+                                              gccjit::rvalue a, \\\n+                                              gccjit::rvalue b, \\\n+                                              gccjit::location loc)\n+\n+   Build a binary operation out of two constituent rvalues.\n+\n+   Parameter ``loc`` is optional.\n+\n+   This is a thin wrapper around the C API's\n+   :c:func:`gcc_jit_context_new_binary_op` and the available binary\n+   operations are documented there.\n+\n+There are shorter ways to spell the various specific kinds of binary\n+operation:\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_plus (gccjit::type result_type, \\\n+                                         gccjit::rvalue a, gccjit::rvalue b, \\\n+                                         gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_minus (gccjit::type result_type, \\\n+                                          gccjit::rvalue a, gccjit::rvalue b, \\\n+                                          gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_mult (gccjit::type result_type, \\\n+                                         gccjit::rvalue a, gccjit::rvalue b, \\\n+                                         gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_divide (gccjit::type result_type, \\\n+                                           gccjit::rvalue a, gccjit::rvalue b, \\\n+                                           gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_modulo (gccjit::type result_type, \\\n+                                           gccjit::rvalue a, gccjit::rvalue b, \\\n+                                           gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_bitwise_and (gccjit::type result_type, \\\n+                                                gccjit::rvalue a, gccjit::rvalue b, \\\n+                                                gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_bitwise_xor (gccjit::type result_type, \\\n+                                                gccjit::rvalue a, gccjit::rvalue b, \\\n+                                                gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_bitwise_or (gccjit::type result_type, \\\n+                                               gccjit::rvalue a, gccjit::rvalue b, \\\n+                                               gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_logical_and (gccjit::type result_type, \\\n+                                                gccjit::rvalue a, gccjit::rvalue b, \\\n+                                                gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_logical_or (gccjit::type result_type, \\\n+                                               gccjit::rvalue a, gccjit::rvalue b, \\\n+                                               gccjit::location loc)\n+\n+The most concise way to spell them is with overloaded operators:\n+\n+.. function:: gccjit::rvalue operator+ (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue sum = a + b;\n+\n+.. function:: gccjit::rvalue operator- (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue diff = a - b;\n+\n+.. function:: gccjit::rvalue operator* (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue prod = a * b;\n+\n+.. function:: gccjit::rvalue operator/ (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue result = a / b;\n+\n+.. function:: gccjit::rvalue operator% (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue mod = a % b;\n+\n+.. function:: gccjit::rvalue operator& (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue x = a & b;\n+\n+.. function:: gccjit::rvalue operator^ (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue x = a ^ b;\n+\n+.. function:: gccjit::rvalue operator| (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue x = a | b;\n+\n+.. function:: gccjit::rvalue operator&& (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = a && b;\n+\n+.. function:: gccjit::rvalue operator|| (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = a || b;\n+\n+These can of course be combined, giving a terse way to build compound\n+expressions:\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue discriminant = (b * b) - (four * a * c);\n+\n+\n+Comparisons\n+***********\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_comparison (enum gcc_jit_comparison,\\\n+                                               gccjit::rvalue a, \\\n+                                               gccjit::rvalue b, \\\n+                                               gccjit::location loc)\n+\n+   Build a boolean rvalue out of the comparison of two other rvalues.\n+\n+   Parameter ``loc`` is optional.\n+\n+   This is a thin wrapper around the C API's\n+   :c:func:`gcc_jit_context_new_comparison` and the available kinds\n+   of comparison are documented there.\n+\n+There are shorter ways to spell the various specific kinds of binary\n+operation:\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_eq (gccjit::rvalue a, gccjit::rvalue b, \\\n+                                       gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_ne (gccjit::rvalue a, gccjit::rvalue b, \\\n+                                       gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_lt (gccjit::rvalue a, gccjit::rvalue b, \\\n+                                       gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_le (gccjit::rvalue a, gccjit::rvalue b, \\\n+                                       gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_gt (gccjit::rvalue a, gccjit::rvalue b, \\\n+                                       gccjit::location loc)\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_ge (gccjit::rvalue a, gccjit::rvalue b, \\\n+                                       gccjit::location loc)\n+\n+The most concise way to spell them is with overloaded operators:\n+\n+.. function:: gccjit::rvalue \\\n+              operator== (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = (a == ctxt.zero (t_int));\n+\n+.. function:: gccjit::rvalue \\\n+              operator!= (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = (i != j);\n+\n+.. function:: gccjit::rvalue \\\n+              operator< (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = i < n;\n+\n+.. function:: gccjit::rvalue \\\n+              operator<= (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = i <= n;\n+\n+.. function:: gccjit::rvalue \\\n+              operator> (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = (ch > limit);\n+\n+.. function:: gccjit::rvalue \\\n+              operator>= (gccjit::rvalue a, gccjit::rvalue b)\n+\n+   .. code-block:: c++\n+\n+      gccjit::rvalue cond = (score >= ctxt.new_rvalue (t_int, 100));\n+\n+.. TODO: beyond this point\n+\n+Function calls\n+**************\n+.. function:: gcc_jit_rvalue *\\\n+              gcc_jit_context_new_call (gcc_jit_context *ctxt,\\\n+                                        gcc_jit_location *loc,\\\n+                                        gcc_jit_function *func,\\\n+                                        int numargs , gcc_jit_rvalue **args)\n+\n+   Given a function and the given table of argument rvalues, construct a\n+   call to the function, with the result as an rvalue.\n+\n+   .. note::\n+\n+      :func:`gccjit::context::new_call` merely builds a\n+      :class:`gccjit::rvalue` i.e. an expression that can be evaluated,\n+      perhaps as part of a more complicated expression.\n+      The call *won't* happen unless you add a statement to a function\n+      that evaluates the expression.\n+\n+      For example, if you want to call a function and discard the result\n+      (or to call a function with ``void`` return type), use\n+      :func:`gccjit::block::add_eval`:\n+\n+      .. code-block:: c++\n+\n+         /* Add \"(void)printf (arg0, arg1);\".  */\n+         block.add_eval (ctxt.new_call (printf_func, arg0, arg1));\n+\n+Type-coercion\n+*************\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::context::new_cast (gccjit::rvalue rvalue,\\\n+                                         gccjit::type type, \\\n+                                         gccjit::location loc)\n+\n+   Given an rvalue of T, construct another rvalue of another type.\n+\n+   Currently only a limited set of conversions are possible:\n+\n+     * int <-> float\n+     * int <-> bool\n+     * P*  <-> Q*, for pointer types P and Q\n+\n+Lvalues\n+-------\n+\n+.. class:: gccjit::lvalue\n+\n+An lvalue is something that can of the *left*-hand side of an assignment:\n+a storage area (such as a variable).  It is a subclass of\n+:class:`gccjit::rvalue`, where the rvalue is computed by reading from the\n+storage area.\n+\n+It iss a thin wrapper around :c:type:`gcc_jit_lvalue *` from the C API.\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::lvalue::get_address (gccjit::location loc)\n+\n+   Take the address of an lvalue; analogous to:\n+\n+   .. code-block:: c\n+\n+     &(EXPR)\n+\n+   in C.\n+\n+   Parameter \"loc\" is optional.\n+\n+Global variables\n+****************\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::context::new_global (gccjit::type type, \\\n+                                           const char *name, \\\n+                                           gccjit::location loc)\n+\n+   Add a new global variable of the given type and name to the context.\n+\n+\n+Working with pointers, structs and unions\n+-----------------------------------------\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::rvalue::dereference (gccjit::location loc)\n+\n+   Given an rvalue of pointer type ``T *``, dereferencing the pointer,\n+   getting an lvalue of type ``T``.  Analogous to:\n+\n+   .. code-block:: c++\n+\n+     *(EXPR)\n+\n+   in C.\n+\n+   Parameter \"loc\" is optional.\n+\n+If you don't need to specify the location, this can also be expressed using\n+an overloaded operator:\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::rvalue::operator* ();\n+\n+   .. code-block:: c++\n+\n+      gccjit::lvalue content = *ptr;\n+\n+Field access is provided separately for both lvalues and rvalues:\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::lvalue::access_field (gccjit::field field, \\\n+                                            gccjit::location loc)\n+\n+   Given an lvalue of struct or union type, access the given field,\n+   getting an lvalue of the field's type.  Analogous to:\n+\n+   .. code-block:: c++\n+\n+      (EXPR).field = ...;\n+\n+   in C.\n+\n+.. function:: gccjit::rvalue \\\n+              gccjit::rvalue::access_field (gccjit::field field, \\\n+                                            gccjit::location loc)\n+\n+   Given an rvalue of struct or union type, access the given field\n+   as an rvalue.  Analogous to:\n+\n+   .. code-block:: c++\n+\n+      (EXPR).field\n+\n+   in C.\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::rvalue::dereference_field (gccjit::field field, \\\n+                                                 gccjit::location loc)\n+\n+   Given an rvalue of pointer type ``T *`` where T is of struct or union\n+   type, access the given field as an lvalue.  Analogous to:\n+\n+   .. code-block:: c++\n+\n+      (EXPR)->field\n+\n+   in C, itself equivalent to ``(*EXPR).FIELD``.\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::context::new_array_access (gccjit::rvalue ptr, \\\n+                                                 gccjit::rvalue index, \\\n+                                                 gccjit::location loc)\n+\n+   Given an rvalue of pointer type ``T *``, get at the element `T` at\n+   the given index, using standard C array indexing rules i.e. each\n+   increment of ``index`` corresponds to ``sizeof(T)`` bytes.\n+   Analogous to:\n+\n+   .. code-block:: c++\n+\n+      PTR[INDEX]\n+\n+   in C (or, indeed, to ``PTR + INDEX``).\n+\n+   Parameter \"loc\" is optional.\n+\n+For array accesses where you don't need to specify a :class:`gccjit::location`,\n+two overloaded operators are available:\n+\n+    gccjit::lvalue gccjit::rvalue::operator[] (gccjit::rvalue index)\n+\n+    .. code-block:: c++\n+\n+       gccjit::lvalue element = array[idx];\n+\n+    gccjit::lvalue gccjit::rvalue::operator[] (int index)\n+\n+    .. code-block:: c++\n+\n+       gccjit::lvalue element = array[0];"}, {"sha": "3acc608d19452a07c485a9ce0f8849e8d0a44f24", "filename": "gcc/jit/docs/cp/topics/functions.rst", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ffunctions.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,243 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Creating and using functions\n+============================\n+\n+Params\n+------\n+.. class:: gccjit::param\n+\n+   A `gccjit::param` represents a parameter to a function.\n+\n+.. function:: gccjit::param \\\n+              gccjit::context::new_param (gccjit::type type,\\\n+                                          const char *name, \\\n+                                          gccjit::location loc)\n+\n+   In preparation for creating a function, create a new parameter of the\n+   given type and name.\n+\n+:class:`gccjit::param` is a subclass of :class:`gccjit::lvalue` (and thus\n+of :class:`gccjit::rvalue` and :class:`gccjit::object`).  It is a thin\n+wrapper around the C API's :c:type:`gcc_jit_param *`.\n+\n+Functions\n+---------\n+\n+.. class:: gccjit::function\n+\n+   A `gccjit::function` represents a function - either one that we're\n+   creating ourselves, or one that we're referencing.\n+\n+.. function::  gccjit::function \\\n+               gccjit::context::new_function (enum gcc_jit_function_kind,\\\n+                                              gccjit::type return_type, \\\n+                                              const char *name, \\\n+                                              std::vector<param> &params, \\\n+                                              int is_variadic, \\\n+                                              gccjit::location loc) \\\n+\n+   Create a gcc_jit_function with the given name and parameters.\n+\n+   Parameters \"is_variadic\" and \"loc\" are optional.\n+\n+   This is a wrapper around the C API's :c:func:`gcc_jit_context_new_function`.\n+\n+.. function::  gccjit::function \\\n+               gccjit::context::get_builtin_function (const char *name)\n+\n+   This is a wrapper around the C API's\n+   :c:func:`gcc_jit_context_get_builtin_function`.\n+\n+.. function::  gccjit::param \\\n+               gccjit::function::get_param (int index) const\n+\n+   Get the param of the given index (0-based).\n+\n+.. function::  void \\\n+               gccjit::function::dump_to_dot (const char *path)\n+\n+   Emit the function in graphviz format to the given path.\n+\n+.. function:: gccjit::lvalue \\\n+              gccjit::function::new_local (gccjit::type type,\\\n+                                           const char *name, \\\n+                                           gccjit::location loc)\n+\n+   Create a new local variable within the function, of the given type and\n+   name.\n+\n+Blocks\n+------\n+.. class:: gccjit::block\n+\n+   A `gccjit::block` represents a basic block within a function  i.e. a\n+   sequence of statements with a single entry point and a single exit\n+   point.\n+\n+   :class:`gccjit::block` is a subclass of :class:`gccjit::object`.\n+\n+   The first basic block that you create within a function will\n+   be the entrypoint.\n+\n+   Each basic block that you create within a function must be\n+   terminated, either with a conditional, a jump, or a return.\n+\n+   It's legal to have multiple basic blocks that return within\n+   one function.\n+\n+.. function::  gccjit::block \\\n+               gccjit::function::new_block (const char *name)\n+\n+   Create a basic block of the given name.  The name may be NULL, but\n+   providing meaningful names is often helpful when debugging: it may\n+   show up in dumps of the internal representation, and in error\n+   messages.\n+\n+Statements\n+----------\n+\n+.. function:: void\\\n+              gccjit::block::add_eval (gccjit::rvalue rvalue, \\\n+                                       gccjit::location loc)\n+\n+   Add evaluation of an rvalue, discarding the result\n+   (e.g. a function call that \"returns\" void).\n+\n+   This is equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     (void)expression;\n+\n+.. function:: void\\\n+              gccjit::block::add_assignment (gccjit::lvalue lvalue, \\\n+                                             gccjit::rvalue rvalue, \\\n+                                             gccjit::location loc)\n+\n+   Add evaluation of an rvalue, assigning the result to the given\n+   lvalue.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     lvalue = rvalue;\n+\n+.. function:: void\\\n+              gccjit::block::add_assignment_op (gccjit::lvalue lvalue, \\\n+                                                enum gcc_jit_binary_op, \\\n+                                                gccjit::rvalue rvalue, \\\n+                                                gccjit::location loc)\n+\n+   Add evaluation of an rvalue, using the result to modify an\n+   lvalue.\n+\n+   This is analogous to \"+=\" and friends:\n+\n+   .. code-block:: c\n+\n+     lvalue += rvalue;\n+     lvalue *= rvalue;\n+     lvalue /= rvalue;\n+\n+   etc.  For example:\n+\n+   .. code-block:: c\n+\n+     /* \"i++\" */\n+     loop_body.add_assignment_op (\n+       i,\n+       GCC_JIT_BINARY_OP_PLUS,\n+       ctxt.one (int_type));\n+\n+.. function:: void\\\n+              gccjit::block::add_comment (const char *text, \\\n+\t                                  gccjit::location loc)\n+\n+   Add a no-op textual comment to the internal representation of the\n+   code.  It will be optimized away, but will be visible in the dumps\n+   seen via :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE`\n+   and :c:macro:`GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE`,\n+   and thus may be of use when debugging how your project's internal\n+   representation gets converted to the libgccjit IR.\n+\n+   Parameter \"loc\" is optional.\n+\n+.. function:: void\\\n+              gccjit::block::end_with_conditional (gccjit::rvalue boolval,\\\n+                                                   gccjit::block on_true,\\\n+                                                   gccjit::block on_false, \\\n+                                                   gccjit::location loc)\n+\n+   Terminate a block by adding evaluation of an rvalue, branching on the\n+   result to the appropriate successor block.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+     if (boolval)\n+       goto on_true;\n+     else\n+       goto on_false;\n+\n+   block, boolval, on_true, and on_false must be non-NULL.\n+\n+.. function:: void\\\n+              gccjit::block::end_with_jump (gccjit::block target, \\\n+                                            gccjit::location loc)\n+\n+   Terminate a block by adding a jump to the given target block.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+      goto target;\n+\n+.. function:: void\\\n+              gccjit::block::end_with_return (gccjit::rvalue rvalue, \\\n+                                              gccjit::location loc)\n+\n+   Terminate a block.\n+\n+   Both params are optional.\n+\n+   An rvalue must be provided for a function returning non-void, and\n+   must not be provided by a function \"returning\" `void`.\n+\n+   If an rvalue is provided, the block is terminated by evaluating the\n+   rvalue and returning the value.\n+\n+   This is roughly equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+      return expression;\n+\n+   If an rvalue is not provided, the block is terminated by adding a\n+   valueless return, for use within a function with \"void\" return type.\n+\n+   This is equivalent to this C code:\n+\n+   .. code-block:: c\n+\n+      return;"}, {"sha": "a12913751539048abd716ffc480181a82c60000f", "filename": "gcc/jit/docs/cp/topics/index.rst", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Findex.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,30 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+Topic Reference\n+===============\n+\n+.. toctree::\n+   :maxdepth: 2\n+\n+   contexts.rst\n+   objects.rst\n+   types.rst\n+   expressions.rst\n+   functions.rst\n+   locations.rst\n+   results.rst"}, {"sha": "255e6f934bc2be9bd1130d9c9f679c3acf44c1fb", "filename": "gcc/jit/docs/cp/topics/locations.rst", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Flocations.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Flocations.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Flocations.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,65 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Source Locations\n+================\n+\n+.. class:: gccjit::location\n+\n+   A `gccjit::location` encapsulates a source code location, so that\n+   you can (optionally) associate locations in your language with\n+   statements in the JIT-compiled code, allowing the debugger to\n+   single-step through your language.\n+\n+   `gccjit::location` instances are optional: you can always omit them\n+   from any C++ API entrypoint accepting one.\n+\n+   You can construct them using :func:`gccjit::context::new_location`.\n+\n+   You need to enable :c:macro:`GCC_JIT_BOOL_OPTION_DEBUGINFO` on the\n+   :class:`gccjit::context` for these locations to actually be usable by\n+   the debugger:\n+\n+   .. code-block:: cpp\n+\n+     ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DEBUGINFO, 1);\n+\n+.. function:: gccjit::location \\\n+              gccjit::context::new_location (const char *filename, \\\n+                                             int line, \\\n+                                             int column)\n+\n+   Create a `gccjit::location` instance representing the given source\n+   location.\n+\n+Faking it\n+---------\n+If you don't have source code for your internal representation, but need\n+to debug, you can generate a C-like representation of the functions in\n+your context using :func:`gccjit::context::dump_to_file()`:\n+\n+.. code-block:: cpp\n+\n+  ctxt.dump_to_file (\"/tmp/something.c\",\n+                     1 /* update_locations */);\n+\n+This will dump C-like code to the given path.  If the `update_locations`\n+argument is true, this will also set up `gccjit::location` information\n+throughout the context, pointing at the dump file as if it were a source\n+file, giving you *something* you can step through in the debugger."}, {"sha": "cb4fc8b6d100a610b4d13d3cbcbb640c011b78c5", "filename": "gcc/jit/docs/cp/topics/objects.rst", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fobjects.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,70 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Objects\n+=======\n+\n+.. class:: gccjit::object\n+\n+Almost every entity in the API (with the exception of\n+:class:`gccjit::context` and :c:type:`gcc_jit_result *`) is a\n+\"contextual\" object, a :class:`gccjit::object`.\n+\n+A JIT object:\n+\n+  * is associated with a :class:`gccjit::context`.\n+\n+  * is automatically cleaned up for you when its context is released so\n+    you don't need to manually track and cleanup all objects, just the\n+    contexts.\n+\n+The C++ class hierarchy within the ``gccjit`` namespace looks like this::\n+\n+  +- object\n+      +- location\n+      +- type\n+         +- struct\n+      +- field\n+      +- function\n+      +- block\n+      +- rvalue\n+          +- lvalue\n+             +- param\n+\n+The :class:`gccjit::object` base class has the following operations:\n+\n+.. function:: gccjit::context gccjit::object::get_context () const\n+\n+  Which context is the obj within?\n+\n+.. function:: std::string gccjit::object::get_debug_string () const\n+\n+  Generate a human-readable description for the given object.\n+\n+  For example,\n+\n+  .. code-block:: c++\n+\n+     printf (\"obj: %s\\n\", obj.get_debug_string ().c_str ());\n+\n+  might give this text on stdout:\n+\n+  .. code-block:: bash\n+\n+     obj: 4.0 * (float)i"}, {"sha": "18200acdbb292e5f5a13df38f5bd8f590310f89e", "filename": "gcc/jit/docs/cp/topics/results.rst", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fresults.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fresults.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Fresults.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,48 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Compilation results\n+===================\n+\n+.. type:: gcc_jit_result\n+\n+  A `gcc_jit_result` encapsulates the result of compiling a context.\n+\n+.. function:: gcc_jit_result *\\\n+              gccjit::context::compile ()\n+\n+   This calls into GCC and builds the code, returning a\n+   `gcc_jit_result *`.\n+\n+\n+.. function:: void *\\\n+              gcc_jit_result_get_code (gcc_jit_result *result,\\\n+                                       const char *funcname)\n+\n+   Locate a given function within the built machine code.\n+   This will need to be cast to a function pointer of the\n+   correct type before it can be called.\n+\n+\n+.. function:: void\\\n+              gcc_jit_result_release (gcc_jit_result *result)\n+\n+   Once we're done with the code, this unloads the built .so file.\n+   This cleans up the result; after calling this, it's no longer\n+   valid to use the result."}, {"sha": "af1e4dca3dafd658967ddbff7658e69b822e4367", "filename": "gcc/jit/docs/cp/topics/types.rst", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fcp%2Ftopics%2Ftypes.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,183 @@\n+.. Copyright (C) 2014 Free Software Foundation, Inc.\n+   Originally contributed by David Malcolm <dmalcolm@redhat.com>\n+\n+   This is free software: you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see\n+   <http://www.gnu.org/licenses/>.\n+\n+.. default-domain:: cpp\n+\n+Types\n+=====\n+\n+.. class:: gccjit::type\n+\n+   gccjit::type represents a type within the library.  It is a subclass\n+   of :class:`gccjit::object`.\n+\n+Types can be created in several ways:\n+\n+* fundamental types can be accessed using\n+  :func:`gccjit::context::get_type`:\n+\n+  .. code-block:: c++\n+\n+      gccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n+\n+  or using the :func:`gccjit::context::get_int_type<T>` template:\n+\n+  .. code-block:: c++\n+\n+      gccjit::type t = ctxt.get_int_type <unsigned short> ();\n+\n+  See :c:func:`gcc_jit_context_get_type` for the available types.\n+\n+* derived types can be accessed by using functions such as\n+  :func:`gccjit::type::get_pointer` and :func:`gccjit::type::get_const`:\n+\n+  .. code-block:: c++\n+\n+    gccjit::type const_int_star = int_type.get_const ().get_pointer ();\n+    gccjit::type int_const_star = int_type.get_pointer ().get_const ();\n+\n+* by creating structures (see below).\n+\n+Standard types\n+--------------\n+\n+.. function:: gccjit::type gccjit::context::get_type (enum gcc_jit_types)\n+\n+   Access a specific type.  This is a thin wrapper around\n+   :c:func:`gcc_jit_context_get_type`; the parameter has the same meaning.\n+\n+.. function:: gccjit::type \\\n+              gccjit::context::get_int_type (size_t num_bytes, int is_signed)\n+\n+   Access the integer type of the given size.\n+\n+.. function:: gccjit::type \\\n+              gccjit::context::get_int_type <T> ()\n+\n+   Access the given integer type.  For example, you could map the\n+   ``unsigned short`` type into a gccjit::type via:\n+\n+   .. code-block:: c++\n+\n+      gccjit::type t = ctxt.get_int_type <unsigned short> ();\n+\n+Pointers, `const`, and `volatile`\n+---------------------------------\n+\n+.. function::  gccjit::type gccjit::type::get_pointer ()\n+\n+   Given type \"T\", get type \"T*\".\n+\n+.. FIXME: get_const doesn't seem to exist\n+\n+.. function::  gccjit::type gccjit::type::get_const ()\n+\n+   Given type \"T\", get type \"const T\".\n+\n+.. function::  gccjit::type gccjit::type::get_volatile ()\n+\n+   Given type \"T\", get type \"volatile T\".\n+\n+.. function::  gccjit::type \\\n+               gccjit::context::new_array_type (gccjit::type element_type, \\\n+                                                int num_elements, \\\n+\t\t\t                        gccjit::location loc)\n+\n+   Given type \"T\", get type \"T[N]\" (for a constant N).\n+   Param \"loc\" is optional.\n+\n+\n+Structures and unions\n+---------------------\n+\n+.. class:: gccjit::struct_\n+\n+A compound type analagous to a C `struct`.\n+\n+:class:`gccjit::struct_` is a subclass of :class:`gccjit::type` (and thus\n+of :class:`gccjit::object` in turn).\n+\n+.. class:: gccjit::field\n+\n+A field within a :class:`gccjit::struct_`.\n+\n+:class:`gccjit::field` is a subclass of :class:`gccjit::object`.\n+\n+You can model C `struct` types by creating :class:`gccjit::struct_` and\n+:class:`gccjit::field` instances, in either order:\n+\n+* by creating the fields, then the structure.  For example, to model:\n+\n+  .. code-block:: c\n+\n+    struct coord {double x; double y; };\n+\n+  you could call:\n+\n+  .. code-block:: c++\n+\n+    gccjit::field field_x = ctxt.new_field (double_type, \"x\");\n+    gccjit::field field_y = ctxt.new_field (double_type, \"y\");\n+    std::vector fields;\n+    fields.push_back (field_x);\n+    fields.push_back (field_y);\n+    gccjit::struct_ coord = ctxt.new_struct_type (\"coord\", fields);\n+\n+* by creating the structure, then populating it with fields, typically\n+  to allow modelling self-referential structs such as:\n+\n+  .. code-block:: c\n+\n+    struct node { int m_hash; struct node *m_next; };\n+\n+  like this:\n+\n+  .. code-block:: c++\n+\n+    gccjit::struct_ node = ctxt.new_opaque_struct_type (\"node\");\n+    gccjit::type node_ptr = node.get_pointer ();\n+    gccjit::field field_hash = ctxt.new_field (int_type, \"m_hash\");\n+    gccjit::field field_next = ctxt.new_field (node_ptr, \"m_next\");\n+    std::vector fields;\n+    fields.push_back (field_hash);\n+    fields.push_back (field_next);\n+    node.set_fields (fields);\n+\n+.. FIXME: the above API doesn't seem to exist yet\n+\n+.. function:: gccjit::field \\\n+              gccjit::context::new_field (gccjit::type type,\\\n+                                          const char *name, \\\n+                                          gccjit::location loc)\n+\n+   Construct a new field, with the given type and name.\n+\n+.. function:: gccjit::struct_ \\\n+   gccjit::context::new_struct_type (const std::string &name,\\\n+                                     std::vector<field> &fields,\\\n+                                     gccjit::location loc)\n+\n+     Construct a new struct type, with the given name and fields.\n+\n+.. function:: gccjit::struct_ \\\n+              gccjit::context::new_opaque_struct (const std::string &name, \\\n+                                                  gccjit::location loc)\n+\n+     Construct a new struct type, with the given name, but without\n+     specifying the fields.   The fields can be omitted (in which case the\n+     size of the struct is not known), or later specified using\n+     :c:func:`gcc_jit_struct_set_fields`."}, {"sha": "d70fe6791af9af2d990307cb75266ba8be758c8f", "filename": "gcc/jit/docs/examples/tut01-hello-world.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut01-hello-world.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut01-hello-world.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut01-hello-world.cc?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,107 @@\n+/* Smoketest example for libgccjit.so C++ API\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <libgccjit++.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+static void\n+create_code (gccjit::context ctxt)\n+{\n+  /* Let's try to inject the equivalent of this C code:\n+     void\n+     greet (const char *name)\n+     {\n+        printf (\"hello %s\\n\", name);\n+     }\n+  */\n+  gccjit::type void_type = ctxt.get_type (GCC_JIT_TYPE_VOID);\n+  gccjit::type const_char_ptr_type =\n+    ctxt.get_type (GCC_JIT_TYPE_CONST_CHAR_PTR);\n+  gccjit::param param_name =\n+    ctxt.new_param (const_char_ptr_type, \"name\");\n+  std::vector<gccjit::param> func_params;\n+  func_params.push_back (param_name);\n+  gccjit::function func =\n+    ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                       void_type,\n+                       \"greet\",\n+                       func_params, 0);\n+\n+  gccjit::param param_format =\n+    ctxt.new_param (const_char_ptr_type, \"format\");\n+  std::vector<gccjit::param> printf_params;\n+  printf_params.push_back (param_format);\n+  gccjit::function printf_func =\n+    ctxt.new_function (GCC_JIT_FUNCTION_IMPORTED,\n+                       ctxt.get_type (GCC_JIT_TYPE_INT),\n+                       \"printf\",\n+                       printf_params, 1);\n+\n+  gccjit::block block = func.new_block ();\n+  block.add_eval (ctxt.new_call (printf_func,\n+                                 ctxt.new_rvalue (\"hello %s\\n\"),\n+                                 param_name));\n+  block.end_with_return ();\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  gccjit::context ctxt;\n+  gcc_jit_result *result;\n+\n+  /* Get a \"context\" object for working with the library.  */\n+  ctxt = gccjit::context::acquire ();\n+\n+  /* Set some options on the context.\n+     Turn this on to see the code being generated, in assembler form.  */\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE, 0);\n+\n+  /* Populate the context.  */\n+  create_code (ctxt);\n+\n+  /* Compile the code.  */\n+  result = ctxt.compile ();\n+  if (!result)\n+    {\n+      fprintf (stderr, \"NULL result\");\n+      exit (1);\n+    }\n+\n+  ctxt.release ();\n+\n+  /* Extract the generated code from \"result\".  */\n+  typedef void (*fn_type) (const char *);\n+  fn_type greet =\n+    (fn_type)gcc_jit_result_get_code (result, \"greet\");\n+  if (!greet)\n+    {\n+      fprintf (stderr, \"NULL greet\");\n+      exit (1);\n+    }\n+\n+  /* Now call the generated function: */\n+  greet (\"world\");\n+  fflush (stdout);\n+\n+  gcc_jit_result_release (result);\n+  return 0;\n+}"}, {"sha": "9ee1f38ea8682926d5cd7e39d8604954ca60dc65", "filename": "gcc/jit/docs/examples/tut02-square.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.c?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -102,7 +102,7 @@ main (int argc, char **argv)\n \n   typedef int (*fn_type) (int);\n   fn_type square = (fn_type)fn_ptr;\n-  printf (\"result: %d\", square (5));\n+  printf (\"result: %d\\n\", square (5));\n \n  error:\n   if (ctxt)"}, {"sha": "a48245ee1f9fca3d16c78393aa8e7310ff36b279", "filename": "gcc/jit/docs/examples/tut02-square.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut02-square.cc?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,95 @@\n+/* Usage example for libgccjit.so's C++ API\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <libgccjit++.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+void\n+create_code (gccjit::context ctxt)\n+{\n+  /* Let's try to inject the equivalent of this C code:\n+\n+      int square (int i)\n+      {\n+        return i * i;\n+      }\n+  */\n+  gccjit::type int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n+  gccjit::param param_i = ctxt.new_param (int_type, \"i\");\n+  std::vector<gccjit::param> params;\n+  params.push_back (param_i);\n+  gccjit::function func = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                                             int_type,\n+                                             \"square\",\n+                                             params, 0);\n+\n+  gccjit::block block = func.new_block ();\n+\n+  gccjit::rvalue expr =\n+    ctxt.new_binary_op (GCC_JIT_BINARY_OP_MULT, int_type,\n+                        param_i, param_i);\n+\n+  block.end_with_return (expr);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  /* Get a \"context\" object for working with the library.  */\n+  gccjit::context ctxt = gccjit::context::acquire ();\n+\n+  /* Set some options on the context.\n+     Turn this on to see the code being generated, in assembler form.  */\n+  ctxt.set_bool_option (\n+    GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+    0);\n+\n+  /* Populate the context.  */\n+  create_code (ctxt);\n+\n+  /* Compile the code.  */\n+  gcc_jit_result *result = ctxt.compile ();\n+\n+  /* We're done with the context; we can release it: */\n+  ctxt.release ();\n+\n+  if (!result)\n+    {\n+      fprintf (stderr, \"NULL result\");\n+      return 1;\n+    }\n+\n+  /* Extract the generated code from \"result\".  */\n+  void *fn_ptr = gcc_jit_result_get_code (result, \"square\");\n+  if (!fn_ptr)\n+     {\n+       fprintf (stderr, \"NULL fn_ptr\");\n+       gcc_jit_result_release (result);\n+       return 1;\n+     }\n+\n+  typedef int (*fn_type) (int);\n+  fn_type square = (fn_type)fn_ptr;\n+  printf (\"result: %d\\n\", square (5));\n+\n+  gcc_jit_result_release (result);\n+  return 0;\n+}"}, {"sha": "dc0832fac2e2f1e28a2311ee8ae05731fd98e603", "filename": "gcc/jit/docs/examples/tut03-sum-of-squares.cc", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut03-sum-of-squares.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut03-sum-of-squares.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut03-sum-of-squares.cc?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,137 @@\n+/* Usage example for libgccjit.so's C++ API\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <libgccjit++.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+void\n+create_code (gccjit::context ctxt)\n+{\n+  /*\n+    Simple sum-of-squares, to test conditionals and looping\n+\n+    int loop_test (int n)\n+    {\n+      int i;\n+      int sum = 0;\n+      for (i = 0; i < n ; i ++)\n+      {\n+\tsum += i * i;\n+      }\n+      return sum;\n+   */\n+  gccjit::type the_type = ctxt.get_int_type <int> ();\n+  gccjit::type return_type = the_type;\n+\n+  gccjit::param n = ctxt.new_param (the_type, \"n\");\n+  std::vector<gccjit::param> params;\n+  params.push_back (n);\n+  gccjit::function func =\n+    ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                       return_type,\n+                       \"loop_test\",\n+                       params, 0);\n+\n+  /* Build locals:  */\n+  gccjit::lvalue i = func.new_local (the_type, \"i\");\n+  gccjit::lvalue sum = func.new_local (the_type, \"sum\");\n+\n+  gccjit::block b_initial = func.new_block (\"initial\");\n+  gccjit::block b_loop_cond = func.new_block (\"loop_cond\");\n+  gccjit::block b_loop_body = func.new_block (\"loop_body\");\n+  gccjit::block b_after_loop = func.new_block (\"after_loop\");\n+\n+  /* sum = 0; */\n+  b_initial.add_assignment (sum, ctxt.zero (the_type));\n+\n+  /* i = 0; */\n+  b_initial.add_assignment (i, ctxt.zero (the_type));\n+\n+  b_initial.end_with_jump (b_loop_cond);\n+\n+  /* if (i >= n) */\n+  b_loop_cond.end_with_conditional (\n+    i >= n,\n+    b_after_loop,\n+    b_loop_body);\n+\n+  /* sum += i * i */\n+  b_loop_body.add_assignment_op (sum,\n+                                 GCC_JIT_BINARY_OP_PLUS,\n+                                 i * i);\n+\n+  /* i++ */\n+  b_loop_body.add_assignment_op (i,\n+                                GCC_JIT_BINARY_OP_PLUS,\n+                                ctxt.one (the_type));\n+\n+  b_loop_body.end_with_jump (b_loop_cond);\n+\n+  /* return sum */\n+  b_after_loop.end_with_return (sum);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  gccjit::context ctxt;\n+  gcc_jit_result *result = NULL;\n+\n+  /* Get a \"context\" object for working with the library.  */\n+  ctxt = gccjit::context::acquire ();\n+\n+  /* Set some options on the context.\n+     Turn this on to see the code being generated, in assembler form.  */\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+                        0);\n+\n+  /* Populate the context.  */\n+  create_code (ctxt);\n+\n+  /* Compile the code.  */\n+  result = ctxt.compile ();\n+\n+  ctxt.release ();\n+\n+  if (!result)\n+    {\n+      fprintf (stderr, \"NULL result\");\n+      return 1;\n+    }\n+\n+  /* Extract the generated code from \"result\".  */\n+  typedef int (*loop_test_fn_type) (int);\n+  loop_test_fn_type loop_test =\n+    (loop_test_fn_type)gcc_jit_result_get_code (result, \"loop_test\");\n+  if (!loop_test)\n+    {\n+      fprintf (stderr, \"NULL loop_test\");\n+      gcc_jit_result_release (result);\n+      return 1;\n+    }\n+\n+  /* Run the generated code.  */\n+  int val = loop_test (10);\n+  printf(\"loop_test returned: %d\\n\", val);\n+\n+  gcc_jit_result_release (result);\n+  return 0;\n+}"}, {"sha": "3a9bbdea86aa2fdc3e3cf979bb2027c995c0b2ac", "filename": "gcc/jit/docs/examples/tut04-toyvm/toyvm.cc", "status": "added", "additions": 902, "deletions": 0, "changes": 902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ftoyvm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ftoyvm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Fexamples%2Ftut04-toyvm%2Ftoyvm.cc?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -0,0 +1,902 @@\n+/* A simple stack-based virtual machine to demonstrate\n+   JIT-compilation.\n+   Copyright (C) 2014 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <assert.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <dejagnu.h>\n+\n+#include <libgccjit++.h>\n+\n+/* Functions are compiled to this function ptr type.  */\n+typedef int (*toyvm_compiled_func) (int);\n+\n+enum opcode {\n+  /* Ops taking no operand.  */\n+  DUP,\n+  ROT,\n+  BINARY_ADD,\n+  BINARY_SUBTRACT,\n+  BINARY_MULT,\n+  BINARY_COMPARE_LT,\n+  RECURSE,\n+  RETURN,\n+\n+  /* Ops taking an operand.  */\n+  PUSH_CONST,\n+  JUMP_ABS_IF_TRUE\n+};\n+\n+#define FIRST_UNARY_OPCODE (PUSH_CONST)\n+\n+const char * const opcode_names[] = {\n+  \"DUP\",\n+  \"ROT\",\n+  \"BINARY_ADD\",\n+  \"BINARY_SUBTRACT\",\n+  \"BINARY_MULT\",\n+  \"BINARY_COMPARE_LT\",\n+  \"RECURSE\",\n+  \"RETURN\",\n+\n+  \"PUSH_CONST\",\n+  \"JUMP_ABS_IF_TRUE\",\n+};\n+\n+struct toyvm_op\n+{\n+  /* Which operation.  */\n+  enum opcode op_opcode;\n+\n+  /* Some opcodes take an argument.  */\n+  int op_operand;\n+\n+  /* The line number of the operation within the source file.  */\n+  int op_linenum;\n+};\n+\n+#define MAX_OPS  (64)\n+\n+class toyvm_function\n+{\n+public:\n+  void\n+  add_op (enum opcode opcode,\n+          int operand, int linenum);\n+\n+  void\n+  add_unary_op (enum opcode opcode,\n+                const char *rest_of_line, int linenum);\n+\n+  static toyvm_function *\n+  parse (const char *filename, const char *name);\n+\n+  void\n+  disassemble_op (toyvm_op *op, int index, FILE *out);\n+\n+  void\n+  disassemble (FILE *out);\n+\n+  int\n+  interpret (int arg, FILE *trace);\n+\n+  toyvm_compiled_func\n+  compile ();\n+\n+private:\n+  const char *fn_filename;\n+  int         fn_num_ops;\n+  toyvm_op    fn_ops[MAX_OPS];\n+  friend struct compilation_state;\n+};\n+\n+#define MAX_STACK_DEPTH (8)\n+\n+class toyvm_frame\n+{\n+public:\n+  void push (int arg);\n+  int pop ();\n+  void dump_stack (FILE *out);\n+\n+private:\n+  toyvm_function *frm_function;\n+  int             frm_pc;\n+  int             frm_stack[MAX_STACK_DEPTH];\n+  int             frm_cur_depth;\n+\n+  friend int toyvm_function::interpret (int arg, FILE *trace);\n+\n+};\n+\n+void\n+toyvm_function::add_op (enum opcode opcode,\n+                        int operand, int linenum)\n+{\n+  toyvm_op *op;\n+  assert (fn_num_ops < MAX_OPS);\n+  op = &fn_ops[fn_num_ops++];\n+  op->op_opcode = opcode;\n+  op->op_operand = operand;\n+  op->op_linenum = linenum;\n+}\n+\n+void\n+toyvm_function::add_unary_op (enum opcode opcode,\n+                              const char *rest_of_line, int linenum)\n+{\n+  int operand = atoi (rest_of_line);\n+  add_op (opcode, operand, linenum);\n+}\n+\n+static char *\n+get_function_name (const char *filename)\n+{\n+  /* Skip any path separators.  */\n+  const char *pathsep = strrchr (filename, '/');\n+  if (pathsep)\n+    filename = pathsep + 1;\n+\n+  /* Copy filename to funcname.  */\n+  char *funcname = (char *)malloc (strlen (filename) + 1);\n+\n+  strcpy (funcname, filename);\n+\n+  /* Convert \".\" to NIL terminator.  */\n+  *(strchr (funcname, '.')) = '\\0';\n+\n+  return funcname;\n+}\n+\n+toyvm_function *\n+toyvm_function::parse (const char *filename, const char *name)\n+{\n+  FILE *f = NULL;\n+  toyvm_function *fn = NULL;\n+  char *line = NULL;\n+  ssize_t linelen;\n+  size_t bufsize;\n+  int linenum = 0;\n+\n+  assert (filename);\n+  assert (name);\n+\n+  f = fopen (filename, \"r\");\n+  if (!f)\n+    {\n+      fprintf (stderr,\n+\t       \"cannot open file %s: %s\\n\",\n+\t       filename, strerror (errno));\n+      goto error;\n+    }\n+\n+  fn = (toyvm_function *)calloc (1, sizeof (toyvm_function));\n+  if (!fn)\n+    {\n+      fprintf (stderr, \"out of memory allocating toyvm_function\\n\");\n+      goto error;\n+    }\n+  fn->fn_filename = filename;\n+\n+  /* Read the lines of the file.  */\n+  while ((linelen = getline (&line, &bufsize, f)) != -1)\n+    {\n+      /* Note that this is a terrible parser, but it avoids the need to\n+\t bring in lex/yacc as a dependency.  */\n+      linenum++;\n+\n+      if (0)\n+\tfprintf (stdout, \"%3d: %s\", linenum, line);\n+\n+      /* Lines beginning with # are comments.  */\n+      if (line[0] == '#')\n+\tcontinue;\n+\n+      /* Skip blank lines.  */\n+      if (line[0] == '\\n')\n+\tcontinue;\n+\n+#define LINE_MATCHES(OPCODE) (0 == strncmp ((OPCODE), line, strlen (OPCODE)))\n+      if (LINE_MATCHES (\"DUP\\n\"))\n+\tfn->add_op (DUP, 0, linenum);\n+      else if (LINE_MATCHES (\"ROT\\n\"))\n+\tfn->add_op (ROT, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_ADD\\n\"))\n+\tfn->add_op (BINARY_ADD, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_SUBTRACT\\n\"))\n+\tfn->add_op (BINARY_SUBTRACT, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_MULT\\n\"))\n+\tfn->add_op (BINARY_MULT, 0, linenum);\n+      else if (LINE_MATCHES (\"BINARY_COMPARE_LT\\n\"))\n+\tfn->add_op (BINARY_COMPARE_LT, 0, linenum);\n+      else if (LINE_MATCHES (\"RECURSE\\n\"))\n+\tfn->add_op (RECURSE, 0, linenum);\n+      else if (LINE_MATCHES (\"RETURN\\n\"))\n+\tfn->add_op (RETURN, 0, linenum);\n+      else if (LINE_MATCHES (\"PUSH_CONST \"))\n+\tfn->add_unary_op (PUSH_CONST,\n+                          line + strlen (\"PUSH_CONST \"), linenum);\n+      else if (LINE_MATCHES (\"JUMP_ABS_IF_TRUE \"))\n+\tfn->add_unary_op (JUMP_ABS_IF_TRUE,\n+                          line + strlen(\"JUMP_ABS_IF_TRUE \"), linenum);\n+      else\n+\t{\n+\t  fprintf (stderr, \"%s:%d: parse error\\n\", filename, linenum);\n+\t  free (fn);\n+\t  fn = NULL;\n+\t  goto error;\n+\t}\n+#undef LINE_MATCHES\n+    }\n+  free (line);\n+  fclose (f);\n+\n+  return fn;\n+\n+ error:\n+  free (line);\n+  if (f)\n+    fclose (f);\n+  free (fn);\n+  return NULL;\n+}\n+\n+void\n+toyvm_function::disassemble_op (toyvm_op *op, int index, FILE *out)\n+{\n+  fprintf (out, \"%s:%d: index %d: %s\",\n+\t   fn_filename, op->op_linenum, index,\n+\t   opcode_names[op->op_opcode]);\n+  if (op->op_opcode >= FIRST_UNARY_OPCODE)\n+    fprintf (out, \" %d\", op->op_operand);\n+  fprintf (out, \"\\n\");\n+}\n+\n+void\n+toyvm_function::disassemble (FILE *out)\n+{\n+  int i;\n+  for (i = 0; i < fn_num_ops; i++)\n+    {\n+      toyvm_op *op = &fn_ops[i];\n+      disassemble_op (op, i, out);\n+    }\n+}\n+\n+void\n+toyvm_frame::push (int arg)\n+{\n+  assert (frm_cur_depth < MAX_STACK_DEPTH);\n+  frm_stack[frm_cur_depth++] = arg;\n+}\n+\n+int\n+toyvm_frame::pop ()\n+{\n+  assert (frm_cur_depth > 0);\n+  return frm_stack[--frm_cur_depth];\n+}\n+\n+void\n+toyvm_frame::dump_stack (FILE *out)\n+{\n+  int i;\n+  fprintf (out, \"stack:\");\n+  for (i = 0; i < frm_cur_depth; i++)\n+    {\n+      fprintf (out, \" %d\", frm_stack[i]);\n+    }\n+  fprintf (out, \"\\n\");\n+}\n+\n+/* Execute the given function.  */\n+\n+int\n+toyvm_function::interpret (int arg, FILE *trace)\n+{\n+  toyvm_frame frame;\n+#define PUSH(ARG) (frame.push (ARG))\n+#define POP(ARG) (frame.pop ())\n+\n+  frame.frm_function = this;\n+  frame.frm_pc = 0;\n+  frame.frm_cur_depth = 0;\n+\n+  PUSH (arg);\n+\n+  while (1)\n+    {\n+      toyvm_op *op;\n+      int x, y;\n+      assert (frame.frm_pc < fn_num_ops);\n+      op = &fn_ops[frame.frm_pc++];\n+\n+      if (trace)\n+\t{\n+\t  frame.dump_stack (trace);\n+\t  disassemble_op (op, frame.frm_pc, trace);\n+\t}\n+\n+      switch (op->op_opcode)\n+\t{\n+\t  /* Ops taking no operand.  */\n+\tcase DUP:\n+\t  x = POP ();\n+\t  PUSH (x);\n+\t  PUSH (x);\n+\t  break;\n+\n+\tcase ROT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (y);\n+\t  PUSH (x);\n+\t  break;\n+\n+\tcase BINARY_ADD:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x + y);\n+\t  break;\n+\n+\tcase BINARY_SUBTRACT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x - y);\n+\t  break;\n+\n+\tcase BINARY_MULT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x * y);\n+\t  break;\n+\n+\tcase BINARY_COMPARE_LT:\n+\t  y = POP ();\n+\t  x = POP ();\n+\t  PUSH (x < y);\n+\t  break;\n+\n+\tcase RECURSE:\n+\t  x = POP ();\n+\t  x = interpret (x, trace);\n+\t  PUSH (x);\n+\t  break;\n+\n+\tcase RETURN:\n+\t  return POP ();\n+\n+\t  /* Ops taking an operand.  */\n+\tcase PUSH_CONST:\n+\t  PUSH (op->op_operand);\n+\t  break;\n+\n+\tcase JUMP_ABS_IF_TRUE:\n+\t  x = POP ();\n+\t  if (x)\n+\t    frame.frm_pc = op->op_operand;\n+\t  break;\n+\n+\tdefault:\n+\t  assert (0); /* unknown opcode */\n+\n+\t} /* end of switch on opcode */\n+    } /* end of while loop */\n+\n+#undef PUSH\n+#undef POP\n+}\n+\n+/* JIT compilation.  */\n+\n+class compilation_state\n+{\n+public:\n+  compilation_state (toyvm_function &toyvmfn) :\n+    toyvmfn (toyvmfn)\n+  {}\n+\n+  void create_context ();\n+  void create_types ();\n+  void create_locations ();\n+  void create_function (const char *funcname);\n+  gcc_jit_result *compile ();\n+\n+private:\n+  void\n+  add_push (gccjit::block block,\n+            gccjit::rvalue rvalue,\n+            gccjit::location loc);\n+\n+  void\n+  add_pop (gccjit::block block,\n+           gccjit::lvalue lvalue,\n+           gccjit::location loc);\n+\n+private:\n+\n+  /* State.  */\n+\n+  toyvm_function &toyvmfn;\n+\n+  gccjit::context ctxt;\n+\n+  gccjit::type int_type;\n+  gccjit::type bool_type;\n+  gccjit::type stack_type; /* int[MAX_STACK_DEPTH] */\n+\n+  gccjit::rvalue const_one;\n+\n+  gccjit::function fn;\n+  gccjit::param param_arg;\n+  gccjit::lvalue stack;\n+  gccjit::lvalue stack_depth;\n+  gccjit::lvalue x;\n+  gccjit::lvalue y;\n+\n+  gccjit::location op_locs[MAX_OPS];\n+  gccjit::block initial_block;\n+  gccjit::block op_blocks[MAX_OPS];\n+\n+};\n+\n+/* The main compilation hook.  */\n+\n+toyvm_compiled_func\n+toyvm_function::compile ()\n+{\n+  compilation_state state (*this);\n+  char *funcname;\n+\n+  funcname = get_function_name (fn_filename);\n+\n+  state.create_context ();\n+  state.create_types ();\n+  state.create_locations ();\n+  state.create_function (funcname);\n+\n+  /* We've now finished populating the context.  Compile it.  */\n+  gcc_jit_result *result = state.compile ();\n+\n+  return (toyvm_compiled_func)gcc_jit_result_get_code (result, funcname);\n+  /* (this leaks \"result\" and \"funcname\") */\n+}\n+\n+/* Stack manipulation.  */\n+\n+void\n+compilation_state::add_push (gccjit::block block,\n+                             gccjit::rvalue rvalue,\n+                             gccjit::location loc)\n+{\n+  /* stack[stack_depth] = RVALUE */\n+  block.add_assignment (\n+    /* stack[stack_depth] */\n+    ctxt.new_array_access (\n+      stack,\n+      stack_depth,\n+      loc),\n+    rvalue,\n+    loc);\n+\n+  /* \"stack_depth++;\".  */\n+  block.add_assignment_op (\n+    stack_depth,\n+    GCC_JIT_BINARY_OP_PLUS,\n+    const_one,\n+    loc);\n+}\n+\n+void\n+compilation_state::add_pop (gccjit::block block,\n+                            gccjit::lvalue lvalue,\n+                            gccjit::location loc)\n+{\n+  /* \"--stack_depth;\".  */\n+  block.add_assignment_op (\n+    stack_depth,\n+    GCC_JIT_BINARY_OP_MINUS,\n+    const_one,\n+    loc);\n+\n+  /* \"LVALUE = stack[stack_depth];\".  */\n+  block.add_assignment (\n+    lvalue,\n+    /* stack[stack_depth] */\n+    ctxt.new_array_access (stack,\n+                           stack_depth,\n+                           loc),\n+    loc);\n+}\n+\n+/* Create the context. */\n+\n+void\n+compilation_state::create_context ()\n+{\n+  ctxt = gccjit::context::acquire ();\n+\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE,\n+                              0);\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_GENERATED_CODE,\n+                              0);\n+  ctxt.set_int_option (GCC_JIT_INT_OPTION_OPTIMIZATION_LEVEL,\n+                             3);\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_KEEP_INTERMEDIATES,\n+                              0);\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DUMP_EVERYTHING,\n+                              0);\n+  ctxt.set_bool_option (GCC_JIT_BOOL_OPTION_DEBUGINFO,\n+                              1);\n+}\n+\n+/* Create types.  */\n+\n+void\n+compilation_state::create_types ()\n+{\n+  /* Create types.  */\n+  int_type = ctxt.get_type (GCC_JIT_TYPE_INT);\n+  bool_type = ctxt.get_type (GCC_JIT_TYPE_BOOL);\n+  stack_type = ctxt.new_array_type (int_type, MAX_STACK_DEPTH);\n+\n+  /* The constant value 1.  */\n+  const_one = ctxt.one (int_type);\n+\n+}\n+\n+/* Create locations.  */\n+\n+void\n+compilation_state::create_locations ()\n+{\n+  for (int pc = 0; pc < toyvmfn.fn_num_ops; pc++)\n+    {\n+      toyvm_op *op = &toyvmfn.fn_ops[pc];\n+\n+      op_locs[pc] = ctxt.new_location (toyvmfn.fn_filename,\n+                                       op->op_linenum,\n+                                       0); /* column */\n+    }\n+}\n+\n+/* Creating the function.  */\n+\n+void\n+compilation_state::create_function (const char *funcname)\n+{\n+  std::vector <gccjit::param> params;\n+  param_arg = ctxt.new_param (int_type, \"arg\", op_locs[0]);\n+  params.push_back (param_arg);\n+  fn = ctxt.new_function (GCC_JIT_FUNCTION_EXPORTED,\n+                          int_type,\n+                          funcname,\n+                          params, 0,\n+                          op_locs[0]);\n+\n+  /* Create stack lvalues.  */\n+  stack = fn.new_local (stack_type, \"stack\");\n+  stack_depth = fn.new_local (int_type, \"stack_depth\");\n+  x = fn.new_local (int_type, \"x\");\n+  y = fn.new_local (int_type, \"y\");\n+\n+  /* 1st pass: create blocks, one per opcode. */\n+\n+  /* We need an entry block to do one-time initialization, so create that\n+     first.  */\n+  initial_block = fn.new_block (\"initial\");\n+\n+  /* Create a block per operation.  */\n+  for (int pc = 0; pc < toyvmfn.fn_num_ops; pc++)\n+    {\n+      char buf[16];\n+      sprintf (buf, \"instr%i\", pc);\n+      op_blocks[pc] = fn.new_block (buf);\n+    }\n+\n+  /* Populate the initial block.  */\n+\n+  /* \"stack_depth = 0;\".  */\n+  initial_block.add_assignment (stack_depth,\n+                                ctxt.zero (int_type),\n+                                op_locs[0]);\n+\n+  /* \"PUSH (arg);\".  */\n+  add_push (initial_block,\n+\t    param_arg,\n+            op_locs[0]);\n+\n+  /* ...and jump to insn 0.  */\n+  initial_block.end_with_jump (op_blocks[0],\n+                               op_locs[0]);\n+\n+  /* 2nd pass: fill in instructions.  */\n+  for (int pc = 0; pc < toyvmfn.fn_num_ops; pc++)\n+    {\n+      gccjit::location loc = op_locs[pc];\n+\n+      gccjit::block block = op_blocks[pc];\n+      gccjit::block next_block = (pc < toyvmfn.fn_num_ops\n+                                  ? op_blocks[pc + 1]\n+                                  : NULL);\n+\n+      toyvm_op *op;\n+      op = &toyvmfn.fn_ops[pc];\n+\n+      /* Helper macros.  */\n+\n+#define X_EQUALS_POP()\\\n+      add_pop (block, x, loc)\n+#define Y_EQUALS_POP()\\\n+      add_pop (block, y, loc)\n+#define PUSH_RVALUE(RVALUE)\\\n+      add_push (block, (RVALUE), loc)\n+#define PUSH_X()\\\n+      PUSH_RVALUE (x)\n+#define PUSH_Y() \\\n+      PUSH_RVALUE (y)\n+\n+      block.add_comment (opcode_names[op->op_opcode], loc);\n+\n+      /* Handle the individual opcodes.  */\n+\n+      switch (op->op_opcode)\n+\t{\n+\tcase DUP:\n+\t  X_EQUALS_POP ();\n+\t  PUSH_X ();\n+\t  PUSH_X ();\n+\t  break;\n+\n+\tcase ROT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_Y ();\n+\t  PUSH_X ();\n+\t  break;\n+\n+\tcase BINARY_ADD:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+\t   ctxt.new_binary_op (\n+\t     GCC_JIT_BINARY_OP_PLUS,\n+\t     int_type,\n+             x, y,\n+             loc));\n+\t  break;\n+\n+\tcase BINARY_SUBTRACT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+           ctxt.new_binary_op (\n+\t     GCC_JIT_BINARY_OP_MINUS,\n+\t     int_type,\n+             x, y,\n+             loc));\n+\t  break;\n+\n+\tcase BINARY_MULT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+           ctxt.new_binary_op (\n+\t     GCC_JIT_BINARY_OP_MULT,\n+\t     int_type,\n+             x, y,\n+             loc));\n+\t  break;\n+\n+\tcase BINARY_COMPARE_LT:\n+\t  Y_EQUALS_POP ();\n+\t  X_EQUALS_POP ();\n+\t  PUSH_RVALUE (\n+\t     /* cast of bool to int */\n+\t     ctxt.new_cast (\n+\t       /* (x < y) as a bool */\n+\t       ctxt.new_comparison (\n+\t\t GCC_JIT_COMPARISON_LT,\n+                 x, y,\n+                 loc),\n+\t       int_type,\n+               loc));\n+\t  break;\n+\n+\tcase RECURSE:\n+\t  {\n+\t    X_EQUALS_POP ();\n+\t    PUSH_RVALUE (\n+\t      ctxt.new_call (\n+\t\tfn,\n+\t\tx,\n+                loc));\n+\t    break;\n+\t  }\n+\n+\tcase RETURN:\n+\t  X_EQUALS_POP ();\n+\t  block.end_with_return (x, loc);\n+\t  break;\n+\n+\t  /* Ops taking an operand.  */\n+\tcase PUSH_CONST:\n+\t  PUSH_RVALUE (\n+\t    ctxt.new_rvalue (int_type, op->op_operand));\n+\t  break;\n+\n+\tcase JUMP_ABS_IF_TRUE:\n+\t  X_EQUALS_POP ();\n+\t  block.end_with_conditional (\n+\t    /* \"(bool)x\".  */\n+            ctxt.new_cast (x, bool_type, loc),\n+\t    op_blocks[op->op_operand], /* on_true */\n+\t    next_block, /* on_false */\n+            loc); \n+\t  break;\n+\n+\tdefault:\n+\t  assert(0);\n+\t} /* end of switch on opcode */\n+\n+      /* Go to the next block.  */\n+      if (op->op_opcode != JUMP_ABS_IF_TRUE\n+\t  && op->op_opcode != RETURN)\n+\tblock.end_with_jump (next_block, loc);\n+\n+    } /* end of loop on PC locations.  */\n+}\n+\n+gcc_jit_result *\n+compilation_state::compile ()\n+{\n+  return ctxt.compile ();\n+}\n+\n+char test[1024];\n+\n+#define CHECK_NON_NULL(PTR) \\\n+  do {                                       \\\n+    if ((PTR) != NULL)                       \\\n+      {                                      \\\n+\tpass (\"%s: %s is non-null\", test, #PTR); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                      \\\n+\tfail (\"%s: %s is NULL\", test, #PTR); \\\n+\tabort ();                            \\\n+    }                                        \\\n+  } while (0)\n+\n+#define CHECK_VALUE(ACTUAL, EXPECTED) \\\n+  do {                                       \\\n+    if ((ACTUAL) == (EXPECTED))              \\\n+      {                                      \\\n+\tpass (\"%s: actual: %s == expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+      }                                      \\\n+    else                                     \\\n+      {                                        \\\n+\tfail (\"%s: actual: %s != expected: %s\", test, #ACTUAL, #EXPECTED); \\\n+\tfprintf (stderr, \"incorrect value\\n\"); \\\n+\tabort ();                              \\\n+    }                                        \\\n+  } while (0)\n+\n+static void\n+test_script (const char *scripts_dir, const char *script_name, int input,\n+\t     int expected_result)\n+{\n+  char *script_path;\n+  toyvm_function *fn;\n+  int interpreted_result;\n+  toyvm_compiled_func code;\n+  int compiled_result;\n+\n+  snprintf (test, sizeof (test), \"toyvm.cc: %s\", script_name);\n+\n+  script_path = (char *)malloc (strlen (scripts_dir)\n+\t\t\t\t+ strlen (script_name) + 1);\n+  CHECK_NON_NULL (script_path);\n+  sprintf (script_path, \"%s%s\", scripts_dir, script_name);\n+\n+  fn = toyvm_function::parse (script_path, script_name);\n+  CHECK_NON_NULL (fn);\n+\n+  interpreted_result = fn->interpret (input, NULL);\n+  CHECK_VALUE (interpreted_result, expected_result);\n+\n+  code = fn->compile ();\n+  CHECK_NON_NULL (code);\n+\n+  compiled_result = code (input);\n+  CHECK_VALUE (compiled_result, expected_result);\n+\n+  free (script_path);\n+}\n+\n+#define PATH_TO_SCRIPTS  (\"/jit/docs/examples/tut04-toyvm/\")\n+\n+static void\n+test_suite (void)\n+{\n+  const char *srcdir;\n+  char *scripts_dir;\n+\n+  snprintf (test, sizeof (test), \"toyvm.cc\");\n+\n+  /* We need to locate the test scripts.\n+     Rely on \"srcdir\" being set in the environment.  */\n+\n+  srcdir = getenv (\"srcdir\");\n+  CHECK_NON_NULL (srcdir);\n+\n+  scripts_dir = (char *)malloc (strlen (srcdir) + strlen(PATH_TO_SCRIPTS)\n+\t\t\t\t+ 1);\n+  CHECK_NON_NULL (scripts_dir);\n+  sprintf (scripts_dir, \"%s%s\", srcdir, PATH_TO_SCRIPTS);\n+\n+  test_script (scripts_dir, \"factorial.toy\", 10, 3628800);\n+  test_script (scripts_dir, \"fibonacci.toy\", 10, 55);\n+\n+  free (scripts_dir);\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  const char *filename = NULL;\n+  toyvm_function *fn = NULL;\n+\n+  /* If called with no args, assume we're being run by the test suite.  */\n+  if (argc < 3)\n+    {\n+      test_suite ();\n+      return 0;\n+    }\n+\n+  if (argc != 3)\n+    {\n+      fprintf (stdout,\n+\t\"%s FILENAME INPUT: Parse and run a .toy file\\n\",\n+\targv[0]);\n+      exit (1);\n+    }\n+\n+  filename = argv[1];\n+  fn = toyvm_function::parse (filename, filename);\n+  if (!fn)\n+    exit (1);\n+\n+  if (0)\n+    fn->disassemble (stdout);\n+\n+  printf (\"interpreter result: %d\\n\",\n+\t  fn->interpret (atoi (argv[2]), NULL));\n+\n+  /* JIT-compilation.  */\n+  toyvm_compiled_func code = fn->compile ();\n+  printf (\"compiler result: %d\\n\",\n+\t  code (atoi (argv[2])));\n+\n+ return 0;\n+}"}, {"sha": "343279a38a488235372ff391769ef1443b519c81", "filename": "gcc/jit/docs/index.rst", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Findex.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Findex.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Findex.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -18,22 +18,30 @@\n libgccjit\n =========\n \n+This document describes `libgccjit <http://gcc.gnu.org/wiki/JIT>`_, an API\n+for embedding GCC inside programs and libraries.\n+\n+Note that libgccjit is currently of \"Alpha\" quality;\n+the APIs are not yet set in stone, and they shouldn't be used in\n+production yet.\n+\n+There are actually two APIs for the library:\n+\n+* a pure C API: ``libgccjit.h``\n+\n+* a C++ wrapper API: ``libgccjit++.h``.  This is a collection of \"thin\"\n+  wrapper classes around the C API, to save typing.\n+\n Contents:\n \n .. toctree::\n    :maxdepth: 2\n \n    intro/index.rst\n    topics/index.rst\n+   cp/index.rst\n    internals/index.rst\n \n-This document describes `libgccjit <http://gcc.gnu.org/wiki/JIT>`_, an API\n-for embedding GCC inside programs and libraries.\n-\n-Note that libgccjit is currently of \"Alpha\" quality;\n-the APIs are not yet set in stone, and they shouldn't be used in\n-production yet.\n-\n \n Indices and tables\n =================="}, {"sha": "626e7c8c7cc1cf06cab831abb230968c333d112a", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29df5715c0a1817ba3ad76dd3e10c7fb6e235254/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=29df5715c0a1817ba3ad76dd3e10c7fb6e235254", "patch": "@@ -89,7 +89,7 @@ cleanup of such objects is done for you when the context is released.\n \n Thread-safety\n -------------\n-Instances of :c:type:`gcc_jit_object *` created via\n+Instances of :c:type:`gcc_jit_context *` created via\n :c:func:`gcc_jit_context_acquire` are independent from each other:\n only one thread may use a given context at once, but multiple threads\n could each have their own contexts without needing locks."}]}