{"sha": "2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmY1YzdmNDUyMjVmODI2ZDQzMGEyNWQ0YTU0ZTllMTk5NjdkM2E3Yw==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-08-12T22:45:05Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-08-12T22:45:05Z"}, "message": "tree.h (DECL_OFFSET_ALIGN): Make the off_align field of the tree structure an exponent rather than an...\n\n* tree.h (DECL_OFFSET_ALIGN): Make the off_align field of\nthe tree structure an exponent rather than an explicit alignment\nso it doesn't overflow.\n(SET_DECL_OFFSET_ALIGN): New macro.\n* stor-layout.c (place_union_field): Use SET_DECL_OFFSET_ALIGN\nrather than DECL_OFFSET_ALIGN.\n(place_field): Likewise.\n* expmed.c (store_bit_field): Abort on align==0 to avoid\nantisocial machine behaviour.\n\nFrom-SVN: r35659", "tree": {"sha": "fa69ec89bc345170fcb966cb78d9c60d962957d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa69ec89bc345170fcb966cb78d9c60d962957d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/comments", "author": null, "committer": null, "parents": [{"sha": "808d8c417114a8df27fbc149f162e56f174783ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/808d8c417114a8df27fbc149f162e56f174783ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/808d8c417114a8df27fbc149f162e56f174783ac"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "cc284f2e39e676749ffc6385d808d81e65672aff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "patch": "@@ -1,3 +1,15 @@\n+2000-05-13  Geoffrey Keating  <geoffk@cygnus.com>\n+\n+\t* tree.h (DECL_OFFSET_ALIGN): Make the off_align field of\n+\tthe tree structure an exponent rather than an explicit alignment\n+\tso it doesn't overflow.\n+\t(SET_DECL_OFFSET_ALIGN): New macro.\n+\t* stor-layout.c (place_union_field): Use SET_DECL_OFFSET_ALIGN\n+\trather than DECL_OFFSET_ALIGN.\n+\t(place_field): Likewise.\n+\t* expmed.c (store_bit_field): Abort on align==0 to avoid\n+\tantisocial machine behaviour.\n+\n 2000-08-12  Richard Henderson  <rth@cygnus.com>\n \n \t* sibcall.c (uses_addressof): Accept both addressof and"}, {"sha": "606333fdbe3d3507615876b16deb98fefb831125", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "patch": "@@ -245,6 +245,11 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n   insv_bitsize = GET_MODE_BITSIZE (op_mode);\n #endif\n \n+  /* It is wrong to have align==0, since every object is aligned at\n+     least at a bit boundary.  This usually means a bug elsewhere.  */\n+  if (align == 0)\n+    abort ();\n+\n   /* Discount the part of the structure before the desired byte.\n      We need to know how many bytes are safe to reference after it.  */\n   if (total_size >= 0)"}, {"sha": "159e2a8551f193b134ea64166d8865cb82410fd4", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "patch": "@@ -584,7 +584,7 @@ place_union_field (rli, field)\n   \n   DECL_FIELD_OFFSET (field) = size_zero_node;\n   DECL_FIELD_BIT_OFFSET (field) = bitsize_zero_node;\n-  DECL_OFFSET_ALIGN (field) = BIGGEST_ALIGNMENT;\n+  SET_DECL_OFFSET_ALIGN (field, BIGGEST_ALIGNMENT);\n \n   desired_align = DECL_ALIGN (field);\n \n@@ -859,7 +859,7 @@ place_field (rli, field)\n   normalize_rli (rli);\n   DECL_FIELD_OFFSET (field) = rli->offset;\n   DECL_FIELD_BIT_OFFSET (field) = rli->bitpos;\n-  DECL_OFFSET_ALIGN (field) = rli->offset_align;\n+  SET_DECL_OFFSET_ALIGN (field, rli->offset_align);\n \n   /* If this field ended up more aligned than we thought it would be (we\n      approximate this by seeing if its position changed), lay out the field"}, {"sha": "e428a8a38649699f3a25e7ad40deb279113b5987", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f5c7f45225f826d430a25d4a54e9e19967d3a7c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2f5c7f45225f826d430a25d4a54e9e19967d3a7c", "patch": "@@ -1308,8 +1308,15 @@ struct tree_type\n #define DECL_SIZE_UNIT(NODE) (DECL_CHECK (NODE)->decl.size_unit)\n /* Holds the alignment required for the datum.  */\n #define DECL_ALIGN(NODE) (DECL_CHECK (NODE)->decl.u1.a.align)\n-/* For FIELD_DECLs, holds the alignment that DECL_FIELD_OFFSET has.  */\n-#define DECL_OFFSET_ALIGN(NODE) (FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align)\n+/* For FIELD_DECLs, off_align holds the number of low-order bits of\n+   DECL_FIELD_OFFSET which are known to be always zero.\n+   DECL_OFFSET_ALIGN thus returns the alignment that DECL_FIELD_OFFSET\n+   has.  */\n+#define DECL_OFFSET_ALIGN(NODE) \\\n+  (((unsigned HOST_WIDE_INT)1) << FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align)\n+/* Specify that DECL_ALIGN(NODE) is a multiple of X.  */\n+#define SET_DECL_OFFSET_ALIGN(NODE, X) \\\n+  (FIELD_DECL_CHECK (NODE)->decl.u1.a.off_align\t= exact_log2 ((X) & -(X)))\n /* 1 if the alignment for this type was requested by \"aligned\" attribute,\n    0 if it is the default for this type.  */\n #define DECL_USER_ALIGN(NODE) (DECL_CHECK (NODE)->decl.user_align)"}]}