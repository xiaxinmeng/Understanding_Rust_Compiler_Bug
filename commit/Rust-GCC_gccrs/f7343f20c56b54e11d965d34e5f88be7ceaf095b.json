{"sha": "f7343f20c56b54e11d965d34e5f88be7ceaf095b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjczNDNmMjBjNTZiNTRlMTFkOTY1ZDM0ZTVmODhiZTdjZWFmMDk1Yg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-01-16T15:18:05Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-01-16T15:18:05Z"}, "message": "__builtin_<add/sub>_overflow issues on AArch64 (redux)\n\nFurther investigation showed that my previous patch for this issue was\nstill incomplete.\n\nThe problem stemmed from what I suspect was a mis-understanding of the\nway overflow is calculated on aarch64 when values are subtracted (and\nhence in comparisons).  In this case, unlike addition, the carry flag\nis /cleared/ if there is overflow (technically, underflow) and set\nwhen that does not happen.  This patch clears up this issue by using\nCCmode for all subtractive operations (this can fully describe the\nnormal overflow conditions without anything particularly fancy);\nclears up the way we express normal unsigned overflow using CC_Cmode\n(the result of a sum is less than one of the operands) and adds a new\nmode, CC_ADCmode to handle expressing overflow of an add-with-carry\noperation, where the standard idiom is no-longer sufficient to\ndescribe the overflow condition.\n\n\tPR target/86891\n\t* config/aarch64/aarch64-modes.def: Add comment about how the carry\n\tbit is set by add and compare.\n\t(CC_ADC): New CC_MODE.\n\t* config/aarch64/aarch64.c (aarch64_select_cc_mode): Use variables\n\tto cache the code and mode of X.  Adjust the shape of a CC_Cmode\n\tcomparison.  Add detection for CC_ADCmode.\n\t(aarch64_get_condition_code_1): Update code support for CC_Cmode.  Add\n\tCC_ADCmode.\n\t* config/aarch64/aarch64.md (uaddv<mode>4): Use LTU with CCmode.\n\t(uaddvti4): Comparison result is in CC_ADCmode and the condition is GEU.\n\t(add<mode>3_compareC_cconly_imm): Delete.  Merge into...\n\t(add<mode>3_compareC_cconly): ... this.  Restructure the comparison\n\tto eliminate the need for zero-extending the operands.\n\t(add<mode>3_compareC_imm): Delete.  Merge into ...\n\t(add<mode>3_compareC): ... this.  Restructure the comparison to\n\teliminate the need for zero-extending the operands.\n\t(add<mode>3_carryin): Use LTU for the overflow detection.\n\t(add<mode>3_carryinC): Use CC_ADCmode for the result of the carry out.\n\tReexpress comparison for overflow.\n\t(add<mode>3_carryinC_zero): Update for change to add<mode>3_carryinC.\n\t(add<mode>3_carryinC): Likewise.\n\t(add<mode>3_carryinV): Use LTU for carry between partials.\n\t* config/aarch64/predicates.md (aarch64_carry_operation): Update\n\thandling of CC_Cmode and add CC_ADCmode.\n\t(aarch64_borrow_operation): Likewise.\n\nFrom-SVN: r267971", "tree": {"sha": "2785ce519759fd3b5a125bedc0c626edbf82ba4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2785ce519759fd3b5a125bedc0c626edbf82ba4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7343f20c56b54e11d965d34e5f88be7ceaf095b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7343f20c56b54e11d965d34e5f88be7ceaf095b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7343f20c56b54e11d965d34e5f88be7ceaf095b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7343f20c56b54e11d965d34e5f88be7ceaf095b/comments", "author": null, "committer": null, "parents": [{"sha": "e964d9b23ad7dc4878294d0119e676c43e1f1ea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e964d9b23ad7dc4878294d0119e676c43e1f1ea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e964d9b23ad7dc4878294d0119e676c43e1f1ea4"}], "stats": {"total": 239, "additions": 126, "deletions": 113}, "files": [{"sha": "14c1a43fe8b10e22f07f15c87ccad2783a003177", "filename": "gcc/config/aarch64/aarch64-modes.def", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-modes.def?ref=f7343f20c56b54e11d965d34e5f88be7ceaf095b", "patch": "@@ -18,12 +18,25 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* Important note about Carry generation in AArch64.\n+\n+   Unlike some architectures, the C flag generated by a subtract\n+   operation, or a simple compare operation is set to 1 if the result\n+   does not overflow in an unsigned sense.  That is, if there is no\n+   borrow needed from a higher word.  That means that overflow from\n+   addition will set C, but overflow from a subtraction will clear C.\n+   We use CC_Cmode to represent detection of overflow from addition as\n+   CCmode is used for 'normal' compare (subtraction) operations.  For\n+   ADC, the representation becomes more complex still, since we cannot\n+   use the normal idiom of comparing the result to one of the input\n+   operands; instead we use CC_ADCmode to represent this case.  */\n CC_MODE (CCFP);\n CC_MODE (CCFPE);\n CC_MODE (CC_SWP);\n CC_MODE (CC_NZ);    /* Only N and Z bits of condition flags are valid.  */\n CC_MODE (CC_Z);     /* Only Z bit of condition flags is valid.  */\n-CC_MODE (CC_C);     /* Only C bit of condition flags is valid.  */\n+CC_MODE (CC_C);     /* C represents unsigned overflow of a simple addition.  */\n+CC_MODE (CC_ADC);   /* Unsigned overflow from an ADC (add with carry).  */\n CC_MODE (CC_V);     /* Only V bit of condition flags is valid.  */\n \n /* Half-precision floating point for __fp16.  */"}, {"sha": "da48c0969dc31d96a3c1b639babd65622929e321", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=f7343f20c56b54e11d965d34e5f88be7ceaf095b", "patch": "@@ -7089,9 +7089,12 @@ aarch64_emit_call_insn (rtx pat)\n machine_mode\n aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n {\n+  machine_mode mode_x = GET_MODE (x);\n+  rtx_code code_x = GET_CODE (x);\n+\n   /* All floating point compares return CCFP if it is an equality\n      comparison, and CCFPE otherwise.  */\n-  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+  if (GET_MODE_CLASS (mode_x) == MODE_FLOAT)\n     {\n       switch (code)\n \t{\n@@ -7122,55 +7125,65 @@ aarch64_select_cc_mode (RTX_CODE code, rtx x, rtx y)\n      using the TST instruction with the appropriate bitmask.  */\n   if (y == const0_rtx && REG_P (x)\n       && (code == EQ || code == NE)\n-      && (GET_MODE (x) == HImode || GET_MODE (x) == QImode))\n+      && (mode_x == HImode || mode_x == QImode))\n     return CC_NZmode;\n \n   /* Similarly, comparisons of zero_extends from shorter modes can\n      be performed using an ANDS with an immediate mask.  */\n-  if (y == const0_rtx && GET_CODE (x) == ZERO_EXTEND\n-      && (GET_MODE (x) == SImode || GET_MODE (x) == DImode)\n+  if (y == const0_rtx && code_x == ZERO_EXTEND\n+      && (mode_x == SImode || mode_x == DImode)\n       && (GET_MODE (XEXP (x, 0)) == HImode || GET_MODE (XEXP (x, 0)) == QImode)\n       && (code == EQ || code == NE))\n     return CC_NZmode;\n \n-  if ((GET_MODE (x) == SImode || GET_MODE (x) == DImode)\n+  if ((mode_x == SImode || mode_x == DImode)\n       && y == const0_rtx\n       && (code == EQ || code == NE || code == LT || code == GE)\n-      && (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS || GET_CODE (x) == AND\n-\t  || GET_CODE (x) == NEG\n-\t  || (GET_CODE (x) == ZERO_EXTRACT && CONST_INT_P (XEXP (x, 1))\n+      && (code_x == PLUS || code_x == MINUS || code_x == AND\n+\t  || code_x == NEG\n+\t  || (code_x == ZERO_EXTRACT && CONST_INT_P (XEXP (x, 1))\n \t      && CONST_INT_P (XEXP (x, 2)))))\n     return CC_NZmode;\n \n   /* A compare with a shifted operand.  Because of canonicalization,\n      the comparison will have to be swapped when we emit the assembly\n      code.  */\n-  if ((GET_MODE (x) == SImode || GET_MODE (x) == DImode)\n+  if ((mode_x == SImode || mode_x == DImode)\n       && (REG_P (y) || GET_CODE (y) == SUBREG || y == const0_rtx)\n-      && (GET_CODE (x) == ASHIFT || GET_CODE (x) == ASHIFTRT\n-\t  || GET_CODE (x) == LSHIFTRT\n-\t  || GET_CODE (x) == ZERO_EXTEND || GET_CODE (x) == SIGN_EXTEND))\n+      && (code_x == ASHIFT || code_x == ASHIFTRT\n+\t  || code_x == LSHIFTRT\n+\t  || code_x == ZERO_EXTEND || code_x == SIGN_EXTEND))\n     return CC_SWPmode;\n \n   /* Similarly for a negated operand, but we can only do this for\n      equalities.  */\n-  if ((GET_MODE (x) == SImode || GET_MODE (x) == DImode)\n+  if ((mode_x == SImode || mode_x == DImode)\n       && (REG_P (y) || GET_CODE (y) == SUBREG)\n       && (code == EQ || code == NE)\n-      && GET_CODE (x) == NEG)\n+      && code_x == NEG)\n     return CC_Zmode;\n \n-  /* A test for unsigned overflow.  */\n-  if ((GET_MODE (x) == DImode || GET_MODE (x) == TImode)\n-      && code == NE\n-      && GET_CODE (x) == PLUS\n-      && GET_CODE (y) == ZERO_EXTEND)\n+  /* A test for unsigned overflow from an addition.  */\n+  if ((mode_x == DImode || mode_x == TImode)\n+      && (code == LTU || code == GEU)\n+      && code_x == PLUS\n+      && rtx_equal_p (XEXP (x, 0), y))\n     return CC_Cmode;\n \n+  /* A test for unsigned overflow from an add with carry.  */\n+  if ((mode_x == DImode || mode_x == TImode)\n+      && (code == LTU || code == GEU)\n+      && code_x == PLUS\n+      && CONST_SCALAR_INT_P (y)\n+      && (rtx_mode_t (y, mode_x)\n+\t  == (wi::shwi (1, mode_x)\n+\t      << (GET_MODE_BITSIZE (mode_x).to_constant () / 2))))\n+    return CC_ADCmode;\n+\n   /* A test for signed overflow.  */\n-  if ((GET_MODE (x) == DImode || GET_MODE (x) == TImode)\n+  if ((mode_x == DImode || mode_x == TImode)\n       && code == NE\n-      && GET_CODE (x) == PLUS\n+      && code_x == PLUS\n       && GET_CODE (y) == SIGN_EXTEND)\n     return CC_Vmode;\n \n@@ -7274,8 +7287,17 @@ aarch64_get_condition_code_1 (machine_mode mode, enum rtx_code comp_code)\n     case E_CC_Cmode:\n       switch (comp_code)\n \t{\n-\tcase NE: return AARCH64_CS;\n-\tcase EQ: return AARCH64_CC;\n+\tcase LTU: return AARCH64_CS;\n+\tcase GEU: return AARCH64_CC;\n+\tdefault: return -1;\n+\t}\n+      break;\n+\n+    case E_CC_ADCmode:\n+      switch (comp_code)\n+\t{\n+\tcase GEU: return AARCH64_CS;\n+\tcase LTU: return AARCH64_CC;\n \tdefault: return -1;\n \t}\n       break;"}, {"sha": "e65936a2cb92ef8453b62cef268c90190a67185c", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 47, "deletions": 83, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=f7343f20c56b54e11d965d34e5f88be7ceaf095b", "patch": "@@ -1871,7 +1871,7 @@\n   \"\"\n {\n   emit_insn (gen_add<mode>3_compareC (operands[0], operands[1], operands[2]));\n-  aarch64_gen_unlikely_cbranch (NE, CC_Cmode, operands[3]);\n+  aarch64_gen_unlikely_cbranch (LTU, CC_Cmode, operands[3]);\n \n   DONE;\n })\n@@ -1973,7 +1973,7 @@\n   emit_move_insn (gen_lowpart (DImode, operands[0]), low_dest);\n   emit_move_insn (gen_highpart (DImode, operands[0]), high_dest);\n \n-  aarch64_gen_unlikely_cbranch (NE, CC_Cmode, operands[3]);\n+  aarch64_gen_unlikely_cbranch (GEU, CC_ADCmode, operands[3]);\n   DONE;\n  })\n \n@@ -2010,69 +2010,36 @@\n   [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n-(define_insn \"*add<mode>3_compareC_cconly_imm\"\n-  [(set (reg:CC_C CC_REGNUM)\n-\t(ne:CC_C\n-\t  (plus:<DWI>\n-\t    (zero_extend:<DWI> (match_operand:GPI 0 \"register_operand\" \"r,r\"))\n-\t    (match_operand:<DWI> 2 \"const_scalar_int_operand\" \"\"))\n-\t  (zero_extend:<DWI>\n-\t    (plus:GPI\n-\t      (match_dup 0)\n-\t      (match_operand:GPI 1 \"aarch64_plus_immediate\" \"I,J\")))))]\n-  \"aarch64_zero_extend_const_eq (<DWI>mode, operands[2],\n-\t\t\t\t <MODE>mode, operands[1])\"\n-  \"@\n-  cmn\\\\t%<w>0, %1\n-  cmp\\\\t%<w>0, #%n1\"\n-  [(set_attr \"type\" \"alus_imm\")]\n-)\n-\n (define_insn \"*add<mode>3_compareC_cconly\"\n   [(set (reg:CC_C CC_REGNUM)\n-\t(ne:CC_C\n-\t  (plus:<DWI>\n-\t    (zero_extend:<DWI> (match_operand:GPI 0 \"register_operand\" \"r\"))\n-\t    (zero_extend:<DWI> (match_operand:GPI 1 \"register_operand\" \"r\")))\n-\t  (zero_extend:<DWI> (plus:GPI (match_dup 0) (match_dup 1)))))]\n+\t(compare:CC_C\n+\t  (plus:GPI\n+\t    (match_operand:GPI 0 \"register_operand\" \"r,r,r\")\n+\t    (match_operand:GPI 1 \"aarch64_plus_operand\" \"r,I,J\"))\n+\t  (match_dup 0)))]\n   \"\"\n-  \"cmn\\\\t%<w>0, %<w>1\"\n-  [(set_attr \"type\" \"alus_sreg\")]\n-)\n-\n-(define_insn \"*add<mode>3_compareC_imm\"\n-  [(set (reg:CC_C CC_REGNUM)\n-\t(ne:CC_C\n-\t  (plus:<DWI>\n-\t    (zero_extend:<DWI> (match_operand:GPI 1 \"register_operand\" \"r,r\"))\n-\t    (match_operand:<DWI> 3 \"const_scalar_int_operand\" \"\"))\n-\t  (zero_extend:<DWI>\n-\t    (plus:GPI\n-\t      (match_dup 1)\n-\t      (match_operand:GPI 2 \"aarch64_plus_immediate\" \"I,J\")))))\n-   (set (match_operand:GPI 0 \"register_operand\" \"=r,r\")\n-\t(plus:GPI (match_dup 1) (match_dup 2)))]\n-  \"aarch64_zero_extend_const_eq (<DWI>mode, operands[3],\n-                                 <MODE>mode, operands[2])\"\n   \"@\n-  adds\\\\t%<w>0, %<w>1, %2\n-  subs\\\\t%<w>0, %<w>1, #%n2\"\n-  [(set_attr \"type\" \"alus_imm\")]\n+  cmn\\\\t%<w>0, %<w>1\n+  cmn\\\\t%<w>0, %1\n+  cmp\\\\t%<w>0, #%n1\"\n+  [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n (define_insn \"add<mode>3_compareC\"\n   [(set (reg:CC_C CC_REGNUM)\n \t(compare:CC_C\n-\t  (plus:<DWI>\n-\t    (zero_extend:<DWI> (match_operand:GPI 1 \"register_operand\" \"r\"))\n-\t    (zero_extend:<DWI> (match_operand:GPI 2 \"register_operand\" \"r\")))\n-\t  (zero_extend:<DWI>\n-\t    (plus:GPI (match_dup 1) (match_dup 2)))))\n-   (set (match_operand:GPI 0 \"register_operand\" \"=r\")\n+\t  (plus:GPI\n+\t    (match_operand:GPI 1 \"register_operand\" \"r,r,r\")\n+\t    (match_operand:GPI 2 \"aarch64_plus_operand\" \"r,I,J\"))\n+\t  (match_dup 1)))\n+   (set (match_operand:GPI 0 \"register_operand\" \"=r,r,r\")\n \t(plus:GPI (match_dup 1) (match_dup 2)))]\n   \"\"\n-  \"adds\\\\t%<w>0, %<w>1, %<w>2\"\n-  [(set_attr \"type\" \"alus_sreg\")]\n+  \"@\n+  adds\\\\t%<w>0, %<w>1, %<w>2\n+  adds\\\\t%<w>0, %<w>1, %2\n+  subs\\\\t%<w>0, %<w>1, #%n2\"\n+  [(set_attr \"type\" \"alus_sreg,alus_imm,alus_imm\")]\n )\n \n (define_insn \"*add<mode>3_compareV_cconly_imm\"\n@@ -2470,7 +2437,7 @@\n   [(set (match_operand:GPI 0 \"register_operand\")\n \t(plus:GPI\n \t  (plus:GPI\n-\t    (ne:GPI (reg:CC_C CC_REGNUM) (const_int 0))\n+\t    (ltu:GPI (reg:CC_C CC_REGNUM) (const_int 0))\n \t    (match_operand:GPI 1 \"aarch64_reg_or_zero\"))\n \t  (match_operand:GPI 2 \"aarch64_reg_or_zero\")))]\n    \"\"\n@@ -2509,65 +2476,62 @@\n (define_expand \"add<mode>3_carryinC\"\n   [(parallel\n      [(set (match_dup 3)\n-\t   (compare:CC_C\n+\t   (compare:CC_ADC\n \t     (plus:<DWI>\n \t       (plus:<DWI>\n \t\t (match_dup 4)\n \t\t (zero_extend:<DWI>\n \t\t   (match_operand:GPI 1 \"register_operand\" \"\")))\n \t       (zero_extend:<DWI>\n \t\t (match_operand:GPI 2 \"register_operand\" \"\")))\n-\t   (zero_extend:<DWI>\n-\t     (plus:GPI\n-\t       (plus:GPI (match_dup 5) (match_dup 1))\n-\t       (match_dup 2)))))\n+\t     (match_dup 6)))\n       (set (match_operand:GPI 0 \"register_operand\")\n \t   (plus:GPI\n \t     (plus:GPI (match_dup 5) (match_dup 1))\n \t     (match_dup 2)))])]\n    \"\"\n {\n-  operands[3] = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n-  operands[4] = gen_rtx_NE (<DWI>mode, operands[3], const0_rtx);\n-  operands[5] = gen_rtx_NE (<MODE>mode, operands[3], const0_rtx);\n+  operands[3] = gen_rtx_REG (CC_ADCmode, CC_REGNUM);\n+  rtx ccin = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+  operands[4] = gen_rtx_LTU (<DWI>mode, ccin, const0_rtx);\n+  operands[5] = gen_rtx_LTU (<MODE>mode, ccin, const0_rtx);\n+  operands[6] = immed_wide_int_const (wi::shwi (1, <DWI>mode)\n+\t\t\t\t      << GET_MODE_BITSIZE (<MODE>mode),\n+\t\t\t\t      TImode);\n })\n \n (define_insn \"*add<mode>3_carryinC_zero\"\n-  [(set (reg:CC_C CC_REGNUM)\n-\t(compare:CC_C\n+  [(set (reg:CC_ADC CC_REGNUM)\n+\t(compare:CC_ADC\n \t  (plus:<DWI>\n \t    (match_operand:<DWI> 2 \"aarch64_carry_operation\" \"\")\n \t    (zero_extend:<DWI> (match_operand:GPI 1 \"register_operand\" \"r\")))\n-\t  (zero_extend:<DWI>\n-\t    (plus:GPI\n-\t      (match_operand:GPI 3 \"aarch64_carry_operation\" \"\")\n-\t      (match_dup 1)))))\n+\t  (match_operand 4 \"const_scalar_int_operand\" \"\")))\n    (set (match_operand:GPI 0 \"register_operand\" \"=r\")\n-\t(plus:GPI (match_dup 3) (match_dup 1)))]\n-   \"\"\n+\t(plus:GPI (match_operand:GPI 3 \"aarch64_carry_operation\" \"\")\n+\t\t  (match_dup 1)))]\n+  \"rtx_mode_t (operands[4], <DWI>mode)\n+   == (wi::shwi (1, <DWI>mode) << (unsigned) GET_MODE_BITSIZE (<MODE>mode))\"\n    \"adcs\\\\t%<w>0, %<w>1, <w>zr\"\n   [(set_attr \"type\" \"adc_reg\")]\n )\n \n (define_insn \"*add<mode>3_carryinC\"\n-  [(set (reg:CC_C CC_REGNUM)\n-\t(compare:CC_C\n+  [(set (reg:CC_ADC CC_REGNUM)\n+\t(compare:CC_ADC\n \t  (plus:<DWI>\n \t    (plus:<DWI>\n \t      (match_operand:<DWI> 3 \"aarch64_carry_operation\" \"\")\n \t      (zero_extend:<DWI> (match_operand:GPI 1 \"register_operand\" \"r\")))\n \t    (zero_extend:<DWI> (match_operand:GPI 2 \"register_operand\" \"r\")))\n-\t  (zero_extend:<DWI>\n-\t    (plus:GPI\n-\t      (plus:GPI\n-\t\t(match_operand:GPI 4 \"aarch64_carry_operation\" \"\")\n-\t\t(match_dup 1))\n-\t      (match_dup 2)))))\n+\t  (match_operand 5 \"const_scalar_int_operand\" \"\")))\n    (set (match_operand:GPI 0 \"register_operand\" \"=r\")\n \t(plus:GPI\n-\t  (plus:GPI (match_dup 4) (match_dup 1))\n+\t  (plus:GPI (match_operand:GPI 4 \"aarch64_carry_operation\" \"\")\n+\t\t    (match_dup 1))\n \t  (match_dup 2)))]\n-   \"\"\n+  \"rtx_mode_t (operands[5], <DWI>mode)\n+   == (wi::shwi (1, <DWI>mode) << (unsigned) GET_MODE_BITSIZE (<MODE>mode))\"\n    \"adcs\\\\t%<w>0, %<w>1, %<w>2\"\n   [(set_attr \"type\" \"adc_reg\")]\n )\n@@ -2594,8 +2558,8 @@\n    \"\"\n {\n   rtx cc = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n-  operands[3] = gen_rtx_NE (<DWI>mode, cc, const0_rtx);\n-  operands[4] = gen_rtx_NE (<MODE>mode, cc, const0_rtx);\n+  operands[3] = gen_rtx_LTU (<DWI>mode, cc, const0_rtx);\n+  operands[4] = gen_rtx_LTU (<MODE>mode, cc, const0_rtx);\n })\n \n (define_insn \"*add<mode>3_carryinV_zero\""}, {"sha": "855cf7b52f840a81e0bbd2b31fd59fc860060626", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7343f20c56b54e11d965d34e5f88be7ceaf095b/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=f7343f20c56b54e11d965d34e5f88be7ceaf095b", "patch": "@@ -347,23 +347,37 @@\n   (match_code \"eq,ne\"))\n \n (define_special_predicate \"aarch64_carry_operation\"\n-  (match_code \"ne,geu\")\n+  (match_code \"ltu,geu\")\n {\n   if (XEXP (op, 1) != const0_rtx)\n     return false;\n-  machine_mode ccmode = (GET_CODE (op) == NE ? CC_Cmode : CCmode);\n   rtx op0 = XEXP (op, 0);\n-  return REG_P (op0) && REGNO (op0) == CC_REGNUM && GET_MODE (op0) == ccmode;\n+  if (!REG_P (op0) || REGNO (op0) != CC_REGNUM)\n+    return false;\n+  machine_mode ccmode = GET_MODE (op0);\n+  if (ccmode == CC_Cmode)\n+    return GET_CODE (op) == LTU;\n+  if (ccmode == CC_ADCmode || ccmode == CCmode)\n+    return GET_CODE (op) == GEU;\n+  return false;\n })\n \n+; borrow is essentially the inverse of carry since the sense of the C flag\n+; is inverted during subtraction.  See the note in aarch64-modes.def.\n (define_special_predicate \"aarch64_borrow_operation\"\n-  (match_code \"eq,ltu\")\n+  (match_code \"geu,ltu\")\n {\n   if (XEXP (op, 1) != const0_rtx)\n     return false;\n-  machine_mode ccmode = (GET_CODE (op) == EQ ? CC_Cmode : CCmode);\n   rtx op0 = XEXP (op, 0);\n-  return REG_P (op0) && REGNO (op0) == CC_REGNUM && GET_MODE (op0) == ccmode;\n+  if (!REG_P (op0) || REGNO (op0) != CC_REGNUM)\n+    return false;\n+  machine_mode ccmode = GET_MODE (op0);\n+  if (ccmode == CC_Cmode)\n+    return GET_CODE (op) == GEU;\n+  if (ccmode == CC_ADCmode || ccmode == CCmode)\n+    return GET_CODE (op) == LTU;\n+  return false;\n })\n \n ;; True if the operand is memory reference suitable for a load/store exclusive."}]}