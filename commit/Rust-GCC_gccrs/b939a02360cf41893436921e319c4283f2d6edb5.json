{"sha": "b939a02360cf41893436921e319c4283f2d6edb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkzOWEwMjM2MGNmNDE4OTM0MzY5MjFlMzE5YzQyODNmMmQ2ZWRiNQ==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-10-20T16:20:50Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-10-20T16:20:50Z"}, "message": "re PR c++/13495 (Friendship to class nested within a template is broken)\n\n\tPR c++/13495\n\t* decl.c (make_unbound_class_template): Add PARM_LIST parameter.\n\t* cp-tree.h (make_unbound_class_template): Adjust prototype.\n\t* parser.c (cp_parser_lookup_name): Adjust call to\n\tmake_unbound_class_template.\n\t(cp_parser_single_declaration): Handle member class of class\n\ttemplate as template friend parsing correctly.\n\t* friend.c (is_friend): Call is_specialization_of_friend for\n\ttemplate friend class.\n\t(make_friend_class): Handle member class of class template as\n\ttemplate friend.\n\t* pt.c (is_specialization_of_friend): Likewise.\n\t(instantiate_class_template): Likewise.\n\t(tsubst): Adjust call to make_unbound_class_template.\n\n\t* g++.dg/template/memfriend9.C: New test.\n\t* g++.dg/template/memfriend10.C: Likewise.\n\t* g++.dg/template/memfriend11.C: Likewise.\n\t* g++.dg/template/memfriend12.C: Likewise.\n\t* g++.dg/template/memfriend13.C: Likewise.\n\t* g++.dg/template/memfriend14.C: Likewise.\n\t* g++.dg/template/memfriend15.C: Likewise.\n\t* g++.dg/template/memfriend16.C: Likewise.\n\t* g++.dg/template/memfriend17.C: Likewise.\n\t* g++.old-deja/g++.pt/friend44.C: Remove bogus error.\n\nFrom-SVN: r89335", "tree": {"sha": "36d5919ab016d6c55b8dee09fb15a76c348df75e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36d5919ab016d6c55b8dee09fb15a76c348df75e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b939a02360cf41893436921e319c4283f2d6edb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b939a02360cf41893436921e319c4283f2d6edb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b939a02360cf41893436921e319c4283f2d6edb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b939a02360cf41893436921e319c4283f2d6edb5/comments", "author": null, "committer": null, "parents": [{"sha": "23517e6b4ea01d0af35984f8473a235a29ff93c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23517e6b4ea01d0af35984f8473a235a29ff93c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23517e6b4ea01d0af35984f8473a235a29ff93c7"}], "stats": {"total": 847, "additions": 797, "deletions": 50}, "files": [{"sha": "a90cc61f575fc53c7ce077bdc1ba73229d32be42", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -1,3 +1,20 @@\n+2004-10-20  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/13495\n+\t* decl.c (make_unbound_class_template): Add PARM_LIST parameter.\n+\t* cp-tree.h (make_unbound_class_template): Adjust prototype.\n+\t* parser.c (cp_parser_lookup_name): Adjust call to\n+\tmake_unbound_class_template.\n+\t(cp_parser_single_declaration): Handle member class of class\n+\ttemplate as template friend parsing correctly.\n+\t* friend.c (is_friend): Call is_specialization_of_friend for\n+\ttemplate friend class.\n+\t(make_friend_class): Handle member class of class template as\n+\ttemplate friend.\n+\t* pt.c (is_specialization_of_friend): Likewise.\n+\t(instantiate_class_template): Likewise.\n+\t(tsubst): Adjust call to make_unbound_class_template.\n+\n 2004-10-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* typeck.c (composite_pointer_type): Add comment about DR 195"}, {"sha": "0f75fce38124836eaa90dd60b39a5c7cb10db579", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -3689,7 +3689,7 @@ extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);\n extern void define_case_label\t\t\t(void);\n extern tree make_typename_type\t\t\t(tree, tree, tsubst_flags_t);\n-extern tree make_unbound_class_template\t\t(tree, tree, tsubst_flags_t);\n+extern tree make_unbound_class_template\t\t(tree, tree, tree, tsubst_flags_t);\n extern tree check_for_out_of_scope_variable     (tree);\n extern tree build_library_fn\t\t\t(tree, tree);\n extern tree build_library_fn_ptr\t\t(const char *, tree);"}, {"sha": "21ffb519e8254f5e27d2929662f8c7469ba82864", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -2730,14 +2730,18 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n   return build_typename_type (context, name, fullname);\n }\n \n-/* Resolve `CONTEXT::template NAME'.  Returns an appropriate type,\n-   unless an error occurs, in which case error_mark_node is returned.\n-   If we locate a TYPE_DECL, we return that, rather than the _TYPE it\n-   corresponds to.  If COMPLAIN zero, don't complain about any errors\n-   that occur.  */\n+/* Resolve `CONTEXT::template NAME'.  Returns a TEMPLATE_DECL if the name\n+   can be resolved or an UNBOUND_CLASS_TEMPLATE, unless an error occurs, \n+   in which case error_mark_node is returned.\n+\n+   If PARM_LIST is non-NULL, also make sure that the template parameter\n+   list of TEMPLATE_DECL matches.\n+\n+   If COMPLAIN zero, don't complain about any errors that occur.  */\n \n tree\n-make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n+make_unbound_class_template (tree context, tree name, tree parm_list,\n+\t\t\t     tsubst_flags_t complain)\n {\n   tree t;\n   tree d;\n@@ -2763,6 +2767,17 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n \t  return error_mark_node;\n \t}\n \n+      if (parm_list\n+\t  && !comp_template_parms (DECL_TEMPLATE_PARMS (tmpl), parm_list))\n+\t{\n+\t  if (complain & tf_error)\n+\t    {\n+\t      error (\"template parameters do not match template\");\n+\t      cp_error_at (\"%qD declared here\", tmpl);\n+\t    }\n+\t  return error_mark_node;\n+\t}\n+\n       if (complain & tf_error)\n \tperform_or_defer_access_check (TYPE_BINFO (context), tmpl);\n \n@@ -2780,6 +2795,7 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n   TYPE_STUB_DECL (TREE_TYPE (d)) = d;\n   DECL_CONTEXT (d) = FROB_CONTEXT (context);\n   DECL_ARTIFICIAL (d) = 1;\n+  DECL_TEMPLATE_PARMS (d) = parm_list;\n \n   return t;\n }"}, {"sha": "2d177a084f3361e989b3731c7727cbc4ea542e2f", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 99, "deletions": 14, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -92,7 +92,7 @@ is_friend (tree type, tree supplicant)\n \t  tree t = TREE_VALUE (list);\n \n \t  if (TREE_CODE (t) == TEMPLATE_DECL ? \n-\t      is_specialization_of (TYPE_MAIN_DECL (supplicant), t) :\n+\t      is_specialization_of_friend (TYPE_MAIN_DECL (supplicant), t) :\n \t      same_type_p (supplicant, t))\n \t    return 1;\n \t}\n@@ -197,15 +197,39 @@ void\n make_friend_class (tree type, tree friend_type, bool complain)\n {\n   tree classes;\n-  int is_template_friend;\n+\n+  /* CLASS_TEMPLATE_DEPTH counts the number of template headers for\n+     the enclosing class.  FRIEND_DEPTH counts the number of template\n+     headers used for this friend declaration.  TEMPLATE_MEMBER_P,\n+     defined inside the `if' block for TYPENAME_TYPE case, is true if\n+     a template header in FRIEND_DEPTH is intended for DECLARATOR.\n+     For example, the code\n+\n+       template <class T> struct A {\n+\t template <class U> struct B {\n+\t   template <class V> template <class W>\n+\t     friend class C<V>::D;\n+\t };\n+       };\n+\n+     will eventually give the following results\n+\n+     1. CLASS_TEMPLATE_DEPTH equals 2 (for `T' and `U').\n+     2. FRIEND_DEPTH equals 2 (for `V' and `W').\n+     3. TEMPLATE_MEMBER_P is true (for `W').\n+\n+     The friend is a template friend iff FRIEND_DEPTH is nonzero.  */\n+\n+  int class_template_depth = template_class_depth (type);\n+  int friend_depth = processing_template_decl - class_template_depth;\n \n   if (! IS_AGGR_TYPE (friend_type))\n     {\n       error (\"invalid type %qT declared %<friend%>\", friend_type);\n       return;\n     }\n \n-  if (processing_template_decl > template_class_depth (type))\n+  if (friend_depth)\n     /* If the TYPE is a template then it makes sense for it to be\n        friends with itself; this means that each instantiation is\n        friends with all other instantiations.  */\n@@ -221,8 +245,6 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t\t friend_type);\n \t  return;\n \t}\n-  \n-      is_template_friend = 1;\n     }\n   else if (same_type_p (type, friend_type))\n     {\n@@ -231,22 +253,82 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t\t type);\n       return;\n     }\n-  else\n-    is_template_friend = 0;\n \n   /* [temp.friend]\n \n      A friend of a class or class template can be a function or\n      class template, a specialization of a function template or\n      class template, or an ordinary (nontemplate) function or\n      class.  */\n-  if (!is_template_friend)\n+  if (!friend_depth)\n     ;/* ok */\n   else if (TREE_CODE (friend_type) == TYPENAME_TYPE)\n     {\n-      /* template <class T> friend typename S<T>::X; */\n-      error (\"typename type %q#T declared %<friend%>\", friend_type);\n-      return;\n+      if (TREE_CODE (TYPENAME_TYPE_FULLNAME (friend_type))\n+\t  == TEMPLATE_ID_EXPR)\n+\t{\n+\t  /* template <class U> friend class T::X<U>; */\n+\t  /* [temp.friend]\n+\t     Friend declarations shall not declare partial\n+\t     specializations.  */\n+\t  error (\"partial specialization %qT declared %<friend%>\",\n+\t\t friend_type);\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  /* We will figure this out later.  */\n+\t  bool template_member_p = false;\n+\n+\t  tree ctype = TYPE_CONTEXT (friend_type);\n+\t  tree name = TYPE_IDENTIFIER (friend_type);\n+\t  tree decl;\n+\n+\t  if (!uses_template_parms_level (ctype, class_template_depth\n+\t\t\t\t\t\t + friend_depth))\n+\t    template_member_p = true;\n+\n+\t  if (class_template_depth)\n+\t    {\n+\t      /* We rely on tsubst_friend_class to check the\n+\t\t validity of the declaration later.  */\n+\t      if (template_member_p)\n+\t\tfriend_type\n+\t\t  = make_unbound_class_template (ctype,\n+\t\t\t\t\t\t name,\n+\t\t\t\t\t\t current_template_parms,\n+\t\t\t\t\t\t tf_error);\n+\t      else\n+\t\tfriend_type\n+\t\t  = make_typename_type (ctype, name, tf_error);\n+\t    }\n+\t  else\n+\t    {\n+\t      decl = lookup_member (ctype, name, 0, true);\n+\t      if (!decl)\n+\t\t{\n+\t\t  error (\"%qT is not a member of %qT\", name, ctype);\n+\t\t  return;\n+\t\t}\n+\t      if (template_member_p && !DECL_CLASS_TEMPLATE_P (decl))\n+\t\t{\n+\t\t  error (\"%qT is not a member class template of %qT\",\n+\t\t\t name, ctype);\n+\t\t  cp_error_at (\"%qD declared here\", decl);\n+\t\t  return;\n+\t\t}\n+\t      if (!template_member_p && (TREE_CODE (decl) != TYPE_DECL\n+\t\t\t\t\t || !CLASS_TYPE_P (TREE_TYPE (decl))))\n+\t\t{\n+\t\t  error (\"%qT is not a nested class of %qT\",\n+\t\t\t name, ctype);\n+\t\t  cp_error_at (\"%qD declared here\", decl);\n+\t\t  return;\n+\t\t}\n+\n+\t      friend_type = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (decl));\n+\t    }\n+\t}\n     }\n   else if (TREE_CODE (friend_type) == TEMPLATE_TYPE_PARM)\n     {\n@@ -260,10 +342,13 @@ make_friend_class (tree type, tree friend_type, bool complain)\n       error (\"%q#T is not a template\", friend_type);\n       return;\n     }\n-\n-  if (is_template_friend)\n+  else\n+    /* template <class T> friend class A; where A is a template */\n     friend_type = CLASSTYPE_TI_TEMPLATE (friend_type);\n \n+  if (friend_type == error_mark_node)\n+    return;\n+\n   /* See if it is already a friend.  */\n   for (classes = CLASSTYPE_FRIEND_CLASSES (type);\n        classes;\n@@ -297,7 +382,7 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \n       CLASSTYPE_FRIEND_CLASSES (type)\n \t= tree_cons (NULL_TREE, friend_type, CLASSTYPE_FRIEND_CLASSES (type));\n-      if (is_template_friend)\n+      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n \tfriend_type = TREE_TYPE (friend_type);\n       if (!uses_template_parms (type))\n \tCLASSTYPE_BEFRIENDING_CLASSES (friend_type)"}, {"sha": "fc947a5936f518b40e5bef9494ead468e0e81bdf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -14158,7 +14158,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t\t\t\t  /*complain=*/1));\n \t  else if (is_template)\n \t    decl = make_unbound_class_template (parser->scope,\n-\t\t\t\t\t\tname,\n+\t\t\t\t\t\tname, NULL_TREE,\n \t\t\t\t\t\t/*complain=*/1);\n \t  else\n \t    decl = build_nt (SCOPE_REF, parser->scope, name);\n@@ -14847,6 +14847,21 @@ cp_parser_single_declaration (cp_parser* parser,\n       if (cp_parser_declares_only_class_p (parser))\n \t{\n \t  decl = shadow_tag (&decl_specifiers);\n+\n+\t  /* In this case:\n+\n+\t       struct C {\n+\t\t friend template <typename T> struct A<T>::B;\n+\t       };\n+\n+\t     A<T>::B will be represented by a TYPENAME_TYPE, and\n+\t     therefore not recognized by shadow_tag.  */\n+\t  if (friend_p && *friend_p\n+\t      && !decl\n+\t      && decl_specifiers.type\n+\t      && TYPE_P (decl_specifiers.type))\n+\t    decl = decl_specifiers.type;\n+\n \t  if (decl && decl != error_mark_node)\n \t    decl = TYPE_NAME (decl);\n \t  else"}, {"sha": "1ced2389f90f932cb07f8967a9a6f1a66203ae6a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 97, "deletions": 25, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -939,7 +939,8 @@ is_specialization_of_friend (tree decl, tree friend)\n   bool need_template = true;\n   int template_depth;\n \n-  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n+  gcc_assert (TREE_CODE (decl) == FUNCTION_DECL\n+\t      || TREE_CODE (decl) == TYPE_DECL);\n \n   /* For [temp.friend/6] when FRIEND is an ordinary member function\n      of a template class, we want to check if DECL is a specialization\n@@ -948,16 +949,20 @@ is_specialization_of_friend (tree decl, tree friend)\n       && DECL_TEMPLATE_INFO (friend)\n       && !DECL_USE_TEMPLATE (friend))\n     {\n+      /* We want a TEMPLATE_DECL for `is_specialization_of'.  */\n       friend = DECL_TI_TEMPLATE (friend);\n       need_template = false;\n     }\n+  else if (TREE_CODE (friend) == TEMPLATE_DECL\n+\t   && !PRIMARY_TEMPLATE_P (friend))\n+    need_template = false;\n \n   /* There is nothing to do if this is not a template friend.  */\n   if (TREE_CODE (friend) != TEMPLATE_DECL)\n-    return 0;\n+    return false;\n \n   if (is_specialization_of (decl, friend))\n-    return 1;\n+    return true;\n \n   /* [temp.friend/6]\n      A member of a class template may be declared to be a friend of a\n@@ -986,17 +991,25 @@ is_specialization_of_friend (tree decl, tree friend)\n \t\t\t       CLASSTYPE_TI_TEMPLATE (DECL_CONTEXT (friend))))\n     {\n       /* Next, we check the members themselves.  In order to handle\n-\t a few tricky cases like\n+\t a few tricky cases, such as when FRIEND's are\n \n \t   template <class T> friend void A<T>::g(T t);\n \t   template <class T> template <T t> friend void A<T>::h();\n \n-\t we need to figure out what ARGS is (corresponding to `T' in above\n-\t examples) from DECL for later processing.  */\n+\t and DECL's are\n+\n+\t   void A<int>::g(int);\n+\t   template <int> void A<int>::h();\n+\n+\t we need to figure out ARGS, the template arguments from\n+\t the context of DECL.  This is required for template substitution\n+\t of `T' in the function parameter of `g' and template parameter\n+\t of `h' in the above examples.  Here ARGS corresponds to `int'.  */\n \n       tree context = DECL_CONTEXT (decl);\n       tree args = NULL_TREE;\n       int current_depth = 0;\n+\n       while (current_depth < template_depth)\n \t{\n \t  if (CLASSTYPE_TEMPLATE_INFO (context))\n@@ -1023,7 +1036,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t  is_template = DECL_TEMPLATE_INFO (decl)\n \t\t\t&& PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl));\n \t  if (need_template ^ is_template)\n-\t    return 0;\n+\t    return false;\n \t  else if (is_template)\n \t    {\n \t      /* If both are templates, check template parameter list.  */\n@@ -1033,7 +1046,7 @@ is_specialization_of_friend (tree decl, tree friend)\n \t      if (!comp_template_parms\n \t\t     (DECL_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl)),\n \t\t      friend_parms))\n-\t\treturn 0;\n+\t\treturn false;\n \n \t      decl_type = TREE_TYPE (DECL_TI_TEMPLATE (decl));\n \t    }\n@@ -1043,11 +1056,11 @@ is_specialization_of_friend (tree decl, tree friend)\n \t  friend_type = tsubst_function_type (TREE_TYPE (friend), args,\n \t\t\t\t\t      tf_none, NULL_TREE);\n \t  if (friend_type == error_mark_node)\n-\t    return 0;\n+\t    return false;\n \n \t  /* Check if return types match.  */\n \t  if (!same_type_p (TREE_TYPE (decl_type), TREE_TYPE (friend_type)))\n-\t    return 0;\n+\t    return false;\n \n \t  /* Check if function parameter types match, ignoring the\n \t     `this' parameter.  */\n@@ -1057,11 +1070,46 @@ is_specialization_of_friend (tree decl, tree friend)\n \t    friend_args_type = TREE_CHAIN (friend_args_type);\n \t  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n \t    decl_args_type = TREE_CHAIN (decl_args_type);\n-\t  if (compparms (decl_args_type, friend_args_type))\n-\t    return 1;\n+\n+\t  return compparms (decl_args_type, friend_args_type);\n+\t}\n+      else\n+\t{\n+\t  /* DECL is a TYPE_DECL */\n+\t  bool is_template;\n+\t  tree decl_type = TREE_TYPE (decl);\n+\n+\t  /* Make sure that both DECL and FRIEND are templates or\n+\t     non-templates.  */\n+\t  is_template\n+\t    = CLASSTYPE_TEMPLATE_INFO (decl_type)\n+\t      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (decl_type));\n+\n+\t  if (need_template ^ is_template)\n+\t    return false;\n+\t  else if (is_template)\n+\t    {\n+\t      tree friend_parms;\n+\t      /* If both are templates, check the name of the two\n+\t\t TEMPLATE_DECL's first because is_friend didn't.  */\n+\t      if (DECL_NAME (CLASSTYPE_TI_TEMPLATE (decl_type))\n+\t\t  != DECL_NAME (friend))\n+\t\treturn false;\n+\n+\t      /* Now check template parameter list.  */\n+\t      friend_parms\n+\t\t= tsubst_template_parms (DECL_TEMPLATE_PARMS (friend),\n+\t\t\t\t\t args, tf_none);\n+\t      return comp_template_parms\n+\t\t(DECL_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (decl_type)),\n+\t\t friend_parms);\n+\t    }\n+\t  else\n+\t    return (DECL_NAME (decl)\n+\t\t    == DECL_NAME (friend));\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n /* Register the specialization SPEC as a specialization of TMPL with\n@@ -5691,40 +5739,61 @@ instantiate_class_template (tree type)\n \t      /* Build new CLASSTYPE_FRIEND_CLASSES.  */\n \n \t      tree friend_type = t;\n-\t      tree new_friend_type;\n+\t      bool adjust_processing_template_decl = false;\n \n \t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n-\t\tnew_friend_type = tsubst_friend_class (friend_type, args);\n+\t\t{\n+\t\t  friend_type = tsubst_friend_class (friend_type, args);\n+\t  \t  adjust_processing_template_decl = true;\n+\t\t}\n+\t      else if (TREE_CODE (friend_type) == UNBOUND_CLASS_TEMPLATE)\n+\t\t{\n+\t\t  friend_type = tsubst (friend_type, args,\n+\t\t\t\t\ttf_error | tf_warning, NULL_TREE);\n+\t\t  if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t\t    friend_type = TREE_TYPE (friend_type);\n+\t  \t  adjust_processing_template_decl = true;\n+\t\t}\n+\t      else if (TREE_CODE (friend_type) == TYPENAME_TYPE)\n+\t\t{\n+\t\t  friend_type = tsubst (friend_type, args,\n+\t\t\t\t\ttf_error | tf_warning, NULL_TREE);\n+\t\t  /* Bump processing_template_decl for correct\n+\t\t     dependent_type_p calculation.  */\n+\t\t  ++processing_template_decl;\n+\t\t  if (dependent_type_p (friend_type))\n+\t\t    adjust_processing_template_decl = true;\n+\t\t  --processing_template_decl;\n+\t\t}\n \t      else if (uses_template_parms (friend_type))\n-\t\tnew_friend_type = tsubst (friend_type, args,\n-\t\t\t\t\t  tf_error | tf_warning, NULL_TREE);\n+\t\tfriend_type = tsubst (friend_type, args,\n+\t\t\t\t      tf_error | tf_warning, NULL_TREE);\n \t      else if (CLASSTYPE_USE_TEMPLATE (friend_type))\n-\t\tnew_friend_type = friend_type;\n+\t\tfriend_type = friend_type;\n \t      else \n \t\t{\n \t\t  tree ns = decl_namespace_context (TYPE_MAIN_DECL (friend_type));\n \n \t\t  /* The call to xref_tag_from_type does injection for friend\n \t\t     classes.  */\n \t\t  push_nested_namespace (ns);\n-\t\t  new_friend_type = \n+\t\t  friend_type = \n \t\t    xref_tag_from_type (friend_type, NULL_TREE, 1);\n \t\t  pop_nested_namespace (ns);\n \t\t}\n \n-\t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t      if (adjust_processing_template_decl)\n \t\t/* Trick make_friend_class into realizing that the friend\n \t\t   we're adding is a template, not an ordinary class.  It's\n \t\t   important that we use make_friend_class since it will\n \t\t   perform some error-checking and output cross-reference\n \t\t   information.  */\n \t\t++processing_template_decl;\n \n-\t      if (new_friend_type != error_mark_node)\n-\t        make_friend_class (type, new_friend_type,\n-\t\t\t\t   /*complain=*/false);\n+\t      if (friend_type != error_mark_node)\n+\t        make_friend_class (type, friend_type, /*complain=*/false);\n \n-\t      if (TREE_CODE (friend_type) == TEMPLATE_DECL)\n+\t      if (adjust_processing_template_decl)\n \t\t--processing_template_decl;\n \t    }\n \t  else\n@@ -7283,11 +7352,14 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \ttree ctx = tsubst_aggr_type (TYPE_CONTEXT (t), args, complain,\n \t\t\t\t     in_decl, /*entering_scope=*/1);\n \ttree name = TYPE_IDENTIFIER (t);\n+\ttree parm_list = DECL_TEMPLATE_PARMS (TYPE_NAME (t));\n \n \tif (ctx == error_mark_node || name == error_mark_node)\n \t  return error_mark_node;\n \n-\treturn make_unbound_class_template (ctx, name, complain);\n+\tif (parm_list)\n+\t  parm_list = tsubst_template_parms (parm_list, args, complain);\n+\treturn make_unbound_class_template (ctx, name, parm_list, complain);\n       }\n \n     case INDIRECT_REF:"}, {"sha": "f072df9f7b69db53978c5df064b6f47a9a96286b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -1,3 +1,17 @@\n+2004-10-20  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/13495\n+\t* g++.dg/template/memfriend9.C: New test.\n+\t* g++.dg/template/memfriend10.C: Likewise.\n+\t* g++.dg/template/memfriend11.C: Likewise.\n+\t* g++.dg/template/memfriend12.C: Likewise.\n+\t* g++.dg/template/memfriend13.C: Likewise.\n+\t* g++.dg/template/memfriend14.C: Likewise.\n+\t* g++.dg/template/memfriend15.C: Likewise.\n+\t* g++.dg/template/memfriend16.C: Likewise.\n+\t* g++.dg/template/memfriend17.C: Likewise.\n+\t* g++.old-deja/g++.pt/friend44.C: Remove bogus error.\n+\n 2004-10-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/conversion/dr195.C: New."}, {"sha": "4fe760af2ebf2701c81880900ab04682198d93fe", "filename": "gcc/testsuite/g++.dg/template/memfriend10.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend10.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,71 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nested class template of class template as friend\n+\n+template <class T> struct A\n+{\n+  template <class U> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+class C {\n+  int i;\n+  template <class T> template <class U> friend struct A<T>::B;\n+};\n+\n+template <class T> struct A<T*>\n+{\n+  template <class U> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <> struct A<char>\n+{\n+  template <class U> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <class T> template <class U> void A<T>::B<U>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <class T> template <class U> void A<T*>::B<U>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <class U> void A<char>::B<U>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <> void A<char>::B<int>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int>::B<int> b1;\n+  b1.f();\n+  A<int *>::B<int> b2;\n+  b2.f();\n+  A<char>::B<char> b3;\n+  b3.f();\n+  A<char>::B<int> b4;\n+  b4.f();\n+}"}, {"sha": "d06a936d59bb72618183ed9f3e31112226917440", "filename": "gcc/testsuite/g++.dg/template/memfriend11.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend11.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nest class template of class template as friend\n+\n+template<class T> struct A\n+{\n+  template <T t> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+class C {\n+  int i;\n+  template<class T> template <T t> friend struct A<T>::B;\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  template <T* t> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<> struct A<char>\n+{\n+  template <char t> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<class T> template <T t> void A<T>::B<t>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template<class T> template <T* t> void A<T*>::B<t>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <char t> void A<char>::B<t>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template <> void A<char>::B<'b'>::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int d2 = 0;\n+\n+int main()\n+{\n+  A<int>::B<0> b1;\n+  b1.f();\n+  A<int *>::B<&d2> b2;\n+  b2.f();\n+  A<char>::B<'a'> b3;\n+  b3.f();\n+  A<char>::B<'b'> b4;\n+  b4.f();\n+}"}, {"sha": "77f8214003d876c3746ecbaab2df5620d69f7082", "filename": "gcc/testsuite/g++.dg/template/memfriend12.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend12.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nested class of class template as friend\n+\n+template<class T> struct A\n+{\n+  struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <class U> class C {\n+  int i;\n+  template<class T> friend struct A<T>::B;\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<> struct A<char>\n+{\n+  struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<class T> void A<T>::B::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template<class T> void A<T*>::B::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+void A<char>::B::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int>::B b1;\n+  b1.f();\n+  A<int *>::B b2;\n+  b2.f();\n+  A<char>::B b3;\n+  b3.f();\n+}"}, {"sha": "7faed22a2172fbc22d13ef12b11a8cbb2b7bc85c", "filename": "gcc/testsuite/g++.dg/template/memfriend13.C", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend13.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,71 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nested class template of class template as friend\n+\n+template <class T> struct A\n+{\n+  template <class U> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <class V> class C {\n+  int i;\n+  template <class T> template <class U> friend struct A<T>::B;\n+};\n+\n+template <class T> struct A<T*>\n+{\n+  template <class U> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <> struct A<char>\n+{\n+  template <class U> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <class T> template <class U> void A<T>::B<U>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template <class T> template <class U> void A<T*>::B<U>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template <class U> void A<char>::B<U>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template <> void A<char>::B<int>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int>::B<int> b1;\n+  b1.f();\n+  A<int *>::B<int> b2;\n+  b2.f();\n+  A<char>::B<char> b3;\n+  b3.f();\n+  A<char>::B<int> b4;\n+  b4.f();\n+}"}, {"sha": "86d2d3f0e26550f749984902365c65bb1088f19c", "filename": "gcc/testsuite/g++.dg/template/memfriend14.C", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend14.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,73 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nest class template of class template as friend\n+\n+template<class T> struct A\n+{\n+  template <T t> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template <class U> class C {\n+  int i;\n+  template<class T> template <T t> friend struct A<T>::B;\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  template <T* t> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<> struct A<char>\n+{\n+  template <char t> struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<class T> template <T t> void A<T>::B<t>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template<class T> template <T* t> void A<T*>::B<t>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template <char t> void A<char>::B<t>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+template <> void A<char>::B<'b'>::f()\n+{\n+  C<int> c;\n+  c.i = 0;\n+}\n+\n+int d2 = 0;\n+\n+int main()\n+{\n+  A<int>::B<0> b1;\n+  b1.f();\n+  A<int *>::B<&d2> b2;\n+  b2.f();\n+  A<char>::B<'a'> b3;\n+  b3.f();\n+  A<char>::B<'b'> b4;\n+  b4.f();\n+}"}, {"sha": "08db7aef65526d7a850f5f9fd5117b436c21d671", "filename": "gcc/testsuite/g++.dg/template/memfriend15.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend15.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nested class of class template as friend\n+\n+template<class T> struct A\n+{\n+  struct B1\n+  {\n+  };\n+  struct B2\n+  {\n+    void f();\n+  };\n+};\n+\n+class C {\n+  int i;\t// { dg-error \"private\" }\n+  template<class T> friend struct A<T>::B1;\n+};\n+\n+template<class T> void A<T>::B2::f()\n+{\n+  C c;\n+  c.i = 0;\t// { dg-error \"context\" }\n+}\n+\n+int main()\n+{\n+  A<int>::B2 b1;\n+  b1.f();\t// { dg-error \"instantiated\" }\n+}"}, {"sha": "a4eeafd79fec7e7331108db262ddbfd4e9c86ce5", "filename": "gcc/testsuite/g++.dg/template/memfriend16.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend16.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nested class of class template as friend\n+\n+template<class T> struct A\n+{\n+  template <class U> struct B1\n+  {\n+  };\n+  template <class U> struct B2\n+  {\n+    void f();\n+  };\n+};\n+\n+class C {\n+  int i;\t// { dg-error \"private\" }\n+  template<class T> template <class U> friend struct A<T>::B1;\n+};\n+\n+template<class T> template <class U> void A<T>::B2<U>::f()\n+{\n+  C c;\n+  c.i = 0;\t// { dg-error \"context\" }\n+}\n+\n+int main()\n+{\n+  A<int>::B2<int> b1;\n+  b1.f();\t// { dg-error \"instantiated\" }\n+}"}, {"sha": "fd26bc0171e17a71105156aa986f87db40c46e58", "filename": "gcc/testsuite/g++.dg/template/memfriend17.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend17.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,46 @@\n+// { dg-do compile }\n+\n+// Origin: Giovanni Bajo <giovannibajo@libero.it>\n+\n+// PR c++/13495: Nested class as template friend.\n+\n+template<typename T>\n+class A{\n+public:\n+    class B\n+    {\n+        void func1(void);\n+        void func2(void);\n+    };\n+};\n+\n+template<typename Q>\n+class F1\n+{\n+    friend class A<Q>::B;\n+    enum { foo = 0 };\t// { dg-error \"private\" }\n+};\n+\n+template<typename Q>\n+class F2\n+{\n+    template<typename T>\n+    friend class A<T>::B;\n+    enum { foo = 0 };\n+};\n+\n+template <typename T>\n+void A<T>::B::func1(void)\n+{\n+    (void)F1<T>::foo;\n+    (void)F2<T>::foo;\n+}\n+\n+template <typename T>\n+void A<T>::B::func2(void)\n+{\n+    (void)F1<T*>::foo;\t// { dg-error \"context\" }\n+    (void)F2<T*>::foo;\n+}\n+\n+template class A<int>;\t// { dg-error \"instantiated\" }"}, {"sha": "9c926013b0617e31cee92cfc6b657b9bc6da6638", "filename": "gcc/testsuite/g++.dg/template/memfriend9.C", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fmemfriend9.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -0,0 +1,63 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+\n+// Nested class of class template as friend\n+\n+template<class T> struct A\n+{\n+  struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+class C {\n+  int i;\n+  template<class T> friend struct A<T>::B;\n+};\n+\n+template<class T> struct A<T*>\n+{\n+  struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<> struct A<char>\n+{\n+  struct B\n+  {\n+    void f();\n+  };\n+};\n+\n+template<class T> void A<T>::B::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+template<class T> void A<T*>::B::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+void A<char>::B::f()\n+{\n+  C c;\n+  c.i = 0;\n+}\n+\n+int main()\n+{\n+  A<int>::B b1;\n+  b1.f();\n+  A<int *>::B b2;\n+  b2.f();\n+  A<char>::B b3;\n+  b3.f();\n+}"}, {"sha": "1d2c1d1f9b67b06ed314ac6b2c320d86847f51dd", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend44.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend44.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b939a02360cf41893436921e319c4283f2d6edb5/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend44.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend44.C?ref=b939a02360cf41893436921e319c4283f2d6edb5", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do run }\n+// { dg-do compile }\n // Test that template friends referring to class template members are\n // respected.\n \n@@ -15,7 +15,7 @@ class B\n {\n   template <class T> friend int A<T>::f (T);\n   template <class T> friend struct A<T>::AI;\n-  int a; // { dg-bogus \"\" \"\" { xfail *-*-* } }\n+  int a;\n public:\n   B(): a(0) { }\n };\n@@ -29,7 +29,7 @@ template <class T> int A<T>::f (T)\n template <class T> int A<T>::AI::f (T)\n {\n   B b;\n-  return b.a; // { dg-bogus \"\" \"\" { xfail *-*-* } }\n+  return b.a;\n }\n \n int main ()"}]}