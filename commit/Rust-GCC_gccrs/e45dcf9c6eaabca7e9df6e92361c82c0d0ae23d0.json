{"sha": "e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ1ZGNmOWM2ZWFhYmNhN2U5ZGY2ZTkyMzYxYzgyYzBkMGFlMjNkMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-02-07T18:04:29Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-02-07T18:04:29Z"}, "message": "df-core.c (df_set_blocks): Do not dereference function pointers.\n\n\t* df-core.c (df_set_blocks): Do not dereference function pointers.\n\t(df_finish1): Likewise.\n\t(df_hybrid_search_forward): Likewise.\n\t(df_hybrid_search_backward): Likewise.\n\t(df_iterative_dataflow): Likewise.\n\t(df_analyze_problem): Likewise.\n\t(df_compact_blocks): Likewise.\n\t(df_dump): Likewise.\n\t* df-scan.c (df_rescan_blocks): Likewise.\n\t(df_record_entry_block_defs): Likewise.\n\n\t* genconditions.c (write_conditions): Guard the definition of\n\t'insn_conditions' with the check on GCC version.\n\t(write_writer): Guard the traversal 'insn_conditions' with\n\tthe check on GCC version.\n\nFrom-SVN: r110702", "tree": {"sha": "57beded1efa81b435a173506fe6e6f19df8eaad8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57beded1efa81b435a173506fe6e6f19df8eaad8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/comments", "author": null, "committer": null, "parents": [{"sha": "0e5264e8ea8f3122c6bc6a4d1289c96c4f3a8d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e5264e8ea8f3122c6bc6a4d1289c96c4f3a8d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e5264e8ea8f3122c6bc6a4d1289c96c4f3a8d63"}], "stats": {"total": 70, "additions": 36, "deletions": 34}, "files": [{"sha": "8821dedeaa3e9e63e1d875cbfa9a0628ed0b7633", "filename": "gcc/df-core.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "patch": "@@ -369,9 +369,9 @@ df_set_blocks (struct df *df, bitmap blocks)\n \t  for (p = df->num_problems_defined - 1; p >= 0 ;p--)\n \t    {\n \t      struct dataflow *dflow = df->problems_in_order[p];\n-\t      if (*dflow->problem->reset_fun)\n-\t\t(*dflow->problem->reset_fun) (dflow, df->blocks_to_analyze);\n-\t      else if (*dflow->problem->free_bb_fun)\n+\t      if (dflow->problem->reset_fun)\n+\t\tdflow->problem->reset_fun (dflow, df->blocks_to_analyze);\n+\t      else if (dflow->problem->free_bb_fun)\n \t\t{\n \t\t  bitmap_iterator bi;\n \t\t  unsigned int bb_index;\n@@ -381,7 +381,7 @@ df_set_blocks (struct df *df, bitmap blocks)\n \t\t      basic_block bb = BASIC_BLOCK (bb_index);\n \t\t      if (bb)\n \t\t\t{\n-\t\t\t  (*dflow->problem->free_bb_fun) \n+\t\t\t  dflow->problem->free_bb_fun\n \t\t\t    (dflow, bb, df_get_bb_info (dflow, bb_index));\n \t\t\t  df_set_bb_info (dflow, bb_index, NULL); \n \t\t\t}\n@@ -403,7 +403,7 @@ df_set_blocks (struct df *df, bitmap blocks)\n \t      for (p = df->num_problems_defined - 1; p >= 0 ;p--)\n \t\t{\n \t\t  struct dataflow *dflow = df->problems_in_order[p];\n-\t\t  if (*dflow->problem->reset_fun)\n+\t\t  if (dflow->problem->reset_fun)\n \t\t    {\n \t\t      if (!blocks_to_reset)\n \t\t\t{\n@@ -414,7 +414,7 @@ df_set_blocks (struct df *df, bitmap blocks)\n \t\t\t      bitmap_set_bit (blocks_to_reset, bb->index); \n \t\t\t    }\n \t\t\t}\n-\t\t      (*dflow->problem->reset_fun) (dflow, blocks_to_reset);\n+\t\t      dflow->problem->reset_fun (dflow, blocks_to_reset);\n \t\t    }\n \t\t}\n \t      if (blocks_to_reset)\n@@ -444,7 +444,7 @@ df_finish1 (struct df *df)\n   int i;\n \n   for (i = 0; i < df->num_problems_defined; i++)\n-    (*df->problems_in_order[i]->problem->free_fun) (df->problems_in_order[i]); \n+    df->problems_in_order[i]->problem->free_fun (df->problems_in_order[i]); \n \n   free (df);\n }\n@@ -479,12 +479,12 @@ df_hybrid_search_forward (basic_block bb,\n \tif (!TEST_BIT (dataflow->considered, e->src->index))\n \t  continue;\n \t\n-\t(*dataflow->problem->con_fun_n) (dataflow, e);\n+\tdataflow->problem->con_fun_n (dataflow, e);\n       }\n-  else if (*dataflow->problem->con_fun_0)\n-    (*dataflow->problem->con_fun_0) (dataflow, bb);\n+  else if (dataflow->problem->con_fun_0)\n+    dataflow->problem->con_fun_0 (dataflow, bb);\n   \n-  result_changed = (*dataflow->problem->trans_fun) (dataflow, i);\n+  result_changed = dataflow->problem->trans_fun (dataflow, i);\n   \n   if (!result_changed || single_pass)\n     return;\n@@ -531,12 +531,12 @@ df_hybrid_search_backward (basic_block bb,\n \tif (!TEST_BIT (dataflow->considered, e->dest->index))\t\t\n \t  continue;\t\t\t\t\t\t\t\n \t\n-\t(*dataflow->problem->con_fun_n) (dataflow, e);\n+\tdataflow->problem->con_fun_n (dataflow, e);\n       }\t\t\t\t\t\t\t\t\n-  else if (*dataflow->problem->con_fun_0)\n-    (*dataflow->problem->con_fun_0) (dataflow, bb);\n+  else if (dataflow->problem->con_fun_0)\n+    dataflow->problem->con_fun_0 (dataflow, bb);\n \n-  result_changed = (*dataflow->problem->trans_fun) (dataflow, i);\n+  result_changed = dataflow->problem->trans_fun (dataflow, i);\n   \n   if (!result_changed || single_pass)\n     return;\n@@ -605,7 +605,7 @@ df_iterative_dataflow (struct dataflow *dataflow,\n       SET_BIT (pending, idx);\n     };\n \n-  (*dataflow->problem->init_fun) (dataflow, blocks_to_init);\n+  dataflow->problem->init_fun (dataflow, blocks_to_init);\n \n   while (1)\n     {\n@@ -704,24 +704,24 @@ df_analyze_problem (struct dataflow *dflow,\n \t\t    int *postorder, int n_blocks, bool single_pass)\n {\n   /* (Re)Allocate the datastructures necessary to solve the problem.  */ \n-  if (*dflow->problem->alloc_fun)\n-    (*dflow->problem->alloc_fun) (dflow, blocks_to_scan);\n+  if (dflow->problem->alloc_fun)\n+    dflow->problem->alloc_fun (dflow, blocks_to_scan);\n \n   /* Set up the problem and compute the local information.  This\n      function is passed both the blocks_to_consider and the\n      blocks_to_scan because the RD and RU problems require the entire\n      function to be rescanned if they are going to be updated.  */\n-  if (*dflow->problem->local_compute_fun)\n-    (*dflow->problem->local_compute_fun) (dflow, blocks_to_consider, blocks_to_scan);\n+  if (dflow->problem->local_compute_fun)\n+    dflow->problem->local_compute_fun (dflow, blocks_to_consider, blocks_to_scan);\n \n   /* Solve the equations.  */\n-  if (*dflow->problem->dataflow_fun)\n-    (*dflow->problem->dataflow_fun) (dflow, blocks_to_consider, blocks_to_init,\n-\t\t\t\t    postorder, n_blocks, single_pass);\n+  if (dflow->problem->dataflow_fun)\n+    dflow->problem->dataflow_fun (dflow, blocks_to_consider, blocks_to_init,\n+\t\t\t\t  postorder, n_blocks, single_pass);\n \n   /* Massage the solution.  */\n-  if (*dflow->problem->finalize_fun)\n-    (*dflow->problem->finalize_fun) (dflow, blocks_to_consider);\n+  if (dflow->problem->finalize_fun)\n+    dflow->problem->finalize_fun (dflow, blocks_to_consider);\n }\n \n \n@@ -825,7 +825,7 @@ df_compact_blocks (struct df *df)\n   for (p = 0; p < df->num_problems_defined; p++)\n     {\n       struct dataflow *dflow = df->problems_in_order[p];\n-      if (*dflow->problem->free_bb_fun)\n+      if (dflow->problem->free_bb_fun)\n \t{\n \t  df_grow_bb_info (dflow);\n \t  memcpy (problem_temps, dflow->block_info, size);\n@@ -849,7 +849,7 @@ df_compact_blocks (struct df *df)\n \t    {\n \t      basic_block bb = BASIC_BLOCK (i); \n \t      if (problem_temps[i] && bb)\n-\t\t(*dflow->problem->free_bb_fun) \n+\t\tdflow->problem->free_bb_fun\n \t\t  (dflow, bb, problem_temps[i]);\n \t    }\n \t}\n@@ -1063,7 +1063,7 @@ df_dump (struct df *df, FILE *file)\n \t   df->def_info.bitmap_size, df->use_info.bitmap_size);\n \n   for (i = 0; i < df->num_problems_defined; i++)\n-    (*df->problems_in_order[i]->problem->dump_fun) (df->problems_in_order[i], file); \n+    df->problems_in_order[i]->problem->dump_fun (df->problems_in_order[i], file); \n \n   fprintf (file, \"\\n\");\n }"}, {"sha": "6cc62c7e9e2aeefce3abfdfe1720fbb9f61db514", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "patch": "@@ -453,7 +453,7 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n       for (i = df->num_problems_defined; i; i--)\n \t{\n \t  bitmap blocks_to_reset = NULL;\n-\t  if (*dflow->problem->reset_fun)\n+\t  if (dflow->problem->reset_fun)\n \t    {\n \t      if (!blocks_to_reset)\n \t\t{\n@@ -462,7 +462,7 @@ df_rescan_blocks (struct df *df, bitmap blocks)\n \t\t  if (df->blocks_to_scan)\n \t\t    bitmap_ior_into (blocks_to_reset, df->blocks_to_scan);\n \t\t}\n-\t      (*dflow->problem->reset_fun) (dflow, blocks_to_reset);\n+\t      dflow->problem->reset_fun (dflow, blocks_to_reset);\n \t    }\n \t  if (blocks_to_reset)\n \t    BITMAP_FREE (blocks_to_reset);\n@@ -1804,7 +1804,7 @@ df_record_entry_block_defs (struct dataflow * dflow)\n #endif\n     }\n \n-  (*targetm.live_on_entry) (df->entry_block_defs);\n+  targetm.live_on_entry (df->entry_block_defs);\n \n   EXECUTE_IF_SET_IN_BITMAP (df->entry_block_defs, 0, i, bi)\n     {"}, {"sha": "b67936502b68223ec80245941c3cb0444d5598f5", "filename": "gcc/genconditions.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=e45dcf9c6eaabca7e9df6e92361c82c0d0ae23d0", "patch": "@@ -160,12 +160,12 @@ struct c_test\\n\\\n    vary at run time.  It works in 3.0.1 and later; 3.0 only when not\\n\\\n    optimizing.  */\\n\\\n \\n\\\n-static const struct c_test insn_conditions[] = {\\n\\\n-#if GCC_VERSION >= 3001\\n\");\n+#if GCC_VERSION >= 3001\\n\\\n+static const struct c_test insn_conditions[] = {\\n\");\n \n   traverse_c_tests (write_one_condition, 0);\n \n-  puts (\"\\n#endif /* gcc >= 3.0.1 */\\n};\\n\");\n+  puts (\"\\n};\\n#endif /* gcc >= 3.0.1 */\\n\");\n }\n \n /* Emit code which will convert the C-format table to a\n@@ -181,6 +181,7 @@ write_writer (void)\n \t\"  unsigned int i;\\n\"\n         \"  const char *p;\\n\"\n         \"  puts (\\\"(define_conditions [\\\");\\n\"\n+\t\"#if GCC_VERSION >= 3001\\n\"\n \t\"  for (i = 0; i < ARRAY_SIZE (insn_conditions); i++)\\n\"\n \t\"    {\\n\"\n \t\"      printf (\\\"  (%d \\\\\\\"\\\", insn_conditions[i].value);\\n\"\n@@ -196,6 +197,7 @@ write_writer (void)\n \t\"        }\\n\"\n         \"      puts (\\\"\\\\\\\")\\\");\\n\"\n         \"    }\\n\"\n+\t\"#endif /* gcc >= 3.0.1 */\\n\"\n \t\"  puts (\\\"])\\\");\\n\"\n         \"  fflush (stdout);\\n\"\n         \"return ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE;\\n\""}]}