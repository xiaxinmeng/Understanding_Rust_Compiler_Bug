{"sha": "b9a0100963b357e7e84084e45bbc51d6576410a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjlhMDEwMDk2M2IzNTdlN2U4NDA4NGU0NWJiYzUxZDY1NzY0MTBhNA==", "commit": {"author": {"name": "Sylvia Taylor", "email": "sylvia.taylor@arm.com", "date": "2019-07-18T16:02:05Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2019-07-18T16:02:05Z"}, "message": "[patch2/2][arm]: remove builtin expand for sha1\n\nThis patch removes the builtin expand handling for sha1h/c/m/p and\nreplaces it with expand patterns. This should make it more consistent\nwith how we handle intrinsic implementations and cleans up the custom\nsha1 code in the arm_expand builtins for unop and ternop.\n\n2019-07-18  Sylvia Taylor  <sylvia.taylor@arm.com>\n\n\t* config/arm/arm-builtins.c\n\t(arm_expand_ternop_builtin): Remove explicit sha1 builtin handling.\n\t(arm_expand_unop_builtin): Likewise.\n\t* config/arm/crypto.md\n\t(crypto_sha1h): Convert from define_insn to define_expand.\n\t(crypto_<crypto_pattern>): Likewise.\n\t(crypto_sha1h_lb): New define_insn.\n\t(crypto_<crypto_pattern>_lb): Likewise.\n\nFrom-SVN: r273575", "tree": {"sha": "806f623c6e01f54496eaf3c26999e573b7396818", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/806f623c6e01f54496eaf3c26999e573b7396818"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9a0100963b357e7e84084e45bbc51d6576410a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a0100963b357e7e84084e45bbc51d6576410a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a0100963b357e7e84084e45bbc51d6576410a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a0100963b357e7e84084e45bbc51d6576410a4/comments", "author": null, "committer": null, "parents": [{"sha": "e38341a8e0c7f89eb2146feddea8c2f3bf25a331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e38341a8e0c7f89eb2146feddea8c2f3bf25a331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e38341a8e0c7f89eb2146feddea8c2f3bf25a331"}], "stats": {"total": 86, "additions": 46, "deletions": 40}, "files": [{"sha": "7055ca4398bce7889e176881fd4f850fb6a5477f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a0100963b357e7e84084e45bbc51d6576410a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a0100963b357e7e84084e45bbc51d6576410a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9a0100963b357e7e84084e45bbc51d6576410a4", "patch": "@@ -1,3 +1,14 @@\n+2019-07-18  Sylvia Taylor  <sylvia.taylor@arm.com>\n+\n+\t* config/arm/arm-builtins.c\n+\t(arm_expand_ternop_builtin): Remove explicit sha1 builtin handling.\n+\t(arm_expand_unop_builtin): Likewise.\n+\t* config/arm/crypto.md\n+\t(crypto_sha1h): Convert from define_insn to define_expand.\n+\t(crypto_<crypto_pattern>): Likewise.\n+\t(crypto_sha1h_lb): New define_insn.\n+\t(crypto_<crypto_pattern>_lb): Likewise.\n+\n 2019-07-18  Sylvia Taylor  <sylvia.taylor@arm.com>\n \n         PR target/90317"}, {"sha": "8f2c93743792bbf8ee9a421c408501b3a3051b2b", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a0100963b357e7e84084e45bbc51d6576410a4/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a0100963b357e7e84084e45bbc51d6576410a4/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=b9a0100963b357e7e84084e45bbc51d6576410a4", "patch": "@@ -1993,25 +1993,12 @@ arm_expand_ternop_builtin (enum insn_code icode,\n   rtx op0 = expand_normal (arg0);\n   rtx op1 = expand_normal (arg1);\n   rtx op2 = expand_normal (arg2);\n-  rtx op3 = NULL_RTX;\n \n-  /* The sha1c, sha1p, sha1m crypto builtins require a different vec_select\n-     lane operand depending on endianness.  */\n-  bool builtin_sha1cpm_p = false;\n-\n-  if (insn_data[icode].n_operands == 5)\n-    {\n-      gcc_assert (icode == CODE_FOR_crypto_sha1c\n-                  || icode == CODE_FOR_crypto_sha1p\n-                  || icode == CODE_FOR_crypto_sha1m);\n-      builtin_sha1cpm_p = true;\n-    }\n   machine_mode tmode = insn_data[icode].operand[0].mode;\n   machine_mode mode0 = insn_data[icode].operand[1].mode;\n   machine_mode mode1 = insn_data[icode].operand[2].mode;\n   machine_mode mode2 = insn_data[icode].operand[3].mode;\n \n-\n   if (VECTOR_MODE_P (mode0))\n     op0 = safe_vector_operand (op0, mode0);\n   if (VECTOR_MODE_P (mode1))\n@@ -2034,13 +2021,8 @@ arm_expand_ternop_builtin (enum insn_code icode,\n     op1 = copy_to_mode_reg (mode1, op1);\n   if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n     op2 = copy_to_mode_reg (mode2, op2);\n-  if (builtin_sha1cpm_p)\n-    op3 = GEN_INT (TARGET_BIG_END ? 1 : 0);\n \n-  if (builtin_sha1cpm_p)\n-    pat = GEN_FCN (icode) (target, op0, op1, op2, op3);\n-  else\n-    pat = GEN_FCN (icode) (target, op0, op1, op2);\n+  pat = GEN_FCN (icode) (target, op0, op1, op2);\n   if (! pat)\n     return 0;\n   emit_insn (pat);\n@@ -2096,16 +2078,8 @@ arm_expand_unop_builtin (enum insn_code icode,\n   rtx pat;\n   tree arg0 = CALL_EXPR_ARG (exp, 0);\n   rtx op0 = expand_normal (arg0);\n-  rtx op1 = NULL_RTX;\n   machine_mode tmode = insn_data[icode].operand[0].mode;\n   machine_mode mode0 = insn_data[icode].operand[1].mode;\n-  bool builtin_sha1h_p = false;\n-\n-  if (insn_data[icode].n_operands == 3)\n-    {\n-      gcc_assert (icode == CODE_FOR_crypto_sha1h);\n-      builtin_sha1h_p = true;\n-    }\n \n   if (! target\n       || GET_MODE (target) != tmode\n@@ -2121,13 +2095,9 @@ arm_expand_unop_builtin (enum insn_code icode,\n       if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n \top0 = copy_to_mode_reg (mode0, op0);\n     }\n-  if (builtin_sha1h_p)\n-    op1 = GEN_INT (TARGET_BIG_END ? 1 : 0);\n \n-  if (builtin_sha1h_p)\n-    pat = GEN_FCN (icode) (target, op0, op1);\n-  else\n-    pat = GEN_FCN (icode) (target, op0);\n+  pat = GEN_FCN (icode) (target, op0);\n+\n   if (! pat)\n     return 0;\n   emit_insn (pat);"}, {"sha": "03596fedb035b2c2670ea1e4f0e37ed4a9004404", "filename": "gcc/config/arm/crypto.md", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9a0100963b357e7e84084e45bbc51d6576410a4/gcc%2Fconfig%2Farm%2Fcrypto.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9a0100963b357e7e84084e45bbc51d6576410a4/gcc%2Fconfig%2Farm%2Fcrypto.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcrypto.md?ref=b9a0100963b357e7e84084e45bbc51d6576410a4", "patch": "@@ -109,13 +109,23 @@\n    of the V4SI, adjusted for endianness. Required due to neon_vget_lane and\n    neon_set_lane that change the element ordering in memory for big-endian.  */\n \n-(define_insn \"crypto_sha1h\"\n+(define_expand \"crypto_sha1h\"\n+  [(set (match_operand:V4SI 0 \"register_operand\")\n+\t(match_operand:V4SI 1 \"register_operand\"))]\n+  \"TARGET_CRYPTO\"\n+{\n+  rtx op2 = GEN_INT (NEON_ENDIAN_LANE_N (V2SImode, 0));\n+  emit_insn (gen_crypto_sha1h_lb (operands[0], operands[1], op2));\n+  DONE;\n+})\n+\n+(define_insn \"crypto_sha1h_lb\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=w\")\n-\t   (unspec:V4SI\n-\t      [(vec_select:SI\n-\t\t(match_operand:V4SI 1 \"register_operand\" \"w\")\n-\t\t(parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))]\n-\t   UNSPEC_SHA1H))]\n+\t(unspec:V4SI\n+\t  [(vec_select:SI\n+\t   (match_operand:V4SI 1 \"register_operand\" \"w\")\n+\t   (parallel [(match_operand:SI 2 \"immediate_operand\" \"i\")]))]\n+\tUNSPEC_SHA1H))]\n   \"TARGET_CRYPTO && INTVAL (operands[2]) == NEON_ENDIAN_LANE_N (V2SImode, 0)\"\n   \"sha1h.32\\\\t%q0, %q1\"\n   [(set_attr \"type\" \"crypto_sha1_fast\")]\n@@ -135,7 +145,22 @@\n    of the V4SI, adjusted for endianness. Required due to neon_vget_lane and\n    neon_set_lane that change the element ordering in memory for big-endian.  */\n \n-(define_insn \"crypto_<crypto_pattern>\"\n+(define_expand \"crypto_<crypto_pattern>\"\n+  [(set (match_operand:V4SI 0 \"register_operand\")\n+\t(unspec:<crypto_mode>\n+\t\t[(match_operand:<crypto_mode> 1 \"register_operand\")\n+\t\t (match_operand:<crypto_mode> 2 \"register_operand\")\n+\t\t (match_operand:<crypto_mode> 3 \"register_operand\")]\n+\tCRYPTO_SELECTING))]\n+  \"TARGET_CRYPTO\"\n+{\n+  rtx op4 = GEN_INT (NEON_ENDIAN_LANE_N (V2SImode, 0));\n+  emit_insn (gen_crypto_<crypto_pattern>_lb\n+\t     (operands[0], operands[1], operands[2], operands[3], op4));\n+  DONE;\n+})\n+\n+(define_insn \"crypto_<crypto_pattern>_lb\"\n   [(set (match_operand:V4SI 0 \"register_operand\" \"=w\")\n         (unspec:<crypto_mode>\n                      [(match_operand:<crypto_mode> 1 \"register_operand\" \"0\")"}]}