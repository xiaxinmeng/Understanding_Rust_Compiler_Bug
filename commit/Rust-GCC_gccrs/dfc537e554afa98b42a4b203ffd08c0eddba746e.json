{"sha": "dfc537e554afa98b42a4b203ffd08c0eddba746e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGZjNTM3ZTU1NGFmYTk4YjQyYTRiMjAzZmZkMDhjMGVkZGJhNzQ2ZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-25T17:59:44Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-25T18:24:13Z"}, "message": "libstdc++: Remove redundant clock conversions in atomic waits\n\nFor the case where a timeout is specified using the system_clock we\nperform a conversion to the preferred clock (which is either\nsteady_clock or system_clock itself), wait using __cond_wait_until_impl,\nand then check the time by that clock again to see if it was reached.\nThis is entirely redundant, as we can just call __cond_wait_until_impl\ndirectly. It will wait using the specified clock, and there's no need to\ncheck the time twice. For the no_timeout case this removes two\nunnecessary calls to the clock's now() function, and for the timeout\ncase it removes three calls.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/atomic_timed_wait.h (__cond_wait_until): Do not\n\tperform redundant conversions to the same clock.", "tree": {"sha": "d683b7caeea89f9f590ed5f4e6df5b3362b7d956", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d683b7caeea89f9f590ed5f4e6df5b3362b7d956"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dfc537e554afa98b42a4b203ffd08c0eddba746e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc537e554afa98b42a4b203ffd08c0eddba746e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfc537e554afa98b42a4b203ffd08c0eddba746e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfc537e554afa98b42a4b203ffd08c0eddba746e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d2a98a7273c423842a3935de64b15a6d6cb33bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d2a98a7273c423842a3935de64b15a6d6cb33bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d2a98a7273c423842a3935de64b15a6d6cb33bc"}], "stats": {"total": 40, "additions": 24, "deletions": 16}, "files": [{"sha": "1c91c858ce7ce4350b7f9cd7225f52558afb5420", "filename": "libstdc++-v3/include/bits/atomic_timed_wait.h", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dfc537e554afa98b42a4b203ffd08c0eddba746e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dfc537e554afa98b42a4b203ffd08c0eddba746e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h?ref=dfc537e554afa98b42a4b203ffd08c0eddba746e", "patch": "@@ -166,24 +166,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __cond_wait_until(__condvar& __cv, mutex& __mx,\n \t  const chrono::time_point<_Clock, _Duration>& __atime)\n       {\n-#ifdef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n-\tusing __clock_t = chrono::steady_clock;\n-#else\n+#ifndef _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT\n \tusing __clock_t = chrono::system_clock;\n+#else\n+\tusing __clock_t = chrono::steady_clock;\n+\tif constexpr (is_same_v<_Clock, chrono::steady_clock>)\n+\t  return __detail::__cond_wait_until_impl(__cv, __mx, __atime);\n+\telse\n #endif\n-\tconst typename _Clock::time_point __c_entry = _Clock::now();\n-\tconst __clock_t::time_point __s_entry = __clock_t::now();\n-\tconst auto __delta = __atime - __c_entry;\n-\tconst auto __s_atime = __s_entry + __delta;\n-\tif (__detail::__cond_wait_until_impl(__cv, __mx, __s_atime)\n-\t    == __atomic_wait_status::no_timeout)\n-\t  return __atomic_wait_status::no_timeout;\n-\t// We got a timeout when measured against __clock_t but\n-\t// we need to check against the caller-supplied clock\n-\t// to tell whether we should return a timeout.\n-\tif (_Clock::now() < __atime)\n-\t  return __atomic_wait_status::no_timeout;\n-\treturn __atomic_wait_status::timeout;\n+\tif constexpr (is_same_v<_Clock, chrono::system_clock>)\n+\t  return __detail::__cond_wait_until_impl(__cv, __mx, __atime);\n+\telse\n+\t  {\n+\t    const typename _Clock::time_point __c_entry = _Clock::now();\n+\t    const __clock_t::time_point __s_entry = __clock_t::now();\n+\t    const auto __delta = __atime - __c_entry;\n+\t    const auto __s_atime = __s_entry + __delta;\n+\t    if (__detail::__cond_wait_until_impl(__cv, __mx, __s_atime)\n+\t\t== __atomic_wait_status::no_timeout)\n+\t      return __atomic_wait_status::no_timeout;\n+\t    // We got a timeout when measured against __clock_t but\n+\t    // we need to check against the caller-supplied clock\n+\t    // to tell whether we should return a timeout.\n+\t    if (_Clock::now() < __atime)\n+\t      return __atomic_wait_status::no_timeout;\n+\t    return __atomic_wait_status::timeout;\n+\t  }\n       }\n #endif // FUTEX\n "}]}