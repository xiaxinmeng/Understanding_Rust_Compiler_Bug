{"sha": "0bb9c57d22015000b3f312091a981139fc35ba59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiOWM1N2QyMjAxNTAwMGIzZjMxMjA5MWE5ODExMzlmYzM1YmE1OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-10T08:14:16Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-10T08:14:16Z"}, "message": "rtti.c (get_tinfo_var): These should always be global\n\n\t* rtti.c (get_tinfo_var): These should always be global\n\t(expand_si_desc): Use tree, not RTL, functions to generate code.\n\t(expand_class_desc): Likewise.\n\t(expand_ptr_desc): Likewise.\n\t(expand_attr_desc): Likewise.\n\t(expand_generic_desc): Likewise.\n\t(synthesize_tinfo_fn): Likewise.\n\nFrom-SVN: r29259", "tree": {"sha": "a7f4d3bb5d2ddfe81e6f5e4c93c5abd326c90019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7f4d3bb5d2ddfe81e6f5e4c93c5abd326c90019"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bb9c57d22015000b3f312091a981139fc35ba59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb9c57d22015000b3f312091a981139fc35ba59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bb9c57d22015000b3f312091a981139fc35ba59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bb9c57d22015000b3f312091a981139fc35ba59/comments", "author": null, "committer": null, "parents": [{"sha": "6a26a9ead44a5b22ab622f67f3fbffa3fc6518b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a26a9ead44a5b22ab622f67f3fbffa3fc6518b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a26a9ead44a5b22ab622f67f3fbffa3fc6518b1"}], "stats": {"total": 60, "additions": 46, "deletions": 14}, "files": [{"sha": "1d7475e28c360fffbfb129083aaf16da330bc25e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bb9c57d22015000b3f312091a981139fc35ba59/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bb9c57d22015000b3f312091a981139fc35ba59/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0bb9c57d22015000b3f312091a981139fc35ba59", "patch": "@@ -1,3 +1,13 @@\n+1999-09-10  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* rtti.c (get_tinfo_var): These should always be global\n+\t(expand_si_desc): Use tree, not RTL, functions to generate code.\n+\t(expand_class_desc): Likewise.\n+\t(expand_ptr_desc): Likewise.\n+\t(expand_attr_desc): Likewise.\n+\t(expand_generic_desc): Likewise.\n+\t(synthesize_tinfo_fn): Likewise.\n+\n 1999-09-09  Mark Mitchell  <mark@codesourcery.com>\n \n \t* semantics.c (RECHAIN_STMTS): Remove `last' parameter."}, {"sha": "3baaaa83882f73867259b52f2b17f86ed83114bf", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bb9c57d22015000b3f312091a981139fc35ba59/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bb9c57d22015000b3f312091a981139fc35ba59/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0bb9c57d22015000b3f312091a981139fc35ba59", "patch": "@@ -351,8 +351,10 @@ get_tinfo_var (type)\n   TREE_PUBLIC (tdecl) = 1;\n   DECL_EXTERNAL (tdecl) = 1;\n   DECL_ARTIFICIAL (tdecl) = 1;\n-  pushdecl_top_level (tdecl);\n+  push_to_top_level ();\n+  pushdecl (tdecl);\n   cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n+  pop_from_top_level ();\n \n   pop_obstacks ();\n \n@@ -734,7 +736,7 @@ expand_si_desc (tdecl, type)\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n \n   type = BINFO_TYPE (TREE_VEC_ELT (TYPE_BINFO_BASETYPES (type), 0));\n-  expand_expr_stmt (get_typeid_1 (type));\n+  finish_expr_stmt (get_typeid_1 (type));\n   t = decay_conversion (get_tinfo_var (type));\n   elems = tree_cons\n     (NULL_TREE, decay_conversion (tdecl), tree_cons\n@@ -766,7 +768,7 @@ expand_si_desc (tdecl, type)\n \n   mark_used (fn);\n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n-  expand_expr_stmt (fn);\n+  finish_expr_stmt (fn);\n }\n \n /* Build an initializer for a __class_type_info node.  */\n@@ -832,7 +834,7 @@ expand_class_desc (tdecl, type)\n     {\n       tree binfo = TREE_VEC_ELT (binfos, i);\n \n-      expand_expr_stmt (get_typeid_1 (BINFO_TYPE (binfo)));\n+      finish_expr_stmt (get_typeid_1 (BINFO_TYPE (binfo)));\n       base = decay_conversion (get_tinfo_var (BINFO_TYPE (binfo)));\n \n       if (TREE_VIA_VIRTUAL (binfo))\n@@ -947,7 +949,7 @@ expand_class_desc (tdecl, type)\n \n   mark_used (fn);\n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n-  expand_expr_stmt (fn);\n+  finish_expr_stmt (fn);\n }\n \n /* Build an initializer for a __pointer_type_info node.  */\n@@ -962,7 +964,7 @@ expand_ptr_desc (tdecl, type)\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n \n   type = TREE_TYPE (type);\n-  expand_expr_stmt (get_typeid_1 (type));\n+  finish_expr_stmt (get_typeid_1 (type));\n   t = decay_conversion (get_tinfo_var (type));\n   elems = tree_cons\n     (NULL_TREE, decay_conversion (tdecl), tree_cons\n@@ -994,7 +996,7 @@ expand_ptr_desc (tdecl, type)\n \n   mark_used (fn);\n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n-  expand_expr_stmt (fn);\n+  finish_expr_stmt (fn);\n }\n \n /* Build an initializer for a __attr_type_info node.  */\n@@ -1009,7 +1011,7 @@ expand_attr_desc (tdecl, type)\n   tree name_string = combine_strings (build_string (strlen (name)+1, name));\n   tree attrval = build_int_2 (TYPE_QUALS (type), 0);\n \n-  expand_expr_stmt (get_typeid_1 (TYPE_MAIN_VARIANT (type)));\n+  finish_expr_stmt (get_typeid_1 (TYPE_MAIN_VARIANT (type)));\n   t = decay_conversion (get_tinfo_var (TYPE_MAIN_VARIANT (type)));\n   elems = tree_cons\n     (NULL_TREE, decay_conversion (tdecl), tree_cons\n@@ -1042,7 +1044,7 @@ expand_attr_desc (tdecl, type)\n \n   mark_used (fn);\n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n-  expand_expr_stmt (fn);\n+  finish_expr_stmt (fn);\n }\n \n /* Build an initializer for a type_info node that just has a name.  */\n@@ -1082,7 +1084,7 @@ expand_generic_desc (tdecl, type, fnname)\n \n   mark_used (fn);\n   fn = build_call (fn, TREE_TYPE (TREE_TYPE (fn)), elems);\n-  expand_expr_stmt (fn);\n+  finish_expr_stmt (fn);\n }\n \n /* Generate the code for a type_info initialization function.\n@@ -1104,6 +1106,9 @@ synthesize_tinfo_fn (fndecl)\n {\n   tree type = TREE_TYPE (DECL_NAME (fndecl));\n   tree tmp, addr, tdecl;\n+  tree compound_stmt;\n+  tree if_stmt;\n+  tree then_clause;\n \n   if (at_eof)\n     {\n@@ -1112,6 +1117,7 @@ synthesize_tinfo_fn (fndecl)\n \treturn;\n     }\n \n+  /* Declare the static typeinfo variable.  */\n   tdecl = get_tinfo_var (type);\n   DECL_EXTERNAL (tdecl) = 0;\n   TREE_STATIC (tdecl) = 1;\n@@ -1120,19 +1126,30 @@ synthesize_tinfo_fn (fndecl)\n   DECL_ALIGN (tdecl) = TYPE_ALIGN (ptr_type_node);\n   cp_finish_decl (tdecl, NULL_TREE, NULL_TREE, 0, 0);\n \n+  /* Begin processing the function.  */\n   start_function (NULL_TREE, fndecl, NULL_TREE, \n \t\t  SF_DEFAULT | SF_PRE_PARSED);\n   store_parm_decls ();\n   clear_last_expr ();\n+\n+  /* Begin the body of the function.  */\n+  compound_stmt = begin_compound_stmt (/*has_no_scope=*/0);\n+\n+  /* For convenience, we save away the address of the static\n+     variable.  Since we will process expression-statements between\n+     here and the end of the function, we must call push_momentary to\n+     keep ADDR from being overwritten.  */\n+  addr = decay_conversion (tdecl);\n   push_momentary ();\n \n   /* If the first word of the array (the vtable) is non-zero, we've already\n      initialized the object, so don't do it again.  */\n-  addr = decay_conversion (tdecl);\n+  if_stmt = begin_if_stmt ();\n   tmp = cp_convert (build_pointer_type (ptr_type_node), addr);\n   tmp = build_indirect_ref (tmp, 0);\n   tmp = build_binary_op (EQ_EXPR, tmp, integer_zero_node);\n-  expand_start_cond (tmp, 0);\n+  finish_if_stmt_cond (tmp, if_stmt);\n+  then_clause = begin_compound_stmt (/*has_no_scope=*/0);\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     expand_generic_desc (tdecl, type, \"__rtti_func\");\n@@ -1167,12 +1184,17 @@ synthesize_tinfo_fn (fndecl)\n   else\n     my_friendly_abort (252);\n \n-  expand_end_cond ();\n+  finish_compound_stmt (/*has_no_scope=*/0, then_clause);\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt ();\n \n   /* OK, now return the type_info object.  */\n   tmp = cp_convert (build_pointer_type (type_info_type_node), addr);\n   tmp = build_indirect_ref (tmp, 0);\n-  c_expand_return (tmp);\n+  finish_return_stmt (tmp);\n+  /* Undo the call to push_momentary above.  */\n   pop_momentary ();\n+  /* Finish the function body.  */\n+  finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n   finish_function (lineno, 0);\n }"}]}