{"sha": "367390404d26b7bfc400d77893579e83e2a19fb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY3MzkwNDA0ZDI2YjdiZmM0MDBkNzc4OTM1NzllODNlMmExOWZiOQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-11-25T03:47:08Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2004-11-25T03:47:08Z"}, "message": "* Merged gcj-abi-2-dev-branch to trunk.\n\n(Actual changes too large to list in the commit message;\nsee ChangeLog.)\n\nFrom-SVN: r91270", "tree": {"sha": "477abdf83653e20b0e74447d6ca47eb67b0511b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/477abdf83653e20b0e74447d6ca47eb67b0511b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/367390404d26b7bfc400d77893579e83e2a19fb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/367390404d26b7bfc400d77893579e83e2a19fb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/367390404d26b7bfc400d77893579e83e2a19fb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/367390404d26b7bfc400d77893579e83e2a19fb9/comments", "author": null, "committer": null, "parents": [{"sha": "ec0641f612862498e829fdaf040a201c0ba68762", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec0641f612862498e829fdaf040a201c0ba68762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec0641f612862498e829fdaf040a201c0ba68762"}], "stats": {"total": 14642, "additions": 11294, "deletions": 3348}, "files": [{"sha": "fc28a08c365dd2cc89b2feece1979ff6ebe54785", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 583, "deletions": 0, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,3 +1,586 @@\n+2004-11-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Merged gcj-abi-2-dev-branch to trunk.\n+\n+2004-11-24  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-parse.c (parse_class_file): Set file_start_location.\n+\n+2004-11-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* class.c (make_field_value): Don't call build_static_field_ref.\n+\t(build_static_field_ref): Don't emit direct references when using\n+\tindirect dispatch.\n+\n+\t* gcj.texi (Invoking gij): Document -verbose.  Put -verbose and\n+\t-verbose:class into man page synopsis.\n+\n+2004-11-09  Tom Tromey  <tromey@redhat.com>\n+\n+\t* expr.c (build_java_arraystore_check): Still generate check if\n+\telement type is itself an array.\n+\n+2004-11-08  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java-tree.h (soft_check_assignment_node): Removed.\n+\t(enum java_tree_index): Removed JTI_SOFT_CHECK_ASSIGNMENT_NODE.\n+\t* decl.c (java_init_decl_processing): Don't initialize\n+\tsoft_check_assignment_node.\n+\n+2004-11-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* class.c (layout_class_methods): Don't add Miranda methods when\n+\tusing indirect dispatch.\n+\n+2004-11-05  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* class.c (make_class_data): Call emit_assertion_table to set the\n+\t'assertion_table' field.\n+\t(build_signature_for_libgcj): Move here from expr.c.\n+\t(add_assertion_table_entry): New function. Callback for assertion\n+\thashtable traversal.\n+\t(emit_assertion_table): New. Take class argument, and generate \n+\tassertion table DECL based on the TYPE_ASSERTIONS hashtable.\n+\t* decl.c (init_decl_processing): Define assertion_entry_type record.\n+\tPush 'assertion_table' class field instead of 'verify'.\n+\t* expr.c (type_assertion_eq): Compare 'assertion_code' field.\n+\t(type_assertion_hash): Include 'assertion_code' in hash.\n+\t(add_type_assertion): Rewritten. Take class and assertion_code\n+\targuments. Add assertions to the TYPE_ASSERTIONS hashtable.\n+\t(can_widen_reference_to): Use new add_type_assertion() arguments.\n+\t* java-tree.h (java_tree_index): Add JTI_ASSERTION_ENTRY_TYPE, \n+\tJTI_ASSERTION_TABLE_TYPE. Remove JTI_VERIFY_IDENTIFIER_NODE.\n+\t(verify_identifier_node): Removed.\n+\t(assertion_entry_type, assertion_table_type): New.\n+\t(ASSERTION_TYPES_COMPATIBLE, ASSERTION_IS_INSTANTIABLE): New. Type\n+\tassertion code definitions.\n+\t(struct type_assertion): Add assertion_code. Rename 'source_type' and\n+\t'target_type' to 'op1' and 'op2'.\n+\t(add_type_assertion): Declare.\n+\t(lang_printable_name_wls): Remove unused definition.\n+\t* verify-glue.c: (vfy_is_assignable_from): New. Call add_type_assertion\n+\tto emit runtime assertion.\n+\t(vfy_note_stack_type): Clean up non-C90 declarations.\n+\t(vfy_note_local_type): Likewise.\n+\t* verify.h (vfy_is_assignable_from): Declare.\n+\t* verify-impl.c (is_assignable_from_slow): Remove unused function.\n+\t(ref_compatible): Rename arguments. Call vfy_is_assignable_from() \n+\tinstead of is_assignable_from_slow().\n+\t(types_compatible): Reinstate ref_compatible() call.\n+\n+2004-11-04  Tom Tromey  <tromey@redhat.com>\n+\n+\t* class.c (build_static_field_ref): Reverted previous patch.\n+\n+\t* class.c (build_static_field_ref): Don't emit direct references\n+\twhen using indirect dispatch.\n+\n+2004-11-03  Tom Tromey  <tromey@redhat.com>\n+\n+\t* expr.c (expand_java_arrayload): Set lhs_type_node.\n+\t(expand_java_arraystore): Set rhs_type_node.\n+\n+2004-11-02  Tom Tromey  <tromey@redhat.com>\n+\n+\t* jcf-parse.c (compute_class_name): Use filename length from zip\n+\tdirectory, not strlen.\n+\n+\t* expr.c (expand_invoke): Mark new interface methods as abstract.\n+\n+2004-11-01  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify-impl.c (push_jump): Removed check for uninitialized\n+\tobjects.\n+\t(push_exception_jump): Likewise.\n+\t(handle_ret_insn): Likewise.\n+\t(handle_jsr_insn): Likewise.\n+\t(state_check_no_uninitialized_objects): Removed.\n+\n+\t* decl.c (check_local_unnamed_variable): Recognize\n+\tpromoted-to-int parameters when using the new verifier.\n+\t* expr.c (expand_java_arraystore): Explicitly request array type\n+\twhen using new verifier.\n+\t(expand_java_arrayload): Likewise.\n+\t(invoke_build_dtable): Don't pass object_type_node as\n+\texpression argument to build_java_indirect_ref.\n+\t(build_java_check_indexed_type): Do nothing.\n+\t(build_java_arraystore_check): Handle case where array doesn't\n+\thave array type.\n+\t(build_java_array_length_access): Likewise.\n+\t(expand_invoke): Handle case where interface overrides a method\n+\tfrom Object.\n+\t(pop_type_0): Always succeed for reference types.\n+\t(process_jvm_instruction): Don't pop a value in a dead\n+\texception handler.\n+\t(pop_arguments): Convert arguments to correct types.\n+\n+2004-10-29  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-parse.c (give_name_to_class): Remove line that was\n+\tincorrectly merged.\n+\n+2004-10-29  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-parse.c (set_source_filename): Add code to build new sfname.\n+\n+2004-10-20  Andrew Haley  <aph@redhat.com>\n+\n+\t* decl.c (end_java_method): Don't expand if flag_syntax_only.\n+\n+2004-10-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.h (vfy_notify_verified): Removed.\n+\t* verify-glue.c (vfy_notify_verified): Removed.\n+\n+2004-10-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify-impl.c (debug_print_state): Declare `i' before code.\n+\t(merge_types): Modify `t' when it is null_type.\n+\n+2004-10-26  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify-impl.c (type_print): Renamed from print.  Now static and\n+\ttakes an argument.\n+\t(debug_print_state): Use type_print.\n+\n+2004-10-25  Tom Tromey  <tromey@redhat.com>\n+\n+\t* expr.c (build_invokeinterface): Compute correct offset for\n+\tindex into interface methods.\n+\n+2004-10-20  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java-tree.h (verify_jvm_instructions_new): Declare.\n+\n+\t* jvspec.c (jvgenmain_spec): Remove -fnew-verifier from cc1\n+\tcommand line.\n+\n+\t* verify-impl.c (verify_instructions): Correctly handle wide\n+\ttypes on the stack.\n+\t* verify-glue.c (vfy_get_class_name): Use DECL_NAME.\n+\t(vfy_get_component_type): Strip pointer types.\n+\t(vfy_find_class): Use get_type_from_signature.  Strip pointer\n+\ttypes.\n+\tInclude java-except.h.\n+\n+2004-10-20  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* verify-impl.c (type_array_elementpop_raw, vfy_pop_type_t, \n+\tvfy_push_type_t, set_variable, add_new_state, merge_into,\n+\thandle_jsr_insn, branch_prepass, check_class_constant,\n+\tcheck_wide_constant, get_one_type, compute_static_types, \n+\tverify_instructions_0): Clean up C99 declarations after statements.\n+\n+2004-10-20  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify-impl.c (merge_refs): Compare reference against iterator,\n+\tnot ref2.\n+\n+\t* verify-glue.c (vfy_tag): Mask off resolved flag.\n+\n+2004-10-19  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify-impl.c (verify_instructions): Call vfy_note_local_type.\n+\t(init_state_with_stack): Initialize `this_type' in state.\n+\t(verify_method): Use debug_print.\n+\t* verify-glue.c (vfy_is_primitive): Removed debugging print.\n+\t(vfy_note_stack_depth): Reverted last patch.\n+\t(vfy_note_stack_type): Note pointer to Object, not Object.\n+\t(vfy_note_local_type): Likewise.\n+\n+\t* verify.h (vfy_note_instruction_seen): Declare.\n+\t* verify-glue.c (verify_jvm_instructions_new): Set\n+\tBCODE_EXCEPTION_TARGET on target instruction.\n+\t(vfy_note_instruction_seen): New function.\n+\t* verify-impl.c (FLAG_INSN_SEEN): New define.\n+\t(verify_instructions_0): Set flag on instruction.  Save state for\n+\tPC=0 later.\n+\t(verify_instructions): Call vfy_note_instruction_seen.\n+\n+\t* verify-glue.c (vfy_note_stack_depth): Fix off-by-one error.\n+\t(verify_jvm_instructions_new): Call method_init_exceptions,\n+\tadd_handler, and handle_nested_ranges.\n+\t* verify-impl.c (verify_method): Return 1 on success.\n+\t(verify_instructions_0): Save the state at PC=0.\n+\n+\t* verify-impl.c (init_type_from_class): Set is_resolved and\n+\tref_next on new ref_intersection.\n+\t(init_type_from_string): Likewise.\n+\n+2004-10-15  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* expr.c (expand_bytecode): Use verify_jvm_instructions_new\n+\tif flag_new_verifier is set.\n+\t* java-tree.h (flag_new_verifier): Declare.\n+\t* lang.opt (fnew-verifier): New option.\n+\t* verify-impl.c: Work around namespace pollution by undef'ing \n+\t'current_class'.\n+\t(struct verifier_context): Make 'bytecode' const.\n+\t(verify_fail_pc): Pass -1 PC argument to vfy_fail.\n+\t(types_compatible): For the BC-ABI, always consider reference types\n+\tcompatible.\n+\t(check_class_constant): Use vfr->current_class.\n+\t(check_constant): Likewise.\n+\t(check_wide_constant): Likewise.\n+\t(check_field_constant): Check for 'L' at start of type name.\n+\t(get_one_type): Return pointer instead of type. Set type result in\n+\tcaller via passed type pointer.\n+\t(compute_argument_types): Update to use new get_one_type arguments.\n+\t(compute_return_type): Likewise.\n+\t(make_verifier_context): New. Allocate and initialize 'vfr'.\n+\t(free_verifier_context): New. Free 'vfr' and its contents.\n+\t(verify_method): Remove ATTRIBUTE_UNUSED. Call make_verifier_context\n+\tand free_verifier_context.\n+\n+2004-10-15  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify-glue.c (vfy_note_local_type): Mark argument as unused.\n+\t* verify.h (vfy_fail): Fixed formatting.\n+\n+\t* verify-impl.c (vfr): Fixed comment formatting.\n+\t(collapse_type): New function.\n+\t(verify_instructions): Notify compiler about type map.\n+\t* verify.h (vfy_note_stack_depth): Updated.\n+\t(vfy_note_stack_type): Likewise.\n+\t(vfy_note_local_type): Likewise.\n+\t(vfy_unsuitable_type, vfy_return_address_type, vfy_null_type):\n+\tDeclare.\n+\t* verify-glue.c (vfy_note_stack_depth): Correctly size type\n+\tstate.  Added `method' argument.\n+\t(vfy_note_stack_type): Renamed from vfy_note_type.  Added `method'\n+\targument.\n+\t(vfy_note_local_type): New function.\n+\t(vfy_unsuitable_type): Likewise.\n+\t(vfy_return_address_type): Likewise.\n+\t(vfy_null_type): Likewise.\n+\n+\t* verify.h (VFY_IN_GCC): Removed.\n+\t(VFY_WANT_TYPEMAP): Removed.\n+\t* verify-impl.c (verify_instructions_0): Removed useless \"\\\".\n+\t(struct state) <next>: Uncomment.\n+\n+2004-10-13  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* verify-impl.c: Formatting fixes. Reformat C++-style comments to \n+\tC-style.\n+\n+2004-10-06  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* Make-lang.in (verify.o): Re-enabled this target.\n+\t* verify-glue.c (vfy_get_interface_count): Add ATTRIBUTE_UNUSED.\n+\t(vfy_get_interface): Likewise.\n+\t(verify_jvm_instructions_new): Renamed from verify_jvm_instructions.\n+\t* verify.h (verify_jvm_instructions_new): Declare.\n+\t* verify-impl.c (free_state): Temporarily comment out unused\n+\tfunction.\n+\n+2004-10-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java-tree.h (JV_STATE_READ): New enum value.\n+\n+2004-10-06  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* verify.h: New file.\n+\n+2004-10-05  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* verify-impl.c, verify-glue.c, verify.h: New files.\n+\t* Make-lang.in: Add rules for verify-impl.o and verify-glue.o.\n+\n+2004-09-24  Andrew Haley  <aph@redhat.com>\n+\n+\t* decl.c (check_local_unnamed_variable): Always use the PARM_DECL\n+\tfor a slot if it's of pointer type.\n+\n+2004-09-14  Tom Tromey  <tromey@redhat.com>\n+\n+\t* class.c (make_class_data): Correctly initialize \"state\" field.\n+\tInitialize \"engine\" field.\n+\t* decl.c (java_init_decl_processing): Add \"engine\" field.\n+\n+2004-09-10  Andrew Haley  <aph@redhat.com>\n+\n+\tPR java/12760\n+\t* expr.c (build_invokeinterface): Use fast method for interface\n+\tdispatch.\n+\t* java-tree.h (enum java_tree_index): Add JTI_ITABLE_TYPE,\n+\tJTI_ITABLE_PTR_TYPE.\n+\t(struct lang_type): Add  itable_methods, itable_decl, itable_syms_decl.\n+\t(emit_symbol_table): Add new arg, element_size.\n+\t* decl.c (java_init_decl_processing): Initialize Class.itable.\n+\t* class.c (GEN_TABLE): New macro.\n+\t(gen_indirect_dispatch_tables): Use it.  Add itable.\n+\t(make_class_data): Add new arg for emit_symbol_table().\n+\tEmit itable.\n+\t(add_miranda_methods): Make sure search_class has been parsed.\n+\t(emit_symbol_table): Add new arg, element_size.\n+\n+2004-09-06  Andrew Haley  <aph@redhat.com>\n+\n+\t* verify.c (merge_types): Return Object for all merges of\n+\tinterfaces.\n+\t* expr.c (add_type_assertion): Don't generate assertions when\n+\tsource type is array of Object.\n+\t\t\n+2004-09-03  Andrew Haley  <aph@redhat.com>\n+\n+\t* class.c (finish_class): Nullify TYPE_VERIFY_METHOD.\n+\n+\t* lang.c (java_post_options): Force flag_verify_invocations if\n+\twe're not using indirect dispatch.\n+\n+\t* expr.c (pop_type_0): Move test for interfaces before call to\n+\tcan_widen_reference_to().\n+\t(build_signature_for_libgcj): Remove generation of canonical array\n+\ttype.\n+\t(add_type_assertion): Canonicalize both arrays.\n+\tDon't assert that type X can be assigned to Object.\n+\tDon't assert that type X an be assigned to type X.\n+\tDon't assert that Object can be assigned to type X.\n+\t(can_widen_reference_to): Warn whenever we generate an assertion.\n+\t(process_jvm_instruction): Use throwable_type_node for the type of\n+\tan exception class.\n+\n+2004-09-01  Andrew Haley  <aph@redhat.com>\n+\n+\t* decl.c (java_init_decl_processing): Change\n+\tverify_identifier_node to \"__verify\".\n+\t* expr.c (add_type_assertion): Use verify_identifier_node for name.\n+\t* java-tree.h (verify_identifier_node): Change to \"__verify\".\n+\n+\t* expr.c (build_signature_for_libgcj): New function.\n+\t(add_type_assertion): Use it to construct signatures for\n+\tsource_type and target_type.\n+\n+2004-08-27  Andrew Haley  <aph@redhat.com>\n+\n+\t* java-tree.h (enum java_tree_index): Add JTI_VERIFY_IDENTIFIER_NODE.\n+\t(verify_identifier_node): New.\n+\t(TYPE_VERIFY_METHOD): New.\n+\t(struct type_assertion): New type.\n+\t* expr.c (type_assertion_eq): New function.\n+\t(type_assertion_hash): New function.\n+\t(add_type_assertion): New function.\n+\t(can_widen_reference_to): Call add_type_assertion().\n+\t* decl.c (java_init_decl_processing): Add verify_identifier_node.\n+\t* class.c (make_class_data): Initialize TYPE_VERIFY_METHOD (type).\n+\t(finish_class): Output TYPE_VERIFY_METHOD (type).\n+\n+\t* decl.c (end_java_method): Nullify unused fields.\n+\n+2004-08-17  Andrew Haley  <aph@redhat.com>\n+\n+\t* verify.c (defer_merging): Quieten.\n+\t* jcf-parse.c (load_class): Only try to open a class file if it's\n+\tjava.lang.Object or if it's part of the current compilation.\n+\tCheck that the class we just tried to load is the class we just\n+\tloaded.  Quieten.\n+\t(java_parse_file): Set flag_verify_invocations off if we're\n+\tcompiling from .class.\n+\t(parse_zip_file_entries): Abort if we try to read a dummy class.\n+\t* expr.c (can_widen_reference_to): Quieten.\n+\t(build_invokevirtual): Abort if we try to invokevirtual an\n+\tinterface.\n+\t(expand_invoke): Don't build a non-interface call to an interface.\n+\t(build_instanceof): Don't do premature optimization if\n+\tflag_verify_invocations is not set.\n+\t* class.c (set_super_info): Disable code that inherits TYPE_DUMMY\n+\tfrom superclass.\n+\t(build_static_field_ref): Add correct type conversion for\n+\tfield_address.\n+\t(add_miranda_methods): Disable generation of Miranda methods for\n+\tdummy classes.\n+\t(layout_class_method): Don't complain about non-static method\n+\toverrides static method with dummy classes.\n+\n+2004-08-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* class.c (build_static_field_ref): Re-enable atable lookups for\n+\tstatic fields.\n+\n+\t* parse.y (strip_out_static_field_access_decl): Indentation fix.\n+\n+2004-08-11  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj.texi (libgcj Runtime Properties): Document new properties.\n+\n+2004-08-06  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-parse.c (load_class): Check that we really have loaded the\n+\tclass we're looking for.\n+\n+2004-07-19  Andrew Haley  <aph@redhat.com>\n+\n+\t* verify.c (verify_jvm_instructions): Comment change only.\n+\n+\t* typeck.c (build_java_array_type): Add size field to array name.\n+\n+\t* java-tree.h (LOCAL_SLOT_P): New.\n+\t(update_aliases): Add PC argument.\n+\t(pushdecl_function_level): New function.\n+\n+\t* java-gimplify.c (java_gimplify_expr): Handle VAR_DECL,\n+\tMODIFY_EXPR, and SAVE_EXPR.\n+\t(java_gimplify_modify_expr): New function.\n+\n+\t* expr.c (push_type_0): Call find_stack_slot() to create temporary.\n+\t(expand_iinc): Pass PC to update_aliases().\n+\t(STORE_INTERNAL): Likewise.\n+\t(process_jvm_instruction): Likewise.\n+\n+\t* decl.c (base_decl_map): New variable.\n+\t(uniq): New variable.\n+\t(update_aliases): Rewrite with more thorough checking.\n+\t(debug_variable_p): New function.\n+\t(push_jvm_slot): Don't initialize local variable.  Don't pushdecl.\n+\t(check_local_named_variable): Delete whole function.\n+\t(initialize_local_variable): New function.\n+\t(check_local_unnamed_variable): Add checks and comments.\n+\t(find_local_variable): Rewrite.\n+\t(java_replace_reference): New function.\n+\t(function_binding_level): New variable.\n+\t(pushdecl_function_level): New function.\n+\t(maybe_pushlevels): Set DECL_LOCAL_END_PC.\n+\t(maybe_pushlevels): Call pushdecl() on each of the new decls.\n+\t(start_java_method): Reset uniq.  Create base_decl_map.  Set\n+\tfunction_binding_level.\n+\t(end_java_method): Null unused fields to save memory.\n+\n+2004-06-29  Andrew Haley  <aph@redhat.com>\n+\n+\t* except.c (expand_start_java_handler): Push a new binding level.\n+\tDon't build a TRY_CATCH_EXPR now, we'll do it later.  Call\n+\tregister_exception_range() to register where we'll do it.\n+\t(expand_end_java_handler): Remove old bogus code.  Replace with\n+\tnew logic that simply builds TRY_CATCH_EXPRs and inserts them at\n+\tthe top of the expression we're curently building.\n+\t(maybe_end_try): Delete.\n+\t* decl.c (binding_level.exception_range): New field.\n+\t(clear_binding_level): Add field exception_range.  Reformat.\n+\t(poplevel): Call expand_end_java_handler().\n+\t(poplevel): Call java_add_stmt only if functionbody is false.\n+\t(maybe_poplevels): Don't call maybe_end_try() from here.\n+\t(end_java_method): Clear no longer used trees in function decl.\n+\t(register_exception_range): New function.\n+\t* java-tree.h (register_exception_range, struct eh_range): Declare.\n+\n+2004-06-22  Andrew Haley  <aph@redhat.com>\n+\n+\t* class.c (gen_indirect_dispatch_tables): Set the DECL_OWNER of\n+\tthe otable.\n+\t* check-init.c (get_variable_decl): Teach check-init about\n+\tFIELD_DECLs addressed via the otable.\n+\t* jcf-parse.c (load_class): Check CLASS_LOADED_P, not\n+\tCLASS_PARSED_P.\n+\n+2004-05-28  Andrew Haley  <aph@redhat.com>\n+\n+\t* jcf-parse.c (load_class): Don't try to read a class that we've\n+\talready read.\n+\n+\t* expr.c (build_invokeinterface): Use the old-fashioned way of\n+\tdoing indirect dispatch: look up interfaces by name.\n+\t* java-tree.h (enum java_tree_index): Add\n+\tJTI_SOFT_LOOKUPINTERFACEMETHODBYNAME_NODE\n+\t* decl.c (java_init_decl_processing): Add\n+\tsoft_lookupinterfacemethodbyname_node.\n+\n+\t* gjavah.c (print_method_info): Final methods have vtable entries,\n+\tso gjavah needs to output them. \n+\t* class.c (layout_class_method): Generate vtable entries for final\n+\tmethods.\n+\t* parse.y (invocation_mode): Use INVOKE_VIRTUAL for indirect\n+\tdispatch, even if a method is final.\n+\n+2004-05-25  Andrew Haley  <aph@redhat.com>\n+\n+\t* class.c (build_symbol_entry): Convert the names of constructors\n+\tto init_identifier_node when generating an entry for the indirect\n+\tdispatch table.\n+\t\n+\t* expr.c (build_known_method_ref): Generate indirect calls for\n+\tall methods marked DECL_EXTERNAL or TREE_PUBLIC.\n+\n+2004-05-24  Andrew Haley  <aph@redhat.com>\n+\n+        * expr.c (build_known_method_ref): Make sure ARRAY_REF access to\n+        atable element is of the right type.\n+\n+        * class.c (build_static_field_ref): Cast pointer to correct type\n+        for field.\n+\n+2004-04-20  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* Merged with HEAD as of 20040514. Diff against\n+\tgcj-abi-2-merge-20040514.\n+\n+2004-04-16  Andrew Haley  <aph@redhat.com>\n+\n+\t* verify.c (check_pending_block): Disable subroutine checks.\n+\t(defer_merging): New function.\n+\t(merge_types): If types are dummy, use defer_merging to combine them.\n+\t(verify_jvm_instructions): If invocation is invokeinterface and\n+\ttarget is dummy, assume target really is an interface.\n+\n+\t* parse.y (patch_invoke): Break out call to java_create_object.\n+\n+\t* lang.c (flag_verify_invocations): New.\n+\n+\t* jcf-parse.c (load_class): If we've already failed to load a\n+\tclass, don't try again.\n+\t(load_class): If we can't find a .class file, don't fail, but emit\n+\ta warning.\n+\t(parse_class_file): Don't act on dummy methods.\n+\n+\t* java-tree.h (flag_verify_invocations): New.\n+\t(TYPE_DUMMY): New.\n+\t(lang_type.dummy_class): New field.\n+\t(java_create_object): New function.\n+\t(METHOD_DUMMY): New.\n+\n+\t* expr.c (build_field_ref): Widen field offset.\n+\t(pop_type_0): If the type in stack_type_map is a TREE_LIST, check\n+\tthat each of its elements is compatible with the one we're\n+\tpopping.\n+\t(pop_type_0): Issue a warning to say that we need to generate a\n+\truntime check.\n+\t(java_create_object): New function.\n+\t(build_field_ref): Only generate hard refs if we're not using\n+\tindirect dispatch.\n+\t(expand_java_field_op): If we're using !verify_invocations and we\n+\tsee a missing field, generate a decl for it.\n+\n+\t(expand_invoke): If a class doesn't have the method we seek and\n+\twe're using !flag_verify_invocations, generate a decl for the\n+\tmethod now.\n+\n+\t(build_known_method_ref): Always use indirect dispatch via the\n+\tatable for static methods.\n+\n+\t(expand_java_NEW): Break out object creation into new function,\t\n+\tjava_create_object.\n+\n+\t(can_widen_reference_to): Issue a warning to say that we need to\n+\tgenerate a runtime check.\n+\n+\t* class.c (set_super_info): Inherit TYPE_DUMMY from sureclass.\n+\t(make_method_value): Also use index for interfaces.\n+\t(make_class_data): Skip dummy field for inherited data.\n+\tDon't build method array for dummy methods.\n+\tSet size_in_byte to -1 when using inirect dispatch\n+\tDon't build a hard class ref if we don't have a hard ref to our\n+\tsuperclass, or if we're using inirect dispatch.\n+\tNull out dispatch tables.\n+\n+\t(layout_class_method): Don't complain about non-static method\n+\toverrides static method is method is artificial.\n+\n+\t(build_static_field_ref): Disable atable references to static\n+\tfields for the time being.\n+\n+\t(layout_class_methods): Check for CLASS_INTERFACE as\n+\twell as CLASS_ABSTRACT.\n+\n 2004-11-24  Steven Bosscher  <stevenb@suse.de>\n \n \t* class.c (make_class_data): Don't check flag_inline_functions."}, {"sha": "16094b9c28b7a0c2f922c9b0ac3af14baeffeed7", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -102,6 +102,7 @@ gt-java-builtins.h gtype-java.h gt-java-resource.h : s-gtype ; @true\n # Executables built by this Makefile:\n JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n   java/constants.o java/lang.o java/typeck.o java/except.o java/verify.o \\\n+  java/verify-glue.o java/verify-impl.o \\\n   java/zextract.o java/jcf-io.o java/win32-host.o java/jcf-parse.o java/mangle.o \\\n   java/mangle_name.o java/builtins.o java/resource.o \\\n   java/jcf-write.o java/buffer.o java/check-init.o java/jcf-depend.o \\\n@@ -338,6 +339,10 @@ java/win32-host.o: java/win32-host.c $(CONFIG_H) $(SYSTEM_H) coretypes.h java/jc\n java/verify.o: java/verify.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   java/javaop.h java/java-opcodes.h java/java-except.h toplev.h $(SYSTEM_H) \\\n   coretypes.h $(TM_H)\n+java/verify-glue.o: java/verify-glue.c $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H) \\\n+  coretypes.h $(TM_H) java/verify.h\n+java/verify-impl.o: java/verify-impl.c $(CONFIG_H) java/verify.h $(SYSTEM_H) \\\n+  coretypes.h  java/jcf.h $(JAVA_TREE_H)\n java/xref.o: java/xref.c java/xref.h $(CONFIG_H) $(JAVA_TREE_H) toplev.h \\\n   $(SYSTEM_H) coretypes.h $(TM_H)\n java/zextract.o: java/zextract.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\"}, {"sha": "05692b0a4c208c039d99ed229b5c7c2244983ad0", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -36,7 +36,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n /* The basic idea is that we assign each local variable declaration\n    and each blank final field an index, and then we pass around\n    bitstrings, where the (2*i)'th bit is set if decl whose DECL_BIT_INDEX\n-   is i is definitely assigned, and the (2*i+1)'th bit is set if \n+   is i is definitely assigned, and the the (2*i=1)'th bit is set if \n    decl whose DECL_BIT_INDEX is i is definitely unassigned */\n \n /* One segment of a bitstring. */\n@@ -45,7 +45,7 @@ typedef unsigned int word;\n /* Pointer to a bitstring. */\n typedef word *words;\n \n-/* Number of local variables currently active. */\n+/* Number of locals variables currently active. */\n static int num_current_locals = 0;\n \n /* The value of num_current_locals when we entered the closest\n@@ -191,6 +191,50 @@ get_variable_decl (tree exp)\n \t    return op1;\n \t}\n     }\n+  else if (TREE_CODE (exp) == INDIRECT_REF)\n+    {\n+      /* For indirect dispatch, look for an expression of the form \n+      (indirect_ref (+ (array_ref otable <N>) this)).  \n+      FIXME: it would probably be better to generate a JAVA_FIELD_REF\n+      expression that gets converted to OTABLE access at\n+      gimplification time.  */\n+      exp = TREE_OPERAND (exp, 0);\n+      if (TREE_CODE (exp) == PLUS_EXPR)\n+\t{\n+\t  tree op0 = TREE_OPERAND (exp, 0);\n+\t  STRIP_NOPS (op0);\n+\t  if (TREE_CODE (op0) == ARRAY_REF)\n+\t    {\n+\t      tree table = TREE_OPERAND (op0, 0);\n+\t      if (TREE_CODE (table) == VAR_DECL\n+\t\t  && DECL_LANG_SPECIFIC (table)\n+\t\t  && DECL_OWNER (table) \n+\t\t  && TYPE_OTABLE_DECL (DECL_OWNER (table)) == table)\n+\t\t{\n+\t\t  HOST_WIDE_INT index \n+\t\t    = TREE_INT_CST_LOW (TREE_OPERAND (op0, 1));\n+\t\t  tree otable_methods \n+\t\t    = TYPE_OTABLE_METHODS (DECL_OWNER (table));\n+\t\t  tree element;\n+\t\t  for (element = otable_methods; \n+\t\t       element; \n+\t\t       element = TREE_CHAIN (element))\n+\t\t    {\n+\t\t      if (index == 1)\n+\t\t\t{\n+\t\t\t  tree purpose = TREE_PURPOSE (element);\n+\t\t\t  if (TREE_CODE (purpose) == FIELD_DECL)\n+\t\t\t    return purpose;\n+\t\t\t  else\n+\t\t\t    return NULL_TREE;\n+\t\t\t}\n+\t\t      --index;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   return NULL_TREE;\n }\n \n@@ -306,7 +350,7 @@ check_bool2_init (enum tree_code code, tree exp0, tree exp1,\n /* Check a boolean expression EXP for definite [un]assignment.\n    BEFORE is the set of variables definitely [un]assigned before the\n    conditional.  (This bitstring may be modified arbitrarily in this function.)\n-   On output, WHEN_FALSE is the set of variables definitely [un]assigned after\n+   On output, WHEN_FALSE is the set of variables [un]definitely assigned after\n    the conditional when the conditional is false.\n    On output, WHEN_TRUE is the set of variables definitely [un]assigned after\n    the conditional when the conditional is true.\n@@ -432,8 +476,8 @@ done_alternative (words after, struct alternatives *current)\n \t      WORDS_NEEDED (2 * current->num_locals));\n }\n \n-/* Used when we are done with a control flow branch and are all merged again.\n-   AFTER is the merged state of [un]assigned variables,\n+/* Used when we done with a control flow branch and are all merged again.\n+ * AFTER is the merged state of [un]assigned variables,\n    CURRENT is a struct alt that was passed to BEGIN_ALTERNATIVES. */\n \n #define END_ALTERNATIVES(after, current) \\\n@@ -445,7 +489,7 @@ done_alternative (words after, struct alternatives *current)\n   start_current_locals = current.save_start_current_locals; \\\n }\n \n-/* Check for [un]initialized local variables in EXP.  */\n+/* Check for (un)initialized local variables in EXP.  */\n \n static void\n check_init (tree exp, words before)\n@@ -460,7 +504,7 @@ check_init (tree exp, words before)\n \t  && DECL_NAME (exp) != this_identifier_node)\n \t{\n \t  int index = DECL_BIT_INDEX (exp);\n-\t  /* We don't want to report and mark as non-initialized class\n+\t  /* We don't want to report and mark as non initialized class\n \t     initialization flags. */\n \t  if (! LOCAL_CLASS_INITIALIZATION_FLAG_P (exp)\n \t      && index >= 0 && ! ASSIGNED_P (before, index))\n@@ -604,7 +648,7 @@ check_init (tree exp, words before)\n \t   \"hypothetical\" analysis model.  We do something much\n \t   simpler: We just disallow assignments inside loops to final\n \t   variables declared outside the loop.  This means we may\n-\t   disallow some contrived assignments that the JLS allows, but I\n+\t   disallow some contrived assignments that the JLS, but I\n \t   can't see how anything except a very contrived testcase (a\n \t   do-while whose condition is false?) would care. */\n "}, {"sha": "391752ad271c63eae40be7517aa43d3dc0393c87", "filename": "gcc/java/class.c", "status": "modified", "additions": 262, "deletions": 87, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -43,6 +43,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"stdio.h\"\n #include \"target.h\"\n #include \"except.h\"\n+#include \"cgraph.h\"\n #include \"tree-iterator.h\"\n \n /* DOS brain-damage */\n@@ -61,6 +62,7 @@ static tree maybe_layout_super_class (tree, tree);\n static void add_miranda_methods (tree, tree);\n static int assume_compiled (const char *);\n static tree build_symbol_entry (tree);\n+static tree emit_assertion_table (tree);\n \n struct obstack temporary_obstack;\n \n@@ -342,6 +344,34 @@ unmangle_classname (const char *name, int name_length)\n   return to_return;\n }\n \n+#define GEN_TABLE(TABLE, NAME, TABLE_TYPE, TYPE)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  const char *typename = IDENTIFIER_POINTER (mangled_classname (\"\", TYPE)); \\\n+  char *buf = alloca (strlen (typename) + strlen (#NAME \"_syms_\") + 1);\t\\\n+  tree decl;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  sprintf (buf, #NAME \"_%s\", typename);\t\t\t\t\t\\\n+  TYPE_## TABLE ##_DECL (type) = decl =\t\t\t\t\t\\\n+    build_decl (VAR_DECL, get_identifier (buf), TABLE_TYPE);\t\t\\\n+  DECL_EXTERNAL (decl) = 1;\t\t\t\t\t\t\\\n+  TREE_STATIC (decl) = 1;\t\t\t\t\t\t\\\n+  TREE_READONLY (decl) = 1;\t\t\t\t\t\t\\\n+  TREE_CONSTANT (decl) = 1;\t\t\t\t\t\t\\\n+  DECL_IGNORED_P (decl) = 1;\t\t\t\t\t\t\\\n+  /* Mark the table as belonging to this class.  */\t\t\t\\\n+  pushdecl (decl);\t\t\t\t\t\t\t\\\n+  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\t\t\t\t\\\n+  DECL_OWNER (decl) = TYPE;\t\t\t\t\t\t\\\n+  sprintf (buf, #NAME \"_syms_%s\", typename);\t\t\t\t\\\n+  TYPE_## TABLE ##_SYMS_DECL (TYPE) =\t\t\t\t\t\\\n+    build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\t\\\n+  TREE_STATIC (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\t\\\n+  TREE_CONSTANT (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\\\n+  DECL_IGNORED_P (TYPE_## TABLE ##_SYMS_DECL (TYPE)) = 1;\t\t\\\n+  pushdecl (TYPE_## TABLE ##_SYMS_DECL (TYPE));\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+while (0)\n \n /* Given a class, create the DECLs for all its associated indirect\n    dispatch tables.  */\n@@ -372,54 +402,14 @@ gen_indirect_dispatch_tables (tree type)\n \n   if (flag_indirect_dispatch)\n     {\n-      {\n-\tchar *buf = alloca (strlen (typename) + strlen (\"_otable_syms_\") + 1);\n-\n-\tsprintf (buf, \"_otable_%s\", typename);\n-\tTYPE_OTABLE_DECL (type) = \n-\t  build_decl (VAR_DECL, get_identifier (buf), otable_type);\n-\tDECL_EXTERNAL (TYPE_OTABLE_DECL (type)) = 1;\n-\tTREE_STATIC (TYPE_OTABLE_DECL (type)) = 1;\n-\tTREE_READONLY (TYPE_OTABLE_DECL (type)) = 1;\n-\tTREE_CONSTANT (TYPE_OTABLE_DECL (type)) = 1;\n-\tDECL_IGNORED_P (TYPE_OTABLE_DECL (type)) = 1;\n-\tpushdecl (TYPE_OTABLE_DECL (type));  \n-\tsprintf (buf, \"_otable_syms_%s\", typename);\n-\tTYPE_OTABLE_SYMS_DECL (type) = \n-\t  build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\n-\tTREE_STATIC (TYPE_OTABLE_SYMS_DECL (type)) = 1;\n-\tTREE_CONSTANT (TYPE_OTABLE_SYMS_DECL (type)) = 1;\n-\tDECL_IGNORED_P(TYPE_OTABLE_SYMS_DECL (type)) = 1;\n-\tpushdecl (TYPE_OTABLE_SYMS_DECL (type));\n-      }\n-\n-      {\n-\tchar *buf = alloca (strlen (typename) + strlen (\"_atable_syms_\") + 1);\n-\ttree decl;\n-\n-\tsprintf (buf, \"_atable_%s\", typename);\n-\tTYPE_ATABLE_DECL (type) = decl =\n-\t  build_decl (VAR_DECL, get_identifier (buf), atable_type);\n-\tDECL_EXTERNAL (decl) = 1;\n-\tTREE_STATIC (decl) = 1;\n-\tTREE_READONLY (decl) = 1;\n-\tTREE_CONSTANT (decl) = 1;\n-\tDECL_IGNORED_P (decl) = 1;\n-\t/* Mark the atable as belonging to this class.  */\n-\tpushdecl (decl);  \n-\tMAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n-\tDECL_OWNER (decl) = type;\n-\tsprintf (buf, \"_atable_syms_%s\", typename);\n-\tTYPE_ATABLE_SYMS_DECL (type) = \n-\t  build_decl (VAR_DECL, get_identifier (buf), symbols_array_type);\n-\tTREE_STATIC (TYPE_ATABLE_SYMS_DECL (type)) = 1;\n-\tTREE_CONSTANT (TYPE_ATABLE_SYMS_DECL (type)) = 1;\n-\tDECL_IGNORED_P (TYPE_ATABLE_SYMS_DECL (type)) = 1;\n-\tpushdecl (TYPE_ATABLE_SYMS_DECL (type));\n-      }\n+      GEN_TABLE (ATABLE, _atable, atable_type, type);\n+      GEN_TABLE (OTABLE, _otable, otable_type, type);\n+      GEN_TABLE (ITABLE, _itable, itable_type, type);\n     }\n }\n \n+#undef GEN_TABLE\n+\n tree\n push_class (tree class_type, tree class_name)\n {\n@@ -959,7 +949,7 @@ build_class_ref (tree type)\n \t we always emit this hard superclass reference.  */\n       if  (flag_indirect_dispatch\n \t   && type != output_class\n-\t   && type != CLASSTYPE_SUPER (output_class)\n+// \t   && type != CLASSTYPE_SUPER (output_class)\n \t   && TREE_CODE (type) == RECORD_TYPE)\n \treturn build_indirect_class_ref (type);\n \n@@ -1062,8 +1052,7 @@ build_static_field_ref (tree fdecl)\n      However, currently sometimes gcj is too eager and will end up\n      returning the field itself, leading to an incorrect external\n      reference being generated.  */\n-  if ((is_compiled \n-       && (! flag_indirect_dispatch || current_class == fclass))\n+  if ((is_compiled && !flag_indirect_dispatch)\n       || (FIELD_FINAL (fdecl) && DECL_INITIAL (fdecl) != NULL_TREE\n \t  && (JSTRING_TYPE_P (TREE_TYPE (fdecl))\n \t      || JNUMERIC_TYPE_P (TREE_TYPE (fdecl)))\n@@ -1084,16 +1073,19 @@ build_static_field_ref (tree fdecl)\n \t= build_int_cst (NULL_TREE, get_symbol_table_index \n \t\t\t (fdecl, &TYPE_ATABLE_METHODS (output_class)));\n       tree field_address\n-\t= build4 (ARRAY_REF, build_pointer_type (TREE_TYPE (fdecl)), \n+\t= build4 (ARRAY_REF, \n+\t\t  TREE_TYPE (TREE_TYPE (TYPE_ATABLE_DECL (output_class))), \n \t\t  TYPE_ATABLE_DECL (output_class), table_index,\n \t\t  NULL_TREE, NULL_TREE);\n+      field_address = convert (build_pointer_type (TREE_TYPE (fdecl)),\n+\t\t\t       field_address);\n       return fold (build1 (INDIRECT_REF, TREE_TYPE (fdecl), \n \t\t\t   field_address));\n     }\n   else  \n     {\n       /* Compile as:\n-       * *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr */\n+       *(FTYPE*)build_class_ref(FCLASS)->fields[INDEX].info.addr */\n       tree ref = build_class_ref (fclass);\n       tree fld;\n       int field_index = 0;\n@@ -1117,7 +1109,7 @@ build_static_field_ref (tree fdecl)\n \t\t\t  ref, build_int_cst (NULL_TREE, field_index)));\n       ref = build1 (INDIRECT_REF, field_type_node, ref);\n       ref = build3 (COMPONENT_REF, field_info_union_node,\n-\t\t    ref, lookup_field (&field_type_node, info_ident),\n+\t\t    ref, lookup_field (&field_type_node, info_ident), \n \t\t    NULL_TREE);\n       ref = build3 (COMPONENT_REF, ptr_type_node,\n \t\t    ref, TREE_CHAIN (TYPE_FIELDS (field_info_union_node)),\n@@ -1284,7 +1276,7 @@ make_field_value (tree fdecl)\n \t      ? TREE_CHAIN (TYPE_FIELDS (field_info_union_node))\n \t      : TYPE_FIELDS (field_info_union_node)),\n \t     (FIELD_STATIC (fdecl)\n-\t      ? build_address_of (build_static_field_ref (fdecl))\n+\t      ? build_address_of (fdecl)\n \t      : byte_position (fdecl)))));\n \n   FINISH_RECORD_CONSTRUCTOR (finit);\n@@ -1565,7 +1557,9 @@ make_class_data (tree type)\n \n   /* Build Field array. */\n   field = TYPE_FIELDS (type);\n-  if (DECL_NAME (field) == NULL_TREE)\n+  while (field && DECL_ARTIFICIAL (field))\n+    field = TREE_CHAIN (field);  /* Skip dummy fields.  */\n+  if (field && DECL_NAME (field) == NULL_TREE)\n     field = TREE_CHAIN (field);  /* Skip dummy field for inherited data. */\n   for ( ;  field != NULL_TREE;  field = TREE_CHAIN (field))\n     {\n@@ -1620,6 +1614,11 @@ make_class_data (tree type)\n \t  && ! flag_keep_inline_functions\n \t  && optimize)\n \tcontinue;\n+      /* Even if we have a decl, we don't necessaily have the code.\n+\t This can happen if we inherit a method from a superclass for\n+\t which we don't have a .class file.  */\n+      if (METHOD_DUMMY (method))\n+\tcontinue;\n       init = make_method_value (method);\n       method_count++;\n       methods = tree_cons (NULL_TREE, init, methods);\n@@ -1663,10 +1662,8 @@ make_class_data (tree type)\n   super = CLASSTYPE_SUPER (type);\n   if (super == NULL_TREE)\n     super = null_pointer_node;\n-  else if (/* FIXME: we should also test for (!\n-\t      flag_indirect_dispatch) here, but libgcj can't cope with\n-\t      a symbolic reference a superclass in the class data.  */\n-\t   assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n+  else if (! flag_indirect_dispatch\n+\t   && assume_compiled (IDENTIFIER_POINTER (DECL_NAME (type_decl)))\n \t   && assume_compiled (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (super)))))\n     super = build_class_ref (super);\n   else\n@@ -1721,13 +1718,19 @@ make_class_data (tree type)\n \t= emit_symbol_table \n \t(DECL_NAME (TYPE_OTABLE_DECL (type)), \n \t TYPE_OTABLE_DECL (type), TYPE_OTABLE_METHODS (type), \n-\t TYPE_OTABLE_SYMS_DECL (type), integer_type_node);\n+\t TYPE_OTABLE_SYMS_DECL (type), integer_type_node, 1);\n        \n       TYPE_ATABLE_DECL (type) \n \t= emit_symbol_table \n \t(DECL_NAME (TYPE_ATABLE_DECL (type)), \n \t TYPE_ATABLE_DECL (type), TYPE_ATABLE_METHODS (type), \n-\t TYPE_ATABLE_SYMS_DECL (type), ptr_type_node);\n+\t TYPE_ATABLE_SYMS_DECL (type), ptr_type_node, 1);\n+       \n+      TYPE_ITABLE_DECL (type) \n+\t= emit_symbol_table \n+\t(DECL_NAME (TYPE_ITABLE_DECL (type)), \n+\t TYPE_ITABLE_DECL (type), TYPE_ITABLE_METHODS (type), \n+\t TYPE_ITABLE_SYMS_DECL (type), ptr_type_node, 2);\n     }\n   \n   TYPE_CTABLE_DECL (type) = emit_catch_table (type);\n@@ -1765,8 +1768,13 @@ make_class_data (tree type)\n   PUSH_FIELD_VALUE (cons, \"fields\",\n \t\t    fields_decl == NULL_TREE ? null_pointer_node\n \t\t    : build1 (ADDR_EXPR, field_ptr_type_node, fields_decl));\n-  PUSH_FIELD_VALUE (cons, \"size_in_bytes\", size_in_bytes (type));\n-  PUSH_FIELD_VALUE (cons, \"field_count\",\n+  /* If we're using the binary compatibility ABI we don't know the\n+     size until load time.  */\n+  PUSH_FIELD_VALUE (cons, \"size_in_bytes\", \n+\t\t    (flag_indirect_dispatch \n+\t\t     ? integer_minus_one_node \n+\t\t     : size_in_bytes (type)));\n+  PUSH_FIELD_VALUE (cons, \"field_count\", \n \t\t    build_int_cst (NULL_TREE, field_count));\n   PUSH_FIELD_VALUE (cons, \"static_field_count\",\n \t\t    build_int_cst (NULL_TREE, static_field_count));\n@@ -1810,24 +1818,59 @@ make_class_data (tree type)\n       TREE_CONSTANT (TYPE_ATABLE_DECL (type)) = 1;\n       TREE_INVARIANT (TYPE_ATABLE_DECL (type)) = 1;\n     }\n+   if (TYPE_ITABLE_METHODS(type) == NULL_TREE)\n+    {\n+      PUSH_FIELD_VALUE (cons, \"itable\", null_pointer_node);\n+      PUSH_FIELD_VALUE (cons, \"itable_syms\", null_pointer_node);\n+    }\n+  else\n+    {\n+      PUSH_FIELD_VALUE (cons, \"itable\",\n+\t\t\tbuild1 (ADDR_EXPR, itable_ptr_type, TYPE_ITABLE_DECL (type)));\n+      PUSH_FIELD_VALUE (cons, \"itable_syms\",\n+\t\t\tbuild1 (ADDR_EXPR, symbols_array_ptr_type,\n+\t\t\t\tTYPE_ITABLE_SYMS_DECL (type)));\n+      TREE_CONSTANT (TYPE_ITABLE_DECL (type)) = 1;\n+      TREE_INVARIANT (TYPE_ITABLE_DECL (type)) = 1;\n+    }\n  \n   PUSH_FIELD_VALUE (cons, \"catch_classes\",\n \t\t    build1 (ADDR_EXPR, ptr_type_node, TYPE_CTABLE_DECL (type))); \n   PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n   PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"interface_count\",\n \t\t    build_int_cst (NULL_TREE, interface_len));\n-  PUSH_FIELD_VALUE (cons, \"state\", integer_zero_node);\n+  PUSH_FIELD_VALUE \n+    (cons, \"state\",\n+     convert (byte_type_node,\n+\t      build_int_cst (NULL_TREE,\n+\t\t\t     flag_indirect_dispatch\n+\t\t\t     ? JV_STATE_PRELOADING\n+\t\t\t     : JV_STATE_COMPILED)));\n \n   PUSH_FIELD_VALUE (cons, \"thread\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"depth\", integer_zero_node);\n   PUSH_FIELD_VALUE (cons, \"ancestors\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"idt\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"arrayclass\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"protectionDomain\", null_pointer_node);\n+\n+  {\n+    tree assertion_table_ref;\n+    if (TYPE_ASSERTIONS (type) == NULL)\n+      assertion_table_ref = null_pointer_node;\n+    else\n+      assertion_table_ref = build1 (ADDR_EXPR, \n+\t\t\t\t    build_pointer_type (assertion_table_type),\n+\t\t\t\t    emit_assertion_table (type));\n+    \n+    PUSH_FIELD_VALUE (cons, \"assertion_table\", assertion_table_ref);\n+  }\n+\n   PUSH_FIELD_VALUE (cons, \"hack_signers\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"chain\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"aux_info\", null_pointer_node);\n+  PUSH_FIELD_VALUE (cons, \"engine\", null_pointer_node);\n \n   FINISH_RECORD_CONSTRUCTOR (cons);\n \n@@ -1838,11 +1881,26 @@ make_class_data (tree type)\n     DECL_ALIGN (decl) = 64; \n   \n   rest_of_decl_compilation (decl, 1, 0);\n+  \n+  TYPE_OTABLE_DECL (type) = NULL_TREE;\n+  TYPE_ATABLE_DECL (type) = NULL_TREE;\n+  TYPE_CTABLE_DECL (type) = NULL_TREE;\n }\n \n void\n finish_class (void)\n {\n+  if (TYPE_VERIFY_METHOD (output_class))\n+    {\n+      tree verify_method = TYPE_VERIFY_METHOD (output_class);\n+      DECL_SAVED_TREE (verify_method) \n+\t= add_stmt_to_compound (DECL_SAVED_TREE (verify_method), void_type_node,\n+\t\t\t\tbuild (RETURN_EXPR, void_type_node, NULL));\n+      java_genericize (verify_method);\n+      cgraph_finalize_function (verify_method, false);\n+      TYPE_ASSERTIONS (current_class) = NULL;\n+    }\n+\n   java_expand_catch_classes (current_class);\n \n   current_function_decl = NULL_TREE;\n@@ -2095,20 +2153,22 @@ layout_class (tree this_class)\n   if (!CLASS_FROM_SOURCE_P (this_class))\n     {\n       int i;\n-      \n-      for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (this_class)) - 1; i > 0; i--)\n+            if (TYPE_BINFO (this_class))\n \t{\n-\t  tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (this_class), i);\n-\t  tree super_interface = BINFO_TYPE (binfo);\n-\t  tree maybe_super_interface \n-\t    = maybe_layout_super_class (super_interface, NULL_TREE);\n-\t  if (maybe_super_interface == NULL\n-\t      || TREE_CODE (TYPE_SIZE (maybe_super_interface)) == ERROR_MARK)\n+\t  for (i = BINFO_N_BASE_BINFOS (TYPE_BINFO (this_class)) - 1; i > 0; i--)\n \t    {\n-\t      TYPE_SIZE (this_class) = error_mark_node;\n-\t      CLASS_BEING_LAIDOUT (this_class) = 0;\n-\t      class_list = TREE_CHAIN (class_list);\n-\t      return;\n+\t      tree binfo = BINFO_BASE_BINFO (TYPE_BINFO (this_class), i);\n+\t      tree super_interface = BINFO_TYPE (binfo);\n+\t      tree maybe_super_interface \n+\t\t= maybe_layout_super_class (super_interface, NULL_TREE);\n+\t      if (maybe_super_interface == NULL\n+\t\t  || TREE_CODE (TYPE_SIZE (maybe_super_interface)) == ERROR_MARK)\n+\t\t{\n+\t\t  TYPE_SIZE (this_class) = error_mark_node;\n+\t\t  CLASS_BEING_LAIDOUT (this_class) = 0;\n+\t\t  class_list = TREE_CHAIN (class_list);\n+\t\t  return;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -2124,15 +2184,23 @@ layout_class (tree this_class)\n static void\n add_miranda_methods (tree base_class, tree search_class)\n {\n-  tree binfo, base_binfo;\n   int i;\n+  tree binfo, base_binfo;\n+\n+  if (!CLASS_PARSED_P (search_class))\n+    load_class (search_class, 1);\n   \n   for (binfo = TYPE_BINFO (search_class), i = 1;\n        BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     {\n       tree method_decl;\n       tree elt = BINFO_TYPE (base_binfo);\n \n+      /* FIXME: This is totally bogus.  We should not be handling\n+\t Miranda methods at all if we're using the BC ABI.  */\n+      if (TYPE_DUMMY (elt))\n+\tcontinue;\n+\n       /* Ensure that interface methods are seen in declared order.  */\n       if (!CLASS_LOADED_P (elt))\n \tload_class (elt, 1);\n@@ -2193,7 +2261,8 @@ layout_class_methods (tree this_class)\n     dtable_count = integer_zero_node;\n \n   type_name = TYPE_NAME (this_class);\n-  if (CLASS_ABSTRACT (type_name) || CLASS_INTERFACE (type_name))\n+  if (!flag_indirect_dispatch\n+      && (CLASS_ABSTRACT (type_name) || CLASS_INTERFACE (type_name)))\n     {\n       /* An abstract class can have methods which are declared only in\n \t an implemented interface.  These are called \"Miranda\n@@ -2273,7 +2342,9 @@ layout_class_method (tree this_class, tree super_class,\n       bool method_override = false;\n       tree super_method = lookup_argument_method (super_class, method_name,\n \t\t\t\t\t\t  method_sig);\n-      if (super_method != NULL_TREE)\n+      if (super_method != NULL_TREE\n+\t  && ! METHOD_DUMMY (super_method)\n+\t  && ! DECL_ARTIFICIAL (super_method))\n         {\n \t  method_override = true;\n \t  if (! METHOD_PUBLIC (super_method) && \n@@ -2296,11 +2367,19 @@ layout_class_method (tree this_class, tree super_class,\n \t    error (\"%Jnon-static method '%D' overrides static method\",\n                    method_decl, method_decl);\n \t}\n-      else if (! METHOD_FINAL (method_decl)\n-\t       && ! METHOD_PRIVATE (method_decl)\n-\t       && ! CLASS_FINAL (TYPE_NAME (this_class))\n+      else if (this_class == object_type_node\n+\t       && (METHOD_FINAL (method_decl)\n+\t\t   || METHOD_PRIVATE (method_decl)))\n+\t{\n+\t  /* We don't generate vtable entries for final Object\n+\t     methods.  This is simply to save space, since every\n+\t     object would otherwise have to define them.  */\n+\t}\n+      else if (! METHOD_PRIVATE (method_decl)\n \t       && dtable_count)\n \t{\n+\t  /* We generate vtable entries for final methods because they\n+\t     may one day be changed to non-final.  */\n \t  set_method_index (method_decl, dtable_count);\n \t  dtable_count = fold (build2 (PLUS_EXPR, integer_type_node,\n \t\t\t\t       dtable_count, integer_one_node));\n@@ -2387,14 +2466,20 @@ static tree\n build_symbol_entry (tree decl)\n {\n   tree clname, name, signature, sym;\n-  \n   clname = build_utf8_ref (DECL_NAME (TYPE_NAME (DECL_CONTEXT (decl))));\n-  name = build_utf8_ref (DECL_NAME (decl));\n+  /* ???  Constructors are given the name foo.foo all the way through\n+     the compiler, but in the method table they're all renamed\n+     foo.<init>.  So, we have to do the same here unless we want an\n+     unresolved reference at runtime.  */\n+  name = build_utf8_ref ((TREE_CODE (decl) == FUNCTION_DECL \n+\t\t\t  && DECL_CONSTRUCTOR_P (decl))\n+\t\t\t ? init_identifier_node\n+\t\t\t : DECL_NAME (decl));\n   signature = build_java_signature (TREE_TYPE (decl));\n   signature = build_utf8_ref (unmangle_classname \n \t\t\t      (IDENTIFIER_POINTER (signature),\n \t\t\t       IDENTIFIER_LENGTH (signature)));\n-\n+      \n   START_RECORD_CONSTRUCTOR (sym, symbol_type);\n   PUSH_FIELD_VALUE (sym, \"clname\", clname);\n   PUSH_FIELD_VALUE (sym, \"name\", name);\n@@ -2410,7 +2495,8 @@ build_symbol_entry (tree decl)\n \n tree\n emit_symbol_table (tree name, tree the_table, tree decl_list,\n-                   tree the_syms_decl, tree the_array_element_type)\n+                   tree the_syms_decl, tree the_array_element_type,\n+\t\t   int element_size)\n {\n   tree method_list, method, table, list, null_symbol;\n   tree table_size, the_array_type;\n@@ -2457,7 +2543,8 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n      uninitialized static array of INDEX + 1 elements. The extra entry\n      is used by the runtime to track whether the table has been\n      initialized. */\n-  table_size = build_index_type (build_int_cst (NULL_TREE, index));\n+  table_size \n+    = build_index_type (build_int_cst (NULL_TREE, index * element_size + 1));\n   the_array_type = build_array_type (the_array_element_type, table_size);\n   the_table = build_decl (VAR_DECL, name, the_array_type);\n   TREE_STATIC (the_table) = 1;\n@@ -2467,7 +2554,7 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n   return the_table;\n }\n \n-/* make an entry for the catch_classes list.  */\n+/* Make an entry for the catch_classes list.  */\n tree\n make_catch_class_record (tree catch_class, tree classname)\n {\n@@ -2512,7 +2599,95 @@ emit_catch_table (tree this_class)\n   rest_of_decl_compilation (table, 1, 0);\n   return table;\n }\n- \n+\n+/* Given a type, return the signature used by\n+   _Jv_FindClassFromSignature() in libgcj.  This isn't exactly the\n+   same as build_java_signature() because we want the canonical array\n+   type.  */\n+\n+static tree\n+build_signature_for_libgcj (tree type)\n+{\n+  tree sig, ref;\n+\n+  sig = build_java_signature (type);\n+  ref = build_utf8_ref (unmangle_classname (IDENTIFIER_POINTER (sig),\n+\t\t\t\t\t    IDENTIFIER_LENGTH (sig)));\n+  return ref;\n+}\n+\n+/* Add an entry to the type assertion table. Callback used during hashtable\n+   traversal.  */\n+\n+static int\n+add_assertion_table_entry (void **htab_entry, void *ptr)\n+{\n+  tree entry;\n+  tree code_val, op1_utf8, op2_utf8;\n+  tree *list = (tree *) ptr;\n+  type_assertion *as = (type_assertion *) *htab_entry;\n+\n+  code_val = build_int_cst (NULL_TREE, as->assertion_code);\n+\n+  if (as->op1 == NULL_TREE)\n+    op1_utf8 = null_pointer_node;\n+  else\n+    op1_utf8 = build_signature_for_libgcj (as->op1);\n+\n+  if (as->op2 == NULL_TREE)\n+    op2_utf8 = null_pointer_node;\n+  else\n+    op2_utf8 = build_signature_for_libgcj (as->op2);\n+  \n+  START_RECORD_CONSTRUCTOR (entry, assertion_entry_type);\n+  PUSH_FIELD_VALUE (entry, \"assertion_code\", code_val);\n+  PUSH_FIELD_VALUE (entry, \"op1\", op1_utf8);\n+  PUSH_FIELD_VALUE (entry, \"op2\", op2_utf8);\n+  FINISH_RECORD_CONSTRUCTOR (entry);\n+  \n+  *list = tree_cons (NULL_TREE, entry, *list);\n+  return true;\n+}\n+\n+/* Generate the type assertion table for CLASS, and return its DECL.  */\n+\n+static tree\n+emit_assertion_table (tree class)\n+{\n+  tree null_entry, ctor, table_decl;\n+  tree list = NULL_TREE;\n+  htab_t assertions_htab = TYPE_ASSERTIONS (class);\n+\n+  /* Iterate through the hash table.  */\n+  htab_traverse (assertions_htab, add_assertion_table_entry, &list);\n+\n+  /* Finish with a null entry.  */\n+  START_RECORD_CONSTRUCTOR (null_entry, assertion_entry_type);\n+  PUSH_FIELD_VALUE (null_entry, \"assertion_code\", integer_zero_node);\n+  PUSH_FIELD_VALUE (null_entry, \"op1\", null_pointer_node);\n+  PUSH_FIELD_VALUE (null_entry, \"op2\", null_pointer_node);\n+  FINISH_RECORD_CONSTRUCTOR (null_entry);\n+  \n+  list = tree_cons (NULL_TREE, null_entry, list);\n+  \n+  /* Put the list in the right order and make it a constructor. */\n+  list = nreverse (list);\n+  ctor = build_constructor (assertion_table_type, list);\n+\n+  table_decl = build_decl (VAR_DECL, mangled_classname (\"_type_assert_\", class),\n+\t\t\t   assertion_table_type);\n+\n+  TREE_STATIC (table_decl) = 1;\n+  TREE_READONLY (table_decl) = 1;\n+  TREE_CONSTANT (table_decl) = 1;\n+  DECL_IGNORED_P (table_decl) = 1;\n+\n+  DECL_INITIAL (table_decl) = ctor;\n+  DECL_ARTIFICIAL (table_decl) = 1;\n+  rest_of_decl_compilation (table_decl, 1, 0);\n+\n+  return table_decl;\n+}\n \n void\n init_class_processing (void)"}, {"sha": "54f788e0d7dbe628d243180e695c36480e166b40", "filename": "gcc/java/decl.c", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -242,17 +242,44 @@ check_local_unnamed_variable (tree best, tree decl, tree type)\n       || (INTEGRAL_TYPE_P (decl_type)\n \t  && INTEGRAL_TYPE_P (type)\n \t  && TYPE_PRECISION (decl_type) <= 32\n-\t    && TYPE_PRECISION (type) <= 32\n+\t  && TYPE_PRECISION (type) <= 32\n \t  && TYPE_PRECISION (decl_type) >= TYPE_PRECISION (type))      \n-\t|| (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n-\t    && type == ptr_type_node))\n-      {\n-\tif (best == NULL_TREE\n+      /*  ptr_type_node is used for null pointers, which are\n+\t  assignment compatible with everything.  */\n+      || (TREE_CODE (decl_type) == POINTER_TYPE\n+\t  && type == ptr_type_node)\n+      /* Whenever anyone wants to use a slot that is initially\n+\t occupied by a PARM_DECL of pointer type they must get that\n+\t decl, even if they asked for a pointer to a different type.\n+\t However, if someone wants a scalar variable in a slot that\n+\t initially held a pointer arg -- or vice versa -- we create a\n+\t new VAR_DECL.  \n+\n+\t ???: As long as verification is correct, this will be a\n+\t compatible type.  But maybe we should create a dummy vribale\n+\t and replace all references to it with the DECL and a\n+\t NOP_EXPR.\n+      */\n+      || (TREE_CODE (decl_type) == POINTER_TYPE\n+\t  && TREE_CODE (decl) == PARM_DECL\n+\t  && TREE_CODE (type) == POINTER_TYPE)\n+\n+      /* The new verifier requires a similar treatment in the\n+\t situation where the parameter has an integral type which\n+\t promotes to `int'.  */\n+      || (flag_new_verifier\n+\t  && TREE_CODE (decl) == PARM_DECL\n+\t  && INTEGRAL_TYPE_P (decl_type)\n+\t  && TYPE_PRECISION (decl_type) <= 32\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && TYPE_PRECISION (type) <= 32))\n+    {\n+      if (best == NULL_TREE\n \t  || (decl_type == type && TREE_TYPE (best) != type))\n-\t  return decl;\n-      }\n+\treturn decl;\n+    }\n \n-    return best;\n+  return best;\n }\n \n \n@@ -286,9 +313,9 @@ find_local_variable (int index, tree type, int pc ATTRIBUTE_UNUSED)\n      variable that is used for every reference in that local variable\n      slot.  */\n   if (! decl)\n-  {\n-    char buf[64];\n-    tree name;\n+    {\n+      char buf[64];\n+      tree name;\n       sprintf (buf, \"#slot#%d#%d\", index, uniq++);\n       name = get_identifier (buf);\n       decl = build_decl (VAR_DECL, name, type);\n@@ -688,6 +715,11 @@ java_init_decl_processing (void)\n   TYPE_NONALIASED_COMPONENT (atable_type) = 1;\n   atable_ptr_type = build_pointer_type (atable_type);\n \n+  itable_type = build_array_type (ptr_type_node, \n+\t\t\t\t  one_elt_array_domain_type);\n+  TYPE_NONALIASED_COMPONENT (itable_type) = 1;\n+  itable_ptr_type = build_pointer_type (itable_type);\n+\n   symbol_type = make_node (RECORD_TYPE);\n   PUSH_FIELD (symbol_type, field, \"clname\", utf8const_ptr_type);\n   PUSH_FIELD (symbol_type, field, \"name\", utf8const_ptr_type);\n@@ -698,6 +730,15 @@ java_init_decl_processing (void)\n \t\t\t\t\t one_elt_array_domain_type);\n   symbols_array_ptr_type = build_pointer_type (symbols_array_type);\n \n+  assertion_entry_type = make_node (RECORD_TYPE);\n+  PUSH_FIELD (assertion_entry_type, field, \"assertion_code\", integer_type_node);\n+  PUSH_FIELD (assertion_entry_type, field, \"op1\", utf8const_ptr_type);\n+  PUSH_FIELD (assertion_entry_type, field, \"op2\", utf8const_ptr_type);\n+  FINISH_RECORD (assertion_entry_type);\n+  \n+  assertion_table_type = build_array_type (assertion_entry_type,\n+                                           one_elt_array_domain_type);\n+\n   /* As you're adding items here, please update the code right after\n      this section, so that the filename containing the source code of\n      the pre-defined class gets registered correctly. */\n@@ -813,6 +854,9 @@ java_init_decl_processing (void)\n   PUSH_FIELD (class_type_node, field, \"atable\", atable_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"atable_syms\", \n   \t      symbols_array_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"itable\", itable_ptr_type);\n+  PUSH_FIELD (class_type_node, field, \"itable_syms\", \n+  \t      symbols_array_ptr_type);\n   PUSH_FIELD (class_type_node, field, \"catch_classes\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"interfaces\",\n \t      build_pointer_type (class_ptr_type));\n@@ -825,9 +869,11 @@ java_init_decl_processing (void)\n   PUSH_FIELD (class_type_node, field, \"idt\", ptr_type_node);  \n   PUSH_FIELD (class_type_node, field, \"arrayclass\", ptr_type_node);  \n   PUSH_FIELD (class_type_node, field, \"protectionDomain\", ptr_type_node);\n+  PUSH_FIELD (class_type_node, field, \"assertion_table\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"hack_signers\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"chain\", ptr_type_node);\n   PUSH_FIELD (class_type_node, field, \"aux_info\", ptr_type_node);\n+  PUSH_FIELD (class_type_node, field, \"engine\", ptr_type_node);\n   for (t = TYPE_FIELDS (class_type_node);  t != NULL_TREE;  t = TREE_CHAIN (t))\n     FIELD_PRIVATE (t) = 1;\n   push_super_field (class_type_node, object_type_node);\n@@ -993,8 +1039,14 @@ java_init_decl_processing (void)\n     = builtin_function (\"_Jv_LookupInterfaceMethodIdx\",\n \t\t\tbuild_function_type (ptr_type_node, t),\n \t\t\t0, NOT_BUILT_IN, NULL, NULL_TREE);\n-\n   DECL_IS_PURE (soft_lookupinterfacemethod_node) = 1;\n+  t = tree_cons (NULL_TREE, ptr_type_node,\n+\t\t tree_cons (NULL_TREE, ptr_type_node,\n+\t\t\t    tree_cons (NULL_TREE, ptr_type_node, endlink)));\n+  soft_lookupinterfacemethodbyname_node \n+    = builtin_function (\"_Jv_LookupInterfaceMethod\",\n+\t\t\tbuild_function_type (ptr_type_node, t),\n+\t\t\t0, NOT_BUILT_IN, NULL, NULL_TREE);\n   t = tree_cons (NULL_TREE, object_ptr_type_node,\n \t\t tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t    tree_cons (NULL_TREE, ptr_type_node, "}, {"sha": "305ab5bdfee0fc16c0cf617d81ae6f26e0feba15", "filename": "gcc/java/expr.c", "status": "modified", "additions": 415, "deletions": 124, "changes": 539, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -323,26 +323,63 @@ pop_type_0 (tree type, char **messagep)\n   t = stack_type_map[--stack_pointer];\n   if (type == NULL_TREE || t == type)\n     return t;\n+  if (TREE_CODE (t) == TREE_LIST)\n+    {      \n+      do\n+\t{\n+\t  tree tt = TREE_PURPOSE (t);\n+\t  if (! can_widen_reference_to (tt, type))\n+\t    {\n+\t      t = tt;\n+\t      goto fail;\n+\t    }\n+\t  t = TREE_CHAIN (t);\n+\t}\n+      while (t);\n+      return t;\n+    }\n   if (INTEGRAL_TYPE_P (type) && INTEGRAL_TYPE_P (t)\n       && TYPE_PRECISION (type) <= 32 && TYPE_PRECISION (t) <= 32)\n-      return t;\n+    return t;\n   if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (t) == POINTER_TYPE)\n     {\n-      if (type == ptr_type_node || type == object_ptr_type_node)\n-\treturn t;\n-      else if (t == ptr_type_node)  /* Special case for null reference. */\n-\treturn type;\n-      else if (can_widen_reference_to (t, type))\n-\treturn t;\n-      /* This is a kludge, but matches what Sun's verifier does.\n-\t It can be tricked, but is safe as long as type errors\n-\t (i.e. interface method calls) are caught at run-time. */\n-      else if (CLASS_INTERFACE (TYPE_NAME (TREE_TYPE (type))))\n-\treturn object_ptr_type_node;\n+      if (flag_new_verifier)\n+\t{\n+\t  /* Since the verifier has already run, we know that any\n+\t     types we see will be compatible.  In BC mode, this fact\n+\t     may be checked at runtime, but if that is so then we can\n+\t     assume its truth here as well.  So, we always succeed\n+\t     here, with the expected type.  */\n+\t  return type;\n+\t}\n+      else\n+\t{\n+\t  if (type == ptr_type_node || type == object_ptr_type_node)\n+\t    return t;\n+\t  else if (t == ptr_type_node)  /* Special case for null reference. */\n+\t    return type;\n+\t  /* This is a kludge, but matches what Sun's verifier does.\n+\t     It can be tricked, but is safe as long as type errors\n+\t     (i.e. interface method calls) are caught at run-time. */\n+\t  else if (CLASS_INTERFACE (TYPE_NAME (TREE_TYPE (type))))\n+\t    return object_ptr_type_node;\n+\t  else if (can_widen_reference_to (t, type))\n+\t    return t;\n+\t}\n+    }\n+\n+  if (! flag_verify_invocations && flag_indirect_dispatch\n+      && t == object_ptr_type_node)\n+    {\n+      if (type != ptr_type_node)\n+\twarning (\"need to insert runtime check for %s\", \n+\t\t xstrdup (lang_printable_name (type, 0)));\n+      return type;\n     }\n \n   /* lang_printable_name uses a static buffer, so we must save the result\n      from calling it the first time.  */\n+ fail:\n   {\n     char *temp = xstrdup (lang_printable_name (type, 0));\n     *messagep = concat (\"expected type '\", temp,\n@@ -370,6 +407,68 @@ pop_type (tree type)\n   return type;\n }\n \n+\f\n+/* Return true if two type assertions are equal.  */\n+\n+static int\n+type_assertion_eq (const void * k1_p, const void * k2_p)\n+{\n+  type_assertion k1 = *(type_assertion *)k1_p;\n+  type_assertion k2 = *(type_assertion *)k2_p;\n+  return (k1.assertion_code == k2.assertion_code\n+          && k1.op1 == k2.op1\n+\t  && k1.op2 == k2.op2);\n+}\n+\n+/* Hash a type assertion.  */\n+\n+static hashval_t\n+type_assertion_hash (const void *p)\n+{\n+  const type_assertion *k_p = p;\n+  hashval_t hash = iterative_hash (&k_p->assertion_code, sizeof\n+\t\t\t\t   k_p->assertion_code, 0);\n+  hash = iterative_hash (&k_p->op1, sizeof k_p->op1, hash);\n+  return iterative_hash (&k_p->op2, sizeof k_p->op2, hash);\n+}\n+\n+/* Add an entry to the type assertion table for the given class.  \n+   CLASS is the class for which this assertion will be evaluated by the \n+   runtime during loading/initialization.\n+   ASSERTION_CODE is the 'opcode' or type of this assertion: see java-tree.h.\n+   OP1 and OP2 are the operands. The tree type of these arguments may be\n+   specific to each assertion_code. */\n+\n+void\n+add_type_assertion (tree class, int assertion_code, tree op1, tree op2)\n+{\n+  htab_t assertions_htab;\n+  type_assertion as;\n+  void **as_pp;\n+\n+  assertions_htab = TYPE_ASSERTIONS (class);\n+  if (assertions_htab == NULL)\n+    {\n+      assertions_htab = htab_create_ggc (7, type_assertion_hash, \n+\t\t\t\t\t type_assertion_eq, NULL);\n+      TYPE_ASSERTIONS (current_class) = assertions_htab;\n+    }\n+\n+  as.assertion_code = assertion_code;\n+  as.op1 = op1;\n+  as.op2 = op2;\n+\n+  as_pp = htab_find_slot (assertions_htab, &as, true);\n+\n+  /* Don't add the same assertion twice.  */\n+  if (*as_pp)\n+    return;\n+\n+  *as_pp = ggc_alloc (sizeof (type_assertion));\n+  **(type_assertion **)as_pp = as;\n+}\n+\n+\f\n /* Return 1 if SOURCE_TYPE can be safely widened to TARGET_TYPE.\n    Handles array types and interfaces.  */\n \n@@ -387,6 +486,28 @@ can_widen_reference_to (tree source_type, tree target_type)\n \n   if (source_type == target_type)\n     return 1;\n+\n+  /* FIXME: This is very pessimistic, in that it checks everything,\n+     even if we already know that the types are compatible.  If we're\n+     to support full Java class loader semantics, we need this.\n+     However, we could do something more optimal.  */\n+  if (! flag_verify_invocations)\n+    {\n+      add_type_assertion (current_class, JV_ASSERT_TYPES_COMPATIBLE, \n+\t\t\t  source_type, target_type);\n+\n+      if (!quiet_flag)\n+       warning (\"assert: %s is assign compatible with %s\", \n+\t\txstrdup (lang_printable_name (target_type, 0)),\n+\t\txstrdup (lang_printable_name (source_type, 0)));\n+      /* Punt everything to runtime.  */\n+      return 1;\n+    }\n+\n+  if (TYPE_DUMMY (source_type) || TYPE_DUMMY (target_type))\n+    {\n+      return 1;\n+    }\n   else\n     {\n       if (TYPE_ARRAY_P (source_type) || TYPE_ARRAY_P (target_type))\n@@ -420,7 +541,16 @@ can_widen_reference_to (tree source_type, tree target_type)\n \t  int source_depth = class_depth (source_type);\n \t  int target_depth = class_depth (target_type);\n \n-\t  /* class_depth can return a negative depth if an error occurred */\n+\t  if (TYPE_DUMMY (source_type) || TYPE_DUMMY (target_type))\n+\t    {\n+\t      if (! quiet_flag)\n+\t\twarning (\"assert: %s is assign compatible with %s\", \n+\t\t\t xstrdup (lang_printable_name (target_type, 0)),\n+\t\t\t xstrdup (lang_printable_name (source_type, 0)));\n+\t      return 1;\n+\t    }\n+\n+ \t  /* class_depth can return a negative depth if an error occurred */\n \t  if (source_depth < 0 || target_depth < 0)\n \t    return 0;\n \n@@ -687,13 +817,18 @@ build_java_array_length_access (tree node)\n      throws a NullPointerException.  The only way we could get a node\n      of type ptr_type_node at this point is `aconst_null; arraylength'\n      or something equivalent.  */\n-  if (type == ptr_type_node)\n+  if (!flag_new_verifier && type == ptr_type_node)\n     return build3 (CALL_EXPR, int_type_node, \n \t\t   build_address_of (soft_nullpointer_node),\n \t\t   NULL_TREE, NULL_TREE);\n \n   if (!is_array_type_p (type))\n-    abort ();\n+    {\n+      /* With the new verifier, we will see an ordinary pointer type\n+\t here.  In this case, we just use an arbitrary array type.  */\n+      array_type = build_java_array_type (object_ptr_type_node, -1);\n+      type = promote_type (array_type);\n+    }\n \n   length = java_array_type_length (type);\n   if (length >= 0)\n@@ -754,6 +889,13 @@ build_java_arrayaccess (tree array, tree type, tree index)\n   tree ref;\n   tree array_type = TREE_TYPE (TREE_TYPE (array));\n \n+  if (!is_array_type_p (TREE_TYPE (array)))\n+    {\n+      /* With the new verifier, we will see an ordinary pointer type\n+\t here.  In this case, we just use the correct array type.  */\n+      array_type = build_java_array_type (type, -1);\n+    }\n+\n   if (flag_bounds_check)\n     {\n       /* Generate:\n@@ -803,11 +945,21 @@ build_java_arraystore_check (tree array, tree object)\n   tree array_type_p = TREE_TYPE (array);\n   tree object_type = TYPE_NAME (TREE_TYPE (TREE_TYPE (object)));\n \n-  if (! is_array_type_p (array_type_p))\n-    abort ();\n+  if (! flag_verify_invocations)\n+    {\n+      /* With the new verifier, we don't track precise types.  FIXME:\n+\t performance regression here.  */\n+      element_type = TYPE_NAME (object_type_node);\n+    }\n+  else\n+    {\n+      if (! is_array_type_p (array_type_p))\n+\tabort ();\n \n-  /* Get the TYPE_DECL for ARRAY's element type. */\n-  element_type = TYPE_NAME (TREE_TYPE (TREE_TYPE (TREE_TYPE (array_type_p))));\n+      /* Get the TYPE_DECL for ARRAY's element type. */\n+      element_type\n+\t= TYPE_NAME (TREE_TYPE (TREE_TYPE (TREE_TYPE (array_type_p))));\n+    }\n \n   if (TREE_CODE (element_type) != TYPE_DECL   \n       || TREE_CODE (object_type) != TYPE_DECL)\n@@ -816,13 +968,14 @@ build_java_arraystore_check (tree array, tree object)\n   if (!flag_store_check)\n     return build1 (NOP_EXPR, array_type_p, array);\n \n-  /* No check is needed if the element type is final or is itself an array.  \n-     Also check that element_type matches object_type, since in the bytecode \n-     compilation case element_type may be the actual element type of the array\n-     rather than its declared type. */\n+  /* No check is needed if the element type is final.  Also check that\n+     element_type matches object_type, since in the bytecode\n+     compilation case element_type may be the actual element type of\n+     the array rather than its declared type.  However, if we're doing\n+     indirect dispatch, we can't do the `final' optimization.  */\n   if (element_type == object_type\n-      && (TYPE_ARRAY_P (TREE_TYPE (element_type))\n-\t  || CLASS_FINAL (element_type)))\n+      && ! flag_indirect_dispatch\n+      && CLASS_FINAL (element_type))\n     return build1 (NOP_EXPR, array_type_p, array);\n   \n   /* OBJECT might be wrapped by a SAVE_EXPR. */\n@@ -864,24 +1017,30 @@ build_java_arraystore_check (tree array, tree object)\n    ARRAY_NODE. This function is used to retrieve something less vague than\n    a pointer type when indexing the first dimension of something like [[<t>.\n    May return a corrected type, if necessary, otherwise INDEXED_TYPE is\n-   return unchanged.\n-   As a side effect, it also makes sure that ARRAY_NODE is an array.  */\n+   return unchanged.  */\n \n static tree\n build_java_check_indexed_type (tree array_node, tree indexed_type)\n {\n   tree elt_type;\n \n+  /* We used to check to see if ARRAY_NODE really had array type.\n+     However, with the new verifier, this is not necessary, as we know\n+     that the object will be an array of the appropriate type.  */\n+\n+  if (flag_new_verifier)\n+    return indexed_type;\n+\n   if (!is_array_type_p (TREE_TYPE (array_node)))\n     abort ();\n \n   elt_type = (TYPE_ARRAY_ELEMENT (TREE_TYPE (TREE_TYPE (array_node))));\n \n-  if (indexed_type == ptr_type_node )\n-      return promote_type (elt_type);\n+  if (indexed_type == ptr_type_node)\n+    return promote_type (elt_type);\n \n   /* BYTE/BOOLEAN store and load are used for both type */\n-  if (indexed_type == byte_type_node && elt_type == boolean_type_node )\n+  if (indexed_type == byte_type_node && elt_type == boolean_type_node)\n     return boolean_type_node;\n \n   if (indexed_type != elt_type )\n@@ -992,7 +1151,25 @@ expand_java_arraystore (tree rhs_type_node)\n \t\t\t\t && TYPE_PRECISION (rhs_type_node) <= 32) ? \n \t\t\t\t int_type_node : rhs_type_node);\n   tree index = pop_value (int_type_node);\n-  tree array = pop_value (ptr_type_node);\n+  tree array_type, array;\n+\n+  if (flag_new_verifier)\n+    {\n+      /* If we're processing an `aaload' we might as well just pick\n+\t `Object'.  */\n+      if (TREE_CODE (rhs_type_node) == POINTER_TYPE)\n+\t{\n+\t  array_type = build_java_array_type (object_ptr_type_node, -1);\n+\t  rhs_type_node = object_ptr_type_node;\n+\t}\n+      else\n+\tarray_type = build_java_array_type (rhs_type_node, -1);\n+    }\n+  else\n+    array_type = ptr_type_node;\n+  array = pop_value (array_type);\n+  if (flag_new_verifier)\n+    array = build1 (NOP_EXPR, promote_type (array_type), array);\n \n   rhs_type_node    = build_java_check_indexed_type (array, rhs_type_node);\n \n@@ -1019,25 +1196,45 @@ expand_java_arraystore (tree rhs_type_node)\n */\n \n static void\n-expand_java_arrayload (tree lhs_type_node )\n+expand_java_arrayload (tree lhs_type_node)\n {\n   tree load_node;\n   tree index_node = pop_value (int_type_node);\n-  tree array_node = pop_value (ptr_type_node);\n+  tree array_type;\n+  tree array_node;\n+\n+  if (flag_new_verifier)\n+    {\n+      /* If we're processing an `aaload' we might as well just pick\n+\t `Object'.  */\n+      if (TREE_CODE (lhs_type_node) == POINTER_TYPE)\n+\t{\n+\t  array_type = build_java_array_type (object_ptr_type_node, -1);\n+\t  lhs_type_node = object_ptr_type_node;\n+\t}\n+      else\n+\tarray_type = build_java_array_type (lhs_type_node, -1);\n+    }\n+  else\n+    array_type = ptr_type_node;\n+  array_node = pop_value (array_type);\n+  if (flag_new_verifier)\n+    array_node = build1 (NOP_EXPR, promote_type (array_type), array_node);\n \n   index_node = save_expr (index_node);\n   array_node = save_expr (array_node);\n-  \n+\n   if (TREE_TYPE (array_node) == ptr_type_node)\n     /* The only way we could get a node of type ptr_type_node at this\n        point is `aconst_null; arraylength' or something equivalent, so\n-       unconditionally throw NullPointerException.  */    \n+       unconditionally throw NullPointerException.  */\n     load_node = build3 (CALL_EXPR, lhs_type_node, \n \t\t\tbuild_address_of (soft_nullpointer_node),\n \t\t\tNULL_TREE, NULL_TREE);\n   else\n     {\n-      lhs_type_node = build_java_check_indexed_type (array_node, lhs_type_node);\n+      lhs_type_node = build_java_check_indexed_type (array_node,\n+\t\t\t\t\t\t     lhs_type_node);\n       load_node = build_java_arrayaccess (array_node,\n \t\t\t\t\t  lhs_type_node,\n \t\t\t\t\t  index_node);\n@@ -1156,6 +1353,19 @@ class_has_finalize_method (tree type)\n     return HAS_FINALIZER_P (type) || class_has_finalize_method (super);\n }\n \n+tree\n+java_create_object (tree type)\n+{\n+  tree alloc_node = (class_has_finalize_method (type) \n+\t\t     ? alloc_object_node\n+\t\t     : alloc_no_finalizer_node);\n+  \n+  return build (CALL_EXPR, promote_type (type),\n+\t\tbuild_address_of (alloc_node),\n+\t\tbuild_tree_list (NULL_TREE, build_class_ref (type)),\n+\t\tNULL_TREE);\n+}\n+\n static void\n expand_java_NEW (tree type)\n {\n@@ -1221,7 +1431,8 @@ build_instanceof (tree value, tree type)\n \t we only need to check for `null'.  */\n       expr = build2 (NE_EXPR, itype, value, null_pointer_node);\n     }\n-  else if (! TYPE_ARRAY_P (type)\n+  else if (flag_verify_invocations\n+\t   && ! TYPE_ARRAY_P (type)\n \t   && ! TYPE_ARRAY_P (valtype)\n \t   && DECL_P (klass) && DECL_P (valclass)\n \t   && ! CLASS_INTERFACE (valclass)\n@@ -1292,7 +1503,7 @@ expand_iinc (unsigned int local_var_index, int ival, int pc)\n   update_aliases (local_var, local_var_index, pc);\n }\n \n-      \n+\n tree\n build_java_soft_divmod (enum tree_code op, tree type, tree op1, tree op2)\n {\n@@ -1529,12 +1740,13 @@ build_field_ref (tree self_value, tree self_class, tree name)\n       tree base_type = promote_type (base_class);\n       if (base_type != TREE_TYPE (self_value))\n \tself_value = fold (build1 (NOP_EXPR, base_type, self_value));\n-      if (flag_indirect_dispatch\n-\t  && output_class != self_class)\n-\t/* FIXME: output_class != self_class is not exactly the right\n-\t   test.  What we really want to know is whether self_class is\n-\t   in the same translation unit as output_class.  If it is,\n-\t   we can make a direct reference.  */\n+      if (! flag_syntax_only\n+\t  && (flag_indirect_dispatch\n+\t      /* DECL_FIELD_OFFSET == 0 if we have no reference for\n+\t\t the field, perhaps because we couldn't find the class\n+\t\t in which the field is defined.  \n+\t\t FIXME: We should investigate this.  */\n+\t      || DECL_FIELD_OFFSET (field_decl) == 0))\n \t{\n \t  tree otable_index\n \t    = build_int_cst (NULL_TREE, get_symbol_table_index \n@@ -1696,29 +1908,6 @@ expand_java_add_case (tree switch_expr, int match, int target_pc)\n   append_to_statement_list (x, &SWITCH_BODY (switch_expr));\n }\n \n-#if 0\n-static void\n-expand_java_call (int target_pc, int return_address)\n-{\n-  tree target_label = lookup_label (target_pc);\n-  tree value = build_int_cst (NULL_TREE, return_address);\n-  push_value (value);\n-  flush_quick_stack ();\n-  expand_goto (target_label);\n-}\n-\n-static void\n-expand_java_ret (tree return_address ATTRIBUTE_UNUSED)\n-{\n-  warning (\"ret instruction not implemented\");\n-#if 0\n-  tree target_label = lookup_label (target_pc);\n-  flush_quick_stack ();\n-  expand_goto (target_label);\n-#endif\n-}\n-#endif\n-\n static tree\n pop_arguments (tree arg_types)\n {\n@@ -1729,9 +1918,17 @@ pop_arguments (tree arg_types)\n       tree tail = pop_arguments (TREE_CHAIN (arg_types));\n       tree type = TREE_VALUE (arg_types);\n       tree arg = pop_value (type);\n-      if (targetm.calls.promote_prototypes (type)\n-\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n-\t  && INTEGRAL_TYPE_P (type))\n+\n+      /* With the new verifier we simply cast each argument to its\n+\t proper type.  This is needed since we lose type information\n+\t coming out of the verifier.  We also have to do this with the\n+\t old verifier when we pop an integer type that must be\n+\t promoted for the function call.  */\n+      if (flag_new_verifier && TREE_CODE (type) == POINTER_TYPE)\n+\targ = build1 (NOP_EXPR, type, arg);\n+      else if (targetm.calls.promote_prototypes (type)\n+\t       && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n+\t       && INTEGRAL_TYPE_P (type))\n \targ = convert (integer_type_node, arg);\n       return tree_cons (NULL_TREE, arg, tail);\n     }\n@@ -1824,8 +2021,12 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n   tree func;\n   if (is_compiled_class (self_type))\n     {\n-      if (!flag_indirect_dispatch\n-\t  || (!TREE_PUBLIC (method) && DECL_CONTEXT (method)))\n+      /* With indirect dispatch we have to use indirect calls for all\n+\t publically visible methods or gcc will use PLT indirections\n+\t to reach them.  We also have to use indirect dispatch for all\n+\t external methods.  */\n+      if (! flag_indirect_dispatch \n+\t  || (! DECL_EXTERNAL (method) && ! TREE_PUBLIC (method)))\n \t{\n \t  make_decl_rtl (method);\n \t  func = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (method)),\n@@ -1836,9 +2037,11 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t  tree table_index\n \t    = build_int_cst (NULL_TREE, get_symbol_table_index \n \t\t\t     (method, &TYPE_ATABLE_METHODS (output_class)));\n-\t  func = build4 (ARRAY_REF,  method_ptr_type_node, \n-\t\t\t TYPE_ATABLE_DECL (output_class), table_index,\n-\t\t\t NULL_TREE, NULL_TREE);\n+\t  func \n+\t    = build4 (ARRAY_REF,  \n+\t\t      TREE_TYPE (TREE_TYPE (TYPE_ATABLE_DECL (output_class))),\n+\t\t      TYPE_ATABLE_DECL (output_class), table_index,\n+\t\t      NULL_TREE, NULL_TREE);\n \t}\n       func = convert (method_ptr_type_node, func);\n     }\n@@ -1899,9 +2102,9 @@ invoke_build_dtable (int is_invoke_interface, tree arg_list)\n      argument is an array then get the dispatch table of the class\n      Object rather than the one from the objectref.  */\n   objectref = (is_invoke_interface \n-\t       && is_array_type_p (TREE_TYPE (TREE_VALUE (arg_list))) ?\n-\t       object_type_node : TREE_VALUE (arg_list));\n-  \n+\t       && is_array_type_p (TREE_TYPE (TREE_VALUE (arg_list)))\n+\t       ? build_class_ref (object_type_node) : TREE_VALUE (arg_list));\n+\n   if (dtable_ident == NULL_TREE)\n     dtable_ident = get_identifier (\"vtable\");\n   dtable = build_java_indirect_ref (object_type_node, objectref, \n@@ -1914,8 +2117,8 @@ invoke_build_dtable (int is_invoke_interface, tree arg_list)\n \n /* Determine the index in SYMBOL_TABLE for a reference to the decl\n    T. If this decl has not been seen before, it will be added to the\n-   otable_methods. If it has, the existing table slot will be\n-   reused. */\n+   [oa]table_methods. If it has, the existing table slot will be\n+   reused.  */\n \n int\n get_symbol_table_index (tree t, tree *symbol_table)\n@@ -1935,7 +2138,7 @@ get_symbol_table_index (tree t, tree *symbol_table)\n     {\n       tree value = TREE_VALUE (method_list);\n       if (value == t)\n-        return i;\n+\treturn i;\n       i++;\n       if (TREE_CHAIN (method_list) == NULL_TREE)\n         break;\n@@ -1958,6 +2161,9 @@ build_invokevirtual (tree dtable, tree method)\n \n   if (flag_indirect_dispatch)\n     {\n+      if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n+\tabort ();\n+\n       otable_index \n \t= build_int_cst (NULL_TREE, get_symbol_table_index \n \t\t\t (method, &TYPE_OTABLE_METHODS (output_class)));\n@@ -1997,11 +2203,8 @@ build_invokeinterface (tree dtable, tree method)\n   tree lookup_arg;\n   tree interface;\n   tree idx;\n-  tree otable_index;\n \n-  /* We expand invokeinterface here.  _Jv_LookupInterfaceMethod() will\n-     ensure that the selected method exists, is public and not\n-     abstract nor static.  */\n+  /* We expand invokeinterface here.  */\n \t    \n   if (class_ident == NULL_TREE)\n     class_ident = get_identifier (\"class\");\n@@ -2018,28 +2221,42 @@ build_invokeinterface (tree dtable, tree method)\n   \n   if (flag_indirect_dispatch)\n     {\n-      otable_index\n-\t= build_int_cst (NULL_TREE, get_symbol_table_index \n-\t\t\t (method, &TYPE_OTABLE_METHODS (output_class)));\n-      idx = build4 (ARRAY_REF, integer_type_node,\n-\t\t    TYPE_OTABLE_DECL (output_class), otable_index,\n-\t\t    NULL_TREE, NULL_TREE);\n+      int itable_index \n+\t= 2 * (get_symbol_table_index \n+\t       (method, &TYPE_ITABLE_METHODS (output_class)));\n+      interface \n+\t= build4 (ARRAY_REF, \n+\t\t TREE_TYPE (TREE_TYPE (TYPE_ITABLE_DECL (output_class))),\n+\t\t TYPE_ITABLE_DECL (output_class), \n+\t\t  build_int_cst (NULL_TREE, itable_index-1),\n+\t\t  NULL_TREE, NULL_TREE);\n+      idx \n+\t= build4 (ARRAY_REF, \n+\t\t TREE_TYPE (TREE_TYPE (TYPE_ITABLE_DECL (output_class))),\n+\t\t TYPE_ITABLE_DECL (output_class), \n+\t\t  build_int_cst (NULL_TREE, itable_index),\n+\t\t  NULL_TREE, NULL_TREE);\n+      interface = convert (class_ptr_type, interface);\n+      idx = convert (integer_type_node, idx);\n     }\n   else\n-    idx = build_int_cst (NULL_TREE,\n-\t\t\t get_interface_method_index (method, interface));\n-\n-  lookup_arg = tree_cons (NULL_TREE, dtable,\n-                          tree_cons (NULL_TREE, build_class_ref (interface),\n-\t\t\t             build_tree_list (NULL_TREE, idx)));\n+    {\n+      idx = build_int_cst (NULL_TREE, \n+\t\t\t   get_interface_method_index (method, interface));\n+      interface = build_class_ref (interface);\n+    }\n \t\t\t\t     \t\t\t  \n+  lookup_arg = tree_cons (NULL_TREE, dtable,\n+\t\t\t  tree_cons (NULL_TREE, interface,\n+\t\t\t\t     build_tree_list (NULL_TREE, idx)));\n+\n   return build3 (CALL_EXPR, ptr_type_node, \n \t\t build_address_of (soft_lookupinterfacemethod_node),\n \t\t lookup_arg, NULL_TREE);\n }\n   \n /* Expand one of the invoke_* opcodes.\n-   OCPODE is the specific opcode.\n+   OPCODE is the specific opcode.\n    METHOD_REF_INDEX is an index into the constant pool.\n    NARGS is the number of arguments, or -1 if not specified. */\n \n@@ -2048,7 +2265,8 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n {\n   tree method_signature\n     = COMPONENT_REF_SIGNATURE(&current_jcf->cpool, method_ref_index);\n-  tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool, method_ref_index);\n+  tree method_name = COMPONENT_REF_NAME (&current_jcf->cpool,\n+\t\t\t\t\t method_ref_index);\n   tree self_type\n     = get_class_constant (current_jcf,\n                           COMPONENT_REF_CLASS_INDEX(&current_jcf->cpool,\n@@ -2071,38 +2289,82 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n     method = lookup_java_constructor (self_type, method_signature);\n   else\n     method = lookup_java_method (self_type, method_name, method_signature);\n+\n+  /* We've found a method in an interface, but this isn't an interface\n+     call.  */\n+  if (opcode != OPCODE_invokeinterface\n+      && method\n+      && (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method)))))\n+    method = NULL_TREE;\n+\n+  /* We've found a non-interface method but we are making an\n+     interface call.  This can happen if the interface overrides a\n+     method in Object.  */\n+  if (! flag_verify_invocations\n+      && opcode == OPCODE_invokeinterface\n+      && method\n+      && ! CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n+    method = NULL_TREE;\n+\n   if (method == NULL_TREE)\n     {\n-      error (\"class '%s' has no method named '%s' matching signature '%s'\",\n-\t     self_name,\n-\t     IDENTIFIER_POINTER (method_name),\n-\t     IDENTIFIER_POINTER (method_signature));\n-    }\n-  /* Invoke static can't invoke static/abstract method */\n-  else if (opcode == OPCODE_invokestatic)\n-    {\n-      if (!METHOD_STATIC (method))\n+      if (flag_verify_invocations || ! flag_indirect_dispatch)\n \t{\n-\t  error (\"invokestatic on non static method\");\n-\t  method = NULL_TREE;\n+\t  error (\"class '%s' has no method named '%s' matching signature '%s'\",\n+\t\t self_name,\n+\t\t IDENTIFIER_POINTER (method_name),\n+\t\t IDENTIFIER_POINTER (method_signature));\n \t}\n-      else if (METHOD_ABSTRACT (method))\n+      else\n \t{\n-\t  error (\"invokestatic on abstract method\");\n-\t  method = NULL_TREE;\n+\t  int flags = ACC_PUBLIC;\n+\t  if (opcode == OPCODE_invokestatic)\n+\t    flags |= ACC_STATIC;\n+\t  if (opcode == OPCODE_invokeinterface)\n+\t    {\n+\t      flags |= ACC_INTERFACE | ACC_ABSTRACT;\n+\t      CLASS_INTERFACE (TYPE_NAME (self_type)) = 1;\n+\t    }\n+\t  method = add_method (self_type, flags, method_name,\n+\t\t\t       method_signature);\n+\t  DECL_ARTIFICIAL (method) = 1;\n+\t  METHOD_DUMMY (method) = 1;\n+\t  layout_class_method (self_type, NULL,\n+\t\t\t       method, NULL);\n \t}\n     }\n-  else\n+\n+  /* Invoke static can't invoke static/abstract method */\n+  if (method != NULL_TREE)\n     {\n-      if (METHOD_STATIC (method))\n+      if (opcode == OPCODE_invokestatic)\n \t{\n-\t  error (\"invoke[non-static] on static method\");\n-\t  method = NULL_TREE;\n+\t  if (!METHOD_STATIC (method))\n+\t    {\n+\t      error (\"invokestatic on non static method\");\n+\t      method = NULL_TREE;\n+\t    }\n+\t  else if (METHOD_ABSTRACT (method))\n+\t    {\n+\t      error (\"invokestatic on abstract method\");\n+\t      method = NULL_TREE;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (METHOD_STATIC (method))\n+\t    {\n+\t      error (\"invoke[non-static] on static method\");\n+\t      method = NULL_TREE;\n+\t    }\n \t}\n     }\n \n   if (method == NULL_TREE)\n     {\n+      /* If we got here, we emitted an error message above.  So we\n+\t just pop the arguments, push a properly-typed zero, and\n+\t continue.  */\n       method_type = get_type_from_signature (method_signature);\n       pop_arguments (TYPE_ARG_TYPES (method_type));\n       if (opcode != OPCODE_invokestatic) \n@@ -2385,6 +2647,7 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n   tree new_value = is_putting ? pop_value (field_type) : NULL_TREE;\n   tree field_ref;\n   int is_error = 0;\n+  tree original_self_type = self_type;\n   tree field_decl;\n   \n   if (! CLASS_LOADED_P (self_type))\n@@ -2396,9 +2659,23 @@ expand_java_field_op (int is_static, int is_putting, int field_ref_index)\n     }\n   else if (field_decl == NULL_TREE)\n     {\n-      error (\"missing field '%s' in '%s'\",\n-\t     IDENTIFIER_POINTER (field_name), self_name);\n-      is_error = 1;\n+      if (! flag_verify_invocations)\n+\t{\n+\t  int flags = ACC_PUBLIC;\n+\t  if (is_static)\n+\t    flags |= ACC_STATIC;\n+\t  self_type = original_self_type;\n+\t  field_decl = add_field (original_self_type, field_name,\n+\t\t\t\t  field_type, flags); \n+\t  DECL_ARTIFICIAL (field_decl) = 1;\n+\t  DECL_IGNORED_P (field_decl) = 1;\n+\t}\n+      else\n+\t{      \n+\t  error (\"missing field '%s' in '%s'\",\n+\t\t IDENTIFIER_POINTER (field_name), self_name);\n+\t  is_error = 1;\n+      }\n     }\n   else if (build_java_signature (TREE_TYPE (field_decl)) != field_signature)\n     {\n@@ -2637,8 +2914,16 @@ expand_byte_code (JCF *jcf, tree method)\n \t}\n     }  \n \n-  if (! verify_jvm_instructions (jcf, byte_ops, length))\n-    return;\n+  if (flag_new_verifier)\n+    {\n+      if (! verify_jvm_instructions_new (jcf, byte_ops, length))\n+        return;\n+    }\n+  else\n+    {\n+      if (! verify_jvm_instructions (jcf, byte_ops, length))\n+\treturn;\n+    }\n \n   /* Translate bytecodes.  */\n   linenumber_pointer = linenumber_table;\n@@ -2749,8 +3034,14 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n      replace the top of the stack with the thrown object reference */\n   if (instruction_bits [PC] & BCODE_EXCEPTION_TARGET)\n     {\n-      tree type = pop_type (ptr_type_node);\n-      push_value (build_exception_object_ref (type));\n+      /* Note that the new verifier will not emit a type map at all\n+\t for dead exception handlers.  In this case we just ignore\n+\t the situation.  */\n+      if (! flag_new_verifier || (instruction_bits[PC] & BCODE_VERIFIED) != 0)\n+\t{\n+\t  tree type = pop_type (promote_type (throwable_type_node));\n+\t  push_value (build_exception_object_ref (type));\n+\t}\n     }\n \n   switch (byte_ops[PC++])"}, {"sha": "370585a7affc05aec3bba4d62a3dcb7ceb364a32", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -873,7 +873,7 @@ gij [@option{-jar}] [@option{OPTION}] @dots{} @var{CLASS} [@var{ARGS}@dots{}]\n   [@option{-cp} @var{path}] [@option{-classpath} @var{path}]\n   [@option{-D}@var{name}[=@var{value}]@dots{}]\n   [@option{-ms=}@var{number}] [@option{-mx=}@var{number}]\n-  [@option{-X@var{argument}]\n+  [@option{-X@var{argument}}] [@option{-verbose}] [@option{-verbose:class}]\n   [@option{--showversion}] [@option{--version}] [@option{--help}][@option{-?}]\n @c man end\n @c man begin SEEALSO gij\n@@ -954,7 +954,8 @@ Print version number and continue.\n @item --version\n Print version number, then exit.\n \n-@item -verbose:class\n+@item -verbose\n+@itemx -verbose:class\n Each time a class is initialized, print a short message on standard error.\n @end table\n \n@@ -2385,6 +2386,24 @@ property is set to @samp{cache}, then any failed lookups are cached\n and not tried again.  If this property is set to @samp{never}, then\n lookups are never done.  For more information, @xref{Extensions}.\n \n+@item gnu.gcj.jit.compiler\n+@c FIXME we should probably have a whole node on this...\n+This is the full path to @command{gcj} executable which should be\n+used to compile classes just-in-time when\n+@code{ClassLoader.defineClass} is called.  If not set, @command{gcj}\n+will not be invoked by the runtime; this can also be controlled via\n+@code{Compiler.disable}.\n+\n+@item gnu.gcj.jit.options\n+This is a space-separated string of options which should be passed to\n+@command{gcj} when in JIT mode.  If not set, a sensible default is\n+chosen.\n+\n+@item gnu.gcj.jit.cachedir\n+This is the directory where cached shared library files are\n+stored.  If not set, JIT compilation is disabled.  This should never\n+be set to a directory that is writable by any other user.\n+\n @end table\n \n "}, {"sha": "0badaf1982955d1bdd31f8466e8913039e83cdda", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -112,6 +112,9 @@ static JCF_u2 last_access;\n #define METHOD_IS_NATIVE(Method) \\\n    ((Method) & ACC_NATIVE)\n \n+#define METHOD_IS_PRIVATE(Class, Method) \\\n+  (((Method) & ACC_PRIVATE) != 0)\n+\n /* We keep a linked list of all method names we have seen.  This lets\n    us determine if a method name and a field name are in conflict.  */\n struct method_name\n@@ -937,7 +940,7 @@ print_method_info (FILE *stream, JCF* jcf, int name_index, int sig_index,\n       fputs (\"  \", out);\n       if ((flags & ACC_STATIC))\n \tfputs (\"static \", out);\n-      else if (! METHOD_IS_FINAL (jcf->access_flags, flags))\n+      else if (! METHOD_IS_PRIVATE (jcf->access_flags, flags))\n \t{\n \t  /* Don't print `virtual' if we have a constructor.  */\n \t  if (! is_init)"}, {"sha": "45e4f0aa8e9470715a924dfec052a1c5010b9ea2", "filename": "gcc/java/java-except.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -53,6 +53,8 @@ struct eh_range\n \n     /* The TRY_CATCH_EXPR for this EH range.  */\n     tree stmt;\n+\n+    tree handler;\n   };\n \n /* A dummy range that represents the entire method. */"}, {"sha": "e8144ee908c2eefda9a2631d039ce6b24db2e9e6", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 69, "deletions": 6, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -227,6 +227,9 @@ extern int flag_indirect_dispatch;\n /* When zero, don't generate runtime array store checks. */\n extern int flag_store_check;\n \n+/* When nonzero, use the new bytecode verifier.  */\n+extern int flag_new_verifier;\n+\n /* Encoding used for source files.  */\n extern const char *current_encoding;\n \n@@ -237,6 +240,8 @@ extern GTY(()) struct JCF * current_jcf;\n    before static field references.  */\n extern int always_initialize_class_p;\n \n+extern int flag_verify_invocations;\n+\n typedef struct CPool constant_pool;\n \n #define CONSTANT_ResolvedFlag 16\n@@ -367,9 +372,13 @@ enum java_tree_index\n   JTI_OTABLE_PTR_TYPE,\n   JTI_ATABLE_TYPE,\n   JTI_ATABLE_PTR_TYPE,\n+  JTI_ITABLE_TYPE,\n+  JTI_ITABLE_PTR_TYPE,\n   JTI_SYMBOL_TYPE,\n   JTI_SYMBOLS_ARRAY_TYPE,\n   JTI_SYMBOLS_ARRAY_PTR_TYPE,\n+  JTI_ASSERTION_ENTRY_TYPE,\n+  JTI_ASSERTION_TABLE_TYPE,\n \n   JTI_END_PARAMS_NODE,\n \n@@ -388,6 +397,7 @@ enum java_tree_index\n   JTI_SOFT_MONITORENTER_NODE,\n   JTI_SOFT_MONITOREXIT_NODE,\n   JTI_SOFT_LOOKUPINTERFACEMETHOD_NODE,\n+  JTI_SOFT_LOOKUPINTERFACEMETHODBYNAME_NODE,\n   JTI_SOFT_LOOKUPJNIMETHOD_NODE,\n   JTI_SOFT_GETJNIENVNEWFRAME_NODE,\n   JTI_SOFT_JNIPOPSYSTEMFRAME_NODE,\n@@ -597,18 +607,24 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_OTABLE_TYPE]\n #define atable_type \\\n   java_global_trees[JTI_ATABLE_TYPE]\n+#define itable_type \\\n+  java_global_trees[JTI_ITABLE_TYPE]\n #define otable_ptr_type \\\n   java_global_trees[JTI_OTABLE_PTR_TYPE]\n #define atable_ptr_type \\\n   java_global_trees[JTI_ATABLE_PTR_TYPE]\n+#define itable_ptr_type \\\n+  java_global_trees[JTI_ITABLE_PTR_TYPE]\n #define symbol_type \\\n   java_global_trees[JTI_SYMBOL_TYPE]\n #define symbols_array_type \\\n   java_global_trees[JTI_SYMBOLS_ARRAY_TYPE]\n #define symbols_array_ptr_type \\\n-  java_global_trees[JTI_SYMBOLS_ARRAY_PTR_TYPE]\n-#define class_refs_decl \\\n-  Jjava_global_trees[TI_CLASS_REFS_DECL]\n+  java_global_trees[JTI_SYMBOLS_ARRAY_PTR_TYPE]  \n+#define assertion_entry_type \\\n+  java_global_trees[JTI_ASSERTION_ENTRY_TYPE]\n+#define assertion_table_type \\\n+  java_global_trees[JTI_ASSERTION_TABLE_TYPE]\n \n #define end_params_node \\\n   java_global_trees[JTI_END_PARAMS_NODE]\n@@ -644,6 +660,8 @@ extern GTY(()) tree java_global_trees[JTI_MAX];\n   java_global_trees[JTI_SOFT_MONITOREXIT_NODE]\n #define soft_lookupinterfacemethod_node \\\n   java_global_trees[JTI_SOFT_LOOKUPINTERFACEMETHOD_NODE]\n+#define soft_lookupinterfacemethodbyname_node \\\n+  java_global_trees[JTI_SOFT_LOOKUPINTERFACEMETHODBYNAME_NODE]\n #define soft_lookupjnimethod_node \\\n   java_global_trees[JTI_SOFT_LOOKUPJNIMETHOD_NODE]\n #define soft_getjnienvnewframe_node \\\n@@ -984,6 +1002,7 @@ struct lang_decl_func GTY(())\n   unsigned int invisible : 1;\t/* Set for methods we generate\n \t\t\t\t   internally but which shouldn't be\n \t\t\t\t   written to the .class file.  */\n+  unsigned int dummy:1;\t\t\n };\n \n struct treetreehash_entry GTY(())\n@@ -992,6 +1011,22 @@ struct treetreehash_entry GTY(())\n   tree value;\n };\n \n+/* These represent the possible assertion_code's that can be emitted in the\n+   type assertion table.  */\n+enum\n+{\n+  JV_ASSERT_END_OF_TABLE = 0,     /* Last entry in table.  */\n+  JV_ASSERT_TYPES_COMPATIBLE = 1, /* Operand A is assignable to Operand B.  */\n+  JV_ASSERT_IS_INSTANTIABLE = 2   /* Operand A is an instantiable class.  */\n+};\n+\n+typedef struct type_assertion GTY(())\n+{\n+  int assertion_code; /* 'opcode' for the type of this assertion. */\n+  tree op1;           /* First operand. */\n+  tree op2;           /* Second operand. */\n+} type_assertion;\n+\n extern tree java_treetreehash_find (htab_t, tree);\n extern tree * java_treetreehash_new (htab_t, tree);\n extern htab_t java_treetreehash_create (size_t size, int ggc);\n@@ -1043,6 +1078,9 @@ struct lang_decl GTY(())\n #define TYPE_II_STMT_LIST(T)     (TYPE_LANG_SPECIFIC (T)->ii_block)\n /* The decl of the synthetic method `class$' used to handle `.class'\n    for non primitive types when compiling to bytecode. */\n+\n+#define TYPE_DUMMY(T)\t\t(TYPE_LANG_SPECIFIC(T)->dummy_class)\n+\n #define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC (T)->dot_class)\n #define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC (T)->package_list)\n #define TYPE_IMPORT_LIST(T)      (TYPE_LANG_SPECIFIC (T)->import_list)\n@@ -1060,10 +1098,16 @@ struct lang_decl GTY(())\n #define TYPE_OTABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->otable_syms_decl)\n #define TYPE_OTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->otable_decl)\n \n+#define TYPE_ITABLE_METHODS(T)   (TYPE_LANG_SPECIFIC (T)->itable_methods)\n+#define TYPE_ITABLE_SYMS_DECL(T) (TYPE_LANG_SPECIFIC (T)->itable_syms_decl)\n+#define TYPE_ITABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->itable_decl)\n+\n #define TYPE_CTABLE_DECL(T)      (TYPE_LANG_SPECIFIC (T)->ctable_decl)\n #define TYPE_CATCH_CLASSES(T)    (TYPE_LANG_SPECIFIC (T)->catch_classes)\n+#define TYPE_VERIFY_METHOD(T)    (TYPE_LANG_SPECIFIC (T)->verify_method)\n \n #define TYPE_TO_RUNTIME_MAP(T)   (TYPE_LANG_SPECIFIC (T)->type_to_runtime_map)\n+#define TYPE_ASSERTIONS(T)   \t (TYPE_LANG_SPECIFIC (T)->type_assertions)\n \n struct lang_type GTY(())\n {\n@@ -1092,18 +1136,31 @@ struct lang_type GTY(())\n   tree atable_decl;\t\t/* The static address table.  */\n   tree atable_syms_decl;\n \n+  tree itable_methods;          /* List of interfaces methods referred\n+\t\t\t\t   to by this class.  */\n+  tree itable_decl;\t\t/* The interfaces table.  */\n+  tree itable_syms_decl;\n+\n   tree ctable_decl;             /* The table of classes for the runtime\n \t\t\t\t   type matcher.  */\n   tree catch_classes;\n \n+  tree verify_method;\t\t/* The verify method for this class.\n+\t\t\t\t   Used in split verification.  */\n+\n   htab_t GTY ((param_is (struct treetreehash_entry))) type_to_runtime_map;   \n                                 /* The mapping of classes to exception region\n \t\t\t\t   markers.  */\n \n+  htab_t GTY ((param_is (struct type_assertion))) type_assertions;\n+\t\t\t\t/* Table of type assertions to be evaluated \n+  \t\t\t\t   by the runtime when this class is loaded. */\n+\n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n   unsigned strictfp:1;\t\t/* `strictfp' class.  */\n   unsigned assertions:1;\t/* Any method uses `assert'.  */\n+  unsigned dummy_class:1;\t\t/* Not a real class, just a placeholder.  */\n };\n \n #define JCF_u4 unsigned long\n@@ -1243,7 +1300,7 @@ extern void make_class_data (tree);\n extern void register_class (void);\n extern int alloc_name_constant (int, tree);\n extern void emit_register_classes (tree *);\n-extern tree emit_symbol_table (tree, tree, tree, tree, tree);\n+extern tree emit_symbol_table (tree, tree, tree, tree, tree, int);\n extern void lang_init_source (int);\n extern void write_classfile (tree);\n extern char *print_int_node (tree);\n@@ -1259,9 +1316,12 @@ extern int alloc_class_constant (tree);\n extern void init_expr_processing (void);\n extern void push_super_field (tree, tree);\n extern void init_class_processing (void);\n+extern void add_type_assertion (tree, int, tree, tree);\n extern int can_widen_reference_to (tree, tree);\n extern int class_depth (tree);\n extern int verify_jvm_instructions (struct JCF *, const unsigned char *, long);\n+extern int verify_jvm_instructions_new (struct JCF *, const unsigned char *,\n+\t\t\t\t\tlong);\n extern void maybe_pushlevels (int);\n extern void maybe_poplevels (int);\n extern void force_poplevels (int);\n@@ -1274,6 +1334,7 @@ extern void push_type (tree);\n extern void load_type_state (tree);\n extern void add_interface (tree, tree);\n extern tree force_evaluation_order (tree);\n+extern tree java_create_object (tree);\n extern int verify_constant_pool (struct JCF *);\n extern void start_java_method (tree);\n extern void end_java_method (void);\n@@ -1321,7 +1382,6 @@ extern tree java_mangle_decl (struct obstack *, tree);\n extern tree java_mangle_class_field (struct obstack *, tree);\n extern tree java_mangle_class_field_from_string (struct obstack *, char *);\n extern tree java_mangle_vtable (struct obstack *, tree);\n-extern const char *lang_printable_name_wls (tree, int);\n extern void append_gpp_mangled_name (const char *, int);\n \n extern void add_predefined_file (tree);\n@@ -1363,6 +1423,8 @@ extern tree builtin_function (const char *, tree, int, enum built_in_class,\n \n /* Access flags etc for a method (a FUNCTION_DECL): */\n \n+#define METHOD_DUMMY(DECL) (DECL_LANG_SPECIFIC (DECL)->u.f.dummy)\n+\n #define METHOD_PUBLIC(DECL) DECL_LANG_FLAG_1 (FUNCTION_DECL_CHECK (DECL))\n #define METHOD_PRIVATE(DECL) TREE_PRIVATE (FUNCTION_DECL_CHECK (DECL))\n #define METHOD_PROTECTED(DECL) TREE_PROTECTED (FUNCTION_DECL_CHECK (DECL))\n@@ -1800,7 +1862,8 @@ enum\n \n   JV_STATE_PRELOADING = 1,\t/* Can do _Jv_FindClass.  */\n   JV_STATE_LOADING = 3,\t\t/* Has super installed.  */\n-  JV_STATE_LOADED = 5,\t\t/* Is complete.  */\n+  JV_STATE_READ = 4,\t\t/* Has been completely defined.  */\n+  JV_STATE_LOADED = 5,\t\t/* Has Miranda methods defined.  */\n \n   JV_STATE_COMPILED = 6,\t/* This was a compiled class.  */\n "}, {"sha": "a7cd57a6d77acdc92057d0be0e7a1d765ee91a32", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 111, "deletions": 31, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -610,8 +610,14 @@ void\n load_class (tree class_or_name, int verbose)\n {\n   tree name, saved;\n-  int class_loaded;\n-  tree class_decl;\n+  int class_loaded = 0;\n+  tree class_decl = NULL_TREE;\n+  bool is_compiled_class = false;\n+\n+  /* We've already failed, don't try again.  */\n+  if (TREE_CODE (class_or_name) == RECORD_TYPE\n+      && TYPE_DUMMY (class_or_name))\n+    return;\n \n   /* class_or_name can be the name of the class we want to load */\n   if (TREE_CODE (class_or_name) == IDENTIFIER_NODE)\n@@ -624,41 +630,99 @@ load_class (tree class_or_name, int verbose)\n   else\n     name = DECL_NAME (TYPE_NAME (class_or_name));\n \n+  class_decl = IDENTIFIER_CLASS_VALUE (name);\n+  if (class_decl != NULL_TREE)\n+    {\n+      tree type = TREE_TYPE (class_decl);\n+      is_compiled_class\n+\t= ((TYPE_JCF (type) && JCF_SEEN_IN_ZIP (TYPE_JCF (type)))\n+\t   || CLASS_FROM_CURRENTLY_COMPILED_P (type));\n+    }\n+\n   /* If the class is from source code, then it must already be loaded.  */\n   class_decl = IDENTIFIER_CLASS_VALUE (name);\n   if (class_decl && CLASS_FROM_SOURCE_P (TREE_TYPE (class_decl)))\n     return;\n \n   saved = name;\n-  while (1)\n+  \n+  /* If flag_verify_invocations is unset, we don't try to load a class\n+     unless we're looking for Object (which is fixed by the ABI) or\n+     it's a class that we're going to compile.  */\n+  if (flag_verify_invocations\n+      || class_or_name == object_type_node\n+      || is_compiled_class\n+      || TREE_CODE (class_or_name) == IDENTIFIER_NODE)\n     {\n-      char *separator;\n+      while (1)\n+\t{\n+\t  char *separator;\n \n-      if ((class_loaded = read_class (name)))\n-\tbreak;\n+\t  /* We've already loaded it.  */\n+\t  if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE)\n+\t    {\n+\t      tree tmp_decl = IDENTIFIER_CLASS_VALUE (name);\n+\t      if (CLASS_PARSED_P (TREE_TYPE (tmp_decl)))\n+\t\tbreak;\n+\t    }\n+\t\n+\t  if (read_class (name))\n+\t    break;\n \n-      /* We failed loading name. Now consider that we might be looking\n-\t for a inner class. */\n-      if ((separator = strrchr (IDENTIFIER_POINTER (name), '$'))\n-\t  || (separator = strrchr (IDENTIFIER_POINTER (name), '.')))\n-\t{\n-\t  int c = *separator;\n-\t  *separator = '\\0';\n-\t  name = get_identifier (IDENTIFIER_POINTER (name));\n-\t  *separator = c;\n-\n-\t  /* Otherwise we might get infinite recursion, if say we have\n-\t     String.class but not String$CaseInsensitiveComparator.class. */\n-\t  if (current_jcf && current_jcf->java_source == 0)\n+\t  /* We failed loading name. Now consider that we might be looking\n+\t     for a inner class. */\n+\t  if ((separator = strrchr (IDENTIFIER_POINTER (name), '$'))\n+\t      || (separator = strrchr (IDENTIFIER_POINTER (name), '.')))\n+\t    {\n+\t      int c = *separator;\n+\t      *separator = '\\0';\n+\t      name = get_identifier (IDENTIFIER_POINTER (name));\n+\t      *separator = c;\n+\n+\t      /* Otherwise we might get infinite recursion, if say we\n+\t\t have String.class but not\n+\t\t String$CaseInsensitiveComparator.class. */\n+\t      if (current_jcf && current_jcf->java_source == 0)\n+\t\tbreak;\n+\t    }\n+\t  /* Otherwise, we failed, we bail. */\n+\t  else\n \t    break;\n \t}\n-      /* Otherwise, we failed, we bail. */\n-      else\n-\tbreak;\n-    }\n \n-  if (!class_loaded && verbose)\n-    error (\"cannot find file for class %s\", IDENTIFIER_POINTER (saved));\n+      {\n+\t/* have we found the class we're looking for?  */\n+\ttree type_decl = IDENTIFIER_CLASS_VALUE (saved);\n+\ttree type = type_decl ? TREE_TYPE (type_decl) : NULL;\n+\tclass_loaded = type && CLASS_PARSED_P (type);\n+      }\t      \n+    }\n+  \n+  if (!class_loaded)\n+    {\n+      if (flag_verify_invocations || ! flag_indirect_dispatch\n+\t  || flag_emit_class_files)\n+\t{\n+\t  if (verbose)\n+\t    error (\"cannot find file for class %s\", IDENTIFIER_POINTER (saved));\n+\t}\n+      else if (verbose)\n+\t{\n+\t  /* This is just a diagnostic during testing, not a real problem.  */\n+\t  if (!quiet_flag)\n+\t    warning(\"cannot find file for class %s\", \n+\t\t    IDENTIFIER_POINTER (saved));\n+\t  \n+\t  /* Fake it.  */\n+\t  if (TREE_CODE (class_or_name) == RECORD_TYPE)\n+\t    {\n+\t      set_super_info (0, class_or_name, object_type_node, 0);\n+\t      TYPE_DUMMY (class_or_name) = 1;\n+\t      /* We won't be able to output any debug info for this class.  */\n+\t      DECL_IGNORED_P (TYPE_NAME (class_or_name)) = 1;\n+\t    }\n+\t}\n+    }\n }\n \n /* Parse the .class file JCF. */\n@@ -760,6 +824,7 @@ parse_class_file (void)\n   java_layout_seen_class_methods ();\n \n   input_location = DECL_SOURCE_LOCATION (TYPE_NAME (current_class));\n+  file_start_location = input_location;\n   (*debug_hooks->start_source_file) (input_line, input_filename);\n \n   /* Currently we always have to emit calls to _Jv_InitClass when\n@@ -775,7 +840,7 @@ parse_class_file (void)\n     {\n       JCF *jcf = current_jcf;\n \n-      if (METHOD_ABSTRACT (method))\n+      if (METHOD_ABSTRACT (method) || METHOD_DUMMY (method))\n \tcontinue;\n \n       if (METHOD_NATIVE (method))\n@@ -911,6 +976,7 @@ static void\n parse_source_file_2 (void)\n {\n   int save_error_count = java_error_count;\n+  flag_verify_invocations = true;\n   java_complete_class ();\t    /* Parse unsatisfied class decl. */\n   java_parse_abort_on_error ();\n }\n@@ -1196,7 +1262,12 @@ java_parse_file (int set_yydebug ATTRIBUTE_UNUSED)\n       input_location = DECL_SOURCE_LOCATION (node);\n       if (CLASS_FILE_P (node))\n \t{\n+\t  /* FIXME: These two flags really should be independent.  We\n+\t     should be able to compile fully binary compatible, but\n+\t     with flag_verify_invocations on.  */\n+\t  flag_verify_invocations = ! flag_indirect_dispatch;\n \t  output_class = current_class = TREE_TYPE (node);\n+\n \t  current_jcf = TYPE_JCF (current_class);\n \t  layout_class (current_class);\n \t  load_inner_classes (current_class);\n@@ -1232,13 +1303,15 @@ compute_class_name (struct ZipDirectory *zdir)\n   char *class_name_in_zip_dir = ZIPDIR_FILENAME (zdir);\n   char *class_name;\n   int i;\n-  int filename_length;\n+  int filename_length = zdir->filename_length;\n \n-  while (strncmp (class_name_in_zip_dir, \"./\", 2) == 0)\n-    class_name_in_zip_dir += 2;\n+  while (filename_length > 2 && strncmp (class_name_in_zip_dir, \"./\", 2) == 0)\n+    {\n+      class_name_in_zip_dir += 2;\n+      filename_length -= 2;\n+    }\n \n-  filename_length = (strlen (class_name_in_zip_dir)\n-\t\t     - strlen (\".class\"));\n+  filename_length -= strlen (\".class\");\n   class_name = ALLOC (filename_length + 1);\n   memcpy (class_name, class_name_in_zip_dir, filename_length);\n   class_name [filename_length] = '\\0';\n@@ -1300,6 +1373,13 @@ parse_zip_file_entries (void)\n \t    current_jcf = TYPE_JCF (class);\n \t    output_class = current_class = class;\n \n+\t    if (TYPE_DUMMY (class))\n+\t      {\n+\t\t/* This is a dummy class, and now we're compiling it\n+\t\t   for real.  */\n+\t\tabort ();\n+\t      }\n+\n \t    /* This is for a corner case where we have a superclass\n \t       but no superclass fields.  \n "}, {"sha": "a3e8c6fd317aef64483899f097693cfbe8892024", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -68,7 +68,7 @@ static const char jvgenmain_spec[] =\n \t\t   %<fcompile-resource* %<fassert %<fno-assert \\\n \t\t   %<femit-class-file %<femit-class-files %<fencoding*\\\n \t\t   %<fuse-boehm-gc %<fhash-synchronization %<fjni\\\n-\t\t   %<findirect-dispatch \\\n+\t\t   %<findirect-dispatch %<fnew-verifier\\\n \t\t   %<fno-store-check %<foutput-class-dir\\\n \t\t   %<fclasspath* %<fCLASSPATH* %<fbootclasspath*\\\n \t\t   %<fextdirs*\\"}, {"sha": "bcf4e45b4bb98affa978cbad1f9beed9b4a28a4e", "filename": "gcc/java/lang.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -128,6 +128,17 @@ int flag_wall = 0;\n /* The encoding of the source file.  */\n const char *current_encoding = NULL;\n \n+/* When nonzero, report use of deprecated classes, methods, or fields.  */\n+int flag_deprecated = 1;\n+\n+/* When zero, don't optimize static class initialization. This flag shouldn't\n+   be tested alone, use STATIC_CLASS_INITIALIZATION_OPTIMIZATION_P instead.  */\n+/* FIXME: Make this work with gimplify.  */\n+/* int flag_optimize_sci = 0;  */\n+\n+/* Don't attempt to verify invocations.  */\n+int flag_verify_invocations = 0; \n+\n /* When nonzero, print extra version information.  */\n static int v_flag = 0;\n \n@@ -593,6 +604,11 @@ java_post_options (const char **pfilename)\n   if (flag_inline_functions)\n     flag_inline_trees = 2;\n \n+  /* An absolute requirement: if we're not using indirect dispatch, we\n+     must always verify everything.  */\n+  if (! flag_indirect_dispatch)\n+    flag_verify_invocations = true;\n+\n   /* Open input file.  */\n \n   if (filename == 0 || !strcmp (filename, \"-\"))\n@@ -972,6 +988,10 @@ java_get_callee_fndecl (tree call_expr)\n \n   HOST_WIDE_INT index;\n \n+  /* FIXME: This is disabled because we end up passing calls through\n+     the PLT, and we do NOT want to do that.  */\n+  return NULL;\n+\n   if (TREE_CODE (call_expr) != CALL_EXPR)\n     return NULL;\n   method = TREE_OPERAND (call_expr, 0);"}, {"sha": "644bd5be2e7939d0899821f1f7fac8e2ff203a49", "filename": "gcc/java/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.opt?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -176,5 +176,9 @@ fuse-divide-subroutine\n Java Var(flag_use_divide_subroutine) Init(1)\n Call a library routine to do integer divisions\n \n+fnew-verifier\n+Java Var(flag_new_verifier)\n+Enable the new bytecode verifier\n+\n version\n Java"}, {"sha": "91776c6f7f53cc6f8efee11fe79cc04ffcbdb0b5", "filename": "gcc/java/parse.y", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -9690,8 +9690,8 @@ strip_out_static_field_access_decl (tree node)\n \t   tree call = TREE_OPERAND (op1, 0);\n \t   if (TREE_CODE (call) == CALL_EXPR\n \t       && TREE_CODE (TREE_OPERAND (call, 0)) == ADDR_EXPR\n-\t       && TREE_OPERAND (TREE_OPERAND (call, 0), 0)\n-\t       == soft_initclass_node)\n+\t       && (TREE_OPERAND (TREE_OPERAND (call, 0), 0)\n+\t\t   == soft_initclass_node))\n \t     return TREE_OPERAND (op1, 1);\n \t }\n       else if (JDECL_P (op1))\n@@ -11025,7 +11025,7 @@ patch_invoke (tree patch, tree method, tree args)\n   if (TREE_CODE (original_call) == NEW_CLASS_EXPR)\n     {\n       tree class = DECL_CONTEXT (method);\n-      tree c1, saved_new, size, new;\n+      tree c1, saved_new, new;\n       tree alloc_node;\n \n       if (flag_emit_class_files || flag_emit_xref)\n@@ -11035,7 +11035,6 @@ patch_invoke (tree patch, tree method, tree args)\n \t}\n       if (!TYPE_SIZE (class))\n \tsafe_layout_class (class);\n-      size = size_in_bytes (class);\n       alloc_node =\n \t(class_has_finalize_method (class) ? alloc_object_node\n \t\t  \t\t\t   : alloc_no_finalizer_node);\n@@ -11109,11 +11108,20 @@ invocation_mode (tree method, int super)\n   if (DECL_CONSTRUCTOR_P (method))\n     return INVOKE_STATIC;\n \n-  if (access & ACC_FINAL || access & ACC_PRIVATE)\n+  if (access & ACC_PRIVATE)\n     return INVOKE_NONVIRTUAL;\n \n-  if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n-    return INVOKE_NONVIRTUAL;\n+  /* Binary compatibility: just because it's final today, that doesn't\n+     mean it'll be final tomorrow.  */\n+  if (! flag_indirect_dispatch  \n+      || DECL_CONTEXT (method) == object_type_node)\n+    {\n+      if (access & ACC_FINAL)\n+\treturn INVOKE_NONVIRTUAL;\n+\n+      if (CLASS_FINAL (TYPE_NAME (DECL_CONTEXT (method))))\n+\treturn INVOKE_NONVIRTUAL;\n+    }\n \n   if (CLASS_INTERFACE (TYPE_NAME (DECL_CONTEXT (method))))\n     return INVOKE_INTERFACE;"}, {"sha": "4db69b4ea0c3c72cb328d55145454280b3ecfd14", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -743,7 +743,7 @@ lookup_java_method (tree searched_class, tree method_name,\n \t\t    method_signature, build_java_signature);\n }\n \n-/* Return true iff CLASS (or its ancestors) has a method METHOD_NAME.  */\n+/* Return true iff CLASS (or its ancestors) has a method METHOD_NAME. \ufffd*/\n int\n has_method (tree class, tree method_name)\n {"}, {"sha": "fb213405e432434d871d9ddacd6932c2a0483b4a", "filename": "gcc/java/verify-glue.c", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify-glue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify-glue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-glue.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,514 @@\n+/* Glue to interface gcj with bytecode verifier.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Tom Tromey <tromey@redhat.com>.  */\n+\n+#include \"config.h\"\n+\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"errors.h\"\n+#include \"parse.h\"\n+\n+#include \"verify.h\"\n+#include \"java-tree.h\"\n+#include \"java-except.h\"\n+\n+void *\n+vfy_alloc (size_t bytes)\n+{\n+  return xmalloc (bytes);\n+}\n+\n+void\n+vfy_free (void *mem)\n+{\n+  free (mem);\n+}\n+\n+bool\n+vfy_strings_equal (vfy_string one, vfy_string two)\n+{\n+  return one == two;\n+}\n+\n+const char *\n+vfy_string_bytes (vfy_string str)\n+{\n+  return IDENTIFIER_POINTER (str);\n+}\n+\n+int\n+vfy_string_length (vfy_string str)\n+{\n+  return IDENTIFIER_LENGTH (str);\n+}\n+\n+vfy_string\n+vfy_init_name ()\n+{\n+  return init_identifier_node;\n+}\n+\n+vfy_string\n+vfy_clinit_name ()\n+{\n+  return clinit_identifier_node;\n+}\n+\n+static const char*\n+skip_one_type (const char* ptr)\n+{\n+  int ch = *ptr++;\n+\n+  while (ch == '[')\n+    { \n+      ch = *ptr++;\n+    }\n+  \n+  if (ch == 'L')\n+    {\n+      do { ch = *ptr++; } while (ch != ';');\n+    }\n+\n+  return ptr;\n+}\n+\n+int\n+vfy_count_arguments (vfy_string signature)\n+{\n+  const char *ptr = IDENTIFIER_POINTER (signature);\n+  int arg_count = 0;\n+\n+  /* Skip '('.  */\n+  ptr++;\n+\n+  /* Count args.  */\n+  while (*ptr != ')')\n+    {\n+      ptr = skip_one_type (ptr);\n+      arg_count += 1;\n+    }\n+\n+  return arg_count;\n+}\n+\n+vfy_string\n+vfy_get_string (const char *s, int len)\n+{\n+  return get_identifier_with_length (s, len);\n+}\n+\n+vfy_string\n+vfy_get_signature (vfy_method *method)\n+{\n+  return method->signature;\n+}\n+\n+vfy_string\n+vfy_get_method_name (vfy_method *method)\n+{\n+  return method->name;\n+}\n+\n+bool\n+vfy_is_static (vfy_method *method)\n+{\n+  return METHOD_STATIC (method->method);\n+}\n+\n+const unsigned char *\n+vfy_get_bytecode (vfy_method *method)\n+{\n+  return method->bytes;\n+}\n+\n+vfy_exception *\n+vfy_get_exceptions (vfy_method *method)\n+{\n+  return method->exceptions;\n+}\n+\n+void\n+vfy_get_exception (vfy_exception *exceptions, int index, int *handler,\n+\t\t   int *start, int *end, int *handler_type)\n+{\n+  *handler = exceptions[index].handler;\n+  *start = exceptions[index].start;\n+  *end = exceptions[index].end;\n+  *handler_type = exceptions[index].type;\n+}\n+\n+int\n+vfy_tag (vfy_constants *pool, int index)\n+{\n+  int result = JPOOL_TAG (pool, index);\n+  /* gcj will resolve constant pool entries other than string and\n+     class references.  The verifier doesn't care about the values, so\n+     we just strip off the resolved flag.  */\n+  if ((result & CONSTANT_ResolvedFlag) != 0\n+      && result != CONSTANT_ResolvedString\n+      && result != CONSTANT_ResolvedClass)\n+    result &= ~ CONSTANT_ResolvedFlag;\n+  return result;\n+}\n+\n+void\n+vfy_load_indexes (vfy_constants *pool, int index,\n+\t\t  vfy_uint_16 *index0, vfy_uint_16 *index1)\n+{\n+  *index0 = JPOOL_USHORT1 (pool, index);\n+  *index1 = JPOOL_USHORT2 (pool, index);\n+}\n+\n+vfy_constants *\n+vfy_get_constants (vfy_jclass klass)\n+{\n+  return TYPE_JCF (klass);\n+}\n+\n+int\n+vfy_get_constants_size (vfy_jclass klass)\n+{\n+  return JPOOL_SIZE (TYPE_JCF (klass));\n+}\n+\n+vfy_string\n+vfy_get_pool_string (vfy_constants *pool, int index)\n+{\n+  return get_name_constant (pool, index);\n+}\n+\n+vfy_jclass\n+vfy_get_pool_class (vfy_constants *pool, int index)\n+{\n+  vfy_jclass k;\n+  k = get_class_constant (pool, index);\n+  return k;\n+}\n+\n+vfy_string\n+vfy_make_string (const char *s, int len)\n+{\n+  tree result;\n+  char *s2 = (char *) s;\n+  char save = s2[len];\n+  s2[len] = '\\0';\n+  result = get_identifier (s2);\n+  s2[len] = save;\n+  return result;  \n+}\n+\n+vfy_string\n+vfy_get_class_name (vfy_jclass klass)\n+{\n+  return DECL_NAME (TYPE_NAME (klass));\n+}\n+\n+bool\n+vfy_is_assignable_from (vfy_jclass target, vfy_jclass source)\n+{\n+  /* At compile time, for the BC-ABI we assume that reference types are always \n+  compatible.  However, a type assertion table entry is emitted so that the\n+  runtime can detect binary-incompatible changes.  */\n+\n+  /* FIXME: implement real test for old ABI.  */\n+\n+  /* Any class is always assignable to itself, or java.lang.Object. */\n+  if (source == target || target == object_type_node)\n+    return true;\n+\n+  /* Otherwise, a type assertion is required.  */\n+  add_type_assertion (current_class, JV_ASSERT_TYPES_COMPATIBLE, source,\n+\t\t      target);\n+  return true;\n+}\n+\n+char\n+vfy_get_primitive_char (vfy_jclass klass)\n+{\n+  tree sig;\n+  if (! vfy_is_primitive (klass))\n+    abort ();\n+  sig = build_java_signature (klass);\n+  return (IDENTIFIER_POINTER (sig))[0];\n+}\n+\n+int\n+vfy_get_interface_count (vfy_jclass klass ATTRIBUTE_UNUSED)\n+{\n+  /* FIXME: Need to merge from mainline to get this. */\n+  #if 0\n+  return BINFO_N_BASE_BINFOS (klass);\n+  #endif\n+  return -1;\n+}\n+\n+vfy_jclass\n+vfy_get_interface (vfy_jclass klass ATTRIBUTE_UNUSED, int index ATTRIBUTE_UNUSED)\n+{\n+  /* FIXME: Need to merge from mainline to get this. */\n+  #if 0\n+  vfy_jclass k;\n+  k = BINFO_BASE_BINFO (klass, index);\n+  return k;\n+  #endif\n+  return NULL;\n+}\n+\n+bool\n+vfy_is_array (vfy_jclass klass)\n+{\n+  return TYPE_ARRAY_P (klass);\n+}\n+\n+bool\n+vfy_is_interface (vfy_jclass klass)\n+{\n+  return CLASS_INTERFACE (TYPE_NAME (klass));\n+}\n+\n+bool\n+vfy_is_primitive (vfy_jclass klass)\n+{\n+  return JPRIMITIVE_TYPE_P (klass);\n+}\n+\n+vfy_jclass\n+vfy_get_superclass (vfy_jclass klass)\n+{\n+  vfy_jclass k;\n+  k = CLASSTYPE_SUPER (klass);\n+  return k;\n+}\n+\n+vfy_jclass\n+vfy_get_array_class (vfy_jclass klass)\n+{\n+  vfy_jclass k;\n+  k = build_java_array_type (klass, -1);\n+  return k;\n+}\n+\n+vfy_jclass\n+vfy_get_component_type (vfy_jclass klass)\n+{\n+  vfy_jclass k;\n+  if (! vfy_is_array (klass))\n+    abort ();\n+  k = TYPE_ARRAY_ELEMENT (klass);\n+  if (TREE_CODE (k) == POINTER_TYPE)\n+    k = TREE_TYPE (k);\n+  return k;\n+}\n+\n+bool\n+vfy_is_abstract (vfy_jclass klass)\n+{\n+  return CLASS_ABSTRACT (TYPE_NAME (klass));\n+}\n+\n+vfy_jclass\n+vfy_find_class (vfy_jclass ignore ATTRIBUTE_UNUSED, vfy_string name)\n+{\n+  vfy_jclass k;\n+\n+  k = get_type_from_signature (name);\n+  if (TREE_CODE (k) == POINTER_TYPE)\n+    k = TREE_TYPE (k);\n+\n+  return k;\n+}\n+\n+vfy_jclass\n+vfy_object_type ()\n+{\n+  vfy_jclass k;\n+  k = object_type_node;\n+  return k;\n+}\n+\n+vfy_jclass\n+vfy_string_type ()\n+{\n+  vfy_jclass k;\n+  k = string_type_node;\n+  return k;\n+}\n+\n+vfy_jclass\n+vfy_throwable_type ()\n+{\n+  vfy_jclass k;\n+  k = throwable_type_node;\n+  return k;\n+}\n+\n+vfy_jclass\n+vfy_unsuitable_type (void)\n+{\n+  return TYPE_SECOND;\n+}\n+\n+vfy_jclass\n+vfy_return_address_type (void)\n+{\n+  return TYPE_RETURN_ADDR;\n+}\n+\n+vfy_jclass\n+vfy_null_type (void)\n+{\n+  return TYPE_NULL;\n+}\n+\n+int\n+vfy_fail (const char *message, int pc, vfy_jclass ignore1 ATTRIBUTE_UNUSED,\n+\t  vfy_method *ignore2 ATTRIBUTE_UNUSED)\n+{\n+  if (pc == -1)\n+    error (\"verification failed: %s\", message);\n+  else\n+    error (\"verification failed at PC=%d: %s\", pc, message);\n+  /* We have to return a value for the verifier to throw.  */\n+  return 1;\n+}\n+\n+vfy_jclass\n+vfy_get_primitive_type (int type)\n+{\n+  vfy_jclass k;\n+  k = decode_newarray_type (type);\n+  return k;\n+}\n+\n+void\n+vfy_note_stack_depth (vfy_method *method, int pc, int depth)\n+{\n+  tree label = lookup_label (pc);\n+  LABEL_TYPE_STATE (label) = make_tree_vec (method->max_locals + depth);\n+}\n+\n+void\n+vfy_note_stack_type (vfy_method *method, int pc, int slot, vfy_jclass type)\n+{\n+  tree label, vec;\n+  \n+  slot += method->max_locals;\n+\n+  if (type == object_type_node)\n+    type = object_ptr_type_node;\n+\n+  label = lookup_label (pc);\n+  vec = LABEL_TYPE_STATE (label);\n+  TREE_VEC_ELT (vec, slot) = type;\n+}\n+\n+void\n+vfy_note_local_type (vfy_method *method ATTRIBUTE_UNUSED, int pc, int slot,\n+\t\t     vfy_jclass type)\n+{\n+  tree label, vec;\n+  \n+  if (type == object_type_node)\n+    type = object_ptr_type_node;\n+\n+  label = lookup_label (pc);\n+  vec = LABEL_TYPE_STATE (label);\n+  TREE_VEC_ELT (vec, slot) = type;\n+}\n+\n+void\n+vfy_note_instruction_seen (int pc)\n+{\n+  instruction_bits[pc] |= BCODE_VERIFIED;\n+}\n+\n+/* Verify the bytecodes of the current method.\n+   Return 1 on success, 0 on failure. */\n+int\n+verify_jvm_instructions_new (JCF *jcf, const unsigned char *byte_ops,\n+\t\t\t long length)\n+{\n+  vfy_method method;\n+  int i, result, eh_count;\n+  vfy_exception *exceptions;\n+\n+  method_init_exceptions ();\n+\n+  JCF_SEEK (jcf, DECL_CODE_OFFSET (current_function_decl) + length);\n+  eh_count = JCF_readu2 (jcf);\n+\n+  exceptions = (vfy_exception *) xmalloc (eh_count * sizeof (vfy_exception));\n+  for (i = 0; i < eh_count; ++i)\n+    {\n+      int start_pc, end_pc, handler_pc, catch_type;\n+      unsigned char *p = jcf->read_ptr + 8 * i;\n+      start_pc = GET_u2 (p);\n+      end_pc = GET_u2 (p+2);\n+      handler_pc = GET_u2 (p+4);\n+      catch_type = GET_u2 (p+6);\n+\n+      if (start_pc < 0 || start_pc >= length\n+\t  || end_pc < 0 || end_pc > length || start_pc >= end_pc\n+\t  || handler_pc < 0 || handler_pc >= length)\n+\t{\n+\t  error (\"bad pc in exception_table\");\n+\t  free (exceptions);\n+\t  return 0;\n+\t}\n+\n+      exceptions[i].handler = handler_pc;\n+      exceptions[i].start = start_pc;\n+      exceptions[i].end = end_pc;\n+      exceptions[i].type = catch_type;\n+\n+      add_handler (start_pc, end_pc,\n+\t\t   lookup_label (handler_pc),\n+\t\t   catch_type == 0 ? NULL_TREE\n+\t\t   : get_class_constant (jcf, catch_type));\n+      instruction_bits[handler_pc] |= BCODE_EXCEPTION_TARGET;\n+    }\n+\n+  handle_nested_ranges ();\n+\n+  method.method = current_function_decl;\n+  method.signature = build_java_signature (TREE_TYPE (current_function_decl));\n+  method.name = DECL_NAME (current_function_decl);\n+  method.bytes = byte_ops;\n+  method.exceptions = exceptions;\n+  method.defining_class = DECL_CONTEXT (current_function_decl);\n+  method.max_stack = DECL_MAX_STACK (current_function_decl);\n+  method.max_locals = DECL_MAX_LOCALS (current_function_decl);\n+  method.code_length = length;\n+  method.exc_count = eh_count;\n+\n+  result = verify_method (&method);\n+\n+  free (exceptions);\n+\n+  return result;\n+}"}, {"sha": "2c402a8c62bc6aa62cbdb88c141b0daa495b831a", "filename": "gcc/java/verify-impl.c", "status": "added", "additions": 3418, "deletions": 0, "changes": 3418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify-impl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify-impl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify-impl.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9"}, {"sha": "8eb0c308488eff8b67abdac3e3adbb650681624f", "filename": "gcc/java/verify.c", "status": "modified", "additions": 73, "deletions": 33, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -89,23 +89,23 @@ check_pending_block (tree target_label)\n \n   if (current_subr == NULL_TREE)\n     {\n-      if (LABEL_IN_SUBR (target_label))\n-\treturn \"might transfer control into subroutine\";\n+/*       if (LABEL_IN_SUBR (target_label)) */\n+/* \treturn \"might transfer control into subroutine\"; */\n     }\n   else\n     {\n       if (LABEL_IN_SUBR (target_label))\n \t{\n-\t  if (LABEL_SUBR_START (target_label) != current_subr)\n-\t    return \"transfer out of subroutine\";\n+/* \t  if (LABEL_SUBR_START (target_label) != current_subr) */\n+/* \t    return \"transfer out of subroutine\"; */\n \t}\n       else if (! LABEL_VERIFIED (target_label))\n \t{\n \t  LABEL_IN_SUBR (target_label) = 1;\n \t  LABEL_SUBR_START (target_label) = current_subr;\n \t}\n-      else\n-\treturn \"transfer out of subroutine\";\n+/*       else */\n+/* \treturn \"transfer out of subroutine\"; */\n     }\n   return NULL;\n }\n@@ -126,6 +126,54 @@ subroutine_nesting (tree label)\n   return nesting;\n }\n \n+static tree\n+defer_merging (tree type1, tree type2)\n+{\n+  // FIXME: This is just a placeholder until we replace the verifier\n+  // altogether.  We really need to ouput a type assertion for all of\n+  // the types, every time they are used.\n+  return object_ptr_type_node;\n+\n+  if (TREE_CODE (type1) == POINTER_TYPE)\n+    type1 = TREE_TYPE (type1);\n+  if (TREE_CODE (type2) == POINTER_TYPE)\n+    type2 = TREE_TYPE (type2);\n+\n+  if (TREE_CODE (type1) == RECORD_TYPE && TREE_CODE (type2) == RECORD_TYPE)\n+    {\n+      tree list = build_tree_list (type1, NULL_TREE);\n+      list = tree_cons (type2, NULL_TREE, list);\n+      return list;\n+    }\n+\n+  if (TREE_CODE (type1) == TREE_LIST && TREE_CODE (type2) == TREE_LIST)\n+    {\n+      return chainon (copy_list (type1), copy_list (type2));\n+    }\n+\n+  if (TREE_CODE (type1) == TREE_LIST && TREE_CODE (type2) == RECORD_TYPE)\n+    {\n+      tree tmp = type1;\n+      do\n+\t{\n+\t  if (TREE_PURPOSE (tmp) == type2)\n+\t    return type1;\n+\t  tmp = TREE_CHAIN (tmp);\n+\t}\n+      while (tmp);\n+\n+      return tree_cons (type2, NULL_TREE, copy_list (type1));\n+    }\n+\n+  if (TREE_CODE (type2) == TREE_LIST && TREE_CODE (type1) == RECORD_TYPE)\n+    {\n+      return defer_merging (type2, type1);\n+    }\n+\n+  abort ();\n+}\n+\n+\n /* Return the \"merged\" types of TYPE1 and TYPE2.\n    If either is primitive, the other must match (after promotion to int).\n    For reference types, return the common super-class.\n@@ -138,7 +186,11 @@ merge_types (tree type1, tree type2)\n     return type1;\n   if (type1 == TYPE_UNKNOWN || type2 == TYPE_UNKNOWN\n       || type1 == TYPE_RETURN_ADDR || type2 == TYPE_RETURN_ADDR)\n-    return TYPE_UNKNOWN;\n+    return TYPE_UNKNOWN;  \n+\n+  if (TREE_CODE (type1) == TREE_LIST || TREE_CODE (type2) == TREE_LIST)\n+    return defer_merging (type1, type2);\n+\n   if (TREE_CODE (type1) == POINTER_TYPE && TREE_CODE (type2) == POINTER_TYPE)\n     {\n       int depth1, depth2;\n@@ -153,6 +205,9 @@ merge_types (tree type1, tree type2)\n       tt1 = TREE_TYPE (type1);\n       tt2 = TREE_TYPE (type2);\n \n+      if (TYPE_DUMMY (tt1) || TYPE_DUMMY (tt2))\n+\treturn defer_merging (tt1, tt2);\n+      \n       /* If tt{1,2} haven't been properly loaded, now is a good time\n          to do it. */\n       if (!TYPE_SIZE (tt1))\n@@ -193,31 +248,10 @@ merge_types (tree type1, tree type2)\n \t  return object_ptr_type_node;\n \t}\n \n-      if (CLASS_INTERFACE (TYPE_NAME (tt1)))\n-\t{\n-\t  /* FIXME: should see if two interfaces have a common\n-\t     superinterface.  */\n-\t  if (CLASS_INTERFACE (TYPE_NAME (tt2)))\n-\t    {\n-\t      /* This is a kludge, but matches what Sun's verifier does.\n-\t\t It can be tricked, but is safe as long as type errors\n-\t\t (i.e. interface method calls) are caught at run-time. */\n-\t      return object_ptr_type_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (can_widen_reference_to (tt2, tt1))\n-\t\treturn type1;\n-\t      else\n-\t\treturn object_ptr_type_node;\n-\t    }\n-\t}\n-      else if (CLASS_INTERFACE (TYPE_NAME (tt2)))\n+      if (CLASS_INTERFACE (TYPE_NAME (tt1))\n+\t  || (CLASS_INTERFACE (TYPE_NAME (tt2))))\n \t{\n-\t  if (can_widen_reference_to (tt1, tt2))\n-\t    return type2;\n-\t  else\n-\t    return object_ptr_type_node;\n+\t  return object_ptr_type_node;\n \t}\n \n       type1 = tt1;\n@@ -675,6 +709,8 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"invalid local variable index %d in load\");\n \ttmp = type_map[index];\n+\tif (TREE_CODE (tmp) != TREE_LIST)\n+\t  {\n \tif (tmp == TYPE_UNKNOWN)\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"loading local variable %d which has unknown type\");\n@@ -688,6 +724,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t: type != tmp))\n \t  VERIFICATION_ERROR_WITH_INDEX\n \t    (\"loading local variable %d which has invalid type\");\n+\t  }\n \tPUSH_TYPE (tmp);\n \tgoto note_used;\n \tcase OPCODE_istore:  type = int_type_node;  goto general_store;\n@@ -736,7 +773,7 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \tprev_eh_ranges = NULL_EH_RANGE;\n \n \t/* Allocate decl for this variable now, so we get a temporary\n-! \t   that survives the whole method. */\n+\t   that survives the whole method. */\n \tfind_local_variable (index, type, oldpc);\n \n         if (TYPE_IS_WIDE (type))\n@@ -1092,6 +1129,10 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t    if (! CLASS_LOADED_P (self_type))\n \t      load_class (self_type, 1);\n \n+\t    if (TYPE_DUMMY (self_type) && op_code == OPCODE_invokeinterface)\n+\t      /* Assume we are an interface.  */\n+\t      CLASS_INTERFACE (TYPE_NAME (self_type)) = 1;\n+\n \t    self_is_interface = CLASS_INTERFACE (TYPE_NAME (self_type));\n \t    method_name = COMPONENT_REF_NAME (&current_jcf->cpool, index);\n \t    method_type = parse_signature_string ((const unsigned char *) IDENTIFIER_POINTER (sig),\n@@ -1129,7 +1170,6 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n \t\t  if (!nargs || notZero)\n \t\t      VERIFICATION_ERROR \n \t\t        (\"invalid argument number in invokeinterface\");\n-\n \t\t  /* If we verify/resolve the constant pool, as we should,\n \t\t     this test (and the one just following) are redundant.  */\n \t\t  if (! self_is_interface)"}, {"sha": "6657ffc471a9f6332c9d26166e18c2f861c34885", "filename": "gcc/java/verify.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/gcc%2Fjava%2Fverify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,160 @@\n+/* Declarations to interface gcj with bytecode verifier.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+Java and all Java-based marks are trademarks or registered trademarks\n+of Sun Microsystems, Inc. in the United States and other countries.\n+The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n+\n+/* Written by Tom Tromey <tromey@redhat.com>.  */\n+\n+#ifndef GCC_VERIFY_H\n+#define GCC_VERIFY_H\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"jcf.h\"\n+#include \"tree.h\"\n+#include \"java-tree.h\"\n+\n+typedef JCF vfy_constants;\n+\n+/* For our purposes a string is the same as an identifier.  */\n+typedef tree vfy_string;\n+\n+/* The TYPE_DECL for a class or primitive type.  */\n+typedef tree vfy_jclass;\n+\n+/* An unsigned jshort.  */\n+typedef uint16 vfy_uint_16;\n+\n+typedef struct\n+{\n+  int handler, start, end, type;\n+} vfy_exception;\n+\n+typedef struct\n+{\n+  tree method;\n+  vfy_string signature;\n+  vfy_string name;\n+  const unsigned char *bytes;\n+  vfy_exception *exceptions;\n+\n+  /* These fields are referred to directly by the verifier.  */\n+  vfy_jclass defining_class;\n+  int max_stack;\n+  int max_locals;\n+  int code_length;\n+  int exc_count;\n+} vfy_method;\n+\n+/* Entry point to the verifier.  */\n+int verify_jvm_instructions_new (JCF *jcf, const unsigned char *byte_ops,\n+\t\t\t\t long length);\n+\n+void *vfy_alloc (size_t bytes);\n+void vfy_free (void *mem);\n+bool vfy_strings_equal (vfy_string one, vfy_string two);\n+const char *vfy_string_bytes (vfy_string str);\n+int vfy_string_length (vfy_string str);\n+vfy_string vfy_get_string (const char *chars, int length);\n+vfy_string vfy_init_name (void);\n+vfy_string vfy_clinit_name (void);\n+int vfy_count_arguments (vfy_string signature);\n+vfy_string vfy_get_signature (vfy_method *method);\n+vfy_string vfy_get_method_name (vfy_method *method);\n+bool vfy_is_static (vfy_method *method);\n+const unsigned char *vfy_get_bytecode (vfy_method *method);\n+vfy_exception *vfy_get_exceptions (vfy_method *method);\n+void vfy_get_exception (vfy_exception *, int index, int *handler,\n+\t\t\tint *start, int *end, int *handler_type);\n+int vfy_tag (vfy_constants *pool, int index);\n+void vfy_load_indexes (vfy_constants *pool, int index,\n+\t\t       vfy_uint_16 *index0, vfy_uint_16 *index1);\n+vfy_constants *vfy_get_constants (vfy_jclass klass);\n+int vfy_get_constants_size (vfy_jclass klass);\n+vfy_string vfy_get_pool_string (vfy_constants *pool, int index);\n+vfy_jclass vfy_get_pool_class (vfy_constants *pool, int index);\n+vfy_string vfy_make_string (const char *s, int len);\n+vfy_string vfy_get_class_name (vfy_jclass klass);\n+bool vfy_is_assignable_from (vfy_jclass target, vfy_jclass source);\n+char vfy_get_primitive_char (vfy_jclass klass);\n+int vfy_get_interface_count (vfy_jclass klass);\n+vfy_jclass vfy_get_interface (vfy_jclass klass, int index);\n+bool vfy_is_array (vfy_jclass klass);\n+bool vfy_is_interface (vfy_jclass klass);\n+bool vfy_is_primitive (vfy_jclass klass);\n+vfy_jclass vfy_get_superclass (vfy_jclass klass);\n+vfy_jclass vfy_get_array_class (vfy_jclass klass);\n+vfy_jclass vfy_get_component_type (vfy_jclass klass);\n+bool vfy_is_abstract (vfy_jclass klass);\n+vfy_jclass vfy_find_class (vfy_jclass klass, vfy_string name);\n+vfy_jclass vfy_object_type (void);\n+vfy_jclass vfy_string_type (void);\n+vfy_jclass vfy_throwable_type (void);\n+vfy_jclass vfy_unsuitable_type (void);\n+vfy_jclass vfy_return_address_type (void);\n+vfy_jclass vfy_null_type (void);\n+int vfy_fail (const char *message, int pc, vfy_jclass ignore1,\n+\t      vfy_method *method);\n+vfy_jclass vfy_get_primitive_type (int type);\n+void vfy_note_stack_depth (vfy_method *method, int pc, int depth);\n+void vfy_note_stack_type (vfy_method *method, int pc, int slot,\n+\t\t\t  vfy_jclass type);\n+void vfy_note_local_type (vfy_method *method, int pc, int slot,\n+\t\t\t  vfy_jclass type);\n+void vfy_note_instruction_seen (int pc);\n+\n+#define GLOM(name, stuff) name ## stuff\n+#define VFY_PRIMITIVE_CLASS(name) \\\n+  vfy_get_primitive_type ((int) (GLOM (name, _type)))\n+\n+typedef enum\n+{\n+#define JAVAOP(name, num, ignore1, ignore2, ignore3) \\\n+  GLOM (op_, name) = num,\n+#include \"javaop.def\"\n+} java_opcode;\n+\n+\n+#define JV_CONSTANT_Class CONSTANT_Class\n+#define JV_CONSTANT_ResolvedClass CONSTANT_ResolvedClass\n+#define JV_CONSTANT_String CONSTANT_String\n+#define JV_CONSTANT_ResolvedString CONSTANT_ResolvedString\n+#define JV_CONSTANT_Integer CONSTANT_Integer\n+#define JV_CONSTANT_Float CONSTANT_Float\n+#define JV_CONSTANT_Long CONSTANT_Long\n+#define JV_CONSTANT_Double CONSTANT_Double\n+#define JV_CONSTANT_Fieldref CONSTANT_Fieldref\n+#define JV_CONSTANT_InterfaceMethodref CONSTANT_InterfaceMethodref\n+#define JV_CONSTANT_Methodref CONSTANT_Methodref\n+\n+int verify_method (vfy_method *meth);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* ! GCC_VERIFY_H */"}, {"sha": "add3919e8fac1a3f2f9cbf6e5c528a9bef3c5eac", "filename": "libjava/ChangeLog", "status": "modified", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,3 +1,758 @@\n+2004-11-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Merged gcj-abi-2-dev-branch to trunk.\n+\n+2004-11-16  Tom Tromey  <tromey@redhat.com>\n+\n+\t* include/java-interp.h (_Jv_DefineClass): Updated.\n+\t* java/lang/natVMClassLoader.cc (defineClass): Pass protection\n+\tdomain to class reader.\n+\t* defineclass.cc (parse): Use print_class_loaded.\n+\tInclude ProtectionDomain.h.\n+\t(_Jv_DefineClass): Added ProtectionDomain argument.\n+\t(_Jv_ClassReader): Likewise.\n+\t* include/jvm.h (_Jv_Linker::print_class_loaded): Declare.\n+\t* link.cc: Include CodeSource.h.\n+\t(print_class_loaded): New function.\n+\t(wait_for_state): Use it.\n+\n+2004-11-16  Andrew Haley  <aph@redhat.com>\n+\n+\t* gnu/gcj/util/Debug.java (print): Add RawDataManaged.\n+\n+2004-11-16  Andrew Haley  <aph@redhat.com>\n+\n+\t* configure.ac (LIBGCJ_LD_SYMBOLIC): AC_SUBST this definition.\n+\t* configure.host: Define libgcj_ld_symbolic for Linux hosts.\n+\t* Makefile.am (lib_*_la_LDFLAGS): Add LIBGCJ_LD_SYMBOLIC.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Regenerate.\t\n+\n+2004-11-15  Andrew Haley  <aph@redhat.com>\n+\n+\t* boehm.cc (_Jv_GCRegisterDisappearingLink): Check that *objp is a\n+\tgc-allocated object.\n+\n+2004-11-15  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/net/URLClassLoader.java\n+\t(URLLoader.getClassPath): New method.\n+\t(JarURLLoader.JarURLLoader): Read mainfest to parse \"Class-Path\"\n+\tattribute and add URLs for each entry.\n+\t(JarURLLoader.classPath): New field.\n+\t(JarURLLoader.getClassPath): New method.\n+\t(addURLImpl): Scan through the list of extraUrls in the new\n+\tloader, adding them to our urlinfos.\n+\t(definePackage, findURLResource, findResources): Use\n+\turlinfos.size(), not urls.size().\n+\n+2004-11-11  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gnu/gcj/runtime/natSharedLibLoader.cc (ensureSupersLinked): New\n+\tmethod.\n+\t* gnu/gcj/runtime/SharedLibHelper.java (findClass): Ensure supers\n+\tlinked.\n+\t(ensureSupersLinked): Declare.\n+\t* java/lang/natVMClassLoader.cc (loadClass): Ensure supers\n+\tlinked.\n+\n+2004-11-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gij.cc (main): Treat -verbose the same as -verbose:class.\n+\t(help): Document -verbose and -verbose:class.\n+\n+\t* link.cc (verbose_class_flag): Declare.\n+\t(wait_for_state): Print message when handling precompiled class.\n+\t* java/lang/natClass.cc (verbose_class_flag): Moved to link.cc.\n+\n+2004-11-09  Tom Tromey  <tromey@redhat.com>\n+\n+\t* testsuite/libjava.lang/assign2.out: New file.\n+\t* testsuite/libjava.lang/assign2.java: New file.\n+\n+\t* java/lang/natRuntime.cc (insertSystemProperties): Set\n+\tjava.version to 1.4.2 and java.specification.version to 1.4.  Set\n+\tjava.runtime.version.\n+\n+2004-11-08  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natClass.cc (_Jv_IsAssignableFromSlow): Ensure\n+\tsupers installed.\n+\t* link.cc (verify_type_assertions): Don't link supers.\n+\n+\t* include/jvm.h (_Jv_Linker::search_method_in_class): Declare.\n+\t* include/java-interp.h (class _Jv_InterpClass)\n+\t<_Jv_PrepareMissingMethods>: No longer `friend'.\n+\t* java/lang/Class.h (_Jv_SearchMethodInClass): No longer\n+\t`friend'.\n+\t(_Jv_PrepareMissingMethods, _Jv_PrepareCompiledClass,\n+\t_Jv_GetInterfaces, _Jv_GenerateITable, _Jv_FindIIndex,\n+\t_Jv_AppendPartialITable, _Jv_LinkSymbolTable,\n+\t_Jv_LayoutInterfaceMethods, _Jv_SetVTableEntries, _Jv_MakeVTable,\n+\t_Jv_linkExceptionClassTable, _Jv_WaitForState): Likewise.\n+\t* link.cc (search_method_in_class): Renamed from\n+\t_Jv_SearchMethodInClass.\n+\t(resolve_pool_entry): Updated.\n+\n+\t* include/jvm.h (_Jv_CheckAssignment): Removed.\n+\t* java/lang/natClass.cc (_Jv_CheckAssignment): Removed.\n+\n+2004-11-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* link.cc (verify_type_assertions): Ensure classes have supers\n+\tlinked.  Strip off array types first.\n+\n+2004-11-05  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* link.cc: Include VerifyError.h. \n+\t(_Jv_Linker::verify_type_assertions): New. Read and evaluate entries\n+\tin the type assertion table.\n+\t* include/execution.h (_Jv_CompiledEngine::do_verify): Use\n+\tverify_type_assertions.\n+\t* include/jvm.h (_Jv_Linker::verify_type_assertions): declare.\n+\t* java/lang/Class.h (JV_ASSERT_END_OF_TABLE, \n+\tJV_ASSERT_TYPES_COMPATIBLE, JV_ASSERT_IS_INSTANTIABLE): Declare\n+\tassertion code values.\n+\t(struct _Jv_TypeAssertion): Declare.\n+\t(assertion_table): New class field.\n+\t(verify): Remove class field.\n+\n+2004-11-05  Andrew Haley  <aph@redhat.com>\n+\n+\t* Makefile.am: Move jv_dbtool.java to\n+\tgnu/gcj/tools/gcj_dbtool/Main.java.\n+\t* Makefile.in: Rebuild.\n+\t* java/lang/VMCompiler.java: Rename property\n+\t\"gnu.gcj.precompiled.db\" to \"gnu.gcj.precompiled.db.path\".\n+\t* gnu/gcj/tools/gcj_dbtool/Main.java: moved here from\n+\tjv_dbtool.java.\n+\t\n+2004-11-05  Andrew Haley  <aph@redhat.com>\n+\n+\t* jv_dbtool.java (main): Allow the user to specify the size of the\n+\tdatabase.  Display the capacity and the size.\n+\t(usage): Show the new option.\n+\t\t\n+2004-11-04  Tom Tromey  <tromey@redhat.com>\n+\n+\t* include/jvm.h (_Jv_Linker::set_vtable_entries): Updated.\n+\t* link.cc (make_vtable): Use correct index when searching for\n+\tmissing method's name.  Don't use `flags'.\n+\t(set_vtable_entries): Removed `flags' argument.  Don't recurse\n+\tinto superclasses.\n+\t(link_symbol_table): Ensure target class method table is\n+\tcomplete.  Ensure target fields are laid out before entering\n+\tloop.\n+\n+\t* java/lang/natClass.cc (_Jv_getInterfaceMethod): Indentation\n+\tfix.\n+\n+\t* interpret.cc (do_verify): Don't verify abstract methods.\n+\n+2004-11-01  Tom Tromey  <tromey@redhat.com>\n+\n+\t* link.cc (wait_for_state): Call verify_class.\n+\n+\t* verify.cc (state::check_no_uninitialized_objects): Removed.\n+\t(push_jump): Updated.\n+\t(push_exception_jump): Likewise.\n+\t(handle_ret_insn): Likewise.\n+\t(handle_jsr_insn): Likewise.\n+\n+2004-10-28  Andrew Haley  <aph@redhat.com>\n+\n+\t* gnu/gcj/runtime/PersistentByteMap.java: New file.\n+\t* jv_dbtool.java: New file.\n+\t* Makefile.am (bin_PROGRAMS): Add jv-dbtool\n+\t(jv_dbtool_SOURCES, jv_dbtool_LDFLAGS, jv_dbtool_LINK)\n+\t(jv_dbtool_LDADD, jv_dbtool_DEPENDENCIES): New.\n+\t* Makefile.in: Regenerate,\n+\t* java/lang/VMCompiler.java: Import NoSuchAlgorithmException,\n+\tEnumeration, StringTokenizer, Vector, PersistentByteMap.\n+\t(precompiledMapFiles): New variable.\n+\t(VMCompiler static intializer): Read \"gnu.gcj.precompiled.db\" to\n+\tinitialize precompiledMapFiles.\n+\t(compileClass): Look at the database of precompiled class files\n+\tbefore firing up gcj.\n+\n+\t* gnu/gcj/runtime/VMClassLoader.java (findClass): Fix comment.\n+\n+2004-10-27  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/VMCompiler.java (compileClass): try looking for\n+\tprecompiledMapFiles.\n+\t* gnu/gcj/runtime/PersistentByteMap.java: New file.\n+\n+2004-10-27  Tom Tromey  <tromey@redhat.com>\n+\n+\t* link.cc (ensure_class_linked): Only resolve classes for\n+\tcompiled classes.\n+\t(add_miranda_methods): Ensure interface supers are installed.\n+\t(resolve_pool_entry): Better error message.\n+\n+2004-10-25  Tom Tromey  <tromey@redhat.com>\n+\n+\t* boehm.cc (_Jv_MarkObj): Test aux_info before dereferencing it.\n+\n+\t* java/util/ResourceBundle.java (tryBundle): Use\n+\tClass.isAssignableFrom rather than catching ClassCastException.\n+\n+\t* java/util/zip/InflaterInputStream.java (fill): Don't throw an\n+\texception if we hit EOF of `in'.\n+\t(read): Handle case where inflating returns -1.\n+\n+\t* gnu/java/text/WordBreakIterator.java (WordBreakIterator): Don't\n+\tinitialize `iter'.\n+\t* gnu/java/text/SentenceBreakIterator.java\n+\t(SentenceBreakIterator): Don't initialize `iter'.\n+\t* gnu/java/text/LineBreakIterator.java (LineBreakIterator): Don't\n+\tinitialize `iter'.\n+\t* gnu/java/text/CharacterBreakIterator.java\n+\t(CharacterBreakIterator): Don't initialize `iter'.\n+\t* gnu/java/text/BaseBreakIterator.java (BaseBreakIterator): New\n+\tconstructor.\n+\t* java/text/BreakIterator.java: Updated documentation.\n+\n+2004-10-20  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/util/ResourceBundle.java (tryBundle): Also ignore\n+\tClassCastException.\n+\n+2004-10-18  Tom Tromey  <tromey@redhat.com>\n+\n+\t* interpret.cc (do_post_miranda_hook): New method.\n+\t* include/execution.h (_Jv_ExecutionEngine::post_miranda_hook):\n+\tNew field.\n+\t(_Jv_CompiledEngine::do_post_miranda_hook): New method.\n+\t(_Jv_CompiledEngine): Initialize new field.\n+\t(_Jv_InterpreterEngine::do_post_miranda_hook): Declare.\n+\t(_Jv_InterpreterEngine): Initialize new field.\n+\t* link.cc (resolve_pool_entry): Put Miranda methods in target\n+\tclass.\n+\t(ensure_method_table_complete): Call post_miranda_hook.\n+\t* java/lang/natVMClassLoader.cc (defineClass): Don't set class'\n+\taux_info.\n+\t* defineclass.cc (read_one_method_attribute): Use _Jv_AllocBytes.\n+\t(parse): Set class' aux_info here.\n+\n+\t* boehm.cc (_Jv_MarkObj): Mark `throws'.\n+\n+\t* boehm.cc: Re-merged with trunk.\n+\n+2004-10-18  Andrew Haley  <aph@redhat.com>\n+\n+\tPR java/18036:\n+\t* gnu/gcj/runtime/natStackTrace.cc (fillInStackTrace): Reorganize\n+\tand correct logic used to find interpreter.\n+\n+2004-10-13  Andrew Haley  <aph@redhat.com>\n+\n+\t* interpret.cc (_Jv_InterpMethod::run): Initialize\n+\t_Jv_StartOfInterpreter.\n+\t(_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): Functions removed.\n+\t(_Jv_StartOfInterpreter, _Jv_EndOfInterpreter): New variables.\n+\t* gnu/gcj/runtime/natStackTrace.cc (fillInStackTrace): Use\n+\t_Unwind_FindEnclosingFunction to discover whether PC is within the\n+\tinterpreter.\n+\n+2004-10-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* link.cc (find_iindex): Copy correct number of slots to new\n+\tioffsets.\n+\n+2004-10-12  Tom Tromey  <tromey@redhat.com>\n+\n+\t* testsuite/libjava.loader/loader.exp (gcj_object_file_name): New\n+\tproc.\n+\t(gcj_loader_test_one): Use it.\n+\t(gcj_loader_run): Likewise.\n+\n+\t* prims.cc: Don't include FirstThread.h.\n+\n+2004-10-06  Tom Tromey  <tromey@redhat.com>\n+\n+\t* link.cc (ensure_method_table_complete): Ensure superclass\n+\tMiranda methods installed.\n+\n+\t* include/java-interp.h (class _Jv_JNIMethod): Added\n+\tJV_MARKOBJ_DECL as a friend.\n+\t* interpret.cc (ncode): Allocate jni_arg_types field with GC.\n+\t* boehm.cc (_Jv_MarkObj): Skip abstract methods when marking\n+\tinterpreter method structures.  Mark jni_arg_types of JNI\n+\tmethods.\n+\n+\t* defineclass.cc (parse): Use JV_STATE_READ.\n+\t* java/lang/Class.h (JV_STATE_READ): New enum value.\n+\n+2004-10-05  Tom Tromey  <tromey@redhat.com>\n+\n+\t* link.cc (resolve_pool_entry): Add signature info to missing\n+\tmethod's information.\n+\n+\t* gnu/gcj/util/Debug.java (Debug(int,boolean)): New constructor.\n+\t* gnu/gcj/util/natDebug.cc (_Jv_StaticDeepDebug): New function.\n+\n+2004-10-04  Tom Tromey  <tromey@redhat.com>\n+\n+\t* boehm.cc (_Jv_MarkObj): Correctly indicate base pointer when\n+\tmarking IDT.\n+\n+2004-09-29  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Makefile.am (libgcj_la_SOURCES): Mention link.cc, not\n+\tresolve.cc.\n+\t* include/jvm.h (class _Jv_Linker): Renamed from _Jv_Resolver.\n+\t* jni.cc: Use _Jv_Linker.\n+\t* interpret.cc: Use _Jv_Linker.\n+\t* java/lang/reflect/natField.cc (getType): Use _Jv_Linker.\n+\t* java/lang/natClassLoader.cc: Use _Jv_Linker.\n+\t* java/lang/natVMClassLoader.cc (resolveClass): Use _Jv_Linker.\n+\t* java/lang/Class.h: Use _Jv_Linker.\n+\t* java/lang/natClass.cc (initializeClass): Use _Jv_Linker.\n+\t* resolve.cc: Renamed ...\n+\t* link.cc: ... here.  Use _Jv_Linker.\n+\t* defineclass.cc (checkExtends): Use _Jv_Linker.\n+\n+2004-09-17  Tom Tromey  <tromey@redhat.com>\n+\n+\t* defineclass.cc (handleCodeAttribute): Don't reference\n+\t`deferred'.\n+\t(handleMethodsEnd): Likewise.\n+\t* include/java-interp.h (_Jv_MethodBase::deferred): Removed\n+\tfield.\n+\t(_Jv_Defer_Resolution): Don't declare or define.\n+\t* interpret.cc (do_create_ncode): Don't resolve deferred method\n+\tpointers.\n+\t* java/lang/Class.h (_Jv_Defer_Resolution): Don't declare.\n+\t* resolve.cc (link_symbol_table): No need to defer resolution.\n+\n+2004-09-14  Tom Tromey  <tromey@redhat.com>\n+\n+\t* boehm.cc (MAYBE_MARK): Remove unused `Exit' argument.\n+\t(_Jv_MarkObj): Updated.\n+\t(_Jv_MarkArray): Likewise.\n+\n+\t* include/jvm.h (StringClass): Removed.\n+\t* jni.cc (_Jv_JNI_ThrowNew): Don't use StringClass.\n+\t* interpret.cc (_Jv_InitField): Don't use StringClass.\n+\t* java/lang/natString.cc (_Jv_StringFindSlot): Don't use\n+\tStringClass.\n+\t(rehash): Likewise\n+\t(intern): Likewise.\n+\t(_Jv_FinalizeString): Likewise.\n+\t(_Jv_NewStringUtf8Const): Likewise.\n+\t(equals): Likewise.\n+\t* prims.cc (JvConvertArgv): Don't use StringClass.\n+\n+\t* gcj/field.h (struct _Jv_Field): Don't mention COMPACT_FIELDS.\n+\t* resolve.cc (ensure_fields_laid_out): Don't mention\n+\tCOMPACT_FIELDS.\n+\t* defineclass.cc (handleField): Don't mention COMPACT_FIELDS.\n+\t* boehm.cc (_Jv_MarkObj): Don't mention COMPACT_FIELDS.\n+\n+\t* java/lang/reflect/natField.cc (getType): Use resolve_field.\n+\t* java/lang/natVMClassLoader.cc (resolveClass): New native\n+\timplementation.\n+\t(linkClass0): Removed.\n+\t(markClassErrorState0): Likewise.\n+\t* java/lang/natClassLoader.cc: Include execution.h.  Moved class\n+\tpreparation code to resolve.cc.\n+\t(_Jv_RegisterClassHookDefault): Set class's execution engine if\n+\tnot already set.\n+\t(_Jv_FindClass): Use wait_for_state.\n+\t(_Jv_NewArrayClass): Likewise.  Simplified permissions setting.\n+\t* java/lang/natClass.cc (_Jv_IsInstanceOf): Include execution.h.\n+\tMoved interface table and class preparation code to resolve.cc.\n+\t(finalize): Rewrote.\n+\t(initializeClass): Simplified locking and class preparation.\n+\t* java/lang/VMClassLoader.java (linkClass0): Removed.\n+\t(markClassErrorState0): Likewise.\n+\t(resolveClass): Now native.\n+\t(transformException): New method.\n+\t* java/lang/Class.h (getSuperclass): Don't try to resolve super\n+\treference.\n+\t(getInterface): Likewise.\n+\t(size): Likewise.\n+\t(set_state): New method.\n+\t(Class): Updated friend declarations.\n+\t(verify): Field now private.\n+\t(engine): New field.\n+\t* include/jvm.h (class _Jv_Resolver): New class declaration.\n+\t(_Jv_ResolveField): Removed declaration.\n+\t(_Jv_CheckAccessNoInit): Likewise.\n+\t(_Jv_isBinaryCompatible): Removed.\n+\t* include/java-interp.h (class _Jv_MethodBase): Updated friend\n+\tdeclarations.\n+\t(class _Jv_InterpMethod): Likewise.\n+\t(class _Jv_InterpClass): Likewise.\n+\t(class _Jv_JNIMethod): Likewise.\n+\t* include/execution.h: New file.\n+\t* gnu/gcj/runtime/natSharedLibLoader.cc: Include execution.h.\n+\t(_Jv_sharedlib_register_hook): Set `engine' on loaded class.\n+\tRegister class after setting fields.\n+\t* resolve.cc: Include execution.h, VerifyError.h.  Moved\n+\tinterpreter-specific code to interpret.cc.\n+\t(uaddr): New location.\n+\t(struct aligner): Likewise.\n+\t(ALIGNOF): Likewise.\n+\t(INITIAL_IOFFSETS_LEN): Interface dispatch code moved here.\n+\t(INITIAL_IFACES_LEN): Likewise.\n+\t(null_idt): Likewise.\n+\t(_Jv_GetMethodString): Likewise.\n+\t(_Jv_ThrowNoSuchMethodError): Likewise.\n+\t(_Jv_abstractMethodError): Likewise.\n+\t(_Jv_Resolver::get_alignment_from_class): Renamed.\n+\t(_Jv_Resolver::resolve_field): Likewise.\n+\t(_Jv_Resolver::resolve_pool_entry): Likewise.\n+\t(_Jv_Resolver::resolve_class_ref): Likewise.\n+\t(_Jv_Resolver::prepare_constant_time_tables): Likewise.\n+\t(_Jv_Resolver::indexof): Likewise.\n+\t(_Jv_Resolver::get_interfaces): Likewise.\n+\t(_Jv_Resolver::generate_itable): Likewise.\n+\t(_Jv_Resolver::append_partial_itable): Likewise.\n+\t(_Jv_Resolver::find_iindex): Likewise.\n+\t(_Jv_Resolver::link_symbol_table): Likewise.\n+\t(_Jv_Resolver::link_exception_table): Likewise.\n+\t(_Jv_Resolver::layout_interface_methods): Likewise.\n+\t(_Jv_Resolver::layout_vtable_methods): Likewise.\n+\t(_Jv_Resolver::set_vtable_entries): Likewise.\n+\t(_Jv_Resolver::make_vtable): Likewise.\n+\t(_Jv_Resolver::ensure_fields_laid_out): Likewise.\n+\t(_Jv_Resolver::ensure_class_linked): Likewise.\n+\t(_Jv_Resolver::ensure_supers_installed): Likewise.\n+\t(_Jv_Resolver::add_miranda_methods): Likewise.\n+\t(_Jv_Resolver::ensure_method_table_complete): Likewise.\n+\t(_Jv_Resolver::verify_class): Likewise.\n+\t(_Jv_Resolver::wait_for_state): Likewise.\n+\t* prims.cc (_Jv_soleCompiledEngine): New global.\n+\t(_Jv_CheckAccess): Use _Jv_IsAssignableFromSlow.\n+\t(_Jv_CheckAccessNoInit): Removed.\n+\t* jni.cc (_Jv_JNI_GetAnyFieldID): Use resolve_field.\n+\t* interpret.cc: Include platform.h, ClassFormatError.h,\n+\tModifier.h, execution.h.\n+\t(_Jv_soleInterpreterEngine): New global.\n+\t(compile): Use resolve_pool_entry.\n+\t(run): Likewise.\n+\t(_Jv_InitField): New location.\n+\t(skip_one_type): Likewise.\n+\t(get_ffi_type_from_signature): Likewise.\n+\t(_Jv_count_arguments): Likewise.\n+\t(init_cif): Likewise.\n+\t(ncode_closure): Likewise.\n+\t(ffi_closure_fun): Likewise.\n+\t(ncode): Likewise.\n+\t(throw_class_format_error): Likewise.\n+\t(throw_class_format_error): Likewise.\n+\t(_Jv_InterpreterEngine::do_verify): New method.\n+\t(_Jv_InterpreterEngine::do_create_ncode): Likewise.\n+\t(_Jv_InterpreterEngine::do_allocate_static_fields): Likewise.\n+\t(_Jv_InterpreterEngine::do_resolve_method): Likewise.\n+\t* defineclass.cc: Include execution.h.\n+\t(_Jv_ClassReader): Initialize size_in_bytes, vtable_method_count,\n+\tengine.\n+\t(checkExtends): Ensure superclass has supers installed.\n+\t(_Jv_ClassNameSamePackage): Clarify usage constraints.\n+\t* boehm.cc (GC_enable, GC_disable): Declare at top of file.\n+\t(_Jv_MarkObj): Unconditionally mark vtable.  Mark interface\n+\tdispatch tables.\n+\n+2004-09-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* mauve-libgcj: List some classes we don't have.\n+\n+2004-09-10  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/Class.h (_Jv_getInterfaceMethod(): new friend.\n+\t* java/lang/natClass.cc (initializeClass): Check itable.\n+\t(_Jv_getInterfaceMethod): New.\n+\t(_Jv_LinkSymbolTable): Rewrite code that handles inerface calls.\n+\tCheck that an interface method isn't called with invokevirtual.\n+\n+\t* java/lang/natClass.cc (_Jv_LayoutVTableMethods): Make sure\n+\tsuper_meth is virtual.\n+\n+2004-09-01  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/Class.h (_Jv_CheckAccessNoInit): Declare as friend.\n+\t* java/lang/natClass.cc (_Jv_LayoutVTableMethods): Use\n+\t_Jv_CheckAccessNoInit.\n+\t* include/jvm.h (_Jv_CheckAccessNoInit): Declare.\n+\t* prims.cc (_Jv_CheckAccessNoInit): New method.\n+\n+\t* java/lang/reflect/natMethod.cc (invoke): Check access against\n+\tdeclaring class, not object's class.\n+\t* java/lang/natClass.cc (_Jv_LookupDeclaredMethod): Added another\n+\targument.\n+\t(_Jv_LayoutVTableMethods): Perform checks of accessibility of\n+\toverridden method.\n+\t* java/lang/Class.h (_Jv_LookupDeclaredMethod): Added another\n+\targument.\n+\n+2004-08-30  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natClass.cc (_Jv_CheckAssignment): Catch\n+\tClassNotFoundException.\n+\tThrow NoClassDefFoundError.\n+\n+\t* java/lang/natClassLoader.cc (_Jv_FindClassInCache): Remove call\n+\tto klass->verify() from here ...\n+\t(_Jv_PrepareCompiledClass): ...and put it here.\n+\n+2004-08-27  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natClassLoader.cc (_Jv_FindClassInCache): Call\n+\tklass->verify().\n+\t* java/lang/natClass.cc (_Jv_LinkSymbolTable): Add debugging.\n+\t(_Jv_LinkSymbolTable): Call Jv_LayoutClass on target class.\n+\n+2004-08-27  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/Class.h (_Jv_IsAssignableFromSlow): Declare as\n+\tfriend.\n+\t* java/lang/natClass.cc (_Jv_CheckAssignment): New function.\n+\t(_Jv_IsAssignableFromSlow): New function.\n+\tInclude VerifyError.h.\n+\t* include/jvm.h (_Jv_CheckAssignment): Declare.\n+\n+2004-08-18  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/VMCompiler.java (loadSharedLibrary): Add className\n+\targument.  Pass it to findClass instead of fileName.\n+\t(compileClass): Pass class name to loadSharedLibrary.\n+\n+2004-06-22  Andrew Haley  <aph@redhat.com>\n+\n+\t* testsuite/libjava.compile/compile.exp: Force indirect dispatch.\n+\n+2004-06-15  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natSystem.cc (getenv0): Don't assume environment\n+\tvariable is Latin 1 coded.\n+\n+2004-06-07  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/System.java: (getenv0): New method.\n+\t(getenv): Add security check.  Do the right thing.\n+\t* java/lang/natSystem.cc (getenv0): New method.\n+\n+2004-04-19    Andrew Haley  <aph@redhat.com>\n+\n+\t* gnu/gcj/runtime/NameFinder.java: Call waitFor() on the processes\n+\twe destroy.\n+\n+\t* gnu/java/net/natPlainSocketImplPosix.cc (read): The value byte\n+\tis returned as an int in the range 0 to 255.\n+\n+2004-08-13  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natClass.cc (_Jv_LinkSymbolTable): Prepare the target\n+\tclass if it is interpreted.\n+\n+2004-08-12  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natClassLoader.cc (_Jv_WaitForState): Updated.\n+\t* java/lang/Class.h (_Jv_ResolveClassRef): Updated declaration.\n+\t(Class::getSuperclass): Updated.\n+\t(Class::getInterfaces): Likewise.\n+\t(Class::size): Updated.\n+\t(_Jv_LayoutClass): Updated declaration.\n+\t* java/lang/natClass.cc (_Jv_ResolveClassRef): Changed interface.\n+\tSynchronize on class.\n+\t(_Jv_LayoutClass): Changed interface.\n+\t(initializeClass): Updated.\n+\t(_Jv_LinkSymbolTable): Likewise.\n+\n+\t* java/lang/Class.h (Class::_Jv_isBinaryCompatible): Declare as\n+\tfriend.\n+\t* java/lang/natClassLoader.cc (_Jv_WaitForState): Use\n+\t_Jv_isBinaryCompatible.\n+\t* java/lang/natClass.cc (initializeClass): Use\n+\t_Jv_isBinaryCompatible.\n+\t(_Jv_LinkSymbolTable): Likewise.\n+\t* include/jvm.h (_Jv_isBinaryCompatible): New function.\n+\n+2004-08-11  Tom Tromey  <tromey@redhat.com>\n+\n+\t* gcj/javaprims.h: Regenerated.\n+\t* java/lang/natClassLoader.cc (getClassLoader0): Removed.\n+\t(_registerClass): Likewise.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (core_java_source_files): Added VMCompiler.\n+\t* java/lang/Compiler.java: Rewrote in terms of VMCompiler.\n+\t* java/lang/VMCompiler.java: New file.\n+\t* gnu/gcj/runtime/SharedLibHelper.java (findClass): Removed\n+\t`verbose' code.\n+\t(copyFile): Don't use fully-qualified name.\n+\t(h): Removed.\n+\t* java/lang/natVMClassLoader.cc: Include VMCompiler.h.\n+\t(defineClass): Use VMCompiler.\n+\t* java/lang/ClassLoader.java (defineClass): Removed jit\n+\tcompilation code and `verbose' code.\n+\t(getClassLoader0): Removed.\n+\t(_registerClass): Likewise.\n+\t(SharedLibHelpers): Removed.\n+\n+2004-08-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/net/URLClassLoader.java (URLLoader(URLClassLoader, URL,\n+\tURL)): New constructor.\n+\t(SoURLLoader): Likewise.\n+\t(JarURLLoader): Create SoURLLoader with override URL.\n+\n+2004-08-10  Mark Wielaard  <mark@klomp.org>\n+\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (interpret.lo): New rule.\n+\n+2004-08-05  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/net/URLClassLoader.java (JarURLLoader.JarURLLoader): Look\n+\taside for \"GCJLIBS\" in directory where jarfiles are loaded.\t\n+\t(JarURLLoader.getClass): New method.\n+\t(JarURLLoader.toString):  New method.\n+\t(FileResource.toString):  New method.\n+\t* java/lang/natClassLoader.cc (_Jv_RegisterClassHookDefault):\n+\tRemove \"Duplicate class registration: \" bug.\n+\t(_registerClass): New method.\n+\t* java/lang/natClass.cc (_Jv_LinkSymbolTable): Check method index.\n+\t(_Jv_LinkSymbolTable): Call _Jv_LayoutClass().\n+\tAdd debugging.\n+\t(_Jv_LayoutClass): Use getSuperclass() rather than directly\n+\taccessing the field.\n+\t* java/lang/ClassLoader.java (SharedLibHelpers): New variable.\n+\t(defineClass): Call gcj to JIT-compile a class.\n+\t(_registerClass): New method.\n+\t* gnu/gcj/runtime/SharedLibHelper.java (findHelper): A shared\n+\tlibrary name can refer to more than one loaded library, so use a\n+\tSet of SharedLibHelpers.\n+\tIf a shared library is already loaded, take a copy.\n+\t(copyFile): New function.\n+\n+\t* testsuite/libjava.compile/compile.exp: Force\n+\t-findirect-dispatch.\n+\n+\t* java/security/BasicPermission.java: Remove bogus checks.\n+\n+\t* java/lang/System.java (getenv0): New method.\n+\t* java/lang/natSystem.cc (getenv0): New method.\n+\n+2004-05-24  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natClass.cc (_Jv_LayoutClass): Remove warning message.\n+\n+2004-04-20  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* Merged with HEAD as of 20040514. Diff against\n+\tgcj-abi-2-merge-20040514.\n+\n+2004-04-16  Andrew Haley  <aph@redhat.com>\n+\n+\t* java/lang/natClassLoader.cc (_Jv_WaitForState): Call\n+\t_Jv_LayoutClass.\n+\t(_Jv_PrepareCompiledClass): Cast address to uaddr for comparison.\n+\t(_Jv_PrepareCompiledClass): If we throw an exception during\n+\tpreparation, restore state.\n+\t(ClassLoader::getClassLoader0): New method.\n+\n+\t* java/lang/natClass.cc (get_alignment_from_class): Moved here\n+\tfrom resolve.cc.\n+\t(ALIGNOF): Use offsetof, not __alignof__.\n+\t(_Jv_ResolveClassRef): Resolve a reference to a class in a\n+\tconstant pool.\n+\t(getInterfaces): Emit debug output if interface hasn't been\n+\tresolved.\n+\t(initializeClass): Call _Jv_LayoutClass.\n+\t(_Jv_LinkSymbolTable): Add debugging output.\n+\t(_Jv_LinkSymbolTable): NoClassDefFoundError if target_class isn't\n+\tfound.\n+\t(_Jv_LinkSymbolTable): Call _Jv_PrepareClass.\n+\t(_Jv_LinkSymbolTable): Pass the real class loader to\n+\t_Jv_FindClass.\n+\t(_Jv_linkExceptionClassTable): Don't throw if we fail to find an\n+\texception class.\n+\t(_Jv_LinkSymbolTable): Assert if we find a static field reference\n+\tto an interpreted class.\n+\t(_Jv_LayoutVTableMethods): Use klass->getSuperclass to get the\n+\tsuperclass.\n+\t(_Jv_LayoutClass): Moved here; it was part of _Jv_PrepareClass in\n+\tresolve.cc.\n+\t\n+\t* java/lang/VMSecurityManager.java: Check for the system class\n+\tloader as well as loader != null.\n+\t\n+\t* java/lang/SecurityManager.java (checkPermission): Remove\n+\tsecurity check.\n+\t(checkRead): Likewise.\n+\t(checkConnect): Likewise.\n+\n+\t* java/lang/ClassLoader.java (loadClass): Include all class\n+\tloaders in stack trace string.\n+\tLook for class in \"gcjlib.so\" in the same directory.\n+\t(getSystemClassLoader) Use getClassLoader0.\n+\t(getClassLoader0): New native method.\n+\n+\t* java/lang/Class.h (getSuperclass): New method.\n+\t(getInterface): New method.\n+\t(size): Lay out class if needed.\n+\t(firstMethodIndex): New method.\n+\t(Jv_ResolveClassRef): New declaration.\n+\t(_Jv_LinkSymbolTable): New declaration.\n+\n+\t* java/io/ObjectOutputStream.java: Add DEBUG statements\n+\teverywhere.\n+\t(dumpElementln): New method.\n+\t(depth): New field.\n+\t* java/io/ObjectInputStream.java (MyIOException): new, for\n+\tdebugging.\n+\tEverywhere: use MyIOException rather than IOException.\n+\tIndent debugging output to make nesting visible.\n+\t(currentClassLoader): Make native\n+\t(callersClassLoader): New field.\n+\t(depth): New field.\n+\t* java/io/natObjectInputStream.cc (getCallersClassLoader): New\n+\tmethod.\n+\t\n+\t(readObject): ENDBLOCKDATA is generated if the class has a write\n+\tmethod, not if it has a read method.\n+\n+\t* include/jvm.h (_Jv_CallAnyMethodA): Add new arg, iface.\n+\n+\t* gnu/javax/rmi/CORBA/DelegateFactory.java: Use the\n+\tgetContextClassLoader form the current thread after our own class\n+\tloader.\n+\n+\t* gnu/gcj/runtime/SharedLibHelper.java (findClass): Class loader\n+\tdebugging.\n+\t(toString): New method.\n+\n+\t* verify.cc (class _Jv_BytecodeVerifier): Don't directly access\n+\tinterfaces array.\n+\n+\t* resolve.cc (_Jv_PrepareMissingMethods): If interface looks like\n+\ta constant pool entry, resolve it now.\n+\t(_Jv_PrepareClass): Break out part of this function to Jv_LayoutClass\n+\tin natClass.cc.\n+\tMove get_alignment_from_class to natClass.cc.\n+\n+\t* prims.cc (_Jv_AllocObjectNoFinalizer): Use size field from class.\n+\t(_Jv_AllocObjectNoInitNoFinalizer): Likewise.\n+\n+\t* defineclass.cc (checkExtends): Don't access superclass field\n+\tdirectly.\n+\n+\t* Makefile.in: regenerate.\n+\n+\t* gnu/gcj/util/natDebug.cc: New\n+\t* gnu/gcj/util/Debug.java: New.\n+\n+\t* Makefile.am (java/io/ObjectInputStream.lo): Use\n+\t-fno-optimize-sibling-calls.\n+\n+\t* java/lang/reflect/natMethod.cc (_Jv_CallAnyMethodA): Use\n+\t_Jv_LookupInterfaceMethodIdx to calculate the address of a method\n+\tin an interface.\n+\t* include/jvm.h (_Jv_CallAnyMethodA): Add new arg: iface.\n+\n 2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* configure: Regenerate for libtool change."}, {"sha": "0b07288b1489b99a4ed4b558047fb041e7948fb1", "filename": "libjava/Makefile.am", "status": "modified", "additions": 30, "deletions": 37, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -124,7 +124,7 @@ propdir = $(libdir)\n \n ## For now, only on native systems.  FIXME.\n if NATIVE\n-bin_PROGRAMS = jv-convert gij grmic grmiregistry\n+bin_PROGRAMS = jv-convert gij grmic grmiregistry gcj-dbtool\n endif\n \n bin_SCRIPTS = addr2name.awk\n@@ -207,7 +207,7 @@ libgij_la_LIBADD = libgcj.la\n libgij_la_DEPENDENCIES = libgcj.la libgcj.spec\n \n libgcj_la_SOURCES = prims.cc jni.cc exception.cc \\\n-\tresolve.cc defineclass.cc interpret.cc verify.cc \\\n+\tlink.cc defineclass.cc interpret.cc verify.cc \\\n \t$(nat_source_files) $(math_c_source_files) $(java_source_files) \\\n \t$(built_java_source_files) \\\n \t$(BOEHMGC_SRC) $(NOGC_SRC) \\\n@@ -363,7 +363,7 @@ lib_gnu_java_awt_peer_gtk_la_LIBADD = $(GTK_LIBS) $(GLIB_LIBS) $(LIBART_LIBS) $(\n lib_gnu_java_awt_peer_gtk_la_DEPENDENCIES = $(gtk_jni_headers) libgcj-@gcc_version@.jar libgcj.la libgcj.spec\n ## The mysterious backslash in the grep pattern is consumed by make.\n lib_gnu_java_awt_peer_gtk_la_LDFLAGS = \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n lib_gnu_java_awt_peer_gtk_la_LINK = $(LIBLINK)\n \n lib_org_ietf_jgss_la_SOURCES = \\\n@@ -384,7 +384,7 @@ lib_org_ietf_jgss_la_LIBADD = -L$(here)/.libs  $(jgss_propertyo_files) \\\n \n ## The mysterious backslash in the grep pattern is consumed by make.\n lib_org_ietf_jgss_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n-\t-version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+\t-version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_org_w3c_dom_la_SOURCES = org/w3c/dom/Attr.java \\\n org/w3c/dom/CDATASection.java \\\n@@ -415,7 +415,7 @@ org/w3c/dom/traversal/TreeWalker.java\n lib_org_w3c_dom_la_LIBADD = -L$(here)/.libs libgcj.la\n ## The mysterious backslash in the grep pattern is consumed by make.\n lib_org_w3c_dom_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_org_xml_sax_la_SOURCES = org/xml/sax/ext/DeclHandler.java \\\n org/xml/sax/ext/LexicalHandler.java \\\n@@ -451,7 +451,7 @@ org/xml/sax/XMLReader.java\n lib_org_xml_sax_la_LIBADD = -L$(here)/.libs libgcj.la\n ## The mysterious backslash in the grep pattern is consumed by make.\n lib_org_xml_sax_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_gnu_awt_xlib_la_SOURCES = \\\n \t$(xlib_java_source_files) \\\n@@ -467,7 +467,7 @@ lib_gnu_awt_xlib_la_CPPFLAGS = \\\n lib_gnu_awt_xlib_la_LDFLAGS = ../libstdc++-v3/src/libstdc++.la \\\n \t@X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ \\\n         -rpath $(toolexeclibdir) \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n lib_gnu_awt_xlib_la_LINK = $(LIBLINK)\n \n all_java_source_files = \\\n@@ -945,6 +945,25 @@ jv_convert_LDADD = -L$(here)/.libs libgcj.la\n ## linking this program.\n jv_convert_DEPENDENCIES = libgcj.la libgcj.spec\n \n+gcj_dbtool_SOURCES = gnu/gcj/tools/gcj_dbtool/Main.java\n+## We need -nodefaultlibs because we want to avoid gcj's `-lgcj'.  We\n+## need this because we are explicitly using libtool to link using the\n+## `.la' file.\n+gcj_dbtool_LDFLAGS = --main=gnu.gcj.tools.gcj_dbtool.Main \\\n+\t-rpath $(toolexeclibdir) -shared-libgcc $(THREADLDFLAGS)\n+gcj_dbtool_LINK = $(GCJLINK)\n+## We don't explicitly link in the libraries we need; libgcj.la brings\n+## in all dependencies.  We need the -L so that gcj can find libgcj\n+## with `-lgcj', but it must come first, otherwise the -L flags\n+## brought in from libgcj.la would cause the install directories to be\n+## searched before the build-tree ones, and we'd get errors because of\n+## different libraries with the same SONAME from picky linkers such as\n+## Solaris'.  FIXME: should be _libs on some systems.\n+gcj_dbtool_LDADD = -L$(here)/.libs libgcj.la\n+## Depend on the spec file to make sure it is up to date before\n+## linking this program.\n+gcj_dbtool_DEPENDENCIES = libgcj.la libgcj.spec\n+\n gij_SOURCES = \n ## We need -nodefaultlibs because we want to avoid gcj's `-lgcj'.  We\n ## need this because we are explicitly using libtool to link using the\n@@ -2140,65 +2159,35 @@ javax/print/attribute/SupportedValuesAttribute.java \\\n javax/print/attribute/TextSyntax.java \\\n javax/print/attribute/UnmodifiableSetException.java \\\n javax/print/attribute/URISyntax.java \\\n-javax/print/attribute/standard/ColorSupported.java \\\n-javax/print/attribute/standard/Compression.java \\\n javax/print/attribute/standard/Copies.java \\\n-javax/print/attribute/standard/CopiesSupported.java \\\n javax/print/attribute/standard/DateTimeAtCompleted.java \\\n javax/print/attribute/standard/DateTimeAtCreation.java \\\n javax/print/attribute/standard/DateTimeAtProcessing.java \\\n javax/print/attribute/standard/DocumentName.java \\\n-javax/print/attribute/standard/Fidelity.java \\\n-javax/print/attribute/standard/Finishings.java \\\n javax/print/attribute/standard/JobHoldUntil.java \\\n javax/print/attribute/standard/JobImpressions.java \\\n javax/print/attribute/standard/JobImpressionsCompleted.java \\\n-javax/print/attribute/standard/JobImpressionsSupported.java \\\n javax/print/attribute/standard/JobKOctets.java \\\n javax/print/attribute/standard/JobKOctetsProcessed.java \\\n-javax/print/attribute/standard/JobKOctetsSupported.java \\\n javax/print/attribute/standard/JobMediaSheets.java \\\n javax/print/attribute/standard/JobMediaSheetsCompleted.java \\\n-javax/print/attribute/standard/JobMediaSheetsSupported.java \\\n javax/print/attribute/standard/JobMessageFromOperator.java \\\n javax/print/attribute/standard/JobName.java \\\n javax/print/attribute/standard/JobOriginatingUserName.java \\\n javax/print/attribute/standard/JobPriority.java \\\n javax/print/attribute/standard/JobPrioritySupported.java \\\n-javax/print/attribute/standard/JobSheets.java \\\n-javax/print/attribute/standard/JobState.java \\\n-javax/print/attribute/standard/JobStateReason.java \\\n-javax/print/attribute/standard/JobStateReasons.java \\\n-javax/print/attribute/standard/Media.java \\\n-javax/print/attribute/standard/MediaSizeName.java \\\n-javax/print/attribute/standard/MultipleDocumentHandling.java \\\n javax/print/attribute/standard/NumberOfDocuments.java \\\n javax/print/attribute/standard/NumberOfInterveningJobs.java \\\n javax/print/attribute/standard/NumberUp.java \\\n-javax/print/attribute/standard/NumberUpSupported.java \\\n-javax/print/attribute/standard/OrientationRequested.java \\\n javax/print/attribute/standard/OutputDeviceAssigned.java \\\n-javax/print/attribute/standard/PDLOverrideSupported.java \\\n-javax/print/attribute/standard/PageRanges.java \\\n javax/print/attribute/standard/PagesPerMinute.java \\\n javax/print/attribute/standard/PagesPerMinuteColor.java \\\n-javax/print/attribute/standard/PresentationDirection.java \\\n-javax/print/attribute/standard/PrintQuality.java \\\n javax/print/attribute/standard/PrinterInfo.java \\\n-javax/print/attribute/standard/PrinterIsAcceptingJobs.java \\\n javax/print/attribute/standard/PrinterLocation.java \\\n javax/print/attribute/standard/PrinterMakeAndModel.java \\\n javax/print/attribute/standard/PrinterMessageFromOperator.java \\\n-javax/print/attribute/standard/PrinterMoreInfo.java \\\n-javax/print/attribute/standard/PrinterMoreInfoManufacturer.java \\\n javax/print/attribute/standard/PrinterName.java \\\n-javax/print/attribute/standard/PrinterResolution.java \\\n-javax/print/attribute/standard/PrinterState.java \\\n-javax/print/attribute/standard/PrinterStateReason.java \\\n-javax/print/attribute/standard/PrinterStateReasons.java \\\n-javax/print/attribute/standard/PrinterURI.java \\\n javax/print/attribute/standard/QueuedJobCount.java \\\n-javax/print/attribute/standard/ReferenceUriSchemesSupported.java \\\n javax/print/attribute/standard/RequestingUserName.java \\\n javax/print/attribute/standard/Severity.java \\\n javax/print/attribute/standard/SheetCollate.java \\\n@@ -2379,6 +2368,7 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/VMClassLoader.java \\\n+java/lang/VMCompiler.java \\\n java/lang/VMSecurityManager.java \\\n java/lang/VMThrowable.java \\\n java/lang/Void.java \\\n@@ -2567,11 +2557,13 @@ gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n gnu/gcj/runtime/MethodRef.java \\\n gnu/gcj/runtime/NameFinder.java \\\n+gnu/gcj/runtime/PersistentByteMap.java \\\n gnu/gcj/runtime/SharedLibHelper.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/StackTrace.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n+gnu/gcj/util/Debug.java \\\n gnu/java/io/ASN1ParsingException.java \\\n gnu/java/io/Base64InputStream.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n@@ -3282,6 +3274,7 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n+gnu/gcj/util/natDebug.cc \\\n gnu/java/lang/natMainThread.cc \\\n gnu/java/net/natPlainDatagramSocketImpl.cc \\\n gnu/java/net/natPlainSocketImpl.cc \\"}, {"sha": "60161a4bee988b7393f6defb345d5efcac75dcc2", "filename": "libjava/Makefile.in", "status": "modified", "additions": 93, "deletions": 300, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -17,7 +17,7 @@\n \n \n \n-SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) $(lib_gnu_java_awt_peer_gtk_la_SOURCES) $(lib_org_ietf_jgss_la_SOURCES) $(lib_org_w3c_dom_la_SOURCES) $(lib_org_xml_sax_la_SOURCES) $(libgcj_la_SOURCES) $(libgij_la_SOURCES) $(gen_from_JIS_SOURCES) $(gij_SOURCES) $(grmic_SOURCES) $(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n+SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) $(lib_gnu_java_awt_peer_gtk_la_SOURCES) $(lib_org_ietf_jgss_la_SOURCES) $(lib_org_w3c_dom_la_SOURCES) $(lib_org_xml_sax_la_SOURCES) $(libgcj_la_SOURCES) $(libgij_la_SOURCES) $(gcj_dbtool_SOURCES) $(gen_from_JIS_SOURCES) $(gij_SOURCES) $(grmic_SOURCES) $(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n \n srcdir = @srcdir@\n top_srcdir = @top_srcdir@\n@@ -43,7 +43,8 @@ build_triplet = @build@\n host_triplet = @host@\n target_triplet = @target@\n @NATIVE_TRUE@bin_PROGRAMS = jv-convert$(EXEEXT) gij$(EXEEXT) \\\n-@NATIVE_TRUE@\tgrmic$(EXEEXT) grmiregistry$(EXEEXT)\n+@NATIVE_TRUE@\tgrmic$(EXEEXT) grmiregistry$(EXEEXT) \\\n+@NATIVE_TRUE@\tgcj-dbtool$(EXEEXT)\n @MAINTAINER_MODE_TRUE@@NATIVE_TRUE@noinst_PROGRAMS =  \\\n @MAINTAINER_MODE_TRUE@@NATIVE_TRUE@\tgen-from-JIS$(EXEEXT)\n DIST_COMMON = README $(am__configure_deps) $(srcdir)/../compile \\\n@@ -371,7 +372,7 @@ lib_org_xml_sax_la_OBJECTS = $(am_lib_org_xml_sax_la_OBJECTS)\n am__DEPENDENCIES_4 = gnu/regexp/MessagesBundle.properties.lo \\\n \tgnu/regexp/MessagesBundle_fr.properties.lo\n am__DEPENDENCIES_5 = $(am__DEPENDENCIES_4)\n-am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n+am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc link.cc \\\n \tdefineclass.cc interpret.cc verify.cc gnu/gcj/natCore.cc \\\n \tgnu/gcj/convert/JIS0208_to_Unicode.cc \\\n \tgnu/gcj/convert/JIS0212_to_Unicode.cc \\\n@@ -386,7 +387,7 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tgnu/gcj/runtime/natSharedLibLoader.cc \\\n \tgnu/gcj/runtime/natStackTrace.cc \\\n \tgnu/gcj/runtime/natStringBuffer.cc \\\n-\tgnu/gcj/runtime/natVMClassLoader.cc \\\n+\tgnu/gcj/runtime/natVMClassLoader.cc gnu/gcj/util/natDebug.cc \\\n \tgnu/java/lang/natMainThread.cc \\\n \tgnu/java/net/natPlainDatagramSocketImpl.cc \\\n \tgnu/java/net/natPlainSocketImpl.cc \\\n@@ -481,9 +482,9 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tjava/lang/UnsupportedClassVersionError.java \\\n \tjava/lang/UnsupportedOperationException.java \\\n \tjava/lang/VerifyError.java java/lang/VirtualMachineError.java \\\n-\tjava/lang/VMClassLoader.java java/lang/VMSecurityManager.java \\\n-\tjava/lang/VMThrowable.java java/lang/Void.java \\\n-\tjava/io/BufferedInputStream.java \\\n+\tjava/lang/VMClassLoader.java java/lang/VMCompiler.java \\\n+\tjava/lang/VMSecurityManager.java java/lang/VMThrowable.java \\\n+\tjava/lang/Void.java java/io/BufferedInputStream.java \\\n \tjava/io/BufferedOutputStream.java java/io/BufferedReader.java \\\n \tjava/io/BufferedWriter.java java/io/ByteArrayInputStream.java \\\n \tjava/io/ByteArrayOutputStream.java \\\n@@ -597,11 +598,12 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tgnu/gcj/runtime/FinalizerThread.java \\\n \tgnu/gcj/runtime/JNIWeakRef.java gnu/gcj/runtime/MethodRef.java \\\n \tgnu/gcj/runtime/NameFinder.java \\\n+\tgnu/gcj/runtime/PersistentByteMap.java \\\n \tgnu/gcj/runtime/SharedLibHelper.java \\\n \tgnu/gcj/runtime/SharedLibLoader.java \\\n \tgnu/gcj/runtime/StackTrace.java \\\n \tgnu/gcj/runtime/StringBuffer.java \\\n-\tgnu/gcj/runtime/VMClassLoader.java \\\n+\tgnu/gcj/runtime/VMClassLoader.java gnu/gcj/util/Debug.java \\\n \tgnu/java/io/ASN1ParsingException.java \\\n \tgnu/java/io/Base64InputStream.java \\\n \tgnu/java/io/ClassLoaderObjectInputStream.java \\\n@@ -2174,65 +2176,35 @@ am__libgcj_la_SOURCES_DIST = prims.cc jni.cc exception.cc resolve.cc \\\n \tjavax/print/attribute/TextSyntax.java \\\n \tjavax/print/attribute/UnmodifiableSetException.java \\\n \tjavax/print/attribute/URISyntax.java \\\n-\tjavax/print/attribute/standard/ColorSupported.java \\\n-\tjavax/print/attribute/standard/Compression.java \\\n \tjavax/print/attribute/standard/Copies.java \\\n-\tjavax/print/attribute/standard/CopiesSupported.java \\\n \tjavax/print/attribute/standard/DateTimeAtCompleted.java \\\n \tjavax/print/attribute/standard/DateTimeAtCreation.java \\\n \tjavax/print/attribute/standard/DateTimeAtProcessing.java \\\n \tjavax/print/attribute/standard/DocumentName.java \\\n-\tjavax/print/attribute/standard/Fidelity.java \\\n-\tjavax/print/attribute/standard/Finishings.java \\\n \tjavax/print/attribute/standard/JobHoldUntil.java \\\n \tjavax/print/attribute/standard/JobImpressions.java \\\n \tjavax/print/attribute/standard/JobImpressionsCompleted.java \\\n-\tjavax/print/attribute/standard/JobImpressionsSupported.java \\\n \tjavax/print/attribute/standard/JobKOctets.java \\\n \tjavax/print/attribute/standard/JobKOctetsProcessed.java \\\n-\tjavax/print/attribute/standard/JobKOctetsSupported.java \\\n \tjavax/print/attribute/standard/JobMediaSheets.java \\\n \tjavax/print/attribute/standard/JobMediaSheetsCompleted.java \\\n-\tjavax/print/attribute/standard/JobMediaSheetsSupported.java \\\n \tjavax/print/attribute/standard/JobMessageFromOperator.java \\\n \tjavax/print/attribute/standard/JobName.java \\\n \tjavax/print/attribute/standard/JobOriginatingUserName.java \\\n \tjavax/print/attribute/standard/JobPriority.java \\\n \tjavax/print/attribute/standard/JobPrioritySupported.java \\\n-\tjavax/print/attribute/standard/JobSheets.java \\\n-\tjavax/print/attribute/standard/JobState.java \\\n-\tjavax/print/attribute/standard/JobStateReason.java \\\n-\tjavax/print/attribute/standard/JobStateReasons.java \\\n-\tjavax/print/attribute/standard/Media.java \\\n-\tjavax/print/attribute/standard/MediaSizeName.java \\\n-\tjavax/print/attribute/standard/MultipleDocumentHandling.java \\\n \tjavax/print/attribute/standard/NumberOfDocuments.java \\\n \tjavax/print/attribute/standard/NumberOfInterveningJobs.java \\\n \tjavax/print/attribute/standard/NumberUp.java \\\n-\tjavax/print/attribute/standard/NumberUpSupported.java \\\n-\tjavax/print/attribute/standard/OrientationRequested.java \\\n \tjavax/print/attribute/standard/OutputDeviceAssigned.java \\\n-\tjavax/print/attribute/standard/PDLOverrideSupported.java \\\n-\tjavax/print/attribute/standard/PageRanges.java \\\n \tjavax/print/attribute/standard/PagesPerMinute.java \\\n \tjavax/print/attribute/standard/PagesPerMinuteColor.java \\\n-\tjavax/print/attribute/standard/PresentationDirection.java \\\n-\tjavax/print/attribute/standard/PrintQuality.java \\\n \tjavax/print/attribute/standard/PrinterInfo.java \\\n-\tjavax/print/attribute/standard/PrinterIsAcceptingJobs.java \\\n \tjavax/print/attribute/standard/PrinterLocation.java \\\n \tjavax/print/attribute/standard/PrinterMakeAndModel.java \\\n \tjavax/print/attribute/standard/PrinterMessageFromOperator.java \\\n-\tjavax/print/attribute/standard/PrinterMoreInfo.java \\\n-\tjavax/print/attribute/standard/PrinterMoreInfoManufacturer.java \\\n \tjavax/print/attribute/standard/PrinterName.java \\\n-\tjavax/print/attribute/standard/PrinterResolution.java \\\n-\tjavax/print/attribute/standard/PrinterState.java \\\n-\tjavax/print/attribute/standard/PrinterStateReason.java \\\n-\tjavax/print/attribute/standard/PrinterStateReasons.java \\\n-\tjavax/print/attribute/standard/PrinterURI.java \\\n \tjavax/print/attribute/standard/QueuedJobCount.java \\\n-\tjavax/print/attribute/standard/ReferenceUriSchemesSupported.java \\\n \tjavax/print/attribute/standard/RequestingUserName.java \\\n \tjavax/print/attribute/standard/Severity.java \\\n \tjavax/print/attribute/standard/SheetCollate.java \\\n@@ -2337,7 +2309,7 @@ am__objects_6 = gnu/gcj/natCore.lo \\\n \tgnu/gcj/runtime/natSharedLibLoader.lo \\\n \tgnu/gcj/runtime/natStackTrace.lo \\\n \tgnu/gcj/runtime/natStringBuffer.lo \\\n-\tgnu/gcj/runtime/natVMClassLoader.lo \\\n+\tgnu/gcj/runtime/natVMClassLoader.lo gnu/gcj/util/natDebug.lo \\\n \tgnu/java/lang/natMainThread.lo \\\n \tgnu/java/net/natPlainDatagramSocketImpl.lo \\\n \tgnu/java/net/natPlainSocketImpl.lo \\\n@@ -2428,11 +2400,11 @@ am__objects_9 = java/lang/AbstractMethodError.lo \\\n \tjava/lang/UnsupportedClassVersionError.lo \\\n \tjava/lang/UnsupportedOperationException.lo \\\n \tjava/lang/VerifyError.lo java/lang/VirtualMachineError.lo \\\n-\tjava/lang/VMClassLoader.lo java/lang/VMSecurityManager.lo \\\n-\tjava/lang/VMThrowable.lo java/lang/Void.lo \\\n-\tjava/io/BufferedInputStream.lo java/io/BufferedOutputStream.lo \\\n-\tjava/io/BufferedReader.lo java/io/BufferedWriter.lo \\\n-\tjava/io/ByteArrayInputStream.lo \\\n+\tjava/lang/VMClassLoader.lo java/lang/VMCompiler.lo \\\n+\tjava/lang/VMSecurityManager.lo java/lang/VMThrowable.lo \\\n+\tjava/lang/Void.lo java/io/BufferedInputStream.lo \\\n+\tjava/io/BufferedOutputStream.lo java/io/BufferedReader.lo \\\n+\tjava/io/BufferedWriter.lo java/io/ByteArrayInputStream.lo \\\n \tjava/io/ByteArrayOutputStream.lo java/io/CharArrayReader.lo \\\n \tjava/io/CharArrayWriter.lo java/io/CharConversionException.lo \\\n \tjava/io/DataInput.lo java/io/DataInputStream.lo \\\n@@ -3435,65 +3407,35 @@ am__objects_13 = javax/accessibility/Accessible.lo \\\n \tjavax/print/attribute/TextSyntax.lo \\\n \tjavax/print/attribute/UnmodifiableSetException.lo \\\n \tjavax/print/attribute/URISyntax.lo \\\n-\tjavax/print/attribute/standard/ColorSupported.lo \\\n-\tjavax/print/attribute/standard/Compression.lo \\\n \tjavax/print/attribute/standard/Copies.lo \\\n-\tjavax/print/attribute/standard/CopiesSupported.lo \\\n \tjavax/print/attribute/standard/DateTimeAtCompleted.lo \\\n \tjavax/print/attribute/standard/DateTimeAtCreation.lo \\\n \tjavax/print/attribute/standard/DateTimeAtProcessing.lo \\\n \tjavax/print/attribute/standard/DocumentName.lo \\\n-\tjavax/print/attribute/standard/Fidelity.lo \\\n-\tjavax/print/attribute/standard/Finishings.lo \\\n \tjavax/print/attribute/standard/JobHoldUntil.lo \\\n \tjavax/print/attribute/standard/JobImpressions.lo \\\n \tjavax/print/attribute/standard/JobImpressionsCompleted.lo \\\n-\tjavax/print/attribute/standard/JobImpressionsSupported.lo \\\n \tjavax/print/attribute/standard/JobKOctets.lo \\\n \tjavax/print/attribute/standard/JobKOctetsProcessed.lo \\\n-\tjavax/print/attribute/standard/JobKOctetsSupported.lo \\\n \tjavax/print/attribute/standard/JobMediaSheets.lo \\\n \tjavax/print/attribute/standard/JobMediaSheetsCompleted.lo \\\n-\tjavax/print/attribute/standard/JobMediaSheetsSupported.lo \\\n \tjavax/print/attribute/standard/JobMessageFromOperator.lo \\\n \tjavax/print/attribute/standard/JobName.lo \\\n \tjavax/print/attribute/standard/JobOriginatingUserName.lo \\\n \tjavax/print/attribute/standard/JobPriority.lo \\\n \tjavax/print/attribute/standard/JobPrioritySupported.lo \\\n-\tjavax/print/attribute/standard/JobSheets.lo \\\n-\tjavax/print/attribute/standard/JobState.lo \\\n-\tjavax/print/attribute/standard/JobStateReason.lo \\\n-\tjavax/print/attribute/standard/JobStateReasons.lo \\\n-\tjavax/print/attribute/standard/Media.lo \\\n-\tjavax/print/attribute/standard/MediaSizeName.lo \\\n-\tjavax/print/attribute/standard/MultipleDocumentHandling.lo \\\n \tjavax/print/attribute/standard/NumberOfDocuments.lo \\\n \tjavax/print/attribute/standard/NumberOfInterveningJobs.lo \\\n \tjavax/print/attribute/standard/NumberUp.lo \\\n-\tjavax/print/attribute/standard/NumberUpSupported.lo \\\n-\tjavax/print/attribute/standard/OrientationRequested.lo \\\n \tjavax/print/attribute/standard/OutputDeviceAssigned.lo \\\n-\tjavax/print/attribute/standard/PDLOverrideSupported.lo \\\n-\tjavax/print/attribute/standard/PageRanges.lo \\\n \tjavax/print/attribute/standard/PagesPerMinute.lo \\\n \tjavax/print/attribute/standard/PagesPerMinuteColor.lo \\\n-\tjavax/print/attribute/standard/PresentationDirection.lo \\\n-\tjavax/print/attribute/standard/PrintQuality.lo \\\n \tjavax/print/attribute/standard/PrinterInfo.lo \\\n-\tjavax/print/attribute/standard/PrinterIsAcceptingJobs.lo \\\n \tjavax/print/attribute/standard/PrinterLocation.lo \\\n \tjavax/print/attribute/standard/PrinterMakeAndModel.lo \\\n \tjavax/print/attribute/standard/PrinterMessageFromOperator.lo \\\n-\tjavax/print/attribute/standard/PrinterMoreInfo.lo \\\n-\tjavax/print/attribute/standard/PrinterMoreInfoManufacturer.lo \\\n \tjavax/print/attribute/standard/PrinterName.lo \\\n-\tjavax/print/attribute/standard/PrinterResolution.lo \\\n-\tjavax/print/attribute/standard/PrinterState.lo \\\n-\tjavax/print/attribute/standard/PrinterStateReason.lo \\\n-\tjavax/print/attribute/standard/PrinterStateReasons.lo \\\n-\tjavax/print/attribute/standard/PrinterURI.lo \\\n \tjavax/print/attribute/standard/QueuedJobCount.lo \\\n-\tjavax/print/attribute/standard/ReferenceUriSchemesSupported.lo \\\n \tjavax/print/attribute/standard/RequestingUserName.lo \\\n \tjavax/print/attribute/standard/Severity.lo \\\n \tjavax/print/attribute/standard/SheetCollate.lo \\\n@@ -3585,10 +3527,11 @@ am__objects_14 = $(am__objects_9) gnu/classpath/ServiceFactory.lo \\\n \tgnu/gcj/runtime/FinalizerThread.lo \\\n \tgnu/gcj/runtime/JNIWeakRef.lo gnu/gcj/runtime/MethodRef.lo \\\n \tgnu/gcj/runtime/NameFinder.lo \\\n+\tgnu/gcj/runtime/PersistentByteMap.lo \\\n \tgnu/gcj/runtime/SharedLibHelper.lo \\\n \tgnu/gcj/runtime/SharedLibLoader.lo \\\n \tgnu/gcj/runtime/StackTrace.lo gnu/gcj/runtime/StringBuffer.lo \\\n-\tgnu/gcj/runtime/VMClassLoader.lo \\\n+\tgnu/gcj/runtime/VMClassLoader.lo gnu/gcj/util/Debug.lo \\\n \tgnu/java/io/ASN1ParsingException.lo \\\n \tgnu/java/io/Base64InputStream.lo \\\n \tgnu/java/io/ClassLoaderObjectInputStream.lo \\\n@@ -4151,7 +4094,7 @@ am__objects_16 = java/lang/ConcreteProcess.lo \\\n @USING_POSIX_THREADS_TRUE@am__objects_24 = posix-threads.lo\n @USING_WIN32_THREADS_TRUE@am__objects_25 = win32-threads.lo\n @USING_NO_THREADS_TRUE@am__objects_26 = no-threads.lo\n-am_libgcj_la_OBJECTS = prims.lo jni.lo exception.lo resolve.lo \\\n+am_libgcj_la_OBJECTS = prims.lo jni.lo exception.lo link.lo \\\n \tdefineclass.lo interpret.lo verify.lo $(am__objects_6) \\\n \t$(am__objects_7) $(am__objects_15) $(am__objects_16) \\\n \t$(am__objects_17) $(am__objects_18) $(am__objects_19) \\\n@@ -4163,6 +4106,8 @@ am_libgij_la_OBJECTS = gij.lo\n libgij_la_OBJECTS = $(am_libgij_la_OBJECTS)\n binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)\n PROGRAMS = $(bin_PROGRAMS) $(noinst_PROGRAMS)\n+am_gcj_dbtool_OBJECTS = gnu/gcj/tools/gcj_dbtool/Main.$(OBJEXT)\n+gcj_dbtool_OBJECTS = $(am_gcj_dbtool_OBJECTS)\n am__gen_from_JIS_SOURCES_DIST = gnu/gcj/convert/gen-from-JIS.c \\\n \tgnu/gcj/convert/make-trie.c\n @MAINTAINER_MODE_TRUE@@NATIVE_TRUE@am_gen_from_JIS_OBJECTS = gnu/gcj/convert/gen-from-JIS.$(OBJEXT) \\\n@@ -4206,15 +4151,16 @@ SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) \\\n \t$(lib_gnu_java_awt_peer_gtk_la_SOURCES) \\\n \t$(lib_org_ietf_jgss_la_SOURCES) $(lib_org_w3c_dom_la_SOURCES) \\\n \t$(lib_org_xml_sax_la_SOURCES) $(libgcj_la_SOURCES) \\\n-\t$(libgij_la_SOURCES) $(gen_from_JIS_SOURCES) $(gij_SOURCES) \\\n-\t$(grmic_SOURCES) $(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n+\t$(libgij_la_SOURCES) $(gcj_dbtool_SOURCES) \\\n+\t$(gen_from_JIS_SOURCES) $(gij_SOURCES) $(grmic_SOURCES) \\\n+\t$(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n DIST_SOURCES = $(lib_gnu_awt_xlib_la_SOURCES) \\\n \t$(am__lib_gnu_java_awt_peer_gtk_la_SOURCES_DIST) \\\n \t$(lib_org_ietf_jgss_la_SOURCES) $(lib_org_w3c_dom_la_SOURCES) \\\n \t$(lib_org_xml_sax_la_SOURCES) $(am__libgcj_la_SOURCES_DIST) \\\n-\t$(libgij_la_SOURCES) $(am__gen_from_JIS_SOURCES_DIST) \\\n-\t$(gij_SOURCES) $(grmic_SOURCES) $(grmiregistry_SOURCES) \\\n-\t$(jv_convert_SOURCES)\n+\t$(libgij_la_SOURCES) $(gcj_dbtool_SOURCES) \\\n+\t$(am__gen_from_JIS_SOURCES_DIST) $(gij_SOURCES) \\\n+\t$(grmic_SOURCES) $(grmiregistry_SOURCES) $(jv_convert_SOURCES)\n RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n \thtml-recursive info-recursive install-data-recursive \\\n \tinstall-exec-recursive install-info-recursive \\\n@@ -4314,6 +4260,7 @@ LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+LIBGCJ_LD_SYMBOLIC = @LIBGCJ_LD_SYMBOLIC@\n LIBICONV = @LIBICONV@\n LIBLTDL = @LIBLTDL@\n LIBOBJS = @LIBOBJS@\n@@ -4546,7 +4493,7 @@ libgij_la_SOURCES = gij.cc\n libgij_la_LIBADD = libgcj.la\n libgij_la_DEPENDENCIES = libgcj.la libgcj.spec\n libgcj_la_SOURCES = prims.cc jni.cc exception.cc \\\n-\tresolve.cc defineclass.cc interpret.cc verify.cc \\\n+\tlink.cc defineclass.cc interpret.cc verify.cc \\\n \t$(nat_source_files) $(math_c_source_files) $(java_source_files) \\\n \t$(built_java_source_files) \\\n \t$(BOEHMGC_SRC) $(NOGC_SRC) \\\n@@ -4686,7 +4633,7 @@ lib_gnu_java_awt_peer_gtk_la_GCJFLAGS = $(AM_GCJFLAGS) -fjni\n lib_gnu_java_awt_peer_gtk_la_LIBADD = $(GTK_LIBS) $(GLIB_LIBS) $(LIBART_LIBS) $(CAIRO_LIBS) $(PANGOFT2_LIBS)\n lib_gnu_java_awt_peer_gtk_la_DEPENDENCIES = $(gtk_jni_headers) libgcj-@gcc_version@.jar libgcj.la libgcj.spec\n lib_gnu_java_awt_peer_gtk_la_LDFLAGS = \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_gnu_java_awt_peer_gtk_la_LINK = $(LIBLINK)\n lib_org_ietf_jgss_la_SOURCES = \\\n@@ -4706,7 +4653,7 @@ lib_org_ietf_jgss_la_LIBADD = -L$(here)/.libs  $(jgss_propertyo_files) \\\n \tlibgcj.la\n \n lib_org_ietf_jgss_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n-\t-version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+\t-version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_org_w3c_dom_la_SOURCES = org/w3c/dom/Attr.java \\\n org/w3c/dom/CDATASection.java \\\n@@ -4736,7 +4683,7 @@ org/w3c/dom/traversal/TreeWalker.java\n \n lib_org_w3c_dom_la_LIBADD = -L$(here)/.libs libgcj.la\n lib_org_w3c_dom_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_org_xml_sax_la_SOURCES = org/xml/sax/ext/DeclHandler.java \\\n org/xml/sax/ext/LexicalHandler.java \\\n@@ -4771,7 +4718,7 @@ org/xml/sax/XMLReader.java\n \n lib_org_xml_sax_la_LIBADD = -L$(here)/.libs libgcj.la\n lib_org_xml_sax_la_LDFLAGS = -rpath $(toolexeclibdir) \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_gnu_awt_xlib_la_SOURCES = \\\n \t$(xlib_java_source_files) \\\n@@ -4787,7 +4734,7 @@ lib_gnu_awt_xlib_la_CPPFLAGS = \\\n lib_gnu_awt_xlib_la_LDFLAGS = ../libstdc++-v3/src/libstdc++.la \\\n \t@X_PRE_LIBS@ @X_LIBS@ -lX11 @X_EXTRA_LIBS@ \\\n         -rpath $(toolexeclibdir) \\\n-        -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n+        -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(LIBGCJ_LD_SYMBOLIC)\n \n lib_gnu_awt_xlib_la_LINK = $(LIBLINK)\n all_java_source_files = \\\n@@ -4851,6 +4798,13 @@ jv_convert_LDFLAGS = --main=gnu.gcj.convert.Convert \\\n jv_convert_LINK = $(GCJLINK)\n jv_convert_LDADD = -L$(here)/.libs libgcj.la\n jv_convert_DEPENDENCIES = libgcj.la libgcj.spec\n+gcj_dbtool_SOURCES = gnu/gcj/tools/gcj_dbtool/Main.java\n+gcj_dbtool_LDFLAGS = --main=gnu.gcj.tools.gcj_dbtool.Main \\\n+\t-rpath $(toolexeclibdir) -shared-libgcc $(THREADLDFLAGS)\n+\n+gcj_dbtool_LINK = $(GCJLINK)\n+gcj_dbtool_LDADD = -L$(here)/.libs libgcj.la\n+gcj_dbtool_DEPENDENCIES = libgcj.la libgcj.spec\n gij_SOURCES = \n gij_LDFLAGS = -rpath $(toolexeclibdir) -shared-libgcc $(THREADLDFLAGS)\n gij_LINK = $(GCJLINK)\n@@ -6022,65 +5976,35 @@ javax/print/attribute/SupportedValuesAttribute.java \\\n javax/print/attribute/TextSyntax.java \\\n javax/print/attribute/UnmodifiableSetException.java \\\n javax/print/attribute/URISyntax.java \\\n-javax/print/attribute/standard/ColorSupported.java \\\n-javax/print/attribute/standard/Compression.java \\\n javax/print/attribute/standard/Copies.java \\\n-javax/print/attribute/standard/CopiesSupported.java \\\n javax/print/attribute/standard/DateTimeAtCompleted.java \\\n javax/print/attribute/standard/DateTimeAtCreation.java \\\n javax/print/attribute/standard/DateTimeAtProcessing.java \\\n javax/print/attribute/standard/DocumentName.java \\\n-javax/print/attribute/standard/Fidelity.java \\\n-javax/print/attribute/standard/Finishings.java \\\n javax/print/attribute/standard/JobHoldUntil.java \\\n javax/print/attribute/standard/JobImpressions.java \\\n javax/print/attribute/standard/JobImpressionsCompleted.java \\\n-javax/print/attribute/standard/JobImpressionsSupported.java \\\n javax/print/attribute/standard/JobKOctets.java \\\n javax/print/attribute/standard/JobKOctetsProcessed.java \\\n-javax/print/attribute/standard/JobKOctetsSupported.java \\\n javax/print/attribute/standard/JobMediaSheets.java \\\n javax/print/attribute/standard/JobMediaSheetsCompleted.java \\\n-javax/print/attribute/standard/JobMediaSheetsSupported.java \\\n javax/print/attribute/standard/JobMessageFromOperator.java \\\n javax/print/attribute/standard/JobName.java \\\n javax/print/attribute/standard/JobOriginatingUserName.java \\\n javax/print/attribute/standard/JobPriority.java \\\n javax/print/attribute/standard/JobPrioritySupported.java \\\n-javax/print/attribute/standard/JobSheets.java \\\n-javax/print/attribute/standard/JobState.java \\\n-javax/print/attribute/standard/JobStateReason.java \\\n-javax/print/attribute/standard/JobStateReasons.java \\\n-javax/print/attribute/standard/Media.java \\\n-javax/print/attribute/standard/MediaSizeName.java \\\n-javax/print/attribute/standard/MultipleDocumentHandling.java \\\n javax/print/attribute/standard/NumberOfDocuments.java \\\n javax/print/attribute/standard/NumberOfInterveningJobs.java \\\n javax/print/attribute/standard/NumberUp.java \\\n-javax/print/attribute/standard/NumberUpSupported.java \\\n-javax/print/attribute/standard/OrientationRequested.java \\\n javax/print/attribute/standard/OutputDeviceAssigned.java \\\n-javax/print/attribute/standard/PDLOverrideSupported.java \\\n-javax/print/attribute/standard/PageRanges.java \\\n javax/print/attribute/standard/PagesPerMinute.java \\\n javax/print/attribute/standard/PagesPerMinuteColor.java \\\n-javax/print/attribute/standard/PresentationDirection.java \\\n-javax/print/attribute/standard/PrintQuality.java \\\n javax/print/attribute/standard/PrinterInfo.java \\\n-javax/print/attribute/standard/PrinterIsAcceptingJobs.java \\\n javax/print/attribute/standard/PrinterLocation.java \\\n javax/print/attribute/standard/PrinterMakeAndModel.java \\\n javax/print/attribute/standard/PrinterMessageFromOperator.java \\\n-javax/print/attribute/standard/PrinterMoreInfo.java \\\n-javax/print/attribute/standard/PrinterMoreInfoManufacturer.java \\\n javax/print/attribute/standard/PrinterName.java \\\n-javax/print/attribute/standard/PrinterResolution.java \\\n-javax/print/attribute/standard/PrinterState.java \\\n-javax/print/attribute/standard/PrinterStateReason.java \\\n-javax/print/attribute/standard/PrinterStateReasons.java \\\n-javax/print/attribute/standard/PrinterURI.java \\\n javax/print/attribute/standard/QueuedJobCount.java \\\n-javax/print/attribute/standard/ReferenceUriSchemesSupported.java \\\n javax/print/attribute/standard/RequestingUserName.java \\\n javax/print/attribute/standard/Severity.java \\\n javax/print/attribute/standard/SheetCollate.java \\\n@@ -6255,6 +6179,7 @@ java/lang/UnsupportedOperationException.java \\\n java/lang/VerifyError.java \\\n java/lang/VirtualMachineError.java \\\n java/lang/VMClassLoader.java \\\n+java/lang/VMCompiler.java \\\n java/lang/VMSecurityManager.java \\\n java/lang/VMThrowable.java \\\n java/lang/Void.java \\\n@@ -6437,11 +6362,13 @@ gnu/gcj/runtime/FinalizerThread.java \\\n gnu/gcj/runtime/JNIWeakRef.java \\\n gnu/gcj/runtime/MethodRef.java \\\n gnu/gcj/runtime/NameFinder.java \\\n+gnu/gcj/runtime/PersistentByteMap.java \\\n gnu/gcj/runtime/SharedLibHelper.java \\\n gnu/gcj/runtime/SharedLibLoader.java \\\n gnu/gcj/runtime/StackTrace.java \\\n gnu/gcj/runtime/StringBuffer.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n+gnu/gcj/util/Debug.java \\\n gnu/java/io/ASN1ParsingException.java \\\n gnu/java/io/Base64InputStream.java \\\n gnu/java/io/ClassLoaderObjectInputStream.java \\\n@@ -7147,6 +7074,7 @@ gnu/gcj/runtime/natSharedLibLoader.cc \\\n gnu/gcj/runtime/natStackTrace.cc \\\n gnu/gcj/runtime/natStringBuffer.cc \\\n gnu/gcj/runtime/natVMClassLoader.cc \\\n+gnu/gcj/util/natDebug.cc \\\n gnu/java/lang/natMainThread.cc \\\n gnu/java/net/natPlainDatagramSocketImpl.cc \\\n gnu/java/net/natPlainSocketImpl.cc \\\n@@ -8042,6 +7970,14 @@ gnu/gcj/runtime/natStringBuffer.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/natVMClassLoader.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n+gnu/gcj/util/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/gcj/util\n+\t@: > gnu/gcj/util/$(am__dirstamp)\n+gnu/gcj/util/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/gcj/util/$(DEPDIR)\n+\t@: > gnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n+gnu/gcj/util/natDebug.lo: gnu/gcj/util/$(am__dirstamp) \\\n+\tgnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n gnu/java/lang/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/lang\n \t@: > gnu/java/lang/$(am__dirstamp)\n@@ -8456,6 +8392,8 @@ java/lang/VirtualMachineError.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/VMClassLoader.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n+java/lang/VMCompiler.lo: java/lang/$(am__dirstamp) \\\n+\tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/VMSecurityManager.lo: java/lang/$(am__dirstamp) \\\n \tjava/lang/$(DEPDIR)/$(am__dirstamp)\n java/lang/VMThrowable.lo: java/lang/$(am__dirstamp) \\\n@@ -8852,6 +8790,8 @@ gnu/gcj/runtime/MethodRef.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/NameFinder.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n+gnu/gcj/runtime/PersistentByteMap.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n+\tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/SharedLibHelper.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/SharedLibLoader.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n@@ -8862,6 +8802,8 @@ gnu/gcj/runtime/StringBuffer.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n gnu/gcj/runtime/VMClassLoader.lo: gnu/gcj/runtime/$(am__dirstamp) \\\n \tgnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n+gnu/gcj/util/Debug.lo: gnu/gcj/util/$(am__dirstamp) \\\n+\tgnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n gnu/java/io/$(am__dirstamp):\n \t@$(mkdir_p) gnu/java/io\n \t@: > gnu/java/io/$(am__dirstamp)\n@@ -13836,18 +13778,9 @@ javax/print/attribute/standard/$(am__dirstamp):\n javax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp):\n \t@$(mkdir_p) javax/print/attribute/standard/$(DEPDIR)\n \t@: > javax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/ColorSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/Compression.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/Copies.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/CopiesSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/DateTimeAtCompleted.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n@@ -13860,12 +13793,6 @@ javax/print/attribute/standard/DateTimeAtProcessing.lo:  \\\n javax/print/attribute/standard/DocumentName.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/Fidelity.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/Finishings.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/JobHoldUntil.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n@@ -13875,27 +13802,18 @@ javax/print/attribute/standard/JobImpressions.lo:  \\\n javax/print/attribute/standard/JobImpressionsCompleted.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobImpressionsSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/JobKOctets.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/JobKOctetsProcessed.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobKOctetsSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/JobMediaSheets.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/JobMediaSheetsCompleted.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobMediaSheetsSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/JobMessageFromOperator.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n@@ -13911,27 +13829,6 @@ javax/print/attribute/standard/JobPriority.lo:  \\\n javax/print/attribute/standard/JobPrioritySupported.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobSheets.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobState.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobStateReason.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/JobStateReasons.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/Media.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/MediaSizeName.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/MultipleDocumentHandling.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/NumberOfDocuments.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n@@ -13941,39 +13838,18 @@ javax/print/attribute/standard/NumberOfInterveningJobs.lo:  \\\n javax/print/attribute/standard/NumberUp.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/NumberUpSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/OrientationRequested.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/OutputDeviceAssigned.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PDLOverrideSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PageRanges.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/PagesPerMinute.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/PagesPerMinuteColor.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PresentationDirection.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrintQuality.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/PrinterInfo.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterIsAcceptingJobs.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/PrinterLocation.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n@@ -13983,36 +13859,12 @@ javax/print/attribute/standard/PrinterMakeAndModel.lo:  \\\n javax/print/attribute/standard/PrinterMessageFromOperator.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterMoreInfo.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterMoreInfoManufacturer.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/PrinterName.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterResolution.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterState.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterStateReason.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterStateReasons.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/PrinterURI.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/QueuedJobCount.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n-javax/print/attribute/standard/ReferenceUriSchemesSupported.lo:  \\\n-\tjavax/print/attribute/standard/$(am__dirstamp) \\\n-\tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n javax/print/attribute/standard/RequestingUserName.lo:  \\\n \tjavax/print/attribute/standard/$(am__dirstamp) \\\n \tjavax/print/attribute/standard/$(DEPDIR)/$(am__dirstamp)\n@@ -14379,6 +14231,18 @@ clean-noinstPROGRAMS:\n \t  echo \" rm -f $$p $$f\"; \\\n \t  rm -f $$p $$f ; \\\n \tdone\n+gnu/gcj/tools/gcj_dbtool/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/gcj/tools/gcj_dbtool\n+\t@: > gnu/gcj/tools/gcj_dbtool/$(am__dirstamp)\n+gnu/gcj/tools/gcj_dbtool/$(DEPDIR)/$(am__dirstamp):\n+\t@$(mkdir_p) gnu/gcj/tools/gcj_dbtool/$(DEPDIR)\n+\t@: > gnu/gcj/tools/gcj_dbtool/$(DEPDIR)/$(am__dirstamp)\n+gnu/gcj/tools/gcj_dbtool/Main.$(OBJEXT):  \\\n+\tgnu/gcj/tools/gcj_dbtool/$(am__dirstamp) \\\n+\tgnu/gcj/tools/gcj_dbtool/$(DEPDIR)/$(am__dirstamp)\n+gcj-dbtool$(EXEEXT): $(gcj_dbtool_OBJECTS) $(gcj_dbtool_DEPENDENCIES) \n+\t@rm -f gcj-dbtool$(EXEEXT)\n+\t$(gcj_dbtool_LINK) $(gcj_dbtool_LDFLAGS) $(gcj_dbtool_OBJECTS) $(gcj_dbtool_LDADD) $(LIBS)\n gnu/gcj/convert/gen-from-JIS.$(OBJEXT):  \\\n \tgnu/gcj/convert/$(am__dirstamp) \\\n \tgnu/gcj/convert/$(DEPDIR)/$(am__dirstamp)\n@@ -14549,6 +14413,8 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/runtime/MethodRef.lo\n \t-rm -f gnu/gcj/runtime/NameFinder.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/NameFinder.lo\n+\t-rm -f gnu/gcj/runtime/PersistentByteMap.$(OBJEXT)\n+\t-rm -f gnu/gcj/runtime/PersistentByteMap.lo\n \t-rm -f gnu/gcj/runtime/SharedLibHelper.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/SharedLibHelper.lo\n \t-rm -f gnu/gcj/runtime/SharedLibLoader.$(OBJEXT)\n@@ -14571,6 +14437,11 @@ mostlyclean-compile:\n \t-rm -f gnu/gcj/runtime/natStringBuffer.lo\n \t-rm -f gnu/gcj/runtime/natVMClassLoader.$(OBJEXT)\n \t-rm -f gnu/gcj/runtime/natVMClassLoader.lo\n+\t-rm -f gnu/gcj/tools/gcj_dbtool/Main.$(OBJEXT)\n+\t-rm -f gnu/gcj/util/Debug.$(OBJEXT)\n+\t-rm -f gnu/gcj/util/Debug.lo\n+\t-rm -f gnu/gcj/util/natDebug.$(OBJEXT)\n+\t-rm -f gnu/gcj/util/natDebug.lo\n \t-rm -f gnu/gcj/xlib/Clip.$(OBJEXT)\n \t-rm -f gnu/gcj/xlib/Clip.lo\n \t-rm -f gnu/gcj/xlib/Colormap.$(OBJEXT)\n@@ -16531,6 +16402,8 @@ mostlyclean-compile:\n \t-rm -f java/lang/UnsupportedOperationException.lo\n \t-rm -f java/lang/VMClassLoader.$(OBJEXT)\n \t-rm -f java/lang/VMClassLoader.lo\n+\t-rm -f java/lang/VMCompiler.$(OBJEXT)\n+\t-rm -f java/lang/VMCompiler.lo\n \t-rm -f java/lang/VMSecurityManager.$(OBJEXT)\n \t-rm -f java/lang/VMSecurityManager.lo\n \t-rm -f java/lang/VMThrowable.$(OBJEXT)\n@@ -18259,14 +18132,8 @@ mostlyclean-compile:\n \t-rm -f javax/print/attribute/URISyntax.lo\n \t-rm -f javax/print/attribute/UnmodifiableSetException.$(OBJEXT)\n \t-rm -f javax/print/attribute/UnmodifiableSetException.lo\n-\t-rm -f javax/print/attribute/standard/ColorSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/ColorSupported.lo\n-\t-rm -f javax/print/attribute/standard/Compression.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/Compression.lo\n \t-rm -f javax/print/attribute/standard/Copies.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/Copies.lo\n-\t-rm -f javax/print/attribute/standard/CopiesSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/CopiesSupported.lo\n \t-rm -f javax/print/attribute/standard/DateTimeAtCompleted.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/DateTimeAtCompleted.lo\n \t-rm -f javax/print/attribute/standard/DateTimeAtCreation.$(OBJEXT)\n@@ -18275,30 +18142,20 @@ mostlyclean-compile:\n \t-rm -f javax/print/attribute/standard/DateTimeAtProcessing.lo\n \t-rm -f javax/print/attribute/standard/DocumentName.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/DocumentName.lo\n-\t-rm -f javax/print/attribute/standard/Fidelity.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/Fidelity.lo\n-\t-rm -f javax/print/attribute/standard/Finishings.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/Finishings.lo\n \t-rm -f javax/print/attribute/standard/JobHoldUntil.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobHoldUntil.lo\n \t-rm -f javax/print/attribute/standard/JobImpressions.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobImpressions.lo\n \t-rm -f javax/print/attribute/standard/JobImpressionsCompleted.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobImpressionsCompleted.lo\n-\t-rm -f javax/print/attribute/standard/JobImpressionsSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobImpressionsSupported.lo\n \t-rm -f javax/print/attribute/standard/JobKOctets.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobKOctets.lo\n \t-rm -f javax/print/attribute/standard/JobKOctetsProcessed.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobKOctetsProcessed.lo\n-\t-rm -f javax/print/attribute/standard/JobKOctetsSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobKOctetsSupported.lo\n \t-rm -f javax/print/attribute/standard/JobMediaSheets.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobMediaSheets.lo\n \t-rm -f javax/print/attribute/standard/JobMediaSheetsCompleted.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobMediaSheetsCompleted.lo\n-\t-rm -f javax/print/attribute/standard/JobMediaSheetsSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobMediaSheetsSupported.lo\n \t-rm -f javax/print/attribute/standard/JobMessageFromOperator.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobMessageFromOperator.lo\n \t-rm -f javax/print/attribute/standard/JobName.$(OBJEXT)\n@@ -18309,74 +18166,30 @@ mostlyclean-compile:\n \t-rm -f javax/print/attribute/standard/JobPriority.lo\n \t-rm -f javax/print/attribute/standard/JobPrioritySupported.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/JobPrioritySupported.lo\n-\t-rm -f javax/print/attribute/standard/JobSheets.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobSheets.lo\n-\t-rm -f javax/print/attribute/standard/JobState.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobState.lo\n-\t-rm -f javax/print/attribute/standard/JobStateReason.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobStateReason.lo\n-\t-rm -f javax/print/attribute/standard/JobStateReasons.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/JobStateReasons.lo\n-\t-rm -f javax/print/attribute/standard/Media.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/Media.lo\n-\t-rm -f javax/print/attribute/standard/MediaSizeName.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/MediaSizeName.lo\n-\t-rm -f javax/print/attribute/standard/MultipleDocumentHandling.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/MultipleDocumentHandling.lo\n \t-rm -f javax/print/attribute/standard/NumberOfDocuments.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/NumberOfDocuments.lo\n \t-rm -f javax/print/attribute/standard/NumberOfInterveningJobs.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/NumberOfInterveningJobs.lo\n \t-rm -f javax/print/attribute/standard/NumberUp.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/NumberUp.lo\n-\t-rm -f javax/print/attribute/standard/NumberUpSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/NumberUpSupported.lo\n-\t-rm -f javax/print/attribute/standard/OrientationRequested.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/OrientationRequested.lo\n \t-rm -f javax/print/attribute/standard/OutputDeviceAssigned.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/OutputDeviceAssigned.lo\n-\t-rm -f javax/print/attribute/standard/PDLOverrideSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PDLOverrideSupported.lo\n-\t-rm -f javax/print/attribute/standard/PageRanges.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PageRanges.lo\n \t-rm -f javax/print/attribute/standard/PagesPerMinute.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PagesPerMinute.lo\n \t-rm -f javax/print/attribute/standard/PagesPerMinuteColor.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PagesPerMinuteColor.lo\n-\t-rm -f javax/print/attribute/standard/PresentationDirection.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PresentationDirection.lo\n-\t-rm -f javax/print/attribute/standard/PrintQuality.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrintQuality.lo\n \t-rm -f javax/print/attribute/standard/PrinterInfo.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PrinterInfo.lo\n-\t-rm -f javax/print/attribute/standard/PrinterIsAcceptingJobs.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterIsAcceptingJobs.lo\n \t-rm -f javax/print/attribute/standard/PrinterLocation.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PrinterLocation.lo\n \t-rm -f javax/print/attribute/standard/PrinterMakeAndModel.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PrinterMakeAndModel.lo\n \t-rm -f javax/print/attribute/standard/PrinterMessageFromOperator.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PrinterMessageFromOperator.lo\n-\t-rm -f javax/print/attribute/standard/PrinterMoreInfo.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterMoreInfo.lo\n-\t-rm -f javax/print/attribute/standard/PrinterMoreInfoManufacturer.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterMoreInfoManufacturer.lo\n \t-rm -f javax/print/attribute/standard/PrinterName.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/PrinterName.lo\n-\t-rm -f javax/print/attribute/standard/PrinterResolution.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterResolution.lo\n-\t-rm -f javax/print/attribute/standard/PrinterState.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterState.lo\n-\t-rm -f javax/print/attribute/standard/PrinterStateReason.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterStateReason.lo\n-\t-rm -f javax/print/attribute/standard/PrinterStateReasons.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterStateReasons.lo\n-\t-rm -f javax/print/attribute/standard/PrinterURI.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/PrinterURI.lo\n \t-rm -f javax/print/attribute/standard/QueuedJobCount.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/QueuedJobCount.lo\n-\t-rm -f javax/print/attribute/standard/ReferenceUriSchemesSupported.$(OBJEXT)\n-\t-rm -f javax/print/attribute/standard/ReferenceUriSchemesSupported.lo\n \t-rm -f javax/print/attribute/standard/RequestingUserName.$(OBJEXT)\n \t-rm -f javax/print/attribute/standard/RequestingUserName.lo\n \t-rm -f javax/print/attribute/standard/Severity.$(OBJEXT)\n@@ -19490,12 +19303,12 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gij.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interpret.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jni.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/link.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/no-threads.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nogc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix-threads.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prims.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/resolve.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/verify.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32-threads.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/win32.Plo@am__quote@\n@@ -19564,6 +19377,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/JNIWeakRef.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/MethodRef.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/NameFinder.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/PersistentByteMap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/SharedLibHelper.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/SharedLibLoader.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/StackTrace.Plo@am__quote@\n@@ -19575,6 +19389,9 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natStackTrace.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natStringBuffer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/runtime/$(DEPDIR)/natVMClassLoader.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/tools/gcj_dbtool/$(DEPDIR)/Main.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/util/$(DEPDIR)/Debug.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/util/$(DEPDIR)/natDebug.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/xlib/$(DEPDIR)/Clip.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/xlib/$(DEPDIR)/Colormap.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@gnu/gcj/xlib/$(DEPDIR)/Display.Plo@am__quote@\n@@ -20555,6 +20372,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/UnsupportedClassVersionError.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/UnsupportedOperationException.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/VMClassLoader.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/VMCompiler.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/VMSecurityManager.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/VMThrowable.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@java/lang/$(DEPDIR)/VerifyError.Plo@am__quote@\n@@ -21419,65 +21237,35 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/$(DEPDIR)/TextSyntax.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/$(DEPDIR)/URISyntax.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/$(DEPDIR)/UnmodifiableSetException.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/ColorSupported.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/Compression.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/Copies.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/CopiesSupported.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/DateTimeAtCompleted.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/DateTimeAtCreation.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/DateTimeAtProcessing.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/DocumentName.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/Fidelity.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/Finishings.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobHoldUntil.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobImpressions.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobImpressionsCompleted.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobImpressionsSupported.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobKOctets.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobKOctetsProcessed.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobKOctetsSupported.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobMediaSheets.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobMediaSheetsCompleted.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobMediaSheetsSupported.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobMessageFromOperator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobName.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobOriginatingUserName.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobPriority.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobPrioritySupported.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobSheets.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobState.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobStateReason.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/JobStateReasons.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/Media.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/MediaSizeName.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/MultipleDocumentHandling.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/NumberOfDocuments.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/NumberOfInterveningJobs.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/NumberUp.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/NumberUpSupported.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/OrientationRequested.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/OutputDeviceAssigned.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PDLOverrideSupported.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PageRanges.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PagesPerMinute.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PagesPerMinuteColor.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PresentationDirection.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrintQuality.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterInfo.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterIsAcceptingJobs.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterLocation.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterMakeAndModel.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterMessageFromOperator.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterMoreInfo.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterMoreInfoManufacturer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterName.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterResolution.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterState.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterStateReason.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterStateReasons.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/PrinterURI.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/QueuedJobCount.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/ReferenceUriSchemesSupported.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/RequestingUserName.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/Severity.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@javax/print/attribute/standard/$(DEPDIR)/SheetCollate.Plo@am__quote@\n@@ -22857,6 +22645,7 @@ clean-libtool:\n \t-rm -rf gnu/gcj/convert/.libs gnu/gcj/convert/_libs\n \t-rm -rf gnu/gcj/io/.libs gnu/gcj/io/_libs\n \t-rm -rf gnu/gcj/runtime/.libs gnu/gcj/runtime/_libs\n+\t-rm -rf gnu/gcj/util/.libs gnu/gcj/util/_libs\n \t-rm -rf gnu/gcj/xlib/.libs gnu/gcj/xlib/_libs\n \t-rm -rf gnu/java/awt/.libs gnu/java/awt/_libs\n \t-rm -rf gnu/java/awt/image/.libs gnu/java/awt/image/_libs\n@@ -23358,6 +23147,10 @@ distclean-generic:\n \t-rm -f gnu/gcj/io/$(am__dirstamp)\n \t-rm -f gnu/gcj/runtime/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/gcj/runtime/$(am__dirstamp)\n+\t-rm -f gnu/gcj/tools/gcj_dbtool/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/gcj/tools/gcj_dbtool/$(am__dirstamp)\n+\t-rm -f gnu/gcj/util/$(DEPDIR)/$(am__dirstamp)\n+\t-rm -f gnu/gcj/util/$(am__dirstamp)\n \t-rm -f gnu/gcj/xlib/$(DEPDIR)/$(am__dirstamp)\n \t-rm -f gnu/gcj/xlib/$(am__dirstamp)\n \t-rm -f gnu/java/awt/$(DEPDIR)/$(am__dirstamp)\n@@ -23646,7 +23439,7 @@ clean-am: clean-binPROGRAMS clean-generic clean-libtool clean-local \\\n \n distclean: distclean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n distclean-am: clean-am distclean-compile distclean-generic \\\n \tdistclean-libtool distclean-local distclean-tags\n@@ -23676,7 +23469,7 @@ installcheck-am:\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n \t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n+\t-rm -rf ./$(DEPDIR) gnu/awt/$(DEPDIR) gnu/awt/j2d/$(DEPDIR) gnu/awt/xlib/$(DEPDIR) gnu/classpath/$(DEPDIR) gnu/gcj/$(DEPDIR) gnu/gcj/convert/$(DEPDIR) gnu/gcj/io/$(DEPDIR) gnu/gcj/runtime/$(DEPDIR) gnu/gcj/tools/gcj_dbtool/$(DEPDIR) gnu/gcj/util/$(DEPDIR) gnu/gcj/xlib/$(DEPDIR) gnu/java/awt/$(DEPDIR) gnu/java/awt/image/$(DEPDIR) gnu/java/awt/peer/$(DEPDIR) gnu/java/awt/peer/gtk/$(DEPDIR) gnu/java/beans/$(DEPDIR) gnu/java/beans/editors/$(DEPDIR) gnu/java/beans/info/$(DEPDIR) gnu/java/io/$(DEPDIR) gnu/java/lang/$(DEPDIR) gnu/java/lang/reflect/$(DEPDIR) gnu/java/locale/$(DEPDIR) gnu/java/math/$(DEPDIR) gnu/java/net/$(DEPDIR) gnu/java/net/protocol/core/$(DEPDIR) gnu/java/net/protocol/file/$(DEPDIR) gnu/java/net/protocol/gcjlib/$(DEPDIR) gnu/java/net/protocol/http/$(DEPDIR) gnu/java/net/protocol/jar/$(DEPDIR) gnu/java/nio/$(DEPDIR) gnu/java/nio/channels/$(DEPDIR) gnu/java/nio/charset/$(DEPDIR) gnu/java/rmi/$(DEPDIR) gnu/java/rmi/dgc/$(DEPDIR) gnu/java/rmi/registry/$(DEPDIR) gnu/java/rmi/rmic/$(DEPDIR) gnu/java/rmi/server/$(DEPDIR) gnu/java/security/$(DEPDIR) gnu/java/security/action/$(DEPDIR) gnu/java/security/der/$(DEPDIR) gnu/java/security/provider/$(DEPDIR) gnu/java/security/util/$(DEPDIR) gnu/java/security/x509/$(DEPDIR) gnu/java/security/x509/ext/$(DEPDIR) gnu/java/text/$(DEPDIR) gnu/java/util/$(DEPDIR) gnu/java/util/prefs/$(DEPDIR) gnu/regexp/$(DEPDIR) java/applet/$(DEPDIR) java/awt/$(DEPDIR) java/awt/color/$(DEPDIR) java/awt/datatransfer/$(DEPDIR) java/awt/dnd/$(DEPDIR) java/awt/dnd/peer/$(DEPDIR) java/awt/event/$(DEPDIR) java/awt/font/$(DEPDIR) java/awt/geom/$(DEPDIR) java/awt/im/$(DEPDIR) java/awt/im/spi/$(DEPDIR) java/awt/image/$(DEPDIR) java/awt/image/renderable/$(DEPDIR) java/awt/peer/$(DEPDIR) java/awt/print/$(DEPDIR) java/beans/$(DEPDIR) java/beans/beancontext/$(DEPDIR) java/io/$(DEPDIR) java/lang/$(DEPDIR) java/lang/ref/$(DEPDIR) java/lang/reflect/$(DEPDIR) java/math/$(DEPDIR) java/net/$(DEPDIR) java/nio/$(DEPDIR) java/nio/channels/$(DEPDIR) java/nio/channels/spi/$(DEPDIR) java/nio/charset/$(DEPDIR) java/nio/charset/spi/$(DEPDIR) java/rmi/$(DEPDIR) java/rmi/activation/$(DEPDIR) java/rmi/dgc/$(DEPDIR) java/rmi/registry/$(DEPDIR) java/rmi/server/$(DEPDIR) java/security/$(DEPDIR) java/security/acl/$(DEPDIR) java/security/cert/$(DEPDIR) java/security/interfaces/$(DEPDIR) java/security/spec/$(DEPDIR) java/sql/$(DEPDIR) java/text/$(DEPDIR) java/util/$(DEPDIR) java/util/jar/$(DEPDIR) java/util/logging/$(DEPDIR) java/util/prefs/$(DEPDIR) java/util/regex/$(DEPDIR) java/util/zip/$(DEPDIR) javax/accessibility/$(DEPDIR) javax/crypto/$(DEPDIR) javax/crypto/interfaces/$(DEPDIR) javax/crypto/spec/$(DEPDIR) javax/imageio/$(DEPDIR) javax/imageio/event/$(DEPDIR) javax/imageio/metadata/$(DEPDIR) javax/imageio/spi/$(DEPDIR) javax/imageio/stream/$(DEPDIR) javax/naming/$(DEPDIR) javax/naming/directory/$(DEPDIR) javax/naming/event/$(DEPDIR) javax/naming/ldap/$(DEPDIR) javax/naming/spi/$(DEPDIR) javax/net/$(DEPDIR) javax/net/ssl/$(DEPDIR) javax/print/$(DEPDIR) javax/print/attribute/$(DEPDIR) javax/print/attribute/standard/$(DEPDIR) javax/print/event/$(DEPDIR) javax/security/auth/$(DEPDIR) javax/security/auth/callback/$(DEPDIR) javax/security/auth/login/$(DEPDIR) javax/security/auth/spi/$(DEPDIR) javax/security/auth/x500/$(DEPDIR) javax/security/cert/$(DEPDIR) javax/security/sasl/$(DEPDIR) javax/sql/$(DEPDIR) javax/swing/$(DEPDIR) javax/swing/border/$(DEPDIR) javax/swing/colorchooser/$(DEPDIR) javax/swing/event/$(DEPDIR) javax/swing/filechooser/$(DEPDIR) javax/swing/plaf/$(DEPDIR) javax/swing/plaf/basic/$(DEPDIR) javax/swing/plaf/metal/$(DEPDIR) javax/swing/table/$(DEPDIR) javax/swing/text/$(DEPDIR) javax/swing/text/html/$(DEPDIR) javax/swing/text/html/parser/$(DEPDIR) javax/swing/tree/$(DEPDIR) javax/swing/undo/$(DEPDIR) javax/transaction/$(DEPDIR) javax/transaction/xa/$(DEPDIR) jni/classpath/$(DEPDIR) jni/gtk-peer/$(DEPDIR) org/ietf/jgss/$(DEPDIR) org/w3c/dom/$(DEPDIR) org/w3c/dom/ranges/$(DEPDIR) org/w3c/dom/traversal/$(DEPDIR) org/xml/sax/$(DEPDIR) org/xml/sax/ext/$(DEPDIR) org/xml/sax/helpers/$(DEPDIR) sysdep/$(DEPDIR)\n \t-rm -f Makefile\n maintainer-clean-am: distclean-am maintainer-clean-generic\n "}, {"sha": "ffc535707c843433190e8a0f5f750d52a1913c9c", "filename": "libjava/aclocal.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Faclocal.m4?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -417,7 +417,7 @@ AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n # 02111-1307, USA.\n \n AC_DEFUN([AM_PROG_GCJ],[\n-AC_CHECK_PROGS(GCJ, [gcj gcj-3.2 gcj-3.1 gcj-3.0 gcj-2.95], gcj)\n+AC_CHECK_PROGS(GCJ, gcj, gcj)\n test -z \"$GCJ\" && AC_MSG_ERROR([no acceptable gcj found in \\$PATH])\n if test \"x${GCJFLAGS-unset}\" = xunset; then\n    GCJFLAGS=\"-g -O2\""}, {"sha": "d2902326e816feb30e6d338cc6de6158bc7c87bb", "filename": "libjava/boehm.cc", "status": "modified", "additions": 127, "deletions": 74, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fboehm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fboehm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fboehm.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,7 @@\n // boehm.cc - interface between libjava and Boehm GC.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -10,6 +11,21 @@ details.  */\n \n #include <config.h>\n \n+#include <stdio.h>\n+#include <limits.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java-interp.h>\n+\n+// More nastiness: the GC wants to define TRUE and FALSE.  We don't\n+// need the Java definitions (themselves a hack), so we undefine them.\n+#undef TRUE\n+#undef FALSE\n+\n extern \"C\"\n {\n #include <gc_config.h>\n@@ -27,34 +43,28 @@ extern \"C\"\n # define GC_REDIRECT_TO_LOCAL\n # include <gc_local_alloc.h>\n #endif\n-};\n \n-#include <stdio.h>\n-#include <limits.h>\n-\n-#include <jvm.h>\n-#include <gcj/cni.h>\n-\n-#include <java/lang/Class.h>\n-#include <java/lang/reflect/Modifier.h>\n-#include <java-interp.h>\n+  // From boehm's misc.c \n+  void GC_enable();\n+  void GC_disable();\n+};\n \n-#define MAYBE_MARK(Obj, Top, Limit, Source, Exit)  \\\n-\tTop=GC_MARK_AND_PUSH((GC_PTR)Obj, Top, Limit, (GC_PTR *)Source)\n+#define MAYBE_MARK(Obj, Top, Limit, Source)  \\\n+\tTop=GC_MARK_AND_PUSH((GC_PTR) Obj, Top, Limit, (GC_PTR *) Source)\n \n // `kind' index used when allocating Java arrays.\n static int array_kind_x;\n \n // Freelist used for Java arrays.\n-static void * *array_free_list;\n+static void **array_free_list;\n \n \f\n \n // This is called by the GC during the mark phase.  It marks a Java\n // object.  We use `void *' arguments and return, and not what the\n // Boehm GC wants, to avoid pollution in our headers.\n void *\n-_Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n+_Jv_MarkObj (void *addr, void *msp, void *msl, void *env)\n {\n   struct GC_ms_entry *mark_stack_ptr = (struct GC_ms_entry *)msp;\n   struct GC_ms_entry *mark_stack_limit = (struct GC_ms_entry *)msl;\n@@ -78,11 +88,11 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n # ifndef JV_HASH_SYNCHRONIZATION\n     // Every object has a sync_info pointer.\n     p = (GC_PTR) obj->sync_info;\n-    MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o1label);\n+    MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj);\n # endif\n   // Mark the object's class.\n   p = (GC_PTR) klass;\n-  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj, o2label);\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj);\n \n   if (__builtin_expect (klass == &java::lang::Class::class$, false))\n     {\n@@ -101,33 +111,35 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n       jclass c = (jclass) addr;\n \n       p = (GC_PTR) c->name;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c3label);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->superclass;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c4label);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       for (int i = 0; i < c->constants.size; ++i)\n \t{\n \t  /* FIXME: We could make this more precise by using the tags -KKT */\n \t  p = (GC_PTR) c->constants.data[i].p;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5label);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t}\n \n #ifdef INTERPRETER\n       if (_Jv_IsInterpretedClass (c))\n \t{\n \t  p = (GC_PTR) c->constants.tags;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5alabel);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t  p = (GC_PTR) c->constants.data;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5blabel);\n-\t  p = (GC_PTR) c->vtable;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c5clabel);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t}\n #endif\n \n+      // The vtable might be allocated even for compiled code.\n+      p = (GC_PTR) c->vtable;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+\n       // If the class is an array, then the methods field holds a\n       // pointer to the element class.  If the class is primitive,\n       // then the methods field holds a pointer to the array class.\n       p = (GC_PTR) c->methods;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c6label);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n       // The vtable might have been set, but the rest of the class\n       // could still be uninitialized.  If this is the case, then\n@@ -143,34 +155,35 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n \t  for (int i = 0; i < c->method_count; ++i)\n \t    {\n \t      p = (GC_PTR) c->methods[i].name;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n-\t\t\t     cm1label);\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t      p = (GC_PTR) c->methods[i].signature;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n-\t\t\t     cm2label);\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+\n+\t      // Note that we don't have to mark each individual throw\n+\t      // separately, as these are stored in the constant pool.\n+\t      p = (GC_PTR) c->methods[i].throws;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t    }\n \t}\n \n       // Mark all the fields.\n       p = (GC_PTR) c->fields;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8label);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       for (int i = 0; i < c->field_count; ++i)\n \t{\n \t  _Jv_Field* field = &c->fields[i];\n \n-#ifndef COMPACT_FIELDS\n \t  p = (GC_PTR) field->name;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8alabel);\n-#endif\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t  p = (GC_PTR) field->type;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8blabel);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n \t  // For the interpreter, we also need to mark the memory\n \t  // containing static members\n \t  if ((field->flags & java::lang::reflect::Modifier::STATIC))\n \t    {\n \t      p = (GC_PTR) field->u.addr;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c8clabel);\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n \t      // also, if the static member is a reference,\n \t      // mark also the value pointed to.  We check for isResolved\n@@ -180,69 +193,110 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n \t\t{\n \t\t  jobject val = *(jobject*) field->u.addr;\n \t\t  p = (GC_PTR) val;\n-\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit,\n-\t\t\t      c, c8elabel);\n+\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t\t}\n \t    }\n \t}\n \n       p = (GC_PTR) c->vtable;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, c9label);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->interfaces;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cAlabel);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       for (int i = 0; i < c->interface_count; ++i)\n \t{\n \t  p = (GC_PTR) c->interfaces[i];\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cClabel);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \t}\n       p = (GC_PTR) c->loader;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cBlabel);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+\n+      // The dispatch tables can be allocated at runtime.\n+      p = (GC_PTR) c->ancestors;\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+      if (c->idt)\n+\t{\n+\t  p = (GC_PTR) c->idt;\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+\n+\t  if (c->isInterface())\n+\t    {\n+\t      p = (GC_PTR) c->idt->iface.ioffsets;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c->idt);\n+\t    }\n+\t  else if (! c->isPrimitive())\n+\t    {\n+\t      // This field is only valid for ordinary classes.\n+\t      p = (GC_PTR) c->idt->cls.itable;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c->idt);\n+\t    }\n+\t}\n+\n       p = (GC_PTR) c->arrayclass;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cDlabel);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->protectionDomain;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cPlabel);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->hack_signers;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cSlabel);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n       p = (GC_PTR) c->aux_info;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c, cTlabel);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n \n #ifdef INTERPRETER\n-      if (_Jv_IsInterpretedClass (c))\n+      if (_Jv_IsInterpretedClass (c) && c->aux_info)\n \t{\n \t  _Jv_InterpClass* ic = (_Jv_InterpClass*) c->aux_info;\n \n \t  p = (GC_PTR) ic->interpreted_methods;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cElabel);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n \n \t  for (int i = 0; i < c->method_count; i++)\n \t    {\n+\t      // The interpreter installs a heap-allocated trampoline\n+\t      // here, so we'll mark it.\n+\t      p = (GC_PTR) c->methods[i].ncode;\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c);\n+\n+\t      using namespace java::lang::reflect;\n+\n+\t      // Mark the direct-threaded code.  Note a subtlety here:\n+\t      // when we add Miranda methods to a class, we don't\n+\t      // resize its interpreted_methods array.  If we try to\n+\t      // reference one of these methods, we may crash.\n+\t      // However, we know these are all abstract, and we know\n+\t      // that abstract methods have nothing useful in this\n+\t      // array.  So, we skip all abstract methods to avoid the\n+\t      // problem.  FIXME: this is pretty obscure, it may be\n+\t      // better to add a methods to the execution engine and\n+\t      // resize the array.\n+\t      if ((c->methods[i].accflags & Modifier::ABSTRACT) != 0)\n+\t\tcontinue;\n+\n \t      p = (GC_PTR) ic->interpreted_methods[i];\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n-\t\t\t  cFlabel);\n+\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n \n-\t      // Mark the direct-threaded code.\n-\t      if ((c->methods[i].accflags\n-\t\t   & java::lang::reflect::Modifier::NATIVE) == 0)\n+\t      if ((c->methods[i].accflags & Modifier::NATIVE) != 0)\n+\t\t{\n+\t\t  _Jv_JNIMethod *jm\n+\t\t    = (_Jv_JNIMethod *) ic->interpreted_methods[i];\n+\t\t  if (jm)\n+\t\t    {\n+\t\t      p = (GC_PTR) jm->jni_arg_types;\n+\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, p);\n+\t\t    }\n+\t\t}\n+\t      else\n \t\t{\n \t\t  _Jv_InterpMethod *im\n \t\t    = (_Jv_InterpMethod *) ic->interpreted_methods[i];\n \t\t  if (im)\n \t\t    {\n \t\t      p = (GC_PTR) im->prepared;\n-\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, \\\n-\t\t\t\t  cFlabel);\n+\t\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n \t\t    }\n \t\t}\n-\n-\t      // The interpreter installs a heap-allocated trampoline\n-\t      // here, so we'll mark it.\n-\t      p = (GC_PTR) c->methods[i].ncode;\n-\t      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, c,\n-\t\t\t  cm3label);\n \t    }\n \n \t  p = (GC_PTR) ic->field_initializers;\n-\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic, cGlabel);\n+\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, ic);\n \t  \n \t}\n #endif\n@@ -269,8 +323,7 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n \t\t{\n \t\t  jobject val = JvGetObjectField (obj, field);\n \t\t  p = (GC_PTR) val;\n-\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit,\n-\t\t\t      obj, elabel);\n+\t\t  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, obj);\n \t\t}\n \t      field = field->getNextField ();\n \t    }\n@@ -285,7 +338,7 @@ _Jv_MarkObj (void *addr, void *msp, void *msl, void * env)\n // array (of objects).  We use `void *' arguments and return, and not\n // what the Boehm GC wants, to avoid pollution in our headers.\n void *\n-_Jv_MarkArray (void *addr, void *msp, void *msl, void * env)\n+_Jv_MarkArray (void *addr, void *msp, void *msl, void *env)\n {\n   struct GC_ms_entry *mark_stack_ptr = (struct GC_ms_entry *)msp;\n   struct GC_ms_entry *mark_stack_limit = (struct GC_ms_entry *)msl;\n@@ -306,17 +359,17 @@ _Jv_MarkArray (void *addr, void *msp, void *msl, void * env)\n # ifndef JV_HASH_SYNCHRONIZATION\n     // Every object has a sync_info pointer.\n     p = (GC_PTR) array->sync_info;\n-    MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array, e1label);\n+    MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array);\n # endif\n   // Mark the object's class.\n   p = (GC_PTR) klass;\n-  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, &(dt -> clas), o2label);\n+  MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, &(dt -> clas));\n \n   for (int i = 0; i < JvGetArrayLength (array); ++i)\n     {\n       jobject obj = elements (array)[i];\n       p = (GC_PTR) obj;\n-      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array, e2label);\n+      MAYBE_MARK (p, mark_stack_ptr, mark_stack_limit, array);\n     }\n \n   return mark_stack_ptr;\n@@ -364,7 +417,7 @@ _Jv_BuildGCDescr(jclass self)\n \t      // If we find a field outside the range of our bitmap,\n \t      // fall back to procedure marker. The bottom 2 bits are\n \t      // reserved.\n-\t      if (off >= (unsigned)bits_per_word - 2)\n+\t      if (off >= (unsigned) bits_per_word - 2)\n \t\treturn (void *) (GCJ_DEFAULT_DESCR);\n \t      desc |= 1ULL << (bits_per_word - off - 1);\n \t    }\n@@ -514,10 +567,6 @@ _Jv_GCSetMaximumHeapSize (size_t size)\n   GC_set_max_heap_size ((GC_word) size);\n }\n \n-// From boehm's misc.c \n-extern \"C\" void GC_enable();\n-extern \"C\" void GC_disable();\n-\n void\n _Jv_DisableGC (void)\n {\n@@ -585,7 +634,7 @@ _Jv_InitGC (void)\n   proc = GC_new_proc((GC_mark_proc)_Jv_MarkArray);\n   array_kind_x = GC_new_kind(array_free_list, GC_MAKE_PROC (proc, 0), 0, 1);\n \n-  /* Arrange to have the GC print Java class names in backtraces, etc. \t*/\n+  // Arrange to have the GC print Java class names in backtraces, etc.\n   GC_register_describe_type_fn(GC_gcj_kind, gcj_describe_type_fn);\n   GC_register_describe_type_fn(GC_gcj_debug_kind, gcj_describe_type_fn);\n }\n@@ -640,7 +689,11 @@ _Jv_GCInitializeFinalizers (void (*notifier) (void))\n void\n _Jv_GCRegisterDisappearingLink (jobject *objp)\n {\n-  GC_general_register_disappearing_link ((GC_PTR *) objp, (GC_PTR) *objp);\n+  // This test helps to ensure that we meet a precondition of\n+  // GC_general_register_disappearing_link, viz. \"Obj must be a\n+  // pointer to the first word of an object we allocated.\"\n+  if (GC_base(*objp))\n+    GC_general_register_disappearing_link ((GC_PTR *) objp, (GC_PTR) *objp);\n }\n \n jboolean"}, {"sha": "cf52939df11e2d8159b18cac50d35ac6c86c629c", "filename": "libjava/configure", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -310,7 +310,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS libgcj_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical LN_S mkinstalldirs CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LDFLAGS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBGCJ_CFLAGS LIBGCJ_CXXFLAGS LIBGCJ_JAVAFLAGS INCLTDL LIBLTDL DIRLTDL LIBTOOL CXXCPP CPPFLAGS GCJ GCJFLAGS GCJDEPMODE am__fastdepGCJ_TRUE am__fastdepGCJ_FALSE subdirs COMPPATH TESTSUBDIR_TRUE TESTSUBDIR_FALSE ONESTEP_TRUE ONESTEP_FALSE LIBGCJDEBUG INTERPRETER LIBFFI LIBFFIINCS PLATFORM_INNER_NAT_HDRS CPP EGREP USING_WIN32_PLATFORM_TRUE USING_WIN32_PLATFORM_FALSE USING_POSIX_PLATFORM_TRUE USING_POSIX_PLATFORM_FALSE USING_ECOS_PLATFORM_TRUE USING_ECOS_PLATFORM_FALSE USING_DARWIN_CRT_TRUE USING_DARWIN_CRT_FALSE SYSTEMSPEC LIBGCJTESTSPEC ZLIBSPEC ZLIBTESTSPEC X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS TOOLKIT XLIB_AWT_TRUE XLIB_AWT_FALSE GTK_AWT_TRUE GTK_AWT_FALSE GTK_CAIRO_TRUE GTK_CAIRO_FALSE PKG_CONFIG CAIRO_CFLAGS CAIRO_LIBS PANGOFT2_CFLAGS PANGOFT2_LIBS GCLIBS GCINCS GCDEPS GCSPEC JC1GCSPEC GCTESTSPEC USING_BOEHMGC_TRUE USING_BOEHMGC_FALSE USING_NOGC_TRUE USING_NOGC_FALSE THREADLIBS THREADINCS THREADDEPS THREADSPEC THREADLDFLAGS THREADCXXFLAGS USING_POSIX_THREADS_TRUE USING_POSIX_THREADS_FALSE USING_WIN32_THREADS_TRUE USING_WIN32_THREADS_FALSE USING_NO_THREADS_TRUE USING_NO_THREADS_FALSE HASH_SYNC_SPEC USING_GCC_TRUE USING_GCC_FALSE tool_include_dir gcc_version LIBICONV LTLIBICONV GTK_CFLAGS GTK_LIBS GLIB_CFLAGS GLIB_LIBS LIBART_CFLAGS LIBART_LIBS SUPPLY_BACKTRACE_TRUE SUPPLY_BACKTRACE_FALSE GCJH ZIP CLASSPATH_SEPARATOR ac_ct_GCJ ZLIBS SYS_ZLIBS ZINCS DIVIDESPEC CHECKREFSPEC EXCEPTIONSPEC IEEESPEC NATIVE_TRUE NATIVE_FALSE NEEDS_DATA_START_TRUE NEEDS_DATA_START_FALSE GCC_UNWIND_INCLUDE toolexecdir toolexecmainlibdir toolexeclibdir GCJVERSION ALLOCA PERL BACKTRACESPEC SYSDEP_SOURCES here LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS libgcj_basedir build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os target_noncanonical LN_S mkinstalldirs CC ac_ct_CC EXEEXT OBJEXT CXX ac_ct_CXX CFLAGS CXXFLAGS LDFLAGS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE AS ac_ct_AS AR ac_ct_AR RANLIB ac_ct_RANLIB MAINTAINER_MODE_TRUE MAINTAINER_MODE_FALSE MAINT LIBGCJ_CFLAGS LIBGCJ_CXXFLAGS LIBGCJ_JAVAFLAGS LIBGCJ_LD_SYMBOLIC INCLTDL LIBLTDL DIRLTDL LIBTOOL CXXCPP CPPFLAGS GCJ GCJFLAGS GCJDEPMODE am__fastdepGCJ_TRUE am__fastdepGCJ_FALSE subdirs COMPPATH TESTSUBDIR_TRUE TESTSUBDIR_FALSE ONESTEP_TRUE ONESTEP_FALSE LIBGCJDEBUG INTERPRETER LIBFFI LIBFFIINCS PLATFORM_INNER_NAT_HDRS CPP EGREP USING_WIN32_PLATFORM_TRUE USING_WIN32_PLATFORM_FALSE USING_POSIX_PLATFORM_TRUE USING_POSIX_PLATFORM_FALSE USING_ECOS_PLATFORM_TRUE USING_ECOS_PLATFORM_FALSE USING_DARWIN_CRT_TRUE USING_DARWIN_CRT_FALSE SYSTEMSPEC LIBGCJTESTSPEC ZLIBSPEC ZLIBTESTSPEC X_CFLAGS X_PRE_LIBS X_LIBS X_EXTRA_LIBS TOOLKIT XLIB_AWT_TRUE XLIB_AWT_FALSE GTK_AWT_TRUE GTK_AWT_FALSE GTK_CAIRO_TRUE GTK_CAIRO_FALSE PKG_CONFIG CAIRO_CFLAGS CAIRO_LIBS PANGOFT2_CFLAGS PANGOFT2_LIBS GCLIBS GCINCS GCDEPS GCSPEC JC1GCSPEC GCTESTSPEC USING_BOEHMGC_TRUE USING_BOEHMGC_FALSE USING_NOGC_TRUE USING_NOGC_FALSE THREADLIBS THREADINCS THREADDEPS THREADSPEC THREADLDFLAGS THREADCXXFLAGS USING_POSIX_THREADS_TRUE USING_POSIX_THREADS_FALSE USING_WIN32_THREADS_TRUE USING_WIN32_THREADS_FALSE USING_NO_THREADS_TRUE USING_NO_THREADS_FALSE HASH_SYNC_SPEC USING_GCC_TRUE USING_GCC_FALSE tool_include_dir gcc_version LIBICONV LTLIBICONV GTK_CFLAGS GTK_LIBS GLIB_CFLAGS GLIB_LIBS LIBART_CFLAGS LIBART_LIBS SUPPLY_BACKTRACE_TRUE SUPPLY_BACKTRACE_FALSE GCJH ZIP CLASSPATH_SEPARATOR ac_ct_GCJ ZLIBS SYS_ZLIBS ZINCS DIVIDESPEC CHECKREFSPEC EXCEPTIONSPEC IEEESPEC NATIVE_TRUE NATIVE_FALSE NEEDS_DATA_START_TRUE NEEDS_DATA_START_FALSE GCC_UNWIND_INCLUDE toolexecdir toolexecmainlibdir toolexeclibdir GCJVERSION ALLOCA PERL BACKTRACESPEC SYSDEP_SOURCES here LIBOBJS LTLIBOBJS'\n ac_subst_files=''\n \n # Initialize some variables set by options.\n@@ -3983,6 +3983,8 @@ libgcj_javaflags=\n LIBGCJ_CFLAGS=\"${libgcj_cflags}\"\n LIBGCJ_CXXFLAGS=\"${libgcj_cxxflags}\"\n LIBGCJ_JAVAFLAGS=\"${libgcj_javaflags}\"\n+LIBGCJ_LD_SYMBOLIC=\"${libgcj_ld_symbolic}\"\n+\n \n \n \n@@ -4741,7 +4743,7 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 4744 \"configure\"' > conftest.$ac_ext\n+  echo '#line 4746 \"configure\"' > conftest.$ac_ext\n   if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n   (eval $ac_compile) 2>&5\n   ac_status=$?\n@@ -5772,7 +5774,7 @@ if test \"${enable_sjlj_exceptions+set}\" = set; then\n   :\n else\n   cat > conftest.$ac_ext << EOF\n-#line 5775 \"configure\"\n+#line 5777 \"configure\"\n struct S { ~S(); };\n void bar();\n void foo()\n@@ -17182,6 +17184,7 @@ s,@MAINT@,$MAINT,;t t\n s,@LIBGCJ_CFLAGS@,$LIBGCJ_CFLAGS,;t t\n s,@LIBGCJ_CXXFLAGS@,$LIBGCJ_CXXFLAGS,;t t\n s,@LIBGCJ_JAVAFLAGS@,$LIBGCJ_JAVAFLAGS,;t t\n+s,@LIBGCJ_LD_SYMBOLIC@,$LIBGCJ_LD_SYMBOLIC,;t t\n s,@INCLTDL@,$INCLTDL,;t t\n s,@LIBLTDL@,$LIBLTDL,;t t\n s,@DIRLTDL@,$DIRLTDL,;t t"}, {"sha": "43156b7f68d318a095b626cf14dea3783b9b980c", "filename": "libjava/configure.ac", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.ac?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -134,9 +134,11 @@ libgcj_javaflags=\n LIBGCJ_CFLAGS=\"${libgcj_cflags}\"\n LIBGCJ_CXXFLAGS=\"${libgcj_cxxflags}\"\n LIBGCJ_JAVAFLAGS=\"${libgcj_javaflags}\"\n+LIBGCJ_LD_SYMBOLIC=\"${libgcj_ld_symbolic}\"\n AC_SUBST(LIBGCJ_CFLAGS)\n AC_SUBST(LIBGCJ_CXXFLAGS)\n AC_SUBST(LIBGCJ_JAVAFLAGS)\n+AC_SUBST(LIBGCJ_LD_SYMBOLIC)\n \n AC_CONFIG_HEADERS([include/config.h gcj/libgcj-config.h])\n "}, {"sha": "e1eaa1bab1e3ce56055083c84e3a879432b876fa", "filename": "libjava/configure.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fconfigure.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fconfigure.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fconfigure.host?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -173,6 +173,7 @@ case \"${host}\" in\n   hppa*-linux* | \\\n   sh-linux* | sh[34]*-linux*)\n   \tcan_unwind_signal=yes\n+\tlibgcj_ld_symbolic='-Wl,-Bsymbolic'\n \tif test x$slow_pthread_self = xyes \\\n \t   && test x$cross_compiling != xyes; then\n \t  cat > conftest.c <<EOF\n@@ -226,7 +227,6 @@ EOF\n   mips*-*-linux* )\n   \tsysdeps_dir=mips\n   \tcan_unwind_signal=yes\n-\tlibgcj_interpreter=yes\n \tlibgcj_flags=\"${libgcj_flags} -mxgot\"\n \tDIVIDESPEC=-fno-use-divide-subroutine\n \tcase \"${host}\" in"}, {"sha": "1a0c4e4da603988e22e36e072070c2b964872429", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // defineclass.cc - defining a class from .class format.\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -26,6 +26,7 @@ details.  */\n #include <stdio.h>\n #include <java-cpool.h>\n #include <gcj/cni.h>\n+#include <execution.h>\n \n #include <java/lang/Class.h>\n #include <java/lang/Float.h>\n@@ -38,6 +39,7 @@ details.  */\n #include <java/lang/ClassCircularityError.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n #include <java/lang/reflect/Modifier.h>\n+#include <java/security/ProtectionDomain.h>\n \n using namespace gcj;\n \n@@ -216,7 +218,8 @@ struct _Jv_ClassReader {\n       throw_class_format_error (\"erroneous type descriptor\");\n   }\n \n-  _Jv_ClassReader (jclass klass, jbyteArray data, jint offset, jint length)\n+  _Jv_ClassReader (jclass klass, jbyteArray data, jint offset, jint length,\n+\t\t   java::security::ProtectionDomain *pd)\n   {\n     if (klass == 0 || length < 0 || offset+length > data->length)\n       throw_internal_error (\"arguments to _Jv_DefineClass\");\n@@ -226,7 +229,10 @@ struct _Jv_ClassReader {\n     len    = length;\n     pos    = 0;\n     def    = klass;\n-    def_interp = (_Jv_InterpClass *) def->aux_info;\n+    def->size_in_bytes = -1;\n+    def->vtable_method_count = -1;\n+    def->engine = &_Jv_soleInterpreterEngine;\n+    def->protectionDomain = pd;\n   }\n \n   /** and here goes the parser members defined out-of-line */\n@@ -273,9 +279,10 @@ struct _Jv_ClassReader {\n };\n \n void\n-_Jv_DefineClass (jclass klass, jbyteArray data, jint offset, jint length)\n+_Jv_DefineClass (jclass klass, jbyteArray data, jint offset, jint length,\n+\t\t java::security::ProtectionDomain *pd)\n {\n-  _Jv_ClassReader reader (klass, data, offset, length);\n+  _Jv_ClassReader reader (klass, data, offset, length, pd);\n   reader.parse();\n \n   /* that's it! */\n@@ -311,8 +318,13 @@ _Jv_ClassReader::parse ()\n \n   handleClassBegin (access_flags, this_class, super_class);\n \n+  // Allocate our aux_info here, after the name is set, to fulfill our\n+  // contract with the collector interface.\n+  def->aux_info = (void *) _Jv_AllocBytes (sizeof (_Jv_InterpClass));\n+  def_interp = (_Jv_InterpClass *) def->aux_info;\n+\n   int interfaces_count = read2u (); \n-\t\n+\n   handleInterfacesBegin (interfaces_count);\n \n   for (int i = 0; i < interfaces_count; i++)\n@@ -335,12 +347,11 @@ _Jv_ClassReader::parse ()\n   if (pos != len)\n     throw_class_format_error (\"unused data before end of file\");\n \n-  // tell everyone we're done.\n-  def->state = JV_STATE_LOADED;\n+  // Tell everyone we're done.\n+  def->state = JV_STATE_READ;\n   if (gcj::verbose_class_flag)\n-    fprintf (stderr, \"[Loaded (bytecode) %s]\\n\", def->name->chars());\n+    _Jv_Linker::print_class_loaded (def);\n   def->notifyAll ();\n-\n }\n \n void _Jv_ClassReader::read_constpool ()\n@@ -517,30 +528,20 @@ void _Jv_ClassReader::read_one_method_attribute (int method_index)\n \tthrow_class_format_error (\"only one Exceptions attribute allowed per method\");\n \n       int num_exceptions = read2u ();\n-      // We use malloc here because the GC won't scan the method\n-      // objects.  FIXME this means a memory leak if we GC a class.\n-      // (Currently we never do.)\n       _Jv_Utf8Const **exceptions =\n-\t(_Jv_Utf8Const **) _Jv_Malloc ((num_exceptions + 1) * sizeof (_Jv_Utf8Const *));\n+\t(_Jv_Utf8Const **) _Jv_AllocBytes ((num_exceptions + 1)\n+\t\t\t\t\t   * sizeof (_Jv_Utf8Const *));\n \n       int out = 0;\n       _Jv_word *pool_data = def->constants.data;\n       for (int i = 0; i < num_exceptions; ++i)\n \t{\n-\t  try\n+\t  int ndx = read2u ();\n+\t  // JLS 2nd Ed. 4.7.5 requires that the tag not be 0.\n+\t  if (ndx != 0)\n \t    {\n-\t      int ndx = read2u ();\n-\t      // JLS 2nd Ed. 4.7.5 requires that the tag not be 0.\n-\t      if (ndx != 0)\n-\t\t{\n-\t\t  check_tag (ndx, JV_CONSTANT_Class);\n-\t\t  exceptions[out++] = pool_data[ndx].utf8; \n-\t\t}\n-\t    }\n-\t  catch (java::lang::Throwable *exc)\n-\t    {\n-\t      _Jv_Free (exceptions);\n-\t      throw exc;\n+\t      check_tag (ndx, JV_CONSTANT_Class);\n+\t      exceptions[out++] = pool_data[ndx].utf8; \n \t    }\n \t}\n       exceptions[out] = NULL;\n@@ -854,8 +855,7 @@ _Jv_ClassReader::prepare_pool_entry (int index, unsigned char this_tag)\n \n \n void\n-_Jv_ClassReader::handleClassBegin\n-  (int access_flags, int this_class, int super_class)\n+_Jv_ClassReader::handleClassBegin (int access_flags, int this_class, int super_class)\n {\n   using namespace java::lang::reflect;\n \n@@ -950,31 +950,33 @@ _Jv_ClassReader::handleClassBegin\n   def->notifyAll ();\n }\n \n-///// implements the checks described in sect. 5.3.5.3\n+///// Implements the checks described in sect. 5.3.5.3\n void\n _Jv_ClassReader::checkExtends (jclass sub, jclass super)\n {\n   using namespace java::lang::reflect;\n \n-  // having an interface or a final class as a superclass is no good\n+  _Jv_Linker::wait_for_state (super, JV_STATE_LOADING);\n+\n+  // Having an interface or a final class as a superclass is no good.\n   if ((super->accflags & (Modifier::INTERFACE | Modifier::FINAL)) != 0)\n     {\n       throw_incompatible_class_change_error (sub->getName ());\n     }\n \n-  // if the super class is not public, we need to check some more\n+  // If the super class is not public, we need to check some more.\n   if ((super->accflags & Modifier::PUBLIC) == 0)\n     {\n-      // With package scope, the classes must have the same\n-      // class loader.\n+      // With package scope, the classes must have the same class\n+      // loader.\n       if (   sub->loader != super->loader\n \t  || !_Jv_ClassNameSamePackage (sub->name, super->name))\n \t{\n \t  throw_incompatible_class_change_error (sub->getName ());\n \t}\n     } \n \n-  for (; super != 0; super = super->superclass)\n+  for (; super != 0; super = super->getSuperclass ())\n     {\n       if (super == sub)\n \tthrow_class_circularity_error (sub->getName ());\n@@ -1072,11 +1074,7 @@ void _Jv_ClassReader::handleField (int field_no,\n   _Jv_Field *field = &def->fields[field_no];\n   _Jv_Utf8Const *field_name = pool_data[name].utf8;\n \n-#ifndef COMPACT_FIELDS\n   field->name      = field_name;\n-#else\n-  field->nameIndex = name;\n-#endif\n \n   // Ignore flags we don't know about.  \n   field->flags = flags & Modifier::ALL_FLAGS;\n@@ -1234,7 +1232,7 @@ void _Jv_ClassReader::handleMethod\n   // ignore unknown flags\n   method->accflags = accflags & Modifier::ALL_FLAGS;\n \n-  // intialize...\n+  // Initialize...\n   method->ncode = 0;\n   method->throws = NULL;\n   \n@@ -1276,7 +1274,6 @@ void _Jv_ClassReader::handleCodeAttribute\n   _Jv_InterpMethod *method = \n     (_Jv_InterpMethod*) (_Jv_AllocBytes (size));\n \n-  method->deferred\t = NULL;\n   method->max_stack      = max_stack;\n   method->max_locals     = max_locals;\n   method->code_length    = code_length;\n@@ -1335,7 +1332,6 @@ void _Jv_ClassReader::handleMethodsEnd ()\n \t      m->self = method;\n \t      m->function = NULL;\n \t      def_interp->interpreted_methods[i] = m;\n-\t      m->deferred = NULL;\n \n \t      if ((method->accflags & Modifier::STATIC))\n \t\t{\n@@ -1626,7 +1622,7 @@ _Jv_VerifyClassName (_Jv_Utf8Const *name)\n }\n \n /* Returns true, if NAME1 and NAME2 represent classes in the same\n-   package.  */\n+   package.  Neither NAME2 nor NAME2 may name an array type.  */\n bool\n _Jv_ClassNameSamePackage (_Jv_Utf8Const *name1, _Jv_Utf8Const *name2)\n {"}, {"sha": "b40dd2a398a7d1350390a81bb36a2c34639b2832", "filename": "libjava/gcj/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgcj%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgcj%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2FMakefile.in?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -146,6 +146,7 @@ LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+LIBGCJ_LD_SYMBOLIC = @LIBGCJ_LD_SYMBOLIC@\n LIBICONV = @LIBICONV@\n LIBLTDL = @LIBLTDL@\n LIBOBJS = @LIBOBJS@"}, {"sha": "8421bc7e04644d1839ab96a50f5739c3114996be", "filename": "libjava/gcj/field.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgcj%2Ffield.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgcj%2Ffield.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Ffield.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // field.h - Header file for fieldID instances.  -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -21,21 +21,15 @@ details.  */\n \n struct _Jv_Field\n {\n-#ifndef COMPACT_FIELDS\n   struct _Jv_Utf8Const*\tname;\n-#endif\n \n   /* The type of the field, if isResolved().\n      If !isResolved():  The fields's signature as a (Utf8Const*). */\n   jclass\t\ttype;\n \n   _Jv_ushort\t\tflags;\n \n-#ifdef COMPACT_FIELDS\n-  jshort\t\tnameIndex;  /* offset in class's name table */\n-#else\n   _Jv_ushort\t\tbsize;  /* not really needed ... */\n-#endif\n \n   union {\n     jint\t\tboffset;  /* offset in bytes for instance field */\n@@ -91,13 +85,8 @@ struct _Jv_Field\n     return flags & java::lang::reflect::Modifier::ALL_FLAGS;\n   }\n \n-#ifdef COMPACT_FIELDS\n-  _Jv_Utf8Const * getNameUtf8Const (jclass cls)\n-  { return clas->fieldNames + nameIndex; }\n-#else\n   _Jv_Utf8Const * getNameUtf8Const (jclass) { return name; }\n #endif\n-#endif\n };\n \n #ifdef __cplusplus"}, {"sha": "53c26fe1a8e5c039ef1733d36df242258a489a82", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,5 +1,6 @@\n // javaprims.h - Main external header file for libgcj.  -*- c++ -*-\n \n+\n /* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n    Free Software Foundation\n \n@@ -84,6 +85,7 @@ extern \"Java\"\n       class LineNumberInputStream;\n       class LineNumberReader;\n       class MemberComparator;\n+      class MyIOException;\n       class NotActiveException;\n       class NotSerializableException;\n       class ObjectInput;\n@@ -214,6 +216,7 @@ extern \"Java\"\n       class UnsupportedClassVersionError;\n       class UnsupportedOperationException;\n       class VMClassLoader;\n+      class VMCompiler;\n       class VMSecurityManager;\n       class VMThrowable;\n       class VerifyError;"}, {"sha": "64457857a1321e52b65546a0ee884ac7834a71d9", "filename": "libjava/gij.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgij.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgij.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgij.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -35,6 +35,7 @@ help ()\n   printf (\"  -X                print help on supported -X options, then exit\\n\");\n   printf (\"  --ms=NUMBER       set initial heap size\\n\");\n   printf (\"  --mx=NUMBER       set maximum heap size\\n\");\n+  printf (\"  --verbose[:class] print information about class loading\\n\");\n   printf (\"  --showversion     print version number, then keep going\\n\");\n   printf (\"  --version         print version number, then exit\\n\");\n   printf (\"\\nOptions can be specified with `-' or `--'.\\n\");\n@@ -133,7 +134,7 @@ main (int argc, const char **argv)\n \t  // correct behavior.\n \t  _Jv_Jar_Class_Path = argv[++i];\n \t}\n-      else if (! strcmp (arg, \"-verbose:class\"))\n+      else if (! strcmp (arg, \"-verbose\") || ! strcmp (arg, \"-verbose:class\"))\n \tgcj::verbose_class_flag = true;\n       else if (arg[1] == 'X')\n \t{"}, {"sha": "90b7d33a8f4eda8524d1925b32ab75fba3105d6e", "filename": "libjava/gnu/gcj/runtime/PersistentByteMap.java", "status": "added", "additions": 484, "deletions": 0, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FPersistentByteMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FPersistentByteMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FPersistentByteMap.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,484 @@\n+/* Copyright (C) 2004  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+\n+\n+/*  A PersistentByteMap maps a byte array to another byte array.  It\n+uses a file that does not need to be serialized but may be\n+memory-mapped and read in-place.  So, even if there are many instances\n+of gcj applications running, the can share PersistentByteMaps.\n+\n+The idea is to make searches as fast as possible: opening a\n+PersistentByteMap is cheap and search time doesn't grow with the\n+number of entries in the table.  On the other hand, enumerating the\n+map is slow, but that is a relatively uncommon operation.\n+\n+The main use of this class is to provide a way to map the\n+MessageDigest of a class file to the location of a DSO that contains\n+the compiled version of that class.  It is up the the installer of an\n+application to keep the DSO up to date with the jar.  \n+\n+USAGE:\n+        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+        digest = md.digest(bytes);\n+\n+        PersistentByteMap map \n+          = new PersistentByteMap\n+            (fileName, PersistentByteMap.AccessMode.READ_ONLY);\n+\n+        byte[] soName = map.get(digest);\n+        if (soName)\n+          {\n+            String SharedLibraryName = new String(soName);\n+\n+BUGS/FEATURES:\n+        remove() isn't written yet.\n+\n+\twe can't change the capacity of a PersistentByteMap.\n+\n+        0x12345678 is a bad choice for the magic number.\n+\n+        capacity is fixed once the map has been created.\n+\n+        We use linear probing to resolve collisions.  It might be\n+        better to use a scheme that results in fewer probes to\n+        determine that an item isn't found.  However, even when the\n+        table is half full there are only on average 1.5 probes for a\n+        successful search and 2.5 probes for an unsuccessful one.\n+\n+        We don't use unique strings.  This wastes space.\n+\n+        capacity should probably be prime, but we don't check that.\n+\n+\twe don't do any locking at all: adding to a PersistentByteMap\n+\tat runtime is possible, but it requires filesystem locks\n+\taround get(), put(), and remove().\n+*/\n+\n+package gnu.gcj.runtime;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.util.*;\n+import java.security.MessageDigest;\n+\n+public class PersistentByteMap\n+{\n+  private MappedByteBuffer buf;\n+\n+  static private final int MAGIC = 0;\n+  static private final int VERSION = 4;\n+  static private final int CAPACITY = 8;\n+  static private final int TABLE_BASE = 12;\n+  static private final int STRING_BASE = 16;\n+  static private final int STRING_SIZE = 20;\n+  static private final int FILE_SIZE = 24;\n+  static private final int ELEMENTS = 28;\n+  \n+  static private final int INT_SIZE = 4;\n+\n+  static private final int TABLE_ENTRY_SIZE = 2 * INT_SIZE;\n+\n+  private int capacity;   // number of entries\n+  private int table_base;   // offset from start of file, in bytes\n+  private int string_base;  // offset from start of file, in bytes\n+  private int string_size;  // size of string table, in bytes\n+  private int file_size;    // size of file, in bytes;\n+  private int elements;     // number of elements in table\n+\n+  private long length;      // the length of the underlying file\n+\n+  static private final int UNUSED_ENTRY = -1; \n+\n+  static public final int KEYS = 0;\n+  static public final int VALUES = 1;\n+  static public final int ENTRIES = 2;\n+\n+  static final public class AccessMode\n+  {\n+    private final FileChannel.MapMode mapMode;\n+\n+    static\n+    {\n+      READ_ONLY = new AccessMode(FileChannel.MapMode.READ_ONLY);\n+      READ_WRITE = new AccessMode(FileChannel.MapMode.READ_WRITE);\n+    }\n+\n+    public static final AccessMode READ_ONLY;\n+    public static final AccessMode READ_WRITE; \n+\n+    private AccessMode(FileChannel.MapMode mode)\n+    {\n+      this.mapMode = mode;\n+    }\n+  }\n+\n+  private PersistentByteMap()\n+  {\n+  }\n+\n+  public PersistentByteMap(String filename, AccessMode mode)\n+    throws IOException \n+  {\n+    this(new File(filename), mode);\n+  }\n+\n+  public PersistentByteMap(File f, AccessMode mode)\n+    throws IOException \n+  {\n+    FileChannel fc;\n+\n+    if (mode == AccessMode.READ_ONLY)\n+      {\n+        FileInputStream fis = new FileInputStream(f);\n+        fc = fis.getChannel();\n+      }\n+    else\n+      {\n+        RandomAccessFile fos = new RandomAccessFile(f, \"rw\");\n+        fc = fos.getChannel();\n+      }\n+\n+    length = fc.size();\n+    buf = fc.map(mode.mapMode, 0, length);\n+\n+    int magic = getWord (MAGIC);\n+    if (magic != 0x12345678)\n+      throw new IllegalArgumentException(f.getName());\n+\n+    table_base = getWord (TABLE_BASE);\n+    capacity = getWord (CAPACITY);\n+    string_base = getWord (STRING_BASE);\n+    string_size = getWord (STRING_SIZE);\n+    file_size = getWord (FILE_SIZE);\n+    elements = getWord (ELEMENTS);\n+\n+    // FIXME:  Insert a bunch of sanity checks here\n+  }\n+\n+  private void init (PersistentByteMap m, File f, int capacity, int strtabSize)\n+    throws IOException \n+  {\n+    f.createNewFile();\n+    RandomAccessFile raf = new RandomAccessFile(f, \"rw\");\n+        \n+    this.capacity = capacity;\n+    table_base = 64;\n+    string_base = table_base + capacity * TABLE_ENTRY_SIZE;\n+    string_size = 0;\n+    file_size = string_base;\n+    elements = 0;\n+\n+    int totalFileSize = string_base + strtabSize;\n+\n+    // Create the file; this rounds up the size of the file to a fixed\n+    // number of 4k pages.\n+    byte[] _4k = new byte[4096];\n+    for (long i = 0; i < totalFileSize; i+= 4096)\n+      raf.write(_4k);\n+        \n+    FileChannel fc = raf.getChannel();\n+    buf = fc.map(FileChannel.MapMode.READ_WRITE, 0, raf.length());\n+\n+    for (int i = 0; i < capacity; i++)\n+      putKeyPos(UNUSED_ENTRY, i);\n+        \n+    putWord(0x12345678, MAGIC);\n+    putWord(0x01, VERSION);\n+    putWord(capacity, CAPACITY);\n+    putWord(table_base, TABLE_BASE);\n+    putWord(string_base, STRING_BASE);\n+    putWord(file_size, FILE_SIZE);\n+    putWord(elements, ELEMENTS);\n+    buf.force();\n+  }     \n+\n+  static public PersistentByteMap emptyPersistentByteMap(String filename, \n+                                                         int capacity, int strtabSize)\n+    throws IOException \n+  {\n+    File f = new File(filename);\n+    PersistentByteMap m = new PersistentByteMap();\n+    m.init(m, f, capacity, strtabSize);\n+    return m;\n+  }     \n+\n+  private int getWord (int index)\n+  {\n+    buf.position(index);\n+    byte[] wordBuf = new byte[4];\n+    buf.get(wordBuf);\n+\n+    int result = (int)wordBuf[0]&0xff;\n+    result += ((int)wordBuf[1]&0xff) << 8;\n+    result += ((int)wordBuf[2]&0xff) << 16;\n+    result += ((int)wordBuf[3]&0xff) << 24;\n+    return result;\n+  }\n+\n+  private void putWord (int word, int index)\n+  {\n+    buf.position(index);\n+    byte[] wordBuf = new byte[4];\n+    wordBuf[0] = (byte)(word);\n+    wordBuf[1] = (byte)(word >>> 8);\n+    wordBuf[2] = (byte)(word >>> 16);\n+    wordBuf[3] = (byte)(word >>> 24);\n+    buf.put(wordBuf);\n+  }\n+\n+  public Set entrySet()\n+  {\n+    return null;\n+  }\n+\n+  private int getBucket(int n)\n+  {\n+    return table_base + (2*n * INT_SIZE);\n+  }\n+\n+  private int getKeyPos(int n)\n+  {\n+    return getWord(getBucket(n));\n+  }\n+  \n+  private int getValuePos(int n)\n+  {\n+    return getWord(getBucket(n) + INT_SIZE);\n+  }\n+\n+  private void putKeyPos(int index, int n)\n+  {\n+    putWord(index, getBucket(n));\n+  }\n+\n+  private void putValuePos(int index, int n)\n+  {\n+    putWord(index, getBucket(n) + INT_SIZE);\n+  }\n+\n+  private byte[] getBytes(int n)\n+  {\n+    int len = getWord (string_base + n);\n+    int base = string_base + n + INT_SIZE;\n+    byte[] key = new byte[len];\n+    buf.position(base);\n+    buf.get(key, 0, len);\n+    return key;\n+  }\n+\n+  private int hash (byte[] b)\n+  {    \n+    // We assume that the message digest is evenly distributed, so we\n+    // only need to use a few bytes of it as the hash function.\n+    long hashIndex \n+      = ((b[0]&0xffL)\n+         + ((b[1]&0xffL)<<8) \n+         + ((b[2]&0xffL)<<16) \n+         + ((b[3]&0xffL)<<24));\n+    long result = hashIndex % (long)capacity;\n+    return (int)result;\n+  }\n+        \n+  public byte[] get(byte[] digest)\n+  {\n+    int hashIndex = hash(digest);\n+\n+    do\n+      {\n+        int k = getKeyPos(hashIndex);\n+        if (k == UNUSED_ENTRY)\n+          return null;\n+\n+        if (Arrays.equals ((byte[])digest, getBytes(k)))\n+          return getBytes(getValuePos(hashIndex));\n+                \n+        // Use linear probing to resolve hash collisions.  This may\n+        // not be theoretically as good as open addressing, but it has\n+        // good cache behviour.\n+        hashIndex++;\n+        hashIndex %= capacity;\n+      }\n+    while (true);\n+  }\n+\n+  public void put(byte[] digest, byte[] value)\n+    throws IllegalAccessException\n+  {\n+    int hashIndex = hash(digest);\n+\n+    // With the the table 2/3 full there will be on average 2 probes\n+    // for a successful search and 5 probes for an unsuccessful one.\n+    if (elements >= capacity * 2/3)\n+      throw new IllegalAccessException(\"Table Full: \" + elements);\n+\n+    do\n+      {\n+        int k = getKeyPos(hashIndex);\n+        if (k == UNUSED_ENTRY)\n+          {\n+            int newKey = addBytes(digest);\n+            putKeyPos(newKey, hashIndex);\n+            int newValue = addBytes(value);\n+            putValuePos(newValue, hashIndex);\n+            elements++;\n+            putWord(elements, ELEMENTS);            \n+            return;\n+          }\n+        else if (Arrays.equals (digest, getBytes(k)))\n+          {\n+            int newValue = addBytes((byte[])value);\n+            putValuePos(newValue, hashIndex);\n+            return;\n+          }         \n+                \n+        hashIndex++;\n+        hashIndex %= capacity;\n+      }\n+    while (true);\n+  }\n+\n+  private int addBytes (byte[] data)\n+    throws IllegalAccessException\n+  {\n+    if (data.length + INT_SIZE >= this.length)\n+      throw new IllegalAccessException(\"String table Full\");\n+\n+    int extent = string_base+string_size;\n+    int top = extent;\n+    putWord(data.length, extent);\n+    extent += INT_SIZE;\n+    buf.position(extent);\n+    buf.put(data, 0, data.length);\n+    extent += data.length;\n+    extent += INT_SIZE-1;\n+    extent &= ~(INT_SIZE-1); // align\n+    string_size = extent - string_base;\n+    file_size = extent;\n+    putWord (string_size, STRING_SIZE);\n+    putWord (file_size, FILE_SIZE);\n+        \n+    return top - string_base;\n+  }\n+\n+  public Iterator iterator(int type)\n+  {\n+    return new HashIterator(type);\n+  }\n+\n+  public int size()\n+  {\n+    return elements;\n+  }\n+\n+  public int capacity()\n+  {\n+    return capacity;\n+  }\n+\n+  private final class HashIterator implements Iterator\n+  {\n+    /** Current index in the physical hash table. */\n+\n+    private int idx;\n+    private int count;\n+    private final int type;\n+\n+    /**\n+     * Construct a new HashIterator with the supplied type.\n+     * @param type {@link #KEYS}, {@link #VALUES}, or {@link #ENTRIES}\n+     */\n+    HashIterator(int type)\n+    {\n+      this.type = type;\n+      count = elements;\n+      idx = 0;\n+    }\n+\n+    /**\n+     * Returns true if the Iterator has more elements.\n+     * @return true if there are more elements\n+     * @throws ConcurrentModificationException if the HashMap was modified\n+     */\n+    public boolean hasNext()\n+    {\n+      return count > 0;\n+    }\n+\n+    /**\n+     * Returns the next element in the Iterator's sequential view.\n+     * @return the next element\n+     * @throws ConcurrentModificationException if the HashMap was modified\n+     * @throws NoSuchElementException if there is none\n+     */\n+    public Object next()\n+    {\n+      count--;\n+      for (int i = idx; i < capacity; i++)\n+        if (getKeyPos(i) != UNUSED_ENTRY)\n+          {\n+            idx = i+1;\n+            if (type == VALUES)\n+              return getBytes(getValuePos(i));\n+            if (type == KEYS)\n+              return getBytes(getKeyPos(i));\n+            return new MapEntry(i,\n+                                getBytes(getKeyPos(i)),\n+                                getBytes(getValuePos(i)));\n+          }\n+      return null;\n+    }    \n+\n+    /**\n+     * Remove from the underlying collection the last element returned\n+     * by next (optional operation). This method can be called only\n+     * once after each call to <code>next()</code>. It does not affect\n+     * what will be returned by subsequent calls to next.\n+     *\n+     * @throws IllegalStateException if next has not yet been called\n+     *         or remove has already been called since the last call\n+     *         to next.\n+     * @throws UnsupportedOperationException if this Iterator does not\n+     *         support the remove operation.\n+     */\n+     public void remove()\n+    {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  static public final class MapEntry\n+  {\n+    private final Object key;\n+    private final Object value;\n+    private final int bucket;\n+\n+    public MapEntry(int bucket, Object newKey, Object newValue)\n+    {\n+      this.key = newKey;\n+      this.value = newValue;\n+      this.bucket = bucket;\n+    }\n+\n+    public final Object getKey()\n+    {\n+      return key;\n+    }\n+\n+    public final Object getValue()\n+    {\n+      return value;\n+    }\n+\n+    public final int getBucket()\n+    {\n+      return bucket;\n+    }\n+  }\n+}"}, {"sha": "a0bfe68b83c343b8b27c939f81251d0be3afa77d", "filename": "libjava/gnu/gcj/runtime/SharedLibHelper.java", "status": "modified", "additions": 83, "deletions": 15, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FSharedLibHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FSharedLibHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FSharedLibHelper.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2001, 2003  Free Software Foundation\n+/* Copyright (C) 2001, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -13,6 +13,12 @@\n import java.util.HashMap;\n import java.security.*;\n import gnu.gcj.Core;\n+import java.util.Set;\n+import java.util.Iterator;\n+import java.util.HashSet;\n+import java.util.HashMap;\n+import java.nio.channels.FileChannel;\n+import java.io.*;\n \n public class SharedLibHelper\n {\n@@ -36,34 +42,82 @@ public static SharedLibHelper findHelper (String libname)\n   {\n     synchronized (map)\n       {\n-\tWeakReference ref = (WeakReference) map.get(libname);\n-\tif (ref != null)\n-\t  return (SharedLibHelper) ref.get();\n+\tSet s = (Set)map.get(libname);\n+\tif (s == null)\n+\t  return null;\n+\tfor (Iterator i=s.iterator(); i.hasNext();)\n+\t  {\n+\t    WeakReference ref = (WeakReference)i.next();\n+\t    if (ref != null)\n+\t      return (SharedLibHelper) ref.get();\n+\t  }\n \treturn null;\n       }\n   }\n \n+  static void copyFile (File in, File out) throws IOException \n+  {\n+    FileChannel source = new FileInputStream(in).getChannel();\n+    FileChannel destination = new FileOutputStream(out).getChannel();\n+    source.transferTo(0, source.size(), destination);\n+    source.close();\n+    destination.close();\n+  }\n+\n   public static SharedLibHelper findHelper (ClassLoader loader, String libname,\n \t\t\t\t\t    CodeSource source)\n   {\n     synchronized (map)\n       {\n \tSharedLibHelper result;\n-\tWeakReference ref = (WeakReference) map.get(libname);\n-\tif (ref != null)\n+\tSet s = (Set)map.get(libname);\n+\tif (s == null)\n+\t  {\n+\t    s = new HashSet();\n+\t    map.put(libname, s);\n+\t  }\n+\telse\n \t  {\n-\t    result = (SharedLibHelper) ref.get();\n-\t    if (result != null)\n+\t    for (Iterator i=s.iterator(); i.hasNext();)\n \t      {\n-\t\tif (result.loader != loader)\n-\t\t  // FIXME\n-\t\t  throw new UnknownError();\n-\t\treturn result;\n+\t\tWeakReference ref = (WeakReference)i.next();\n+\t\tif (ref != null)\n+\t\t  {\n+\t\t    result = (SharedLibHelper) ref.get();\n+\t\t    if (result != null)\n+\t\t      {\t\t\t\n+\t\t\t// A match succeeds if the library is already\n+\t\t\t// loaded by LOADER or any of its ancestors.\n+\t\t\tClassLoader l = loader;\n+\t\t\tdo\n+\t\t\t  {\n+\t\t\t    if (result.loader == l)\n+\t\t\t      return result;\n+\t\t\t    l = l.getParent();\n+\t\t\t  }\n+\t\t\twhile (l != null);\n+\t\t      }\n+\t\t  }\n \t      }\n-\t  }\n \n+\t    // Oh dear.  We've already mapped this shared library, but\n+\t    // with a different class loader.  We need to copy it.\n+\t    try\n+\t      {\n+\t\tFile copy \n+\t\t  = File.createTempFile(new File(libname).getName(), \n+\t\t\t\t\t\".so\", new File (\"/tmp\"));\n+\t\tFile src = new File(libname);\n+\t\tcopyFile (src, copy);\n+\t\tlibname = copy.getPath();\n+\t      }\n+\t    catch (IOException e)\n+\t      {\n+\t\treturn null;\n+\t      }\n+\t  }\n \tresult = new SharedLibHelper(libname, loader, source, 0);\n-\tmap.put(libname, new WeakReference(result));\n+\ts.add(new WeakReference(result));\n \treturn result;\n       }\n   }\n@@ -73,7 +127,15 @@ public static SharedLibHelper findHelper (ClassLoader loader, String libname,\n   public Class findClass(String name)\n   {\n     ensureInit();\n-    return (Class) classMap.get(name);\n+    Class result = (Class) classMap.get(name);\n+    if (result != null)\n+      {\n+\t// We never want to return a class without its supers linked.\n+\t// It isn't clear from the spec, but this is what other\n+\t// implementations do in practice.\n+\tensureSupersLinked(result);\n+      }\n+    return result;\n   }\n \n   public URL findResource (String name)\n@@ -106,6 +168,12 @@ void ensureInit()\n \n   native boolean hasResource(String name);\n   native void init();\n+  native void ensureSupersLinked(Class k);\n+\n+  public String toString ()\n+  {\n+    return \"shared object \" + baseName;\n+  }\n \n   /** Called during dlopen's processing of the init section. */\n   void registerClass(String name, Class cls)"}, {"sha": "f9ef872b30a5c5e1309a1fdd842ff7a39527b7b0", "filename": "libjava/gnu/gcj/runtime/VMClassLoader.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FVMClassLoader.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -105,7 +105,8 @@ public boolean accept (File dir, String name)\n   /** This is overridden to search the internal hash table, which \n    * will only search existing linked-in classes.   This will make\n    * the default implementation of loadClass (in ClassLoader) work right.\n-   * The implementation of this method is in java/lang/natClassLoader.cc.\n+   * The implementation of this method is in\n+   * gnu/gcj/runtime/natVMClassLoader.cc.\n    */\n   protected native Class findClass(String name) \n     throws java.lang.ClassNotFoundException;"}, {"sha": "184692e10403a68af29c151fbd7be90fe77ea886", "filename": "libjava/gnu/gcj/runtime/natSharedLibLoader.cc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatSharedLibLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatSharedLibLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FnatSharedLibLoader.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // natSharedLibLoader.cc - Implementation of SharedLibHelper native methods.\n \n-/* Copyright (C) 2001, 2003  Free Software Foundation\n+/* Copyright (C) 2001, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -12,6 +12,8 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <execution.h>\n+\n #include <gnu/gcj/runtime/SharedLibHelper.h>\n #include <java/io/IOException.h>\n #include <java/lang/UnsupportedOperationException.h>\n@@ -30,9 +32,10 @@ typedef void (*CoreHookFunc) (_Jv_core_chain *);\n void\n _Jv_sharedlib_register_hook (jclass cls)\n {\n-  curHelper->registerClass(cls->getName(), cls);\n   cls->protectionDomain = curHelper->domain;\n   cls->loader = curLoader;\n+  cls->engine = &_Jv_soleCompiledEngine;\n+  curHelper->registerClass(cls->getName(), cls);\n }\n \n static void\n@@ -122,3 +125,9 @@ gnu::gcj::runtime::SharedLibHelper::finalize()\n   dlclose (handler);\n #endif\n }\n+\n+void\n+gnu::gcj::runtime::SharedLibHelper::ensureSupersLinked(jclass k)\n+{\n+  _Jv_Linker::wait_for_state (k, JV_STATE_LOADING);\n+}"}, {"sha": "a478f93429756779e29193823b4f3d120fc7cefe", "filename": "libjava/gnu/gcj/tools/gcj_dbtool/Main.java", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Ftools%2Fgcj_dbtool%2FMain.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fgnu%2Fgcj%2Ftools%2Fgcj_dbtool%2FMain.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Ftools%2Fgcj_dbtool%2FMain.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,272 @@\n+/* Copyright (C) 2004  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.tools.gcj_dbtool;\n+\n+\n+import gnu.gcj.runtime.PersistentByteMap;\n+import java.io.*;\n+import java.util.*;\n+import java.util.jar.*;\n+import java.security.MessageDigest;\n+import java.math.BigInteger;\n+\n+public class Main\n+{\n+  public static void main (String[] s)\n+  {\n+    insist (s.length >= 1);\n+    if (s[0].equals(\"-v\"))\n+      {\n+\tinsist (s.length == 1);\n+\tSystem.out.println(\"jv-dbtool (\"\n+\t\t\t   + System.getProperty(\"java.vm.name\")\n+\t\t\t   + \") \"\n+\t\t\t   + System.getProperty(\"java.vm.version\"));\n+\tSystem.out.println();\n+\tSystem.out.println(\"Copyright 2004 Free Software Foundation, Inc.\");\n+\tSystem.out.println(\"This is free software; see the source for copying conditions.  There is NO\");\n+\tSystem.out.println(\"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\");\n+\treturn;\n+      }\n+\n+    if (s[0].equals(\"-n\"))\n+      {\n+\tinsist (s.length >= 2 && s.length <= 3);\n+\n+\tint capacity = 32749;\n+\n+\tif (s.length == 3)\n+\t  {\n+\t    // The user has explicitly provided a size for the table.\n+\t    // We're going to make that size prime.  This isn't\n+\t    // strictly necessary but it can't hurt.\n+\n+\t    BigInteger size = new BigInteger(s[2], 10);\n+\t    BigInteger two = BigInteger.ONE.add(BigInteger.ONE);\n+\n+\t    if (size.getLowestSetBit() != 0) // A hard way to say isEven()\n+\t      size = size.add(BigInteger.ONE);\n+\n+\t    while (! size.isProbablePrime(10))\n+\t      size = size.add(two);\n+\n+\t    capacity = size.intValue();\n+\n+\t    if (capacity <= 2)\n+\t      {\n+\t\tusage();\n+\t\tSystem.exit(1);\n+\t      }\n+\t  }\n+\t    \n+\ttry\n+\t  {\n+\t    PersistentByteMap b \n+\t      = PersistentByteMap.emptyPersistentByteMap (s[1], capacity, capacity*64);\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    System.err.println (\"error: could not create \" \n+\t\t\t\t+ s[1] + \": \" + e.toString());\n+\t    System.exit(2);\n+\t  }\n+\treturn;\n+      }\n+\n+    if (s[0].equals(\"-a\"))\n+      {\n+\ttry\n+\t  {\n+\t    insist (s.length == 4);\n+\t    File jar = new File(s[2]);\n+\t    PersistentByteMap b \n+\t      = new PersistentByteMap(new File(s[1]), \n+\t\t\t\t      PersistentByteMap.AccessMode.READ_WRITE);\n+\t    File soFile = new File(s[3]);\n+\t    if (! soFile.isFile())\n+\t      throw new IllegalArgumentException(s[3] + \" is not a file\");\n+\t    \n+\t    addJar(jar, b, soFile);\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    System.err.println (\"error: could not update \" + s[1] \n+\t\t\t\t+ \": \" + e.toString());\n+\t    System.exit(2);\n+\t  }\n+\treturn;\n+      }\n+\n+    if (s[0].equals(\"-t\"))\n+      {\n+\ttry\n+\t  {\n+\t    insist (s.length == 2);\n+\t    PersistentByteMap b \n+\t      = new PersistentByteMap(new File(s[1]),\n+\t\t\t\t      PersistentByteMap.AccessMode.READ_ONLY);\n+\t    Iterator iterator = b.iterator(PersistentByteMap.ENTRIES);\n+\t\n+\t    while (iterator.hasNext())\n+\t      {\n+\t\tPersistentByteMap.MapEntry entry \n+\t\t  = (PersistentByteMap.MapEntry)iterator.next();\n+\t\tbyte[] key = (byte[])entry.getKey();\n+\t\tbyte[] value = (byte[])b.get(key);\n+\t\tif (! Arrays.equals (value, (byte[])entry.getValue()))\n+\t\t  {\n+\t\t    String err \n+\t\t      = (\"Key \" + bytesToString(key) + \" at bucket \" \n+\t\t\t + entry.getBucket());\n+\t\t  \n+\t\t    throw new RuntimeException(err);\n+\t\t  }\n+\t      }\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    e.printStackTrace();\n+\t    System.exit(3);\n+\t  }\n+\treturn;\n+      }\n+\t \n+    if (s[0].equals(\"-l\"))\n+      {\n+\tinsist (s.length == 2);\n+\ttry\n+\t  {\n+\t    PersistentByteMap b \n+\t      = new PersistentByteMap(new File(s[1]),\n+\t\t\t\t      PersistentByteMap.AccessMode.READ_ONLY);\n+\n+\t    System.out.println (\"Capacity: \" + b.capacity());\n+\t    System.out.println (\"Size: \" + b.size());\n+\t    System.out.println ();\n+\n+\t    System.out.println (\"Elements: \");\n+\t    Iterator iterator = b.iterator(PersistentByteMap.ENTRIES);\n+    \n+\t    while (iterator.hasNext())\n+\t      {\n+\t\tPersistentByteMap.MapEntry entry \n+\t\t  = (PersistentByteMap.MapEntry)iterator.next();\n+\t\tbyte[] digest = (byte[])entry.getKey();\n+\t\tSystem.out.print (\"[\" + entry.getBucket() + \"] \" \n+\t\t\t\t  + bytesToString(digest)\n+\t\t\t\t  + \" -> \");\n+\t\tSystem.out.println (new String((byte[])entry.getValue()));\n+\t      }\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    System.err.println (\"error: could not list \" \n+\t\t\t\t+ s[1] + \": \" + e.toString());\n+\t    System.exit(2);\n+\t  }\n+\treturn;\n+      }\n+\n+    if (s[0].equals(\"-d\"))\n+      {\n+\tinsist (s.length == 2);\n+\ttry\n+\t  {    \n+\t    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+\t    PersistentByteMap b \n+\t      = new PersistentByteMap(new File(s[1]), \n+\t\t\t\t      PersistentByteMap.AccessMode.READ_WRITE);\n+\t    int N = b.capacity();\n+\t    byte[] bytes = new byte[1];\n+\t    byte digest[] = md.digest(bytes);\n+\t    for (int i = 0; i < N; i++)\n+\t      {\n+\t\tdigest = md.digest(digest);\n+\t\tb.put(digest, digest);\n+\t      }\n+\t  }\n+\tcatch (Exception e)\n+\t  {\n+\t    e.printStackTrace();\n+\t    System.exit(3);\n+\t  }\t    \n+\treturn;\n+      }\n+    \n+    usage();\n+    System.exit(1);\t    \n+  }\n+\n+  private static void insist(boolean ok)\n+  {\n+    if (! ok)\n+      {\n+\tusage();\n+\tSystem.exit(1);\n+      }\t    \n+  }\n+\n+  private static void usage()\n+  {\n+    System.err.println\n+      (\"jv-dbtool: Manipulate gcj map database files\\n\"\n+       + \"\\n\"\n+       + \"  Usage: \\n\"\n+       + \"    jv-dbtool -n file.gcjdb [size]     - Create a new gcj map database\\n\"\n+       + \"    jv-dbtool -a file.gcjdb file.jar file.so\\n\"\n+       + \"            - Add the contents of file.jar to the database\\n\"\n+       + \"    jv-dbtool -t file.gcjdb            - Test a gcj map database\\n\"\n+       + \"    jv-dbtool -l file.gcjdb            - List a gcj map database\\n\");\n+  }\n+      \n+\n+  private static void addJar(File f, PersistentByteMap b, File soFile)\n+   throws Exception\n+  {\n+    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n+\n+    JarFile jar = new JarFile (f);\n+    Enumeration entries = jar.entries();\n+\n+    while (entries.hasMoreElements())\n+      {\n+\tJarEntry classfile = (JarEntry)entries.nextElement();\n+\tif (classfile.getName().endsWith(\".class\"))\n+\t  {\n+\t    InputStream str = jar.getInputStream(classfile);\n+\t    long length = classfile.getSize();\n+\t    if (length == -1)\n+\t      throw new EOFException();\n+\n+\t    byte[] data = new byte[length];\n+\t    int pos = 0;\n+\t    while (length - pos > 0)\n+\t      {\n+\t\tint len = str.read(data, pos, (int)(length - pos));\n+\t\tif (len == -1)\n+\t\t  throw new EOFException(\"Not enough data reading from: \"\n+\t\t\t\t\t + classfile.getName());\n+\t\tpos += len;\n+\t      }\n+\t    b.put(md.digest(data), \n+\t\t  soFile.getCanonicalPath().getBytes());\n+\t  }\n+      }\t      \n+  }    \n+\n+  static String bytesToString(byte[] b)\n+  {\n+    StringBuffer hexBytes = new StringBuffer();\n+    int length = b.length;\n+    for (int i = 0; i < length; ++i)\n+      hexBytes.append(Integer.toHexString(b[i] & 0xff));\n+    return hexBytes.toString();\n+  }\n+}\n+    "}, {"sha": "82cef6f29a2788dbb91b1b81a5046411ed6aca01", "filename": "libjava/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2FMakefile.in?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -145,6 +145,7 @@ LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+LIBGCJ_LD_SYMBOLIC = @LIBGCJ_LD_SYMBOLIC@\n LIBICONV = @LIBICONV@\n LIBLTDL = @LIBLTDL@\n LIBOBJS = @LIBOBJS@"}, {"sha": "b8f47468fc75d872b4f172721d7508994a757e93", "filename": "libjava/include/execution.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fexecution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fexecution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fexecution.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,146 @@\n+// execution.h - Execution engines. -*- c++ -*-\n+\n+/* Copyright (C) 2004  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JAVA_EXECUTION_H__\n+#define __JAVA_EXECUTION_H__\n+\n+// This represents one execution engine.  Note that we use function\n+// pointers and not virtual methods to avoid calls to\n+// __cxa_call_unexpected and the like.\n+struct _Jv_ExecutionEngine\n+{\n+ public:\n+\n+  void (*unregister) (jclass);\n+  // FIXME: probably should handle this elsewhere, see how\n+  // interpreter does it.\n+  bool (*need_resolve_string_fields) ();\n+  void (*verify) (jclass);\n+  void (*allocate_static_fields) (jclass, int);\n+  void (*create_ncode) (jclass);\n+  _Jv_ResolvedMethod *(*resolve_method) (_Jv_Method *, jclass,\n+\t\t\t\t\t jboolean, jint);\n+  void (*post_miranda_hook) (jclass);\n+};\n+\n+// This handles all gcj-compiled code, including BC ABI.\n+struct _Jv_CompiledEngine : public _Jv_ExecutionEngine\n+{\n+ public:\n+\n+  static void do_unregister (jclass)\n+  {\n+  }\n+\n+  static bool do_need_resolve_string_fields ()\n+  {\n+    return true;\n+  }\n+\n+  static void do_verify (jclass klass)\n+  {\n+    _Jv_Linker::verify_type_assertions (klass);\n+  }\n+\n+  static _Jv_ResolvedMethod *do_resolve_method (_Jv_Method *, jclass,\n+\t\t\t\t\t\tjboolean, jint)\n+  {\n+    return NULL;\n+  }\n+\n+  static void do_allocate_static_fields (jclass, int)\n+  {\n+    // Compiled classes don't need this.\n+  }\n+\n+  static void do_create_ncode (jclass)\n+  {\n+    // Not needed.\n+  }\n+\n+  static void do_post_miranda_hook (jclass)\n+  {\n+    // Not needed.\n+  }\n+\n+  _Jv_CompiledEngine ()\n+  {\n+    unregister = do_unregister;\n+    need_resolve_string_fields = do_need_resolve_string_fields;\n+    verify = do_verify;\n+    allocate_static_fields = do_allocate_static_fields;\n+    create_ncode = do_create_ncode;\n+    resolve_method = do_resolve_method;\n+    post_miranda_hook = do_post_miranda_hook;\n+  }\n+\n+  // These operators make it so we don't have to link in libstdc++.\n+  void *operator new (size_t bytes)\n+  {\n+    return _Jv_Malloc(bytes);\n+  }\n+\n+  void operator delete (void *mem)\n+  {\n+    _Jv_Free(mem);\n+  }\n+};\n+\n+// This handles interpreted code.\n+class _Jv_InterpreterEngine : public _Jv_ExecutionEngine\n+{\n+ public:\n+\n+  static void do_verify (jclass);\n+  static void do_allocate_static_fields (jclass, int);\n+  static void do_create_ncode (jclass);\n+  static _Jv_ResolvedMethod *do_resolve_method (_Jv_Method *, jclass,\n+\t\t\t\t\t\tjboolean, jint);\n+\n+  static bool do_need_resolve_string_fields ()\n+  {\n+    return false;\n+  }\n+\n+  static void do_unregister(jclass klass)\n+  {\n+    _Jv_UnregisterClass(klass);\n+  }\n+\n+  static void do_post_miranda_hook (jclass);\n+\n+  _Jv_InterpreterEngine ()\n+  {\n+    unregister = do_unregister;\n+    need_resolve_string_fields = do_need_resolve_string_fields;\n+    verify = do_verify;\n+    allocate_static_fields = do_allocate_static_fields;\n+    create_ncode = do_create_ncode;\n+    resolve_method = do_resolve_method;\n+    post_miranda_hook = do_post_miranda_hook;\n+  }\n+\n+  // These operators make it so we don't have to link in libstdc++.\n+  void *operator new (size_t bytes)\n+  {\n+    return _Jv_Malloc(bytes);\n+  }\n+\n+  void operator delete (void *mem)\n+  {\n+    _Jv_Free(mem);\n+  }\n+};\n+\n+\n+extern _Jv_InterpreterEngine _Jv_soleInterpreterEngine;\n+extern _Jv_CompiledEngine _Jv_soleCompiledEngine;\n+\n+#endif // __JAVA_EXECUTION_H__"}, {"sha": "c8e041ae3876ed9d8c8fa783c16e36de352ba128", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 11, "deletions": 39, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // java-interp.h - Header file for the bytecode interpreter.  -*- c++ -*-\n \n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -36,7 +36,8 @@ _Jv_IsInterpretedClass (jclass c)\n struct _Jv_ResolvedMethod;\n \n void _Jv_InitInterpreter ();\n-void _Jv_DefineClass (jclass, jbyteArray, jint, jint);\n+void _Jv_DefineClass (jclass, jbyteArray, jint, jint,\n+\t\t      java::security::ProtectionDomain *);\n \n void _Jv_InitField (jobject, jclass, int);\n void * _Jv_AllocMethodInvocation (jsize size);\n@@ -88,11 +89,7 @@ class _Jv_MethodBase\n   // Size of raw arguments.\n   _Jv_ushort args_raw_size;\n \n-  // Chain of addresses to fill in.  See _Jv_Defer_Resolution.\n-  void *deferred;\n-\n-  friend void _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n-  friend void _Jv_PrepareClass(jclass);\n+  friend class _Jv_InterpreterEngine;\n \n public:\n   _Jv_Method *get_method ()\n@@ -150,10 +147,9 @@ class _Jv_InterpMethod : public _Jv_MethodBase\n   friend class _Jv_BytecodeVerifier;\n   friend class gnu::gcj::runtime::NameFinder;\n   friend class gnu::gcj::runtime::StackTrace;\n+  friend class _Jv_InterpreterEngine;\n   \n \n-  friend void _Jv_PrepareClass(jclass);\n-\n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;\n #endif\n@@ -166,43 +162,15 @@ class _Jv_InterpClass\n \n   friend class _Jv_ClassReader;\n   friend class _Jv_InterpMethod;\n-  friend void  _Jv_PrepareClass(jclass);\n-  friend void  _Jv_PrepareMissingMethods (jclass base2, jclass iface_class);\n+  friend class _Jv_InterpreterEngine;\n   friend void  _Jv_InitField (jobject, jclass, int);\n #ifdef JV_MARKOBJ_DECL\n   friend JV_MARKOBJ_DECL;\n #endif\n \n   friend _Jv_MethodBase ** _Jv_GetFirstMethod (_Jv_InterpClass *klass);\n-  friend void _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n };\n \n-// We have an interpreted class CL and we're trying to find the\n-// address of the ncode of a method METH.  That interpreted class\n-// hasn't yet been prepared, so we defer fixups until they are ready.\n-// To do this, we create a chain of fixups that will be resolved by\n-// _Jv_PrepareClass.\n-extern inline void \n-_Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **address)\n-{\n-  int i;\n-  jclass self = (jclass) cl;\n-  _Jv_InterpClass *interp_cl = (_Jv_InterpClass*) self->aux_info;\n-\n-  for (i = 0; i < self->method_count; i++)\n-    {\n-      _Jv_Method *m = &self->methods[i];\n-      if (m == meth)\n-\t{\n-\t  _Jv_MethodBase *imeth = interp_cl->interpreted_methods[i];\n-\t  *address = imeth->deferred;\n-\t  imeth->deferred = address;\n-\t  return;\n-\t}\n-    }\n-  return;\n-}    \n-\n extern inline _Jv_MethodBase **\n _Jv_GetFirstMethod (_Jv_InterpClass *klass)\n {\n@@ -240,7 +208,11 @@ class _Jv_JNIMethod : public _Jv_MethodBase\n   void *ncode ();\n \n   friend class _Jv_ClassReader;\n-  friend void _Jv_PrepareClass(jclass);\n+  friend class _Jv_InterpreterEngine;\n+\n+#ifdef JV_MARKOBJ_DECL\n+  friend JV_MARKOBJ_DECL;\n+#endif\n \n public:\n   // FIXME: this is ugly."}, {"sha": "6c3103ce05682d0eed6f003dadfed5bb18f58288", "filename": "libjava/include/java-stack.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fjava-stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fjava-stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-stack.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,84 @@\n+// java-stack.h - Definitions for unwinding & inspecting the call stack.\n+\n+/* Copyright (C) 2003  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#ifndef __JV_STACKTRACE_H__\n+#define __JV_STACKTRACE_H__\n+\n+#include <unwind.h>\n+\n+#include <gcj/cni.h>\n+#include <gcj/javaprims.h>\n+\n+#include <java-interp.h>\n+\n+#include <java/lang/Class.h>\n+#include <java/lang/StackTraceElement.h>\n+#include <java/lang/Throwable.h>\n+\n+#include <gnu/gcj/runtime/NameFinder.h>\n+\n+using namespace gnu::gcj::runtime;\n+\n+enum _Jv_FrameType\n+{\n+  frame_native,\n+  frame_interpreter\n+};\n+\n+#ifdef INTERPRETER\n+struct _Jv_InterpFrameInfo\n+{\n+  _Jv_InterpMethod *meth;\n+  pc_t pc;\n+};\n+#endif\n+\n+union _Jv_FrameInfo\n+{\n+};\n+\n+struct _Jv_StackFrame\n+{\n+  _Jv_FrameType type;   /* Native or interpreted.  */\n+  union {\n+#ifdef INTERPRETER\n+    _Jv_InterpFrameInfo interp;\n+#endif\n+    void *ip;  \n+  };\n+//  _Jv_FrameInfo info;   /* Frame-type specific data.  */\n+  jclass klass;\n+  _Jv_Method *meth;\n+};\n+\n+class _Jv_StackTrace\n+{\n+private:\n+  int length;\n+  _Jv_StackFrame frames[];\n+\n+  static void UpdateNCodeMap ();\n+  static jclass ClassForIP (void *ip, void **ncode);\n+  static void FillInFrameInfo (_Jv_StackFrame *frame);\n+  static void getLineNumberForFrame(_Jv_StackFrame *frame, NameFinder *finder, \n+\t\t\t     jstring *sourceFileName, jint *lineNum);\n+  \n+  static _Unwind_Reason_Code UnwindTraceFn (struct _Unwind_Context *context, \n+    void *state_ptr);\n+\n+public:\n+  static _Jv_StackTrace *GetStackTrace (void);\n+  static JArray< ::java::lang::StackTraceElement *>*\n+    GetStackTraceElements (_Jv_StackTrace *trace, \n+    java::lang::Throwable *throwable);\n+  static jclass GetCallingClass (void);\n+};\n+\n+#endif /* __JV_STACKTRACE_H__ */"}, {"sha": "a3d06e7b09fec3c73c27860d4ace8ad7308d571f", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // jvm.h - Header file for private implementation information. -*- c++ -*-\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -231,9 +231,6 @@ inline _Jv_TempUTFString::~_Jv_TempUTFString ()\n   char utfstr##_buf[utfstr##_len <= 256 ? utfstr##_len : 0]; \\\n   _Jv_TempUTFString utfstr(utfstr##thejstr, sizeof(utfstr##_buf)==0 ? 0 : utfstr##_buf)\n \n-// FIXME: remove this define.\n-#define StringClass java::lang::String::class$\n-\n namespace gcj\n {\n   /* Some constants used during lookup of special class methods.  */\n@@ -249,6 +246,43 @@ namespace gcj\n   extern bool verbose_class_flag;\n }\n \n+// This class handles all aspects of class preparation and linking.\n+class _Jv_Linker\n+{\n+private:\n+  static void prepare_constant_time_tables(jclass);\n+  static jshort get_interfaces(jclass, _Jv_ifaces *);\n+  static void link_symbol_table(jclass);\n+  static void link_exception_table(jclass);\n+  static void layout_interface_methods(jclass);\n+  static void layout_vtable_methods(jclass);\n+  static void set_vtable_entries(jclass, _Jv_VTable *);\n+  static void make_vtable(jclass);\n+  static void ensure_fields_laid_out(jclass);\n+  static void ensure_class_linked(jclass);\n+  static void ensure_supers_installed(jclass);\n+  static void add_miranda_methods(jclass, jclass);\n+  static void ensure_method_table_complete(jclass);\n+  static void verify_class(jclass);\n+  static jshort find_iindex(jclass *, jshort *, jshort);\n+  static jshort indexof(void *, void **, jshort);\n+  static int get_alignment_from_class(jclass);\n+  static void generate_itable(jclass, _Jv_ifaces *, jshort *);\n+  static jshort append_partial_itable(jclass, jclass, void **, jshort);\n+  static _Jv_Method *search_method_in_class (jclass, jclass,\n+\t\t\t\t\t     _Jv_Utf8Const *,\n+\t\t\t\t\t     _Jv_Utf8Const *);\n+\n+public:\n+\n+  static void print_class_loaded (jclass);\n+  static void resolve_class_ref (jclass, jclass *);\n+  static void wait_for_state(jclass, int);\n+  static _Jv_word resolve_pool_entry (jclass, int);\n+  static void resolve_field (_Jv_Field *, java::lang::ClassLoader *);\n+  static void verify_type_assertions (jclass);\n+};\n+\n /* Type of pointer used as finalizer.  */\n typedef void _Jv_FinalizerFunc (jobject);\n \n@@ -416,7 +450,6 @@ extern \"C\" void _Jv_RegisterClasses_Counted (const jclass *classes,\n \t\t\t\t\t     size_t count);\n extern \"C\" void _Jv_RegisterResource (void *vptr);\n extern void _Jv_UnregisterClass (_Jv_Utf8Const*, java::lang::ClassLoader*);\n-extern void _Jv_ResolveField (_Jv_Field *, java::lang::ClassLoader*);\n \n extern jclass _Jv_FindClass (_Jv_Utf8Const *name,\n \t\t\t     java::lang::ClassLoader *loader);"}, {"sha": "91d4b194774e41719f137cf7db60260dcd58181f", "filename": "libjava/interpret.cc", "status": "modified", "additions": 587, "deletions": 22, "changes": 609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -11,6 +11,7 @@ details.  */\n /* Author: Kresten Krab Thorup <krab@gnu.org>  */\n \n #include <config.h>\n+#include <platform.h>\n \n // Define this to get the direct-threaded interpreter.  If undefined,\n // we revert to a basic bytecode interpreter.  The former is faster\n@@ -38,9 +39,15 @@ details.  */\n #include <java/lang/Thread.h>\n #include <java-insns.h>\n #include <java-signal.h>\n+#include <java/lang/ClassFormatError.h>\n+#include <execution.h>\n+#include <java/lang/reflect/Modifier.h>\n \n #ifdef INTERPRETER\n \n+// Execution engine for interpreted code.\n+_Jv_InterpreterEngine _Jv_soleInterpreterEngine;\n+\n #include <stdlib.h>\n \n using namespace gcj;\n@@ -54,6 +61,11 @@ static void throw_null_pointer_exception ()\n   __attribute__ ((__noreturn__));\n #endif\n \n+static void throw_class_format_error (jstring msg)\n+\t__attribute__ ((__noreturn__));\n+static void throw_class_format_error (char *msg)\n+\t__attribute__ ((__noreturn__));\n+\n #ifdef DIRECT_THREADED\n // Lock to ensure that methods are not compiled concurrently.\n // We could use a finer-grained lock here, however it is not safe to use\n@@ -765,8 +777,9 @@ _Jv_InterpMethod::compile (const void * const *insn_targets)\n       exc[i].start_pc.p = &insns[pc_mapping[exc[i].start_pc.i]];\n       exc[i].end_pc.p = &insns[pc_mapping[exc[i].end_pc.i]];\n       exc[i].handler_pc.p = &insns[pc_mapping[exc[i].handler_pc.i]];\n-      jclass handler = (_Jv_ResolvePoolEntry (defining_class,\n-\t\t\t\t\t      exc[i].handler_type.i)).clazz;\n+      jclass handler\n+\t= (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t     exc[i].handler_type.i)).clazz;\n       exc[i].handler_type.p = handler;\n     }\n \n@@ -1113,13 +1126,14 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\t/* _Jv_ResolvePoolEntry returns immediately if the value already\n-\t * is resolved.  If we want to clutter up the code here to gain\n-\t * a little performance, then we can check the corresponding bit\n-\t * JV_CONSTANT_ResolvedFlag in the tag directly.  For now, I\n-\t * don't think it is worth it.  */\n+\t/* _Jv_Linker::resolve_pool_entry returns immediately if the\n+\t * value already is resolved.  If we want to clutter up the\n+\t * code here to gain a little performance, then we can check\n+\t * the corresponding bit JV_CONSTANT_ResolvedFlag in the tag\n+\t * directly.  For now, I don't think it is worth it.  */\n \n-\trmeth = (_Jv_ResolvePoolEntry (defining_class, index)).rmethod;\n+\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n \t// We don't use NULLCHECK here because we can't rely on that\n@@ -2409,7 +2423,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_getstatic:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tif ((field->flags & Modifier::STATIC) == 0)\n@@ -2496,7 +2510,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_getfield:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tif ((field->flags & Modifier::STATIC) != 0)\n@@ -2612,7 +2626,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_putstatic:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tjclass type = field->type;\n@@ -2699,7 +2713,7 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_putfield:\n       {\n \tjint fieldref_index = GET2U ();\n-\t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n+\t_Jv_Linker::resolve_pool_entry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n \tjclass type = field->type;\n@@ -2825,7 +2839,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\trmeth = (_Jv_ResolvePoolEntry (defining_class, index)).rmethod;\n+\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n \n@@ -2863,7 +2878,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\trmeth = (_Jv_ResolvePoolEntry (defining_class, index)).rmethod;\n+\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n \n@@ -2892,7 +2908,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tint index = GET2U ();\n \n-\trmeth = (_Jv_ResolvePoolEntry (defining_class, index)).rmethod;\n+\trmeth = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t   index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n \n@@ -2935,7 +2952,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_new:\n       {\n \tint index = GET2U ();\n-\tjclass klass = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n+\tjclass klass = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t\t  index)).clazz;\n \tjobject res = _Jv_AllocObject (klass);\n \tPUSHA (res);\n \n@@ -2968,7 +2986,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n     insn_anewarray:\n       {\n \tint index = GET2U ();\n-\tjclass klass = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n+\tjclass klass = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t\t  index)).clazz;\n \tint size  = POPI();\n \tjobject result = _Jv_NewObjectArray (size, klass, 0);\n \tPUSHA (result);\n@@ -3010,7 +3029,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tjobject value = POPA();\n \tjint index = GET2U ();\n-\tjclass to = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n+\tjclass to = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t       index)).clazz;\n \n \tif (value != NULL && ! to->isInstance (value))\n \t  throw new java::lang::ClassCastException (to->getName());\n@@ -3040,7 +3060,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n       {\n \tjobject value = POPA();\n \tjint index = GET2U ();\n-\tjclass to = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n+\tjclass to = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t       index)).clazz;\n \tPUSHI (to->isInstance (value));\n \n #ifdef DIRECT_THREADED\n@@ -3102,7 +3123,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n \tint dim        = GET1U ();\n \n \tjclass type    \n-\t  = (_Jv_ResolvePoolEntry (defining_class, kind_index)).clazz;\n+\t  = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t       kind_index)).clazz;\n \tjint *sizes    = (jint*) __builtin_alloca (sizeof (jint)*dim);\n \n \tfor (int i = dim - 1; i >= 0; i--)\n@@ -3203,8 +3225,8 @@ _Jv_InterpMethod::run (void *retp, ffi_raw *args)\n #else\n \t      jclass handler = NULL;\n \t      if (exc[i].handler_type.i != 0)\n-\t\thandler = (_Jv_ResolvePoolEntry (defining_class,\n-\t\t\t\t\t\t exc[i].handler_type.i)).clazz;\n+\t\thandler = (_Jv_Linker::resolve_pool_entry (defining_class,\n+\t\t\t\t\t\t\t     exc[i].handler_type.i)).clazz;\n #endif /* DIRECT_THREADED */\n \n \t      if (handler == NULL || handler->isAssignableFrom (exc_class))\n@@ -3250,4 +3272,547 @@ throw_null_pointer_exception ()\n }\n #endif\n \n+/** Do static initialization for fields with a constant initializer */\n+void\n+_Jv_InitField (jobject obj, jclass klass, int index)\n+{\n+  using namespace java::lang::reflect;\n+\n+  if (obj != 0 && klass == 0)\n+    klass = obj->getClass ();\n+\n+  if (!_Jv_IsInterpretedClass (klass))\n+    return;\n+\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass*)klass->aux_info;\n+\n+  _Jv_Field * field = (&klass->fields[0]) + index;\n+\n+  if (index > klass->field_count)\n+    throw_internal_error (\"field out of range\");\n+\n+  int init = iclass->field_initializers[index];\n+  if (init == 0)\n+    return;\n+\n+  _Jv_Constants *pool = &klass->constants;\n+  int tag = pool->tags[init];\n+\n+  if (! field->isResolved ())\n+    throw_internal_error (\"initializing unresolved field\");\n+\n+  if (obj==0 && ((field->flags & Modifier::STATIC) == 0))\n+    throw_internal_error (\"initializing non-static field with no object\");\n+\n+  void *addr = 0;\n+\n+  if ((field->flags & Modifier::STATIC) != 0)\n+    addr = (void*) field->u.addr;\n+  else\n+    addr = (void*) (((char*)obj) + field->u.boffset);\n+\n+  switch (tag)\n+    {\n+    case JV_CONSTANT_String:\n+      {\n+\tjstring str;\n+\tstr = _Jv_NewStringUtf8Const (pool->data[init].utf8);\n+\tpool->data[init].string = str;\n+\tpool->tags[init] = JV_CONSTANT_ResolvedString;\n+      }\n+      /* fall through */\n+\n+    case JV_CONSTANT_ResolvedString:\n+      if (! (field->type == &java::lang::String::class$\n+ \t     || field->type == &java::lang::Class::class$))\n+\tthrow_class_format_error (\"string initialiser to non-string field\");\n+\n+      *(jstring*)addr = pool->data[init].string;\n+      break;\n+\n+    case JV_CONSTANT_Integer:\n+      {\n+\tint value = pool->data[init].i;\n+\n+\tif (field->type == JvPrimClass (boolean))\n+\t  *(jboolean*)addr = (jboolean)value;\n+\t\n+\telse if (field->type == JvPrimClass (byte))\n+\t  *(jbyte*)addr = (jbyte)value;\n+\t\n+\telse if (field->type == JvPrimClass (char))\n+\t  *(jchar*)addr = (jchar)value;\n+\n+\telse if (field->type == JvPrimClass (short))\n+\t  *(jshort*)addr = (jshort)value;\n+\t\n+\telse if (field->type == JvPrimClass (int))\n+\t  *(jint*)addr = (jint)value;\n+\n+\telse\n+\t  throw_class_format_error (\"erroneous field initializer\");\n+      }  \n+      break;\n+\n+    case JV_CONSTANT_Long:\n+      if (field->type != JvPrimClass (long))\n+\tthrow_class_format_error (\"erroneous field initializer\");\n+\n+      *(jlong*)addr = _Jv_loadLong (&pool->data[init]);\n+      break;\n+\n+    case JV_CONSTANT_Float:\n+      if (field->type != JvPrimClass (float))\n+\tthrow_class_format_error (\"erroneous field initializer\");\n+\n+      *(jfloat*)addr = pool->data[init].f;\n+      break;\n+\n+    case JV_CONSTANT_Double:\n+      if (field->type != JvPrimClass (double))\n+\tthrow_class_format_error (\"erroneous field initializer\");\n+\n+      *(jdouble*)addr = _Jv_loadDouble (&pool->data[init]);\n+      break;\n+\n+    default:\n+      throw_class_format_error (\"erroneous field initializer\");\n+    }\n+}\n+\n+inline static unsigned char*\n+skip_one_type (unsigned char* ptr)\n+{\n+  int ch = *ptr++;\n+\n+  while (ch == '[')\n+    { \n+      ch = *ptr++;\n+    }\n+  \n+  if (ch == 'L')\n+    {\n+      do { ch = *ptr++; } while (ch != ';');\n+    }\n+\n+  return ptr;\n+}\n+\n+static ffi_type*\n+get_ffi_type_from_signature (unsigned char* ptr)\n+{\n+  switch (*ptr) \n+    {\n+    case 'L':\n+    case '[':\n+      return &ffi_type_pointer;\n+      break;\n+\n+    case 'Z':\n+      // On some platforms a bool is a byte, on others an int.\n+      if (sizeof (jboolean) == sizeof (jbyte))\n+\treturn &ffi_type_sint8;\n+      else\n+\t{\n+\t  JvAssert (sizeof (jbyte) == sizeof (jint));\n+\t  return &ffi_type_sint32;\n+\t}\n+      break;\n+\n+    case 'B':\n+      return &ffi_type_sint8;\n+      break;\n+      \n+    case 'C':\n+      return &ffi_type_uint16;\n+      break;\n+\t  \n+    case 'S': \n+      return &ffi_type_sint16;\n+      break;\n+\t  \n+    case 'I':\n+      return &ffi_type_sint32;\n+      break;\n+\t  \n+    case 'J':\n+      return &ffi_type_sint64;\n+      break;\n+\t  \n+    case 'F':\n+      return &ffi_type_float;\n+      break;\n+\t  \n+    case 'D':\n+      return &ffi_type_double;\n+      break;\n+\n+    case 'V':\n+      return &ffi_type_void;\n+      break;\n+    }\n+\n+  throw_internal_error (\"unknown type in signature\");\n+}\n+\n+/* this function yields the number of actual arguments, that is, if the\n+ * function is non-static, then one is added to the number of elements\n+ * found in the signature */\n+\n+int \n+_Jv_count_arguments (_Jv_Utf8Const *signature,\n+\t\t     jboolean staticp)\n+{\n+  unsigned char *ptr = (unsigned char*) signature->chars();\n+  int arg_count = staticp ? 0 : 1;\n+\n+  /* first, count number of arguments */\n+\n+  // skip '('\n+  ptr++;\n+\n+  // count args\n+  while (*ptr != ')')\n+    {\n+      ptr = skip_one_type (ptr);\n+      arg_count += 1;\n+    }\n+\n+  return arg_count;\n+}\n+\n+/* This beast will build a cif, given the signature.  Memory for\n+ * the cif itself and for the argument types must be allocated by the\n+ * caller.\n+ */\n+\n+static int \n+init_cif (_Jv_Utf8Const* signature,\n+\t  int arg_count,\n+\t  jboolean staticp,\n+\t  ffi_cif *cif,\n+\t  ffi_type **arg_types,\n+\t  ffi_type **rtype_p)\n+{\n+  unsigned char *ptr = (unsigned char*) signature->chars();\n+\n+  int arg_index = 0;\t\t// arg number\n+  int item_count = 0;\t\t// stack-item count\n+\n+  // setup receiver\n+  if (!staticp)\n+    {\n+      arg_types[arg_index++] = &ffi_type_pointer;\n+      item_count += 1;\n+    }\n+\n+  // skip '('\n+  ptr++;\n+\n+  // assign arg types\n+  while (*ptr != ')')\n+    {\n+      arg_types[arg_index++] = get_ffi_type_from_signature (ptr);\n+\n+      if (*ptr == 'J' || *ptr == 'D')\n+\titem_count += 2;\n+      else\n+\titem_count += 1;\n+\n+      ptr = skip_one_type (ptr);\n+    }\n+\n+  // skip ')'\n+  ptr++;\n+  ffi_type *rtype = get_ffi_type_from_signature (ptr);\n+\n+  ptr = skip_one_type (ptr);\n+  if (ptr != (unsigned char*)signature->chars() + signature->len())\n+    throw_internal_error (\"did not find end of signature\");\n+\n+  if (ffi_prep_cif (cif, FFI_DEFAULT_ABI,\n+\t\t    arg_count, rtype, arg_types) != FFI_OK)\n+    throw_internal_error (\"ffi_prep_cif failed\");\n+\n+  if (rtype_p != NULL)\n+    *rtype_p = rtype;\n+\n+  return item_count;\n+}\n+\n+#if FFI_NATIVE_RAW_API\n+#   define FFI_PREP_RAW_CLOSURE ffi_prep_raw_closure\n+#   define FFI_RAW_SIZE ffi_raw_size\n+#else\n+#   define FFI_PREP_RAW_CLOSURE ffi_prep_java_raw_closure\n+#   define FFI_RAW_SIZE ffi_java_raw_size\n+#endif\n+\n+/* we put this one here, and not in interpret.cc because it\n+ * calls the utility routines _Jv_count_arguments \n+ * which are static to this module.  The following struct defines the\n+ * layout we use for the stubs, it's only used in the ncode method. */\n+\n+typedef struct {\n+  ffi_raw_closure  closure;\n+  ffi_cif   cif;\n+  ffi_type *arg_types[0];\n+} ncode_closure;\n+\n+typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_raw*,void*);\n+\n+void *\n+_Jv_InterpMethod::ncode ()\n+{\n+  using namespace java::lang::reflect;\n+\n+  if (self->ncode != 0)\n+    return self->ncode;\n+\n+  jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n+  int arg_count = _Jv_count_arguments (self->signature, staticp);\n+\n+  ncode_closure *closure =\n+    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n+\t\t\t\t\t+ arg_count * sizeof (ffi_type*));\n+\n+  init_cif (self->signature,\n+\t    arg_count,\n+\t    staticp,\n+\t    &closure->cif,\n+\t    &closure->arg_types[0],\n+\t    NULL);\n+\n+  ffi_closure_fun fun;\n+\n+  args_raw_size = FFI_RAW_SIZE (&closure->cif);\n+\n+  JvAssert ((self->accflags & Modifier::NATIVE) == 0);\n+\n+  if ((self->accflags & Modifier::SYNCHRONIZED) != 0)\n+    {\n+      if (staticp)\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;\n+      else\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object; \n+    }\n+  else\n+    {\n+      if (staticp)\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_class;\n+      else\n+\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;\n+    }\n+\n+  FFI_PREP_RAW_CLOSURE (&closure->closure,\n+\t\t        &closure->cif, \n+\t\t        fun,\n+\t\t        (void*)this);\n+\n+  self->ncode = (void*)closure;\n+  return self->ncode;\n+}\n+\n+void *\n+_Jv_JNIMethod::ncode ()\n+{\n+  using namespace java::lang::reflect;\n+\n+  if (self->ncode != 0)\n+    return self->ncode;\n+\n+  jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n+  int arg_count = _Jv_count_arguments (self->signature, staticp);\n+\n+  ncode_closure *closure =\n+    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n+\t\t\t\t    + arg_count * sizeof (ffi_type*));\n+\n+  ffi_type *rtype;\n+  init_cif (self->signature,\n+\t    arg_count,\n+\t    staticp,\n+\t    &closure->cif,\n+\t    &closure->arg_types[0],\n+\t    &rtype);\n+\n+  ffi_closure_fun fun;\n+\n+  args_raw_size = FFI_RAW_SIZE (&closure->cif);\n+\n+  // Initialize the argument types and CIF that represent the actual\n+  // underlying JNI function.\n+  int extra_args = 1;\n+  if ((self->accflags & Modifier::STATIC))\n+    ++extra_args;\n+  jni_arg_types = (ffi_type **) _Jv_AllocBytes ((extra_args + arg_count)\n+\t\t\t\t\t\t* sizeof (ffi_type *));\n+  int offset = 0;\n+  jni_arg_types[offset++] = &ffi_type_pointer;\n+  if ((self->accflags & Modifier::STATIC))\n+    jni_arg_types[offset++] = &ffi_type_pointer;\n+  memcpy (&jni_arg_types[offset], &closure->arg_types[0],\n+\t  arg_count * sizeof (ffi_type *));\n+\n+  if (ffi_prep_cif (&jni_cif, _Jv_platform_ffi_abi,\n+\t\t    extra_args + arg_count, rtype,\n+\t\t    jni_arg_types) != FFI_OK)\n+    throw_internal_error (\"ffi_prep_cif failed for JNI function\");\n+\n+  JvAssert ((self->accflags & Modifier::NATIVE) != 0);\n+\n+  // FIXME: for now we assume that all native methods for\n+  // interpreted code use JNI.\n+  fun = (ffi_closure_fun) &_Jv_JNIMethod::call;\n+\n+  FFI_PREP_RAW_CLOSURE (&closure->closure,\n+\t\t\t&closure->cif, \n+\t\t\tfun,\n+\t\t\t(void*) this);\n+\n+  self->ncode = (void *) closure;\n+  return self->ncode;\n+}\n+\n+static void\n+throw_class_format_error (jstring msg)\n+{\n+  throw (msg\n+\t ? new java::lang::ClassFormatError (msg)\n+\t : new java::lang::ClassFormatError);\n+}\n+\n+static void\n+throw_class_format_error (char *msg)\n+{\n+  throw_class_format_error (JvNewStringLatin1 (msg));\n+}\n+\n+\f\n+\n+void\n+_Jv_InterpreterEngine::do_verify (jclass klass)\n+{\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass *) klass->aux_info;\n+  for (int i = 0; i < klass->method_count; i++)\n+    {\n+      using namespace java::lang::reflect;\n+      _Jv_MethodBase *imeth = iclass->interpreted_methods[i];\n+      _Jv_ushort accflags = klass->methods[i].accflags;\n+      if ((accflags & (Modifier::NATIVE | Modifier::ABSTRACT)) == 0)\n+\t{\n+\t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n+\t  _Jv_VerifyMethod (im);\n+\t}\n+    }\n+}\n+\n+void\n+_Jv_InterpreterEngine::do_create_ncode (jclass klass)\n+{\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass *) klass->aux_info;\n+  for (int i = 0; i < klass->method_count; i++)\n+    {\n+      // Just skip abstract methods.  This is particularly important\n+      // because we don't resize the interpreted_methods array when\n+      // miranda methods are added to it.\n+      if ((klass->methods[i].accflags\n+\t   & java::lang::reflect::Modifier::ABSTRACT)\n+\t  != 0)\n+\tcontinue;\n+\n+      _Jv_MethodBase *imeth = iclass->interpreted_methods[i];\n+\n+      if ((klass->methods[i].accflags & java::lang::reflect::Modifier::NATIVE)\n+\t  != 0)\n+\t{\n+\t  // You might think we could use a virtual `ncode' method in\n+\t  // the _Jv_MethodBase and unify the native and non-native\n+\t  // cases.  Well, we can't, because we don't allocate these\n+\t  // objects using `new', and thus they don't get a vtable.\n+\t  _Jv_JNIMethod *jnim = reinterpret_cast<_Jv_JNIMethod *> (imeth);\n+\t  klass->methods[i].ncode = jnim->ncode ();\n+\t}\n+      else if (imeth != 0)\t\t// it could be abstract\n+\t{\n+\t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n+\t  klass->methods[i].ncode = im->ncode ();\n+\t}\n+    }\n+}\n+\n+void\n+_Jv_InterpreterEngine::do_allocate_static_fields (jclass klass,\n+\t\t\t\t\t\t  int static_size)\n+{\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass *) klass->aux_info;\n+\n+  char *static_data = (char *) _Jv_AllocBytes (static_size);\n+  memset (static_data, 0, static_size);\n+\n+  for (int i = 0; i < klass->field_count; i++)\n+    {\n+      _Jv_Field *field = &klass->fields[i];\n+\n+      if ((field->flags & java::lang::reflect::Modifier::STATIC) != 0)\n+\t{\n+\t  field->u.addr  = static_data + field->u.boffset;\n+\t      \n+\t  if (iclass->field_initializers[i] != 0)\n+\t    {\n+\t      _Jv_Linker::resolve_field (field, klass->loader);\n+\t      _Jv_InitField (0, klass, i);\n+\t    }\n+\t}\n+    }\n+\n+  // Now we don't need the field_initializers anymore, so let the\n+  // collector get rid of it.\n+  iclass->field_initializers = 0;\n+}\n+\n+_Jv_ResolvedMethod *\n+_Jv_InterpreterEngine::do_resolve_method (_Jv_Method *method, jclass klass,\n+\t\t\t\t\t  jboolean staticp, jint vtable_index)\n+{\n+  int arg_count = _Jv_count_arguments (method->signature, staticp);\n+\n+  _Jv_ResolvedMethod* result = (_Jv_ResolvedMethod*)\n+    _Jv_AllocBytes (sizeof (_Jv_ResolvedMethod)\n+\t\t    + arg_count*sizeof (ffi_type*));\n+\n+  result->stack_item_count\n+    = init_cif (method->signature,\n+\t\targ_count,\n+\t\tstaticp,\n+\t\t&result->cif,\n+\t\t&result->arg_types[0],\n+\t\tNULL);\n+\n+  result->vtable_index        = vtable_index;\n+  result->method              = method;\n+  result->klass               = klass;\n+\n+  return result;\n+}\n+\n+void\n+_Jv_InterpreterEngine::do_post_miranda_hook (jclass klass)\n+{\n+  _Jv_InterpClass *iclass = (_Jv_InterpClass *) klass->aux_info;\n+  for (int i = 0; i < klass->method_count; i++)\n+    {\n+      // Just skip abstract methods.  This is particularly important\n+      // because we don't resize the interpreted_methods array when\n+      // miranda methods are added to it.\n+      if ((klass->methods[i].accflags\n+\t   & java::lang::reflect::Modifier::ABSTRACT)\n+\t  != 0)\n+\tcontinue;\n+      // Miranda method additions mean that the `methods' array moves.\n+      // We cache a pointer into this array, so we have to update.\n+      iclass->interpreted_methods[i]->self = &klass->methods[i];\n+    }\n+}\n+\n #endif // INTERPRETER"}, {"sha": "0c79d332700ac24c268d01b62c3de2e94bd0d69f", "filename": "libjava/java/io/ObjectInputStream.java", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Fio%2FObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Fio%2FObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectInputStream.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -121,15 +121,15 @@ else if (dump == true && (val == null || val.equals(\"\")))\n    */\n   public final Object readObject() throws ClassNotFoundException, IOException\n   {\n-      if (callersClassLoader == null)\n-\t{\n-\t  callersClassLoader = getCallersClassLoader ();\n-\t  if (Configuration.DEBUG && dump)\n-\t    {\n-\t      dumpElementln (\"CallersClassLoader = \" + callersClassLoader);\n-\t    }\n-\t}\n-\n+\tif (callersClassLoader == null)\n+\t  {\n+\t\tcallersClassLoader = getCallersClassLoader ();\n+\t\tif (Configuration.DEBUG && dump)\n+\t\t  {\n+\t\t\tdumpElementln (\"CallersClassLoader = \" + callersClassLoader);\n+\t\t  }\n+\t  }\n+\t\n     if (this.useSubclassMethod)\n       return readObjectOverride();\n \n@@ -271,7 +271,7 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \t      readArrayElements(array, componentType);\n \t      if(dump)\n \t        for (int i = 0, len = Array.getLength(array); i < len; i++)\n-\t\t  dumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n+\t\t\t  dumpElementln(\"  ELEMENT[\" + i + \"]=\" + Array.get(array, i));\n \t      ret_val = processResolution(null, array, handle);\n \t      break;\n \t    }\n@@ -398,6 +398,8 @@ public final Object readObject() throws ClassNotFoundException, IOException\n \tsetBlockDataMode(old_mode);\n \t\n \tthis.isDeserializing = was_deserializing;\n+\n+\tdepth -= 2;\n \t\n \tdepth -= 2;\n \t\n@@ -1806,6 +1808,7 @@ private void invokeValidators() throws InvalidObjectException\n    * @param sm SecurityManager instance which should be called.\n    * @return The current class loader in the calling stack.\n    */\n+\n   private static native ClassLoader currentClassLoader (SecurityManager sm);\n   \n   private native ClassLoader getCallersClassLoader();\n@@ -1875,7 +1878,7 @@ private native Object allocateObject (Class clazz)\n   private int depth = 0;\n \n   private void dumpElement (String msg)\n-  {\n+  {\t\n     System.out.print(msg);\n   }\n   "}, {"sha": "3482225232a19930dc4865b1db50169c8d92f3ba", "filename": "libjava/java/io/ObjectOutputStream.java", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Fio%2FObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FObjectOutputStream.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -347,8 +347,8 @@ public final void writeObject(Object obj) throws IOException\n \t\t    fieldsAlreadyWritten = false;\n \t\t    if (currentObjectStreamClass.hasWriteMethod())\n \t\t      {\n-\t\t\tif (dump)\n-\t\t\t  dumpElementln (\"WRITE METHOD CALLED FOR: \" + obj);\n+\t\t\t\tif (dump)\n+\t\t\t\t  dumpElementln (\"WRITE METHOD CALLED FOR: \" + obj);\n \t\t\tsetBlockDataMode(true);\n \t\t\tcallWriteMethod(obj, currentObjectStreamClass);\n \t\t\tsetBlockDataMode(false);\n@@ -358,10 +358,10 @@ public final void writeObject(Object obj) throws IOException\n \t\t      }\n \t\t    else\n \t\t      {\n-\t\t\tif (dump)\n-\t\t\t  dumpElementln (\"WRITE FIELDS CALLED FOR: \" + obj);\n-\t\t      writeFields(obj, currentObjectStreamClass);\n-\t\t  }\n+\t\t\t\tif (dump)\n+\t\t\t\t  dumpElementln (\"WRITE FIELDS CALLED FOR: \" + obj);\n+\t\t\t\twriteFields(obj, currentObjectStreamClass);\n+\t\t\t  }\n \t\t  }\n \n \t\tthis.currentObject = prevObject;"}, {"sha": "320b09965d0e08233fddb95851f3ac1727ac5e36", "filename": "libjava/java/lang/Class.h", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FClass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FClass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClass.h?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -42,13 +42,15 @@ enum\n \n   JV_STATE_PRELOADING = 1,\t// Can do _Jv_FindClass.\n   JV_STATE_LOADING = 3,\t\t// Has super installed.\n-  JV_STATE_COMPILED = 5,\t// This was a compiled class.\n+  JV_STATE_READ = 4,\t\t// Has been completely defined.\n+  JV_STATE_LOADED = 5,\t\t// Has Miranda methods defined.\n+\n+  JV_STATE_COMPILED = 6,\t// This was a compiled class.\n \n-  JV_STATE_LOADED = 6,\t\t// Is complete.\n   JV_STATE_PREPARED = 7,\t// Layout & static init done.\n   JV_STATE_LINKED = 9,\t\t// Strings interned.\n \n-  JV_STATE_IN_PROGRESS = 10,\t// <Clinit> running.\n+  JV_STATE_IN_PROGRESS = 10,\t// <clinit> running.\n \n   JV_STATE_ERROR = 12,\n \n@@ -59,6 +61,9 @@ struct _Jv_Field;\n struct _Jv_VTable;\n union _Jv_word;\n struct _Jv_ArrayVTable;\n+class _Jv_ExecutionEngine;\n+class _Jv_CompiledEngine;\n+class _Jv_InterpreterEngine;\n \n struct _Jv_Constants\n {\n@@ -106,7 +111,7 @@ union _Jv_IDispatchTable\n   } iface;\n };\n \n-// Used by _Jv_GetInterfaces ()\n+// Used by _Jv_Linker::get_interfaces ()\n struct _Jv_ifaces\n {\n   jclass *list;\n@@ -139,6 +144,23 @@ struct _Jv_CatchClass\n   _Jv_Utf8Const *classname;\n };\n \n+// Possible values for the assertion_code field in the type assertion table.\n+enum\n+{\n+  JV_ASSERT_END_OF_TABLE = 0,\n+  JV_ASSERT_TYPES_COMPATIBLE = 1,\n+  JV_ASSERT_IS_INSTANTIABLE = 2\n+};\n+\n+// Entry in the type assertion table, used to validate type constraints\n+// for binary compatibility.\n+struct _Jv_TypeAssertion\n+{\n+  jint assertion_code;\n+  _Jv_Utf8Const *op1;\n+  _Jv_Utf8Const *op2;\n+};\n+\n #define JV_PRIMITIVE_VTABLE ((_Jv_VTable *) -1)\n \n #define JV_CLASS(Obj) ((jclass) (*(_Jv_VTable **) Obj)->clas)\n@@ -149,11 +171,11 @@ struct _Jv_CatchClass\n _Jv_Method *_Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \t\t\t\t_Jv_Utf8Const *signature);\n jboolean _Jv_IsAssignableFrom (jclass, jclass);\n+jboolean _Jv_IsAssignableFromSlow (jclass, jclass);\n jboolean _Jv_InterfaceAssignableFrom (jclass, jclass);\n-void _Jv_InitClass (jclass klass);\n \n _Jv_Method* _Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *, \n-\t\t\t\t      _Jv_Utf8Const*);\n+\t\t\t\t      _Jv_Utf8Const*, jclass * = NULL);\n jfieldID JvGetFirstInstanceField (jclass);\n jint JvNumInstanceFields (jclass);\n jfieldID JvGetFirstStaticField (jclass);\n@@ -183,10 +205,6 @@ class java::io::ObjectOutputStream;\n class java::io::ObjectInputStream;\n class java::io::ObjectStreamClass;\n \n-void _Jv_WaitForState (jclass, int);\n-void _Jv_RegisterClasses (const jclass *classes);\n-void _Jv_RegisterClasses_Counted (const jclass *classes, \n-\t\t\t\t  size_t count);\n void _Jv_RegisterClassHookDefault (jclass klass);\n void _Jv_RegisterInitiatingLoader (jclass,java::lang::ClassLoader*);\n void _Jv_UnregisterClass (jclass);\n@@ -205,45 +223,22 @@ void _Jv_InitNewClassFields (jclass klass);\n \n // Friend functions and classes in prims.cc\n void _Jv_InitPrimClass (jclass, char *, char, int);\n-void _Jv_PrepareCompiledClass (jclass);\n-void _Jv_PrepareConstantTimeTables (jclass);\n-jshort _Jv_GetInterfaces (jclass, _Jv_ifaces *);\n-void _Jv_GenerateITable (jclass, _Jv_ifaces *, jshort *);\n jstring _Jv_GetMethodString (jclass, _Jv_Utf8Const *);\n-jshort _Jv_AppendPartialITable (jclass, jclass, void **, jshort);\n-jshort _Jv_FindIIndex (jclass *, jshort *, jshort);\n-void _Jv_LinkSymbolTable (jclass);\n-void _Jv_LayoutInterfaceMethods (jclass);\n-void _Jv_LayoutVTableMethods (jclass klass);\n-void _Jv_SetVTableEntries (jclass, _Jv_VTable *, jboolean *);\n-void _Jv_MakeVTable (jclass);\n-void _Jv_linkExceptionClassTable (jclass);\n \n jboolean _Jv_CheckAccess (jclass self_klass, jclass other_klass,\n \t\t\t  jint flags);\n jclass _Jv_GetArrayClass (jclass klass, java::lang::ClassLoader *loader);\n \n #ifdef INTERPRETER\n jboolean _Jv_IsInterpretedClass (jclass);\n-void _Jv_InitField (jobject, jclass, _Jv_Field*);\n void _Jv_InitField (jobject, jclass, int);\n-_Jv_word _Jv_ResolvePoolEntry (jclass, int);\n-_Jv_Method *_Jv_SearchMethodInClass (jclass cls, jclass klass, \n-\t\t\t\t     _Jv_Utf8Const *method_name, \n-\t\t\t\t     _Jv_Utf8Const *method_signature);\n \n-void _Jv_PrepareClass (jclass);\n-void _Jv_PrepareMissingMethods (jclass base, jclass iface_class);\n-\n-void _Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n-  \n class _Jv_ClassReader;\t\n class _Jv_InterpClass;\n class _Jv_InterpMethod;\n #endif\n \n class _Jv_BytecodeVerifier;\n-class _Jv_StackTrace;\n class gnu::gcj::runtime::StackTrace;\n class java::io::VMObjectStreamClass;\n \n@@ -316,9 +311,14 @@ class java::lang::Class : public java::lang::Object\n   void setSigners(JArray<jobject> *);\n \n   inline jclass getSuperclass (void)\n-    {\n-      return superclass;\n-    }\n+  {\n+    return superclass;\n+  }\n+\n+  inline jclass getInterface (jint n)\n+  {\n+    return interfaces[n];\n+  }\n \n   inline jboolean isArray (void)\n     {\n@@ -351,9 +351,16 @@ class java::lang::Class : public java::lang::Object\n \n   // FIXME: this probably shouldn't be public.\n   jint size (void)\n-    {\n-      return size_in_bytes;\n-    }\n+  {\n+    return size_in_bytes;\n+  }\n+\n+  // The index of the first method we declare ourself (as opposed to\n+  // inheriting).\n+  inline jint firstMethodIndex (void)\n+  {\n+    return vtable_method_count - method_count;\n+  }\n     \n   // finalization\n   void finalize ();\n@@ -372,18 +379,25 @@ class java::lang::Class : public java::lang::Object\n \n   static jstring getPackagePortion (jstring);\n \n+  void set_state (jint nstate)\n+  {\n+    state = nstate;\n+    notifyAll ();\n+  }\n+\n   // Friend functions implemented in natClass.cc.\n   friend _Jv_Method *::_Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \t\t\t\t\t   _Jv_Utf8Const *signature);\n   friend jboolean (::_Jv_IsAssignableFrom) (jclass, jclass);\n+  friend jboolean (::_Jv_IsAssignableFromSlow) (jclass, jclass);\n   friend jboolean (::_Jv_InterfaceAssignableFrom) (jclass, jclass);\n   friend void *::_Jv_LookupInterfaceMethodIdx (jclass klass, jclass iface, \n \t\t\t\t\t       int method_idx);\n \n   friend void ::_Jv_InitClass (jclass klass);\n \n   friend _Jv_Method* ::_Jv_LookupDeclaredMethod (jclass, _Jv_Utf8Const *, \n-\t\t\t\t\t\t _Jv_Utf8Const*);\n+\t\t\t\t\t\t _Jv_Utf8Const*, jclass *);\n   friend jfieldID (::JvGetFirstInstanceField) (jclass);\n   friend jint (::JvNumInstanceFields) (jclass);\n   friend jfieldID (::JvGetFirstStaticField) (jclass);\n@@ -413,7 +427,6 @@ class java::lang::Class : public java::lang::Object\n   friend class java::io::ObjectInputStream;\n   friend class java::io::ObjectStreamClass;\n \n-  friend void ::_Jv_WaitForState (jclass, int);\n   friend void ::_Jv_RegisterClasses (const jclass *classes);\n   friend void ::_Jv_RegisterClasses_Counted (const jclass *classes, \n \t\t\t\t\t     size_t count);\n@@ -436,40 +449,22 @@ class java::lang::Class : public java::lang::Object\n   // in prims.cc\n   friend void ::_Jv_InitPrimClass (jclass, char *, char, int);\n \n-  friend void ::_Jv_PrepareCompiledClass (jclass);\n-  friend void ::_Jv_PrepareConstantTimeTables (jclass);\n-  friend jshort (::_Jv_GetInterfaces) (jclass, _Jv_ifaces *);\n-  friend void ::_Jv_GenerateITable (jclass, _Jv_ifaces *, jshort *);\n   friend jstring (::_Jv_GetMethodString) (jclass, _Jv_Utf8Const *);\n-  friend jshort (::_Jv_AppendPartialITable) (jclass, jclass, void **, jshort);\n-  friend jshort (::_Jv_FindIIndex) (jclass *, jshort *, jshort);\n-  friend void ::_Jv_LinkSymbolTable (jclass);\n-  friend void ::_Jv_LayoutInterfaceMethods (jclass);\n-  friend void ::_Jv_LayoutVTableMethods (jclass klass);\n-  friend void ::_Jv_SetVTableEntries (jclass, _Jv_VTable *, jboolean *);\n-  friend void ::_Jv_MakeVTable (jclass);\n-  friend void ::_Jv_linkExceptionClassTable (jclass);\n \n   friend jboolean (::_Jv_CheckAccess) (jclass self_klass, jclass other_klass,\n \t\t\t\t   jint flags);\n+  \n+  friend bool _Jv_getInterfaceMethod(jclass, jclass&, int&, \n+\t\t\t\t     const _Jv_Utf8Const*,\n+\t\t\t\t     const _Jv_Utf8Const*);\n \n   friend jclass (::_Jv_GetArrayClass) (jclass klass,\n \t\t\t\t       java::lang::ClassLoader *loader);\n \n #ifdef INTERPRETER\n   friend jboolean (::_Jv_IsInterpretedClass) (jclass);\n-  friend void ::_Jv_InitField (jobject, jclass, _Jv_Field*);\n   friend void ::_Jv_InitField (jobject, jclass, int);\n-  friend _Jv_word (::_Jv_ResolvePoolEntry) (jclass, int);\n-  friend _Jv_Method *::_Jv_SearchMethodInClass (jclass cls, jclass klass, \n-\t\t\t\t\t\t_Jv_Utf8Const *method_name, \n-\t\t\t\t\t\t_Jv_Utf8Const *method_signature);\n \n-  friend void ::_Jv_PrepareClass (jclass);\n-  friend void ::_Jv_PrepareMissingMethods (jclass base, jclass iface_class);\n-\n-  friend void ::_Jv_Defer_Resolution (void *cl, _Jv_Method *meth, void **);\n-  \n   friend class ::_Jv_ClassReader;\t\n   friend class ::_Jv_InterpClass;\n   friend class ::_Jv_InterpMethod;\n@@ -480,10 +475,14 @@ class java::lang::Class : public java::lang::Object\n #endif\n \n   friend class ::_Jv_BytecodeVerifier;\n-  friend class ::_Jv_StackTrace;\n   friend class gnu::gcj::runtime::StackTrace;\n   friend class java::io::VMObjectStreamClass;\n \n+  friend class _Jv_Linker;\n+  friend class _Jv_ExecutionEngine;\n+  friend class _Jv_CompiledEngine;\n+  friend class _Jv_InterpreterEngine;\n+\n   friend void ::_Jv_sharedlib_register_hook (jclass klass);\n \n   // Chain for class pool.\n@@ -518,8 +517,12 @@ class java::lang::Class : public java::lang::Object\n   _Jv_OffsetTable *otable;\n   // Offset table symbols.\n   _Jv_MethodSymbol *otable_syms;\n+  // Address table\n   _Jv_AddressTable *atable;\n   _Jv_MethodSymbol *atable_syms;\n+  // Interface table\n+  _Jv_AddressTable *itable;\n+  _Jv_MethodSymbol *itable_syms;\n   _Jv_CatchClass *catch_classes;\n   // Interfaces implemented by this class.\n   jclass *interfaces;\n@@ -542,13 +545,17 @@ class java::lang::Class : public java::lang::Object\n   jclass arrayclass;\n   // Security Domain to which this class belongs (or null).\n   java::security::ProtectionDomain *protectionDomain;\n+  // Pointer to the type assertion table for this class.\n+  _Jv_TypeAssertion *assertion_table;\n   // Signers of this class (or null).\n   JArray<jobject> *hack_signers;\n   // Used by Jv_PopClass and _Jv_PushClass to communicate with StackTrace.\n   jclass chain;\n-  // Additional data, specific to the generator (JIT, native, interpreter) of this \n-  // class.\n+  // Additional data, specific to the generator (JIT, native,\n+  // interpreter) of this class.\n   void *aux_info;\n+  // Execution engine.\n+  _Jv_ExecutionEngine *engine;\n };\n \n // Inline functions that are friends of java::lang::Class"}, {"sha": "648afca5435c7a5a81437710b6bb760243ddc506", "filename": "libjava/java/lang/ClassLoader.java", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FClassLoader.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -288,6 +288,8 @@ protected synchronized Class loadClass(String name, boolean resolve)\n     if (c != null)\n       return c;\n \n+    ClassNotFoundException ex = null;\n+\n     // Can the class be loaded by a parent?\n     try\n       {\n@@ -304,9 +306,20 @@ protected synchronized Class loadClass(String name, boolean resolve)\n       }\n     catch (ClassNotFoundException e)\n       {\n+\tex = e;\n       }\n     // Still not found, we have to do it ourself.\n-    c = findClass(name);\n+    try\n+      {\n+\tc = findClass(name);\n+      }\n+    catch (ClassNotFoundException cause)\n+      {\n+\tif (ex != null)\n+\t  throw new ClassNotFoundException(ex.toString(), cause);\n+\telse\n+\t  throw cause;\n+      }\n     if (resolve)\n       resolveClass(c);\n     return c;\n@@ -435,8 +448,9 @@ protected final synchronized Class defineClass(String name, byte[] data,\n       domain = defaultProtectionDomain;\n     if (! initialized)\n       throw new SecurityException(\"attempt to define class from uninitialized class loader\");\n+    \n     Class retval = VMClassLoader.defineClass(this, name, data,\n-                                             offset, len, domain);\n+\t\t\t\t\t     offset, len, domain);\n     loadedClasses.put(retval.getName(), retval);\n     return retval;\n   }"}, {"sha": "858f63ee993393fb5cce50c29fb520686a742d8e", "filename": "libjava/java/lang/Compiler.java", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FCompiler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FCompiler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FCompiler.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,5 +1,5 @@\n /* Compiler.java -- placeholder for Java-to-native runtime compilers\n-   Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -76,8 +76,7 @@ private Compiler()\n    */\n   public static boolean compileClass(Class oneClass)\n   {\n-    // Never succeed.\n-    return false;\n+    return VMCompiler.compileClass(oneClass);\n   }\n \n   /**\n@@ -90,8 +89,7 @@ public static boolean compileClass(Class oneClass)\n    */\n   public static boolean compileClasses(String classNames)\n   {\n-    // Note the incredibly lame interface.  Always fail.\n-    return false;\n+    return VMCompiler.compileClasses(classNames);\n   }\n \n   /**\n@@ -105,8 +103,7 @@ public static boolean compileClasses(String classNames)\n    */\n   public static Object command(Object arg)\n   {\n-    // Our implementation defines this to a no-op.\n-    return null;\n+    return VMCompiler.command(arg);\n   }\n \n   /**\n@@ -116,6 +113,7 @@ public static Object command(Object arg)\n    */\n   public static void enable()\n   {\n+    VMCompiler.enable();\n   }\n \n   /**\n@@ -124,5 +122,6 @@ public static void enable()\n    */\n   public static void disable()\n   {\n+    VMCompiler.disable();\n   }\n }"}, {"sha": "972b312d94366d9327262691f984b59251bc3038", "filename": "libjava/java/lang/SecurityManager.java", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSecurityManager.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -324,7 +324,7 @@ public Object getSecurityContext()\n   public void checkPermission(Permission perm)\n   {\n     // XXX Should be: AccessController.checkPermission(perm);\n-    throw new SecurityException(\"Operation not allowed\");\n+    //.throw new SecurityException(\"Operation not allowed\");\n   }\n \n   /**\n@@ -553,7 +553,7 @@ public void checkRead(String filename, Object context)\n     //   throw new SecurityException(\"Missing context\");\n     // AccessControlContext ac = (AccessControlContext) context;\n     // ac.checkPermission(new FilePermission(filename, \"read\"));\n-    throw new SecurityException(\"Cannot read files via file names.\");\n+    // throw new SecurityException(\"Cannot read files via file names.\");\n   }\n \n   /**\n@@ -677,7 +677,7 @@ public void checkConnect(String host, int port, Object context)\n     //   // Use the toString() hack to do the null check.\n     //   ac.checkPermission(new SocketPermission(host.toString + \":\" +port,\n     //                                           \"connect\"));\n-    throw new SecurityException(\"Cannot make network connections.\");\n+    // throw new SecurityException(\"Cannot make network connections.\");\n   }\n \n   /**"}, {"sha": "8f78f9bb6666cb562a6df11410cac41a7ac8fd1e", "filename": "libjava/java/lang/VMClassLoader.java", "status": "modified", "additions": 17, "deletions": 30, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FVMClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FVMClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMClassLoader.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -97,44 +97,31 @@ static final native Class defineClass(ClassLoader cl, String name,\n \t\t\t\t\tProtectionDomain pd)\n     throws ClassFormatError;\n \n-  static final native void linkClass0 (Class klass);\n-  static final native void markClassErrorState0 (Class klass);\n-\n   /**\n    * Helper to resolve all references to other classes from this class.\n    *\n    * @param c the class to resolve\n    */\n-  static final void resolveClass(Class clazz)\n+  static final native void resolveClass(Class clazz);\n+\n+  static final void transformException(Class clazz, Throwable x)\n   {\n-    synchronized (clazz)\n+    LinkageError e;\n+    if (x instanceof LinkageError)\n+      e = (LinkageError) x;\n+    else if (x instanceof ClassNotFoundException)\n       {\n-\ttry\n-\t  {\n-\t    linkClass0 (clazz);\n-\t  }\n-\tcatch (Throwable x)\n-\t  {\n-\t    markClassErrorState0 (clazz);\n-\n-\t    LinkageError e;\n-\t    if (x instanceof LinkageError)\n-\t      e = (LinkageError) x;\n-\t    else if (x instanceof ClassNotFoundException)\n-\t      {\n-\t\te = new NoClassDefFoundError(\"while resolving class: \"\n-\t\t\t\t\t     + clazz.getName());\n-\t\te.initCause (x);\n-\t      }\n-\t    else\n-\t      {\n-\t\te = new LinkageError (\"unexpected exception during linking: \"\n-\t\t\t\t      + clazz.getName());\n-\t\te.initCause (x);\n-\t      }\n-\t    throw e;\n-\t  }\n+\te = new NoClassDefFoundError(\"while resolving class: \"\n+\t\t\t\t     + clazz.getName());\n+\te.initCause (x);\n+      }\n+    else\n+      {\n+\te = new LinkageError (\"unexpected exception during linking: \"\n+\t\t\t      + clazz.getName());\n+\te.initCause (x);\n       }\n+    throw e;\n   }\n \n   /**"}, {"sha": "98efc7ee44fc217a9256df8e1ba2d07b06d1f389", "filename": "libjava/java/lang/VMCompiler.java", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FVMCompiler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FVMCompiler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMCompiler.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,332 @@\n+/* VMClassLoader.java -- Reference implementation of compiler interface\n+   Copyright (C) 2004 Free Software Foundation\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.lang;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStreamReader;\n+import java.security.MessageDigest;\n+import java.security.ProtectionDomain;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.WeakHashMap;\n+import java.util.HashSet;\n+import java.util.Enumeration;\n+import java.util.StringTokenizer;\n+import java.util.Vector;\n+import gnu.gcj.runtime.SharedLibHelper;\n+import gnu.gcj.runtime.PersistentByteMap;\n+\n+/**\n+ * This class is just a per-VM reflection of java.lang.Compiler.\n+ * All methods are defined identically.\n+ */\n+final class VMCompiler\n+{\n+  // True if we want to use gcj-jit.\n+  public static boolean useCompiler = true;\n+\n+  // True if we're able to use gcj-jit.\n+  public static final boolean canUseCompiler;\n+\n+  // Compiler to use.\n+  public static String gcjJitCompiler;\n+\n+  // Compiler options.\n+  public static String gcjJitCompilerOptions;\n+\n+  // Temporary directory to use.\n+  public static String gcjJitTmpdir;\n+\n+  // This maps a ClassLoader to a set of SharedLibHelper objects that\n+  // it has used.  We do things this way to ensure that a\n+  // SharedLibHelper is collected if and only if the ClassLoader is.\n+  private static WeakHashMap sharedHelperMap = new WeakHashMap();\n+\n+  private static Vector precompiledMapFiles;\n+\n+  static\n+  {\n+    gcjJitCompiler = System.getProperty(\"gnu.gcj.jit.compiler\");\n+    if (gcjJitCompiler == null)\n+      canUseCompiler = false;\n+    else\n+      {\n+\tgcjJitCompilerOptions = System.getProperty(\"gnu.gcj.jit.options\",\n+\t\t\t\t\t\t   \"-g\");\n+\tgcjJitTmpdir = System.getProperty(\"gnu.gcj.jit.cachedir\");\n+\t// Note that we *don't* choose java.io.tmpdir as a default --\n+\t// that would allow easy attacks against the VM.\n+\tif (gcjJitTmpdir == null)\n+\t  canUseCompiler = false;\n+\telse\n+\t  canUseCompiler = true;\n+      }\n+\n+    String prop = System.getProperty (\"gnu.gcj.precompiled.db.path\");\n+    if (prop != null)\n+      {\n+\tprecompiledMapFiles = new Vector();\n+\t// Add the \n+\tStringTokenizer st\n+\t  = new StringTokenizer (prop,\n+\t\t\t\t System.getProperty (\"path.separator\", \":\"));\n+\t{\n+\t  while (st.hasMoreElements ()) \n+\t    {  \n+\t      String e = st.nextToken ();\n+\t      try\n+\t\t{\n+\t\t  PersistentByteMap map \n+\t\t    = new PersistentByteMap\n+\t\t    (e, PersistentByteMap.AccessMode.READ_ONLY);\n+\t\t  precompiledMapFiles.add(map);\n+\t\t}\n+\t      catch (IllegalArgumentException _)\n+\t\t{\n+\t\t  // Not a map file\t      \n+\t\t}\n+\t      catch (java.io.IOException _)\n+\t\t{\n+\t\t}\n+\t    }\n+\t}\n+      }\n+  }\n+\n+  /**\n+   * Don't allow new `Compiler's to be made.\n+   */\n+  private VMCompiler()\n+  {\n+  }\n+\n+  private static Class loadSharedLibrary(ClassLoader loader,\n+\t\t\t\t\t String fileName,\n+\t\t\t\t\t ProtectionDomain domain,\n+\t\t\t\t\t String className)\n+  {\n+    Class c = null;\n+    SharedLibHelper helper \n+      = SharedLibHelper.findHelper (loader, fileName, domain.getCodeSource());\n+    c = helper.findClass (className);\n+    if (c != null)\n+      {\n+\tHashSet hs = (HashSet) sharedHelperMap.get(loader);\n+\tif (hs == null)\n+\t  {\n+\t    hs = new HashSet();\n+\t    sharedHelperMap.put(loader, hs);\n+\t  }\n+\ths.add(helper);\n+      }\n+    return c;\n+  }\n+\n+  /**\n+   * Compile a class given the bytes for it.  Returns the Class, or\n+   * null if compilation failed or otherwise could not be done.\n+   */\n+  public static Class compileClass(ClassLoader loader,\n+\t\t\t\t   String name, byte[] data,\n+\t\t\t\t   int offset, int len,\n+\t\t\t\t   ProtectionDomain domain)\n+  {\n+    if (precompiledMapFiles == null\n+\t&& (! useCompiler || ! canUseCompiler))\n+      return null;\n+\n+    byte digest[];\n+\n+    try\n+      {\n+\tMessageDigest md = MessageDigest.getInstance(\"MD5\");\n+\tdigest = md.digest(data);\n+      }\n+    catch (NoSuchAlgorithmException _)\n+      {\n+\treturn null;\n+      }\n+\n+    // We use lookaside cache files to determine whether these bytes\n+    // correspond to a class file that is part of a precompiled DSO.\n+    if (precompiledMapFiles != null)\n+      {\n+\ttry\n+\t  {\n+\t    Enumeration elements = precompiledMapFiles.elements();\n+\t    while (elements.hasMoreElements())\n+\t      {\n+\t\tPersistentByteMap map = (PersistentByteMap)elements.nextElement();\n+\t\tbyte[] soName = map.get(digest);\n+\t\tif (soName != null)\n+\t\t  return loadSharedLibrary(loader, \n+\t\t\t\t\t   new String(soName), \n+\t\t\t\t\t   domain, name);\n+\t      }\n+\t  }\n+\tcatch (Exception _)\n+\t  {\n+\t  }\n+      }\n+ \n+    if (! useCompiler || ! canUseCompiler)\n+      return null;\n+\n+    try\n+      {\n+\t// FIXME: Make sure that the class represented by the\n+\t// bytes in DATA really is the class named in NAME.  Make\n+\t// sure it's not \"java.*\".\n+\tStringBuffer hexBytes = new StringBuffer(gcjJitTmpdir);\n+\thexBytes.append(File.separatorChar);\n+\tint digestLength = digest.length;\n+\tfor (int i = 0; i < digestLength; ++i)\n+\t  hexBytes.append(Integer.toHexString(digest[i] & 0xff));\n+\n+\t// FIXME: use System.mapLibraryName?\n+\t// I'm thinking we should use that, plus a class specified\n+\t// via a property that determines lookup policy.\n+\tFile soFile = new File(hexBytes + \".so\");\n+\tif (soFile.isFile())\n+          return loadSharedLibrary (loader, soFile.toString(), domain,\n+\t\t\t\t    name);\n+\n+\tFile classFile = new File(hexBytes + \".class\");\n+\tclassFile.delete();\n+\tif (classFile.createNewFile() != true)\t  \n+\t  return null;\n+\n+\tFileOutputStream f = new FileOutputStream (classFile);\n+\t// FIXME: race condition if bytes change... ?\n+\tf.write(data, offset, len);\n+\n+\t// Invoke the compiler.\n+\tStringBuffer command = new StringBuffer(gcjJitCompiler);\n+\tcommand.append(\" \");\n+\tcommand.append(classFile);\n+\tcommand.append(\" \");\n+\tcommand.append(gcjJitCompilerOptions);\n+\t// These options are required.\n+\tcommand.append(\" -findirect-dispatch -fjni -shared -fPIC -o \");\n+\tcommand.append(soFile);\n+\tProcess p = Runtime.getRuntime().exec(command.toString());\n+\n+\t// Read the process' stderr into a string.\n+\tStringBuffer err = new StringBuffer();\n+\tInputStreamReader stderr = new InputStreamReader (p.getErrorStream());\n+\tchar[] inBuf = new char[500];\n+\tint bytesRead;\n+\twhile ((bytesRead = stderr.read (inBuf)) != -1)\n+\t  err.append(inBuf, 0, bytesRead);\n+\n+\tif (p.waitFor() != 0)\n+\t  {\n+\t    // FIXME: we could log err.toString() somewhere...\n+\t    return null;\n+\t  }\n+\n+\treturn loadSharedLibrary(loader, soFile.toString(), domain, name);\n+      }\n+    catch (Exception _)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * Compile the class named by <code>oneClass</code>.\n+   *\n+   * @param oneClass the class to compile\n+   * @return <code>false</code> if no compiler is available or\n+   *         compilation failed, <code>true</code> if compilation succeeded\n+   * @throws NullPointerException if oneClass is null\n+   */\n+  public static boolean compileClass(Class oneClass)\n+  {\n+    // Never succeed.\n+    return false;\n+  }\n+\n+  /**\n+   * Compile the classes whose name matches <code>classNames</code>.\n+   *\n+   * @param classNames the name of classes to compile\n+   * @return <code>false</code> if no compiler is available or\n+   *         compilation failed, <code>true</code> if compilation succeeded\n+   * @throws NullPointerException if classNames is null\n+   */\n+  public static boolean compileClasses(String classNames)\n+  {\n+    // Note the incredibly lame interface.  Always fail.\n+    return false;\n+  }\n+\n+  /**\n+   * This method examines the argument and performs an operation\n+   * according to the compilers documentation.  No specific operation\n+   * is required.\n+   *\n+   * @param arg a compiler-specific argument\n+   * @return a compiler-specific value, including null\n+   * @throws NullPointerException if the compiler doesn't like a null arg\n+   */\n+  public static Object command(Object arg)\n+  {\n+    // Our implementation defines this to a no-op.\n+    return null;\n+  }\n+\n+  /**\n+   * Calling <code>Compiler.enable()</code> will cause the compiler\n+   * to resume operation if it was previously disabled; provided that a\n+   * compiler even exists.\n+   */\n+  public static void enable()\n+  {\n+    useCompiler = true;\n+  }\n+\n+  /**\n+   * Calling <code>Compiler.disable()</code> will cause the compiler\n+   * to be suspended; provided that a compiler even exists.\n+   */\n+  public static void disable()\n+  {\n+    useCompiler = false;\n+  }\n+}"}, {"sha": "604f8ecb428eb3ea4285f2090cb7a3983b65a745", "filename": "libjava/java/lang/VMSecurityManager.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FVMSecurityManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FVMSecurityManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FVMSecurityManager.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -54,11 +54,12 @@ static ClassLoader currentClassLoader()\n     // The docs above are wrong.  See the online docs.\n     // FIXME this implementation is a bit wrong too -- the docs say we\n     // must also consider ancestors of the system class loader.\n+    ClassLoader systemClassLoader = VMClassLoader.getSystemClassLoader();\n     Class[] classStack = getClassContext ();\n     for (int i = 0; i < classStack.length; i++)\n       {\n \tClassLoader loader = classStack[i].getClassLoader();\n-\tif (loader != null)\n+\tif (loader != null && loader != systemClassLoader)\n \t  return loader;\n       }\n "}, {"sha": "0e9c26c7b4fa91f0d4332e88c6f3fc3d6df95500", "filename": "libjava/java/lang/natClass.cc", "status": "modified", "additions": 191, "deletions": 942, "changes": 1133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatClass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatClass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClass.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -14,6 +14,7 @@ details.  */\n #include <limits.h>\n #include <string.h>\n #include <stddef.h>\n+#include <stdio.h>\n \n #pragma implementation \"Class.h\"\n \n@@ -56,16 +57,17 @@ details.  */\n #include <gcj/method.h>\n #include <gnu/gcj/runtime/MethodRef.h>\n #include <gnu/gcj/RawData.h>\n+#include <java/lang/VerifyError.h>\n \n #include <java-cpool.h>\n #include <java-interp.h>\n+#include <java-assert.h>\n+#include <execution.h>\n \n \f\n \n using namespace gcj;\n \n-bool gcj::verbose_class_flag;\n-\n jclass\n java::lang::Class::forName (jstring className, jboolean initialize,\n                             java::lang::ClassLoader *loader)\n@@ -485,7 +487,12 @@ java::lang::Class::getInterfaces (void)\n   jobjectArray r = JvNewObjectArray (interface_count, getClass (), NULL);\n   jobject *data = elements (r);\n   for (int i = 0; i < interface_count; ++i)\n-    data[i] = interfaces[i];\n+    {\n+      typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n+      data[i] = interfaces[i];\n+      if ((uaddr)data[i] < (uaddr)constants.size)\n+\tfprintf (stderr, \"ERROR !!!\\n\");\n+    }\n   return reinterpret_cast<JArray<jclass> *> (r);\n }\n \n@@ -495,7 +502,8 @@ java::lang::Class::_getMethod (jstring name, JArray<jclass> *param_types)\n   jstring partial_sig = getSignature (param_types, false);\n   jint p_len = partial_sig->length();\n   _Jv_Utf8Const *utf_name = _Jv_makeUtf8Const (name);\n-  for (Class *klass = this; klass; klass = klass->getSuperclass())\n+\n+   for (Class *klass = this; klass; klass = klass->getSuperclass())\n     {\n       int i = klass->isPrimitive () ? 0 : klass->method_count;\n       while (--i >= 0)\n@@ -699,78 +707,45 @@ java::lang::Class::newInstance (void)\n void\n java::lang::Class::finalize (void)\n {\n-#ifdef INTERPRETER\n-  JvAssert (_Jv_IsInterpretedClass (this));\n-  _Jv_UnregisterClass (this);\n-#endif\n+  engine->unregister(this);\n }\n \n // This implements the initialization process for a class.  From Spec\n // section 12.4.2.\n void\n java::lang::Class::initializeClass (void)\n {\n-  // short-circuit to avoid needless locking.\n+  // Short-circuit to avoid needless locking.\n   if (state == JV_STATE_DONE)\n     return;\n \n-  // Step 1.\n-  _Jv_MonitorEnter (this);\n+  // Step 1.  We introduce a new scope so we can synchronize more\n+  // easily.\n+  {\n+    JvSynchronize sync (this);\n \n-  if (state < JV_STATE_LINKED)\n-    {    \n-#ifdef INTERPRETER\n-      if (_Jv_IsInterpretedClass (this))\n-\t{\n-\t  // this can throw exceptions, so exit the monitor as a precaution.\n-\t  _Jv_MonitorExit (this);\n-\t  java::lang::VMClassLoader::resolveClass (this);\n-\t  _Jv_MonitorEnter (this);\n-\t}\n-      else\n-#endif\n-        {\n-\t  _Jv_PrepareCompiledClass (this);\n-\t}\n-    }\n-\n-  // Step 2.\n-  java::lang::Thread *self = java::lang::Thread::currentThread();\n-  // FIXME: `self' can be null at startup.  Hence this nasty trick.\n-  self = (java::lang::Thread *) ((long) self | 1);\n-  while (state == JV_STATE_IN_PROGRESS && thread && thread != self)\n-    wait ();\n-\n-  // Steps 3 &  4.\n-  if (state == JV_STATE_DONE)\n-    {\n-      _Jv_MonitorExit (this);\n-      return;\n-    }\n-  if (state == JV_STATE_IN_PROGRESS)\n-    {\n-      _Jv_MonitorExit (this);\n+    if (state < JV_STATE_LINKED)\n+      java::lang::VMClassLoader::resolveClass (this);\n \n-      /* Initialization in progress.  The class is linked now,\n-         so ensure internal tables are built.  */\n-      _Jv_PrepareConstantTimeTables (this);\n-      _Jv_MakeVTable(this);\n-      _Jv_LinkSymbolTable(this);\n+    // Step 2.\n+    java::lang::Thread *self = java::lang::Thread::currentThread();\n+    self = (java::lang::Thread *) ((long) self | 1);\n+    while (state == JV_STATE_IN_PROGRESS && thread && thread != self)\n+      wait ();\n \n+    // Steps 3 &  4.\n+    if (state == JV_STATE_DONE || state == JV_STATE_IN_PROGRESS)\n       return;\n-    }\n \n-  // Step 5.\n-  if (state == JV_STATE_ERROR)\n-    {\n-      _Jv_MonitorExit (this);\n+    // Step 5.\n+    if (state == JV_STATE_ERROR)\n       throw new java::lang::NoClassDefFoundError (getName());\n-    }\n \n-  // Step 6.\n-  thread = self;\n-  state = JV_STATE_IN_PROGRESS;\n-  _Jv_MonitorExit (this);\n+    // Step 6.\n+    thread = self;\n+    _Jv_Linker::wait_for_state (this, JV_STATE_LINKED);\n+    state = JV_STATE_IN_PROGRESS;\n+  }\n \n   // Step 7.\n   if (! isInterface () && superclass)\n@@ -782,24 +757,13 @@ java::lang::Class::initializeClass (void)\n       catch (java::lang::Throwable *except)\n \t{\n \t  // Caught an exception.\n-\t  _Jv_MonitorEnter (this);\n+\t  JvSynchronize sync (this);\n \t  state = JV_STATE_ERROR;\n \t  notifyAll ();\n-\t  _Jv_MonitorExit (this);\n \t  throw except;\n \t}\n     }\n \n-  _Jv_PrepareConstantTimeTables (this);\n-\n-  if (vtable == NULL)\n-    _Jv_MakeVTable(this);\n-\n-  if (otable || atable)\n-    _Jv_LinkSymbolTable(this);\n-\n-  _Jv_linkExceptionClassTable (this);\n-\n   // Steps 8, 9, 10, 11.\n   try\n     {\n@@ -821,17 +785,91 @@ java::lang::Class::initializeClass (void)\n \t      except = t;\n \t    }\n \t}\n-      _Jv_MonitorEnter (this);\n+\n+      JvSynchronize sync (this);\n       state = JV_STATE_ERROR;\n       notifyAll ();\n-      _Jv_MonitorExit (this);\n       throw except;\n     }\n \n-  _Jv_MonitorEnter (this);\n+  JvSynchronize sync (this);\n   state = JV_STATE_DONE;\n   notifyAll ();\n-  _Jv_MonitorExit (this);\n+}\n+\n+// Only used by serialization\n+java::lang::reflect::Field *\n+java::lang::Class::getPrivateField (jstring name)\n+{\n+  int hash = name->hashCode ();\n+\n+  java::lang::reflect::Field* rfield;\n+  for (int i = 0;  i < field_count;  i++)\n+    {\n+      _Jv_Field *field = &fields[i];\n+      if (! _Jv_equal (field->name, name, hash))\n+\tcontinue;\n+      rfield = new java::lang::reflect::Field ();\n+      rfield->offset = (char*) field - (char*) fields;\n+      rfield->declaringClass = this;\n+      rfield->name = name;\n+      return rfield;\n+    }\n+  jclass superclass = getSuperclass();\n+  if (superclass == NULL)\n+    return NULL;\n+  rfield = superclass->getPrivateField(name);\n+  for (int i = 0; i < interface_count && rfield == NULL; ++i)\n+    rfield = interfaces[i]->getPrivateField (name);\n+  return rfield;\n+}\n+\n+// Only used by serialization\n+java::lang::reflect::Method *\n+java::lang::Class::getPrivateMethod (jstring name, JArray<jclass> *param_types)\n+{\n+  jstring partial_sig = getSignature (param_types, false);\n+  jint p_len = partial_sig->length();\n+  _Jv_Utf8Const *utf_name = _Jv_makeUtf8Const (name);\n+  for (Class *klass = this; klass; klass = klass->getSuperclass())\n+    {\n+      int i = klass->isPrimitive () ? 0 : klass->method_count;\n+      while (--i >= 0)\n+\t{\n+\t  if (_Jv_equalUtf8Consts (klass->methods[i].name, utf_name)\n+\t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len))\n+\t    {\n+\t      // Found it.\n+\t      using namespace java::lang::reflect;\n+\n+\t      Method *rmethod = new Method ();\n+\t      rmethod->offset = ((char *) (&klass->methods[i])\n+\t\t\t\t - (char *) klass->methods);\n+\t      rmethod->declaringClass = klass;\n+\t      return rmethod;\n+\t    }\n+\t}\n+    }\n+  throw new java::lang::NoSuchMethodException (name);\n+}\n+\n+// Private accessor method for Java code to retrieve the protection domain.\n+java::security::ProtectionDomain *\n+java::lang::Class::getProtectionDomain0 ()\n+{\n+  return protectionDomain;\n+}\n+\n+JArray<jobject> *\n+java::lang::Class::getSigners()\n+{\n+  return hack_signers;\n+}\n+\n+void\n+java::lang::Class::setSigners(JArray<jobject> *s)\n+{\n+  hack_signers = s;\n }\n \n \f\n@@ -857,14 +895,19 @@ _Jv_GetMethodLocal (jclass klass, _Jv_Utf8Const *name,\n \n _Jv_Method *\n _Jv_LookupDeclaredMethod (jclass klass, _Jv_Utf8Const *name,\n-                          _Jv_Utf8Const *signature)\n+                          _Jv_Utf8Const *signature,\n+\t\t\t  jclass *declarer_result)\n {\n   for (; klass; klass = klass->getSuperclass())\n     {\n       _Jv_Method *meth = _Jv_GetMethodLocal (klass, name, signature);\n \n       if (meth)\n-        return meth;\n+\t{\n+\t  if (declarer_result)\n+\t    *declarer_result = klass;\n+\t  return meth;\n+\t}\n     }\n \n   return NULL;\n@@ -886,7 +929,7 @@ _Jv_FindMethodInCache (jclass klass,\n                        _Jv_Utf8Const *name,\n                        _Jv_Utf8Const *signature)\n {\n-  int index = name->hash16() & MCACHE_SIZE;\n+  int index = name->hash16 () & MCACHE_SIZE;\n   _Jv_mcache *mc = method_cache + index;\n   _Jv_Method *m = mc->method;\n \n@@ -904,7 +947,7 @@ _Jv_AddMethodToCache (jclass klass,\n {\n   _Jv_MonitorEnter (&java::lang::Class::class$); \n \n-  int index = method->name->hash16() & MCACHE_SIZE;\n+  int index = method->name->hash16 () & MCACHE_SIZE;\n \n   method_cache[index].method = method;\n   method_cache[index].klass = klass;\n@@ -1085,898 +1128,104 @@ _Jv_CheckArrayStore (jobject arr, jobject obj)\n     }\n }\n \n-#define INITIAL_IOFFSETS_LEN 4\n-#define INITIAL_IFACES_LEN 4\n-\n-static _Jv_IDispatchTable null_idt = { {SHRT_MAX, 0, NULL} };\n-\n-// Generate tables for constant-time assignment testing and interface\n-// method lookup. This implements the technique described by Per Bothner\n-// <per@bothner.com> on the java-discuss mailing list on 1999-09-02:\n-// http://gcc.gnu.org/ml/java/1999-q3/msg00377.html\n-void \n-_Jv_PrepareConstantTimeTables (jclass klass)\n-{  \n-  if (klass->isPrimitive () || klass->isInterface ())\n-    return;\n-  \n-  // Short-circuit in case we've been called already.\n-  if ((klass->idt != NULL) || klass->depth != 0)\n-    return;\n-\n-  // Calculate the class depth and ancestor table. The depth of a class \n-  // is how many \"extends\" it is removed from Object. Thus the depth of \n-  // java.lang.Object is 0, but the depth of java.io.FilterOutputStream \n-  // is 2. Depth is defined for all regular and array classes, but not \n-  // interfaces or primitive types.\n-   \n-  jclass klass0 = klass;\n-  jboolean has_interfaces = 0;\n-  while (klass0 != &java::lang::Object::class$)\n-    {\n-      has_interfaces += klass0->interface_count;\n-      klass0 = klass0->superclass;\n-      klass->depth++;\n-    }\n-\n-  // We do class member testing in constant time by using a small table \n-  // of all the ancestor classes within each class. The first element is \n-  // a pointer to the current class, and the rest are pointers to the \n-  // classes ancestors, ordered from the current class down by decreasing \n-  // depth. We do not include java.lang.Object in the table of ancestors, \n-  // since it is redundant.\n-\t\n-  klass->ancestors = (jclass *) _Jv_Malloc (klass->depth * sizeof (jclass));\n-  klass0 = klass;\n-  for (int index = 0; index < klass->depth; index++)\n-    {\n-      klass->ancestors[index] = klass0;\n-      klass0 = klass0->superclass;\n-    }\n-    \n-  if (java::lang::reflect::Modifier::isAbstract (klass->accflags))\n-    return;\n-  \n-  // Optimization: If class implements no interfaces, use a common\n-  // predefined interface table.\n-  if (!has_interfaces)\n-    {\n-      klass->idt = &null_idt;\n-      return;\n-    }\n-\n-  klass->idt = \n-    (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n-    \n-  _Jv_ifaces ifaces;\n-\n-  ifaces.count = 0;\n-  ifaces.len = INITIAL_IFACES_LEN;\n-  ifaces.list = (jclass *) _Jv_Malloc (ifaces.len * sizeof (jclass *));\n-\n-  int itable_size = _Jv_GetInterfaces (klass, &ifaces);\n-\n-  if (ifaces.count > 0)\n-    {\n-      klass->idt->cls.itable = \n-\t(void **) _Jv_Malloc (itable_size * sizeof (void *));\n-      klass->idt->cls.itable_length = itable_size;\n-          \n-      jshort *itable_offsets = \n-\t(jshort *) _Jv_Malloc (ifaces.count * sizeof (jshort));\n-\n-      _Jv_GenerateITable (klass, &ifaces, itable_offsets);\n-\n-      jshort cls_iindex = \n-\t_Jv_FindIIndex (ifaces.list, itable_offsets, ifaces.count);\n-\n-      for (int i=0; i < ifaces.count; i++)\n-\t{\n-\t  ifaces.list[i]->idt->iface.ioffsets[cls_iindex] =\n-\t    itable_offsets[i];\n-\t}\n-\n-      klass->idt->cls.iindex = cls_iindex;\t    \n-\n-      _Jv_Free (ifaces.list);\n-      _Jv_Free (itable_offsets);\n-    }\n-  else \n-    {\n-      klass->idt->cls.iindex = SHRT_MAX;\n-    }\n-}\n-\n-// Return index of item in list, or -1 if item is not present.\n-inline jshort\n-_Jv_IndexOf (void *item, void **list, jshort list_len)\n+jboolean\n+_Jv_IsAssignableFromSlow (jclass target, jclass source)\n {\n-  for (int i=0; i < list_len; i++)\n+  // First, strip arrays.\n+  while (target->isArray ())\n     {\n-      if (list[i] == item)\n-        return i;\n+      // If target is array, source must be as well.\n+      if (! source->isArray ())\n+       return false;\n+      target = target->getComponentType ();\n+      source = source->getComponentType ();\n     }\n-  return -1;\n-}\n \n-// Find all unique interfaces directly or indirectly implemented by klass.\n-// Returns the size of the interface dispatch table (itable) for klass, which \n-// is the number of unique interfaces plus the total number of methods that \n-// those interfaces declare. May extend ifaces if required.\n-jshort\n-_Jv_GetInterfaces (jclass klass, _Jv_ifaces *ifaces)\n-{\n-  jshort result = 0;\n-  \n-  for (int i=0; i < klass->interface_count; i++)\n-    {\n-      jclass iface = klass->interfaces[i];\n-\n-      /* Make sure interface is linked.  */\n-      _Jv_WaitForState(iface, JV_STATE_LINKED);\n+  // Quick success.\n+  if (target == &java::lang::Object::class$)\n+    return true;\n \n-      if (_Jv_IndexOf (iface, (void **) ifaces->list, ifaces->count) == -1)\n-        {\n-\t  if (ifaces->count + 1 >= ifaces->len)\n-\t    {\n-\t      /* Resize ifaces list */\n-\t      ifaces->len = ifaces->len * 2;\n-\t      ifaces->list = (jclass *) _Jv_Realloc (ifaces->list, \n-\t                     ifaces->len * sizeof(jclass));\n-\t    }\n-\t  ifaces->list[ifaces->count] = iface;\n-\t  ifaces->count++;\n+  // Ensure that the classes have their supers installed.\n+  _Jv_Linker::wait_for_state (source, JV_STATE_LOADING);\n+  _Jv_Linker::wait_for_state (target, JV_STATE_LOADING);\n \n-\t  result += _Jv_GetInterfaces (klass->interfaces[i], ifaces);\n-\t}\n-    }\n-    \n-  if (klass->isInterface())\n-    {\n-      result += klass->method_count + 1;\n-    }\n-  else\n+  do\n     {\n-      if (klass->superclass)\n-        {\n-\t  result += _Jv_GetInterfaces (klass->superclass, ifaces);\n-\t}\n+      if (source == target)\n+       return true;\n+\n+      if (target->isPrimitive () || source->isPrimitive ())\n+       return false;\n+\n+      if (target->isInterface ())\n+       {\n+         for (int i = 0; i < source->interface_count; ++i)\n+           {\n+             // We use a recursive call because we also need to\n+             // check superinterfaces.\n+             if (_Jv_IsAssignableFromSlow (target, source->getInterface (i)))\n+               return true;\n+           }\n+       }\n+      source = source->getSuperclass ();\n     }\n-  return result;\n-}\n-\n-// Fill out itable in klass, resolving method declarations in each ifaces.\n-// itable_offsets is filled out with the position of each iface in itable,\n-// such that itable[itable_offsets[n]] == ifaces.list[n].\n-void\n-_Jv_GenerateITable (jclass klass, _Jv_ifaces *ifaces, jshort *itable_offsets)\n-{\n-  void **itable = klass->idt->cls.itable;\n-  jshort itable_pos = 0;\n-\n-  for (int i=0; i < ifaces->count; i++)\n-    { \n-      jclass iface = ifaces->list[i];\n-      itable_offsets[i] = itable_pos;\n-      itable_pos = _Jv_AppendPartialITable (klass, iface, itable, itable_pos);\n-      \n-      /* Create interface dispatch table for iface */\n-      if (iface->idt == NULL)\n-\t{\n-\t  iface->idt = \n-\t    (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n-\n-\t  // The first element of ioffsets is its length (itself included).\n-\t  jshort *ioffsets = \n-\t    (jshort *) _Jv_Malloc (INITIAL_IOFFSETS_LEN * sizeof (jshort));\n-\t  ioffsets[0] = INITIAL_IOFFSETS_LEN;\n-\t  for (int i=1; i < INITIAL_IOFFSETS_LEN; i++)\n-\t    ioffsets[i] = -1;\n-\n-\t  iface->idt->iface.ioffsets = ioffsets;\t    \n-\t}\n-    }\n-}\n-\n-// Format method name for use in error messages.\n-jstring\n-_Jv_GetMethodString (jclass klass, _Jv_Utf8Const *name)\n-{\n-  jstring r = klass->name->toString();\n-  r = r->concat (JvNewStringUTF (\".\"));\n-  r = r->concat (name->toString());\n-  return r;\n-}\n-\n-void \n-_Jv_ThrowNoSuchMethodError ()\n-{\n-  throw new java::lang::NoSuchMethodError;\n-}\n-\n-// Each superinterface of a class (i.e. each interface that the class\n-// directly or indirectly implements) has a corresponding \"Partial\n-// Interface Dispatch Table\" whose size is (number of methods + 1) words.\n-// The first word is a pointer to the interface (i.e. the java.lang.Class\n-// instance for that interface).  The remaining words are pointers to the\n-// actual methods that implement the methods declared in the interface,\n-// in order of declaration.\n-//\n-// Append partial interface dispatch table for \"iface\" to \"itable\", at\n-// position itable_pos.\n-// Returns the offset at which the next partial ITable should be appended.\n-jshort\n-_Jv_AppendPartialITable (jclass klass, jclass iface, void **itable, \n-                         jshort pos)\n-{\n-  using namespace java::lang::reflect;\n-\n-  itable[pos++] = (void *) iface;\n-  _Jv_Method *meth;\n-  \n-  for (int j=0; j < iface->method_count; j++)\n-    {\n-      meth = NULL;\n-      for (jclass cl = klass; cl; cl = cl->getSuperclass())\n-        {\n-\t  meth = _Jv_GetMethodLocal (cl, iface->methods[j].name,\n-\t\t\t\t     iface->methods[j].signature);\n-\t\t \n-\t  if (meth)\n-\t    break;\n-\t}\n+  while (source != NULL);\n \n-      if (meth && (meth->name->first() == '<'))\n-\t{\n-\t  // leave a placeholder in the itable for hidden init methods.\n-          itable[pos] = NULL;\t\n-\t}\n-      else if (meth)\n-        {\n-\t  if (Modifier::isStatic(meth->accflags))\n-\t    throw new java::lang::IncompatibleClassChangeError\n-\t      (_Jv_GetMethodString (klass, meth->name));\n-\t  if (Modifier::isAbstract(meth->accflags))\n-\t    throw new java::lang::AbstractMethodError\n-\t      (_Jv_GetMethodString (klass, meth->name));\n-\t  if (! Modifier::isPublic(meth->accflags))\n-\t    throw new java::lang::IllegalAccessError\n-\t      (_Jv_GetMethodString (klass, meth->name));\n-\n-\t  itable[pos] = meth->ncode;\n-\t}\n-      else\n-        {\n-\t  // The method doesn't exist in klass. Binary compatibility rules\n-\t  // permit this, so we delay the error until runtime using a pointer\n-\t  // to a method which throws an exception.\n-\t  itable[pos] = (void *) _Jv_ThrowNoSuchMethodError;\n-\t}\n-      pos++;\n-    }\n-    \n-  return pos;\n+  return false;\n }\n \n-static _Jv_Mutex_t iindex_mutex;\n-static bool iindex_mutex_initialized = false;\n-\n-// We need to find the correct offset in the Class Interface Dispatch \n-// Table for a given interface. Once we have that, invoking an interface \n-// method just requires combining the Method's index in the interface \n-// (known at compile time) to get the correct method.  Doing a type test \n-// (cast or instanceof) is the same problem: Once we have a possible Partial \n-// Interface Dispatch Table, we just compare the first element to see if it \n-// matches the desired interface. So how can we find the correct offset?  \n-// Our solution is to keep a vector of candiate offsets in each interface \n-// (idt->iface.ioffsets), and in each class we have an index \n-// (idt->cls.iindex) used to select the correct offset from ioffsets.\n+// Lookup an interface method by name.  This is very similar to\n+// purpose to _getMethod, but the interfaces are quite different.  It\n+// might be a good idea for _getMethod to call this function.\n //\n-// Calculate and return iindex for a new class. \n-// ifaces is a vector of num interfaces that the class implements.\n-// offsets[j] is the offset in the interface dispatch table for the\n-// interface corresponding to ifaces[j].\n-// May extend the interface ioffsets if required.\n-jshort\n-_Jv_FindIIndex (jclass *ifaces, jshort *offsets, jshort num)\n-{\n-  int i;\n-  int j;\n-  \n-  // Acquire a global lock to prevent itable corruption in case of multiple \n-  // classes that implement an intersecting set of interfaces being linked\n-  // simultaneously. We can assume that the mutex will be initialized\n-  // single-threaded.\n-  if (! iindex_mutex_initialized)\n-    {\n-      _Jv_MutexInit (&iindex_mutex);\n-      iindex_mutex_initialized = true;\n-    }\n-  \n-  _Jv_MutexLock (&iindex_mutex);\n-  \n-  for (i=1;; i++)  /* each potential position in ioffsets */\n-    {\n-      for (j=0;; j++)  /* each iface */\n-        {\n-\t  if (j >= num)\n-\t    goto found;\n-\t  if (i >= ifaces[j]->idt->iface.ioffsets[0])\n-\t    continue;\n-\t  int ioffset = ifaces[j]->idt->iface.ioffsets[i];\n-\t  /* We can potentially share this position with another class. */\n-\t  if (ioffset >= 0 && ioffset != offsets[j])\n-\t    break; /* Nope. Try next i. */\t  \n-\t}\n-    }\n-  found:\n-  for (j = 0; j < num; j++)\n-    {\n-      int len = ifaces[j]->idt->iface.ioffsets[0];\n-      if (i >= len) \n-\t{\n-\t  /* Resize ioffsets. */\n-\t  int newlen = 2 * len;\n-\t  if (i >= newlen)\n-\t    newlen = i + 3;\n-\t  jshort *old_ioffsets = ifaces[j]->idt->iface.ioffsets;\n-\t  jshort *new_ioffsets = (jshort *) _Jv_Realloc (old_ioffsets, \n-\t                                  newlen * sizeof(jshort));\t  \n-\t  new_ioffsets[0] = newlen;\n-\n-\t  while (len < newlen)\n-\t    new_ioffsets[len++] = -1;\n-\t  \n-\t  ifaces[j]->idt->iface.ioffsets = new_ioffsets;\n-\t}\n-      ifaces[j]->idt->iface.ioffsets[i] = offsets[j];\n-    }\n-\n-  _Jv_MutexUnlock (&iindex_mutex);\n-\n-  return i;\n-}\n-\n-// Only used by serialization\n-java::lang::reflect::Field *\n-java::lang::Class::getPrivateField (jstring name)\n+// Return true of the method is found, with the class in FOUND_CLASS\n+// and the index in INDEX.\n+bool\n+_Jv_getInterfaceMethod (jclass search_class, jclass &found_class, int &index,\n+\t\t\tconst _Jv_Utf8Const *utf_name,  \n+\t\t\tconst _Jv_Utf8Const *utf_sig)\n {\n-  int hash = name->hashCode ();\n-\n-  java::lang::reflect::Field* rfield;\n-  for (int i = 0;  i < field_count;  i++)\n+   for (jclass klass = search_class; klass; klass = klass->getSuperclass())\n     {\n-      _Jv_Field *field = &fields[i];\n-      if (! _Jv_equal (field->name, name, hash))\n-\tcontinue;\n-      rfield = new java::lang::reflect::Field ();\n-      rfield->offset = (char*) field - (char*) fields;\n-      rfield->declaringClass = this;\n-      rfield->name = name;\n-      return rfield;\n-    }\n-  jclass superclass = getSuperclass();\n-  if (superclass == NULL)\n-    return NULL;\n-  rfield = superclass->getPrivateField(name);\n-  for (int i = 0; i < interface_count && rfield == NULL; ++i)\n-    rfield = interfaces[i]->getPrivateField (name);\n-  return rfield;\n-}\n-\n-// Only used by serialization\n-java::lang::reflect::Method *\n-java::lang::Class::getPrivateMethod (jstring name, JArray<jclass> *param_types)\n-{\n-  jstring partial_sig = getSignature (param_types, false);\n-  jint p_len = partial_sig->length();\n-  _Jv_Utf8Const *utf_name = _Jv_makeUtf8Const (name);\n-  for (Class *klass = this; klass; klass = klass->getSuperclass())\n-    {\n-      int i = klass->isPrimitive () ? 0 : klass->method_count;\n+      // FIXME: Throw an exception?\n+      if (!klass->isInterface ())\n+\treturn false;\n+      \n+      int i = klass->method_count;\n       while (--i >= 0)\n \t{\n \t  if (_Jv_equalUtf8Consts (klass->methods[i].name, utf_name)\n-\t      && _Jv_equaln (klass->methods[i].signature, partial_sig, p_len))\n+\t      && _Jv_equalUtf8Consts (klass->methods[i].signature, utf_sig))\n \t    {\n \t      // Found it.\n \t      using namespace java::lang::reflect;\n \n-\t      Method *rmethod = new Method ();\n-\t      rmethod->offset = ((char *) (&klass->methods[i])\n-\t\t\t\t - (char *) klass->methods);\n-\t      rmethod->declaringClass = klass;\n-\t      return rmethod;\n-\t    }\n-\t}\n-    }\n-  throw new java::lang::NoSuchMethodException (name);\n-}\n-\n-// Private accessor method for Java code to retrieve the protection domain.\n-java::security::ProtectionDomain *\n-java::lang::Class::getProtectionDomain0 ()\n-{\n-  return protectionDomain;\n-}\n-\n-JArray<jobject> *\n-java::lang::Class::getSigners()\n-{\n-  return hack_signers;\n-}\n-\n-void\n-java::lang::Class::setSigners(JArray<jobject> *s)\n-{\n-  hack_signers = s;\n-}\n-\n-// Functions for indirect dispatch (symbolic virtual binding) support.\n-\n-// There are two tables, atable and otable.  atable is an array of\n-// addresses, and otable is an array of offsets, and these are used\n-// for static and virtual members respectively.\n-\n-// {a,o}table_syms is an array of _Jv_MethodSymbols.  Each such symbol\n-// is a tuple of {classname, member name, signature}.\n-// _Jv_LinkSymbolTable() scans these two arrays and fills in the\n-// corresponding atable and otable with the addresses of static\n-// members and the offsets of virtual members.\n-\n-// The offset (in bytes) for each resolved method or field is placed\n-// at the corresponding position in the virtual method offset table\n-// (klass->otable). \n-\n-// The same otable and atable may be shared by many classes.\n-\n-void\n-_Jv_LinkSymbolTable(jclass klass)\n-{\n-  //// FIXME: Need to lock the tables ////\n-  \n-  int index = 0;\n-  _Jv_MethodSymbol sym;\n-  if (klass->otable == NULL\n-      || klass->otable->state != 0)\n-    goto atable;\n-   \n-  klass->otable->state = 1;\n-\n-  for (index = 0; sym = klass->otable_syms[index], sym.name != NULL; index++)\n-    {\n-      // FIXME: Why are we passing NULL as the class loader?\n-      jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n-      _Jv_Method *meth = NULL;            \n-\n-      const _Jv_Utf8Const *signature = sym.signature;\n-\n-      {\n-\tstatic char *bounce = (char *)_Jv_ThrowNoSuchMethodError;\n-\tptrdiff_t offset = (char *)(klass->vtable) - bounce;\n-\tklass->otable->offsets[index] = offset;\n-      }\n-\n-      if (target_class == NULL)\n-\tcontinue;\n-\n-      if (target_class->isInterface())\n-\t{\n-\t  // FIXME: This does not yet fully conform to binary compatibility\n-\t  // rules. It will break if a declaration is moved into a \n-\t  // superinterface.\n-\t  for (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n-\t    {\n-\t      for (int i=0; i < cls->method_count; i++)\n-\t\t{\n-\t\t  meth = &cls->methods[i];\n-\t\t  if (_Jv_equalUtf8Consts (sym.name, meth->name)\n-\t\t      && _Jv_equalUtf8Consts (signature, meth->signature))\n-\t\t    {\n-\t\t      klass->otable->offsets[index] = i + 1;\n-\t\t      goto found;\n-\t\t    }\n-\t\t}\n-\t    \n-\t    }\n-\tfound:\n-\t  continue;\n-\t}\n-\n-      // We're looking for a field or a method, and we can tell\n-      // which is needed by looking at the signature.\n-      if (signature->first() == '(' && signature->len() >= 2)\n-\t{\n- \t  // If the target class does not have a vtable_method_count yet, \n-\t  // then we can't tell the offsets for its methods, so we must lay \n-\t  // it out now.\n-\t  if (target_class->vtable_method_count == -1)\n-\t    {\n-\t      JvSynchronize sync (target_class);\n-\t      _Jv_LayoutVTableMethods (target_class);\n-\t    }\n-\t\t\n-\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n-\t\t\t\t\t  sym.signature);\n-\t\t\n-\t  if (meth != NULL)\n-\t    {\n-\t      klass->otable->offsets[index] = \n-\t\t_Jv_VTable::idx_to_offset (meth->index);\t      \n-\t    }\n-\n-\t  continue;\n-\t}\n-\n-      // try fields\n-      {\n-\t_Jv_Field *the_field = NULL;\n-\n-\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n-\t  {\n-\t    for (int i = 0; i < cls->field_count; i++)\n-\t      {\n-\t\t_Jv_Field *field = &cls->fields[i];\n-\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n-\t\t  continue;\n-\n-\t\t// FIXME: What access checks should we perform here?\n-// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n-// \t\t  {\n-\n-\t\tif (!field->isResolved ())\n-\t\t  _Jv_ResolveField (field, cls->loader);\n-\n-// \t\tif (field_type != 0 && field->type != field_type)\n-// \t\t  throw new java::lang::LinkageError\n-// \t\t    (JvNewStringLatin1 \n-// \t\t     (\"field type mismatch with different loaders\"));\n-\n-\t\tthe_field = field;\n-\t\tgoto end_of_field_search;\n-\t      }\n-\t  }\n-      end_of_field_search:\n-\tif (the_field != NULL)\n-\t  {\n-\t    if (the_field->flags & 0x0008 /* Modifier::STATIC */)\n-\t      {\t      \n-\t\tthrow new java::lang::IncompatibleClassChangeError;\n-\t      }\n-\t    else\n-\t      {\n-\t\tklass->otable->offsets[index] = the_field->u.boffset;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    throw new java::lang::NoSuchFieldError\n-\t      (_Jv_NewStringUtf8Const (sym.name));\n-\t  }\n-      }\n-    }\n-\n- atable:\n-  if (klass->atable == NULL\n-      || klass->atable->state != 0)\n-    return;\n-\n-  klass->atable->state = 1;\n-\n-  for (index = 0; sym = klass->atable_syms[index], sym.name != NULL; index++)\n-    {\n-      // FIXME: Why are we passing NULL as the class loader?\n-      jclass target_class = _Jv_FindClass (sym.class_name, NULL);\n-      _Jv_Method *meth = NULL;            \n-      const _Jv_Utf8Const *signature = sym.signature;\n-\n-      // ??? Setting this pointer to null will at least get us a\n-      // NullPointerException\n-      klass->atable->addresses[index] = NULL;\n-      \n-      if (target_class == NULL)\n-\tcontinue;\n-      \n-      // We're looking for a static field or a static method, and we\n-      // can tell which is needed by looking at the signature.\n-      if (signature->first() == '(' && signature->len() >= 2)\n-\t{\n- \t  // If the target class does not have a vtable_method_count yet, \n-\t  // then we can't tell the offsets for its methods, so we must lay \n-\t  // it out now.\n-\t  if (target_class->vtable_method_count == -1)\n-\t    {\n-\t      JvSynchronize sync (target_class);\n-\t      _Jv_LayoutVTableMethods (target_class);\n-\t    }\n-\t  \n-\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name,\n-\t\t\t\t\t  sym.signature);\n-\t  \n-\t  if (meth != NULL)\n-\t    {\n-\t      if (meth->ncode) // Maybe abstract?\n-\t\tklass->atable->addresses[index] = meth->ncode;\n-#ifdef INTERPRETER\n-\t      else if (_Jv_IsInterpretedClass (target_class))\n-\t\t_Jv_Defer_Resolution (target_class, meth, \n-\t\t\t\t      &klass->atable->addresses[index]);\n-#endif\n-\t    }\n-\t  else\n-\t    klass->atable->addresses[index] = (void *)_Jv_ThrowNoSuchMethodError;\n-\n-\t  continue;\n-\t}\n-\n-      // try fields\n-      {\n-\t_Jv_Field *the_field = NULL;\n-\n-\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n-\t  {\n-\t    for (int i = 0; i < cls->field_count; i++)\n-\t      {\n-\t\t_Jv_Field *field = &cls->fields[i];\n-\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n-\t\t  continue;\n-\n-\t\t// FIXME: What access checks should we perform here?\n-// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n-// \t\t  {\n-\n-\t\tif (!field->isResolved ())\n-\t\t  _Jv_ResolveField (field, cls->loader);\n-\t\t\n-// \t\tif (field_type != 0 && field->type != field_type)\n-// \t\t  throw new java::lang::LinkageError\n-// \t\t    (JvNewStringLatin1 \n-// \t\t     (\"field type mismatch with different loaders\"));\n-\n-\t\tthe_field = field;\n-\t\tgoto end_of_static_field_search;\n-\t      }\n-\t  }\n-      end_of_static_field_search:\n-\tif (the_field != NULL)\n-\t  {\n-\t    if (the_field->flags & 0x0008 /* Modifier::STATIC */)\n-\t      {\t      \n-\t\tklass->atable->addresses[index] = the_field->u.addr;\n-\t      }\n-\t    else\n-\t      {\n-\t\tthrow new java::lang::IncompatibleClassChangeError;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    throw new java::lang::NoSuchFieldError\n-\t      (_Jv_NewStringUtf8Const (sym.name));\n-\t  }\n-      }\n-    }\n-}\n-\n-\n-// For each catch_record in the list of caught classes, fill in the\n-// address field.\n-void \n-_Jv_linkExceptionClassTable (jclass self)\n-{\n-  struct _Jv_CatchClass *catch_record = self->catch_classes;\n-  if (!catch_record || catch_record->classname)\n-    return;  \n-  catch_record++;\n-  while (catch_record->classname)\n-    {\n-      jclass target_class = _Jv_FindClass (catch_record->classname,  \n-\t\t\t\t\t   self->getClassLoaderInternal ());\n-      *catch_record->address = target_class;\n-      catch_record++;\n-    }\n-  self->catch_classes->classname = (_Jv_Utf8Const *)-1;\n-}\n-  \n-// This is put in empty vtable slots.\n-static void\n-_Jv_abstractMethodError (void)\n-{\n-  throw new java::lang::AbstractMethodError();\n-}\n-\n-// Set itable method indexes for members of interface IFACE.\n-void\n-_Jv_LayoutInterfaceMethods (jclass iface)\n-{\n-  if (! iface->isInterface())\n-    return;\n-  \n-  // itable indexes start at 1. \n-  // FIXME: Static initalizers currently get a NULL placeholder entry in the\n-  // itable so they are also assigned an index here.\n-  for (int i = 0; i < iface->method_count; i++)\n-    iface->methods[i].index = i + 1;\n-}\n-\n-// Prepare virtual method declarations in KLASS, and any superclasses as \n-// required, by determining their vtable index, setting method->index, and\n-// finally setting the class's vtable_method_count. Must be called with the\n-// lock for KLASS held.\n-void\n-_Jv_LayoutVTableMethods (jclass klass)\n-{\n-  if (klass->vtable != NULL || klass->isInterface() \n-      || klass->vtable_method_count != -1)\n-    return;\n-\n-  jclass superclass = klass->superclass;\n-\n-  typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n+\t      // FIXME: Method must be public.  Throw an exception?\n+\t      if (! Modifier::isPublic (klass->methods[i].accflags))\n+\t\tbreak;\n \n-  // If superclass looks like a constant pool entry,\n-  // resolve it now.\n-  if ((uaddr) superclass < (uaddr) klass->constants.size)\n-    {\n-      if (klass->state < JV_STATE_LINKED)\n-\t{\n-\t  _Jv_Utf8Const *name = klass->constants.data[(uaddr) superclass].utf8;\n-\t  superclass = _Jv_FindClass (name, klass->loader);\n-\t  if (! superclass)\n-\t    {\n-\t      throw new java::lang::NoClassDefFoundError (name->toString());\n+\t      found_class = klass;\n+\t      // Interface method indexes count from 1.\n+\t      index = i+1;\n+\t      return true;\n \t    }\n \t}\n-      else\n-\tsuperclass = klass->constants.data[(uaddr) superclass].clazz;\n-    }\n-\n-  if (superclass != NULL && superclass->vtable_method_count == -1)\n-    {\n-      JvSynchronize sync (superclass);\n-      _Jv_LayoutVTableMethods (superclass);\n-    }\n-\n-  int index = (superclass == NULL ? 0 : superclass->vtable_method_count);\n-\n-  for (int i = 0; i < klass->method_count; ++i)\n-    {\n-      _Jv_Method *meth = &klass->methods[i];\n-      _Jv_Method *super_meth = NULL;\n-\n-      if (! _Jv_isVirtualMethod (meth))\n-\tcontinue;\n-\n-      // FIXME: Must check that we don't override:\n-      // - Package-private method where superclass is in different package.\n-      // - Final or less-accessible declaration in superclass (check binary \n-      //   spec, do we allocate new vtable entry or put throw node in vtable?)\n-      // - Static or private method in superclass.\n-\n-      if (superclass != NULL)\n-\t{\n-\t  super_meth = _Jv_LookupDeclaredMethod (superclass, meth->name, \n-\t\t\t\t\t\t meth->signature);\n-\t}\n-\n-      if (super_meth)\n-        meth->index = super_meth->index;\n-      else\n-\tmeth->index = index++;\n-    }\n-\n-  klass->vtable_method_count = index;\n-}\n-\n-// Set entries in VTABLE for virtual methods declared in KLASS. If\n-// KLASS has an immediate abstract parent, recursively do its methods\n-// first.  FLAGS is used to determine which slots we've actually set.\n-void\n-_Jv_SetVTableEntries (jclass klass, _Jv_VTable *vtable, jboolean *flags)\n-{\n-  using namespace java::lang::reflect;\n-\n-  jclass superclass = klass->getSuperclass();\n-\n-  if (superclass != NULL && (superclass->getModifiers() & Modifier::ABSTRACT))\n-    _Jv_SetVTableEntries (superclass, vtable, flags);\n-\n-  for (int i = klass->method_count - 1; i >= 0; i--)\n-    {\n-      _Jv_Method *meth = &klass->methods[i];\n-      if (meth->index == (_Jv_ushort) -1)\n-\tcontinue;\n-      if ((meth->accflags & Modifier::ABSTRACT))\n-\t{\n-\t  vtable->set_method(meth->index, (void *) &_Jv_abstractMethodError);\n-\t  flags[meth->index] = false;\n-\t}\n-      else\n-\t{\n-\t  vtable->set_method(meth->index, meth->ncode);\n-\t  flags[meth->index] = true;\n-\t}\n     }\n-}\n-\n-// Allocate and lay out the virtual method table for KLASS. This will also\n-// cause vtables to be generated for any non-abstract superclasses, and\n-// virtual method layout to occur for any abstract superclasses. Must be\n-// called with monitor lock for KLASS held.\n-void\n-_Jv_MakeVTable (jclass klass)\n-{\n-  using namespace java::lang::reflect;  \n \n-  if (klass->vtable != NULL || klass->isInterface() \n-      || (klass->accflags & Modifier::ABSTRACT))\n-    return;\n-\n-  // Class must be laid out before we can create a vtable. \n-  if (klass->vtable_method_count == -1)\n-    _Jv_LayoutVTableMethods (klass);\n-\n-  // Allocate the new vtable.\n-  _Jv_VTable *vtable = _Jv_VTable::new_vtable (klass->vtable_method_count);\n-  klass->vtable = vtable;\n-\n-  jboolean flags[klass->vtable_method_count];\n-  for (int i = 0; i < klass->vtable_method_count; ++i)\n-    flags[i] = false;\n-\n-  // Copy the vtable of the closest non-abstract superclass.\n-  jclass superclass = klass->superclass;\n-  if (superclass != NULL)\n+  // If we haven't found a match, and this class is an interface, then\n+  // check all the superinterfaces.\n+  if (search_class->isInterface())\n     {\n-      while ((superclass->accflags & Modifier::ABSTRACT) != 0)\n-\tsuperclass = superclass->superclass;\n-\n-      if (superclass->vtable == NULL)\n-\t{\n-\t  JvSynchronize sync (superclass);\n-\t  _Jv_MakeVTable (superclass);\n-\t}\n-\n-      for (int i = 0; i < superclass->vtable_method_count; ++i)\n+      for (int i = 0; i < search_class->interface_count; ++i)\n \t{\n-\t  vtable->set_method (i, superclass->vtable->get_method (i));\n-\t  flags[i] = true;\n+\t  using namespace java::lang::reflect;\n+\t  bool found = _Jv_getInterfaceMethod (search_class->interfaces[i], \n+\t\t\t\t\t   found_class, index,\n+\t\t\t\t\t   utf_name, utf_sig);\n+\t  if (found)\n+\t    return true;\n \t}\n     }\n \n-  // Set the class pointer and GC descriptor.\n-  vtable->clas = klass;\n-  vtable->gc_descr = _Jv_BuildGCDescr (klass);\n-\n-  // For each virtual declared in klass and any immediate abstract \n-  // superclasses, set new vtable entry or override an old one.\n-  _Jv_SetVTableEntries (klass, vtable, flags);\n-\n-  // It is an error to have an abstract method in a concrete class.\n-  if (! (klass->accflags & Modifier::ABSTRACT))\n-    {\n-      for (int i = 0; i < klass->vtable_method_count; ++i)\n-\tif (! flags[i])\n-\t  {\n-\t    using namespace java::lang;\n-\t    while (klass != NULL)\n-\t      {\n-\t\tfor (int j = 0; j < klass->method_count; ++j)\n-\t\t  {\n-\t\t    if (klass->methods[i].index == i)\n-\t\t      {\n-\t\t\tStringBuffer *buf = new StringBuffer ();\n-\t\t\tbuf->append (_Jv_NewStringUtf8Const (klass->methods[i].name));\n-\t\t\tbuf->append ((jchar) ' ');\n-\t\t\tbuf->append (_Jv_NewStringUtf8Const (klass->methods[i].signature));\n-\t\t\tthrow new AbstractMethodError (buf->toString ());\n-\t\t      }\n-\t\t  }\n-\t\tklass = klass->getSuperclass ();\n-\t      }\n-\t    // Couldn't find the name, which is weird.\n-\t    // But we still must throw the error.\n-\t    throw new AbstractMethodError ();\n-\t  }\n-    }\n+  return false;\n }"}, {"sha": "dd5cd463cfaa83a5fb91a4793527c329bd54cdca", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 21, "deletions": 173, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -18,6 +18,7 @@ details.  */\n \n #include <gcj/cni.h>\n #include <jvm.h>\n+#include <execution.h>\n \n #include <java-threads.h>\n #include <java-interp.h>\n@@ -33,6 +34,7 @@ details.  */\n #include <java/lang/ClassNotFoundException.h>\n #include <java/lang/ClassCircularityError.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/ClassFormatError.h>\n #include <java/lang/VirtualMachineError.h>\n #include <java/lang/VMClassLoader.h>\n #include <java/lang/reflect/Modifier.h>\n@@ -41,156 +43,6 @@ details.  */\n #include <java/io/Serializable.h>\n #include <java/lang/Cloneable.h>\n \n-void\n-_Jv_WaitForState (jclass klass, int state)\n-{\n-  if (klass->state >= state)\n-    return;\n-  \n-  _Jv_MonitorEnter (klass) ;\n-\n-  if (klass->state == JV_STATE_COMPILED)\n-    {\n-      klass->state = JV_STATE_LOADED;\n-      if (gcj::verbose_class_flag)\n-\tfprintf (stderr, \"[Loaded (pre-compiled) %s]\\n\", klass->name->chars());\n-    }\n-  if (state == JV_STATE_LINKED)\n-    {\n-      // Must call _Jv_PrepareCompiledClass while holding the class\n-      // mutex.\n-#ifdef INTERPRETER\n-      if (_Jv_IsInterpretedClass (klass))\n-\t_Jv_PrepareClass (klass);\n-#endif\n-      _Jv_PrepareCompiledClass (klass);\n-      _Jv_MonitorExit (klass);\n-      return;\n-    }\n-\t\n-  java::lang::Thread *self = java::lang::Thread::currentThread();\n-\n-  // this is similar to the strategy for class initialization.\n-  // if we already hold the lock, just leave.\n-  while (klass->state <= state\n-\t && klass->thread \n-\t && klass->thread != self)\n-    klass->wait ();\n-\n-  _Jv_MonitorExit (klass);\n-\n-  if (klass->state == JV_STATE_ERROR)\n-    throw new java::lang::LinkageError;\n-}\n-\n-typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n-\n-/** This function does class-preparation for compiled classes.  \n-    NOTE: It contains replicated functionality from\n-    _Jv_ResolvePoolEntry, and this is intentional, since that function\n-    lives in resolve.cc which is entirely conditionally compiled.\n- */\n-void\n-_Jv_PrepareCompiledClass (jclass klass)\n-{\n-  jint state = klass->state;\n-  if (state >= JV_STATE_LINKED)\n-    return;\n-\n-  // Short-circuit, so that mutually dependent classes are ok.\n-  klass->state = JV_STATE_LINKED;\n-\n-  _Jv_Constants *pool = &klass->constants;\n-\n-  // Resolve class constants first, since other constant pool\n-  // entries may rely on these.\n-  for (int index = 1; index < pool->size; ++index)\n-    {\n-      if (pool->tags[index] == JV_CONSTANT_Class)\n-\t{\n-\t  _Jv_Utf8Const *name = pool->data[index].utf8;\n-\t  \n-\t  jclass found;\n-\t  if (name->first() == '[')\n-\t    found = _Jv_FindClassFromSignature (name->chars(),\n-\t\t\t\t\t\tklass->loader);\n-\t  else\n-\t    found = _Jv_FindClass (name, klass->loader);\n-\t\t\n-\t  if (! found)\n-\t    {\n-\t      jstring str = name->toString();\n-\t      throw new java::lang::NoClassDefFoundError (str);\n-\t    }\n-\n-\t  pool->data[index].clazz = found;\n-\t  pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-\t}\n-    }\n-\n-  // If superclass looks like a constant pool entry,\n-  // resolve it now.\n-  if ((uaddr) klass->superclass < pool->size)\n-    klass->superclass = pool->data[(uaddr) klass->superclass].clazz;\n-\n-  // Likewise for interfaces.\n-  for (int i = 0; i < klass->interface_count; i++)\n-    if ((uaddr) klass->interfaces[i] < pool->size)\n-      klass->interfaces[i] = pool->data[(uaddr) klass->interfaces[i]].clazz;\n-\n-  // Resolve the remaining constant pool entries.\n-  for (int index = 1; index < pool->size; ++index)\n-    {\n-      if (pool->tags[index] == JV_CONSTANT_String)\n-\t{\n-\t  jstring str;\n-\n-\t  str = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n-\t  pool->data[index].o = str;\n-\t  pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-\t}\n-    }\n-\n-#ifdef INTERPRETER\n-  // FIXME: although the comment up top says that this function is\n-  // only called for compiled classes, it is actually called for every\n-  // class.\n-  if (! _Jv_IsInterpretedClass (klass))\n-    {\n-#endif /* INTERPRETER */\n-      jfieldID f = JvGetFirstStaticField (klass);\n-      for (int n = JvNumStaticFields (klass); n > 0; --n)\n-\t{\n-\t  int mod = f->getModifiers ();\n-\t  // If we have a static String field with a non-null initial\n-\t  // value, we know it points to a Utf8Const.\n-\t  _Jv_ResolveField(f, klass->loader);\n-\t  if (f->getClass () == &java::lang::String::class$\n-\t      && java::lang::reflect::Modifier::isStatic (mod))\n-\t    {\n-\t      jstring *strp = (jstring *) f->u.addr;\n-\t      if (*strp)\n-\t\t*strp = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) *strp);\n-\t    }\n-\t  f = f->getNextField ();\n-\t}\n-#ifdef INTERPRETER\n-    }\n-#endif /* INTERPRETER */\n-\n-  if (klass->isInterface ())\n-    _Jv_LayoutInterfaceMethods (klass);\n-\n-  if (state == JV_STATE_COMPILED && gcj::verbose_class_flag)\n-    fprintf (stderr, \"[Loaded (pre-compiled) %s]\\n\",\n-\t     klass->name->chars());\n-\n-  klass->notifyAll ();\n-\n-  _Jv_PushClass (klass);\n-}\n-\n-\n //\n //  A single class can have many \"initiating\" class loaders,\n //  and a single \"defining\" class loader.  The Defining\n@@ -221,6 +73,8 @@ static _Jv_LoaderInfo *initiated_classes[HASH_LEN];\n static jclass loaded_classes[HASH_LEN];\n \n // This is the root of a linked list of classes\n+static jclass stack_head;\n+\n \n \f\n \n@@ -323,11 +177,6 @@ _Jv_RegisterClasses (const jclass *classes)\n       jclass klass = *classes;\n \n       (*_Jv_RegisterClassHook) (klass);\n-\n-      // registering a compiled class causes\n-      // it to be immediately \"prepared\".  \n-      if (klass->state == JV_STATE_NOTHING)\n-\tklass->state = JV_STATE_COMPILED;\n     }\n }\n \n@@ -341,11 +190,6 @@ _Jv_RegisterClasses_Counted (const jclass * classes, size_t count)\n       jclass klass = classes[i];\n \n       (*_Jv_RegisterClassHook) (klass);\n-\n-      // registering a compiled class causes\n-      // it to be immediately \"prepared\".  \n-      if (klass->state == JV_STATE_NOTHING)\n-\tklass->state = JV_STATE_COMPILED;\n     }\n }\n \n@@ -354,8 +198,10 @@ _Jv_RegisterClassHookDefault (jclass klass)\n {\n   jint hash = HASH_UTF (klass->name);\n \n-  jclass check_class = loaded_classes[hash];\n-\n+  // The BC ABI makes this check unnecessary: we always resolve all\n+  // data references via the appropriate class loader, so the kludge\n+  // that required this check has gone.\n+#if 0\n   // If the class is already registered, don't re-register it.\n   while (check_class != NULL)\n     {\n@@ -381,7 +227,11 @@ _Jv_RegisterClassHookDefault (jclass klass)\n \n       check_class = check_class->next;\n     }\n+#endif\n \n+  // FIXME: this is really bogus!\n+  if (! klass->engine)\n+    klass->engine = &_Jv_soleCompiledEngine;\n   klass->next = loaded_classes[hash];\n   loaded_classes[hash] = klass;\n }\n@@ -442,7 +292,7 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n     {\n       // we need classes to be in the hash while\n       // we're loading, so that they can refer to themselves. \n-      _Jv_WaitForState (klass, JV_STATE_LOADED);\n+      _Jv_Linker::wait_for_state (klass, JV_STATE_LOADED);\n     }\n \n   return klass;\n@@ -555,7 +405,7 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n   // cache one and reuse it. It is not necessary to synchronize this.\n   if (!array_idt)\n     {\n-      _Jv_PrepareConstantTimeTables (array_class);\n+      _Jv_Linker::wait_for_state(array_class, JV_STATE_PREPARED);\n       array_idt = array_class->idt;\n       array_depth = array_class->depth;\n       array_ancestors = array_class->ancestors;\n@@ -569,19 +419,19 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n \n   using namespace java::lang::reflect;\n   {\n-    // Array classes are \"abstract final\"...\n-    _Jv_ushort accflags = Modifier::FINAL | Modifier::ABSTRACT;\n-    // ... and inherit accessibility from element type, per vmspec 5.3.3.2\n-    accflags |= (element->accflags & Modifier::PUBLIC);\n-    accflags |= (element->accflags & Modifier::PROTECTED);\n-    accflags |= (element->accflags & Modifier::PRIVATE);      \n+    // Array classes are \"abstract final\" and inherit accessibility\n+    // from element type, per vmspec 5.3.3.2\n+    _Jv_ushort accflags = (Modifier::FINAL | Modifier::ABSTRACT\n+\t\t\t   | (element->accflags\n+\t\t\t      & (Modifier::PUBLIC | Modifier::PROTECTED\n+\t\t\t\t | Modifier::PRIVATE)));\n     array_class->accflags = accflags;\n   }\n \n   // An array class has no visible instance fields. \"length\" is invisible to \n   // reflection.\n \n-  // say this class is initialized and ready to go!\n+  // Say this class is initialized and ready to go!\n   array_class->state = JV_STATE_DONE;\n \n   // vmspec, section 5.3.3 describes this\n@@ -591,8 +441,6 @@ _Jv_NewArrayClass (jclass element, java::lang::ClassLoader *loader,\n   element->arrayclass = array_class;\n }\n \n-static jclass stack_head;\n-\n // These two functions form a stack of classes.   When a class is loaded\n // it is pushed onto the stack by the class loader; this is so that\n // StackTrace can quickly determine which classes have been loaded."}, {"sha": "332f2c7b625df1b1006d0c80fe2a53b4263dd379", "filename": "libjava/java/lang/natRuntime.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatRuntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatRuntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatRuntime.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // natRuntime.cc - Implementation of native side of Runtime class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -388,8 +388,11 @@ java::lang::Runtime::insertSystemProperties (java::util::Properties *newprops)\n \tnewprops->put(JvNewStringLatin1 (Prop), JvNewStringLatin1 (Val))\n \n   // A mixture of the Java Product Versioning Specification\n-  // (introduced in 1.2), and earlier versioning properties.\n-  SET (\"java.version\", GCJVERSION);\n+  // (introduced in 1.2), and earlier versioning properties.  Some\n+  // programs rely on seeing values that they expect, so we claim to\n+  // be a 1.4-ish VM for their sake.\n+  SET (\"java.version\", \"1.4.2\");\n+  SET (\"java.runtime.version\", \"1.4.2\");\n   SET (\"java.vendor\", \"Free Software Foundation, Inc.\");\n   SET (\"java.vendor.url\", \"http://gcc.gnu.org/java/\");\n   SET (\"java.class.version\", \"46.0\");\n@@ -399,7 +402,7 @@ java::lang::Runtime::insertSystemProperties (java::util::Properties *newprops)\n   SET (\"java.vm.version\", __VERSION__);\n   SET (\"java.vm.vendor\", \"Free Software Foundation, Inc.\");\n   SET (\"java.vm.name\", \"GNU libgcj\");\n-  SET (\"java.specification.version\", \"1.3\");\n+  SET (\"java.specification.version\", \"1.4\");\n   SET (\"java.specification.name\", \"Java(tm) Platform API Specification\");\n   SET (\"java.specification.vendor\", \"Sun Microsystems Inc.\");\n "}, {"sha": "e2558f4f7473ab4d8484b47ebb24a63ff22623ed", "filename": "libjava/java/lang/natString.cc", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatString.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatString.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatString.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,7 +1,6 @@\n // natString.cc - Implementation of java.lang.String native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004\n-   Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -57,7 +56,7 @@ static int strhash_size = 0;  /* Number of slots available in strhash.\n jstring*\n _Jv_StringFindSlot (jchar* data, jint len, jint hash)\n {\n-  JvSynchronize sync (&StringClass);\n+  JvSynchronize sync (&java::lang::String::class$);\n \n   int start_index = hash & (strhash_size - 1);\n   int deleted_index = -1;\n@@ -120,7 +119,7 @@ _Jv_StringGetSlot (jstring str)\n static void\n rehash ()\n {\n-  JvSynchronize sync (&StringClass);\n+  JvSynchronize sync (&java::lang::String::class$);\n \n   if (strhash == NULL)\n     {\n@@ -167,7 +166,7 @@ rehash ()\n jstring\n java::lang::String::intern()\n {\n-  JvSynchronize sync (&StringClass);\n+  JvSynchronize sync (&java::lang::String::class$);\n   if (3 * strhash_count >= 2 * strhash_size)\n     rehash();\n   jstring* ptr = _Jv_StringGetSlot(this);\n@@ -194,7 +193,7 @@ java::lang::String::intern()\n void\n _Jv_FinalizeString (jobject obj)\n {\n-  JvSynchronize sync (&StringClass);\n+  JvSynchronize sync (&java::lang::String::class$);\n \n   // We might not actually have intern()d any strings at all, if\n   // we're being called from Reference.\n@@ -286,9 +285,9 @@ _Jv_NewStringUtf8Const (Utf8Const* str)\n     }\n   chrs -= length;\n \n-  JvSynchronize sync (&StringClass);\n+  JvSynchronize sync (&java::lang::String::class$);\n   if (3 * strhash_count >= 2 * strhash_size)\n-    rehash ();\n+    rehash();\n   jstring* ptr = _Jv_StringFindSlot (chrs, length, hash);\n   if (*ptr != NULL && *ptr != DELETED_STRING)\n     return (jstring) UNMASK_PTR (*ptr);\n@@ -527,7 +526,7 @@ java::lang::String::equals(jobject anObject)\n     return false;\n   if (anObject == this)\n     return true;\n-  if (anObject->getClass() != &StringClass)\n+  if (anObject->getClass() != &java::lang::String::class$)\n     return false;\n   jstring other = (jstring) anObject;\n   if (count != other->count)"}, {"sha": "841b3e0789e1d60ef630ce0425a5915e3511f722", "filename": "libjava/java/lang/natVMClassLoader.cc", "status": "modified", "additions": 74, "deletions": 62, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -22,13 +22,29 @@ details.  */\n #include <java-interp.h>\n \n #include <java/lang/VMClassLoader.h>\n+#include <java/lang/VMCompiler.h>\n #include <gnu/gcj/runtime/VMClassLoader.h>\n #include <java/lang/ClassLoader.h>\n #include <java/lang/Class.h>\n #include <java/lang/Throwable.h>\n #include <java/security/ProtectionDomain.h>\n #include <java/lang/ClassFormatError.h>\n \n+void\n+java::lang::VMClassLoader::resolveClass (jclass klass)\n+{\n+  JvSynchronize sync (klass);\n+  try\n+    {\n+      _Jv_Linker::wait_for_state (klass, JV_STATE_LINKED);\n+    }\n+  catch (java::lang::Throwable *x)\n+    {\n+      klass->set_state(JV_STATE_ERROR);\n+      transformException(klass, x);\n+    }\n+}\n+\n java::lang::Class *\n java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *loader,\n \t\t\t\t\tjstring name,\n@@ -37,72 +53,61 @@ java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *loader,\n \t\t\t\t\tjint length,\n \t\t\t\t\tjava::security::ProtectionDomain *pd)\n {\n-#ifdef INTERPRETER\n-  jclass klass;\n-  klass = new java::lang::Class ();\n-  klass->aux_info = (void *) _Jv_AllocBytes (sizeof (_Jv_InterpClass));\n-\n-  // Synchronize on the class, so that it is not attempted initialized\n-  // until we're done loading.\n-  JvSynchronize sync (klass);\n-\n-  // Record the defining loader.  For the system class loader, we\n-  // record NULL.\n-  if (loader != java::lang::ClassLoader::getSystemClassLoader())\n-    klass->loader = loader;\n-\n-  if (name != 0)\n-    {\n-      _Jv_Utf8Const *name2 = _Jv_makeUtf8Const (name);\n-\n-      if (! _Jv_VerifyClassName (name2))\n-\tthrow new java::lang::ClassFormatError\n-\t  (JvNewStringLatin1 (\"erroneous class name\"));\n-\n-      klass->name = name2;\n-    }\n+  jclass klass = VMCompiler::compileClass(loader, name, data,\n+\t\t\t\t\t  offset, length, pd);\n \n-  try\n+  if (klass != NULL)\n     {\n-      _Jv_DefineClass (klass, data, offset, length);\n+      JvSynchronize sync (&java::lang::Class::class$);\n+      _Jv_RegisterClass (klass);\n     }\n-  catch (java::lang::Throwable *ex)\n+#ifdef INTERPRETER\n+  else\n     {\n-      klass->state = JV_STATE_ERROR;\n-      klass->notifyAll ();\n-\n-      _Jv_UnregisterClass (klass);\n-\n-      // If EX is not a ClassNotFoundException, that's ok, because we\n-      // account for the possibility in defineClass().\n-      throw ex;\n+      klass = new java::lang::Class ();\n+\n+      // Synchronize on the class, so that it is not attempted initialized\n+      // until we're done loading.\n+      JvSynchronize sync (klass);\n+\n+      // Record the defining loader.  For the system class loader, we\n+      // record NULL.\n+      if (loader != java::lang::ClassLoader::getSystemClassLoader())\n+\tklass->loader = loader;\n+\n+      if (name != 0)\n+\t{\n+\t  _Jv_Utf8Const *name2 = _Jv_makeUtf8Const (name);\n+\n+\t  if (! _Jv_VerifyClassName (name2))\n+\t    throw new java::lang::ClassFormatError\n+\t      (JvNewStringLatin1 (\"erroneous class name\"));\n+\n+\t  klass->name = name2;\n+\t}\n+\n+      try\n+\t{\n+\t  _Jv_DefineClass (klass, data, offset, length, pd);\n+\t}\n+      catch (java::lang::Throwable *ex)\n+\t{\n+\t  klass->state = JV_STATE_ERROR;\n+\t  klass->notifyAll ();\n+\n+\t  _Jv_UnregisterClass (klass);\n+\n+\t  // If EX is not a ClassNotFoundException, that's ok, because we\n+\t  // account for the possibility in defineClass().\n+\t  throw ex;\n+\t}\n+\n+      // if everything proceeded sucessfully, we're loaded.\n+      JvAssert (klass->state == JV_STATE_LOADED);\n     }\n-    \n-  klass->protectionDomain = pd;\n-\n-  // if everything proceeded sucessfully, we're loaded.\n-  JvAssert (klass->state == JV_STATE_LOADED);\n+#endif // INTERPRETER\n \n   return klass;\n-\n-#else // INTERPRETER\n-\n-  return 0;\n-#endif\n-}\n-\n-// Finish linking a class.  Only called from ClassLoader::resolveClass.\n-void\n-java::lang::VMClassLoader::linkClass0 (java::lang::Class *klass)\n-{\n-  _Jv_WaitForState (klass, JV_STATE_LINKED);\n-}\n-\n-void\n-java::lang::VMClassLoader::markClassErrorState0 (java::lang::Class *klass)\n-{\n-  klass->state = JV_STATE_ERROR;\n-  klass->notifyAll ();\n }\n \n java::lang::ClassLoader *\n@@ -125,9 +130,16 @@ jclass\n java::lang::VMClassLoader::loadClass(jstring name, jboolean resolve)\n {\n   _Jv_Utf8Const *utf = _Jv_makeUtf8Const (name);\n-  // FIXME: we culd make _Jv_FindClassFromSignature a template.\n   jclass klass = _Jv_FindClassInCache (utf, NULL);\n-  if (klass && resolve)\n-    _Jv_InitClass (klass);\n+  if (klass)\n+    {\n+      // We never want to return a class without its supers linked.\n+      // It isn't clear from the spec, but this is what other\n+      // implementations do in practice.\n+      if (resolve)\n+\t_Jv_InitClass (klass);\n+      else\n+\t_Jv_Linker::wait_for_state (klass, JV_STATE_LOADING);\n+    }\n   return klass;\n }"}, {"sha": "7eb032227abc2c83a30a9eeb4f25a33785aca431", "filename": "libjava/java/lang/reflect/natField.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatField.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // natField.cc - Implementation of java.lang.reflect.Field native methods.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001, 2003  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001, 2003, 2004  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -47,7 +47,7 @@ java::lang::reflect::Field::getType ()\n {\n   jfieldID fld = _Jv_FromReflectedField (this);\n   JvSynchronize sync (declaringClass);\n-  _Jv_ResolveField (fld, declaringClass->getClassLoaderInternal ());\n+  _Jv_Linker::resolve_field (fld, declaringClass->getClassLoaderInternal ());\n   return fld->type;\n }\n "}, {"sha": "b194067300b3d18e3d52fa02c036ec2704afc9f5", "filename": "libjava/java/lang/reflect/natMethod.cc", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FnatMethod.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,6 +1,6 @@\n // natMethod.cc - Native code for Method class.\n \n-/* Copyright (C) 1998, 1999, 2000, 2001 , 2002, 2003 Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000, 2001 , 2002, 2003, 2004 Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -149,20 +149,17 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n     getType ();\n     \n   jmethodID meth = _Jv_FromReflectedMethod (this);\n-  jclass objClass;\n \n   if (Modifier::isStatic(meth->accflags))\n     {\n       // We have to initialize a static class.  It is safe to do this\n       // here and not in _Jv_CallAnyMethodA because JNI initializes a\n       // class whenever a method lookup is done.\n       _Jv_InitClass (declaringClass);\n-      objClass = declaringClass;\n     }\n   else\n     {\n-      objClass = JV_CLASS (obj);\n-     \n+      jclass objClass = JV_CLASS (obj);\n       if (! _Jv_IsAssignableFrom (declaringClass, objClass))\n         throw new java::lang::IllegalArgumentException;\n     }\n@@ -184,7 +181,7 @@ java::lang::reflect::Method::invoke (jobject obj, jobjectArray args)\n \t{\n \t}\n \n-      if (! _Jv_CheckAccess(caller, objClass, meth->accflags))\n+      if (! _Jv_CheckAccess(caller, declaringClass, meth->accflags))\n \tthrow new IllegalAccessException;\n     }\n "}, {"sha": "3efc5dca76f08062095584b2fc827fe501572366", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 132, "deletions": 19, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -54,6 +54,8 @@\n import java.security.cert.Certificate;\n import java.util.Enumeration;\n import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.StringTokenizer;\n import java.util.Vector;\n import java.util.jar.Attributes;\n import java.util.jar.JarEntry;\n@@ -144,9 +146,10 @@ public class URLClassLoader extends SecureClassLoader\n   private final Vector urls = new Vector();\n \n   /**\n-   * Store pre-parsed information for each url into this vector\n-   * each element is a URL loader, corresponding to the URL of\n-   * the same index in \"urls\"\n+   * Store pre-parsed information for each url into this vector: each\n+   * element is a URL loader.  A jar file has its own class-path\n+   * attribute which adds to the URLs that will be searched, but this\n+   * does not add to the list of urls.\n    */\n   private final Vector urlinfos = new Vector();\n \n@@ -188,10 +191,15 @@ public class URLClassLoader extends SecureClassLoader\n     final CodeSource noCertCodeSource;\n \n     URLLoader(URLClassLoader classloader, URL baseURL)\n+    {\n+      this(classloader, baseURL, baseURL);\n+    }\n+\n+    URLLoader(URLClassLoader classloader, URL baseURL, URL overrideURL)\n     {\n       this.classloader = classloader;\n       this.baseURL = baseURL;\n-      this.noCertCodeSource = new CodeSource(baseURL, null);\n+      this.noCertCodeSource = new CodeSource(overrideURL, null);\n     }\n \n     /**\n@@ -221,6 +229,11 @@ Manifest getManifest()\n     {\n       return null;\n     }\n+\n+    Vector getClassPath()\n+    {\n+      return null;\n+    }\n   }\n \n   /**\n@@ -290,6 +303,10 @@ static final class JarURLLoader extends URLLoader\n     final JarFile jarfile; // The jar file for this url\n     final URL baseJarURL; // Base jar: url for all resources loaded from jar\n \n+    Vector classPath;\t// The \"Class-Path\" attribute of this Jar's manifest\n+\n+    SoURLLoader soURLLoader;\n+\n     public JarURLLoader(URLClassLoader classloader, URL baseURL)\n     {\n       super(classloader, baseURL);\n@@ -302,25 +319,87 @@ public JarURLLoader(URLClassLoader classloader, URL baseURL)\n       sb.append(\"!/\");\n       String jarURL = sb.toString();\n \n+      this.soURLLoader = null;\n+      this.classPath = null;\n       URL baseJarURL = null;\n       JarFile jarfile = null;\n       try\n-        {\n-          baseJarURL =\n-            new URL(null, jarURL, classloader.getURLStreamHandler(\"jar\"));\n-\n-          jarfile =\n-            ((JarURLConnection) baseJarURL.openConnection()).getJarFile();\n-        }\n+\t{\n+\t  baseJarURL\n+\t    = new URL(null, jarURL, classloader.getURLStreamHandler(\"jar\"));\n+\t  jarfile\n+\t    = ((JarURLConnection) baseJarURL.openConnection()).getJarFile();\n+\n+\t  if (jarfile != null)\n+\t    {\n+\t      String fileName = baseURL.getFile();\n+\t      if (fileName != null)\n+\t\t{\n+\t\t  File f = new File(fileName);\n+\t\t  String libDirName = f.getCanonicalFile().getParent()\n+\t\t    + File.separator + \"GCJLIBS\";\n+\t\t  File libDir = new File(libDirName);\n+\t\t  if (libDir != null && (libDir.isDirectory()))\n+\t\t    {\n+\t\t      File soFile = new File (libDirName \n+\t\t\t\t\t      + File.separator + f.getName() \n+\t\t\t\t\t      + \".so\");\n+\t\t      if (soFile != null && soFile.isFile())\n+\t\t\tthis.soURLLoader\n+\t\t\t  = new SoURLLoader (classloader, soFile.toURL(),\n+\t\t\t\t\t     baseURL);\n+\t\t    }\n+\t\t}\n+\n+\t      Manifest manifest;\n+\t      Attributes attributes;\n+\t      String classPathString;\n+\n+\t      if ((manifest = jarfile.getManifest()) != null\n+\t\t  && (attributes = manifest.getMainAttributes()) != null\n+\t\t  && ((classPathString \n+\t\t       = attributes.getValue(Attributes.Name.CLASS_PATH)) \n+\t\t      != null))\n+\t\t{\n+\t\t  this.classPath = new Vector();\n+\n+\t\t  StringTokenizer st\n+\t\t    = new StringTokenizer \n+\t\t      (classPathString,\n+\t\t       System.getProperty (\"path.separator\", \":\"));\n+      \n+\t\t  while (st.hasMoreElements ()) \n+\t\t    {  \n+\t\t      String e = st.nextToken ();\n+\t\t      try\n+\t\t\t{\n+\t\t\t  URL url = new URL(baseURL, e);\n+\t\t\t  this.classPath.add(url);\n+\t\t\t} \n+\t\t      catch (java.net.MalformedURLException xx)\n+\t\t\t{\n+\t\t\t  // Give up\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+ \t    }\n+\t}\n       catch (IOException ioe)\n         {\n-          /* ignored */\n+\t  /* ignored */\n         }\n \n       this.baseJarURL = baseJarURL;\n       this.jarfile = jarfile;\n     }\n \n+    Class getClass(String className)\n+    {\n+      if (soURLLoader != null)\n+\treturn soURLLoader.getClass(className);\n+      return null;\n+    }\n+\n     /** get resource with the name \"name\" in the jar url */\n     Resource getResource(String name)\n     {\n@@ -337,6 +416,11 @@ Resource getResource(String name)\n         return null;\n     }\n \n+    public String toString ()\n+    {\n+\treturn \"jarfile \" + jarfile.getName();\n+    }\n+\n     Manifest getManifest()\n     {\n       try\n@@ -348,6 +432,11 @@ Manifest getManifest()\n           return null;\n         }\n     }\n+\n+    Vector getClassPath()\n+    {\n+      return classPath;\n+    }\n   }\n \n   static final class JarURLResource extends Resource\n@@ -486,7 +575,12 @@ final static class SoURLLoader extends URLLoader\n \n     SoURLLoader(URLClassLoader classloader, URL url)\n     {\n-      super(classloader, url);\n+      this(classloader, url, url);\n+    }\n+\n+    SoURLLoader(URLClassLoader classloader, URL url, URL overrideURL)\n+    {\n+      super(classloader, url, overrideURL);\n       helper = SharedLibHelper.findHelper(classloader, url.getFile(),\n \t\t\t\t\t  noCertCodeSource);\n     }\n@@ -577,6 +671,11 @@ public int getLength()\n       return (int) file.length();\n     }\n \n+    public String toString ()\n+    {\n+\treturn \"file \" +file.getAbsolutePath();\n+    }\n+\n     public URL getURL()\n     {\n       try\n@@ -729,6 +828,7 @@ public URLClassLoader(URL[] urls, ClassLoader parent,\n    */\n   protected void addURL(URL newUrl)\n   {\n+    urls.add(newUrl);\n     addURLImpl(newUrl);\n   }\n \n@@ -761,8 +861,21 @@ else if (\"file\".equals(protocol))\n             urlloaders.put(newUrl, loader);\n           }\n \n-        urls.add(newUrl);\n-        urlinfos.add(loader);\n+\turlinfos.add(loader);\n+\n+\tVector extraUrls = loader.getClassPath();\n+\tif (extraUrls != null)\n+\t  {\n+\t    Iterator it = extraUrls.iterator();\n+\t    while (it.hasNext())\n+\t      {\n+\t\tURL url = (URL)it.next();\n+\t\tURLLoader extraLoader = (URLLoader) urlloaders.get(url);\n+\t\tif (! urlinfos.contains (extraLoader))\n+\t\t  addURLImpl(url);\n+\t      }\n+\t  }\n+\n       }\n   }\n \n@@ -773,7 +886,7 @@ else if (\"file\".equals(protocol))\n   private void addURLs(URL[] newUrls)\n   {\n     for (int i = 0; i < newUrls.length; i++)\n-      addURLImpl(newUrls[i]);\n+      addURL(newUrls[i]);\n   }\n \n   /**\n@@ -830,7 +943,7 @@ protected Class findClass(final String className)\n   {\n     // Just try to find the resource by the (almost) same name\n     String resourceName = className.replace('.', '/') + \".class\";\n-    int max = urls.size();\n+    int max = urlinfos.size();\n     Resource resource = null;\n     for (int i = 0; i < max && resource == null; i++)\n       {\n@@ -939,7 +1052,7 @@ public Object run()\n    */\n   private Resource findURLResource(String resourceName)\n   {\n-    int max = urls.size();\n+    int max = urlinfos.size();\n     for (int i = 0; i < max; i++)\n       {\n         URLLoader loader = (URLLoader) urlinfos.elementAt(i);\n@@ -1010,7 +1123,7 @@ public Enumeration findResources(String resourceName)\n     throws IOException\n   {\n     Vector resources = new Vector();\n-    int max = urls.size();\n+    int max = urlinfos.size();\n     for (int i = 0; i < max; i++)\n       {\n         URLLoader loader = (URLLoader) urlinfos.elementAt(i);"}, {"sha": "6138334ebaffce829ed884d9cdda77c06b93d349", "filename": "libjava/jni.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -563,11 +563,12 @@ _Jv_JNI_ThrowNew (JNIEnv *env, jclass clazz, const char *message)\n \t\t\t\t\t       NULL);\n \n       jclass *elts = elements (argtypes);\n-      elts[0] = &StringClass;\n+      elts[0] = &java::lang::String::class$;\n \n       Constructor *cons = clazz->getConstructor (argtypes);\n \n-      jobjectArray values = JvNewObjectArray (1, &StringClass, NULL);\n+      jobjectArray values = JvNewObjectArray (1, &java::lang::String::class$,\n+\t\t\t\t\t      NULL);\n       jobject *velts = elements (values);\n       velts[0] = JvNewStringUTF (message);\n \n@@ -1204,7 +1205,7 @@ _Jv_JNI_GetAnyFieldID (JNIEnv *env, jclass clazz,\n \n \t      // The field might be resolved or it might not be.  It\n \t      // is much simpler to always resolve it.\n-\t      _Jv_ResolveField (field, loader);\n+\t      _Jv_Linker::resolve_field (field, loader);\n \t      if (_Jv_equalUtf8Consts (f_name, a_name)\n \t\t  && field->getClass() == field_class)\n \t\treturn field;"}, {"sha": "39ade1481a3646f52dbcf3256f49cbdf082b7892", "filename": "libjava/link.cc", "status": "added", "additions": 1764, "deletions": 0, "changes": 1764, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Flink.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Flink.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Flink.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,1764 @@\n+// link.cc - Code for linking and resolving classes and pool entries.\n+\n+/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n+\n+#include <config.h>\n+#include <platform.h>\n+\n+#include <java-interp.h>\n+\n+#include <jvm.h>\n+#include <gcj/cni.h>\n+#include <string.h>\n+#include <java-cpool.h>\n+#include <execution.h>\n+#include <java/lang/Class.h>\n+#include <java/lang/String.h>\n+#include <java/lang/StringBuffer.h>\n+#include <java/lang/Thread.h>\n+#include <java/lang/InternalError.h>\n+#include <java/lang/VirtualMachineError.h>\n+#include <java/lang/VerifyError.h>\n+#include <java/lang/NoSuchFieldError.h>\n+#include <java/lang/NoSuchMethodError.h>\n+#include <java/lang/ClassFormatError.h>\n+#include <java/lang/IllegalAccessError.h>\n+#include <java/lang/AbstractMethodError.h>\n+#include <java/lang/NoClassDefFoundError.h>\n+#include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/VerifyError.h>\n+#include <java/lang/VMClassLoader.h>\n+#include <java/lang/reflect/Modifier.h>\n+#include <java/security/CodeSource.h>\n+\n+using namespace gcj;\n+\n+// When true, print debugging information about class loading.\n+bool gcj::verbose_class_flag;\n+\n+typedef unsigned int uaddr __attribute__ ((mode (pointer)));\n+\n+template<typename T>\n+struct aligner\n+{\n+  char c;\n+  T field;\n+};\n+\n+#define ALIGNOF(TYPE) (offsetof (aligner<TYPE>, field))\n+\n+// This returns the alignment of a type as it would appear in a\n+// structure.  This can be different from the alignment of the type\n+// itself.  For instance on x86 double is 8-aligned but struct{double}\n+// is 4-aligned.\n+int\n+_Jv_Linker::get_alignment_from_class (jclass klass)\n+{\n+  if (klass == JvPrimClass (byte))\n+    return ALIGNOF (jbyte);\n+  else if (klass == JvPrimClass (short))\n+    return ALIGNOF (jshort);\n+  else if (klass == JvPrimClass (int)) \n+    return ALIGNOF (jint);\n+  else if (klass == JvPrimClass (long))\n+    return ALIGNOF (jlong);\n+  else if (klass == JvPrimClass (boolean))\n+    return ALIGNOF (jboolean);\n+  else if (klass == JvPrimClass (char))\n+    return ALIGNOF (jchar);\n+  else if (klass == JvPrimClass (float))\n+    return ALIGNOF (jfloat);\n+  else if (klass == JvPrimClass (double))\n+    return ALIGNOF (jdouble);\n+  else\n+    return ALIGNOF (jobject);\n+}\n+\n+void\n+_Jv_Linker::resolve_field (_Jv_Field *field, java::lang::ClassLoader *loader)\n+{\n+  if (! field->isResolved ())\n+    {\n+      _Jv_Utf8Const *sig = (_Jv_Utf8Const*)field->type;\n+      field->type = _Jv_FindClassFromSignature (sig->chars(), loader);\n+      field->flags &= ~_Jv_FIELD_UNRESOLVED_FLAG;\n+    }\n+}\n+\n+_Jv_word\n+_Jv_Linker::resolve_pool_entry (jclass klass, int index)\n+{\n+  using namespace java::lang::reflect;\n+\n+  _Jv_Constants *pool = &klass->constants;\n+\n+  if ((pool->tags[index] & JV_CONSTANT_ResolvedFlag) != 0)\n+    return pool->data[index];\n+\n+  switch (pool->tags[index])\n+    {\n+    case JV_CONSTANT_Class:\n+      {\n+\t_Jv_Utf8Const *name = pool->data[index].utf8;\n+\n+\tjclass found;\n+\tif (name->first() == '[')\n+\t  found = _Jv_FindClassFromSignature (name->chars(),\n+\t\t\t\t\t      klass->loader);\n+\telse\n+\t  found = _Jv_FindClass (name, klass->loader);\n+\n+\tif (! found)\n+\t  throw new java::lang::NoClassDefFoundError (name->toString());\n+\n+\t// Check accessibility, but first strip array types as\n+\t// _Jv_ClassNameSamePackage can't handle arrays.\n+\tjclass check;\n+\tfor (check = found;\n+\t     check && check->isArray();\n+\t     check = check->getComponentType())\n+\t  ;\n+\tif ((found->accflags & Modifier::PUBLIC) == Modifier::PUBLIC\n+\t    || (_Jv_ClassNameSamePackage (check->name,\n+\t\t\t\t\t  klass->name)))\n+\t  {\n+\t    pool->data[index].clazz = found;\n+\t    pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\t  }\n+\telse\n+\t  {\n+\t    java::lang::StringBuffer *sb = new java::lang::StringBuffer ();\n+\t    sb->append(klass->getName());\n+\t    sb->append(JvNewStringLatin1(\" can't access class \"));\n+\t    sb->append(found->getName());\n+\t    throw new java::lang::IllegalAccessError(sb->toString());\n+\t  }\n+      }\n+      break;\n+\n+    case JV_CONSTANT_String:\n+      {\n+\tjstring str;\n+\tstr = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n+\tpool->data[index].o = str;\n+\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+      }\n+      break;\n+\n+    case JV_CONSTANT_Fieldref:\n+      {\n+\t_Jv_ushort class_index, name_and_type_index;\n+\t_Jv_loadIndexes (&pool->data[index],\n+\t\t\t class_index,\n+\t\t\t name_and_type_index);\n+\tjclass owner = (resolve_pool_entry (klass, class_index)).clazz;\n+\n+\tif (owner != klass)\n+\t  _Jv_InitClass (owner);\n+\n+\t_Jv_ushort name_index, type_index;\n+\t_Jv_loadIndexes (&pool->data[name_and_type_index],\n+\t\t\t name_index,\n+\t\t\t type_index);\n+\n+\t_Jv_Utf8Const *field_name = pool->data[name_index].utf8;\n+\t_Jv_Utf8Const *field_type_name = pool->data[type_index].utf8;\n+\n+\t// FIXME: The implementation of this function\n+\t// (_Jv_FindClassFromSignature) will generate an instance of\n+\t// _Jv_Utf8Const for each call if the field type is a class name\n+\t// (Lxx.yy.Z;).  This may be too expensive to do for each and\n+\t// every fieldref being resolved.  For now, we fix the problem by\n+\t// only doing it when we have a loader different from the class\n+\t// declaring the field.\n+\n+\tjclass field_type = 0;\n+\n+\tif (owner->loader != klass->loader)\n+\t  field_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n+\t\t\t\t\t\t   klass->loader);\n+      \n+\t_Jv_Field* the_field = 0;\n+\n+\tfor (jclass cls = owner; cls != 0; cls = cls->getSuperclass ())\n+\t  {\n+\t    for (int i = 0;  i < cls->field_count;  i++)\n+\t      {\n+\t\t_Jv_Field *field = &cls->fields[i];\n+\t\tif (! _Jv_equalUtf8Consts (field->name, field_name))\n+\t\t  continue;\n+\n+\t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n+\t\t  {\n+\t\t    // Resolve the field using the class' own loader if\n+\t\t    // necessary.\n+\n+\t\t    if (!field->isResolved ())\n+\t\t      resolve_field (field, cls->loader);\n+\n+\t\t    if (field_type != 0 && field->type != field_type)\n+\t\t      throw new java::lang::LinkageError\n+\t\t\t(JvNewStringLatin1 \n+\t\t\t (\"field type mismatch with different loaders\"));\n+\n+\t\t    the_field = field;\n+\t\t    goto end_of_field_search;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    java::lang::StringBuffer *sb\n+\t\t      = new java::lang::StringBuffer ();\n+\t\t    sb->append(klass->getName());\n+\t\t    sb->append(JvNewStringLatin1(\": \"));\n+\t\t    sb->append(cls->getName());\n+\t\t    sb->append(JvNewStringLatin1(\".\"));\n+\t\t    sb->append(_Jv_NewStringUtf8Const (field_name));\n+\t\t    throw new java::lang::IllegalAccessError(sb->toString());\n+\t\t  }\n+\t      }\n+\t  }\n+\n+      end_of_field_search:\n+\tif (the_field == 0)\n+\t  {\n+\t    java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n+\t    sb->append(JvNewStringLatin1(\"field \"));\n+\t    sb->append(owner->getName());\n+\t    sb->append(JvNewStringLatin1(\".\"));\n+\t    sb->append(_Jv_NewStringUTF(field_name->chars()));\n+\t    sb->append(JvNewStringLatin1(\" was not found.\"));\n+\t    throw\n+\t      new java::lang::IncompatibleClassChangeError (sb->toString());\n+\t  }\n+\n+\tpool->data[index].field = the_field;\n+\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+      }\n+      break;\n+\n+    case JV_CONSTANT_Methodref:\n+    case JV_CONSTANT_InterfaceMethodref:\n+      {\n+\t_Jv_ushort class_index, name_and_type_index;\n+\t_Jv_loadIndexes (&pool->data[index],\n+\t\t\t class_index,\n+\t\t\t name_and_type_index);\n+\tjclass owner = (resolve_pool_entry (klass, class_index)).clazz;\n+\n+\tif (owner != klass)\n+\t  _Jv_InitClass (owner);\n+\n+\t_Jv_ushort name_index, type_index;\n+\t_Jv_loadIndexes (&pool->data[name_and_type_index],\n+\t\t\t name_index,\n+\t\t\t type_index);\n+\n+\t_Jv_Utf8Const *method_name = pool->data[name_index].utf8;\n+\t_Jv_Utf8Const *method_signature = pool->data[type_index].utf8;\n+\n+\t_Jv_Method *the_method = 0;\n+\tjclass found_class = 0;\n+\n+\t// We're going to cache a pointer to the _Jv_Method object\n+\t// when we find it.  So, to ensure this doesn't get moved from\n+\t// beneath us, we first put all the needed Miranda methods\n+\t// into the target class.\n+\twait_for_state (klass, JV_STATE_LOADED);\n+\n+\t// First search the class itself.\n+\tthe_method = search_method_in_class (owner, klass,\n+\t\t\t\t\t     method_name, method_signature);\n+\n+\tif (the_method != 0)\n+\t  {\n+\t    found_class = owner;\n+\t    goto end_of_method_search;\n+\t  }\n+\n+\t// If we are resolving an interface method, search the\n+\t// interface's superinterfaces (A superinterface is not an\n+\t// interface's superclass - a superinterface is implemented by\n+\t// the interface).\n+\tif (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n+\t  {\n+\t    _Jv_ifaces ifaces;\n+\t    ifaces.count = 0;\n+\t    ifaces.len = 4;\n+\t    ifaces.list = (jclass *) _Jv_Malloc (ifaces.len\n+\t\t\t\t\t\t * sizeof (jclass *));\n+\n+\t    get_interfaces (owner, &ifaces);\t  \n+\n+\t    for (int i = 0; i < ifaces.count; i++)\n+\t      {\n+\t\tjclass cls = ifaces.list[i];\n+\t\tthe_method = search_method_in_class (cls, klass, method_name, \n+\t\t\t\t\t\t     method_signature);\n+\t\tif (the_method != 0)\n+\t\t  {\n+\t\t    found_class = cls;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\n+\t    _Jv_Free (ifaces.list);\n+\n+\t    if (the_method != 0)\n+\t      goto end_of_method_search;\n+\t  }\n+\n+\t// Finally, search superclasses. \n+\tfor (jclass cls = owner->getSuperclass (); cls != 0; \n+\t     cls = cls->getSuperclass ())\n+\t  {\n+\t    the_method = search_method_in_class (cls, klass, method_name,\n+\t\t\t\t\t\t method_signature);\n+\t    if (the_method != 0)\n+\t      {\n+\t\tfound_class = cls;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\n+      end_of_method_search:\n+    \n+\t// FIXME: if (cls->loader != klass->loader), then we\n+\t// must actually check that the types of arguments\n+\t// correspond.  That is, for each argument type, and\n+\t// the return type, doing _Jv_FindClassFromSignature\n+\t// with either loader should produce the same result,\n+\t// i.e., exactly the same jclass object. JVMS 5.4.3.3    \n+    \n+\tif (the_method == 0)\n+\t  {\n+\t    java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n+\t    sb->append(JvNewStringLatin1(\"method \"));\n+\t    sb->append(owner->getName());\n+\t    sb->append(JvNewStringLatin1(\".\"));\n+\t    sb->append(_Jv_NewStringUTF(method_name->chars()));\n+\t    sb->append(JvNewStringLatin1(\" with signature \"));\n+\t    sb->append(_Jv_NewStringUTF(method_signature->chars()));\n+\t    sb->append(JvNewStringLatin1(\" was not found.\"));\n+\t    throw new java::lang::NoSuchMethodError (sb->toString());\n+\t  }\n+      \n+\tint vtable_index = -1;\n+\tif (pool->tags[index] != JV_CONSTANT_InterfaceMethodref)\n+\t  vtable_index = (jshort)the_method->index;\n+\n+\tpool->data[index].rmethod\n+\t  = klass->engine->resolve_method(the_method,\n+\t\t\t\t\t  found_class,\n+\t\t\t\t\t  ((the_method->accflags\n+\t\t\t\t\t    & Modifier::STATIC) != 0),\n+\t\t\t\t\t  vtable_index);\n+\tpool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+      }\n+      break;\n+    }\n+  return pool->data[index];\n+}\n+\n+// This function is used to lazily locate superclasses and\n+// superinterfaces.  This must be called with the class lock held.\n+void\n+_Jv_Linker::resolve_class_ref (jclass klass, jclass *classref)\n+{\n+  jclass ret = *classref;\n+\n+  // If superclass looks like a constant pool entry, resolve it now.\n+  if (ret && (uaddr) ret < (uaddr) klass->constants.size)\n+    {\n+      if (klass->state < JV_STATE_LINKED)\n+\t{\n+\t  _Jv_Utf8Const *name = klass->constants.data[(uaddr) *classref].utf8;\n+\t  ret = _Jv_FindClass (name, klass->loader);\n+\t  if (! ret)\n+\t    {\n+\t      throw new java::lang::NoClassDefFoundError (name->toString());\n+\t    }\n+\t}\n+      else\n+\tret = klass->constants.data[(uaddr) classref].clazz;\n+      *classref = ret;\n+    }\n+}\n+\n+// Find a method declared in the cls that is referenced from klass and\n+// perform access checks.\n+_Jv_Method *\n+_Jv_Linker::search_method_in_class (jclass cls, jclass klass, \n+\t\t\t\t    _Jv_Utf8Const *method_name, \n+\t\t\t\t    _Jv_Utf8Const *method_signature)\n+{\n+  using namespace java::lang::reflect;\n+\n+  for (int i = 0;  i < cls->method_count;  i++)\n+    {\n+      _Jv_Method *method = &cls->methods[i];\n+      if (   (!_Jv_equalUtf8Consts (method->name,\n+\t\t\t\t    method_name))\n+\t  || (!_Jv_equalUtf8Consts (method->signature,\n+\t\t\t\t    method_signature)))\n+\tcontinue;\n+\n+      if (_Jv_CheckAccess (klass, cls, method->accflags))\n+\treturn method;\n+      else\n+\t{\n+\t  java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n+\t  sb->append(klass->getName());\n+\t  sb->append(JvNewStringLatin1(\": \"));\n+\t  sb->append(cls->getName());\n+\t  sb->append(JvNewStringLatin1(\".\"));\n+\t  sb->append(_Jv_NewStringUTF(method_name->chars()));\n+\t  sb->append(_Jv_NewStringUTF(method_signature->chars()));\n+\t  throw new java::lang::IllegalAccessError (sb->toString());\n+\t}\n+    }\n+  return 0;\n+}\n+\n+\n+#define INITIAL_IOFFSETS_LEN 4\n+#define INITIAL_IFACES_LEN 4\n+\n+static _Jv_IDispatchTable null_idt = { {SHRT_MAX, 0, NULL} };\n+\n+// Generate tables for constant-time assignment testing and interface\n+// method lookup. This implements the technique described by Per Bothner\n+// <per@bothner.com> on the java-discuss mailing list on 1999-09-02:\n+// http://gcc.gnu.org/ml/java/1999-q3/msg00377.html\n+void\n+_Jv_Linker::prepare_constant_time_tables (jclass klass)\n+{  \n+  if (klass->isPrimitive () || klass->isInterface ())\n+    return;\n+\n+  // Short-circuit in case we've been called already.\n+  if ((klass->idt != NULL) || klass->depth != 0)\n+    return;\n+\n+  // Calculate the class depth and ancestor table. The depth of a class \n+  // is how many \"extends\" it is removed from Object. Thus the depth of \n+  // java.lang.Object is 0, but the depth of java.io.FilterOutputStream \n+  // is 2. Depth is defined for all regular and array classes, but not \n+  // interfaces or primitive types.\n+   \n+  jclass klass0 = klass;\n+  jboolean has_interfaces = 0;\n+  while (klass0 != &java::lang::Object::class$)\n+    {\n+      has_interfaces += klass0->interface_count;\n+      klass0 = klass0->superclass;\n+      klass->depth++;\n+    }\n+\n+  // We do class member testing in constant time by using a small table \n+  // of all the ancestor classes within each class. The first element is \n+  // a pointer to the current class, and the rest are pointers to the \n+  // classes ancestors, ordered from the current class down by decreasing \n+  // depth. We do not include java.lang.Object in the table of ancestors, \n+  // since it is redundant.\n+\n+  // FIXME: _Jv_AllocBytes\n+  klass->ancestors = (jclass *) _Jv_Malloc (klass->depth\n+\t\t\t\t\t\t* sizeof (jclass));\n+  klass0 = klass;\n+  for (int index = 0; index < klass->depth; index++)\n+    {\n+      klass->ancestors[index] = klass0;\n+      klass0 = klass0->superclass;\n+    }\n+\n+  if ((klass->accflags & java::lang::reflect::Modifier::ABSTRACT) != 0)\n+    return;\n+\n+  // Optimization: If class implements no interfaces, use a common\n+  // predefined interface table.\n+  if (!has_interfaces)\n+    {\n+      klass->idt = &null_idt;\n+      return;\n+    }\n+\n+  // FIXME: _Jv_AllocBytes\n+  klass->idt = \n+    (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n+\n+  _Jv_ifaces ifaces;\n+  ifaces.count = 0;\n+  ifaces.len = INITIAL_IFACES_LEN;\n+  ifaces.list = (jclass *) _Jv_Malloc (ifaces.len * sizeof (jclass *));\n+\n+  int itable_size = get_interfaces (klass, &ifaces);\n+\n+  if (ifaces.count > 0)\n+    {\n+      klass->idt->cls.itable = \n+\t// FIXME: _Jv_AllocBytes\n+\t(void **) _Jv_Malloc (itable_size * sizeof (void *));\n+      klass->idt->cls.itable_length = itable_size;\n+\n+      jshort *itable_offsets = \n+\t(jshort *) _Jv_Malloc (ifaces.count * sizeof (jshort));\n+\n+      generate_itable (klass, &ifaces, itable_offsets);\n+\n+      jshort cls_iindex = find_iindex (ifaces.list, itable_offsets,\n+\t\t\t\t       ifaces.count);\n+\n+      for (int i = 0; i < ifaces.count; i++)\n+\t{\n+\t  ifaces.list[i]->idt->iface.ioffsets[cls_iindex] =\n+\t    itable_offsets[i];\n+\t}\n+\n+      klass->idt->cls.iindex = cls_iindex;\t    \n+\n+      _Jv_Free (ifaces.list);\n+      _Jv_Free (itable_offsets);\n+    }\n+  else \n+    {\n+      klass->idt->cls.iindex = SHRT_MAX;\n+    }\n+}\n+\n+// Return index of item in list, or -1 if item is not present.\n+inline jshort\n+_Jv_Linker::indexof (void *item, void **list, jshort list_len)\n+{\n+  for (int i=0; i < list_len; i++)\n+    {\n+      if (list[i] == item)\n+        return i;\n+    }\n+  return -1;\n+}\n+\n+// Find all unique interfaces directly or indirectly implemented by klass.\n+// Returns the size of the interface dispatch table (itable) for klass, which \n+// is the number of unique interfaces plus the total number of methods that \n+// those interfaces declare. May extend ifaces if required.\n+jshort\n+_Jv_Linker::get_interfaces (jclass klass, _Jv_ifaces *ifaces)\n+{\n+  jshort result = 0;\n+  \n+  for (int i = 0; i < klass->interface_count; i++)\n+    {\n+      jclass iface = klass->interfaces[i];\n+\n+      /* Make sure interface is linked.  */\n+      wait_for_state(iface, JV_STATE_LINKED);\n+\n+      if (indexof (iface, (void **) ifaces->list, ifaces->count) == -1)\n+        {\n+\t  if (ifaces->count + 1 >= ifaces->len)\n+\t    {\n+\t      /* Resize ifaces list */\n+\t      ifaces->len = ifaces->len * 2;\n+\t      ifaces->list\n+\t\t= (jclass *) _Jv_Realloc (ifaces->list,\n+\t\t\t\t\t  ifaces->len * sizeof(jclass));\n+\t    }\n+\t  ifaces->list[ifaces->count] = iface;\n+\t  ifaces->count++;\n+\n+\t  result += get_interfaces (klass->interfaces[i], ifaces);\n+\t}\n+    }\n+    \n+  if (klass->isInterface())\n+    result += klass->method_count + 1;\n+  else if (klass->superclass)\n+    result += get_interfaces (klass->superclass, ifaces);\n+  return result;\n+}\n+\n+// Fill out itable in klass, resolving method declarations in each ifaces.\n+// itable_offsets is filled out with the position of each iface in itable,\n+// such that itable[itable_offsets[n]] == ifaces.list[n].\n+void\n+_Jv_Linker::generate_itable (jclass klass, _Jv_ifaces *ifaces,\n+\t\t\t       jshort *itable_offsets)\n+{\n+  void **itable = klass->idt->cls.itable;\n+  jshort itable_pos = 0;\n+\n+  for (int i = 0; i < ifaces->count; i++)\n+    { \n+      jclass iface = ifaces->list[i];\n+      itable_offsets[i] = itable_pos;\n+      itable_pos = append_partial_itable (klass, iface, itable, itable_pos);\n+\n+      /* Create interface dispatch table for iface */\n+      if (iface->idt == NULL)\n+\t{\n+\t  // FIXME: _Jv_AllocBytes\n+\t  iface->idt\n+\t    = (_Jv_IDispatchTable *) _Jv_Malloc (sizeof (_Jv_IDispatchTable));\n+\n+\t  // The first element of ioffsets is its length (itself included).\n+\t  // FIXME: _Jv_AllocBytes\n+\t  jshort *ioffsets = (jshort *) _Jv_Malloc (INITIAL_IOFFSETS_LEN\n+\t\t\t\t\t\t    * sizeof (jshort));\n+\t  ioffsets[0] = INITIAL_IOFFSETS_LEN;\n+\t  for (int i = 1; i < INITIAL_IOFFSETS_LEN; i++)\n+\t    ioffsets[i] = -1;\n+\n+\t  iface->idt->iface.ioffsets = ioffsets;\t    \n+\t}\n+    }\n+}\n+\n+// Format method name for use in error messages.\n+jstring\n+_Jv_GetMethodString (jclass klass, _Jv_Utf8Const *name)\n+{\n+  jstring r = klass->name->toString();\n+  r = r->concat (JvNewStringUTF (\".\"));\n+  r = r->concat (name->toString());\n+  return r;\n+}\n+\n+void \n+_Jv_ThrowNoSuchMethodError ()\n+{\n+  throw new java::lang::NoSuchMethodError;\n+}\n+\n+// Each superinterface of a class (i.e. each interface that the class\n+// directly or indirectly implements) has a corresponding \"Partial\n+// Interface Dispatch Table\" whose size is (number of methods + 1) words.\n+// The first word is a pointer to the interface (i.e. the java.lang.Class\n+// instance for that interface).  The remaining words are pointers to the\n+// actual methods that implement the methods declared in the interface,\n+// in order of declaration.\n+//\n+// Append partial interface dispatch table for \"iface\" to \"itable\", at\n+// position itable_pos.\n+// Returns the offset at which the next partial ITable should be appended.\n+jshort\n+_Jv_Linker::append_partial_itable (jclass klass, jclass iface,\n+\t\t\t\t     void **itable, jshort pos)\n+{\n+  using namespace java::lang::reflect;\n+\n+  itable[pos++] = (void *) iface;\n+  _Jv_Method *meth;\n+  \n+  for (int j=0; j < iface->method_count; j++)\n+    {\n+      meth = NULL;\n+      for (jclass cl = klass; cl; cl = cl->getSuperclass())\n+        {\n+\t  meth = _Jv_GetMethodLocal (cl, iface->methods[j].name,\n+\t\t\t\t     iface->methods[j].signature);\n+\t\t \n+\t  if (meth)\n+\t    break;\n+\t}\n+\n+      if (meth && (meth->name->first() == '<'))\n+\t{\n+\t  // leave a placeholder in the itable for hidden init methods.\n+          itable[pos] = NULL;\t\n+\t}\n+      else if (meth)\n+        {\n+\t  if ((meth->accflags & Modifier::STATIC) != 0)\n+\t    throw new java::lang::IncompatibleClassChangeError\n+\t      (_Jv_GetMethodString (klass, meth->name));\n+\t  if ((meth->accflags & Modifier::ABSTRACT) != 0)\n+\t    throw new java::lang::AbstractMethodError\n+\t      (_Jv_GetMethodString (klass, meth->name));\n+\t  if ((meth->accflags & Modifier::PUBLIC) == 0)\n+\t    throw new java::lang::IllegalAccessError\n+\t      (_Jv_GetMethodString (klass, meth->name));\n+\n+\t  itable[pos] = meth->ncode;\n+\t}\n+      else\n+        {\n+\t  // The method doesn't exist in klass. Binary compatibility rules\n+\t  // permit this, so we delay the error until runtime using a pointer\n+\t  // to a method which throws an exception.\n+\t  itable[pos] = (void *) _Jv_ThrowNoSuchMethodError;\n+\t}\n+      pos++;\n+    }\n+    \n+  return pos;\n+}\n+\n+static _Jv_Mutex_t iindex_mutex;\n+static bool iindex_mutex_initialized = false;\n+\n+// We need to find the correct offset in the Class Interface Dispatch \n+// Table for a given interface. Once we have that, invoking an interface \n+// method just requires combining the Method's index in the interface \n+// (known at compile time) to get the correct method.  Doing a type test \n+// (cast or instanceof) is the same problem: Once we have a possible Partial \n+// Interface Dispatch Table, we just compare the first element to see if it \n+// matches the desired interface. So how can we find the correct offset?  \n+// Our solution is to keep a vector of candiate offsets in each interface \n+// (idt->iface.ioffsets), and in each class we have an index \n+// (idt->cls.iindex) used to select the correct offset from ioffsets.\n+//\n+// Calculate and return iindex for a new class. \n+// ifaces is a vector of num interfaces that the class implements.\n+// offsets[j] is the offset in the interface dispatch table for the\n+// interface corresponding to ifaces[j].\n+// May extend the interface ioffsets if required.\n+jshort\n+_Jv_Linker::find_iindex (jclass *ifaces, jshort *offsets, jshort num)\n+{\n+  int i;\n+  int j;\n+  \n+  // Acquire a global lock to prevent itable corruption in case of multiple \n+  // classes that implement an intersecting set of interfaces being linked\n+  // simultaneously. We can assume that the mutex will be initialized\n+  // single-threaded.\n+  if (! iindex_mutex_initialized)\n+    {\n+      _Jv_MutexInit (&iindex_mutex);\n+      iindex_mutex_initialized = true;\n+    }\n+  \n+  _Jv_MutexLock (&iindex_mutex);\n+  \n+  for (i=1;; i++)  /* each potential position in ioffsets */\n+    {\n+      for (j=0;; j++)  /* each iface */\n+        {\n+\t  if (j >= num)\n+\t    goto found;\n+\t  if (i >= ifaces[j]->idt->iface.ioffsets[0])\n+\t    continue;\n+\t  int ioffset = ifaces[j]->idt->iface.ioffsets[i];\n+\t  /* We can potentially share this position with another class. */\n+\t  if (ioffset >= 0 && ioffset != offsets[j])\n+\t    break; /* Nope. Try next i. */\t  \n+\t}\n+    }\n+  found:\n+  for (j = 0; j < num; j++)\n+    {\n+      int len = ifaces[j]->idt->iface.ioffsets[0];\n+      if (i >= len) \n+\t{\n+\t  // Resize ioffsets.\n+\t  int newlen = 2 * len;\n+\t  if (i >= newlen)\n+\t    newlen = i + 3;\n+\t  jshort *old_ioffsets = ifaces[j]->idt->iface.ioffsets;\n+\t  // FIXME: _Jv_AllocBytes\n+\t  jshort *new_ioffsets = (jshort *) _Jv_Malloc (newlen\n+\t\t\t\t\t\t\t* sizeof(jshort));\n+\t  memcpy (&new_ioffsets[1], &old_ioffsets[1],\n+\t\t  (len - 1) * sizeof (jshort));\n+\t  new_ioffsets[0] = newlen;\n+\n+\t  while (len < newlen)\n+\t    new_ioffsets[len++] = -1;\n+\t  \n+\t  ifaces[j]->idt->iface.ioffsets = new_ioffsets;\n+\t}\n+      ifaces[j]->idt->iface.ioffsets[i] = offsets[j];\n+    }\n+\n+  _Jv_MutexUnlock (&iindex_mutex);\n+\n+  return i;\n+}\n+\n+\n+// Functions for indirect dispatch (symbolic virtual binding) support.\n+\n+// There are three tables, atable otable and itable.  atable is an\n+// array of addresses, and otable is an array of offsets, and these\n+// are used for static and virtual members respectively.  itable is an\n+// array of pairs {address, index} where each address is a pointer to\n+// an interface.\n+\n+// {a,o,i}table_syms is an array of _Jv_MethodSymbols.  Each such\n+// symbol is a tuple of {classname, member name, signature}.\n+\n+// Set this to true to enable debugging of indirect dispatch tables/linking.\n+static bool debug_link = false;\n+\n+// link_symbol_table() scans these two arrays and fills in the\n+// corresponding atable and otable with the addresses of static\n+// members and the offsets of virtual members.\n+\n+// The offset (in bytes) for each resolved method or field is placed\n+// at the corresponding position in the virtual method offset table\n+// (klass->otable). \n+\n+// The same otable and atable may be shared by many classes.\n+\n+// This must be called while holding the class lock.\n+\n+void\n+_Jv_Linker::link_symbol_table (jclass klass)\n+{\n+  int index = 0;\n+  _Jv_MethodSymbol sym;\n+  if (klass->otable == NULL\n+      || klass->otable->state != 0)\n+    goto atable;\n+   \n+  klass->otable->state = 1;\n+\n+  if (debug_link)\n+    fprintf (stderr, \"Fixing up otable in %s:\\n\", klass->name->chars());\n+  for (index = 0;\n+       (sym = klass->otable_syms[index]).class_name != NULL;\n+       ++index)\n+    {\n+      jclass target_class = _Jv_FindClass (sym.class_name, klass->loader);\n+      _Jv_Method *meth = NULL;            \n+\n+      _Jv_Utf8Const *signature = sym.signature;\n+\n+      {\n+\tstatic char *bounce = (char *)_Jv_ThrowNoSuchMethodError;\n+\tptrdiff_t offset = (char *)(klass->vtable) - bounce;\n+\tklass->otable->offsets[index] = offset;\n+      }\n+\n+      if (target_class == NULL)\n+\tthrow new java::lang::NoClassDefFoundError \n+\t  (_Jv_NewStringUTF (sym.class_name->chars()));\n+\n+      // We're looking for a field or a method, and we can tell\n+      // which is needed by looking at the signature.\n+      if (signature->first() == '(' && signature->len() >= 2)\n+\t{\n+\t  // Looks like someone is trying to invoke an interface method\n+\t  if (target_class->isInterface())\n+\t    {\n+\t      using namespace java::lang;\n+\t      StringBuffer *sb = new StringBuffer();\n+\t      sb->append(JvNewStringLatin1(\"found interface \"));\n+\t      sb->append(target_class->getName());\n+\t      sb->append(JvNewStringLatin1(\" when searching for a class\"));\n+\t      throw new VerifyError(sb->toString());\n+\t    }\n+\n+ \t  // If the target class does not have a vtable_method_count yet, \n+\t  // then we can't tell the offsets for its methods, so we must lay \n+\t  // it out now.\n+\t  wait_for_state(target_class, JV_STATE_PREPARED);\n+\n+\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n+\t\t\t\t\t  sym.signature);\n+\n+\t  if (meth != NULL)\n+\t    {\n+\t      int offset = _Jv_VTable::idx_to_offset (meth->index);\n+\t      if (offset == -1)\n+\t\tJvFail (\"Bad method index\");\n+\t      JvAssert (meth->index < target_class->vtable_method_count);\n+\t      klass->otable->offsets[index] = offset;\n+\t    }\n+\t  if (debug_link)\n+\t    fprintf (stderr, \"  offsets[%d] = %d (class %s@%p : %s(%s))\\n\",\n+\t\t     (int)index,\n+\t\t     (int)klass->otable->offsets[index],\n+\t\t     (const char*)target_class->name->chars(),\n+\t\t     target_class,\n+\t\t     (const char*)sym.name->chars(),\n+\t\t     (const char*)signature->chars());\n+\t  continue;\n+\t}\n+\n+      // try fields\n+      {\n+\t_Jv_Field *the_field = NULL;\n+\n+\twait_for_state(target_class, JV_STATE_PREPARED);\n+\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n+\t  {\n+\t    for (int i = 0; i < cls->field_count; i++)\n+\t      {\n+\t\t_Jv_Field *field = &cls->fields[i];\n+\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n+\t\t  continue;\n+\n+\t\t// FIXME: What access checks should we perform here?\n+// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n+// \t\t  {\n+\n+\t\tif (!field->isResolved ())\n+\t\t  resolve_field (field, cls->loader);\n+\n+// \t\tif (field_type != 0 && field->type != field_type)\n+// \t\t  throw new java::lang::LinkageError\n+// \t\t    (JvNewStringLatin1 \n+// \t\t     (\"field type mismatch with different loaders\"));\n+\n+\t\tthe_field = field;\n+\t\tif (debug_link)\n+\t\t  fprintf (stderr, \"  offsets[%d] = %d (class %s@%p : %s)\\n\",\n+\t\t\t   (int)index,\n+\t\t\t   (int)field->u.boffset,\n+\t\t\t   (const char*)cls->name->chars(),\n+\t\t\t   cls,\n+\t\t\t   (const char*)field->name->chars());\n+\t\tgoto end_of_field_search;\n+\t      }\n+\t  }\n+      end_of_field_search:\n+\tif (the_field != NULL)\n+\t  {\n+\t    if ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n+\t      throw new java::lang::IncompatibleClassChangeError;\n+\t    else\n+\t      klass->otable->offsets[index] = the_field->u.boffset;\n+\t  }\n+\telse\n+\t  {\n+\t    throw new java::lang::NoSuchFieldError\n+\t      (_Jv_NewStringUtf8Const (sym.name));\n+\t  }\n+      }\n+    }\n+\n+ atable:\n+  if (klass->atable == NULL || klass->atable->state != 0)\n+    goto itable;\n+\n+  klass->atable->state = 1;\n+\n+  for (index = 0;\n+       (sym = klass->atable_syms[index]).class_name != NULL;\n+       ++index)\n+    {\n+      jclass target_class = _Jv_FindClass (sym.class_name, klass->loader);\n+      _Jv_Method *meth = NULL;            \n+      _Jv_Utf8Const *signature = sym.signature;\n+\n+      // ??? Setting this pointer to null will at least get us a\n+      // NullPointerException\n+      klass->atable->addresses[index] = NULL;\n+      \n+      if (target_class == NULL)\n+\tthrow new java::lang::NoClassDefFoundError \n+\t  (_Jv_NewStringUTF (sym.class_name->chars()));\n+      \n+      // We're looking for a static field or a static method, and we\n+      // can tell which is needed by looking at the signature.\n+      if (signature->first() == '(' && signature->len() >= 2)\n+\t{\n+ \t  // If the target class does not have a vtable_method_count yet, \n+\t  // then we can't tell the offsets for its methods, so we must lay \n+\t  // it out now.\n+\t  wait_for_state (target_class, JV_STATE_PREPARED);\n+\n+\t  // Interface methods cannot have bodies.\n+\t  if (target_class->isInterface())\n+\t    {\n+\t      using namespace java::lang;\n+\t      StringBuffer *sb = new StringBuffer();\n+\t      sb->append(JvNewStringLatin1(\"class \"));\n+\t      sb->append(target_class->getName());\n+\t      sb->append(JvNewStringLatin1(\" is an interface: \"\n+\t\t\t\t\t   \"class expected\"));\n+\t      throw new VerifyError(sb->toString());\n+\t    }\n+\n+\t  meth = _Jv_LookupDeclaredMethod(target_class, sym.name, \n+\t\t\t\t\t  sym.signature);\n+\n+\t  if (meth != NULL)\n+\t    {\n+\t      if (meth->ncode) // Maybe abstract?\n+\t\t{\n+\t\t  klass->atable->addresses[index] = meth->ncode;\n+\t\t  if (debug_link)\n+\t\t    fprintf (stderr, \"  addresses[%d] = %p (class %s@%p : %s(%s))\\n\",\n+\t\t\t     index,\n+\t\t\t     &klass->atable->addresses[index],\n+\t\t\t     (const char*)target_class->name->chars(),\n+\t\t\t     klass,\n+\t\t\t     (const char*)sym.name->chars(),\n+\t\t\t     (const char*)signature->chars());\n+\t\t}\n+\t    }\n+\t  else\n+\t    klass->atable->addresses[index]\n+\t      = (void *)_Jv_ThrowNoSuchMethodError;\n+\n+\t  continue;\n+\t}\n+\n+      // try fields\n+      {\n+\t_Jv_Field *the_field = NULL;\n+\n+\twait_for_state(target_class, JV_STATE_PREPARED);\n+\tfor (jclass cls = target_class; cls != 0; cls = cls->getSuperclass ())\n+\t  {\n+\t    for (int i = 0; i < cls->field_count; i++)\n+\t      {\n+\t\t_Jv_Field *field = &cls->fields[i];\n+\t\tif (! _Jv_equalUtf8Consts (field->name, sym.name))\n+\t\t  continue;\n+\n+\t\t// FIXME: What access checks should we perform here?\n+// \t\tif (_Jv_CheckAccess (klass, cls, field->flags))\n+// \t\t  {\n+\n+\t\tif (!field->isResolved ())\n+\t\t  resolve_field (field, cls->loader);\n+\n+// \t\tif (field_type != 0 && field->type != field_type)\n+// \t\t  throw new java::lang::LinkageError\n+// \t\t    (JvNewStringLatin1 \n+// \t\t     (\"field type mismatch with different loaders\"));\n+\n+\t\tthe_field = field;\n+\t\tgoto end_of_static_field_search;\n+\t      }\n+\t  }\n+      end_of_static_field_search:\n+\tif (the_field != NULL)\n+\t  {\n+\t    if ((the_field->flags & java::lang::reflect::Modifier::STATIC))\n+\t      klass->atable->addresses[index] = the_field->u.addr;\n+\t    else\n+\t      throw new java::lang::IncompatibleClassChangeError;\n+\t  }\n+\telse\n+\t  {\n+\t    throw new java::lang::NoSuchFieldError\n+\t      (_Jv_NewStringUtf8Const (sym.name));\n+\t  }\n+      }\n+    }\n+\n+ itable:\n+  if (klass->itable == NULL\n+      || klass->itable->state != 0)\n+    return;\n+\n+  klass->itable->state = 1;\n+\n+  for (index = 0;\n+       (sym = klass->itable_syms[index]).class_name != NULL; \n+       ++index)\n+    {\n+      jclass target_class = _Jv_FindClass (sym.class_name, klass->loader);\n+      _Jv_Utf8Const *signature = sym.signature;\n+\n+      jclass cls;\n+      int i;\n+\n+      wait_for_state(target_class, JV_STATE_LOADED);\n+      bool found = _Jv_getInterfaceMethod (target_class, cls, i,\n+\t\t\t\t\t   sym.name, sym.signature);\n+\n+      if (found)\n+\t{\n+\t  klass->itable->addresses[index * 2] = cls;\n+\t  klass->itable->addresses[index * 2 + 1] = (void *)(intptr_t) i;\n+\t  if (debug_link)\n+\t    {\n+\t      fprintf (stderr, \"  interfaces[%d] = %p (interface %s@%p : %s(%s))\\n\",\n+\t\t       index,\n+\t\t       klass->itable->addresses[index * 2],\n+\t\t       (const char*)cls->name->chars(),\n+\t\t       cls,\n+\t\t       (const char*)sym.name->chars(),\n+\t\t       (const char*)signature->chars());\n+\t      fprintf (stderr, \"            [%d] = offset %d\\n\",\n+\t\t       index + 1,\n+\t\t       (int)(intptr_t)klass->itable->addresses[index * 2 + 1]);\n+\t    }\n+\n+\t}\n+      else\n+\tthrow new java::lang::IncompatibleClassChangeError;\n+    }\n+\n+}\n+\n+// For each catch_record in the list of caught classes, fill in the\n+// address field.\n+void \n+_Jv_Linker::link_exception_table (jclass self)\n+{\n+  struct _Jv_CatchClass *catch_record = self->catch_classes;\n+  if (!catch_record || catch_record->classname)\n+    return;  \n+  catch_record++;\n+  while (catch_record->classname)\n+    {\n+      try\n+\t{\n+\t  jclass target_class\n+\t    = _Jv_FindClass (catch_record->classname,  \n+\t\t\t     self->getClassLoaderInternal ());\n+\t  *catch_record->address = target_class;\n+\t}\n+      catch (::java::lang::Throwable *t)\n+\t{\n+\t  // FIXME: We need to do something better here.\n+\t  *catch_record->address = 0;\n+\t}\n+      catch_record++;\n+    }\n+  self->catch_classes->classname = (_Jv_Utf8Const *)-1;\n+}\n+  \n+// This is put in empty vtable slots.\n+static void\n+_Jv_abstractMethodError (void)\n+{\n+  throw new java::lang::AbstractMethodError();\n+}\n+\n+// Set itable method indexes for members of interface IFACE.\n+void\n+_Jv_Linker::layout_interface_methods (jclass iface)\n+{\n+  if (! iface->isInterface())\n+    return;\n+\n+  // itable indexes start at 1. \n+  // FIXME: Static initalizers currently get a NULL placeholder entry in the\n+  // itable so they are also assigned an index here.\n+  for (int i = 0; i < iface->method_count; i++)\n+    iface->methods[i].index = i + 1;\n+}\n+\n+// Prepare virtual method declarations in KLASS, and any superclasses\n+// as required, by determining their vtable index, setting\n+// method->index, and finally setting the class's vtable_method_count.\n+// Must be called with the lock for KLASS held.\n+void\n+_Jv_Linker::layout_vtable_methods (jclass klass)\n+{\n+  if (klass->vtable != NULL || klass->isInterface() \n+      || klass->vtable_method_count != -1)\n+    return;\n+\n+  jclass superclass = klass->getSuperclass();\n+\n+  if (superclass != NULL && superclass->vtable_method_count == -1)\n+    {\n+      JvSynchronize sync (superclass);\n+      layout_vtable_methods (superclass);\n+    }\n+\n+  int index = (superclass == NULL ? 0 : superclass->vtable_method_count);\n+\n+  for (int i = 0; i < klass->method_count; ++i)\n+    {\n+      _Jv_Method *meth = &klass->methods[i];\n+      _Jv_Method *super_meth = NULL;\n+\n+      if (! _Jv_isVirtualMethod (meth))\n+\tcontinue;\n+\n+      if (superclass != NULL)\n+\t{\n+\t  jclass declarer;\n+\t  super_meth = _Jv_LookupDeclaredMethod (superclass, meth->name,\n+\t\t\t\t\t\t meth->signature, &declarer);\n+\t  // See if this method actually overrides the other method\n+\t  // we've found.\n+\t  if (super_meth)\n+\t    {\n+\t      if (! _Jv_isVirtualMethod (super_meth)\n+\t\t  || ! _Jv_CheckAccess (klass, declarer,\n+\t\t\t\t\tsuper_meth->accflags))\n+\t\tsuper_meth = NULL;\n+\t      else if ((super_meth->accflags\n+\t\t\t& java::lang::reflect::Modifier::FINAL) != 0)\n+\t\t{\n+\t\t  using namespace java::lang;\n+\t\t  StringBuffer *sb = new StringBuffer();\n+\t\t  sb->append(JvNewStringLatin1(\"method \"));\n+\t\t  sb->append(_Jv_GetMethodString(klass, meth->name));\n+\t\t  sb->append(JvNewStringLatin1(\" overrides final method \"));\n+\t\t  sb->append(_Jv_GetMethodString(declarer, super_meth->name));\n+\t\t  throw new VerifyError(sb->toString());\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (super_meth)\n+        meth->index = super_meth->index;\n+      else\n+\tmeth->index = index++;\n+    }\n+\n+  klass->vtable_method_count = index;\n+}\n+\n+// Set entries in VTABLE for virtual methods declared in KLASS.\n+void\n+_Jv_Linker::set_vtable_entries (jclass klass, _Jv_VTable *vtable)\n+{\n+  for (int i = klass->method_count - 1; i >= 0; i--)\n+    {\n+      using namespace java::lang::reflect;\n+\n+      _Jv_Method *meth = &klass->methods[i];\n+      if (meth->index == (_Jv_ushort) -1)\n+\tcontinue;\n+      if ((meth->accflags & Modifier::ABSTRACT))\n+\tvtable->set_method(meth->index, (void *) &_Jv_abstractMethodError);\n+      else\n+\tvtable->set_method(meth->index, meth->ncode);\n+    }\n+}\n+\n+// Allocate and lay out the virtual method table for KLASS.  This will\n+// also cause vtables to be generated for any non-abstract\n+// superclasses, and virtual method layout to occur for any abstract\n+// superclasses.  Must be called with monitor lock for KLASS held.\n+void\n+_Jv_Linker::make_vtable (jclass klass)\n+{\n+  using namespace java::lang::reflect;  \n+\n+  // If the vtable exists, or for interface classes, do nothing.  All\n+  // other classes, including abstract classes, need a vtable.\n+  if (klass->vtable != NULL || klass->isInterface())\n+    return;\n+\n+  // Ensure all the `ncode' entries are set.\n+  klass->engine->create_ncode(klass);\n+\n+  // Class must be laid out before we can create a vtable. \n+  if (klass->vtable_method_count == -1)\n+    layout_vtable_methods (klass);\n+\n+  // Allocate the new vtable.\n+  _Jv_VTable *vtable = _Jv_VTable::new_vtable (klass->vtable_method_count);\n+  klass->vtable = vtable;\n+\n+  // Copy the vtable of the closest superclass.\n+  jclass superclass = klass->superclass;\n+  {\n+    JvSynchronize sync (superclass);\n+    make_vtable (superclass);\n+  }\n+  for (int i = 0; i < superclass->vtable_method_count; ++i)\n+    vtable->set_method (i, superclass->vtable->get_method (i));\n+\n+  // Set the class pointer and GC descriptor.\n+  vtable->clas = klass;\n+  vtable->gc_descr = _Jv_BuildGCDescr (klass);\n+\n+  // For each virtual declared in klass, set new vtable entry or\n+  // override an old one.\n+  set_vtable_entries (klass, vtable);\n+\n+  // It is an error to have an abstract method in a concrete class.\n+  if (! (klass->accflags & Modifier::ABSTRACT))\n+    {\n+      for (int i = 0; i < klass->vtable_method_count; ++i)\n+\tif (vtable->get_method(i) == (void *) &_Jv_abstractMethodError)\n+\t  {\n+\t    using namespace java::lang;\n+\t    while (klass != NULL)\n+\t      {\n+\t\tfor (int j = 0; j < klass->method_count; ++j)\n+\t\t  {\n+\t\t    if (klass->methods[j].index == i)\n+\t\t      {\n+\t\t\tStringBuffer *buf = new StringBuffer ();\n+\t\t\tbuf->append (_Jv_NewStringUtf8Const (klass->methods[j].name));\n+\t\t\tbuf->append ((jchar) ' ');\n+\t\t\tbuf->append (_Jv_NewStringUtf8Const (klass->methods[j].signature));\n+\t\t\tthrow new AbstractMethodError (buf->toString ());\n+\t\t      }\n+\t\t  }\n+\t\tklass = klass->getSuperclass ();\n+\t      }\n+\t    // Couldn't find the name, which is weird.\n+\t    // But we still must throw the error.\n+\t    throw new AbstractMethodError ();\n+\t  }\n+    }\n+}\n+\n+// Lay out the class, allocating space for static fields and computing\n+// offsets of instance fields.  The class lock must be held by the\n+// caller.\n+void\n+_Jv_Linker::ensure_fields_laid_out (jclass klass)\n+{  \n+  if (klass->size_in_bytes != -1)\n+    return;\n+\n+  // Compute the alignment for this type by searching through the\n+  // superclasses and finding the maximum required alignment.  We\n+  // could consider caching this in the Class.\n+  int max_align = __alignof__ (java::lang::Object);\n+  jclass super = klass->getSuperclass();\n+  while (super != NULL)\n+    {\n+      // Ensure that our super has its super installed before\n+      // recursing.\n+      wait_for_state(super, JV_STATE_LOADING);\n+      ensure_fields_laid_out(super);\n+      int num = JvNumInstanceFields (super);\n+      _Jv_Field *field = JvGetFirstInstanceField (super);\n+      while (num > 0)\n+\t{\n+\t  int field_align = get_alignment_from_class (field->type);\n+\t  if (field_align > max_align)\n+\t    max_align = field_align;\n+\t  ++field;\n+\t  --num;\n+\t}\n+      super = super->getSuperclass();\n+    }\n+\n+  int instance_size;\n+  int static_size = 0;\n+\n+  // Although java.lang.Object is never interpreted, an interface can\n+  // have a null superclass.  Note that we have to lay out an\n+  // interface because it might have static fields.\n+  if (klass->superclass)\n+    instance_size = klass->superclass->size();\n+  else\n+    instance_size = java::lang::Object::class$.size();\n+\n+  for (int i = 0; i < klass->field_count; i++)\n+    {\n+      int field_size;\n+      int field_align;\n+\n+      _Jv_Field *field = &klass->fields[i];\n+\n+      if (! field->isRef ())\n+\t{\n+\t  // It is safe to resolve the field here, since it's a\n+\t  // primitive class, which does not cause loading to happen.\n+\t  resolve_field (field, klass->loader);\n+\n+\t  field_size = field->type->size ();\n+\t  field_align = get_alignment_from_class (field->type);\n+\t}\n+      else \n+\t{\n+\t  field_size = sizeof (jobject);\n+\t  field_align = __alignof__ (jobject);\n+\t}\n+\n+      field->bsize = field_size;\n+\n+      if ((field->flags & java::lang::reflect::Modifier::STATIC))\n+\t{\n+\t  if (field->u.addr == NULL)\n+\t    {\n+\t      // This computes an offset into a region we'll allocate\n+\t      // shortly, and then add this offset to the start\n+\t      // address.\n+\t      static_size       = ROUND (static_size, field_align);\n+\t      field->u.boffset   = static_size;\n+\t      static_size       += field_size;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  instance_size      = ROUND (instance_size, field_align);\n+\t  field->u.boffset   = instance_size;\n+\t  instance_size     += field_size;\n+\t  if (field_align > max_align)\n+\t    max_align = field_align;\n+\t}\n+    }\n+\n+  if (static_size != 0)\n+    klass->engine->allocate_static_fields (klass, static_size);\n+\n+  // Set the instance size for the class.  Note that first we round it\n+  // to the alignment required for this object; this keeps us in sync\n+  // with our current ABI.\n+  instance_size = ROUND (instance_size, max_align);\n+  klass->size_in_bytes = instance_size;\n+}\n+\n+// This takes the class to state JV_STATE_LINKED.  The class lock must\n+// be held when calling this.\n+void\n+_Jv_Linker::ensure_class_linked (jclass klass)\n+{\n+  if (klass->state >= JV_STATE_LINKED)\n+    return;\n+\n+  int state = klass->state;\n+  try\n+    {\n+      // Short-circuit, so that mutually dependent classes are ok.\n+      klass->state = JV_STATE_LINKED;\n+\n+      _Jv_Constants *pool = &klass->constants;\n+\n+      // Compiled classes require that their class constants be\n+      // resolved here.  However, interpreted classes need their\n+      // constants to be resolved lazily.  If we resolve an\n+      // interpreted class' constants eagerly, we can end up with\n+      // spurious IllegalAccessErrors when the constant pool contains\n+      // a reference to a class we can't access.  This can validly\n+      // occur in an obscure case involving the InnerClasses\n+      // attribute.\n+      if (! _Jv_IsInterpretedClass (klass))\n+\t{\n+\t  // Resolve class constants first, since other constant pool\n+\t  // entries may rely on these.\n+\t  for (int index = 1; index < pool->size; ++index)\n+\t    {\n+\t      if (pool->tags[index] == JV_CONSTANT_Class)\n+\t\tresolve_pool_entry (klass, index);\n+\t    }\n+\t}\n+\n+#if 0  // Should be redundant now\n+      // If superclass looks like a constant pool entry,\n+      // resolve it now.\n+      if ((uaddr) klass->superclass < (uaddr) pool->size)\n+\tklass->superclass = pool->data[(uaddr) klass->superclass].clazz;\n+\n+      // Likewise for interfaces.\n+      for (int i = 0; i < klass->interface_count; i++)\n+\t{\n+\t  if ((uaddr) klass->interfaces[i] < (uaddr) pool->size)\n+\t    klass->interfaces[i]\n+\t      = pool->data[(uaddr) klass->interfaces[i]].clazz;\n+\t}\n+#endif\n+\n+      // Resolve the remaining constant pool entries.\n+      for (int index = 1; index < pool->size; ++index)\n+\t{\n+\t  if (pool->tags[index] == JV_CONSTANT_String)\n+\t    {\n+\t      jstring str;\n+\n+\t      str = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n+\t      pool->data[index].o = str;\n+\t      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n+\t    }\n+\t}\n+\n+      if (klass->engine->need_resolve_string_fields())\n+\t{\n+\t  jfieldID f = JvGetFirstStaticField (klass);\n+\t  for (int n = JvNumStaticFields (klass); n > 0; --n)\n+\t    {\n+\t      int mod = f->getModifiers ();\n+\t      // If we have a static String field with a non-null initial\n+\t      // value, we know it points to a Utf8Const.\n+\t      resolve_field(f, klass->loader);\n+\t      if (f->getClass () == &java::lang::String::class$\n+\t\t  && (mod & java::lang::reflect::Modifier::STATIC) != 0)\n+\t\t{\n+\t\t  jstring *strp = (jstring *) f->u.addr;\n+\t\t  if (*strp)\n+\t\t    *strp = _Jv_NewStringUtf8Const ((_Jv_Utf8Const *) *strp);\n+\t\t}\n+\t      f = f->getNextField ();\n+\t    }\n+\t}\n+\n+      klass->notifyAll ();\n+\n+      _Jv_PushClass (klass);\n+    }\n+  catch (java::lang::Throwable *t)\n+    {\n+      klass->state = state;\n+      throw t;\n+    }\n+}\n+\n+// This ensures that symbolic superclass and superinterface references\n+// are resolved for the indicated class.  This must be called with the\n+// class lock held.\n+void\n+_Jv_Linker::ensure_supers_installed (jclass klass)\n+{\n+  resolve_class_ref (klass, &klass->superclass);\n+  // An interface won't have a superclass.\n+  if (klass->superclass)\n+    wait_for_state (klass->superclass, JV_STATE_LOADING);\n+\n+  for (int i = 0; i < klass->interface_count; ++i)\n+    {\n+      resolve_class_ref (klass, &klass->interfaces[i]);\n+      wait_for_state (klass->interfaces[i], JV_STATE_LOADING);\n+    }\n+}\n+\n+// This adds missing `Miranda methods' to a class.\n+void\n+_Jv_Linker::add_miranda_methods (jclass base, jclass iface_class)\n+{\n+  // Note that at this point, all our supers, and the supers of all\n+  // our superclasses and superinterfaces, will have been installed.\n+\n+  for (int i = 0; i < iface_class->interface_count; ++i)\n+    {\n+      jclass interface = iface_class->interfaces[i];\n+\n+      for (int j = 0; j < interface->method_count; ++j)\n+\t{\n+ \t  _Jv_Method *meth = &interface->methods[j];\n+\t  // Don't bother with <clinit>.\n+\t  if (meth->name->first() == '<')\n+\t    continue;\n+\t  _Jv_Method *new_meth = _Jv_LookupDeclaredMethod (base, meth->name,\n+\t\t\t\t\t\t\t   meth->signature);\n+\t  if (! new_meth)\n+\t    {\n+\t      // We assume that such methods are very unlikely, so we\n+\t      // just reallocate the method array each time one is\n+\t      // found.  This greatly simplifies the searching --\n+\t      // otherwise we have to make sure that each such method\n+\t      // found is really unique among all superinterfaces.\n+\t      int new_count = base->method_count + 1;\n+\t      _Jv_Method *new_m\n+\t\t= (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method)\n+\t\t\t\t\t\t * new_count);\n+\t      memcpy (new_m, base->methods,\n+\t\t      sizeof (_Jv_Method) * base->method_count);\n+\n+\t      // Add new method.\n+\t      new_m[base->method_count] = *meth;\n+\t      new_m[base->method_count].index = (_Jv_ushort) -1;\n+\t      new_m[base->method_count].accflags\n+\t\t|= java::lang::reflect::Modifier::INVISIBLE;\n+\n+\t      base->methods = new_m;\n+\t      base->method_count = new_count;\n+\t    }\n+\t}\n+\n+      wait_for_state (interface, JV_STATE_LOADED);\n+      add_miranda_methods (base, interface);\n+    }\n+}\n+\n+// This ensures that the class' method table is \"complete\".  This must\n+// be called with the class lock held.\n+void\n+_Jv_Linker::ensure_method_table_complete (jclass klass)\n+{\n+  if (klass->vtable != NULL || klass->isInterface())\n+    return;\n+\n+  // We need our superclass to have its own Miranda methods installed.\n+  wait_for_state (klass->getSuperclass (), JV_STATE_LOADED);\n+\n+  // A class might have so-called \"Miranda methods\".  This is a method\n+  // that is declared in an interface and not re-declared in an\n+  // abstract class.  Some compilers don't emit declarations for such\n+  // methods in the class; this will give us problems since we expect\n+  // a declaration for any method requiring a vtable entry.  We handle\n+  // this here by searching for such methods and constructing new\n+  // internal declarations for them.  Note that we do this\n+  // unconditionally, and not just for abstract classes, to correctly\n+  // account for cases where a class is modified to be concrete and\n+  // still incorrectly inherits an abstract method.\n+  int pre_count = klass->method_count;\n+  add_miranda_methods (klass, klass);\n+\n+  // Let the execution engine know that we've added methods.\n+  if (klass->method_count != pre_count)\n+    klass->engine->post_miranda_hook(klass);\n+}\n+\n+// Verify a class.  Must be called with class lock held.\n+void\n+_Jv_Linker::verify_class (jclass klass)\n+{\n+  klass->engine->verify(klass);\n+}\n+\n+// Check the assertions contained in the type assertion table for KLASS.\n+// This is the equivilent of bytecode verification for native, BC-ABI code.\n+void\n+_Jv_Linker::verify_type_assertions (jclass klass)\n+{\n+  if (debug_link)\n+    fprintf (stderr, \"Evaluating type assertions for %s:\\n\",\n+\t     klass->name->chars());\n+\n+  if (klass->assertion_table == NULL)\n+    return;\n+\n+  for (int i = 0;; i++)\n+    {\n+      int assertion_code = klass->assertion_table[i].assertion_code;\n+      _Jv_Utf8Const *op1 = klass->assertion_table[i].op1;\n+      _Jv_Utf8Const *op2 = klass->assertion_table[i].op2;\n+      \n+      if (assertion_code == JV_ASSERT_END_OF_TABLE)\n+        return;\n+      else if (assertion_code == JV_ASSERT_TYPES_COMPATIBLE)\n+        {\n+\t  if (debug_link)\n+\t    {\n+\t      fprintf (stderr, \"  code=%i, operand A=%s B=%s\\n\",\n+\t\t       assertion_code, op1->chars(), op2->chars());\n+\t    }\n+\t\n+\t  // The operands are class signatures. op1 is the source, \n+\t  // op2 is the target.\n+\t  jclass cl1 = _Jv_FindClassFromSignature (op1->chars(), \n+\t    klass->getClassLoaderInternal());\n+\t  jclass cl2 = _Jv_FindClassFromSignature (op2->chars(),\n+\t    klass->getClassLoaderInternal());\n+\t    \n+\t  // If the class doesn't exist, ignore the assertion. An exception\n+\t  // will be thrown later if an attempt is made to actually \n+\t  // instantiate the class.\n+\t  if (cl1 == NULL || cl2 == NULL)\n+\t    continue;\n+\n+          if (! _Jv_IsAssignableFromSlow (cl2, cl1))\n+\t    {\n+\t      jstring s = JvNewStringUTF (\"Incompatible types: In class \");\n+\t      s = s->concat (klass->getName());\n+\t      s = s->concat (JvNewStringUTF (\": \"));\n+\t      s = s->concat (cl1->getName());\n+\t      s = s->concat (JvNewStringUTF (\" is not assignable to \"));\n+\t      s = s->concat (cl2->getName());\n+\t      throw new java::lang::VerifyError (s);\n+\t    }\n+\t}\n+      else if (assertion_code == JV_ASSERT_IS_INSTANTIABLE)\n+        {\n+\t  // TODO: Implement this.\n+\t}\n+      // Unknown assertion codes are ignored, for forwards-compatibility.\n+    }\n+}\n+   \n+void\n+_Jv_Linker::print_class_loaded (jclass klass)\n+{\n+  char *codesource = NULL;\n+  if (klass->protectionDomain != NULL)\n+    {\n+      java::security::CodeSource *cs\n+\t= klass->protectionDomain->getCodeSource();\n+      if (cs != NULL)\n+\t{\n+\t  jstring css = cs->toString();\n+\t  int len = JvGetStringUTFLength(css);\n+\t  codesource = (char *) _Jv_AllocBytes(len + 1);\n+\t  JvGetStringUTFRegion(css, 0, css->length(), codesource);\n+\t  codesource[len] = '\\0';\n+\t}\n+    }\n+  if (codesource == NULL)\n+    codesource = \"<no code source>\";\n+\n+  // We use a somewhat bogus test for the ABI here.\n+  char *abi;\n+  if (_Jv_IsInterpretedClass (klass))\n+    abi = \"bytecode\";\n+  else if (klass->state == JV_STATE_PRELOADING)\n+    abi = \"BC-compiled\";\n+  else\n+    abi = \"pre-compiled\";\n+\n+  fprintf (stderr, \"[Loaded (%s) %s from %s]\\n\", abi, klass->name->chars(),\n+\t   codesource);\n+}\n+\n+// FIXME: mention invariants and stuff.\n+void\n+_Jv_Linker::wait_for_state (jclass klass, int state)\n+{\n+  if (klass->state >= state)\n+    return;\n+\n+  JvSynchronize sync (klass);\n+\n+  // This is similar to the strategy for class initialization.  If we\n+  // already hold the lock, just leave.\n+  java::lang::Thread *self = java::lang::Thread::currentThread();\n+  while (klass->state <= state\n+\t && klass->thread \n+\t && klass->thread != self)\n+    klass->wait ();\n+\n+  java::lang::Thread *save = klass->thread;\n+  klass->thread = self;\n+\n+  // Print some debugging info if requested.  Interpreted classes are\n+  // handled in defineclass, so we only need to handle the two\n+  // pre-compiled cases here.\n+  if (gcj::verbose_class_flag\n+      && (klass->state == JV_STATE_COMPILED\n+\t  || klass->state == JV_STATE_PRELOADING)\n+      && ! _Jv_IsInterpretedClass (klass))\n+    print_class_loaded (klass);\n+\n+  try\n+    {\n+      if (state >= JV_STATE_LOADING && klass->state < JV_STATE_LOADING)\n+\t{\n+\t  ensure_supers_installed (klass);\n+\t  klass->set_state(JV_STATE_LOADING);\n+\t}\n+\n+      if (state >= JV_STATE_LOADED && klass->state < JV_STATE_LOADED)\n+\t{\n+\t  ensure_method_table_complete (klass);\n+\t  klass->set_state(JV_STATE_LOADED);\n+\t}\n+\n+      if (state >= JV_STATE_PREPARED && klass->state < JV_STATE_PREPARED)\n+\t{\n+\t  ensure_fields_laid_out (klass);\n+\t  make_vtable (klass);\n+\t  layout_interface_methods (klass);\n+\t  prepare_constant_time_tables (klass);\n+\t  klass->set_state(JV_STATE_PREPARED);\n+\t}\n+\n+      if (state >= JV_STATE_LINKED && klass->state < JV_STATE_LINKED)\n+\t{\n+\t  verify_class (klass);\n+\n+\t  ensure_class_linked (klass);\n+\t  link_exception_table (klass);\n+\t  link_symbol_table (klass);\n+\t  klass->set_state(JV_STATE_LINKED);\n+\t}\n+    }\n+  catch (java::lang::Throwable *exc)\n+    {\n+      klass->thread = save;\n+      klass->set_state(JV_STATE_ERROR);\n+      throw exc;\n+    }\n+\n+  klass->thread = save;\n+\n+  if (klass->state == JV_STATE_ERROR)\n+    throw new java::lang::LinkageError;\n+}"}, {"sha": "e3d5750cd1ce002e0a43ece024967c0ec05053ea", "filename": "libjava/prims.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -61,12 +61,16 @@ details.  */\n #include <java/lang/VirtualMachineError.h>\n #include <gnu/gcj/runtime/VMClassLoader.h>\n #include <gnu/gcj/runtime/FinalizerThread.h>\n+#include <execution.h>\n #include <gnu/java/lang/MainThread.h>\n \n #ifdef USE_LTDL\n #include <ltdl.h>\n #endif\n \n+// Execution engine for compiled code.\n+_Jv_CompiledEngine _Jv_soleCompiledEngine;\n+\n // We allocate a single OutOfMemoryError exception which we keep\n // around for use if we run out of memory.\n static java::lang::OutOfMemoryError *no_memory;\n@@ -723,7 +727,7 @@ JvConvertArgv (int argc, const char **argv)\n {\n   if (argc < 0)\n     argc = 0;\n-  jobjectArray ar = JvNewObjectArray(argc, &StringClass, NULL);\n+  jobjectArray ar = JvNewObjectArray(argc, &java::lang::String::class$, NULL);\n   jobject *ptr = elements(ar);\n   jbyteArray bytes = NULL;\n   for (int i = 0;  i < argc;  i++)\n@@ -1204,7 +1208,7 @@ _Jv_CheckAccess (jclass self_klass, jclass other_klass, jint flags)\n   return ((self_klass == other_klass)\n \t  || ((flags & Modifier::PUBLIC) != 0)\n \t  || (((flags & Modifier::PROTECTED) != 0)\n-\t      && other_klass->isAssignableFrom (self_klass))\n+\t      && _Jv_IsAssignableFromSlow (other_klass, self_klass))\n \t  || (((flags & Modifier::PRIVATE) == 0)\n \t      && _Jv_ClassNameSamePackage (self_klass->name,\n \t\t\t\t\t   other_klass->name)));"}, {"sha": "5ebefebecef5d101b1654e6a7c1f87731de6131a", "filename": "libjava/resolve.cc", "status": "removed", "additions": 0, "deletions": 1125, "changes": 1125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec0641f612862498e829fdaf040a201c0ba68762/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec0641f612862498e829fdaf040a201c0ba68762/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=ec0641f612862498e829fdaf040a201c0ba68762", "patch": "@@ -1,1125 +0,0 @@\n-// resolve.cc - Code for linking and resolving classes and pool entries.\n-\n-/* Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-/* Author: Kresten Krab Thorup <krab@gnu.org>  */\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#include <java-interp.h>\n-\n-#include <jvm.h>\n-#include <gcj/cni.h>\n-#include <string.h>\n-#include <java-cpool.h>\n-#include <java/lang/Class.h>\n-#include <java/lang/String.h>\n-#include <java/lang/StringBuffer.h>\n-#include <java/lang/Thread.h>\n-#include <java/lang/InternalError.h>\n-#include <java/lang/VirtualMachineError.h>\n-#include <java/lang/NoSuchFieldError.h>\n-#include <java/lang/NoSuchMethodError.h>\n-#include <java/lang/ClassFormatError.h>\n-#include <java/lang/IllegalAccessError.h>\n-#include <java/lang/AbstractMethodError.h>\n-#include <java/lang/NoClassDefFoundError.h>\n-#include <java/lang/IncompatibleClassChangeError.h>\n-#include <java/lang/VMClassLoader.h>\n-#include <java/lang/reflect/Modifier.h>\n-\n-using namespace gcj;\n-\n-void\n-_Jv_ResolveField (_Jv_Field *field, java::lang::ClassLoader *loader)\n-{\n-  if (! field->isResolved ())\n-    {\n-      _Jv_Utf8Const *sig = (_Jv_Utf8Const*)field->type;\n-      field->type = _Jv_FindClassFromSignature (sig->chars(), loader);\n-      field->flags &= ~_Jv_FIELD_UNRESOLVED_FLAG;\n-    }\n-}\n-\n-#ifdef INTERPRETER\n-\n-static void throw_internal_error (char *msg)\n-\t__attribute__ ((__noreturn__));\n-static void throw_class_format_error (jstring msg)\n-\t__attribute__ ((__noreturn__));\n-static void throw_class_format_error (char *msg)\n-\t__attribute__ ((__noreturn__));\n-\n-static int get_alignment_from_class (jclass);\n-\n-static _Jv_ResolvedMethod* \n-_Jv_BuildResolvedMethod (_Jv_Method*,\n-\t\t\t jclass,\n-\t\t\t jboolean,\n-\t\t\t jint);\n-\n-\n-static void throw_incompatible_class_change_error (jstring msg)\n-{\n-  throw new java::lang::IncompatibleClassChangeError (msg);\n-}\n-\n-_Jv_word\n-_Jv_ResolvePoolEntry (jclass klass, int index)\n-{\n-  using namespace java::lang::reflect;\n-\n-  _Jv_Constants *pool = &klass->constants;\n-\n-  if ((pool->tags[index] & JV_CONSTANT_ResolvedFlag) != 0)\n-    return pool->data[index];\n-\n-  switch (pool->tags[index]) {\n-  case JV_CONSTANT_Class:\n-    {\n-      _Jv_Utf8Const *name = pool->data[index].utf8;\n-\n-      jclass found;\n-      if (name->first() == '[')\n-\tfound = _Jv_FindClassFromSignature (name->chars(),\n-\t\t\t\t\t    klass->loader);\n-      else\n-\tfound = _Jv_FindClass (name, klass->loader);\n-\n-      if (! found)\n-\t{\n-\t  jstring str = name->toString();\n-\t  // This exception is specified in JLS 2nd Ed, section 5.1.\n-\t  throw new java::lang::NoClassDefFoundError (str);\n-\t}\n-\n-      if ((found->accflags & Modifier::PUBLIC) == Modifier::PUBLIC\n-\t  || (_Jv_ClassNameSamePackage (found->name,\n-\t\t\t\t\tklass->name)))\n-\t{\n-\t  pool->data[index].clazz = found;\n-\t  pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-\t}\n-      else\n-\t{\n-\t  throw new java::lang::IllegalAccessError (found->getName());\n-\t}\n-    }\n-    break;\n-\n-  case JV_CONSTANT_String:\n-    {\n-      jstring str;\n-      str = _Jv_NewStringUtf8Const (pool->data[index].utf8);\n-      pool->data[index].o = str;\n-      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-    }\n-    break;\n-\n-\n-  case JV_CONSTANT_Fieldref:\n-    {\n-      _Jv_ushort class_index, name_and_type_index;\n-      _Jv_loadIndexes (&pool->data[index],\n-\t\t       class_index,\n-\t\t       name_and_type_index);\n-      jclass owner = (_Jv_ResolvePoolEntry (klass, class_index)).clazz;\n-\n-      if (owner != klass)\n-\t_Jv_InitClass (owner);\n-\n-      _Jv_ushort name_index, type_index;\n-      _Jv_loadIndexes (&pool->data[name_and_type_index],\n-\t\t       name_index,\n-\t\t       type_index);\n-\n-      _Jv_Utf8Const *field_name = pool->data[name_index].utf8;\n-      _Jv_Utf8Const *field_type_name = pool->data[type_index].utf8;\n-\n-      // FIXME: The implementation of this function\n-      // (_Jv_FindClassFromSignature) will generate an instance of\n-      // _Jv_Utf8Const for each call if the field type is a class name\n-      // (Lxx.yy.Z;).  This may be too expensive to do for each and\n-      // every fieldref being resolved.  For now, we fix the problem by\n-      // only doing it when we have a loader different from the class\n-      // declaring the field.\n-\n-      jclass field_type = 0;\n-\n-      if (owner->loader != klass->loader)\n-\tfield_type = _Jv_FindClassFromSignature (field_type_name->chars(),\n-\t\t\t\t\t\t klass->loader);\n-      \n-      _Jv_Field* the_field = 0;\n-\n-      for (jclass cls = owner; cls != 0; cls = cls->getSuperclass ())\n-\t{\n-\t  for (int i = 0;  i < cls->field_count;  i++)\n-\t    {\n-\t      _Jv_Field *field = &cls->fields[i];\n-\t      if (! _Jv_equalUtf8Consts (field->name, field_name))\n-\t\tcontinue;\n-\n-\t      if (_Jv_CheckAccess (klass, cls, field->flags))\n-\t\t{\n-\t\t  /* resove the field using the class' own loader\n-\t\t     if necessary */\n-\n-\t\t  if (!field->isResolved ())\n-\t\t    _Jv_ResolveField (field, cls->loader);\n-\n-\t\t  if (field_type != 0 && field->type != field_type)\n-\t\t    throw new java::lang::LinkageError\n-\t\t      (JvNewStringLatin1 \n-\t\t       (\"field type mismatch with different loaders\"));\n-\n-\t\t  the_field = field;\n-\t\t  goto end_of_field_search;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  java::lang::StringBuffer *sb\n-\t\t    = new java::lang::StringBuffer ();\n-\t\t  sb->append(klass->getName());\n-\t\t  sb->append(JvNewStringLatin1(\": \"));\n-\t\t  sb->append(cls->getName());\n-\t\t  sb->append(JvNewStringLatin1(\".\"));\n-\t\t  sb->append(_Jv_NewStringUtf8Const (field_name));\n-\t\t  throw new java::lang::IllegalAccessError(sb->toString());\n-\t\t}\n-\t    }\n-\t}\n-\n-    end_of_field_search:\n-      if (the_field == 0)\n-\t{\n-\t  java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n-\t  sb->append(JvNewStringLatin1(\"field \"));\n-\t  sb->append(owner->getName());\n-\t  sb->append(JvNewStringLatin1(\".\"));\n-\t  sb->append(field_name->toString());\n-\t  sb->append(JvNewStringLatin1(\" was not found.\"));\n-\t  throw_incompatible_class_change_error(sb->toString());\n-\t}\n-\n-      pool->data[index].field = the_field;\n-      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-    }\n-    break;\n-\n-  case JV_CONSTANT_Methodref:\n-  case JV_CONSTANT_InterfaceMethodref:\n-    {\n-      _Jv_ushort class_index, name_and_type_index;\n-      _Jv_loadIndexes (&pool->data[index],\n-\t\t       class_index,\n-\t\t       name_and_type_index);\n-      jclass owner = (_Jv_ResolvePoolEntry (klass, class_index)).clazz;\n-\n-      if (owner != klass)\n-\t_Jv_InitClass (owner);\n-\n-      _Jv_ushort name_index, type_index;\n-      _Jv_loadIndexes (&pool->data[name_and_type_index],\n-\t\t       name_index,\n-\t\t       type_index);\n-\n-      _Jv_Utf8Const *method_name = pool->data[name_index].utf8;\n-      _Jv_Utf8Const *method_signature = pool->data[type_index].utf8;\n-\n-      _Jv_Method *the_method = 0;\n-      jclass found_class = 0;\n-\n-      // First search the class itself.\n-      the_method = _Jv_SearchMethodInClass (owner, klass, \n-\t\t\t\t\t    method_name, method_signature);\n-\n-      if (the_method != 0)\n-        {\n-\t  found_class = owner;\n-          goto end_of_method_search;\n-\t}\n-\n-      // If we are resolving an interface method, search the\n-      // interface's superinterfaces (A superinterface is not an\n-      // interface's superclass - a superinterface is implemented by\n-      // the interface).\n-      if (pool->tags[index] == JV_CONSTANT_InterfaceMethodref)\n-        {\n-\t  _Jv_ifaces ifaces;\n-\t  ifaces.count = 0;\n-\t  ifaces.len = 4;\n-\t  ifaces.list = (jclass *) _Jv_Malloc (ifaces.len * sizeof (jclass *));\n-\n-\t  _Jv_GetInterfaces (owner, &ifaces);\t  \n-\n-\t  for (int i = 0; i < ifaces.count; i++)\n-\t    {\n-\t      jclass cls = ifaces.list[i];\n-\t      the_method = _Jv_SearchMethodInClass (cls, klass, method_name, \n-\t                                            method_signature);\n-\t      if (the_method != 0)\n-\t        {\n-\t\t  found_class = cls;\n-                  break;\n-\t\t}\n-\t    }\n-\n-\t  _Jv_Free (ifaces.list);\n-\n-\t  if (the_method != 0)\n-\t    goto end_of_method_search;\n-\t}\n-\n-      // Finally, search superclasses. \n-      for (jclass cls = owner->getSuperclass (); cls != 0; \n-           cls = cls->getSuperclass ())\n-\t{\n-\t  the_method = _Jv_SearchMethodInClass (cls, klass, \n-\t\t\t\t\t\tmethod_name, method_signature);\n-          if (the_method != 0)\n-\t    {\n-\t      found_class = cls;\n-\t      break;\n-\t    }\n-\t}\n-\n-    end_of_method_search:\n-    \n-      // FIXME: if (cls->loader != klass->loader), then we\n-      // must actually check that the types of arguments\n-      // correspond.  That is, for each argument type, and\n-      // the return type, doing _Jv_FindClassFromSignature\n-      // with either loader should produce the same result,\n-      // i.e., exactly the same jclass object. JVMS 5.4.3.3    \n-    \n-      if (the_method == 0)\n-\t{\n-\t  java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n-\t  sb->append(JvNewStringLatin1(\"method \"));\n-\t  sb->append(owner->getName());\n-\t  sb->append(JvNewStringLatin1(\".\"));\n-\t  sb->append(method_name->toString());\n-\t  sb->append(JvNewStringLatin1(\" was not found.\"));\n-\t  throw new java::lang::NoSuchMethodError (sb->toString());\n-\t}\n-      \n-      int vtable_index = -1;\n-      if (pool->tags[index] != JV_CONSTANT_InterfaceMethodref)\n-\tvtable_index = (jshort)the_method->index;\n-\n-      pool->data[index].rmethod = \n-\t_Jv_BuildResolvedMethod(the_method,\n-\t\t\t\tfound_class,\n-\t\t\t\t(the_method->accflags & Modifier::STATIC) != 0,\n-\t\t\t\tvtable_index);\n-      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-    }\n-    break;\n-\n-  }\n-\n-  return pool->data[index];\n-}\n-\n-// Find a method declared in the cls that is referenced from klass and\n-// perform access checks.\n-_Jv_Method *\n-_Jv_SearchMethodInClass (jclass cls, jclass klass, \n-                         _Jv_Utf8Const *method_name, \n-\t\t\t _Jv_Utf8Const *method_signature)\n-{\n-  using namespace java::lang::reflect;\n-\n-  for (int i = 0;  i < cls->method_count;  i++)\n-    {\n-      _Jv_Method *method = &cls->methods[i];\n-      if (   (!_Jv_equalUtf8Consts (method->name,\n-\t\t\t\t    method_name))\n-\t  || (!_Jv_equalUtf8Consts (method->signature,\n-\t\t\t\t    method_signature)))\n-\tcontinue;\n-\n-      if (_Jv_CheckAccess (klass, cls, method->accflags))\n-\treturn method;\n-      else\n-\t{\n-\t  java::lang::StringBuffer *sb = new java::lang::StringBuffer();\n-\t  sb->append(klass->getName());\n-\t  sb->append(JvNewStringLatin1(\": \"));\n-\t  sb->append(cls->getName());\n-\t  sb->append(JvNewStringLatin1(\".\"));\n-\t  sb->append(method_name->toString());\n-\t  sb->append(method_signature->toString());\n-\t  throw new java::lang::IllegalAccessError (sb->toString());\n-\t}\n-    }\n-  return 0;\n-}\n-\n-// A helper for _Jv_PrepareClass.  This adds missing `Miranda methods'\n-// to a class.\n-void\n-_Jv_PrepareMissingMethods (jclass base, jclass iface_class)\n-{\n-  _Jv_InterpClass *interp_base = (_Jv_InterpClass *) base->aux_info;\n-  for (int i = 0; i < iface_class->interface_count; ++i)\n-    {\n-      for (int j = 0; j < iface_class->interfaces[i]->method_count; ++j)\n-\t{\n-\t  _Jv_Method *meth = &iface_class->interfaces[i]->methods[j];\n-\t  // Don't bother with <clinit>.\n-\t  if (meth->name->first() == '<')\n-\t    continue;\n-\t  _Jv_Method *new_meth = _Jv_LookupDeclaredMethod (base, meth->name,\n-\t\t\t\t\t\t\t   meth->signature);\n-\t  if (! new_meth)\n-\t    {\n-\t      // We assume that such methods are very unlikely, so we\n-\t      // just reallocate the method array each time one is\n-\t      // found.  This greatly simplifies the searching --\n-\t      // otherwise we have to make sure that each such method\n-\t      // found is really unique among all superinterfaces.\n-\t      int new_count = base->method_count + 1;\n-\t      _Jv_Method *new_m\n-\t\t= (_Jv_Method *) _Jv_AllocBytes (sizeof (_Jv_Method)\n-\t\t\t\t\t\t * new_count);\n-\t      memcpy (new_m, base->methods,\n-\t\t      sizeof (_Jv_Method) * base->method_count);\n-\n-\t      // Add new method.\n-\t      new_m[base->method_count] = *meth;\n-\t      new_m[base->method_count].index = (_Jv_ushort) -1;\n-\t      new_m[base->method_count].accflags\n-\t\t|= java::lang::reflect::Modifier::INVISIBLE;\n-\n-\t      _Jv_MethodBase **new_im\n-\t\t= (_Jv_MethodBase **) _Jv_AllocBytes (sizeof (_Jv_MethodBase *)\n-\t\t\t\t\t\t      * new_count);\n-\t      memcpy (new_im, interp_base->interpreted_methods,\n-\t\t      sizeof (_Jv_MethodBase *) * base->method_count);\n-\n-\t      base->methods = new_m;\n-\t      interp_base->interpreted_methods = new_im;\n-\t      base->method_count = new_count;\n-\t    }\n-\t}\n-\n-      _Jv_PrepareMissingMethods (base, iface_class->interfaces[i]);\n-    }\n-}\n-\n-void \n-_Jv_PrepareClass(jclass klass)\n-{\n-  using namespace java::lang::reflect;\n-\n- /*\n-  * The job of this function is to: 1) assign storage to fields, and 2)\n-  * build the vtable.  static fields are assigned real memory, instance\n-  * fields are assigned offsets.\n-  *\n-  * NOTE: we have a contract with the garbage collector here.  Static\n-  * reference fields must not be resolved, until after they have storage\n-  * assigned which is the check used by the collector to see if it\n-  * should indirect the static field reference and mark the object\n-  * pointed to. \n-  *\n-  * Most fields are resolved lazily (i.e. have their class-type\n-  * assigned) when they are accessed the first time by calling as part\n-  * of _Jv_ResolveField, which is allways called after _Jv_PrepareClass.\n-  * Static fields with initializers are resolved as part of this\n-  * function, as are fields with primitive types.\n-  */\n-\n-  if (! _Jv_IsInterpretedClass (klass))\n-    return;\n-\n-  if (klass->state >= JV_STATE_PREPARED)\n-    return;\n-\n-  // Make sure super-class is linked.  This involves taking a lock on\n-  // the super class, so we use the Java method resolveClass, which\n-  // will unlock it properly, should an exception happen.  If there's\n-  // no superclass, do nothing -- Object will already have been\n-  // resolved.\n-\n-  if (klass->superclass)\n-    java::lang::VMClassLoader::resolveClass (klass->superclass);\n-\n-  _Jv_InterpClass *iclass = (_Jv_InterpClass*)klass->aux_info;\n-\n-  /************ PART ONE: OBJECT LAYOUT ***************/\n-\n-  // Compute the alignment for this type by searching through the\n-  // superclasses and finding the maximum required alignment.  We\n-  // could consider caching this in the Class.\n-  int max_align = __alignof__ (java::lang::Object);\n-  jclass super = klass->superclass;\n-  while (super != NULL)\n-    {\n-      int num = JvNumInstanceFields (super);\n-      _Jv_Field *field = JvGetFirstInstanceField (super);\n-      while (num > 0)\n-\t{\n-\t  int field_align = get_alignment_from_class (field->type);\n-\t  if (field_align > max_align)\n-\t    max_align = field_align;\n-\t  ++field;\n-\t  --num;\n-\t}\n-      super = super->superclass;\n-    }\n-\n-  int instance_size;\n-  int static_size = 0;\n-\n-  // Although java.lang.Object is never interpreted, an interface can\n-  // have a null superclass.  Note that we have to lay out an\n-  // interface because it might have static fields.\n-  if (klass->superclass)\n-    instance_size = klass->superclass->size();\n-  else\n-    instance_size = java::lang::Object::class$.size();\n-\n-  for (int i = 0; i < klass->field_count; i++)\n-    {\n-      int field_size;\n-      int field_align;\n-\n-      _Jv_Field *field = &klass->fields[i];\n-\n-      if (! field->isRef ())\n-\t{\n-\t  // it's safe to resolve the field here, since it's \n-\t  // a primitive class, which does not cause loading to happen.\n-\t  _Jv_ResolveField (field, klass->loader);\n-\n-\t  field_size = field->type->size ();\n-\t  field_align = get_alignment_from_class (field->type);\n-\t}\n-      else \n-\t{\n-\t  field_size = sizeof (jobject);\n-\t  field_align = __alignof__ (jobject);\n-\t}\n-\n-#ifndef COMPACT_FIELDS\n-      field->bsize = field_size;\n-#endif\n-\n-      if (field->flags & Modifier::STATIC)\n-\t{\n-\t  /* this computes an offset into a region we'll allocate \n-\t     shortly, and then add this offset to the start address */\n-\n-\t  static_size        = ROUND (static_size, field_align);\n-\t  field->u.boffset   = static_size;\n-\t  static_size       += field_size;\n-\t}\n-      else\n-\t{\n-\t  instance_size      = ROUND (instance_size, field_align);\n-\t  field->u.boffset   = instance_size;\n-\t  instance_size     += field_size;\n-\t  if (field_align > max_align)\n-\t    max_align = field_align;\n-\t}\n-    }\n-\n-  // Set the instance size for the class.  Note that first we round it\n-  // to the alignment required for this object; this keeps us in sync\n-  // with our current ABI.\n-  instance_size = ROUND (instance_size, max_align);\n-  klass->size_in_bytes = instance_size;\n-\n-  // allocate static memory\n-  if (static_size != 0)\n-    {\n-      char *static_data = (char*)_Jv_AllocBytes (static_size);\n-\n-      memset (static_data, 0, static_size);\n-\n-      for (int i = 0; i < klass->field_count; i++)\n-\t{\n-\t  _Jv_Field *field = &klass->fields[i];\n-\n-\t  if ((field->flags & Modifier::STATIC) != 0)\n-\t    {\n-\t      field->u.addr  = static_data + field->u.boffset;\n-\t      \n-\t      if (iclass->field_initializers[i] != 0)\n-\t\t{\n-\t\t  _Jv_ResolveField (field, klass->loader);\n-\t\t  _Jv_InitField (0, klass, i);\n-\t\t}\n-\t    }\n-\t}\n-\n-      // now we don't need the field_initializers anymore, so let the\n-      // collector get rid of it!\n-\n-      iclass->field_initializers = 0;\n-    }\n-\n-  /************ PART TWO: VTABLE LAYOUT ***************/\n-\n-  /* preparation: build the vtable stubs (even interfaces can)\n-     have code -- for static constructors. */\n-  for (int i = 0; i < klass->method_count; i++)\n-    {\n-      _Jv_MethodBase *imeth = iclass->interpreted_methods[i];\n-\n-      if ((klass->methods[i].accflags & Modifier::NATIVE) != 0)\n-\t{\n-\t  // You might think we could use a virtual `ncode' method in\n-\t  // the _Jv_MethodBase and unify the native and non-native\n-\t  // cases.  Well, we can't, because we don't allocate these\n-\t  // objects using `new', and thus they don't get a vtable.\n-\t  _Jv_JNIMethod *jnim = reinterpret_cast<_Jv_JNIMethod *> (imeth);\n-\t  klass->methods[i].ncode = jnim->ncode ();\n-\t}\n-      else if (imeth != 0)\t\t// it could be abstract\n-\t{\n-\t  _Jv_InterpMethod *im = reinterpret_cast<_Jv_InterpMethod *> (imeth);\n-\t  _Jv_VerifyMethod (im);\n-\t  klass->methods[i].ncode = im->ncode ();\n-\n-\t  // Resolve ctable entries pointing to this method.  See\n-\t  // _Jv_Defer_Resolution.\n-\t  void **code = (void **)imeth->deferred;\n-\t  while (code)\n-\t    {\n-\t      void **target = (void **)*code;\n-\t      *code = klass->methods[i].ncode;\n-\t      code = target;\n-\t    }\n-\t}\n-    }\n-\n-  if ((klass->accflags & Modifier::INTERFACE))\n-    {\n-      klass->state = JV_STATE_PREPARED;\n-      klass->notifyAll ();\n-      return;\n-    }\n-\n-  // A class might have so-called \"Miranda methods\".  This is a method\n-  // that is declared in an interface and not re-declared in an\n-  // abstract class.  Some compilers don't emit declarations for such\n-  // methods in the class; this will give us problems since we expect\n-  // a declaration for any method requiring a vtable entry.  We handle\n-  // this here by searching for such methods and constructing new\n-  // internal declarations for them.  We only need to do this for\n-  // abstract classes.\n-  if ((klass->accflags & Modifier::ABSTRACT))\n-    _Jv_PrepareMissingMethods (klass, klass);\n-\n-  klass->vtable_method_count = -1;\n-  _Jv_MakeVTable (klass);\n-\n-  /* wooha! we're done. */\n-  klass->state = JV_STATE_PREPARED;\n-  klass->notifyAll ();\n-}\n-\n-/** Do static initialization for fields with a constant initializer */\n-void\n-_Jv_InitField (jobject obj, jclass klass, int index)\n-{\n-  using namespace java::lang::reflect;\n-\n-  if (obj != 0 && klass == 0)\n-    klass = obj->getClass ();\n-\n-  if (!_Jv_IsInterpretedClass (klass))\n-    return;\n-\n-  _Jv_InterpClass *iclass = (_Jv_InterpClass*)klass->aux_info;\n-\n-  _Jv_Field * field = (&klass->fields[0]) + index;\n-\n-  if (index > klass->field_count)\n-    throw_internal_error (\"field out of range\");\n-\n-  int init = iclass->field_initializers[index];\n-  if (init == 0)\n-    return;\n-\n-  _Jv_Constants *pool = &klass->constants;\n-  int tag = pool->tags[init];\n-\n-  if (! field->isResolved ())\n-    throw_internal_error (\"initializing unresolved field\");\n-\n-  if (obj==0 && ((field->flags & Modifier::STATIC) == 0))\n-    throw_internal_error (\"initializing non-static field with no object\");\n-\n-  void *addr = 0;\n-\n-  if ((field->flags & Modifier::STATIC) != 0)\n-    addr = (void*) field->u.addr;\n-  else\n-    addr = (void*) (((char*)obj) + field->u.boffset);\n-\n-  switch (tag)\n-    {\n-    case JV_CONSTANT_String:\n-      {\n-\t_Jv_MonitorEnter (klass);\n-\tjstring str;\n-\tstr = _Jv_NewStringUtf8Const (pool->data[init].utf8);\n-\tpool->data[init].string = str;\n-\tpool->tags[init] = JV_CONSTANT_ResolvedString;\n-\t_Jv_MonitorExit (klass);\n-      }\n-      /* fall through */\n-\n-    case JV_CONSTANT_ResolvedString:\n-      if (! (field->type == &StringClass\n- \t     || field->type == &java::lang::Class::class$))\n-\tthrow_class_format_error (\"string initialiser to non-string field\");\n-\n-      *(jstring*)addr = pool->data[init].string;\n-      break;\n-\n-    case JV_CONSTANT_Integer:\n-      {\n-\tint value = pool->data[init].i;\n-\n-\tif (field->type == JvPrimClass (boolean))\n-\t  *(jboolean*)addr = (jboolean)value;\n-\t\n-\telse if (field->type == JvPrimClass (byte))\n-\t  *(jbyte*)addr = (jbyte)value;\n-\t\n-\telse if (field->type == JvPrimClass (char))\n-\t  *(jchar*)addr = (jchar)value;\n-\n-\telse if (field->type == JvPrimClass (short))\n-\t  *(jshort*)addr = (jshort)value;\n-\t\n-\telse if (field->type == JvPrimClass (int))\n-\t  *(jint*)addr = (jint)value;\n-\n-\telse\n-\t  throw_class_format_error (\"erroneous field initializer\");\n-      }  \n-      break;\n-\n-    case JV_CONSTANT_Long:\n-      if (field->type != JvPrimClass (long))\n-\tthrow_class_format_error (\"erroneous field initializer\");\n-\n-      *(jlong*)addr = _Jv_loadLong (&pool->data[init]);\n-      break;\n-\n-    case JV_CONSTANT_Float:\n-      if (field->type != JvPrimClass (float))\n-\tthrow_class_format_error (\"erroneous field initializer\");\n-\n-      *(jfloat*)addr = pool->data[init].f;\n-      break;\n-\n-    case JV_CONSTANT_Double:\n-      if (field->type != JvPrimClass (double))\n-\tthrow_class_format_error (\"erroneous field initializer\");\n-\n-      *(jdouble*)addr = _Jv_loadDouble (&pool->data[init]);\n-      break;\n-\n-    default:\n-      throw_class_format_error (\"erroneous field initializer\");\n-    }\n-}\n-\n-template<typename T>\n-struct aligner\n-{\n-  T field;\n-};\n-\n-#define ALIGNOF(TYPE) (__alignof__ (((aligner<TYPE> *) 0)->field))\n-\n-// This returns the alignment of a type as it would appear in a\n-// structure.  This can be different from the alignment of the type\n-// itself.  For instance on x86 double is 8-aligned but struct{double}\n-// is 4-aligned.\n-static int\n-get_alignment_from_class (jclass klass)\n-{\n-  if (klass == JvPrimClass (byte))\n-    return ALIGNOF (jbyte);\n-  else if (klass == JvPrimClass (short))\n-    return ALIGNOF (jshort);\n-  else if (klass == JvPrimClass (int)) \n-    return ALIGNOF (jint);\n-  else if (klass == JvPrimClass (long))\n-    return ALIGNOF (jlong);\n-  else if (klass == JvPrimClass (boolean))\n-    return ALIGNOF (jboolean);\n-  else if (klass == JvPrimClass (char))\n-    return ALIGNOF (jchar);\n-  else if (klass == JvPrimClass (float))\n-    return ALIGNOF (jfloat);\n-  else if (klass == JvPrimClass (double))\n-    return ALIGNOF (jdouble);\n-  else\n-    return ALIGNOF (jobject);\n-}\n-\n-\n-inline static unsigned char*\n-skip_one_type (unsigned char* ptr)\n-{\n-  int ch = *ptr++;\n-\n-  while (ch == '[')\n-    { \n-      ch = *ptr++;\n-    }\n-  \n-  if (ch == 'L')\n-    {\n-      do { ch = *ptr++; } while (ch != ';');\n-    }\n-\n-  return ptr;\n-}\n-\n-static ffi_type*\n-get_ffi_type_from_signature (unsigned char* ptr)\n-{\n-  switch (*ptr) \n-    {\n-    case 'L':\n-    case '[':\n-      return &ffi_type_pointer;\n-      break;\n-\n-    case 'Z':\n-      // On some platforms a bool is a byte, on others an int.\n-      if (sizeof (jboolean) == sizeof (jbyte))\n-\treturn &ffi_type_sint8;\n-      else\n-\t{\n-\t  JvAssert (sizeof (jbyte) == sizeof (jint));\n-\t  return &ffi_type_sint32;\n-\t}\n-      break;\n-\n-    case 'B':\n-      return &ffi_type_sint8;\n-      break;\n-      \n-    case 'C':\n-      return &ffi_type_uint16;\n-      break;\n-\t  \n-    case 'S': \n-      return &ffi_type_sint16;\n-      break;\n-\t  \n-    case 'I':\n-      return &ffi_type_sint32;\n-      break;\n-\t  \n-    case 'J':\n-      return &ffi_type_sint64;\n-      break;\n-\t  \n-    case 'F':\n-      return &ffi_type_float;\n-      break;\n-\t  \n-    case 'D':\n-      return &ffi_type_double;\n-      break;\n-\n-    case 'V':\n-      return &ffi_type_void;\n-      break;\n-    }\n-\n-  throw_internal_error (\"unknown type in signature\");\n-}\n-\n-/* this function yields the number of actual arguments, that is, if the\n- * function is non-static, then one is added to the number of elements\n- * found in the signature */\n-\n-int \n-_Jv_count_arguments (_Jv_Utf8Const *signature,\n-\t\t     jboolean staticp)\n-{\n-  unsigned char *ptr = (unsigned char*) signature->chars();\n-  int arg_count = staticp ? 0 : 1;\n-\n-  /* first, count number of arguments */\n-\n-  // skip '('\n-  ptr++;\n-\n-  // count args\n-  while (*ptr != ')')\n-    {\n-      ptr = skip_one_type (ptr);\n-      arg_count += 1;\n-    }\n-\n-  return arg_count;\n-}\n-\n-/* This beast will build a cif, given the signature.  Memory for\n- * the cif itself and for the argument types must be allocated by the\n- * caller.\n- */\n-\n-static int \n-init_cif (_Jv_Utf8Const* signature,\n-\t  int arg_count,\n-\t  jboolean staticp,\n-\t  ffi_cif *cif,\n-\t  ffi_type **arg_types,\n-\t  ffi_type **rtype_p)\n-{\n-  unsigned char *ptr = (unsigned char*) signature->chars();\n-\n-  int arg_index = 0;\t\t// arg number\n-  int item_count = 0;\t\t// stack-item count\n-\n-  // setup receiver\n-  if (!staticp)\n-    {\n-      arg_types[arg_index++] = &ffi_type_pointer;\n-      item_count += 1;\n-    }\n-\n-  // skip '('\n-  ptr++;\n-\n-  // assign arg types\n-  while (*ptr != ')')\n-    {\n-      arg_types[arg_index++] = get_ffi_type_from_signature (ptr);\n-\n-      if (*ptr == 'J' || *ptr == 'D')\n-\titem_count += 2;\n-      else\n-\titem_count += 1;\n-\n-      ptr = skip_one_type (ptr);\n-    }\n-\n-  // skip ')'\n-  ptr++;\n-  ffi_type *rtype = get_ffi_type_from_signature (ptr);\n-\n-  ptr = skip_one_type (ptr);\n-  if (ptr != (unsigned char*)signature->chars() + signature->len())\n-    throw_internal_error (\"did not find end of signature\");\n-\n-  if (ffi_prep_cif (cif, FFI_DEFAULT_ABI,\n-\t\t    arg_count, rtype, arg_types) != FFI_OK)\n-    throw_internal_error (\"ffi_prep_cif failed\");\n-\n-  if (rtype_p != NULL)\n-    *rtype_p = rtype;\n-\n-  return item_count;\n-}\n-\n-#if FFI_NATIVE_RAW_API\n-#   define FFI_PREP_RAW_CLOSURE ffi_prep_raw_closure\n-#   define FFI_RAW_SIZE ffi_raw_size\n-#else\n-#   define FFI_PREP_RAW_CLOSURE ffi_prep_java_raw_closure\n-#   define FFI_RAW_SIZE ffi_java_raw_size\n-#endif\n-\n-/* we put this one here, and not in interpret.cc because it\n- * calls the utility routines _Jv_count_arguments \n- * which are static to this module.  The following struct defines the\n- * layout we use for the stubs, it's only used in the ncode method. */\n-\n-typedef struct {\n-  ffi_raw_closure  closure;\n-  ffi_cif   cif;\n-  ffi_type *arg_types[0];\n-} ncode_closure;\n-\n-typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_raw*,void*);\n-\n-void *\n-_Jv_InterpMethod::ncode ()\n-{\n-  using namespace java::lang::reflect;\n-\n-  if (self->ncode != 0)\n-    return self->ncode;\n-\n-  jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n-  int arg_count = _Jv_count_arguments (self->signature, staticp);\n-\n-  ncode_closure *closure =\n-    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n-\t\t\t\t\t+ arg_count * sizeof (ffi_type*));\n-\n-  init_cif (self->signature,\n-\t    arg_count,\n-\t    staticp,\n-\t    &closure->cif,\n-\t    &closure->arg_types[0],\n-\t    NULL);\n-\n-  ffi_closure_fun fun;\n-\n-  args_raw_size = FFI_RAW_SIZE (&closure->cif);\n-\n-  JvAssert ((self->accflags & Modifier::NATIVE) == 0);\n-\n-  if ((self->accflags & Modifier::SYNCHRONIZED) != 0)\n-    {\n-      if (staticp)\n-\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;\n-      else\n-\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_object; \n-    }\n-  else\n-    {\n-      if (staticp)\n-\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_class;\n-      else\n-\tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_normal;\n-    }\n-\n-  FFI_PREP_RAW_CLOSURE (&closure->closure,\n-\t\t        &closure->cif, \n-\t\t        fun,\n-\t\t        (void*)this);\n-\n-  self->ncode = (void*)closure;\n-  return self->ncode;\n-}\n-\n-void *\n-_Jv_JNIMethod::ncode ()\n-{\n-  using namespace java::lang::reflect;\n-\n-  if (self->ncode != 0)\n-    return self->ncode;\n-\n-  jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n-  int arg_count = _Jv_count_arguments (self->signature, staticp);\n-\n-  ncode_closure *closure =\n-    (ncode_closure*)_Jv_AllocBytes (sizeof (ncode_closure)\n-\t\t\t\t    + arg_count * sizeof (ffi_type*));\n-\n-  ffi_type *rtype;\n-  init_cif (self->signature,\n-\t    arg_count,\n-\t    staticp,\n-\t    &closure->cif,\n-\t    &closure->arg_types[0],\n-\t    &rtype);\n-\n-  ffi_closure_fun fun;\n-\n-  args_raw_size = FFI_RAW_SIZE (&closure->cif);\n-\n-  // Initialize the argument types and CIF that represent the actual\n-  // underlying JNI function.\n-  int extra_args = 1;\n-  if ((self->accflags & Modifier::STATIC))\n-    ++extra_args;\n-  jni_arg_types = (ffi_type **) _Jv_Malloc ((extra_args + arg_count)\n-\t\t\t\t\t    * sizeof (ffi_type *));\n-  int offset = 0;\n-  jni_arg_types[offset++] = &ffi_type_pointer;\n-  if ((self->accflags & Modifier::STATIC))\n-    jni_arg_types[offset++] = &ffi_type_pointer;\n-  memcpy (&jni_arg_types[offset], &closure->arg_types[0],\n-\t  arg_count * sizeof (ffi_type *));\n-\n-  if (ffi_prep_cif (&jni_cif, _Jv_platform_ffi_abi,\n-\t\t    extra_args + arg_count, rtype,\n-\t\t    jni_arg_types) != FFI_OK)\n-    throw_internal_error (\"ffi_prep_cif failed for JNI function\");\n-\n-  JvAssert ((self->accflags & Modifier::NATIVE) != 0);\n-\n-  // FIXME: for now we assume that all native methods for\n-  // interpreted code use JNI.\n-  fun = (ffi_closure_fun) &_Jv_JNIMethod::call;\n-\n-  FFI_PREP_RAW_CLOSURE (&closure->closure,\n-\t\t\t&closure->cif, \n-\t\t\tfun,\n-\t\t\t(void*) this);\n-\n-  self->ncode = (void *) closure;\n-  return self->ncode;\n-}\n-\n-\n-/* A _Jv_ResolvedMethod is what is put in the constant pool for a\n- * MethodRef or InterfacemethodRef.  */\n-static _Jv_ResolvedMethod*\n-_Jv_BuildResolvedMethod (_Jv_Method* method,\n-\t\t\t jclass      klass,\n-\t\t\t jboolean staticp,\n-\t\t\t jint vtable_index)\n-{\n-  int arg_count = _Jv_count_arguments (method->signature, staticp);\n-\n-  _Jv_ResolvedMethod* result = (_Jv_ResolvedMethod*)\n-    _Jv_AllocBytes (sizeof (_Jv_ResolvedMethod)\n-\t\t    + arg_count*sizeof (ffi_type*));\n-\n-  result->stack_item_count\n-    = init_cif (method->signature,\n-\t\targ_count,\n-\t\tstaticp,\n-\t\t&result->cif,\n-\t\t&result->arg_types[0],\n-\t\tNULL);\n-\n-  result->vtable_index        = vtable_index;\n-  result->method              = method;\n-  result->klass               = klass;\n-\n-  return result;\n-}\n-\n-\n-static void\n-throw_class_format_error (jstring msg)\n-{\n-  throw (msg\n-\t ? new java::lang::ClassFormatError (msg)\n-\t : new java::lang::ClassFormatError);\n-}\n-\n-static void\n-throw_class_format_error (char *msg)\n-{\n-  throw_class_format_error (JvNewStringLatin1 (msg));\n-}\n-\n-static void\n-throw_internal_error (char *msg)\n-{\n-  throw new java::lang::InternalError (JvNewStringLatin1 (msg));\n-}\n-\n-\n-#endif /* INTERPRETER */"}, {"sha": "2fe07c88e310d93753d34dacfbe0fa65efffdc9b", "filename": "libjava/testsuite/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2FMakefile.in?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -134,6 +134,7 @@ LIBGCJTESTSPEC = @LIBGCJTESTSPEC@\n LIBGCJ_CFLAGS = @LIBGCJ_CFLAGS@\n LIBGCJ_CXXFLAGS = @LIBGCJ_CXXFLAGS@\n LIBGCJ_JAVAFLAGS = @LIBGCJ_JAVAFLAGS@\n+LIBGCJ_LD_SYMBOLIC = @LIBGCJ_LD_SYMBOLIC@\n LIBICONV = @LIBICONV@\n LIBLTDL = @LIBLTDL@\n LIBOBJS = @LIBOBJS@"}, {"sha": "41fdcb594d9f577802360cce2c3b8575c7a6c034", "filename": "libjava/testsuite/libjava.lang/assign2.java", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2Flibjava.lang%2Fassign2.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2Flibjava.lang%2Fassign2.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fassign2.java?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1,21 @@\n+// Test for an array assignment bug we've had.\n+\n+public class assign2\n+{\n+  public static Object[][] c () { return new Long[5][5]; }\n+\n+  public static Object[] d () { return new Integer[3]; }\n+\n+  public static void main(String[] args)\n+  {\n+    try\n+      {\n+\tObject[][] x = c();\n+\tx[0] = d();\n+      }\n+    catch (ArrayStoreException _)\n+      {\n+\tSystem.out.println(\"good\");\n+      }\n+  }\n+}"}, {"sha": "12799ccbe7ce445b11b7bd4833bcc2c2ce1b48b7", "filename": "libjava/testsuite/libjava.lang/assign2.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2Flibjava.lang%2Fassign2.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2Flibjava.lang%2Fassign2.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2Fassign2.out?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -0,0 +1 @@\n+good"}, {"sha": "86e518170c4f7c97837e549780b35f54324efff9", "filename": "libjava/testsuite/libjava.loader/loader.exp", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2Flibjava.loader%2Floader.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Ftestsuite%2Flibjava.loader%2Floader.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.loader%2Floader.exp?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -1,5 +1,15 @@\n # Tests for ClassLoader and native library loader code.\n \n+# Compute the correct name for an object file.\n+# This is an awful hack.\n+proc gcj_object_file_name {compiler base} {\n+  verbose \"OBJECT: compiler = $compiler\"\n+  if {[string match *libtool* $compiler]} {\n+    return $base.lo\n+  }\n+  return $base.o\n+}\n+\n # Do all the work for a single JNI test.  Return 0 on failure.\n proc gcj_loader_test_one {srcfile} {\n   global objdir srcdir subdir\n@@ -9,9 +19,9 @@ proc gcj_loader_test_one {srcfile} {\n   regsub \"^.*/(\\[^/.\\]+)\\[.\\]\\[^/]*$\" \"$srcfile\" \"\\\\1\" out\n   set executable \"${objdir}/$out.exe\"\n \n-    set errname [file rootname [file tail $srcfile]]\n-    set args [libjava_arguments link]\n-    lappend args \"additional_flags=--main=[file rootname [file tail $srcfile]] $srcdir/$subdir/MyLoader.java $objdir/dummy.o\"\n+  set errname [file rootname [file tail $srcfile]]\n+  set args [libjava_arguments link]\n+  lappend args \"additional_flags=--main=[file rootname [file tail $srcfile]] $srcdir/$subdir/MyLoader.java $objdir/[gcj_object_file_name $args dummy]\"\n   set x [libjava_prune_warnings \\\n \t     [libjava_tcompile $srcfile \"$executable\" executable $args]]\n \n@@ -47,7 +57,7 @@ proc gcj_loader_run {} {\n   set args [libjava_arguments compile]\n   lappend args \"additional_flags=--resource $objdir/dummy.class\"\n   set x [libjava_prune_warnings \\\n-\t   [libjava_tcompile \"$objdir/dummy.class\" \"$objdir/dummy.o\" object $args]]\n+\t   [libjava_tcompile \"$objdir/dummy.class\" \"$objdir/[gcj_object_file_name $args dummy]\" object $args]]\n \n     if { $x != \"\" } {\n \tverbose \"resource compilation failed: $x\" 2"}, {"sha": "988b5aab67ee6139a0d83a2ee383cb83e178cd33", "filename": "libjava/verify.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/367390404d26b7bfc400d77893579e83e2a19fb9/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=367390404d26b7bfc400d77893579e83e2a19fb9", "patch": "@@ -553,7 +553,7 @@ class _Jv_BytecodeVerifier\n \t      {\n \t\t// We use a recursive call because we also need to\n \t\t// check superinterfaces.\n-\t\tif (is_assignable_from_slow (target, source->interfaces[i]))\n+\t\tif (is_assignable_from_slow (target, source->getInterface (i)))\n \t\t  return true;\n \t      }\n \t  }"}]}