{"sha": "f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgzM2ZmZDQyMTUwYTJlNjlmYjM3YTViN2Y5YzgyMTZkMjYxM2ZmOA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-06-09T07:19:14Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-06-09T07:19:14Z"}, "message": "mips.h (GLOBAL_POINTER_REGNUM): New macro.\n\n\t* config/mips/mips.h (GLOBAL_POINTER_REGNUM): New macro.\n\t(PIC_OFFSET_TABLE_REGNUM): Look at pic_offset_table_rtx after reload.\n\t(STARTING_FRAME_OFFSET): Don't allocate a cprestore slot for\n\tn32/64 PIC.\n\t(MUST_SAVE_REGISTERS): Delete.\n\t* config/mips/mips.c (mips_frame_info): Remove extra_size field.\n\t(machine_function): Add global_pointer field.\n\t(mips_classify_constant): Check for (const $gp) using pointer equality\n\twith pic_offset_table_rtx.\n\t(mips_classify_constant): Handle RELOC_LOADGP_HI and RELOC_LOADGP_LO.\n\t(mips_restore_gp): Use current_function_outgoing_args_size.\n\t(print_operand): Use PIC_OFFSET_TABLE_REGNUM instead of\n\tGP_REG_FIRST + 28.  Handle relocation strings that have\n\tmore than one '('.\n\t(mips_reloc_string): Handle RELOC_LOADGP_HI and RELOC_LOADGP_LO.\n\t(mips_global_pointer): New function.\n\t(mips_save_reg_p): New function, mostly split out from...\n\t(compute_frame_size): ...here.  Remove handling of extra_size.\n\tReclaim args_size if no variables depend on it.  Don't treat gp\n\tas a special case: handle it in the main GPR loop.\n\t(mips_initial_elimination_offset): Fix comment.\n\t(save_restore_insns): Save every register in the GPR mask,\n\tremoving distinction between mask and real_mask.\n\t(mips_output_function_prologue): Update .frame psuedo-op after\n\tthe removal of extra_size.  Move the SVR4 PIC stack allocation\n\tand cprestore instructions to mips_expand_prologue.\n\t(mips_gp_insn): New function.\n\t(mips_expand_prologue): Set REGNO (pic_offset_table_rtx) to\n\tthe chosen global pointer.  Handle SVR4 PIC stack allocation\n\tin the same way as other ABIs.  Adjust varargs code accordingly.\n\tEmit a cprestore insn after allocating the stack.  Use mips_gp_insn\n\tto emit the loadgp sequence.  Follow it with a loadgp_blockage\n\tif not using explicit relocs.\n\t(mips_output_function_epilogue): Reinstate the default gp register.\n\t(mips16_gp_pseudo_reg): Use pic_offset_table_rtx.\n\t(mips16_optimize_gp): Likewise.\n\t* config/mips/mips.md (UNSPEC_LOADGP): Remove.\n\t(UNSPEC_SETJMP, UNSPEC_LONGJMP): Remove.\n\t(UNSPEC_CPRESTORE, RELOC_LOADGP_HI, RELOC_LOADGP_LO): New.\n\t(loadgp): Remove.\n\t(loadgp_blockage, cprestore): New instructions.\n\t(builtin_setjmp_setup): Implement using emit_move_insn.  Use\n\tpic_offset_table_rtx.\n\t(builtin_setjmp_setup_32, builtin_setjmp_setup_64): Remove.\n\t(builtin_longjmp): Use gen_raw_REG to force use of $28.\n\nCo-Authored-By: Alexandre Oliva <aoliva@redhat.com>\n\nFrom-SVN: r67656", "tree": {"sha": "fc9941d89e0d050b2e6febd4713f24b9619afa35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc9941d89e0d050b2e6febd4713f24b9619afa35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/comments", "author": null, "committer": null, "parents": [{"sha": "32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ad6a47f78997e7cb032cea8c45ad09d57a5b7a"}], "stats": {"total": 542, "additions": 331, "deletions": 211}, "files": [{"sha": "21222323898b62981dd19575d720aa392e2e8f6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "patch": "@@ -1,3 +1,52 @@\n+2003-06-09  Richard Sandiford  <rsandifo@redhat.com>\n+\t    Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* config/mips/mips.h (GLOBAL_POINTER_REGNUM): New macro.\n+\t(PIC_OFFSET_TABLE_REGNUM): Look at pic_offset_table_rtx after reload.\n+\t(STARTING_FRAME_OFFSET): Don't allocate a cprestore slot for\n+\tn32/64 PIC.\n+\t(MUST_SAVE_REGISTERS): Delete.\n+\t* config/mips/mips.c (mips_frame_info): Remove extra_size field.\n+\t(machine_function): Add global_pointer field.\n+\t(mips_classify_constant): Check for (const $gp) using pointer equality\n+\twith pic_offset_table_rtx.\n+\t(mips_classify_constant): Handle RELOC_LOADGP_HI and RELOC_LOADGP_LO.\n+\t(mips_restore_gp): Use current_function_outgoing_args_size.\n+\t(print_operand): Use PIC_OFFSET_TABLE_REGNUM instead of\n+\tGP_REG_FIRST + 28.  Handle relocation strings that have\n+\tmore than one '('.\n+\t(mips_reloc_string): Handle RELOC_LOADGP_HI and RELOC_LOADGP_LO.\n+\t(mips_global_pointer): New function.\n+\t(mips_save_reg_p): New function, mostly split out from...\n+\t(compute_frame_size): ...here.  Remove handling of extra_size.\n+\tReclaim args_size if no variables depend on it.  Don't treat gp\n+\tas a special case: handle it in the main GPR loop.\n+\t(mips_initial_elimination_offset): Fix comment.\n+\t(save_restore_insns): Save every register in the GPR mask,\n+\tremoving distinction between mask and real_mask.\n+\t(mips_output_function_prologue): Update .frame psuedo-op after\n+\tthe removal of extra_size.  Move the SVR4 PIC stack allocation\n+\tand cprestore instructions to mips_expand_prologue.\n+\t(mips_gp_insn): New function.\n+\t(mips_expand_prologue): Set REGNO (pic_offset_table_rtx) to\n+\tthe chosen global pointer.  Handle SVR4 PIC stack allocation\n+\tin the same way as other ABIs.  Adjust varargs code accordingly.\n+\tEmit a cprestore insn after allocating the stack.  Use mips_gp_insn\n+\tto emit the loadgp sequence.  Follow it with a loadgp_blockage\n+\tif not using explicit relocs.\n+\t(mips_output_function_epilogue): Reinstate the default gp register.\n+\t(mips16_gp_pseudo_reg): Use pic_offset_table_rtx.\n+\t(mips16_optimize_gp): Likewise.\n+\t* config/mips/mips.md (UNSPEC_LOADGP): Remove.\n+\t(UNSPEC_SETJMP, UNSPEC_LONGJMP): Remove.\n+\t(UNSPEC_CPRESTORE, RELOC_LOADGP_HI, RELOC_LOADGP_LO): New.\n+\t(loadgp): Remove.\n+\t(loadgp_blockage, cprestore): New instructions.\n+\t(builtin_setjmp_setup): Implement using emit_move_insn.  Use\n+\tpic_offset_table_rtx.\n+\t(builtin_setjmp_setup_32, builtin_setjmp_setup_64): Remove.\n+\t(builtin_longjmp): Use gen_raw_REG to force use of $28.\n+\n 2003-06-09  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips-protos.h (mips_output_division): Declare."}, {"sha": "47f3edde76f0302ba66fc721b9fdaf77bb30ccbd", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 216, "deletions": 132, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "patch": "@@ -231,12 +231,15 @@ static void mips_arg_info\t\tPARAMS ((const CUMULATIVE_ARGS *,\n \t\t\t\t\t\t struct mips_arg_info *));\n static bool mips_get_unaligned_mem\t\tPARAMS ((rtx *, unsigned int,\n \t\t\t\t\t\t\t int, rtx *, rtx *));\n+static unsigned int mips_global_pointer\t\tPARAMS ((void));\n+static bool mips_save_reg_p\t\t\tPARAMS ((unsigned int));\n static rtx mips_add_large_offset_to_sp\t\tPARAMS ((HOST_WIDE_INT));\n static void mips_set_frame_expr\t\t\tPARAMS ((rtx));\n static rtx mips_frame_set\t\t\tPARAMS ((rtx, int));\n static void mips_emit_frame_related_store\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\t HOST_WIDE_INT));\n static void save_restore_insns\t\t\tPARAMS ((int, rtx, long));\n+static void mips_gp_insn\t\t\tPARAMS ((rtx, rtx));\n static void mips16_fp_args\t\t\tPARAMS ((FILE *, int, int));\n static void build_mips16_function_stub\t\tPARAMS ((FILE *));\n static void mips16_optimize_gp\t\t\tPARAMS ((rtx));\n@@ -298,7 +301,6 @@ struct mips_frame_info GTY(())\n   long total_size;\t\t/* # bytes that the entire frame takes up */\n   long var_size;\t\t/* # bytes that variables take up */\n   long args_size;\t\t/* # bytes that outgoing arguments take up */\n-  long extra_size;\t\t/* # bytes of extra gunk */\n   int  gp_reg_size;\t\t/* # bytes needed to store gp regs */\n   int  fp_reg_size;\t\t/* # bytes needed to store fp regs */\n   long mask;\t\t\t/* mask of saved gp registers */\n@@ -327,6 +329,9 @@ struct machine_function GTY(()) {\n \n   /* Length of instructions in function; mips16 only.  */\n   long insns_len;\n+\n+  /* The register to use as the global pointer within this function.  */\n+  unsigned int global_pointer;\n };\n \n /* Information about a single argument.  */\n@@ -890,7 +895,7 @@ mips_classify_constant (info, x)\n     {\n       x = XEXP (x, 0);\n \n-      if (GET_CODE (x) == REG && REGNO (x) == GP_REG_FIRST + 28)\n+      if (x == pic_offset_table_rtx)\n \treturn CONSTANT_GP;\n \n       while (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == CONST_INT)\n@@ -913,6 +918,8 @@ mips_classify_constant (info, x)\n \t  case RELOC_CALL16:\n \t  case RELOC_CALL_HI:\n \t  case RELOC_CALL_LO:\n+\t  case RELOC_LOADGP_HI:\n+\t  case RELOC_LOADGP_LO:\n \t    /* These relocations should be applied to bare symbols only.  */\n \t    return (info->offset == 0 ? CONSTANT_RELOC : CONSTANT_NONE);\n \t  }\n@@ -3033,7 +3040,7 @@ mips_restore_gp (operands)\n     loc = hard_frame_pointer_rtx;\n   else\n     loc = stack_pointer_rtx;\n-  loc = plus_constant (loc, cfun->machine->frame.args_size);\n+  loc = plus_constant (loc, current_function_outgoing_args_size);\n   operands[1] = gen_rtx_MEM (ptr_mode, loc);\n \n   return mips_output_move (operands[0], operands[1]);\n@@ -5861,7 +5868,7 @@ mips_debugger_offset (addr, offset)\n    '.'\tPrint the name of the register with a hard-wired zero (zero or $0).\n    '^'\tPrint the name of the pic call-through register (t9 or $25).\n    '$'\tPrint the name of the stack pointer register (sp or $29).\n-   '+'\tPrint the name of the gp register (gp or $28).\n+   '+'\tPrint the name of the gp register (usually gp or $28).\n    '~'\tOutput a branch alignment to LABEL_ALIGN(NULL).  */\n \n void\n@@ -5872,6 +5879,7 @@ print_operand (file, op, letter)\n {\n   register enum rtx_code code;\n   struct mips_constant_info c;\n+  const char *reloc;\n \n   if (PRINT_OPERAND_PUNCT_VALID_P (letter))\n     {\n@@ -5899,7 +5907,7 @@ print_operand (file, op, letter)\n \t  break;\n \n \tcase '+':\n-\t  fputs (reg_names[GP_REG_FIRST + 28], file);\n+\t  fputs (reg_names[PIC_OFFSET_TABLE_REGNUM], file);\n \t  break;\n \n \tcase '&':\n@@ -6159,15 +6167,17 @@ print_operand (file, op, letter)\n \tbreak;\n \n       case CONSTANT_GP:\n-\tfputs (reg_names[GP_REG_FIRST + 28], file);\n+\tfputs (reg_names[PIC_OFFSET_TABLE_REGNUM], file);\n \tbreak;\n \n       case CONSTANT_RELOC:\n-\tfputs (mips_reloc_string (XINT (c.symbol, 1)), file);\n+\treloc = mips_reloc_string (XINT (c.symbol, 1));\n+\tfputs (reloc, file);\n \toutput_addr_const (file, plus_constant (XVECEXP (c.symbol, 0, 0),\n \t\t\t\t\t\tc.offset));\n-\tfputc (')', file);\n-\tbreak;\n+\twhile (*reloc != 0)\n+\t  if (*reloc++ == '(')\n+\t    fputc (')', file);\n       }\n }\n \f\n@@ -6187,6 +6197,8 @@ mips_reloc_string (reloc)\n     case RELOC_CALL16:\t  return \"%call16(\";\n     case RELOC_CALL_HI:\t  return \"%call_hi(\";\n     case RELOC_CALL_LO:\t  return \"%call_lo(\";\n+    case RELOC_LOADGP_HI: return \"%hi(%neg(%gp_rel(\";\n+    case RELOC_LOADGP_LO: return \"%lo(%neg(%gp_rel(\";\n     }\n   abort ();\n }\n@@ -6615,6 +6627,117 @@ mips_declare_object (stream, name, init_string, final_string, size)\n     }\n }\n \f\n+/* Return the register that should be used as the global pointer\n+   within this function.  Return 0 if the function doesn't need\n+   a global pointer.  */\n+\n+static unsigned int\n+mips_global_pointer ()\n+{\n+  unsigned int regno;\n+\n+  /* $gp is always available in non-abicalls code.  */\n+  if (!TARGET_ABICALLS)\n+    return GLOBAL_POINTER_REGNUM;\n+\n+  /* We must always provide $gp when it is used implicitly.  */\n+  if (!TARGET_EXPLICIT_RELOCS)\n+    return GLOBAL_POINTER_REGNUM;\n+\n+  /* FUNCTION_PROFILER includes a jal macro, so we need to give it\n+     a valid gp.  */\n+  if (current_function_profile)\n+    return GLOBAL_POINTER_REGNUM;\n+\n+  /* If the gp is never referenced, there's no need to initialize it.\n+     Note that reload can sometimes introduce constant pool references\n+     into a function that otherwise didn't need them.  For example,\n+     suppose we have an instruction like:\n+\n+\t  (set (reg:DF R1) (float:DF (reg:SI R2)))\n+\n+     If R2 turns out to be constant such as 1, the instruction may have a\n+     REG_EQUAL note saying that R1 == 1.0.  Reload then has the option of\n+     using this constant if R2 doesn't get allocated to a register.\n+\n+     In cases like these, reload will have added the constant to the pool\n+     but no instruction will yet refer to it.  */\n+  if (!regs_ever_live[GLOBAL_POINTER_REGNUM]\n+      && !current_function_uses_const_pool)\n+    return 0;\n+\n+  /* We need a global pointer, but perhaps we can use a call-clobbered\n+     register instead of $gp.  */\n+  if (TARGET_NEWABI && current_function_is_leaf)\n+    for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n+      if (!regs_ever_live[regno]\n+\t  && call_used_regs[regno]\n+\t  && !fixed_regs[regno])\n+\treturn regno;\n+\n+  return GLOBAL_POINTER_REGNUM;\n+}\n+\n+\n+/* Return true if the current function must save REGNO.  */\n+\n+static bool\n+mips_save_reg_p (regno)\n+     unsigned int regno;\n+{\n+  /* We only need to save $gp for NewABI PIC.  */\n+  if (regno == GLOBAL_POINTER_REGNUM)\n+    return (TARGET_ABICALLS && TARGET_NEWABI\n+\t    && cfun->machine->global_pointer == regno);\n+\n+  /* Check call-saved registers.  */\n+  if (regs_ever_live[regno] && !call_used_regs[regno])\n+    return true;\n+\n+  /* We need to save the old frame pointer before setting up a new one.  */\n+  if (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\n+    return true;\n+\n+  /* We need to save the incoming return address if it is ever clobbered\n+     within the function.  */\n+  if (regno == GP_REG_FIRST + 31 && regs_ever_live[regno])\n+    return true;\n+\n+  if (TARGET_MIPS16)\n+    {\n+      tree return_type;\n+\n+      return_type = DECL_RESULT (current_function_decl);\n+\n+      /* $18 is a special case in mips16 code.  It may be used to call\n+\t a function which returns a floating point value, but it is\n+\t marked in call_used_regs.  */\n+      if (regno == GP_REG_FIRST + 18 && regs_ever_live[regno])\n+\treturn true;\n+\n+      /* $31 is also a special case.  When not using -mentry, it will be\n+\t used to copy a return value into the floating point registers if\n+\t the return value is floating point.  */\n+      if (regno == GP_REG_FIRST + 31\n+\t  && mips16_hard_float\n+\t  && !mips_entry\n+\t  && !aggregate_value_p (return_type)\n+\t  && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n+\t  && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE)\n+\treturn true;\n+\n+      /* The entry and exit pseudo instructions can not save $17\n+\t without also saving $16.  */\n+      if (mips_entry\n+\t  && regno == GP_REG_FIRST + 16\n+\t  && mips_save_reg_p (GP_REG_FIRST + 17))\n+\treturn true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Return the bytes needed to compute the frame pointer from the current\n    stack pointer.\n \n@@ -6676,21 +6799,26 @@ compute_frame_size (size)\n   HOST_WIDE_INT total_size;\t/* # bytes that the entire frame takes up */\n   HOST_WIDE_INT var_size;\t/* # bytes that variables take up */\n   HOST_WIDE_INT args_size;\t/* # bytes that outgoing arguments take up */\n-  HOST_WIDE_INT extra_size;\t/* # extra bytes */\n   HOST_WIDE_INT gp_reg_rounded;\t/* # bytes needed to store gp after rounding */\n   HOST_WIDE_INT gp_reg_size;\t/* # bytes needed to store gp regs */\n   HOST_WIDE_INT fp_reg_size;\t/* # bytes needed to store fp regs */\n   long mask;\t\t\t/* mask of saved gp registers */\n   long fmask;\t\t\t/* mask of saved fp registers */\n-  tree return_type;\n+\n+  cfun->machine->global_pointer = mips_global_pointer ();\n \n   gp_reg_size = 0;\n   fp_reg_size = 0;\n   mask = 0;\n   fmask\t= 0;\n-  extra_size = MIPS_STACK_ALIGN (((TARGET_ABICALLS) ? UNITS_PER_WORD : 0));\n   var_size = MIPS_STACK_ALIGN (size);\n-  args_size = MIPS_STACK_ALIGN (current_function_outgoing_args_size);\n+  args_size = MIPS_STACK_ALIGN (STARTING_FRAME_OFFSET);\n+\n+  /* The space set aside by STARTING_FRAME_OFFSET isn't needed in leaf\n+     functions.  If the function has local variables, we're committed\n+     to allocating it anyway.  Otherwise reclaim it here.  */\n+  if (var_size == 0 && current_function_is_leaf)\n+    args_size = 0;\n \n   /* The MIPS 3.0 linker does not like functions that dynamically\n      allocate the stack and have 0 for STACK_DYNAMIC_OFFSET, since it\n@@ -6700,44 +6828,15 @@ compute_frame_size (size)\n   if (args_size == 0 && current_function_calls_alloca)\n     args_size = 4 * UNITS_PER_WORD;\n \n-  total_size = var_size + args_size + extra_size;\n-  return_type = DECL_RESULT (current_function_decl);\n+  total_size = var_size + args_size;\n \n   /* Calculate space needed for gp registers.  */\n   for (regno = GP_REG_FIRST; regno <= GP_REG_LAST; regno++)\n-    {\n-      /* $18 is a special case on the mips16.  It may be used to call\n-         a function which returns a floating point value, but it is\n-         marked in call_used_regs.  $31 is also a special case.  When\n-         not using -mentry, it will be used to copy a return value\n-         into the floating point registers if the return value is\n-         floating point.  */\n-      if (MUST_SAVE_REGISTER (regno)\n-\t  || (TARGET_MIPS16\n-\t      && regno == GP_REG_FIRST + 18\n-\t      && regs_ever_live[regno])\n-\t  || (TARGET_MIPS16\n-\t      && regno == GP_REG_FIRST + 31\n-\t      && mips16_hard_float\n-\t      && ! mips_entry\n-\t      && ! aggregate_value_p (return_type)\n-\t      && GET_MODE_CLASS (DECL_MODE (return_type)) == MODE_FLOAT\n-\t      && GET_MODE_SIZE (DECL_MODE (return_type)) <= UNITS_PER_FPVALUE))\n-\t{\n-\t  gp_reg_size += GET_MODE_SIZE (gpr_mode);\n-\t  mask |= 1L << (regno - GP_REG_FIRST);\n-\n-\t  /* The entry and exit pseudo instructions can not save $17\n-\t     without also saving $16.  */\n-\t  if (mips_entry\n-\t      && regno == GP_REG_FIRST + 17\n-\t      && ! MUST_SAVE_REGISTER (GP_REG_FIRST + 16))\n-\t    {\n-\t      gp_reg_size += UNITS_PER_WORD;\n-\t      mask |= 1L << 16;\n-\t    }\n-\t}\n-    }\n+    if (mips_save_reg_p (regno))\n+      {\n+\tgp_reg_size += GET_MODE_SIZE (gpr_mode);\n+\tmask |= 1L << (regno - GP_REG_FIRST);\n+      }\n \n   /* We need to restore these for the handler.  */\n   if (current_function_calls_eh_return)\n@@ -6759,7 +6858,7 @@ compute_frame_size (size)\n        regno >= FP_REG_FIRST;\n        regno -= FP_INC)\n     {\n-      if (regs_ever_live[regno] && !call_used_regs[regno])\n+      if (mips_save_reg_p (regno))\n \t{\n \t  fp_reg_size += FP_INC * UNITS_PER_FPREG;\n \t  fmask |= ((1 << FP_INC) - 1) << (regno - FP_REG_FIRST);\n@@ -6769,25 +6868,6 @@ compute_frame_size (size)\n   gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n   total_size += gp_reg_rounded + MIPS_STACK_ALIGN (fp_reg_size);\n \n-  /* The gp reg is caller saved in the 32 bit ABI, so there is no need\n-     for leaf routines (total_size == extra_size) to save the gp reg.\n-     The gp reg is callee saved in the 64 bit ABI, so all routines must\n-     save the gp reg.  This is not a leaf routine if -p, because of the\n-     call to mcount.  */\n-  if (total_size == extra_size\n-      && (mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI)\n-      && ! current_function_profile)\n-    total_size = extra_size = 0;\n-  else if (TARGET_ABICALLS)\n-    {\n-      /* Add the context-pointer to the saved registers.  */\n-      gp_reg_size += UNITS_PER_WORD;\n-      mask |= 1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST);\n-      total_size -= gp_reg_rounded;\n-      gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n-      total_size += gp_reg_rounded;\n-    }\n-\n   /* Add in space reserved on the stack by the callee for storing arguments\n      passed in registers.  */\n   if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n@@ -6801,7 +6881,6 @@ compute_frame_size (size)\n   cfun->machine->frame.total_size = total_size;\n   cfun->machine->frame.var_size = var_size;\n   cfun->machine->frame.args_size = args_size;\n-  cfun->machine->frame.extra_size = extra_size;\n   cfun->machine->frame.gp_reg_size = gp_reg_size;\n   cfun->machine->frame.fp_reg_size = fp_reg_size;\n   cfun->machine->frame.mask = mask;\n@@ -6817,8 +6896,7 @@ compute_frame_size (size)\n       /* When using mips_entry, the registers are always saved at the\n          top of the stack.  */\n       if (! mips_entry)\n-\toffset = (args_size + extra_size + var_size\n-\t\t  + gp_reg_size - GET_MODE_SIZE (gpr_mode));\n+\toffset = args_size + var_size + gp_reg_size - GET_MODE_SIZE (gpr_mode);\n       else\n \toffset = total_size - GET_MODE_SIZE (gpr_mode);\n \n@@ -6833,7 +6911,7 @@ compute_frame_size (size)\n \n   if (fmask)\n     {\n-      unsigned long offset = (args_size + extra_size + var_size\n+      unsigned long offset = (args_size + var_size\n \t\t\t      + gp_reg_rounded + fp_reg_size\n \t\t\t      - FP_INC * UNITS_PER_FPREG);\n       cfun->machine->frame.fp_sp_offset = offset;\n@@ -6850,8 +6928,8 @@ compute_frame_size (size)\n }\n \f\n /* Implement INITIAL_ELIMINATION_OFFSET.  FROM is either the frame\n-   pointer, argument pointer, or return address pointer.  TO is either\n-   the stack pointer or hard frame pointer.  */\n+   pointer or argument pointer.  TO is either the stack pointer or\n+   hard frame pointer.  */\n \n int\n mips_initial_elimination_offset (from, to)\n@@ -6995,7 +7073,6 @@ save_restore_insns (store_p, large_reg, large_offset)\n {\n   long mask = cfun->machine->frame.mask;\n   long fmask = cfun->machine->frame.fmask;\n-  long real_mask = mask;\n   int regno;\n   rtx base_reg_rtx;\n   HOST_WIDE_INT base_offset;\n@@ -7007,12 +7084,6 @@ save_restore_insns (store_p, large_reg, large_offset)\n       && ! BITSET_P (mask, HARD_FRAME_POINTER_REGNUM - GP_REG_FIRST))\n     abort ();\n \n-  /* Do not restore GP under certain conditions.  */\n-  if (! store_p\n-      && TARGET_ABICALLS\n-      && (mips_abi == ABI_32 || mips_abi == ABI_O64))\n-    mask &= ~(1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST));\n-\n   if (mask == 0 && fmask == 0)\n     return;\n \n@@ -7124,11 +7195,8 @@ save_restore_insns (store_p, large_reg, large_offset)\n \t\t    emit_move_insn (gen_rtx (REG, gpr_mode, regno),\n \t\t\t\t    reg_rtx);\n \t\t}\n+\t      gp_offset -= GET_MODE_SIZE (gpr_mode);\n \t    }\n-\t  /* If the restore is being supressed, still take into account\n-\t     the offset at which it is stored.  */\n-\t  if (BITSET_P (real_mask, regno - GP_REG_FIRST))\n-\t    gp_offset -= GET_MODE_SIZE (gpr_mode);\n \t}\n     }\n   else\n@@ -7252,7 +7320,7 @@ mips_output_function_prologue (file, size)\n     {\n       /* .frame FRAMEREG, FRAMESIZE, RETREG */\n       fprintf (file,\n-\t       \"\\t.frame\\t%s,%ld,%s\\t\\t# vars= %ld, regs= %d/%d, args= %d, extra= %ld\\n\",\n+\t       \"\\t.frame\\t%s,%ld,%s\\t\\t# vars= %ld, regs= %d/%d, args= %d, gp= %ld\\n\",\n \t       (reg_names[(frame_pointer_needed)\n \t\t\t  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM]),\n \t       ((frame_pointer_needed && TARGET_MIPS16)\n@@ -7263,7 +7331,8 @@ mips_output_function_prologue (file, size)\n \t       cfun->machine->frame.num_gp,\n \t       cfun->machine->frame.num_fp,\n \t       current_function_outgoing_args_size,\n-\t       cfun->machine->frame.extra_size);\n+\t       cfun->machine->frame.args_size\n+\t       - current_function_outgoing_args_size);\n \n       /* .mask MASK, GPOFFSET; .fmask FPOFFSET */\n       fprintf (file, \"\\t.mask\\t0x%08lx,%ld\\n\\t.fmask\\t0x%08lx,%ld\\n\",\n@@ -7392,25 +7461,33 @@ mips_output_function_prologue (file, size)\n       fprintf (file, \"\\n\");\n     }\n \n-  if (TARGET_ABICALLS && (mips_abi == ABI_32 || mips_abi == ABI_O64))\n-    {\n-      const char *const sp_str = reg_names[STACK_POINTER_REGNUM];\n+  /* Handle the initialization of $gp for SVR4 PIC.  */\n+  if (TARGET_ABICALLS && !TARGET_NEWABI && cfun->machine->global_pointer > 0)\n+    fprintf (file, \"\\t.set\\tnoreorder\\n\\t.cpload\\t%s\\n\\t.set\\treorder\\n\",\n+\t     reg_names[PIC_FUNCTION_ADDR_REGNUM]);\n+}\n+\f\n+/* Emit an instruction to move SRC into DEST.  When generating\n+   explicit reloc code, mark the instruction as potentially dead.  */\n \n-      fprintf (file, \"\\t.set\\tnoreorder\\n\\t.cpload\\t%s\\n\\t.set\\treorder\\n\",\n-\t       reg_names[PIC_FUNCTION_ADDR_REGNUM]);\n-      if (tsize > 0)\n-\t{\n-\t  fprintf (file, \"\\t%s\\t%s,%s,%ld\\n\",\n-\t\t   (ptr_mode == DImode ? \"dsubu\" : \"subu\"),\n-\t\t   sp_str, sp_str, (long) tsize);\n-\t  fprintf (file, \"\\t.cprestore %ld\\n\", cfun->machine->frame.args_size);\n-\t}\n+static void\n+mips_gp_insn (dest, src)\n+     rtx dest, src;\n+{\n+  rtx insn;\n \n-      if (dwarf2out_do_frame ())\n-\tdwarf2out_def_cfa (\"\", STACK_POINTER_REGNUM, tsize);\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, dest, src));\n+  if (TARGET_EXPLICIT_RELOCS)\n+    {\n+      /* compute_frame_size assumes that any function which uses the\n+\t constant pool will need a gp.  However, all constant\n+\t pool references could be eliminated, in which case\n+\t it is OK for flow to delete the gp load as well.  */\n+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_MAYBE_DEAD, const0_rtx,\n+\t\t\t\t\t    REG_NOTES (insn));\n     }\n }\n-\f\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -7432,6 +7509,9 @@ mips_expand_prologue ()\n   int store_args_on_stack = (mips_abi == ABI_32 || mips_abi == ABI_O64)\n                             && (! mips_entry || mips_can_use_return_insn ());\n \n+  if (cfun->machine->global_pointer > 0)\n+    REGNO (pic_offset_table_rtx) = cfun->machine->global_pointer;\n+\n   /* If struct value address is treated as the first argument, make it so.  */\n   if (aggregate_value_p (DECL_RESULT (fndecl))\n       && ! current_function_returns_pcc_struct\n@@ -7558,10 +7638,6 @@ mips_expand_prologue ()\n       int offset = (regno - GP_ARG_FIRST) * UNITS_PER_WORD;\n       rtx ptr = stack_pointer_rtx;\n \n-      /* If we are doing svr4-abi, sp has already been decremented by tsize.  */\n-      if (TARGET_ABICALLS)\n-\toffset += tsize;\n-\n       for (; regno <= GP_ARG_LAST; regno++)\n \t{\n \t  if (offset != 0)\n@@ -7657,8 +7733,7 @@ mips_expand_prologue ()\n       /* If we are doing svr4-abi, sp move is done by\n          function_prologue.  In mips16 mode with a large frame, we\n          save the registers before adjusting the stack.  */\n-      if ((!TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n-\t  && (!TARGET_MIPS16 || tsize <= 32767))\n+      if (!TARGET_MIPS16 || tsize <= 32767)\n \t{\n \t  rtx adjustment_rtx;\n \n@@ -7687,9 +7762,11 @@ mips_expand_prologue ()\n       else if (reg_18_save != NULL_RTX)\n \temit_insn (reg_18_save);\n \n-      if ((!TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n-\t  && TARGET_MIPS16\n-\t  && tsize > 32767)\n+      if (TARGET_ABICALLS && !TARGET_NEWABI && !current_function_is_leaf)\n+\temit_insn (gen_cprestore\n+\t\t   (GEN_INT (current_function_outgoing_args_size)));\n+\n+      if (TARGET_MIPS16 && tsize > 32767)\n \t{\n \t  rtx reg_rtx;\n \n@@ -7718,9 +7795,7 @@ mips_expand_prologue ()\n              instructions when using the frame pointer by pointing the\n              frame pointer ahead of the argument space allocated on\n              the stack.  */\n-\t  if ((! TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n-\t      && TARGET_MIPS16\n-\t      && tsize > 32767)\n+\t  if (TARGET_MIPS16 && tsize > 32767)\n \t    {\n \t      /* In this case, we have already copied the stack\n                  pointer into the frame pointer, above.  We need only\n@@ -7760,10 +7835,24 @@ mips_expand_prologue ()\n \t  if (insn)\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+    }\n+\n+  if (TARGET_ABICALLS && TARGET_NEWABI && cfun->machine->global_pointer > 0)\n+    {\n+      rtx temp, fnsymbol, fnaddr;\n \n-      if (TARGET_ABICALLS && (mips_abi != ABI_32 && mips_abi != ABI_O64))\n-\temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0),\n-\t\t\t       gen_rtx_REG (DImode, 25)));\n+      temp = gen_rtx_REG (Pmode, MIPS_TEMP1_REGNUM);\n+      fnsymbol = XEXP (DECL_RTL (current_function_decl), 0);\n+      fnaddr = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n+\n+      mips_gp_insn (temp, mips_lui_reloc (fnsymbol, RELOC_LOADGP_HI));\n+      mips_gp_insn (temp, gen_rtx_PLUS (Pmode, temp, fnaddr));\n+      mips_gp_insn (pic_offset_table_rtx,\n+\t\t    gen_rtx_PLUS (Pmode, temp,\n+\t\t\t\t  mips_reloc (fnsymbol, RELOC_LOADGP_LO)));\n+\n+      if (!TARGET_EXPLICIT_RELOCS)\n+\temit_insn (gen_loadgp_blockage ());\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -7824,6 +7913,9 @@ mips_output_function_epilogue (file, size)\n   for (string = mips16_strings; string != 0; string = XEXP (string, 1))\n     SYMBOL_REF_FLAG (XEXP (string, 0)) = 0;\n   free_EXPR_LIST_list (&mips16_strings);\n+\n+  /* Reinstate the normal $gp.  */\n+  REGNO (pic_offset_table_rtx) = GLOBAL_POINTER_REGNUM;\n }\n \f\n /* Expand the epilogue into a bunch of separate insns.  SIBCALL_P is true\n@@ -8680,9 +8772,7 @@ mips16_gp_pseudo_reg ()\n \n       /* We want to initialize this to a value which gcc will believe\n          is constant.  */\n-      const_gp = gen_rtx (CONST, Pmode,\n-\t\t\t  gen_rtx (REG, Pmode, GP_REG_FIRST + 28));\n-\n+      const_gp = gen_rtx_CONST (Pmode, pic_offset_table_rtx);\n       start_sequence ();\n       emit_move_insn (cfun->machine->mips16_gp_pseudo_rtx,\n \t\t      const_gp);\n@@ -9223,8 +9313,7 @@ mips16_optimize_gp (first)\n \n       if (gpcopy == NULL_RTX\n \t  && GET_CODE (SET_SRC (set)) == CONST\n-\t  && GET_CODE (XEXP (SET_SRC (set), 0)) == REG\n-\t  && REGNO (XEXP (SET_SRC (set), 0)) == GP_REG_FIRST + 28\n+\t  && XEXP (SET_SRC (set), 0) == pic_offset_table_rtx\n \t  && GET_CODE (SET_DEST (set)) == REG)\n \tgpcopy = SET_DEST (set);\n       else if (slot == NULL_RTX\n@@ -9249,9 +9338,7 @@ mips16_optimize_gp (first)\n \t       && (GET_CODE (SET_DEST (set)) != REG\n \t\t   || REGNO (SET_DEST (set)) != REGNO (gpcopy)\n \t\t   || ((GET_CODE (SET_SRC (set)) != CONST\n-\t\t\t|| GET_CODE (XEXP (SET_SRC (set), 0)) != REG\n-\t\t\t|| (REGNO (XEXP (SET_SRC (set), 0))\n-\t\t\t    != GP_REG_FIRST + 28))\n+\t\t\t|| XEXP (SET_SRC (set), 0) != pic_offset_table_rtx)\n \t\t       && ! rtx_equal_p (SET_SRC (set), slot))))\n \tbreak;\n       else if (slot != NULL_RTX\n@@ -9324,8 +9411,7 @@ mips16_optimize_gp (first)\n \n \t  if (GET_CODE (SET_DEST (set1)) == REG\n \t      && GET_CODE (SET_SRC (set1)) == CONST\n-\t      && GET_CODE (XEXP (SET_SRC (set1), 0)) == REG\n-\t      && REGNO (XEXP (SET_SRC (set1), 0)) == GP_REG_FIRST + 28\n+\t      && XEXP (SET_SRC (set1), 0) == pic_offset_table_rtx\n \t      && rtx_equal_p (SET_DEST (set1), SET_DEST (set2))\n \t      && GET_CODE (SET_SRC (set2)) == PLUS\n \t      && rtx_equal_p (SET_DEST (set1), XEXP (SET_SRC (set2), 0))\n@@ -9387,13 +9473,11 @@ mips16_optimize_gp (first)\n \t       && rtx_equal_p (SET_SRC (set), slot))\n \t{\n \t  enum machine_mode mode;\n+\t  rtx src;\n \n \t  mode = GET_MODE (SET_DEST (set));\n-\t  emit_insn_after (gen_rtx (SET, VOIDmode, SET_DEST (set),\n-\t\t\t\t    gen_rtx (CONST, mode,\n-\t\t\t\t\t     gen_rtx (REG, mode,\n-\t\t\t\t\t\t      GP_REG_FIRST + 28))),\n-\t\t\t   insn);\n+\t  src = gen_rtx_CONST (mode, pic_offset_table_rtx);\n+\t  emit_insn_after (gen_rtx_SET (VOIDmode, SET_DEST (set), src), insn);\n \t  PUT_CODE (insn, NOTE);\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t  NOTE_SOURCE_FILE (insn) = 0;"}, {"sha": "1481d512b551100185f15732a345a891054ae65f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "patch": "@@ -1945,14 +1945,20 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    kept in a register.  */\n #define NO_RECURSIVE_FUNCTION_CSE 1\n \n-/* The register number of the register used to address a table of\n-   static data addresses in memory.  In some cases this register is\n-   defined by a processor's \"application binary interface\" (ABI).\n-   When this macro is defined, RTL is generated for this register\n-   once, as with the stack pointer and frame pointer registers.  If\n-   this macro is not defined, it is up to the machine-dependent\n-   files to allocate such a register (if necessary).  */\n-#define PIC_OFFSET_TABLE_REGNUM (GP_REG_FIRST + 28)\n+/* The ABI-defined global pointer.  Sometimes we use a different\n+   register in leaf functions: see PIC_OFFSET_TABLE_REGNUM.  */\n+#define GLOBAL_POINTER_REGNUM (GP_REG_FIRST + 28)\n+\n+/* We normally use $28 as the global pointer.  However, when generating\n+   n32/64 PIC, it is better for leaf functions to use a call-clobbered\n+   register instead.  They can then avoid saving and restoring $28\n+   and perhaps avoid using a frame at all.\n+\n+   When a leaf function uses something other than $28, mips_expand_prologue\n+   will modify pic_offset_table_rtx in place.  Take the register number\n+   from there after reload.  */\n+#define PIC_OFFSET_TABLE_REGNUM \\\n+  (reload_completed ? REGNO (pic_offset_table_rtx) : GLOBAL_POINTER_REGNUM)\n \n #define PIC_FUNCTION_ADDR_REGNUM (GP_REG_FIRST + 25)\n \f\n@@ -2353,23 +2359,14 @@ extern enum reg_class mips_char_to_class[256];\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n #define STACK_GROWS_DOWNWARD\n \n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-/* #define FRAME_GROWS_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n+/* The offset of the first local variable from the beginning of the frame.\n+   See compute_frame_size for details about the frame layout.  */\n #define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n   (current_function_outgoing_args_size\t\t\t\t\t\\\n-   + (TARGET_ABICALLS ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n+   + (TARGET_ABICALLS && !TARGET_NEWABI\t\t\t\t\t\\\n+      ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n \n /* Offset from the stack pointer register to an item dynamically\n    allocated on the stack, e.g., by `alloca'.\n@@ -2837,13 +2834,6 @@ typedef struct mips_args {\n \t(mips_abi == ABI_EABI && UNITS_PER_FPVALUE >= UNITS_PER_DOUBLE)\n \n \f\n-/* Tell prologue and epilogue if register REGNO should be saved / restored.  */\n-\n-#define MUST_SAVE_REGISTER(regno) \\\n- ((regs_ever_live[regno] && !call_used_regs[regno])\t\t\t\\\n-  || (regno == HARD_FRAME_POINTER_REGNUM && frame_pointer_needed)\t\\\n-  || (regno == (GP_REG_FIRST + 31) && regs_ever_live[GP_REG_FIRST + 31]))\n-\n /* Say that the epilogue uses the return address register.  Note that\n    in the case of sibcalls, the values \"used by the epilogue\" are\n    considered live at the start of the called function.  */"}, {"sha": "3bc3f85a03661893ddf26ce68e2fae9de47506ca", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f833ffd42150a2e69fb37a5b7f9c8216d2613ff8/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=f833ffd42150a2e69fb37a5b7f9c8216d2613ff8", "patch": "@@ -32,9 +32,7 @@\n    (UNSPEC_STORE_DF_HIGH\t 2)\n    (UNSPEC_GET_FNADDR\t\t 4)\n    (UNSPEC_BLOCKAGE\t\t 6)\n-   (UNSPEC_LOADGP\t\t 7)\n-   (UNSPEC_SETJMP\t\t 8)\n-   (UNSPEC_LONGJMP\t\t 9)\n+   (UNSPEC_CPRESTORE\t\t 8)\n    (UNSPEC_EH_RECEIVER\t\t10)\n    (UNSPEC_EH_RETURN\t\t11)\n    (UNSPEC_CONSTTABLE_QI\t12)\n@@ -67,7 +65,9 @@\n    (RELOC_GOT_DISP\t\t104)\n    (RELOC_CALL16\t\t105)\n    (RELOC_CALL_HI\t\t106)\n-   (RELOC_CALL_LO\t\t107)])\n+   (RELOC_CALL_LO\t\t107)\n+   (RELOC_LOADGP_HI\t\t108)\n+   (RELOC_LOADGP_LO\t\t109)])\n \f\n \n ;; ....................\n@@ -5428,21 +5428,28 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SF\")\n    (set_attr \"length\"\t\"4\")])\n \n-;; Instructions to load the global pointer register.\n-;; This is volatile to make sure that the scheduler won't move any symbol_ref\n-;; uses in front of it.  All symbol_refs implicitly use the gp reg.\n+;; The use of gp is hidden when not using explicit relocations.\n+;; This blockage instruction prevents the gp load from being\n+;; scheduled after an implicit use of gp.  It also prevents\n+;; the load from being deleted as dead.\n+(define_insn \"loadgp_blockage\"\n+  [(unspec_volatile [(reg:DI 28)] UNSPEC_BLOCKAGE)]\n+  \"\"\n+  \"\"\n+  [(set_attr \"type\"\t\"unknown\")\n+   (set_attr \"mode\"\t\"none\")\n+   (set_attr \"length\"\t\"0\")])\n \n-(define_insn \"loadgp\"\n-  [(set (reg:DI 28)\n-\t(unspec_volatile:DI [(match_operand 0 \"immediate_operand\" \"\")\n-\t\t\t     (match_operand:DI 1 \"register_operand\" \"\")]\n-\t\t\t    UNSPEC_LOADGP))\n-   (clobber (reg:DI 1))]\n+;; Emit a .cprestore directive, which expands to a single store instruction.\n+;; Note that we continue to use .cprestore for explicit reloc code so that\n+;; jals inside inlines asms will work correctly.\n+(define_insn \"cprestore\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"\")]\n+\t\t    UNSPEC_CPRESTORE)]\n   \"\"\n-  \"%[lui\\\\t$1,%%hi(%%neg(%%gp_rel(%0)))\\\\n\\\\taddiu\\\\t$1,$1,%%lo(%%neg(%%gp_rel(%0)))\\\\n\\\\tdaddu\\\\t$gp,$1,%1%]\"\n-  [(set_attr \"type\"\t\"move\")\n-   (set_attr \"mode\"\t\"DI\")\n-   (set_attr \"length\"\t\"12\")])\n+  \".cprestore\\t%0\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n \f\n ;; Block moves, see mips.c for more details.\n ;; Argument 0 is the destination\n@@ -8776,55 +8783,45 @@ ld\\\\t%2,%1-%S1(%2)\\;daddu\\\\t%2,%2,$31\\\\n\\\\t%*j\\\\t%2\"\n    (set_attr \"mode\"\t\"none\")\n    (set_attr \"length\"\t\"24\")])\n \n-;; For o32/n32/n64, we save the gp in the jmp_buf as well.  While it is\n-;; possible to either pull it off the stack (in the o32 case) or recalculate\n-;; it given t9 and our target label, it takes 3 or 4 insns to do so, and\n-;; this is easy.\n+;; For TARGET_ABICALLS, we save the gp in the jmp_buf as well.\n+;; While it is possible to either pull it off the stack (in the\n+;; o32 case) or recalculate it given t9 and our target label,\n+;; it takes 3 or 4 insns to do so.\n \n (define_expand \"builtin_setjmp_setup\"\n-  [(unspec [(match_operand 0 \"register_operand\" \"r\")] UNSPEC_SETJMP)]\n+  [(use (match_operand 0 \"register_operand\" \"\"))]\n   \"TARGET_ABICALLS\"\n-  \"\n-{\n-  if (Pmode == DImode)\n-    emit_insn (gen_builtin_setjmp_setup_64 (operands[0]));\n-  else\n-    emit_insn (gen_builtin_setjmp_setup_32 (operands[0]));\n-  DONE;\n-}\")\n-\n-(define_expand \"builtin_setjmp_setup_32\"\n-  [(set (mem:SI (plus:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t   (const_int 12)))\n-      (reg:SI 28))]\n-  \"TARGET_ABICALLS && ! (Pmode == DImode)\"\n-  \"\")\n+  {\n+    rtx addr;\n \n-(define_expand \"builtin_setjmp_setup_64\"\n-  [(set (mem:DI (plus:DI (match_operand:DI 0 \"register_operand\" \"r\")\n-\t\t   (const_int 24)))\n-      (reg:DI 28))]\n-  \"TARGET_ABICALLS && Pmode == DImode\"\n-  \"\")\n+    addr = plus_constant (operands[0], GET_MODE_SIZE (Pmode) * 3);\n+    emit_move_insn (gen_rtx_MEM (Pmode, addr), pic_offset_table_rtx);\n+    DONE;\n+  })\n \n-;; For o32/n32/n64, we need to arrange for longjmp to put the\n-;; target address in t9 so that we can use it for loading $gp.\n+;; Restore the gp that we saved above.  Despite the comment, it seems that\n+;; older code did recalculate the gp from $25.  Continue to jump through\n+;; $25 for compatibility (we lose nothing by doing so).\n \n (define_expand \"builtin_longjmp\"\n-  [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")] UNSPEC_LONGJMP)]\n+  [(use (match_operand 0 \"register_operand\" \"r\"))]\n   \"TARGET_ABICALLS\"\n   \"\n {\n   /* The elements of the buffer are, in order:  */\n-  int W = (Pmode == DImode ? 8 : 4);\n+  int W = GET_MODE_SIZE (Pmode);\n   rtx fp = gen_rtx_MEM (Pmode, operands[0]);\n   rtx lab = gen_rtx_MEM (Pmode, plus_constant (operands[0], 1*W));\n   rtx stack = gen_rtx_MEM (Pmode, plus_constant (operands[0], 2*W));\n   rtx gpv = gen_rtx_MEM (Pmode, plus_constant (operands[0], 3*W));\n-  rtx pv = gen_rtx_REG (Pmode, 25);\n-  rtx gp = gen_rtx_REG (Pmode, 28);\n-\n-  /* This bit is the same as expand_builtin_longjmp.  */\n+  rtx pv = gen_rtx_REG (Pmode, PIC_FUNCTION_ADDR_REGNUM);\n+  /* Use gen_raw_REG to avoid being given pic_offset_table_rtx.\n+     The target is bound to be using $28 as the global pointer\n+     but the current function might not be.  */\n+  rtx gp = gen_raw_REG (Pmode, GLOBAL_POINTER_REGNUM);\n+\n+  /* This bit is similar to expand_builtin_longjmp except that it\n+     restores $gp as well.  */\n   emit_move_insn (hard_frame_pointer_rtx, fp);\n   emit_move_insn (pv, lab);\n   emit_stack_restore (SAVE_NONLOCAL, stack, NULL_RTX);"}]}