{"sha": "d81481d3d95364ece0e95fb8d0373bef2e55f50d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxNDgxZDNkOTUzNjRlY2UwZTk1ZmI4ZDAzNzNiZWYyZTU1ZjUwZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-02T18:10:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-02T18:10:47Z"}, "message": "(can_combine_p): Allow an insn with a REG_EQUIV note that reads memory\nto be moved past an insn that writes memory.\n\nFrom-SVN: r5562", "tree": {"sha": "958c1eba283b70add246dda8245e404336270826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/958c1eba283b70add246dda8245e404336270826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d81481d3d95364ece0e95fb8d0373bef2e55f50d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81481d3d95364ece0e95fb8d0373bef2e55f50d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d81481d3d95364ece0e95fb8d0373bef2e55f50d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81481d3d95364ece0e95fb8d0373bef2e55f50d/comments", "author": null, "committer": null, "parents": [{"sha": "1ddb342ad7b20c56b38ad4319f937d2d62c95841", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ddb342ad7b20c56b38ad4319f937d2d62c95841", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ddb342ad7b20c56b38ad4319f937d2d62c95841"}], "stats": {"total": 10, "additions": 7, "deletions": 3}, "files": [{"sha": "c50265681b0c40456d108e7a54ed5ff6cc20e664", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81481d3d95364ece0e95fb8d0373bef2e55f50d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81481d3d95364ece0e95fb8d0373bef2e55f50d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d81481d3d95364ece0e95fb8d0373bef2e55f50d", "patch": "@@ -855,10 +855,14 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \t If the insns are adjacent, a use can't cross a set even though we\n \t think it might (this can happen for a sequence of insns each setting\n \t the same destination; reg_last_set of that register might point to\n-\t a NOTE).  Also, don't move a volatile asm or UNSPEC_VOLATILE across\n-\t any other insns.  */\n+\t a NOTE).  If INSN has a REG_EQUIV note, the register is always\n+\t equivalent to the memory so the substitution is valid even if there\n+\t are intervening stores.  Also, don't move a volatile asm or\n+\t UNSPEC_VOLATILE across any other insns.  */\n       || (! all_adjacent\n-\t  && (use_crosses_set_p (src, INSN_CUID (insn))\n+\t  && (((GET_CODE (src) != MEM\n+\t\t|| ! find_reg_note (insn, REG_EQUIV, src))\n+\t       && use_crosses_set_p (src, INSN_CUID (insn)))\n \t      || (GET_CODE (src) == ASM_OPERANDS && MEM_VOLATILE_P (src))\n \t      || GET_CODE (src) == UNSPEC_VOLATILE))\n       /* If there is a REG_NO_CONFLICT note for DEST in I3 or SUCC, we get"}]}