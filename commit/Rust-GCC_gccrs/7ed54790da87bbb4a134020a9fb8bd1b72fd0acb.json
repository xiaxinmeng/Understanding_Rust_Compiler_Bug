{"sha": "7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VkNTQ3OTBkYTg3YmJiNGExMzQwMjBhOWZiOGJkMWI3MmZkMGFjYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-21T06:40:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-21T06:40:53Z"}, "message": "Pass a vec_info to get_vectype_for_scalar_type\n\n2019-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (get_vectype_for_scalar_type): Take a vec_info.\n\t* tree-vect-stmts.c (get_vectype_for_scalar_type): Likewise.\n\t(vect_prologue_cost_for_slp_op): Update call accordingly.\n\t(vect_get_vec_def_for_operand, vect_get_gather_scatter_ops)\n\t(vect_get_strided_load_store_ops, vectorizable_simd_clone_call)\n\t(vect_supportable_shift, vect_is_simple_cond, vectorizable_comparison)\n\t(get_mask_type_for_scalar_type): Likewise.\n\t(vect_get_vector_types_for_stmt): Likewise.\n\t* tree-vect-data-refs.c (vect_analyze_data_refs): Likewise.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n\t(get_initial_def_for_reduction, build_vect_cond_expr): Likewise.\n\t* tree-vect-patterns.c (vect_supportable_direct_optab_p): Likewise.\n\t(vect_split_statement, vect_convert_input): Likewise.\n\t(vect_recog_widen_op_pattern, vect_recog_pow_pattern): Likewise.\n\t(vect_recog_over_widening_pattern, vect_recog_mulhs_pattern): Likewise.\n\t(vect_recog_average_pattern, vect_recog_cast_forwprop_pattern)\n\t(vect_recog_rotate_pattern, vect_recog_vector_vector_shift_pattern)\n\t(vect_synth_mult_by_constant, vect_recog_mult_pattern): Likewise.\n\t(vect_recog_divmod_pattern, vect_recog_mixed_size_cond_pattern)\n\t(check_bool_pattern, adjust_bool_pattern_cast, adjust_bool_pattern)\n\t(search_type_for_mask_1, vect_recog_bool_pattern): Likewise.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\t(vect_add_conversion_to_pattern): Likewise.\n\t(vect_recog_gather_scatter_pattern): Likewise.\n\t* tree-vect-slp.c (vect_build_slp_tree_2): Likewise.\n\t(vect_analyze_slp_instance, vect_get_constant_vectors): Likewise.\n\nFrom-SVN: r277227", "tree": {"sha": "599ea179e29440c0399990f310c1fa22469b8fd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/599ea179e29440c0399990f310c1fa22469b8fd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1bd5196c9b1a0cd7280adadd6d788f81a82ca023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bd5196c9b1a0cd7280adadd6d788f81a82ca023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bd5196c9b1a0cd7280adadd6d788f81a82ca023"}], "stats": {"total": 190, "additions": 118, "deletions": 72}, "files": [{"sha": "42762a9be4e735c2dec7a66f06a218da34eaee4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -1,3 +1,32 @@\n+2019-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (get_vectype_for_scalar_type): Take a vec_info.\n+\t* tree-vect-stmts.c (get_vectype_for_scalar_type): Likewise.\n+\t(vect_prologue_cost_for_slp_op): Update call accordingly.\n+\t(vect_get_vec_def_for_operand, vect_get_gather_scatter_ops)\n+\t(vect_get_strided_load_store_ops, vectorizable_simd_clone_call)\n+\t(vect_supportable_shift, vect_is_simple_cond, vectorizable_comparison)\n+\t(get_mask_type_for_scalar_type): Likewise.\n+\t(vect_get_vector_types_for_stmt): Likewise.\n+\t* tree-vect-data-refs.c (vect_analyze_data_refs): Likewise.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Likewise.\n+\t(get_initial_def_for_reduction, build_vect_cond_expr): Likewise.\n+\t* tree-vect-patterns.c (vect_supportable_direct_optab_p): Likewise.\n+\t(vect_split_statement, vect_convert_input): Likewise.\n+\t(vect_recog_widen_op_pattern, vect_recog_pow_pattern): Likewise.\n+\t(vect_recog_over_widening_pattern, vect_recog_mulhs_pattern): Likewise.\n+\t(vect_recog_average_pattern, vect_recog_cast_forwprop_pattern)\n+\t(vect_recog_rotate_pattern, vect_recog_vector_vector_shift_pattern)\n+\t(vect_synth_mult_by_constant, vect_recog_mult_pattern): Likewise.\n+\t(vect_recog_divmod_pattern, vect_recog_mixed_size_cond_pattern)\n+\t(check_bool_pattern, adjust_bool_pattern_cast, adjust_bool_pattern)\n+\t(search_type_for_mask_1, vect_recog_bool_pattern): Likewise.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\t(vect_add_conversion_to_pattern): Likewise.\n+\t(vect_recog_gather_scatter_pattern): Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree_2): Likewise.\n+\t(vect_analyze_slp_instance, vect_get_constant_vectors): Likewise.\n+\n 2019-10-21  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (get_mask_type_for_scalar_type): Take a vec_info."}, {"sha": "987dc0ee177fd6728924ef465c1dc76ad8e785a9", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -4344,7 +4344,7 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf, bool *fatal)\n       /* Set vectype for STMT.  */\n       scalar_type = TREE_TYPE (DR_REF (dr));\n       STMT_VINFO_VECTYPE (stmt_info)\n-\t= get_vectype_for_scalar_type (scalar_type);\n+\t= get_vectype_for_scalar_type (vinfo, scalar_type);\n       if (!STMT_VINFO_VECTYPE (stmt_info))\n         {\n           if (dump_enabled_p ())\n@@ -4392,7 +4392,8 @@ vect_analyze_data_refs (vec_info *vinfo, poly_uint64 *min_vf, bool *fatal)\n \t  if (!vect_check_gather_scatter (stmt_info,\n \t\t\t\t\t  as_a <loop_vec_info> (vinfo),\n \t\t\t\t\t  &gs_info)\n-\t      || !get_vectype_for_scalar_type (TREE_TYPE (gs_info.offset)))\n+\t      || !get_vectype_for_scalar_type (vinfo,\n+\t\t\t\t\t       TREE_TYPE (gs_info.offset)))\n \t    {\n \t      if (fatal)\n \t\t*fatal = false;"}, {"sha": "304bb5e597fc8348ce5a8b10298afe3e9ea2cc5d", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -327,7 +327,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t\t\t \"get vectype for scalar type:  %T\\n\",\n \t\t\t\t scalar_type);\n \n-\t      vectype = get_vectype_for_scalar_type (scalar_type);\n+\t      vectype = get_vectype_for_scalar_type (loop_vinfo, scalar_type);\n \t      if (!vectype)\n \t\treturn opt_result::failure_at (phi,\n \t\t\t\t\t       \"not vectorized: unsupported \"\n@@ -3774,7 +3774,7 @@ get_initial_def_for_reduction (stmt_vec_info stmt_vinfo,\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree scalar_type = TREE_TYPE (init_val);\n-  tree vectype = get_vectype_for_scalar_type (scalar_type);\n+  tree vectype = get_vectype_for_scalar_type (loop_vinfo, scalar_type);\n   tree def_for_init;\n   tree init_def;\n   REAL_VALUE_TYPE real_init_val = dconst0;\n@@ -5555,11 +5555,11 @@ build_vect_cond_expr (enum tree_code code, tree vop[3], tree mask,\n    corresponds to the type of arguments to the reduction stmt, and should *NOT*\n    be used to create the vectorized stmt.  The right vectype for the vectorized\n    stmt is obtained from the type of the result X:\n-        get_vectype_for_scalar_type (TREE_TYPE (X))\n+      get_vectype_for_scalar_type (vinfo, TREE_TYPE (X))\n \n    This means that, contrary to \"regular\" reductions (or \"regular\" stmts in\n    general), the following equation:\n-      STMT_VINFO_VECTYPE == get_vectype_for_scalar_type (TREE_TYPE (X))\n+      STMT_VINFO_VECTYPE == get_vectype_for_scalar_type (vinfo, TREE_TYPE (X))\n    does *NOT* necessarily hold for reduction patterns.  */\n \n bool"}, {"sha": "b497ec908d9b8506fd3a4be512df23aa356225f4", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -187,15 +187,15 @@ vect_get_external_def_edge (vec_info *vinfo, tree var)\n    is nonnull.  */\n \n static bool\n-vect_supportable_direct_optab_p (vec_info *, tree otype, tree_code code,\n+vect_supportable_direct_optab_p (vec_info *vinfo, tree otype, tree_code code,\n \t\t\t\t tree itype, tree *vecotype_out,\n \t\t\t\t tree *vecitype_out = NULL)\n {\n-  tree vecitype = get_vectype_for_scalar_type (itype);\n+  tree vecitype = get_vectype_for_scalar_type (vinfo, itype);\n   if (!vecitype)\n     return false;\n \n-  tree vecotype = get_vectype_for_scalar_type (otype);\n+  tree vecotype = get_vectype_for_scalar_type (vinfo, otype);\n   if (!vecotype)\n     return false;\n \n@@ -635,6 +635,7 @@ static bool\n vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n \t\t      gimple *stmt1, tree vectype)\n {\n+  vec_info *vinfo = stmt2_info->vinfo;\n   if (is_pattern_stmt_p (stmt2_info))\n     {\n       /* STMT2_INFO is part of a pattern.  Get the statement to which\n@@ -678,7 +679,7 @@ vect_split_statement (stmt_vec_info stmt2_info, tree new_rhs,\n \t two-statement pattern now.  */\n       gcc_assert (!STMT_VINFO_RELATED_STMT (stmt2_info));\n       tree lhs_type = TREE_TYPE (gimple_get_lhs (stmt2_info->stmt));\n-      tree lhs_vectype = get_vectype_for_scalar_type (lhs_type);\n+      tree lhs_vectype = get_vectype_for_scalar_type (vinfo, lhs_type);\n       if (!lhs_vectype)\n \treturn false;\n \n@@ -715,6 +716,8 @@ static tree\n vect_convert_input (stmt_vec_info stmt_info, tree type,\n \t\t    vect_unpromoted_value *unprom, tree vectype)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n+\n   /* Check for a no-op conversion.  */\n   if (types_compatible_p (type, TREE_TYPE (unprom->op)))\n     return unprom->op;\n@@ -752,7 +755,7 @@ vect_convert_input (stmt_vec_info stmt_info, tree type,\n \t     unsigned promotion.  */\n \t  tree midtype = build_nonstandard_integer_type\n \t    (TYPE_PRECISION (type), TYPE_UNSIGNED (unprom->type));\n-\t  tree vec_midtype = get_vectype_for_scalar_type (midtype);\n+\t  tree vec_midtype = get_vectype_for_scalar_type (vinfo, midtype);\n \t  if (vec_midtype)\n \t    {\n \t      input = vect_recog_temp_ssa_var (midtype, NULL);\n@@ -1189,6 +1192,7 @@ vect_recog_widen_op_pattern (stmt_vec_info last_stmt_info, tree *type_out,\n \t\t\t     tree_code orig_code, tree_code wide_code,\n \t\t\t     bool shift_p, const char *name)\n {\n+  vec_info *vinfo = last_stmt_info->vinfo;\n   gimple *last_stmt = last_stmt_info->stmt;\n \n   vect_unpromoted_value unprom[2];\n@@ -1208,8 +1212,8 @@ vect_recog_widen_op_pattern (stmt_vec_info last_stmt_info, tree *type_out,\n \t\t\t\t\t    TYPE_UNSIGNED (half_type));\n \n   /* Check target support  */\n-  tree vectype = get_vectype_for_scalar_type (half_type);\n-  tree vecitype = get_vectype_for_scalar_type (itype);\n+  tree vectype = get_vectype_for_scalar_type (vinfo, half_type);\n+  tree vecitype = get_vectype_for_scalar_type (vinfo, itype);\n   enum tree_code dummy_code;\n   int dummy_int;\n   auto_vec<tree> dummy_vec;\n@@ -1221,7 +1225,7 @@ vect_recog_widen_op_pattern (stmt_vec_info last_stmt_info, tree *type_out,\n \t\t\t\t\t  &dummy_int, &dummy_vec))\n     return NULL;\n \n-  *type_out = get_vectype_for_scalar_type (type);\n+  *type_out = get_vectype_for_scalar_type (vinfo, type);\n   if (!*type_out)\n     return NULL;\n \n@@ -1342,7 +1346,7 @@ vect_recog_pow_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t\t  if (node->simd_clones == NULL)\n \t\t    return NULL;\n \t\t}\n-\t      *type_out = get_vectype_for_scalar_type (TREE_TYPE (base));\n+\t      *type_out = get_vectype_for_scalar_type (vinfo, TREE_TYPE (base));\n \t      if (!*type_out)\n \t\treturn NULL;\n \t      tree def = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n@@ -1380,7 +1384,7 @@ vect_recog_pow_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   if (TREE_CODE (exp) == REAL_CST\n       && real_equal (&TREE_REAL_CST (exp), &dconsthalf))\n     {\n-      *type_out = get_vectype_for_scalar_type (TREE_TYPE (base));\n+      *type_out = get_vectype_for_scalar_type (vinfo, TREE_TYPE (base));\n       if (*type_out\n \t  && direct_internal_fn_supported_p (IFN_SQRT, *type_out,\n \t\t\t\t\t     OPTIMIZE_FOR_SPEED))\n@@ -1665,7 +1669,7 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n \n   vect_pattern_detected (\"vect_recog_over_widening_pattern\", last_stmt);\n \n-  *type_out = get_vectype_for_scalar_type (type);\n+  *type_out = get_vectype_for_scalar_type (vinfo, type);\n   if (!*type_out)\n     return NULL;\n \n@@ -1686,8 +1690,8 @@ vect_recog_over_widening_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n      wants to rewrite anyway.  If targets have a minimum element size\n      for some optabs, we should pattern-match smaller ops to larger ops\n      where beneficial.  */\n-  tree new_vectype = get_vectype_for_scalar_type (new_type);\n-  tree op_vectype = get_vectype_for_scalar_type (op_type);\n+  tree new_vectype = get_vectype_for_scalar_type (vinfo, new_type);\n+  tree op_vectype = get_vectype_for_scalar_type (vinfo, op_type);\n   if (!new_vectype || !op_vectype)\n     return NULL;\n \n@@ -1864,15 +1868,15 @@ vect_recog_mulhs_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n       (target_precision, TYPE_UNSIGNED (new_type));\n \n   /* Check for target support.  */\n-  tree new_vectype = get_vectype_for_scalar_type (new_type);\n+  tree new_vectype = get_vectype_for_scalar_type (vinfo, new_type);\n   if (!new_vectype\n       || !direct_internal_fn_supported_p\n \t    (ifn, new_vectype, OPTIMIZE_FOR_SPEED))\n     return NULL;\n \n   /* The IR requires a valid vector type for the cast result, even though\n      it's likely to be discarded.  */\n-  *type_out = get_vectype_for_scalar_type (lhs_type);\n+  *type_out = get_vectype_for_scalar_type (vinfo, lhs_type);\n   if (!*type_out)\n     return NULL;\n \n@@ -2014,15 +2018,15 @@ vect_recog_average_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n \t\t\t\t\t       TYPE_UNSIGNED (new_type));\n \n   /* Check for target support.  */\n-  tree new_vectype = get_vectype_for_scalar_type (new_type);\n+  tree new_vectype = get_vectype_for_scalar_type (vinfo, new_type);\n   if (!new_vectype\n       || !direct_internal_fn_supported_p (ifn, new_vectype,\n \t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n     return NULL;\n \n   /* The IR requires a valid vector type for the cast result, even though\n      it's likely to be discarded.  */\n-  *type_out = get_vectype_for_scalar_type (type);\n+  *type_out = get_vectype_for_scalar_type (vinfo, type);\n   if (!*type_out)\n     return NULL;\n \n@@ -2108,7 +2112,7 @@ vect_recog_cast_forwprop_pattern (stmt_vec_info last_stmt_info, tree *type_out)\n      the unnecessary widening and narrowing.  */\n   vect_pattern_detected (\"vect_recog_cast_forwprop_pattern\", last_stmt);\n \n-  *type_out = get_vectype_for_scalar_type (lhs_type);\n+  *type_out = get_vectype_for_scalar_type (vinfo, lhs_type);\n   if (!*type_out)\n     return NULL;\n \n@@ -2219,7 +2223,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t}\n \n       type = TREE_TYPE (lhs);\n-      vectype = get_vectype_for_scalar_type (type);\n+      vectype = get_vectype_for_scalar_type (vinfo, type);\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n@@ -2285,7 +2289,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       && dt != vect_external_def)\n     return NULL;\n \n-  vectype = get_vectype_for_scalar_type (type);\n+  vectype = get_vectype_for_scalar_type (vinfo, type);\n   if (vectype == NULL_TREE)\n     return NULL;\n \n@@ -2404,7 +2408,7 @@ vect_recog_rotate_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n     }\n   else\n     {\n-      tree vecstype = get_vectype_for_scalar_type (stype);\n+      tree vecstype = get_vectype_for_scalar_type (vinfo, stype);\n \n       if (vecstype == NULL_TREE)\n \treturn NULL;\n@@ -2533,7 +2537,7 @@ vect_recog_vector_vector_shift_pattern (stmt_vec_info stmt_vinfo,\n   if (!def_vinfo)\n     return NULL;\n \n-  *type_out = get_vectype_for_scalar_type (TREE_TYPE (oprnd0));\n+  *type_out = get_vectype_for_scalar_type (vinfo, TREE_TYPE (oprnd0));\n   if (*type_out == NULL_TREE)\n     return NULL;\n \n@@ -2556,7 +2560,8 @@ vect_recog_vector_vector_shift_pattern (stmt_vec_info stmt_vinfo,\n \t\t\t\t       TYPE_PRECISION (TREE_TYPE (oprnd1)));\n \t      def = vect_recog_temp_ssa_var (TREE_TYPE (rhs1), NULL);\n \t      def_stmt = gimple_build_assign (def, BIT_AND_EXPR, rhs1, mask);\n-\t      tree vecstype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+\t      tree vecstype = get_vectype_for_scalar_type (vinfo,\n+\t\t\t\t\t\t\t   TREE_TYPE (rhs1));\n \t      append_pattern_def_seq (stmt_vinfo, def_stmt, vecstype);\n \t    }\n \t}\n@@ -2751,7 +2756,7 @@ vect_synth_mult_by_constant (tree op, tree val,\n   if (!possible)\n     return NULL;\n \n-  tree vectype = get_vectype_for_scalar_type (multtype);\n+  tree vectype = get_vectype_for_scalar_type (vinfo, multtype);\n \n   if (!vectype\n       || !target_supports_mult_synth_alg (&alg, variant,\n@@ -2897,6 +2902,7 @@ vect_synth_mult_by_constant (tree op, tree val,\n static gimple *\n vect_recog_mult_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1, vectype, itype;\n   gimple *pattern_stmt;\n@@ -2917,7 +2923,7 @@ vect_recog_mult_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       || !type_has_mode_precision_p (itype))\n     return NULL;\n \n-  vectype = get_vectype_for_scalar_type (itype);\n+  vectype = get_vectype_for_scalar_type (vinfo, itype);\n   if (vectype == NULL_TREE)\n     return NULL;\n \n@@ -2985,6 +2991,7 @@ vect_recog_mult_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n static gimple *\n vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *last_stmt = stmt_vinfo->stmt;\n   tree oprnd0, oprnd1, vectype, itype, cond;\n   gimple *pattern_stmt, *def_stmt;\n@@ -3017,7 +3024,7 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n     return NULL;\n \n   scalar_int_mode itype_mode = SCALAR_INT_TYPE_MODE (itype);\n-  vectype = get_vectype_for_scalar_type (itype);\n+  vectype = get_vectype_for_scalar_type (vinfo, itype);\n   if (vectype == NULL_TREE)\n     return NULL;\n \n@@ -3115,7 +3122,7 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t    {\n \t      tree utype\n \t\t= build_nonstandard_integer_type (prec, 1);\n-\t      tree vecutype = get_vectype_for_scalar_type (utype);\n+\t      tree vecutype = get_vectype_for_scalar_type (vinfo, utype);\n \t      tree shift\n \t\t= build_int_cst (utype, GET_MODE_BITSIZE (itype_mode)\n \t\t\t\t\t- tree_log2 (oprnd1));\n@@ -3433,6 +3440,7 @@ vect_recog_divmod_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n static gimple *\n vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n {\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *last_stmt = stmt_vinfo->stmt;\n   tree cond_expr, then_clause, else_clause;\n   tree type, vectype, comp_vectype, itype = NULL_TREE, vecitype;\n@@ -3455,7 +3463,7 @@ vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n     return NULL;\n \n   comp_scalar_type = TREE_TYPE (TREE_OPERAND (cond_expr, 0));\n-  comp_vectype = get_vectype_for_scalar_type (comp_scalar_type);\n+  comp_vectype = get_vectype_for_scalar_type (vinfo, comp_scalar_type);\n   if (comp_vectype == NULL_TREE)\n     return NULL;\n \n@@ -3503,7 +3511,7 @@ vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   if (GET_MODE_BITSIZE (type_mode) == cmp_mode_size)\n     return NULL;\n \n-  vectype = get_vectype_for_scalar_type (type);\n+  vectype = get_vectype_for_scalar_type (vinfo, type);\n   if (vectype == NULL_TREE)\n     return NULL;\n \n@@ -3518,7 +3526,7 @@ vect_recog_mixed_size_cond_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       || GET_MODE_BITSIZE (SCALAR_TYPE_MODE (itype)) != cmp_mode_size)\n     return NULL;\n \n-  vecitype = get_vectype_for_scalar_type (itype);\n+  vecitype = get_vectype_for_scalar_type (vinfo, itype);\n   if (vecitype == NULL_TREE)\n     return NULL;\n \n@@ -3612,7 +3620,7 @@ check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n \t  if (stmt_could_throw_p (cfun, def_stmt))\n \t    return false;\n \n-\t  comp_vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+\t  comp_vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs1));\n \t  if (comp_vectype == NULL_TREE)\n \t    return false;\n \n@@ -3627,7 +3635,7 @@ check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n \t      scalar_mode mode = SCALAR_TYPE_MODE (TREE_TYPE (rhs1));\n \t      tree itype\n \t\t= build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 1);\n-\t      vecitype = get_vectype_for_scalar_type (itype);\n+\t      vecitype = get_vectype_for_scalar_type (vinfo, itype);\n \t      if (vecitype == NULL_TREE)\n \t\treturn false;\n \t    }\n@@ -3656,10 +3664,11 @@ check_bool_pattern (tree var, vec_info *vinfo, hash_set<gimple *> &stmts)\n static tree\n adjust_bool_pattern_cast (tree type, tree var, stmt_vec_info stmt_info)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   gimple *cast_stmt = gimple_build_assign (vect_recog_temp_ssa_var (type, NULL),\n \t\t\t\t\t   NOP_EXPR, var);\n   append_pattern_def_seq (stmt_info, cast_stmt,\n-\t\t\t  get_vectype_for_scalar_type (type));\n+\t\t\t  get_vectype_for_scalar_type (vinfo, type));\n   return gimple_assign_lhs (cast_stmt);\n }\n \n@@ -3673,6 +3682,7 @@ static void\n adjust_bool_pattern (tree var, tree out_type,\n \t\t     stmt_vec_info stmt_info, hash_map <tree, tree> &defs)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   gimple *stmt = SSA_NAME_DEF_STMT (var);\n   enum tree_code rhs_code, def_rhs_code;\n   tree itype, cond_expr, rhs1, rhs2, irhs1, irhs2;\n@@ -3834,7 +3844,7 @@ adjust_bool_pattern (tree var, tree out_type,\n \n   gimple_set_location (pattern_stmt, loc);\n   append_pattern_def_seq (stmt_info, pattern_stmt,\n-\t\t\t  get_vectype_for_scalar_type (itype));\n+\t\t\t  get_vectype_for_scalar_type (vinfo, itype));\n   defs.put (var, gimple_assign_lhs (pattern_stmt));\n }\n \n@@ -3937,7 +3947,7 @@ search_type_for_mask_1 (tree var, vec_info *vinfo,\n \t      break;\n \t    }\n \n-\t  comp_vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+\t  comp_vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs1));\n \t  if (comp_vectype == NULL_TREE)\n \t    {\n \t      res = NULL_TREE;\n@@ -4052,7 +4062,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       if (! INTEGRAL_TYPE_P (TREE_TYPE (lhs))\n \t  || TYPE_PRECISION (TREE_TYPE (lhs)) == 1)\n \treturn NULL;\n-      vectype = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+      vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (lhs));\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n@@ -4089,7 +4099,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n \t  if (!useless_type_conversion_p (type, TREE_TYPE (lhs)))\n \t    {\n-\t      tree new_vectype = get_vectype_for_scalar_type (type);\n+\t      tree new_vectype = get_vectype_for_scalar_type (vinfo, type);\n \t      append_pattern_def_seq (stmt_vinfo, pattern_stmt, new_vectype);\n \n \t      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n@@ -4105,7 +4115,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   else if (rhs_code == COND_EXPR\n \t   && TREE_CODE (var) == SSA_NAME)\n     {\n-      vectype = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+      vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (lhs));\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n@@ -4119,7 +4129,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n       tree type\n \t= build_nonstandard_integer_type (prec,\n \t\t\t\t\t  TYPE_UNSIGNED (TREE_TYPE (var)));\n-      if (get_vectype_for_scalar_type (type) == NULL_TREE)\n+      if (get_vectype_for_scalar_type (vinfo, type) == NULL_TREE)\n \treturn NULL;\n \n       if (!check_bool_pattern (var, vinfo, bool_stmts))\n@@ -4163,7 +4173,7 @@ vect_recog_bool_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \n \t  cst0 = build_int_cst (type, 0);\n \t  cst1 = build_int_cst (type, 1);\n-\t  new_vectype = get_vectype_for_scalar_type (type);\n+\t  new_vectype = get_vectype_for_scalar_type (vinfo, type);\n \n \t  rhs = vect_recog_temp_ssa_var (type, NULL);\n \t  pattern_stmt = gimple_build_assign (rhs, COND_EXPR, var, cst1, cst0);\n@@ -4264,12 +4274,12 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t{\n \t  int rhs_index = internal_fn_stored_value_index (ifn);\n \t  tree rhs = gimple_call_arg (last_stmt, rhs_index);\n-\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (rhs));\n+\t  vectype1 = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs));\n \t}\n       else\n \t{\n \t  lhs = gimple_call_lhs (last_stmt);\n-\t  vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+\t  vectype1 = get_vectype_for_scalar_type (vinfo, TREE_TYPE (lhs));\n \t}\n \n       tree mask_arg = gimple_call_arg (last_stmt, mask_argno);\n@@ -4322,7 +4332,7 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n   /* Check for cond expression requiring mask conversion.  */\n   if (rhs_code == COND_EXPR)\n     {\n-      vectype1 = get_vectype_for_scalar_type (TREE_TYPE (lhs));\n+      vectype1 = get_vectype_for_scalar_type (vinfo, TREE_TYPE (lhs));\n \n       if (TREE_CODE (rhs1) == SSA_NAME)\n \t{\n@@ -4388,7 +4398,8 @@ vect_recog_mask_conversion_pattern (stmt_vec_info stmt_vinfo, tree *type_out)\n \t      tree wide_scalar_type = build_nonstandard_integer_type\n \t\t(tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype1))),\n \t\t TYPE_UNSIGNED (rhs1_type));\n-\t      tree vectype3 = get_vectype_for_scalar_type (wide_scalar_type);\n+\t      tree vectype3 = get_vectype_for_scalar_type (vinfo,\n+\t\t\t\t\t\t\t   wide_scalar_type);\n \t      if (expand_vec_cond_expr_p (vectype1, vectype3, TREE_CODE (rhs1)))\n \t\treturn NULL;\n \t    }\n@@ -4544,10 +4555,11 @@ vect_add_conversion_to_pattern (tree type, tree value, stmt_vec_info stmt_info)\n   if (useless_type_conversion_p (type, TREE_TYPE (value)))\n     return value;\n \n+  vec_info *vinfo = stmt_info->vinfo;\n   tree new_value = vect_recog_temp_ssa_var (type, NULL);\n   gassign *conversion = gimple_build_assign (new_value, CONVERT_EXPR, value);\n   append_pattern_def_seq (stmt_info, conversion,\n-\t\t\t  get_vectype_for_scalar_type (type));\n+\t\t\t  get_vectype_for_scalar_type (vinfo, type));\n   return new_value;\n }\n \n@@ -4583,7 +4595,8 @@ vect_recog_gather_scatter_pattern (stmt_vec_info stmt_info, tree *type_out)\n     return NULL;\n \n   /* Convert the mask to the right form.  */\n-  tree gs_vectype = get_vectype_for_scalar_type (gs_info.element_type);\n+  tree gs_vectype = get_vectype_for_scalar_type (loop_vinfo,\n+\t\t\t\t\t\t gs_info.element_type);\n   if (mask)\n     mask = vect_convert_mask_for_vectype (mask, gs_vectype, stmt_info,\n \t\t\t\t\t  loop_vinfo);"}, {"sha": "886bbce43ec8e898cd28b419f09105fb8813fad7", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -1127,7 +1127,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n   if (gphi *stmt = dyn_cast <gphi *> (stmt_info->stmt))\n     {\n       tree scalar_type = TREE_TYPE (PHI_RESULT (stmt));\n-      tree vectype = get_vectype_for_scalar_type (scalar_type);\n+      tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n       if (!vect_record_max_nunits (stmt_info, group_size, vectype, max_nunits))\n \treturn NULL;\n \n@@ -1926,7 +1926,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       scalar_type = TREE_TYPE (DR_REF (dr));\n-      vectype = get_vectype_for_scalar_type (scalar_type);\n+      vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n       group_size = DR_GROUP_SIZE (stmt_info);\n     }\n   else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n@@ -3287,6 +3287,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n {\n   vec<stmt_vec_info> stmts = SLP_TREE_SCALAR_STMTS (slp_node);\n   stmt_vec_info stmt_vinfo = stmts[0];\n+  vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *stmt = stmt_vinfo->stmt;\n   unsigned HOST_WIDE_INT nunits;\n   tree vec_cst;\n@@ -3310,7 +3311,7 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n     vector_type\n       = build_same_sized_truth_vector_type (STMT_VINFO_VECTYPE (stmt_vinfo));\n   else\n-    vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+    vector_type = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op));\n \n   if (STMT_VINFO_DATA_REF (stmt_vinfo))\n     {"}, {"sha": "35fe141870cdf4a4e5f62805922a0bbdb747046f", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -796,14 +796,15 @@ vect_prologue_cost_for_slp_op (slp_tree node, stmt_vec_info stmt_info,\n \t\t\t       unsigned opno, enum vect_def_type dt,\n \t\t\t       stmt_vector_for_cost *cost_vec)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0]->stmt;\n   tree op = gimple_op (stmt, opno);\n   unsigned prologue_cost = 0;\n \n   /* Without looking at the actual initializer a vector of\n      constants can be implemented as load from the constant pool.\n      When all elements are the same we can use a splat.  */\n-  tree vectype = get_vectype_for_scalar_type (TREE_TYPE (op));\n+  tree vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (op));\n   unsigned group_size = SLP_TREE_SCALAR_STMTS (node).length ();\n   unsigned num_vects_to_check;\n   unsigned HOST_WIDE_INT const_nunits;\n@@ -1610,7 +1611,7 @@ vect_get_vec_def_for_operand (tree op, stmt_vec_info stmt_vinfo, tree vectype)\n \t       && VECTOR_BOOLEAN_TYPE_P (stmt_vectype))\n \tvector_type = build_same_sized_truth_vector_type (stmt_vectype);\n       else\n-\tvector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\tvector_type = get_vectype_for_scalar_type (loop_vinfo, TREE_TYPE (op));\n \n       gcc_assert (vector_type);\n       return vect_init_vector (stmt_vinfo, op, vector_type, NULL);\n@@ -2975,6 +2976,7 @@ vect_get_gather_scatter_ops (class loop *loop, stmt_vec_info stmt_info,\n \t\t\t     gather_scatter_info *gs_info,\n \t\t\t     tree *dataref_ptr, tree *vec_offset)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   gimple_seq stmts = NULL;\n   *dataref_ptr = force_gimple_operand (gs_info->base, &stmts, true, NULL_TREE);\n   if (stmts != NULL)\n@@ -2985,7 +2987,7 @@ vect_get_gather_scatter_ops (class loop *loop, stmt_vec_info stmt_info,\n       gcc_assert (!new_bb);\n     }\n   tree offset_type = TREE_TYPE (gs_info->offset);\n-  tree offset_vectype = get_vectype_for_scalar_type (offset_type);\n+  tree offset_vectype = get_vectype_for_scalar_type (vinfo, offset_type);\n   *vec_offset = vect_get_vec_def_for_operand (gs_info->offset, stmt_info,\n \t\t\t\t\t      offset_vectype);\n }\n@@ -3020,7 +3022,7 @@ vect_get_strided_load_store_ops (stmt_vec_info stmt_info,\n   /* The offset given in GS_INFO can have pointer type, so use the element\n      type of the vector instead.  */\n   tree offset_type = TREE_TYPE (gs_info->offset);\n-  tree offset_vectype = get_vectype_for_scalar_type (offset_type);\n+  tree offset_vectype = get_vectype_for_scalar_type (loop_vinfo, offset_type);\n   offset_type = TREE_TYPE (offset_vectype);\n \n   /* Calculate X = DR_STEP / SCALE and convert it to the appropriate type.  */\n@@ -4101,9 +4103,8 @@ vectorizable_simd_clone_call (stmt_vec_info stmt_info,\n \t || arginfo[i].dt == vect_external_def)\n \t&& bestn->simdclone->args[i].arg_type == SIMD_CLONE_ARG_TYPE_VECTOR)\n       {\n-\targinfo[i].vectype\n-\t  = get_vectype_for_scalar_type (TREE_TYPE (gimple_call_arg (stmt,\n-\t\t\t\t\t\t\t\t     i)));\n+\ttree arg_type = TREE_TYPE (gimple_call_arg (stmt, i));\n+\targinfo[i].vectype = get_vectype_for_scalar_type (vinfo, arg_type);\n \tif (arginfo[i].vectype == NULL\n \t    || (simd_clone_subparts (arginfo[i].vectype)\n \t\t> bestn->simdclone->simdlen))\n@@ -5466,15 +5467,15 @@ vectorizable_assignment (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n    either as shift by a scalar or by a vector.  */\n \n bool\n-vect_supportable_shift (vec_info *, enum tree_code code, tree scalar_type)\n+vect_supportable_shift (vec_info *vinfo, enum tree_code code, tree scalar_type)\n {\n \n   machine_mode vec_mode;\n   optab optab;\n   int icode;\n   tree vectype;\n \n-  vectype = get_vectype_for_scalar_type (scalar_type);\n+  vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n   if (!vectype)\n     return false;\n \n@@ -9763,7 +9764,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo,\n \tscalar_type = build_nonstandard_integer_type\n \t  (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (vectype))),\n \t   TYPE_UNSIGNED (scalar_type));\n-      *comp_vectype = get_vectype_for_scalar_type (scalar_type);\n+      *comp_vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n     }\n \n   return true;\n@@ -10359,7 +10360,7 @@ vectorizable_comparison (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n   /* Invariant comparison.  */\n   if (!vectype)\n     {\n-      vectype = get_vectype_for_scalar_type (TREE_TYPE (rhs1));\n+      vectype = get_vectype_for_scalar_type (vinfo, TREE_TYPE (rhs1));\n       if (maybe_ne (TYPE_VECTOR_SUBPARTS (vectype), nunits))\n \treturn false;\n     }\n@@ -11140,7 +11141,7 @@ poly_uint64 current_vector_size;\n    by the target.  */\n \n tree\n-get_vectype_for_scalar_type (tree scalar_type)\n+get_vectype_for_scalar_type (vec_info *, tree scalar_type)\n {\n   tree vectype;\n   vectype = get_vectype_for_scalar_type_and_size (scalar_type,\n@@ -11157,9 +11158,9 @@ get_vectype_for_scalar_type (tree scalar_type)\n    of vectors of specified SCALAR_TYPE as supported by target.  */\n \n tree\n-get_mask_type_for_scalar_type (vec_info *, tree scalar_type)\n+get_mask_type_for_scalar_type (vec_info *vinfo, tree scalar_type)\n {\n-  tree vectype = get_vectype_for_scalar_type (scalar_type);\n+  tree vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n \n   if (!vectype)\n     return NULL;\n@@ -11853,6 +11854,7 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n \t\t\t\ttree *stmt_vectype_out,\n \t\t\t\ttree *nunits_vectype_out)\n {\n+  vec_info *vinfo = stmt_info->vinfo;\n   gimple *stmt = stmt_info->stmt;\n \n   *stmt_vectype_out = NULL_TREE;\n@@ -11919,7 +11921,7 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n-      vectype = get_vectype_for_scalar_type (scalar_type);\n+      vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n       if (!vectype)\n \treturn opt_result::failure_at (stmt,\n \t\t\t\t       \"not vectorized:\"\n@@ -11952,7 +11954,7 @@ vect_get_vector_types_for_stmt (stmt_vec_info stmt_info,\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"get vectype for scalar type:  %T\\n\", scalar_type);\n-      nunits_vectype = get_vectype_for_scalar_type (scalar_type);\n+      nunits_vectype = get_vectype_for_scalar_type (vinfo, scalar_type);\n     }\n   if (!nunits_vectype)\n     return opt_result::failure_at (stmt,"}, {"sha": "108e704eaf176093c6eba63d83287cd4f2b3852b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ed54790da87bbb4a134020a9fb8bd1b72fd0acb/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=7ed54790da87bbb4a134020a9fb8bd1b72fd0acb", "patch": "@@ -1589,7 +1589,7 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n extern poly_uint64 current_vector_size;\n-extern tree get_vectype_for_scalar_type (tree);\n+extern tree get_vectype_for_scalar_type (vec_info *, tree);\n extern tree get_vectype_for_scalar_type_and_size (tree, poly_uint64);\n extern tree get_mask_type_for_scalar_type (vec_info *, tree);\n extern tree get_same_sized_vectype (tree, tree);"}]}