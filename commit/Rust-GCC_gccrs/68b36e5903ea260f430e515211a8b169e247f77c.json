{"sha": "68b36e5903ea260f430e515211a8b169e247f77c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhiMzZlNTkwM2VhMjYwZjQzMGU1MTUyMTFhOGIxNjllMjQ3Zjc3Yw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-01-13T15:37:09Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-01-13T15:37:09Z"}, "message": "re PR tree-optimization/33562 (aggregate DSE disabled)\n\n\tPR tree-optimization/33562\n\tPR tree-optimization/61912\n\tPR tree-optimization/77485\n\t* sbitmap.h (bitmap_count_bits): Prototype.\n\t(bitmap_clear_range, bitmap_set_range): Likewise.\n\t* sbitmap.c (bitmap_clear_range): New function.\n\t(bitmap_set_range, sbitmap_popcount, bitmap_count_bits): Likewise.\n\nFrom-SVN: r244441", "tree": {"sha": "65333dee070ad358beea984d61b8f1e9bc058937", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65333dee070ad358beea984d61b8f1e9bc058937"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68b36e5903ea260f430e515211a8b169e247f77c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b36e5903ea260f430e515211a8b169e247f77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b36e5903ea260f430e515211a8b169e247f77c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b36e5903ea260f430e515211a8b169e247f77c/comments", "author": null, "committer": null, "parents": [{"sha": "90aa73309eafd5458a1c39b12cbdc7baddca9a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90aa73309eafd5458a1c39b12cbdc7baddca9a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90aa73309eafd5458a1c39b12cbdc7baddca9a2e"}], "stats": {"total": 177, "additions": 177, "deletions": 0}, "files": [{"sha": "d6b95eb1d59b935217940065560e21d67c3aeb0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b36e5903ea260f430e515211a8b169e247f77c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b36e5903ea260f430e515211a8b169e247f77c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68b36e5903ea260f430e515211a8b169e247f77c", "patch": "@@ -1,3 +1,13 @@\n+2017-01-13  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/33562\n+\tPR tree-optimization/61912\n+\tPR tree-optimization/77485\n+\t* sbitmap.h (bitmap_count_bits): Prototype.\n+\t(bitmap_clear_range, bitmap_set_range): Likewise.\n+\t* sbitmap.c (bitmap_clear_range): New function.\n+\t(bitmap_set_range, sbitmap_popcount, bitmap_count_bits): Likewise.\n+\n 2017-01-13  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/79043"}, {"sha": "c065d1317675e5f47907400e14bf22953acb1cd1", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b36e5903ea260f430e515211a8b169e247f77c/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b36e5903ea260f430e515211a8b169e247f77c/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=68b36e5903ea260f430e515211a8b169e247f77c", "patch": "@@ -202,6 +202,170 @@ bitmap_empty_p (const_sbitmap bmap)\n   return true;\n }\n \n+/* Clear COUNT bits from START in BMAP.  */\n+\n+void\n+bitmap_clear_range (sbitmap bmap, unsigned int start, unsigned int count)\n+{\n+  if (count == 0)\n+    return;\n+\n+  unsigned int start_word = start / SBITMAP_ELT_BITS;\n+  unsigned int start_bitno = start % SBITMAP_ELT_BITS;\n+\n+  /* Clearing less than a full word, starting at the beginning of a word.  */\n+  if (start_bitno == 0 && count < SBITMAP_ELT_BITS)\n+    {\n+      SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << count) - 1;\n+      bmap->elms[start_word] &= ~mask;\n+      return;\n+    }\n+\n+  unsigned int end_word = (start + count) / SBITMAP_ELT_BITS;\n+  unsigned int end_bitno = (start + count) % SBITMAP_ELT_BITS;\n+\n+  /* Clearing starts somewhere in the middle of the first word.  Clear up to\n+     the end of the first word or the end of the requested region, whichever\n+     comes first.  */\n+  if (start_bitno != 0)\n+    {\n+      unsigned int nbits = ((start_word == end_word)\n+\t\t\t    ? end_bitno - start_bitno\n+\t\t\t    : SBITMAP_ELT_BITS - start_bitno);\n+      SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << nbits) - 1;\n+      mask <<= start_bitno;\n+      bmap->elms[start_word] &= ~mask;\n+      start_word++;\n+      count -= nbits;\n+    }\n+\n+  if (count == 0)\n+    return;\n+\n+  /* Now clear words at a time until we hit a partial word.  */\n+  unsigned int nwords = (end_word - start_word);\n+  if (nwords)\n+    {\n+      memset (&bmap->elms[start_word], 0, nwords * sizeof (SBITMAP_ELT_TYPE));\n+      count -= nwords * sizeof (SBITMAP_ELT_TYPE) * BITS_PER_UNIT;\n+      start_word += nwords;\n+    }\n+\n+  if (count == 0)\n+    return;\n+\n+  /* Now handle residuals in the last word.  */\n+  SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << count) - 1;\n+  bmap->elms[start_word] &= ~mask;\n+}\n+\n+/* Set COUNT bits from START in BMAP.  */\n+void\n+bitmap_set_range (sbitmap bmap, unsigned int start, unsigned int count)\n+{\n+  if (count == 0)\n+    return;\n+\n+  unsigned int start_word = start / SBITMAP_ELT_BITS;\n+  unsigned int start_bitno = start % SBITMAP_ELT_BITS;\n+\n+  /* Setting less than a full word, starting at the beginning of a word.  */\n+  if (start_bitno == 0 && count < SBITMAP_ELT_BITS)\n+    {\n+      SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << count) - 1;\n+      bmap->elms[start_word] |= mask;\n+      return;\n+    }\n+\n+  unsigned int end_word = (start + count) / SBITMAP_ELT_BITS;\n+  unsigned int end_bitno = (start + count) % SBITMAP_ELT_BITS;\n+\n+  /* Setting starts somewhere in the middle of the first word.  Set up to\n+     the end of the first word or the end of the requested region, whichever\n+     comes first.  */\n+  if (start_bitno != 0)\n+    {\n+      unsigned int nbits = ((start_word == end_word)\n+\t\t\t    ? end_bitno - start_bitno\n+\t\t\t    : SBITMAP_ELT_BITS - start_bitno);\n+      SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << nbits) - 1;\n+      mask <<= start_bitno;\n+      bmap->elms[start_word] |= mask;\n+      start_word++;\n+      count -= nbits;\n+    }\n+\n+  if (count == 0)\n+    return;\n+\n+  /* Now set words at a time until we hit a partial word.  */\n+  unsigned int nwords = (end_word - start_word);\n+  if (nwords)\n+    {\n+      memset (&bmap->elms[start_word], 0xff,\n+\t      nwords * sizeof (SBITMAP_ELT_TYPE));\n+      count -= nwords * sizeof (SBITMAP_ELT_TYPE) * BITS_PER_UNIT;\n+      start_word += nwords;\n+    }\n+\n+  if (count == 0)\n+    return;\n+\n+  /* Now handle residuals in the last word.  */\n+  SBITMAP_ELT_TYPE mask = ((SBITMAP_ELT_TYPE)1 << count) - 1;\n+  bmap->elms[start_word] |= mask;\n+}\n+\n+#if GCC_VERSION < 3400\n+/* Table of number of set bits in a character, indexed by value of char.  */\n+static const unsigned char popcount_table[] =\n+{\n+    0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n+    3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8,\n+};\n+\n+static unsigned long\n+sbitmap_popcount (SBITMAP_ELT_TYPE a)\n+{\n+  unsigned long ret = 0;\n+  unsigned i;\n+\n+  /* Just do this the table way for now  */\n+  for (i = 0; i < HOST_BITS_PER_WIDEST_FAST_INT; i += 8)\n+    ret += popcount_table[(a >> i) & 0xff];\n+  return ret;\n+}\n+#endif\n+\n+/* Count and return the number of bits set in the bitmap BMAP.  */\n+\n+unsigned int\n+bitmap_count_bits (const_sbitmap bmap)\n+{\n+  unsigned int count = 0;\n+  for (unsigned int i = 0; i < bmap->size; i++)\n+    if (bmap->elms[i])\n+      {\n+#if GCC_VERSION < 3400\n+\tcount += sbitmap_popcount (bmap->elms[i]);\n+#else\n+# if HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONG\n+\tcount += __builtin_popcountl (bmap->elms[i]);\n+# elif HOST_BITS_PER_WIDEST_FAST_INT == HOST_BITS_PER_LONGLONG\n+\tcount += __builtin_popcountll (bmap->elms[i]);\n+# else\n+\tcount += __builtin_popcount (bmap->elms[i]);\n+# endif\n+#endif\n+      }\n+  return count;\n+}\n \n /* Zero all elements in a bitmap.  */\n "}, {"sha": "ce4d27d927c2b8553f54ea1baf5e5c6230d6f55b", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b36e5903ea260f430e515211a8b169e247f77c/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b36e5903ea260f430e515211a8b169e247f77c/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=68b36e5903ea260f430e515211a8b169e247f77c", "patch": "@@ -231,8 +231,11 @@ extern sbitmap *sbitmap_vector_alloc (unsigned int, unsigned int);\n extern sbitmap sbitmap_resize (sbitmap, unsigned int, int);\n extern void bitmap_copy (sbitmap, const_sbitmap);\n extern int bitmap_equal_p (const_sbitmap, const_sbitmap);\n+extern unsigned int bitmap_count_bits (const_sbitmap);\n extern bool bitmap_empty_p (const_sbitmap);\n extern void bitmap_clear (sbitmap);\n+extern void bitmap_clear_range (sbitmap, unsigned, unsigned);\n+extern void bitmap_set_range (sbitmap, unsigned, unsigned);\n extern void bitmap_ones (sbitmap);\n extern void bitmap_vector_clear (sbitmap *, unsigned int);\n extern void bitmap_vector_ones (sbitmap *, unsigned int);"}]}