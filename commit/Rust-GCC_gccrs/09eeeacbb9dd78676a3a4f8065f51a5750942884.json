{"sha": "09eeeacbb9dd78676a3a4f8065f51a5750942884", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDllZWVhY2JiOWRkNzg2NzZhM2E0ZjgwNjVmNTFhNTc1MDk0Mjg4NA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2002-07-18T00:15:32Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2002-07-18T00:15:32Z"}, "message": "rs6000.c (first_reg_to_save): Remove bogus adjustments to first_reg for profiling case.\n\n\t* config/rs6000/rs6000.c (first_reg_to_save): Remove bogus\n\tadjustments to first_reg for profiling case.\n\t(output_function_profiler): Correct lr save slot for ABI_AIX_NODESC.\n\tDisable profiling for 64 bit code on both ABI_V4 and ABI_AIX_NODESC.\n\tSave static chain reg to sp + 12 on ABI_AIX_NODESC.\n\t* config/rs6000/sysv4.h (ASM_OUTPUT_REG_PUSH): Define.\n\t(ASM_OUTPUT_REG_POP): Define.\n\t* config/rs6000/linux64.h (ASM_OUTPUT_REG_PUSH): Undef.\n\t(ASM_OUTPUT_REG_POP): Undef.\n\nFrom-SVN: r55544", "tree": {"sha": "7bbbbdf1afe78787c81b597e6061faf1b3b84c6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bbbbdf1afe78787c81b597e6061faf1b3b84c6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09eeeacbb9dd78676a3a4f8065f51a5750942884", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09eeeacbb9dd78676a3a4f8065f51a5750942884", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09eeeacbb9dd78676a3a4f8065f51a5750942884", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09eeeacbb9dd78676a3a4f8065f51a5750942884/comments", "author": null, "committer": null, "parents": [{"sha": "a1fa4e3170490d0c0089110b63578f772d04752b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1fa4e3170490d0c0089110b63578f772d04752b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1fa4e3170490d0c0089110b63578f772d04752b"}], "stats": {"total": 137, "additions": 76, "deletions": 61}, "files": [{"sha": "044eda69809948a2f8c9799f6ed75d8a0de63fa1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09eeeacbb9dd78676a3a4f8065f51a5750942884", "patch": "@@ -1,3 +1,15 @@\n+2002-07-18  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (first_reg_to_save): Remove bogus\n+\tadjustments to first_reg for profiling case.\n+\t(output_function_profiler): Correct lr save slot for ABI_AIX_NODESC.\n+\tDisable profiling for 64 bit code on both ABI_V4 and ABI_AIX_NODESC.\n+\tSave static chain reg to sp + 12 on ABI_AIX_NODESC.\n+\t* config/rs6000/sysv4.h (ASM_OUTPUT_REG_PUSH): Define.\n+\t(ASM_OUTPUT_REG_POP): Define.\n+\t* config/rs6000/linux64.h (ASM_OUTPUT_REG_PUSH): Undef.\n+\t(ASM_OUTPUT_REG_POP): Undef.\n+\n 2002-07-17  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* cpplib.c (do_sccs): Handle #sccs on all systems."}, {"sha": "7a905983757de48eab7201b6f8bb41222adedd98", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=09eeeacbb9dd78676a3a4f8065f51a5750942884", "patch": "@@ -329,3 +329,7 @@ do\t\t\t\t\t\t\t\t\t\\\n     sym_lineno += 1;\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n+\n+/* Override sysv4.h as these are ABI_V4 only.  */\n+#undef\tASM_OUTPUT_REG_PUSH\n+#undef\tASM_OUTPUT_REG_POP"}, {"sha": "94b35ff16f37f73f874d2703fd295ffbb74d356c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 28, "deletions": 61, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=09eeeacbb9dd78676a3a4f8065f51a5750942884", "patch": "@@ -7356,53 +7356,6 @@ first_reg_to_save ()\n \t\t    || (DEFAULT_ABI == ABI_DARWIN && flag_pic)))))\n       break;\n \n-  if (current_function_profile)\n-    {\n-      /* AIX must save/restore every register that contains a parameter\n-\t before/after the .__mcount call plus an additional register\n-\t for the static chain, if needed; use registers from 30 down to 22\n-\t to do this.  */\n-      if (DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n-\t{\n-\t  int last_parm_reg, profile_first_reg;\n-\n-\t  /* Figure out last used parameter register.  The proper thing\n-\t     to do is to walk incoming args of the function.  A function\n-\t     might have live parameter registers even if it has no\n-\t     incoming args.  */\n-\t  for (last_parm_reg = 10;\n-\t       last_parm_reg > 2 && ! regs_ever_live [last_parm_reg];\n-\t       last_parm_reg--)\n-\t    ;\n-\n-\t  /* Calculate first reg for saving parameter registers\n-\t     and static chain.\n-\t     Skip reg 31 which may contain the frame pointer.  */\n-\t  profile_first_reg = (33 - last_parm_reg\n-\t\t\t       - (current_function_needs_context ? 1 : 0));\n-#if TARGET_MACHO\n-          /* Need to skip another reg to account for R31 being PICBASE\n-             (when flag_pic is set) or R30 being used as the frame\n-             pointer (when flag_pic is not set).  */\n-          --profile_first_reg;\n-#endif\n-\t  /* Do not save frame pointer if no parameters needs to be saved.  */\n-\t  if (profile_first_reg == 31)\n-\t    profile_first_reg = 32;\n-\n-\t  if (first_reg > profile_first_reg)\n-\t    first_reg = profile_first_reg;\n-\t}\n-\n-      /* SVR4 may need one register to preserve the static chain.  */\n-      else if (current_function_needs_context)\n-\t{\n-\t  /* Skip reg 31 which may contain the frame pointer.  */\n-\t  if (first_reg > 30)\n-\t    first_reg = 30;\n-\t}\n-    }\n-\n #if TARGET_MACHO\n   if (flag_pic && current_function_uses_pic_offset_table &&\n       (first_reg > RS6000_PIC_OFFSET_TABLE_REGNUM))\n@@ -10429,6 +10382,7 @@ output_function_profiler (file, labelno)\n   int labelno;\n {\n   char buf[100];\n+  int save_lr = 8;\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, \"LP\", labelno);\n   switch (DEFAULT_ABI)\n@@ -10437,22 +10391,30 @@ output_function_profiler (file, labelno)\n       abort ();\n \n     case ABI_V4:\n+      save_lr = 4;\n+      /* Fall through.  */\n+\n     case ABI_AIX_NODESC:\n+      if (!TARGET_32BIT)\n+\t{\n+\t  warning (\"no profiling of 64-bit code for this ABI\");\n+\t  return;\n+\t}\n       fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n       if (flag_pic == 1)\n \t{\n \t  fputs (\"\\tbl _GLOBAL_OFFSET_TABLE_@local-4\\n\", file);\n-\t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\",\n-\t\t       reg_names[0], reg_names[1]);\n+\t  asm_fprintf (file, \"\\t{st|stw} %s,%d(%s)\\n\",\n+\t\t       reg_names[0], save_lr, reg_names[1]);\n \t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[12]);\n \t  asm_fprintf (file, \"\\t{l|lwz} %s,\", reg_names[0]);\n \t  assemble_name (file, buf);\n \t  asm_fprintf (file, \"@got(%s)\\n\", reg_names[12]);\n \t}\n       else if (flag_pic > 1)\n \t{\n-\t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\",\n-\t\t       reg_names[0], reg_names[1]);\n+\t  asm_fprintf (file, \"\\t{st|stw} %s,%d(%s)\\n\",\n+\t\t       reg_names[0], save_lr, reg_names[1]);\n \t  /* Now, we need to get the address of the label.  */\n \t  fputs (\"\\tbl 1f\\n\\t.long \", file);\n \t  assemble_name (file, buf);\n@@ -10468,27 +10430,32 @@ output_function_profiler (file, labelno)\n \t  asm_fprintf (file, \"\\t{liu|lis} %s,\", reg_names[12]);\n \t  assemble_name (file, buf);\n \t  fputs (\"@ha\\n\", file);\n-\t  asm_fprintf (file, \"\\t{st|stw} %s,4(%s)\\n\",\n-\t\t       reg_names[0], reg_names[1]);\n+\t  asm_fprintf (file, \"\\t{st|stw} %s,%d(%s)\\n\",\n+\t\t       reg_names[0], save_lr, reg_names[1]);\n \t  asm_fprintf (file, \"\\t{cal|la} %s,\", reg_names[0]);\n \t  assemble_name (file, buf);\n \t  asm_fprintf (file, \"@l(%s)\\n\", reg_names[12]);\n \t}\n \n-      if (current_function_needs_context)\n-\tasm_fprintf (file, \"\\tmr %s,%s\\n\",\n-\t\t     reg_names[30], reg_names[STATIC_CHAIN_REGNUM]);\n-      fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n-      if (current_function_needs_context)\n-\tasm_fprintf (file, \"\\tmr %s,%s\\n\",\n-\t\t     reg_names[STATIC_CHAIN_REGNUM], reg_names[30]);\n+      if (current_function_needs_context && DEFAULT_ABI == ABI_AIX_NODESC)\n+\t{\n+\t  asm_fprintf (file, \"\\t{st|stw} %s,%d(%s)\\n\",\n+\t\t       reg_names[STATIC_CHAIN_REGNUM],\n+\t\t       12, reg_names[1]);\n+\t  fprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n+\t  asm_fprintf (file, \"\\t{l|lwz} %s,%d(%s)\\n\",\n+\t\t       reg_names[STATIC_CHAIN_REGNUM],\n+\t\t       12, reg_names[1]);\n+\t}\n+      else\n+\t/* ABI_V4 saves the static chain reg with ASM_OUTPUT_REG_PUSH.  */\n+\tfprintf (file, \"\\tbl %s\\n\", RS6000_MCOUNT);\n       break;\n \n     case ABI_AIX:\n     case ABI_DARWIN:\n       /* Don't do anything, done in output_profile_hook ().  */\n       break;\n-\n     }\n }\n "}, {"sha": "7ec055c940aaa16131ba88c680392135ffa686d9", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09eeeacbb9dd78676a3a4f8065f51a5750942884/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=09eeeacbb9dd78676a3a4f8065f51a5750942884", "patch": "@@ -736,6 +736,38 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ASM_OUTPUT_ALIGNED_LOCAL (FILE, NAME, SIZE, ALIGN);\t\t\t\\\n } while (0)\n \n+/* This is how to output code to push a register on the stack.\n+   It need not be very fast code.\n+\n+   On the rs6000, we must keep the backchain up to date.  In order\n+   to simplify things, always allocate 16 bytes for a push (System V\n+   wants to keep stack aligned to a 16 byte boundary).  */\n+\n+#define\tASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (DEFAULT_ABI == ABI_V4)\t\t\t\t\t\t\\\n+    asm_fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t\t (TARGET_32BIT\t\t\t\t\t\t\\\n+\t\t  ? \"\\t{stu|stwu} %s,-16(%s)\\n\\t{st|stw} %s,12(%s)\\n\"\t\\\n+\t\t  : \"\\tstdu %s,-32(%s)\\n\\tstd %s,24(%s)\\n\"),\t\t\\\n+\t\t reg_names[1], reg_names[1], reg_names[REGNO],\t\t\\\n+\t\t reg_names[1]);\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define\tASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (DEFAULT_ABI == ABI_V4)\t\t\t\t\t\t\\\n+    asm_fprintf (FILE,\t\t\t\t\t\t\t\\\n+\t\t (TARGET_32BIT\t\t\t\t\t\t\\\n+\t\t  ? \"\\t{l|lwz} %s,12(%s)\\n\\t{ai|addic} %s,%s,16\\n\"\t\\\n+\t\t  : \"\\tld %s,24(%s)\\n\\t{ai|addic} %s,%s,32\\n\"),\t\t\\\n+\t\t reg_names[REGNO], reg_names[1], reg_names[1],\t\t\\\n+\t\t reg_names[1]);\t\t\t\t\t\t\\\n+} while (0)\n+\n /* Switch  Recognition by gcc.c.  Add -G xx support.  */\n \n /* Override svr4.h definition.  */"}]}