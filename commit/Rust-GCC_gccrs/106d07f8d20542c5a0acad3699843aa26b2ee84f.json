{"sha": "106d07f8d20542c5a0acad3699843aa26b2ee84f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA2ZDA3ZjhkMjA1NDJjNWEwYWNhZDM2OTk4NDNhYTI2YjJlZTg0Zg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-07-21T10:44:33Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-07-21T10:44:33Z"}, "message": "tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne): Clean up by removing computation of may_be_zero.\n\n\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne): Clean up\n\tby removing computation of may_be_zero.\n\nFrom-SVN: r238585", "tree": {"sha": "205080d939b6f0d2de5b3e0e98c252275345d067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/205080d939b6f0d2de5b3e0e98c252275345d067"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/106d07f8d20542c5a0acad3699843aa26b2ee84f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106d07f8d20542c5a0acad3699843aa26b2ee84f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/106d07f8d20542c5a0acad3699843aa26b2ee84f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/106d07f8d20542c5a0acad3699843aa26b2ee84f/comments", "author": null, "committer": null, "parents": [{"sha": "a1b01d34036c85f23b7ca1a2c99e5b6bb0b8e68c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1b01d34036c85f23b7ca1a2c99e5b6bb0b8e68c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1b01d34036c85f23b7ca1a2c99e5b6bb0b8e68c"}], "stats": {"total": 110, "additions": 33, "deletions": 77}, "files": [{"sha": "1082405fdffcca8a81284299b3e460f2a646a66a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106d07f8d20542c5a0acad3699843aa26b2ee84f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106d07f8d20542c5a0acad3699843aa26b2ee84f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=106d07f8d20542c5a0acad3699843aa26b2ee84f", "patch": "@@ -1,3 +1,8 @@\n+2016-07-21  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-niter.c (number_of_iterations_lt_to_ne): Clean up\n+\tby removing computation of may_be_zero.\n+\n 2016-07-21  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-object-size.c (unknown): Use HOST_WIDE_INT_M1U instead of -1."}, {"sha": "1102c8a921cd83821900965c630e3453ec6db957", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 28, "deletions": 77, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/106d07f8d20542c5a0acad3699843aa26b2ee84f/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/106d07f8d20542c5a0acad3699843aa26b2ee84f/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=106d07f8d20542c5a0acad3699843aa26b2ee84f", "patch": "@@ -1072,109 +1072,60 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree niter_type = TREE_TYPE (step);\n   tree mod = fold_build2 (FLOOR_MOD_EXPR, niter_type, *delta, step);\n   tree tmod;\n-  mpz_t mmod;\n-  tree assumption = boolean_true_node, bound, noloop;\n-  bool ret = false, fv_comp_no_overflow;\n-  tree type1 = type;\n-  if (POINTER_TYPE_P (type))\n-    type1 = sizetype;\n+  tree assumption = boolean_true_node, bound;\n+  tree type1 = (POINTER_TYPE_P (type)) ? sizetype : type;\n \n   if (TREE_CODE (mod) != INTEGER_CST)\n     return false;\n   if (integer_nonzerop (mod))\n     mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n   tmod = fold_convert (type1, mod);\n \n-  mpz_init (mmod);\n-  wi::to_mpz (mod, mmod, UNSIGNED);\n-  mpz_neg (mmod, mmod);\n-\n   /* If the induction variable does not overflow and the exit is taken,\n-     then the computation of the final value does not overflow.  This is\n-     also obviously the case if the new final value is equal to the\n-     current one.  Finally, we postulate this for pointer type variables,\n-     as the code cannot rely on the object to that the pointer points being\n-     placed at the end of the address space (and more pragmatically,\n-     TYPE_{MIN,MAX}_VALUE is not defined for pointers).  */\n-  if (integer_zerop (mod) || POINTER_TYPE_P (type))\n-    fv_comp_no_overflow = true;\n-  else if (!exit_must_be_taken)\n-    fv_comp_no_overflow = false;\n-  else\n-    fv_comp_no_overflow =\n-\t    (iv0->no_overflow && integer_nonzerop (iv0->step))\n-\t    || (iv1->no_overflow && integer_nonzerop (iv1->step));\n-\n-  if (integer_nonzerop (iv0->step))\n+     then the computation of the final value does not overflow.  There\n+     are three cases:\n+       1) The case if the new final value is equal to the current one.\n+       2) Induction varaible has pointer type, as the code cannot rely\n+\t  on the object to that the pointer points being placed at the\n+\t  end of the address space (and more pragmatically,\n+\t  TYPE_{MIN,MAX}_VALUE is not defined for pointers).\n+       3) EXIT_MUST_BE_TAKEN is true, note it implies that the induction\n+\t  variable does not overflow.  */\n+  if (!integer_zerop (mod) && !POINTER_TYPE_P (type) && !exit_must_be_taken)\n     {\n-      /* The final value of the iv is iv1->base + MOD, assuming that this\n-\t computation does not overflow, and that\n-\t iv0->base <= iv1->base + MOD.  */\n-      if (!fv_comp_no_overflow)\n+      if (integer_nonzerop (iv0->step))\n \t{\n+\t  /* The final value of the iv is iv1->base + MOD, assuming\n+\t     that this computation does not overflow, and that\n+\t     iv0->base <= iv1->base + MOD.  */\n \t  bound = fold_build2 (MINUS_EXPR, type1,\n \t\t\t       TYPE_MAX_VALUE (type1), tmod);\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n-\t  if (integer_zerop (assumption))\n-\t    goto end;\n \t}\n-      if (mpz_cmp (mmod, bnds->below) < 0)\n-\tnoloop = boolean_false_node;\n-      else if (POINTER_TYPE_P (type))\n-\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t      iv0->base,\n-\t\t\t      fold_build_pointer_plus (iv1->base, tmod));\n       else\n-\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t      iv0->base,\n-\t\t\t      fold_build2 (PLUS_EXPR, type1,\n-\t\t\t\t\t   iv1->base, tmod));\n-    }\n-  else\n-    {\n-      /* The final value of the iv is iv0->base - MOD, assuming that this\n-\t computation does not overflow, and that\n-\t iv0->base - MOD <= iv1->base. */\n-      if (!fv_comp_no_overflow)\n \t{\n+\t  /* The final value of the iv is iv0->base - MOD, assuming\n+\t     that this computation does not overflow, and that\n+\t     iv0->base - MOD <= iv1->base.  */\n \t  bound = fold_build2 (PLUS_EXPR, type1,\n \t\t\t       TYPE_MIN_VALUE (type1), tmod);\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n-\t  if (integer_zerop (assumption))\n-\t    goto end;\n \t}\n-      if (mpz_cmp (mmod, bnds->below) < 0)\n-\tnoloop = boolean_false_node;\n-      else if (POINTER_TYPE_P (type))\n-\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t      fold_build_pointer_plus (iv0->base,\n-\t\t\t\t\t\t       fold_build1 (NEGATE_EXPR,\n-\t\t\t\t\t\t\t\t    type1, tmod)),\n-\t\t\t      iv1->base);\n-      else\n-\tnoloop = fold_build2 (GT_EXPR, boolean_type_node,\n-\t\t\t      fold_build2 (MINUS_EXPR, type1,\n-\t\t\t\t\t   iv0->base, tmod),\n-\t\t\t      iv1->base);\n+      if (integer_zerop (assumption))\n+\treturn false;\n+      else if (!integer_nonzerop (assumption))\n+\tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t\t  niter->assumptions, assumption);\n     }\n \n-  if (!integer_nonzerop (assumption))\n-    niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n-\t\t\t\t      niter->assumptions,\n-\t\t\t\t      assumption);\n-  if (!integer_zerop (noloop))\n-    niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\t\t      niter->may_be_zero,\n-\t\t\t\t      noloop);\n+  /* Since we are transforming LT to NE and DELTA is constant, there\n+     is no need to compute may_be_zero because this loop must roll.  */\n+\n   bounds_add (bnds, wi::to_widest (mod), type);\n   *delta = fold_build2 (PLUS_EXPR, niter_type, *delta, mod);\n-\n-  ret = true;\n-end:\n-  mpz_clear (mmod);\n-  return ret;\n+  return true;\n }\n \n /* Add assertions to NITER that ensure that the control variable of the loop"}]}