{"sha": "d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA4ZDQ4MTkxMmI5YTJkYzMzODhmOGUxMTgzY2VhMGJmM2ZmYWU5Zg==", "commit": {"author": {"name": "Dmitriy Anisimkov", "email": "anisimko@adacore.com", "date": "2020-08-08T12:49:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-23T08:25:07Z"}, "message": "[Ada] Sockets.Poll implementation\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_SOCKETS_OBJS): New object\n\tg-socpol$(objext) New source files noted: g-socpol.adb,\n\tg-socpol.ads, g-socpol__dummy.adb, g-socpol__dummy.ads,\n\tg-sopowa.adb, g-sopowa__posix.adb, g-sopowa__mingw.adb,\n\tg-spogwa.adb, g-spogwa.ads.\n\t* impunit.adb (Non_Imp_File_Names_95): New base filename\n\tg-socpol in \"GNAT Library Units\" section for GNAT.Sockets.Poll\n\tunit.\n\t* libgnat/g-socket.ads, libgnat/g-socket.adb:\n\t(Raise_Socket_Error): Moved from body to private part of\n\tspecification to use in GNAT.Sockets.Poll.\n\t* libgnat/g-socpol.ads, libgnat/g-socpol.adb: Main unit of the\n\timplementation.\n\t* libgnat/g-socpol__dummy.ads, libgnat/g-socpol__dummy.adb:\n\tEmpty unit for the systems without sockets support.\n\t* libgnat/g-spogwa.ads, libgnat/g-spogwa.adb: Generic unit\n\timplementing sockets poll on top of select system call.\n\t* libgnat/g-sopowa.adb (Wait): Separate implementation for\n\toperation systems with poll system call support.\n\t* libgnat/g-sopowa__posix.adb (Wait): Separate implementation\n\tfor POSIX select system call.\n\t* libgnat/g-sopowa__mingw.adb (Wait): Separate implementation\n\tfor Windows select system call.\n\t* gsocket.h (_WIN32_WINNT): Increase to 0x0600 for winsock2.h to\n\tallow WSAPoll related definitions.\n\t* s-oscons-tmplt.c: Fix comment next to #endif for\n\t#if defined (__linux__) || defined (__ANDROID__) line.  Include\n\t<poll.h> for all except VxWorks and Windows.\n\t(SIZEOF_nfds_t): New definition.\n\t(SIZEOF_fd_type): New definition.\n\t(SIZEOF_pollfd_events): New definition.\n\t(POLLIN, POLLPRI, POLLOUT, POLLERR, POLLHUP, POLLNVAL): New\n\tdefinitions for VxWorks to be able to emulate poll on top of\n\tselect in it.  Define POLLPRI as zero on Windows as it is not\n\tsupported there.\n\t(Poll_Linkname): New definition, because the poll system call\n\thas different name in Windows and POSIX.", "tree": {"sha": "22e513c76801fa433fcc0445892f3b47d4c7a0bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22e513c76801fa433fcc0445892f3b47d4c7a0bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/comments", "author": {"login": "anisimkov", "id": 15864134, "node_id": "MDQ6VXNlcjE1ODY0MTM0", "avatar_url": "https://avatars.githubusercontent.com/u/15864134?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anisimkov", "html_url": "https://github.com/anisimkov", "followers_url": "https://api.github.com/users/anisimkov/followers", "following_url": "https://api.github.com/users/anisimkov/following{/other_user}", "gists_url": "https://api.github.com/users/anisimkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/anisimkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anisimkov/subscriptions", "organizations_url": "https://api.github.com/users/anisimkov/orgs", "repos_url": "https://api.github.com/users/anisimkov/repos", "events_url": "https://api.github.com/users/anisimkov/events{/privacy}", "received_events_url": "https://api.github.com/users/anisimkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e97274cef35ed40584c7a09096fffa061fddf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e97274cef35ed40584c7a09096fffa061fddf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e97274cef35ed40584c7a09096fffa061fddf0"}], "stats": {"total": 1243, "additions": 1235, "deletions": 8}, "files": [{"sha": "ac222cb1b80c55684a430eba5c0b333d1017d2cb", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -820,15 +820,17 @@ GNATLIB_SHARED = gnatlib\n # to LIBGNAT_TARGET_PAIRS.\n \n GNATRTL_SOCKETS_OBJS = g-soccon$(objext) g-socket$(objext) g-socthi$(objext) \\\n-  g-soliop$(objext) g-sothco$(objext)\n+  g-soliop$(objext) g-sothco$(objext) g-socpol$(objext)\n \n DUMMY_SOCKETS_TARGET_PAIRS = \\\n   g-socket.adb<libgnat/g-socket__dummy.adb \\\n   g-socket.ads<libgnat/g-socket__dummy.ads \\\n   g-socthi.adb<libgnat/g-socthi__dummy.adb \\\n   g-socthi.ads<libgnat/g-socthi__dummy.ads \\\n   g-sothco.adb<libgnat/g-sothco__dummy.adb \\\n-  g-sothco.ads<libgnat/g-sothco__dummy.ads\n+  g-sothco.ads<libgnat/g-sothco__dummy.ads \\\n+  g-socpol.adb<libgnat/g-socpol__dummy.adb \\\n+  g-socpol.ads<libgnat/g-socpol__dummy.ads\n \n # On platforms where atomic increment/decrement operations are supported,\n # special version of Ada.Strings.Unbounded package can be used.\n@@ -1043,6 +1045,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworks vxworksspe vxworks7% vxworks7spe\n   s-vxwork.ads<libgnarl/s-vxwork__ppc.ads \\\n   g-socthi.ads<libgnat/g-socthi__vxworks.ads \\\n   g-socthi.adb<libgnat/g-socthi__vxworks.adb \\\n+  g-sopowa.adb<libgnat/g-sopowa__posix.adb \\\n   g-stsifd.adb<libgnat/g-stsifd__sockets.adb \\\n   $(ATOMICS_TARGET_PAIRS) \\\n   $(ATOMICS_BUILTINS_TARGET_PAIRS)\n@@ -1203,6 +1206,7 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae vxworksaespe,$(target_cpu) $(t\n     LIBGNAT_TARGET_PAIRS += \\\n     g-socthi.ads<libgnat/g-socthi__vxworks.ads \\\n     g-socthi.adb<libgnat/g-socthi__vxworks.adb \\\n+    g-sopowa.adb<libgnat/g-sopowa__posix.adb \\\n     g-stsifd.adb<libgnat/g-stsifd__sockets.adb\n   endif\n \n@@ -1261,6 +1265,7 @@ ifeq ($(strip $(filter-out %86 wrs vxworksae,$(target_cpu) $(target_vendor) $(ta\n     LIBGNAT_TARGET_PAIRS += \\\n     g-socthi.ads<libgnat/g-socthi__vxworks.ads \\\n     g-socthi.adb<libgnat/g-socthi__vxworks.adb \\\n+    g-sopowa.adb<libgnat/g-sopowa__posix.adb \\\n     g-stsifd.adb<libgnat/g-stsifd__sockets.adb\n   endif\n \n@@ -1291,6 +1296,7 @@ ifeq ($(strip $(filter-out %86 x86_64 wrs vxworks vxworks7%,$(target_cpu) $(targ\n   s-vxwork.ads<libgnarl/s-vxwork__x86.ads \\\n   g-socthi.ads<libgnat/g-socthi__vxworks.ads \\\n   g-socthi.adb<libgnat/g-socthi__vxworks.adb \\\n+  g-sopowa.adb<libgnat/g-sopowa__posix.adb \\\n   g-stsifd.adb<libgnat/g-stsifd__sockets.adb \\\n   $(ATOMICS_TARGET_PAIRS)\n \n@@ -1435,6 +1441,7 @@ ifeq ($(strip $(filter-out aarch64 arm% coff wrs vx%,$(target_cpu) $(target_vend\n   s-taspri.ads<libgnarl/s-taspri__vxworks.ads \\\n   g-socthi.ads<libgnat/g-socthi__vxworks.ads \\\n   g-socthi.adb<libgnat/g-socthi__vxworks.adb \\\n+  g-sopowa.adb<libgnat/g-sopowa__posix.adb \\\n   g-stsifd.adb<libgnat/g-stsifd__sockets.adb\n \n   ifeq ($(strip $(filter-out aarch64, $(target_cpu))),)\n@@ -2166,7 +2173,8 @@ ifeq ($(strip $(filter-out cygwin% mingw32% pe,$(target_os))),)\n   else\n     LIBGNAT_TARGET_PAIRS = \\\n     g-socthi.ads<libgnat/g-socthi__mingw.ads \\\n-    g-socthi.adb<libgnat/g-socthi__mingw.adb\n+    g-socthi.adb<libgnat/g-socthi__mingw.adb \\\n+    g-sopowa.adb<libgnat/g-sopowa__mingw.adb\n   endif\n   LIBGNAT_TARGET_PAIRS += \\\n   a-dirval.adb<libgnat/a-dirval__mingw.adb \\"}, {"sha": "ba51fb1e7cc72188d920679d41ca680328f0b49b", "filename": "gcc/ada/gsocket.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Fgsocket.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Fgsocket.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgsocket.h?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -80,6 +80,12 @@\n #define FD_SETSIZE 1024\n \n #ifdef __MINGW32__\n+/* winsock2.h allows WSAPoll related definitions only when\n+ * _WIN32_WINNT >= 0x0600 */\n+#if !defined(_WIN32_WINNT) || _WIN32_WINNT < 0x0600\n+#define _WIN32_WINNT 0x0600\n+#endif\n+\n #include <winsock2.h>\n #include <ws2tcpip.h>\n #include <versionhelpers.h>"}, {"sha": "2cde4305570a5fe68e37440178ad5c17a830af6e", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -310,6 +310,7 @@ package body Impunit is\n     (\"g-sha512\", F),  -- GNAT.SHA512\n     (\"g-signal\", F),  -- GNAT.Signals\n     (\"g-socket\", F),  -- GNAT.Sockets\n+    (\"g-socpol\", F),  -- GNAT.Sockets.Poll\n     (\"g-souinf\", F),  -- GNAT.Source_Info\n     (\"g-speche\", F),  -- GNAT.Spell_Checker\n     (\"g-spchge\", F),  -- GNAT.Spell_Checker_Generic"}, {"sha": "57a880024b7948920a021222009ec07a9cb418e6", "filename": "gcc/ada/libgnat/g-socket.adb", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socket.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -186,10 +186,6 @@ package body GNAT.Sockets is\n        else Value);\n    --  Removes dot at the end of error message\n \n-   procedure Raise_Socket_Error (Error : Integer);\n-   --  Raise Socket_Error with an exception message describing the error code\n-   --  from errno.\n-\n    procedure Raise_Host_Error (H_Error : Integer; Name : String);\n    --  Raise Host_Error exception with message describing error code (note\n    --  hstrerror seems to be obsolete) from h_errno. Name is the name"}, {"sha": "bf78777d4d8b2c9f5ca8fe42e4843abec6cefbe9", "filename": "gcc/ada/libgnat/g-socket.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socket.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socket.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socket.ads?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -1573,4 +1573,8 @@ private\n    Wait_For_A_Full_Reception : constant Request_Flag_Type := 4;\n    Send_End_Of_Record        : constant Request_Flag_Type := 8;\n \n+   procedure Raise_Socket_Error (Error : Integer);\n+   --  Raise Socket_Error with an exception message describing the error code\n+   --  from errno.\n+\n end GNAT.Sockets;"}, {"sha": "ab3286c87fd22b476d95a84e231215f009f4a1f1", "filename": "gcc/ada/libgnat/g-socpol.adb", "status": "added", "additions": 430, "deletions": 0, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socpol.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,430 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . S O C K E T S . P O L L                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Calendar;\n+\n+with GNAT.Sockets.Thin;\n+\n+package body GNAT.Sockets.Poll is\n+\n+   To_C : constant array (Wait_Event_Type) of Events_Type :=\n+            (Input => SOC.POLLIN or SOC.POLLPRI, Output => SOC.POLLOUT);\n+   --  To convert Wait_Event_Type to C I/O events flags\n+\n+   procedure Set_Mode (Item : out Pollfd; Mode : Wait_Event_Set);\n+   --  Set I/O waiting mode on Item\n+\n+   procedure Set_Event\n+     (Item : out Pollfd; Event : Wait_Event_Type; Value : Boolean);\n+   --  Set or reset waiting state on I/O event\n+\n+   procedure Check_Range (Self : Set; Index : Positive) with Inline;\n+   --  raise Constraint_Error if Index is more than number of sockets in Self\n+\n+   function Status (Item : Pollfd) return Event_Set is\n+     (Input           => (Item.REvents and To_C (Input)) /= 0,\n+      Output          => (Item.REvents and To_C (Output)) /= 0,\n+      Error           => (Item.REvents and SOC.POLLERR) /= 0,\n+      Hang_Up         => (Item.REvents and SOC.POLLHUP) /= 0,\n+      Invalid_Request => (Item.REvents and SOC.POLLNVAL) /= 0);\n+   --  Get I/O events from C word\n+\n+   procedure Wait\n+     (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer);\n+   --  Waits until one or more of the sockets descriptors become ready for some\n+   --  class of I/O operation or error state occurs on one or more of them.\n+   --  Timeout is in milliseconds. Result mean how many sockets ready for I/O\n+   --  or have error state.\n+\n+   ----------\n+   -- Wait --\n+   ----------\n+\n+   procedure Wait\n+     (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer)\n+   is separate;\n+\n+   ------------\n+   -- Create --\n+   ------------\n+\n+   function Create (Size : Positive) return Set is\n+   begin\n+      return Result : Set (Size);\n+   end Create;\n+\n+   ------------\n+   -- To_Set --\n+   ------------\n+\n+   function To_Set\n+     (Socket : Socket_Type;\n+      Events : Wait_Event_Set;\n+      Size   : Positive := 1) return Set is\n+   begin\n+      return Result : Set (Size) do\n+         Append (Result, Socket, Events);\n+      end return;\n+   end To_Set;\n+\n+   ------------\n+   -- Append --\n+   ------------\n+\n+   procedure Append\n+     (Self : in out Set; Socket : Socket_Type; Events : Wait_Event_Set) is\n+   begin\n+      Insert (Self, Socket, Events, Self.Length + 1);\n+   end Append;\n+\n+   ------------\n+   -- Insert --\n+   ------------\n+\n+   procedure Insert\n+     (Self       : in out Set;\n+      Socket     : Socket_Type;\n+      Events     : Wait_Event_Set;\n+      Index      : Positive;\n+      Keep_Order : Boolean := False) is\n+   begin\n+      if Self.Size <= Self.Length then\n+         raise Constraint_Error with \"Socket set is full\";\n+\n+      elsif Index > Self.Length + 1 then\n+         raise Constraint_Error with \"Insert out of range\";\n+      end if;\n+\n+      if Socket < 0 then\n+         raise Socket_Error with\n+           \"Wrong socket descriptor \" & Socket_Type'Image (Socket);\n+      end if;\n+\n+      Self.Length := Self.Length + 1;\n+\n+      if Index /= Self.Length then\n+         if Keep_Order then\n+            Self.Fds (Index + 1 .. Self.Length) :=\n+              Self.Fds (Index .. Self.Length - 1);\n+         else\n+            Self.Fds (Self.Length) := Self.Fds (Index);\n+         end if;\n+\n+         Self.Fds (Index).Events := 0;\n+      end if;\n+\n+      Self.Fds (Index).Socket := FD_Type (Socket);\n+      Set_Mode (Self.Fds (Index), Events);\n+\n+      if FD_Type (Socket) > Self.Max_FD then\n+         Self.Max_FD := FD_Type (Socket);\n+         Self.Max_OK := True;\n+      end if;\n+   end Insert;\n+\n+   -----------------\n+   -- Check_Range --\n+   -----------------\n+\n+   procedure Check_Range (Self : Set; Index : Positive) is\n+   begin\n+      if Index > Self.Length then\n+         raise Constraint_Error;\n+      end if;\n+   end Check_Range;\n+\n+   ----------\n+   -- Copy --\n+   ----------\n+\n+   procedure Copy (Source : Set; Target : out Set) is\n+   begin\n+      if Target.Size < Source.Length then\n+         raise Constraint_Error with\n+           \"Can't copy because size of target less than source length\";\n+      end if;\n+\n+      Target.Fds (1 .. Source.Length) := Source.Fds (1 .. Source.Length);\n+\n+      Target.Length := Source.Length;\n+      Target.Max_FD := Source.Max_FD;\n+      Target.Max_OK := Source.Max_OK;\n+   end Copy;\n+\n+   ----------------\n+   -- Get_Events --\n+   ----------------\n+\n+   function Get_Events\n+     (Self : Set; Index  : Positive) return Wait_Event_Set is\n+   begin\n+      Check_Range (Self, Index);\n+      return\n+        (Input  => (Self.Fds (Index).Events and To_C (Input)) /= 0,\n+         Output => (Self.Fds (Index).Events and To_C (Output)) /= 0);\n+   end Get_Events;\n+\n+   ------------\n+   -- Growth --\n+   ------------\n+\n+   function Growth (Self : Set) return Set is\n+   begin\n+      return Resize\n+        (Self,\n+         (case Self.Size is\n+             when 1  .. 20 => 32,\n+             when 21 .. 50 => 64,\n+             when 51 .. 99 => Self.Size + Self.Size / 3,\n+             when others   => Self.Size + Self.Size / 4));\n+   end Growth;\n+\n+   ------------\n+   -- Remove --\n+   ------------\n+\n+   procedure Remove\n+     (Self : in out Set; Index : Positive; Keep_Order : Boolean := False) is\n+   begin\n+      Check_Range (Self, Index);\n+\n+      if Self.Max_FD = Self.Fds (Index).Socket then\n+         Self.Max_OK := False;\n+      end if;\n+\n+      if Index < Self.Length then\n+         if Keep_Order then\n+            Self.Fds (Index .. Self.Length - 1) :=\n+              Self.Fds (Index + 1 .. Self.Length);\n+         else\n+            Self.Fds (Index) := Self.Fds (Self.Length);\n+         end if;\n+      end if;\n+\n+      Self.Length := Self.Length - 1;\n+   end Remove;\n+\n+   ------------\n+   -- Resize --\n+   ------------\n+\n+   function Resize (Self : Set; Size : Positive) return Set is\n+   begin\n+      return Result : Set (Size) do\n+         Copy (Self, Result);\n+      end return;\n+   end Resize;\n+\n+   ---------------\n+   -- Set_Event --\n+   ---------------\n+\n+   procedure Set_Event\n+     (Self  : in out Set;\n+      Index : Positive;\n+      Event : Wait_Event_Type;\n+      Value : Boolean) is\n+   begin\n+      Check_Range (Self, Index);\n+      Set_Event (Self.Fds (Index), Event, Value);\n+   end Set_Event;\n+\n+   procedure Set_Event\n+     (Item : out Pollfd; Event : Wait_Event_Type; Value : Boolean) is\n+   begin\n+      if Value then\n+         Item.Events := Item.Events or To_C (Event);\n+      else\n+         Item.Events := Item.Events and not To_C (Event);\n+      end if;\n+   end Set_Event;\n+\n+   ----------------\n+   -- Set_Events --\n+   ----------------\n+\n+   procedure Set_Events\n+     (Self   : in out Set;\n+      Index  : Positive;\n+      Events : Wait_Event_Set) is\n+   begin\n+      Check_Range (Self, Index);\n+      Set_Mode (Self.Fds (Index), Events);\n+   end Set_Events;\n+\n+   --------------\n+   -- Set_Mode --\n+   --------------\n+\n+   procedure Set_Mode (Item : out Pollfd; Mode : Wait_Event_Set) is\n+   begin\n+      for J in Mode'Range loop\n+         Set_Event (Item, J, Mode (J));\n+      end loop;\n+   end Set_Mode;\n+\n+   ------------\n+   -- Socket --\n+   ------------\n+\n+   function Socket (Self : Set; Index : Positive) return Socket_Type is\n+   begin\n+      Check_Range (Self, Index);\n+      return Socket_Type (Self.Fds (Index).Socket);\n+   end Socket;\n+\n+   -----------\n+   -- State --\n+   -----------\n+\n+   procedure State\n+     (Self   : Set;\n+      Index  : Positive;\n+      Socket : out Socket_Type;\n+      Status : out Event_Set) is\n+   begin\n+      Check_Range (Self, Index);\n+      Socket := Socket_Type (Self.Fds (Index).Socket);\n+      Status := Poll.Status (Self.Fds (Index));\n+   end State;\n+\n+   ----------\n+   -- Wait --\n+   ----------\n+\n+   procedure Wait (Self : in out Set; Timeout : Duration; Count : out Natural)\n+   is\n+      use Ada.Calendar;\n+      --  Used to calculate partially consumed timeout on EINTR.\n+      --  Better to use Ada.Real_Time, but we can't in current GNAT because\n+      --  Ada.Real_Time is in tasking part of runtime.\n+\n+      Result       : Integer;\n+      Poll_Timeout : Duration := Timeout;\n+      C_Timeout    : Interfaces.C.int;\n+      Errno        : Integer;\n+      Stamp        : constant Time := Clock;\n+   begin\n+      if Self.Length = 0 then\n+         Count := 0;\n+         return;\n+      end if;\n+\n+      loop\n+         if Poll_Timeout >= Duration (Interfaces.C.int'Last - 8) / 1_000 then\n+            --  Minus 8 is to workaround Linux kernel 2.6.24 bug with close to\n+            --  Integer'Last poll timeout values.\n+            --  syscall (SYS_poll, &ufds, 1, 2147483644); // is waiting\n+            --  syscall (SYS_poll, &ufds, 1, 2147483645); // is not waiting\n+            --  Timeout values close to maximum could be not safe because of\n+            --  possible time conversion boundary errors in the kernel.\n+            --  Use unlimited timeout instead of maximum 24 days timeout for\n+            --  safety reasons.\n+\n+            C_Timeout := -1;\n+         else\n+            C_Timeout := Interfaces.C.int (Poll_Timeout * 1_000);\n+         end if;\n+\n+         Wait (Self, C_Timeout, Result);\n+\n+         exit when Result >= 0;\n+\n+         Errno := Thin.Socket_Errno;\n+\n+         --  In case of EINTR error we have to continue waiting for network\n+         --  events.\n+\n+         if Errno = SOC.EINTR then\n+            if C_Timeout >= 0 then\n+               Poll_Timeout := Timeout - (Clock - Stamp);\n+\n+               if Poll_Timeout < 0.0 then\n+                  Count := 0;\n+                  return;\n+\n+               elsif Poll_Timeout > Timeout then\n+                  --  Clock moved back in time. This should not be happen when\n+                  --  we use monotonic time.\n+\n+                  Poll_Timeout := Timeout;\n+               end if;\n+            end if;\n+\n+         else\n+            Raise_Socket_Error (Errno);\n+         end if;\n+      end loop;\n+\n+      Count := Result;\n+   end Wait;\n+\n+   ----------\n+   -- Next --\n+   ----------\n+\n+   procedure Next (Self : Set; Index : in out Natural) is\n+   begin\n+      loop\n+         Index := Index + 1;\n+\n+         if Index > Self.Length then\n+            Index := 0;\n+            return;\n+\n+         elsif Self.Fds (Index).REvents /= 0 then\n+            return;\n+         end if;\n+      end loop;\n+   end Next;\n+\n+   ------------\n+   -- Status --\n+   ------------\n+\n+   function Status (Self : Set; Index : Positive) return Event_Set is\n+   begin\n+      Check_Range (Self, Index);\n+      return Status (Self.Fds (Index));\n+   end Status;\n+\n+   --------------\n+   -- C_Status --\n+   --------------\n+\n+   function C_Status\n+     (Self : Set; Index : Positive) return Interfaces.C.unsigned is\n+   begin\n+      Check_Range (Self, Index);\n+      return Interfaces.C.unsigned (Self.Fds (Index).REvents);\n+   end C_Status;\n+\n+end GNAT.Sockets.Poll;"}, {"sha": "c03c578f3f8206b80966097aeb53ca50a7fc1024", "filename": "gcc/ada/libgnat/g-socpol.ads", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socpol.ads?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,216 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . S O C K E T S . P O L L                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides an interface to wait for one of a set of sockets to\n+--  become ready to perform I/O.\n+\n+with System.OS_Constants;\n+\n+package GNAT.Sockets.Poll is\n+\n+   type Event_Type is (Input, Output, Error, Hang_Up, Invalid_Request);\n+   --  I/O events we can expect on socket.\n+   --  Input           - socket ready to read;\n+   --  Output          - socket available for write;\n+   --  Error           - socket is in error state;\n+   --  Hang_Up         - peer closed;\n+   --  Invalid_Request - invalid socket;\n+\n+   type Event_Set is array (Event_Type) of Boolean;\n+   --  The type to get results on events waiting\n+\n+   subtype Wait_Event_Type is Event_Type range Input .. Output;\n+   type Wait_Event_Set is array (Wait_Event_Type) of Boolean;\n+   --  The type to set events to wait. Note that Error event would be waited\n+   --  anyway.\n+\n+   -------------------------------\n+   --  Predefined set of events --\n+   -------------------------------\n+\n+   Input_Event  : constant Wait_Event_Set;\n+   --  Wait for input availability only\n+\n+   Output_Event : constant Wait_Event_Set;\n+   --  Wait for output availability only\n+\n+   Both_Events : constant Wait_Event_Set;\n+   --  Wait for Input and Output availability\n+\n+   Error_Event : constant Wait_Event_Set;\n+   --  Wait only for error state on socket\n+\n+   type Set (Size : Positive) is private;\n+   --  Set of sockets with I/O event set to wait on\n+\n+   function Create (Size : Positive) return Set;\n+   --  Create empty socket set with defined size\n+\n+   function To_Set\n+     (Socket : Socket_Type;\n+      Events : Wait_Event_Set;\n+      Size   : Positive := 1) return Set;\n+   --  Create socket set and put the Socket there at the first place.\n+   --  Events parameter is defining what state of the socket we are going to\n+   --  wait.\n+\n+   procedure Append\n+     (Self   : in out Set;\n+      Socket : Socket_Type;\n+      Events : Wait_Event_Set);\n+   --  Add Socket and its I/O waiting state at the end of Self\n+\n+   procedure Insert\n+     (Self       : in out Set;\n+      Socket     : Socket_Type;\n+      Events     : Wait_Event_Set;\n+      Index      : Positive;\n+      Keep_Order : Boolean := False);\n+   --  Insert Socket and its I/O waiting state at the Index position.\n+   --  If Keep_Order is True then all next elements moved to the next index up.\n+   --  Otherwise the old element from Index moved to the end of the Self set.\n+\n+   procedure Remove\n+     (Self : in out Set; Index : Positive; Keep_Order : Boolean := False);\n+   --  Remove socket from Index. If Keep_Order is True then move all next\n+   --  elements after removed one to previous index. If Keep_Order is False\n+   --  then move the last element on place of the removed one.\n+\n+   procedure Set_Event\n+     (Self  : in out Set;\n+      Index : Positive;\n+      Event : Wait_Event_Type;\n+      Value : Boolean);\n+   --  Set I/O waiting event to Value for the socket at Index position\n+\n+   procedure Set_Events\n+     (Self   : in out Set;\n+      Index  : Positive;\n+      Events : Wait_Event_Set);\n+   --  Set I/O waiting events for the socket at Index position\n+\n+   function Get_Events\n+     (Self : Set; Index : Positive) return Wait_Event_Set;\n+   --  Get I/O waiting events for the socket at Index position\n+\n+   function Length (Self : Set) return Natural;\n+   --  Get the number of sockets currently in the Self set\n+\n+   function Full (Self : Set) return Boolean;\n+   --  Return True if there is no more space in the Self set for new sockets\n+\n+   procedure Wait (Self : in out Set; Timeout : Duration; Count : out Natural);\n+   --  Wait no longer than Timeout on the socket set for the I/O events.\n+   --  Count output parameter is the number of elements in the Self set are\n+   --  detected for I/O events. Zero Count mean timeout on wait.\n+   --  The iteration over activated elements in set could be done with routine\n+   --  Next. The kind of I/O events on element could be cheched with State or\n+   --  Status routines.\n+\n+   procedure Next (Self : Set; Index : in out Natural);\n+   --  Iterate over set looking for the next index with active I/O event state.\n+   --  Put 0 initially into Index. Each iteration increments Index and then\n+   --  checks for state. End of iterations can be detected by 0 in the Index.\n+\n+   procedure Copy (Source : Set; Target : out Set);\n+   --  Copy sockets and its I/O waiting events from Source set into Target\n+\n+   function Resize (Self : Set; Size : Positive) return Set;\n+   --  Returns the copy of Source with modified Size\n+\n+   function Growth (Self : Set) return Set;\n+   --  Returns the copy of Source with increased Size\n+\n+   function Socket (Self : Set; Index : Positive) return Socket_Type;\n+   --  Returns the Socket from Index position\n+\n+   function Status (Self : Set; Index : Positive) return Event_Set;\n+   --  Returns I/O events detected in previous Wait call at Index position\n+\n+   procedure State\n+     (Self   : Set;\n+      Index  : Positive;\n+      Socket : out Socket_Type;\n+      Status : out Event_Set);\n+   --  Returns Socket and its I/O events detected in previous Wait call at\n+   --  Index position.\n+\n+   function C_Status\n+     (Self : Set; Index : Positive) return Interfaces.C.unsigned;\n+   --  Return word with I/O events detected flags in previous Wait call at\n+   --  Index position. Possible flags are defined in System.OS_Constants names\n+   --  starting with POLL prefix.\n+\n+private\n+\n+   Input_Event  : constant Wait_Event_Set := (Input => True, Output => False);\n+   Output_Event : constant Wait_Event_Set := (Input => False, Output => True);\n+   Both_Events  : constant Wait_Event_Set := (others => True);\n+   Error_Event  : constant Wait_Event_Set := (others => False);\n+\n+   package SOC renames System.OS_Constants;\n+\n+   type nfds_t is mod 2 ** SOC.SIZEOF_nfds_t;\n+   for nfds_t'Size use SOC.SIZEOF_nfds_t;\n+\n+   FD_Type_Bound : constant := 2 ** (SOC.SIZEOF_fd_type - 1);\n+\n+   type FD_Type is range -FD_Type_Bound .. FD_Type_Bound - 1;\n+   for FD_Type'Size use SOC.SIZEOF_fd_type;\n+\n+   type Events_Type is mod 2 ** SOC.SIZEOF_pollfd_events;\n+   for Events_Type'Size use SOC.SIZEOF_pollfd_events;\n+\n+   type Pollfd is record\n+      Socket  : FD_Type;\n+      Events  : Events_Type := 0;\n+      REvents : Events_Type := 0;\n+   end record with Convention => C;\n+\n+   type Poll_Set is array (Positive range <>) of Pollfd with Convention => C;\n+\n+   type Set (Size : Positive) is record\n+      Length : Natural := 0;\n+      Max_FD : FD_Type := 0;\n+      Max_OK : Boolean;\n+      --  Is the Max_FD actual. It can became inactual after remove socket with\n+      --  Max_FD from set and became actual again after add socket with FD more\n+      --  than Max_FD.\n+      Fds    : Poll_Set (1 .. Size);\n+   end record;\n+\n+   function Length (Self : Set) return Natural\n+   is (Self.Length);\n+\n+   function Full (Self : Set) return Boolean\n+   is (Self.Size = Self.Length);\n+\n+end GNAT.Sockets.Poll;"}, {"sha": "01c7cc5b567c3a993696a37d9a827c3a8ca64e02", "filename": "gcc/ada/libgnat/g-socpol__dummy.adb", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol__dummy.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol__dummy.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socpol__dummy.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,32 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . S O C K E T S . P O L L                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                         Copyright (C) 2020, AdaCore                      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+pragma No_Body;"}, {"sha": "507471ef0ee43a67fcc741ad4189217d21dfe341", "filename": "gcc/ada/libgnat/g-socpol__dummy.ads", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol__dummy.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-socpol__dummy.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-socpol__dummy.ads?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,37 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    G N A T . S O C K E T S . P O L L                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                         Copyright (C) 2020, AdaCore                      --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package is a placeholder for the sockets binding for platforms where\n+--  it is not implemented.\n+\n+package GNAT.Sockets.Thin_Common is\n+   pragma Unimplemented_Unit;\n+end GNAT.Sockets.Thin_Common;"}, {"sha": "fc6e6d96be3fc319711a50457681a3814a0e3aac", "filename": "gcc/ada/libgnat/g-sopowa.adb", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-sopowa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-sopowa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sopowa.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,56 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . S O C K E T S . P O L L . W A I T               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Wait implementation on top of native poll call\n+--\n+--  This submodule can be used on systems where poll system call is natively\n+--  supported. Microsoft Windows supports WSAPoll system call from Vista\n+--  version and this submodule can be used on such Windows versions too, the\n+--  System.OS_Constants.Poll_Linkname constant defines appropriate link name\n+--  for Windows. But we do not use WSAPoll in GNAT.Sockets.Poll implementation\n+--  for now because it is much slower than select system call, at least in\n+--  Windows version 10.0.18363.1016.\n+\n+separate (GNAT.Sockets.Poll)\n+\n+procedure Wait\n+  (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer)\n+is\n+\n+   function Poll\n+     (Fds     : Poll_Set;\n+      Nfds    : nfds_t;\n+      Timeout : Interfaces.C.int) return Integer\n+     with Import, Convention => Stdcall, External_Name => SOC.Poll_Linkname;\n+\n+begin\n+   Result := Poll (Fds.Fds, nfds_t (Fds.Length), Timeout);\n+end Wait;"}, {"sha": "3d6643771b11aa415af549b0a9f35796697024d0", "filename": "gcc/ada/libgnat/g-sopowa__mingw.adb", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-sopowa__mingw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-sopowa__mingw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sopowa__mingw.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,92 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . S O C K E T S . P O L L . W A I T               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Wait implementation on top of Windows select call\n+--\n+--  Microsoft Windows from Vista version has WSAPoll function in API which is\n+--  similar to POSIX poll call, but experiments show that the WSAPoll is much\n+--  slower than select at least in Windows version 10.0.18363.1016.\n+\n+with GNAT.Sockets.Poll.G_Wait;\n+\n+separate (GNAT.Sockets.Poll)\n+\n+procedure Wait\n+  (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer)\n+is\n+   use Interfaces;\n+\n+   type FD_Array is array (1 .. Fds.Length) of FD_Type\n+     with Convention => C;\n+\n+   type FD_Set_Type is record\n+      Count : C.int;\n+      Set   : FD_Array;\n+   end record with Convention => C;\n+\n+   procedure Reset_Socket_Set (Set : in out FD_Set_Type) with Inline;\n+\n+   procedure Insert_Socket_In_Set (Set : in out FD_Set_Type; FD : FD_Type)\n+     with Inline;\n+\n+   function Is_Socket_In_Set (Set : FD_Set_Type; FD : FD_Type) return C.int\n+     with Import, Convention => C,\n+          External_Name => \"__gnat_is_socket_in_set\";\n+\n+   --------------------------\n+   -- Insert_Socket_In_Set --\n+   --------------------------\n+\n+   procedure Insert_Socket_In_Set (Set : in out FD_Set_Type; FD : FD_Type) is\n+   begin\n+      Set.Count := Set.Count + 1;\n+      Set.Set (Integer (Set.Count)) := FD;\n+   end Insert_Socket_In_Set;\n+\n+   ----------------------\n+   -- Reset_Socket_Set --\n+   ----------------------\n+\n+   procedure Reset_Socket_Set (Set : in out FD_Set_Type) is\n+   begin\n+      Set.Count := 0;\n+   end Reset_Socket_Set;\n+\n+   ----------\n+   -- Poll --\n+   ----------\n+\n+   procedure Poll is new G_Wait\n+     (FD_Set_Type, Reset_Socket_Set, Insert_Socket_In_Set, Is_Socket_In_Set);\n+\n+begin\n+   Poll (Fds, Timeout, Result);\n+end Wait;"}, {"sha": "02ccb77227ee287b3609083a7b298c134f5ccd33", "filename": "gcc/ada/libgnat/g-sopowa__posix.adb", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-sopowa__posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-sopowa__posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sopowa__posix.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,91 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                G N A T . S O C K E T S . P O L L . W A I T               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Wait implementation on top of posix select call\n+\n+with GNAT.Sockets.Poll.G_Wait;\n+\n+separate (GNAT.Sockets.Poll)\n+\n+procedure Wait\n+  (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer)\n+is\n+   use Interfaces;\n+\n+   function Get_Max_FD return FD_Type;\n+   --  Check is Max_FD is actual and correct it if necessary\n+\n+   type FD_Set_Type is array (0 .. Get_Max_FD / C.long'Size) of C.long\n+     with Convention => C;\n+\n+   procedure Reset_Socket_Set (Set : in out FD_Set_Type);\n+   --  Use own FD_ZERO routine because FD_Set_Type size depend on Fds.Max_FD\n+\n+   procedure Insert_Socket_In_Set (Set : in out FD_Set_Type; FD : FD_Type)\n+     with Import, Convention => C,\n+          External_Name => \"__gnat_insert_socket_in_set\";\n+\n+   function Is_Socket_In_Set (Set : FD_Set_Type; FD : FD_Type) return C.int\n+     with Import, Convention => C,\n+          External_Name => \"__gnat_is_socket_in_set\";\n+\n+   procedure Reset_Socket_Set (Set : in out FD_Set_Type) is\n+   begin\n+      Set := (others => 0);\n+   end Reset_Socket_Set;\n+\n+   procedure Poll is new G_Wait\n+     (FD_Set_Type, Reset_Socket_Set, Insert_Socket_In_Set, Is_Socket_In_Set);\n+\n+   ----------------\n+   -- Get_Max_FD --\n+   ----------------\n+\n+   function Get_Max_FD return FD_Type is\n+   begin\n+      if not Fds.Max_OK then\n+         Fds.Max_FD := Fds.Fds (Fds.Fds'First).Socket;\n+\n+         for J in Fds.Fds'First + 1 .. Fds.Length loop\n+            if Fds.Max_FD < Fds.Fds (J).Socket then\n+               Fds.Max_FD := Fds.Fds (J).Socket;\n+            end if;\n+         end loop;\n+\n+         Fds.Max_OK := True;\n+      end if;\n+\n+      return Fds.Max_FD;\n+   end Get_Max_FD;\n+\n+begin\n+   Poll (Fds, Timeout, Result);\n+end Wait;"}, {"sha": "a9135ea110d5e4ece46e3ccd75995c80489328b2", "filename": "gcc/ada/libgnat/g-spogwa.adb", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-spogwa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-spogwa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-spogwa.adb?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,139 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--             G N A T . S O C K E T S . P O L L . G _ W A I T              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with GNAT.Sockets.Thin_Common;\n+\n+procedure GNAT.Sockets.Poll.G_Wait\n+  (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer)\n+is\n+   use Interfaces;\n+\n+   use type C.int;\n+\n+   function C_Select\n+     (Nfds      : C.int;\n+      readfds   : access FD_Set_Type;\n+      writefds  : access FD_Set_Type;\n+      exceptfds : access FD_Set_Type;\n+      timeout   : access Thin_Common.Timeval) return Integer\n+     with Import => True, Convention => Stdcall, External_Name => \"select\";\n+\n+   Timeout_V : aliased Thin_Common.Timeval;\n+   Timeout_A : access Thin_Common.Timeval;\n+\n+   Rfds      : aliased FD_Set_Type;\n+   Rcount    : Natural := 0;\n+   Wfds      : aliased FD_Set_Type;\n+   Wcount    : Natural := 0;\n+   Efds      : aliased FD_Set_Type;\n+\n+   Rfdsa     : access FD_Set_Type;\n+   Wfdsa     : access FD_Set_Type;\n+\n+   FD_Events : Events_Type;\n+\n+begin\n+   --  Setup (convert data from poll to select layout)\n+\n+   if Timeout >= 0 then\n+      Timeout_A := Timeout_V'Access;\n+      Timeout_V.tv_sec  := Thin_Common.time_t  (Timeout / 1000);\n+      Timeout_V.tv_usec := Thin_Common.suseconds_t (Timeout rem 1000 * 1000);\n+   end if;\n+\n+   Reset_Socket_Set (Rfds);\n+   Reset_Socket_Set (Wfds);\n+   Reset_Socket_Set (Efds);\n+\n+   for J in Fds.Fds'First .. Fds.Length loop\n+      Fds.Fds (J).REvents := 0;\n+\n+      FD_Events := Fds.Fds (J).Events;\n+\n+      if (FD_Events and (SOC.POLLIN or SOC.POLLPRI)) /= 0 then\n+         Insert_Socket_In_Set (Rfds, Fds.Fds (J).Socket);\n+         Rcount := Rcount + 1;\n+      end if;\n+\n+      if (FD_Events and SOC.POLLOUT) /= 0 then\n+         Insert_Socket_In_Set (Wfds, Fds.Fds (J).Socket);\n+         Wcount := Wcount + 1;\n+      end if;\n+\n+      Insert_Socket_In_Set (Efds, Fds.Fds (J).Socket);\n+\n+      if Fds.Fds (J).Socket > Fds.Max_FD then\n+         raise Program_Error with \"Wrong Max_FD\";\n+      end if;\n+   end loop;\n+\n+   --  Any non-null descriptor set must contain at least one handle\n+   --  to a socket on Windows (MSDN).\n+\n+   if Rcount /= 0 then\n+      Rfdsa := Rfds'Access;\n+   end if;\n+\n+   if Wcount /= 0 then\n+      Wfdsa := Wfds'Access;\n+   end if;\n+\n+   --  Call OS select\n+\n+   Result :=\n+     C_Select (C.int (Fds.Max_FD + 1), Rfdsa, Wfdsa, Efds'Access, Timeout_A);\n+\n+   --  Build result (convert back from select to poll layout)\n+\n+   if Result > 0 then\n+      Result := 0;\n+\n+      for J in Fds.Fds'First .. Fds.Length loop\n+         if Is_Socket_In_Set (Rfds, Fds.Fds (J).Socket) /= 0 then\n+            --  Do not need \"or\" with Poll_Ptr (J).REvents because it's zero\n+\n+            Fds.Fds (J).REvents := SOC.POLLIN;\n+         end if;\n+\n+         if Is_Socket_In_Set (Wfds, Fds.Fds (J).Socket) /= 0 then\n+            Fds.Fds (J).REvents := Fds.Fds (J).REvents or SOC.POLLOUT;\n+         end if;\n+\n+         if Is_Socket_In_Set (Efds, Fds.Fds (J).Socket) /= 0 then\n+            Fds.Fds (J).REvents := Fds.Fds (J).REvents or SOC.POLLERR;\n+         end if;\n+\n+         if Fds.Fds (J).REvents /= 0 then\n+            Result := Result + 1;\n+         end if;\n+      end loop;\n+   end if;\n+end GNAT.Sockets.Poll.G_Wait;"}, {"sha": "bde6a69fe5051e8898fae0109cae609ee6b8dc2f", "filename": "gcc/ada/libgnat/g-spogwa.ads", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-spogwa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Flibgnat%2Fg-spogwa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-spogwa.ads?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -0,0 +1,50 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--             G N A T . S O C K E T S . P O L L . G _ W A I T              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--                       Copyright (C) 2020, AdaCore                        --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces.C;\n+\n+private generic\n+   type FD_Set_Type is private;\n+   with procedure Reset_Socket_Set (Set : in out FD_Set_Type);\n+   with procedure Insert_Socket_In_Set\n+          (Set : in out FD_Set_Type; FD : FD_Type);\n+   with function Is_Socket_In_Set\n+          (Set : FD_Set_Type; FD : FD_Type) return Interfaces.C.int;\n+procedure GNAT.Sockets.Poll.G_Wait\n+  (Fds : in out Set; Timeout : Interfaces.C.int; Result : out Integer);\n+--  Common code to implement GNAT.Sockets.Poll.Wait routine on top of posix or\n+--  win32 select API.\n+--  Posix and Win32 select has the same API but different socket set structure.\n+--  C API for select has socket set size defined at compilation stage. This Ada\n+--  implementation allow to define size of socket set at the execution time.\n+--  Unlike C select API we do not need allocate socket set for maximum number\n+--  of sockets when we need to check only few of them. And we are not limited\n+--  with FD_SETSIZE when we need more sockets to check."}, {"sha": "e3e5bc2f03d4b1c78dae8d5d5a4f9601c8e67d09", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d08d481912b9a2dc3388f8e1183cea0bf3ffae9f/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=d08d481912b9a2dc3388f8e1183cea0bf3ffae9f", "patch": "@@ -96,7 +96,7 @@ pragma Style_Checks (\"M32766\");\n /* Define _BSD_SOURCE to get CRTSCTS */\n # define _BSD_SOURCE\n \n-#endif /* defined (__linux__) */\n+#endif /* defined (__linux__) || defined (__ANDROID__) */\n \n /* Include gsocket.h before any system header so it can redefine FD_SETSIZE */\n \n@@ -121,6 +121,8 @@ pragma Style_Checks (\"M32766\");\n  **/\n \n # include <vxWorks.h>\n+#elif !defined(__MINGW32__)\n+#include <poll.h>\n #endif\n \n #include \"adaint.h\"\n@@ -1735,12 +1737,28 @@ CND(SIZEOF_sigset, \"sigset\")\n #endif\n \n #if defined(_WIN32) || defined(__vxworks)\n+#define SIZEOF_nfds_t sizeof (int) * 8\n #define SIZEOF_socklen_t sizeof (size_t)\n #else\n+#define SIZEOF_nfds_t sizeof (nfds_t) * 8\n #define SIZEOF_socklen_t sizeof (socklen_t)\n #endif\n+CND(SIZEOF_nfds_t, \"Size of nfds_t\");\n CND(SIZEOF_socklen_t, \"Size of socklen_t\");\n \n+{\n+#if defined(__vxworks)\n+#define SIZEOF_fd_type sizeof (int) * 8\n+#define SIZEOF_pollfd_events sizeof (short) * 8\n+#else\n+const struct pollfd v_pollfd;\n+#define SIZEOF_fd_type sizeof (v_pollfd.fd) * 8\n+#define SIZEOF_pollfd_events sizeof (v_pollfd.events) * 8\n+#endif\n+CND(SIZEOF_fd_type, \"Size of socket fd\");\n+CND(SIZEOF_pollfd_events, \"Size of pollfd.events\");\n+}\n+\n #ifndef IF_NAMESIZE\n #ifdef IF_MAX_STRING_SIZE\n #define IF_NAMESIZE IF_MAX_STRING_SIZE\n@@ -1750,6 +1768,50 @@ CND(SIZEOF_socklen_t, \"Size of socklen_t\");\n #endif\n CND(IF_NAMESIZE, \"Max size of interface name with 0 terminator\");\n \n+/*\n+\n+   --  Poll values\n+\n+*/\n+\n+#if defined(__vxworks)\n+#ifndef POLLIN\n+#define POLLIN 1\n+#endif\n+\n+#ifndef POLLPRI\n+#define POLLPRI 2\n+#endif\n+\n+#ifndef POLLOUT\n+#define POLLOUT 4\n+#endif\n+\n+#ifndef POLLERR\n+#define POLLERR 8\n+#endif\n+\n+#ifndef POLLHUP\n+#define POLLHUP 16\n+#endif\n+\n+#ifndef POLLNVAL\n+#define POLLNVAL 32\n+#endif\n+\n+#elif defined(_WIN32)\n+#define POLLPRI 0\n+/*  If the POLLPRI flag is set on a socket for the Microsoft Winsock provider,\n+ *  the WSAPoll function will fail. */\n+#endif\n+\n+CND(POLLIN, \"There is data to read\");\n+CND(POLLPRI, \"Urgent data to read\");\n+CND(POLLOUT, \"Writing will not block\");\n+CND(POLLERR, \"Error (output only)\");\n+CND(POLLHUP, \"Hang up (output only)\");\n+CND(POLLNVAL, \"Invalid request\");\n+\n /*\n \n    --  Fields of struct msghdr\n@@ -1799,6 +1861,13 @@ CST(Inet_Pton_Linkname, \"\")\n #endif\n CST(Inet_Ntop_Linkname, \"\")\n \n+#if defined(_WIN32)\n+# define Poll_Linkname \"WSAPoll\"\n+#else\n+# define Poll_Linkname \"poll\"\n+#endif\n+CST(Poll_Linkname, \"\")\n+\n #endif /* HAVE_SOCKETS */\n \n /*"}]}