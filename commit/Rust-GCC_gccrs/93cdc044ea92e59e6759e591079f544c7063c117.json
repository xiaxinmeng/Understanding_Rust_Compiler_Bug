{"sha": "93cdc044ea92e59e6759e591079f544c7063c117", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNjZGMwNDRlYTkyZTU5ZTY3NTllNTkxMDc5ZjU0NGM3MDYzYzExNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-02-27T02:27:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-27T02:27:38Z"}, "message": "pt.c (tsubst, [...]): Support member class templates.\n\n\t* pt.c (tsubst, TEMPLATE_DECL): Support member class templates.\n\t(tsubst, *_PARM): Support multiple levels of template classes.\n\t(instantiate_class_template): Look up the pattern from the\n\toriginal template.\n\t(lookup_template_class): Handle getting a template for d1.\n\t(push_template_decl): Correct setting of 'primary'.\n\t(reduce_template_parm_level): Add 'levels' parm.\n\t(finish_member_template_decl): Support member class templates.\n\t(template_class_depth): Handle multiple levels.\n\t* parse.y (component_decl_1, fn.def2): Remove member template case.\n\t(component_decl): Add member template cases.\n\t* decl2.c (check_member_template): We now handle member template\n\tclasses.\n\t* decl.c (pushtag): Handle member templates.\n\t* method.c (do_inline_function_hair): Don't touch\n\tIDENTIFIER_GLOBAL_VALUE.\n\t* init.c (build_offset_ref): If name isn't an identifier, just\n\treturn it.\n\t* spew.c (yylex): Handle PTYPENAME like TYPENAME.\n\t* typeck.c (get_delta_difference): Do adjust for conversions to\n\tand from virtual base.\n\nFrom-SVN: r18280", "tree": {"sha": "9c59831d3f8b9c110c366e7b78742e0abaccd4c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c59831d3f8b9c110c366e7b78742e0abaccd4c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93cdc044ea92e59e6759e591079f544c7063c117", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cdc044ea92e59e6759e591079f544c7063c117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93cdc044ea92e59e6759e591079f544c7063c117", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93cdc044ea92e59e6759e591079f544c7063c117/comments", "author": null, "committer": null, "parents": [{"sha": "a7b4c0acc8bc02994bb0050ea8f2d34b833d3b41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b4c0acc8bc02994bb0050ea8f2d34b833d3b41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7b4c0acc8bc02994bb0050ea8f2d34b833d3b41"}], "stats": {"total": 6798, "additions": 3435, "deletions": 3363}, "files": [{"sha": "319136f50c8c2aedfa6d9fa5c84353e8c5dfa09c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -1,3 +1,28 @@\n+Fri Feb 27 02:25:16 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst, TEMPLATE_DECL): Support member class templates.\n+\t(tsubst, *_PARM): Support multiple levels of template classes.\n+\t(instantiate_class_template): Look up the pattern from the\n+\toriginal template.\n+\t(lookup_template_class): Handle getting a template for d1.\n+\t(push_template_decl): Correct setting of 'primary'.\n+\t(reduce_template_parm_level): Add 'levels' parm.\n+\t(finish_member_template_decl): Support member class templates.\n+\t(template_class_depth): Handle multiple levels.\n+\t* parse.y (component_decl_1, fn.def2): Remove member template case.\n+\t(component_decl): Add member template cases.\n+\t* decl2.c (check_member_template): We now handle member template\n+\tclasses.\n+\t* decl.c (pushtag): Handle member templates.\n+\t* method.c (do_inline_function_hair): Don't touch\n+\tIDENTIFIER_GLOBAL_VALUE.\n+\t* init.c (build_offset_ref): If name isn't an identifier, just \n+\treturn it.\n+\t* spew.c (yylex): Handle PTYPENAME like TYPENAME.\n+\n+\t* typeck.c (get_delta_difference): Do adjust for conversions to\n+\tand from virtual base.\n+\n Wed Feb 25 09:51:29 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* typeck.c (get_delta_difference): Give hard error for conversion"}, {"sha": "9f96b4af0a5da68b76bf5f624c2260bdccd9e01e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -1439,12 +1439,9 @@ extern int flag_new_for_scope;\n   (TREE_CODE (NODE) == TEMPLATE_DECL \\\n    && TREE_CODE (DECL_TEMPLATE_RESULT (NODE)) == FUNCTION_DECL)\n \n-/* A `primary' template is one which depends on no tbemplate parameters\n-   except those specified in its parameter list.  So, a template\n-   member of a non-template class is primary, and every global\n-   function template is primary, but a member function of a template\n-   class is not primary, neither is a member template of a template\n-   class.  */\n+/* A `primary' template is one that has its own template header.  A\n+   member function of a class template is a template, but not primary.\n+   A member template is primary.  */\n #define PRIMARY_TEMPLATE_P(NODE) \\\n   (TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (NODE)) == (NODE))\n "}, {"sha": "0002891352bcd0c303e6c44eb05e8086dda63f2b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -2179,47 +2179,43 @@ pushtag (name, type, globalize)\n       /* Do C++ gratuitous typedefing.  */\n       if (IDENTIFIER_TYPE_VALUE (name) != type)\n         {\n-          register tree d;\n-\t  int newdecl = 0;\n-\t  \n-\t  if (b->parm_flag != 2\n-\t      || TYPE_SIZE (current_class_type) != NULL_TREE)\n-\t    {\n-\t      d = lookup_nested_type (type, c_decl);\n+          register tree d = NULL_TREE;\n+\t  int newdecl = 0, in_class = 0;\n \n-\t      if (d == NULL_TREE)\n-\t\t{\n-\t\t  newdecl = 1;\n-\t\t  d = build_decl (TYPE_DECL, name, type);\n-\t\t  SET_DECL_ARTIFICIAL (d);\n-\t\t  set_identifier_type_value_with_scope (name, type, b);\n-\t\t}\n-\t      else\n-\t\td = TYPE_MAIN_DECL (d);\n-\n-\t      TYPE_NAME (type) = d;\n-\t      DECL_CONTEXT (d) = context;\n-\t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n-\t\td = push_template_decl (d);\n-\n-\t      if (b->parm_flag == 2)\n-\t\td = pushdecl_class_level (d);\n-\t      else\n-\t\td = pushdecl_with_scope (d, b);\n-\t    }\n+\t  if ((b->pseudo_global && b->level_chain->parm_flag == 2)\n+\t      || b->parm_flag == 2)\n+\t    in_class = 1;\n \t  else\n+\t    d = lookup_nested_type (type, c_decl);\n+\n+\t  if (d == NULL_TREE)\n \t    {\n-\t      /* Make nested declarations go into class-level scope.  */\n \t      newdecl = 1;\n \t      d = build_decl (TYPE_DECL, name, type);\n \t      SET_DECL_ARTIFICIAL (d);\n-\t      TYPE_NAME (type) = d;\n-\t      DECL_CONTEXT (d) = context;\n-\t      if (! globalize && processing_template_decl && IS_AGGR_TYPE (type))\n-\t\td = push_template_decl (d);\n+\t      if (! in_class)\n+\t\tset_identifier_type_value_with_scope (name, type, b);\n+\t    }\n+\t  else\n+\t    d = TYPE_MAIN_DECL (d);\n+\n+\t  TYPE_NAME (type) = d;\n+\t  DECL_CONTEXT (d) = context;\n \n-\t      d = pushdecl_class_level (d);\n+\t  if (! globalize && processing_template_decl\n+\t      && IS_AGGR_TYPE (type))\n+\t    {\n+\t      d = push_template_decl (d);\n+\t      if (b->pseudo_global && b->level_chain->parm_flag == 2)\n+\t\tpushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n+\t\t\t\t     b->level_chain);\n \t    }\n+\n+\t  if (b->parm_flag == 2)\n+\t    d = pushdecl_class_level (d);\n+\t  else\n+\t    d = pushdecl_with_scope (d, b);\n+\n \t  if (newdecl)\n \t    {\n \t      if (ANON_AGGRNAME_P (name))"}, {"sha": "cb786f91c03a922c9a3bb454735fc68b1c6be83a", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -1395,9 +1395,6 @@ check_member_template (tmpl)\n \t   A local class shall not have member templates.  */\n \tcp_error (\"declaration of of member template `%#D' in local class\",\n \t\t  decl);\n-\n-      /* We don't handle member template classes yet. */\n-      sorry (\"member templates classes\");\n     }\n   else\n     cp_error (\"template declaration of `%#D'\", decl);"}, {"sha": "e2104ce5d4943bed70406c7b0222229c3196d8cd", "filename": "gcc/cp/init.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -1836,6 +1836,9 @@ build_offset_ref (type, name)\n   tree basebinfo = NULL_TREE;\n   int dtor = 0;\n \n+  if (TREE_CODE (name) != IDENTIFIER_NODE)\n+    return name;\n+\n   if (type == std_node)\n     return do_scoped_id (name, 0);\n "}, {"sha": "3a800dafc7107d00a318223702081ffeda37ad0e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -151,11 +151,6 @@ do_inline_function_hair (type, friend_list)\n \t      DECL_CONTEXT (args) = method;\n \t      args = TREE_CHAIN (args);\n \t    }\n-\n-\t  /* Allow this decl to be seen in global scope.  Don't do this for\n-             local class methods, though.  */\n-\t  if (! current_function_decl)\n-\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (method)) = method;\n \t}\n       method = TREE_CHAIN (method);\n     }\n@@ -174,10 +169,6 @@ do_inline_function_hair (type, friend_list)\n \t      DECL_CONTEXT (args) = fndecl;\n \t      args = TREE_CHAIN (args);\n \t    }\n-\n-\t  /* Allow this decl to be seen in global scope */\n-\t  if (! current_function_decl)\n-\t    IDENTIFIER_GLOBAL_VALUE (DECL_ASSEMBLER_NAME (fndecl)) = fndecl;\n \t}\n \n       friend_list = TREE_CHAIN (friend_list);"}, {"sha": "2591f7d08d51c7010b65f02173443c42cb62a375", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3264, "deletions": 3258, "changes": 6522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=93cdc044ea92e59e6759e591079f544c7063c117"}, {"sha": "71a59a19b0111cd3eb4a7d0d02195d565973f9d6", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -769,8 +769,6 @@ fn.def2:\n \t\t  $$ = start_method (specs, $2); goto rest_of_mdef; }\n \t| constructor_declarator\n \t\t{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }\n-        | template_header fn.def2 \n-                { $$ = finish_member_template_decl ($1, $2); }\n \t;\n \n return_id:\n@@ -2760,6 +2758,14 @@ component_decl:\n \t| extension component_decl\n \t\t{ $$ = $2;\n \t\t  pedantic = $<itype>1; }\n+        | template_header component_decl\n+                { $$ = finish_member_template_decl ($1, $2); }\n+\t| template_header typed_declspecs ';'\n+                {\n+\t\t  shadow_tag ($2.t);\n+\t\t  note_list_got_semicolon ($2.t);\n+\t\t  $$ = finish_member_template_decl ($1, $2.t);\n+\t\t}\n \t;\n \n component_decl_1:\n@@ -2799,8 +2805,6 @@ component_decl_1:\n \t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n \t| using_decl\n \t\t{ $$ = do_class_using_decl ($1); }\n-        | template_header component_decl_1 \n-                { $$ = finish_member_template_decl ($1, $2); }\n \n /* The case of exactly one component is handled directly by component_decl.  */\n /* ??? Huh? ^^^ */"}, {"sha": "a64fe4cc5a6a965c756d5987bdd620d11ba864d3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 93, "deletions": 47, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -99,12 +99,24 @@ finish_member_template_decl (template_parameters, decl)\n   tree decl;\n {\n   if (template_parameters)\n-    end_template_decl();\n+    end_template_decl ();\n   else\n-    end_specialization();\n+    end_specialization ();\n \n-  if (decl && DECL_TEMPLATE_INFO (decl) &&\n-      !DECL_TEMPLATE_SPECIALIZATION (decl))\n+  if (decl == NULL_TREE || decl == void_type_node)\n+    return NULL_TREE;\n+  else if (TREE_CODE (decl) == TREE_LIST)\n+    {\n+      decl = TREE_VALUE (decl);\n+      if (IS_AGGR_TYPE (decl) && CLASSTYPE_TEMPLATE_INFO (decl))\n+\t{\n+\t  tree tmpl = CLASSTYPE_TI_TEMPLATE (decl);\n+\t  check_member_template (tmpl);\n+\t  return tmpl;\n+\t}\n+    }\n+  else if (DECL_TEMPLATE_INFO (decl) &&\n+\t   !DECL_TEMPLATE_SPECIALIZATION (decl))\n     {\n       check_member_template (DECL_TI_TEMPLATE (decl));\n       return DECL_TI_TEMPLATE (decl);\n@@ -130,14 +142,14 @@ int\n template_class_depth (type)\n      tree type;\n {\n-  int depth = 0;\n+  int depth;\n \n-  /* Note: this implementation will be broken when we have nested\n-     template classes.  Presumably we will have to wrap this if\n-     statement a loop.  */\n-  if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && uses_template_parms (CLASSTYPE_TI_ARGS (type)))\n-    ++depth;\n+  for (depth = 0; type && TREE_CODE (type) != FUNCTION_DECL;\n+       type = TYPE_CONTEXT (type))\n+    if (CLASSTYPE_TEMPLATE_INFO (type)\n+\t&& PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type))\n+\t&& uses_template_parms (CLASSTYPE_TI_ARGS (type)))\n+      ++depth;\n \n   return depth;\n }\n@@ -1047,26 +1059,27 @@ build_template_parm_index (index, level, orig_level, decl, type)\n \n \n /* Return a TEMPLATE_PARM_INDEX, similar to INDEX, but whose\n-   TEMPLATE_PARM_LEVEL has been decreased by one.  If such a\n+   TEMPLATE_PARM_LEVEL has been decreased by LEVELS.  If such a\n    TEMPLATE_PARM_INDEX already exists, it is returned; otherwise, a\n    new one is created.  */\n \n static tree \n-reduce_template_parm_level (index, type)\n+reduce_template_parm_level (index, type, levels)\n      tree index;\n      tree type;\n+     int levels;\n {\n   if (TEMPLATE_PARM_DESCENDANTS (index) == NULL_TREE\n       || (TEMPLATE_PARM_LEVEL (TEMPLATE_PARM_DESCENDANTS (index))\n-\t  != TEMPLATE_PARM_LEVEL (index) - 1))\n+\t  != TEMPLATE_PARM_LEVEL (index) - levels))\n     {\n       tree decl \n \t= build_decl (TREE_CODE (TEMPLATE_PARM_DECL (index)),\n \t\t      DECL_NAME (TEMPLATE_PARM_DECL (index)),\n \t\t      type);\n       tree t\n \t= build_template_parm_index (TEMPLATE_PARM_IDX (index),\n-\t\t\t\t     TEMPLATE_PARM_LEVEL (index) - 1,\n+\t\t\t\t     TEMPLATE_PARM_LEVEL (index) - levels,\n \t\t\t\t     TEMPLATE_PARM_ORIG_LEVEL (index),\n \t\t\t\t     decl, type);\n       TEMPLATE_PARM_DESCENDANTS (index) = t;\n@@ -1313,16 +1326,19 @@ push_template_decl (decl)\n        is assumed to be a member of the class.  */\n     ctx = current_class_type;\n \n-  if ((! ctx\n-       || (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't'\n-\t   && template_class_depth (ctx) == 0))\n-      /* At this point, we know that the DECL is not a member of some\n-\t template class.  However, a friend function declared in a\n-\t template class is still not primary, since, in general it can\n-\t depend on the template parameters of the enclosing class.  */\n-      && !(is_friend\n-\t   && DECL_CLASS_CONTEXT (decl)\n-\t   && template_class_depth (DECL_CLASS_CONTEXT (decl)) > 0))\n+  /* For determining whether this is a primary template or not, we're really\n+     interested in the lexical context, not the true context.  */\n+  if (is_friend)\n+    info = DECL_CLASS_CONTEXT (decl);\n+  else\n+    info = ctx;\n+\n+  if (info && TREE_CODE (info) == FUNCTION_DECL)\n+    primary = 0;\n+  else if (! info\n+\t   || (TYPE_BEING_DEFINED (info) && template_header_count\n+\t       && ! processing_specialization)\n+\t   || (template_header_count > template_class_depth (info)))\n     primary = 1;\n   else\n     primary = 0;\n@@ -2376,6 +2392,13 @@ lookup_template_class (d1, arglist, in_decl, context)\n       template = CLASSTYPE_TI_TEMPLATE (d1);\n       d1 = DECL_NAME (template);\n     }\n+  else if (TREE_CODE (d1) == TEMPLATE_DECL\n+\t   && TREE_CODE (DECL_RESULT (d1)) == TYPE_DECL)\n+    {\n+      template = d1;\n+      d1 = DECL_NAME (template);\n+      context = DECL_CONTEXT (template);\n+    }\n   else\n     my_friendly_abort (272);\n \n@@ -2928,6 +2951,13 @@ instantiate_class_template (type)\n   my_friendly_assert (TREE_CODE (template) == TEMPLATE_DECL, 279);\n   args = TI_ARGS (template_info);\n \n+  if (DECL_TEMPLATE_INFO (template))\n+    {\n+      args = add_to_template_args (DECL_TI_ARGS (template), args);\n+      while (DECL_TEMPLATE_INFO (template))\n+\ttemplate = DECL_TI_TEMPLATE (template);\n+    }\n+\n   t = most_specialized_class\n     (DECL_TEMPLATE_SPECIALIZATIONS (template), args);\n \n@@ -3391,6 +3421,7 @@ tsubst (t, args, in_decl)\n       {\n \tint idx;\n \tint level;\n+\tint levels;\n \ttree r = NULL_TREE;\n \n \tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM\n@@ -3411,12 +3442,17 @@ tsubst (t, args, in_decl)\n \n \t    if (TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n \t      {\n-\t\tif (TREE_VEC_LENGTH (args) >= level - 1)\n+\t\tlevels = TREE_VEC_LENGTH (args);\n+\t\tif (level <= levels)\n \t\t  arg = TREE_VEC_ELT\n \t\t    (TREE_VEC_ELT (args, level - 1), idx);\n \t      }\n-\t    else if (level == 1)\n-\t      arg = TREE_VEC_ELT (args, idx);\n+\t    else\n+\t      {\n+\t\tlevels = 1;\n+\t\tif (level == 1)\n+\t\t  arg = TREE_VEC_ELT (args, idx);\n+\t      }\n \n \t    if (arg != NULL_TREE)\n \t      {\n@@ -3470,14 +3506,14 @@ tsubst (t, args, in_decl)\n \t    r = copy_node (t);\n \t    TEMPLATE_TYPE_PARM_INDEX (r)\n \t      = reduce_template_parm_level (TEMPLATE_TYPE_PARM_INDEX (t),\n-\t\t\t\t\t    r);\n+\t\t\t\t\t    r, levels);\n \t    TYPE_STUB_DECL (r) = TYPE_NAME (r) = TEMPLATE_TYPE_DECL (r);\n \t    TYPE_MAIN_VARIANT (r) = r;\n \t    TYPE_POINTER_TO (r) = NULL_TREE;\n \t    break;\n \n \t  case TEMPLATE_PARM_INDEX:\n-\t    r = reduce_template_parm_level (t, TREE_TYPE (t));\n+\t    r = reduce_template_parm_level (t, TREE_TYPE (t), levels);\n \t    break;\n \t   \n \t  default:\n@@ -3493,23 +3529,15 @@ tsubst (t, args, in_decl)\n \t   of a template class.  */\n \ttree tmpl;\n \ttree decl = DECL_TEMPLATE_RESULT (t);\n-\ttree new_decl;\n \ttree parms;\n \ttree* new_parms;\n \ttree spec;\n \n-\tif (TREE_CODE (decl) == TYPE_DECL)\n-\t  {\n-\t    if (TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TEMPLATE_PARM)\n-\t      /* There is no tsubst'ing to be done in a template template\n-\t\t parameter.  */\n-\t      return t;\n-\n-\t    /* This must be a member template class.  We don't handle\n-\t       this case yet.  */\n-\t    sorry (\"member template classes\");\n-\t    return t;\n-\t  }\n+\tif (TREE_CODE (decl) == TYPE_DECL\n+\t    && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TEMPLATE_PARM)\n+\t  /* There is no tsubst'ing to be done in a template template\n+\t     parameter.  */\n+\t  return t;\n \n \t/* We might already have an instance of this template. */\n \tspec = retrieve_specialization (t, args);\n@@ -3531,10 +3559,22 @@ tsubst (t, args, in_decl)\n \tDECL_CLASS_CONTEXT (tmpl) = tsubst (DECL_CLASS_CONTEXT (t),\n \t\t\t\t\t    args, in_decl);\n \tDECL_TEMPLATE_INFO (tmpl) = build_tree_list (t, args);\n-\tnew_decl = tsubst (decl, args, in_decl);\n-\tDECL_RESULT (tmpl) = new_decl;\n-\tDECL_TI_TEMPLATE (new_decl) = tmpl;\n-\tTREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n+\n+\tif (TREE_CODE (decl) == TYPE_DECL)\n+\t  {\n+\t    tree new_type = tsubst (TREE_TYPE (t), args, in_decl);\n+\t    TREE_TYPE (tmpl) = new_type;\n+\t    CLASSTYPE_TI_TEMPLATE (new_type) = tmpl;\n+\t    DECL_RESULT (tmpl) = TYPE_MAIN_DECL (new_type);\n+\t  }\n+\telse\n+\t  {\n+\t    tree new_decl = tsubst (decl, args, in_decl);\n+\t    DECL_RESULT (tmpl) = new_decl;\n+\t    DECL_TI_TEMPLATE (new_decl) = tmpl;\n+\t    TREE_TYPE (tmpl) = TREE_TYPE (new_decl);\n+\t  }\n+\n \tDECL_TEMPLATE_INSTANTIATIONS (tmpl) = NULL_TREE;\n \tSET_DECL_IMPLICIT_INSTANTIATION (tmpl);\n \n@@ -3572,6 +3612,12 @@ tsubst (t, args, in_decl)\n \t\t\t NULL_TREE);\n \t  }\n \n+\tif (PRIMARY_TEMPLATE_P (t))\n+\t  TREE_TYPE (DECL_INNERMOST_TEMPLATE_PARMS (tmpl)) = tmpl;\n+\n+\tif (TREE_CODE (decl) == TYPE_DECL)\n+\t  return tmpl;\n+\n \t/* What should we do with the specializations of this member\n \t   template?  Are they specializations of this new template,\n \t   or instantiations of the templates they previously were?"}, {"sha": "2112e23cf27093debe106c5f0b7874db60900491", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -313,14 +313,14 @@ yylex ()\n \t    case TYPENAME:\n \t    case SELFNAME:\n \t    case NSNAME:\n+\t    case PTYPENAME:\n \t      lastiddecl = trrr;\n \t      if (got_scope)\n \t\ttmp_token.yylval.ttype = trrr;\n \t      break;\n \n \t    case PFUNCNAME:\n \t    case IDENTIFIER:\n-\t    case PTYPENAME:\n \t      lastiddecl = trrr;\n \t      break;\n "}, {"sha": "ce695e0b44d82c724c37c8549b128cb04e37a05c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93cdc044ea92e59e6759e591079f544c7063c117/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=93cdc044ea92e59e6759e591079f544c7063c117", "patch": "@@ -6304,8 +6304,16 @@ get_delta_difference (from, to, force)\n \t  return delta;\n \t}\n       binfo = get_binfo (to, from, 1);\n-      if (binfo == 0 || binfo == error_mark_node || TREE_VIA_VIRTUAL (binfo))\n+      if (binfo == 0 || binfo == error_mark_node)\n \treturn delta;\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\t{\n+\t  binfo = binfo_member (BINFO_TYPE (binfo),\n+\t\t\t\tCLASSTYPE_VBASECLASSES (from));\n+\t  cp_warning (\"pointer to member cast to virtual base `%T'\",\n+\t\t      BINFO_TYPE (binfo));\n+\t  warning (\"  will only work if you are very careful\");\n+\t}\n       delta = BINFO_OFFSET (binfo);\n       delta = cp_convert (ptrdiff_type_node, delta);\n       \n@@ -6325,7 +6333,6 @@ get_delta_difference (from, to, force)\n       else\n \tcp_error (\"pointer to member conversion from virtual base `%T'\",\n \t\t  BINFO_TYPE (binfo));\n-      return delta;\n     }\n \n   return BINFO_OFFSET (binfo);"}]}