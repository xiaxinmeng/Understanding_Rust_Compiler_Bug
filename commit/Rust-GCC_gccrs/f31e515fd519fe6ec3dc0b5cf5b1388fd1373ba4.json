{"sha": "f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMxZTUxNWZkNTE5ZmU2ZWMzZGMwYjVjZjViMTM4OGZkMTM3M2JhNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-15T14:37:57Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-15T14:37:57Z"}, "message": "Fix vector/scalar to vector/vector conversion (PR92515)\n\nr278235 broke conversions of vector/scalar shifts into vector/vector\nshifts on targets that only provide the latter.  We need to record\nwhether a conversion is required in that case too.\n\nAlso, the old useless_type_conversion_p condition seemed unnecessarily\nstrong, since the shift amount can have a different signedness from\nthe shifted value and its vector type is never assumed to be identical\nto vectype.  The patch therefore uses tree_nop_conversion_p instead.\n\n2019-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR tree-optimization/92515\n\t* tree-vect-stmts.c (vectorizable_shift): Record incompatible op1\n\ttypes when converting a vector/scalar shift into a vector/vector one,\n\tusing tree_nop_conversion_p instead of useless_type_conversion_p.\n\tMove the conversion code to the transform block.\n\nFrom-SVN: r278295", "tree": {"sha": "634ce276a3251413184a9402f80b56a7bad672a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/634ce276a3251413184a9402f80b56a7bad672a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63841daf70b8f5d9ab3014956ea2c0f22488660e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63841daf70b8f5d9ab3014956ea2c0f22488660e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63841daf70b8f5d9ab3014956ea2c0f22488660e"}], "stats": {"total": 34, "additions": 19, "deletions": 15}, "files": [{"sha": "619afc5b6d6d318746316ea56159558a564cd499", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4", "patch": "@@ -1,3 +1,11 @@\n+2019-11-15  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/92515\n+\t* tree-vect-stmts.c (vectorizable_shift): Record incompatible op1\n+\ttypes when converting a vector/scalar shift into a vector/vector one,\n+\tusing tree_nop_conversion_p instead of useless_type_conversion_p.\n+\tMove the conversion code to the transform block.\n+\n 2019-11-15  Matthew Malcomson  <matthew.malcomson@arm.com>\n \n \t* read-rtl-function.c"}, {"sha": "6164946228d7d9f8b1d14d5716857d6605efd347", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f31e515fd519fe6ec3dc0b5cf5b1388fd1373ba4", "patch": "@@ -5750,21 +5750,9 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n                  the rhs being int, instead of the same type as the lhs,\n                  so make sure the scalar is the right type if we are\n \t\t dealing with vectors of long long/long/short/char.  */\n-              if (dt[1] == vect_constant_def)\n-\t\t{\n-\t\t  if (!slp_node)\n-\t\t    op1 = fold_convert (TREE_TYPE (vectype), op1);\n-\t\t}\n-\t      else if (!useless_type_conversion_p (TREE_TYPE (vectype),\n-\t\t\t\t\t\t   TREE_TYPE (op1)))\n-\t\t{\n-\t\t  if (vec_stmt && !slp_node)\n-\t\t    {\n-\t\t      op1 = fold_convert (TREE_TYPE (vectype), op1);\n-\t\t      op1 = vect_init_vector (stmt_info, op1,\n-\t\t\t\t\t      TREE_TYPE (vectype), NULL);\n-\t\t    }\n-\t\t}\n+\t      incompatible_op1_vectype_p\n+\t\t= !tree_nop_conversion_p (TREE_TYPE (vectype),\n+\t\t\t\t\t  TREE_TYPE (op1));\n             }\n         }\n     }\n@@ -5819,6 +5807,14 @@ vectorizable_shift (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"transform binary/unary operation.\\n\");\n \n+  if (incompatible_op1_vectype_p && !slp_node)\n+    {\n+      op1 = fold_convert (TREE_TYPE (vectype), op1);\n+      if (dt[1] != vect_constant_def)\n+\top1 = vect_init_vector (stmt_info, op1,\n+\t\t\t\tTREE_TYPE (vectype), NULL);\n+    }\n+\n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n "}]}