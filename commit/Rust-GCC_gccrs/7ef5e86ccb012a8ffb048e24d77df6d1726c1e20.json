{"sha": "7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmNWU4NmNjYjAxMmE4ZmZiMDQ4ZTI0ZDc3ZGY2ZDE3MjZjMWUyMA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-04T17:47:52Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-04T17:47:52Z"}, "message": "tree.c (free_lang_data_in_one_sizepos): New inline function.\n\n\t* tree.c (free_lang_data_in_one_sizepos): New inline function.\n\t(free_lang_data_in_type): Call it on TYPE_{MIN|MAX}_VALUE of numerical\n\ttypes.  Call it on TYPE_SIZE and TYPE_SIZE_UNIT of all types.\n\t(free_lang_data_in_decl): Call it on DECL_SIZE and DECL_SIZE_UNIT of\n\tall decls.  Call it on DECL_FIELD_OFFSET of fields.\n\t(find_decls_types_r): Follow DECL_VALUE_EXPR.\n\t(iterative_hash_expr) <PLACEHOLDER_EXPR>: New case.\n\nFrom-SVN: r159039", "tree": {"sha": "9c07bd40cf2fbaf22796139526d1ed47478b6791", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c07bd40cf2fbaf22796139526d1ed47478b6791"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/comments", "author": null, "committer": null, "parents": [{"sha": "6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f"}], "stats": {"total": 124, "additions": 118, "deletions": 6}, "files": [{"sha": "72671c84f7acf900a65a83f13a3d7d00b930ff18", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "patch": "@@ -1,3 +1,13 @@\n+2010-05-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree.c (free_lang_data_in_one_sizepos): New inline function.\n+\t(free_lang_data_in_type): Call it on TYPE_{MIN|MAX}_VALUE of numerical\n+\ttypes.  Call it on TYPE_SIZE and TYPE_SIZE_UNIT of all types.\n+\t(free_lang_data_in_decl): Call it on DECL_SIZE and DECL_SIZE_UNIT of\n+\tall decls.  Call it on DECL_FIELD_OFFSET of fields.\n+\t(find_decls_types_r): Follow DECL_VALUE_EXPR.\n+\t(iterative_hash_expr) <PLACEHOLDER_EXPR>: New case.\n+\n 2010-05-04  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (build_access_from_expr_1): The first parameter type"}, {"sha": "1ad5bc027b32b388a9341a329463781acae8f1c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "patch": "@@ -1,3 +1,8 @@\n+2010-05-04  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/lto1.adb: New test.\n+\t* gnat.dg/lto1_pkg.ad[sb]: New helper.\n+\n 2010-05-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/43671"}, {"sha": "085094e2f811ede23b854b376dd8a866e0d213d1", "filename": "gcc/testsuite/gnat.dg/lto1.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2Fgnat.dg%2Flto1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2Fgnat.dg%2Flto1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto1.adb?ref=7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "patch": "@@ -0,0 +1,14 @@\n+-- PR ada/43106\n+-- Testcase by Bill Neven <neven@hitt.nl>\n+\n+-- { dg-do run }\n+-- { dg-options \"-O2 -flto\" }\n+\n+with Lto1_Pkg; use Lto1_Pkg;\n+\n+procedure Lto1 is\n+   Radar : Radar_T;\n+begin\n+   Radar.Sensor_Type := radcmb;\n+   Initialize (Radar);\n+end;"}, {"sha": "99955a87426a90b3870f68f1d2f1877afcd355dd", "filename": "gcc/testsuite/gnat.dg/lto1_pkg.adb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2Fgnat.dg%2Flto1_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2Fgnat.dg%2Flto1_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto1_pkg.adb?ref=7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "patch": "@@ -0,0 +1,23 @@\n+package body Lto1_Pkg is\n+\n+  procedure Initialize (Radar : in Radar_T) is\n+    Antenna1 : Antenna_Type_T;\n+    Antenna2 : Antenna_Type_T;\n+  begin\n+    case Radar.Sensor_Type is\n+      when radpr | radssr =>\n+        Antenna1 := Radar.Sensor_Type;\n+        Antenna2 := Radar.Sensor_Type;\n+      when radcmb =>\n+        Antenna1 := radpr;\n+        Antenna2 := radssr;\n+      when others =>\n+        Antenna1 := radpr;\n+        Antenna2 := radssr;\n+    end case;\n+    if Antenna1 /= radpr or Antenna2 /= radssr then\n+      raise Program_Error;\n+    end if;\n+  end Initialize;\n+\n+end Lto1_Pkg;"}, {"sha": "33c9bc9b53d6c981f3dcd1531a8e144e7c767c13", "filename": "gcc/testsuite/gnat.dg/lto1_pkg.ads", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2Fgnat.dg%2Flto1_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftestsuite%2Fgnat.dg%2Flto1_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto1_pkg.ads?ref=7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "patch": "@@ -0,0 +1,23 @@\n+package Lto1_Pkg  is\n+\n+   type Unsigned_64 is mod 2 ** 64;\n+\n+   type Associated_Report_T is (miss, radpr, radssr, radcmb);\n+\n+   -- sensor type : primary, secondary, co-rotating (combined)\n+   subtype Sensor_Type_T is Associated_Report_T; -- range radpr .. radcmb;\n+   subtype Antenna_Type_T is Sensor_Type_T range radpr .. radssr;\n+\n+   type Filtering_Level_T is (none, pr_in_clutter, ssr_plots, pr_plots);\n+   type Filtering_Levels_T is array (Filtering_Level_T) of boolean;\n+\n+   type Radar_T is record\n+      External_Sensor_ID : Unsigned_64;\n+      Dual_Radar_Index : Integer;\n+      Compatible_Filtering_Levels : Filtering_Levels_T;\n+      Sensor_Type : Sensor_Type_T;\n+   end record;\n+\n+   procedure Initialize (Radar : in Radar_T);\n+\n+end Lto1_Pkg;"}, {"sha": "b9eeb3d9693daefc0d2790493f6b41951efc9bbb", "filename": "gcc/tree.c", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ef5e86ccb012a8ffb048e24d77df6d1726c1e20/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=7ef5e86ccb012a8ffb048e24d77df6d1726c1e20", "patch": "@@ -4174,6 +4174,26 @@ build_type_attribute_variant (tree ttype, tree attribute)\n }\n \n \n+/* Reset the expression *EXPR_P, a size or position.\n+\n+   ??? We could reset all non-constant sizes or positions.  But it's cheap\n+   enough to not do so and refrain from adding workarounds to dwarf2out.c.\n+\n+   We need to reset self-referential sizes or positions because they cannot\n+   be gimplified and thus can contain a CALL_EXPR after the gimplification\n+   is finished, which will run afoul of LTO streaming.  And they need to be\n+   reset to something essentially dummy but not constant, so as to preserve\n+   the properties of the object they are attached to.  */\n+\n+static inline void\n+free_lang_data_in_one_sizepos (tree *expr_p)\n+{\n+  tree expr = *expr_p;\n+  if (CONTAINS_PLACEHOLDER_P (expr))\n+    *expr_p = build0 (PLACEHOLDER_EXPR, TREE_TYPE (expr));\n+}\n+\n+\n /* Reset all the fields in a binfo node BINFO.  We only keep\n    BINFO_VIRTUALS, which is used by gimple_fold_obj_type_ref.  */\n \n@@ -4280,8 +4300,19 @@ free_lang_data_in_type (tree type)\n       /* For non-aggregate types, clear out the language slot (which\n \t overloads TYPE_BINFO).  */\n       TYPE_LANG_SLOT_1 (type) = NULL_TREE;\n+\n+      if (INTEGRAL_TYPE_P (type)\n+\t  || SCALAR_FLOAT_TYPE_P (type)\n+\t  || FIXED_POINT_TYPE_P (type))\n+\t{\n+\t  free_lang_data_in_one_sizepos (&TYPE_MIN_VALUE (type));\n+\t  free_lang_data_in_one_sizepos (&TYPE_MAX_VALUE (type));\n+\t}\n     }\n \n+  free_lang_data_in_one_sizepos (&TYPE_SIZE (type));\n+  free_lang_data_in_one_sizepos (&TYPE_SIZE_UNIT (type));\n+\n   if (debug_info_level < DINFO_LEVEL_TERSE\n       || (TYPE_CONTEXT (type)\n \t  && TREE_CODE (TYPE_CONTEXT (type)) != FUNCTION_DECL\n@@ -4417,9 +4448,10 @@ free_lang_data_in_decl (tree decl)\n        }\n    }\n \n- /* ???  We could free non-constant DECL_SIZE, DECL_SIZE_UNIT\n-    and DECL_FIELD_OFFSET.  But it's cheap enough to not do\n-    that and refrain from adding workarounds to dwarf2out.c  */\n+  free_lang_data_in_one_sizepos (&DECL_SIZE (decl));\n+  free_lang_data_in_one_sizepos (&DECL_SIZE_UNIT (decl));\n+  if (TREE_CODE (decl) == FIELD_DECL)\n+    free_lang_data_in_one_sizepos (&DECL_FIELD_OFFSET (decl));\n \n  /* DECL_FCONTEXT is only used for debug info generation.  */\n  if (TREE_CODE (decl) == FIELD_DECL\n@@ -4633,6 +4665,10 @@ find_decls_types_r (tree *tp, int *ws, void *data)\n \t  fld_worklist_push (DECL_COMDAT_GROUP (t), fld);\n \t}\n \n+      if ((TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n+\t  && DECL_HAS_VALUE_EXPR_P (t))\n+\tfld_worklist_push (DECL_VALUE_EXPR (t), fld);\n+\n       if (TREE_CODE (t) != FIELD_DECL)\n \tfld_worklist_push (TREE_CHAIN (t), fld);\n       *ws = 0;\n@@ -6591,11 +6627,12 @@ iterative_hash_expr (const_tree t, hashval_t val)\n       return iterative_hash_expr (TREE_IMAGPART (t), val);\n     case VECTOR_CST:\n       return iterative_hash_expr (TREE_VECTOR_CST_ELTS (t), val);\n-\n     case SSA_NAME:\n-      /* we can just compare by pointer.  */\n+      /* We can just compare by pointer.  */\n       return iterative_hash_host_wide_int (SSA_NAME_VERSION (t), val);\n-\n+    case PLACEHOLDER_EXPR:\n+      /* The node itself doesn't matter.  */\n+      return val;\n     case TREE_LIST:\n       /* A list of expressions, for a CALL_EXPR or as the elements of a\n \t VECTOR_CST.  */"}]}