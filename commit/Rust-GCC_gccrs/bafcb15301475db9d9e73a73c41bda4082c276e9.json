{"sha": "bafcb15301475db9d9e73a73c41bda4082c276e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFmY2IxNTMwMTQ3NWRiOWQ5ZTczYTczYzQxYmRhNDA4MmMyNzZlOQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-07T15:40:17Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-07T15:40:17Z"}, "message": "move graphite bookkeeping from sese to sese_info\n\n2015-10-06  Aditya Kumar  <aditya.k7@samsung.com>\n                Sebastian Pop  <s.pop@samsung.com>\n\n                * graphite-isl-ast-to-gimple.c (translate_isl_ast_to_gimple): Use\n                an sese_info_p.\n                (copy_def): Same.\n                (copy_internal_parameters): Same.\n                (translate_isl_ast_to_gimple): Use an sese_l.\n                (build_iv_mapping): Same.\n                * graphite-poly.c (new_sese): Rename new_sese_info.\n                (free_sese): Rename free_sese_info.\n                * graphite-poly.h (struct scop): Use an sese_info_p.\n                (scop_set_region): Same.\n                * graphite-scop-detection.c (struct sese_l): Moved...\n                (get_entry_bb): Moved...\n                (get_exit_bb): Moved...\n                (parameter_index_in_region_1): Use an sese_info_p.\n                (parameter_index_in_region): Same.\n                (scan_tree_for_params): Same.\n                (find_params_in_bb): Same.\n                (sese_dom_walker): Use an sese_l.\n                * graphite-sese-to-poly.c (remove_invariant_phi): Same.\n                (reduction_phi_p): Same.\n                (parameter_index_in_region_1): Use an sese_info_p.\n                (propagate_expr_outside_region): Use an sese_l.\n                * graphite.c: Replace uses of SCOP_REGION.\n                * sese.c (sese_record_loop): Use an sese_info_p.\n                (build_sese_loop_nests): Same.\n                (sese_build_liveouts_use): Same.\n                (sese_build_liveouts_bb): Same.\n                (sese_build_liveouts_bb): Same.\n                (sese_bad_liveouts_use): Same.\n                (sese_reset_debug_liveouts_bb): Same.\n                (sese_build_liveouts): Same.\n                (new_sese): Renamed new_sese_info.\n                (free_sese): Renamed free_sese_info.\n                (set_rename): Use an sese_info_p.\n                (graphite_copy_stmts_from_block): Same.\n                (copy_bb_and_scalar_dependences): Same.\n                (outermost_loop_in_sese_1): Use an sese_l.\n                (outermost_loop_in_sese): Same.\n                (if_region_set_false_region): Use an sese_info_p.\n                (move_sese_in_condition): Same.\n                (scalar_evolution_in_region): Use an sese_l.\n                * sese.h (struct sese_l): ... here.\n                (SESE_ENTRY): Remove.\n                (SESE_ENTRY_BB): Remove.\n                (SESE_EXIT): Remove.\n                (SESE_EXIT_BB): Remove.\n                (sese_contains_loop): Use an sese_info_p.\n                (sese_nb_params): Same.\n                (bb_in_sese_p): Use an sese_l.\n                (stmt_in_sese_p): Same.\n                (defined_in_sese_p): Same.\n                (loop_in_sese_p): Same.\n                (sese_loop_depth): Same.\n                (struct ifsese_s): Use an sese_info_p.\n                (gbb_loop_at_index): Use an sese_l.\n                (nb_common_loops): Same.\n                (scev_analyzable_p): Same.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r228572", "tree": {"sha": "52d9f99e1a45ff8db4eea5f4b72274f513275471", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52d9f99e1a45ff8db4eea5f4b72274f513275471"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bafcb15301475db9d9e73a73c41bda4082c276e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bafcb15301475db9d9e73a73c41bda4082c276e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bafcb15301475db9d9e73a73c41bda4082c276e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bafcb15301475db9d9e73a73c41bda4082c276e9/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b850dd2f0b0c10067114eb0320b167be2ac87d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b850dd2f0b0c10067114eb0320b167be2ac87d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b850dd2f0b0c10067114eb0320b167be2ac87d6c"}], "stats": {"total": 522, "additions": 283, "deletions": 239}, "files": [{"sha": "e0dd02fb23ceb703a487cefbe8c02293a68f74ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -1,3 +1,64 @@\n+2015-10-07  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-isl-ast-to-gimple.c (translate_isl_ast_to_gimple): Use\n+\tan sese_info_p.\n+\t(copy_def): Same.\n+\t(copy_internal_parameters): Same.\n+\t(translate_isl_ast_to_gimple): Use an sese_l.\n+\t(build_iv_mapping): Same.\n+\t* graphite-poly.c (new_sese): Rename new_sese_info.\n+\t(free_sese): Rename free_sese_info.\n+\t* graphite-poly.h (struct scop): Use an sese_info_p.\n+\t(scop_set_region): Same.\n+\t* graphite-scop-detection.c (struct sese_l): Moved...\n+\t(get_entry_bb): Moved...\n+\t(get_exit_bb): Moved...\n+\t(parameter_index_in_region_1): Use an sese_info_p.\n+\t(parameter_index_in_region): Same.\n+\t(scan_tree_for_params): Same.\n+\t(find_params_in_bb): Same.\n+\t(sese_dom_walker): Use an sese_l.\n+\t* graphite-sese-to-poly.c (remove_invariant_phi): Same.\n+\t(reduction_phi_p): Same.\n+\t(parameter_index_in_region_1): Use an sese_info_p.\n+\t(propagate_expr_outside_region): Use an sese_l.\n+\t* graphite.c: Replace uses of SCOP_REGION.\n+\t* sese.c (sese_record_loop): Use an sese_info_p.\n+\t(build_sese_loop_nests): Same.\n+\t(sese_build_liveouts_use): Same.\n+\t(sese_build_liveouts_bb): Same.\n+\t(sese_build_liveouts_bb): Same.\n+\t(sese_bad_liveouts_use): Same.\n+\t(sese_reset_debug_liveouts_bb): Same.\n+\t(sese_build_liveouts): Same.\n+\t(new_sese): Renamed new_sese_info.\n+\t(free_sese): Renamed free_sese_info.\n+\t(set_rename): Use an sese_info_p.\n+\t(graphite_copy_stmts_from_block): Same.\n+\t(copy_bb_and_scalar_dependences): Same.\n+\t(outermost_loop_in_sese_1): Use an sese_l.\n+\t(outermost_loop_in_sese): Same.\n+\t(if_region_set_false_region): Use an sese_info_p.\n+\t(move_sese_in_condition): Same.\n+\t(scalar_evolution_in_region): Use an sese_l.\n+\t* sese.h (struct sese_l): ... here.\n+\t(SESE_ENTRY): Remove.\n+\t(SESE_ENTRY_BB): Remove.\n+\t(SESE_EXIT): Remove.\n+\t(SESE_EXIT_BB): Remove.\n+\t(sese_contains_loop): Use an sese_info_p.\n+\t(sese_nb_params): Same.\n+\t(bb_in_sese_p): Use an sese_l.\n+\t(stmt_in_sese_p): Same.\n+\t(defined_in_sese_p): Same.\n+\t(loop_in_sese_p): Same.\n+\t(sese_loop_depth): Same.\n+\t(struct ifsese_s): Use an sese_info_p.\n+\t(gbb_loop_at_index): Use an sese_l.\n+\t(nb_common_loops): Same.\n+\t(scev_analyzable_p): Same.\n+\n 2015-10-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (ix86_conditional_register_usage): Use"}, {"sha": "f4e7edfe1f957fc2f8b1a30003dc5a01c23a671c", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -132,7 +132,7 @@ void ivs_params_clear (ivs_params &ip)\n class translate_isl_ast_to_gimple\n {\n  public:\n-  translate_isl_ast_to_gimple (sese r)\n+  translate_isl_ast_to_gimple (sese_info_p r)\n     : region (r)\n   { }\n \n@@ -261,9 +261,9 @@ class translate_isl_ast_to_gimple\n      corresponding tree expressions.  */\n   void build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \t\t\t __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n-\t\t\t sese region);\n+\t\t\t sese_l &region);\n private:\n-  sese region;\n+  sese_info_p region;\n };\n \n /* Return the tree variable that corresponds to the given isl ast identifier\n@@ -741,7 +741,7 @@ void\n translate_isl_ast_to_gimple::\n build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \t\t  __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n-\t\t  sese region)\n+\t\t  sese_l &region)\n {\n   gcc_assert (isl_ast_expr_get_type (user_expr) == isl_ast_expr_op &&\n \t      isl_ast_expr_get_op_type (user_expr) == isl_ast_op_call);\n@@ -756,7 +756,6 @@ build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n       loop_p old_loop = gbb_loop_at_index (gbb, region, i - 1);\n       iv_map[old_loop->num] = t;\n     }\n-\n }\n \n /* Translates an isl_ast_node_user to Gimple.\n@@ -787,10 +786,10 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n   iv_map.create (nb_loops);\n   iv_map.safe_grow_cleared (nb_loops);\n \n-  build_iv_mapping (iv_map, gbb, user_expr, ip, SCOP_REGION (pbb->scop));\n+  build_iv_mapping (iv_map, gbb, user_expr, ip, pbb->scop->region->region);\n   isl_ast_expr_free (user_expr);\n   next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb),\n-\t\t\t\t\t   SCOP_REGION (pbb->scop), next_e,\n+\t\t\t\t\t   pbb->scop->region, next_e,\n \t\t\t\t\t   iv_map,\n \t\t\t\t\t   &graphite_regenerate_error);\n   iv_map.release ();\n@@ -910,7 +909,7 @@ print_isl_ast_node (FILE *file, __isl_keep isl_ast_node *node,\n static void\n add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n {\n-  sese region = SCOP_REGION (scop);\n+  sese_info_p region = scop->region;\n   unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n   gcc_assert (nb_parameters == SESE_PARAMS (region).length ());\n   unsigned i;\n@@ -1075,13 +1074,14 @@ scop_to_isl_ast (scop_p scop, ivs_params &ip)\n    DEF_STMT. GSI points to entry basic block of the TO_REGION.  */\n \n static void\n-copy_def(tree tr, gimple *def_stmt, sese region, sese to_region, gimple_stmt_iterator *gsi)\n+copy_def (tree tr, gimple *def_stmt, sese_info_p region, sese_info_p to_region,\n+\t  gimple_stmt_iterator *gsi)\n {\n-  if (!defined_in_sese_p (tr, region))\n+  if (!defined_in_sese_p (tr, region->region))\n     return;\n+\n   ssa_op_iter iter;\n   use_operand_p use_p;\n-\n   FOR_EACH_SSA_USE_OPERAND (use_p, def_stmt, iter, SSA_OP_USE)\n     {\n       tree use_tr = USE_FROM_PTR (use_p);\n@@ -1116,14 +1116,14 @@ copy_def(tree tr, gimple *def_stmt, sese region, sese to_region, gimple_stmt_ite\n }\n \n static void\n-copy_internal_parameters(sese region, sese to_region)\n+copy_internal_parameters (sese_info_p region, sese_info_p to_region)\n {\n   /* For all the parameters which definitino is in the if_region->false_region,\n      insert code on true_region (if_region->true_region->entry). */\n \n   int i;\n   tree tr;\n-  gimple_stmt_iterator gsi = gsi_start_bb(to_region->entry->dest);\n+  gimple_stmt_iterator gsi = gsi_start_bb(to_region->region.entry->dest);\n \n   FOR_EACH_VEC_ELT (region->params, i, tr)\n     {\n@@ -1144,7 +1144,7 @@ bool\n graphite_regenerate_ast_isl (scop_p scop)\n {\n   loop_p context_loop;\n-  sese region = SCOP_REGION (scop);\n+  sese_info_p region = scop->region;\n   ifsese if_region = NULL;\n   isl_ast_node *root_node;\n   ivs_params ip;\n@@ -1165,19 +1165,19 @@ graphite_regenerate_ast_isl (scop_p scop)\n \n   if_region = move_sese_in_condition (region);\n   sese_insert_phis_for_liveouts (region,\n-\t\t\t\t if_region->region->exit->src,\n-\t\t\t\t if_region->false_region->exit,\n-\t\t\t\t if_region->true_region->exit);\n+\t\t\t\t if_region->region->region.exit->src,\n+\t\t\t\t if_region->false_region->region.exit,\n+\t\t\t\t if_region->true_region->region.exit);\n   recompute_all_dominators ();\n   graphite_verify ();\n \n-  context_loop = SESE_ENTRY (region)->src->loop_father;\n+  context_loop = region->region.entry->src->loop_father;\n \n   /* Copy all the parameters which are defined in the region.  */\n   copy_internal_parameters(if_region->false_region, if_region->true_region);\n \n   translate_isl_ast_to_gimple t(region);\n-  edge e = single_succ_edge (if_region->true_region->entry->dest);\n+  edge e = single_succ_edge (if_region->true_region->region.entry->dest);\n   split_edge (e);\n   t.translate_isl_ast (context_loop, root_node, e, ip);\n "}, {"sha": "39e7aa4e581f85b0a39ded9e787240fd197884f6", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -303,7 +303,7 @@ remove_gbbs_in_scop (scop_p scop)\n scop_p\n new_scop (edge entry, edge exit)\n {\n-  sese region = new_sese (entry, exit);\n+  sese_info_p region = new_sese_info (entry, exit);\n   scop_p scop = XNEW (struct scop);\n \n   scop->param_context = NULL;\n@@ -336,7 +336,7 @@ free_scop (scop_p scop)\n   poly_bb_p pbb;\n \n   remove_gbbs_in_scop (scop);\n-  free_sese (SCOP_REGION (scop));\n+  free_sese_info (SCOP_REGION (scop));\n \n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     free_poly_bb (pbb);"}, {"sha": "977f97efb5ad42df77167f1fc9950282e2ffb630", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -407,7 +407,7 @@ struct dr_info\n struct scop\n {\n   /* A SCOP is defined as a SESE region.  */\n-  sese region;\n+  sese_info_p region;\n \n   /* Number of parameters in SCoP.  */\n   graphite_dim_t nb_params;\n@@ -468,7 +468,7 @@ extern bool apply_poly_transforms (scop_p);\n /* Set the region of SCOP to REGION.  */\n \n static inline void\n-scop_set_region (scop_p scop, sese region)\n+scop_set_region (scop_p scop, sese_info_p region)\n {\n   scop->region = region;\n }"}, {"sha": "7e5039cb3a68fe91fccb1a610c8f8a0fbf588856", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 47, "deletions": 87, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -56,42 +56,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"graphite-scop-detection.h\"\n #include \"gimple-pretty-print.h\"\n \n-/* Lightweight representation of sese for scop detection.\n-   TODO: Make all this as a constant_edge.  */\n-struct sese_l\n-{\n-  sese_l (edge e, edge x) : entry (e), exit (x) {}\n-\n-  /* This is to push objects of sese_l in a vec.  */\n-  sese_l (int i) : entry (NULL), exit (NULL) { gcc_assert (i == 0); }\n-\n-  operator bool () const { return entry && exit; }\n-\n-  const sese_l &\n-  operator= (const sese_l &s)\n-  {\n-    entry = s.entry;\n-    exit = s.exit;\n-    return *this;\n-  }\n-\n-  edge entry;\n-  edge exit;\n-};\n-\n-/* APIs for getting entry/exit of an sese.  */\n-static basic_block\n-get_entry_bb (edge e)\n-{\n-  return e->dest;\n-}\n-\n-static basic_block\n-get_exit_bb (edge e)\n-{\n-  return e->src;\n-}\n-\n class debug_printer\n {\n private:\n@@ -684,16 +648,16 @@ scop_detection::merge_sese (sese_l first, sese_l second) const\n   /* Find the common dominators for entry,\n      and common post-dominators for the exit.  */\n   basic_block dom = nearest_common_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t      get_entry_bb (first.entry),\n-\t\t\t\t\t      get_entry_bb (second.entry));\n+\t\t\t\t\t      get_entry_bb (first),\n+\t\t\t\t\t      get_entry_bb (second));\n \n   edge entry = get_nearest_dom_with_single_entry (dom);\n   if (!entry)\n     return invalid_sese;\n \n   basic_block pdom = nearest_common_dominator (CDI_POST_DOMINATORS,\n-\t\t\t\t\t       get_exit_bb (first.exit),\n-\t\t\t\t\t       get_exit_bb (second.exit));\n+\t\t\t\t\t       get_exit_bb (first),\n+\t\t\t\t\t       get_exit_bb (second));\n   pdom = nearest_common_dominator (CDI_POST_DOMINATORS, dom, pdom);\n \n   edge exit = get_nearest_pdom_with_single_exit (pdom);\n@@ -713,10 +677,10 @@ scop_detection::merge_sese (sese_l first, sese_l second) const\n   /* For now we just want to bail out when exit does not post-dominate entry.\n      TODO: We might just add a basic_block at the exit to make exit\n      post-dominate entry (the entire region).  */\n-  if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (entry),\n-\t\t       get_exit_bb (exit))\n-      || !dominated_by_p (CDI_DOMINATORS, get_exit_bb (exit),\n-\t\t\t  get_entry_bb (entry)))\n+  if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (combined),\n+\t\t       get_exit_bb (combined))\n+      || !dominated_by_p (CDI_DOMINATORS, get_exit_bb (combined),\n+\t\t\t  get_entry_bb (combined)))\n     {\n       DEBUG_PRINT (dp << \"[scop-detection-fail] cannot merge seses.\\n\");\n       return invalid_sese;\n@@ -725,7 +689,7 @@ scop_detection::merge_sese (sese_l first, sese_l second) const\n   /* FIXME: We should remove this piece of code once\n      canonicalize_loop_closed_ssa has been removed, because that function\n      adds a BB with single exit.  */\n-  if (!trivially_empty_bb_p (get_exit_bb (combined.exit)))\n+  if (!trivially_empty_bb_p (get_exit_bb (combined)))\n     {\n       /* Find the first empty succ (with single exit) of combined.exit.  */\n       basic_block imm_succ = combined.exit->dest;\n@@ -897,7 +861,7 @@ scop_detection::add_scop (sese_l s)\n       return;\n     }\n \n-  if (get_exit_bb (s.exit) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+  if (get_exit_bb (s) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n     {\n       DEBUG_PRINT (dp << \"\\n[scop-detection-fail] \"\n \t\t      << \"Discarding SCoP exiting to return\";\n@@ -923,8 +887,8 @@ scop_detection::add_scop (sese_l s)\n bool\n scop_detection::harmful_stmt_in_region (sese_l scop) const\n {\n-  basic_block exit_bb = get_exit_bb (scop.exit);\n-  basic_block entry_bb = get_entry_bb (scop.entry);\n+  basic_block exit_bb = get_exit_bb (scop);\n+  basic_block entry_bb = get_entry_bb (scop);\n \n   DEBUG_PRINT (dp << \"\\n[checking-harmful-bbs] \";\n \t       print_sese (dump_file, scop));\n@@ -958,10 +922,10 @@ scop_detection::harmful_stmt_in_region (sese_l scop) const\n bool\n scop_detection::subsumes (sese_l s1, sese_l s2)\n {\n-  if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n-\t\t      get_entry_bb (s1.entry))\n-      && dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (s2.exit),\n-\t\t\t get_entry_bb (s1.exit)))\n+  if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2),\n+\t\t      get_entry_bb (s1))\n+      && dominated_by_p (CDI_POST_DOMINATORS, s2.exit->dest,\n+\t\t\t s1.exit->dest))\n     return true;\n   return false;\n }\n@@ -989,10 +953,10 @@ scop_detection::remove_subscops (sese_l s1)\n bool\n scop_detection::intersects (sese_l s1, sese_l s2)\n {\n-  if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n-\t\t      get_entry_bb (s1.entry))\n-      && !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n-\t\t\t  get_exit_bb (s1.exit)))\n+  if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2),\n+\t\t      get_entry_bb (s1))\n+      && !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2),\n+\t\t\t  get_exit_bb (s1)))\n     return true;\n   if ((s1.exit == s2.entry) || (s2.exit == s1.entry))\n     return true;\n@@ -1137,9 +1101,7 @@ bool\n scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,\n \t\t\t\t\t     tree expr)\n {\n-  sese region = new_sese (scop.entry, scop.exit);\n-  tree scev = scalar_evolution_in_region (region, loop, expr);\n-  free_sese (region);\n+  tree scev = scalar_evolution_in_region (scop, loop, expr);\n   return graphite_can_represent_scev (scev);\n }\n \n@@ -1149,8 +1111,7 @@ scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,\n bool\n scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n {\n-  sese region = new_sese (scop.entry, scop.exit);\n-  loop_p nest = outermost_loop_in_sese (region, gimple_bb (stmt));\n+  loop_p nest = outermost_loop_in_sese (scop, gimple_bb (stmt));\n   loop_p loop = loop_containing_stmt (stmt);\n   vec<data_reference_p> drs = vNULL;\n \n@@ -1359,9 +1320,9 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n       /* Select color for SCoP.  */\n       FOR_EACH_VEC_ELT (scops, i, scop)\n \t{\n-\t  sese region = SCOP_REGION (scop);\n-\t  if (bb_in_sese_p (bb, region) || (SESE_EXIT_BB (region) == bb)\n-\t      || (SESE_ENTRY_BB (region) == bb))\n+\t  sese_l region = scop->region->region;\n+\t  if (bb_in_sese_p (bb, region) || (region.exit->dest == bb)\n+\t      || (region.entry->dest == bb))\n \t    {\n \t      switch (i % 17)\n \t\t{\n@@ -1426,11 +1387,11 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n \t      if (!bb_in_sese_p (bb, region))\n \t\tfprintf (file, \" (\");\n \n-\t      if (bb == SESE_ENTRY_BB (region) && bb == SESE_EXIT_BB (region))\n+\t      if (bb == region.entry->dest && bb == region.exit->dest)\n \t\tfprintf (file, \" %d*# \", bb->index);\n-\t      else if (bb == SESE_ENTRY_BB (region))\n+\t      else if (bb == region.entry->dest)\n \t\tfprintf (file, \" %d* \", bb->index);\n-\t      else if (bb == SESE_EXIT_BB (region))\n+\t      else if (bb == region.exit->dest)\n \t\tfprintf (file, \" %d# \", bb->index);\n \t      else\n \t\tfprintf (file, \" %d \", bb->index);\n@@ -1566,7 +1527,7 @@ scop_detection::try_generate_gimple_bb (scop_p scop, basic_block bb)\n {\n   vec<data_reference_p> drs;\n   drs.create (5);\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n   loop_p nest = outermost_loop_in_sese (region, bb);\n \n   loop_p loop = bb->loop_father;\n@@ -1609,9 +1570,8 @@ scop_detection::all_non_dominated_preds_marked_p (basic_block bb, sbitmap map)\n void\n scop_detection::build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n {\n-  sese region = SCOP_REGION (scop);\n-\n-  if (bitmap_bit_p (visited, bb->index) || !bb_in_sese_p (bb, region))\n+  if (bitmap_bit_p (visited, bb->index)\n+      || !bb_in_sese_p (bb, scop->region->region))\n     return;\n \n   poly_bb_p pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n@@ -1648,10 +1608,10 @@ void\n scop_detection::build_scop_bbs (scop_p scop)\n {\n   sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n \n   bitmap_clear (visited);\n-  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n+  build_scop_bbs_1 (scop, visited, region.entry->dest);\n   sbitmap_free (visited);\n }\n \n@@ -1665,7 +1625,7 @@ scop_detection::nb_pbbs_in_loops (scop_p scop)\n   int res = 0;\n \n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    if (loop_in_sese_p (gbb_loop (PBB_BLACK_BOX (pbb)), SCOP_REGION (scop)))\n+    if (loop_in_sese_p (gbb_loop (PBB_BLACK_BOX (pbb)), scop->region->region))\n       res++;\n \n   return res;\n@@ -1675,7 +1635,7 @@ scop_detection::nb_pbbs_in_loops (scop_p scop)\n    Otherwise returns -1.  */\n \n static inline int\n-parameter_index_in_region_1 (tree name, sese region)\n+parameter_index_in_region_1 (tree name, sese_info_p region)\n {\n   int i;\n   tree p;\n@@ -1694,7 +1654,7 @@ parameter_index_in_region_1 (tree name, sese region)\n    and returns the index of NAME.  */\n \n static int\n-parameter_index_in_region (tree name, sese region)\n+parameter_index_in_region (tree name, sese_info_p region)\n {\n   int i;\n \n@@ -1704,7 +1664,7 @@ parameter_index_in_region (tree name, sese region)\n   if (TREE_CODE (TREE_TYPE (name)) != INTEGER_TYPE)\n     return -1;\n \n-  if (!invariant_in_sese_p_rec (name, region))\n+  if (!invariant_in_sese_p_rec (name, region->region))\n     return -1;\n \n   i = parameter_index_in_region_1 (name, region);\n@@ -1724,7 +1684,7 @@ parameter_index_in_region (tree name, sese region)\n    parameters.  */\n \n static void\n-scan_tree_for_params (sese s, tree e)\n+scan_tree_for_params (sese_info_p s, tree e)\n {\n   if (e == chrec_dont_know)\n     return;\n@@ -1777,7 +1737,7 @@ scan_tree_for_params (sese s, tree e)\n    access functions, conditions and loop bounds.  */\n \n static void\n-find_params_in_bb (sese region, gimple_poly_bb_p gbb)\n+find_params_in_bb (sese_info_p region, gimple_poly_bb_p gbb)\n {\n   /* Find parameters in the access functions of data references.  */\n   int i;\n@@ -1791,9 +1751,9 @@ find_params_in_bb (sese region, gimple_poly_bb_p gbb)\n   loop_p loop = GBB_BB (gbb)->loop_father;\n   FOR_EACH_VEC_ELT (GBB_CONDITIONS (gbb), i, stmt)\n     {\n-      tree lhs = scalar_evolution_in_region (region, loop,\n+      tree lhs = scalar_evolution_in_region (region->region, loop,\n \t\t\t\t\t     gimple_cond_lhs (stmt));\n-      tree rhs = scalar_evolution_in_region (region, loop,\n+      tree rhs = scalar_evolution_in_region (region->region, loop,\n \t\t\t\t\t     gimple_cond_rhs (stmt));\n \n       scan_tree_for_params (region, lhs);\n@@ -1808,7 +1768,7 @@ static void\n find_scop_parameters (scop_p scop)\n {\n   unsigned i;\n-  sese region = SCOP_REGION (scop);\n+  sese_info_p region = scop->region;\n   struct loop *loop;\n \n   /* Find the parameters used in the loop bounds.  */\n@@ -1819,7 +1779,7 @@ find_scop_parameters (scop_p scop)\n       if (!chrec_contains_symbols (nb_iters))\n \tcontinue;\n \n-      nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n+      nb_iters = scalar_evolution_in_region (region->region, loop, nb_iters);\n       scan_tree_for_params (region, nb_iters);\n     }\n \n@@ -1836,17 +1796,17 @@ find_scop_parameters (scop_p scop)\n class sese_dom_walker : public dom_walker\n {\n public:\n-  sese_dom_walker (cdi_direction, sese);\n+  sese_dom_walker (cdi_direction, sese_l);\n \n   virtual void before_dom_children (basic_block);\n   virtual void after_dom_children (basic_block);\n \n private:\n   auto_vec<gimple *, 3> m_conditions, m_cases;\n-  sese m_region;\n+  sese_l m_region;\n };\n }\n-sese_dom_walker::sese_dom_walker (cdi_direction direction, sese region)\n+sese_dom_walker::sese_dom_walker (cdi_direction direction, sese_l region)\n   : dom_walker (direction), m_region (region)\n {\n }\n@@ -1936,7 +1896,7 @@ build_scops (vec<scop_p> *scops)\n \n       build_sese_loop_nests (scop->region);\n       /* Record all conditions in REGION.  */\n-      sese_dom_walker (CDI_DOMINATORS, scop->region).walk\n+      sese_dom_walker (CDI_DOMINATORS, scop->region->region).walk\n \t(cfun->cfg->x_entry_block_ptr);\n \n       find_scop_parameters (scop);"}, {"sha": "c9a296485b618327cc22881bfe092f4e45283e1c", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -118,7 +118,7 @@ remove_simple_copy_phi (gphi_iterator *psi)\n    loop ENTRY edge the assignment RES = INIT.  */\n \n static void\n-remove_invariant_phi (sese region, gphi_iterator *psi)\n+remove_invariant_phi (sese_l &region, gphi_iterator *psi)\n {\n   gphi *phi = psi->phi ();\n   loop_p loop = loop_containing_stmt (phi);\n@@ -161,7 +161,7 @@ simple_copy_phi_p (gphi *phi)\n    be considered.  */\n \n static bool\n-reduction_phi_p (sese region, gphi_iterator *psi)\n+reduction_phi_p (sese_l &region, gphi_iterator *psi)\n {\n   loop_p loop;\n   gphi *phi = psi->phi ();\n@@ -335,7 +335,7 @@ build_scop_scattering (scop_p scop)\n       int prefix = 0;\n \n       if (previous_gbb)\n-\tprefix = nb_common_loops (SCOP_REGION (scop), previous_gbb, gbb);\n+\tprefix = nb_common_loops (scop->region->region, previous_gbb, gbb);\n \n       previous_gbb = gbb;\n \n@@ -357,7 +357,7 @@ extract_affine_chrec (scop_p s, tree e, __isl_take isl_space *space)\n   isl_pw_aff *lhs = extract_affine (s, CHREC_LEFT (e), isl_space_copy (space));\n   isl_pw_aff *rhs = extract_affine (s, CHREC_RIGHT (e), isl_space_copy (space));\n   isl_local_space *ls = isl_local_space_from_space (space);\n-  unsigned pos = sese_loop_depth (SCOP_REGION (s), get_chrec_loop (e)) - 1;\n+  unsigned pos = sese_loop_depth (s->region->region, get_chrec_loop (e)) - 1;\n   isl_aff *loop = isl_aff_set_coefficient_si\n     (isl_aff_zero_on_domain (ls), isl_dim_in, pos, 1);\n   isl_pw_aff *l = isl_pw_aff_from_aff (loop);\n@@ -482,7 +482,7 @@ wrap (isl_pw_aff *pwaff, unsigned width)\n    Otherwise returns -1.  */\n \n static inline int\n-parameter_index_in_region_1 (tree name, sese region)\n+parameter_index_in_region_1 (tree name, sese_info_p region)\n {\n   int i;\n   tree p;\n@@ -540,7 +540,7 @@ extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n \n     case SSA_NAME:\n       gcc_assert (-1 != parameter_index_in_region_1 (e, s->region)\n-\t\t  || !invariant_in_sese_p_rec (e, s->region));\n+\t\t  || !invariant_in_sese_p_rec (e, s->region->region));\n       res = extract_affine_name (s, e, space);\n       break;\n \n@@ -571,7 +571,7 @@ extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n static void\n set_scop_parameter_dim (scop_p scop)\n {\n-  sese region = SCOP_REGION (scop);\n+  sese_info_p region = scop->region;\n   unsigned nbp = sese_nb_params (region);\n   isl_space *space = isl_space_set_alloc (scop->isl_context, nbp, 0);\n \n@@ -594,7 +594,7 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n {\n \n   tree nb_iters = number_of_latch_executions (loop);\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n   gcc_assert (loop_in_sese_p (loop, region));\n \n   isl_set *inner = isl_set_copy (outer);\n@@ -704,7 +704,7 @@ create_pw_aff_from_tree (poly_bb_p pbb, tree t)\n {\n   scop_p scop = PBB_SCOP (pbb);\n \n-  t = scalar_evolution_in_region (SCOP_REGION (scop), pbb_loop (pbb), t);\n+  t = scalar_evolution_in_region (scop->region->region, pbb_loop (pbb), t);\n   gcc_assert (!automatically_generated_chrec_p (t));\n \n   return extract_affine (scop, t, isl_set_get_space (pbb->domain));\n@@ -818,7 +818,7 @@ add_conditions_to_constraints (scop_p scop)\n static void\n add_param_constraints (scop_p scop, graphite_dim_t p)\n {\n-  tree parameter = SESE_PARAMS (SCOP_REGION (scop))[p];\n+  tree parameter = SESE_PARAMS (scop->region)[p];\n   tree type = TREE_TYPE (parameter);\n   tree lb = NULL_TREE;\n   tree ub = NULL_TREE;\n@@ -892,14 +892,14 @@ build_scop_context (scop_p scop)\n static void\n build_scop_iteration_domain (scop_p scop)\n {\n-  sese region = SCOP_REGION (scop);\n+  sese_info_p region = scop->region;\n   int nb_loops = number_of_loops (cfun);\n   isl_set **doms = XCNEWVEC (isl_set *, nb_loops);\n \n   int i;\n   struct loop *loop;\n   FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n-    if (!loop_in_sese_p (loop_outer (loop), region))\n+    if (!loop_in_sese_p (loop_outer (loop), region->region))\n       build_loop_iteration_domains (scop, loop, 0,\n \t\t\t\t    isl_set_copy (scop->param_context), doms);\n \n@@ -1166,7 +1166,7 @@ build_scop_drs (scop_p scop)\n static void\n analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple *> stmts)\n {\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n   if (!bb_in_sese_p (bb, region))\n     return;\n \n@@ -1284,7 +1284,7 @@ insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n   gsi_commit_edge_inserts ();\n   basic_block bb = gimple_bb (stmt);\n \n-  if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n+  if (!bb_in_sese_p (bb, scop->region->region))\n     return;\n \n   if (!gbb_from_bb (bb))\n@@ -1326,7 +1326,7 @@ scalar_close_phi_node_p (gimple *phi)\n    all the uses of DEF outside REGION.  */\n \n static void\n-propagate_expr_outside_region (tree def, tree expr, sese region)\n+propagate_expr_outside_region (tree def, tree expr, sese_l &region)\n {\n   gimple_seq stmts;\n   bool replaced_once = false;\n@@ -1355,7 +1355,7 @@ propagate_expr_outside_region (tree def, tree expr, sese region)\n \n   if (replaced_once)\n     {\n-      gsi_insert_seq_on_edge (SESE_ENTRY (region), stmts);\n+      gsi_insert_seq_on_edge (region.entry, stmts);\n       gsi_commit_edge_inserts ();\n     }\n }\n@@ -1366,7 +1366,7 @@ propagate_expr_outside_region (tree def, tree expr, sese region)\n static void\n rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n {\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n   gimple *phi = gsi_stmt (*psi);\n   tree res = gimple_phi_result (phi);\n   basic_block bb = gimple_bb (phi);\n@@ -1499,7 +1499,7 @@ static void\n rewrite_reductions_out_of_ssa (scop_p scop)\n {\n   basic_block bb;\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (bb_in_sese_p (bb, region))\n@@ -1564,7 +1564,7 @@ handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple *stmt)\n   tree var = create_tmp_reg (TREE_TYPE (def));\n   tree new_name = make_ssa_name (var, stmt);\n   bool needs_copy = false;\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n \n   imm_use_iterator imm_iter;\n   gimple *use_stmt;\n@@ -1588,7 +1588,7 @@ handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple *stmt)\n   if (needs_copy)\n     {\n       gimple *assign = gimple_build_assign (new_name, def);\n-      gimple_stmt_iterator psi = gsi_after_labels (SESE_EXIT (region)->dest);\n+      gimple_stmt_iterator psi = gsi_after_labels (region.exit->dest);\n \n       update_stmt (assign);\n       gsi_insert_before (&psi, assign, GSI_SAME_STMT);\n@@ -1602,7 +1602,7 @@ handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple *stmt)\n static bool\n rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n {\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n   gimple *stmt = gsi_stmt (*gsi);\n   imm_use_iterator imm_iter;\n   tree def;\n@@ -1687,11 +1687,11 @@ rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p scop)\n {\n   basic_block bb;\n   gimple_stmt_iterator psi;\n-  sese region = SCOP_REGION (scop);\n+  sese_l region = scop->region->region;\n   bool changed = false;\n \n   /* Create an extra empty BB after the scop.  */\n-  split_edge (SESE_EXIT (region));\n+  split_edge (region.exit);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (bb_in_sese_p (bb, region))"}, {"sha": "9489f8df9d60db22f47813a1d16103c10005109e", "filename": "gcc/graphite.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -144,7 +144,7 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n       gimple_stmt_iterator psi;\n       loop_p loop = bb->loop_father;\n \n-      if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n+      if (!bb_in_sese_p (bb, scop->region->region))\n \tcontinue;\n \n       n_bbs++;\n@@ -162,7 +162,7 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n \t  n_p_stmts += bb->count;\n \t}\n \n-      if (loop->header == bb && loop_in_sese_p (loop, SCOP_REGION (scop)))\n+      if (loop->header == bb && loop_in_sese_p (loop, scop->region->region))\n \t{\n \t  n_loops++;\n \t  n_p_loops += bb->count;\n@@ -171,8 +171,8 @@ print_graphite_scop_statistics (FILE* file, scop_p scop)\n \n   fprintf (file, \"\\nFunction Name: %s\\n\", current_function_name ());\n \n-  edge scop_begin = scop->region->entry;\n-  edge scop_end = scop->region->exit;\n+  edge scop_begin = scop->region->region.entry;\n+  edge scop_end = scop->region->region.exit;\n \n   fprintf (file, \"\\nSCoP (entry_edge (bb_%d, bb_%d), \",\n \t   scop_begin->src->index, scop_begin->dest->index);"}, {"sha": "ad6c89a0a69c54c5101a0d940ef05bbd355f76ac", "filename": "gcc/sese.c", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -80,7 +80,7 @@ debug_rename_map (rename_map_type *rename_map)\n /* Record LOOP as occurring in REGION.  */\n \n static void\n-sese_record_loop (sese region, loop_p loop)\n+sese_record_loop (sese_info_p region, loop_p loop)\n {\n   if (sese_contains_loop (region, loop))\n     return;\n@@ -93,20 +93,20 @@ sese_record_loop (sese region, loop_p loop)\n    operation was successful.  */\n \n void\n-build_sese_loop_nests (sese region)\n+build_sese_loop_nests (sese_info_p region)\n {\n   unsigned i;\n   basic_block bb;\n   struct loop *loop0, *loop1;\n \n   FOR_EACH_BB_FN (bb, cfun)\n-    if (bb_in_sese_p (bb, region))\n+    if (bb_in_sese_p (bb, region->region))\n       {\n \tstruct loop *loop = bb->loop_father;\n \n \t/* Only add loops if they are completely contained in the SCoP.  */\n \tif (loop->header == bb\n-\t    && bb_in_sese_p (loop->latch, region))\n+\t    && bb_in_sese_p (loop->latch, region->region))\n \t  sese_record_loop (region, loop);\n       }\n \n@@ -131,16 +131,16 @@ build_sese_loop_nests (sese region)\n    LIVEOUTS set.  */\n \n static void\n-sese_build_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n+sese_build_liveouts_use (sese_info_p region, bitmap liveouts, basic_block bb,\n \t\t\t tree use)\n {\n-  gcc_assert (!bb_in_sese_p (bb, region));\n+  gcc_assert (!bb_in_sese_p (bb, region->region));\n   if (TREE_CODE (use) != SSA_NAME)\n     return;\n \n   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n \n-  if (!def_bb || !bb_in_sese_p (def_bb, region))\n+  if (!def_bb || !bb_in_sese_p (def_bb, region->region))\n     return;\n \n   unsigned ver = SSA_NAME_VERSION (use);\n@@ -151,7 +151,7 @@ sese_build_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n    used in BB that is outside of the REGION.  */\n \n static void\n-sese_build_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n+sese_build_liveouts_bb (sese_info_p region, bitmap liveouts, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -181,10 +181,10 @@ sese_build_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n    in the LIVEOUTS set.  */\n \n static bool\n-sese_bad_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n+sese_bad_liveouts_use (sese_info_p region, bitmap liveouts, basic_block bb,\n \t\t       tree use)\n {\n-  gcc_assert (!bb_in_sese_p (bb, region));\n+  gcc_assert (!bb_in_sese_p (bb, region->region));\n \n   if (TREE_CODE (use) != SSA_NAME)\n     return false;\n@@ -198,7 +198,7 @@ sese_bad_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n \n   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));\n \n-  if (!def_bb || !bb_in_sese_p (def_bb, region))\n+  if (!def_bb || !bb_in_sese_p (def_bb, region->region))\n     return false;\n \n   return true;\n@@ -208,7 +208,7 @@ sese_bad_liveouts_use (sese region, bitmap liveouts, basic_block bb,\n    are not marked as liveouts.  */\n \n static void\n-sese_reset_debug_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n+sese_reset_debug_liveouts_bb (sese_info_p region, bitmap liveouts, basic_block bb)\n {\n   gimple_stmt_iterator bsi;\n   ssa_op_iter iter;\n@@ -236,31 +236,31 @@ sese_reset_debug_liveouts_bb (sese region, bitmap liveouts, basic_block bb)\n    and used outside the REGION.  */\n \n static void\n-sese_build_liveouts (sese region, bitmap liveouts)\n+sese_build_liveouts (sese_info_p region, bitmap liveouts)\n {\n   basic_block bb;\n \n   /* FIXME: We could start iterating form the successor of sese.  */\n   FOR_EACH_BB_FN (bb, cfun)\n-    if (!bb_in_sese_p (bb, region))\n+    if (!bb_in_sese_p (bb, region->region))\n       sese_build_liveouts_bb (region, liveouts, bb);\n \n   /* FIXME: We could start iterating form the successor of sese.  */\n   if (MAY_HAVE_DEBUG_STMTS)\n     FOR_EACH_BB_FN (bb, cfun)\n-      if (!bb_in_sese_p (bb, region))\n+      if (!bb_in_sese_p (bb, region->region))\n \tsese_reset_debug_liveouts_bb (region, liveouts, bb);\n }\n \n /* Builds a new SESE region from edges ENTRY and EXIT.  */\n \n-sese\n-new_sese (edge entry, edge exit)\n+sese_info_p\n+new_sese_info (edge entry, edge exit)\n {\n-  sese region = XNEW (struct sese_s);\n+  sese_info_p region = XNEW (struct sese_info_t);\n \n-  SESE_ENTRY (region) = entry;\n-  SESE_EXIT (region) = exit;\n+  region->region.entry = entry;\n+  region->region.exit = exit;\n   SESE_LOOPS (region) = BITMAP_ALLOC (NULL);\n   SESE_LOOP_NEST (region).create (3);\n   SESE_ADD_PARAMS (region) = true;\n@@ -273,7 +273,7 @@ new_sese (edge entry, edge exit)\n /* Deletes REGION.  */\n \n void\n-free_sese (sese region)\n+free_sese_info (sese_info_p region)\n {\n   if (SESE_LOOPS (region))\n     SESE_LOOPS (region) = BITMAP_ALLOC (NULL);\n@@ -310,7 +310,7 @@ sese_add_exit_phis_edge (basic_block exit, tree use, edge false_e, edge true_e)\n */\n \n void\n-sese_insert_phis_for_liveouts (sese region, basic_block bb,\n+sese_insert_phis_for_liveouts (sese_info_p region, basic_block bb,\n \t\t\t       edge false_e, edge true_e)\n {\n   unsigned i;\n@@ -375,7 +375,8 @@ get_rename (rename_map_type *rename_map, tree old_name)\n /* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).  */\n \n static void\n-set_rename (rename_map_type *rename_map, tree old_name, tree expr, sese region)\n+set_rename (rename_map_type *rename_map, tree old_name, tree expr,\n+\t    sese_info_p region)\n {\n   if (old_name == expr)\n     return;\n@@ -400,7 +401,7 @@ set_rename (rename_map_type *rename_map, tree old_name, tree expr, sese region)\n static bool\n rename_uses (gimple *copy, rename_map_type *rename_map,\n \t     gimple_stmt_iterator *gsi_tgt,\n-\t     sese region, loop_p loop, vec<tree> iv_map,\n+\t     sese_info_p region, loop_p loop, vec<tree> iv_map,\n \t     bool *gloog_error)\n {\n   use_operand_p use_p;\n@@ -452,7 +453,7 @@ rename_uses (gimple *copy, rename_map_type *rename_map,\n \t  continue;\n \t}\n \n-      scev = scalar_evolution_in_region (region, loop, old_name);\n+      scev = scalar_evolution_in_region (region->region, loop, old_name);\n \n       /* At this point we should know the exact scev for each\n \t scalar SSA_NAME used in the scop: all the other scalar\n@@ -506,7 +507,7 @@ rename_uses (gimple *copy, rename_map_type *rename_map,\n static void\n graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n \t\t\t\trename_map_type *rename_map,\n-\t\t\t\tvec<tree> iv_map, sese region,\n+\t\t\t\tvec<tree> iv_map, sese_info_p region,\n \t\t\t\tbool *gloog_error)\n {\n   gimple_stmt_iterator gsi, gsi_tgt;\n@@ -531,7 +532,7 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n \t  && (lhs = gimple_assign_lhs (stmt))\n \t  && TREE_CODE (lhs) == SSA_NAME\n \t  && is_gimple_reg (lhs)\n-\t  && scev_analyzable_p (lhs, region))\n+\t  && scev_analyzable_p (lhs, region->region))\n \tcontinue;\n \n       /* Do not copy parameters that have been generated in the header of the\n@@ -595,7 +596,7 @@ graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n    set when the code generation cannot continue.  */\n \n edge\n-copy_bb_and_scalar_dependences (basic_block bb, sese region,\n+copy_bb_and_scalar_dependences (basic_block bb, sese_info_p region,\n \t\t\t\tedge next_e, vec<tree> iv_map,\n \t\t\t\tbool *gloog_error)\n {\n@@ -613,7 +614,7 @@ copy_bb_and_scalar_dependences (basic_block bb, sese region,\n /* Returns the outermost loop in SCOP that contains BB.  */\n \n struct loop *\n-outermost_loop_in_sese_1 (sese region, basic_block bb)\n+outermost_loop_in_sese_1 (sese_l &region, basic_block bb)\n {\n   struct loop *nest;\n \n@@ -631,7 +632,7 @@ outermost_loop_in_sese_1 (sese region, basic_block bb)\n    REGION when the loop containing BB does not belong to REGION.  */\n \n loop_p\n-outermost_loop_in_sese (sese region, basic_block bb)\n+outermost_loop_in_sese (sese_l &region, basic_block bb)\n {\n   loop_p nest = outermost_loop_in_sese_1 (region, bb);\n \n@@ -654,13 +655,13 @@ outermost_loop_in_sese (sese region, basic_block bb)\n /* Sets the false region of an IF_REGION to REGION.  */\n \n void\n-if_region_set_false_region (ifsese if_region, sese region)\n+if_region_set_false_region (ifsese if_region, sese_info_p region)\n {\n   basic_block condition = if_region_get_condition_block (if_region);\n   edge false_edge = get_false_edge_from_guard_bb (condition);\n   basic_block dummy = false_edge->dest;\n-  edge entry_region = SESE_ENTRY (region);\n-  edge exit_region = SESE_EXIT (region);\n+  edge entry_region = region->region.entry;\n+  edge exit_region = region->region.exit;\n   basic_block before_region = entry_region->src;\n   basic_block last_in_region = exit_region->src;\n   hashval_t hash = htab_hash_pointer (exit_region);\n@@ -679,7 +680,7 @@ if_region_set_false_region (ifsese if_region, sese region)\n   exit_region->flags = EDGE_FALLTHRU;\n   recompute_all_dominators ();\n \n-  SESE_EXIT (region) = false_edge;\n+  region->region.exit = false_edge;\n \n   free (if_region->false_region);\n   if_region->false_region = region;\n@@ -707,28 +708,28 @@ create_if_region_on_edge (edge entry, tree condition)\n {\n   edge e;\n   edge_iterator ei;\n-  sese sese_region = XNEW (struct sese_s);\n-  sese true_region = XNEW (struct sese_s);\n-  sese false_region = XNEW (struct sese_s);\n+  sese_info_p sese_region = XNEW (struct sese_info_t);\n+  sese_info_p true_region = XNEW (struct sese_info_t);\n+  sese_info_p false_region = XNEW (struct sese_info_t);\n   ifsese if_region = XNEW (struct ifsese_s);\n   edge exit = create_empty_if_region_on_edge (entry, condition);\n \n   if_region->region = sese_region;\n-  if_region->region->entry = entry;\n-  if_region->region->exit = exit;\n+  if_region->region->region.entry = entry;\n+  if_region->region->region.exit = exit;\n \n   FOR_EACH_EDGE (e, ei, entry->dest->succs)\n     {\n       if (e->flags & EDGE_TRUE_VALUE)\n \t{\n-\t  true_region->entry = e;\n-\t  true_region->exit = single_succ_edge (e->dest);\n+\t  true_region->region.entry = e;\n+\t  true_region->region.exit = single_succ_edge (e->dest);\n \t  if_region->true_region = true_region;\n \t}\n       else if (e->flags & EDGE_FALSE_VALUE)\n \t{\n-\t  false_region->entry = e;\n-\t  false_region->exit = single_succ_edge (e->dest);\n+\t  false_region->region.entry = e;\n+\t  false_region->region.exit = single_succ_edge (e->dest);\n \t  if_region->false_region = false_region;\n \t}\n     }\n@@ -744,12 +745,12 @@ create_if_region_on_edge (edge entry, tree condition)\n */\n \n ifsese\n-move_sese_in_condition (sese region)\n+move_sese_in_condition (sese_info_p region)\n {\n-  basic_block pred_block = split_edge (SESE_ENTRY (region));\n+  basic_block pred_block = split_edge (region->region.entry);\n   ifsese if_region;\n \n-  SESE_ENTRY (region) = single_succ_edge (pred_block);\n+  region->region.entry = single_succ_edge (pred_block);\n   if_region = create_if_region_on_edge (single_pred_edge (pred_block),\n \t\t\t\t\tinteger_one_node);\n   if_region_set_false_region (if_region, region);\n@@ -767,8 +768,8 @@ move_sese_in_condition (sese region)\n void\n set_ifsese_condition (ifsese if_region, tree condition)\n {\n-  sese region = if_region->region;\n-  edge entry = region->entry;\n+  sese_info_p region = if_region->region;\n+  edge entry = region->region.entry;\n   basic_block bb = entry->dest;\n   gimple *last = last_stmt (bb);\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n@@ -789,7 +790,7 @@ set_ifsese_condition (ifsese if_region, tree condition)\n    variant in REGION.  */\n \n bool\n-invariant_in_sese_p_rec (tree t, sese region)\n+invariant_in_sese_p_rec (tree t, sese_l &region)\n {\n   ssa_op_iter iter;\n   use_operand_p use_p;\n@@ -828,11 +829,11 @@ invariant_in_sese_p_rec (tree t, sese region)\n    is not defined in the REGION is considered a parameter.  */\n \n tree\n-scalar_evolution_in_region (sese region, loop_p loop, tree t)\n+scalar_evolution_in_region (sese_l &region, loop_p loop, tree t)\n {\n   gimple *def;\n   struct loop *def_loop;\n-  basic_block before = block_before_sese (region);\n+  basic_block before = region.entry->src;\n \n   /* SCOP parameters.  */\n   if (TREE_CODE (t) == SSA_NAME"}, {"sha": "5cca574c68d61524d1aca55d09840a52ccbd31a5", "filename": "gcc/sese.h", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bafcb15301475db9d9e73a73c41bda4082c276e9/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=bafcb15301475db9d9e73a73c41bda4082c276e9", "patch": "@@ -26,10 +26,48 @@ typedef hash_map<tree, tree> parameter_rename_map_t;\n \n /* A Single Entry, Single Exit region is a part of the CFG delimited\n    by two edges.  */\n-typedef struct sese_s\n+struct sese_l\n {\n-  /* Single ENTRY and single EXIT from the SESE region.  */\n-  edge entry, exit;\n+  sese_l (edge e, edge x) : entry (e), exit (x) {}\n+\n+  /* This is to push objects of sese_l in a vec.  */\n+  sese_l (int i) : entry (NULL), exit (NULL) { gcc_assert (i == 0); }\n+\n+  operator bool () const { return entry && exit; }\n+\n+  const sese_l &\n+  operator= (const sese_l &s)\n+  {\n+    entry = s.entry;\n+    exit = s.exit;\n+    return *this;\n+  }\n+\n+  edge entry;\n+  edge exit;\n+};\n+\n+/* Get the entry of an sese S.  */\n+\n+static inline basic_block\n+get_entry_bb (sese_l &s)\n+{\n+  return s.entry->dest;\n+}\n+\n+/* Get the exit of an sese S.  */\n+\n+static inline basic_block\n+get_exit_bb (sese_l &s)\n+{\n+  return s.exit->src;\n+}\n+\n+/* A helper structure for bookkeeping information about a scop in graphite.  */\n+typedef struct sese_info_t\n+{\n+  /* The SESE region.  */\n+  sese_l region;\n \n   /* Parameters used within the SCOP.  */\n   vec<tree> params;\n@@ -45,39 +83,35 @@ typedef struct sese_s\n      can only add new params before generating the bb domains, otherwise they\n      become invalid.  */\n   bool add_params;\n-} *sese;\n+} *sese_info_p;\n \n-#define SESE_ENTRY(S) (S->entry)\n-#define SESE_ENTRY_BB(S) (S->entry->dest)\n-#define SESE_EXIT(S) (S->exit)\n-#define SESE_EXIT_BB(S) (S->exit->dest)\n #define SESE_PARAMS(S) (S->params)\n #define SESE_LOOPS(S) (S->loops)\n #define SESE_LOOP_NEST(S) (S->loop_nest)\n #define SESE_ADD_PARAMS(S) (S->add_params)\n \n-extern sese new_sese (edge, edge);\n-extern void free_sese (sese);\n-extern void sese_insert_phis_for_liveouts (sese, basic_block, edge, edge);\n-extern void build_sese_loop_nests (sese);\n-extern edge copy_bb_and_scalar_dependences (basic_block, sese, edge,\n+extern sese_info_p new_sese_info (edge, edge);\n+extern void free_sese_info (sese_info_p);\n+extern void sese_insert_phis_for_liveouts (sese_info_p, basic_block, edge, edge);\n+extern void build_sese_loop_nests (sese_info_p);\n+extern edge copy_bb_and_scalar_dependences (basic_block, sese_info_p, edge,\n \t\t\t\t\t    vec<tree> , bool *);\n-extern struct loop *outermost_loop_in_sese (sese, basic_block);\n-extern tree scalar_evolution_in_region (sese, loop_p, tree);\n-extern bool invariant_in_sese_p_rec (tree, sese);\n+extern struct loop *outermost_loop_in_sese (sese_l &, basic_block);\n+extern tree scalar_evolution_in_region (sese_l &, loop_p, tree);\n+extern bool invariant_in_sese_p_rec (tree, sese_l &);\n \n /* Check that SESE contains LOOP.  */\n \n static inline bool\n-sese_contains_loop (sese sese, struct loop *loop)\n+sese_contains_loop (sese_info_p sese, struct loop *loop)\n {\n   return bitmap_bit_p (SESE_LOOPS (sese), loop->num);\n }\n \n /* The number of parameters in REGION. */\n \n static inline unsigned\n-sese_nb_params (sese region)\n+sese_nb_params (sese_info_p region)\n {\n   return SESE_PARAMS (region).length ();\n }\n@@ -109,36 +143,32 @@ bb_in_region (basic_block bb, basic_block entry, basic_block exit)\n    EXIT blocks.  */\n \n static inline bool\n-bb_in_sese_p (basic_block bb, sese region)\n+bb_in_sese_p (basic_block bb, sese_l &r)\n {\n-  basic_block entry = SESE_ENTRY_BB (region);\n-  basic_block exit = SESE_EXIT_BB (region);\n-\n-  return bb_in_region (bb, entry, exit);\n+  return bb_in_region (bb, r.entry->dest, r.exit->dest);\n }\n \n /* Returns true when STMT is defined in REGION.  */\n \n static inline bool\n-stmt_in_sese_p (gimple *stmt, sese region)\n+stmt_in_sese_p (gimple *stmt, sese_l &r)\n {\n   basic_block bb = gimple_bb (stmt);\n-  return bb && bb_in_sese_p (bb, region);\n+  return bb && bb_in_sese_p (bb, r);\n }\n \n /* Returns true when NAME is defined in REGION.  */\n \n static inline bool\n-defined_in_sese_p (tree name, sese region)\n+defined_in_sese_p (tree name, sese_l &r)\n {\n-  gimple *stmt = SSA_NAME_DEF_STMT (name);\n-  return stmt_in_sese_p (stmt, region);\n+  return stmt_in_sese_p (SSA_NAME_DEF_STMT (name), r);\n }\n \n /* Returns true when LOOP is in REGION.  */\n \n static inline bool\n-loop_in_sese_p (struct loop *loop, sese region)\n+loop_in_sese_p (struct loop *loop, sese_l &region)\n {\n   return (bb_in_sese_p (loop->header, region)\n \t  && bb_in_sese_p (loop->latch, region));\n@@ -168,7 +198,7 @@ loop_in_sese_p (struct loop *loop, sese region)\n     loop_2 is completely contained -> depth 1  */\n \n static inline unsigned int\n-sese_loop_depth (sese region, loop_p loop)\n+sese_loop_depth (sese_l &region, loop_p loop)\n {\n   unsigned int depth = 0;\n \n@@ -183,7 +213,7 @@ sese_loop_depth (sese region, loop_p loop)\n \n /* Splits BB to make a single entry single exit region.  */\n \n-static inline sese\n+static inline sese_info_p\n split_region_for_bb (basic_block bb)\n {\n   edge entry, exit;\n@@ -205,43 +235,35 @@ split_region_for_bb (basic_block bb)\n       exit = split_block (bb, gsi_stmt (gsi));\n     }\n \n-  return new_sese (entry, exit);\n-}\n-\n-/* Returns the block preceding the entry of a SESE.  */\n-\n-static inline basic_block\n-block_before_sese (sese sese)\n-{\n-  return SESE_ENTRY (sese)->src;\n+  return new_sese_info (entry, exit);\n }\n \n \f\n \n /* A single entry single exit specialized for conditions.  */\n \n typedef struct ifsese_s {\n-  sese region;\n-  sese true_region;\n-  sese false_region;\n+  sese_info_p region;\n+  sese_info_p true_region;\n+  sese_info_p false_region;\n } *ifsese;\n \n-extern void if_region_set_false_region (ifsese, sese);\n-extern ifsese move_sese_in_condition (sese);\n+extern void if_region_set_false_region (ifsese, sese_info_p);\n+extern ifsese move_sese_in_condition (sese_info_p);\n extern edge get_true_edge_from_guard_bb (basic_block);\n extern edge get_false_edge_from_guard_bb (basic_block);\n extern void set_ifsese_condition (ifsese, tree);\n \n static inline edge\n if_region_entry (ifsese if_region)\n {\n-  return SESE_ENTRY (if_region->region);\n+  return if_region->region->region.entry;\n }\n \n static inline edge\n if_region_exit (ifsese if_region)\n {\n-  return SESE_EXIT (if_region->region);\n+  return if_region->region->region.exit;\n }\n \n static inline basic_block\n@@ -311,23 +333,23 @@ gbb_loop (gimple_poly_bb_p gbb)\n    If there is no corresponding gimple loop, we return NULL.  */\n \n static inline loop_p\n-gbb_loop_at_index (gimple_poly_bb_p gbb, sese region, int index)\n+gbb_loop_at_index (gimple_poly_bb_p gbb, sese_l &region, int index)\n {\n   loop_p loop = gbb_loop (gbb);\n   int depth = sese_loop_depth (region, loop);\n \n   while (--depth > index)\n     loop = loop_outer (loop);\n \n-  gcc_assert (sese_contains_loop (region, loop));\n+  gcc_assert (loop_in_sese_p (loop, region));\n \n   return loop;\n }\n \n /* The number of common loops in REGION for GBB1 and GBB2.  */\n \n static inline int\n-nb_common_loops (sese region, gimple_poly_bb_p gbb1, gimple_poly_bb_p gbb2)\n+nb_common_loops (sese_l &region, gimple_poly_bb_p gbb1, gimple_poly_bb_p gbb2)\n {\n   loop_p l1 = gbb_loop (gbb1);\n   loop_p l2 = gbb_loop (gbb2);\n@@ -340,7 +362,7 @@ nb_common_loops (sese region, gimple_poly_bb_p gbb1, gimple_poly_bb_p gbb2)\n    evolution analyzer.  */\n \n static inline bool\n-scev_analyzable_p (tree def, sese region)\n+scev_analyzable_p (tree def, sese_l &region)\n {\n   loop_p loop;\n   tree scev;"}]}