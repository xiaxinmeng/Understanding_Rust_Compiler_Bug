{"sha": "1699ec0b951194866205fab00a7190c3c2aebe27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5OWVjMGI5NTExOTQ4NjYyMDVmYWIwMGE3MTkwYzNjMmFlYmUyNw==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-06-25T22:51:27Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-06-25T22:51:27Z"}, "message": "rtl.texi (Machine Modes): Document QQ...\n\n\t* doc/rtl.texi (Machine Modes): Document QQ, HQ, SQ, DQ, TQ,\n\tUQQ, UHQ, USQ, UDQ, UTQ, HA, SA, DA, TA, UHA, USA, UDA, and UTAmodes.\n\tDocument MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM.\n\tDocument GET_MODE_IBIT, and GET_MODE_FBIT.\n\n\t* machmode.h (VECTOR_MODE_P): Test MODE_VECTOR_FRACT,\n\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n\t(SCALAR_FRACT_MODE_P, SCALAR_UFRACT_MODE_P, ALL_SCALAR_FRACT_MODE_P,\n\tSCALAR_ACCUM_MODE_P, SCALAR_UACCUM_MODE_P, ALL_SCALAR_ACCUM_MODE_P,\n\tSIGNED_SCALAR_FIXED_POINT_MODE_P, UNSIGNED_SCALAR_FIXED_POINT_MODE_P,\n\tALL_SCALAR_FIXED_POINT_MODE_P, FRACT_MODE_P, UFRACT_MODE_P,\n\tALL_FRACT_MODE_P, ACCUM_MODE_P, UACCUM_MODE_P, ALL_ACCUM_MODE_P,\n\tSIGNED_FIXED_POINT_MODE_P, UNSIGNED_FIXED_POINT_MODE_P,\n\tALL_FIXED_POINT_MODE_P): New define.\n\t(CLASS_HAS_WIDER_MODES_P): Test MODE_FRACT, MODE_UFRACT, MODE_ACCUM,\n\tMODE_UACCUM.\n\t(GET_MODE_IBIT, GET_MODE_FBIT): New define.\n\n\t* mode-classes.def (MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM,\n\tMODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM,\n\tMODE_VECTOR_UACCUM): New mode classes.\n\n\t* machmode.def: Document FRACT_MODE, UFRACT_MODE, ACCUM_MODE,\n\tUACCUM_MODE, ADJUST_IBIT, and ADJUST_FBIT.\n\tAdd QQ, HQ, SQ, DQ, TQ, UQQ, UHQ, USQ, UDQ, UTQ, HA, SA, DA, TA, UHA,\n\tUSA, UDA, and UTA.\n\n\t* genmodes.c (struct mode_data): Add ibit and fbit fields.\n\t(blank_mode): Initialize ibit and fbit.\n\t(adj_ibit, adj_fbit): New to adjust ibit and fbit.\n\t(vector_class): Handle MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM.\n\t(new_adjust): Change required_class to required_class_from and\n\trequired_class_to for testing within a range.\n\t(complete_mode): Handle MODE_FRACT, MODE_UFRACT, MODE_ACCUM,\n\tMODE_UACCUM, MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM,\n\tMODE_VECTOR_UACCUM.\n\t(FRACT_MODE, UFRACT_MODE, ACCUM_MODE, UACCUM_MODE): New define.\n\t(make_fixed_point_mode): New.\n\t(_ADD_ADJUST): Change C to C1 and C2.\n\t(ADJUST_BYTESIZE, ADJUST_ALIGNMENT, ADJUST_FLOAT_FORMAT): Change to\n\tuse a range for machine classes.\n\t(ADJUST_IBIT, ADJUST_FBIT): New.\n\t(emit_insn_modes_h): Output defines of CONST_MODE_IBIT and\n\tCONST_MODE_FBIT.\n\t(emit_mode_adjustments): Handle MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT,\n\tMODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n\tEmit adjustment for ibit and fbit.\n\t(emit_mode_ibit, emit_mode_fbit): New.\n\t(emit_insn_modes_c): Add emit_mode_ibit and emit_mode_fbit.\n\nFrom-SVN: r126007", "tree": {"sha": "6ecd0978afb0fb7ed48648a6a19859f96c4e1500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ecd0978afb0fb7ed48648a6a19859f96c4e1500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1699ec0b951194866205fab00a7190c3c2aebe27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1699ec0b951194866205fab00a7190c3c2aebe27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1699ec0b951194866205fab00a7190c3c2aebe27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1699ec0b951194866205fab00a7190c3c2aebe27/comments", "author": null, "committer": null, "parents": [{"sha": "b46ce77fe88b9640619b588283830faa1e20a7e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46ce77fe88b9640619b588283830faa1e20a7e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46ce77fe88b9640619b588283830faa1e20a7e3"}], "stats": {"total": 465, "additions": 448, "deletions": 17}, "files": [{"sha": "ed785d505e9cce3170f31f87ca896c030ae3dda0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1699ec0b951194866205fab00a7190c3c2aebe27", "patch": "@@ -1,3 +1,55 @@\n+2007-06-25  Chao-ying Fu  <fu@mips.com>\n+\n+\t* doc/rtl.texi (Machine Modes): Document QQ, HQ, SQ, DQ, TQ,\n+\tUQQ, UHQ, USQ, UDQ, UTQ, HA, SA, DA, TA, UHA, USA, UDA, and UTAmodes.\n+\tDocument MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM.\n+\tDocument GET_MODE_IBIT, and GET_MODE_FBIT.\n+\n+\t* machmode.h (VECTOR_MODE_P): Test MODE_VECTOR_FRACT,\n+\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n+\t(SCALAR_FRACT_MODE_P, SCALAR_UFRACT_MODE_P, ALL_SCALAR_FRACT_MODE_P,\n+\tSCALAR_ACCUM_MODE_P, SCALAR_UACCUM_MODE_P, ALL_SCALAR_ACCUM_MODE_P,\n+\tSIGNED_SCALAR_FIXED_POINT_MODE_P, UNSIGNED_SCALAR_FIXED_POINT_MODE_P,\n+\tALL_SCALAR_FIXED_POINT_MODE_P, FRACT_MODE_P, UFRACT_MODE_P,\n+\tALL_FRACT_MODE_P, ACCUM_MODE_P, UACCUM_MODE_P, ALL_ACCUM_MODE_P,\n+\tSIGNED_FIXED_POINT_MODE_P, UNSIGNED_FIXED_POINT_MODE_P,\n+\tALL_FIXED_POINT_MODE_P): New define.\n+\t(CLASS_HAS_WIDER_MODES_P): Test MODE_FRACT, MODE_UFRACT, MODE_ACCUM,\n+\tMODE_UACCUM.\n+\t(GET_MODE_IBIT, GET_MODE_FBIT): New define.\n+\n+\t* mode-classes.def (MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM,\n+\tMODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM,\n+\tMODE_VECTOR_UACCUM): New mode classes.\n+\n+\t* machmode.def: Document FRACT_MODE, UFRACT_MODE, ACCUM_MODE,\n+\tUACCUM_MODE, ADJUST_IBIT, and ADJUST_FBIT.\n+\tAdd QQ, HQ, SQ, DQ, TQ, UQQ, UHQ, USQ, UDQ, UTQ, HA, SA, DA, TA, UHA,\n+\tUSA, UDA, and UTA.\n+\n+\t* genmodes.c (struct mode_data): Add ibit and fbit fields.\n+\t(blank_mode): Initialize ibit and fbit.\n+\t(adj_ibit, adj_fbit): New to adjust ibit and fbit.\n+\t(vector_class): Handle MODE_FRACT, MODE_UFRACT, MODE_ACCUM, MODE_UACCUM.\n+\t(new_adjust): Change required_class to required_class_from and\n+\trequired_class_to for testing within a range.\n+\t(complete_mode): Handle MODE_FRACT, MODE_UFRACT, MODE_ACCUM,\n+\tMODE_UACCUM, MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM,\n+\tMODE_VECTOR_UACCUM.\n+\t(FRACT_MODE, UFRACT_MODE, ACCUM_MODE, UACCUM_MODE): New define.\n+\t(make_fixed_point_mode): New.\n+\t(_ADD_ADJUST): Change C to C1 and C2.\n+\t(ADJUST_BYTESIZE, ADJUST_ALIGNMENT, ADJUST_FLOAT_FORMAT): Change to\n+\tuse a range for machine classes.\n+\t(ADJUST_IBIT, ADJUST_FBIT): New.\n+\t(emit_insn_modes_h): Output defines of CONST_MODE_IBIT and\n+\tCONST_MODE_FBIT.\n+\t(emit_mode_adjustments): Handle MODE_VECTOR_FRACT, MODE_VECTOR_UFRACT,\n+\tMODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n+\tEmit adjustment for ibit and fbit.\n+\t(emit_mode_ibit, emit_mode_fbit): New.\n+\t(emit_insn_modes_c): Add emit_mode_ibit and emit_mode_fbit.\n+\n 2007-06-25  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/rs6000/spe.md (*frob_ti_tf_2): Specify an input_operand"}, {"sha": "fb38f7f3430ee58cdfa783ac6602a09edbd53d15", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=1699ec0b951194866205fab00a7190c3c2aebe27", "patch": "@@ -1135,6 +1135,96 @@ floating point number all 128 of whose bits are meaningful.\n all 128 of whose bits are meaningful.  One common use is the\n IEEE quad-precision format.\n \n+@findex QQmode\n+@item QQmode\n+``Quarter-Fractional'' mode represents a single byte treated as a signed\n+fractional number.  The default format is ``s.7''.\n+\n+@findex HQmode\n+@item HQmode\n+``Half-Fractional'' mode represents a two-byte signed fractional number.\n+The default format is ``s.15''.\n+\n+@findex SQmode\n+@item SQmode\n+``Single Fractional'' mode represents a four-byte signed fractional number.\n+The default format is ``s.31''.\n+\n+@findex DQmode\n+@item DQmode\n+``Double Fractional'' mode represents an eight-byte signed fractional number.\n+The default format is ``s.63''.\n+\n+@findex TQmode\n+@item TQmode\n+``Tetra Fractional'' mode represents a sixteen-byte signed fractional number.\n+The default format is ``s.127''.\n+\n+@findex UQQmode\n+@item UQQmode\n+``Unsigned Quarter-Fractional'' mode represents a single byte treated as an\n+unsigned fractional number.  The default format is ``.8''.\n+\n+@findex UHQmode\n+@item UHQmode\n+``Unsigned Half-Fractional'' mode represents a two-byte unsigned fractional\n+number.  The default format is ``.16''.\n+\n+@findex USQmode\n+@item USQmode\n+``Unsigned Single Fractional'' mode represents a four-byte unsigned fractional\n+number.  The default format is ``.32''.\n+\n+@findex UDQmode\n+@item UDQmode\n+``Unsigned Double Fractional'' mode represents an eight-byte unsigned\n+fractional number.  The default format is ``.64''.\n+\n+@findex UTQmode\n+@item UTQmode\n+``Unsigned Tetra Fractional'' mode represents a sixteen-byte unsigned\n+fractional number.  The default format is ``.128''.\n+\n+@findex HAmode\n+@item HAmode\n+``Half-Accumulator'' mode represents a two-byte signed accumulator.\n+The default format is ``s8.7''.\n+\n+@findex SAmode\n+@item SAmode\n+``Single Accumulator'' mode represents a four-byte signed accumulator.\n+The default format is ``s16.15''.\n+\n+@findex DAmode\n+@item DAmode\n+``Double Accumulator'' mode represents an eight-byte signed accumulator.\n+The default format is ``s32.31''.\n+\n+@findex TAmode\n+@item TAmode\n+``Tetra Accumulator'' mode represents a sixteen-byte signed accumulator.\n+The default format is ``s64.63''.\n+\n+@findex UHAmode\n+@item UHAmode\n+``Unsigned Half-Accumulator'' mode represents a two-byte unsigned accumulator.\n+The default format is ``8.8''.\n+\n+@findex USAmode\n+@item USAmode\n+``Unsigned Single Accumulator'' mode represents a four-byte unsigned\n+accumulator.  The default format is ``16.16''.\n+\n+@findex UDAmode\n+@item UDAmode\n+``Unsigned Double Accumulator'' mode represents an eight-byte unsigned\n+accumulator.  The default format is ``32.32''.\n+\n+@findex UTAmode\n+@item UTAmode\n+``Unsigned Tetra Accumulator'' mode represents a sixteen-byte unsigned\n+accumulator.  The default format is ``64.64''.\n+\n @findex CCmode\n @item CCmode\n ``Condition Code'' mode represents the value of a condition code, which\n@@ -1226,6 +1316,26 @@ Floating point modes.  By default these are @code{QFmode},\n Decimal floating point modes.  By default these are @code{SDmode},\n @code{DDmode} and @code{TDmode}.\n \n+@findex MODE_FRACT\n+@item MODE_FRACT\n+Signed fractional modes.  By default these are @code{QQmode}, @code{HQmode},\n+@code{SQmode}, @code{DQmode} and @code{TQmode}.\n+\n+@findex MODE_UFRACT\n+@item MODE_UFRACT\n+Unsigned fractional modes.  By default these are @code{UQQmode}, @code{UHQmode},\n+@code{USQmode}, @code{UDQmode} and @code{UTQmode}.\n+\n+@findex MODE_ACCUM\n+@item MODE_ACCUM\n+Signed accumulator modes.  By default these are @code{HAmode},\n+@code{SAmode}, @code{DAmode} and @code{TAmode}.\n+\n+@findex MODE_UACCUM\n+@item MODE_UACCUM\n+Unsigned accumulator modes.  By default these are @code{UHAmode},\n+@code{USAmode}, @code{UDAmode} and @code{UTAmode}.\n+\n @findex MODE_COMPLEX_INT\n @item MODE_COMPLEX_INT\n Complex integer modes.  (These are not currently implemented).\n@@ -1293,6 +1403,14 @@ Returns the size in bytes of a datum of mode @var{m}.\n @item GET_MODE_BITSIZE (@var{m})\n Returns the size in bits of a datum of mode @var{m}.\n \n+@findex GET_MODE_IBIT\n+@item GET_MODE_IBIT (@var{m})\n+Returns the number of integral bits of a datum of fixed-point mode @var{m}.\n+\n+@findex GET_MODE_FBIT\n+@item GET_MODE_FBIT (@var{m})\n+Returns the number of fractional bits of a datum of fixed-point mode @var{m}.\n+\n @findex GET_MODE_MASK\n @item GET_MODE_MASK (@var{m})\n Returns a bitmask containing 1 for all bits in a word that fit within"}, {"sha": "0a2e6f3c8778c8b3292d688924c68a7c932b31ee", "filename": "gcc/genmodes.c", "status": "modified", "additions": 127, "deletions": 11, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fgenmodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fgenmodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmodes.c?ref=1699ec0b951194866205fab00a7190c3c2aebe27", "patch": "@@ -73,6 +73,8 @@ struct mode_data\n   const char *file;\t\t/* file and line of definition, */\n   unsigned int line;\t\t/* for error reporting */\n   unsigned int counter;\t\t/* Rank ordering of modes */\n+  unsigned int ibit;\t\t/* the number of integral bits */\n+  unsigned int fbit;\t\t/* the number of fractional bits */\n };\n \n static struct mode_data *modes[MAX_MODE_CLASS];\n@@ -83,7 +85,7 @@ static const struct mode_data blank_mode = {\n   0, \"<unknown>\", MAX_MODE_CLASS,\n   -1U, -1U, -1U, -1U,\n   0, 0, 0, 0, 0, 0,\n-  \"<unknown>\", 0, 0\n+  \"<unknown>\", 0, 0, 0, 0\n };\n \n static htab_t modes_by_name;\n@@ -104,6 +106,8 @@ struct mode_adjust\n static struct mode_adjust *adj_bytesize;\n static struct mode_adjust *adj_alignment;\n static struct mode_adjust *adj_format;\n+static struct mode_adjust *adj_ibit;\n+static struct mode_adjust *adj_fbit;\n \n /* Mode class operations.  */\n static enum mode_class\n@@ -126,6 +130,10 @@ vector_class (enum mode_class cl)\n     {\n     case MODE_INT: return MODE_VECTOR_INT;\n     case MODE_FLOAT: return MODE_VECTOR_FLOAT;\n+    case MODE_FRACT: return MODE_VECTOR_FRACT;\n+    case MODE_UFRACT: return MODE_VECTOR_UFRACT;\n+    case MODE_ACCUM: return MODE_VECTOR_ACCUM;\n+    case MODE_UACCUM: return MODE_VECTOR_UACCUM;\n     default:\n       error (\"no vector class for class %s\", mode_class_names[cl]);\n       return MODE_RANDOM;\n@@ -200,7 +208,8 @@ static void ATTRIBUTE_UNUSED\n new_adjust (const char *name,\n \t    struct mode_adjust **category, const char *catname,\n \t    const char *adjustment,\n-\t    enum mode_class required_class,\n+\t    enum mode_class required_class_from,\n+\t    enum mode_class required_class_to,\n \t    const char *file, unsigned int line)\n {\n   struct mode_data *mode = find_mode (name);\n@@ -214,10 +223,12 @@ new_adjust (const char *name,\n       return;\n     }\n \n-  if (required_class != MODE_RANDOM && mode->cl != required_class)\n+  if (required_class_from != MODE_RANDOM\n+      && (mode->cl < required_class_from || mode->cl > required_class_to))\n     {\n-      error (\"%s:%d: mode \\\"%s\\\" is not class %s\",\n-\t     file, line, name, mode_class_names[required_class] + 5);\n+      error (\"%s:%d: mode \\\"%s\\\" is not among class {%s, %s}\",\n+\t     file, line, name, mode_class_names[required_class_from] + 5,\n+\t     mode_class_names[required_class_to] + 5);\n       return;\n     }\n   \n@@ -327,11 +338,16 @@ complete_mode (struct mode_data *m)\n     case MODE_INT:\n     case MODE_FLOAT:\n     case MODE_DECIMAL_FLOAT:\n+    case MODE_FRACT:\n+    case MODE_UFRACT:\n+    case MODE_ACCUM:\n+    case MODE_UACCUM:\n       /* A scalar mode must have a byte size, may have a bit size,\n \t and must not have components.   A float mode must have a\n          format.  */\n       validate_mode (m, OPTIONAL, SET, UNSET, UNSET,\n-\t\t     m->cl != MODE_INT ? SET : UNSET);\n+\t\t     (m->cl == MODE_FLOAT || m->cl == MODE_DECIMAL_FLOAT)\n+\t\t     ? SET : UNSET);\n \n       m->ncomponents = 1;\n       m->component = 0;\n@@ -361,6 +377,10 @@ complete_mode (struct mode_data *m)\n \n     case MODE_VECTOR_INT:\n     case MODE_VECTOR_FLOAT:\n+    case MODE_VECTOR_FRACT:\n+    case MODE_VECTOR_UFRACT:\n+    case MODE_VECTOR_ACCUM:\n+    case MODE_VECTOR_UACCUM:\n       /* Vector modes should have a component and a number of components.  */\n       validate_mode (m, UNSET, UNSET, SET, SET, UNSET);\n       if (m->component->precision != (unsigned int)-1)\n@@ -533,6 +553,35 @@ make_int_mode (const char *name,\n   m->precision = precision;\n }\n \n+#define FRACT_MODE(N, Y, F) \\\n+\tmake_fixed_point_mode (MODE_FRACT, #N, Y, 0, F, __FILE__, __LINE__)\n+\n+#define UFRACT_MODE(N, Y, F) \\\n+\tmake_fixed_point_mode (MODE_UFRACT, #N, Y, 0, F, __FILE__, __LINE__)\n+\n+#define ACCUM_MODE(N, Y, I, F) \\\n+\tmake_fixed_point_mode (MODE_ACCUM, #N, Y, I, F, __FILE__, __LINE__)\n+\n+#define UACCUM_MODE(N, Y, I, F) \\\n+\tmake_fixed_point_mode (MODE_UACCUM, #N, Y, I, F, __FILE__, __LINE__)\n+\n+/* Create a fixed-point mode by setting CL, NAME, BYTESIZE, IBIT, FBIT,\n+   FILE, and LINE.  */\n+\n+static void\n+make_fixed_point_mode (enum mode_class cl,\n+\t\t       const char *name,\n+\t\t       unsigned int bytesize,\n+\t\t       unsigned int ibit,\n+\t\t       unsigned int fbit,\n+\t\t       const char *file, unsigned int line)\n+{\n+  struct mode_data *m = new_mode (cl, name, file, line);\n+  m->bytesize = bytesize;\n+  m->ibit = ibit;\n+  m->fbit = fbit;\n+}\n+\n #define FLOAT_MODE(N, Y, F)             FRACTIONAL_FLOAT_MODE (N, -1U, Y, F)\n #define FRACTIONAL_FLOAT_MODE(N, B, Y, F) \\\n   make_float_mode (#N, B, Y, #F, __FILE__, __LINE__)\n@@ -658,12 +707,14 @@ make_vector_mode (enum mode_class bclass,\n }\n \n /* Adjustability.  */\n-#define _ADD_ADJUST(A, M, X, C) \\\n-  new_adjust (#M, &adj_##A, #A, #X, MODE_##C, __FILE__, __LINE__)\n+#define _ADD_ADJUST(A, M, X, C1, C2) \\\n+  new_adjust (#M, &adj_##A, #A, #X, MODE_##C1, MODE_##C2, __FILE__, __LINE__)\n \n-#define ADJUST_BYTESIZE(M, X)  _ADD_ADJUST(bytesize, M, X, RANDOM)\n-#define ADJUST_ALIGNMENT(M, X) _ADD_ADJUST(alignment, M, X, RANDOM)\n-#define ADJUST_FLOAT_FORMAT(M, X)    _ADD_ADJUST(format, M, X, FLOAT)\n+#define ADJUST_BYTESIZE(M, X)  _ADD_ADJUST(bytesize, M, X, RANDOM, RANDOM)\n+#define ADJUST_ALIGNMENT(M, X) _ADD_ADJUST(alignment, M, X, RANDOM, RANDOM)\n+#define ADJUST_FLOAT_FORMAT(M, X)    _ADD_ADJUST(format, M, X, FLOAT, FLOAT)\n+#define ADJUST_IBIT(M, X)  _ADD_ADJUST(ibit, M, X, ACCUM, UACCUM)\n+#define ADJUST_FBIT(M, X)  _ADD_ADJUST(fbit, M, X, FRACT, UACCUM)\n \n static void\n create_modes (void)\n@@ -861,6 +912,8 @@ enum machine_mode\\n{\");\n #if 0 /* disabled for backward compatibility, temporary */\n   printf (\"#define CONST_REAL_FORMAT_FOR_MODE%s\\n\", adj_format ? \"\" :\" const\");\n #endif\n+  printf (\"#define CONST_MODE_IBIT%s\\n\", adj_ibit ? \"\" : \" const\");\n+  printf (\"#define CONST_MODE_FBIT%s\\n\", adj_fbit ? \"\" : \" const\");\n   puts (\"\\\n \\n\\\n #endif /* insn-modes.h */\");\n@@ -1173,6 +1226,10 @@ emit_mode_adjustments (void)\n \n \t    case MODE_VECTOR_INT:\n \t    case MODE_VECTOR_FLOAT:\n+\t    case MODE_VECTOR_FRACT:\n+\t    case MODE_VECTOR_UFRACT:\n+\t    case MODE_VECTOR_ACCUM:\n+\t    case MODE_VECTOR_UACCUM:\n \t      printf (\"  mode_size[%smode] = %d*s;\\n\",\n \t\t      m->name, m->ncomponents);\n \t      printf (\"  mode_base_align[%smode] = (%d*s) & (~(%d*s)+1);\\n\",\n@@ -1207,6 +1264,10 @@ emit_mode_adjustments (void)\n \n \t    case MODE_VECTOR_INT:\n \t    case MODE_VECTOR_FLOAT:\n+\t    case MODE_VECTOR_FRACT:\n+\t    case MODE_VECTOR_UFRACT:\n+\t    case MODE_VECTOR_ACCUM:\n+\t    case MODE_VECTOR_UACCUM:\n \t      printf (\"  mode_base_align[%smode] = %d*s;\\n\",\n \t\t      m->name, m->ncomponents);\n \t      break;\n@@ -1219,6 +1280,22 @@ emit_mode_adjustments (void)\n \t    }\n \t}\n     }\n+\n+  /* Ibit adjustments don't have to propagate.  */\n+  for (a = adj_ibit; a; a = a->next)\n+    {\n+      printf (\"\\n  /* %s:%d */\\n  s = %s;\\n\",\n+\t      a->file, a->line, a->adjustment);\n+      printf (\"  mode_ibit[%smode] = s;\\n\", a->mode->name);\n+    }\n+\n+  /* Fbit adjustments don't have to propagate.  */\n+  for (a = adj_fbit; a; a = a->next)\n+    {\n+      printf (\"\\n  /* %s:%d */\\n  s = %s;\\n\",\n+\t      a->file, a->line, a->adjustment);\n+      printf (\"  mode_fbit[%smode] = s;\\n\", a->mode->name);\n+    }\n       \n   /* Real mode formats don't have to propagate anywhere.  */\n   for (a = adj_format; a; a = a->next)\n@@ -1228,6 +1305,43 @@ emit_mode_adjustments (void)\n   puts (\"}\");\n }\n \n+/* Emit ibit for all modes.  */\n+\n+static void\n+emit_mode_ibit (void)\n+{\n+  int c;\n+  struct mode_data *m;\n+\n+  print_maybe_const_decl (\"%sunsigned char\",\n+\t\t\t  \"mode_ibit\", \"NUM_MACHINE_MODES\",\n+\t\t\t  ibit);\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%u\", m->ibit, m->name);\n+\n+  print_closer ();\n+}\n+\n+/* Emit fbit for all modes.  */\n+\n+static void\n+emit_mode_fbit (void)\n+{\n+  int c;\n+  struct mode_data *m;\n+\n+  print_maybe_const_decl (\"%sunsigned char\",\n+\t\t\t  \"mode_fbit\", \"NUM_MACHINE_MODES\",\n+\t\t\t  fbit);\n+\n+  for_all_modes (c, m)\n+    tagged_printf (\"%u\", m->fbit, m->name);\n+\n+  print_closer ();\n+}\n+\n+\n static void\n emit_insn_modes_c (void)\n {\n@@ -1244,6 +1358,8 @@ emit_insn_modes_c (void)\n   emit_class_narrowest_mode ();\n   emit_real_format_for_mode ();\n   emit_mode_adjustments ();\n+  emit_mode_ibit ();\n+  emit_mode_fbit ();\n }\n \n static void"}, {"sha": "51d6980579e33536d35a1595aa764f670272d2ee", "filename": "gcc/machmode.def", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fmachmode.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fmachmode.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.def?ref=1699ec0b951194866205fab00a7190c3c2aebe27", "patch": "@@ -96,6 +96,24 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \tstorage, but with only PRECISION significant bits, using\n \tfloating point format FORMAT.\n \n+     FRACT_MODE (MODE, BYTESIZE, FBIT);\n+\tdeclares MODE to be of class FRACT and BYTESIZE bytes wide\n+\twith FBIT fractional bits.  There may be padding bits.\n+\n+     UFRACT_MODE (MODE, BYTESIZE, FBIT);\n+\tdeclares MODE to be of class UFRACT and BYTESIZE bytes wide\n+\twith FBIT fractional bits.  There may be padding bits.\n+\n+     ACCUM_MODE (MODE, BYTESIZE, IBIT, FBIT);\n+\tdeclares MODE to be of class ACCUM and BYTESIZE bytes wide\n+\twith IBIT integral bits and FBIT fractional bits.\n+\tThere may be padding bits.\n+\n+     UACCUM_MODE (MODE, BYTESIZE, FBIT);\n+\tdeclares MODE to be of class UACCUM and BYTESIZE bytes wide\n+\twith IBIT integral bits and FBIT fractional bits.\n+\tThere may be padding bits.\n+\n      RESET_FLOAT_FORMAT (MODE, FORMAT);\n \tchanges the format of MODE, which must be class FLOAT,\n \tto FORMAT.  Use in an ARCH-modes.def to reset the format\n@@ -133,10 +151,12 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n      ADJUST_BYTESIZE (MODE, EXPR);\n      ADJUST_ALIGNMENT (MODE, EXPR);\n      ADJUST_FLOAT_FORMAT (MODE, EXPR);\n-        Arrange for the byte size, alignment, or floating point format\n-\tof MODE to be adjustable at run time.  EXPR will be executed\n+     ADJUST_IBIT (MODE, EXPR);\n+     ADJUST_FBIT (MODE, EXPR);\n+\tArrange for the byte size, alignment, floating point format, ibit,\n+\tor fbit of MODE to be adjustable at run time.  EXPR will be executed\n \tonce after processing all command line options, and should\n-\tevaluate to the desired byte size, alignment, or format.\n+\tevaluate to the desired byte size, alignment, format, ibit or fbit.\n \n \tUnlike a FORMAT argument, if you are adjusting a float format\n \tyou must put an & in front of the name of each format structure.\n@@ -181,6 +201,29 @@ FLOAT_MODE (DF, 8, ieee_double_format);\n    FIXME define this only for targets that need it.  */\n CC_MODE (CC);\n \n+/* Fixed-point modes.  */\n+FRACT_MODE (QQ, 1, 7); /* s.7 */\n+FRACT_MODE (HQ, 2, 15); /* s.15 */\n+FRACT_MODE (SQ, 4, 31); /* s.31 */\n+FRACT_MODE (DQ, 8, 63); /* s.63 */\n+FRACT_MODE (TQ, 16, 127); /* s.127 */\n+\n+UFRACT_MODE (UQQ, 1, 8); /* .8 */\n+UFRACT_MODE (UHQ, 2, 16); /* .16 */\n+UFRACT_MODE (USQ, 4, 32); /* .32 */\n+UFRACT_MODE (UDQ, 8, 64); /* .64 */\n+UFRACT_MODE (UTQ, 16, 128); /* .128 */\n+\n+ACCUM_MODE (HA, 2, 8, 7); /* s8.7 */\n+ACCUM_MODE (SA, 4, 16, 15); /* s16.15 */\n+ACCUM_MODE (DA, 8, 32, 31); /* s32.31 */\n+ACCUM_MODE (TA, 16, 64, 63); /* s64.63 */\n+\n+UACCUM_MODE (UHA, 2, 8, 8); /* 8.8 */\n+UACCUM_MODE (USA, 4, 16, 16); /* 16.16 */\n+UACCUM_MODE (UDA, 8, 32, 32); /* 32.32 */\n+UACCUM_MODE (UTA, 16, 64, 64); /* 64.64 */\n+\n /* Allow the target to specify additional modes of various kinds.  */\n #if HAVE_EXTRA_MODES\n # include EXTRA_MODES_FILE"}, {"sha": "68a2071ccff7554747eaa5f45b0ec1cfa11e11bd", "filename": "gcc/machmode.h", "status": "modified", "additions": 96, "deletions": 2, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=1699ec0b951194866205fab00a7190c3c2aebe27", "patch": "@@ -66,7 +66,11 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n /* Nonzero if MODE is a vector mode.  */\n #define VECTOR_MODE_P(MODE)\t\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\\\n-   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FRACT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_UFRACT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_ACCUM\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_UACCUM)\n \n /* Nonzero if MODE is a scalar integral mode.  */\n #define SCALAR_INT_MODE_P(MODE)\t\t\t\\\n@@ -82,12 +86,94 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n #define DECIMAL_FLOAT_MODE_P(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_DECIMAL_FLOAT)\n \n+/* Nonzero if MODE is a scalar fract mode.  */\n+#define SCALAR_FRACT_MODE_P(MODE)\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_FRACT)\n+\n+/* Nonzero if MODE is a scalar ufract mode.  */\n+#define SCALAR_UFRACT_MODE_P(MODE)\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_UFRACT)\n+\n+/* Nonzero if MODE is a scalar fract or ufract mode.  */\n+#define ALL_SCALAR_FRACT_MODE_P(MODE)\t\\\n+  (SCALAR_FRACT_MODE_P (MODE) || SCALAR_UFRACT_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar accum mode.  */\n+#define SCALAR_ACCUM_MODE_P(MODE)\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_ACCUM)\n+\n+/* Nonzero if MODE is a scalar uaccum mode.  */\n+#define SCALAR_UACCUM_MODE_P(MODE)\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_UACCUM)\n+\n+/* Nonzero if MODE is a scalar accum or uaccum mode.  */\n+#define ALL_SCALAR_ACCUM_MODE_P(MODE)\t\\\n+  (SCALAR_ACCUM_MODE_P (MODE) || SCALAR_UACCUM_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar fract or accum mode.  */\n+#define SIGNED_SCALAR_FIXED_POINT_MODE_P(MODE)\t\\\n+  (SCALAR_FRACT_MODE_P (MODE) || SCALAR_ACCUM_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar ufract or uaccum mode.  */\n+#define UNSIGNED_SCALAR_FIXED_POINT_MODE_P(MODE)\t\\\n+  (SCALAR_UFRACT_MODE_P (MODE) || SCALAR_UACCUM_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar fract, ufract, accum or uaccum mode.  */\n+#define ALL_SCALAR_FIXED_POINT_MODE_P(MODE)\t\\\n+  (SIGNED_SCALAR_FIXED_POINT_MODE_P (MODE)\t\\\n+   || UNSIGNED_SCALAR_FIXED_POINT_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar/vector fract mode.  */\n+#define FRACT_MODE_P(MODE)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_FRACT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_FRACT)\n+\n+/* Nonzero if MODE is a scalar/vector ufract mode.  */\n+#define UFRACT_MODE_P(MODE)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_UFRACT\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_UFRACT)\n+\n+/* Nonzero if MODE is a scalar/vector fract or ufract mode.  */\n+#define ALL_FRACT_MODE_P(MODE)\t\t\\\n+  (FRACT_MODE_P (MODE) || UFRACT_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar/vector accum mode.  */\n+#define ACCUM_MODE_P(MODE)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_ACCUM\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_ACCUM)\n+\n+/* Nonzero if MODE is a scalar/vector uaccum mode.  */\n+#define UACCUM_MODE_P(MODE)\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_UACCUM\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_VECTOR_UACCUM)\n+\n+/* Nonzero if MODE is a scalar/vector accum or uaccum mode.  */\n+#define ALL_ACCUM_MODE_P(MODE)\t\t\\\n+  (ACCUM_MODE_P (MODE) || UACCUM_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar/vector fract or accum mode.  */\n+#define SIGNED_FIXED_POINT_MODE_P(MODE)\t\t\\\n+  (FRACT_MODE_P (MODE) || ACCUM_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar/vector ufract or uaccum mode.  */\n+#define UNSIGNED_FIXED_POINT_MODE_P(MODE)\t\\\n+  (UFRACT_MODE_P (MODE) || UACCUM_MODE_P (MODE))\n+\n+/* Nonzero if MODE is a scalar/vector fract, ufract, accum or uaccum mode.  */\n+#define ALL_FIXED_POINT_MODE_P(MODE)\t\t\\\n+  (SIGNED_FIXED_POINT_MODE_P (MODE)\t\t\\\n+   || UNSIGNED_FIXED_POINT_MODE_P (MODE))\n+\n /* Nonzero if CLASS modes can be widened.  */\n #define CLASS_HAS_WIDER_MODES_P(CLASS)         \\\n   (CLASS == MODE_INT                           \\\n    || CLASS == MODE_FLOAT                      \\\n    || CLASS == MODE_DECIMAL_FLOAT              \\\n-   || CLASS == MODE_COMPLEX_FLOAT)\n+   || CLASS == MODE_COMPLEX_FLOAT              \\\n+   || CLASS == MODE_FRACT                      \\\n+   || CLASS == MODE_UFRACT                     \\\n+   || CLASS == MODE_ACCUM                      \\\n+   || CLASS == MODE_UACCUM)\n \n /* Get the size in bytes and bits of an object of mode MODE.  */\n \n@@ -99,6 +185,14 @@ extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];\n extern const unsigned short mode_precision[NUM_MACHINE_MODES];\n #define GET_MODE_PRECISION(MODE)  mode_precision[MODE]\n \n+/* Get the number of integral bits of an object of mode MODE.  */\n+extern CONST_MODE_IBIT unsigned char mode_ibit[NUM_MACHINE_MODES];\n+#define GET_MODE_IBIT(MODE) mode_ibit[MODE]\n+\n+/* Get the number of fractional bits of an object of mode MODE.  */\n+extern CONST_MODE_FBIT unsigned char mode_fbit[NUM_MACHINE_MODES];\n+#define GET_MODE_FBIT(MODE) mode_fbit[MODE]\n+\n /* Get a bitmask containing 1 for all bits in a word\n    that fit within mode MODE.  */\n "}, {"sha": "2f56efac1a1ca9998f4f13c86a39c95cb01e6468", "filename": "gcc/mode-classes.def", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fmode-classes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1699ec0b951194866205fab00a7190c3c2aebe27/gcc%2Fmode-classes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-classes.def?ref=1699ec0b951194866205fab00a7190c3c2aebe27", "patch": "@@ -23,10 +23,18 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n   DEF_MODE_CLASS (MODE_RANDOM),\t\t/* other */\t\t\t   \\\n   DEF_MODE_CLASS (MODE_CC),\t\t/* condition code in a register */ \\\n   DEF_MODE_CLASS (MODE_INT),\t\t/* integer */\t\t\t   \\\n-  DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */\t   \\\n+  DEF_MODE_CLASS (MODE_PARTIAL_INT),\t/* integer with padding bits */    \\\n+  DEF_MODE_CLASS (MODE_FRACT),\t\t/* signed fractional number */\t   \\\n+  DEF_MODE_CLASS (MODE_UFRACT),\t\t/* unsigned fractional number */   \\\n+  DEF_MODE_CLASS (MODE_ACCUM),\t\t/* signed accumulator */\t   \\\n+  DEF_MODE_CLASS (MODE_UACCUM),\t\t/* unsigned accumulator */\t   \\\n   DEF_MODE_CLASS (MODE_FLOAT),\t\t/* floating point */\t\t   \\\n   DEF_MODE_CLASS (MODE_DECIMAL_FLOAT),\t/* decimal floating point */\t   \\\n   DEF_MODE_CLASS (MODE_COMPLEX_INT), \t/* complex numbers */\t\t   \\\n   DEF_MODE_CLASS (MODE_COMPLEX_FLOAT),\t\t\t\t\t   \\\n   DEF_MODE_CLASS (MODE_VECTOR_INT),\t/* SIMD vectors */\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_FRACT),\t/* SIMD vectors */\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_UFRACT),\t/* SIMD vectors */\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_ACCUM),\t/* SIMD vectors */\t\t   \\\n+  DEF_MODE_CLASS (MODE_VECTOR_UACCUM),\t/* SIMD vectors */\t\t   \\\n   DEF_MODE_CLASS (MODE_VECTOR_FLOAT)"}]}