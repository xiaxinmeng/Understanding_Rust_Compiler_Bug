{"sha": "f10ea6402795bce5c74a2a086cbbe27b267f8880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEwZWE2NDAyNzk1YmNlNWM3NGEyYTA4NmNiYmUyN2IyNjdmODg4MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-06-07T15:33:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-06-07T15:33:34Z"}, "message": "cgraph.c (cgraph_edge_cannot_lead_to_return): Also check if caller is noreturn.\n\n\t* cgraph.c (cgraph_edge_cannot_lead_to_return): Also check\n\tif caller is noreturn.\n\t* ipa-reference.c (analyze_function): Use ipa_ref_cannot_lead_to_return\n\t* ipa-ref.h (ipa_ref_cannot_lead_to_return): New function.\n\t* ipa-ref.c (ipa_ref_cannot_lead_to_return): New function.\n\t* ipa-pure-const.c (check_decl): Add IPA parameter.\n\t(state_from_flags): New function.\n\t(better_state, worse_state): New functions.\n\t(check_call): When in IPA mode, do not care about callees.\n\t(check_load, check_store): Update.\n\t(check_ipa_load, check_ipa_store): New.\n\t(check_stmt): When in IPA mode, use IPA checkers.\n\t(analyze_function): Use state_from_flags.\n\t(propagate): Check indirect edges and references.\n\nFrom-SVN: r160380", "tree": {"sha": "27f7a4b02c0fe509806c2b0ca767116cf3ebf7fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27f7a4b02c0fe509806c2b0ca767116cf3ebf7fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f10ea6402795bce5c74a2a086cbbe27b267f8880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f10ea6402795bce5c74a2a086cbbe27b267f8880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f10ea6402795bce5c74a2a086cbbe27b267f8880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f10ea6402795bce5c74a2a086cbbe27b267f8880/comments", "author": null, "committer": null, "parents": [{"sha": "dba16b83d4b296964daeb709abdb15bfecfc6ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dba16b83d4b296964daeb709abdb15bfecfc6ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dba16b83d4b296964daeb709abdb15bfecfc6ac5"}], "stats": {"total": 466, "additions": 343, "deletions": 123}, "files": [{"sha": "d1b819ac4a1b9ffc876d5c0702fbdcea474b5ea3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -1,3 +1,20 @@\n+2010-06-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_edge_cannot_lead_to_return): Also check\n+\tif caller is noreturn.\n+\t* ipa-reference.c (analyze_function): Use ipa_ref_cannot_lead_to_return\n+\t* ipa-ref.h (ipa_ref_cannot_lead_to_return): New function.\n+\t* ipa-ref.c (ipa_ref_cannot_lead_to_return): New function.\n+\t* ipa-pure-const.c (check_decl): Add IPA parameter.\n+\t(state_from_flags): New function.\n+\t(better_state, worse_state): New functions.\n+\t(check_call): When in IPA mode, do not care about callees.\n+\t(check_load, check_store): Update.\n+\t(check_ipa_load, check_ipa_store): New.\n+\t(check_stmt): When in IPA mode, use IPA checkers.\n+\t(analyze_function): Use state_from_flags.\n+\t(propagate): Check indirect edges and references.\n+\n 2010-06-07  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR rtl-optimization/44404"}, {"sha": "105cdab14a63c505e31e209abe4b5fa8c973e2e5", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -2606,6 +2606,8 @@ cgraph_node_cannot_return (struct cgraph_node *node)\n bool\n cgraph_edge_cannot_lead_to_return (struct cgraph_edge *e)\n {\n+  if (cgraph_node_cannot_return (e->caller))\n+    return true;\n   if (e->indirect_unknown_callee)\n     {\n       int flags = e->indirect_info->ecf_flags;"}, {"sha": "9055a66e94aecccd0819cd6db9e241864171148b", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 224, "deletions": 121, "changes": 345, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -227,7 +227,7 @@ set_function_state (struct cgraph_node *node, funct_state s)\n \n static inline void\n check_decl (funct_state local,\n-\t    tree t, bool checking_write)\n+\t    tree t, bool checking_write, bool ipa)\n {\n   /* Do not want to do anything with volatile except mark any\n      function that uses one to be not const or pure.  */\n@@ -253,6 +253,11 @@ check_decl (funct_state local,\n       return;\n     }\n \n+  /* In IPA mode we are not interested in checking actual loads and stores;\n+     they will be processed at propagation time using ipa_ref.  */\n+  if (ipa)\n+    return;\n+\n   /* Since we have dealt with the locals and params cases above, if we\n      are CHECKING_WRITE, this cannot be a pure or constant\n      function.  */\n@@ -333,6 +338,78 @@ check_op (funct_state local, tree t, bool checking_write)\n     }\n }\n \n+/* compute state based on ECF FLAGS and store to STATE and LOOPING.  */\n+\n+static void\n+state_from_flags (enum pure_const_state_e *state, bool *looping,\n+\t          int flags, bool cannot_lead_to_return)\n+{\n+  *looping = false;\n+  if (flags & ECF_LOOPING_CONST_OR_PURE)\n+    {\n+      *looping = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" looping\");\n+    }\n+  if (flags & ECF_CONST)\n+    {\n+      *state = IPA_CONST;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" const\\n\");\n+    }\n+  else if (flags & ECF_PURE)\n+    {\n+      *state = IPA_PURE;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" pure\\n\");\n+    }\n+  else if (cannot_lead_to_return)\n+    {\n+      *state = IPA_PURE;\n+      *looping = true;\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" ignoring side effects->pure looping\\n\");\n+    }\n+  else\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \" neihter\\n\");\n+      *state = IPA_NEITHER;\n+      *looping = true;\n+    }\n+}\n+\n+/* Merge STATE and STATE2 and LOOPING and LOOPING2 and store\n+   into STATE and LOOPING better of the two variants.\n+   Be sure to merge looping correctly.  IPA_NEITHER functions\n+   have looping 0 even if they don't have to return.  */\n+\n+static inline void\n+better_state (enum pure_const_state_e *state, bool *looping,\n+\t      enum pure_const_state_e state2, bool looping2)\n+{\n+  if (state2 < *state)\n+    {\n+      if (*state == IPA_NEITHER)\n+\t*looping = looping2;\n+      else\n+\t*looping = MIN (*looping, looping2);\n+    }\n+  else if (state2 != IPA_NEITHER)\n+    *looping = MIN (*looping, looping2);\n+}\n+\n+/* Merge STATE and STATE2 and LOOPING and LOOPING2 and store\n+   into STATE and LOOPING worse of the two variants.  */\n+\n+static inline void\n+worse_state (enum pure_const_state_e *state, bool *looping,\n+\t     enum pure_const_state_e state2, bool looping2)\n+{\n+  *state = MAX (*state, state2);\n+  *looping = MAX (*looping, looping2);\n+}\n+\n /* Check the parameters of a function call to CALL_EXPR to see if\n    there are any references in the parameters that are not allowed for\n    pure or const functions.  Also check to see if this is either an\n@@ -422,8 +499,10 @@ check_call (funct_state local, gimple call, bool ipa)\n      Look to see if there are any bits available for the callee (such as by\n      declaration or because it is builtin) and process solely on the basis of\n      those bits. */\n-  else if (!ipa || !callee_t)\n+  else if (!ipa)\n     {\n+      enum pure_const_state_e call_state;\n+      bool call_looping;\n       if (possibly_throws && cfun->can_throw_non_call_exceptions)\n         {\n \t  if (dump_file)\n@@ -442,68 +521,61 @@ check_call (funct_state local, gimple call, bool ipa)\n \t    }\n           local->can_throw = true;\n \t}\n-      if (flags & ECF_CONST)\n-\t{\n-          if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"    calls looping pure.\\n\");\n-              local->looping = true;\n-\t    }\n-\t }\n-      else if (flags & ECF_PURE)\n-\t{\n-          if (callee_t && DECL_LOOPING_CONST_OR_PURE_P (callee_t))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"    calls looping const.\\n\");\n-              local->looping = true;\n-\t    }\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    pure function call in not const\\n\");\n-\t  if (local->pure_const_state == IPA_CONST)\n-\t    local->pure_const_state = IPA_PURE;\n-\t}\n-      else if ((flags & (ECF_NORETURN | ECF_NOTHROW))\n-\t       == (ECF_NORETURN | ECF_NOTHROW)\n-\t       || (!flag_exceptions && (flags & ECF_NORETURN)))\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    noreturn nothrow call is looping pure\\n\");\n-\t  if (local->pure_const_state == IPA_CONST)\n-\t    local->pure_const_state = IPA_PURE;\n-          local->looping = true;\n-\t}\n-      else\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"    uknown function call is not const/pure\\n\");\n-\t  local->pure_const_state = IPA_NEITHER;\n-          local->looping = true;\n-\t}\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"    checking flags for call:\");\n+      state_from_flags (&call_state, &call_looping, flags,\n+\t\t\t((flags & (ECF_NORETURN | ECF_NOTHROW))\n+\t\t\t == (ECF_NORETURN | ECF_NOTHROW))\n+\t\t\t|| (!flag_exceptions && (flags & ECF_NORETURN)));\n+      worse_state (&local->pure_const_state, &local->looping,\n+\t\t   call_state, call_looping);\n     }\n   /* Direct functions calls are handled by IPA propagation.  */\n }\n \n-/* Wrapper around check_decl for loads.  */\n+/* Wrapper around check_decl for loads in local more.  */\n \n static bool\n check_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n {\n   if (DECL_P (op))\n-    check_decl ((funct_state)data, op, false);\n+    check_decl ((funct_state)data, op, false, false);\n   else\n     check_op ((funct_state)data, op, false);\n   return false;\n }\n \n-/* Wrapper around check_decl for stores.  */\n+/* Wrapper around check_decl for stores in local more.  */\n \n static bool\n check_store (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n {\n   if (DECL_P (op))\n-    check_decl ((funct_state)data, op, true);\n+    check_decl ((funct_state)data, op, true, false);\n+  else\n+    check_op ((funct_state)data, op, true);\n+  return false;\n+}\n+\n+/* Wrapper around check_decl for loads in ipa mode.  */\n+\n+static bool\n+check_ipa_load (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  if (DECL_P (op))\n+    check_decl ((funct_state)data, op, false, true);\n+  else\n+    check_op ((funct_state)data, op, false);\n+  return false;\n+}\n+\n+/* Wrapper around check_decl for stores in ipa mode.  */\n+\n+static bool\n+check_ipa_store (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  if (DECL_P (op))\n+    check_decl ((funct_state)data, op, true, true);\n   else\n     check_op ((funct_state)data, op, true);\n   return false;\n@@ -527,7 +599,9 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n     }\n \n   /* Look for loads and stores.  */\n-  walk_stmt_load_store_ops (stmt, local, check_load, check_store);\n+  walk_stmt_load_store_ops (stmt, local,\n+\t\t\t    ipa ? check_ipa_load : check_load,\n+\t\t\t    ipa ? check_ipa_store :  check_store);\n \n   if (gimple_code (stmt) != GIMPLE_CALL\n       && stmt_could_throw_p (stmt))\n@@ -669,21 +743,15 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \t}\n     }\n \n-  if (TREE_READONLY (decl))\n-    {\n-      l->pure_const_state = IPA_CONST;\n-      l->state_previously_known = IPA_CONST;\n-      if (!DECL_LOOPING_CONST_OR_PURE_P (decl))\n-        l->looping = false, l->looping_previously_known = false;\n-    }\n-  if (DECL_PURE_P (decl))\n-    {\n-      if (l->pure_const_state != IPA_CONST)\n-        l->pure_const_state = IPA_PURE;\n-      l->state_previously_known = IPA_PURE;\n-      if (!DECL_LOOPING_CONST_OR_PURE_P (decl))\n-        l->looping = false, l->looping_previously_known = false;\n-    }\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"    checking previously known:\");\n+  state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n+\t\t    flags_from_decl_or_type (fn->decl),\n+\t\t    cgraph_node_cannot_return (fn));\n+\n+  better_state (&l->pure_const_state, &l->looping,\n+\t\tl->state_previously_known,\n+\t\tl->looping_previously_known);\n   if (TREE_NOTHROW (decl))\n     l->can_throw = false;\n \n@@ -953,6 +1021,7 @@ self_recursive_p (struct cgraph_node *node)\n   return false;\n }\n \n+\n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by generate_summary.\n    Note that there is no function_transform pass since this only\n@@ -995,43 +1064,52 @@ propagate (void)\n \n       /* Find the worst state for any node in the cycle.  */\n       w = node;\n-      while (w)\n+      while (w && pure_const_state != IPA_NEITHER)\n \t{\n \t  struct cgraph_edge *e;\n+\t  struct cgraph_edge *ie;\n+\t  int i;\n+\t  struct ipa_ref *ref;\n+\n \t  funct_state w_l = get_function_state (w);\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Visiting %s/%i state:%s looping %i\\n\",\n \t\t     cgraph_node_name (w),\n \t\t     w->uid,\n \t\t     pure_const_names[w_l->pure_const_state],\n \t\t     w_l->looping);\n-\t  if (pure_const_state < w_l->pure_const_state)\n-\t    pure_const_state = w_l->pure_const_state;\n \n-\t  if (w_l->looping)\n-\t    looping = true;\n+\t  /* First merge in function body properties.  */\n+\t  worse_state (&pure_const_state, &looping,\n+\t\t       w_l->pure_const_state, w_l->looping);\n+\t  if (pure_const_state == IPA_NEITHER)\n+\t    break;\n+\n+\t  /* For overwritable nodes we can not assume anything.  */\n \t  if (cgraph_function_body_availability (w) == AVAIL_OVERWRITABLE)\n \t    {\n-\t      looping |= w_l->looping_previously_known;\n-\t      if (pure_const_state < w_l->state_previously_known)\n-\t        pure_const_state = w_l->state_previously_known;\n+\t      worse_state (&pure_const_state, &looping,\n+\t\t\t   w_l->state_previously_known,\n+\t\t\t   w_l->looping_previously_known);\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n \t\t  fprintf (dump_file,\n \t\t\t   \"    Overwritable. state %s looping %i\\n\",\n \t\t\t   pure_const_names[w_l->state_previously_known],\n \t\t\t   w_l->looping_previously_known);\n \t\t}\n+\t      break;\n \t    }\n \n-\t  if (pure_const_state == IPA_NEITHER)\n-\t    break;\n-\n \t  count++;\n \n+\t  /* We consider recursive cycles as possibly infinite.\n+\t     This might be relaxed since infinite recursion leads to stack\n+\t     overflow.  */\n \t  if (count > 1)\n \t    looping = true;\n \n+\t  /* Now walk the edges and merge in callee properties.  */\n \t  for (e = w->callees; e; e = e->next_callee)\n \t    {\n \t      struct cgraph_node *y = e->callee;\n@@ -1059,10 +1137,9 @@ propagate (void)\n \t\t      && cgraph_edge_cannot_lead_to_return (e))\n \t\t    {\n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\t\n-\t\t\t  fprintf (dump_file,\n-\t\t\t\t   \"        Ignoring side effects -> pure, looping\\n\");\n-\t\t\t}\n+\t\t\tfprintf (dump_file,\n+\t\t\t\t \"        Ignoring side effects\"\n+\t\t\t\t \" -> pure, looping\\n\");\n \t\t      edge_state = IPA_PURE;\n \t\t      edge_looping = true;\n \t\t    }\n@@ -1073,55 +1150,78 @@ propagate (void)\n \t\t    }\n \t\t}\n \t      else\n-\t        {\n-\t\t  int flags = flags_from_decl_or_type (y->decl);\n+\t\tstate_from_flags (&edge_state, &edge_looping,\n+\t\t\t          flags_from_decl_or_type (y->decl),\n+\t\t\t          cgraph_edge_cannot_lead_to_return (e));\n+\n+\t      /* Merge the results with what we already know.  */\n+\t      better_state (&edge_state, &edge_looping,\n+\t\t\t    w_l->state_previously_known,\n+\t\t\t    w_l->looping_previously_known);\n+\t      worse_state (&pure_const_state, &looping,\n+\t\t\t   edge_state, edge_looping);\n+\t      if (pure_const_state == IPA_NEITHER)\n+\t        break;\n+\t    }\n+\t  if (pure_const_state == IPA_NEITHER)\n+\t    break;\n \n-\t\t  if (flags & ECF_LOOPING_CONST_OR_PURE)\n-\t\t    {\n-\t\t      edge_looping = true;\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tfprintf (dump_file, \" unavailable looping\");\n-\t\t    }\n-\t\t  if (flags & ECF_CONST)\n-\t\t    {\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t        fprintf (dump_file, \" const\\n\");\n-\t\t    }\n-\t\t  else if (flags & ECF_PURE)\n-\t\t    {\n-\t\t      edge_state = IPA_PURE;\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t        fprintf (dump_file, \" pure\\n\");\n-\t\t    }\n-\t\t  else if (cgraph_edge_cannot_lead_to_return (e))\n-\t\t    {\n-\t\t      edge_state = IPA_PURE;\n-\t\t      edge_looping = true;\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t        fprintf (dump_file, \" ignoring side effects->pure looping\\n\");\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t        fprintf (dump_file, \" neihter\\n\");\n-\t\t      edge_state = IPA_NEITHER;\n-\t\t      edge_looping = true;\n-\t\t    }\n-\t\t}\n+\t  /* Now process the indirect call.  */\n+          for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n+\t    {\n+\t      enum pure_const_state_e edge_state = IPA_CONST;\n+\t      bool edge_looping = false;\n \n-\t      /* Merge the results with what we already know.\n-\t\t When we found function to be NEITHER, but we know\n-\t\t it is looping pure const, be sure to set the looping flag. */\n-\t      pure_const_state = MAX (pure_const_state, MIN (edge_state,\n-\t\t\t\t      w_l->state_previously_known));\n-\t      if (edge_state > w_l->state_previously_known)\n-\t\tlooping = MAX (looping, w_l->looping_previously_known);\n-\t      else\n-\t\tlooping = MAX (looping, MIN (edge_looping,\n-\t\t\t\t\t     w_l->looping_previously_known));\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"    Indirect call\");\n+\t      state_from_flags (&edge_state, &edge_looping,\n+\t\t\t        ie->indirect_info->ecf_flags,\n+\t\t\t        cgraph_edge_cannot_lead_to_return (ie));\n+\t      /* Merge the results with what we already know.  */\n+\t      better_state (&edge_state, &edge_looping,\n+\t\t\t    w_l->state_previously_known,\n+\t\t\t    w_l->looping_previously_known);\n+\t      worse_state (&pure_const_state, &looping,\n+\t\t\t   edge_state, edge_looping);\n \t      if (pure_const_state == IPA_NEITHER)\n \t        break;\n \t    }\n+\t  if (pure_const_state == IPA_NEITHER)\n+\t    break;\n+\n+\t  /* And finally all loads and stores.  */\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t    {\n+\t      enum pure_const_state_e ref_state = IPA_CONST;\n+\t      bool ref_looping = false;\n+\t      switch (ref->use)\n+\t\t{\n+\t\tcase IPA_REF_LOAD:\n+\t\t  /* readonly reads are safe.  */\n+\t\t  if (TREE_READONLY (ipa_ref_varpool_node (ref)->decl))\n+\t\t    break;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"    nonreadonly global var read\\n\");\n+\t\t  ref_state = IPA_PURE;\n+\t\t  break;\n+\t\tcase IPA_REF_STORE:\n+\t\t  if (ipa_ref_cannot_lead_to_return (ref))\n+\t\t    break;\n+\t\t  ref_state = IPA_NEITHER;\n+\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t    fprintf (dump_file, \"    global var write\\n\");\n+\t\t  break;\n+\t\tcase IPA_REF_ADDR:\n+\t\t  break;\n+\t\t}\n+\t      better_state (&ref_state, &ref_looping,\n+\t\t\t    w_l->state_previously_known,\n+\t\t\t    w_l->looping_previously_known);\n+\t      worse_state (&pure_const_state, &looping,\n+\t\t\t   ref_state, ref_looping);\n+\t      if (pure_const_state == IPA_NEITHER)\n+\t\tbreak;\n+\t    }\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}\n@@ -1220,7 +1320,7 @@ propagate (void)\n       w = node;\n       while (w)\n \t{\n-\t  struct cgraph_edge *e;\n+\t  struct cgraph_edge *e, *ie;\n \t  funct_state w_l = get_function_state (w);\n \n \t  if (w_l->can_throw\n@@ -1247,6 +1347,9 @@ propagate (void)\n \t      else if (e->can_throw_external && !TREE_NOTHROW (y->decl))\n \t        can_throw = true;\n \t    }\n+          for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n+\t    if (ie->can_throw_external)\n+\t      can_throw = true;\n \t  w_info = (struct ipa_dfs_info *) w->aux;\n \t  w = w_info->next_cycle;\n \t}"}, {"sha": "27c32dcd3d6f8bb36b5695cc65b066e49c4335e0", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -233,3 +233,11 @@ ipa_clone_refering (struct cgraph_node *dest_node,\n \t\t\t  dest_node, dest_varpool_node,\n \t\t\t  ref->use, ref->stmt);\n }\n+\n+/* Return true when execution of REF can load to return from\n+   function. */\n+bool\n+ipa_ref_cannot_lead_to_return (struct ipa_ref *ref)\n+{\n+  return cgraph_node_cannot_return (ipa_ref_refering_node (ref));\n+}"}, {"sha": "2be73536f8ebf2c520c1c8e502cdb5f74b6e06a0", "filename": "gcc/ipa-ref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.h?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -88,4 +88,5 @@ void ipa_dump_references (FILE *, struct ipa_ref_list *);\n void ipa_dump_refering (FILE *, struct ipa_ref_list *);\n void ipa_clone_references (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n void ipa_clone_refering (struct cgraph_node *, struct varpool_node *, struct ipa_ref_list *);\n+bool ipa_ref_cannot_lead_to_return (struct ipa_ref *);\n "}, {"sha": "64ccb4ead27d7359cad4028c711e66c5b7afbfbf", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -439,6 +439,8 @@ analyze_function (struct cgraph_node *fn)\n           bitmap_set_bit (local->statics_read, DECL_UID (var));\n \t  break;\n \tcase IPA_REF_STORE:\n+\t  if (ipa_ref_cannot_lead_to_return (ref))\n+\t    break;\n           bitmap_set_bit (local->statics_written, DECL_UID (var));\n \t  break;\n \tcase IPA_REF_ADDR:"}, {"sha": "ada0b2c290c97d971680770c7f7177f37a60088f", "filename": "gcc/ipa.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -512,8 +512,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \n    FIXME: This can not be done in between gimplify and omp_expand since\n    readonly flag plays role on what is shared and what is not.  Currently we do\n-   this transformation as part of ipa-reference pass, but it would make sense\n-   to do it before early optimizations.  */\n+   this transformation as part of whole program visibility and re-do at\n+   ipa-reference pass (to take into account clonning), but it would\n+   make sense to do it before early optimizations.  */\n \n void\n ipa_discover_readonly_nonaddressable_vars (void)\n@@ -825,6 +826,8 @@ whole_program_function_and_variable_visibility (void)\n \t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n       fprintf (dump_file, \"\\n\\n\");\n     }\n+  if (optimize)\n+    ipa_discover_readonly_nonaddressable_vars ();\n   return 0;\n }\n "}, {"sha": "757934e2368286f4e63422c2bec4390f48df3a4e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -1,3 +1,7 @@\n+2010-06-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/pure-const-1.c: New testcase.\n+\n 2010-06-07  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR rtl-optimization/44404"}, {"sha": "51837ea9bad69c142c1f182077e2c0f3ce83ce18", "filename": "gcc/testsuite/gcc.dg/ipa/pure-const-1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpure-const-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f10ea6402795bce5c74a2a086cbbe27b267f8880/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpure-const-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpure-const-1.c?ref=f10ea6402795bce5c74a2a086cbbe27b267f8880", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-local-pure-const1 -fdump-ipa-pure-const -fdump-tree-optimized -fno-early-inlining\" } */\n+void abort (void);\n+int error_code;\n+static int val;\n+__attribute__ ((noinline, noclone))\n+static int\n+i_am_pure1 (int a)\n+{\n+  if (a > 50)\n+    abort ();\n+  return a;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+static int\n+i_am_const2 (int a)\n+{\n+  return a+val;\n+}\n+\n+__attribute__ ((noinline, noclone))\n+int\n+call_me(int a)\n+{\n+  return a;\n+}\n+\n+inline int\n+call_callback(int (*fn)(int), int a)\n+{\n+  return fn(a);\n+}\n+\n+__attribute__ ((noinline, noclone))\n+i_am_const3(int a)\n+{\n+  return call_callback (call_me, a);\n+}\n+\n+__attribute__ ((noinline))\n+explode_badly()\n+{\n+  error_code = 0xbad;\n+  abort ();\n+}\n+\n+__attribute__ ((noinline, noclone))\n+i_am_pure4(int a)\n+{\n+  if (a > 50)\n+    explode_badly ();\n+  return a;\n+}\n+\n+test()\n+{\n+  int s;\n+  s = i_am_pure1(5);\n+  s += i_am_pure1(5);\n+  s += i_am_const2(5);\n+  s += i_am_const2(5);\n+  s += i_am_const3(5);\n+  s += i_am_const3(5);\n+  s += i_am_pure4(5);\n+  s += i_am_pure4(5);\n+  return s;\n+}\n+/* { dg-final { scan-tree-dump-times \"i_am_pure1 .5\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"i_am_const2 .5\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"i_am_const3 .5\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump-times \"i_am_pure4 .5\" 1 \"optimized\"} } */\n+/* { dg-final { scan-tree-dump \"found to be looping pure: i_am_pure1\" \"local-pure-const1\"} } */\n+/* { dg-final { scan-tree-dump \"found to be looping pure: i_am_pure4\" \"local-pure-const1\"} } */\n+/* { dg-final { scan-ipa-dump \"found to be const: i_am_const2\" \"pure-const\"} } */\n+/* { dg-final { scan-ipa-dump \"found to be const: i_am_const3\" \"pure-const\"} } */\n+/* { dg-final { cleanup-tree-dump \"local-pure-const1\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final { cleanup-ipa-dump \"pure-const\" } } */\n+"}]}