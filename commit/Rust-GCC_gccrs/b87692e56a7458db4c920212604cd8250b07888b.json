{"sha": "b87692e56a7458db4c920212604cd8250b07888b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg3NjkyZTU2YTc0NThkYjRjOTIwMjEyNjA0Y2Q4MjUwYjA3ODg4Yg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-19T18:01:45Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-19T18:01:45Z"}, "message": "91th Cygnus<->FSF quick merge\n\nFrom-SVN: r14098", "tree": {"sha": "5456ebde32295223ef5435b92a3ed2b969b93ddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5456ebde32295223ef5435b92a3ed2b969b93ddf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b87692e56a7458db4c920212604cd8250b07888b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87692e56a7458db4c920212604cd8250b07888b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b87692e56a7458db4c920212604cd8250b07888b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b87692e56a7458db4c920212604cd8250b07888b/comments", "author": null, "committer": null, "parents": [{"sha": "eaf95893f87d262bbb8ef64272aa3ca56f3f0e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf95893f87d262bbb8ef64272aa3ca56f3f0e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf95893f87d262bbb8ef64272aa3ca56f3f0e33"}], "stats": {"total": 147, "additions": 109, "deletions": 38}, "files": [{"sha": "79e655cebdea17c54b6cba3d556d6138837fe94c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b87692e56a7458db4c920212604cd8250b07888b", "patch": "@@ -1,3 +1,36 @@\n+Sat May 17 10:48:31 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (instantiate_class_template): Oops.\n+\n+Fri May 16 14:23:57 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.def: Add TAG_DEFN.\n+\t* pt.c (tsubst_enum): New fn.\n+\t(instantiate_class_template): Use it.\n+\t(tsubst_expr): Support TAG_DEFN.\n+\t(tsubst): Support local enums.\n+\t(tsubst_copy): Likewise.\n+\t* decl.c (finish_enum): Likewise.\n+\t(start_enum): If this is a local enum, switch to permanent_obstack.\n+\n+Wed May 14 19:08:28 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (store_parm_decls): Set last_parm_cleanup_insn here.\n+\t(finish_function): Put the base init code for constructors just\n+\tafter the parm cleanup insns.\n+\t(struct cp_function): Add last_parm_cleanup_insn.\n+\t(push_cp_function_context): Likewise.\n+\t(pop_cp_function_context): Likewise.\n+\t\n+Tue May 13 15:51:20 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* pt.c (tsubst_copy): Handle BIT_NOT_EXPR.\n+\n+Wed May  7 11:17:59 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* method.c (emit_thunk) [ASM_OUTPUT_MI_THUNK]: Build up the RTL\n+\tfor THUNK_FNDECL before we switch to temporary allocation.\n+\n Mon May  5 14:46:53 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* call.c (build_new_op): Handle null arg2 for ?:."}, {"sha": "39ccfae59d8eb648ce9069b96b54bc7e3f858f52", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=b87692e56a7458db4c920212604cd8250b07888b", "patch": "@@ -152,3 +152,5 @@ DEFTREECODE (REF_BIND, \"ref_bind\", \"e\", 1)\n DEFTREECODE (USER_CONV, \"user_conv\", \"e\", 4)\n DEFTREECODE (AMBIG_CONV, \"ambig_conv\", \"e\", 1)\n DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", \"e\", 1)\n+\n+DEFTREECODE (TAG_DEFN, \"tag_defn\", \"e\", 0)"}, {"sha": "0ed77d49cfa0985c4b9a972513afc1a017cd5b38", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b87692e56a7458db4c920212604cd8250b07888b", "patch": "@@ -268,6 +268,12 @@ tree dtor_label;\n \n static rtx last_dtor_insn;\n \n+/* In a constructor, the last insn emitted after the start of the\n+   function and the parms, but before the start of the exception\n+   specification.  */\n+\n+static rtx last_parm_cleanup_insn;\n+\n /* In a constructor, the point at which we are ready to return\n    the pointer to the initialized object.  */\n \n@@ -10579,6 +10585,9 @@ start_enum (name)\n   register tree enumtype = NULL_TREE;\n   struct binding_level *b = inner_binding_level;\n \n+  if (processing_template_decl && current_function_decl)\n+    end_temporary_allocation ();\n+\n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n      forward reference.  */\n@@ -10657,7 +10666,14 @@ finish_enum (enumtype, values)\n   TYPE_VALUES (enumtype) = nreverse (values);\n \n   if (processing_template_decl)\n-    return enumtype;\n+    {\n+      if (current_function_decl)\n+\t{\n+\t  add_tree (build_min (TAG_DEFN, enumtype));\n+\t  resume_temporary_allocation ();\n+\t}\n+      return enumtype;\n+    }\n \n   {\n     int unsignedp = tree_int_cst_sgn (minnode) >= 0;\n@@ -11417,6 +11433,8 @@ store_parm_decls ()\n       expand_start_bindings (0);\n     }\n \n+  last_parm_cleanup_insn = get_last_insn ();\n+\n   if (! processing_template_decl && flag_exceptions)\n     {\n       /* Do the starting of the exception specifications, if we have any.  */\n@@ -11819,19 +11837,9 @@ finish_function (lineno, call_poplevel, nested)\n \t  insns = get_insns ();\n \t  end_sequence ();\n \n-\t  /* This is where the body of the constructor begins.\n-\t     If there were no insns in this function body, then the\n-\t     last_parm_insn is also the last insn.\n-\t     \n-\t     If optimization is enabled, last_parm_insn may move, so\n-\t     we don't hold on to it (across emit_base_init).  */\n-\t  last_parm_insn = get_first_nonparm_insn ();\n-\t  if (last_parm_insn == NULL_RTX)\n-\t    last_parm_insn = get_last_insn ();\n-\t  else\n-\t    last_parm_insn = previous_insn (last_parm_insn);\n+\t  /* This is where the body of the constructor begins.  */\n \n-\t  emit_insns_after (insns, last_parm_insn);\n+\t  emit_insns_after (insns, last_parm_cleanup_insn);\n \n \t  end_protect_partials ();\n \n@@ -12480,6 +12488,7 @@ struct cp_function\n   tree ctor_label;\n   tree dtor_label;\n   rtx last_dtor_insn;\n+  rtx last_parm_cleanup_insn;\n   tree base_init_list;\n   tree member_init_list;\n   tree base_init_expr;\n@@ -12518,6 +12527,7 @@ push_cp_function_context (context)\n   p->ctor_label = ctor_label;\n   p->dtor_label = dtor_label;\n   p->last_dtor_insn = last_dtor_insn;\n+  p->last_parm_cleanup_insn = last_parm_cleanup_insn;\n   p->assigns_this = current_function_assigns_this;\n   p->just_assigned_this = current_function_just_assigned_this;\n   p->parms_stored = current_function_parms_stored;\n@@ -12558,6 +12568,7 @@ pop_cp_function_context (context)\n   ctor_label = p->ctor_label;\n   dtor_label = p->dtor_label;\n   last_dtor_insn = p->last_dtor_insn;\n+  last_parm_cleanup_insn = p->last_parm_cleanup_insn;\n   current_function_assigns_this = p->assigns_this;\n   current_function_just_assigned_this = p->just_assigned_this;\n   current_function_parms_stored = p->parms_stored;"}, {"sha": "640b1bfa90374ab0bcd630c23712a8fc1f60c479", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b87692e56a7458db4c920212604cd8250b07888b", "patch": "@@ -1674,10 +1674,9 @@ make_thunk (function, delta)\n      int delta;\n {\n   char buffer[250];\n-  tree thunk_fndecl, thunk_id;\n+  tree thunk_id;\n   tree thunk;\n   char *func_name;\n-  static int thunk_number = 0;\n   tree func_decl;\n   if (TREE_CODE (function) != ADDR_EXPR)\n     abort ();\n@@ -1739,10 +1738,12 @@ emit_thunk (thunk_fndecl)\n #ifdef ASM_OUTPUT_MI_THUNK\n     char *fnname;\n     current_function_decl = thunk_fndecl;\n+    /* Make sure we build up its RTL before we go onto the\n+       temporary obstack.  */\n+    make_function_rtl (thunk_fndecl);\n     temporary_allocation ();\n     DECL_RESULT (thunk_fndecl)\n       = build_decl (RESULT_DECL, 0, integer_type_node);\n-    make_function_rtl (thunk_fndecl);\n     fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n     assemble_start_function (thunk_fndecl, fnname);\n     ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);"}, {"sha": "823116ca18c9c8bb9395586be0b509dca407564d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b87692e56a7458db4c920212604cd8250b07888b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b87692e56a7458db4c920212604cd8250b07888b", "patch": "@@ -72,6 +72,7 @@ static int comp_template_args PROTO((tree, tree));\n tree most_specialized_class PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n tree make_temp_vec PROTO((int));\n+static tree tsubst_enum\t\t\t\tPROTO((tree, tree *, int));\n \n /* We've got a template header coming up; push to a new level for storing\n    the parms.  */\n@@ -1198,36 +1199,22 @@ instantiate_class_template (type)\n     {\n       tree name = TREE_PURPOSE (t);\n       tree tag = TREE_VALUE (t);\n-      tree newtag;\n \n       /* These will add themselves to CLASSTYPE_TAGS for the new type.  */\n-      if (TREE_CODE (tag) == ENUMERAL_TYPE)\n-\tnewtag = start_enum (name);\n-      else\n-\tnewtag = tsubst (tag, &TREE_VEC_ELT (args, 0),\n-\t\t\t TREE_VEC_LENGTH (args), NULL_TREE);\n-\n       if (TREE_CODE (tag) == ENUMERAL_TYPE)\n \t{\n-\t  tree e, values = NULL_TREE, *last = &values;\n-\n-\t  for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n-\t    {\n-\t      tree elt = build_enumerator\n-\t\t(TREE_PURPOSE (e),\n-\t\t tsubst_expr (TREE_VALUE (e), &TREE_VEC_ELT (args, 0),\n-\t\t\t      TREE_VEC_LENGTH (args), NULL_TREE));\n-\t      DECL_FIELD_CONTEXT (TREE_VALUE (elt)) = type;\n-\t      *last = elt;\n-\t      last = &TREE_CHAIN (elt);\n-\t    }\n-\n-\t  finish_enum (newtag, values);\n+\t  tree e, newtag = tsubst_enum (tag, &TREE_VEC_ELT (args, 0),\n+\t\t\t\t\tTREE_VEC_LENGTH (args));\n+\t  for (e = TYPE_VALUES (newtag); e; e = TREE_CHAIN (e))\n+\t    DECL_FIELD_CONTEXT (TREE_VALUE (e)) = type;\n \n \t  *field_chain = grok_enum_decls (newtag, NULL_TREE);\n \t  while (*field_chain)\n \t    field_chain = &TREE_CHAIN (*field_chain);\n \t}\n+      else\n+\ttsubst (tag, &TREE_VEC_ELT (args, 0),\n+\t\tTREE_VEC_LENGTH (args), NULL_TREE);\n     }\n \n   /* Don't replace enum constants here.  */\n@@ -1411,6 +1398,8 @@ tsubst (t, args, nargs, in_decl)\n \ttree ctx = tsubst (TYPE_CONTEXT (t), args, nargs, in_decl);\n \tif (ctx == NULL_TREE)\n \t  return t;\n+\telse if (ctx == current_function_decl)\n+\t  return lookup_name (TYPE_IDENTIFIER (t), 1);\n \telse\n \t  return lookup_nested_type_by_name (ctx, TYPE_IDENTIFIER (t));\n       }\n@@ -2000,7 +1989,9 @@ tsubst_copy (t, args, nargs, in_decl)\n       if (DECL_CONTEXT (t))\n \t{\n \t  tree ctx = tsubst (DECL_CONTEXT (t), args, nargs, in_decl);\n-\t  if (ctx != DECL_CONTEXT (t))\n+\t  if (ctx == current_function_decl)\n+\t    return lookup_name (DECL_NAME (t), 0);\n+\t  else if (ctx != DECL_CONTEXT (t))\n \t    return lookup_field (ctx, DECL_NAME (t), 0, 0);\n \t}\n       return t;\n@@ -2033,6 +2024,7 @@ tsubst_copy (t, args, nargs, in_decl)\n     case POSTINCREMENT_EXPR:\n     case NEGATE_EXPR:\n     case TRUTH_NOT_EXPR:\n+    case BIT_NOT_EXPR:\n     case ADDR_EXPR:\n     case CONVERT_EXPR:      /* Unary + */\n     case SIZEOF_EXPR:\n@@ -2491,6 +2483,13 @@ tsubst_expr (t, args, nargs, in_decl)\n       do_poplevel ();\n       break;\n \n+    case TAG_DEFN:\n+      lineno = TREE_COMPLEXITY (t);\n+      t = TREE_TYPE (t);\n+      if (TREE_CODE (t) == ENUMERAL_TYPE)\n+\ttsubst_enum (t, args, nargs);\n+      break;\n+\n     default:\n       return build_expr_from_tree (tsubst_copy (t, args, nargs, in_decl));\n     }\n@@ -3578,3 +3577,28 @@ add_maybe_template (d, fns)\n   maybe_template_tail = &TREE_CHAIN (*maybe_template_tail);\n   DECL_MAYBE_TEMPLATE (d) = 1;\n }\n+\n+/* Instantiate an enumerated type.  Used by instantiate_class_template and\n+   tsubst_expr.  */\n+\n+static tree\n+tsubst_enum (tag, args, nargs)\n+     tree tag, *args;\n+     int nargs;\n+{\n+  tree newtag = start_enum (TYPE_IDENTIFIER (tag));\n+  tree e, values = NULL_TREE;\n+\n+  for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n+    {\n+      tree elt = build_enumerator (TREE_PURPOSE (e),\n+\t\t\t\t   tsubst_expr (TREE_VALUE (e), args,\n+\t\t\t\t\t\tnargs, NULL_TREE));\n+      TREE_CHAIN (elt) = values;\n+      values = elt;\n+    }\n+\n+  finish_enum (newtag, values);\n+\n+  return newtag;\n+}"}]}