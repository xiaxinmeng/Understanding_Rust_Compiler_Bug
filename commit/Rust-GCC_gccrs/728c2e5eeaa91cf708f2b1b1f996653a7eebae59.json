{"sha": "728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI4YzJlNWVlYWE5MWNmNzA4ZjJiMWIxZjk5NjY1M2E3ZWViYWU1OQ==", "commit": {"author": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2019-12-13T17:02:53Z"}, "committer": {"name": "Roman Zhuykov", "email": "zhroma@gcc.gnu.org", "date": "2019-12-13T17:02:53Z"}, "message": "modulo-sched: speed up DDG analysis (PR90001)\n\n\tPR rtl-optimization/90001\n\t* ddg.c (create_ddg): Init max_dist array for each node.\n\t(free_ddg): Free max_dist array.\n\t(create_ddg_edge): Use bool field instead of aux union.\n\t(set_recurrence_length): Use prepared max_dist information instead\n\tof calling longest_simple_path.\n\t(create_scc): Remove graph argument, fill node's aux.count with\n\tSCC id, and move set_recurrence_length call to...\n\t(create_ddg_all_sccs): ...here, after filling all max_dist arrays\n\tusing Floyd\u2013Warshall-like algorithm.\n\t(update_dist_to_successors): Remove the whole function.\n\t(longest_simple_path): Likewise.\n\t* ddg.h (struct ddg_node): Add max_dist pointer.\n\t(struct ddg_edge): Use bool field instead of unused aux union.\n\nFrom-SVN: r279375", "tree": {"sha": "62136a55af00cbdc3a1f6358607258019c789b02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62136a55af00cbdc3a1f6358607258019c789b02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/comments", "author": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b945b19ad7cebebbaaf4eec44a7a572233ab91b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b945b19ad7cebebbaaf4eec44a7a572233ab91b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b945b19ad7cebebbaaf4eec44a7a572233ab91b"}], "stats": {"total": 181, "additions": 87, "deletions": 94}, "files": [{"sha": "46795b26cff52ce24c1555ab4d5230bc075e989e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "patch": "@@ -1,3 +1,19 @@\n+2019-12-13  Roman Zhuykov  <zhroma@ispras.ru>\n+\n+\t* ddg.c (create_ddg): Init max_dist array for each node.\n+\t(free_ddg): Free max_dist array.\n+\t(create_ddg_edge): Use bool field instead of aux union.\n+\t(set_recurrence_length): Use prepared max_dist information instead\n+\tof calling longest_simple_path.\n+\t(create_scc): Remove graph argument, fill node's aux.count with\n+\tSCC id, and move set_recurrence_length call to...\n+\t(create_ddg_all_sccs): ...here, after filling all max_dist arrays\n+\tusing Floyd\u2013Warshall-like algorithm.\n+\t(update_dist_to_successors): Remove the whole function.\n+\t(longest_simple_path): Likewise.\n+\t* ddg.h (struct ddg_node): Add max_dist pointer.\n+\t(struct ddg_edge): Use bool field instead of unused aux union.\n+\n 2019-12-13  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config/gcn/gcn-valu.md (mulv64si3<exec>): Rename to ..."}, {"sha": "d9285dd2b1190b9f0eacdd441d900faca22f6059", "filename": "gcc/ddg.c", "status": "modified", "additions": 65, "deletions": 88, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "patch": "@@ -32,9 +32,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #ifdef INSN_SCHEDULING\n \n-/* A flag indicating that a ddg edge belongs to an SCC or not.  */\n-enum edge_flag {NOT_IN_SCC = 0, IN_SCC};\n-\n /* Forward declarations.  */\n static void add_backarc_to_ddg (ddg_ptr, ddg_edge_ptr);\n static void add_backarc_to_scc (ddg_scc_ptr, ddg_edge_ptr);\n@@ -564,7 +561,7 @@ create_ddg (basic_block bb, int closing_branch_deps)\n {\n   ddg_ptr g;\n   rtx_insn *insn, *first_note;\n-  int i;\n+  int i, j;\n   int num_nodes = 0;\n \n   g = (ddg_ptr) xcalloc (1, sizeof (struct ddg));\n@@ -632,6 +629,12 @@ create_ddg (basic_block bb, int closing_branch_deps)\n       g->nodes[i].predecessors = sbitmap_alloc (num_nodes);\n       bitmap_clear (g->nodes[i].predecessors);\n       g->nodes[i].first_note = (first_note ? first_note : insn);\n+\n+      g->nodes[i].aux.count = -1;\n+      g->nodes[i].max_dist = XCNEWVEC (int, num_nodes);\n+      for (j = 0; j < num_nodes; j++)\n+         g->nodes[i].max_dist[j] = -1;\n+\n       g->nodes[i++].insn = insn;\n       first_note = NULL;\n     }\n@@ -668,6 +671,7 @@ free_ddg (ddg_ptr g)\n \t}\n       sbitmap_free (g->nodes[i].successors);\n       sbitmap_free (g->nodes[i].predecessors);\n+      free (g->nodes[i].max_dist);\n     }\n   if (g->num_backarcs > 0)\n     free (g->backarcs);\n@@ -792,7 +796,7 @@ create_ddg_edge (ddg_node_ptr src, ddg_node_ptr dest,\n   e->latency = l;\n   e->distance = d;\n   e->next_in = e->next_out = NULL;\n-  e->aux.info = 0;\n+  e->in_scc = false;\n   return e;\n }\n \n@@ -820,35 +824,32 @@ add_edge_to_ddg (ddg_ptr g ATTRIBUTE_UNUSED, ddg_edge_ptr e)\n    for now that cycles in the data dependence graph contain a single backarc.\n    This simplifies the algorithm, and can be generalized later.  */\n static void\n-set_recurrence_length (ddg_scc_ptr scc, ddg_ptr g)\n+set_recurrence_length (ddg_scc_ptr scc)\n {\n   int j;\n   int result = -1;\n \n   for (j = 0; j < scc->num_backarcs; j++)\n     {\n       ddg_edge_ptr backarc = scc->backarcs[j];\n-      int length;\n       int distance = backarc->distance;\n       ddg_node_ptr src = backarc->dest;\n       ddg_node_ptr dest = backarc->src;\n+      int length = src->max_dist[dest->cuid];\n+\n+      if (length < 0)\n+        continue;\n \n-      length = longest_simple_path (g, src->cuid, dest->cuid, scc->nodes);\n-      if (length < 0 )\n-\t{\n-\t  /* fprintf (stderr, \"Backarc not on simple cycle in SCC.\\n\"); */\n-\t  continue;\n-\t}\n       length += backarc->latency;\n       result = MAX (result, (length / distance));\n     }\n   scc->recurrence_length = result;\n }\n \n /* Create a new SCC given the set of its nodes.  Compute its recurrence_length\n-   and mark edges that belong to this scc as IN_SCC.  */\n+   and mark edges that belong to this scc.  */\n static ddg_scc_ptr\n-create_scc (ddg_ptr g, sbitmap nodes)\n+create_scc (ddg_ptr g, sbitmap nodes, int id)\n {\n   ddg_scc_ptr scc;\n   unsigned int u = 0;\n@@ -866,16 +867,18 @@ create_scc (ddg_ptr g, sbitmap nodes)\n       ddg_edge_ptr e;\n       ddg_node_ptr n = &g->nodes[u];\n \n+      gcc_assert (n->aux.count == -1);\n+      n->aux.count = id;\n+\n       for (e = n->out; e; e = e->next_out)\n \tif (bitmap_bit_p (nodes, e->dest->cuid))\n \t  {\n-\t    e->aux.count = IN_SCC;\n+\t    e->in_scc = true;\n \t    if (e->distance > 0)\n \t      add_backarc_to_scc (scc, e);\n \t  }\n     }\n \n-  set_recurrence_length (scc, g);\n   return scc;\n }\n \n@@ -1018,7 +1021,7 @@ check_sccs (ddg_all_sccs_ptr sccs, int num_nodes)\n ddg_all_sccs_ptr\n create_ddg_all_sccs (ddg_ptr g)\n {\n-  int i;\n+  int i, j, k, scc, way;\n   int num_nodes = g->num_nodes;\n   auto_sbitmap from (num_nodes);\n   auto_sbitmap to (num_nodes);\n@@ -1038,7 +1041,7 @@ create_ddg_all_sccs (ddg_ptr g)\n       ddg_node_ptr dest = backarc->dest;\n \n       /* If the backarc already belongs to an SCC, continue.  */\n-      if (backarc->aux.count == IN_SCC)\n+      if (backarc->in_scc)\n \tcontinue;\n \n       bitmap_clear (scc_nodes);\n@@ -1049,10 +1052,52 @@ create_ddg_all_sccs (ddg_ptr g)\n \n       if (find_nodes_on_paths (scc_nodes, g, from, to))\n \t{\n-\t  scc = create_scc (g, scc_nodes);\n+\t  scc = create_scc (g, scc_nodes, sccs->num_sccs);\n \t  add_scc_to_ddg (sccs, scc);\n \t}\n     }\n+\n+  /* Init max_dist arrays for Floyd\u2013Warshall-like\n+     longest patch calculation algorithm.  */\n+  for (k = 0; k < num_nodes; k++)\n+    {\n+      ddg_edge_ptr e;\n+      ddg_node_ptr n = &g->nodes[k];\n+\n+      if (n->aux.count == -1)\n+        continue;\n+\n+      n->max_dist[k] = 0;\n+      for (e = n->out; e; e = e->next_out)\n+        if (e->distance == 0 && g->nodes[e->dest->cuid].aux.count == n->aux.count)\n+          n->max_dist[e->dest->cuid] = e->latency;\n+    }\n+\n+  /* Run main Floid-Warshall loop.  We use only non-backarc edges\n+     inside each scc.  */\n+  for (k = 0; k < num_nodes; k++)\n+    {\n+      scc = g->nodes[k].aux.count;\n+      if (scc != -1)\n+        {\n+          for (i = 0; i < num_nodes; i++)\n+            if (g->nodes[i].aux.count == scc)\n+              for (j = 0; j < num_nodes; j++)\n+                if (g->nodes[j].aux.count == scc\n+                    && g->nodes[i].max_dist[k] >= 0\n+                    && g->nodes[k].max_dist[j] >= 0)\n+                  {\n+                    way = g->nodes[i].max_dist[k] + g->nodes[k].max_dist[j];\n+                    if (g->nodes[i].max_dist[j] < way)\n+                      g->nodes[i].max_dist[j] = way;\n+                  }\n+        }\n+    }\n+\n+  /* Calculate recurrence_length using max_dist info.  */\n+  for (i = 0; i < sccs->num_sccs; i++)\n+    set_recurrence_length (sccs->sccs[i]);\n+\n   order_sccs (sccs);\n \n   if (flag_checking)\n@@ -1155,72 +1200,4 @@ find_nodes_on_paths (sbitmap result, ddg_ptr g, sbitmap from, sbitmap to)\n   return bitmap_and (result, reachable_from, reach_to);\n }\n \n-\n-/* Updates the counts of U_NODE's successors (that belong to NODES) to be\n-   at-least as large as the count of U_NODE plus the latency between them.\n-   Sets a bit in TMP for each successor whose count was changed (increased).\n-   Returns nonzero if any count was changed.  */\n-static int\n-update_dist_to_successors (ddg_node_ptr u_node, sbitmap nodes, sbitmap tmp)\n-{\n-  ddg_edge_ptr e;\n-  int result = 0;\n-\n-  for (e = u_node->out; e; e = e->next_out)\n-    {\n-      ddg_node_ptr v_node = e->dest;\n-      int v = v_node->cuid;\n-\n-      if (bitmap_bit_p (nodes, v)\n-\t  && (e->distance == 0)\n-\t  && (v_node->aux.count < u_node->aux.count + e->latency))\n-\t{\n-\t  v_node->aux.count = u_node->aux.count + e->latency;\n-\t  bitmap_set_bit (tmp, v);\n-\t  result = 1;\n-\t}\n-    }\n-  return result;\n-}\n-\n-\n-/* Find the length of a longest path from SRC to DEST in G,\n-   going only through NODES, and disregarding backarcs.  */\n-int\n-longest_simple_path (struct ddg * g, int src, int dest, sbitmap nodes)\n-{\n-  int i;\n-  unsigned int u = 0;\n-  int change = 1;\n-  int num_nodes = g->num_nodes;\n-  auto_sbitmap workset (num_nodes);\n-  auto_sbitmap tmp (num_nodes);\n-\n-\n-  /* Data will hold the distance of the longest path found so far from\n-     src to each node.  Initialize to -1 = less than minimum.  */\n-  for (i = 0; i < g->num_nodes; i++)\n-    g->nodes[i].aux.count = -1;\n-  g->nodes[src].aux.count = 0;\n-\n-  bitmap_clear (tmp);\n-  bitmap_set_bit (tmp, src);\n-\n-  while (change)\n-    {\n-      sbitmap_iterator sbi;\n-\n-      change = 0;\n-      bitmap_copy (workset, tmp);\n-      bitmap_clear (tmp);\n-      EXECUTE_IF_SET_IN_BITMAP (workset, 0, u, sbi)\n-\t{\n-\t  ddg_node_ptr u_node = &g->nodes[u];\n-\n-\t  change |= update_dist_to_successors (u_node, nodes, tmp);\n-\t}\n-    }\n-  return g->nodes[dest].aux.count;\n-}\n-\n #endif /* INSN_SCHEDULING */"}, {"sha": "aff3561fa29ff45663080c99e2574ecaba3c109e", "filename": "gcc/ddg.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728c2e5eeaa91cf708f2b1b1f996653a7eebae59/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=728c2e5eeaa91cf708f2b1b1f996653a7eebae59", "patch": "@@ -64,6 +64,10 @@ struct ddg_node\n   sbitmap successors;\n   sbitmap predecessors;\n \n+  /* Temporary array used for Floyd-Warshall algorithm to find\n+     scc recurrence length.  */\n+  int *max_dist;\n+\n   /* For general use by algorithms manipulating the ddg.  */\n   union {\n     int count;\n@@ -95,11 +99,8 @@ struct ddg_edge\n   ddg_edge_ptr next_in;\n   ddg_edge_ptr next_out;\n \n-  /* For general use by algorithms manipulating the ddg.  */\n-  union {\n-    int count;\n-    void *info;\n-  } aux;\n+  /* Is true when edge is already in scc.  */\n+  bool in_scc;\n };\n \n /* This structure holds the Data Dependence Graph for a basic block.  */\n@@ -178,7 +179,6 @@ ddg_all_sccs_ptr create_ddg_all_sccs (ddg_ptr);\n void free_ddg_all_sccs (ddg_all_sccs_ptr);\n \n int find_nodes_on_paths (sbitmap result, ddg_ptr, sbitmap from, sbitmap to);\n-int longest_simple_path (ddg_ptr, int from, int to, sbitmap via);\n \n bool autoinc_var_is_used_p (rtx_insn *, rtx_insn *);\n "}]}