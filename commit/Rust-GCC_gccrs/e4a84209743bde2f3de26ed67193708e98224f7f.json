{"sha": "e4a84209743bde2f3de26ed67193708e98224f7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRhODQyMDk3NDNiZGUyZjNkZTI2ZWQ2NzE5MzcwOGU5ODIyNGY3Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-08-04T11:46:41Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-08-04T11:46:41Z"}, "message": "decl.c (pushtag): Don't mangle the name of a TYPE_DECL if it uses template parameters.\n\n\t* decl.c (pushtag): Don't mangle the name of a TYPE_DECL if it\n\tuses template parameters.\n\t* method.c (build_template_parm_names): Use the full set of\n\ttemplate arguments for tsubst'ing.\n\t(build_overload_identifier): Pass the full set of template\n\targuments to build_template_parm_names, not just the\n\tinnermost_args.\n\t* pt.c (TMPL_ARGS_DEPTH): Define using\n\tTMPL_ARGS_HAVE_MULTIPLE_LEVELS, for clarity.\n\t(NUM_TMPL_ARGS): New macro.\n\t(add_outermost_template_args): Deal with the case where the outer\n\targs will be completely discarded.\n\t(coerce_template_parms): Use the full set of template arguments\n\tfor tsubst'ing.  Simplify.  Add some asserts.  Improve\n\terror messages.\n\t(lookup_template_class): Pass the full set of template arguments\n\tto coerce_template_parms.\n\t(tsubst): Add assertion.\n\t(do_type_instantiation): Don't instantiate member template\n\tclasses.\n\t* init.c (build_offset_ref): Deal with a TEMPLATE_ID_EXPR whose\n\tname is a LOOKUP_EXPR, rather than an IDENTIFIER_NODE.\n\nFrom-SVN: r21609", "tree": {"sha": "6d41a333fd86ba17254ebabc966afa6b506dd6e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d41a333fd86ba17254ebabc966afa6b506dd6e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4a84209743bde2f3de26ed67193708e98224f7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a84209743bde2f3de26ed67193708e98224f7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4a84209743bde2f3de26ed67193708e98224f7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4a84209743bde2f3de26ed67193708e98224f7f/comments", "author": null, "committer": null, "parents": [{"sha": "be5ceb725bcd4a27928d767fa27c8f198f24bca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be5ceb725bcd4a27928d767fa27c8f198f24bca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be5ceb725bcd4a27928d767fa27c8f198f24bca8"}], "stats": {"total": 232, "additions": 184, "deletions": 48}, "files": [{"sha": "12218d8ae80da7a3300f35c8f2e96a143693ac56", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -1,3 +1,29 @@\n+1998-08-04  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* decl.c (pushtag): Don't mangle the name of a TYPE_DECL if it\n+\tuses template parameters.\n+\t* method.c (build_template_parm_names): Use the full set of\n+\ttemplate arguments for tsubst'ing.\n+\t(build_overload_identifier): Pass the full set of template\n+\targuments to build_template_parm_names, not just the\n+\tinnermost_args. \n+\t* pt.c (TMPL_ARGS_DEPTH): Define using\n+\tTMPL_ARGS_HAVE_MULTIPLE_LEVELS, for clarity.\n+\t(NUM_TMPL_ARGS): New macro.\n+\t(add_outermost_template_args): Deal with the case where the outer\n+\targs will be completely discarded.\n+\t(coerce_template_parms): Use the full set of template arguments\n+\tfor tsubst'ing.  Simplify.  Add some asserts.  Improve\n+\terror messages.\n+\t(lookup_template_class): Pass the full set of template arguments\n+\tto coerce_template_parms.\n+\t(tsubst): Add assertion.\n+\t(do_type_instantiation): Don't instantiate member template\n+\tclasses. \n+\t\n+\t* init.c (build_offset_ref): Deal with a TEMPLATE_ID_EXPR whose\n+\tname is a LOOKUP_EXPR, rather than an IDENTIFIER_NODE.\n+\n 1998-08-03  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* method.c (set_mangled_name_for_decl): Change return type to void."}, {"sha": "699170a0c9235ecf47245ee93e03e259d4ed6509", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -2396,8 +2396,9 @@ pushtag (name, type, globalize)\n \n \t      TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n \t      DECL_ASSEMBLER_NAME (d) = DECL_NAME (d);\n-\t      DECL_ASSEMBLER_NAME (d)\n-\t\t= get_identifier (build_overload_name (type, 1, 1));\n+\t      if (!uses_template_parms (type))\n+\t\tDECL_ASSEMBLER_NAME (d)\n+\t\t  = get_identifier (build_overload_name (type, 1, 1));\n \t    }\n         }\n       if (b->parm_flag == 2)"}, {"sha": "78b6c5d8cbadf3d7acd131981f6d0f0d860664cc", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -1547,6 +1547,11 @@ build_offset_ref (type, name)\n \t part, we treat this just like a.f.  We do remember, however,\n \t the template-id that was used.  */\n       name = TREE_OPERAND (orig_name, 0);\n+\n+      if (TREE_CODE (name) == LOOKUP_EXPR)\n+\t/* This can happen during tsubst'ing.  */\n+\tname = TREE_OPERAND (name, 0);\n+\n       my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 0);\n     }\n "}, {"sha": "16ecbf2d7daf7e1b4ba5de1de486d1553541ab26", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -862,13 +862,14 @@ build_template_parm_names (parmlist, arglist)\n      tree arglist;\n {\n   int i, nparms;\n-  \n+  tree inner_args = innermost_args (arglist);\n+\n   nparms = TREE_VEC_LENGTH (parmlist);\n   icat (nparms);\n   for (i = 0; i < nparms; i++)\n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n-      tree arg = TREE_VEC_ELT (arglist, i);\n+      tree arg = TREE_VEC_ELT (inner_args, i);\n       if (TREE_CODE (parm) == TYPE_DECL)\n \t{\n \t  /* This parameter is a type.  */\n@@ -919,9 +920,8 @@ build_overload_identifier (name)\n     {\n       /* NAME is the TYPE_DECL for a template specialization.  */\n       tree template, parmlist, arglist, tname;\n-      template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));\n-      arglist = innermost_args (TREE_VALUE (template));\n-      template = TREE_PURPOSE (template);\n+      template = CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name));\n+      arglist = CLASSTYPE_TI_ARGS (TREE_TYPE (name));\n       tname = DECL_NAME (template);\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n       OB_PUTC ('t');"}, {"sha": "6775575cb596fcd2918db31d71ac118b907bd9c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 109, "deletions": 41, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -135,19 +135,6 @@ static int template_class_depth_real PROTO((tree, int));\n    only one level of arguments, but which is a TREE_VEC containing as\n    its only entry the TREE_VEC for that level.  */\n \n-/* The depth of a template argument vector.  When called directly by\n-   the parser, we use a TREE_LIST rather than a TREE_VEC to represent\n-   template arguments.  In fact, we may even see NULL_TREE if there\n-   are no template arguments.  In both of those cases, there is only\n-   one level of template arguments.  */\n-#define TMPL_ARGS_DEPTH(NODE)\t\t\t\t\t\\\n-  ((NODE != NULL_TREE\t\t\t\t\t\t\\\n-    && TREE_CODE (NODE) == TREE_VEC\t\t\t\t\\\n-    && TREE_VEC_LENGTH (NODE) > 0\t\t\t\t\\\n-    && TREE_VEC_ELT (NODE, 0) != NULL_TREE\t\t\t\\\n-    && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC) ?\t\\\n-   TREE_VEC_LENGTH (NODE) : 1)\n-\n /* Non-zero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */\n #define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \\\n@@ -157,6 +144,14 @@ static int template_class_depth_real PROTO((tree, int));\n    && TREE_VEC_ELT (NODE, 0) != NULL_TREE\t\t\t\\\n    && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n \n+/* The depth of a template argument vector.  When called directly by\n+   the parser, we use a TREE_LIST rather than a TREE_VEC to represent\n+   template arguments.  In fact, we may even see NULL_TREE if there\n+   are no template arguments.  In both of those cases, there is only\n+   one level of template arguments.  */\n+#define TMPL_ARGS_DEPTH(NODE)\t\t\t\t\t\\\n+  (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (NODE) ? TREE_VEC_LENGTH (NODE) : 1)\n+\n /* The LEVELth level of the template ARGS.  Note that template\n    parameter levels are indexed from 1, not from 0.  */\n #define TMPL_ARGS_LEVEL(ARGS, LEVEL)\t\t\\\n@@ -177,6 +172,13 @@ static int template_class_depth_real PROTO((tree, int));\n #define SET_TMPL_ARG(ARGS, LEVEL, IDX, VAL)\t\t\t\\\n   (TREE_VEC_ELT (TREE_VEC_ELT ((ARGS), (LEVEL) - 1), (IDX)) = (VAL))\n \n+/* Given a single level of template arguments in NODE, return the\n+   number of arguments.  */\n+#define NUM_TMPL_ARGS(NODE) \t\t\t\t\\\n+  ((NODE) == NULL_TREE ? 0 \t\t\t\t\\\n+   : (TREE_CODE (NODE) == TREE_VEC \t\t\t\\\n+      ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))\n+\n /* The number of levels of template parameters given by NODE.  */\n #define TMPL_PARMS_DEPTH(NODE) \\\n   (TREE_INT_CST_HIGH (TREE_PURPOSE (NODE)))\n@@ -506,6 +508,16 @@ add_outermost_template_args (args, extra_args)\n {\n   tree new_args;\n \n+  /* If there are more levels of EXTRA_ARGS than there are ARGS,\n+     something very fishy is going on.  */\n+  my_friendly_assert (TMPL_ARGS_DEPTH (args) >= TMPL_ARGS_DEPTH (extra_args),\n+\t\t      0);\n+\n+  /* If *all* the new arguments will be the EXTRA_ARGS, just return\n+     them.  */\n+  if (TMPL_ARGS_DEPTH (args) == TMPL_ARGS_DEPTH (extra_args))\n+    return extra_args;\n+\n   /* For the moment, we make ARGS look like it contains fewer levels.  */\n   TREE_VEC_LENGTH (args) -= TMPL_ARGS_DEPTH (extra_args);\n   \n@@ -2545,15 +2557,11 @@ coerce_template_parms (parms, arglist, in_decl,\n      int require_all_arguments;\n {\n   int nparms, nargs, i, lost = 0;\n-  tree vec = NULL_TREE;\n-\n-  if (arglist == NULL_TREE)\n-    nargs = 0;\n-  else if (TREE_CODE (arglist) == TREE_VEC)\n-    nargs = TREE_VEC_LENGTH (arglist);\n-  else\n-    nargs = list_length (arglist);\n+  tree inner_args;\n+  tree vec;\n \n+  inner_args = innermost_args (arglist);\n+  nargs = NUM_TMPL_ARGS (inner_args);\n   nparms = TREE_VEC_LENGTH (parms);\n \n   if (nargs > nparms\n@@ -2563,22 +2571,42 @@ coerce_template_parms (parms, arglist, in_decl,\n     {\n       if (complain) \n \t{\n-\t  error (\"incorrect number of parameters (%d, should be %d)\",\n-\t\t nargs, nparms);\n+\t  cp_error (\"wrong number of template arguments (%d, should be %d)\",\n+\t\t    nargs, nparms);\n \t  \n \t  if (in_decl)\n-\t    cp_error_at (\"in template expansion for decl `%D'\",\n-\t\t\t in_decl);\n+\t    cp_error_at (\"provided for `%D'\", in_decl);\n \t}\n \n       return error_mark_node;\n     }\n \n-  if (arglist && TREE_CODE (arglist) == TREE_VEC && nargs == nparms)\n-    vec = copy_node (arglist);\n+  /* Create in VEC the appropriate innermost arguments, and reset\n+     ARGLIST to contain the complete set of arguments.  */\n+  if (inner_args && TREE_CODE (inner_args) == TREE_VEC && nargs == nparms)\n+    {\n+      /* If we already have all the arguments, we can just use them.\n+\t This is an optimization over the code in the `else' branch\n+\t below, and should be functionally identicial.  */\n+      vec = copy_node (inner_args);\n+      arglist = add_outermost_template_args (arglist, vec);\n+    }\n   else\n     {\n+      /* If we don't already have all the arguments we must get what\n+\t we can from default template arguments.  The tricky bit is\n+\t that previous arguments can influence the default values,\n+\t e.g.:  \n+\n+\t   template <class T, class U = T> void foo();\n+\n+\t If we see `foo<int>' we have to come up with an {int, int}\n+\t vector.  */\n+\n+      tree new_arglist;\n+\n       vec = make_tree_vec (nparms);\n+      new_arglist = add_outermost_template_args (arglist, vec);\n \n       for (i = 0; i < nparms; i++)\n \t{\n@@ -2597,23 +2625,33 @@ coerce_template_parms (parms, arglist, in_decl,\n \t    }\n \t  else if (i < nargs)\n \t    {\n-\t      arg = TREE_VEC_ELT (arglist, i);\n+\t      arg = TREE_VEC_ELT (inner_args, i);\n \t      if (arg == error_mark_node)\n \t\tlost++;\n \t    }\n+\t  /* If no template argument was supplied, look for a default\n+\t     value.  */\n \t  else if (TREE_PURPOSE (parm) == NULL_TREE)\n \t    {\n+\t      /* There was no default value.  */\n \t      my_friendly_assert (!require_all_arguments, 0);\n \t      break;\n \t    }\n \t  else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n-\t    arg = tsubst (TREE_PURPOSE (parm), vec, in_decl);\n+\t    arg = tsubst (TREE_PURPOSE (parm), new_arglist, in_decl);\n \t  else\n-\t    arg = tsubst_expr (TREE_PURPOSE (parm), vec, in_decl);\n+\t    arg = tsubst_expr (TREE_PURPOSE (parm), new_arglist, in_decl);\n \n \t  TREE_VEC_ELT (vec, i) = arg;\n \t}\n+\n+      /* We've left ARGLIST intact up to this point, in order to allow\n+\t iteration through it in the case that it was a TREE_LIST, but\n+\t from here on it should contain the full set of template\n+\t arguments.  */\n+      arglist = new_arglist;\n     }\n+\n   for (i = 0; i < nparms; i++)\n     {\n       tree arg = TREE_VEC_ELT (vec, i);\n@@ -2772,7 +2810,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t}\n       else\n \t{\n-\t  tree t = tsubst (TREE_TYPE (parm), vec, in_decl);\n+\t  tree t = tsubst (TREE_TYPE (parm), arglist, in_decl);\n \n \t  if (processing_template_decl)\n \t    arg = maybe_fold_nontype_arg (arg);\n@@ -3205,17 +3243,29 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t{\n \t  /* We have multiple levels of arguments to coerce, at once.  */\n \t  int i;\n+\t  int saved_depth = TMPL_ARGS_DEPTH (arglist);\n \n \t  tree bound_args = make_tree_vec (parm_depth);\n \t  \n-\t  for (i = TREE_VEC_LENGTH (arglist) - 1, \n+\t  for (i = saved_depth,\n \t\t t = DECL_TEMPLATE_PARMS (template); \n-\t       i >= 0 && t != NULL_TREE;\n+\t       i > 0 && t != NULL_TREE;\n \t       --i, t = TREE_CHAIN (t))\n-\t    TREE_VEC_ELT (bound_args, i) =\n-\t      coerce_template_parms (TREE_VALUE (t),\n-\t\t\t\t     TREE_VEC_ELT (arglist, i),\n-\t\t\t\t     template, 1, 1);\n+\t    {\n+\t      tree a = coerce_template_parms (TREE_VALUE (t),\n+\t\t\t\t\t      arglist, template, 1, 1);\n+\t      SET_TMPL_ARGS_LEVEL (bound_args, i, a);\n+\n+\t      /* We temporarily reduce the length of the ARGLIST so\n+\t\t that coerce_template_parms will see only the arguments\n+\t\t corresponding to the template parameters it is\n+\t\t examining.  */\n+\t      TREE_VEC_LENGTH (arglist)--;\n+\t    }\n+\n+\t  /* Restore the ARGLIST to its full size.  */\n+\t  TREE_VEC_LENGTH (arglist) = saved_depth;\n+\n \t  arglist = bound_args;\n \t}\n       else\n@@ -4647,9 +4697,13 @@ tsubst (t, args, in_decl)\n \t    if (arg != NULL_TREE)\n \t      {\n \t\tif (TREE_CODE (t) == TEMPLATE_TYPE_PARM)\n-\t\t  return cp_build_type_variant\n-\t\t    (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n-\t\t     TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\t\t  {\n+\t\t    my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (arg))\n+\t\t\t\t\t== 't', 0);\n+\t\t    return cp_build_type_variant\n+\t\t      (arg, TYPE_READONLY (arg) || TYPE_READONLY (t),\n+\t\t       TYPE_VOLATILE (arg) || TYPE_VOLATILE (t));\n+\t\t  }\n \t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n \t\t    if (CLASSTYPE_TEMPLATE_INFO (t))\n@@ -7392,8 +7446,22 @@ do_type_instantiation (t, storage)\n \t    instantiate_decl (tmp);\n \t}\n \n+    /* In contrast to implicit instantiation, where only the\n+       declarations, and not the definitions, of members are\n+       instantiated, we have here:\n+\n+         [temp.explicit]\n+\n+\t The explicit instantiation of a class template specialization\n+\t implies the instantiation of all of its members not\n+\t previously explicitly specialized in the translation unit\n+\t containing the explicit instantiation.  \n+\n+       Of course, we can't instantiate member template classes, since\n+       we don't have any arguments for them.  */\n     for (tmp = CLASSTYPE_TAGS (t); tmp; tmp = TREE_CHAIN (tmp))\n-      if (IS_AGGR_TYPE (TREE_VALUE (tmp)))\n+      if (IS_AGGR_TYPE (TREE_VALUE (tmp))\n+\t  && !uses_template_parms (CLASSTYPE_TI_ARGS (TREE_VALUE (tmp))))\n \tdo_type_instantiation (TYPE_MAIN_DECL (TREE_VALUE (tmp)), storage);\n   }\n }"}, {"sha": "b12c702e856744514bd2b00b8e365db5f3e9dc0c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash18.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash18.C?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -0,0 +1,23 @@\n+// Build don't run:\n+\n+template<class T>\n+class foo {\n+  T deft;\n+\n+  template<class U> int priv (U u, T t) { return u - t; }\n+public:\n+  foo (T t) : deft (t) {}\n+\n+  template<class U> int pub (U u) {\n+    int (foo::*fn) (U, T);\n+    fn = &foo<T>::template priv<U>;\n+    return (this->*fn) (u, deft);\n+  }\n+};\n+\n+int\n+main ()\n+{\n+  foo<long> fff (5);\n+  return fff.pub (3);\n+}"}, {"sha": "e8e564369e910183455d013da2c31a2afb51aad0", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memclass16.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4a84209743bde2f3de26ed67193708e98224f7f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemclass16.C?ref=e4a84209743bde2f3de26ed67193708e98224f7f", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+\n+template <class Q>\n+class A {\n+public:\n+ \n+        typedef enum { X, Y } B;\n+        template <B c> class Traits{ };\n+};\n+\n+\n+template class A<int>;\n+template class A<double>::Traits<A<double>::X>;"}]}