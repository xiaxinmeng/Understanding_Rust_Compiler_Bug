{"sha": "97c07987a6d8052c77125b5f9841abc1f937b3eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdjMDc5ODdhNmQ4MDUyYzc3MTI1YjVmOTg0MWFiYzFmOTM3YjNlYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-01-24T08:12:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-01-24T08:12:40Z"}, "message": "cfgcleanup.c (try_crossjump_to_edge): Use combine_with_count to merge probabilities.\n\n\n\t* cfgcleanup.c (try_crossjump_to_edge): Use combine_with_count\n\tto merge probabilities.\n\t* predict.c (probably_never_executed): Also mark as cold functions\n\twith global 0 profile and guessed local profile.\n\t* profile-count.c (profile_probability::combine_with_count): New\n\tmember function.\n\t* profile-count.h (profile_probability::operator*,\n\tprofile_probability::operator*=, profile_probability::operator/,\n\tprofile_probability::operator/=): Reduce precision to adjusted\n\tand set value to guessed on contradictory divisions.\n\t(profile_probability::combine_with_freq): Remove.\n\t(profile_probability::combine_wiht_count): Declare.\n\t(profile_count::force_nonzero):: Set to adjusted.\n\t(profile_count::probability_in):: Set quality to adjusted.\n\t* tree-ssa-tail-merge.c (replace_block_by): Use\n\tcombine_with_count.\n\nFrom-SVN: r257010", "tree": {"sha": "660c3f17e8e166b824b72c77a9eb809b2f20310e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/660c3f17e8e166b824b72c77a9eb809b2f20310e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97c07987a6d8052c77125b5f9841abc1f937b3eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c07987a6d8052c77125b5f9841abc1f937b3eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97c07987a6d8052c77125b5f9841abc1f937b3eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97c07987a6d8052c77125b5f9841abc1f937b3eb/comments", "author": null, "committer": null, "parents": [{"sha": "3885527ddf9ea47d0eab8d2c3a503a8e8e01d97d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3885527ddf9ea47d0eab8d2c3a503a8e8e01d97d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3885527ddf9ea47d0eab8d2c3a503a8e8e01d97d"}], "stats": {"total": 140, "additions": 92, "deletions": 48}, "files": [{"sha": "b3ebc9d5eec28094100b02e4ee270433348a44c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=97c07987a6d8052c77125b5f9841abc1f937b3eb", "patch": "@@ -1,3 +1,22 @@\n+2018-01-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfgcleanup.c (try_crossjump_to_edge): Use combine_with_count\n+\tto merge probabilities.\n+\t* predict.c (probably_never_executed): Also mark as cold functions\n+\twith global 0 profile and guessed local profile.\n+\t* profile-count.c (profile_probability::combine_with_count): New\n+\tmember function.\n+\t* profile-count.h (profile_probability::operator*,\n+\tprofile_probability::operator*=, profile_probability::operator/,\n+\tprofile_probability::operator/=): Reduce precision to adjusted\n+\tand set value to guessed on contradictory divisions.\n+\t(profile_probability::combine_with_freq): Remove.\n+\t(profile_probability::combine_wiht_count): Declare.\n+\t(profile_count::force_nonzero):: Set to adjusted.\n+\t(profile_count::probability_in):: Set quality to adjusted.\n+\t* tree-ssa-tail-merge.c (replace_block_by): Use\n+\tcombine_with_count.\n+\n 2018-01-23  Andrew Waterman  <andrew@sifive.com>\n \t    Jim Wilson  <jimw@sifive.com>\n "}, {"sha": "6892d806e53272dc76b5adcb8accedc44cb5451f", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=97c07987a6d8052c77125b5f9841abc1f937b3eb", "patch": "@@ -2130,11 +2130,9 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n       if (FORWARDER_BLOCK_P (s2->dest))\n \ts2->dest->count -= s->count ();\n \n-      /* FIXME: Is this correct? Should be rewritten to count API.  */\n-      if (redirect_edges_to->count.nonzero_p () && src1->count.nonzero_p ())\n-\ts->probability = s->probability.combine_with_freq\n-\t\t\t   (redirect_edges_to->count.to_frequency (cfun),\n-\t\t\t    s2->probability, src1->count.to_frequency (cfun));\n+      s->probability = s->probability.combine_with_count\n+\t\t\t  (redirect_edges_to->count,\n+\t\t\t   s2->probability, src1->count);\n     }\n \n   /* Adjust count for the block.  An earlier jump"}, {"sha": "25629db89f8b731b5ca79f96345508c28efad801", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=97c07987a6d8052c77125b5f9841abc1f937b3eb", "patch": "@@ -210,7 +210,7 @@ probably_never_executed (struct function *fun,\n                          profile_count count)\n {\n   gcc_checking_assert (fun);\n-  if (count == profile_count::zero ())\n+  if (count.ipa () == profile_count::zero ())\n     return true;\n   /* Do not trust adjusted counts.  This will make us to drop int cold section\n      code with low execution count as a result of inlining. These low counts"}, {"sha": "c3b115f0b81c96b4456af77ff24cb1043a95dcbb", "filename": "gcc/profile-count.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=97c07987a6d8052c77125b5f9841abc1f937b3eb", "patch": "@@ -345,3 +345,29 @@ profile_count::from_gcov_type (gcov_type v)\n     return ret;\n   }\n \n+\n+/* COUNT1 times event happens with *THIS probability, COUNT2 times OTHER\n+   happens with COUNT2 probablity. Return probablity that either *THIS or\n+   OTHER happens.  */\n+\n+profile_probability\n+profile_probability::combine_with_count (profile_count count1,\n+\t\t\t\t\t profile_probability other,\n+\t\t\t\t\t profile_count count2) const\n+{\n+  /* If probabilities are same, we are done.\n+     If counts are nonzero we can distribute accordingly. In remaining\n+     cases just avreage the values and hope for the best.  */\n+  if (*this == other || count1 == count2\n+      || (count2 == profile_count::zero ()\n+\t  && !(count1 == profile_count::zero ())))\n+    return *this;\n+  if (count1 == profile_count::zero () && !(count2 == profile_count::zero ()))\n+    return other;\n+  else if (count1.nonzero_p () || count2.nonzero_p ())\n+    return *this * count1.probability_in (count1 + count2)\n+\t   + other * count2.probability_in (count1 + count2);\n+  else\n+    return *this * profile_probability::even ()\n+\t   + other * profile_probability::even ();\n+}"}, {"sha": "c83fa3beb8feb6dd3f6238c611c4fa0508cf83c6", "filename": "gcc/profile-count.h", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=97c07987a6d8052c77125b5f9841abc1f937b3eb", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_PROFILE_COUNT_H\n \n struct function;\n+class profile_count;\n \n /* Quality of the profile count.  Because gengtype does not support enums\n    inside of classes, this is in global namespace.  */\n@@ -350,7 +351,7 @@ class GTY((user)) profile_probability\n \treturn profile_probability::uninitialized ();\n       profile_probability ret;\n       ret.m_val = RDIV ((uint64_t)m_val * other.m_val, max_probability);\n-      ret.m_quality = MIN (m_quality, other.m_quality);\n+      ret.m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n       return ret;\n     }\n   profile_probability &operator*= (const profile_probability &other)\n@@ -363,7 +364,7 @@ class GTY((user)) profile_probability\n       else\n \t{\n \t  m_val = RDIV ((uint64_t)m_val * other.m_val, max_probability);\n-\t  m_quality = MIN (m_quality, other.m_quality);\n+\t  m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n \t}\n       return *this;\n     }\n@@ -374,8 +375,14 @@ class GTY((user)) profile_probability\n       if (!initialized_p () || !other.initialized_p ())\n \treturn profile_probability::uninitialized ();\n       profile_probability ret;\n+      /* If we get probability above 1, mark it as unreliable and return 1. */\n       if (m_val >= other.m_val)\n-\tret.m_val = max_probability;\n+\t{\n+\t  ret.m_val = max_probability;\n+          ret.m_quality = MIN (MIN (m_quality, other.m_quality),\n+\t\t\t       profile_guessed);\n+\t  return ret;\n+\t}\n       else if (!m_val)\n \tret.m_val = 0;\n       else\n@@ -385,7 +392,7 @@ class GTY((user)) profile_probability\n \t\t\t\t other.m_val),\n \t\t\t   max_probability);\n \t}\n-      ret.m_quality = MIN (m_quality, other.m_quality);\n+      ret.m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n       return ret;\n     }\n   profile_probability &operator/= (const profile_probability &other)\n@@ -396,8 +403,15 @@ class GTY((user)) profile_probability\n \treturn *this = profile_probability::uninitialized ();\n       else\n \t{\n+          /* If we get probability above 1, mark it as unreliable\n+\t     and return 1. */\n \t  if (m_val > other.m_val)\n-\t    m_val = max_probability;\n+\t    {\n+\t      m_val = max_probability;\n+              m_quality = MIN (MIN (m_quality, other.m_quality),\n+\t\t\t       profile_guessed);\n+\t      return *this;\n+\t    }\n \t  else if (!m_val)\n \t    ;\n \t  else\n@@ -407,7 +421,7 @@ class GTY((user)) profile_probability\n \t\t\t\t other.m_val),\n \t\t\t   max_probability);\n \t    }\n-\t  m_quality = MIN (m_quality, other.m_quality);\n+\t  m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n \t}\n       return *this;\n     }\n@@ -465,27 +479,6 @@ class GTY((user)) profile_probability\n       return ret;\n     }\n \n-  profile_probability combine_with_freq (int freq1, profile_probability other,\n-\t\t\t\t\t int freq2) const\n-    {\n-      profile_probability ret;\n-\n-      if (*this == profile_probability::uninitialized ()\n-\t  || other == profile_probability::uninitialized ())\n-\treturn profile_probability::uninitialized ();\n-\n-      gcc_checking_assert (freq1 >= 0 && freq2 >= 0);\n-      if (!freq1 && !freq2)\n-\t{\n-\t  ret.m_val = (m_val + other.m_val) / 2;\n-\t}\n-      else\n-\tret.m_val = RDIV (m_val * (uint64_t) freq1\n-\t\t\t  + other.m_val * (uint64_t) freq2, freq1 + freq2);\n-      ret.m_quality = MIN (m_quality, other.m_quality);\n-      return ret;\n-    }\n-\n   /* Return *THIS * NUM / DEN.  */\n   profile_probability apply_scale (int64_t num, int64_t den) const\n     {\n@@ -569,6 +562,12 @@ class GTY((user)) profile_probability\n   bool differs_from_p (profile_probability other) const;\n   /* Return if difference is greater than 50%.  */\n   bool differs_lot_from_p (profile_probability other) const;\n+  /* COUNT1 times event happens with *THIS probability, COUNT2 times OTHER\n+     happens with COUNT2 probablity. Return probablity that either *THIS or\n+     OTHER happens.  */\n+  profile_probability combine_with_count (profile_count count1,\n+\t\t\t\t\t  profile_probability other,\n+\t\t\t\t\t  profile_count count2) const;\n \n   /* LTO streaming support.  */\n   static profile_probability stream_in (struct lto_input_block *);\n@@ -906,7 +905,10 @@ class GTY(()) profile_count\n \treturn *this;\n       profile_count ret = *this;\n       if (ret.m_val == 0)\n-\tret.m_val = 1;\n+\t{\n+\t  ret.m_val = 1;\n+          ret.m_quality = MIN (m_quality, profile_adjusted);\n+\t}\n       return ret;\n     }\n \n@@ -1062,20 +1064,28 @@ class GTY(()) profile_count\n      OVERALL.  */\n   profile_probability probability_in (const profile_count overall) const\n     {\n-      if (*this == profile_count::zero ())\n+      if (*this == profile_count::zero ()\n+\t  && !(overall == profile_count::zero ()))\n \treturn profile_probability::never ();\n       if (!initialized_p () || !overall.initialized_p ()\n \t  || !overall.m_val)\n \treturn profile_probability::uninitialized ();\n+      if (*this == overall && m_quality == profile_precise)\n+\treturn profile_probability::always ();\n       profile_probability ret;\n       gcc_checking_assert (compatible_p (overall));\n \n       if (overall.m_val < m_val)\n-\tret.m_val = profile_probability::max_probability;\n+\t{\n+\t  ret.m_val = profile_probability::max_probability;\n+\t  ret.m_quality = profile_guessed;\n+\t  return ret;\n+\t}\n       else\n \tret.m_val = RDIV (m_val * profile_probability::max_probability,\n \t\t\t  overall.m_val);\n-      ret.m_quality = MAX (MIN (m_quality, overall.m_quality), profile_guessed);\n+      ret.m_quality = MIN (MAX (MIN (m_quality, overall.m_quality),\n+\t\t\t\tprofile_guessed), profile_adjusted);\n       return ret;\n     }\n "}, {"sha": "a687c3f28df9ea2212221029259b8f6e2b82ad69", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97c07987a6d8052c77125b5f9841abc1f937b3eb/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=97c07987a6d8052c77125b5f9841abc1f937b3eb", "patch": "@@ -1570,17 +1570,8 @@ replace_block_by (basic_block bb1, basic_block bb2)\n \t/* If probabilities are same, we are done.\n \t   If counts are nonzero we can distribute accordingly. In remaining\n \t   cases just avreage the values and hope for the best.  */\n-\tif (e1->probability == e2->probability)\n-\t  ;\n-\telse if (bb1->count.nonzero_p () || bb2->count.nonzero_p ())\n-\t  e2->probability\n-\t     = e2->probability\n-\t\t * bb2->count.probability_in (bb1->count + bb2->count)\n-\t       + e1->probability\n-\t\t * bb1->count.probability_in (bb1->count + bb2->count);\n-\telse\n-\t  e2->probability = e2->probability * profile_probability::even ()\n-\t\t\t    + e1->probability * profile_probability::even ();\n+\te2->probability = e1->probability.combine_with_count\n+\t                     (bb1->count, e2->probability, bb2->count);\n       }\n   bb2->count += bb1->count;\n "}]}