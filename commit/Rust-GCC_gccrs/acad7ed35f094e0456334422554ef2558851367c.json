{"sha": "acad7ed35f094e0456334422554ef2558851367c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNhZDdlZDM1ZjA5NGUwNDU2MzM0NDIyNTU0ZWYyNTU4ODUxMzY3Yw==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2000-05-25T18:17:46Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2000-05-25T18:17:46Z"}, "message": "rs6000.c (expand_block_move): Add 64-bit PowerPC doubleword move to STRING case.\n\n        * rs6000.c (expand_block_move): Add 64-bit PowerPC doubleword move\n        to STRING case.  Use doubleword STRING move for TARGET_POWERPC64\n        when unaligned.\n        * rs6000.h (CONST_OK_FOR_LETTER_P, 'J'): unsigned HOST_WIDE_INT.\n        (RETURN_ADDR_RTX): Use COUNT and FRAME, not count and frame.\n        (LEGITIMIZE_RELOAD_ADDRESS): unsigned HOST_WIDE_INT high.\n        * rs6000.md: Name various internal patterns.\n\nFrom-SVN: r34174", "tree": {"sha": "473b51170650223ff91b4b76281589dd4558a858", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/473b51170650223ff91b4b76281589dd4558a858"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acad7ed35f094e0456334422554ef2558851367c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acad7ed35f094e0456334422554ef2558851367c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acad7ed35f094e0456334422554ef2558851367c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acad7ed35f094e0456334422554ef2558851367c/comments", "author": null, "committer": null, "parents": [{"sha": "1098da33fe181bad25c9bd569bd5d9ae348e36fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1098da33fe181bad25c9bd569bd5d9ae348e36fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1098da33fe181bad25c9bd569bd5d9ae348e36fc"}], "stats": {"total": 65, "additions": 44, "deletions": 21}, "files": [{"sha": "8fdf38df4fdfa405dd87a6ddcef776afab117a6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad7ed35f094e0456334422554ef2558851367c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad7ed35f094e0456334422554ef2558851367c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=acad7ed35f094e0456334422554ef2558851367c", "patch": "@@ -1,3 +1,13 @@\n+2000-05-25  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* rs6000.c (expand_block_move): Add 64-bit PowerPC doubleword move\n+\tto STRING case.  Use doubleword STRING move for TARGET_POWERPC64\n+\twhen unaligned.\n+\t* rs6000.h (CONST_OK_FOR_LETTER_P, 'J'): unsigned HOST_WIDE_INT.\n+\t(RETURN_ADDR_RTX): Use COUNT and FRAME, not count and frame.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): unsigned HOST_WIDE_INT high.\n+\t* rs6000.md: Name various internal patterns.\n+\n 2000-05-25  Jan Hubicka  <jh@suse.cz>\n \n \t* jump.c (invert_exp_1): Remove first argument, use pc_set"}, {"sha": "f0ad8f3d5e6168452dd588a6136a0d10087b1983", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad7ed35f094e0456334422554ef2558851367c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad7ed35f094e0456334422554ef2558851367c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=acad7ed35f094e0456334422554ef2558851367c", "patch": "@@ -2369,7 +2369,20 @@ expand_block_move (operands)\n \t\t\t\t\t    GEN_INT (move_bytes),\n \t\t\t\t\t    align_rtx));\n \t    }\n-\t  else if (bytes > 4 && ! TARGET_POWERPC64)\n+\t  else if (bytes >= 8 && TARGET_POWERPC64\n+\t      /* 64-bit loads and stores require word-aligned displacements. */\n+\t      && (align >= 8 || (! STRICT_ALIGNMENT && align >= 4)))\n+\t    {\n+\t      move_bytes = 8;\n+\t      tmp_reg = gen_reg_rtx (DImode);\n+\t      emit_move_insn (tmp_reg,\n+\t\t\t      expand_block_move_mem (DImode,\n+\t\t\t\t\t\t     src_addr, orig_src));\n+\t      emit_move_insn (expand_block_move_mem (DImode,\n+\t\t\t\t\t\t     dest_addr, orig_dest),\n+\t\t\t      tmp_reg);\n+\t    }\n+\t  else if (bytes > 4)\n \t    {\t\t\t/* move up to 8 bytes at a time */\n \t      move_bytes = (bytes > 8) ? 8 : bytes;\n \t      emit_insn (gen_movstrsi_2reg (expand_block_move_mem (BLKmode,\n@@ -3000,7 +3013,7 @@ addrs_ok_for_quad_peep (addr1, addr2)\n       offset1 = 0;\n     }\n \n-  /* Make sure the second address is a (mem (plus (reg) (const_int).  */\n+  /* Make sure the second address is a (mem (plus (reg) (const_int))).  */\n   if (GET_CODE (addr2) != PLUS)\n     return 0;\n "}, {"sha": "87d01009036e7e87288ed67023c6d157cd75623d", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad7ed35f094e0456334422554ef2558851367c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad7ed35f094e0456334422554ef2558851367c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=acad7ed35f094e0456334422554ef2558851367c", "patch": "@@ -1056,7 +1056,7 @@ enum reg_class\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\t\\\n    ( (C) == 'I' ? (unsigned HOST_WIDE_INT) ((VALUE) + 0x8000) < 0x10000\t\\\n-   : (C) == 'J' ? ((VALUE) & (~ (HOST_WIDE_INT) 0xffff0000u)) == 0\t\\\n+   : (C) == 'J' ? ((VALUE) & (~ (unsigned HOST_WIDE_INT) 0xffff0000u)) == 0 \\\n    : (C) == 'K' ? ((VALUE) & (~ (HOST_WIDE_INT) 0xffff)) == 0\t\t\\\n    : (C) == 'L' ? (((VALUE) & 0xffff) == 0\t\t\t\t\\\n \t\t   && ((VALUE) >> 31 == -1 || (VALUE) >> 31 == 0))\t\\\n@@ -1622,16 +1622,16 @@ typedef struct rs6000_args\n /* The current return address is in link register (65).  The return address\n    of anything farther back is accessed normally at an offset of 8 from the\n    frame pointer.  */\n-#define RETURN_ADDR_RTX(count, frame)\t\t\t\\\n-  ((count == -1)\t\t\t\t\t\\\n+#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\\\n+  (((COUNT) == -1)\t\t\t\t\t\\\n    ? gen_rtx_REG (Pmode, LINK_REGISTER_REGNUM)\t\t\\\n    : gen_rtx_MEM (Pmode,\t\t\t\t\\\n \t\t  memory_address\t\t\t\\\n \t\t  (Pmode, \t\t\t\t\\\n \t\t   plus_constant (copy_to_reg\t\t\\\n \t\t\t\t  (gen_rtx_MEM (Pmode,\t\\\n \t\t\t\t\t\tmemory_address (Pmode, \\\n-\t\t\t\t\t\t\t\tframe))), \\\n+\t\t\t\t\t\t\t\t(FRAME)))), \\\n \t\t\t\t  RETURN_ADDRESS_OFFSET))))\n \f\n /* Definitions for register eliminations.\n@@ -1935,8 +1935,8 @@ do {                                                                    \\\n     {                                                                   \\\n       HOST_WIDE_INT val = INTVAL (XEXP (X, 1));                         \\\n       HOST_WIDE_INT low = ((val & 0xffff) ^ 0x8000) - 0x8000;           \\\n-      HOST_WIDE_INT high                                                \\\n-        = (((val - low) & 0xffffffffu) ^ 0x80000000u) - 0x80000000u;       \\\n+      unsigned HOST_WIDE_INT high                                       \\\n+        = (((val - low) & 0xffffffffu) ^ 0x80000000u) - 0x80000000u;    \\\n                                                                         \\\n       /* Check for 32-bit overflow.  */                                 \\\n       if (high + low != val)                                            \\"}, {"sha": "561762ccf7842ab5f632c7bd08f77e7eab06c09a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acad7ed35f094e0456334422554ef2558851367c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acad7ed35f094e0456334422554ef2558851367c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=acad7ed35f094e0456334422554ef2558851367c", "patch": "@@ -7552,7 +7552,7 @@\n     }\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movsi_internal1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n \t(match_operand:SI 1 \"input_operand\" \"r,U,m,r,I,L,n,R,*h,r,r,0\"))]\n   \"gpc_reg_operand (operands[0], SImode)\n@@ -7592,7 +7592,7 @@\n   operands[3] = GEN_INT (INTVAL (operands[1]) & 0xffff);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movsi_internal2\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t    (const_int 0)))\n@@ -8182,7 +8182,7 @@\n     }\n }\")\n \n-(define_insn \"*movdi_32\"\n+(define_insn \"*movdi_internal32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m,r,r,r,r,r\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,f,m,f,IJK,n,G,H,F\"))]\n   \"! TARGET_POWERPC64\n@@ -8264,7 +8264,7 @@\n   operands[5] = GEN_INT (CONST_DOUBLE_LOW  (operands[1]));\n }\")\n \n-(define_insn \"*movdi_64\"\n+(define_insn \"*movdi_internal64\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,r,f,f,m,r,*h,*h\")\n \t(match_operand:DI 1 \"input_operand\" \"r,m,r,I,L,nF,R,f,m,f,*h,r,0\"))]\n   \"TARGET_POWERPC64\n@@ -8494,7 +8494,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n #endif\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*movdi_internal2\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t    (const_int 0)))\n@@ -8505,7 +8505,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"4,8\")])\n-\f\n+\n (define_split\n   [(set (match_operand:CC 2 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n@@ -8517,7 +8517,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n-\n+\f\n ;; TImode is similar, except that we usually want to compute the address into\n ;; a register and use lsi/stsi (the exception is during reload).  MQ is also\n ;; clobbered in stsi for POWER, so we need a SCRATCH for it.\n@@ -10682,15 +10682,15 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n }\")\n \f\n ;; Here are the actual compare insns.\n-(define_insn \"\"\n+(define_insn \"*cmpsi_internal1\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CC (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t    (match_operand:SI 2 \"reg_or_short_operand\" \"rI\")))]\n   \"\"\n   \"{cmp%I2|cmpw%I2} %0,%1,%2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*cmpdi_internal1\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t    (match_operand:DI 2 \"reg_or_short_operand\" \"rI\")))]\n@@ -10726,15 +10726,15 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   operands[5] = GEN_INT (sextc);\n }\")\n \n-(define_insn \"\"\n+(define_insn \"*cmpsi_internal2\"\n   [(set (match_operand:CCUNS 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCUNS (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n \t\t       (match_operand:SI 2 \"reg_or_u_short_operand\" \"rK\")))]\n   \"\"\n   \"{cmpl%I2|cmplw%I2} %0,%1,%W2\"\n   [(set_attr \"type\" \"compare\")])\n \n-(define_insn \"\"\n+(define_insn \"*cmpdi_internal2\"\n   [(set (match_operand:CCUNS 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCUNS (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t       (match_operand:DI 2 \"reg_or_u_short_operand\" \"rK\")))]\n@@ -10787,15 +10787,15 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   [(set (match_dup 3) (compare:CCUNS (match_dup 1) (match_dup 2)))\n    (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 4)))])\n \n-(define_insn \"\"\n+(define_insn \"*cmpsf_internal1\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCFP (match_operand:SF 1 \"gpc_reg_operand\" \"f\")\n \t\t      (match_operand:SF 2 \"gpc_reg_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT\"\n   \"fcmpu %0,%1,%2\"\n   [(set_attr \"type\" \"fpcompare\")])\n \n-(define_insn \"\"\n+(define_insn \"*cmpdf_internal1\"\n   [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n \t(compare:CCFP (match_operand:DF 1 \"gpc_reg_operand\" \"f\")\n \t\t      (match_operand:DF 2 \"gpc_reg_operand\" \"f\")))]"}]}