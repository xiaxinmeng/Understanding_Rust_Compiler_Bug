{"sha": "f4088621a53c4c93304030178a4ff14b4fdb30db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwODg2MjFhNTNjNGM5MzMwNDAzMDE3OGE0ZmYxNGI0ZmRiMzBkYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-07-02T11:53:08Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-07-02T11:53:08Z"}, "message": "re PR middle-end/15988 (ICE in fold_convert with pointer-to-member-function)\n\n2007-07-02  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-flow.h (types_compatible_p): Declare.\n\t* tree-ssa.c (types_compatible_p): New function.\n\t* ipa-type-escape.c (discover_unique_type): Use\n\ttypes_compatible_p instead of lang_hooks.types_compatible_p.\n\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Likewise.\n\t* tree-vn.c (expressions_equal_p): Likewise.\n\t* tree.c (fields_compatible_p): Likewise.\n\t* tree-ssa-dom.c (avail_expr_eq): Likewise.\n\t(cprop_operand): Use useless_type_conversion_p instead of\n\tlang_hooks.types_compatible_p.\n\t* tree-inline.c (setup_one_parameter): Likewise.\n\t(declare_return_variable): Likewise.\n\t* tree-nrv.c (tree_nrv): Likewise.\n\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): Likewise.\n\t(maybe_fold_offset_to_component_ref): Likewise.\n\t(maybe_fold_offset_to_reference): Likewise.\n\t* tree-ssa-copy.c (may_propagate_copy): Likewise.\n\t(merge_alias_info): Likewise.\n\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n\t* tree-ssa-phiopt.c (conditional_replacement): Likewise.\n\t* tree-ssa-reassoc.c (optimize_ops_list): Likewise.\n\t* tree-tailcall.c (find_tail_calls): Likewise.\n\t* tree-vect-generic.c (expand_vector_operations_1): Likewise.\n\t* gimplify.c (canonicalize_addr_expr): Likewise.\n\t(fold_indirect_ref_rhs): Likewise.\n\t(gimplify_addr_expr): Likewise.  Swap parameters to cpt_same_type.\n\t(cpt_same_type): Likewise.\n\t(check_pointer_types_r): Swap parameters to cpt_same_type\n\twhere appropriate.\n\t* fold-const.c (fold_convert): Revert fix for PR15988.\n\t* tree-inline.c (setup_one_parameter): Instead fix it here by\n\tusing fold_build1 instead of fold_convert and checking for\n\terror_mark_node.  Convert only if the conversion is necessary.\n\nFrom-SVN: r126198", "tree": {"sha": "3d0ceb6622e9dd1148a3d0ed7aa630d1fae0d3e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d0ceb6622e9dd1148a3d0ed7aa630d1fae0d3e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4088621a53c4c93304030178a4ff14b4fdb30db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4088621a53c4c93304030178a4ff14b4fdb30db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4088621a53c4c93304030178a4ff14b4fdb30db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4088621a53c4c93304030178a4ff14b4fdb30db/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e51917ae365c16e909bf8ec4f9d3acb6e4d6fb31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e51917ae365c16e909bf8ec4f9d3acb6e4d6fb31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e51917ae365c16e909bf8ec4f9d3acb6e4d6fb31"}], "stats": {"total": 139, "additions": 96, "deletions": 43}, "files": [{"sha": "66176e1f2ad4e10d16060630363e9af4286f9c5f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -1,3 +1,39 @@\n+2007-07-02  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-flow.h (types_compatible_p): Declare.\n+\t* tree-ssa.c (types_compatible_p): New function.\n+\t* ipa-type-escape.c (discover_unique_type): Use\n+\ttypes_compatible_p instead of lang_hooks.types_compatible_p.\n+\t* tree-ssa-copyrename.c (copy_rename_partition_coalesce): Likewise.\n+\t* tree-vn.c (expressions_equal_p): Likewise.\n+\t* tree.c (fields_compatible_p): Likewise.\n+\t* tree-ssa-dom.c (avail_expr_eq): Likewise.\n+\t(cprop_operand): Use useless_type_conversion_p instead of\n+\tlang_hooks.types_compatible_p.\n+\t* tree-inline.c (setup_one_parameter): Likewise.\n+\t(declare_return_variable): Likewise.\n+\t* tree-nrv.c (tree_nrv): Likewise.\n+\t* tree-ssa-ccp.c (maybe_fold_offset_to_array_ref): Likewise.\n+\t(maybe_fold_offset_to_component_ref): Likewise.\n+\t(maybe_fold_offset_to_reference): Likewise.\n+\t* tree-ssa-copy.c (may_propagate_copy): Likewise.\n+\t(merge_alias_info): Likewise.\n+\t* tree-ssa-forwprop.c (forward_propagate_addr_expr_1): Likewise.\n+\t* tree-ssa-phiopt.c (conditional_replacement): Likewise.\n+\t* tree-ssa-reassoc.c (optimize_ops_list): Likewise.\n+\t* tree-tailcall.c (find_tail_calls): Likewise.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Likewise.\n+\t* gimplify.c (canonicalize_addr_expr): Likewise.\n+\t(fold_indirect_ref_rhs): Likewise.\n+\t(gimplify_addr_expr): Likewise.  Swap parameters to cpt_same_type.\n+\t(cpt_same_type): Likewise.\n+\t(check_pointer_types_r): Swap parameters to cpt_same_type\n+\twhere appropriate.\n+\t* fold-const.c (fold_convert): Revert fix for PR15988.\n+\t* tree-inline.c (setup_one_parameter): Instead fix it here by\n+\tusing fold_build1 instead of fold_convert and checking for\n+\terror_mark_node.  Convert only if the conversion is necessary.\n+\n 2007-07-02  Joseph Myers  <joseph@codesourcery.com>\n \n \t* configure.ac: Check for .gnu_attribute on Power."}, {"sha": "e69945fcba4076bd525daed455d43cabf68ff693", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -2262,9 +2262,7 @@ fold_convert (tree type, tree arg)\n       || TREE_CODE (orig) == ERROR_MARK)\n     return error_mark_node;\n \n-  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig)\n-      || lang_hooks.types_compatible_p (TYPE_MAIN_VARIANT (type),\n-\t\t\t\t\tTYPE_MAIN_VARIANT (orig)))\n+  if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (orig))\n     return fold_build1 (NOP_EXPR, type, arg);\n \n   switch (TREE_CODE (type))"}, {"sha": "5510f6008db6e34e174a3cd6a59eb90e445ef200", "filename": "gcc/gimplify.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -1599,13 +1599,13 @@ canonicalize_addr_expr (tree *expr_p)\n   /* Both cast and addr_expr types should address the same object type.  */\n   dctype = TREE_TYPE (ctype);\n   ddatype = TREE_TYPE (datype);\n-  if (!lang_hooks.types_compatible_p (ddatype, dctype))\n+  if (!useless_type_conversion_p (dctype, ddatype))\n     return;\n \n   /* The addr_expr and the object type should match.  */\n   obj_expr = TREE_OPERAND (addr_expr, 0);\n   otype = TREE_TYPE (obj_expr);\n-  if (!lang_hooks.types_compatible_p (otype, datype))\n+  if (!useless_type_conversion_p (datype, otype))\n     return;\n \n   /* The lower bound and element sizes must be constant.  */\n@@ -3304,11 +3304,11 @@ fold_indirect_ref_rhs (tree t)\n       tree op = TREE_OPERAND (sub, 0);\n       tree optype = TREE_TYPE (op);\n       /* *&p => p */\n-      if (lang_hooks.types_compatible_p (type, optype))\n+      if (useless_type_conversion_p (type, optype))\n         return op;\n       /* *(foo *)&fooarray => fooarray[0] */\n       else if (TREE_CODE (optype) == ARRAY_TYPE\n-\t       && lang_hooks.types_compatible_p (type, TREE_TYPE (optype)))\n+\t       && useless_type_conversion_p (type, TREE_TYPE (optype)))\n        {\n          tree type_domain = TYPE_DOMAIN (optype);\n          tree min_val = size_zero_node;\n@@ -3320,7 +3320,7 @@ fold_indirect_ref_rhs (tree t)\n \n   /* *(foo *)fooarrptr => (*fooarrptr)[0] */\n   if (TREE_CODE (TREE_TYPE (subtype)) == ARRAY_TYPE\n-      && lang_hooks.types_compatible_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n+      && useless_type_conversion_p (type, TREE_TYPE (TREE_TYPE (subtype))))\n     {\n       tree type_domain;\n       tree min_val = size_zero_node;\n@@ -3974,14 +3974,15 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \ttree t_expr = TREE_TYPE (expr);\n \ttree t_op00 = TREE_TYPE (op00);\n \n-        if (!lang_hooks.types_compatible_p (t_expr, t_op00))\n+        if (!useless_type_conversion_p (t_expr, t_op00))\n \t  {\n #ifdef ENABLE_CHECKING\n \t    tree t_op0 = TREE_TYPE (op0);\n \t    gcc_assert (POINTER_TYPE_P (t_expr)\n-\t\t\t&& cpt_same_type (TREE_CODE (t_op0) == ARRAY_TYPE\n-\t\t\t\t\t  ? TREE_TYPE (t_op0) : t_op0,\n-\t\t\t\t\t  TREE_TYPE (t_expr))\n+\t\t\t&& (cpt_same_type (TREE_TYPE (t_expr), t_op0)\n+\t\t\t    || (TREE_CODE (t_op0) == ARRAY_TYPE\n+\t\t\t\t&& cpt_same_type (TREE_TYPE (t_expr),\n+\t\t\t\t\t\t  TREE_TYPE (t_op0))))\n \t\t\t&& POINTER_TYPE_P (t_op00)\n \t\t\t&& cpt_same_type (t_op0, TREE_TYPE (t_op00)));\n #endif\n@@ -6385,7 +6386,7 @@ gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n static bool\n cpt_same_type (tree a, tree b)\n {\n-  if (lang_hooks.types_compatible_p (a, b))\n+  if (useless_type_conversion_p (a, b))\n     return true;\n \n   /* ??? The C++ FE decomposes METHOD_TYPES to FUNCTION_TYPES and doesn't\n@@ -6436,15 +6437,15 @@ check_pointer_types_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n       ptype = TREE_TYPE (t);\n       otype = TREE_TYPE (TREE_OPERAND (t, 0));\n       dtype = TREE_TYPE (ptype);\n-      if (!cpt_same_type (otype, dtype))\n+      if (!cpt_same_type (dtype, otype))\n \t{\n \t  /* &array is allowed to produce a pointer to the element, rather than\n \t     a pointer to the array type.  We must allow this in order to\n \t     properly represent assigning the address of an array in C into\n \t     pointer to the element type.  */\n \t  gcc_assert (TREE_CODE (otype) == ARRAY_TYPE\n \t\t      && POINTER_TYPE_P (ptype)\n-\t\t      && cpt_same_type (TREE_TYPE (otype), dtype));\n+\t\t      && cpt_same_type (dtype, TREE_TYPE (otype)));\n \t  break;\n \t}\n       break;"}, {"sha": "d9d464d624230a20ccd2c1b6c88448e29e92c693", "filename": "gcc/ipa-type-escape.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Fipa-type-escape.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Fipa-type-escape.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-type-escape.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -219,7 +219,7 @@ discover_unique_type (tree type)\n \t  /* Create an alias since this is just the same as\n \t     other_type.  */\n \t  tree other_type = (tree) result->value;\n-\t  if (lang_hooks.types_compatible_p (type, other_type) == 1)\n+\t  if (types_compatible_p (type, other_type))\n \t    {\n \t      free (brand);\n \t      /* Insert this new type as an alias for other_type.  */"}, {"sha": "542f5f85f3d56c82e571f97b7c4d0e4f160276c8", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -869,6 +869,7 @@ extern edge ssa_redirect_edge (edge, basic_block);\n extern void flush_pending_stmts (edge);\n extern bool tree_ssa_useless_type_conversion (tree);\n extern bool useless_type_conversion_p (tree, tree);\n+extern bool types_compatible_p (tree, tree);\n extern void verify_ssa (bool);\n extern void delete_tree_ssa (void);\n extern void walk_use_def_chains (tree, walk_use_def_chains_fn, void *, bool);"}, {"sha": "244b5b075593583ad96195314ea430464ae66ac1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -1278,10 +1278,15 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n   tree init_stmt;\n   tree var;\n   tree var_sub;\n-  tree rhs = value ? fold_convert (TREE_TYPE (p), value) : NULL;\n+  tree rhs = value;\n   tree def = (gimple_in_ssa_p (cfun)\n \t      ? gimple_default_def (id->src_cfun, p) : NULL);\n \n+  if (value\n+      && value != error_mark_node\n+      && !useless_type_conversion_p (TREE_TYPE (p), TREE_TYPE (value)))\n+    rhs = fold_build1 (NOP_EXPR, TREE_TYPE (p), value);\n+\n   /* If the parameter is never assigned to, has no SSA_NAMEs created,\n      we may not need to create a new variable here at all.  Instead, we may\n      be able to just use the argument value.  */\n@@ -1295,7 +1300,8 @@ setup_one_parameter (copy_body_data *id, tree p, tree value, tree fn,\n \t It is not big deal to prohibit constant propagation here as\n \t we will constant propagate in DOM1 pass anyway.  */\n       if (is_gimple_min_invariant (value)\n-\t  && lang_hooks.types_compatible_p (TREE_TYPE (value), TREE_TYPE (p))\n+\t  && useless_type_conversion_p (TREE_TYPE (p),\n+\t\t\t\t\t\t TREE_TYPE (value))\n \t  /* We have to be very careful about ADDR_EXPR.  Make sure\n \t     the base variable isn't a local variable of the inlined\n \t     function, e.g., when doing recursive inlining, direct or\n@@ -1573,7 +1579,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n       bool use_it = false;\n \n       /* We can't use MODIFY_DEST if there's type promotion involved.  */\n-      if (!lang_hooks.types_compatible_p (caller_type, callee_type))\n+      if (!useless_type_conversion_p (callee_type, caller_type))\n \tuse_it = false;\n \n       /* ??? If we're assigning to a variable sized type, then we must\n@@ -1637,7 +1643,7 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n   /* Build the use expr.  If the return type of the function was\n      promoted, convert it back to the expected type.  */\n   use = var;\n-  if (!lang_hooks.types_compatible_p (TREE_TYPE (var), caller_type))\n+  if (!useless_type_conversion_p (caller_type, TREE_TYPE (var)))\n     use = fold_convert (caller_type, var);\n     \n   STRIP_USELESS_TYPE_CONVERSION (use);"}, {"sha": "5a0db8972522f7552cbdd664b1d88d8f2e84aab3", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -159,8 +159,8 @@ tree_nrv (void)\n \t\t  || TREE_STATIC (found)\n \t\t  || TREE_ADDRESSABLE (found)\n \t\t  || DECL_ALIGN (found) > DECL_ALIGN (result)\n-\t\t  || !lang_hooks.types_compatible_p (TREE_TYPE (found), \n-\t\t\t\t\t\t     result_type))\n+\t\t  || !useless_type_conversion_p (result_type,\n+\t\t\t\t\t        TREE_TYPE (found)))\n \t\treturn 0;\n \t    }\n \t  else if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT)"}, {"sha": "272a4f857414a25e9fab1242ac47d5ed829d67e1", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -1575,7 +1575,7 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n   if (TREE_CODE (array_type) != ARRAY_TYPE)\n     return NULL_TREE;\n   elt_type = TREE_TYPE (array_type);\n-  if (!lang_hooks.types_compatible_p (orig_type, elt_type))\n+  if (!useless_type_conversion_p (orig_type, elt_type))\n     return NULL_TREE;\n \n   /* Use signed size type for intermediate computation on the index.  */\n@@ -1666,7 +1666,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n     return NULL_TREE;\n \n   /* Short-circuit silly cases.  */\n-  if (lang_hooks.types_compatible_p (record_type, orig_type))\n+  if (useless_type_conversion_p (record_type, orig_type))\n     return NULL_TREE;\n \n   tail_array_field = NULL_TREE;\n@@ -1704,7 +1704,7 @@ maybe_fold_offset_to_component_ref (tree record_type, tree base, tree offset,\n       /* Here we exactly match the offset being checked.  If the types match,\n \t then we can return that field.  */\n       if (cmp == 0\n-\t  && lang_hooks.types_compatible_p (orig_type, field_type))\n+\t  && useless_type_conversion_p (orig_type, field_type))\n \t{\n \t  if (base_is_ptr)\n \t    base = build1 (INDIRECT_REF, record_type, base);\n@@ -1809,7 +1809,7 @@ maybe_fold_offset_to_reference (tree base, tree offset, tree orig_type)\n \t\t\t\t\t  sub_offset / BITS_PER_UNIT), 1);\n \t    }\n \t}\n-      if (lang_hooks.types_compatible_p (orig_type, TREE_TYPE (base))\n+      if (useless_type_conversion_p (orig_type, TREE_TYPE (base))\n \t  && integer_zerop (offset))\n \treturn base;\n       type = TREE_TYPE (base);"}, {"sha": "e791459f2d3b7c6c77463663257f5a1d5843e822", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -130,7 +130,7 @@ may_propagate_copy (tree dest, tree orig)\n       tree mt_orig = symbol_mem_tag (SSA_NAME_VAR (orig));\n       if (mt_dest && mt_orig && mt_dest != mt_orig)\n \treturn false;\n-      else if (!lang_hooks.types_compatible_p (type_d, type_o))\n+      else if (!useless_type_conversion_p (type_d, type_o))\n \treturn false;\n       else if (get_alias_set (TREE_TYPE (type_d)) != \n \t       get_alias_set (TREE_TYPE (type_o)))\n@@ -222,8 +222,8 @@ merge_alias_info (tree orig_name, tree new_name)\n   gcc_assert (POINTER_TYPE_P (TREE_TYPE (new_name)));\n \n #if defined ENABLE_CHECKING\n-  gcc_assert (lang_hooks.types_compatible_p (TREE_TYPE (orig_name),\n-\t\t\t\t\t     TREE_TYPE (new_name)));\n+  gcc_assert (useless_type_conversion_p (TREE_TYPE (orig_name),\n+\t\t\t\t\tTREE_TYPE (new_name)));\n \n   /* If the pointed-to alias sets are different, these two pointers\n      would never have the same memory tag.  In this case, NEW should"}, {"sha": "812ebe195089b5db1af563c0d1e3b1932d90327e", "filename": "gcc/tree-ssa-copyrename.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-copyrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-copyrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copyrename.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -240,7 +240,7 @@ copy_rename_partition_coalesce (var_map map, tree var1, tree var2, FILE *debug)\n     }\n \n   /* Don't coalesce if the two variables aren't type compatible.  */\n-  if (!lang_hooks.types_compatible_p (TREE_TYPE (root1), TREE_TYPE (root2)))\n+  if (!types_compatible_p (TREE_TYPE (root1), TREE_TYPE (root2)))\n     {\n       if (debug)\n \tfprintf (debug, \" : Incompatible types.  No coalesce.\\n\");"}, {"sha": "b0bfbba882a0dbc65a5d8d28963811f2007cb33e", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -1680,7 +1680,7 @@ cprop_operand (tree stmt, use_operand_p op_p)\n \t propagation opportunity.  */\n       if (TREE_CODE (val) != SSA_NAME)\n \t{\n-\t  if (!lang_hooks.types_compatible_p (op_type, val_type))\n+\t  if (!useless_type_conversion_p (op_type, val_type))\n \t    {\n \t      val = fold_convert (TREE_TYPE (op), val);\n \t      if (!is_gimple_min_invariant (val))\n@@ -2048,8 +2048,7 @@ avail_expr_eq (const void *p1, const void *p2)\n \n   /* In case of a collision, both RHS have to be identical and have the\n      same VUSE operands.  */\n-  if ((TREE_TYPE (rhs1) == TREE_TYPE (rhs2)\n-       || lang_hooks.types_compatible_p (TREE_TYPE (rhs1), TREE_TYPE (rhs2)))\n+  if (types_compatible_p (TREE_TYPE (rhs1), TREE_TYPE (rhs2))\n       && operand_equal_p (rhs1, rhs2, OEP_PURE_SAME))\n     {\n       bool ret = compare_ssa_operands_equal (stmt1, stmt2, SSA_OP_VUSE);"}, {"sha": "effa93dd0cf467f7a61a6cac0e9650dfbbcdbc40", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -670,7 +670,7 @@ forward_propagate_addr_expr_1 (tree name, tree def_rhs, tree use_stmt,\n       && TREE_CODE (TREE_OPERAND (rhs, 1)) == SSA_NAME\n       /* Avoid problems with IVopts creating PLUS_EXPRs with a\n \t different type than their operands.  */\n-      && lang_hooks.types_compatible_p (TREE_TYPE (name), TREE_TYPE (rhs)))\n+      && useless_type_conversion_p (TREE_TYPE (rhs), TREE_TYPE (name)))\n     {\n       bool res;\n       "}, {"sha": "8e91cc23865bc540ec9e3264f0dd0c61768ba977", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -401,7 +401,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n   cond = COND_EXPR_COND (last_stmt (cond_bb));\n   result = PHI_RESULT (phi);\n   if (TREE_CODE (cond) != SSA_NAME\n-      && !lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n+      && !useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (cond)))\n     {\n       tree tmp;\n \n@@ -418,7 +418,7 @@ conditional_replacement (basic_block cond_bb, basic_block middle_bb,\n   /* If the condition was a naked SSA_NAME and the type is not the\n      same as the type of the result, then convert the type of the\n      condition.  */\n-  if (!lang_hooks.types_compatible_p (TREE_TYPE (cond), TREE_TYPE (result)))\n+  if (!useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (cond)))\n     cond = fold_convert (TREE_TYPE (result), cond);\n \n   /* We need to know which is the true edge and which is the false"}, {"sha": "448107b2d720cd5e5ff9275151b3c3bd1c52b20a", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -727,8 +727,8 @@ optimize_ops_list (enum tree_code opcode,\n \n       if (oelm1->rank == 0\n \t  && is_gimple_min_invariant (oelm1->op)\n-\t  && lang_hooks.types_compatible_p (TREE_TYPE (oelm1->op),\n-\t\t\t\t\t    TREE_TYPE (oelast->op)))\n+\t  && useless_type_conversion_p (TREE_TYPE (oelm1->op),\n+\t\t\t\t       TREE_TYPE (oelast->op)))\n \t{\n \t  tree folded = fold_binary (opcode, TREE_TYPE (oelm1->op),\n \t\t\t\t     oelm1->op, oelast->op);"}, {"sha": "9e7160606e320833a2c68f1629d89739baf9eb61", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -971,6 +971,17 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n   return false;\n }\n \n+/* Return true if a conversion from either type of TYPE1 and TYPE2\n+   to the other is not required.  Otherwise return false.  */\n+\n+bool\n+types_compatible_p (tree type1, tree type2)\n+{\n+  return (type1 == type2\n+\t  || (useless_type_conversion_p (type1, type2)\n+\t      && useless_type_conversion_p (type2, type1)));\n+}\n+\n /* Return true if EXPR is a useless type conversion, otherwise return\n    false.  */\n "}, {"sha": "135cf1ed78c498bf9cab392ffe92d03028987437", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -448,8 +448,8 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \t         equivalent types.  The latter requirement could be relaxed if\n \t         we emitted a suitable type conversion statement.  */\n \t      if (!is_gimple_reg_type (TREE_TYPE (param))\n-\t\t  || !lang_hooks.types_compatible_p (TREE_TYPE (param),\n-\t\t\t\t\t\t     TREE_TYPE (arg)))\n+\t\t  || !useless_type_conversion_p (TREE_TYPE (param),\n+\t\t\t\t\t        TREE_TYPE (arg)))\n \t\tbreak;\n \n \t      /* The parameter should be a real operand, so that phi node"}, {"sha": "582998916e143f3f5e9c1e474a2b7710b4f355fe", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -469,7 +469,7 @@ expand_vector_operations_1 (block_stmt_iterator *bsi)\n \n   gcc_assert (code != VEC_LSHIFT_EXPR && code != VEC_RSHIFT_EXPR);\n   rhs = expand_vector_operation (bsi, type, compute_type, rhs, code);\n-  if (lang_hooks.types_compatible_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+  if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n     *p_rhs = rhs;\n   else\n     *p_rhs = gimplify_build1 (bsi, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);"}, {"sha": "d62aeea9398664022dc44ef0f6e50e86f6bca55a", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -84,7 +84,8 @@ expressions_equal_p (tree e1, tree e2)\n \n     }\n   else if (TREE_CODE (e1) == TREE_CODE (e2) \n-\t   && (te1 == te2 || lang_hooks.types_compatible_p (te1, te2))\n+\t   && (te1 == te2\n+\t       || types_compatible_p (te1, te2))\n \t   && operand_equal_p (e1, e2, OEP_PURE_SAME))\n     return true;\n "}, {"sha": "72a2593ee5f32ad9ed78fbf5bcfadf6742bf26bc", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4088621a53c4c93304030178a4ff14b4fdb30db/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=f4088621a53c4c93304030178a4ff14b4fdb30db", "patch": "@@ -7714,7 +7714,7 @@ fields_compatible_p (tree f1, tree f2)\n                         DECL_FIELD_OFFSET (f2), OEP_ONLY_CONST))\n     return false;\n \n-  if (!lang_hooks.types_compatible_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n+  if (!types_compatible_p (TREE_TYPE (f1), TREE_TYPE (f2)))\n     return false;\n \n   return true;"}]}