{"sha": "957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTU3ZjBkOGZhZjQxZDY0ZmE0YmE1NDg0MTFlNmQ0ZGQ5NWEwODNiZg==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-10-18T16:04:16Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-10-18T16:04:16Z"}, "message": "tree-loop-distribution.c (INCLUDE_ALGORITHM): New header file.\n\n\t* tree-loop-distribution.c (INCLUDE_ALGORITHM): New header file.\n\t(tree-ssa-loop-ivopts.h): New header file.\n\t(struct builtin_info): New fields.\n\t(classify_builtin_1): Compute and record base and offset parts for\n\tmemset builtin partition by calling strip_offset.\n\t(offset_cmp, fuse_memset_builtins): New functions.\n\t(finalize_partitions): Fuse adjacent memset partitions by calling\n\tabove function.\n\t* tree-ssa-loop-ivopts.c (strip_offset): Delete static declaration.\n\tExpose the interface.\n\t* tree-ssa-loop-ivopts.h (strip_offset): New declaration.\n\n\t* gcc.dg/tree-ssa/ldist-17.c: Adjust test string.\n\t* gcc.dg/tree-ssa/ldist-32.c: New test.\n\t* gcc.dg/tree-ssa/ldist-35.c: New test.\n\t* gcc.dg/tree-ssa/ldist-36.c: New test.\n\nFrom-SVN: r253859", "tree": {"sha": "131565bc95410d1201c4c1be486f24340fcb7924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/131565bc95410d1201c4c1be486f24340fcb7924"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/comments", "author": null, "committer": null, "parents": [{"sha": "85aa9ed64bf871b2e620211609855804e1775864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85aa9ed64bf871b2e620211609855804e1775864", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85aa9ed64bf871b2e620211609855804e1775864"}], "stats": {"total": 239, "additions": 232, "deletions": 7}, "files": [{"sha": "8e056f249cb8a594e67925d9f744303b0cad96e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -1,3 +1,17 @@\n+2017-10-18  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (INCLUDE_ALGORITHM): New header file.\n+\t(tree-ssa-loop-ivopts.h): New header file.\n+\t(struct builtin_info): New fields.\n+\t(classify_builtin_1): Compute and record base and offset parts for\n+\tmemset builtin partition by calling strip_offset.\n+\t(offset_cmp, fuse_memset_builtins): New functions.\n+\t(finalize_partitions): Fuse adjacent memset partitions by calling\n+\tabove function.\n+\t* tree-ssa-loop-ivopts.c (strip_offset): Delete static declaration.\n+\tExpose the interface.\n+\t* tree-ssa-loop-ivopts.h (strip_offset): New declaration.\n+\n 2017-10-18  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82574"}, {"sha": "ee05077ecf09418605e0b0af46316daaa1b176b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -1,3 +1,10 @@\n+2017-10-18  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/ldist-17.c: Adjust test string.\n+\t* gcc.dg/tree-ssa/ldist-32.c: New test.\n+\t* gcc.dg/tree-ssa/ldist-35.c: New test.\n+\t* gcc.dg/tree-ssa/ldist-36.c: New test.\n+\n 2017-10-18  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/82574"}, {"sha": "b3617f685a1dcf349c5299198ee822e6a2de05f6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-17.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-17.c?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -45,5 +45,5 @@ mad_synth_mute (struct mad_synth *synth)\n   return;\n }\n \n-/* { dg-final { scan-tree-dump \"distributed: split to 0 loops and 4 library calls\" \"ldist\" } } */\n-/* { dg-final { scan-tree-dump-times \"generated memset zero\" 4 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump \"Loop nest . distributed: split to 0 loops and 1 library calls\" \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"generated memset zero\" 1 \"ldist\" } } */"}, {"sha": "477d222fb3b75b70db0e0336677c25fbcf79c8fc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-32.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-32.c?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+#define M (256)\n+#define N (512)\n+\n+struct st\n+{\n+  int a[M][N];\n+  int c[M];\n+  int b[M][N];\n+};\n+\n+void\n+foo (struct st *p)\n+{\n+  for (unsigned i = 0; i < M; ++i)\n+    {\n+      p->c[i] = 0;\n+      for (unsigned j = N; j > 0; --j)\n+\t{\n+\t  p->a[i][j - 1] = 0;\n+\t  p->b[i][j - 1] = 0;\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop nest . distributed: split to 0 loops and 1 library\" 1 \"ldist\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin_memset \\\\(.*, 0, 1049600\\\\);\" 1 \"ldist\" } } */"}, {"sha": "445d23d114b0ae6f546ed4a3c93a3a6563fea04d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-35.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-35.c?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+#define M (256)\n+#define N (512)\n+\n+struct st\n+{\n+  int a[M][N];\n+  int c[M];\n+  int b[M][N];\n+};\n+\n+void\n+foo (struct st * restrict p, struct st * restrict q)\n+{\n+  for (unsigned i = 0; i < M; ++i)\n+    {\n+      p->c[i] = 0;\n+      for (unsigned j = N; j > 0; --j)\n+\t{\n+\t  p->a[i][j - 1] = q->a[i][j - 1];\n+\t  p->b[i][j - 1] = 0;\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop nest . distributed: split to 0 loops and 1 library\" 1 \"ldist\" { xfail *-*-* } } } */"}, {"sha": "0e843f4dd5514d1de8a1c36dfdf335353ed4a727", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-36.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-36.c?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -ftree-loop-distribute-patterns -fdump-tree-ldist-details\" } */\n+\n+#define M (256)\n+#define N (512)\n+\n+struct st\n+{\n+  int a[M][N];\n+  int c[M];\n+  int b[M][N];\n+};\n+\n+void\n+foo (struct st * restrict p)\n+{\n+  for (unsigned i = 0; i < M; ++i)\n+    {\n+      p->c[i] = 0;\n+      for (unsigned j = N; j > 0; --j)\n+\t{\n+\t  p->b[i][j - 1] = p->a[i][j - 1];\n+\t  p->a[i][j - 1] = 0;\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Loop nest . distributed: split to 0 loops and 3 library\" 1 \"ldist\" } } */"}, {"sha": "52db3c94bd9563d89a1ea65e5e621d59065b8f8c", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -90,6 +90,7 @@ along with GCC; see the file COPYING3.  If not see\n \tdata reuse.  */\n \n #include \"config.h\"\n+#define INCLUDE_ALGORITHM /* stable_sort */\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n@@ -106,6 +107,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stor-layout.h\"\n #include \"tree-cfg.h\"\n #include \"tree-ssa-loop-manip.h\"\n+#include \"tree-ssa-loop-ivopts.h\"\n #include \"tree-ssa-loop.h\"\n #include \"tree-into-ssa.h\"\n #include \"tree-ssa.h\"\n@@ -604,6 +606,10 @@ struct builtin_info\n   tree dst_base;\n   tree src_base;\n   tree size;\n+  /* Base and offset part of dst_base after stripping constant offset.  This\n+     is only used in memset builtin distribution for now.  */\n+  tree dst_base_base;\n+  unsigned HOST_WIDE_INT dst_base_offset;\n };\n \n /* Partition for loop distribution.  */\n@@ -1504,7 +1510,11 @@ classify_builtin_st (loop_p loop, partition *partition, data_reference_p dr)\n   if (!compute_access_range (loop, dr, &base, &size))\n     return;\n \n-  partition->builtin = alloc_builtin (dr, NULL, base, NULL_TREE, size);\n+  struct builtin_info *builtin;\n+  builtin = alloc_builtin (dr, NULL, base, NULL_TREE, size);\n+  builtin->dst_base_base = strip_offset (builtin->dst_base,\n+\t\t\t\t\t &builtin->dst_base_offset);\n+  partition->builtin = builtin;\n   partition->kind = PKIND_MEMSET;\n }\n \n@@ -2480,6 +2490,113 @@ version_for_distribution_p (vec<struct partition *> *partitions,\n   return (alias_ddrs->length () > 0);\n }\n \n+/* Compare base offset of builtin mem* partitions P1 and P2.  */\n+\n+static bool\n+offset_cmp (struct partition *p1, struct partition *p2)\n+{\n+  gcc_assert (p1 != NULL && p1->builtin != NULL);\n+  gcc_assert (p2 != NULL && p2->builtin != NULL);\n+  return p1->builtin->dst_base_offset < p2->builtin->dst_base_offset;\n+}\n+\n+/* Fuse adjacent memset builtin PARTITIONS if possible.  This is a special\n+   case optimization transforming below code:\n+\n+     __builtin_memset (&obj, 0, 100);\n+     _1 = &obj + 100;\n+     __builtin_memset (_1, 0, 200);\n+     _2 = &obj + 300;\n+     __builtin_memset (_2, 0, 100);\n+\n+   into:\n+\n+     __builtin_memset (&obj, 0, 400);\n+\n+   Note we don't have dependence information between different partitions\n+   at this point, as a result, we can't handle nonadjacent memset builtin\n+   partitions since dependence might be broken.  */\n+\n+static void\n+fuse_memset_builtins (vec<struct partition *> *partitions)\n+{\n+  unsigned i, j;\n+  struct partition *part1, *part2;\n+\n+  for (i = 0; partitions->iterate (i, &part1);)\n+    {\n+      if (part1->kind != PKIND_MEMSET)\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+\n+      /* Find sub-array of memset builtins of the same base.  Index range\n+\t of the sub-array is [i, j) with \"j > i\".  */\n+      for (j = i + 1; partitions->iterate (j, &part2); ++j)\n+\t{\n+\t  if (part2->kind != PKIND_MEMSET\n+\t      || !operand_equal_p (part1->builtin->dst_base_base,\n+\t\t\t\t   part2->builtin->dst_base_base, 0))\n+\t    break;\n+\t}\n+\n+      /* Stable sort is required in order to avoid breaking dependence.  */\n+      std::stable_sort (&(*partitions)[i],\n+\t\t\t&(*partitions)[i] + j - i, offset_cmp);\n+      /* Continue with next partition.  */\n+      i = j;\n+    }\n+\n+  /* Merge all consecutive memset builtin partitions.  */\n+  for (i = 0; i < partitions->length () - 1;)\n+    {\n+      part1 = (*partitions)[i];\n+      if (part1->kind != PKIND_MEMSET)\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+\n+      part2 = (*partitions)[i + 1];\n+      /* Only merge memset partitions of the same base and with constant\n+\t access sizes.  */\n+      if (part2->kind != PKIND_MEMSET\n+\t  || TREE_CODE (part1->builtin->size) != INTEGER_CST\n+\t  || TREE_CODE (part2->builtin->size) != INTEGER_CST\n+\t  || !operand_equal_p (part1->builtin->dst_base_base,\n+\t\t\t       part2->builtin->dst_base_base, 0))\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      tree rhs1 = gimple_assign_rhs1 (DR_STMT (part1->builtin->dst_dr));\n+      tree rhs2 = gimple_assign_rhs1 (DR_STMT (part2->builtin->dst_dr));\n+      int bytev1 = const_with_all_bytes_same (rhs1);\n+      int bytev2 = const_with_all_bytes_same (rhs2);\n+      /* Only merge memset partitions of the same value.  */\n+      if (bytev1 != bytev2 || bytev1 == -1)\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      wide_int end1 = wi::add (part1->builtin->dst_base_offset,\n+\t\t\t       wi::to_wide (part1->builtin->size));\n+      /* Only merge adjacent memset partitions.  */\n+      if (wi::ne_p (end1, part2->builtin->dst_base_offset))\n+\t{\n+\t  i++;\n+\t  continue;\n+\t}\n+      /* Merge partitions[i] and partitions[i+1].  */\n+      part1->builtin->size = fold_build2 (PLUS_EXPR, sizetype,\n+\t\t\t\t\t  part1->builtin->size,\n+\t\t\t\t\t  part2->builtin->size);\n+      partition_free (part2);\n+      partitions->ordered_remove (i + 1);\n+    }\n+}\n+\n /* Fuse PARTITIONS of LOOP if necessary before finalizing distribution.\n    ALIAS_DDRS contains ddrs which need runtime alias check.  */\n \n@@ -2523,6 +2640,10 @@ finalize_partitions (struct loop *loop, vec<struct partition *> *partitions,\n \t}\n       partitions->truncate (1);\n     }\n+\n+  /* Fuse memset builtins if possible.  */\n+  if (partitions->length () > 1)\n+    fuse_memset_builtins (partitions);\n }\n \n /* Distributes the code from LOOP in such a way that producer statements"}, {"sha": "793e66fa616dc21f9c4afa3fff9331dbc705a40c", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -1550,9 +1550,6 @@ record_invariant (struct ivopts_data *data, tree op, bool nonlinear_use)\n   bitmap_set_bit (data->relevant, SSA_NAME_VERSION (op));\n }\n \n-static tree\n-strip_offset (tree expr, unsigned HOST_WIDE_INT *offset);\n-\n /* Record a group of TYPE.  */\n \n static struct iv_group *\n@@ -2863,7 +2860,7 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n \n /* Strips constant offsets from EXPR and stores them to OFFSET.  */\n \n-static tree\n+tree\n strip_offset (tree expr, unsigned HOST_WIDE_INT *offset)\n {\n   HOST_WIDE_INT off;"}, {"sha": "bd9205138c4b089e536fb6fef771e07af6f9ded9", "filename": "gcc/tree-ssa-loop-ivopts.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftree-ssa-loop-ivopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/957f0d8faf41d64fa4ba548411e6d4dd95a083bf/gcc%2Ftree-ssa-loop-ivopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.h?ref=957f0d8faf41d64fa4ba548411e6d4dd95a083bf", "patch": "@@ -28,6 +28,7 @@ extern void dump_cand (FILE *, struct iv_cand *);\n extern bool contains_abnormal_ssa_name_p (tree);\n extern struct loop *outermost_invariant_loop_for_expr (struct loop *, tree);\n extern bool expr_invariant_in_loop_p (struct loop *, tree);\n+extern tree strip_offset (tree, unsigned HOST_WIDE_INT *);\n bool may_be_nonaddressable_p (tree expr);\n void tree_ssa_iv_optimize (void);\n "}]}