{"sha": "692aefcd5618a00e622a1c96957d943723040b4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyYWVmY2Q1NjE4YTAwZTYyMmExYzk2OTU3ZDk0MzcyMzA0MGI0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-10T05:26:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-01-10T05:26:29Z"}, "message": "runtime: work around escaping closure in export_test.go\n    \n    When compiling runtime, it is not allowed for local variables\n    and closures to be heap allocated. In one test, there is a go\n    statement with a closure. In the gc compiler, it distinguishes\n    capturing variable by value vs. by address, and rewrites it to\n    passing the captured values as arguments. Currently we don't\n    have this, and the escape analysis decides to heap allocate the\n    closure and also the captured variables, which is not allowed.\n    Work around it by passing the variables explicitly.\n    \n    This is in preparation of turning on escape analysis for the\n    runtime.\n    \n    Reviewed-on: https://go-review.googlesource.com/86245\n\nFrom-SVN: r256419", "tree": {"sha": "ae7606fee60c2a35f1f871e4356eb9e02c1b4078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae7606fee60c2a35f1f871e4356eb9e02c1b4078"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/692aefcd5618a00e622a1c96957d943723040b4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692aefcd5618a00e622a1c96957d943723040b4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692aefcd5618a00e622a1c96957d943723040b4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692aefcd5618a00e622a1c96957d943723040b4c/comments", "author": null, "committer": null, "parents": [{"sha": "e4876be5f5c5524ea742527100e36c5095181b28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4876be5f5c5524ea742527100e36c5095181b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4876be5f5c5524ea742527100e36c5095181b28"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "18c23cf86fb3a175274b429aeb9459fee9007ac7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692aefcd5618a00e622a1c96957d943723040b4c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692aefcd5618a00e622a1c96957d943723040b4c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=692aefcd5618a00e622a1c96957d943723040b4c", "patch": "@@ -1,4 +1,4 @@\n-5cae6a4e0849a3586ee7ce9c915c1520a17db982\n+c18c6bd80e0995827ad3396eb1c2401451de88fd\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5e798e3e3a3c6d0225dfff8eee1c13d90c7673f1", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692aefcd5618a00e622a1c96957d943723040b4c/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692aefcd5618a00e622a1c96957d943723040b4c/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=692aefcd5618a00e622a1c96957d943723040b4c", "patch": "@@ -123,29 +123,29 @@ func RunSchedLocalQueueEmptyTest(iters int) {\n \t// can lead to underutilization (both runnable Gs and idle Ps coexist\n \t// for arbitrary long time).\n \tdone := make(chan bool, 1)\n-\tp := new(p)\n+\t_p_ := new(p)\n \tgs := make([]g, 2)\n \tready := new(uint32)\n \tfor i := 0; i < iters; i++ {\n \t\t*ready = 0\n \t\tnext0 := (i & 1) == 0\n \t\tnext1 := (i & 2) == 0\n-\t\trunqput(p, &gs[0], next0)\n-\t\tgo func() {\n+\t\trunqput(_p_, &gs[0], next0)\n+\t\tgo func(done chan bool, p *p, ready *uint32, next0, next1 bool) {\n \t\t\tfor atomic.Xadd(ready, 1); atomic.Load(ready) != 2; {\n \t\t\t}\n \t\t\tif runqempty(p) {\n \t\t\t\tprintln(\"next:\", next0, next1)\n \t\t\t\tthrow(\"queue is empty\")\n \t\t\t}\n \t\t\tdone <- true\n-\t\t}()\n+\t\t}(done, _p_, ready, next0, next1)\n \t\tfor atomic.Xadd(ready, 1); atomic.Load(ready) != 2; {\n \t\t}\n-\t\trunqput(p, &gs[1], next1)\n-\t\trunqget(p)\n+\t\trunqput(_p_, &gs[1], next1)\n+\t\trunqget(_p_)\n \t\t<-done\n-\t\trunqget(p)\n+\t\trunqget(_p_)\n \t}\n }\n "}]}