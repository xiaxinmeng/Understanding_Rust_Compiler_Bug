{"sha": "011d0a033ab370ea38b06b813ac62be8dde0801b", "node_id": "C_kwDOANBUbNoAKDAxMWQwYTAzM2FiMzcwZWEzOGIwNmI4MTNhYzYyYmU4ZGRlMDgwMWI", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-17T11:18:01Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-18T14:38:00Z"}, "message": "Make path_range_query standalone and add reset_path.\n\nThese are a bunch of cleanups inspired by Richi's suggestion of making\npath_range_query standalone, instead of having to call\ncompute_ranges() for each path.\n\nI've made the ranger need explicit, and moved the responsibility for\nits creation to the caller.\n\nI've also investigated and documented why the forward threader needs its\nown compute exit dependencies variant.  I can't wait for it to go away\n:-/.\n\nI've also added constructors that take a path and dependencies, and\nmade compute_ranges() private.  Unfortunately, reinstantiating\npath_range_query in the forward threader caused a 14% performance\nregression in DOM, because the old threader calls it over and over on\nthe same path to simplify statements (some of which not even in the\nIL, but that's old news).\n\nIn the meantime, I've left the ability to reset a path, but this time\nappropriately called reset_path().\n\nTested, benchmarked, and thread counted on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* gimple-range-path.cc (path_range_query::path_range_query): Add\n\tvarious constructors to take a path.\n\t(path_range_query::~path_range_query): Remove m_alloced_ranger.\n\t(path_range_query::range_on_path_entry): Adjust for m_ranger being\n\ta reference.\n\t(path_range_query::set_path): Rename to...\n\t(path_range_query::reset_path): ...this and call compute_ranges.\n\t(path_range_query::ssa_range_in_phi): Adjust for m_ranger\n\treference.\n\t(path_range_query::range_defined_in_block): Same.\n\t(path_range_query::compute_ranges_in_block): Same.\n\t(path_range_query::adjust_for_non_null_uses): Same.\n\t(path_range_query::compute_exit_dependencies): Use m_path instead\n\tof argument.\n\t(path_range_query::compute_ranges): Remove path argument.\n\t(path_range_query::range_of_stmt): Adjust for m_ranger reference.\n\t(path_range_query::compute_outgoing_relations): Same.\n\t* gimple-range-path.h (class path_range_query): Add various\n\tconstructors.\n\tMake compute_ranges and compute_exit_dependencies private.\n\tRename set_path to reset_path.\n\tMake m_ranger a reference.\n\tRemove m_alloced_ranger.\n\t* tree-ssa-dom.cc (pass_dominator::execute): Adjust constructor to\n\tpath_range_query.\n\t* tree-ssa-loop-ch.cc (entry_loop_condition_is_static): Take a\n\tranger and instantiate a new path_range_query every time.\n\t(ch_base::copy_headers): Pass ranger instead of path_range_query.\n\t* tree-ssa-threadbackward.cc (class back_threader): Remove m_solver.\n\t(back_threader::~back_threader): Remove m_solver.\n\t(back_threader::find_taken_edge_switch): Adjust for m_ranger\n\treference.\n\t(back_threader::find_taken_edge_cond): Same.\n\t(back_threader::dump): Remove m_solver.\n\t(back_threader::back_threader): Move verify_marked_backedges\n\there from the path_range_query constructor.\n\t* tree-ssa-threadedge.cc (hybrid_jt_simplifier::simplify): Move\n\tsome code from compute_ranges_from_state here.\n\t(hybrid_jt_simplifier::compute_ranges_from_state): Rename...\n\t(hybrid_jt_simplifier::compute_exit_dependencies): ...to this.\n\t* tree-ssa-threadedge.h (class hybrid_jt_simplifier): Rename\n\tcompute_ranges_from_state to compute_exit_dependencies.\n\tRemove m_path.", "tree": {"sha": "b0abbeb3bea4d27cd333a9e07264c5f8511024a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0abbeb3bea4d27cd333a9e07264c5f8511024a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/011d0a033ab370ea38b06b813ac62be8dde0801b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011d0a033ab370ea38b06b813ac62be8dde0801b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011d0a033ab370ea38b06b813ac62be8dde0801b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011d0a033ab370ea38b06b813ac62be8dde0801b/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac68f904fe31baf80fa53218f1d8ee033bd8c79b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac68f904fe31baf80fa53218f1d8ee033bd8c79b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac68f904fe31baf80fa53218f1d8ee033bd8c79b"}], "stats": {"total": 205, "additions": 106, "deletions": 99}, "files": [{"sha": "ba7c2ed9b473a13d1c1de3baba067a60bb486e6a", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 58, "deletions": 56, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -36,33 +36,52 @@ along with GCC; see the file COPYING3.  If not see\n // Internal construct to help facilitate debugging of solver.\n #define DEBUG_SOLVER (dump_file && (param_threader_debug == THREADER_DEBUG_ALL))\n \n-path_range_query::path_range_query (bool resolve, gimple_ranger *ranger)\n+path_range_query::path_range_query (gimple_ranger &ranger,\n+\t\t\t\t    const vec<basic_block> &path,\n+\t\t\t\t    const bitmap_head *dependencies,\n+\t\t\t\t    bool resolve)\n   : m_cache (new ssa_global_cache),\n     m_has_cache_entry (BITMAP_ALLOC (NULL)),\n-    m_resolve (resolve),\n-    m_alloced_ranger (!ranger)\n+    m_ranger (ranger),\n+    m_resolve (resolve)\n {\n-  if (m_alloced_ranger)\n-    m_ranger = new gimple_ranger;\n-  else\n-    m_ranger = ranger;\n+  m_oracle = new path_oracle (m_ranger.oracle ());\n+\n+  reset_path (path, dependencies);\n+}\n \n-  m_oracle = new path_oracle (m_ranger->oracle ());\n+path_range_query::path_range_query (gimple_ranger &ranger, bool resolve)\n+  : m_cache (new ssa_global_cache),\n+    m_has_cache_entry (BITMAP_ALLOC (NULL)),\n+    m_ranger (ranger),\n+    m_resolve (resolve)\n+{\n+  m_oracle = new path_oracle (m_ranger.oracle ());\n+}\n \n-  if (m_resolve && flag_checking)\n-    verify_marked_backedges (cfun);\n+path_range_query::path_range_query (gimple_ranger &ranger,\n+\t\t\t\t    edge e,\n+\t\t\t\t    bool resolve)\n+  : m_cache (new ssa_global_cache),\n+    m_has_cache_entry (BITMAP_ALLOC (NULL)),\n+    m_ranger (ranger),\n+    m_resolve (resolve)\n+{\n+  m_oracle = new path_oracle (m_ranger.oracle ());\n+  auto_vec<basic_block> bbs (2);\n+  bbs.quick_push (e->dest);\n+  bbs.quick_push (e->src);\n+  reset_path (bbs, NULL);\n }\n \n path_range_query::~path_range_query ()\n {\n   delete m_oracle;\n-  if (m_alloced_ranger)\n-    delete m_ranger;\n   BITMAP_FREE (m_has_cache_entry);\n   delete m_cache;\n }\n \n-// Return TRUE if NAME is an exit depenency for the path.\n+// Return TRUE if NAME is an exit dependency for the path.\n \n bool\n path_range_query::exit_dependency_p (tree name)\n@@ -153,7 +172,7 @@ path_range_query::range_on_path_entry (vrange &r, tree name)\n {\n   gcc_checking_assert (defined_outside_path (name));\n   basic_block entry = entry_bb ();\n-  m_ranger->range_on_entry (r, entry, name);\n+  m_ranger.range_on_entry (r, entry, name);\n }\n \n // Return the range of NAME at the end of the path being analyzed.\n@@ -211,19 +230,19 @@ path_range_query::unreachable_path_p ()\n   return m_undefined_path;\n }\n \n-// Initialize the current path to PATH.  The current block is set to\n-// the entry block to the path.\n-//\n-// Note that the blocks are in reverse order, so the exit block is\n-// path[0].\n+// Reset the current path to PATH.\n \n void\n-path_range_query::set_path (const vec<basic_block> &path)\n+path_range_query::reset_path (const vec<basic_block> &path,\n+\t\t\t      const bitmap_head *dependencies)\n {\n   gcc_checking_assert (path.length () > 1);\n   m_path = path.copy ();\n   m_pos = m_path.length () - 1;\n+  m_undefined_path = false;\n   bitmap_clear (m_has_cache_entry);\n+\n+  compute_ranges (dependencies);\n }\n \n bool\n@@ -248,7 +267,7 @@ path_range_query::ssa_range_in_phi (vrange &r, gphi *phi)\n \n   if (at_entry ())\n     {\n-      if (m_resolve && m_ranger->range_of_expr (r, name, phi))\n+      if (m_resolve && m_ranger.range_of_expr (r, name, phi))\n \treturn;\n \n       // Try to fold the phi exclusively with global or cached values.\n@@ -290,7 +309,7 @@ path_range_query::ssa_range_in_phi (vrange &r, gphi *phi)\n \t    range_on_path_entry (r, arg);\n \t  else\n \t    r.set_varying (TREE_TYPE (name));\n-\t  m_ranger->range_on_edge (tmp, e_in, arg);\n+\t  m_ranger.range_on_edge (tmp, e_in, arg);\n \t  r.intersect (tmp);\n \t  return;\n \t}\n@@ -325,7 +344,7 @@ path_range_query::range_defined_in_block (vrange &r, tree name, basic_block bb)\n     }\n \n   if (bb && POINTER_TYPE_P (TREE_TYPE (name)))\n-    m_ranger->m_cache.m_exit.maybe_adjust_range (r, name, bb);\n+    m_ranger.m_cache.m_exit.maybe_adjust_range (r, name, bb);\n \n   if (DEBUG_SOLVER && (bb || !r.varying_p ()))\n     {\n@@ -441,7 +460,7 @@ path_range_query::compute_ranges_in_block (basic_block bb)\n       p->reset_path ();\n     }\n \n-  gori_compute &g = m_ranger->gori ();\n+  gori_compute &g = m_ranger.gori ();\n   bitmap exports = g.exports (bb);\n   EXECUTE_IF_AND_IN_BITMAP (m_exit_dependencies, exports, 0, i, bi)\n     {\n@@ -495,7 +514,7 @@ path_range_query::adjust_for_non_null_uses (basic_block bb)\n       else\n \tr.set_varying (TREE_TYPE (name));\n \n-      if (m_ranger->m_cache.m_exit.maybe_adjust_range (r, name, bb))\n+      if (m_ranger.m_cache.m_exit.maybe_adjust_range (r, name, bb))\n \tset_cache (r, name);\n     }\n }\n@@ -515,12 +534,11 @@ path_range_query::add_to_exit_dependencies (tree name, bitmap dependencies)\n // SSA names used to calculate the final conditional along the path.\n \n void\n-path_range_query::compute_exit_dependencies (bitmap dependencies,\n-\t\t\t\t\t     const vec<basic_block> &path)\n+path_range_query::compute_exit_dependencies (bitmap dependencies)\n {\n   // Start with the imports from the exit block...\n-  basic_block exit = path[0];\n-  gori_compute &gori = m_ranger->gori ();\n+  basic_block exit = m_path[0];\n+  gori_compute &gori = m_ranger.gori ();\n   bitmap_copy (dependencies, gori.imports (exit));\n \n   auto_vec<tree> worklist (bitmap_count_bits (dependencies));\n@@ -538,7 +556,7 @@ path_range_query::compute_exit_dependencies (bitmap dependencies,\n       tree name = worklist.pop ();\n       gimple *def_stmt = SSA_NAME_DEF_STMT (name);\n       if (SSA_NAME_IS_DEFAULT_DEF (name)\n-\t  || !path.contains (gimple_bb (def_stmt)))\n+\t  || !m_path.contains (gimple_bb (def_stmt)))\n \tcontinue;\n \n       if (gphi *phi = dyn_cast <gphi *> (def_stmt))\n@@ -549,7 +567,7 @@ path_range_query::compute_exit_dependencies (bitmap dependencies,\n \t      tree arg = gimple_phi_arg (phi, i)->def;\n \n \t      if (TREE_CODE (arg) == SSA_NAME\n-\t\t  && path.contains (e->src)\n+\t\t  && m_path.contains (e->src)\n \t\t  && bitmap_set_bit (dependencies, SSA_NAME_VERSION (arg)))\n \t\tworklist.safe_push (arg);\n \t    }\n@@ -565,9 +583,9 @@ path_range_query::compute_exit_dependencies (bitmap dependencies,\n     }\n   // Exported booleans along the path, may help conditionals.\n   if (m_resolve)\n-    for (i = 0; i < path.length (); ++i)\n+    for (i = 0; i < m_path.length (); ++i)\n       {\n-\tbasic_block bb = path[i];\n+\tbasic_block bb = m_path[i];\n \ttree name;\n \tFOR_EACH_GORI_EXPORT_NAME (gori, bb, name)\n \t  if (TREE_CODE (TREE_TYPE (name)) == BOOLEAN_TYPE)\n@@ -583,32 +601,28 @@ path_range_query::compute_exit_dependencies (bitmap dependencies,\n // calculated from the final conditional in the path.\n \n void\n-path_range_query::compute_ranges (const vec<basic_block> &path,\n-\t\t\t\t  const bitmap_head *dependencies)\n+path_range_query::compute_ranges (const bitmap_head *dependencies)\n {\n   if (DEBUG_SOLVER)\n     fprintf (dump_file, \"\\n==============================================\\n\");\n \n-  set_path (path);\n-  m_undefined_path = false;\n-\n   if (dependencies)\n     bitmap_copy (m_exit_dependencies, dependencies);\n   else\n-    compute_exit_dependencies (m_exit_dependencies, m_path);\n+    compute_exit_dependencies (m_exit_dependencies);\n \n   if (m_resolve)\n     {\n       path_oracle *p = get_path_oracle ();\n-      p->reset_path (m_ranger->oracle ());\n+      p->reset_path (m_ranger.oracle ());\n     }\n \n   if (DEBUG_SOLVER)\n     {\n       fprintf (dump_file, \"path_range_query: compute_ranges for path: \");\n-      for (unsigned i = path.length (); i > 0; --i)\n+      for (unsigned i = m_path.length (); i > 0; --i)\n \t{\n-\t  basic_block bb = path[i - 1];\n+\t  basic_block bb = m_path[i - 1];\n \t  fprintf (dump_file, \"%d\", bb->index);\n \t  if (i > 1)\n \t    fprintf (dump_file, \"->\");\n@@ -636,18 +650,6 @@ path_range_query::compute_ranges (const vec<basic_block> &path,\n     }\n }\n \n-// Convenience function to compute ranges along a path consisting of\n-// E->SRC and E->DEST.\n-\n-void\n-path_range_query::compute_ranges (edge e)\n-{\n-  auto_vec<basic_block> bbs (2);\n-  bbs.quick_push (e->dest);\n-  bbs.quick_push (e->src);\n-  compute_ranges (bbs);\n-}\n-\n // A folding aid used to register and query relations along a path.\n // When queried, it returns relations as they would appear on exit to\n // the path.\n@@ -730,7 +732,7 @@ path_range_query::range_of_stmt (vrange &r, gimple *stmt, tree)\n   if (m_resolve)\n     {\n       fold_using_range f;\n-      jt_fur_source src (stmt, this, &m_ranger->gori (), m_path);\n+      jt_fur_source src (stmt, this, &m_ranger.gori (), m_path);\n       if (!f.fold_stmt (r, stmt, src))\n \tr.set_varying (type);\n     }\n@@ -820,7 +822,7 @@ path_range_query::compute_outgoing_relations (basic_block bb, basic_block next)\n       else\n \tgcc_unreachable ();\n \n-      jt_fur_source src (NULL, this, &m_ranger->gori (), m_path);\n+      jt_fur_source src (NULL, this, &m_ranger.gori (), m_path);\n       src.register_outgoing_edges (cond, r, e0, e1);\n     }\n }"}, {"sha": "483fde0d43149671d90ab53419357af06d5440c8", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -32,13 +32,14 @@ along with GCC; see the file COPYING3.  If not see\n class path_range_query : public range_query\n {\n public:\n-  path_range_query (bool resolve = true, class gimple_ranger *ranger = NULL);\n+  path_range_query (class gimple_ranger &ranger,\n+\t\t    const vec<basic_block> &path,\n+\t\t    const bitmap_head *dependencies = NULL,\n+\t\t    bool resolve = true);\n+  path_range_query (gimple_ranger &ranger, bool resolve = true);\n+  path_range_query (gimple_ranger &ranger, edge e, bool resolve = true);\n   virtual ~path_range_query ();\n-  void compute_ranges (const vec<basic_block> &,\n-\t\t       const bitmap_head *dependencies = NULL);\n-  void compute_ranges (edge e);\n-  void compute_exit_dependencies (bitmap dependencies,\n-\t\t\t\t  const vec<basic_block> &);\n+  void reset_path (const vec<basic_block> &, const bitmap_head *dependencies);\n   bool range_of_expr (vrange &r, tree name, gimple * = NULL) override;\n   bool range_of_stmt (vrange &r, gimple *, tree name = NULL) override;\n   bool unreachable_path_p ();\n@@ -47,6 +48,8 @@ class path_range_query : public range_query\n \n private:\n   bool internal_range_of_expr (vrange &r, tree name, gimple *);\n+  void compute_ranges (const bitmap_head *dependencies);\n+  void compute_exit_dependencies (bitmap_head *dependencies);\n   bool defined_outside_path (tree name);\n   void range_on_path_entry (vrange &r, tree name);\n   path_oracle *get_path_oracle () { return (path_oracle *)m_oracle; }\n@@ -71,7 +74,6 @@ class path_range_query : public range_query\n   bool relations_may_be_invalidated (edge);\n \n   // Path navigation.\n-  void set_path (const vec<basic_block> &);\n   basic_block entry_bb () { return m_path[m_path.length () - 1]; }\n   basic_block exit_bb ()  { return m_path[0]; }\n   basic_block curr_bb ()  { return m_path[m_pos]; }\n@@ -99,7 +101,7 @@ class path_range_query : public range_query\n \n   // A ranger used to resolve ranges for SSA names whose values come\n   // from outside the path.\n-  gimple_ranger *m_ranger;\n+  gimple_ranger &m_ranger;\n \n   // Current path position.\n   unsigned m_pos;\n@@ -109,10 +111,6 @@ class path_range_query : public range_query\n \n   // Set if there were any undefined expressions while pre-calculating path.\n   bool m_undefined_path;\n-\n-  // True if m_ranger was allocated in this class and must be freed at\n-  // destruction.\n-  bool m_alloced_ranger;\n };\n \n #endif // GCC_TREE_SSA_THREADSOLVER_H"}, {"sha": "513e0c882545b521586c63a84e8b19cfe45098f4", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -798,7 +798,7 @@ pass_dominator::execute (function *fun)\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n   gimple_ranger *ranger = enable_ranger (fun);\n-  path_range_query path_query (/*resolve=*/true, ranger);\n+  path_range_query path_query (*ranger);\n   dom_jt_simplifier simplifier (avail_exprs_stack, ranger, &path_query);\n   dom_jt_state state (const_and_copies, avail_exprs_stack);\n   jump_threader threader (&simplifier, &state);"}, {"sha": "96816b892875dd8db183072af1e0edc0e0a87149", "filename": "gcc/tree-ssa-loop-ch.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-loop-ch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-loop-ch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.cc?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -49,7 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n    be statically determined.  */\n \n static bool\n-entry_loop_condition_is_static (class loop *l, path_range_query *query)\n+entry_loop_condition_is_static (class loop *l, gimple_ranger *ranger)\n {\n   edge e = loop_preheader_edge (l);\n   gcond *last = safe_dyn_cast <gcond *> (last_stmt (e->dest));\n@@ -72,8 +72,8 @@ entry_loop_condition_is_static (class loop *l, path_range_query *query)\n     desired_static_value = boolean_true_node;\n \n   int_range<2> r;\n-  query->compute_ranges (e);\n-  query->range_of_stmt (r, last);\n+  path_range_query query (*ranger, e);\n+  query.range_of_stmt (r, last);\n   return r == int_range<2> (desired_static_value, desired_static_value);\n }\n \n@@ -385,7 +385,7 @@ ch_base::copy_headers (function *fun)\n   auto_vec<std::pair<edge, loop_p> > copied;\n \n   mark_dfs_back_edges ();\n-  path_range_query *query = new path_range_query;\n+  gimple_ranger *ranger = new gimple_ranger;\n   for (auto loop : loops_list (cfun, 0))\n     {\n       int initial_limit = param_max_loop_header_insns;\n@@ -409,7 +409,7 @@ ch_base::copy_headers (function *fun)\n \t iteration.  */\n       if (optimize_loop_for_size_p (loop)\n \t  && !loop->force_vectorize\n-\t  && !entry_loop_condition_is_static (loop, query))\n+\t  && !entry_loop_condition_is_static (loop, ranger))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -422,7 +422,7 @@ ch_base::copy_headers (function *fun)\n \tcandidates.safe_push (loop);\n     }\n   /* Do not use ranger after we change the IL and not have updated SSA.  */\n-  delete query;\n+  delete ranger;\n \n   for (auto loop : candidates)\n     {"}, {"sha": "3218ad931eff7992b8c7de7847a7a9646443ed96", "filename": "gcc/tree-ssa-threadbackward.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-threadbackward.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-threadbackward.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.cc?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -116,7 +116,6 @@ class back_threader\n   virtual void dump (FILE *out);\n \n   back_threader_registry m_registry;\n-  path_range_query *m_solver;\n \n   // Current path being analyzed.\n   auto_vec<basic_block> m_path;\n@@ -136,6 +135,8 @@ class back_threader\n   // with the ranger.  Otherwise, unknown SSA names are assumed to be\n   // VARYING.  Setting to true is more precise but slower.\n   function *m_fun;\n+  // Ranger for the path solver.\n+  gimple_ranger *m_ranger;\n   unsigned m_flags;\n   // Set to TRUE for the first of each thread[12] pass or the first of\n   // each threadfull[12] pass.  This is used to differentiate between\n@@ -162,13 +163,13 @@ back_threader::back_threader (function *fun, unsigned flags, bool first)\n   // The path solver needs EDGE_DFS_BACK in resolving mode.\n   if (flags & BT_RESOLVE)\n     mark_dfs_back_edges ();\n-  m_solver = new path_range_query (flags & BT_RESOLVE);\n+\n+  m_ranger = new gimple_ranger;\n }\n \n back_threader::~back_threader ()\n {\n-  delete m_solver;\n-\n+  delete m_ranger;\n   loop_optimizer_finalize ();\n }\n \n@@ -305,8 +306,8 @@ back_threader::find_taken_edge_switch (const vec<basic_block> &path,\n   tree name = gimple_switch_index (sw);\n   int_range_max r;\n \n-  m_solver->compute_ranges (path, m_imports);\n-  m_solver->range_of_expr (r, name, sw);\n+  path_range_query solver (*m_ranger, path, m_imports, m_flags & BT_RESOLVE);\n+  solver.range_of_expr (r, name, sw);\n \n   if (r.undefined_p ())\n     return UNREACHABLE_EDGE;\n@@ -329,10 +330,10 @@ back_threader::find_taken_edge_cond (const vec<basic_block> &path,\n {\n   int_range_max r;\n \n-  m_solver->compute_ranges (path, m_imports);\n-  m_solver->range_of_stmt (r, cond);\n+  path_range_query solver (*m_ranger, path, m_imports, m_flags & BT_RESOLVE);\n+  solver.range_of_stmt (r, cond);\n \n-  if (m_solver->unreachable_path_p ())\n+  if (solver.unreachable_path_p ())\n     return UNREACHABLE_EDGE;\n \n   int_range<2> true_range (boolean_true_node, boolean_true_node);\n@@ -583,7 +584,6 @@ debug (const vec <basic_block> &path)\n void\n back_threader::dump (FILE *out)\n {\n-  m_solver->dump (out);\n   fprintf (out, \"\\nCandidates for pre-computation:\\n\");\n   fprintf (out, \"===================================\\n\");\n "}, {"sha": "905a98c8c68d98105be025b45f120dd69d64c653", "filename": "gcc/tree-ssa-threadedge.cc", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-threadedge.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-threadedge.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.cc?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -1399,7 +1399,6 @@ jt_state::register_equivs_stmt (gimple *stmt, basic_block bb,\n \n // Hybrid threader implementation.\n \n-\n hybrid_jt_simplifier::hybrid_jt_simplifier (gimple_ranger *r,\n \t\t\t\t\t    path_range_query *q)\n {\n@@ -1411,7 +1410,12 @@ tree\n hybrid_jt_simplifier::simplify (gimple *stmt, gimple *, basic_block,\n \t\t\t\tjt_state *state)\n {\n-  compute_ranges_from_state (stmt, state);\n+  auto_bitmap dependencies;\n+  auto_vec<basic_block> path;\n+\n+  state->get_path (path);\n+  compute_exit_dependencies (dependencies, path, stmt);\n+  m_query->reset_path (path, dependencies);\n \n   if (gimple_code (stmt) == GIMPLE_COND\n       || gimple_code (stmt) == GIMPLE_ASSIGN)\n@@ -1432,31 +1436,33 @@ hybrid_jt_simplifier::simplify (gimple *stmt, gimple *, basic_block,\n   return NULL;\n }\n \n-// Use STATE to generate the list of imports needed for the solver,\n-// and calculate the ranges along the path.\n+// Calculate the set of exit dependencies for a path and statement to\n+// be simplified.  This is different than the\n+// compute_exit_dependencies in the path solver because the forward\n+// threader asks questions about statements not necessarily in the\n+// path.  Using the default compute_exit_dependencies in the path\n+// solver gets noticeably less threads.\n \n void\n-hybrid_jt_simplifier::compute_ranges_from_state (gimple *stmt, jt_state *state)\n+hybrid_jt_simplifier::compute_exit_dependencies (bitmap dependencies,\n+\t\t\t\t\t\t const vec<basic_block> &path,\n+\t\t\t\t\t\t gimple *stmt)\n {\n-  auto_bitmap imports;\n   gori_compute &gori = m_ranger->gori ();\n \n-  state->get_path (m_path);\n-\n   // Start with the imports to the final conditional.\n-  bitmap_copy (imports, gori.imports (m_path[0]));\n+  bitmap_copy (dependencies, gori.imports (path[0]));\n \n   // Add any other interesting operands we may have missed.\n-  if (gimple_bb (stmt) != m_path[0])\n+  if (gimple_bb (stmt) != path[0])\n     {\n       for (unsigned i = 0; i < gimple_num_ops (stmt); ++i)\n \t{\n \t  tree op = gimple_op (stmt, i);\n \t  if (op\n \t      && TREE_CODE (op) == SSA_NAME\n \t      && Value_Range::supports_type_p (TREE_TYPE (op)))\n-\t    bitmap_set_bit (imports, SSA_NAME_VERSION (op));\n+\t    bitmap_set_bit (dependencies, SSA_NAME_VERSION (op));\n \t}\n     }\n-  m_query->compute_ranges (m_path, imports);\n }"}, {"sha": "790ac2ea538c60569b3fe015682e0ef33c933f47", "filename": "gcc/tree-ssa-threadedge.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-threadedge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011d0a033ab370ea38b06b813ac62be8dde0801b/gcc%2Ftree-ssa-threadedge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.h?ref=011d0a033ab370ea38b06b813ac62be8dde0801b", "patch": "@@ -69,11 +69,12 @@ class hybrid_jt_simplifier : public jt_simplifier\n   tree simplify (gimple *stmt, gimple *, basic_block, jt_state *) override;\n \n private:\n-  void compute_ranges_from_state (gimple *stmt, jt_state *);\n+  void compute_exit_dependencies (bitmap dependencies,\n+\t\t\t\t  const vec<basic_block> &path,\n+\t\t\t\t  gimple *stmt);\n \n   gimple_ranger *m_ranger;\n   path_range_query *m_query;\n-  auto_vec<basic_block> m_path;\n };\n \n // This is the high level threader.  The entry point is"}]}