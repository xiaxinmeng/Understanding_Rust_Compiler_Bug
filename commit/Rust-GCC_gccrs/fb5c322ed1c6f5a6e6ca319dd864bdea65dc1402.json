{"sha": "fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI1YzMyMmVkMWM2ZjVhNmU2Y2EzMTlkZDg2NGJkZWE2NWRjMTQwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-04-24T00:58:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-04-24T00:58:25Z"}, "message": "ipa-icf.c (sem_function::equals_wpa): Compare thunk info.\n\n\n\t* ipa-icf.c (sem_function::equals_wpa): Compare thunk info.\n\t(sem_function::equals): IGNORED_NODES parameter is now unused;\n\tupdate call of equals_private.\n\t(sem_function::equals_private): Do not call equals_wpa; skip\n\tgimple body matching if there is no body.\n\t(sem_function::init): Add logic to hash tthunk info.\n\t(sem_function::parse): Also parse thunks.\n\t* ipa-icf.h (equals_private): Update declaration.\n\nFrom-SVN: r222392", "tree": {"sha": "819b00396021a82b9b24921b0e421c5e222bb057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/819b00396021a82b9b24921b0e421c5e222bb057"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/comments", "author": null, "committer": null, "parents": [{"sha": "b3b80089c26d4c8c899626feb19602e217e1cbee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3b80089c26d4c8c899626feb19602e217e1cbee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3b80089c26d4c8c899626feb19602e217e1cbee"}], "stats": {"total": 124, "additions": 83, "deletions": 41}, "files": [{"sha": "2eaacfdfd1418577a53ef338617043f11c8f02c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "patch": "@@ -1,3 +1,14 @@\n+2015-04-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c (sem_function::equals_wpa): Compare thunk info.\n+\t(sem_function::equals): IGNORED_NODES parameter is now unused;\n+\tupdate call of equals_private.\n+\t(sem_function::equals_private): Do not call equals_wpa; skip\n+\tgimple body matching if there is no body.\n+\t(sem_function::init): Add logic to hash tthunk info.\n+\t(sem_function::parse): Also parse thunks.\n+\t* ipa-icf.h (equals_private): Update declaration.\n+\n 2015-04-23  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* config/rs6000/altivec.md (*altivec_lvx_<mode>_internal): Remove"}, {"sha": "ce4aca20b669461ac9c5796aeb81710d4b3e4164", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 71, "deletions": 39, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "patch": "@@ -601,12 +601,32 @@ sem_function::equals_wpa (sem_item *item,\n \t\t\t  hash_map <symtab_node *, sem_item *> &ignored_nodes)\n {\n   gcc_assert (item->type == FUNC);\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+  cgraph_node *cnode2 = dyn_cast <cgraph_node *> (item->node);\n \n   m_compared_func = static_cast<sem_function *> (item);\n \n   if (arg_types.length () != m_compared_func->arg_types.length ())\n     return return_false_with_msg (\"different number of arguments\");\n \n+  if (cnode->thunk.thunk_p != cnode2->thunk.thunk_p)\n+    return return_false_with_msg (\"thunk_p mismatch\");\n+\n+  if (cnode->thunk.thunk_p)\n+    {\n+      if (cnode->thunk.fixed_offset != cnode2->thunk.fixed_offset)\n+        return return_false_with_msg (\"thunk fixed_offset mismatch\");\n+      if (cnode->thunk.virtual_value != cnode2->thunk.virtual_value)\n+        return return_false_with_msg (\"thunk virtual_value mismatch\");\n+      if (cnode->thunk.this_adjusting != cnode2->thunk.this_adjusting)\n+        return return_false_with_msg (\"thunk this_adjusting mismatch\");\n+      if (cnode->thunk.virtual_offset_p != cnode2->thunk.virtual_offset_p)\n+        return return_false_with_msg (\"thunk virtual_offset_p mismatch\");\n+      if (cnode->thunk.add_pointer_bounds_args\n+\t  != cnode2->thunk.add_pointer_bounds_args)\n+        return return_false_with_msg (\"thunk add_pointer_bounds_args mismatch\");\n+    }\n+\n   /* Compare special function DECL attributes.  */\n   if (DECL_FUNCTION_PERSONALITY (decl)\n       != DECL_FUNCTION_PERSONALITY (item->decl))\n@@ -862,10 +882,10 @@ sem_item::update_hash_by_local_refs (hash_map <symtab_node *,\n \n bool\n sem_function::equals (sem_item *item,\n-\t\t      hash_map <symtab_node *, sem_item *> &ignored_nodes)\n+\t\t      hash_map <symtab_node *, sem_item *> &)\n {\n   gcc_assert (item->type == FUNC);\n-  bool eq = equals_private (item, ignored_nodes);\n+  bool eq = equals_private (item);\n \n   if (m_checker != NULL)\n     {\n@@ -890,8 +910,7 @@ sem_function::equals (sem_item *item,\n /* Processes function equality comparison.  */\n \n bool\n-sem_function::equals_private (sem_item *item,\n-\t\t\t      hash_map <symtab_node *, sem_item *> &ignored_nodes)\n+sem_function::equals_private (sem_item *item)\n {\n   if (item->type != FUNC)\n     return false;\n@@ -911,9 +930,6 @@ sem_function::equals_private (sem_item *item,\n       || cfg_checksum != m_compared_func->cfg_checksum)\n     return return_false ();\n \n-  if (!equals_wpa (item, ignored_nodes))\n-    return false;\n-\n   m_checker = new func_checker (decl, m_compared_func->decl,\n \t\t\t\tcompare_polymorphic_p (),\n \t\t\t\tfalse,\n@@ -925,6 +941,9 @@ sem_function::equals_private (sem_item *item,\n     if (!m_checker->compare_decl (arg1, arg2))\n       return return_false ();\n \n+  if (!dyn_cast <cgraph_node *> (node)->has_gimple_body_p ())\n+    return true;\n+\n   /* Fill-up label dictionary.  */\n   for (unsigned i = 0; i < bb_sorted.length (); ++i)\n     {\n@@ -1380,44 +1399,59 @@ sem_function::init (void)\n   arg_count = count_formal_params (fndecl);\n \n   edge_count = n_edges_for_fn (func);\n-  cfg_checksum = coverage_compute_cfg_checksum (func);\n-\n-  inchash::hash hstate;\n-\n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, func)\n-  {\n-    unsigned nondbg_stmt_count = 0;\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n+  if (!cnode->thunk.thunk_p)\n+    {\n+      cfg_checksum = coverage_compute_cfg_checksum (func);\n \n-    edge e;\n-    for (edge_iterator ei = ei_start (bb->preds); ei_cond (ei, &e);\n-\t ei_next (&ei))\n-      cfg_checksum = iterative_hash_host_wide_int (e->flags,\n-\t\t     cfg_checksum);\n+      inchash::hash hstate;\n \n-    for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n-\t gsi_next (&gsi))\n+      basic_block bb;\n+      FOR_EACH_BB_FN (bb, func)\n       {\n-\tgimple stmt = gsi_stmt (gsi);\n+\tunsigned nondbg_stmt_count = 0;\n+\n+\tedge e;\n+\tfor (edge_iterator ei = ei_start (bb->preds); ei_cond (ei, &e);\n+\t     ei_next (&ei))\n+\t  cfg_checksum = iterative_hash_host_wide_int (e->flags,\n+\t\t\t cfg_checksum);\n \n-\tif (gimple_code (stmt) != GIMPLE_DEBUG\n-\t    && gimple_code (stmt) != GIMPLE_PREDICT)\n+\tfor (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+\t     gsi_next (&gsi))\n \t  {\n-\t    hash_stmt (stmt, hstate);\n-\t    nondbg_stmt_count++;\n+\t    gimple stmt = gsi_stmt (gsi);\n+\n+\t    if (gimple_code (stmt) != GIMPLE_DEBUG\n+\t\t&& gimple_code (stmt) != GIMPLE_PREDICT)\n+\t      {\n+\t\thash_stmt (stmt, hstate);\n+\t\tnondbg_stmt_count++;\n+\t      }\n \t  }\n-      }\n \n-    gcode_hash = hstate.end ();\n-    bb_sizes.safe_push (nondbg_stmt_count);\n+\tgcode_hash = hstate.end ();\n+\tbb_sizes.safe_push (nondbg_stmt_count);\n \n-    /* Inserting basic block to hash table.  */\n-    sem_bb *semantic_bb = new sem_bb (bb, nondbg_stmt_count,\n-\t\t\t\t      EDGE_COUNT (bb->preds)\n-\t\t\t\t      + EDGE_COUNT (bb->succs));\n+\t/* Inserting basic block to hash table.  */\n+\tsem_bb *semantic_bb = new sem_bb (bb, nondbg_stmt_count,\n+\t\t\t\t\t  EDGE_COUNT (bb->preds)\n+\t\t\t\t\t  + EDGE_COUNT (bb->succs));\n \n-    bb_sorted.safe_push (semantic_bb);\n-  }\n+\tbb_sorted.safe_push (semantic_bb);\n+      }\n+    }\n+  else\n+    {\n+      cfg_checksum = 0;\n+      inchash::hash hstate;\n+      hstate.add_wide_int (cnode->thunk.fixed_offset);\n+      hstate.add_wide_int (cnode->thunk.virtual_value);\n+      hstate.add_flag (cnode->thunk.this_adjusting);\n+      hstate.add_flag (cnode->thunk.virtual_offset_p);\n+      hstate.add_flag (cnode->thunk.add_pointer_bounds_args);\n+      gcode_hash = hstate.end ();\n+    }\n \n   parse_tree_args ();\n }\n@@ -1657,9 +1691,7 @@ sem_function::parse (cgraph_node *node, bitmap_obstack *stack)\n   tree fndecl = node->decl;\n   function *func = DECL_STRUCT_FUNCTION (fndecl);\n \n-  /* TODO: add support for thunks.  */\n-\n-  if (!func || !node->has_gimple_body_p ())\n+  if (!func || (!node->has_gimple_body_p () && !node->thunk.thunk_p))\n     return NULL;\n \n   if (lookup_attribute_by_prefix (\"omp \", DECL_ATTRIBUTES (node->decl)) != NULL)"}, {"sha": "a3b9ab93678102c6c094f9d212613a256fdd6bb1", "filename": "gcc/ipa-icf.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/gcc%2Fipa-icf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402/gcc%2Fipa-icf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.h?ref=fb5c322ed1c6f5a6e6ca319dd864bdea65dc1402", "patch": "@@ -380,8 +380,7 @@ class sem_function: public sem_item\n   bool compare_edge_flags (cgraph_edge *e1, cgraph_edge *e2);\n \n   /* Processes function equality comparison.  */\n-  bool equals_private (sem_item *item,\n-\t\t       hash_map <symtab_node *, sem_item *> &ignored_nodes);\n+  bool equals_private (sem_item *item);\n \n   /* Returns true if tree T can be compared as a handled component.  */\n   static bool icf_handled_component_p (tree t);"}]}