{"sha": "5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ4M2Y0NGJhYTQ5ZmJlYWRiOWI1YzM1Y2IxNWUzZjhhODYwODAyZg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@bitmover.com", "date": "1999-08-04T20:39:33Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-08-04T20:39:33Z"}, "message": "cpphash.c (macroexpand): Delete leading whitespace when arg is concatenated before.\n\nWed Aug  4 13:29:23 1999  Zack Weinberg  <zack@bitmover.com>\n\n\t* cpphash.c (macroexpand): Delete leading whitespace when arg\n\tis concatenated before.\n\t(unsafe_chars): Correct test for whether + and - can extend a\n\ttoken.\n\n\t* cppinit.c (cpp_start_read): Do dependencies for\n\t-include/-imacros files also.\n\n\t* cpplib.c (cpp_scan_buffer): In no-output mode, don't bother\n\ttokenizing non-directive lines.\n\t(cpp_expand_to_buffer): Temporarily disable no-output mode.\n\t* cppmain.c: In no-output mode, just call cpp_scan_buffer for\n\tthe input file.\n\nFrom-SVN: r28512", "tree": {"sha": "7dea07caa27d775c7af2d93e14dea09352a6d2e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7dea07caa27d775c7af2d93e14dea09352a6d2e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/comments", "author": null, "committer": null, "parents": [{"sha": "2a94e396c65da274a48a7d572d3e229dace92308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a94e396c65da274a48a7d572d3e229dace92308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a94e396c65da274a48a7d572d3e229dace92308"}], "stats": {"total": 139, "additions": 103, "deletions": 36}, "files": [{"sha": "39a7bbc474476d277b01448327bf99114d7994c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "patch": "@@ -1,3 +1,19 @@\n+Wed Aug  4 13:29:23 1999  Zack Weinberg  <zack@bitmover.com>\n+\n+\t* cpphash.c (macroexpand): Delete leading whitespace when arg\n+\tis concatenated before.\n+\t(unsafe_chars): Correct test for whether + and - can extend a\n+\ttoken.\n+\n+\t* cppinit.c (cpp_start_read): Do dependencies for\n+\t-include/-imacros files also.\n+\n+\t* cpplib.c (cpp_scan_buffer): In no-output mode, don't bother\n+\ttokenizing non-directive lines.\n+\t(cpp_expand_to_buffer): Temporarily disable no-output mode.\n+\t* cppmain.c: In no-output mode, just call cpp_scan_buffer for\n+\tthe input file.\n+\n Wed Aug  4 12:53:44 1999  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* expr.c (expand_expr, case PLUS_EXPR): Fix parallel case, too."}, {"sha": "2b5291bea2b77da32c004001e46bdd7943ff545f", "filename": "gcc/cpphash.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "patch": "@@ -1337,10 +1337,17 @@ macroexpand (pfile, hp)\n \t      U_CHAR *l1 = p1 + arg->raw_length;\n \t      if (ap->raw_before)\n \t\t{\n-\t\t  while (p1 != l1 && is_space[*p1])\n-\t\t    p1++;\n-\t\t  while (p1 != l1 && is_idchar[*p1])\n-\t\t    xbuf[totlen++] = *p1++;\n+\t\t  /* Arg is concatenated before: delete leading whitespace,\n+\t\t     whitespace markers, and no-reexpansion markers.  */\n+\t\t  while (p1 != l1)\n+\t\t    {\n+\t\t      if (is_space[p1[0]])\n+\t\t\tp1++;\n+\t\t      else if (p1[0] == '\\r')\n+\t\t\tp1 += 2;\n+\t\t      else\n+\t\t\tbreak;\n+\t\t    }\n \t\t}\n \t      if (ap->raw_after)\n \t\t{\n@@ -1460,15 +1467,12 @@ unsafe_chars (c1, c2)\n {\n   switch (c1)\n     {\n-    case '+':\n-    case '-':\n+    case '+':  case '-':\n       if (c2 == c1 || c2 == '=')\n \treturn 1;\n       goto letter;\n \n-    case '.':    case '0':    case '1':    case '2':    case '3':\n-    case '4':    case '5':    case '6':    case '7':    case '8':\n-    case '9':    case 'e':    case 'E':    case 'p':    case 'P':\n+    case 'e':  case 'E':  case 'p':  case 'P':\n       if (c2 == '-' || c2 == '+')\n \treturn 1;\t\t/* could extend a pre-processing number */\n       goto letter;\n@@ -1478,6 +1482,8 @@ unsafe_chars (c1, c2)\n \treturn 1;\t\t/* Could turn into L\"xxx\" or L'xxx'.  */\n       goto letter;\n \n+    case '.':  case '0':  case '1':  case '2':  case '3':\n+    case '4':  case '5':  case '6':  case '7':  case '8':  case '9':\n     case '_':  case 'a':  case 'b':  case 'c':  case 'd':  case 'f':\n     case 'g':  case 'h':  case 'i':  case 'j':  case 'k':  case 'l':\n     case 'm':  case 'n':  case 'o':  case 'q':  case 'r':  case 's':"}, {"sha": "c9f7ece352127657fb54ad63a1de2348cccd7e9a", "filename": "gcc/cppinit.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "patch": "@@ -1029,8 +1029,15 @@ cpp_start_read (pfile, fname)\n       ih_fake->control_macro = 0;\n       ih_fake->buf = (char *)-1;\n       ih_fake->limit = 0;\n-      if (!finclude (pfile, fd, ih_fake))\n-\tcpp_scan_buffer (pfile);\n+      if (finclude (pfile, fd, ih_fake))\n+\t{\n+\t  if (CPP_PRINT_DEPS (pfile))\n+\t    deps_output (pfile, ih_fake->name, ' ');\n+\n+\t  cpp_scan_buffer (pfile);\n+\t}\n+      else\n+\tcpp_pop_buffer (pfile);\n       free (ih_fake);\n \n       q = p->next;\n@@ -1062,8 +1069,14 @@ cpp_start_read (pfile, fname)\n       ih_fake->buf = (char *)-1;\n       ih_fake->limit = 0;\n       if (finclude (pfile, fd, ih_fake))\n-\toutput_line_command (pfile, enter_file);\n-\n+\t{\n+\t  if (CPP_PRINT_DEPS (pfile))\n+\t    deps_output (pfile, ih_fake->name, ' ');\n+\t  \n+\t  output_line_command (pfile, enter_file);\n+\t}\n+      else\n+\tcpp_pop_buffer (pfile);\n       q = p->next;\n       free (p);\n       p = q;"}, {"sha": "ab2e203c27f4828f968f08395b3b7d9777c71428", "filename": "gcc/cpplib.c", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "patch": "@@ -731,15 +731,42 @@ cpp_scan_buffer (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = CPP_BUFFER (pfile);\n-  for (;;)\n+  enum cpp_token token;\n+  if (CPP_OPTIONS (pfile)->no_output)\n     {\n-      enum cpp_token token = cpp_get_token (pfile);\n-      if (token == CPP_EOF) /* Should not happen ...  */\n-\tbreak;\n-      if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+      long old_written = CPP_WRITTEN (pfile);\n+      /* In no-output mode, we can ignore everything but directives.  */\n+      for (;;)\n \t{\n-\t  cpp_pop_buffer (pfile);\n-\t  break;\n+\t  if (! pfile->only_seen_white)\n+\t    skip_rest_of_line (pfile);\n+\t  token = cpp_get_token (pfile);\n+\t  if (token == CPP_EOF) /* Should not happen ...  */\n+\t    break;\n+\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t    {\n+\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile))\n+\t\t  != CPP_NULL_BUFFER (pfile))\n+\t\tcpp_pop_buffer (pfile);\n+\t      break;\n+\t    }\n+\t}\n+      CPP_SET_WRITTEN (pfile, old_written);\n+    }\n+  else\n+    {\n+      for (;;)\n+\t{\n+\t  token = cpp_get_token (pfile);\n+\t  if (token == CPP_EOF) /* Should not happen ...  */\n+\t    break;\n+\t  if (token == CPP_POP && CPP_BUFFER (pfile) == buffer)\n+\t    {\n+\t      if (CPP_PREV_BUFFER (CPP_BUFFER (pfile))\n+\t\t  != CPP_NULL_BUFFER (pfile))\n+\t\tcpp_pop_buffer (pfile);\n+\t      break;\n+\t    }\n \t}\n     }\n }\n@@ -760,13 +787,8 @@ cpp_expand_to_buffer (pfile, buf, length)\n      int length;\n {\n   register cpp_buffer *ip;\n-#if 0\n-  cpp_buffer obuf;\n-#endif\n   U_CHAR *buf1;\n-#if 0\n-  int odepth = indepth;\n-#endif\n+  int save_no_output;\n \n   if (length < 0)\n     {\n@@ -784,12 +806,12 @@ cpp_expand_to_buffer (pfile, buf, length)\n   if (ip == NULL)\n     return;\n   ip->has_escapes = 1;\n-#if 0\n-  ip->lineno = obuf.lineno = 1;\n-#endif\n \n   /* Scan the input, create the output.  */\n+  save_no_output = CPP_OPTIONS (pfile)->no_output;\n+  CPP_OPTIONS (pfile)->no_output = 0;\n   cpp_scan_buffer (pfile);\n+  CPP_OPTIONS (pfile)->no_output = save_no_output;\n \n   CPP_NUL_TERMINATE (pfile);\n }"}, {"sha": "e2b5614667b3a2803bae290e2c522bfc636974ec", "filename": "gcc/cppmain.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d83f44baa49fbeadb9b5c35cb15e3f8a860802f/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=5d83f44baa49fbeadb9b5c35cb15e3f8a860802f", "patch": "@@ -81,25 +81,35 @@ main (argc, argv)\n   else if (! freopen (opts->out_fname, \"w\", stdout))\n     cpp_pfatal_with_name (&parse_in, opts->out_fname);\n \n-  do\n+  if (! opts->no_output)\n     {\n-      kind = cpp_get_token (&parse_in);\n-      if (CPP_WRITTEN (&parse_in) >= BUFSIZ || kind == CPP_EOF)\n+      do\n \t{\n-\t  if (! opts->no_output)\n+\t  kind = cpp_get_token (&parse_in);\n+\t  if (CPP_WRITTEN (&parse_in) >= BUFSIZ || kind == CPP_EOF)\n \t    {\n \t      size_t rem, count = CPP_WRITTEN (&parse_in);\n \n \t      rem = fwrite (parse_in.token_buffer, 1, count, stdout);\n \t      if (rem < count)\n \t\t/* Write error. */\n \t\tcpp_pfatal_with_name (&parse_in, opts->out_fname);\n-\t    }\n \n-\t  CPP_SET_WRITTEN (&parse_in, 0);\n+\t      CPP_SET_WRITTEN (&parse_in, 0);\n+\t    }\n+\t}\n+      while (kind != CPP_EOF);\n+    }\n+  else\n+    {\n+      do\n+\t{\n+\t  cpp_scan_buffer (&parse_in);\n+\t  kind = cpp_get_token (&parse_in);\n \t}\n+      while (kind != CPP_EOF);\n+      CPP_SET_WRITTEN (&parse_in, 0);\n     }\n-  while (kind != CPP_EOF);\n \n   cpp_finish (&parse_in);\n   if (fwrite (parse_in.token_buffer, 1, CPP_WRITTEN (&parse_in), stdout)"}]}