{"sha": "3bb806ed995be40284e8617d32bc908f76626aee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JiODA2ZWQ5OTViZTQwMjg0ZTg2MTdkMzJiYzkwOGY3NjYyNmFlZQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-08-28T07:18:52Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-08-28T07:18:52Z"}, "message": "regmove.c (regclass_compatible_p): New function.\n\n        * regmove.c (regclass_compatible_p): New function.\n        (regmove_optimize): Use it.\n        Use NREGS parameter insted of calling max_reg_num.\n        (fixup_match_1): Don't use code = MINUS when later tieing with\n        a hard register is likely.\n\nFrom-SVN: r22052", "tree": {"sha": "dd67eeb902cd6b83a2c3b8cae6fc9ee53c874209", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd67eeb902cd6b83a2c3b8cae6fc9ee53c874209"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bb806ed995be40284e8617d32bc908f76626aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb806ed995be40284e8617d32bc908f76626aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb806ed995be40284e8617d32bc908f76626aee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb806ed995be40284e8617d32bc908f76626aee/comments", "author": null, "committer": null, "parents": [{"sha": "8ed69d0908630adcf3d385266d168f49d3ba1b5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ed69d0908630adcf3d385266d168f49d3ba1b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ed69d0908630adcf3d385266d168f49d3ba1b5e"}], "stats": {"total": 50, "additions": 37, "deletions": 13}, "files": [{"sha": "a4c535ac1b7e2408e772f4b8708f68de9f95ee14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb806ed995be40284e8617d32bc908f76626aee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb806ed995be40284e8617d32bc908f76626aee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bb806ed995be40284e8617d32bc908f76626aee", "patch": "@@ -1,3 +1,13 @@\n+Fri Aug 28 15:13:25 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+        * regmove.c (regclass_compatible_p): New function.\n+        (regmove_optimize): Use it.\n+\n+        Use NREGS parameter insted of calling max_reg_num.\n+\n+        (fixup_match_1): Don't use code = MINUS when later tieing with\n+        a hard register is likely.\n+\n Fri Aug 28 14:54:07 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* loop.c (check_dbra_loop): Fix calculation of FINAL_VALUE when"}, {"sha": "8df75e5c8aa19c654f8739a5d5949273ecc32c39", "filename": "gcc/regmove.c", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb806ed995be40284e8617d32bc908f76626aee/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb806ed995be40284e8617d32bc908f76626aee/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=3bb806ed995be40284e8617d32bc908f76626aee", "patch": "@@ -60,8 +60,22 @@ static int fixup_match_1 PROTO((rtx, rtx, rtx, rtx, rtx, int, int, int, FILE *))\n ;\n static int reg_is_remote_constant_p PROTO((rtx, rtx, rtx));\n static int stable_but_for_p PROTO((rtx, rtx, rtx));\n+static int regclass_compatible_p PROTO((int, int));\n static int loop_depth;\n \n+/* Return non-zero if registers with CLASS1 and CLASS2 can be merged without\n+   causing too much register allocation problems.  */\n+static int\n+regclass_compatible_p (class0, class1)\n+     int class0, class1;\n+{\n+  return (class0 == class1\n+\t  || (reg_class_subset_p (class0, class1)\n+\t      && ! CLASS_LIKELY_SPILLED_P (class0))\n+\t  || (reg_class_subset_p (class1, class0)\n+\t      && ! CLASS_LIKELY_SPILLED_P (class1)));\n+}\n+\n /* Generate and return an insn body to add r1 and c,\n    storing the result in r0.  */\n static rtx\n@@ -894,11 +908,11 @@ regmove_optimize (f, nregs, regmove_dump_file)\n   rtx insn;\n   struct match match;\n   int pass;\n-  int maxregnum = max_reg_num (), i;\n+  int i;\n   rtx copy_src, copy_dst;\n \n-  regno_src_regno = (int *)alloca (sizeof *regno_src_regno * maxregnum);\n-  for (i = maxregnum; --i >= 0; ) regno_src_regno[i] = -1;\n+  regno_src_regno = (int *)alloca (sizeof *regno_src_regno * nregs);\n+  for (i = nregs; --i >= 0; ) regno_src_regno[i] = -1;\n \n   regmove_bb_head = (int *)alloca (sizeof (int) * (get_max_uid () + 1));\n   for (i = get_max_uid (); i >= 0; i--) regmove_bb_head[i] = -1;\n@@ -1052,11 +1066,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n \t      src_class = reg_preferred_class (REGNO (src));\n \t      dst_class = reg_preferred_class (REGNO (dst));\n-\t      if (src_class != dst_class\n-\t\t  && (! reg_class_subset_p (src_class, dst_class)\n-\t\t      || CLASS_LIKELY_SPILLED_P (src_class))\n-\t\t  && (! reg_class_subset_p (dst_class, src_class)\n-\t\t      || CLASS_LIKELY_SPILLED_P (dst_class)))\n+\t      if (! regclass_compatible_p (src_class, dst_class))\n \t\tcontinue;\n \t  \n \t      if (fixup_match_1 (insn, set, src, src_subreg, dst, pass,\n@@ -1164,11 +1174,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t}\n \t      src_class = reg_preferred_class (REGNO (src));\n \t      dst_class = reg_preferred_class (REGNO (dst));\n-\t      if (src_class != dst_class\n-\t\t  && (! reg_class_subset_p (src_class, dst_class)\n-\t\t      || CLASS_LIKELY_SPILLED_P (src_class))\n-\t\t  && (! reg_class_subset_p (dst_class, src_class)\n-\t\t      || CLASS_LIKELY_SPILLED_P (dst_class)))\n+\t      if (! regclass_compatible_p (src_class, dst_class))\n \t\t{\n \t\t  if (!copy_src)\n \t\t    {\n@@ -1604,6 +1610,14 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t\t     This also gives opportunities for subsequent\n \t\t     optimizations in the backward pass, so do it there.  */\n \t\t  if (code == PLUS && backward\n+\t\t      /* Don't do this if we can likely tie DST to SET_DEST\n+\t\t\t of P later; we can't do this tying here if we got a\n+\t\t\t hard register.  */\n+\t\t      && ! (dst_note && ! REG_N_CALLS_CROSSED (REGNO (dst))\n+\t\t\t    && single_set (p)\n+\t\t\t    && GET_CODE (SET_DEST (single_set (p))) == REG\n+\t\t\t    && (REGNO (SET_DEST (single_set (p)))\n+\t\t\t\t< FIRST_PSEUDO_REGISTER))\n #ifdef HAVE_cc0\n \t\t      /* We may not emit an insn directly\n \t\t\t after P if the latter sets CC0.  */"}]}