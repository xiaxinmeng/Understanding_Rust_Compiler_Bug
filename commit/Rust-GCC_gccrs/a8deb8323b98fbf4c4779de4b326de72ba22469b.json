{"sha": "a8deb8323b98fbf4c4779de4b326de72ba22469b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThkZWI4MzIzYjk4ZmJmNGM0Nzc5ZGU0YjMyNmRlNzJiYTIyNDY5Yg==", "commit": {"author": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-04T21:26:58Z"}, "committer": {"name": "Tom Tromey", "email": "tom@tromey.com", "date": "2021-05-05T06:06:18Z"}, "message": "libcc1: share the GCC interface code\n\nBoth the C and C++ side of the GDB plugin in libcc1 share a lot of\ncode relating to the base GCC interface.  It was all copy-and-pasted,\nbut is essentially identical between the two.  This is by design, as\nthe base GCC API is intended to be shared.\n\nThis patch merges the implementations into base_gdb_plugin, which was\nintroduced earlier for this purpose.\n\nlibcc1\n\n\t* libcp1.cc (libcp1): Change parameters.  Update.\n\t(libcp1_set_verbose, libcp1_set_arguments)\n\t(libcp1_set_triplet_regexp, libcp1_set_driver_filename)\n\t(libcp1_set_source_file, libcp1_set_print_callback, fork_exec)\n\t(libcp1_compile, libcp1_destroy, vtable): Remove.\n\t(libcp1::add_callbacks): New method, extracted from\n\tlibcp1_compile.\n\t(gcc_c_fe_context): Update.\n\t* libcc1.cc (libcc1): Change parameters.  Update.\n\t(libcc1_set_verbose, libcc1_set_arguments)\n\t(libcc1_set_triplet_regexp, libcc1_set_driver_filename)\n\t(libcc1_set_source_file, libcc1_set_print_callback, fork_exec)\n\t(libcc1_compile, libcc1_destroy, vtable): Remove.\n\t(libcc1::add_callbacks): New method, extracted from\n\tlibcc1_compile.\n\t(gcc_c_fe_context): Update.\n\t* gdbctx.hh (base_gdb_plugin): Change parameters.\n\t(~base_gdb_plugin): New.\n\t<add_callbacks>: New virtual method.\n\t<plugin_name, fe_version, compiler_name, vtable>: New members.\n\t(get_self, do_set_verbose, do_set_arguments)\n\t(do_set_triplet_regexp, do_set_driver_filename)\n\t(do_set_arguments_v0, do_set_source_file, do_set_print_callback)\n\t(fork_exec, do_compile, do_compile_v0, do_destroy): New methods.", "tree": {"sha": "6e1b3439add29c8ba76b3e5750d39e2bbcc7a8c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e1b3439add29c8ba76b3e5750d39e2bbcc7a8c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8deb8323b98fbf4c4779de4b326de72ba22469b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8deb8323b98fbf4c4779de4b326de72ba22469b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8deb8323b98fbf4c4779de4b326de72ba22469b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8deb8323b98fbf4c4779de4b326de72ba22469b/comments", "author": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tromey", "id": 1557670, "node_id": "MDQ6VXNlcjE1NTc2NzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tromey", "html_url": "https://github.com/tromey", "followers_url": "https://api.github.com/users/tromey/followers", "following_url": "https://api.github.com/users/tromey/following{/other_user}", "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}", "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tromey/subscriptions", "organizations_url": "https://api.github.com/users/tromey/orgs", "repos_url": "https://api.github.com/users/tromey/repos", "events_url": "https://api.github.com/users/tromey/events{/privacy}", "received_events_url": "https://api.github.com/users/tromey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b65c0bcbe13b2b56a1e84856856548f2a29ada7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b65c0bcbe13b2b56a1e84856856548f2a29ada7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b65c0bcbe13b2b56a1e84856856548f2a29ada7e"}], "stats": {"total": 741, "additions": 277, "deletions": 464}, "files": [{"sha": "4a48381f2b4ae84ef2295c7fc43af780d34b965d", "filename": "libcc1/gdbctx.hh", "status": "modified", "additions": 251, "deletions": 2, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8deb8323b98fbf4c4779de4b326de72ba22469b/libcc1%2Fgdbctx.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8deb8323b98fbf4c4779de4b326de72ba22469b/libcc1%2Fgdbctx.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fgdbctx.hh?ref=a8deb8323b98fbf4c4779de4b326de72ba22469b", "patch": "@@ -23,16 +23,38 @@ along with GCC; see the file COPYING3.  If not see\n namespace cc1_plugin\n {\n   // The compiler context that we hand back to our caller.\n+  // Due to this, the entire implementation is in this header.\n   template<typename T>\n   struct base_gdb_plugin : public T\n   {\n-    explicit base_gdb_plugin (const gcc_base_vtable *v)\n+    base_gdb_plugin (const char *plugin_name_, const char *base_name,\n+\t\t     int version)\n       : verbose (false),\n+\tplugin_name (plugin_name_),\n+\tfe_version (version),\n+\tcompiler_name (base_name),\n \tcompilerp (new compiler (verbose))\n     {\n-      this->base.ops = v;\n+      vtable =\n+\t{\n+\t  GCC_FE_VERSION_1,\n+\t  do_set_arguments_v0,\n+\t  do_set_source_file,\n+\t  do_set_print_callback,\n+\t  do_compile_v0,\n+\t  do_destroy,\n+\t  do_set_verbose,\n+\t  do_compile,\n+\t  do_set_arguments,\n+\t  do_set_triplet_regexp,\n+\t  do_set_driver_filename,\n+\t};\n+\n+      this->base.ops = &vtable;\n     }\n \n+    virtual ~base_gdb_plugin () = default;\n+\n     // A convenience function to print something.\n     void print (const char *str)\n     {\n@@ -53,6 +75,10 @@ namespace cc1_plugin\n       connection.reset (new local_connection (fd, aux_fd, this));\n     }\n \n+    // This is called just before compilation begins.  It should set\n+    // any needed callbacks on the connection.\n+    virtual void add_callbacks () = 0;\n+\n     // A local subclass of connection that holds a back-pointer to the\n     // context object that we provide to our caller.\n     class local_connection : public cc1_plugin::connection\n@@ -84,7 +110,230 @@ namespace cc1_plugin\n     /* Non-zero as an equivalent to gcc driver option \"-v\".  */\n     bool verbose;\n \n+    const char *plugin_name;\n+    int fe_version;\n+\n+    const char *compiler_name;\n     std::unique_ptr<cc1_plugin::compiler> compilerp;\n+\n+  private:\n+\n+    struct gcc_base_vtable vtable;\n+\n+    static inline base_gdb_plugin<T> *\n+    get_self (gcc_base_context *s)\n+    {\n+      T *sub = (T *) s;\n+      return static_cast<base_gdb_plugin<T> *> (sub);\n+    }\n+\n+    static void\n+    do_set_verbose (struct gcc_base_context *s, int /* bool */ verbose)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      self->set_verbose (verbose != 0);\n+    }\n+\n+    static char *\n+    do_set_arguments (struct gcc_base_context *s,\n+\t\t      int argc, char **argv)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      std::string compiler;\n+      char *errmsg = self->compilerp->find (self->compiler_name, compiler);\n+      if (errmsg != NULL)\n+\treturn errmsg;\n+\n+      self->args.push_back (compiler);\n+\n+      for (int i = 0; i < argc; ++i)\n+\tself->args.push_back (argv[i]);\n+\n+      return NULL;\n+    }\n+\n+    static char *\n+    do_set_triplet_regexp (struct gcc_base_context *s,\n+\t\t\t   const char *triplet_regexp)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      self->compilerp.reset\n+\t(new cc1_plugin::compiler_triplet_regexp (self->verbose,\n+\t\t\t\t\t\t  triplet_regexp));\n+      return NULL;\n+    }\n+\n+    static char *\n+    do_set_driver_filename (struct gcc_base_context *s,\n+\t\t\t    const char *driver_filename)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      self->compilerp.reset\n+\t(new cc1_plugin::compiler_driver_filename (self->verbose,\n+\t\t\t\t\t\t   driver_filename));\n+      return NULL;\n+    }\n+\n+    static char *\n+    do_set_arguments_v0 (struct gcc_base_context *s,\n+\t\t\t const char *triplet_regexp,\n+\t\t\t int argc, char **argv)\n+    {\n+      char *errmsg = do_set_triplet_regexp (s, triplet_regexp);\n+      if (errmsg != NULL)\n+\treturn errmsg;\n+\n+      return do_set_arguments (s, argc, argv);\n+    }\n+\n+    static void\n+    do_set_source_file (struct gcc_base_context *s,\n+\t\t\tconst char *file)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      self->source_file = file;\n+    }\n+\n+    static void\n+    do_set_print_callback (struct gcc_base_context *s,\n+\t\t\t   void (*print_function) (void *datum,\n+\t\t\t\t\t\t   const char *message),\n+\t\t\t   void *datum)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      self->print_function = print_function;\n+      self->print_datum = datum;\n+    }\n+\n+    int fork_exec (char **argv, int spair_fds[2], int stderr_fds[2])\n+    {\n+      pid_t child_pid = fork ();\n+\n+      if (child_pid == -1)\n+\t{\n+\t  close (spair_fds[0]);\n+\t  close (spair_fds[1]);\n+\t  close (stderr_fds[0]);\n+\t  close (stderr_fds[1]);\n+\t  return 0;\n+\t}\n+\n+      if (child_pid == 0)\n+\t{\n+\t  // Child.\n+\t  dup2 (stderr_fds[1], 1);\n+\t  dup2 (stderr_fds[1], 2);\n+\t  close (stderr_fds[0]);\n+\t  close (stderr_fds[1]);\n+\t  close (spair_fds[0]);\n+\n+\t  execvp (argv[0], argv);\n+\t  _exit (127);\n+\t}\n+      else\n+\t{\n+\t  // Parent.\n+\t  close (spair_fds[1]);\n+\t  close (stderr_fds[1]);\n+\n+\t  cc1_plugin::status result = cc1_plugin::FAIL;\n+\t  if (connection->send ('H')\n+\t      && ::cc1_plugin::marshall (connection.get (), fe_version))\n+\t    result = connection->wait_for_query ();\n+\n+\t  close (spair_fds[0]);\n+\t  close (stderr_fds[0]);\n+\n+\t  while (true)\n+\t    {\n+\t      int status;\n+\n+\t      if (waitpid (child_pid, &status, 0) == -1)\n+\t\t{\n+\t\t  if (errno != EINTR)\n+\t\t    return 0;\n+\t\t}\n+\n+\t      if (!WIFEXITED (status) || WEXITSTATUS (status) != 0)\n+\t\treturn 0;\n+\t      break;\n+\t    }\n+\n+\t  if (!result)\n+\t    return 0;\n+\t  return 1;\n+\t}\n+    }\n+\n+    static int\n+    do_compile (struct gcc_base_context *s,\n+\t\tconst char *filename)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      int fds[2];\n+      if (socketpair (AF_UNIX, SOCK_STREAM, 0, fds) != 0)\n+\t{\n+\t  self->print (\"could not create socketpair\\n\");\n+\t  return 0;\n+\t}\n+\n+      int stderr_fds[2];\n+      if (pipe (stderr_fds) != 0)\n+\t{\n+\t  self->print (\"could not create pipe\\n\");\n+\t  close (fds[0]);\n+\t  close (fds[1]);\n+\t  return 0;\n+\t}\n+\n+      self->args.push_back (std::string (\"-fplugin=\") + self->plugin_name);\n+      self->args.push_back (std::string (\"-fplugin-arg-\") + self->plugin_name\n+\t\t\t    + \"-fd=\" + std::to_string (fds[1]));\n+\n+      self->args.push_back (self->source_file);\n+      self->args.push_back (\"-c\");\n+      self->args.push_back (\"-o\");\n+      self->args.push_back (filename);\n+      if (self->verbose)\n+\tself->args.push_back (\"-v\");\n+\n+      self->set_connection (fds[0], stderr_fds[0]);\n+\n+      self->add_callbacks ();\n+\n+      char **argv = new (std::nothrow) char *[self->args.size () + 1];\n+      if (argv == NULL)\n+\treturn 0;\n+\n+      for (unsigned int i = 0; i < self->args.size (); ++i)\n+\targv[i] = const_cast<char *> (self->args[i].c_str ());\n+      argv[self->args.size ()] = NULL;\n+\n+      return self->fork_exec (argv, fds, stderr_fds);\n+    }\n+\n+    static int\n+    do_compile_v0 (struct gcc_base_context *s, const char *filename,\n+\t\t   int verbose)\n+    {\n+      do_set_verbose (s, verbose);\n+      return do_compile (s, filename);\n+    }\n+\n+    static void\n+    do_destroy (struct gcc_base_context *s)\n+    {\n+      base_gdb_plugin<T> *self = get_self (s);\n+\n+      delete self;\n+    }\n   };\n \n   // Instances of this rpc<> template function are installed into the"}, {"sha": "cbc54ee0a0444950444aee3fbcadbdcf322c9918", "filename": "libcc1/libcc1.cc", "status": "modified", "additions": 12, "deletions": 230, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8deb8323b98fbf4c4779de4b326de72ba22469b/libcc1%2Flibcc1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8deb8323b98fbf4c4779de4b326de72ba22469b/libcc1%2Flibcc1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1.cc?ref=a8deb8323b98fbf4c4779de4b326de72ba22469b", "patch": "@@ -42,15 +42,19 @@ along with GCC; see the file COPYING3.  If not see\n // The C compiler context that we hand back to our caller.\n struct libcc1 : public cc1_plugin::base_gdb_plugin<gcc_c_context>\n {\n-  libcc1 (const gcc_base_vtable *, const gcc_c_fe_vtable *);\n+  explicit libcc1 (const gcc_c_fe_vtable *);\n+\n+  void add_callbacks () override;\n \n   gcc_c_oracle_function *binding_oracle = nullptr;\n   gcc_c_symbol_address_function *address_oracle = nullptr;\n   void *oracle_datum = nullptr;\n };\n \n-libcc1::libcc1 (const gcc_base_vtable *v, const gcc_c_fe_vtable *cv)\n-  : cc1_plugin::base_gdb_plugin<gcc_c_context> (v)\n+libcc1::libcc1 (const gcc_c_fe_vtable *cv)\n+  : cc1_plugin::base_gdb_plugin<gcc_c_context> (\"libcc1plugin\",\n+\t\t\t\t\t\tC_COMPILER_NAME,\n+\t\t\t\t\t\tGCC_C_FE_VERSION_1)\n {\n   c_ops = cv;\n }\n@@ -135,244 +139,22 @@ static const struct gcc_c_fe_vtable c_vtable =\n \n \f\n \n-static void\n-libcc1_set_verbose (struct gcc_base_context *s, int /* bool */ verbose)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  self->set_verbose (verbose != 0);\n-}\n-\n-static char *\n-libcc1_set_arguments (struct gcc_base_context *s,\n-\t\t      int argc, char **argv)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  std::string compiler;\n-  char *errmsg = self->compilerp->find (C_COMPILER_NAME, compiler);\n-  if (errmsg != NULL)\n-    return errmsg;\n-\n-  self->args.push_back (compiler);\n-\n-  for (int i = 0; i < argc; ++i)\n-    self->args.push_back (argv[i]);\n-\n-  return NULL;\n-}\n-\n-static char *\n-libcc1_set_triplet_regexp (struct gcc_base_context *s,\n-\t\t\t   const char *triplet_regexp)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  self->compilerp.reset\n-    (new cc1_plugin::compiler_triplet_regexp (self->verbose,\n-\t\t\t\t\t      triplet_regexp));\n-  return NULL;\n-}\n-\n-static char *\n-libcc1_set_driver_filename (struct gcc_base_context *s,\n-\t\t\t    const char *driver_filename)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  self->compilerp.reset\n-    (new cc1_plugin::compiler_driver_filename (self->verbose,\n-\t\t\t\t\t       driver_filename));\n-  return NULL;\n-}\n-\n-static char *\n-libcc1_set_arguments_v0 (struct gcc_base_context *s,\n-\t\t\t const char *triplet_regexp,\n-\t\t\t int argc, char **argv)\n+void\n+libcc1::add_callbacks ()\n {\n-  char *errmsg = libcc1_set_triplet_regexp (s, triplet_regexp);\n-  if (errmsg != NULL)\n-    return errmsg;\n-\n-  return libcc1_set_arguments (s, argc, argv);\n-}\n-\n-static void\n-libcc1_set_source_file (struct gcc_base_context *s,\n-\t\t\tconst char *file)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  self->source_file = file;\n-}\n-\n-static void\n-libcc1_set_print_callback (struct gcc_base_context *s,\n-\t\t\t   void (*print_function) (void *datum,\n-\t\t\t\t\t\t   const char *message),\n-\t\t\t   void *datum)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  self->print_function = print_function;\n-  self->print_datum = datum;\n-}\n-\n-static int\n-fork_exec (libcc1 *self, char **argv, int spair_fds[2], int stderr_fds[2])\n-{\n-  pid_t child_pid = fork ();\n-\n-  if (child_pid == -1)\n-    {\n-      close (spair_fds[0]);\n-      close (spair_fds[1]);\n-      close (stderr_fds[0]);\n-      close (stderr_fds[1]);\n-      return 0;\n-    }\n-\n-  if (child_pid == 0)\n-    {\n-      // Child.\n-      dup2 (stderr_fds[1], 1);\n-      dup2 (stderr_fds[1], 2);\n-      close (stderr_fds[0]);\n-      close (stderr_fds[1]);\n-      close (spair_fds[0]);\n-\n-      execvp (argv[0], argv);\n-      _exit (127);\n-    }\n-  else\n-    {\n-      // Parent.\n-      close (spair_fds[1]);\n-      close (stderr_fds[1]);\n-\n-      cc1_plugin::status result = cc1_plugin::FAIL;\n-      if (self->connection->send ('H')\n-\t  && ::cc1_plugin::marshall (self->connection.get (),\n-\t\t\t\t     GCC_C_FE_VERSION_1))\n-\tresult = self->connection->wait_for_query ();\n-\n-      close (spair_fds[0]);\n-      close (stderr_fds[0]);\n-\n-      while (true)\n-\t{\n-\t  int status;\n-\n-\t  if (waitpid (child_pid, &status, 0) == -1)\n-\t    {\n-\t      if (errno != EINTR)\n-\t\treturn 0;\n-\t    }\n-\n-\t  if (!WIFEXITED (status) || WEXITSTATUS (status) != 0)\n-\t    return 0;\n-\t  break;\n-\t}\n-\n-      if (!result)\n-\treturn 0;\n-      return 1;\n-    }\n-}\n-\n-static int\n-libcc1_compile (struct gcc_base_context *s,\n-\t\tconst char *filename)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  int fds[2];\n-  if (socketpair (AF_UNIX, SOCK_STREAM, 0, fds) != 0)\n-    {\n-      self->print (\"could not create socketpair\\n\");\n-      return 0;\n-    }\n-\n-  int stderr_fds[2];\n-  if (pipe (stderr_fds) != 0)\n-    {\n-      self->print (\"could not create pipe\\n\");\n-      close (fds[0]);\n-      close (fds[1]);\n-      return 0;\n-    }\n-\n-  self->args.push_back (\"-fplugin=libcc1plugin\");\n-  char buf[100];\n-  if (snprintf (buf, sizeof (buf), \"-fplugin-arg-libcc1plugin-fd=%d\", fds[1])\n-      >= (long) sizeof (buf))\n-    abort ();\n-  self->args.push_back (buf);\n-\n-  self->args.push_back (self->source_file);\n-  self->args.push_back (\"-c\");\n-  self->args.push_back (\"-o\");\n-  self->args.push_back (filename);\n-  if (self->verbose)\n-    self->args.push_back (\"-v\");\n-\n-  self->set_connection (fds[0], stderr_fds[0]);\n-\n   cc1_plugin::callback_ftype *fun\n     = cc1_plugin::callback<int,\n \t\t\t   enum gcc_c_oracle_request,\n \t\t\t   const char *,\n \t\t\t   c_call_binding_oracle>;\n-  self->connection->add_callback (\"binding_oracle\", fun);\n+  connection->add_callback (\"binding_oracle\", fun);\n \n   fun = cc1_plugin::callback<gcc_address,\n \t\t\t     const char *,\n \t\t\t     c_call_symbol_address>;\n-  self->connection->add_callback (\"address_oracle\", fun);\n-\n-  char **argv = new (std::nothrow) char *[self->args.size () + 1];\n-  if (argv == NULL)\n-    return 0;\n-\n-  for (unsigned int i = 0; i < self->args.size (); ++i)\n-    argv[i] = const_cast<char *> (self->args[i].c_str ());\n-  argv[self->args.size ()] = NULL;\n-\n-  return fork_exec (self, argv, fds, stderr_fds);\n-}\n-\n-static int\n-libcc1_compile_v0 (struct gcc_base_context *s, const char *filename,\n-\t\t   int verbose)\n-{\n-  libcc1_set_verbose (s, verbose);\n-  return libcc1_compile (s, filename);\n+  connection->add_callback (\"address_oracle\", fun);\n }\n \n-static void\n-libcc1_destroy (struct gcc_base_context *s)\n-{\n-  libcc1 *self = (libcc1 *) s;\n-\n-  delete self;\n-}\n-\n-static const struct gcc_base_vtable vtable =\n-{\n-  GCC_FE_VERSION_1,\n-  libcc1_set_arguments_v0,\n-  libcc1_set_source_file,\n-  libcc1_set_print_callback,\n-  libcc1_compile_v0,\n-  libcc1_destroy,\n-  libcc1_set_verbose,\n-  libcc1_compile,\n-  libcc1_set_arguments,\n-  libcc1_set_triplet_regexp,\n-  libcc1_set_driver_filename,\n-};\n-\n extern \"C\" gcc_c_fe_context_function gcc_c_fe_context;\n \n #ifdef __GNUC__\n@@ -388,5 +170,5 @@ gcc_c_fe_context (enum gcc_base_api_version base_version,\n       || (c_version != GCC_C_FE_VERSION_0 && c_version != GCC_C_FE_VERSION_1))\n     return NULL;\n \n-  return new libcc1 (&vtable, &c_vtable);\n+  return new libcc1 (&c_vtable);\n }"}, {"sha": "d22d9dc6af8c51c1825f91c3764e2148e06315e8", "filename": "libcc1/libcp1.cc", "status": "modified", "additions": 14, "deletions": 232, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8deb8323b98fbf4c4779de4b326de72ba22469b/libcc1%2Flibcp1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8deb8323b98fbf4c4779de4b326de72ba22469b/libcc1%2Flibcp1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1.cc?ref=a8deb8323b98fbf4c4779de4b326de72ba22469b", "patch": "@@ -41,7 +41,9 @@ along with GCC; see the file COPYING3.  If not see\n // The C compiler context that we hand back to our caller.\n struct libcp1 : public cc1_plugin::base_gdb_plugin<gcc_cp_context>\n {\n-  libcp1 (const gcc_base_vtable *, const gcc_cp_fe_vtable *);\n+  explicit libcp1 (const gcc_cp_fe_vtable *);\n+\n+  void add_callbacks () override;\n \n   gcc_cp_oracle_function *binding_oracle = nullptr;\n   gcc_cp_symbol_address_function *address_oracle = nullptr;\n@@ -50,8 +52,10 @@ struct libcp1 : public cc1_plugin::base_gdb_plugin<gcc_cp_context>\n   void *oracle_datum = nullptr;\n };\n \n-libcp1::libcp1 (const gcc_base_vtable *v, const gcc_cp_fe_vtable *cv)\n-  : cc1_plugin::base_gdb_plugin<gcc_cp_context> (v)\n+libcp1::libcp1 (const gcc_cp_fe_vtable *cv)\n+  : cc1_plugin::base_gdb_plugin<gcc_cp_context> (\"libcp1plugin\",\n+\t\t\t\t\t\t CP_COMPILER_NAME,\n+\t\t\t\t\t\t GCC_CP_FE_VERSION_0)\n {\n   cp_ops = cv;\n }\n@@ -158,252 +162,30 @@ static const struct gcc_cp_fe_vtable cp_vtable =\n \n \f\n \n-static void\n-libcp1_set_verbose (struct gcc_base_context *s, int /* bool */ verbose)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  self->set_verbose (verbose != 0);\n-}\n-\n-static char *\n-libcp1_set_arguments (struct gcc_base_context *s,\n-\t\t      int argc, char **argv)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  std::string compiler;\n-  char *errmsg = self->compilerp->find (CP_COMPILER_NAME, compiler);\n-  if (errmsg != NULL)\n-    return errmsg;\n-\n-  self->args.push_back (compiler);\n-\n-  for (int i = 0; i < argc; ++i)\n-    self->args.push_back (argv[i]);\n-\n-  return NULL;\n-}\n-\n-static char *\n-libcp1_set_triplet_regexp (struct gcc_base_context *s,\n-\t\t\t   const char *triplet_regexp)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  self->compilerp.reset\n-    (new cc1_plugin::compiler_triplet_regexp (self->verbose,\n-\t\t\t\t\t      triplet_regexp));\n-  return NULL;\n-}\n-\n-static char *\n-libcp1_set_driver_filename (struct gcc_base_context *s,\n-\t\t\t    const char *driver_filename)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  self->compilerp.reset\n-    (new cc1_plugin::compiler_driver_filename (self->verbose,\n-\t\t\t\t\t       driver_filename));\n-  return NULL;\n-}\n-\n-static char *\n-libcp1_set_arguments_v0 (struct gcc_base_context *s,\n-\t\t\t const char *triplet_regexp,\n-\t\t\t int argc, char **argv)\n-{\n-  char *errmsg = libcp1_set_triplet_regexp (s, triplet_regexp);\n-  if (errmsg != NULL)\n-    return errmsg;\n-\n-  return libcp1_set_arguments (s, argc, argv);\n-}\n-\n-static void\n-libcp1_set_source_file (struct gcc_base_context *s,\n-\t\t\t const char *file)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  self->source_file = file;\n-}\n-\n-static void\n-libcp1_set_print_callback (struct gcc_base_context *s,\n-\t\t\t    void (*print_function) (void *datum,\n-\t\t\t\t\t\t    const char *message),\n-\t\t\t    void *datum)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  self->print_function = print_function;\n-  self->print_datum = datum;\n-}\n-\n-static int\n-fork_exec (libcp1 *self, char **argv, int spair_fds[2], int stderr_fds[2])\n-{\n-  pid_t child_pid = fork ();\n-\n-  if (child_pid == -1)\n-    {\n-      close (spair_fds[0]);\n-      close (spair_fds[1]);\n-      close (stderr_fds[0]);\n-      close (stderr_fds[1]);\n-      return 0;\n-    }\n-\n-  if (child_pid == 0)\n-    {\n-      // Child.\n-      dup2 (stderr_fds[1], 1);\n-      dup2 (stderr_fds[1], 2);\n-      close (stderr_fds[0]);\n-      close (stderr_fds[1]);\n-      close (spair_fds[0]);\n-\n-      execvp (argv[0], argv);\n-      _exit (127);\n-    }\n-  else\n-    {\n-      // Parent.\n-      close (spair_fds[1]);\n-      close (stderr_fds[1]);\n-\n-      cc1_plugin::status result = cc1_plugin::FAIL;\n-      if (self->connection->send ('H')\n-\t  && ::cc1_plugin::marshall (self->connection.get (),\n-\t\t\t\t     GCC_CP_FE_VERSION_0))\n-\tresult = self->connection->wait_for_query ();\n-\n-      close (spair_fds[0]);\n-      close (stderr_fds[0]);\n-\n-      while (true)\n-\t{\n-\t  int status;\n-\n-\t  if (waitpid (child_pid, &status, 0) == -1)\n-\t    {\n-\t      if (errno != EINTR)\n-\t\treturn 0;\n-\t    }\n-\n-\t  if (!WIFEXITED (status) || WEXITSTATUS (status) != 0)\n-\t    return 0;\n-\t  break;\n-\t}\n-\n-      if (!result)\n-\treturn 0;\n-      return 1;\n-    }\n-}\n-\n-static int\n-libcp1_compile (struct gcc_base_context *s,\n-\t\tconst char *filename)\n+void\n+libcp1::add_callbacks ()\n {\n-  libcp1 *self = (libcp1 *) s;\n-\n-  int fds[2];\n-  if (socketpair (AF_UNIX, SOCK_STREAM, 0, fds) != 0)\n-    {\n-      self->print (\"could not create socketpair\\n\");\n-      return 0;\n-    }\n-\n-  int stderr_fds[2];\n-  if (pipe (stderr_fds) != 0)\n-    {\n-      self->print (\"could not create pipe\\n\");\n-      close (fds[0]);\n-      close (fds[1]);\n-      return 0;\n-    }\n-\n-  self->args.push_back (\"-fplugin=libcp1plugin\");\n-  char buf[100];\n-  if (snprintf (buf, sizeof (buf), \"-fplugin-arg-libcp1plugin-fd=%d\", fds[1])\n-      >= (long) sizeof (buf))\n-    abort ();\n-  self->args.push_back (buf);\n-\n-  self->args.push_back (self->source_file);\n-  self->args.push_back (\"-c\");\n-  self->args.push_back (\"-o\");\n-  self->args.push_back (filename);\n-  if (self->verbose)\n-    self->args.push_back (\"-v\");\n-\n-  self->set_connection (fds[0], stderr_fds[0]);\n-\n   cc1_plugin::callback_ftype *fun\n     = cc1_plugin::callback<int,\n \t\t\t   enum gcc_cp_oracle_request,\n \t\t\t   const char *,\n \t\t\t   cp_call_binding_oracle>;\n-  self->connection->add_callback (\"binding_oracle\", fun);\n+  connection->add_callback (\"binding_oracle\", fun);\n \n   fun = cc1_plugin::callback<gcc_address,\n \t\t\t     const char *,\n \t\t\t     cp_call_symbol_address>;\n-  self->connection->add_callback (\"address_oracle\", fun);\n+  connection->add_callback (\"address_oracle\", fun);\n \n   fun = cc1_plugin::callback<int,\n \t\t\t     cp_call_enter_scope>;\n-  self->connection->add_callback (\"enter_scope\", fun);\n+  connection->add_callback (\"enter_scope\", fun);\n \n   fun = cc1_plugin::callback<int,\n \t\t\t     cp_call_leave_scope>;\n-  self->connection->add_callback (\"leave_scope\", fun);\n-\n-  char **argv = new (std::nothrow) char *[self->args.size () + 1];\n-  if (argv == NULL)\n-    return 0;\n-\n-  for (unsigned int i = 0; i < self->args.size (); ++i)\n-    argv[i] = const_cast<char *> (self->args[i].c_str ());\n-  argv[self->args.size ()] = NULL;\n-\n-  return fork_exec (self, argv, fds, stderr_fds);\n-}\n-\n-static int\n-libcp1_compile_v0 (struct gcc_base_context *s, const char *filename,\n-\t\t   int verbose)\n-{\n-  libcp1_set_verbose (s, verbose);\n-  return libcp1_compile (s, filename);\n+  connection->add_callback (\"leave_scope\", fun);\n }\n \n-static void\n-libcp1_destroy (struct gcc_base_context *s)\n-{\n-  libcp1 *self = (libcp1 *) s;\n-\n-  delete self;\n-}\n-\n-static const struct gcc_base_vtable vtable =\n-{\n-  GCC_FE_VERSION_1,\n-  libcp1_set_arguments_v0,\n-  libcp1_set_source_file,\n-  libcp1_set_print_callback,\n-  libcp1_compile_v0,\n-  libcp1_destroy,\n-  libcp1_set_verbose,\n-  libcp1_compile,\n-  libcp1_set_arguments,\n-  libcp1_set_triplet_regexp,\n-  libcp1_set_driver_filename,\n-};\n-\n extern \"C\" gcc_cp_fe_context_function gcc_cp_fe_context;\n \n #ifdef __GNUC__\n@@ -419,5 +201,5 @@ gcc_cp_fe_context (enum gcc_base_api_version base_version,\n       || cp_version != GCC_CP_FE_VERSION_0)\n     return NULL;\n \n-  return new libcp1 (&vtable, &cp_vtable);\n+  return new libcp1 (&cp_vtable);\n }"}]}