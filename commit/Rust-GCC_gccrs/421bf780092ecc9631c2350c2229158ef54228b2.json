{"sha": "421bf780092ecc9631c2350c2229158ef54228b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDIxYmY3ODAwOTJlY2M5NjMxYzIzNTBjMjIyOTE1OGVmNTQyMjhiMg==", "commit": {"author": {"name": "Marc Glisse", "email": "marc.glisse@inria.fr", "date": "2014-05-08T13:17:01Z"}, "committer": {"name": "Marc Glisse", "email": "glisse@gcc.gnu.org", "date": "2014-05-08T13:17:01Z"}, "message": "re PR tree-optimization/59100 (requesting optimization of safe rotate function)\n\n2014-05-08  Marc Glisse  <marc.glisse@inria.fr>\n\n\tPR tree-optimization/59100\ngcc/\n\t* tree-ssa-phiopt.c: Include tree-inline.h.\n\t(neutral_element_p, absorbing_element_p): New functions.\n\t(value_replacement): Handle conditional binary operations with a\n\tneutral or absorbing element.\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/phi-opt-12.c: New file.\n\t* gcc.dg/tree-ssa/phi-opt-13.c: Likewise.\n\nFrom-SVN: r210212", "tree": {"sha": "ba4f432f8402ceb0cdd18854c09f3615a8c2fbd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba4f432f8402ceb0cdd18854c09f3615a8c2fbd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/421bf780092ecc9631c2350c2229158ef54228b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421bf780092ecc9631c2350c2229158ef54228b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/421bf780092ecc9631c2350c2229158ef54228b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421bf780092ecc9631c2350c2229158ef54228b2/comments", "author": {"login": "mglisse", "id": 10097863, "node_id": "MDQ6VXNlcjEwMDk3ODYz", "avatar_url": "https://avatars.githubusercontent.com/u/10097863?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mglisse", "html_url": "https://github.com/mglisse", "followers_url": "https://api.github.com/users/mglisse/followers", "following_url": "https://api.github.com/users/mglisse/following{/other_user}", "gists_url": "https://api.github.com/users/mglisse/gists{/gist_id}", "starred_url": "https://api.github.com/users/mglisse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mglisse/subscriptions", "organizations_url": "https://api.github.com/users/mglisse/orgs", "repos_url": "https://api.github.com/users/mglisse/repos", "events_url": "https://api.github.com/users/mglisse/events{/privacy}", "received_events_url": "https://api.github.com/users/mglisse/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5eaec4266e37aee0ec6cf28543776f12604b5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5eaec4266e37aee0ec6cf28543776f12604b5e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5eaec4266e37aee0ec6cf28543776f12604b5e9"}], "stats": {"total": 160, "additions": 157, "deletions": 3}, "files": [{"sha": "5b036768d66e0f533a51f8a487ade7c113b008df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=421bf780092ecc9631c2350c2229158ef54228b2", "patch": "@@ -1,3 +1,11 @@\n+2014-05-08  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/59100\n+\t* tree-ssa-phiopt.c: Include tree-inline.h.\n+\t(neutral_element_p, absorbing_element_p): New functions.\n+\t(value_replacement): Handle conditional binary operations with a\n+\tneutral or absorbing element.\n+\n 2014-05-08  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-sccvn.c (vn_get_expr_for): Valueize operands before"}, {"sha": "ad7a652e3f9d226a42b7b761bbc2d34d204fac70", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=421bf780092ecc9631c2350c2229158ef54228b2", "patch": "@@ -1,3 +1,9 @@\n+2014-05-08  Marc Glisse  <marc.glisse@inria.fr>\n+\n+\tPR tree-optimization/59100\n+\t* gcc.dg/tree-ssa/phi-opt-12.c: New file.\n+\t* gcc.dg/tree-ssa/phi-opt-13.c: Likewise.\n+\n 2014-05-08  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tPR tree-optimization/61095"}, {"sha": "b52c6d711a75c7f6e2097e0a0cc15a93f53c20bd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-12.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-12.c?ref=421bf780092ecc9631c2350c2229158ef54228b2", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-phiopt1\" } */\n+\n+int f(int a, int b, int c) {\n+  if (c > 5) return c;\n+  if (a == 0) return b;\n+  return a + b;\n+}\n+\n+unsigned rot(unsigned x, int n) {\n+  const int bits = __CHAR_BIT__ * __SIZEOF_INT__;\n+  return (n == 0) ? x : ((x << n) | (x >> (bits - n)));\n+}\n+\n+unsigned m(unsigned a, unsigned b) {\n+  if (a == 0)\n+    return 0;\n+  else\n+    return a & b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"goto\" 2 \"phiopt1\" } } */\n+/* { dg-final { cleanup-tree-dump \"phiopt1\" } } */"}, {"sha": "3e09c218890312de825aa29002e1f1c70dae137d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/phi-opt-13.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fphi-opt-13.c?ref=421bf780092ecc9631c2350c2229158ef54228b2", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+// Division is expensive\n+long f(long a, long b) {\n+  if (__builtin_expect(b == 1, 1)) return a;\n+  return a / b;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"goto \" 2 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d4aaf42b2a5f0eada943dfbfa40a8f39ff155b7b", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 109, "deletions": 3, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/421bf780092ecc9631c2350c2229158ef54228b2/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=421bf780092ecc9631c2350c2229158ef54228b2", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"optabs.h\"\n #include \"tree-scalar-evolution.h\"\n+#include \"tree-inline.h\"\n \n #ifndef HAVE_conditional_move\n #define HAVE_conditional_move (0)\n@@ -659,6 +660,64 @@ operand_equal_for_value_replacement (const_tree arg0, const_tree arg1,\n   return false;\n }\n \n+/* Returns true if ARG is a neutral element for operation CODE\n+   on the RIGHT side.  */\n+\n+static bool\n+neutral_element_p (tree_code code, tree arg, bool right)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      return integer_zerop (arg);\n+\n+    case LROTATE_EXPR:\n+    case RROTATE_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case MINUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+      return right && integer_zerop (arg);\n+\n+    case MULT_EXPR:\n+      return integer_onep (arg);\n+\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      return right && integer_onep (arg);\n+\n+    case BIT_AND_EXPR:\n+      return integer_all_onesp (arg);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Returns true if ARG is an absorbing element for operation CODE.  */\n+\n+static bool\n+absorbing_element_p (tree_code code, tree arg)\n+{\n+  switch (code)\n+    {\n+    case BIT_IOR_EXPR:\n+      return integer_all_onesp (arg);\n+\n+    case MULT_EXPR:\n+    case BIT_AND_EXPR:\n+      return integer_zerop (arg);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /*  The function value_replacement does the main work of doing the value\n     replacement.  Return non-zero if the replacement is done.  Otherwise return\n     0.  If we remove the middle basic block, return 2.\n@@ -683,9 +742,7 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \n   /* If there is a statement in MIDDLE_BB that defines one of the PHI\n      arguments, then adjust arg0 or arg1.  */\n-  gsi = gsi_after_labels (middle_bb);\n-  if (!gsi_end_p (gsi) && is_gimple_debug (gsi_stmt (gsi)))\n-    gsi_next_nondebug (&gsi);\n+  gsi = gsi_start_nondebug_after_labels_bb (middle_bb);\n   while (!gsi_end_p (gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n@@ -781,6 +838,55 @@ value_replacement (basic_block cond_bb, basic_block middle_bb,\n \t}\n \n     }\n+\n+  /* Now optimize (x != 0) ? x + y : y to just y.\n+     The following condition is too restrictive, there can easily be another\n+     stmt in middle_bb, for instance a CONVERT_EXPR for the second argument.  */\n+  gimple assign = last_and_only_stmt (middle_bb);\n+  if (!assign || gimple_code (assign) != GIMPLE_ASSIGN\n+      || gimple_assign_rhs_class (assign) != GIMPLE_BINARY_RHS\n+      || (!INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n+\t  && !POINTER_TYPE_P (TREE_TYPE (arg0))))\n+    return 0;\n+\n+  /* Size-wise, this is always profitable.  */\n+  if (optimize_bb_for_speed_p (cond_bb)\n+      /* The special case is useless if it has a low probability.  */\n+      && profile_status_for_fn (cfun) != PROFILE_ABSENT\n+      && EDGE_PRED (middle_bb, 0)->probability < PROB_EVEN\n+      /* If assign is cheap, there is no point avoiding it.  */\n+      && estimate_num_insns (assign, &eni_time_weights)\n+\t >= 3 * estimate_num_insns (cond, &eni_time_weights))\n+    return 0;\n+\n+  tree lhs = gimple_assign_lhs (assign);\n+  tree rhs1 = gimple_assign_rhs1 (assign);\n+  tree rhs2 = gimple_assign_rhs2 (assign);\n+  enum tree_code code_def = gimple_assign_rhs_code (assign);\n+  tree cond_lhs = gimple_cond_lhs (cond);\n+  tree cond_rhs = gimple_cond_rhs (cond);\n+\n+  if (((code == NE_EXPR && e1 == false_edge)\n+\t|| (code == EQ_EXPR && e1 == true_edge))\n+      && arg0 == lhs\n+      && ((arg1 == rhs1\n+\t   && operand_equal_for_phi_arg_p (rhs2, cond_lhs)\n+\t   && neutral_element_p (code_def, cond_rhs, true))\n+\t  || (arg1 == rhs2\n+\t      && operand_equal_for_phi_arg_p (rhs1, cond_lhs)\n+\t      && neutral_element_p (code_def, cond_rhs, false))\n+\t  || (operand_equal_for_phi_arg_p (arg1, cond_rhs)\n+\t      && (operand_equal_for_phi_arg_p (rhs2, cond_lhs)\n+\t\t  || operand_equal_for_phi_arg_p (rhs1, cond_lhs))\n+\t      && absorbing_element_p (code_def, cond_rhs))))\n+    {\n+      gsi = gsi_for_stmt (cond);\n+      gimple_stmt_iterator gsi_from = gsi_for_stmt (assign);\n+      gsi_move_before (&gsi_from, &gsi);\n+      replace_phi_edge_with_variable (cond_bb, e1, phi, lhs);\n+      return 2;\n+    }\n+\n   return 0;\n }\n "}]}