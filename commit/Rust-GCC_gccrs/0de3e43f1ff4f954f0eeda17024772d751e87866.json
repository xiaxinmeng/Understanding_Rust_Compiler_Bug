{"sha": "0de3e43f1ff4f954f0eeda17024772d751e87866", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlM2U0M2YxZmY0Zjk1NGYwZWVkYTE3MDI0NzcyZDc1MWU4Nzg2Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-03-12T13:27:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-03-12T13:27:43Z"}, "message": "cselib.c (LONG_TERM_PRESERVED_VALUE_P): Remove.\n\n\t* cselib.c (LONG_TERM_PRESERVED_VALUE_P): Remove.\n\t(cselib_preserve_definitely, cselib_clear_preserve): Remove.\n\t(cselib_preserve_only_values): Remove retain argument, don't\n\ttraverse hash table with cselib_{preserve_definitely,clear_preserve}.\n\t* cselib.h (cselib_preserve_only_values): Remove retain argument.\n\t* var-tracking.c (micro_operation): Move insn field before union.\n\tAdd DEF_VEC_O and DEF_VEC_ALLOC_O for this type.\n\t(struct variable_tracking_info_def): Remove n_mos field, change\n\tmos into a vector of micro_operations.\n\t(count_uses, count_uses_1, count_stores, count_with_sets): Remove.\n\t(bb_stack_adjust_offset, log_op_type, add_uses, add_stores,\n\tcompute_bb_dataflow, emit_notes_in_bb): Adjust for VTI (bb)->mos\n\tchanging into a vector.\n\t(add_with_sets): Likewise.  Ensure MO_VAL_USE uops from add_stores\n\tcome before all other uops generated by add_stores.\n\t(vt_add_function_parameters): Adjust for cselib_preserve_only_values\n\targument removal.\n\t(vt_initialize): Likewise.  Adjust for VTI (bb)->mos changing into\n\ta vector.  Run just one pass over the bbs instead of separate counting\n\tand computation phase.\n\t(vt_finalize): Free VTI (bb)->mos vector instead of array.\n\nFrom-SVN: r157403", "tree": {"sha": "e12fe17c4daff632e72812078a4cb3dd45be7118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e12fe17c4daff632e72812078a4cb3dd45be7118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0de3e43f1ff4f954f0eeda17024772d751e87866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de3e43f1ff4f954f0eeda17024772d751e87866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de3e43f1ff4f954f0eeda17024772d751e87866", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de3e43f1ff4f954f0eeda17024772d751e87866/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70235ab941c572a4efabd15fcf737c22fc999814", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70235ab941c572a4efabd15fcf737c22fc999814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70235ab941c572a4efabd15fcf737c22fc999814"}], "stats": {"total": 636, "additions": 214, "deletions": 422}, "files": [{"sha": "ce51db69c8c79a03463f9ac94f80281be01c97b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0de3e43f1ff4f954f0eeda17024772d751e87866", "patch": "@@ -1,5 +1,27 @@\n 2010-03-12  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* cselib.c (LONG_TERM_PRESERVED_VALUE_P): Remove.\n+\t(cselib_preserve_definitely, cselib_clear_preserve): Remove.\n+\t(cselib_preserve_only_values): Remove retain argument, don't\n+\ttraverse hash table with cselib_{preserve_definitely,clear_preserve}.\n+\t* cselib.h (cselib_preserve_only_values): Remove retain argument.\n+\t* var-tracking.c (micro_operation): Move insn field before union.\n+\tAdd DEF_VEC_O and DEF_VEC_ALLOC_O for this type.\n+\t(struct variable_tracking_info_def): Remove n_mos field, change\n+\tmos into a vector of micro_operations.\n+\t(count_uses, count_uses_1, count_stores, count_with_sets): Remove.\n+\t(bb_stack_adjust_offset, log_op_type, add_uses, add_stores,\n+\tcompute_bb_dataflow, emit_notes_in_bb): Adjust for VTI (bb)->mos\n+\tchanging into a vector.\n+\t(add_with_sets): Likewise.  Ensure MO_VAL_USE uops from add_stores\n+\tcome before all other uops generated by add_stores.\n+\t(vt_add_function_parameters): Adjust for cselib_preserve_only_values\n+\targument removal.\n+\t(vt_initialize): Likewise.  Adjust for VTI (bb)->mos changing into\n+\ta vector.  Run just one pass over the bbs instead of separate counting\n+\tand computation phase.\n+\t(vt_finalize): Free VTI (bb)->mos vector instead of array.\n+\n \tPR debug/43329\n \t* tree-inline.c (remap_decls): Put old_var rather than origin_var\n \tinto *nonlocalized_list vector."}, {"sha": "f63ea3f5f1ceaffe19274227122abe6bb852c130", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0de3e43f1ff4f954f0eeda17024772d751e87866", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination library for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n+   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -155,8 +155,6 @@ void (*cselib_record_sets_hook) (rtx insn, struct cselib_set *sets,\n \n #define PRESERVED_VALUE_P(RTX) \\\n   (RTL_FLAG_CHECK1(\"PRESERVED_VALUE_P\", (RTX), VALUE)->unchanging)\n-#define LONG_TERM_PRESERVED_VALUE_P(RTX) \\\n-  (RTL_FLAG_CHECK1(\"LONG_TERM_PRESERVED_VALUE_P\", (RTX), VALUE)->in_struct)\n \n \f\n \n@@ -436,51 +434,14 @@ cselib_preserved_value_p (cselib_val *v)\n   return PRESERVED_VALUE_P (v->val_rtx);\n }\n \n-/* Mark preserved values as preserved for the long term.  */\n-\n-static int\n-cselib_preserve_definitely (void **slot, void *info ATTRIBUTE_UNUSED)\n-{\n-  cselib_val *v = (cselib_val *)*slot;\n-\n-  if (PRESERVED_VALUE_P (v->val_rtx)\n-      && !LONG_TERM_PRESERVED_VALUE_P (v->val_rtx))\n-    LONG_TERM_PRESERVED_VALUE_P (v->val_rtx) = true;\n-\n-  return 1;\n-}\n-\n-/* Clear the preserve marks for values not preserved for the long\n-   term.  */\n-\n-static int\n-cselib_clear_preserve (void **slot, void *info ATTRIBUTE_UNUSED)\n-{\n-  cselib_val *v = (cselib_val *)*slot;\n-\n-  if (PRESERVED_VALUE_P (v->val_rtx)\n-      && !LONG_TERM_PRESERVED_VALUE_P (v->val_rtx))\n-    {\n-      PRESERVED_VALUE_P (v->val_rtx) = false;\n-      if (!v->locs)\n-\tn_useless_values++;\n-    }\n-\n-  return 1;\n-}\n-\n /* Clean all non-constant expressions in the hash table, but retain\n    their values.  */\n \n void\n-cselib_preserve_only_values (bool retain)\n+cselib_preserve_only_values (void)\n {\n   int i;\n \n-  htab_traverse (cselib_hash_table,\n-\t\t retain ? cselib_preserve_definitely : cselib_clear_preserve,\n-\t\t NULL);\n-\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     cselib_invalidate_regno (i, reg_raw_mode[i]);\n "}, {"sha": "67e599202544c4ffb6bd8ba45e2f2edcf90625c1", "filename": "gcc/cselib.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2Fcselib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2Fcselib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.h?ref=0de3e43f1ff4f954f0eeda17024772d751e87866", "patch": "@@ -91,6 +91,6 @@ extern void cselib_reset_table (unsigned int);\n extern unsigned int cselib_get_next_uid (void);\n extern void cselib_preserve_value (cselib_val *);\n extern bool cselib_preserved_value_p (cselib_val *);\n-extern void cselib_preserve_only_values (bool);\n+extern void cselib_preserve_only_values (void);\n \n extern void dump_cselib_table (FILE *);"}, {"sha": "430e16830a8c0beb93633abc25689db89385f5dc", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 189, "deletions": 380, "changes": 569, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de3e43f1ff4f954f0eeda17024772d751e87866/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0de3e43f1ff4f954f0eeda17024772d751e87866", "patch": "@@ -169,6 +169,13 @@ typedef struct micro_operation_def\n   /* Type of micro operation.  */\n   enum micro_operation_type type;\n \n+  /* The instruction which the micro operation is in, for MO_USE,\n+     MO_USE_NO_VAR, MO_CALL and MO_ADJUST, or the subsequent\n+     instruction or note in the original flow (before any var-tracking\n+     notes are inserted, to simplify emission of notes), for MO_SET\n+     and MO_CLOBBER.  */\n+  rtx insn;\n+\n   union {\n     /* Location.  For MO_SET and MO_COPY, this is the SET that\n        performs the assignment, if known, otherwise it is the target\n@@ -181,15 +188,11 @@ typedef struct micro_operation_def\n     /* Stack adjustment.  */\n     HOST_WIDE_INT adjust;\n   } u;\n-\n-  /* The instruction which the micro operation is in, for MO_USE,\n-     MO_USE_NO_VAR, MO_CALL and MO_ADJUST, or the subsequent\n-     instruction or note in the original flow (before any var-tracking\n-     notes are inserted, to simplify emission of notes), for MO_SET\n-     and MO_CLOBBER.  */\n-  rtx insn;\n } micro_operation;\n \n+DEF_VEC_O(micro_operation);\n+DEF_VEC_ALLOC_O(micro_operation,heap);\n+\n /* A declaration of a variable, or an RTL value being handled like a\n    declaration.  */\n typedef void *decl_or_value;\n@@ -258,11 +261,8 @@ typedef struct dataflow_set_def\n    needed for variable tracking.  */\n typedef struct variable_tracking_info_def\n {\n-  /* Number of micro operations stored in the MOS array.  */\n-  int n_mos;\n-\n-  /* The array of micro operations.  */\n-  micro_operation *mos;\n+  /* The vector of micro operations.  */\n+  VEC(micro_operation, heap) *mos;\n \n   /* The IN and OUT set for dataflow analysis.  */\n   dataflow_set in;\n@@ -453,9 +453,6 @@ static void dataflow_set_destroy (dataflow_set *);\n static bool contains_symbol_ref (rtx);\n static bool track_expr_p (tree, bool);\n static bool same_variable_part_p (rtx, tree, HOST_WIDE_INT);\n-static int count_uses (rtx *, void *);\n-static void count_uses_1 (rtx *, void *);\n-static void count_stores (rtx, const_rtx, void *);\n static int add_uses (rtx *, void *);\n static void add_uses_1 (rtx *, void *);\n static void add_stores (rtx, const_rtx, void *);\n@@ -626,20 +623,18 @@ static void\n bb_stack_adjust_offset (basic_block bb)\n {\n   HOST_WIDE_INT offset;\n-  int i;\n+  unsigned int i;\n+  micro_operation *mo;\n \n   offset = VTI (bb)->in.stack_adjust;\n-  for (i = 0; i < VTI (bb)->n_mos; i++)\n+  for (i = 0; VEC_iterate (micro_operation, VTI (bb)->mos, i, mo); i++)\n     {\n-      if (VTI (bb)->mos[i].type == MO_ADJUST)\n-\toffset += VTI (bb)->mos[i].u.adjust;\n-      else if (VTI (bb)->mos[i].type != MO_CALL)\n+      if (mo->type == MO_ADJUST)\n+\toffset += mo->u.adjust;\n+      else if (mo->type != MO_CALL)\n \t{\n-\t  if (MEM_P (VTI (bb)->mos[i].u.loc))\n-\t    {\n-\t      VTI (bb)->mos[i].u.loc\n-\t\t= adjust_stack_reference (VTI (bb)->mos[i].u.loc, -offset);\n-\t    }\n+\t  if (MEM_P (mo->u.loc))\n+\t    mo->u.loc = adjust_stack_reference (mo->u.loc, -offset);\n \t}\n     }\n   VTI (bb)->out.stack_adjust = offset;\n@@ -4489,118 +4484,12 @@ log_op_type (rtx x, basic_block bb, rtx insn,\n \t     enum micro_operation_type mopt, FILE *out)\n {\n   fprintf (out, \"bb %i op %i insn %i %s \",\n-\t   bb->index, VTI (bb)->n_mos - 1,\n+\t   bb->index, VEC_length (micro_operation, VTI (bb)->mos),\n \t   INSN_UID (insn), micro_operation_type_name[mopt]);\n   print_inline_rtx (out, x, 2);\n   fputc ('\\n', out);\n }\n \n-/* Count uses (register and memory references) LOC which will be tracked.\n-   INSN is instruction which the LOC is part of.  */\n-\n-static int\n-count_uses (rtx *ploc, void *cuip)\n-{\n-  rtx loc = *ploc;\n-  struct count_use_info *cui = (struct count_use_info *) cuip;\n-  enum micro_operation_type mopt = use_type (loc, cui, NULL);\n-\n-  if (mopt != MO_CLOBBER)\n-    {\n-      cselib_val *val;\n-      enum machine_mode mode = GET_MODE (loc);\n-\n-      switch (mopt)\n-\t{\n-\tcase MO_VAL_LOC:\n-\t  loc = PAT_VAR_LOCATION_LOC (loc);\n-\t  if (VAR_LOC_UNKNOWN_P (loc))\n-\t    break;\n-\t  /* Fall through.  */\n-\n-\tcase MO_VAL_USE:\n-\tcase MO_VAL_SET:\n-\t  if (MEM_P (loc)\n-\t      && !REG_P (XEXP (loc, 0)) && !MEM_P (XEXP (loc, 0)))\n-\t    {\n-\t      enum machine_mode address_mode\n-\t\t= targetm.addr_space.address_mode (MEM_ADDR_SPACE (loc));\n-\t      val = cselib_lookup (XEXP (loc, 0), address_mode, 0);\n-\n-\t      if (val && !cselib_preserved_value_p (val))\n-\t\t{\n-\t\t  VTI (cui->bb)->n_mos++;\n-\t\t  cselib_preserve_value (val);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    log_op_type (XEXP (loc, 0), cui->bb, cui->insn,\n-\t\t\t\t MO_VAL_USE, dump_file);\n-\t\t}\n-\t    }\n-\n-\t  val = find_use_val (loc, mode, cui);\n-\t  if (val)\n-\t    {\n-\t      if (mopt == MO_VAL_SET\n-\t\t  && GET_CODE (PATTERN (cui->insn)) == COND_EXEC\n-\t\t  && (REG_P (loc)\n-\t\t      || (MEM_P (loc)\n-\t\t\t  && (use_type (loc, NULL, NULL) == MO_USE\n-\t\t\t      || cui->sets))))\n-\t\t{\n-\t\t  cselib_val *oval = cselib_lookup (loc, GET_MODE (loc), 0);\n-\n-\t\t  gcc_assert (oval != val);\n-\t\t  gcc_assert (REG_P (loc) || MEM_P (loc));\n-\n-\t\t  if (!cselib_preserved_value_p (oval))\n-\t\t    {\n-\t\t      VTI (cui->bb)->n_mos++;\n-\t\t      cselib_preserve_value (oval);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tlog_op_type (loc, cui->bb, cui->insn,\n-\t\t\t\t     MO_VAL_USE, dump_file);\n-\t\t    }\n-\t\t}\n-\n-\t      cselib_preserve_value (val);\n-\t    }\n-\t  else\n-\t    gcc_assert (mopt == MO_VAL_LOC\n-\t\t\t|| (mopt == MO_VAL_SET && cui->store_p));\n-\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-\n-      VTI (cui->bb)->n_mos++;\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tlog_op_type (loc, cui->bb, cui->insn, mopt, dump_file);\n-    }\n-\n-  return 0;\n-}\n-\n-/* Helper function for finding all uses of REG/MEM in X in CUI's\n-   insn.  */\n-\n-static void\n-count_uses_1 (rtx *x, void *cui)\n-{\n-  for_each_rtx (x, count_uses, cui);\n-}\n-\n-/* Count stores (register and memory references) LOC which will be\n-   tracked.  CUI is a count_use_info object containing the instruction\n-   which the LOC is part of.  */\n-\n-static void\n-count_stores (rtx loc, const_rtx expr ATTRIBUTE_UNUSED, void *cui)\n-{\n-  count_uses (&loc, cui);\n-}\n-\n /* Adjust sets if needed.  Currently this optimizes read-only MEM loads\n    if REG_EQUAL/REG_EQUIV note is present.  */\n \n@@ -4625,35 +4514,6 @@ adjust_sets (rtx insn, struct cselib_set *sets, int n_sets)\n     }\n }\n \n-/* Callback for cselib_record_sets_hook, that counts how many micro\n-   operations it takes for uses and stores in an insn after\n-   cselib_record_sets has analyzed the sets in an insn, but before it\n-   modifies the stored values in the internal tables, unless\n-   cselib_record_sets doesn't call it directly (perhaps because we're\n-   not doing cselib in the first place, in which case sets and n_sets\n-   will be 0).  */\n-\n-static void\n-count_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n-{\n-  basic_block bb = BLOCK_FOR_INSN (insn);\n-  struct count_use_info cui;\n-\n-  cselib_hook_called = true;\n-\n-  adjust_sets (insn, sets, n_sets);\n-\n-  cui.insn = insn;\n-  cui.bb = bb;\n-  cui.sets = sets;\n-  cui.n_sets = n_sets;\n-\n-  cui.store_p = false;\n-  note_uses (&PATTERN (insn), count_uses_1, &cui);\n-  cui.store_p = true;\n-  note_stores (PATTERN (insn), count_stores, &cui);\n-}\n-\n /* Tell whether the CONCAT used to holds a VALUE and its location\n    needs value resolution, i.e., an attempt of mapping the location\n    back to other incoming values.  */\n@@ -4679,9 +4539,7 @@ count_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n /* All preserved VALUEs.  */\n static VEC (rtx, heap) *preserved_values;\n \n-/* Ensure VAL is preserved and remember it in a vector for vt_emit_notes.\n-   This must be only called when cselib_preserve_only_values will be called\n-   with true, the counting phase must use cselib_preserve_value.  */\n+/* Ensure VAL is preserved and remember it in a vector for vt_emit_notes.  */\n \n static void\n preserve_value (cselib_val *val)\n@@ -4704,11 +4562,11 @@ add_uses (rtx *ploc, void *data)\n   if (type != MO_CLOBBER)\n     {\n       basic_block bb = cui->bb;\n-      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+      micro_operation mo;\n \n-      mo->type = type;\n-      mo->u.loc = type == MO_USE ? var_lowpart (mode, loc) : loc;\n-      mo->insn = cui->insn;\n+      mo.type = type;\n+      mo.u.loc = type == MO_USE ? var_lowpart (mode, loc) : loc;\n+      mo.insn = cui->insn;\n \n       if (type == MO_VAL_LOC)\n \t{\n@@ -4729,19 +4587,17 @@ add_uses (rtx *ploc, void *data)\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n-\t\t  micro_operation *mon = VTI (bb)->mos + VTI (bb)->n_mos++;\n-\t\t  mon->type = mo->type;\n-\t\t  mon->u.loc = mo->u.loc;\n-\t\t  mon->insn = mo->insn;\n+\t\t  micro_operation moa;\n \t\t  preserve_value (val);\n-\t\t  mo->type = MO_VAL_USE;\n \t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n-\t\t  mo->u.loc = gen_rtx_CONCAT (address_mode,\n+\t\t  moa.type = MO_VAL_USE;\n+\t\t  moa.insn = cui->insn;\n+\t\t  moa.u.loc = gen_rtx_CONCAT (address_mode,\n \t\t\t\t\t      val->val_rtx, mloc);\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    log_op_type (mo->u.loc, cui->bb, cui->insn,\n-\t\t\t\t mo->type, dump_file);\n-\t\t  mo = mon;\n+\t\t    log_op_type (moa.u.loc, cui->bb, cui->insn,\n+\t\t\t\t moa.type, dump_file);\n+\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &moa);\n \t\t}\n \t    }\n \n@@ -4778,7 +4634,7 @@ add_uses (rtx *ploc, void *data)\n \t      PAT_VAR_LOCATION_LOC (oloc) = gen_rtx_UNKNOWN_VAR_LOC ();\n \t    }\n \n-\t  mo->u.loc = oloc;\n+\t  mo.u.loc = oloc;\n \t}\n       else if (type == MO_VAL_USE)\n \t{\n@@ -4800,20 +4656,17 @@ add_uses (rtx *ploc, void *data)\n \n \t      if (val && !cselib_preserved_value_p (val))\n \t\t{\n-\t\t  micro_operation *mon = VTI (bb)->mos + VTI (bb)->n_mos++;\n-\t\t  mon->type = mo->type;\n-\t\t  mon->u.loc = mo->u.loc;\n-\t\t  mon->insn = mo->insn;\n+\t\t  micro_operation moa;\n \t\t  preserve_value (val);\n-\t\t  mo->type = MO_VAL_USE;\n \t\t  mloc = cselib_subst_to_values (XEXP (mloc, 0));\n-\t\t  mo->u.loc = gen_rtx_CONCAT (address_mode,\n+\t\t  moa.type = MO_VAL_USE;\n+\t\t  moa.insn = cui->insn;\n+\t\t  moa.u.loc = gen_rtx_CONCAT (address_mode,\n \t\t\t\t\t      val->val_rtx, mloc);\n-\t\t  mo->insn = cui->insn;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    log_op_type (mo->u.loc, cui->bb, cui->insn,\n-\t\t\t\t mo->type, dump_file);\n-\t\t  mo = mon;\n+\t\t    log_op_type (moa.u.loc, cui->bb, cui->insn,\n+\t\t\t\t moa.type, dump_file);\n+\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &moa);\n \t\t}\n \t    }\n \n@@ -4846,21 +4699,22 @@ add_uses (rtx *ploc, void *data)\n \t  else\n \t    oloc = val->val_rtx;\n \n-\t  mo->u.loc = gen_rtx_CONCAT (mode, oloc, nloc);\n+\t  mo.u.loc = gen_rtx_CONCAT (mode, oloc, nloc);\n \n \t  if (type2 == MO_USE)\n-\t    VAL_HOLDS_TRACK_EXPR (mo->u.loc) = 1;\n+\t    VAL_HOLDS_TRACK_EXPR (mo.u.loc) = 1;\n \t  if (!cselib_preserved_value_p (val))\n \t    {\n-\t      VAL_NEEDS_RESOLUTION (mo->u.loc) = 1;\n+\t      VAL_NEEDS_RESOLUTION (mo.u.loc) = 1;\n \t      preserve_value (val);\n \t    }\n \t}\n       else\n \tgcc_assert (type == MO_USE || type == MO_USE_NO_VAR);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tlog_op_type (mo->u.loc, cui->bb, cui->insn, mo->type, dump_file);\n+\tlog_op_type (mo.u.loc, cui->bb, cui->insn, mo.type, dump_file);\n+      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n     }\n \n   return 0;\n@@ -4985,7 +4839,7 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n   enum machine_mode mode = VOIDmode, mode2;\n   struct count_use_info *cui = (struct count_use_info *)cuip;\n   basic_block bb = cui->bb;\n-  micro_operation *mo;\n+  micro_operation mo;\n   rtx oloc = loc, nloc, src = NULL;\n   enum micro_operation_type type = use_type (loc, cui, &mode);\n   bool track_p = false;\n@@ -5000,14 +4854,12 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n   if (REG_P (loc))\n     {\n-      mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n-\n       if ((GET_CODE (expr) == CLOBBER && type != MO_VAL_SET)\n \t  || !(track_p = use_type (loc, NULL, &mode2) == MO_USE)\n \t  || GET_CODE (expr) == CLOBBER)\n \t{\n-\t  mo->type = MO_CLOBBER;\n-\t  mo->u.loc = loc;\n+\t  mo.type = MO_CLOBBER;\n+\t  mo.u.loc = loc;\n \t}\n       else\n \t{\n@@ -5020,8 +4872,8 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n \t  if (src == NULL)\n \t    {\n-\t      mo->type = MO_SET;\n-\t      mo->u.loc = loc;\n+\t      mo.type = MO_SET;\n+\t      mo.u.loc = loc;\n \t    }\n \t  else\n \t    {\n@@ -5030,20 +4882,18 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t      if (SET_SRC (expr) != src)\n \t\txexpr = gen_rtx_SET (VOIDmode, loc, src);\n \t      if (same_variable_part_p (src, REG_EXPR (loc), REG_OFFSET (loc)))\n-\t\tmo->type = MO_COPY;\n+\t\tmo.type = MO_COPY;\n \t      else\n-\t\tmo->type = MO_SET;\n-\t      mo->u.loc = xexpr;\n+\t\tmo.type = MO_SET;\n+\t      mo.u.loc = xexpr;\n \t    }\n \t}\n-      mo->insn = cui->insn;\n+      mo.insn = cui->insn;\n     }\n   else if (MEM_P (loc)\n \t   && ((track_p = use_type (loc, NULL, &mode2) == MO_USE)\n \t       || cui->sets))\n     {\n-      mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n-\n       if (MEM_P (loc) && type == MO_VAL_SET\n \t  && !REG_P (XEXP (loc, 0)) && !MEM_P (XEXP (loc, 0)))\n \t{\n@@ -5055,21 +4905,21 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t  if (val && !cselib_preserved_value_p (val))\n \t    {\n \t      preserve_value (val);\n-\t      mo->type = MO_VAL_USE;\n+\t      mo.type = MO_VAL_USE;\n \t      mloc = cselib_subst_to_values (XEXP (mloc, 0));\n-\t      mo->u.loc = gen_rtx_CONCAT (address_mode, val->val_rtx, mloc);\n-\t      mo->insn = cui->insn;\n+\t      mo.u.loc = gen_rtx_CONCAT (address_mode, val->val_rtx, mloc);\n+\t      mo.insn = cui->insn;\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tlog_op_type (mo->u.loc, cui->bb, cui->insn,\n-\t\t\t     mo->type, dump_file);\n-\t      mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\t\tlog_op_type (mo.u.loc, cui->bb, cui->insn,\n+\t\t\t     mo.type, dump_file);\n+\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n \t    }\n \t}\n \n       if (GET_CODE (expr) == CLOBBER || !track_p)\n \t{\n-\t  mo->type = MO_CLOBBER;\n-\t  mo->u.loc = track_p ? var_lowpart (mode2, loc) : loc;\n+\t  mo.type = MO_CLOBBER;\n+\t  mo.u.loc = track_p ? var_lowpart (mode2, loc) : loc;\n \t}\n       else\n \t{\n@@ -5082,8 +4932,8 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n \t  if (src == NULL)\n \t    {\n-\t      mo->type = MO_SET;\n-\t      mo->u.loc = loc;\n+\t      mo.type = MO_SET;\n+\t      mo.u.loc = loc;\n \t    }\n \t  else\n \t    {\n@@ -5094,13 +4944,13 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t      if (same_variable_part_p (SET_SRC (xexpr),\n \t\t\t\t\tMEM_EXPR (loc),\n \t\t\t\t\tINT_MEM_OFFSET (loc)))\n-\t\tmo->type = MO_COPY;\n+\t\tmo.type = MO_COPY;\n \t      else\n-\t\tmo->type = MO_SET;\n-\t      mo->u.loc = xexpr;\n+\t\tmo.type = MO_SET;\n+\t      mo.u.loc = xexpr;\n \t    }\n \t}\n-      mo->insn = cui->insn;\n+      mo.insn = cui->insn;\n     }\n   else\n     return;\n@@ -5128,23 +4978,24 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \n       if (!cselib_preserved_value_p (oval))\n \t{\n-\t  micro_operation *nmo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+\t  micro_operation moa;\n \n \t  preserve_value (oval);\n \n-\t  nmo->type = MO_VAL_USE;\n-\t  nmo->u.loc = gen_rtx_CONCAT (mode, oval->val_rtx, oloc);\n-\t  VAL_NEEDS_RESOLUTION (nmo->u.loc) = 1;\n-\t  nmo->insn = mo->insn;\n+\t  moa.type = MO_VAL_USE;\n+\t  moa.u.loc = gen_rtx_CONCAT (mode, oval->val_rtx, oloc);\n+\t  VAL_NEEDS_RESOLUTION (moa.u.loc) = 1;\n+\t  moa.insn = cui->insn;\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    log_op_type (nmo->u.loc, cui->bb, cui->insn,\n-\t\t\t nmo->type, dump_file);\n+\t    log_op_type (moa.u.loc, cui->bb, cui->insn,\n+\t\t\t moa.type, dump_file);\n+\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &moa);\n \t}\n \n       resolve = false;\n     }\n-  else if (resolve && GET_CODE (mo->u.loc) == SET)\n+  else if (resolve && GET_CODE (mo.u.loc) == SET)\n     {\n       src = get_adjusted_src (cui, SET_SRC (expr));\n       nloc = replace_expr_with_values (src);\n@@ -5157,30 +5008,30 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n \t}\n \n       if (nloc)\n-\toloc = gen_rtx_SET (GET_MODE (mo->u.loc), oloc, nloc);\n+\toloc = gen_rtx_SET (GET_MODE (mo.u.loc), oloc, nloc);\n       else\n \t{\n-\t  if (oloc == SET_DEST (mo->u.loc))\n+\t  if (oloc == SET_DEST (mo.u.loc))\n \t    /* No point in duplicating.  */\n-\t    oloc = mo->u.loc;\n-\t  if (!REG_P (SET_SRC (mo->u.loc)))\n+\t    oloc = mo.u.loc;\n+\t  if (!REG_P (SET_SRC (mo.u.loc)))\n \t    resolve = false;\n \t}\n     }\n   else if (!resolve)\n     {\n-      if (GET_CODE (mo->u.loc) == SET\n-\t  && oloc == SET_DEST (mo->u.loc))\n+      if (GET_CODE (mo.u.loc) == SET\n+\t  && oloc == SET_DEST (mo.u.loc))\n \t/* No point in duplicating.  */\n-\toloc = mo->u.loc;\n+\toloc = mo.u.loc;\n     }\n   else\n     resolve = false;\n \n   loc = gen_rtx_CONCAT (mode, v->val_rtx, oloc);\n \n-  if (mo->u.loc != oloc)\n-    loc = gen_rtx_CONCAT (GET_MODE (mo->u.loc), loc, mo->u.loc);\n+  if (mo.u.loc != oloc)\n+    loc = gen_rtx_CONCAT (GET_MODE (mo.u.loc), loc, mo.u.loc);\n \n   /* The loc of a MO_VAL_SET may have various forms:\n \n@@ -5207,12 +5058,12 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       reverse = reverse_op (v->val_rtx, expr);\n       if (reverse)\n \t{\n-\t  loc = gen_rtx_CONCAT (GET_MODE (mo->u.loc), loc, reverse);\n+\t  loc = gen_rtx_CONCAT (GET_MODE (mo.u.loc), loc, reverse);\n \t  VAL_EXPR_HAS_REVERSE (loc) = 1;\n \t}\n     }\n \n-  mo->u.loc = loc;\n+  mo.u.loc = loc;\n \n   if (track_p)\n     VAL_HOLDS_TRACK_EXPR (loc) = 1;\n@@ -5221,16 +5072,17 @@ add_stores (rtx loc, const_rtx expr, void *cuip)\n       VAL_NEEDS_RESOLUTION (loc) = resolve;\n       preserve_value (v);\n     }\n-  if (mo->type == MO_CLOBBER)\n+  if (mo.type == MO_CLOBBER)\n     VAL_EXPR_IS_CLOBBERED (loc) = 1;\n-  if (mo->type == MO_COPY)\n+  if (mo.type == MO_COPY)\n     VAL_EXPR_IS_COPIED (loc) = 1;\n \n-  mo->type = MO_VAL_SET;\n+  mo.type = MO_VAL_SET;\n \n  log_and_return:\n   if (dump_file && (dump_flags & TDF_DETAILS))\n-    log_op_type (mo->u.loc, cui->bb, cui->insn, mo->type, dump_file);\n+    log_op_type (mo.u.loc, cui->bb, cui->insn, mo.type, dump_file);\n+  VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n }\n \n /* Callback for cselib_record_sets_hook, that records as micro\n@@ -5246,6 +5098,7 @@ add_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n   basic_block bb = BLOCK_FOR_INSN (insn);\n   int n1, n2;\n   struct count_use_info cui;\n+  micro_operation *mos;\n \n   cselib_hook_called = true;\n \n@@ -5256,80 +5109,102 @@ add_with_sets (rtx insn, struct cselib_set *sets, int n_sets)\n   cui.sets = sets;\n   cui.n_sets = n_sets;\n \n-  n1 = VTI (bb)->n_mos;\n+  n1 = VEC_length (micro_operation, VTI (bb)->mos);\n   cui.store_p = false;\n   note_uses (&PATTERN (insn), add_uses_1, &cui);\n-  n2 = VTI (bb)->n_mos - 1;\n+  n2 = VEC_length (micro_operation, VTI (bb)->mos) - 1;\n+  mos = VEC_address (micro_operation, VTI (bb)->mos);\n \n   /* Order the MO_USEs to be before MO_USE_NO_VARs and MO_VAL_USE, and\n      MO_VAL_LOC last.  */\n   while (n1 < n2)\n     {\n-      while (n1 < n2 && VTI (bb)->mos[n1].type == MO_USE)\n+      while (n1 < n2 && mos[n1].type == MO_USE)\n \tn1++;\n-      while (n1 < n2 && VTI (bb)->mos[n2].type != MO_USE)\n+      while (n1 < n2 && mos[n2].type != MO_USE)\n \tn2--;\n       if (n1 < n2)\n \t{\n \t  micro_operation sw;\n \n-\t  sw = VTI (bb)->mos[n1];\n-\t  VTI (bb)->mos[n1] = VTI (bb)->mos[n2];\n-\t  VTI (bb)->mos[n2] = sw;\n+\t  sw = mos[n1];\n+\t  mos[n1] = mos[n2];\n+\t  mos[n2] = sw;\n \t}\n     }\n \n-  n2 = VTI (bb)->n_mos - 1;\n-\n+  n2 = VEC_length (micro_operation, VTI (bb)->mos) - 1;\n   while (n1 < n2)\n     {\n-      while (n1 < n2 && VTI (bb)->mos[n1].type != MO_VAL_LOC)\n+      while (n1 < n2 && mos[n1].type != MO_VAL_LOC)\n \tn1++;\n-      while (n1 < n2 && VTI (bb)->mos[n2].type == MO_VAL_LOC)\n+      while (n1 < n2 && mos[n2].type == MO_VAL_LOC)\n \tn2--;\n       if (n1 < n2)\n \t{\n \t  micro_operation sw;\n \n-\t  sw = VTI (bb)->mos[n1];\n-\t  VTI (bb)->mos[n1] = VTI (bb)->mos[n2];\n-\t  VTI (bb)->mos[n2] = sw;\n+\t  sw = mos[n1];\n+\t  mos[n1] = mos[n2];\n+\t  mos[n2] = sw;\n \t}\n     }\n \n   if (CALL_P (insn))\n     {\n-      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n+      micro_operation mo;\n \n-      mo->type = MO_CALL;\n-      mo->insn = insn;\n+      mo.type = MO_CALL;\n+      mo.insn = insn;\n+      mo.u.loc = NULL_RTX;\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n-\tlog_op_type (PATTERN (insn), bb, insn, mo->type, dump_file);\n+\tlog_op_type (PATTERN (insn), bb, insn, mo.type, dump_file);\n+      VEC_safe_push (micro_operation, heap, VTI (bb)->mos, &mo);\n     }\n \n-  n1 = VTI (bb)->n_mos;\n+  n1 = VEC_length (micro_operation, VTI (bb)->mos);\n   /* This will record NEXT_INSN (insn), such that we can\n      insert notes before it without worrying about any\n      notes that MO_USEs might emit after the insn.  */\n   cui.store_p = true;\n   note_stores (PATTERN (insn), add_stores, &cui);\n-  n2 = VTI (bb)->n_mos - 1;\n+  n2 = VEC_length (micro_operation, VTI (bb)->mos) - 1;\n+  mos = VEC_address (micro_operation, VTI (bb)->mos);\n \n-  /* Order the MO_CLOBBERs to be before MO_SETs.  */\n+  /* Order the MO_VAL_USEs first (note_stores does nothing\n+     on DEBUG_INSNs, so there are no MO_VAL_LOCs from this\n+     insn), then MO_CLOBBERs, then MO_SET/MO_COPY/MO_VAL_SET.  */\n   while (n1 < n2)\n     {\n-      while (n1 < n2 && VTI (bb)->mos[n1].type == MO_CLOBBER)\n+      while (n1 < n2 && mos[n1].type == MO_VAL_USE)\n \tn1++;\n-      while (n1 < n2 && VTI (bb)->mos[n2].type != MO_CLOBBER)\n+      while (n1 < n2 && mos[n2].type != MO_VAL_USE)\n \tn2--;\n       if (n1 < n2)\n \t{\n \t  micro_operation sw;\n \n-\t  sw = VTI (bb)->mos[n1];\n-\t  VTI (bb)->mos[n1] = VTI (bb)->mos[n2];\n-\t  VTI (bb)->mos[n2] = sw;\n+\t  sw = mos[n1];\n+\t  mos[n1] = mos[n2];\n+\t  mos[n2] = sw;\n+\t}\n+    }\n+\n+  n2 = VEC_length (micro_operation, VTI (bb)->mos) - 1;\n+  while (n1 < n2)\n+    {\n+      while (n1 < n2 && mos[n1].type == MO_CLOBBER)\n+\tn1++;\n+      while (n1 < n2 && mos[n2].type != MO_CLOBBER)\n+\tn2--;\n+      if (n1 < n2)\n+\t{\n+\t  micro_operation sw;\n+\n+\t  sw = mos[n1];\n+\t  mos[n1] = mos[n2];\n+\t  mos[n2] = sw;\n \t}\n     }\n }\n@@ -5401,7 +5276,8 @@ find_src_set_src (dataflow_set *set, rtx src)\n static bool\n compute_bb_dataflow (basic_block bb)\n {\n-  int i, n;\n+  unsigned int i;\n+  micro_operation *mo;\n   bool changed;\n   dataflow_set old_out;\n   dataflow_set *in = &VTI (bb)->in;\n@@ -5411,20 +5287,19 @@ compute_bb_dataflow (basic_block bb)\n   dataflow_set_copy (&old_out, out);\n   dataflow_set_copy (out, in);\n \n-  n = VTI (bb)->n_mos;\n-  for (i = 0; i < n; i++)\n+  for (i = 0; VEC_iterate (micro_operation, VTI (bb)->mos, i, mo); i++)\n     {\n-      rtx insn = VTI (bb)->mos[i].insn;\n+      rtx insn = mo->insn;\n \n-      switch (VTI (bb)->mos[i].type)\n+      switch (mo->type)\n \t{\n \t  case MO_CALL:\n \t    dataflow_set_clear_at_call (out);\n \t    break;\n \n \t  case MO_USE:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \n \t      if (REG_P (loc))\n \t\tvar_reg_set (out, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n@@ -5435,7 +5310,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_VAL_LOC:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx val, vloc;\n \t      tree var;\n \n@@ -5467,7 +5342,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_VAL_USE:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx val, vloc, uloc;\n \n \t      vloc = uloc = XEXP (loc, 1);\n@@ -5498,7 +5373,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_VAL_SET:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx val, vloc, uloc, reverse = NULL_RTX;\n \n \t      vloc = loc;\n@@ -5591,7 +5466,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_SET:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx set_src = NULL;\n \n \t      if (GET_CODE (loc) == SET)\n@@ -5611,7 +5486,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_COPY:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      enum var_init_status src_status;\n \t      rtx set_src = NULL;\n \n@@ -5642,7 +5517,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_USE_NO_VAR:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \n \t      if (REG_P (loc))\n \t\tvar_reg_delete (out, loc, false);\n@@ -5653,7 +5528,7 @@ compute_bb_dataflow (basic_block bb)\n \n \t  case MO_CLOBBER:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \n \t      if (REG_P (loc))\n \t\tvar_reg_delete (out, loc, true);\n@@ -5663,7 +5538,7 @@ compute_bb_dataflow (basic_block bb)\n \t    break;\n \n \t  case MO_ADJUST:\n-\t    out->stack_adjust += VTI (bb)->mos[i].u.adjust;\n+\t    out->stack_adjust += mo->u.adjust;\n \t    break;\n \t}\n     }\n@@ -7318,16 +7193,17 @@ emit_notes_for_differences (rtx insn, dataflow_set *old_set,\n static void\n emit_notes_in_bb (basic_block bb, dataflow_set *set)\n {\n-  int i;\n+  unsigned int i;\n+  micro_operation *mo;\n \n   dataflow_set_clear (set);\n   dataflow_set_copy (set, &VTI (bb)->in);\n \n-  for (i = 0; i < VTI (bb)->n_mos; i++)\n+  for (i = 0; VEC_iterate (micro_operation, VTI (bb)->mos, i, mo); i++)\n     {\n-      rtx insn = VTI (bb)->mos[i].insn;\n+      rtx insn = mo->insn;\n \n-      switch (VTI (bb)->mos[i].type)\n+      switch (mo->type)\n \t{\n \t  case MO_CALL:\n \t    dataflow_set_clear_at_call (set);\n@@ -7336,7 +7212,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_USE:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \n \t      if (REG_P (loc))\n \t\tvar_reg_set (set, loc, VAR_INIT_STATUS_UNINITIALIZED, NULL);\n@@ -7349,7 +7225,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_VAL_LOC:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx val, vloc;\n \t      tree var;\n \n@@ -7383,7 +7259,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_VAL_USE:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx val, vloc, uloc;\n \n \t      vloc = uloc = XEXP (loc, 1);\n@@ -7416,7 +7292,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_VAL_SET:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx val, vloc, uloc, reverse = NULL_RTX;\n \n \t      vloc = loc;\n@@ -7506,7 +7382,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_SET:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      rtx set_src = NULL;\n \n \t      if (GET_CODE (loc) == SET)\n@@ -7529,7 +7405,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_COPY:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \t      enum var_init_status src_status;\n \t      rtx set_src = NULL;\n \n@@ -7554,7 +7430,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_USE_NO_VAR:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \n \t      if (REG_P (loc))\n \t\tvar_reg_delete (set, loc, false);\n@@ -7567,7 +7443,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \n \t  case MO_CLOBBER:\n \t    {\n-\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\t      rtx loc = mo->u.loc;\n \n \t      if (REG_P (loc))\n \t\tvar_reg_delete (set, loc, true);\n@@ -7580,7 +7456,7 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n \t    break;\n \n \t  case MO_ADJUST:\n-\t    set->stack_adjust += VTI (bb)->mos[i].u.adjust;\n+\t    set->stack_adjust += mo->u.adjust;\n \t    break;\n \t}\n     }\n@@ -7806,7 +7682,7 @@ vt_add_function_parameters (void)\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n-      cselib_preserve_only_values (true);\n+      cselib_preserve_only_values ();\n       cselib_reset_table (cselib_get_next_uid ());\n     }\n \n@@ -7840,13 +7716,11 @@ vt_initialize (void)\n     {\n       rtx insn;\n       HOST_WIDE_INT pre, post = 0;\n-      unsigned int next_uid_before = cselib_get_next_uid ();\n-      unsigned int next_uid_after = next_uid_before;\n       basic_block first_bb, last_bb;\n \n       if (MAY_HAVE_DEBUG_INSNS)\n \t{\n-\t  cselib_record_sets_hook = count_with_sets;\n+\t  cselib_record_sets_hook = add_with_sets;\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"first value: %i\\n\",\n \t\t     cselib_get_next_uid ());\n@@ -7866,10 +7740,9 @@ vt_initialize (void)\n \t}\n       last_bb = bb;\n \n-      /* Count the number of micro operations.  */\n+      /* Add the micro-operations to the vector.  */\n       FOR_BB_BETWEEN (bb, first_bb, last_bb->next_bb, next_bb)\n \t{\n-\t  VTI (bb)->n_mos = 0;\n \t  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n \t       insn = NEXT_INSN (insn))\n \t    {\n@@ -7880,75 +7753,12 @@ vt_initialize (void)\n \t\t      insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n \t\t      if (pre)\n \t\t\t{\n-\t\t\t  VTI (bb)->n_mos++;\n-\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t    log_op_type (GEN_INT (pre), bb, insn,\n-\t\t\t\t\t MO_ADJUST, dump_file);\n-\t\t\t}\n-\t\t      if (post)\n-\t\t\t{\n-\t\t\t  VTI (bb)->n_mos++;\n-\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t    log_op_type (GEN_INT (post), bb, insn,\n-\t\t\t\t\t MO_ADJUST, dump_file);\n-\t\t\t}\n-\t\t    }\n-\t\t  cselib_hook_called = false;\n-\t\t  if (MAY_HAVE_DEBUG_INSNS)\n-\t\t    {\n-\t\t      cselib_process_insn (insn);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  print_rtl_single (dump_file, insn);\n-\t\t\t  dump_cselib_table (dump_file);\n-\t\t\t}\n-\t\t    }\n-\t\t  if (!cselib_hook_called)\n-\t\t    count_with_sets (insn, 0, 0);\n-\t\t  if (CALL_P (insn))\n-\t\t    {\n-\t\t      VTI (bb)->n_mos++;\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\tlog_op_type (PATTERN (insn), bb, insn,\n-\t\t\t\t     MO_CALL, dump_file);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (MAY_HAVE_DEBUG_INSNS)\n-\t{\n-\t  cselib_preserve_only_values (false);\n-\t  next_uid_after = cselib_get_next_uid ();\n-\t  cselib_reset_table (next_uid_before);\n-\t  cselib_record_sets_hook = add_with_sets;\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    fprintf (dump_file, \"first value: %i\\n\",\n-\t\t     cselib_get_next_uid ());\n-\t}\n-\n-      /* Add the micro-operations to the array.  */\n-      FOR_BB_BETWEEN (bb, first_bb, last_bb->next_bb, next_bb)\n-\t{\n-\t  int count = VTI (bb)->n_mos;\n-\t  VTI (bb)->mos = XNEWVEC (micro_operation, count);\n-\t  VTI (bb)->n_mos = 0;\n-\t  for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n-\t       insn = NEXT_INSN (insn))\n-\t    {\n-\t      if (INSN_P (insn))\n-\t\t{\n-\t\t  if (!frame_pointer_needed)\n-\t\t    {\n-\t\t      insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n-\t\t      if (pre)\n-\t\t\t{\n-\t\t\t  micro_operation *mo\n-\t\t\t    = VTI (bb)->mos + VTI (bb)->n_mos++;\n-\n-\t\t\t  mo->type = MO_ADJUST;\n-\t\t\t  mo->u.adjust = pre;\n-\t\t\t  mo->insn = insn;\n+\t\t\t  micro_operation mo;\n+\t\t\t  mo.type = MO_ADJUST;\n+\t\t\t  mo.u.adjust = pre;\n+\t\t\t  mo.insn = insn;\n+\t\t\t  VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n+\t\t\t\t\t &mo);\n \n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t    log_op_type (PATTERN (insn), bb, insn,\n@@ -7971,28 +7781,27 @@ vt_initialize (void)\n \n \t\t  if (!frame_pointer_needed && post)\n \t\t    {\n-\t\t      micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n-\n-\t\t      mo->type = MO_ADJUST;\n-\t\t      mo->u.adjust = post;\n-\t\t      mo->insn = insn;\n+\t\t      micro_operation mo;\n+\t\t      mo.type = MO_ADJUST;\n+\t\t      mo.u.adjust = post;\n+\t\t      mo.insn = insn;\n+\t\t      VEC_safe_push (micro_operation, heap, VTI (bb)->mos,\n+\t\t\t\t     &mo);\n \n \t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\tlog_op_type (PATTERN (insn), bb, insn,\n \t\t\t\t     MO_ADJUST, dump_file);\n \t\t    }\n \t\t}\n \t    }\n-\t  gcc_assert (count == VTI (bb)->n_mos);\n \t}\n \n       bb = last_bb;\n \n       if (MAY_HAVE_DEBUG_INSNS)\n \t{\n-\t  cselib_preserve_only_values (true);\n-\t  gcc_assert (next_uid_after == cselib_get_next_uid ());\n-\t  cselib_reset_table (next_uid_after);\n+\t  cselib_preserve_only_values ();\n+\t  cselib_reset_table (cselib_get_next_uid ());\n \t  cselib_record_sets_hook = NULL;\n \t}\n     }\n@@ -8079,7 +7888,7 @@ vt_finalize (void)\n \n   FOR_EACH_BB (bb)\n     {\n-      free (VTI (bb)->mos);\n+      VEC_free (micro_operation, heap, VTI (bb)->mos);\n     }\n \n   FOR_ALL_BB (bb)"}]}