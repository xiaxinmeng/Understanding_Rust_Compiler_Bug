{"sha": "b6a45605019bfe2fe588961c6959630f8b9deed0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZhNDU2MDUwMTliZmUyZmU1ODg5NjFjNjk1OTYzMGY4YjlkZWVkMA==", "commit": {"author": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-08-02T08:57:58Z"}, "committer": {"name": "Janus Weil", "email": "janus@gcc.gnu.org", "date": "2012-08-02T08:57:58Z"}, "message": "re PR fortran/54147 ([F03] Interface checks for PPCs & deferred TBPs)\n\n2012-08-02  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/54147\n\t* resolve.c (check_proc_interface): New routine for PROCEDURE interface\n\tchecks.\n\t(resolve_procedure_interface,resolve_typebound_procedure,\n\tresolve_fl_derived0): Call it.\n\n2012-08-02  Janus Weil  <janus@gcc.gnu.org>\n\n\tPR fortran/54147\n\t* gfortran.dg/abstract_type_6.f03: Modified.\n\t* gfortran.dg/proc_ptr_comp_3.f90: Modified.\n\t* gfortran.dg/proc_ptr_comp_35.f90: New.\n\t* gfortran.dg/typebound_proc_9.f03: Modified.\n\t* gfortran.dg/typebound_proc_26.f90: New.\n\nFrom-SVN: r190069", "tree": {"sha": "474d74292af17992991fcdd0126392a5776ef88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/474d74292af17992991fcdd0126392a5776ef88d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6a45605019bfe2fe588961c6959630f8b9deed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a45605019bfe2fe588961c6959630f8b9deed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6a45605019bfe2fe588961c6959630f8b9deed0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6a45605019bfe2fe588961c6959630f8b9deed0/comments", "author": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "janusw", "id": 484108, "node_id": "MDQ6VXNlcjQ4NDEwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/484108?v=4", "gravatar_id": "", "url": "https://api.github.com/users/janusw", "html_url": "https://github.com/janusw", "followers_url": "https://api.github.com/users/janusw/followers", "following_url": "https://api.github.com/users/janusw/following{/other_user}", "gists_url": "https://api.github.com/users/janusw/gists{/gist_id}", "starred_url": "https://api.github.com/users/janusw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/janusw/subscriptions", "organizations_url": "https://api.github.com/users/janusw/orgs", "repos_url": "https://api.github.com/users/janusw/repos", "events_url": "https://api.github.com/users/janusw/events{/privacy}", "received_events_url": "https://api.github.com/users/janusw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46eb666a79f04e992bd3405b0bb9a464cd8a2802", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46eb666a79f04e992bd3405b0bb9a464cd8a2802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46eb666a79f04e992bd3405b0bb9a464cd8a2802"}], "stats": {"total": 222, "additions": 159, "deletions": 63}, "files": [{"sha": "5ed954a7745ac55c999da6405d4c4264094988fc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -1,3 +1,11 @@\n+2012-08-02  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/54147\n+\t* resolve.c (check_proc_interface): New routine for PROCEDURE interface\n+\tchecks.\n+\t(resolve_procedure_interface,resolve_typebound_procedure,\n+\tresolve_fl_derived0): Call it.\n+\n 2012-08-01  Thomas K\u00f6nig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/54033"}, {"sha": "c5810b27172d833d01c58242c9d7163b52bd41ca", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 63, "deletions": 59, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -138,31 +138,14 @@ resolve_typespec_used (gfc_typespec* ts, locus* where, const char* name)\n }\n \n \n-static void resolve_symbol (gfc_symbol *sym);\n-\n-\n-/* Resolve the interface for a PROCEDURE declaration or procedure pointer.  */\n-\n static gfc_try\n-resolve_procedure_interface (gfc_symbol *sym)\n+check_proc_interface (gfc_symbol *ifc, locus *where)\n {\n-  gfc_symbol *ifc = sym->ts.interface;\n-\n-  if (!ifc)\n-    return SUCCESS;\n-\n   /* Several checks for F08:C1216.  */\n-  if (ifc == sym)\n-    {\n-      gfc_error (\"PROCEDURE '%s' at %L may not be used as its own interface\",\n-\t\t sym->name, &sym->declared_at);\n-      return FAILURE;\n-    }\n   if (ifc->attr.procedure)\n     {\n-      gfc_error (\"Interface '%s', used by procedure '%s' at %L, is declared \"\n-\t\t \"in a later PROCEDURE statement\", ifc->name,\n-\t\t sym->name, &sym->declared_at);\n+      gfc_error (\"Interface '%s' at %L is declared \"\n+\t\t \"in a later PROCEDURE statement\", ifc->name, where);\n       return FAILURE;\n     }\n   if (ifc->generic)\n@@ -175,14 +158,14 @@ resolve_procedure_interface (gfc_symbol *sym)\n       if (!gen)\n \t{\n \t  gfc_error (\"Interface '%s' at %L may not be generic\",\n-\t\t     ifc->name, &sym->declared_at);\n+\t\t     ifc->name, where);\n \t  return FAILURE;\n \t}\n     }\n   if (ifc->attr.proc == PROC_ST_FUNCTION)\n     {\n       gfc_error (\"Interface '%s' at %L may not be a statement function\",\n-\t\t ifc->name, &sym->declared_at);\n+\t\t ifc->name, where);\n       return FAILURE;\n     }\n   if (gfc_is_intrinsic (ifc, 0, ifc->declared_at)\n@@ -191,15 +174,44 @@ resolve_procedure_interface (gfc_symbol *sym)\n   if (ifc->attr.intrinsic && !gfc_intrinsic_actual_ok (ifc->name, 0))\n     {\n       gfc_error (\"Intrinsic procedure '%s' not allowed in \"\n-\t\t \"PROCEDURE statement at %L\", ifc->name, &sym->declared_at);\n+\t\t \"PROCEDURE statement at %L\", ifc->name, where);\n+      return FAILURE;\n+    }\n+  if (!ifc->attr.if_source && !ifc->attr.intrinsic && ifc->name[0] != '\\0')\n+    {\n+      gfc_error (\"Interface '%s' at %L must be explicit\", ifc->name, where);\n       return FAILURE;\n     }\n+  return SUCCESS;\n+}\n+\n+\n+static void resolve_symbol (gfc_symbol *sym);\n+\n+\n+/* Resolve the interface for a PROCEDURE declaration or procedure pointer.  */\n+\n+static gfc_try\n+resolve_procedure_interface (gfc_symbol *sym)\n+{\n+  gfc_symbol *ifc = sym->ts.interface;\n+\n+  if (!ifc)\n+    return SUCCESS;\n+\n+  if (ifc == sym)\n+    {\n+      gfc_error (\"PROCEDURE '%s' at %L may not be used as its own interface\",\n+\t\t sym->name, &sym->declared_at);\n+      return FAILURE;\n+    }\n+  if (check_proc_interface (ifc, &sym->declared_at) == FAILURE)\n+    return FAILURE;\n \n-  /* Get the attributes from the interface (now resolved).  */\n   if (ifc->attr.if_source || ifc->attr.intrinsic)\n     {\n+      /* Resolve interface and copy attributes.  */\n       resolve_symbol (ifc);\n-\n       if (ifc->attr.intrinsic)\n \tgfc_resolve_intrinsic (ifc, &ifc->declared_at);\n \n@@ -246,12 +258,6 @@ resolve_procedure_interface (gfc_symbol *sym)\n \t    return FAILURE;\n \t}\n     }\n-  else if (ifc->name[0] != '\\0')\n-    {\n-      gfc_error (\"Interface '%s' of procedure '%s' at %L must be explicit\",\n-\t\t ifc->name, sym->name, &sym->declared_at);\n-      return FAILURE;\n-    }\n \n   return SUCCESS;\n }\n@@ -11565,17 +11571,25 @@ resolve_typebound_procedure (gfc_symtree* stree)\n   /* Default access should already be resolved from the parser.  */\n   gcc_assert (stree->n.tb->access != ACCESS_UNKNOWN);\n \n-  /* It should be a module procedure or an external procedure with explicit\n-     interface.  For DEFERRED bindings, abstract interfaces are ok as well.  */\n-  if ((!proc->attr.subroutine && !proc->attr.function)\n-      || (proc->attr.proc != PROC_MODULE\n-\t  && proc->attr.if_source != IFSRC_IFBODY)\n-      || (proc->attr.abstract && !stree->n.tb->deferred))\n+  if (stree->n.tb->deferred)\n     {\n-      gfc_error (\"'%s' must be a module procedure or an external procedure with\"\n-\t\t \" an explicit interface at %L\", proc->name, &where);\n-      goto error;\n+      if (check_proc_interface (proc, &where) == FAILURE)\n+\tgoto error;\n+    }\n+  else\n+    {\n+      /* Check for F08:C465.  */\n+      if ((!proc->attr.subroutine && !proc->attr.function)\n+\t  || (proc->attr.proc != PROC_MODULE\n+\t      && proc->attr.if_source != IFSRC_IFBODY)\n+\t  || proc->attr.abstract)\n+\t{\n+\t  gfc_error (\"'%s' must be a module procedure or an external procedure with\"\n+\t\t    \" an explicit interface at %L\", proc->name, &where);\n+\t  goto error;\n+\t}\n     }\n+\n   stree->n.tb->subroutine = proc->attr.subroutine;\n   stree->n.tb->function = proc->attr.function;\n \n@@ -11928,20 +11942,17 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \n       if (c->attr.proc_pointer && c->ts.interface)\n \t{\n-\t  if (c->ts.interface->attr.procedure && !sym->attr.vtype)\n-\t    gfc_error (\"Interface '%s', used by procedure pointer component \"\n-\t\t       \"'%s' at %L, is declared in a later PROCEDURE statement\",\n-\t\t       c->ts.interface->name, c->name, &c->loc);\n+\t  gfc_symbol *ifc = c->ts.interface;\n \n-\t  /* Get the attributes from the interface (now resolved).  */\n-\t  if (c->ts.interface->attr.if_source\n-\t      || c->ts.interface->attr.intrinsic)\n-\t    {\n-\t      gfc_symbol *ifc = c->ts.interface;\n+\t  if (!sym->attr.vtype\n+\t      && check_proc_interface (ifc, &c->loc) == FAILURE)\n+\t    return FAILURE;\n \n+\t  if (ifc->attr.if_source || ifc->attr.intrinsic)\n+\t    {\n+\t      /* Resolve interface and copy attributes.  */\n \t      if (ifc->formal && !ifc->formal_ns)\n \t\tresolve_symbol (ifc);\n-\n \t      if (ifc->attr.intrinsic)\n \t\tgfc_resolve_intrinsic (ifc, &ifc->declared_at);\n \n@@ -11980,25 +11991,18 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \t\t      gfc_expr_replace_comp (c->as->lower[i], c);\n \t\t      gfc_expr_replace_comp (c->as->upper[i], c);\n \t\t    }\n-\t        }\n+\t\t}\n \t      /* Copy char length.  */\n \t      if (ifc->ts.type == BT_CHARACTER && ifc->ts.u.cl)\n \t\t{\n \t\t  gfc_charlen *cl = gfc_new_charlen (sym->ns, ifc->ts.u.cl);\n \t\t  gfc_expr_replace_comp (cl->length, c);\n \t\t  if (cl->length && !cl->resolved\n-\t\t        && gfc_resolve_expr (cl->length) == FAILURE)\n+\t\t\t&& gfc_resolve_expr (cl->length) == FAILURE)\n \t\t    return FAILURE;\n \t\t  c->ts.u.cl = cl;\n \t\t}\n \t    }\n-\t  else if (!sym->attr.vtype && c->ts.interface->name[0] != '\\0')\n-\t    {\n-\t      gfc_error (\"Interface '%s' of procedure pointer component \"\n-\t\t\t \"'%s' at %L must be explicit\", c->ts.interface->name,\n-\t\t\t c->name, &c->loc);\n-\t      return FAILURE;\n- \t    }\n \t}\n       else if (c->attr.proc_pointer && c->ts.type == BT_UNKNOWN)\n \t{"}, {"sha": "604782ca8ac3b2f617c7abe46cef8e673d476bd5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -1,3 +1,12 @@\n+2012-08-02  Janus Weil  <janus@gcc.gnu.org>\n+\n+\tPR fortran/54147\n+\t* gfortran.dg/abstract_type_6.f03: Modified.\n+\t* gfortran.dg/proc_ptr_comp_3.f90: Modified.\n+\t* gfortran.dg/proc_ptr_comp_35.f90: New.\n+\t* gfortran.dg/typebound_proc_9.f03: Modified.\n+\t* gfortran.dg/typebound_proc_26.f90: New.\n+\n 2012-08-02  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/torture/pta-callused-1.c: Adjust."}, {"sha": "5eefcb836176a828eb2c8081b4c0fe68a65007e6", "filename": "gcc/testsuite/gfortran.dg/abstract_type_6.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fabstract_type_6.f03?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -10,7 +10,7 @@\n module m\n TYPE, ABSTRACT :: top\n CONTAINS\n-   PROCEDURE(xxx), DEFERRED :: proc_a ! { dg-error \"must be a module procedure\" }\n+   PROCEDURE(xxx), DEFERRED :: proc_a ! { dg-error \"must be explicit\" }\n    ! some useful default behaviour\n    PROCEDURE :: proc_c => top_c ! { dg-error \"must be a module procedure\" }\n END TYPE top"}, {"sha": "eb1d84555ddb1067ca6952fc55e113a8b5daaf81", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_3.f90", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_3.f90?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -24,10 +24,13 @@ subroutine sub\n   procedure, pointer, nopass :: ptr6             ! { dg-error \"Syntax error\" }\n   procedure(), nopass :: ptr8                    ! { dg-error \"POINTER attribute is required\" }\n   procedure(pp), pointer, nopass :: ptr9         ! { dg-error \"declared in a later PROCEDURE statement\" }\n-  procedure(aaargh), pointer, nopass :: ptr10    ! { dg-error \"must be explicit\" }\n   real :: y\n end type t\n \n+type :: t2\n+  procedure(aaargh), pointer, nopass :: ptr10    ! { dg-error \"must be explicit\" }\n+end type\n+\n type,bind(c) :: bct                   ! { dg-error \"BIND.C. derived type\" }\n   procedure(), pointer,nopass :: ptr  ! { dg-error \"cannot be a member of|may not be C interoperable\" }\n end type bct\n@@ -47,4 +50,3 @@ subroutine sub\n call x%y          ! { dg-error \"Expected type-bound procedure or procedure pointer component\" }\n \n end\n-"}, {"sha": "75a76b8ebbfe7ee8d77bf1f32c23256b08840ce8", "filename": "gcc/testsuite/gfortran.dg/proc_ptr_comp_35.f90", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_35.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_35.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fproc_ptr_comp_35.f90?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -0,0 +1,35 @@\n+! { dg-do compile }\n+!\n+! PR 54147: [F03] Interface checks for PPCs & deferred TBPs\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  interface gen\n+    procedure gen\n+  end interface\n+\n+  type t1\n+    procedure(gen),pointer,nopass  :: p1\n+    procedure(gen2),pointer,nopass :: p2  ! { dg-error \"may not be generic\" }\n+  end type\n+\n+  type t2\n+    procedure(sf),pointer,nopass   :: p3  ! { dg-error \"may not be a statement function\" }\n+  end type\n+\n+  type t3\n+    procedure(char),pointer,nopass :: p4  ! { dg-error \"Intrinsic procedure\" }\n+  end type\n+\n+  interface gen2\n+    procedure gen\n+  end interface\n+\n+  sf(x) = x**2  ! { dg-warning \"Obsolescent feature\" }\n+\n+contains\n+\n+  subroutine gen\n+  end subroutine\n+\n+end"}, {"sha": "0c4264ed131b67a1fa8e6e42a3514d8a95f4cc41", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_26.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_26.f90?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do compile }\n+!\n+! PR 54147: [F03] Interface checks for PPCs & deferred TBPs\n+!\n+! Contributed by Janus Weil <janus@gcc.gnu.org>\n+\n+  interface gen\n+    procedure gen\n+  end interface\n+\n+  type, abstract :: t1\n+  contains\n+    procedure(gen),deferred,nopass  :: p1\n+    procedure(gen2),deferred,nopass :: p2  ! { dg-error \"may not be generic\" }\n+  end type\n+\n+  type, abstract :: t2\n+  contains\n+    procedure(sf),deferred,nopass   :: p3  ! { dg-error \"may not be a statement function\" }\n+  end type\n+\n+  type, abstract :: t3\n+  contains\n+    procedure(char),deferred,nopass :: p4  ! { dg-error \"Intrinsic procedure\" }\n+  end type\n+\n+  interface gen2\n+    procedure gen\n+  end interface\n+\n+  sf(x) = x**2  ! { dg-warning \"Obsolescent feature\" }\n+\n+contains\n+\n+  subroutine gen\n+  end subroutine\n+\n+end"}, {"sha": "a6ca35bb010a19a5dcfddf61f2a7fb4da16540fb", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_9.f03", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_9.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6a45605019bfe2fe588961c6959630f8b9deed0/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_9.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_9.f03?ref=b6a45605019bfe2fe588961c6959630f8b9deed0", "patch": "@@ -21,7 +21,7 @@ END SUBROUTINE intf\n     PROCEDURE, DEFERRED :: p2 ! { dg-error \"Interface must be specified\" }\n     PROCEDURE(intf), NOPASS :: p3 ! { dg-error \"should be declared DEFERRED\" }\n     PROCEDURE(intf), DEFERRED, NON_OVERRIDABLE :: p4 ! { dg-error \"can't both\" }\n-    PROCEDURE(unknown), DEFERRED :: p5 ! { dg-error \"has no IMPLICIT|module procedure\" }\n+    PROCEDURE(unknown), DEFERRED :: p5 ! { dg-error \"has no IMPLICIT|must be explicit\" }\n     PROCEDURE(intf), DEFERRED, DEFERRED :: p6 ! { dg-error \"Duplicate DEFERRED\" }\n     PROCEDURE(intf), DEFERRED :: p6 => proc ! { dg-error \"is invalid for DEFERRED\" }\n     PROCEDURE(), DEFERRED :: p7 ! { dg-error \"Interface-name expected\" }"}]}