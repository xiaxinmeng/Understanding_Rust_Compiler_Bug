{"sha": "2e9c3ef35436092c081022cbc7fc6df39ff879e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU5YzNlZjM1NDM2MDkyYzA4MTAyMmNiYzdmYzZkZjM5ZmY4NzllMQ==", "commit": {"author": {"name": "Matt Austern", "email": "austern@google.com", "date": "2010-09-28T10:35:53Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-09-28T10:35:53Z"}, "message": "chi2_quality.cc: New.\n\n2010-09-28  Matt Austern  <austern@google.com>\n\n\t* testsuite/20_util/hash/chi2_quality.cc: New.\n\t* testsuite/20_util/hash/quality.cc: Likewise.\n\nFrom-SVN: r164682", "tree": {"sha": "70488a3f7bac5e033bd345960a3a7318134c4918", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70488a3f7bac5e033bd345960a3a7318134c4918"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e9c3ef35436092c081022cbc7fc6df39ff879e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e9c3ef35436092c081022cbc7fc6df39ff879e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e9c3ef35436092c081022cbc7fc6df39ff879e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e9c3ef35436092c081022cbc7fc6df39ff879e1/comments", "author": {"login": "austern", "id": 2576694, "node_id": "MDQ6VXNlcjI1NzY2OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2576694?v=4", "gravatar_id": "", "url": "https://api.github.com/users/austern", "html_url": "https://github.com/austern", "followers_url": "https://api.github.com/users/austern/followers", "following_url": "https://api.github.com/users/austern/following{/other_user}", "gists_url": "https://api.github.com/users/austern/gists{/gist_id}", "starred_url": "https://api.github.com/users/austern/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/austern/subscriptions", "organizations_url": "https://api.github.com/users/austern/orgs", "repos_url": "https://api.github.com/users/austern/repos", "events_url": "https://api.github.com/users/austern/events{/privacy}", "received_events_url": "https://api.github.com/users/austern/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c1165050677dbdc26d844fadf2b3b57da1266bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c1165050677dbdc26d844fadf2b3b57da1266bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c1165050677dbdc26d844fadf2b3b57da1266bf"}], "stats": {"total": 391, "additions": 391, "deletions": 0}, "files": [{"sha": "7d05785b6b65018ba475d7691e2cc531e1bb5125", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9c3ef35436092c081022cbc7fc6df39ff879e1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9c3ef35436092c081022cbc7fc6df39ff879e1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2e9c3ef35436092c081022cbc7fc6df39ff879e1", "patch": "@@ -1,3 +1,8 @@\n+2010-09-28  Matt Austern  <austern@google.com>\n+\n+\t* testsuite/20_util/hash/chi2_quality.cc: New.\n+\t* testsuite/20_util/hash/quality.cc: Likewise.\n+\n 2010-09-27  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/bits/allocator.h (allocator_arg_t, allocator_arg,"}, {"sha": "4c2f09e3ce7ee88f21eb75c6d7b89503b626cba1", "filename": "libstdc++-v3/testsuite/20_util/hash/chi2_quality.cc", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9c3ef35436092c081022cbc7fc6df39ff879e1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhash%2Fchi2_quality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9c3ef35436092c081022cbc7fc6df39ff879e1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhash%2Fchi2_quality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhash%2Fchi2_quality.cc?ref=2e9c3ef35436092c081022cbc7fc6df39ff879e1", "patch": "@@ -0,0 +1,214 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// This file uses the chi^2 test to measure the quality of a hash\n+// function, by computing the uniformity with which it distributes a set\n+// of N strings into k buckets (where k is significantly greater than N).\n+//\n+// Each bucket has B[i] strings in it. The expected value of each bucket\n+// for a uniform distribution is z = N/k, so\n+//   chi^2 = Sum_i (B[i] - z)^2 / z.\n+//\n+// We check whether chi^2 is small enough to be consistent with the\n+// hypothesis of a uniform distribution. If F(chi^2, k-1) is close to\n+// 0 (where F is the cumulative probability distribution), we can\n+// reject that hypothesis. So we don't want F to be too small, which\n+// for large k, means we want chi^2 to be not too much larger than k.\n+//\n+// We use the chi^2 test for several sets of strings. Any non-horrible\n+// hash function should do well with purely random strings. A really\n+// good hash function will also do well with more structured sets,\n+// including ones where the strings differ by only a few bits.\n+\n+#include <algorithm>\n+#include <cstdlib>\n+#include <cstdio>\n+#include <fstream>\n+#include <functional>\n+#include <iostream>\n+#include <iterator>\n+#include <string>\n+#include <unordered_set>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+// Use smaller statistics when running on simulators, so it takes less time.\n+// { dg-options \"-DSAMPLES=10000\" { target simulator } }\n+#ifndef SAMPLES\n+#define SAMPLES 300000\n+#endif\n+\n+template <typename Container>\n+  double\n+  chi2_hash(const Container& c, long buckets)\n+  {\n+    std::vector<int> counts(buckets);\n+    std::hash<std::string> hasher;\n+    double elements = 0;\n+    for (auto i = c.begin(); i != c.end(); ++i)\n+      {\n+        ++counts[hasher(*i) % buckets];\n+        ++elements;\n+      }\n+\n+    const double z = elements / buckets;\n+    double sum = 0;\n+    for (long i = 0; i < buckets; ++i)\n+      {\n+        double delta = counts[i] - z;\n+        sum += delta*delta;\n+      }\n+    return sum/z;\n+  }\n+\n+// Tests chi^2 for a distribution of uniformly generated random strings.\n+void\n+test_uniform_random()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::srand(137);\n+  std::unordered_set<std::string> set;\n+  std::string s;\n+  const unsigned long N = SAMPLES;\n+  const unsigned long k = N/100;\n+  const unsigned int len = 25;\n+  while (set.size() < N)\n+    {\n+      s.clear();\n+      for (int i = 0; i < len; ++i)\n+        {\n+          s.push_back(rand() % 128);\n+        }\n+      set.insert(s);\n+    }\n+\n+  double chi2 = chi2_hash(set, k);\n+  VERIFY( chi2 < k*1.1 );\n+}\n+\n+// Tests chi^2 for a distribution of strings that differ from each\n+// other by only a few bits. We start with an arbitrary base string, and\n+// flip three random bits for each member of the set.\n+void\n+test_bit_flip_set()\n+{\n+  bool test __attribute__((unused)) = true;\n+  const unsigned long N = SAMPLES;\n+  const unsigned long k = N/100;\n+  const unsigned int len = 67;\n+  const unsigned int bitlen = len * 8;\n+  const unsigned int bits_to_flip = 3;\n+  const char base[len+1] = \"abcdefghijklmnopqrstuvwxyz\"\n+                           \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+                           \"0123456789!@#$%\";\n+\n+  std::unordered_set<std::string> set;\n+  while (set.size() < N)\n+    {\n+      std::string s(base, base+len);\n+      for (int i = 0; i < bits_to_flip; ++i)\n+        {\n+          int bit = rand() % bitlen;\n+          s[bit/8] ^= (1 << (bit%8));\n+        }\n+      set.insert(s);\n+    }\n+\n+  double chi2 = chi2_hash(set, k);\n+  VERIFY( chi2 < k*1.1 );\n+}\n+\n+// Tests chi^2 of a set of strings that all have a similar pattern,\n+// intended to mimic some sort of ID string.\n+void\n+test_numeric_pattern_set()\n+{\n+  bool test __attribute__((unused)) = true;\n+  const unsigned long N = SAMPLES;\n+  const unsigned long k = N/100;\n+  std::vector<std::string> set;\n+  for (unsigned long i = 0; i < N; ++i)\n+    {\n+      long i1 = i % 100000;\n+      long i2 = i / 100000;\n+      char buf[16];\n+      std::sprintf(buf, \"XX-%05lu-%05lu\", i1, i2);\n+      set.push_back(buf);\n+    }\n+\n+  double chi2 = chi2_hash(set, k);\n+  VERIFY( chi2 < k*1.1 );\n+}\n+\n+// Tests chi^2 for a set of strings that all consist of '1' and '0'.\n+void\n+test_bit_string_set()\n+{\n+  bool test __attribute__((unused)) = true;\n+  const unsigned long N = SAMPLES;\n+  const unsigned long k = N/100;\n+  std::vector<std::string> set;\n+  std::string s;\n+  for (unsigned long i = 0; i < N; ++i)\n+    {\n+      s.clear();\n+      for (int j = 0; j < sizeof(unsigned long) * 8; ++j)\n+        {\n+          const bool bit = (1UL << j) & i;\n+          s.push_back(bit ? '1' : '0');\n+        }\n+      set.push_back(s);\n+    }\n+\n+  double chi2 = chi2_hash(set, k);\n+  VERIFY( chi2 < k*1.1 );\n+}\n+\n+// Tests chi^2 for a set of words taken from a document written in English.\n+void\n+test_document_words()\n+{\n+  bool test __attribute__((unused)) = true;\n+  const std::string f_name = \"thirty_years_among_the_dead_preproc.txt\";\n+  std::ifstream in(f_name);\n+  VERIFY( in.is_open() );\n+  std::vector<std::string> words;\n+  words.assign(std::istream_iterator<std::string>(in),\n+               std::istream_iterator<std::string>());\n+  VERIFY( words.size() > 100000 );\n+  std::sort(words.begin(), words.end());\n+  auto it = std::unique(words.begin(), words.end());\n+  words.erase(it, words.end());\n+  VERIFY( words.size() > 5000 );\n+\n+  const unsigned long k = words.size() / 20;\n+  double chi2 = chi2_hash(words, k);\n+  VERIFY( chi2 < k*1.1 );\n+}\n+\n+int\n+main()\n+{\n+  test_uniform_random();\n+  test_bit_flip_set();\n+  test_numeric_pattern_set();\n+  test_bit_string_set();\n+  test_document_words();\n+  return 0;\n+}"}, {"sha": "3e3951f00edd8bd5410563f194b91f7a1736d871", "filename": "libstdc++-v3/testsuite/20_util/hash/quality.cc", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e9c3ef35436092c081022cbc7fc6df39ff879e1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhash%2Fquality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e9c3ef35436092c081022cbc7fc6df39ff879e1/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhash%2Fquality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fhash%2Fquality.cc?ref=2e9c3ef35436092c081022cbc7fc6df39ff879e1", "patch": "@@ -0,0 +1,172 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <cstdlib>\n+#include <unordered_set>\n+#include <string>\n+#include <functional>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+using namespace std;\n+\n+// { dg-options \"-DNTESTS=1 -DNSTRINGS=100 -DSTRSIZE=21\" { target simulator } }\n+#ifndef NTESTS\n+#define NTESTS 5\n+#endif\n+#ifndef NSTRINGS\n+#define NSTRINGS 200\n+#endif\n+#ifndef STRSIZE\n+#define STRSIZE 42\n+#endif\n+\n+const int num_quality_tests = NTESTS;\n+const int num_strings_for_quality_tests = NSTRINGS;\n+const int string_size = STRSIZE;\n+\n+vector<string>\n+random_strings(int n, int len)\n+{\n+  string s(len, '\\0');\n+  unordered_set<string> result_set;\n+  while (result_set.size() < n)\n+    {\n+      result_set.insert(s);\n+      unsigned int tmp = rand();\n+      tmp %= len * 256;\n+      s[tmp / 256] = tmp % 256;\n+    }\n+  return vector<string>(result_set.begin(), result_set.end());\n+}\n+\n+double\n+score_from_varying_position(string s, int index)\n+{\n+  bool test __attribute__((unused)) = true;\n+  int bits_in_hash_code = sizeof(size_t) * 8;\n+\n+  // We'll iterate through all 256 vals for s[index], leaving the rest\n+  // of s fixed.  Then, for example, out of the 128 times that\n+  // s[index] has its 3rd bit equal to 0 we would like roughly half 1s\n+  // and half 0s in bit 9 of the hash codes.\n+  //\n+  // Bookkeeping: Conceptually we want a 3D array of ints.  We want to\n+  // count the number of times each output position (of which there are\n+  // bits_in_hash_code) is 1 for each bit position within s[index] (of \n+  // which there are 8) and value of that bit (of which there are 2).\n+  const int jj = 2;\n+  const int kk = jj * bits_in_hash_code;\n+  const int array_size = 8 * kk;\n+  vector<int> ones(array_size, 0);\n+\n+  for (int i = 0; i < 256; i++)\n+    {\n+      s[index] = i;\n+      size_t h = hash<string>()(s);\n+      for (int j = 0; h != 0; j++, h >>= 1)\n+        {\n+          if (h & 1)\n+            {\n+              for (int k = 0; k < 8; k++)\n+                ++ones[k * kk + j * jj + ((i >> k) & 1)];\n+            }\n+        }\n+    }\n+\n+  // At most, the innermost statement in the above loop nest can\n+  // execute 256 * bits_in_hash_code * 8 times.  If the hash is good,\n+  // it'll execute about half that many times, with a pretty even\n+  // spread across the elements of ones[].\n+  VERIFY( 256 * bits_in_hash_code * 8 / array_size == 128 );\n+  int max_ones_possible = 128;\n+  int good = 0, bad = 0;\n+  for (int bit = 0; bit <= 1; bit++)\n+    {\n+      for (int j = 0; j < bits_in_hash_code; j++)\n+        {\n+          for (int bitpos = 0; bitpos < 8; bitpos++)\n+            {\n+              int z = ones[bitpos * kk + j * jj + bit];\n+              if (z <= max_ones_possible / 6\n+\t\t  || z >= max_ones_possible * 5 / 6)\n+                {\n+                  // The hash function screwed up, or was just unlucky,\n+                  // as 128 flips of a perfect coin occasionally yield\n+                  // far from 64 heads.\n+                  bad++;\n+                }\n+              else\n+                good++;\n+            }\n+        }\n+    }\n+  return good / (double)(good + bad);\n+}\n+\n+double\n+score_from_varying_position(const vector<string>& v, int index)\n+{\n+  double score = 0;\n+  for (int i = 0; i < v.size(); i++)\n+    score += score_from_varying_position(v[i], index);\n+  return score / v.size();\n+}\n+\n+double\n+quality_test(int num_strings, int string_size)\n+{\n+  // Construct random strings.\n+  vector<string> v = random_strings(num_strings, string_size);\n+  double sum_of_scores = 0;\n+  for (int i = 0; i < string_size; i++)\n+    sum_of_scores += score_from_varying_position(v, i);\n+\n+  // A good hash function should have a score very close to 1, and a bad\n+  // hash function will have a score close to 0.\n+  return sum_of_scores / string_size;\n+}\n+\n+void\n+quality_test()\n+{\n+  bool test __attribute__((unused)) = true;\n+  srand(137);\n+  double sum_of_scores = 0;\n+  for (int i = 0; i < num_quality_tests; i++)\n+    {\n+      double score = quality_test(num_strings_for_quality_tests,\n+\t\t\t\t  string_size);\n+      sum_of_scores += score;\n+      VERIFY( score > 0.99 );\n+    }\n+\n+  if (num_quality_tests > 1)\n+    {\n+      double mean_quality = sum_of_scores / num_quality_tests;\n+      VERIFY( mean_quality > 0.9999 );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  quality_test();\n+  return 0;\n+}"}]}