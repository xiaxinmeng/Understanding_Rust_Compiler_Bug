{"sha": "86e3672871beff63eebb195642566224c9f80891", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZlMzY3Mjg3MWJlZmY2M2VlYmIxOTU2NDI1NjYyMjRjOWY4MDg5MQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:15:20Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:15:20Z"}, "message": "poly_int: current_vector_size and TARGET_AUTOVECTORIZE_VECTOR_SIZES\n\nThis patch changes the type of current_vector_size to poly_uint64.\nIt also changes TARGET_AUTOVECTORIZE_VECTOR_SIZES so that it fills\nin a vector of possible sizes (as poly_uint64s) instead of returning\na bitmask.  The documentation claimed that the hook didn't need to\ninclude the default vector size (returned by preferred_simd_mode),\nbut that wasn't consistent with the omp-low.c usage.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.h (vector_sizes, auto_vector_sizes): New typedefs.\n\t* target.def (autovectorize_vector_sizes): Return the vector sizes\n\tby pointer, using vector_sizes rather than a bitmask.\n\t* targhooks.h (default_autovectorize_vector_sizes): Update accordingly.\n\t* targhooks.c (default_autovectorize_vector_sizes): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_autovectorize_vector_sizes):\n\tLikewise.\n\t* config/arc/arc.c (arc_autovectorize_vector_sizes): Likewise.\n\t* config/arm/arm.c (arm_autovectorize_vector_sizes): Likewise.\n\t* config/i386/i386.c (ix86_autovectorize_vector_sizes): Likewise.\n\t* config/mips/mips.c (mips_autovectorize_vector_sizes): Likewise.\n\t* omp-general.c (omp_max_vf): Likewise.\n\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n\t* optabs-query.c (can_vec_mask_load_store_p): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop): Likewise.\n\t* tree-vect-slp.c (vect_slp_bb): Likewise.\n\t* doc/tm.texi: Regenerate.\n\t* tree-vectorizer.h (current_vector_size): Change from an unsigned int\n\tto a poly_uint64.\n\t* tree-vect-stmts.c (get_vectype_for_scalar_type_and_size): Take\n\tthe vector size as a poly_uint64 rather than an unsigned int.\n\t(current_vector_size): Change from an unsigned int to a poly_uint64.\n\t(get_vectype_for_scalar_type): Update accordingly.\n\t* tree.h (build_truth_vector_type): Take the size and number of\n\tunits as a poly_uint64 rather than an unsigned int.\n\t(build_vector_type): Add a temporary overload that takes\n\tthe number of units as a poly_uint64 rather than an unsigned int.\n\t* tree.c (make_vector_type): Likewise.\n\t(build_truth_vector_type): Take the number of units as a poly_uint64\n\trather than an unsigned int.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256131", "tree": {"sha": "2904209c48ac70db2e36ec1f0c1f7534c4b09f0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2904209c48ac70db2e36ec1f0c1f7534c4b09f0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86e3672871beff63eebb195642566224c9f80891", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e3672871beff63eebb195642566224c9f80891", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86e3672871beff63eebb195642566224c9f80891", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86e3672871beff63eebb195642566224c9f80891/comments", "author": null, "committer": null, "parents": [{"sha": "87133c45a06aa9c04cb6bc13b3b0733ec43efcec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87133c45a06aa9c04cb6bc13b3b0733ec43efcec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87133c45a06aa9c04cb6bc13b3b0733ec43efcec"}], "stats": {"total": 348, "additions": 231, "deletions": 117}, "files": [{"sha": "39f3a91d24d3edd2c47c4f0aad355bb4330e70b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -1,3 +1,38 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.h (vector_sizes, auto_vector_sizes): New typedefs.\n+\t* target.def (autovectorize_vector_sizes): Return the vector sizes\n+\tby pointer, using vector_sizes rather than a bitmask.\n+\t* targhooks.h (default_autovectorize_vector_sizes): Update accordingly.\n+\t* targhooks.c (default_autovectorize_vector_sizes): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_autovectorize_vector_sizes):\n+\tLikewise.\n+\t* config/arc/arc.c (arc_autovectorize_vector_sizes): Likewise.\n+\t* config/arm/arm.c (arm_autovectorize_vector_sizes): Likewise.\n+\t* config/i386/i386.c (ix86_autovectorize_vector_sizes): Likewise.\n+\t* config/mips/mips.c (mips_autovectorize_vector_sizes): Likewise.\n+\t* omp-general.c (omp_max_vf): Likewise.\n+\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n+\t* optabs-query.c (can_vec_mask_load_store_p): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop): Likewise.\n+\t* tree-vect-slp.c (vect_slp_bb): Likewise.\n+\t* doc/tm.texi: Regenerate.\n+\t* tree-vectorizer.h (current_vector_size): Change from an unsigned int\n+\tto a poly_uint64.\n+\t* tree-vect-stmts.c (get_vectype_for_scalar_type_and_size): Take\n+\tthe vector size as a poly_uint64 rather than an unsigned int.\n+\t(current_vector_size): Change from an unsigned int to a poly_uint64.\n+\t(get_vectype_for_scalar_type): Update accordingly.\n+\t* tree.h (build_truth_vector_type): Take the size and number of\n+\tunits as a poly_uint64 rather than an unsigned int.\n+\t(build_vector_type): Add a temporary overload that takes\n+\tthe number of units as a poly_uint64 rather than an unsigned int.\n+\t* tree.c (make_vector_type): Likewise.\n+\t(build_truth_vector_type): Take the number of units as a poly_uint64\n+\trather than an unsigned int.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "21f049a4974f5fc46412699a693c6e091108c9f8", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -11327,12 +11327,13 @@ aarch64_preferred_simd_mode (scalar_mode mode)\n   return aarch64_simd_container_mode (mode, 128);\n }\n \n-/* Return the bitmask of possible vector sizes for the vectorizer\n+/* Return a list of possible vector sizes for the vectorizer\n    to iterate over.  */\n-static unsigned int\n-aarch64_autovectorize_vector_sizes (void)\n+static void\n+aarch64_autovectorize_vector_sizes (vector_sizes *sizes)\n {\n-  return (16 | 8);\n+  sizes->safe_push (16);\n+  sizes->safe_push (8);\n }\n \n /* Implement TARGET_MANGLE_TYPE.  */"}, {"sha": "ed7c29533eff5ae77f64189f5ea7537a1ee3751d", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -410,10 +410,14 @@ arc_preferred_simd_mode (scalar_mode mode)\n /* Implements target hook\n    TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES.  */\n \n-static unsigned int\n-arc_autovectorize_vector_sizes (void)\n+static void\n+arc_autovectorize_vector_sizes (vector_sizes *sizes)\n {\n-  return TARGET_PLUS_QMACW ? (8 | 4) : 0;\n+  if (TARGET_PLUS_QMACW)\n+    {\n+      sizes->quick_push (8);\n+      sizes->quick_push (4);\n+    }\n }\n \n /* TARGET_PRESERVE_RELOAD_P is still awaiting patch re-evaluation / review.  */"}, {"sha": "dfd3c7c39f989f8cf643516ee2aef4f18728f2ee", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -284,7 +284,7 @@ static bool arm_builtin_support_vector_misalignment (machine_mode mode,\n static void arm_conditional_register_usage (void);\n static enum flt_eval_method arm_excess_precision (enum excess_precision_type);\n static reg_class_t arm_preferred_rename_class (reg_class_t rclass);\n-static unsigned int arm_autovectorize_vector_sizes (void);\n+static void arm_autovectorize_vector_sizes (vector_sizes *);\n static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n static int arm_cortex_m_branch_cost (bool, bool);\n@@ -28119,10 +28119,14 @@ arm_vector_alignment (const_tree type)\n   return align;\n }\n \n-static unsigned int\n-arm_autovectorize_vector_sizes (void)\n+static void\n+arm_autovectorize_vector_sizes (vector_sizes *sizes)\n {\n-  return TARGET_NEON_VECTORIZE_DOUBLE ? 0 : (16 | 8);\n+  if (!TARGET_NEON_VECTORIZE_DOUBLE)\n+    {\n+      sizes->safe_push (16);\n+      sizes->safe_push (8);\n+    }\n }\n \n static bool"}, {"sha": "cac510de9710766a5139d095d0212954a628496b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -48942,17 +48942,20 @@ ix86_preferred_simd_mode (scalar_mode mode)\n    vectors.  If AVX512F is enabled then try vectorizing with 512bit,\n    256bit and 128bit vectors.  */\n \n-static unsigned int\n-ix86_autovectorize_vector_sizes (void)\n+static void\n+ix86_autovectorize_vector_sizes (vector_sizes *sizes)\n {\n-  unsigned int bytesizes = 0;\n-\n   if (TARGET_AVX512F && !TARGET_PREFER_AVX256)\n-    bytesizes |= (64 | 32 | 16);\n+    {\n+      sizes->safe_push (64);\n+      sizes->safe_push (32);\n+      sizes->safe_push (16);\n+    }\n   else if (TARGET_AVX && !TARGET_PREFER_AVX128)\n-    bytesizes |= (32 | 16);\n-\n-  return bytesizes;\n+    {\n+      sizes->safe_push (32);\n+      sizes->safe_push (16);\n+    }\n }\n \n /* Implemenation of targetm.vectorize.get_mask_mode.  */"}, {"sha": "b1acdf6df2b55473869ee47a100270a949667861", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -13401,10 +13401,11 @@ mips_preferred_simd_mode (scalar_mode mode)\n \n /* Implement TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES.  */\n \n-static unsigned int\n-mips_autovectorize_vector_sizes (void)\n+static void\n+mips_autovectorize_vector_sizes (vector_sizes *sizes)\n {\n-  return ISA_HAS_MSA ? 16 : 0;\n+  if (ISA_HAS_MSA)\n+    sizes->safe_push (16);\n }\n \n /* Implement TARGET_INIT_LIBFUNCS.  */"}, {"sha": "08593a4f5a61d5e97a654220f422dae9c33b91ca", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -5873,11 +5873,15 @@ equal to @code{word_mode}, because the vectorizer can do some\n transformations even in absence of specialized @acronym{SIMD} hardware.\n @end deftypefn\n \n-@deftypefn {Target Hook} {unsigned int} TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES (void)\n-This hook should return a mask of sizes that should be iterated over\n-after trying to autovectorize using the vector size derived from the\n-mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n-The default is zero which means to not iterate over other vector sizes.\n+@deftypefn {Target Hook} void TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES (vector_sizes *@var{sizes})\n+If the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is not\n+the only one that is worth considering, this hook should add all suitable\n+vector sizes to @var{sizes}, in order of decreasing preference.  The first\n+one should be the size of @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n+\n+The hook does not need to do anything if the vector returned by\n+@code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is the only one relevant\n+for autovectorization.  The default implementation does nothing.\n @end deftypefn\n \n @deftypefn {Target Hook} opt_machine_mode TARGET_VECTORIZE_GET_MASK_MODE (poly_uint64 @var{nunits}, poly_uint64 @var{length})"}, {"sha": "179139c5e759e29a9f7e4251e01a7db9d131b7dc", "filename": "gcc/omp-general.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -429,17 +429,21 @@ omp_max_vf (void)\n \t  && global_options_set.x_flag_tree_loop_vectorize))\n     return 1;\n \n-  int vf = 1;\n-  int vs = targetm.vectorize.autovectorize_vector_sizes ();\n-  if (vs)\n-    vf = 1 << floor_log2 (vs);\n-  else\n+  auto_vector_sizes sizes;\n+  targetm.vectorize.autovectorize_vector_sizes (&sizes);\n+  if (!sizes.is_empty ())\n     {\n-      machine_mode vqimode = targetm.vectorize.preferred_simd_mode (QImode);\n-      if (GET_MODE_CLASS (vqimode) == MODE_VECTOR_INT)\n-\tvf = GET_MODE_NUNITS (vqimode);\n+      poly_uint64 vf = 0;\n+      for (unsigned int i = 0; i < sizes.length (); ++i)\n+\tvf = ordered_max (vf, sizes[i]);\n+      return vf;\n     }\n-  return vf;\n+\n+  machine_mode vqimode = targetm.vectorize.preferred_simd_mode (QImode);\n+  if (GET_MODE_CLASS (vqimode) == MODE_VECTOR_INT)\n+    return GET_MODE_NUNITS (vqimode);\n+\n+  return 1;\n }\n \n /* Return maximum SIMT width if offloading may target SIMT hardware.  */"}, {"sha": "efbdd0519a4e0b4e580f3de3153adeff1856f02b", "filename": "gcc/omp-low.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -3381,9 +3381,11 @@ omp_clause_aligned_alignment (tree clause)\n   /* Otherwise return implementation defined alignment.  */\n   unsigned int al = 1;\n   opt_scalar_mode mode_iter;\n-  int vs = targetm.vectorize.autovectorize_vector_sizes ();\n-  if (vs)\n-    vs = 1 << floor_log2 (vs);\n+  auto_vector_sizes sizes;\n+  targetm.vectorize.autovectorize_vector_sizes (&sizes);\n+  poly_uint64 vs = 0;\n+  for (unsigned int i = 0; i < sizes.length (); ++i)\n+    vs = ordered_max (vs, sizes[i]);\n   static enum mode_class classes[]\n     = { MODE_INT, MODE_VECTOR_INT, MODE_FLOAT, MODE_VECTOR_FLOAT };\n   for (int i = 0; i < 4; i += 2)\n@@ -3394,16 +3396,16 @@ omp_clause_aligned_alignment (tree clause)\n \tmachine_mode vmode = targetm.vectorize.preferred_simd_mode (mode);\n \tif (GET_MODE_CLASS (vmode) != classes[i + 1])\n \t  continue;\n-\twhile (vs\n-\t       && GET_MODE_SIZE (vmode) < vs\n+\twhile (maybe_ne (vs, 0U)\n+\t       && known_lt (GET_MODE_SIZE (vmode), vs)\n \t       && GET_MODE_2XWIDER_MODE (vmode).exists ())\n \t  vmode = GET_MODE_2XWIDER_MODE (vmode).require ();\n \n \ttree type = lang_hooks.types.type_for_mode (mode, 1);\n \tif (type == NULL_TREE || TYPE_MODE (type) != mode)\n \t  continue;\n-\ttype = build_vector_type (type, GET_MODE_SIZE (vmode)\n-\t\t\t\t\t/ GET_MODE_SIZE (mode));\n+\tunsigned int nelts = GET_MODE_SIZE (vmode) / GET_MODE_SIZE (mode);\n+\ttype = build_vector_type (type, nelts);\n \tif (TYPE_MODE (type) != vmode)\n \t  continue;\n \tif (TYPE_ALIGN_UNIT (type) > al)"}, {"sha": "a2838e936887fad26f81b839d67abdf5c2eacc28", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -556,7 +556,6 @@ can_vec_mask_load_store_p (machine_mode mode,\n {\n   optab op = is_load ? maskload_optab : maskstore_optab;\n   machine_mode vmode;\n-  unsigned int vector_sizes;\n \n   /* If mode is vector mode, check it directly.  */\n   if (VECTOR_MODE_P (mode))\n@@ -580,14 +579,14 @@ can_vec_mask_load_store_p (machine_mode mode,\n       && convert_optab_handler (op, vmode, mask_mode) != CODE_FOR_nothing)\n     return true;\n \n-  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n-  while (vector_sizes != 0)\n+  auto_vector_sizes vector_sizes;\n+  targetm.vectorize.autovectorize_vector_sizes (&vector_sizes);\n+  for (unsigned int i = 0; i < vector_sizes.length (); ++i)\n     {\n-      unsigned int cur = 1 << floor_log2 (vector_sizes);\n-      vector_sizes &= ~cur;\n-      if (cur <= GET_MODE_SIZE (smode))\n+      poly_uint64 cur = vector_sizes[i];\n+      poly_uint64 nunits;\n+      if (!multiple_p (cur, GET_MODE_SIZE (smode), &nunits))\n \tcontinue;\n-      unsigned int nunits = cur / GET_MODE_SIZE (smode);\n       if (mode_for_vector (smode, nunits).exists (&vmode)\n \t  && VECTOR_MODE_P (vmode)\n \t  && targetm.vectorize.get_mask_mode (nunits, cur).exists (&mask_mode)"}, {"sha": "dcebb7716d2725006a04aa736e640673bb5ee56a", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -1894,12 +1894,16 @@ transformations even in absence of specialized @acronym{SIMD} hardware.\",\n    after processing the preferred one derived from preferred_simd_mode.  */\n DEFHOOK\n (autovectorize_vector_sizes,\n- \"This hook should return a mask of sizes that should be iterated over\\n\\\n-after trying to autovectorize using the vector size derived from the\\n\\\n-mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\\n\\\n-The default is zero which means to not iterate over other vector sizes.\",\n- unsigned int,\n- (void),\n+ \"If the mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is not\\n\\\n+the only one that is worth considering, this hook should add all suitable\\n\\\n+vector sizes to @var{sizes}, in order of decreasing preference.  The first\\n\\\n+one should be the size of @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\\n\\\n+\\n\\\n+The hook does not need to do anything if the vector returned by\\n\\\n+@code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE} is the only one relevant\\n\\\n+for autovectorization.  The default implementation does nothing.\",\n+ void,\n+ (vector_sizes *sizes),\n  default_autovectorize_vector_sizes)\n \n /* Function to get a target mode for a vector mask.  */"}, {"sha": "6c1015a98666289f2c0467cf66e82a7520e40c7e", "filename": "gcc/target.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -195,6 +195,13 @@ enum vect_cost_model_location {\n \n class vec_perm_indices;\n \n+/* The type to use for lists of vector sizes.  */\n+typedef vec<poly_uint64> vector_sizes;\n+\n+/* Same, but can be used to construct local lists that are\n+   automatically freed.  */\n+typedef auto_vec<poly_uint64, 8> auto_vector_sizes;\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "4533f9016ff57b0d969560429e6de83c20153679", "filename": "gcc/targhooks.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -1284,10 +1284,9 @@ default_preferred_simd_mode (scalar_mode)\n /* By default only the size derived from the preferred vector mode\n    is tried.  */\n \n-unsigned int\n-default_autovectorize_vector_sizes (void)\n+void\n+default_autovectorize_vector_sizes (vector_sizes *)\n {\n-  return 0;\n }\n \n /* By default a vector of integers is used as a mask.  */"}, {"sha": "d67afb2461f1bfa35d980c60e854a4bc9c340f58", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -108,7 +108,7 @@ default_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t     const_tree,\n \t\t\t\t\t     int, bool);\n extern machine_mode default_preferred_simd_mode (scalar_mode mode);\n-extern unsigned int default_autovectorize_vector_sizes (void);\n+extern void default_autovectorize_vector_sizes (vector_sizes *);\n extern opt_machine_mode default_get_mask_mode (poly_uint64, poly_uint64);\n extern void *default_init_cost (struct loop *);\n extern unsigned default_add_stmt_cost (void *, int, enum vect_cost_for_stmt,"}, {"sha": "557522c2ee5c6349a1f86e907db5d401d17c896a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 56, "deletions": 33, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -2330,11 +2330,12 @@ loop_vec_info\n vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n {\n   loop_vec_info loop_vinfo;\n-  unsigned int vector_sizes;\n+  auto_vector_sizes vector_sizes;\n \n   /* Autodetect first vector size we try.  */\n   current_vector_size = 0;\n-  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+  targetm.vectorize.autovectorize_vector_sizes (&vector_sizes);\n+  unsigned int next_size = 0;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -2350,6 +2351,7 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n       return NULL;\n     }\n \n+  poly_uint64 autodetected_vector_size = 0;\n   while (1)\n     {\n       /* Check the CFG characteristics of the loop (nesting, entry/exit).  */\n@@ -2376,18 +2378,28 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n \n       delete loop_vinfo;\n \n-      vector_sizes &= ~current_vector_size;\n+      if (next_size == 0)\n+\tautodetected_vector_size = current_vector_size;\n+\n+      if (next_size < vector_sizes.length ()\n+\t  && known_eq (vector_sizes[next_size], autodetected_vector_size))\n+\tnext_size += 1;\n+\n       if (fatal\n-\t  || vector_sizes == 0\n-\t  || current_vector_size == 0)\n+\t  || next_size == vector_sizes.length ()\n+\t  || known_eq (current_vector_size, 0U))\n \treturn NULL;\n \n       /* Try the next biggest vector size.  */\n-      current_vector_size = 1 << floor_log2 (vector_sizes);\n+      current_vector_size = vector_sizes[next_size++];\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"***** Re-trying analysis with \"\n-\t\t\t \"vector size %d\\n\", current_vector_size);\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"***** Re-trying analysis with \"\n+\t\t\t   \"vector size \");\n+\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t  dump_printf (MSG_NOTE, \"\\n\");\n+\t}\n     }\n }\n \n@@ -7748,9 +7760,12 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t  dump_printf (MSG_NOTE, \"\\n\");\n \t}\n       else\n-\tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"LOOP EPILOGUE VECTORIZED (VS=%d)\\n\",\n-\t\t\t current_vector_size);\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t   \"LOOP EPILOGUE VECTORIZED (VS=\");\n+\t  dump_dec (MSG_NOTE, current_vector_size);\n+\t  dump_printf (MSG_NOTE, \")\\n\");\n+\t}\n     }\n \n   /* Free SLP instances here because otherwise stmt reference counting\n@@ -7767,31 +7782,39 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   if (LOOP_VINFO_EPILOGUE_P (loop_vinfo))\n     epilogue = NULL;\n \n+  if (!PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK))\n+    epilogue = NULL;\n+\n   if (epilogue)\n     {\n-\tunsigned int vector_sizes\n-\t  = targetm.vectorize.autovectorize_vector_sizes ();\n-\tvector_sizes &= current_vector_size - 1;\n-\n-\tif (!PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK))\n-\t  epilogue = NULL;\n-\telse if (!vector_sizes)\n-\t  epilogue = NULL;\n-\telse if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-\t\t && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) >= 0\n-\t\t && known_eq (vf, lowest_vf))\n-\t  {\n-\t    int smallest_vec_size = 1 << ctz_hwi (vector_sizes);\n-\t    int ratio = current_vector_size / smallest_vec_size;\n-\t    unsigned HOST_WIDE_INT eiters = LOOP_VINFO_INT_NITERS (loop_vinfo)\n-\t      - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo);\n-\t    eiters = eiters % lowest_vf;\n+      auto_vector_sizes vector_sizes;\n+      targetm.vectorize.autovectorize_vector_sizes (&vector_sizes);\n+      unsigned int next_size = 0;\n \n-\t    epilogue->nb_iterations_upper_bound = eiters - 1;\n+      if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+\t  && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) >= 0\n+\t  && known_eq (vf, lowest_vf))\n+\t{\n+\t  unsigned int eiters\n+\t    = (LOOP_VINFO_INT_NITERS (loop_vinfo)\n+\t       - LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo));\n+\t  eiters = eiters % lowest_vf;\n+\t  epilogue->nb_iterations_upper_bound = eiters - 1;\n+\n+\t  unsigned int ratio;\n+\t  while (next_size < vector_sizes.length ()\n+\t\t && !(constant_multiple_p (current_vector_size,\n+\t\t\t\t\t   vector_sizes[next_size], &ratio)\n+\t\t      && eiters >= lowest_vf / ratio))\n+\t    next_size += 1;\n+\t}\n+      else\n+\twhile (next_size < vector_sizes.length ()\n+\t       && maybe_lt (current_vector_size, vector_sizes[next_size]))\n+\t  next_size += 1;\n \n-\t    if (eiters < lowest_vf / ratio)\n-\t      epilogue = NULL;\n-\t    }\n+      if (next_size == vector_sizes.length ())\n+\tepilogue = NULL;\n     }\n \n   if (epilogue)"}, {"sha": "7d8c3522050f1f438eb3f7df5f83231c3ae44091", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -3032,18 +3032,20 @@ vect_slp_bb (basic_block bb)\n {\n   bb_vec_info bb_vinfo;\n   gimple_stmt_iterator gsi;\n-  unsigned int vector_sizes;\n   bool any_vectorized = false;\n+  auto_vector_sizes vector_sizes;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"===vect_slp_analyze_bb===\\n\");\n \n   /* Autodetect first vector size we try.  */\n   current_vector_size = 0;\n-  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+  targetm.vectorize.autovectorize_vector_sizes (&vector_sizes);\n+  unsigned int next_size = 0;\n \n   gsi = gsi_start_bb (bb);\n \n+  poly_uint64 autodetected_vector_size = 0;\n   while (1)\n     {\n       if (gsi_end_p (gsi))\n@@ -3098,10 +3100,16 @@ vect_slp_bb (basic_block bb)\n \n       any_vectorized |= vectorized;\n \n-      vector_sizes &= ~current_vector_size;\n+      if (next_size == 0)\n+\tautodetected_vector_size = current_vector_size;\n+\n+      if (next_size < vector_sizes.length ()\n+\t  && known_eq (vector_sizes[next_size], autodetected_vector_size))\n+\tnext_size += 1;\n+\n       if (vectorized\n-\t  || vector_sizes == 0\n-\t  || current_vector_size == 0\n+\t  || next_size == vector_sizes.length ()\n+\t  || known_eq (current_vector_size, 0U)\n \t  /* If vect_slp_analyze_bb_1 signaled that analysis for all\n \t     vector sizes will fail do not bother iterating.  */\n \t  || fatal)\n@@ -3114,16 +3122,20 @@ vect_slp_bb (basic_block bb)\n \n \t  /* And reset vector sizes.  */\n \t  current_vector_size = 0;\n-\t  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+\t  next_size = 0;\n \t}\n       else\n \t{\n \t  /* Try the next biggest vector size.  */\n-\t  current_vector_size = 1 << floor_log2 (vector_sizes);\n+\t  current_vector_size = vector_sizes[next_size++];\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"***** Re-trying analysis with \"\n-\t\t\t     \"vector size %d\\n\", current_vector_size);\n+\t    {\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t       \"***** Re-trying analysis with \"\n+\t\t\t       \"vector size \");\n+\t      dump_dec (MSG_NOTE, current_vector_size);\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n+\t    }\n \n \t  /* Start over.  */\n \t  gsi = region_begin;"}, {"sha": "244dd351381ab16d8cd3e5379e420216b8697686", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -9130,12 +9130,12 @@ free_stmt_vec_info (gimple *stmt)\n    by the target.  */\n \n static tree\n-get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n+get_vectype_for_scalar_type_and_size (tree scalar_type, poly_uint64 size)\n {\n   tree orig_scalar_type = scalar_type;\n   scalar_mode inner_mode;\n   machine_mode simd_mode;\n-  int nunits;\n+  poly_uint64 nunits;\n   tree vectype;\n \n   if (!is_int_mode (TYPE_MODE (scalar_type), &inner_mode)\n@@ -9177,13 +9177,13 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n \n   /* If no size was supplied use the mode the target prefers.   Otherwise\n      lookup a vector mode of the specified size.  */\n-  if (size == 0)\n+  if (known_eq (size, 0U))\n     simd_mode = targetm.vectorize.preferred_simd_mode (inner_mode);\n-  else if (!mode_for_vector (inner_mode, size / nbytes).exists (&simd_mode))\n+  else if (!multiple_p (size, nbytes, &nunits)\n+\t   || !mode_for_vector (inner_mode, nunits).exists (&simd_mode))\n     return NULL_TREE;\n-  nunits = GET_MODE_SIZE (simd_mode) / nbytes;\n   /* NOTE: nunits == 1 is allowed to support single element vector types.  */\n-  if (nunits < 1)\n+  if (!multiple_p (GET_MODE_SIZE (simd_mode), nbytes, &nunits))\n     return NULL_TREE;\n \n   vectype = build_vector_type (scalar_type, nunits);\n@@ -9201,7 +9201,7 @@ get_vectype_for_scalar_type_and_size (tree scalar_type, unsigned size)\n   return vectype;\n }\n \n-unsigned int current_vector_size;\n+poly_uint64 current_vector_size;\n \n /* Function get_vectype_for_scalar_type.\n \n@@ -9215,7 +9215,7 @@ get_vectype_for_scalar_type (tree scalar_type)\n   vectype = get_vectype_for_scalar_type_and_size (scalar_type,\n \t\t\t\t\t\t  current_vector_size);\n   if (vectype\n-      && current_vector_size == 0)\n+      && known_eq (current_vector_size, 0U))\n     current_vector_size = GET_MODE_SIZE (TYPE_MODE (vectype));\n   return vectype;\n }"}, {"sha": "58f63189699972d4b30f17731850bd8676ee79ae", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -1199,7 +1199,7 @@ extern source_location find_loop_location (struct loop *);\n extern bool vect_can_advance_ivs_p (loop_vec_info);\n \n /* In tree-vect-stmts.c.  */\n-extern unsigned int current_vector_size;\n+extern poly_uint64 current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n extern tree get_mask_type_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);"}, {"sha": "f13e2d8227dc8ef75cb6a71bf4bfc8f6aa161945", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -9614,6 +9614,13 @@ make_vector_type (tree innertype, int nunits, machine_mode mode)\n   return t;\n }\n \n+/* Temporary.  */\n+static tree\n+make_vector_type (tree innertype, poly_uint64 nunits, machine_mode mode)\n+{\n+  return make_vector_type (innertype, (int) nunits.to_constant (), mode);\n+}\n+\n static tree\n make_or_reuse_type (unsigned size, int unsignedp)\n {\n@@ -10518,19 +10525,18 @@ build_vector_type (tree innertype, int nunits)\n /* Build truth vector with specified length and number of units.  */\n \n tree\n-build_truth_vector_type (unsigned nunits, unsigned vector_size)\n+build_truth_vector_type (poly_uint64 nunits, poly_uint64 vector_size)\n {\n   machine_mode mask_mode\n     = targetm.vectorize.get_mask_mode (nunits, vector_size).else_blk ();\n \n-  unsigned HOST_WIDE_INT vsize;\n+  poly_uint64 vsize;\n   if (mask_mode == BLKmode)\n     vsize = vector_size * BITS_PER_UNIT;\n   else\n     vsize = GET_MODE_BITSIZE (mask_mode);\n \n-  unsigned HOST_WIDE_INT esize = vsize / nunits;\n-  gcc_assert (esize * nunits == vsize);\n+  unsigned HOST_WIDE_INT esize = vector_element_size (vsize, nunits);\n \n   tree bool_type = build_nonstandard_boolean_type (esize);\n "}, {"sha": "f523a0850ca48a1c404b9cdc07504ecb05bccaec", "filename": "gcc/tree.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86e3672871beff63eebb195642566224c9f80891/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=86e3672871beff63eebb195642566224c9f80891", "patch": "@@ -4121,7 +4121,13 @@ extern tree build_reference_type_for_mode (tree, machine_mode, bool);\n extern tree build_reference_type (tree);\n extern tree build_vector_type_for_mode (tree, machine_mode);\n extern tree build_vector_type (tree innertype, int nunits);\n-extern tree build_truth_vector_type (unsigned, unsigned);\n+/* Temporary.  */\n+inline tree\n+build_vector_type (tree innertype, poly_uint64 nunits)\n+{\n+  return build_vector_type (innertype, (int) nunits.to_constant ());\n+}\n+extern tree build_truth_vector_type (poly_uint64, poly_uint64);\n extern tree build_same_sized_truth_vector_type (tree vectype);\n extern tree build_opaque_vector_type (tree innertype, int nunits);\n extern tree build_index_type (tree);"}]}