{"sha": "830a38eec6e9b38b58adb8a7aa785300ead47688", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMwYTM4ZWVjNmU5YjM4YjU4YWRiOGE3YWE3ODUzMDBlYWQ0NzY4OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-09T18:45:46Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-09T18:45:46Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r947", "tree": {"sha": "b9f26aeab92edd47bdf9c292b6fcd8996b968f7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9f26aeab92edd47bdf9c292b6fcd8996b968f7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/830a38eec6e9b38b58adb8a7aa785300ead47688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830a38eec6e9b38b58adb8a7aa785300ead47688", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830a38eec6e9b38b58adb8a7aa785300ead47688", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830a38eec6e9b38b58adb8a7aa785300ead47688/comments", "author": null, "committer": null, "parents": [{"sha": "81dd58a68e7a46261869073fa7c655fa3a3d0afc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81dd58a68e7a46261869073fa7c655fa3a3d0afc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81dd58a68e7a46261869073fa7c655fa3a3d0afc"}], "stats": {"total": 28, "additions": 23, "deletions": 5}, "files": [{"sha": "6f8154b72fccda6b1998446b476002537b522023", "filename": "gcc/cse.c", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830a38eec6e9b38b58adb8a7aa785300ead47688/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830a38eec6e9b38b58adb8a7aa785300ead47688/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=830a38eec6e9b38b58adb8a7aa785300ead47688", "patch": "@@ -742,7 +742,7 @@ make_regs_eqv (new, old)\n   if (! (firstr < FIRST_PSEUDO_REGISTER && FIXED_REGNO_P (firstr))\n       /* Certain fixed registers might be of the class NO_REGS.  This means\n \t that not only can they not be allocated by the compiler, but\n-\t they cannot be used in substitutions or cannonicallizations\n+\t they cannot be used in substitutions or canonicalizations\n \t either.  */\n       && (new >= FIRST_PSEUDO_REGISTER || REGNO_REG_CLASS (new) != NO_REGS)\n       && ((new < FIRST_PSEUDO_REGISTER && FIXED_REGNO_P (new))\n@@ -1129,7 +1129,7 @@ lookup_as_function (x, code)\n    goes in front, except that the first element in the list\n    remains first unless a cheaper element is added.  The order of\n    pseudo-registers does not matter, as canon_reg will be called to\n-   find the cheapest when a register is retreived from the table.\n+   find the cheapest when a register is retrieved from the table.\n \n    The in_memory field in the hash table element is set to 0.\n    The caller must set it nonzero if appropriate.\n@@ -3785,6 +3785,22 @@ simplify_binary_operation (code, mode, op0, op1)\n       /* Do nothing here.  */\n       return 0;\n \n+    case SMIN:\n+      val = arg0s <= arg1s ? arg0s : arg1s;\n+      break;\n+\n+    case UMIN:\n+      val = (unsigned int)arg0 <= (unsigned int)arg1 ? arg0 : arg1;\n+      break;\n+\n+    case SMAX:\n+      val = arg0s > arg1s ? arg0s : arg1s;\n+      break;\n+\n+    case UMAX:\n+      val = (unsigned int)arg0 > (unsigned int)arg1 ? arg0 : arg1;\n+      break;\n+\n     default:\n       abort ();\n     }\n@@ -5299,13 +5315,15 @@ cse_insn (insn, in_libcall_block)\n \t and we should not substitute some other register\n \t which is not supposed to be clobbered.\n \t Therefore, this loop cannot be merged into the one below\n-\t because a CALL may preceed a CLOBBER and refer to the\n+\t because a CALL may precede a CLOBBER and refer to the\n \t value clobbered.  We must not let a canonicalization do\n \t anything in that case.  */\n       for (i = 0; i < lim; i++)\n \t{\n \t  register rtx y = XVECEXP (x, 0, i);\n-\t  if (GET_CODE (y) == CLOBBER && GET_CODE (XEXP (y, 0)) == REG)\n+\t  if (GET_CODE (y) == CLOBBER\n+\t      && (GET_CODE (XEXP (y, 0)) == REG\n+\t\t  || GET_CODE (XEXP (y, 0)) == SUBREG))\n \t    invalidate (XEXP (y, 0));\n \t}\n \t    \n@@ -7383,7 +7401,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \t  /* Track when we are inside in LIBCALL block.  Inside such a block,\n \t     we do not want to record destinations.  The last insn of a\n \t     LIBCALL block is not considered to be part of the block, since\n-\t     its desitination is the result of the block and hence should be\n+\t     its destination is the result of the block and hence should be\n \t     recorded.  */\n \n \t  if (find_reg_note (insn, REG_LIBCALL, 0))"}]}