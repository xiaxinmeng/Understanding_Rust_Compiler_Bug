{"sha": "6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmMxNzRmYzBlNmU4ZTFiMzJjZDlhM2ZkMzk1MGZlMjhmNjA5ZGUxYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-01-02T04:48:04Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-01-02T04:48:04Z"}, "message": "c-decl.c (init_decl_processing): Provide proper fallback symbol for __builtin_memset.\n\n* c-decl.c (init_decl_processing): Provide proper fallback symbol\nfor __builtin_memset.\n* expr.c (expand_builtin) [MEMSET]: Arg 3 type code is INTEGER_TYPE\nnot INTEGER_CST.  Assert arg 3 is a constant.\n* alpha.c (mode_width_operand): Accept 64-bit modes.\n(mode_mask_operand): Likewise.\n(print_operand): Likewise for 'M' and 'U' codes.\n(alpha_expand_unaligned_load): New function.\n(alpha_expand_unaligned_store): Likewise.\n(alpha_expand_unaligned_load_words): Likewise.\n(alpha_expand_unaligned_store_words): Likewise.\n(alpha_expand_block_move): Likewise.\n(alpha_expand_block_clear): Likewise.\n* alpha.h (MOVE_RATIO): New define.\n* alpha.md (extxl, ext*h, ins*l, mskxl): Name them.\n(insql, insxh, mskxh, extv, extzv, insv, movstrqi, clrstrqi): New.\n* alpha.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE): Set to 3.\n(CONSTANT_ALIGNMENT, DATA_ALIGNMENT): Disable.\n\nFrom-SVN: r17278", "tree": {"sha": "845ba70a5c89399039225a89e43ea832388e7ef0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/845ba70a5c89399039225a89e43ea832388e7ef0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/comments", "author": null, "committer": null, "parents": [{"sha": "8fbf199e916474fe6783858654dc1eb9c0d06ccc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbf199e916474fe6783858654dc1eb9c0d06ccc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fbf199e916474fe6783858654dc1eb9c0d06ccc"}], "stats": {"total": 836, "additions": 812, "deletions": 24}, "files": [{"sha": "8e52ace9210da8b4696b9aab0272df9f5d821e9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "patch": "@@ -1,3 +1,26 @@\n+Fri Jan  2 04:34:14 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* c-decl.c (init_decl_processing): Provide proper fallback symbol\n+\tfor __builtin_memset.\n+\t* expr.c (expand_builtin) [MEMSET]: Arg 3 type code is INTEGER_TYPE\n+\tnot INTEGER_CST.  Assert arg 3 is a constant.\n+\n+\t* alpha.c (mode_width_operand): Accept 64-bit modes.\n+\t(mode_mask_operand): Likewise.\n+\t(print_operand): Likewise for 'M' and 'U' codes.\n+\t(alpha_expand_unaligned_load): New function.\n+\t(alpha_expand_unaligned_store): Likewise.\n+\t(alpha_expand_unaligned_load_words): Likewise.\n+\t(alpha_expand_unaligned_store_words): Likewise.\n+\t(alpha_expand_block_move): Likewise.\n+\t(alpha_expand_block_clear): Likewise.\n+\t* alpha.h (MOVE_RATIO): New define.\n+\t* alpha.md (extxl, ext*h, ins*l, mskxl): Name them.\n+\t(insql, insxh, mskxh, extv, extzv, insv, movstrqi, clrstrqi): New.\n+\n+\t* alpha.h (ASM_OUTPUT_LOOP_ALIGN, ASM_OUTPUT_ALIGN_CODE): Set to 3.\n+\t(CONSTANT_ALIGNMENT, DATA_ALIGNMENT): Disable.\n+\n Thu Jan  1 15:40:15 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* configure.in: Put parenthesis around TARGET_CPU_DEFAULT's value."}, {"sha": "d7f5737d3a92b48c3df3630e4bd40ddea59027cf", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "patch": "@@ -3353,7 +3353,7 @@ init_decl_processing ()\n   builtin_function (\"__builtin_memcmp\", int_ftype_cptr_cptr_sizet,\n \t\t    BUILT_IN_MEMCMP, \"memcmp\");\n   builtin_function (\"__builtin_memset\", memset_ftype,\n-\t\t    BUILT_IN_MEMSET, NULL_PTR);\n+\t\t    BUILT_IN_MEMSET, \"memset\");\n   builtin_function (\"__builtin_strcmp\", int_ftype_string_string,\n \t\t    BUILT_IN_STRCMP, \"strcmp\");\n   builtin_function (\"__builtin_strcpy\", string_ftype_ptr_ptr,\n@@ -3450,8 +3450,6 @@ init_decl_processing ()\n \t\t    BUILT_IN_FMOD, NULL_PTR);\n   builtin_function (\"__builtin_frem\", double_ftype_double_double,\n \t\t    BUILT_IN_FREM, NULL_PTR);\n-  builtin_function (\"__builtin_memset\", ptr_ftype_ptr_int_int,\n-\t\t    BUILT_IN_MEMSET, NULL_PTR);\n   builtin_function (\"__builtin_getexp\", double_ftype_double, BUILT_IN_GETEXP,\n \t\t    NULL_PTR);\n   builtin_function (\"__builtin_getman\", double_ftype_double, BUILT_IN_GETMAN,"}, {"sha": "168ca7c8b99a0ccc2bd64ddff622a763ab22a00c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 607, "deletions": 5, "changes": 612, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "patch": "@@ -450,7 +450,8 @@ mode_width_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) == 8 || INTVAL (op) == 16 || INTVAL (op) == 32));\n+\t  && (INTVAL (op) == 8 || INTVAL (op) == 16\n+\t      || INTVAL (op) == 32 || INTVAL (op) == 64));\n }\n \n /* Return 1 if OP is a constant that is the width of an integral machine mode\n@@ -463,14 +464,20 @@ mode_mask_operand (op, mode)\n {\n #if HOST_BITS_PER_WIDE_INT == 32\n   if (GET_CODE (op) == CONST_DOUBLE)\n-    return CONST_DOUBLE_HIGH (op) == 0 && CONST_DOUBLE_LOW (op) == -1;\n+    return (CONST_DOUBLE_LOW (op) == -1\n+\t    && (CONST_DOUBLE_HIGH (op) == -1\n+\t\t|| CONST_DOUBLE_HIGH (op) == 0));\n+#else\n+  if (GET_CODE (op) == CONST_DOUBLE)\n+    return (CONST_DOUBLE_LOW (op) == -1 && CONST_DOUBLE_HIGH (op) == 0);\n #endif\n \n   return (GET_CODE (op) == CONST_INT\n \t  && (INTVAL (op) == 0xff\n \t      || INTVAL (op) == 0xffff\n #if HOST_BITS_PER_WIDE_INT == 64\n \t      || INTVAL (op) == 0xffffffff\n+\t      || INTVAL (op) == 0xffffffffffffffff\n #endif\n \t      ));\n }\n@@ -1262,6 +1269,587 @@ alpha_emit_conditional_move (cmp, mode)\n   emit_move_insn (tem, gen_rtx (code, cmp_op_mode, op0, op1));\n   return gen_rtx (cmov_code, VOIDmode, tem, CONST0_RTX (cmp_op_mode));\n }\n+\f\n+/* Use ext[wlq][lh] as the Architecture Handbook describes for extracting\n+   unaligned data:\n+\n+           unsigned:                       signed:\n+   word:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)\n+           ldq_u  r2,X+1(r11)              ldq_u  r2,X+1(r11)\n+           lda    r3,X(r11)                lda    r3,X+2(r11)\n+           extwl  r1,r3,r1                 extql  r1,r3,r1\n+           extwh  r2,r3,r2                 extqh  r2,r3,r2\n+           or     r1.r2.r1                 or     r1,r2,r1\n+                                           sra    r1,48,r1\n+\n+   long:   ldq_u  r1,X(r11)                ldq_u  r1,X(r11)\n+           ldq_u  r2,X+3(r11)              ldq_u  r2,X+3(r11)\n+           lda    r3,X(r11)                lda    r3,X(r11)\n+           extll  r1,r3,r1                 extll  r1,r3,r1\n+           extlh  r2,r3,r2                 extlh  r2,r3,r2\n+           or     r1.r2.r1                 addl   r1,r2,r1\n+\n+   quad:   ldq_u  r1,X(r11)\n+           ldq_u  r2,X+7(r11)\n+           lda    r3,X(r11)\n+           extql  r1,r3,r1\n+           extqh  r2,r3,r2\n+           or     r1.r2.r1\n+*/\n+\n+void\n+alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n+     rtx tgt, mem;\n+     HOST_WIDE_INT size, ofs;\n+     int sign;\n+{\n+  rtx meml, memh, addr, extl, exth;\n+\n+  meml = gen_reg_rtx (DImode);\n+  memh = gen_reg_rtx (DImode);\n+  addr = gen_reg_rtx (DImode);\n+  extl = gen_reg_rtx (DImode);\n+  exth = gen_reg_rtx (DImode);\n+\n+  emit_move_insn (meml,\n+\t\t  change_address (mem, DImode,\n+\t\t\t\t  gen_rtx (AND, DImode, \n+\t\t\t\t\t   plus_constant (XEXP (mem, 0), ofs),\n+\t\t\t\t\t   GEN_INT (-8))));\n+\n+  emit_move_insn (memh,\n+\t\t  change_address (mem, DImode,\n+\t\t\t\t  gen_rtx (AND, DImode, \n+\t\t\t\t\t   plus_constant (XEXP (mem, 0),\n+\t\t\t\t\t\t\t  ofs + size - 1),\n+\t\t\t\t\t   GEN_INT (-8))));\n+\n+  if (sign && size == 2)\n+    {\n+      emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs+2));\n+\n+      emit_insn (gen_extxl (extl, meml, GEN_INT (64), addr));\n+      emit_insn (gen_extqh (exth, memh, addr));\n+\n+      expand_binop (DImode, ior_optab, extl, exth, addr, 1, OPTAB_WIDEN);\n+      expand_binop (DImode, ashr_optab, addr, GEN_INT (48), addr,\n+\t\t    1, OPTAB_WIDEN);\n+      emit_move_insn (tgt, addr);\n+      return;\n+    }\n+\n+  emit_move_insn (addr, plus_constant (XEXP (mem, 0), ofs));\n+  emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n+  switch (size)\n+    {\n+    case 2:\n+      emit_insn (gen_extwh (exth, memh, addr));\n+      break;\n+\n+    case 4:\n+      emit_insn (gen_extlh (exth, memh, addr));\n+      break;\n+\n+    case 8:\n+      emit_insn (gen_extqh (exth, memh, addr));\n+      break;\n+    }\n+\n+  expand_binop (DImode, ior_optab, extl, exth, tgt, sign, OPTAB_WIDEN);\n+}\n+\n+/* Similarly, use ins and msk instructions to perform unaligned stores.  */\n+\n+void\n+alpha_expand_unaligned_store (dst, src, size, ofs)\n+     rtx dst, src;\n+     HOST_WIDE_INT size, ofs;\n+{\n+  rtx dstl, dsth, addr, insl, insh, meml, memh;\n+  \n+  dstl = gen_reg_rtx (DImode);\n+  dsth = gen_reg_rtx (DImode);\n+  insl = gen_reg_rtx (DImode);\n+  insh = gen_reg_rtx (DImode);\n+\n+  meml = change_address (dst, DImode,\n+\t\t\t gen_rtx (AND, DImode, \n+\t\t\t\t  plus_constant (XEXP (dst, 0), ofs),\n+\t\t\t\t  GEN_INT (-8)));\n+  memh = change_address (dst, DImode,\n+\t\t\t gen_rtx (AND, DImode, \n+\t\t\t\t  plus_constant (XEXP (dst, 0), ofs+size-1),\n+\t\t\t\t  GEN_INT (-8)));\n+\n+  emit_move_insn (dsth, memh);\n+  emit_move_insn (dstl, meml);\n+  addr = copy_addr_to_reg (plus_constant (XEXP (dst, 0), ofs));\n+\n+  if (src != const0_rtx)\n+    {\n+      emit_insn (gen_insxh (insh, src, GEN_INT (size*8), addr));\n+\n+      switch (size)\n+\t{\n+\tcase 2:\n+\t  emit_insn (gen_inswl (insl, gen_lowpart (HImode, src), addr));\n+\t  break;\n+\tcase 4:\n+\t  emit_insn (gen_insll (insl, gen_lowpart (SImode, src), addr));\n+\t  break;\n+\tcase 8:\n+\t  emit_insn (gen_insql (insl, src, addr));\n+\t  break;\n+\t}\n+    }\n+\n+  emit_insn (gen_mskxh (dsth, dsth, GEN_INT (size*8), addr));\n+\n+  switch (size)\n+    {\n+    case 2:\n+      emit_insn (gen_mskxl (dstl, dstl, GEN_INT (0xffff), addr));\n+      break;\n+    case 4:\n+      emit_insn (gen_mskxl (dstl, dstl, GEN_INT (0xffffffff), addr));\n+      break;\n+    case 8:\n+      {\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\trtx msk = immed_double_const (0xffffffff, 0xffffffff, DImode);\n+#else\n+\trtx msk = immed_double_const (0xffffffffffffffff, 0, DImode);\n+#endif\n+\temit_insn (gen_mskxl (dstl, dstl, msk, addr));\n+      }\n+      break;\n+    }\n+\n+  if (src != const0_rtx)\n+    {\n+      expand_binop (DImode, ior_optab, insh, dsth, dsth, 0, OPTAB_WIDEN);\n+      expand_binop (DImode, ior_optab, insl, dstl, dstl, 0, OPTAB_WIDEN);\n+    }\n+  \n+  /* Must store high before low for degenerate case of aligned.  */\n+  emit_move_insn (memh, dsth);\n+  emit_move_insn (meml, dstl);\n+}\n+\n+/* Load an integral number of consecutive unaligned quadwords.  */\n+\n+#define MAX_MOVE_WORDS\t4\n+\n+static void\n+alpha_expand_unaligned_load_words (data_regs, src_addr, words)\n+     rtx data_regs[MAX_MOVE_WORDS+1];\n+     rtx src_addr;\n+     HOST_WIDE_INT words;\n+{\n+  rtx const im8 = GEN_INT (-8);\n+  rtx const i64 = GEN_INT (64);\n+  rtx ext_tmps[MAX_MOVE_WORDS];\n+  rtx src_reg, and_reg;\n+  HOST_WIDE_INT i;\n+\n+  /* Generate all the tmp registers we need.  */\n+  for (i = 0; i < words; ++i)\n+    ext_tmps[i] = gen_reg_rtx(DImode);\n+  \n+  /* Load up all of the source data.  */\n+  for (i = 0; i < words; ++i)\n+    {\n+      emit_move_insn (data_regs[i],\n+\t\t      change_address (src_addr, DImode,\n+\t\t\t\t      gen_rtx (AND, DImode,\n+\t\t\t\t\t       plus_constant (XEXP(src_addr,0),\n+\t\t\t\t\t\t\t      8*i),\n+\t\t\t\t\t       im8)));\n+    }\n+  emit_move_insn (data_regs[words],\n+\t\t  change_address (src_addr, DImode,\n+\t\t\t\t  gen_rtx (AND, DImode,\n+\t\t\t\t\t   plus_constant (XEXP(src_addr,0),\n+\t\t\t\t\t\t\t  8*words - 1),\n+\t\t\t\t\t   im8)));\n+\n+  /* Extract the half-word fragments.  Unfortunately DEC decided to make\n+     extxh with offset zero a noop instead of zeroing the register, so \n+     we must take care of that edge condition ourselves with cmov.  */\n+\n+  src_reg = copy_addr_to_reg (XEXP (src_addr, 0));\n+  and_reg = expand_binop (DImode, and_optab, src_reg, GEN_INT (7), NULL, \n+\t\t\t  1, OPTAB_WIDEN);\n+  for (i = 0; i < words; ++i)\n+    {\n+      emit_insn (gen_extxl (data_regs[i], data_regs[i], i64, src_reg));\n+\n+      emit_insn (gen_extqh (ext_tmps[i], data_regs[i+1], src_reg));\n+      emit_insn (gen_rtx (SET, VOIDmode, ext_tmps[i],\n+\t\t\t  gen_rtx (IF_THEN_ELSE, DImode,\n+\t\t\t\t   gen_rtx (EQ, DImode, and_reg, const0_rtx),\n+\t\t\t\t   const0_rtx, ext_tmps[i])));\n+    }\n+\n+  /* Merge the half-words into whole words.  */\n+  for (i = 0; i < words; ++i)\n+    {\n+      expand_binop (DImode, ior_optab, data_regs[i], ext_tmps[i],\n+\t\t    data_regs[i], 1, OPTAB_WIDEN);\n+    }\n+}\n+\n+/* Store an integral number of consecutive unaligned quadwords.  DATA_REGS\n+   may be NULL to store zeros.  */\n+\n+static void\n+alpha_expand_unaligned_store_words (data_regs, dst_addr, words)\n+     rtx *data_regs;\n+     rtx dst_addr;\n+     HOST_WIDE_INT words;\n+{\n+  rtx const im8 = GEN_INT (-8);\n+  rtx const i64 = GEN_INT (64);\n+#if HOST_BITS_PER_WIDE_INT == 32\n+  rtx const im1 = immed_double_const (0xffffffff, 0xffffffff, DImode);\n+#else\n+  rtx const im1 = immed_double_const (0xffffffffffffffff, 0, DImode);\n+#endif\n+  rtx ins_tmps[MAX_MOVE_WORDS];\n+  rtx st_tmp_1, st_tmp_2, dst_reg;\n+  rtx st_addr_1, st_addr_2;\n+  HOST_WIDE_INT i;\n+\n+  /* Generate all the tmp registers we need.  */\n+  if (data_regs != NULL)\n+    for (i = 0; i < words; ++i)\n+      ins_tmps[i] = gen_reg_rtx(DImode);\n+  st_tmp_1 = gen_reg_rtx(DImode);\n+  st_tmp_2 = gen_reg_rtx(DImode);\n+  \n+  st_addr_2 = change_address (dst_addr, DImode,\n+\t\t\t      gen_rtx (AND, DImode,\n+\t\t\t\t       plus_constant (XEXP(dst_addr,0),\n+\t\t\t\t\t\t      words*8 - 1),\n+\t\t\t\t       im8));\n+  st_addr_1 = change_address (dst_addr, DImode,\n+\t\t\t      gen_rtx (AND, DImode, \n+\t\t\t\t       XEXP (dst_addr, 0),\n+\t\t\t\t       im8));\n+\n+  /* Load up the destination end bits.  */\n+  emit_move_insn (st_tmp_2, st_addr_2);\n+  emit_move_insn (st_tmp_1, st_addr_1);\n+\n+  /* Shift the input data into place.  */\n+  dst_reg = copy_addr_to_reg (XEXP (dst_addr, 0));\n+\n+  if (data_regs != NULL)\n+    {\n+      for (i = words-1; i >= 0; --i)\n+\t{\n+\t  emit_insn (gen_insxh (ins_tmps[i], data_regs[i], i64, dst_reg));\n+\t  emit_insn (gen_insql (data_regs[i], data_regs[i], dst_reg));\n+\t}\n+\n+      for (i = words-1; i > 0; --i)\n+\t{\n+\t  expand_binop (DImode, ior_optab, data_regs[i], ins_tmps[i-1],\n+\t\t\tins_tmps[i-1], 1, OPTAB_WIDEN);\n+\t}\n+    }\n+\n+  /* Split and merge the ends with the destination data.  */\n+  emit_insn (gen_mskxh (st_tmp_2, st_tmp_2, i64, dst_reg));\n+  emit_insn (gen_mskxl (st_tmp_1, st_tmp_1, im1, dst_reg));\n+\n+  if (data_regs != NULL)\n+    {\n+      expand_binop (DImode, ior_optab, st_tmp_2, ins_tmps[words-1],\n+\t\t    st_tmp_2, 1, OPTAB_WIDEN);\n+      expand_binop (DImode, ior_optab, st_tmp_1, data_regs[0],\n+\t\t    st_tmp_1, 1, OPTAB_WIDEN);\n+    }\n+\n+  /* Store it all.  */\n+  emit_move_insn (st_addr_2, st_tmp_2);\n+  for (i = words-1; i > 0; --i)\n+    {\n+      emit_move_insn (change_address (dst_addr, DImode,\n+\t\t\t\t      gen_rtx (AND, DImode,\n+\t\t\t\t\t       plus_constant(XEXP (dst_addr,0),\n+\t\t\t\t\t\t\t     i*8),\n+\t\t\t\t\t       im8)),\n+\t\t      data_regs ? ins_tmps[i-1] : const0_rtx);\n+    }\n+  emit_move_insn (st_addr_1, st_tmp_1);\n+}\n+\n+\n+/* Expand string/block move operations.\n+\n+   operands[0] is the pointer to the destination.\n+   operands[1] is the pointer to the source.\n+   operands[2] is the number of bytes to move.\n+   operands[3] is the alignment.  */\n+\n+int\n+alpha_expand_block_move (operands)\n+     rtx operands[];\n+{\n+  rtx bytes_rtx\t= operands[2];\n+  rtx align_rtx = operands[3];\n+  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n+  HOST_WIDE_INT align = INTVAL (align_rtx);\n+  rtx orig_src\t= operands[1];\n+  rtx orig_dst\t= operands[0];\n+  rtx tmp = NULL_RTX;\n+  rtx data_regs[2*MAX_MOVE_WORDS];\n+  HOST_WIDE_INT i, words, ofs = 0;\n+  \n+  if (bytes <= 0)\n+    return 1;\n+  if (bytes > MAX_MOVE_WORDS*8)\n+    return 0;\n+\n+  /* Handle a block of contiguous words first.  */\n+\n+  if (align >= 8 && bytes >= 8)\n+    {\n+      words = bytes / 8;\n+\n+      /* Make some data registers. */\n+      for (i = 0; i < words; ++i)\n+\tdata_regs[i] = gen_reg_rtx(DImode);\n+\n+      /* Move in aligned hunks.  */\n+      for (i = 0; i < words; ++i)\n+\t{\n+\t  emit_move_insn (data_regs[i],\n+\t\t\t  change_address(orig_src, DImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t\ti*8)));\n+\t}\n+      for (i = 0; i < words; ++i)\n+\t{\n+\t  emit_move_insn (change_address(orig_dst, DImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\ti*8)),\n+\t\t\t  data_regs[i]);\n+\t}\n+\n+      bytes -= words * 8;\n+      ofs = words * 8;\n+    }\n+  if (align >= 4 && bytes >= 4)\n+    {\n+      words = bytes / 4;\n+\n+      /* Make some data registers. */\n+      for (i = 0; i < words; ++i)\n+\tdata_regs[i] = gen_reg_rtx(SImode);\n+\n+      /* Move in aligned hunks.  */\n+      for (i = 0; i < words; ++i)\n+\t{\n+\t  emit_move_insn (data_regs[i],\n+\t\t\t  change_address(orig_src, SImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t\ti*4)));\n+\t}\n+      for (i = 0; i < words; ++i)\n+\t{\n+\t  emit_move_insn (change_address(orig_dst, SImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\ti*4)),\n+\t\t\t  data_regs[i]);\n+\t}\n+\n+      bytes -= words * 4;\n+      ofs = words * 4;\n+    }\n+  if (bytes >= 16)\n+    {\n+      words = bytes / 8;\n+\n+      /* Make some data registers. */\n+      for (i = 0; i < words+1; ++i)\n+\tdata_regs[i] = gen_reg_rtx(DImode);\n+\n+      /* Move in unaligned hunks.  */\n+      alpha_expand_unaligned_load_words (data_regs, orig_src, words);\n+      alpha_expand_unaligned_store_words (data_regs, orig_dst, words);\n+\n+      bytes -= words * 8;\n+      ofs = words * 8;\n+    }\n+\n+  /* Next clean up any trailing pieces.  We know from the contiguous\n+     block move that there are no aligned SImode or DImode hunks left.  */\n+\n+  if (!TARGET_BWX && bytes >= 8)\n+    {\n+      tmp = gen_reg_rtx (DImode);\n+      alpha_expand_unaligned_load (tmp, orig_src, 8, ofs, 0);\n+      alpha_expand_unaligned_store (orig_dst, tmp, 8, ofs);\n+\n+      bytes -= 8;\n+      ofs += 8;\n+    }\n+  if (!TARGET_BWX && bytes >= 4)\n+    {\n+      tmp = gen_reg_rtx (DImode);\n+      alpha_expand_unaligned_load (tmp, orig_src, 4, ofs, 0);\n+      alpha_expand_unaligned_store (orig_dst, tmp, 4, ofs);\n+\n+      bytes -= 4;\n+      ofs += 4;\n+    }\n+  if (bytes >= 2)\n+    {\n+      if (align >= 2)\n+\t{\n+\t  do {\n+\t    emit_move_insn (change_address (orig_dst, HImode,\n+\t\t\t\t\t    plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t   ofs)),\n+\t\t\t    change_address (orig_src, HImode,\n+\t\t\t\t\t    plus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t\t   ofs)));\n+\t    bytes -= 2;\n+\t    ofs += 2;\n+\t  } while (bytes >= 2);\n+\t}\n+      else if (!TARGET_BWX)\n+\t{\n+\t  tmp = gen_reg_rtx (DImode);\n+\t  alpha_expand_unaligned_load (tmp, orig_src, 2, ofs, 0);\n+\t  alpha_expand_unaligned_store (orig_dst, tmp, 2, ofs);\n+\t  bytes -= 2;\n+\t  ofs += 2;\n+\t}\n+    }\n+  while (bytes > 0)\n+    {\n+      emit_move_insn (change_address (orig_dst, QImode,\n+\t\t\t\t      plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t     ofs)),\n+\t\t      change_address (orig_src, QImode,\n+\t\t\t\t      plus_constant (XEXP (orig_src, 0),\n+\t\t\t\t\t\t     ofs)));\n+      bytes -= 1;\n+      ofs += 1;\n+    }\n+\n+  return 1;\n+}\n+\n+int\n+alpha_expand_block_clear (operands)\n+     rtx operands[];\n+{\n+  rtx bytes_rtx\t= operands[1];\n+  rtx align_rtx = operands[2];\n+  HOST_WIDE_INT bytes = INTVAL (bytes_rtx);\n+  HOST_WIDE_INT align = INTVAL (align_rtx);\n+  rtx orig_dst\t= operands[0];\n+  HOST_WIDE_INT i, words, ofs = 0;\n+  \n+  if (bytes <= 0)\n+    return 1;\n+  if (bytes > MAX_MOVE_WORDS*8)\n+    return 0;\n+\n+  /* Handle a block of contiguous words first.  */\n+\n+  if (align >= 8 && bytes >= 8)\n+    {\n+      words = bytes / 8;\n+\n+      for (i = 0; i < words; ++i)\n+\t{\n+\t  emit_move_insn (change_address(orig_dst, DImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\ti*8)),\n+\t\t\t  const0_rtx);\n+\t}\n+\n+      bytes -= words * 8;\n+      ofs = words * 8;\n+    }\n+  else if (align >= 4 && bytes >= 4)\n+    {\n+      words = bytes / 4;\n+\n+      for (i = 0; i < words; ++i)\n+\t{\n+\t  emit_move_insn (change_address(orig_dst, SImode,\n+\t\t\t\t\t plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\ti*4)),\n+\t\t\t  const0_rtx);\n+\t}\n+\n+      bytes -= words * 4;\n+      ofs = words * 4;\n+    }\n+  else if (bytes >= 16)\n+    {\n+      words = bytes / 8;\n+\n+      alpha_expand_unaligned_store_words (NULL, orig_dst, words);\n+\n+      bytes -= words * 8;\n+      ofs = words * 8;\n+    }\n+\n+  /* Next clean up any trailing pieces.  We know from the contiguous\n+     block move that there are no aligned SImode or DImode hunks left.  */\n+\n+  if (!TARGET_BWX && bytes >= 8)\n+    {\n+      alpha_expand_unaligned_store (orig_dst, const0_rtx, 8, ofs);\n+      bytes -= 8;\n+      ofs += 8;\n+    }\n+  if (!TARGET_BWX && bytes >= 4)\n+    {\n+      alpha_expand_unaligned_store (orig_dst, const0_rtx, 4, ofs);\n+      bytes -= 4;\n+      ofs += 4;\n+    }\n+  if (bytes >= 2)\n+    {\n+      if (align >= 2)\n+\t{\n+\t  do {\n+\t    emit_move_insn (change_address (orig_dst, HImode,\n+\t\t\t\t\t    plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t\t   ofs)),\n+\t\t\t    const0_rtx);\n+\t    bytes -= 2;\n+\t    ofs += 2;\n+\t  } while (bytes >= 2);\n+\t}\n+      else if (!TARGET_BWX)\n+\t{\n+\t  alpha_expand_unaligned_store (orig_dst, const0_rtx, 2, ofs);\n+\t  bytes -= 2;\n+\t  ofs += 2;\n+\t}\n+    }\n+  while (bytes > 0)\n+    {\n+      emit_move_insn (change_address (orig_dst, QImode,\n+\t\t\t\t      plus_constant (XEXP (orig_dst, 0),\n+\t\t\t\t\t\t     ofs)),\n+\t\t      const0_rtx);\n+      bytes -= 1;\n+      ofs += 1;\n+    }\n+\n+  return 1;\n+}\n+\n \f\n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost.  */\n@@ -1667,13 +2255,17 @@ print_operand (file, x, code)\n       break;\n \n     case 'M':\n-      /* 'b', 'w', or 'l' as the value of the constant.  */\n+      /* 'b', 'w', 'l', or 'q' as the value of the constant.  */\n       if (GET_CODE (x) != CONST_INT\n-\t  || (INTVAL (x) != 8 && INTVAL (x) != 16 && INTVAL (x) != 32))\n+\t  || (INTVAL (x) != 8 && INTVAL (x) != 16\n+\t      && INTVAL (x) != 32 && INTVAL (x) != 64))\n \toutput_operand_lossage (\"invalid %%M value\");\n \n       fprintf (file, \"%s\",\n-\t       INTVAL (x) == 8 ? \"b\" : INTVAL (x) == 16 ? \"w\" : \"l\");\n+\t       (INTVAL (x) == 8 ? \"b\"\n+\t\t: INTVAL (x) == 16 ? \"w\"\n+\t\t: INTVAL (x) == 32 ? \"l\"\n+\t\t: \"q\"));\n       break;\n \n     case 'U':\n@@ -1687,9 +2279,19 @@ print_operand (file, x, code)\n \t       && CONST_DOUBLE_HIGH (x) == 0\n \t       && CONST_DOUBLE_LOW (x) == -1)\n \tfprintf (file, \"l\");\n+      else if (GET_CODE (x) == CONST_DOUBLE\n+\t       && CONST_DOUBLE_HIGH (x) == -1\n+\t       && CONST_DOUBLE_LOW (x) == -1)\n+\tfprintf (file, \"q\");\n #else\n       else if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0xffffffff)\n \tfprintf (file, \"l\");\n+      else if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0xffffffffffffffff)\n+\tfprintf (file, \"q\");\n+      else if (GET_CODE (x) == CONST_DOUBLE\n+\t       && CONST_DOUBLE_HIGH (x) == 0\n+\t       && CONST_DOUBLE_LOW (x) == -1)\n+\tfprintf (file, \"q\");\n #endif\n       else\n \toutput_operand_lossage (\"invalid %%U value\");"}, {"sha": "459af5d8527faa0fd3c546966b433c17f47e9930", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "patch": "@@ -384,18 +384,22 @@ extern void override_options ();\n    ??? Kludge this and the next macro for the moment by not doing anything if\n    we don't optimize and also if we are writing ECOFF symbols to work around\n    a bug in DEC's assembler. */\n+/* Aligning past 2**3 wastes insn cache lines, and doesn't buy much \n+   issue-wise on average anyway.  */\n \n #define ASM_OUTPUT_LOOP_ALIGN(FILE) \\\n   if (optimize > 0 && write_symbols != SDB_DEBUG)  \\\n-    ASM_OUTPUT_ALIGN (FILE, 5)\n+    ASM_OUTPUT_ALIGN (FILE, 3)\n \n /* This is how to align an instruction for optimal branching.\n    On Alpha we'll get better performance by aligning on a quadword\n    boundary.  */\n+/* Aligning past 2**3 wastes insn cache lines, and doesn't buy much \n+   issue-wise on average anyway.  */\n \n #define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n   if (optimize > 0 && write_symbols != SDB_DEBUG) \\\n-    ASM_OUTPUT_ALIGN ((FILE), 4)\n+    ASM_OUTPUT_ALIGN ((FILE), 3)\n \n /* No data type wants to be aligned rounder than this.  */\n #define BIGGEST_ALIGNMENT 64\n@@ -406,8 +410,12 @@ extern void override_options ();\n \n /* Align all constants and variables to at least a word boundary so\n    we can pick up pieces of them faster.  */\n+/* ??? Only if block-move stuff knows about different source/destination\n+   alignment.  */\n+#if 0\n #define CONSTANT_ALIGNMENT(EXP, ALIGN) MAX ((ALIGN), BITS_PER_WORD)\n #define DATA_ALIGNMENT(EXP, ALIGN) MAX ((ALIGN), BITS_PER_WORD)\n+#endif\n \n /* Set this non-zero if move instructions will actually fail to work\n    when given unaligned data.\n@@ -1509,6 +1517,12 @@ extern void alpha_init_expanders ();\n \n #define MOVE_MAX 8\n \n+/* Controls how many units are moved by expr.c before resorting to movstr.\n+   Without byte/word accesses, we want no more than one; with, several single\n+   byte accesses are better.   */\n+\n+#define MOVE_RATIO  (TARGET_BWX ? 7 : 2)\n+\n /* Largest number of bytes of an object that can be placed in a register.\n    On the Alpha we have plenty of registers, so use TImode.  */\n #define MAX_FIXED_MODE_SIZE\tGET_MODE_BITSIZE (TImode)"}, {"sha": "364de59b33d28d0989e9dadd18c6bd14e98ca6d0", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 157, "deletions": 10, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "patch": "@@ -1431,7 +1431,7 @@\n   \"ext%M2l %r1,%s3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"extxl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n \t\t\t (match_operand:DI 2 \"mode_width_operand\" \"n\")\n@@ -1441,7 +1441,7 @@\n   \"ext%M2l %r1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"extqh\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n \t (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1456,7 +1456,7 @@\n   \"extqh %r1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"extlh\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n \t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1472,7 +1472,7 @@\n   \"extlh %r1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"extwh\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n \t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1538,7 +1538,7 @@\n   \"insll %1,%s2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"insbl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\"))\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n@@ -1547,7 +1547,7 @@\n   \"insbl %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"inswl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\"))\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n@@ -1556,7 +1556,7 @@\n   \"inswl %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"\"\n+(define_insn \"insll\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n@@ -1565,10 +1565,30 @@\n   \"insll %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n+(define_insn \"insql\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t      (const_int 3))))]\n+  \"\"\n+  \"insql %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n ;; We do not include the insXh insns because they are complex to express\n ;; and it does not appear that we would ever want to generate them.\n+;;\n+;; Since we need them for block moves, though, cop out and use unspec.\n \n-(define_insn \"\"\n+(define_insn \"insxh\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:DI 2 \"mode_width_operand\" \"n\")\n+\t\t (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")] 2))]\n+  \"\"\n+  \"ins%M2h %1,%3,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"mskxl\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (ashift:DI\n \t\t\t (match_operand:DI 2 \"mode_mask_operand\" \"n\")\n@@ -1580,8 +1600,19 @@\n   \"msk%U2l %r1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-;; We do not include the mskXh insns because it does not appear we would ever\n-;; generate one.\n+;; We do not include the mskXh insns because it does not appear we would\n+;; ever generate one.\n+;;\n+;; Again, we do for block moves and we use unspec again.\n+\n+(define_insn \"mskxh\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (match_operand:DI 2 \"mode_width_operand\" \"n\")\n+\t\t (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")] 3))]\n+  \"\"\n+  \"msk%M2h %1,%3,%0\"\n+  [(set_attr \"type\" \"shift\")])\n \f\n ;; Floating-point operations.  All the double-precision insns can extend\n ;; from single, so indicate that.  The exception are the ones that simply\n@@ -4781,6 +4812,122 @@\n   DONE;\n }\")\n \f\n+;; Bit field extract patterns which use ext[wlq][lh]\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(sign_extract:DI (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n+  if (INTVAL (operands[3]) % 8 != 0\n+      || (INTVAL (operands[2]) != 16\n+\t  && INTVAL (operands[2]) != 32\n+\t  && INTVAL (operands[2]) != 64))\n+    FAIL;\n+\n+  /* From mips.md: extract_bit_field doesn't verify that our source\n+     matches the predicate, so we force it to be a MEM here.  */\n+  if (GET_CODE (operands[1]) != MEM)\n+    FAIL;\n+\n+  alpha_expand_unaligned_load (operands[0], operands[1],\n+\t\t\t       INTVAL (operands[2]) / 8,\n+\t\t\t       INTVAL (operands[3]) / 8, 1);\n+  DONE;\n+}\")\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(zero_extract:DI (match_operand:QI 1 \"memory_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n+  if (INTVAL (operands[3]) % 8 != 0\n+      || (INTVAL (operands[2]) != 16\n+\t  && INTVAL (operands[2]) != 32\n+\t  && INTVAL (operands[2]) != 64))\n+    FAIL;\n+\n+  /* From mips.md: extract_bit_field doesn't verify that our source\n+     matches the predicate, so we force it to be a MEM here.  */\n+  if (GET_CODE (operands[1]) != MEM)\n+    FAIL;\n+\n+  alpha_expand_unaligned_load (operands[0], operands[1],\n+\t\t\t       INTVAL (operands[2]) / 8,\n+\t\t\t       INTVAL (operands[3]) / 8, 0);\n+  DONE;\n+}\")\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:DI (match_operand:QI 0 \"memory_operand\" \"\")\n+\t\t\t (match_operand:DI 1 \"immediate_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"immediate_operand\" \"\"))\n+\t(match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n+  if (INTVAL (operands[2]) % 8 != 0\n+      || (INTVAL (operands[1]) != 16\n+\t  && INTVAL (operands[1]) != 32\n+\t  && INTVAL (operands[1]) != 64))\n+    FAIL;\n+\n+  /* From mips.md: store_bit_field doesn't verify that our source\n+     matches the predicate, so we force it to be a MEM here.  */\n+  if (GET_CODE (operands[0]) != MEM)\n+    FAIL;\n+\n+  alpha_expand_unaligned_store (operands[0], operands[3],\n+\t\t\t        INTVAL (operands[1]) / 8,\n+\t\t\t        INTVAL (operands[2]) / 8);\n+  DONE;\n+}\")\n+\n+\n+\n+;; Block move/clear, see alpha.c for more details.\n+;; Argument 0 is the destination\n+;; Argument 1 is the source\n+;; Argument 2 is the length\n+;; Argument 3 is the alignment\n+\n+(define_expand \"movstrqi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n+\t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:DI 3 \"immediate_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (alpha_expand_block_move (operands))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_expand \"clrstrqi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+\t\t   (const_int 0))\n+\t      (use (match_operand:DI 1 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:DI 2 \"immediate_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (alpha_expand_block_clear (operands))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\f\n ;; Subroutine of stack space allocation.  Perform a stack probe.\n (define_expand \"probe_stack\"\n   [(set (match_dup 1) (match_operand:DI 0 \"const_int_operand\" \"\"))]"}, {"sha": "e54f3e47a45004df9f9b3f2eaf10901c27a485d8", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6c174fc0e6e8e1b32cd9a3fd3950fe28f609de1c", "patch": "@@ -9036,7 +9036,7 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))\n \t      != INTEGER_TYPE)\n \t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n-\t  || (INTEGER_CST\n+\t  || (INTEGER_TYPE\n \t      != (TREE_CODE (TREE_TYPE\n \t\t\t     (TREE_VALUE\n \t\t\t      (TREE_CHAIN (TREE_CHAIN (arglist))))))))\n@@ -9061,11 +9061,16 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t  if (expand_expr (val, NULL_RTX, VOIDmode, 0) != const0_rtx)\n \t    break;\n \n+\t  /* If LEN does not expand to a constant, don't do this\n+\t     operation in-line.  */\n+\t  len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n+\t  if (GET_CODE (len_rtx) != CONST_INT)\n+\t    break;\n+\n \t  dest_rtx = expand_expr (dest, NULL_RTX, ptr_mode, EXPAND_SUM);\n \t  dest_mem = gen_rtx (MEM, BLKmode,\n \t\t\t      memory_address (BLKmode, dest_rtx));\n-\t  len_rtx = expand_expr (len, NULL_RTX, VOIDmode, 0);\n-\n+\t   \n \t  /* Just check DST is writable and mark it as readable.  */\n \t  if (flag_check_memory_usage)\n \t    emit_library_call (chkr_check_addr_libfunc, 1, VOIDmode, 3,\n@@ -9074,7 +9079,6 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \t\t\t       GEN_INT (MEMORY_USE_WO),\n \t\t\t       TYPE_MODE (integer_type_node));\n \n-\n \t  /* There could be a void* cast on top of the object.  */\n \t  while (TREE_CODE (dest) == NOP_EXPR)\n \t    dest = TREE_OPERAND (dest, 0);"}]}