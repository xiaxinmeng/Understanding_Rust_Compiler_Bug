{"sha": "879ac954ef76a1af1888abfaa44257f6f728372b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc5YWM5NTRlZjc2YTFhZjE4ODhhYmZhYTQ0MjU3ZjZmNzI4MzcyYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T13:04:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-23T13:04:01Z"}, "message": "[multiple changes]\n\n2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* contracts.ads, contracts.adb: New unit.\n\t* exp_ch6.adb Add with and use clauses for Contracts.\n\t(Expand_Subprogram_Contract): Moved to Contracts.\n\t* exp_ch6.ads (Expand_Subprogram_Contract): Moved to Contracts.\n\t* sem_ch3.adb Add with and use clauses for Contracts.\n\t(Analyze_Object_Contract): Moved to Contracts.\n\t(Analyze_Declarations): Remove local variable Pack_Decl. Do not\n\tcapture global references in contracts. Check the hidden states\n\tof a package body.\n\t* sem_ch6.adb Add with and use clauses in Contracts.\n\t(Analyze_Generic_Subprogram_Body): Do not capture global\n\treferences in contracts.\n\t(Analyze_Subprogram_Body_Contract):\n\tMoved to Contracts.\n\t(Analyze_Subprogram_Body_Helper): Freeze the\n\tcontract of the nearest enclosing package body. Always analyze\n\tthe subprogram body contract. Do not expand the subprogram\n\tbody contract.\n\t(Analyze_Subprogram_Contract): Moved to Contracts.\n\t* sem_ch6.ads (Analyze_Subprogram_Body_Contract): Moved to Contracts.\n\t(Analyze_Subprogram_Contract): Moved to Contracts.\n\t* sem_ch7.adb Add with and use clauses for Contracts.\n\t(Analyze_Package_Body_Contract): Moved to Contracts.\n\t(Analyze_Package_Body_Helper): Freeze the contract of the\n\tnearest enclosing package body.\n\t(Analyze_Package_Contract): Moved to Contracts.\n\t* sem_ch7.ads (Analyze_Package_Body_Contract): Moved to Contracts.\n\t(Analyze_Package_Contract): Moved to Contracts.\n\t* sem_ch10.adb Add with and use clauses for Contracts.\n\t(Analyze_Compilation_Unit): Do not capture global references\n\tin contracts.\n\t(Analyze_Subprogram_Body_Stub_Contract): Moved to Contracts.\n\t* sem_ch10.ads (Analyze_Subprogram_Body_Stub_Contract): Moved\n\tto Contracts.\n\t* sem_ch12.adb Add with and use clauses for Contracts.\n\t(Analyze_Subprogram_Instantiation): Update the call to\n\tInstantiate_Subprogram_Contract.\n\t(Instantiate_Package_Body):\n\tDo not copy the entity of the spec when creating an entity\n\tfor the body. Construct a brand new defining identifier for\n\tthe body and inherit the Comes_From_Source flag from the spec.\n\t(Instantiate_Subprogram_Body): Remove Anon_Id to Act_Decl_Id\n\tand update all occurrences. Construct a brand new defining\n\tidentifier for the body and inherit the Comes_From_Source\n\tflag from the spec.\n\t(Instantiate_Subprogram_Contract): Moved\n\tto Contracts.\n\t(Save_Global_References_In_Aspects): Moved to\n\tthe spec of Sem_Ch12.\n\t(Save_Global_References_In_Contract):\n\tMoved to Contracts.\n\t* sem_ch12.ads (Save_Global_References_In_Aspects): Moved from\n\tthe body of Sem_Ch12.\n\t(Save_Global_References_In_Contract):\n\tMoved to Contracts.\n\t* sem_prag.adb Add with and use clauses for Contracts.\n\t(Add_Item): Removed. All references to this routine have been\n\treplaced with calls to Append_New_Elmt.\n\t(Analyze_Constituent):\n\tAdd special diagnostics for errors caused by freezing of\n\tcontracts.\n\t(Analyze_Refined_State_In_Decl_Part): Add formal\n\tparameter Freeze_Id. Add new global variable Freeze_Posted.\n\t(Collect_Body_States): Removed.\n\t(Report_Unused_States): Removed.\n\t* sem_prag.ads (Analyze_Defined_State_In_Decl_Part): Add formal\n\tparameter Freeze_Id and update comment on usage.\n\t* sem_util.adb Remove with and use clauses for\n\tSem_Ch12.\n\t(Add_Contract_Item): Moved to Contracts.\n\t(Check_Unused_Body_States): New routine.\n\t(Collect_Body_States):\n\tNew routine.\n\t(Create_Generic_Contract): Moved to Contracts.\n\t(Inherit_Subprogram_Contract): Moved to Contracts.\n\t(Report_Unused_Body_States): New routine.\n\t* sem_util.ads (Add_Contract_Item): Moved to Contracts.\n\t(Check_Unused_Body_States): New routine.\n\t(Collect_Body_States): New routine.\n\t(Create_Generic_Contract): Moved to Contracts.\n\t(Inherit_Subprogram_Contract): Moved to Contracts.\n\t(Report_Unused_Body_States): New routine.\n\t* sinfo.adb (Is_Expanded_Contract): New routine.\n\t(Set_Is_Expanded_Contract): New routine.\n\t* sinfo.ads New attribute Is_Expanded_Contract along with\n\tplacement in nodes.\n\t(Is_Expanded_Contract): New routine along\n\twith pragma Inline.\n\t(Set_Is_Expanded_Contract): New routine\n\talong with pragma Inline.\n\t* gcc-interface/Make-lang.in: Add entry for contracts.o\n\n2015-10-23  Bob Duff  <duff@adacore.com>\n\n\t* bindgen.adb, init.c, opt.ads, switch-b.adb: Implement new -Ea and\n\t-Es switches.\n\t* switch-b.ads: Minor comment fix.\n\t* bindusg.adb: Document new -Ea and -Es switches.\n\t* s-exctra.ads: Use -Es instead of -E.\n\nFrom-SVN: r229253", "tree": {"sha": "dff0f664288fdfea6014177ce744d3e81f47c203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dff0f664288fdfea6014177ce744d3e81f47c203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/879ac954ef76a1af1888abfaa44257f6f728372b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/879ac954ef76a1af1888abfaa44257f6f728372b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/879ac954ef76a1af1888abfaa44257f6f728372b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/879ac954ef76a1af1888abfaa44257f6f728372b/comments", "author": null, "committer": null, "parents": [{"sha": "9733088f6ab15a857474e6b66f4757e9710f1a37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9733088f6ab15a857474e6b66f4757e9710f1a37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9733088f6ab15a857474e6b66f4757e9710f1a37"}], "stats": {"total": 6784, "additions": 3681, "deletions": 3103}, "files": [{"sha": "88a2197025d3241f1435f4cd306d7654c50e41e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -1,3 +1,105 @@\n+2015-10-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.ads, contracts.adb: New unit.\n+\t* exp_ch6.adb Add with and use clauses for Contracts.\n+\t(Expand_Subprogram_Contract): Moved to Contracts.\n+\t* exp_ch6.ads (Expand_Subprogram_Contract): Moved to Contracts.\n+\t* sem_ch3.adb Add with and use clauses for Contracts.\n+\t(Analyze_Object_Contract): Moved to Contracts.\n+\t(Analyze_Declarations): Remove local variable Pack_Decl. Do not\n+\tcapture global references in contracts. Check the hidden states\n+\tof a package body.\n+\t* sem_ch6.adb Add with and use clauses in Contracts.\n+\t(Analyze_Generic_Subprogram_Body): Do not capture global\n+\treferences in contracts.\n+\t(Analyze_Subprogram_Body_Contract):\n+\tMoved to Contracts.\n+\t(Analyze_Subprogram_Body_Helper): Freeze the\n+\tcontract of the nearest enclosing package body. Always analyze\n+\tthe subprogram body contract. Do not expand the subprogram\n+\tbody contract.\n+\t(Analyze_Subprogram_Contract): Moved to Contracts.\n+\t* sem_ch6.ads (Analyze_Subprogram_Body_Contract): Moved to Contracts.\n+\t(Analyze_Subprogram_Contract): Moved to Contracts.\n+\t* sem_ch7.adb Add with and use clauses for Contracts.\n+\t(Analyze_Package_Body_Contract): Moved to Contracts.\n+\t(Analyze_Package_Body_Helper): Freeze the contract of the\n+\tnearest enclosing package body.\n+\t(Analyze_Package_Contract): Moved to Contracts.\n+\t* sem_ch7.ads (Analyze_Package_Body_Contract): Moved to Contracts.\n+\t(Analyze_Package_Contract): Moved to Contracts.\n+\t* sem_ch10.adb Add with and use clauses for Contracts.\n+\t(Analyze_Compilation_Unit): Do not capture global references\n+\tin contracts.\n+\t(Analyze_Subprogram_Body_Stub_Contract): Moved to Contracts.\n+\t* sem_ch10.ads (Analyze_Subprogram_Body_Stub_Contract): Moved\n+\tto Contracts.\n+\t* sem_ch12.adb Add with and use clauses for Contracts.\n+\t(Analyze_Subprogram_Instantiation): Update the call to\n+\tInstantiate_Subprogram_Contract.\n+\t(Instantiate_Package_Body):\n+\tDo not copy the entity of the spec when creating an entity\n+\tfor the body. Construct a brand new defining identifier for\n+\tthe body and inherit the Comes_From_Source flag from the spec.\n+\t(Instantiate_Subprogram_Body): Remove Anon_Id to Act_Decl_Id\n+\tand update all occurrences. Construct a brand new defining\n+\tidentifier for the body and inherit the Comes_From_Source\n+\tflag from the spec.\n+\t(Instantiate_Subprogram_Contract): Moved\n+\tto Contracts.\n+\t(Save_Global_References_In_Aspects): Moved to\n+\tthe spec of Sem_Ch12.\n+\t(Save_Global_References_In_Contract):\n+\tMoved to Contracts.\n+\t* sem_ch12.ads (Save_Global_References_In_Aspects): Moved from\n+\tthe body of Sem_Ch12.\n+\t(Save_Global_References_In_Contract):\n+\tMoved to Contracts.\n+\t* sem_prag.adb Add with and use clauses for Contracts.\n+\t(Add_Item): Removed. All references to this routine have been\n+\treplaced with calls to Append_New_Elmt.\n+\t(Analyze_Constituent):\n+\tAdd special diagnostics for errors caused by freezing of\n+\tcontracts.\n+\t(Analyze_Refined_State_In_Decl_Part): Add formal\n+\tparameter Freeze_Id. Add new global variable Freeze_Posted.\n+\t(Collect_Body_States): Removed.\n+\t(Report_Unused_States): Removed.\n+\t* sem_prag.ads (Analyze_Defined_State_In_Decl_Part): Add formal\n+\tparameter Freeze_Id and update comment on usage.\n+\t* sem_util.adb Remove with and use clauses for\n+\tSem_Ch12.\n+\t(Add_Contract_Item): Moved to Contracts.\n+\t(Check_Unused_Body_States): New routine.\n+\t(Collect_Body_States):\n+\tNew routine.\n+\t(Create_Generic_Contract): Moved to Contracts.\n+\t(Inherit_Subprogram_Contract): Moved to Contracts.\n+\t(Report_Unused_Body_States): New routine.\n+\t* sem_util.ads (Add_Contract_Item): Moved to Contracts.\n+\t(Check_Unused_Body_States): New routine.\n+\t(Collect_Body_States): New routine.\n+\t(Create_Generic_Contract): Moved to Contracts.\n+\t(Inherit_Subprogram_Contract): Moved to Contracts.\n+\t(Report_Unused_Body_States): New routine.\n+\t* sinfo.adb (Is_Expanded_Contract): New routine.\n+\t(Set_Is_Expanded_Contract): New routine.\n+\t* sinfo.ads New attribute Is_Expanded_Contract along with\n+\tplacement in nodes.\n+\t(Is_Expanded_Contract): New routine along\n+\twith pragma Inline.\n+\t(Set_Is_Expanded_Contract): New routine\n+\talong with pragma Inline.\n+\t* gcc-interface/Make-lang.in: Add entry for contracts.o\n+\n+2015-10-23  Bob Duff  <duff@adacore.com>\n+\n+\t* bindgen.adb, init.c, opt.ads, switch-b.adb: Implement new -Ea and\n+\t-Es switches.\n+\t* switch-b.ads: Minor comment fix.\n+\t* bindusg.adb: Document new -Ea and -Es switches.\n+\t* s-exctra.ads: Use -Es instead of -E.\n+\n 2015-10-23  Tristan Gingold  <gingold@adacore.com>\n \n \t* gcc-interface/utils2.c (build_call_alloc_dealloc): Check no implicit"}, {"sha": "e284a0e130b65b16c794bceebeebf992ac4ef016", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -166,6 +166,7 @@ package body Bindgen is\n    --     Num_Interrupt_States          : Integer;\n    --     Unreserve_All_Interrupts      : Integer;\n    --     Exception_Tracebacks          : Integer;\n+   --     Exception_Tracebacks_Symbolic : Integer;\n    --     Detect_Blocking               : Integer;\n    --     Default_Stack_Size            : Integer;\n    --     Leap_Seconds_Support          : Integer;\n@@ -235,10 +236,13 @@ package body Bindgen is\n    --  Unreserve_All_Interrupts is set to one if at least one unit in the\n    --  partition had a pragma Unreserve_All_Interrupts, and zero otherwise.\n \n-   --  Exception_Tracebacks is set to one if the -E parameter was present\n-   --  in the bind and to zero otherwise. Note that on some targets exception\n-   --  tracebacks are provided by default, so a value of zero for this\n-   --  parameter does not necessarily mean no trace backs are available.\n+   --  Exception_Tracebacks is set to one if the -Ea or -E parameter was\n+   --  present in the bind and to zero otherwise. Note that on some targets\n+   --  exception tracebacks are provided by default, so a value of zero for\n+   --  this parameter does not necessarily mean no trace backs are available.\n+\n+   --  Exception_Tracebacks_Symbolic is set to one if the -Es parameter was\n+   --  present in the bind and to zero otherwise.\n \n    --  Detect_Blocking indicates whether pragma Detect_Blocking is active or\n    --  not. A value of zero indicates that the pragma is not present, while a\n@@ -607,10 +611,16 @@ package body Bindgen is\n          WBI (\"      pragma Import (C, Unreserve_All_Interrupts, \" &\n               \"\"\"__gl_unreserve_all_interrupts\"\");\");\n \n-         if Exception_Tracebacks then\n+         if Exception_Tracebacks or Exception_Tracebacks_Symbolic then\n             WBI (\"      Exception_Tracebacks : Integer;\");\n             WBI (\"      pragma Import (C, Exception_Tracebacks, \" &\n                  \"\"\"__gl_exception_tracebacks\"\");\");\n+\n+            if Exception_Tracebacks_Symbolic then\n+               WBI (\"      Exception_Tracebacks_Symbolic : Integer;\");\n+               WBI (\"      pragma Import (C, Exception_Tracebacks_Symbolic, \" &\n+                    \"\"\"__gl_exception_tracebacks_symbolic\"\");\");\n+            end if;\n          end if;\n \n          WBI (\"      Detect_Blocking : Integer;\");\n@@ -795,8 +805,12 @@ package body Bindgen is\n          Set_Char (';');\n          Write_Statement_Buffer;\n \n-         if Exception_Tracebacks then\n+         if Exception_Tracebacks or Exception_Tracebacks_Symbolic then\n             WBI (\"      Exception_Tracebacks := 1;\");\n+\n+            if Exception_Tracebacks_Symbolic then\n+               WBI (\"      Exception_Tracebacks_Symbolic := 1;\");\n+            end if;\n          end if;\n \n          Set_String (\"      Detect_Blocking := \");"}, {"sha": "f1a61777bfbfd1ed2d9b21e454cbc3f6030961e3", "filename": "gcc/ada/bindusg.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fbindusg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fbindusg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindusg.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -108,7 +108,10 @@ package body Bindusg is\n \n       --  Line for -E switch\n \n-      Write_Line (\"  -E        Store tracebacks in exception occurrences\");\n+      Write_Line (\"  -Ea       Store tracebacks in exception occurrences\");\n+      Write_Line (\"  -Es       Store tracebacks in exception occurrences,\");\n+      Write_Line (\"            and enable symbolic tracebacks\");\n+      Write_Line (\"  -E        Same as -Ea\");\n \n       --  The -f switch is voluntarily omitted, because it is obsolete\n "}, {"sha": "ffdd510acac439e600cd79e0f268bd653d78df61", "filename": "gcc/ada/contracts.adb", "status": "added", "additions": 2453, "deletions": 0, "changes": 2453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -0,0 +1,2453 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            C O N T R A C T S                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Aspects;  use Aspects;\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Errout;   use Errout;\n+with Exp_Prag; use Exp_Prag;\n+with Exp_Tss;  use Exp_Tss;\n+with Exp_Util; use Exp_Util;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Ch6;  use Sem_Ch6;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch12; use Sem_Ch12;\n+with Sem_Disp; use Sem_Disp;\n+with Sem_Prag; use Sem_Prag;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stringt;  use Stringt;\n+with Tbuild;   use Tbuild;\n+\n+package body Contracts is\n+\n+   procedure Expand_Subprogram_Contract (Body_Id : Entity_Id);\n+   --  Expand the contracts of a subprogram body and its correspoding spec (if\n+   --  any). This routine processes all [refined] pre- and postconditions as\n+   --  well as Contract_Cases, invariants and predicates. Body_Id denotes the\n+   --  entity of the subprogram body.\n+\n+   -----------------------\n+   -- Add_Contract_Item --\n+   -----------------------\n+\n+   procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id) is\n+      Items : Node_Id := Contract (Id);\n+\n+      procedure Add_Classification;\n+      --  Prepend Prag to the list of classifications\n+\n+      procedure Add_Contract_Test_Case;\n+      --  Prepend Prag to the list of contract and test cases\n+\n+      procedure Add_Pre_Post_Condition;\n+      --  Prepend Prag to the list of pre- and postconditions\n+\n+      ------------------------\n+      -- Add_Classification --\n+      ------------------------\n+\n+      procedure Add_Classification is\n+      begin\n+         Set_Next_Pragma (Prag, Classifications (Items));\n+         Set_Classifications (Items, Prag);\n+      end Add_Classification;\n+\n+      ----------------------------\n+      -- Add_Contract_Test_Case --\n+      ----------------------------\n+\n+      procedure Add_Contract_Test_Case is\n+      begin\n+         Set_Next_Pragma (Prag, Contract_Test_Cases (Items));\n+         Set_Contract_Test_Cases (Items, Prag);\n+      end Add_Contract_Test_Case;\n+\n+      ----------------------------\n+      -- Add_Pre_Post_Condition --\n+      ----------------------------\n+\n+      procedure Add_Pre_Post_Condition is\n+      begin\n+         Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n+         Set_Pre_Post_Conditions (Items, Prag);\n+      end Add_Pre_Post_Condition;\n+\n+      --  Local variables\n+\n+      Prag_Nam : Name_Id;\n+\n+   --  Start of processing for Add_Contract_Item\n+\n+   begin\n+      --  A contract must contain only pragmas\n+\n+      pragma Assert (Nkind (Prag) = N_Pragma);\n+      Prag_Nam := Pragma_Name (Prag);\n+\n+      --  Create a new contract when adding the first item\n+\n+      if No (Items) then\n+         Items := Make_Contract (Sloc (Id));\n+         Set_Contract (Id, Items);\n+      end if;\n+\n+      --  Contract items related to constants. Applicable pragmas are:\n+      --    Part_Of\n+\n+      if Ekind (Id) = E_Constant then\n+         if Prag_Nam = Name_Part_Of then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to [generic] packages or instantiations. The\n+      --  applicable pragmas are:\n+      --    Abstract_States\n+      --    Initial_Condition\n+      --    Initializes\n+      --    Part_Of (instantiation only)\n+\n+      elsif Ekind_In (Id, E_Generic_Package, E_Package) then\n+         if Nam_In (Prag_Nam, Name_Abstract_State,\n+                              Name_Initial_Condition,\n+                              Name_Initializes)\n+         then\n+            Add_Classification;\n+\n+         --  Indicator Part_Of must be associated with a package instantiation\n+\n+         elsif Prag_Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to package bodies. The applicable pragmas are:\n+      --    Refined_States\n+\n+      elsif Ekind (Id) = E_Package_Body then\n+         if Prag_Nam = Name_Refined_State then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to subprogram or entry declarations. The\n+      --  applicable pragmas are:\n+      --    Contract_Cases\n+      --    Depends\n+      --    Extensions_Visible\n+      --    Global\n+      --    Postcondition\n+      --    Precondition\n+      --    Test_Case\n+      --    Volatile_Function\n+\n+      elsif Ekind_In (Id, E_Entry, E_Entry_Family)\n+        or else Is_Generic_Subprogram (Id)\n+        or else Is_Subprogram (Id)\n+      then\n+         if Nam_In (Prag_Nam, Name_Postcondition, Name_Precondition) then\n+            Add_Pre_Post_Condition;\n+\n+         elsif Nam_In (Prag_Nam, Name_Contract_Cases, Name_Test_Case) then\n+            Add_Contract_Test_Case;\n+\n+         elsif Nam_In (Prag_Nam, Name_Depends,\n+                                 Name_Extensions_Visible,\n+                                 Name_Global)\n+         then\n+            Add_Classification;\n+\n+         elsif Prag_Nam = Name_Volatile_Function\n+           and then Ekind_In (Id, E_Function, E_Generic_Function)\n+         then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to subprogram bodies. Applicable pragmas are:\n+      --    Postcondition\n+      --    Precondition\n+      --    Refined_Depends\n+      --    Refined_Global\n+      --    Refined_Post\n+\n+      elsif Ekind (Id) = E_Subprogram_Body then\n+         if Nam_In (Prag_Nam, Name_Refined_Depends, Name_Refined_Global) then\n+            Add_Classification;\n+\n+         elsif Nam_In (Prag_Nam, Name_Postcondition,\n+                                 Name_Precondition,\n+                                 Name_Refined_Post)\n+         then\n+            Add_Pre_Post_Condition;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+\n+      --  Contract items related to variables. Applicable pragmas are:\n+      --    Async_Readers\n+      --    Async_Writers\n+      --    Constant_After_Elaboration\n+      --    Effective_Reads\n+      --    Effective_Writes\n+      --    Part_Of\n+\n+      elsif Ekind (Id) = E_Variable then\n+         if Nam_In (Prag_Nam, Name_Async_Readers,\n+                              Name_Async_Writers,\n+                              Name_Constant_After_Elaboration,\n+                              Name_Effective_Reads,\n+                              Name_Effective_Writes,\n+                              Name_Part_Of)\n+         then\n+            Add_Classification;\n+\n+         --  The pragma is not a proper contract item\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end if;\n+   end Add_Contract_Item;\n+\n+   ---------------------------------------------\n+   -- Analyze_Enclosing_Package_Body_Contract --\n+   ---------------------------------------------\n+\n+   procedure Analyze_Enclosing_Package_Body_Contract (Body_Decl : Node_Id) is\n+      Par : Node_Id;\n+\n+   begin\n+      --  Climb the parent chain looking for an enclosing body. Do not use the\n+      --  scope stack as a body uses the entity of its corresponding spec.\n+\n+      Par := Parent (Body_Decl);\n+      while Present (Par) loop\n+         if Nkind (Par) = N_Package_Body then\n+            Analyze_Package_Body_Contract\n+              (Body_Id   => Defining_Entity (Par),\n+               Freeze_Id => Defining_Entity (Body_Decl));\n+\n+            return;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+   end Analyze_Enclosing_Package_Body_Contract;\n+\n+   -----------------------------\n+   -- Analyze_Object_Contract --\n+   -----------------------------\n+\n+   procedure Analyze_Object_Contract (Obj_Id : Entity_Id) is\n+      Obj_Typ : constant Entity_Id := Etype (Obj_Id);\n+      AR_Val  : Boolean := False;\n+      AW_Val  : Boolean := False;\n+      ER_Val  : Boolean := False;\n+      EW_Val  : Boolean := False;\n+      Items   : Node_Id;\n+      Prag    : Node_Id;\n+      Seen    : Boolean := False;\n+\n+   begin\n+      --  The loop parameter in an element iterator over a formal container\n+      --  is declared with an object declaration but no contracts apply.\n+\n+      if Ekind (Obj_Id) = E_Loop_Parameter then\n+         return;\n+      end if;\n+\n+      --  Do not analyze a contract mutiple times\n+\n+      Items := Contract (Obj_Id);\n+\n+      if Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Constant related checks\n+\n+      if Ekind (Obj_Id) = E_Constant then\n+\n+         --  A constant cannot be effectively volatile (SPARK RM 7.1.3(4)).\n+         --  This check is relevant only when SPARK_Mode is on as it is not a\n+         --  standard Ada legality rule. Internally-generated constants that\n+         --  map generic formals to actuals in instantiations are allowed to\n+         --  be volatile.\n+\n+         if SPARK_Mode = On\n+           and then Comes_From_Source (Obj_Id)\n+           and then Is_Effectively_Volatile (Obj_Id)\n+           and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n+         then\n+            Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n+         end if;\n+\n+      --  Variable related checks\n+\n+      else pragma Assert (Ekind (Obj_Id) = E_Variable);\n+\n+         --  The following checks are relevant only when SPARK_Mode is on as\n+         --  they are not standard Ada legality rules. Internally generated\n+         --  temporaries are ignored.\n+\n+         if SPARK_Mode = On and then Comes_From_Source (Obj_Id) then\n+            if Is_Effectively_Volatile (Obj_Id) then\n+\n+               --  The declaration of an effectively volatile object must\n+               --  appear at the library level (SPARK RM 7.1.3(3), C.6(6)).\n+\n+               if not Is_Library_Level_Entity (Obj_Id) then\n+                  Error_Msg_N\n+                    (\"volatile variable & must be declared at library level\",\n+                     Obj_Id);\n+\n+               --  An object of a discriminated type cannot be effectively\n+               --  volatile except for protected objects (SPARK RM 7.1.3(5)).\n+\n+               elsif Has_Discriminants (Obj_Typ)\n+                 and then not Is_Protected_Type (Obj_Typ)\n+               then\n+                  Error_Msg_N\n+                    (\"discriminated object & cannot be volatile\", Obj_Id);\n+\n+               --  An object of a tagged type cannot be effectively volatile\n+               --  (SPARK RM C.6(5)).\n+\n+               elsif Is_Tagged_Type (Obj_Typ) then\n+                  Error_Msg_N (\"tagged object & cannot be volatile\", Obj_Id);\n+               end if;\n+\n+            --  The object is not effectively volatile\n+\n+            else\n+               --  A non-effectively volatile object cannot have effectively\n+               --  volatile components (SPARK RM 7.1.3(6)).\n+\n+               if not Is_Effectively_Volatile (Obj_Id)\n+                 and then Has_Volatile_Component (Obj_Typ)\n+               then\n+                  Error_Msg_N\n+                    (\"non-volatile object & cannot have volatile components\",\n+                     Obj_Id);\n+               end if;\n+            end if;\n+         end if;\n+\n+         if Is_Ghost_Entity (Obj_Id) then\n+\n+            --  A Ghost object cannot be effectively volatile (SPARK RM 6.9(8))\n+\n+            if Is_Effectively_Volatile (Obj_Id) then\n+               Error_Msg_N (\"ghost variable & cannot be volatile\", Obj_Id);\n+\n+            --  A Ghost object cannot be imported or exported (SPARK RM 6.9(8))\n+\n+            elsif Is_Imported (Obj_Id) then\n+               Error_Msg_N (\"ghost object & cannot be imported\", Obj_Id);\n+\n+            elsif Is_Exported (Obj_Id) then\n+               Error_Msg_N (\"ghost object & cannot be exported\", Obj_Id);\n+            end if;\n+         end if;\n+\n+         --  Analyze all external properties\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Async_Readers);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n+            Seen := True;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Async_Writers);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n+            Seen := True;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Reads);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n+            Seen := True;\n+         end if;\n+\n+         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Writes);\n+\n+         if Present (Prag) then\n+            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n+            Seen := True;\n+         end if;\n+\n+         --  Verify the mutual interaction of the various external properties\n+\n+         if Seen then\n+            Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n+         end if;\n+      end if;\n+\n+      --  Check whether the lack of indicator Part_Of agrees with the placement\n+      --  of the object with respect to the state space.\n+\n+      Prag := Get_Pragma (Obj_Id, Pragma_Part_Of);\n+\n+      if No (Prag) then\n+         Check_Missing_Part_Of (Obj_Id);\n+      end if;\n+\n+      --  A ghost object cannot be imported or exported (SPARK RM 6.9(8)). One\n+      --  exception to this is the object that represents the dispatch table of\n+      --  a Ghost tagged type as the symbol needs to be exported.\n+\n+      if Comes_From_Source (Obj_Id) and then Is_Ghost_Entity (Obj_Id) then\n+         if Is_Exported (Obj_Id) then\n+            Error_Msg_N (\"ghost object & cannot be exported\", Obj_Id);\n+\n+         elsif Is_Imported (Obj_Id) then\n+            Error_Msg_N (\"ghost object & cannot be imported\", Obj_Id);\n+         end if;\n+      end if;\n+   end Analyze_Object_Contract;\n+\n+   -----------------------------------\n+   -- Analyze_Package_Body_Contract --\n+   -----------------------------------\n+\n+   procedure Analyze_Package_Body_Contract\n+     (Body_Id   : Entity_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n+      Body_Decl : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n+      Items     : constant Node_Id   := Contract (Body_Id);\n+      Spec_Id   : constant Entity_Id := Spec_Entity (Body_Id);\n+      Mode      : SPARK_Mode_Type;\n+      Ref_State : Node_Id;\n+\n+   begin\n+      --  Do not analyze a contract mutiple times\n+\n+      if Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related package body.\n+\n+      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n+\n+      Ref_State := Get_Pragma (Body_Id, Pragma_Refined_State);\n+\n+      --  The analysis of pragma Refined_State detects whether the spec has\n+      --  abstract states available for refinement.\n+\n+      if Present (Ref_State) then\n+         Analyze_Refined_State_In_Decl_Part (Ref_State, Freeze_Id);\n+\n+      --  State refinement is required when the package declaration defines at\n+      --  least one abstract state. Null states are not considered. Refinement\n+      --  is not envorced when SPARK checks are turned off.\n+\n+      elsif SPARK_Mode /= Off\n+        and then Requires_State_Refinement (Spec_Id, Body_Id)\n+      then\n+         Error_Msg_N (\"package & requires state refinement\", Spec_Id);\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+\n+      --  Capture all global references in a generic package body now that the\n+      --  contract has been analyzed.\n+\n+      if Is_Generic_Declaration_Or_Body (Body_Decl) then\n+         Save_Global_References_In_Contract\n+           (Templ  => Original_Node (Body_Decl),\n+            Gen_Id => Spec_Id);\n+      end if;\n+   end Analyze_Package_Body_Contract;\n+\n+   ------------------------------\n+   -- Analyze_Package_Contract --\n+   ------------------------------\n+\n+   procedure Analyze_Package_Contract (Pack_Id : Entity_Id) is\n+      Items     : constant Node_Id := Contract (Pack_Id);\n+      Pack_Decl : constant Node_Id := Unit_Declaration_Node (Pack_Id);\n+      Init      : Node_Id := Empty;\n+      Init_Cond : Node_Id := Empty;\n+      Mode      : SPARK_Mode_Type;\n+      Prag      : Node_Id;\n+      Prag_Nam  : Name_Id;\n+\n+   begin\n+      --  Do not analyze a contract mutiple times\n+\n+      if Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related package.\n+\n+      Save_SPARK_Mode_And_Set (Pack_Id, Mode);\n+\n+      if Present (Items) then\n+\n+         --  Locate and store pragmas Initial_Condition and Initializes since\n+         --  their order of analysis matters.\n+\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n+\n+            if Prag_Nam = Name_Initial_Condition then\n+               Init_Cond := Prag;\n+\n+            elsif Prag_Nam = Name_Initializes then\n+               Init := Prag;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze the initialization related pragmas. Initializes must come\n+         --  before Initial_Condition due to item dependencies.\n+\n+         if Present (Init) then\n+            Analyze_Initializes_In_Decl_Part (Init);\n+         end if;\n+\n+         if Present (Init_Cond) then\n+            Analyze_Initial_Condition_In_Decl_Part (Init_Cond);\n+         end if;\n+      end if;\n+\n+      --  Check whether the lack of indicator Part_Of agrees with the placement\n+      --  of the package instantiation with respect to the state space.\n+\n+      if Is_Generic_Instance (Pack_Id) then\n+         Prag := Get_Pragma (Pack_Id, Pragma_Part_Of);\n+\n+         if No (Prag) then\n+            Check_Missing_Part_Of (Pack_Id);\n+         end if;\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+\n+      --  Capture all global references in a generic package now that the\n+      --  contract has been analyzed.\n+\n+      if Is_Generic_Declaration_Or_Body (Pack_Decl) then\n+         Save_Global_References_In_Contract\n+           (Templ  => Original_Node (Pack_Decl),\n+            Gen_Id => Pack_Id);\n+      end if;\n+   end Analyze_Package_Contract;\n+\n+   --------------------------------------\n+   -- Analyze_Subprogram_Body_Contract --\n+   --------------------------------------\n+\n+   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n+      Body_Decl   : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n+      Items       : constant Node_Id   := Contract (Body_Id);\n+      Spec_Id     : constant Entity_Id := Corresponding_Spec_Of (Body_Decl);\n+      Mode        : SPARK_Mode_Type;\n+      Prag        : Node_Id;\n+      Prag_Nam    : Name_Id;\n+      Ref_Depends : Node_Id   := Empty;\n+      Ref_Global  : Node_Id   := Empty;\n+\n+   begin\n+      --  When a subprogram body declaration is illegal, its defining entity is\n+      --  left unanalyzed. There is nothing left to do in this case because the\n+      --  body lacks a contract, or even a proper Ekind.\n+\n+      if Ekind (Body_Id) = E_Void then\n+         return;\n+\n+      --  Do not analyze a contract mutiple times\n+\n+      elsif Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related subprogram body.\n+\n+      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n+\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed.\n+\n+      if not Has_Significant_Contract (Body_Id) then\n+         null;\n+\n+      --  The subprogram body is a completion, analyze all delayed pragmas that\n+      --  apply. Note that when the body is stand alone, the pragmas are always\n+      --  analyzed on the spot.\n+\n+      elsif Present (Items) then\n+\n+         --  Locate and store pragmas Refined_Depends and Refined_Global since\n+         --  their order of analysis matters.\n+\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n+\n+            if Prag_Nam = Name_Refined_Depends then\n+               Ref_Depends := Prag;\n+\n+            elsif Prag_Nam = Name_Refined_Global then\n+               Ref_Global := Prag;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze Refined_Global first as Refined_Depends may mention items\n+         --  classified in the global refinement.\n+\n+         if Present (Ref_Global) then\n+            Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n+         end if;\n+\n+         --  Refined_Depends must be analyzed after Refined_Global in order to\n+         --  see the modes of all global refinements.\n+\n+         if Present (Ref_Depends) then\n+            Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n+         end if;\n+      end if;\n+\n+      --  Ensure that the contract cases or postconditions mention 'Result or\n+      --  define a post-state.\n+\n+      Check_Result_And_Post_State (Body_Id);\n+\n+      --  A stand alone non-volatile function body cannot have an effectively\n+      --  volatile formal parameter or return type (SPARK RM 7.1.3(9)). This\n+      --  check is relevant only when SPARK_Mode is on as it is not a standard\n+      --  legality rule. The check is performed here because Volatile_Function\n+      --  is processed after the analysis of the related subprogram body.\n+\n+      if SPARK_Mode = On\n+        and then Ekind_In (Body_Id, E_Function, E_Generic_Function)\n+        and then not Is_Volatile_Function (Body_Id)\n+      then\n+         Check_Nonvolatile_Function_Profile (Body_Id);\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+\n+      --  Capture all global references in a generic subprogram body now that\n+      --  the contract has been analyzed.\n+\n+      if Is_Generic_Declaration_Or_Body (Body_Decl) then\n+         Save_Global_References_In_Contract\n+           (Templ  => Original_Node (Body_Decl),\n+            Gen_Id => Spec_Id);\n+      end if;\n+\n+      --  Deal with preconditions, [refined] postconditions, Contract_Cases,\n+      --  invariants and predicates associated with body and its spec. Do not\n+      --  expand the contract of subprogram body stubs.\n+\n+      if Nkind (Body_Decl) = N_Subprogram_Body then\n+         Expand_Subprogram_Contract (Body_Id);\n+      end if;\n+   end Analyze_Subprogram_Body_Contract;\n+\n+   ---------------------------------\n+   -- Analyze_Subprogram_Contract --\n+   ---------------------------------\n+\n+   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id) is\n+      Items     : constant Node_Id := Contract (Subp_Id);\n+      Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+      Depends   : Node_Id := Empty;\n+      Global    : Node_Id := Empty;\n+      Mode      : SPARK_Mode_Type;\n+      Prag      : Node_Id;\n+      Prag_Nam  : Name_Id;\n+\n+   begin\n+      --  Do not analyze a contract mutiple times\n+\n+      if Present (Items) then\n+         if Analyzed (Items) then\n+            return;\n+         else\n+            Set_Analyzed (Items);\n+         end if;\n+      end if;\n+\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related subprogram body.\n+\n+      Save_SPARK_Mode_And_Set (Subp_Id, Mode);\n+\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed.\n+\n+      if not Has_Significant_Contract (Subp_Id) then\n+         null;\n+\n+      elsif Present (Items) then\n+\n+         --  Analyze pre- and postconditions\n+\n+         Prag := Pre_Post_Conditions (Items);\n+         while Present (Prag) loop\n+            Analyze_Pre_Post_Condition_In_Decl_Part (Prag);\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze contract-cases and test-cases\n+\n+         Prag := Contract_Test_Cases (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n+\n+            if Prag_Nam = Name_Contract_Cases then\n+               Analyze_Contract_Cases_In_Decl_Part (Prag);\n+            else\n+               pragma Assert (Prag_Nam = Name_Test_Case);\n+               Analyze_Test_Case_In_Decl_Part (Prag);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze classification pragmas\n+\n+         Prag := Classifications (Items);\n+         while Present (Prag) loop\n+            Prag_Nam := Pragma_Name (Prag);\n+\n+            if Prag_Nam = Name_Depends then\n+               Depends := Prag;\n+\n+            elsif Prag_Nam = Name_Global then\n+               Global := Prag;\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+\n+         --  Analyze Global first as Depends may mention items classified in\n+         --  the global categorization.\n+\n+         if Present (Global) then\n+            Analyze_Global_In_Decl_Part (Global);\n+         end if;\n+\n+         --  Depends must be analyzed after Global in order to see the modes of\n+         --  all global items.\n+\n+         if Present (Depends) then\n+            Analyze_Depends_In_Decl_Part (Depends);\n+         end if;\n+\n+         --  Ensure that the contract cases or postconditions mention 'Result\n+         --  or define a post-state.\n+\n+         Check_Result_And_Post_State (Subp_Id);\n+      end if;\n+\n+      --  A non-volatile function cannot have an effectively volatile formal\n+      --  parameter or return type (SPARK RM 7.1.3(9)). This check is relevant\n+      --  only when SPARK_Mode is on as it is not a standard legality rule. The\n+      --  check is performed here because pragma Volatile_Function is processed\n+      --  after the analysis of the related subprogram declaration.\n+\n+      if SPARK_Mode = On\n+        and then Ekind_In (Subp_Id, E_Function, E_Generic_Function)\n+        and then not Is_Volatile_Function (Subp_Id)\n+      then\n+         Check_Nonvolatile_Function_Profile (Subp_Id);\n+      end if;\n+\n+      --  Restore the SPARK_Mode of the enclosing context after all delayed\n+      --  pragmas have been analyzed.\n+\n+      Restore_SPARK_Mode (Mode);\n+\n+      --  Capture all global references in a generic subprogram now that the\n+      --  contract has been analyzed.\n+\n+      if Is_Generic_Declaration_Or_Body (Subp_Decl) then\n+         Save_Global_References_In_Contract\n+           (Templ  => Original_Node (Subp_Decl),\n+            Gen_Id => Subp_Id);\n+      end if;\n+   end Analyze_Subprogram_Contract;\n+\n+   -------------------------------------------\n+   -- Analyze_Subprogram_Body_Stub_Contract --\n+   -------------------------------------------\n+\n+   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id) is\n+      Stub_Decl : constant Node_Id   := Parent (Parent (Stub_Id));\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of_Stub (Stub_Decl);\n+\n+   begin\n+      --  A subprogram body stub may act as its own spec or as the completion\n+      --  of a previous declaration. Depending on the context, the contract of\n+      --  the stub may contain two sets of pragmas.\n+\n+      --  The stub is a completion, the applicable pragmas are:\n+      --    Refined_Depends\n+      --    Refined_Global\n+\n+      if Present (Spec_Id) then\n+         Analyze_Subprogram_Body_Contract (Stub_Id);\n+\n+      --  The stub acts as its own spec, the applicable pragmas are:\n+      --    Contract_Cases\n+      --    Depends\n+      --    Global\n+      --    Postcondition\n+      --    Precondition\n+      --    Test_Case\n+\n+      else\n+         Analyze_Subprogram_Contract (Stub_Id);\n+      end if;\n+   end Analyze_Subprogram_Body_Stub_Contract;\n+\n+   -----------------------------\n+   -- Create_Generic_Contract --\n+   -----------------------------\n+\n+   procedure Create_Generic_Contract (Unit : Node_Id) is\n+      Templ    : constant Node_Id   := Original_Node (Unit);\n+      Templ_Id : constant Entity_Id := Defining_Entity (Templ);\n+\n+      procedure Add_Generic_Contract_Pragma (Prag : Node_Id);\n+      --  Add a single contract-related source pragma Prag to the contract of\n+      --  generic template Templ_Id.\n+\n+      ---------------------------------\n+      -- Add_Generic_Contract_Pragma --\n+      ---------------------------------\n+\n+      procedure Add_Generic_Contract_Pragma (Prag : Node_Id) is\n+         Prag_Templ : Node_Id;\n+\n+      begin\n+         --  Mark the pragma to prevent the premature capture of global\n+         --  references when capturing global references of the context\n+         --  (see Save_References_In_Pragma).\n+\n+         Set_Is_Generic_Contract_Pragma (Prag);\n+\n+         --  Pragmas that apply to a generic subprogram declaration are not\n+         --  part of the semantic structure of the generic template:\n+\n+         --    generic\n+         --    procedure Example (Formal : Integer);\n+         --    pragma Precondition (Formal > 0);\n+\n+         --  Create a generic template for such pragmas and link the template\n+         --  of the pragma with the generic template.\n+\n+         if Nkind (Templ) = N_Generic_Subprogram_Declaration then\n+            Rewrite\n+              (Prag, Copy_Generic_Node (Prag, Empty, Instantiating => False));\n+            Prag_Templ := Original_Node (Prag);\n+\n+            Set_Is_Generic_Contract_Pragma (Prag_Templ);\n+            Add_Contract_Item (Prag_Templ, Templ_Id);\n+\n+         --  Otherwise link the pragma with the generic template\n+\n+         else\n+            Add_Contract_Item (Prag, Templ_Id);\n+         end if;\n+      end Add_Generic_Contract_Pragma;\n+\n+      --  Local variables\n+\n+      Context : constant Node_Id   := Parent (Unit);\n+      Decl    : Node_Id := Empty;\n+\n+   --  Start of processing for Create_Generic_Contract\n+\n+   begin\n+      --  A generic package declaration carries contract-related source pragmas\n+      --  in its visible declarations.\n+\n+      if Nkind (Templ) = N_Generic_Package_Declaration then\n+         Set_Ekind (Templ_Id, E_Generic_Package);\n+\n+         if Present (Visible_Declarations (Specification (Templ))) then\n+            Decl := First (Visible_Declarations (Specification (Templ)));\n+         end if;\n+\n+      --  A generic package body carries contract-related source pragmas in its\n+      --  declarations.\n+\n+      elsif Nkind (Templ) = N_Package_Body then\n+         Set_Ekind (Templ_Id, E_Package_Body);\n+\n+         if Present (Declarations (Templ)) then\n+            Decl := First (Declarations (Templ));\n+         end if;\n+\n+      --  Generic subprogram declaration\n+\n+      elsif Nkind (Templ) = N_Generic_Subprogram_Declaration then\n+         if Nkind (Specification (Templ)) = N_Function_Specification then\n+            Set_Ekind (Templ_Id, E_Generic_Function);\n+         else\n+            Set_Ekind (Templ_Id, E_Generic_Procedure);\n+         end if;\n+\n+         --  When the generic subprogram acts as a compilation unit, inspect\n+         --  the Pragmas_After list for contract-related source pragmas.\n+\n+         if Nkind (Context) = N_Compilation_Unit then\n+            if Present (Aux_Decls_Node (Context))\n+              and then Present (Pragmas_After (Aux_Decls_Node (Context)))\n+            then\n+               Decl := First (Pragmas_After (Aux_Decls_Node (Context)));\n+            end if;\n+\n+         --  Otherwise inspect the successive declarations for contract-related\n+         --  source pragmas.\n+\n+         else\n+            Decl := Next (Unit);\n+         end if;\n+\n+      --  A generic subprogram body carries contract-related source pragmas in\n+      --  its declarations.\n+\n+      elsif Nkind (Templ) = N_Subprogram_Body then\n+         Set_Ekind (Templ_Id, E_Subprogram_Body);\n+\n+         if Present (Declarations (Templ)) then\n+            Decl := First (Declarations (Templ));\n+         end if;\n+      end if;\n+\n+      --  Inspect the relevant declarations looking for contract-related source\n+      --  pragmas and add them to the contract of the generic unit.\n+\n+      while Present (Decl) loop\n+         if Comes_From_Source (Decl) then\n+            if Nkind (Decl) = N_Pragma then\n+\n+               --  The source pragma is a contract annotation\n+\n+               if Is_Contract_Annotation (Decl) then\n+                  Add_Generic_Contract_Pragma (Decl);\n+               end if;\n+\n+            --  The region where a contract-related source pragma may appear\n+            --  ends with the first source non-pragma declaration or statement.\n+\n+            else\n+               exit;\n+            end if;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+   end Create_Generic_Contract;\n+\n+   --------------------------------\n+   -- Expand_Subprogram_Contract --\n+   --------------------------------\n+\n+   procedure Expand_Subprogram_Contract (Body_Id : Entity_Id) is\n+      Body_Decl : constant Node_Id   := Unit_Declaration_Node (Body_Id);\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec (Body_Decl);\n+\n+      procedure Add_Invariant_And_Predicate_Checks\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id;\n+         Result  : out Node_Id);\n+      --  Process the result of function Subp_Id (if applicable) and all its\n+      --  formals. Add invariant and predicate checks where applicable. The\n+      --  routine appends all the checks to list Stmts. If Subp_Id denotes a\n+      --  function, Result contains the entity of parameter _Result, to be\n+      --  used in the creation of procedure _Postconditions.\n+\n+      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id);\n+      --  Append a node to a list. If there is no list, create a new one. When\n+      --  the item denotes a pragma, it is added to the list only when it is\n+      --  enabled.\n+\n+      procedure Build_Postconditions_Procedure\n+        (Subp_Id : Entity_Id;\n+         Stmts   : List_Id;\n+         Result  : Entity_Id);\n+      --  Create the body of procedure _Postconditions which handles various\n+      --  assertion actions on exit from subprogram Subp_Id. Stmts is the list\n+      --  of statements to be checked on exit. Parameter Result is the entity\n+      --  of parameter _Result when Subp_Id denotes a function.\n+\n+      function Build_Pragma_Check_Equivalent\n+        (Prag     : Node_Id;\n+         Subp_Id  : Entity_Id := Empty;\n+         Inher_Id : Entity_Id := Empty) return Node_Id;\n+      --  Transform a [refined] pre- or postcondition denoted by Prag into an\n+      --  equivalent pragma Check. When the pre- or postcondition is inherited,\n+      --  the routine corrects the references of all formals of Inher_Id to\n+      --  point to the formals of Subp_Id.\n+\n+      procedure Process_Contract_Cases (Stmts : in out List_Id);\n+      --  Process pragma Contract_Cases. This routine prepends items to the\n+      --  body declarations and appends items to list Stmts.\n+\n+      procedure Process_Postconditions (Stmts : in out List_Id);\n+      --  Collect all [inherited] spec and body postconditions and accumulate\n+      --  their pragma Check equivalents in list Stmts.\n+\n+      procedure Process_Preconditions;\n+      --  Collect all [inherited] spec and body preconditions and prepend their\n+      --  pragma Check equivalents to the declarations of the body.\n+\n+      ----------------------------------------\n+      -- Add_Invariant_And_Predicate_Checks --\n+      ----------------------------------------\n+\n+      procedure Add_Invariant_And_Predicate_Checks\n+        (Subp_Id : Entity_Id;\n+         Stmts   : in out List_Id;\n+         Result  : out Node_Id)\n+      is\n+         procedure Add_Invariant_Access_Checks (Id : Entity_Id);\n+         --  Id denotes the return value of a function or a formal parameter.\n+         --  Add an invariant check if the type of Id is access to a type with\n+         --  invariants. The routine appends the generated code to Stmts.\n+\n+         function Invariant_Checks_OK (Typ : Entity_Id) return Boolean;\n+         --  Determine whether type Typ can benefit from invariant checks. To\n+         --  qualify, the type must have a non-null invariant procedure and\n+         --  subprogram Subp_Id must appear visible from the point of view of\n+         --  the type.\n+\n+         ---------------------------------\n+         -- Add_Invariant_Access_Checks --\n+         ---------------------------------\n+\n+         procedure Add_Invariant_Access_Checks (Id : Entity_Id) is\n+            Loc : constant Source_Ptr := Sloc (Body_Decl);\n+            Ref : Node_Id;\n+            Typ : Entity_Id;\n+\n+         begin\n+            Typ := Etype (Id);\n+\n+            if Is_Access_Type (Typ) and then not Is_Access_Constant (Typ) then\n+               Typ := Designated_Type (Typ);\n+\n+               if Invariant_Checks_OK (Typ) then\n+                  Ref :=\n+                    Make_Explicit_Dereference (Loc,\n+                      Prefix => New_Occurrence_Of (Id, Loc));\n+                  Set_Etype (Ref, Typ);\n+\n+                  --  Generate:\n+                  --    if <Id> /= null then\n+                  --       <invariant_call (<Ref>)>\n+                  --    end if;\n+\n+                  Append_Enabled_Item\n+                    (Item =>\n+                       Make_If_Statement (Loc,\n+                         Condition =>\n+                           Make_Op_Ne (Loc,\n+                             Left_Opnd  => New_Occurrence_Of (Id, Loc),\n+                             Right_Opnd => Make_Null (Loc)),\n+                         Then_Statements => New_List (\n+                           Make_Invariant_Call (Ref))),\n+                     List => Stmts);\n+               end if;\n+            end if;\n+         end Add_Invariant_Access_Checks;\n+\n+         -------------------------\n+         -- Invariant_Checks_OK --\n+         -------------------------\n+\n+         function Invariant_Checks_OK (Typ : Entity_Id) return Boolean is\n+            function Has_Null_Body (Proc_Id : Entity_Id) return Boolean;\n+            --  Determine whether the body of procedure Proc_Id contains a sole\n+            --  null statement, possibly followed by an optional return.\n+\n+            function Has_Public_Visibility_Of_Subprogram return Boolean;\n+            --  Determine whether type Typ has public visibility of subprogram\n+            --  Subp_Id.\n+\n+            -------------------\n+            -- Has_Null_Body --\n+            -------------------\n+\n+            function Has_Null_Body (Proc_Id : Entity_Id) return Boolean is\n+               Body_Id : Entity_Id;\n+               Decl    : Node_Id;\n+               Spec    : Node_Id;\n+               Stmt1   : Node_Id;\n+               Stmt2   : Node_Id;\n+\n+            begin\n+               Spec := Parent (Proc_Id);\n+               Decl := Parent (Spec);\n+\n+               --  Retrieve the entity of the invariant procedure body\n+\n+               if Nkind (Spec) = N_Procedure_Specification\n+                 and then Nkind (Decl) = N_Subprogram_Declaration\n+               then\n+                  Body_Id := Corresponding_Body (Decl);\n+\n+               --  The body acts as a spec\n+\n+               else\n+                  Body_Id := Proc_Id;\n+               end if;\n+\n+               --  The body will be generated later\n+\n+               if No (Body_Id) then\n+                  return False;\n+               end if;\n+\n+               Spec := Parent (Body_Id);\n+               Decl := Parent (Spec);\n+\n+               pragma Assert\n+                 (Nkind (Spec) = N_Procedure_Specification\n+                   and then Nkind (Decl) = N_Subprogram_Body);\n+\n+               Stmt1 := First (Statements (Handled_Statement_Sequence (Decl)));\n+\n+               --  Look for a null statement followed by an optional return\n+               --  statement.\n+\n+               if Nkind (Stmt1) = N_Null_Statement then\n+                  Stmt2 := Next (Stmt1);\n+\n+                  if Present (Stmt2) then\n+                     return Nkind (Stmt2) = N_Simple_Return_Statement;\n+                  else\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               return False;\n+            end Has_Null_Body;\n+\n+            -----------------------------------------\n+            -- Has_Public_Visibility_Of_Subprogram --\n+            -----------------------------------------\n+\n+            function Has_Public_Visibility_Of_Subprogram return Boolean is\n+               Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+\n+            begin\n+               --  An Initialization procedure must be considered visible even\n+               --  though it is internally generated.\n+\n+               if Is_Init_Proc (Defining_Entity (Subp_Decl)) then\n+                  return True;\n+\n+               elsif Ekind (Scope (Typ)) /= E_Package then\n+                  return False;\n+\n+               --  Internally generated code is never publicly visible except\n+               --  for a subprogram that is the implementation of an expression\n+               --  function. In that case the visibility is determined by the\n+               --  last check.\n+\n+               elsif not Comes_From_Source (Subp_Decl)\n+                 and then\n+                   (Nkind (Original_Node (Subp_Decl)) /= N_Expression_Function\n+                      or else not\n+                        Comes_From_Source (Defining_Entity (Subp_Decl)))\n+               then\n+                  return False;\n+\n+               --  Determine whether the subprogram is declared in the visible\n+               --  declarations of the package containing the type.\n+\n+               else\n+                  return List_Containing (Subp_Decl) =\n+                    Visible_Declarations\n+                      (Specification (Unit_Declaration_Node (Scope (Typ))));\n+               end if;\n+            end Has_Public_Visibility_Of_Subprogram;\n+\n+         --  Start of processing for Invariant_Checks_OK\n+\n+         begin\n+            return\n+              Has_Invariants (Typ)\n+                and then Present (Invariant_Procedure (Typ))\n+                and then not Has_Null_Body (Invariant_Procedure (Typ))\n+                and then Has_Public_Visibility_Of_Subprogram;\n+         end Invariant_Checks_OK;\n+\n+         --  Local variables\n+\n+         Loc : constant Source_Ptr := Sloc (Body_Decl);\n+         --  Source location of subprogram body contract\n+\n+         Formal : Entity_Id;\n+         Typ    : Entity_Id;\n+\n+      --  Start of processing for Add_Invariant_And_Predicate_Checks\n+\n+      begin\n+         Result := Empty;\n+\n+         --  Process the result of a function\n+\n+         if Ekind (Subp_Id) = E_Function then\n+            Typ := Etype (Subp_Id);\n+\n+            --  Generate _Result which is used in procedure _Postconditions to\n+            --  verify the return value.\n+\n+            Result := Make_Defining_Identifier (Loc, Name_uResult);\n+            Set_Etype (Result, Typ);\n+\n+            --  Add an invariant check when the return type has invariants and\n+            --  the related function is visible to the outside.\n+\n+            if Invariant_Checks_OK (Typ) then\n+               Append_Enabled_Item\n+                 (Item =>\n+                    Make_Invariant_Call (New_Occurrence_Of (Result, Loc)),\n+                  List => Stmts);\n+            end if;\n+\n+            --  Add an invariant check when the return type is an access to a\n+            --  type with invariants.\n+\n+            Add_Invariant_Access_Checks (Result);\n+         end if;\n+\n+         --  Add invariant and predicates for all formals that qualify\n+\n+         Formal := First_Formal (Subp_Id);\n+         while Present (Formal) loop\n+            Typ := Etype (Formal);\n+\n+            if Ekind (Formal) /= E_In_Parameter\n+              or else Is_Access_Type (Typ)\n+            then\n+               if Invariant_Checks_OK (Typ) then\n+                  Append_Enabled_Item\n+                    (Item =>\n+                       Make_Invariant_Call (New_Occurrence_Of (Formal, Loc)),\n+                     List => Stmts);\n+               end if;\n+\n+               Add_Invariant_Access_Checks (Formal);\n+\n+               --  Note: we used to add predicate checks for OUT and IN OUT\n+               --  formals here, but that was misguided, since such checks are\n+               --  performed on the caller side, based on the predicate of the\n+               --  actual, rather than the predicate of the formal.\n+\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+      end Add_Invariant_And_Predicate_Checks;\n+\n+      -------------------------\n+      -- Append_Enabled_Item --\n+      -------------------------\n+\n+      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id) is\n+      begin\n+         --  Do not chain ignored or disabled pragmas\n+\n+         if Nkind (Item) = N_Pragma\n+           and then (Is_Ignored (Item) or else Is_Disabled (Item))\n+         then\n+            null;\n+\n+         --  Otherwise, add the item\n+\n+         else\n+            if No (List) then\n+               List := New_List;\n+            end if;\n+\n+            --  If the pragma is a conjunct in a composite postcondition, it\n+            --  has been processed in reverse order. In the postcondition body\n+            --  if must appear before the others.\n+\n+            if Nkind (Item) = N_Pragma\n+              and then From_Aspect_Specification (Item)\n+              and then Split_PPC (Item)\n+            then\n+               Prepend (Item, List);\n+            else\n+               Append (Item, List);\n+            end if;\n+         end if;\n+      end Append_Enabled_Item;\n+\n+      ------------------------------------\n+      -- Build_Postconditions_Procedure --\n+      ------------------------------------\n+\n+      procedure Build_Postconditions_Procedure\n+        (Subp_Id : Entity_Id;\n+         Stmts   : List_Id;\n+         Result  : Entity_Id)\n+      is\n+         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id);\n+         --  Insert node Stmt before the first source declaration of the\n+         --  related subprogram's body. If no such declaration exists, Stmt\n+         --  becomes the last declaration.\n+\n+         --------------------------------------------\n+         -- Insert_Before_First_Source_Declaration --\n+         --------------------------------------------\n+\n+         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id) is\n+            Decls : constant List_Id := Declarations (Body_Decl);\n+            Decl  : Node_Id;\n+\n+         begin\n+            --  Inspect the declarations of the related subprogram body looking\n+            --  for the first source declaration.\n+\n+            if Present (Decls) then\n+               Decl := First (Decls);\n+               while Present (Decl) loop\n+                  if Comes_From_Source (Decl) then\n+                     Insert_Before (Decl, Stmt);\n+                     return;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop;\n+\n+               --  If we get there, then the subprogram body lacks any source\n+               --  declarations. The body of _Postconditions now acts as the\n+               --  last declaration.\n+\n+               Append (Stmt, Decls);\n+\n+            --  Ensure that the body has a declaration list\n+\n+            else\n+               Set_Declarations (Body_Decl, New_List (Stmt));\n+            end if;\n+         end Insert_Before_First_Source_Declaration;\n+\n+         --  Local variables\n+\n+         Loc      : constant Source_Ptr := Sloc (Body_Decl);\n+         Params   : List_Id := No_List;\n+         Proc_Bod : Node_Id;\n+         Proc_Id  : Entity_Id;\n+\n+      --  Start of processing for Build_Postconditions_Procedure\n+\n+      begin\n+         --  Nothing to do if there are no actions to check on exit\n+\n+         if No (Stmts) then\n+            return;\n+         end if;\n+\n+         Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n+         Set_Debug_Info_Needed   (Proc_Id);\n+         Set_Postconditions_Proc (Subp_Id, Proc_Id);\n+\n+         --  The related subprogram is a function, create the specification of\n+         --  parameter _Result.\n+\n+         if Present (Result) then\n+            Params := New_List (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Result,\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (Etype (Result), Loc)));\n+         end if;\n+\n+         --  Insert _Postconditions before the first source declaration of the\n+         --  body. This ensures that the body will not cause any premature\n+         --  freezing as it may mention types:\n+\n+         --    procedure Proc (Obj : Array_Typ) is\n+         --       procedure _postconditions is\n+         --       begin\n+         --          ... Obj ...\n+         --       end _postconditions;\n+\n+         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n+         --    begin\n+\n+         --  In the example above, Obj is of type T but the incorrect placement\n+         --  of _Postconditions will cause a crash in gigi due to an out of\n+         --  order reference. The body of _Postconditions must be placed after\n+         --  the declaration of Temp to preserve correct visibility.\n+\n+         --  Set an explicit End_Lavel to override the sloc of the implicit\n+         --  RETURN statement, and prevent it from inheriting the sloc of one\n+         --  the postconditions: this would cause confusing debug into to be\n+         --  produced, interfering with coverage analysis tools.\n+\n+         Proc_Bod :=\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name       => Proc_Id,\n+                 Parameter_Specifications => Params),\n+\n+             Declarations               => Empty_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Stmts,\n+                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id))));\n+\n+         Insert_Before_First_Source_Declaration (Proc_Bod);\n+         Analyze (Proc_Bod);\n+      end Build_Postconditions_Procedure;\n+\n+      -----------------------------------\n+      -- Build_Pragma_Check_Equivalent --\n+      -----------------------------------\n+\n+      function Build_Pragma_Check_Equivalent\n+        (Prag     : Node_Id;\n+         Subp_Id  : Entity_Id := Empty;\n+         Inher_Id : Entity_Id := Empty) return Node_Id\n+      is\n+         function Suppress_Reference (N : Node_Id) return Traverse_Result;\n+         --  Detect whether node N references a formal parameter subject to\n+         --  pragma Unreferenced. If this is the case, set Comes_From_Source\n+         --  to False to suppress the generation of a reference when analyzing\n+         --  N later on.\n+\n+         ------------------------\n+         -- Suppress_Reference --\n+         ------------------------\n+\n+         function Suppress_Reference (N : Node_Id) return Traverse_Result is\n+            Formal : Entity_Id;\n+\n+         begin\n+            if Is_Entity_Name (N) and then Present (Entity (N)) then\n+               Formal := Entity (N);\n+\n+               --  The formal parameter is subject to pragma Unreferenced.\n+               --  Prevent the generation of a reference by resetting the\n+               --  Comes_From_Source flag.\n+\n+               if Is_Formal (Formal)\n+                 and then Has_Pragma_Unreferenced (Formal)\n+               then\n+                  Set_Comes_From_Source (N, False);\n+               end if;\n+            end if;\n+\n+            return OK;\n+         end Suppress_Reference;\n+\n+         procedure Suppress_References is\n+           new Traverse_Proc (Suppress_Reference);\n+\n+         --  Local variables\n+\n+         Loc          : constant Source_Ptr := Sloc (Prag);\n+         Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n+         Check_Prag   : Node_Id;\n+         Formals_Map  : Elist_Id;\n+         Inher_Formal : Entity_Id;\n+         Msg_Arg      : Node_Id;\n+         Nam          : Name_Id;\n+         Subp_Formal  : Entity_Id;\n+\n+      --  Start of processing for Build_Pragma_Check_Equivalent\n+\n+      begin\n+         Formals_Map := No_Elist;\n+\n+         --  When the pre- or postcondition is inherited, map the formals of\n+         --  the inherited subprogram to those of the current subprogram.\n+\n+         if Present (Inher_Id) then\n+            pragma Assert (Present (Subp_Id));\n+\n+            Formals_Map := New_Elmt_List;\n+\n+            --  Create a relation <inherited formal> => <subprogram formal>\n+\n+            Inher_Formal := First_Formal (Inher_Id);\n+            Subp_Formal  := First_Formal (Subp_Id);\n+            while Present (Inher_Formal) and then Present (Subp_Formal) loop\n+               Append_Elmt (Inher_Formal, Formals_Map);\n+               Append_Elmt (Subp_Formal, Formals_Map);\n+\n+               Next_Formal (Inher_Formal);\n+               Next_Formal (Subp_Formal);\n+            end loop;\n+         end if;\n+\n+         --  Copy the original pragma while performing substitutions (if\n+         --  applicable).\n+\n+         Check_Prag :=\n+           New_Copy_Tree\n+             (Source    => Prag,\n+              Map       => Formals_Map,\n+              New_Scope => Current_Scope);\n+\n+         --  Mark the pragma as being internally generated and reset the\n+         --  Analyzed flag.\n+\n+         Set_Analyzed          (Check_Prag, False);\n+         Set_Comes_From_Source (Check_Prag, False);\n+\n+         --  The tree of the original pragma may contain references to the\n+         --  formal parameters of the related subprogram. At the same time\n+         --  the corresponding body may mark the formals as unreferenced:\n+\n+         --     procedure Proc (Formal : ...)\n+         --       with Pre => Formal ...;\n+\n+         --     procedure Proc (Formal : ...) is\n+         --        pragma Unreferenced (Formal);\n+         --     ...\n+\n+         --  This creates problems because all pragma Check equivalents are\n+         --  analyzed at the end of the body declarations. Since all source\n+         --  references have already been accounted for, reset any references\n+         --  to such formals in the generated pragma Check equivalent.\n+\n+         Suppress_References (Check_Prag);\n+\n+         if Present (Corresponding_Aspect (Prag)) then\n+            Nam := Chars (Identifier (Corresponding_Aspect (Prag)));\n+         else\n+            Nam := Prag_Nam;\n+         end if;\n+\n+         --  Convert the copy into pragma Check by correcting the name and\n+         --  adding a check_kind argument.\n+\n+         Set_Pragma_Identifier\n+           (Check_Prag, Make_Identifier (Loc, Name_Check));\n+\n+         Prepend_To (Pragma_Argument_Associations (Check_Prag),\n+           Make_Pragma_Argument_Association (Loc,\n+             Expression => Make_Identifier (Loc, Nam)));\n+\n+         --  Update the error message when the pragma is inherited\n+\n+         if Present (Inher_Id) then\n+            Msg_Arg := Last (Pragma_Argument_Associations (Check_Prag));\n+\n+            if Chars (Msg_Arg) = Name_Message then\n+               String_To_Name_Buffer (Strval (Expression (Msg_Arg)));\n+\n+               --  Insert \"inherited\" to improve the error message\n+\n+               if Name_Buffer (1 .. 8) = \"failed p\" then\n+                  Insert_Str_In_Name_Buffer (\"inherited \", 8);\n+                  Set_Strval (Expression (Msg_Arg), String_From_Name_Buffer);\n+               end if;\n+            end if;\n+         end if;\n+\n+         return Check_Prag;\n+      end Build_Pragma_Check_Equivalent;\n+\n+      ----------------------------\n+      -- Process_Contract_Cases --\n+      ----------------------------\n+\n+      procedure Process_Contract_Cases (Stmts : in out List_Id) is\n+         procedure Process_Contract_Cases_For (Subp_Id : Entity_Id);\n+         --  Process pragma Contract_Cases for subprogram Subp_Id\n+\n+         --------------------------------\n+         -- Process_Contract_Cases_For --\n+         --------------------------------\n+\n+         procedure Process_Contract_Cases_For (Subp_Id : Entity_Id) is\n+            Items : constant Node_Id := Contract (Subp_Id);\n+            Prag  : Node_Id;\n+\n+         begin\n+            if Present (Items) then\n+               Prag := Contract_Test_Cases (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Contract_Cases then\n+                     Expand_Pragma_Contract_Cases\n+                       (CCs     => Prag,\n+                        Subp_Id => Subp_Id,\n+                        Decls   => Declarations (Body_Decl),\n+                        Stmts   => Stmts);\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+         end Process_Contract_Cases_For;\n+\n+      --  Start of processing for Process_Contract_Cases\n+\n+      begin\n+         Process_Contract_Cases_For (Body_Id);\n+\n+         if Present (Spec_Id) then\n+            Process_Contract_Cases_For (Spec_Id);\n+         end if;\n+      end Process_Contract_Cases;\n+\n+      ----------------------------\n+      -- Process_Postconditions --\n+      ----------------------------\n+\n+      procedure Process_Postconditions (Stmts : in out List_Id) is\n+         procedure Process_Body_Postconditions (Post_Nam : Name_Id);\n+         --  Collect all [refined] postconditions of a specific kind denoted\n+         --  by Post_Nam that belong to the body and generate pragma Check\n+         --  equivalents in list Stmts.\n+\n+         procedure Process_Spec_Postconditions;\n+         --  Collect all [inherited] postconditions of the spec and generate\n+         --  pragma Check equivalents in list Stmts.\n+\n+         ---------------------------------\n+         -- Process_Body_Postconditions --\n+         ---------------------------------\n+\n+         procedure Process_Body_Postconditions (Post_Nam : Name_Id) is\n+            Items     : constant Node_Id := Contract (Body_Id);\n+            Unit_Decl : constant Node_Id := Parent (Body_Decl);\n+            Decl      : Node_Id;\n+            Prag      : Node_Id;\n+\n+         begin\n+            --  Process the contract\n+\n+            if Present (Items) then\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Post_Nam then\n+                     Append_Enabled_Item\n+                       (Item => Build_Pragma_Check_Equivalent (Prag),\n+                        List => Stmts);\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+\n+            --  The subprogram body being processed is actually the proper body\n+            --  of a stub with a corresponding spec. The subprogram stub may\n+            --  carry a postcondition pragma in which case it must be taken\n+            --  into account. The pragma appears after the stub.\n+\n+            if Present (Spec_Id) and then Nkind (Unit_Decl) = N_Subunit then\n+               Decl := Next (Corresponding_Stub (Unit_Decl));\n+               while Present (Decl) loop\n+\n+                  --  Note that non-matching pragmas are skipped\n+\n+                  if Nkind (Decl) = N_Pragma then\n+                     if Pragma_Name (Decl) = Post_Nam then\n+                        Append_Enabled_Item\n+                          (Item => Build_Pragma_Check_Equivalent (Decl),\n+                           List => Stmts);\n+                     end if;\n+\n+                  --  Skip internally generated code\n+\n+                  elsif not Comes_From_Source (Decl) then\n+                     null;\n+\n+                  --  Postcondition pragmas are usually grouped together. There\n+                  --  is no need to inspect the whole declarative list.\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop;\n+            end if;\n+         end Process_Body_Postconditions;\n+\n+         ---------------------------------\n+         -- Process_Spec_Postconditions --\n+         ---------------------------------\n+\n+         procedure Process_Spec_Postconditions is\n+            Subps   : constant Subprogram_List :=\n+                        Inherited_Subprograms (Spec_Id);\n+            Items   : Node_Id;\n+            Prag    : Node_Id;\n+            Subp_Id : Entity_Id;\n+\n+         begin\n+            --  Process the contract\n+\n+            Items := Contract (Spec_Id);\n+\n+            if Present (Items) then\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Postcondition then\n+                     Append_Enabled_Item\n+                       (Item => Build_Pragma_Check_Equivalent (Prag),\n+                        List => Stmts);\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+\n+            --  Process the contracts of all inherited subprograms, looking for\n+            --  class-wide postconditions.\n+\n+            for Index in Subps'Range loop\n+               Subp_Id := Subps (Index);\n+               Items   := Contract (Subp_Id);\n+\n+               if Present (Items) then\n+                  Prag := Pre_Post_Conditions (Items);\n+                  while Present (Prag) loop\n+                     if Pragma_Name (Prag) = Name_Postcondition\n+                       and then Class_Present (Prag)\n+                     then\n+                        Append_Enabled_Item\n+                          (Item =>\n+                             Build_Pragma_Check_Equivalent\n+                               (Prag     => Prag,\n+                                Subp_Id  => Spec_Id,\n+                                Inher_Id => Subp_Id),\n+                           List => Stmts);\n+                     end if;\n+\n+                     Prag := Next_Pragma (Prag);\n+                  end loop;\n+               end if;\n+            end loop;\n+         end Process_Spec_Postconditions;\n+\n+      --  Start of processing for Process_Postconditions\n+\n+      begin\n+         --  The processing of postconditions is done in reverse order (body\n+         --  first) to ensure the following arrangement:\n+\n+         --    <refined postconditions from body>\n+         --    <postconditions from body>\n+         --    <postconditions from spec>\n+         --    <inherited postconditions>\n+\n+         Process_Body_Postconditions (Name_Refined_Post);\n+         Process_Body_Postconditions (Name_Postcondition);\n+\n+         if Present (Spec_Id) then\n+            Process_Spec_Postconditions;\n+         end if;\n+      end Process_Postconditions;\n+\n+      ---------------------------\n+      -- Process_Preconditions --\n+      ---------------------------\n+\n+      procedure Process_Preconditions is\n+         Class_Pre : Node_Id := Empty;\n+         --  The sole [inherited] class-wide precondition pragma that applies\n+         --  to the subprogram.\n+\n+         Insert_Node : Node_Id := Empty;\n+         --  The insertion node after which all pragma Check equivalents are\n+         --  inserted.\n+\n+         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id);\n+         --  Merge two class-wide preconditions by \"or else\"-ing them. The\n+         --  changes are accumulated in parameter Into. Update the error\n+         --  message of Into.\n+\n+         procedure Prepend_To_Decls (Item : Node_Id);\n+         --  Prepend a single item to the declarations of the subprogram body\n+\n+         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id);\n+         --  Save a class-wide precondition into Class_Pre or prepend a normal\n+         --  precondition ot the declarations of the body and analyze it.\n+\n+         procedure Process_Inherited_Preconditions;\n+         --  Collect all inherited class-wide preconditions and merge them into\n+         --  one big precondition to be evaluated as pragma Check.\n+\n+         procedure Process_Preconditions_For (Subp_Id : Entity_Id);\n+         --  Collect all preconditions of subprogram Subp_Id and prepend their\n+         --  pragma Check equivalents to the declarations of the body.\n+\n+         -------------------------\n+         -- Merge_Preconditions --\n+         -------------------------\n+\n+         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id) is\n+            function Expression_Arg (Prag : Node_Id) return Node_Id;\n+            --  Return the boolean expression argument of a precondition while\n+            --  updating its parenteses count for the subsequent merge.\n+\n+            function Message_Arg (Prag : Node_Id) return Node_Id;\n+            --  Return the message argument of a precondition\n+\n+            --------------------\n+            -- Expression_Arg --\n+            --------------------\n+\n+            function Expression_Arg (Prag : Node_Id) return Node_Id is\n+               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+               Arg  : constant Node_Id := Get_Pragma_Arg (Next (First (Args)));\n+\n+            begin\n+               if Paren_Count (Arg) = 0 then\n+                  Set_Paren_Count (Arg, 1);\n+               end if;\n+\n+               return Arg;\n+            end Expression_Arg;\n+\n+            -----------------\n+            -- Message_Arg --\n+            -----------------\n+\n+            function Message_Arg (Prag : Node_Id) return Node_Id is\n+               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+            begin\n+               return Get_Pragma_Arg (Last (Args));\n+            end Message_Arg;\n+\n+            --  Local variables\n+\n+            From_Expr : constant Node_Id := Expression_Arg (From);\n+            From_Msg  : constant Node_Id := Message_Arg    (From);\n+            Into_Expr : constant Node_Id := Expression_Arg (Into);\n+            Into_Msg  : constant Node_Id := Message_Arg    (Into);\n+            Loc       : constant Source_Ptr := Sloc (Into);\n+\n+         --  Start of processing for Merge_Preconditions\n+\n+         begin\n+            --  Merge the two preconditions by \"or else\"-ing them\n+\n+            Rewrite (Into_Expr,\n+              Make_Or_Else (Loc,\n+                Right_Opnd => Relocate_Node (Into_Expr),\n+                Left_Opnd  => From_Expr));\n+\n+            --  Merge the two error messages to produce a single message of the\n+            --  form:\n+\n+            --    failed precondition from ...\n+            --      also failed inherited precondition from ...\n+\n+            if not Exception_Locations_Suppressed then\n+               Start_String (Strval (Into_Msg));\n+               Store_String_Char (ASCII.LF);\n+               Store_String_Chars (\"  also \");\n+               Store_String_Chars (Strval (From_Msg));\n+\n+               Set_Strval (Into_Msg, End_String);\n+            end if;\n+         end Merge_Preconditions;\n+\n+         ----------------------\n+         -- Prepend_To_Decls --\n+         ----------------------\n+\n+         procedure Prepend_To_Decls (Item : Node_Id) is\n+            Decls : List_Id := Declarations (Body_Decl);\n+\n+         begin\n+            --  Ensure that the body has a declarative list\n+\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Declarations (Body_Decl, Decls);\n+            end if;\n+\n+            Prepend_To (Decls, Item);\n+         end Prepend_To_Decls;\n+\n+         ------------------------------\n+         -- Prepend_To_Decls_Or_Save --\n+         ------------------------------\n+\n+         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id) is\n+            Check_Prag : Node_Id;\n+\n+         begin\n+            Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+\n+            --  Save the sole class-wide precondition (if any) for the next\n+            --  step where it will be merged with inherited preconditions.\n+\n+            if Class_Present (Prag) then\n+               pragma Assert (No (Class_Pre));\n+               Class_Pre := Check_Prag;\n+\n+            --  Accumulate the corresponding Check pragmas at the top of the\n+            --  declarations. Prepending the items ensures that they will be\n+            --  evaluated in their original order.\n+\n+            else\n+               if Present (Insert_Node) then\n+                  Insert_After (Insert_Node, Check_Prag);\n+               else\n+                  Prepend_To_Decls (Check_Prag);\n+               end if;\n+\n+               Analyze (Check_Prag);\n+            end if;\n+         end Prepend_To_Decls_Or_Save;\n+\n+         -------------------------------------\n+         -- Process_Inherited_Preconditions --\n+         -------------------------------------\n+\n+         procedure Process_Inherited_Preconditions is\n+            Subps      : constant Subprogram_List :=\n+                           Inherited_Subprograms (Spec_Id);\n+            Check_Prag : Node_Id;\n+            Items      : Node_Id;\n+            Prag       : Node_Id;\n+            Subp_Id    : Entity_Id;\n+\n+         begin\n+            --  Process the contracts of all inherited subprograms, looking for\n+            --  class-wide preconditions.\n+\n+            for Index in Subps'Range loop\n+               Subp_Id := Subps (Index);\n+               Items   := Contract (Subp_Id);\n+\n+               if Present (Items) then\n+                  Prag := Pre_Post_Conditions (Items);\n+                  while Present (Prag) loop\n+                     if Pragma_Name (Prag) = Name_Precondition\n+                       and then Class_Present (Prag)\n+                     then\n+                        Check_Prag :=\n+                          Build_Pragma_Check_Equivalent\n+                            (Prag     => Prag,\n+                             Subp_Id  => Spec_Id,\n+                             Inher_Id => Subp_Id);\n+\n+                        --  The spec or an inherited subprogram already yielded\n+                        --  a class-wide precondition. Merge the existing\n+                        --  precondition with the current one using \"or else\".\n+\n+                        if Present (Class_Pre) then\n+                           Merge_Preconditions (Check_Prag, Class_Pre);\n+                        else\n+                           Class_Pre := Check_Prag;\n+                        end if;\n+                     end if;\n+\n+                     Prag := Next_Pragma (Prag);\n+                  end loop;\n+               end if;\n+            end loop;\n+\n+            --  Add the merged class-wide preconditions\n+\n+            if Present (Class_Pre) then\n+               Prepend_To_Decls (Class_Pre);\n+               Analyze (Class_Pre);\n+            end if;\n+         end Process_Inherited_Preconditions;\n+\n+         -------------------------------\n+         -- Process_Preconditions_For --\n+         -------------------------------\n+\n+         procedure Process_Preconditions_For (Subp_Id : Entity_Id) is\n+            Items     : constant Node_Id := Contract (Subp_Id);\n+            Decl      : Node_Id;\n+            Prag      : Node_Id;\n+            Subp_Decl : Node_Id;\n+\n+         begin\n+            --  Process the contract\n+\n+            if Present (Items) then\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Precondition then\n+                     Prepend_To_Decls_Or_Save (Prag);\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+\n+            --  The subprogram declaration being processed is actually a body\n+            --  stub. The stub may carry a precondition pragma in which case it\n+            --  must be taken into account. The pragma appears after the stub.\n+\n+            Subp_Decl := Unit_Declaration_Node (Subp_Id);\n+\n+            if Nkind (Subp_Decl) = N_Subprogram_Body_Stub then\n+\n+               --  Inspect the declarations following the body stub\n+\n+               Decl := Next (Subp_Decl);\n+               while Present (Decl) loop\n+\n+                  --  Note that non-matching pragmas are skipped\n+\n+                  if Nkind (Decl) = N_Pragma then\n+                     if Pragma_Name (Decl) = Name_Precondition then\n+                        Prepend_To_Decls_Or_Save (Decl);\n+                     end if;\n+\n+                  --  Skip internally generated code\n+\n+                  elsif not Comes_From_Source (Decl) then\n+                     null;\n+\n+                  --  Preconditions are usually grouped together. There is no\n+                  --  need to inspect the whole declarative list.\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop;\n+            end if;\n+         end Process_Preconditions_For;\n+\n+         --  Local variables\n+\n+         Decls : constant List_Id := Declarations (Body_Decl);\n+         Decl  : Node_Id;\n+\n+      --  Start of processing for Process_Preconditions\n+\n+      begin\n+         --  Find the last internally generate declaration starting from the\n+         --  top of the body declarations. This ensures that discriminals and\n+         --  subtypes are properly visible to the pragma Check equivalents.\n+\n+         if Present (Decls) then\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+               exit when Comes_From_Source (Decl);\n+               Insert_Node := Decl;\n+               Next (Decl);\n+            end loop;\n+         end if;\n+\n+         --  The processing of preconditions is done in reverse order (body\n+         --  first) because each pragma Check equivalent is inserted at the\n+         --  top of the declarations. This ensures that the final order is\n+         --  consistent with following diagram:\n+\n+         --    <inherited preconditions>\n+         --    <preconditions from spec>\n+         --    <preconditions from body>\n+\n+         Process_Preconditions_For (Body_Id);\n+\n+         if Present (Spec_Id) then\n+            Process_Preconditions_For (Spec_Id);\n+            Process_Inherited_Preconditions;\n+         end if;\n+      end Process_Preconditions;\n+\n+      --  Local variables\n+\n+      Restore_Scope : Boolean := False;\n+      Result        : Entity_Id;\n+      Stmts         : List_Id := No_List;\n+      Subp_Id       : Entity_Id;\n+\n+   --  Start of processing for Expand_Subprogram_Contract\n+\n+   begin\n+      --  Obtain the entity of the initial declaration\n+\n+      if Present (Spec_Id) then\n+         Subp_Id := Spec_Id;\n+      else\n+         Subp_Id := Body_Id;\n+      end if;\n+\n+      --  Do not perform expansion activity when it is not needed\n+\n+      if not Expander_Active then\n+         return;\n+\n+      --  ASIS requires an unaltered tree\n+\n+      elsif ASIS_Mode then\n+         return;\n+\n+      --  GNATprove does not need the executable semantics of a contract\n+\n+      elsif GNATprove_Mode then\n+         return;\n+\n+      --  The contract of a generic subprogram or one declared in a generic\n+      --  context is not expanded as the corresponding instance will provide\n+      --  the executable semantics of the contract.\n+\n+      elsif Is_Generic_Subprogram (Subp_Id) or else Inside_A_Generic then\n+         return;\n+\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed. This is a small optimization.\n+\n+      elsif not Has_Significant_Contract (Subp_Id) then\n+         return;\n+\n+      --  The contract of an ignored Ghost subprogram does not need expansion\n+      --  because the subprogram and all calls to it will be removed.\n+\n+      elsif Is_Ignored_Ghost_Entity (Subp_Id) then\n+         return;\n+      end if;\n+\n+      --  Do not re-expand the same contract. This scenario occurs when a\n+      --  construct is rewritten into something else during its analysis\n+      --  (expression functions for instance).\n+\n+      if Has_Expanded_Contract (Subp_Id) then\n+         return;\n+\n+      --  Otherwise mark the subprogram\n+\n+      else\n+         Set_Has_Expanded_Contract (Subp_Id);\n+      end if;\n+\n+      --  Ensure that the formal parameters are visible when expanding all\n+      --  contract items.\n+\n+      if not In_Open_Scopes (Subp_Id) then\n+         Restore_Scope := True;\n+         Push_Scope (Subp_Id);\n+\n+         if Is_Generic_Subprogram (Subp_Id) then\n+            Install_Generic_Formals (Subp_Id);\n+         else\n+            Install_Formals (Subp_Id);\n+         end if;\n+      end if;\n+\n+      --  The expansion of a subprogram contract involves the creation of Check\n+      --  pragmas to verify the contract assertions of the spec and body in a\n+      --  particular order. The order is as follows:\n+\n+      --    function Example (...) return ... is\n+      --       procedure _Postconditions (...) is\n+      --       begin\n+      --          <refined postconditions from body>\n+      --          <postconditions from body>\n+      --          <postconditions from spec>\n+      --          <inherited postconditions>\n+      --          <contract case consequences>\n+      --          <invariant check of function result>\n+      --          <invariant and predicate checks of parameters>\n+      --       end _Postconditions;\n+\n+      --       <inherited preconditions>\n+      --       <preconditions from spec>\n+      --       <preconditions from body>\n+      --       <contract case conditions>\n+\n+      --       <source declarations>\n+      --    begin\n+      --       <source statements>\n+\n+      --       _Preconditions (Result);\n+      --       return Result;\n+      --    end Example;\n+\n+      --  Routine _Postconditions holds all contract assertions that must be\n+      --  verified on exit from the related subprogram.\n+\n+      --  Step 1: Handle all preconditions. This action must come before the\n+      --  processing of pragma Contract_Cases because the pragma prepends items\n+      --  to the body declarations.\n+\n+      Process_Preconditions;\n+\n+      --  Step 2: Handle all postconditions. This action must come before the\n+      --  processing of pragma Contract_Cases because the pragma appends items\n+      --  to list Stmts.\n+\n+      Process_Postconditions (Stmts);\n+\n+      --  Step 3: Handle pragma Contract_Cases. This action must come before\n+      --  the processing of invariants and predicates because those append\n+      --  items to list Smts.\n+\n+      Process_Contract_Cases (Stmts);\n+\n+      --  Step 4: Apply invariant and predicate checks on a function result and\n+      --  all formals. The resulting checks are accumulated in list Stmts.\n+\n+      Add_Invariant_And_Predicate_Checks (Subp_Id, Stmts, Result);\n+\n+      --  Step 5: Construct procedure _Postconditions\n+\n+      Build_Postconditions_Procedure (Subp_Id, Stmts, Result);\n+\n+      if Restore_Scope then\n+         End_Scope;\n+      end if;\n+   end Expand_Subprogram_Contract;\n+\n+   ---------------------------------\n+   -- Inherit_Subprogram_Contract --\n+   ---------------------------------\n+\n+   procedure Inherit_Subprogram_Contract\n+     (Subp      : Entity_Id;\n+      From_Subp : Entity_Id)\n+   is\n+      procedure Inherit_Pragma (Prag_Id : Pragma_Id);\n+      --  Propagate a pragma denoted by Prag_Id from From_Subp's contract to\n+      --  Subp's contract.\n+\n+      --------------------\n+      -- Inherit_Pragma --\n+      --------------------\n+\n+      procedure Inherit_Pragma (Prag_Id : Pragma_Id) is\n+         Prag     : constant Node_Id := Get_Pragma (From_Subp, Prag_Id);\n+         New_Prag : Node_Id;\n+\n+      begin\n+         --  A pragma cannot be part of more than one First_Pragma/Next_Pragma\n+         --  chains, therefore the node must be replicated. The new pragma is\n+         --  flagged is inherited for distrinction purposes.\n+\n+         if Present (Prag) then\n+            New_Prag := New_Copy_Tree (Prag);\n+            Set_Is_Inherited (New_Prag);\n+\n+            Add_Contract_Item (New_Prag, Subp);\n+         end if;\n+      end Inherit_Pragma;\n+\n+   --   Start of processing for Inherit_Subprogram_Contract\n+\n+   begin\n+      --  Inheritance is carried out only when both entities are subprograms\n+      --  with contracts.\n+\n+      if Is_Subprogram_Or_Generic_Subprogram (Subp)\n+        and then Is_Subprogram_Or_Generic_Subprogram (From_Subp)\n+        and then Present (Contract (From_Subp))\n+      then\n+         Inherit_Pragma (Pragma_Extensions_Visible);\n+      end if;\n+   end Inherit_Subprogram_Contract;\n+\n+   -------------------------------------\n+   -- Instantiate_Subprogram_Contract --\n+   -------------------------------------\n+\n+   procedure Instantiate_Subprogram_Contract (Templ : Node_Id; L : List_Id) is\n+      procedure Instantiate_Pragmas (First_Prag : Node_Id);\n+      --  Instantiate all contract-related source pragmas found in the list\n+      --  starting with pragma First_Prag. Each instantiated pragma is added\n+      --  to list L.\n+\n+      -------------------------\n+      -- Instantiate_Pragmas --\n+      -------------------------\n+\n+      procedure Instantiate_Pragmas (First_Prag : Node_Id) is\n+         Inst_Prag : Node_Id;\n+         Prag      : Node_Id;\n+\n+      begin\n+         Prag := First_Prag;\n+         while Present (Prag) loop\n+            if Is_Generic_Contract_Pragma (Prag) then\n+               Inst_Prag :=\n+                 Copy_Generic_Node (Prag, Empty, Instantiating => True);\n+\n+               Set_Analyzed (Inst_Prag, False);\n+               Append_To (L, Inst_Prag);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end Instantiate_Pragmas;\n+\n+      --  Local variables\n+\n+      Items : constant Node_Id := Contract (Defining_Entity (Templ));\n+\n+   --  Start of processing for Instantiate_Subprogram_Contract\n+\n+   begin\n+      if Present (Items) then\n+         Instantiate_Pragmas (Pre_Post_Conditions (Items));\n+         Instantiate_Pragmas (Contract_Test_Cases (Items));\n+         Instantiate_Pragmas (Classifications     (Items));\n+      end if;\n+   end Instantiate_Subprogram_Contract;\n+\n+   ----------------------------------------\n+   -- Save_Global_References_In_Contract --\n+   ----------------------------------------\n+\n+   procedure Save_Global_References_In_Contract\n+     (Templ  : Node_Id;\n+      Gen_Id : Entity_Id)\n+   is\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n+      --  Save all global references in contract-related source pragmas found\n+      --  in the list starting with pragma First_Prag.\n+\n+      ------------------------------------\n+      -- Save_Global_References_In_List --\n+      ------------------------------------\n+\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n+         Prag : Node_Id;\n+\n+      begin\n+         Prag := First_Prag;\n+         while Present (Prag) loop\n+            if Is_Generic_Contract_Pragma (Prag) then\n+               Save_Global_References (Prag);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end Save_Global_References_In_List;\n+\n+      --  Local variables\n+\n+      Items : constant Node_Id := Contract (Defining_Entity (Templ));\n+\n+   --  Start of processing for Save_Global_References_In_Contract\n+\n+   begin\n+      --  The entity of the analyzed generic copy must be on the scope stack\n+      --  to ensure proper detection of global references.\n+\n+      Push_Scope (Gen_Id);\n+\n+      if Permits_Aspect_Specifications (Templ)\n+        and then Has_Aspects (Templ)\n+      then\n+         Save_Global_References_In_Aspects (Templ);\n+      end if;\n+\n+      if Present (Items) then\n+         Save_Global_References_In_List (Pre_Post_Conditions (Items));\n+         Save_Global_References_In_List (Contract_Test_Cases (Items));\n+         Save_Global_References_In_List (Classifications     (Items));\n+      end if;\n+\n+      Pop_Scope;\n+   end Save_Global_References_In_Contract;\n+\n+end Contracts;"}, {"sha": "beeed57a7980c371f2214b5f901b40d0cf5710bc", "filename": "gcc/ada/contracts.ads", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -0,0 +1,156 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                            C O N T R A C T S                             --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines that perform analysis and expansion of\n+--  various contracts.\n+\n+with Types; use Types;\n+\n+package Contracts is\n+\n+   procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n+   --  Add pragma Prag to the contract of a constant, entry, package [body],\n+   --  subprogram [body] or variable denoted by Id. The following are valid\n+   --  pragmas:\n+   --    Abstract_State\n+   --    Async_Readers\n+   --    Async_Writers\n+   --    Constant_After_Elaboration\n+   --    Contract_Cases\n+   --    Depends\n+   --    Effective_Reads\n+   --    Effective_Writes\n+   --    Extensions_Visible\n+   --    Global\n+   --    Initial_Condition\n+   --    Initializes\n+   --    Part_Of\n+   --    Postcondition\n+   --    Precondition\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Refined_States\n+   --    Test_Case\n+   --    Volatile_Function\n+\n+   procedure Analyze_Enclosing_Package_Body_Contract (Body_Decl : Node_Id);\n+   --  Analyze the contract of the nearest package body (if any) which encloses\n+   --  package or subprogram body Body_Decl.\n+\n+   procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n+   --  Analyze all delayed pragmas chained on the contract of object Obj_Id as\n+   --  if they appeared at the end of the declarative region. The pragmas to be\n+   --  considered are:\n+   --    Async_Readers\n+   --    Async_Writers\n+   --    Effective_Reads\n+   --    Effective_Writes\n+   --    Part_Of\n+\n+   procedure Analyze_Package_Body_Contract\n+     (Body_Id   : Entity_Id;\n+      Freeze_Id : Entity_Id := Empty);\n+   --  Analyze all delayed aspects chained on the contract of package body\n+   --  Body_Id as if they appeared at the end of a declarative region. The\n+   --  aspects that are considered are:\n+   --    Refined_State\n+   --\n+   --  Freeze_Id is the entity of a [generic] package body or a [generic]\n+   --  subprogram body which \"feezes\" the contract of Body_Id.\n+\n+   procedure Analyze_Package_Contract (Pack_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of package Pack_Id\n+   --  as if they appeared at the end of a declarative region. The aspects\n+   --  that are considered are:\n+   --    Initial_Condition\n+   --    Initializes\n+   --    Part_Of\n+\n+   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of subprogram body\n+   --  Body_Id as if they appeared at the end of a declarative region. Aspects\n+   --  in question are:\n+   --    Contract_Cases   (stand alone body)\n+   --    Depends          (stand alone body)\n+   --    Global           (stand alone body)\n+   --    Postcondition    (stand alone body)\n+   --    Precondition     (stand alone body)\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Test_Case        (stand alone body)\n+\n+   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of subprogram\n+   --  Subp_Id as if they appeared at the end of a declarative region. The\n+   --  aspects in question are:\n+   --    Contract_Cases\n+   --    Depends\n+   --    Global\n+   --    Postcondition\n+   --    Precondition\n+   --    Test_Case\n+\n+   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of a subprogram body\n+   --  stub Stub_Id as if they appeared at the end of a declarative region. The\n+   --  aspects in question are:\n+   --    Contract_Cases\n+   --    Depends\n+   --    Global\n+   --    Postcondition\n+   --    Precondition\n+   --    Refined_Depends\n+   --    Refined_Global\n+   --    Refined_Post\n+   --    Test_Case\n+\n+   procedure Create_Generic_Contract (Unit : Node_Id);\n+   --  Create a contract node for a generic package, generic subprogram or a\n+   --  generic body denoted by Unit by collecting all source contract-related\n+   --  pragmas in the contract of the unit.\n+\n+   procedure Inherit_Subprogram_Contract\n+     (Subp      : Entity_Id;\n+      From_Subp : Entity_Id);\n+   --  Inherit relevant contract items from source subprogram From_Subp. Subp\n+   --  denotes the destination subprogram. The inherited items are:\n+   --    Extensions_Visible\n+   --  ??? it would be nice if this routine handles Pre'Class and Post'Class\n+\n+   procedure Instantiate_Subprogram_Contract (Templ : Node_Id; L : List_Id);\n+   --  Instantiate all source pragmas found in the contract of the generic\n+   --  subprogram declaration template denoted by Templ. The instantiated\n+   --  pragmas are added to list L.\n+\n+   procedure Save_Global_References_In_Contract\n+     (Templ  : Node_Id;\n+      Gen_Id : Entity_Id);\n+   --  Save all global references found within the aspect specifications and\n+   --  the contract-related source pragmas assocated with generic template\n+   --  Templ. Gen_Id denotes the entity of the analyzed generic copy.\n+\n+end Contracts;"}, {"sha": "1e142aa96f6765394aa03b59d8450bca22b4df05", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 52, "deletions": 1310, "changes": 1362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -23,60 +23,59 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;    use Atree;\n-with Checks;   use Checks;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Errout;   use Errout;\n-with Elists;   use Elists;\n-with Exp_Aggr; use Exp_Aggr;\n-with Exp_Atag; use Exp_Atag;\n-with Exp_Ch2;  use Exp_Ch2;\n-with Exp_Ch3;  use Exp_Ch3;\n-with Exp_Ch7;  use Exp_Ch7;\n-with Exp_Ch9;  use Exp_Ch9;\n-with Exp_Dbug; use Exp_Dbug;\n-with Exp_Disp; use Exp_Disp;\n-with Exp_Dist; use Exp_Dist;\n-with Exp_Intr; use Exp_Intr;\n-with Exp_Pakd; use Exp_Pakd;\n-with Exp_Prag; use Exp_Prag;\n-with Exp_Tss;  use Exp_Tss;\n-with Exp_Unst; use Exp_Unst;\n-with Exp_Util; use Exp_Util;\n-with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n-with Inline;   use Inline;\n-with Lib;      use Lib;\n-with Namet;    use Namet;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Dim;  use Sem_Dim;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Dist; use Sem_Dist;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Mech; use Sem_Mech;\n-with Sem_Res;  use Sem_Res;\n-with Sem_SCIL; use Sem_SCIL;\n-with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n-with Snames;   use Snames;\n-with Stand;    use Stand;\n-with Stringt;  use Stringt;\n+with Atree;     use Atree;\n+with Checks;    use Checks;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Errout;    use Errout;\n+with Elists;    use Elists;\n+with Exp_Aggr;  use Exp_Aggr;\n+with Exp_Atag;  use Exp_Atag;\n+with Exp_Ch2;   use Exp_Ch2;\n+with Exp_Ch3;   use Exp_Ch3;\n+with Exp_Ch7;   use Exp_Ch7;\n+with Exp_Ch9;   use Exp_Ch9;\n+with Exp_Dbug;  use Exp_Dbug;\n+with Exp_Disp;  use Exp_Disp;\n+with Exp_Dist;  use Exp_Dist;\n+with Exp_Intr;  use Exp_Intr;\n+with Exp_Pakd;  use Exp_Pakd;\n+with Exp_Tss;   use Exp_Tss;\n+with Exp_Unst;  use Exp_Unst;\n+with Exp_Util;  use Exp_Util;\n+with Freeze;    use Freeze;\n+with Ghost;     use Ghost;\n+with Inline;    use Inline;\n+with Lib;       use Lib;\n+with Namet;     use Namet;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Dim;   use Sem_Dim;\n+with Sem_Disp;  use Sem_Disp;\n+with Sem_Dist;  use Sem_Dist;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Mech;  use Sem_Mech;\n+with Sem_Res;   use Sem_Res;\n+with Sem_SCIL;  use Sem_SCIL;\n+with Sem_Util;  use Sem_Util;\n+with Sinfo;     use Sinfo;\n+with Snames;    use Snames;\n+with Stand;     use Stand;\n with Table;\n-with Targparm; use Targparm;\n-with Tbuild;   use Tbuild;\n-with Uintp;    use Uintp;\n-with Validsw;  use Validsw;\n+with Targparm;  use Targparm;\n+with Tbuild;    use Tbuild;\n+with Uintp;     use Uintp;\n+with Validsw;   use Validsw;\n \n package body Exp_Ch6 is\n \n@@ -6773,1263 +6772,6 @@ package body Exp_Ch6 is\n       end if;\n    end Expand_Simple_Function_Return;\n \n-   --------------------------------\n-   -- Expand_Subprogram_Contract --\n-   --------------------------------\n-\n-   procedure Expand_Subprogram_Contract (N : Node_Id) is\n-      Body_Id : constant Entity_Id := Defining_Entity (N);\n-      Spec_Id : constant Entity_Id := Corresponding_Spec (N);\n-\n-      procedure Add_Invariant_And_Predicate_Checks\n-        (Subp_Id : Entity_Id;\n-         Stmts   : in out List_Id;\n-         Result  : out Node_Id);\n-      --  Process the result of function Subp_Id (if applicable) and all its\n-      --  formals. Add invariant and predicate checks where applicable. The\n-      --  routine appends all the checks to list Stmts. If Subp_Id denotes a\n-      --  function, Result contains the entity of parameter _Result, to be\n-      --  used in the creation of procedure _Postconditions.\n-\n-      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id);\n-      --  Append a node to a list. If there is no list, create a new one. When\n-      --  the item denotes a pragma, it is added to the list only when it is\n-      --  enabled.\n-\n-      procedure Build_Postconditions_Procedure\n-        (Subp_Id : Entity_Id;\n-         Stmts   : List_Id;\n-         Result  : Entity_Id);\n-      --  Create the body of procedure _Postconditions which handles various\n-      --  assertion actions on exit from subprogram Subp_Id. Stmts is the list\n-      --  of statements to be checked on exit. Parameter Result is the entity\n-      --  of parameter _Result when Subp_Id denotes a function.\n-\n-      function Build_Pragma_Check_Equivalent\n-        (Prag     : Node_Id;\n-         Subp_Id  : Entity_Id := Empty;\n-         Inher_Id : Entity_Id := Empty) return Node_Id;\n-      --  Transform a [refined] pre- or postcondition denoted by Prag into an\n-      --  equivalent pragma Check. When the pre- or postcondition is inherited,\n-      --  the routine corrects the references of all formals of Inher_Id to\n-      --  point to the formals of Subp_Id.\n-\n-      procedure Process_Contract_Cases (Stmts : in out List_Id);\n-      --  Process pragma Contract_Cases. This routine prepends items to the\n-      --  body declarations and appends items to list Stmts.\n-\n-      procedure Process_Postconditions (Stmts : in out List_Id);\n-      --  Collect all [inherited] spec and body postconditions and accumulate\n-      --  their pragma Check equivalents in list Stmts.\n-\n-      procedure Process_Preconditions;\n-      --  Collect all [inherited] spec and body preconditions and prepend their\n-      --  pragma Check equivalents to the declarations of the body.\n-\n-      ----------------------------------------\n-      -- Add_Invariant_And_Predicate_Checks --\n-      ----------------------------------------\n-\n-      procedure Add_Invariant_And_Predicate_Checks\n-        (Subp_Id : Entity_Id;\n-         Stmts   : in out List_Id;\n-         Result  : out Node_Id)\n-      is\n-         procedure Add_Invariant_Access_Checks (Id : Entity_Id);\n-         --  Id denotes the return value of a function or a formal parameter.\n-         --  Add an invariant check if the type of Id is access to a type with\n-         --  invariants. The routine appends the generated code to Stmts.\n-\n-         function Invariant_Checks_OK (Typ : Entity_Id) return Boolean;\n-         --  Determine whether type Typ can benefit from invariant checks. To\n-         --  qualify, the type must have a non-null invariant procedure and\n-         --  subprogram Subp_Id must appear visible from the point of view of\n-         --  the type.\n-\n-         ---------------------------------\n-         -- Add_Invariant_Access_Checks --\n-         ---------------------------------\n-\n-         procedure Add_Invariant_Access_Checks (Id : Entity_Id) is\n-            Loc : constant Source_Ptr := Sloc (N);\n-            Ref : Node_Id;\n-            Typ : Entity_Id;\n-\n-         begin\n-            Typ := Etype (Id);\n-\n-            if Is_Access_Type (Typ) and then not Is_Access_Constant (Typ) then\n-               Typ := Designated_Type (Typ);\n-\n-               if Invariant_Checks_OK (Typ) then\n-                  Ref :=\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix => New_Occurrence_Of (Id, Loc));\n-                  Set_Etype (Ref, Typ);\n-\n-                  --  Generate:\n-                  --    if <Id> /= null then\n-                  --       <invariant_call (<Ref>)>\n-                  --    end if;\n-\n-                  Append_Enabled_Item\n-                    (Item =>\n-                       Make_If_Statement (Loc,\n-                         Condition =>\n-                           Make_Op_Ne (Loc,\n-                             Left_Opnd  => New_Occurrence_Of (Id, Loc),\n-                             Right_Opnd => Make_Null (Loc)),\n-                         Then_Statements => New_List (\n-                           Make_Invariant_Call (Ref))),\n-                     List => Stmts);\n-               end if;\n-            end if;\n-         end Add_Invariant_Access_Checks;\n-\n-         -------------------------\n-         -- Invariant_Checks_OK --\n-         -------------------------\n-\n-         function Invariant_Checks_OK (Typ : Entity_Id) return Boolean is\n-            function Has_Null_Body (Proc_Id : Entity_Id) return Boolean;\n-            --  Determine whether the body of procedure Proc_Id contains a sole\n-            --  null statement, possibly followed by an optional return.\n-\n-            function Has_Public_Visibility_Of_Subprogram return Boolean;\n-            --  Determine whether type Typ has public visibility of subprogram\n-            --  Subp_Id.\n-\n-            -------------------\n-            -- Has_Null_Body --\n-            -------------------\n-\n-            function Has_Null_Body (Proc_Id : Entity_Id) return Boolean is\n-               Body_Id : Entity_Id;\n-               Decl    : Node_Id;\n-               Spec    : Node_Id;\n-               Stmt1   : Node_Id;\n-               Stmt2   : Node_Id;\n-\n-            begin\n-               Spec := Parent (Proc_Id);\n-               Decl := Parent (Spec);\n-\n-               --  Retrieve the entity of the invariant procedure body\n-\n-               if Nkind (Spec) = N_Procedure_Specification\n-                 and then Nkind (Decl) = N_Subprogram_Declaration\n-               then\n-                  Body_Id := Corresponding_Body (Decl);\n-\n-               --  The body acts as a spec\n-\n-               else\n-                  Body_Id := Proc_Id;\n-               end if;\n-\n-               --  The body will be generated later\n-\n-               if No (Body_Id) then\n-                  return False;\n-               end if;\n-\n-               Spec := Parent (Body_Id);\n-               Decl := Parent (Spec);\n-\n-               pragma Assert\n-                 (Nkind (Spec) = N_Procedure_Specification\n-                   and then Nkind (Decl) = N_Subprogram_Body);\n-\n-               Stmt1 := First (Statements (Handled_Statement_Sequence (Decl)));\n-\n-               --  Look for a null statement followed by an optional return\n-               --  statement.\n-\n-               if Nkind (Stmt1) = N_Null_Statement then\n-                  Stmt2 := Next (Stmt1);\n-\n-                  if Present (Stmt2) then\n-                     return Nkind (Stmt2) = N_Simple_Return_Statement;\n-                  else\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               return False;\n-            end Has_Null_Body;\n-\n-            -----------------------------------------\n-            -- Has_Public_Visibility_Of_Subprogram --\n-            -----------------------------------------\n-\n-            function Has_Public_Visibility_Of_Subprogram return Boolean is\n-               Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n-\n-            begin\n-               --  An Initialization procedure must be considered visible even\n-               --  though it is internally generated.\n-\n-               if Is_Init_Proc (Defining_Entity (Subp_Decl)) then\n-                  return True;\n-\n-               elsif Ekind (Scope (Typ)) /= E_Package then\n-                  return False;\n-\n-               --  Internally generated code is never publicly visible except\n-               --  for a subprogram that is the implementation of an expression\n-               --  function. In that case the visibility is determined by the\n-               --  last check.\n-\n-               elsif not Comes_From_Source (Subp_Decl)\n-                 and then\n-                   (Nkind (Original_Node (Subp_Decl)) /= N_Expression_Function\n-                      or else not\n-                        Comes_From_Source (Defining_Entity (Subp_Decl)))\n-               then\n-                  return False;\n-\n-               --  Determine whether the subprogram is declared in the visible\n-               --  declarations of the package containing the type.\n-\n-               else\n-                  return List_Containing (Subp_Decl) =\n-                    Visible_Declarations\n-                      (Specification (Unit_Declaration_Node (Scope (Typ))));\n-               end if;\n-            end Has_Public_Visibility_Of_Subprogram;\n-\n-         --  Start of processing for Invariant_Checks_OK\n-\n-         begin\n-            return\n-              Has_Invariants (Typ)\n-                and then Present (Invariant_Procedure (Typ))\n-                and then not Has_Null_Body (Invariant_Procedure (Typ))\n-                and then Has_Public_Visibility_Of_Subprogram;\n-         end Invariant_Checks_OK;\n-\n-         --  Local variables\n-\n-         Loc : constant Source_Ptr := Sloc (N);\n-         --  Source location of subprogram contract\n-\n-         Formal : Entity_Id;\n-         Typ    : Entity_Id;\n-\n-      --  Start of processing for Add_Invariant_And_Predicate_Checks\n-\n-      begin\n-         Result := Empty;\n-\n-         --  Process the result of a function\n-\n-         if Ekind (Subp_Id) = E_Function then\n-            Typ := Etype (Subp_Id);\n-\n-            --  Generate _Result which is used in procedure _Postconditions to\n-            --  verify the return value.\n-\n-            Result := Make_Defining_Identifier (Loc, Name_uResult);\n-            Set_Etype (Result, Typ);\n-\n-            --  Add an invariant check when the return type has invariants and\n-            --  the related function is visible to the outside.\n-\n-            if Invariant_Checks_OK (Typ) then\n-               Append_Enabled_Item\n-                 (Item =>\n-                    Make_Invariant_Call (New_Occurrence_Of (Result, Loc)),\n-                  List => Stmts);\n-            end if;\n-\n-            --  Add an invariant check when the return type is an access to a\n-            --  type with invariants.\n-\n-            Add_Invariant_Access_Checks (Result);\n-         end if;\n-\n-         --  Add invariant and predicates for all formals that qualify\n-\n-         Formal := First_Formal (Subp_Id);\n-         while Present (Formal) loop\n-            Typ := Etype (Formal);\n-\n-            if Ekind (Formal) /= E_In_Parameter\n-              or else Is_Access_Type (Typ)\n-            then\n-               if Invariant_Checks_OK (Typ) then\n-                  Append_Enabled_Item\n-                    (Item =>\n-                       Make_Invariant_Call (New_Occurrence_Of (Formal, Loc)),\n-                     List => Stmts);\n-               end if;\n-\n-               Add_Invariant_Access_Checks (Formal);\n-\n-               --  Note: we used to add predicate checks for OUT and IN OUT\n-               --  formals here, but that was misguided, since such checks are\n-               --  performed on the caller side, based on the predicate of the\n-               --  actual, rather than the predicate of the formal.\n-\n-            end if;\n-\n-            Next_Formal (Formal);\n-         end loop;\n-      end Add_Invariant_And_Predicate_Checks;\n-\n-      -------------------------\n-      -- Append_Enabled_Item --\n-      -------------------------\n-\n-      procedure Append_Enabled_Item (Item : Node_Id; List : in out List_Id) is\n-      begin\n-         --  Do not chain ignored or disabled pragmas\n-\n-         if Nkind (Item) = N_Pragma\n-           and then (Is_Ignored (Item) or else Is_Disabled (Item))\n-         then\n-            null;\n-\n-         --  Otherwise, add the item\n-\n-         else\n-            if No (List) then\n-               List := New_List;\n-            end if;\n-\n-            --  If the pragma is a conjunct in a composite postcondition, it\n-            --  has been processed in reverse order. In the postcondition body\n-            --  if must appear before the others.\n-\n-            if Nkind (Item) = N_Pragma\n-              and then From_Aspect_Specification (Item)\n-              and then Split_PPC (Item)\n-            then\n-               Prepend (Item, List);\n-            else\n-               Append (Item, List);\n-            end if;\n-         end if;\n-      end Append_Enabled_Item;\n-\n-      ------------------------------------\n-      -- Build_Postconditions_Procedure --\n-      ------------------------------------\n-\n-      procedure Build_Postconditions_Procedure\n-        (Subp_Id : Entity_Id;\n-         Stmts   : List_Id;\n-         Result  : Entity_Id)\n-      is\n-         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id);\n-         --  Insert node Stmt before the first source declaration of the\n-         --  related subprogram's body. If no such declaration exists, Stmt\n-         --  becomes the last declaration.\n-\n-         --------------------------------------------\n-         -- Insert_Before_First_Source_Declaration --\n-         --------------------------------------------\n-\n-         procedure Insert_Before_First_Source_Declaration (Stmt : Node_Id) is\n-            Decls : constant List_Id := Declarations (N);\n-            Decl  : Node_Id;\n-\n-         begin\n-            --  Inspect the declarations of the related subprogram body looking\n-            --  for the first source declaration.\n-\n-            if Present (Decls) then\n-               Decl := First (Decls);\n-               while Present (Decl) loop\n-                  if Comes_From_Source (Decl) then\n-                     Insert_Before (Decl, Stmt);\n-                     return;\n-                  end if;\n-\n-                  Next (Decl);\n-               end loop;\n-\n-               --  If we get there, then the subprogram body lacks any source\n-               --  declarations. The body of _Postconditions now acts as the\n-               --  last declaration.\n-\n-               Append (Stmt, Decls);\n-\n-            --  Ensure that the body has a declaration list\n-\n-            else\n-               Set_Declarations (N, New_List (Stmt));\n-            end if;\n-         end Insert_Before_First_Source_Declaration;\n-\n-         --  Local variables\n-\n-         Loc      : constant Source_Ptr := Sloc (N);\n-         Params   : List_Id := No_List;\n-         Proc_Bod : Node_Id;\n-         Proc_Id  : Entity_Id;\n-\n-      --  Start of processing for Build_Postconditions_Procedure\n-\n-      begin\n-         --  Nothing to do if there are no actions to check on exit\n-\n-         if No (Stmts) then\n-            return;\n-         end if;\n-\n-         Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n-         Set_Debug_Info_Needed   (Proc_Id);\n-         Set_Postconditions_Proc (Subp_Id, Proc_Id);\n-\n-         --  The related subprogram is a function, create the specification of\n-         --  parameter _Result.\n-\n-         if Present (Result) then\n-            Params := New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Result,\n-                Parameter_Type      =>\n-                  New_Occurrence_Of (Etype (Result), Loc)));\n-         end if;\n-\n-         --  Insert _Postconditions before the first source declaration of the\n-         --  body. This ensures that the body will not cause any premature\n-         --  freezing as it may mention types:\n-\n-         --    procedure Proc (Obj : Array_Typ) is\n-         --       procedure _postconditions is\n-         --       begin\n-         --          ... Obj ...\n-         --       end _postconditions;\n-\n-         --       subtype T is Array_Typ (Obj'First (1) .. Obj'Last (1));\n-         --    begin\n-\n-         --  In the example above, Obj is of type T but the incorrect placement\n-         --  of _Postconditions will cause a crash in gigi due to an out of\n-         --  order reference. The body of _Postconditions must be placed after\n-         --  the declaration of Temp to preserve correct visibility.\n-\n-         --  Set an explicit End_Lavel to override the sloc of the implicit\n-         --  RETURN statement, and prevent it from inheriting the sloc of one\n-         --  the postconditions: this would cause confusing debug into to be\n-         --  produced, interfering with coverage analysis tools.\n-\n-         Proc_Bod :=\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name       => Proc_Id,\n-                 Parameter_Specifications => Params),\n-\n-             Declarations               => Empty_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc,\n-                 Statements => Stmts,\n-                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id))));\n-\n-         Insert_Before_First_Source_Declaration (Proc_Bod);\n-         Analyze (Proc_Bod);\n-      end Build_Postconditions_Procedure;\n-\n-      -----------------------------------\n-      -- Build_Pragma_Check_Equivalent --\n-      -----------------------------------\n-\n-      function Build_Pragma_Check_Equivalent\n-        (Prag     : Node_Id;\n-         Subp_Id  : Entity_Id := Empty;\n-         Inher_Id : Entity_Id := Empty) return Node_Id\n-      is\n-         function Suppress_Reference (N : Node_Id) return Traverse_Result;\n-         --  Detect whether node N references a formal parameter subject to\n-         --  pragma Unreferenced. If this is the case, set Comes_From_Source\n-         --  to False to suppress the generation of a reference when analyzing\n-         --  N later on.\n-\n-         ------------------------\n-         -- Suppress_Reference --\n-         ------------------------\n-\n-         function Suppress_Reference (N : Node_Id) return Traverse_Result is\n-            Formal : Entity_Id;\n-\n-         begin\n-            if Is_Entity_Name (N) and then Present (Entity (N)) then\n-               Formal := Entity (N);\n-\n-               --  The formal parameter is subject to pragma Unreferenced.\n-               --  Prevent the generation of a reference by resetting the\n-               --  Comes_From_Source flag.\n-\n-               if Is_Formal (Formal)\n-                 and then Has_Pragma_Unreferenced (Formal)\n-               then\n-                  Set_Comes_From_Source (N, False);\n-               end if;\n-            end if;\n-\n-            return OK;\n-         end Suppress_Reference;\n-\n-         procedure Suppress_References is\n-           new Traverse_Proc (Suppress_Reference);\n-\n-         --  Local variables\n-\n-         Loc          : constant Source_Ptr := Sloc (Prag);\n-         Prag_Nam     : constant Name_Id    := Pragma_Name (Prag);\n-         Check_Prag   : Node_Id;\n-         Formals_Map  : Elist_Id;\n-         Inher_Formal : Entity_Id;\n-         Msg_Arg      : Node_Id;\n-         Nam          : Name_Id;\n-         Subp_Formal  : Entity_Id;\n-\n-      --  Start of processing for Build_Pragma_Check_Equivalent\n-\n-      begin\n-         Formals_Map := No_Elist;\n-\n-         --  When the pre- or postcondition is inherited, map the formals of\n-         --  the inherited subprogram to those of the current subprogram.\n-\n-         if Present (Inher_Id) then\n-            pragma Assert (Present (Subp_Id));\n-\n-            Formals_Map := New_Elmt_List;\n-\n-            --  Create a relation <inherited formal> => <subprogram formal>\n-\n-            Inher_Formal := First_Formal (Inher_Id);\n-            Subp_Formal  := First_Formal (Subp_Id);\n-            while Present (Inher_Formal) and then Present (Subp_Formal) loop\n-               Append_Elmt (Inher_Formal, Formals_Map);\n-               Append_Elmt (Subp_Formal, Formals_Map);\n-\n-               Next_Formal (Inher_Formal);\n-               Next_Formal (Subp_Formal);\n-            end loop;\n-         end if;\n-\n-         --  Copy the original pragma while performing substitutions (if\n-         --  applicable).\n-\n-         Check_Prag :=\n-           New_Copy_Tree\n-             (Source    => Prag,\n-              Map       => Formals_Map,\n-              New_Scope => Current_Scope);\n-\n-         --  Mark the pragma as being internally generated and reset the\n-         --  Analyzed flag.\n-\n-         Set_Analyzed          (Check_Prag, False);\n-         Set_Comes_From_Source (Check_Prag, False);\n-\n-         --  The tree of the original pragma may contain references to the\n-         --  formal parameters of the related subprogram. At the same time\n-         --  the corresponding body may mark the formals as unreferenced:\n-\n-         --     procedure Proc (Formal : ...)\n-         --       with Pre => Formal ...;\n-\n-         --     procedure Proc (Formal : ...) is\n-         --        pragma Unreferenced (Formal);\n-         --     ...\n-\n-         --  This creates problems because all pragma Check equivalents are\n-         --  analyzed at the end of the body declarations. Since all source\n-         --  references have already been accounted for, reset any references\n-         --  to such formals in the generated pragma Check equivalent.\n-\n-         Suppress_References (Check_Prag);\n-\n-         if Present (Corresponding_Aspect (Prag)) then\n-            Nam := Chars (Identifier (Corresponding_Aspect (Prag)));\n-         else\n-            Nam := Prag_Nam;\n-         end if;\n-\n-         --  Convert the copy into pragma Check by correcting the name and\n-         --  adding a check_kind argument.\n-\n-         Set_Pragma_Identifier\n-           (Check_Prag, Make_Identifier (Loc, Name_Check));\n-\n-         Prepend_To (Pragma_Argument_Associations (Check_Prag),\n-           Make_Pragma_Argument_Association (Loc,\n-             Expression => Make_Identifier (Loc, Nam)));\n-\n-         --  Update the error message when the pragma is inherited\n-\n-         if Present (Inher_Id) then\n-            Msg_Arg := Last (Pragma_Argument_Associations (Check_Prag));\n-\n-            if Chars (Msg_Arg) = Name_Message then\n-               String_To_Name_Buffer (Strval (Expression (Msg_Arg)));\n-\n-               --  Insert \"inherited\" to improve the error message\n-\n-               if Name_Buffer (1 .. 8) = \"failed p\" then\n-                  Insert_Str_In_Name_Buffer (\"inherited \", 8);\n-                  Set_Strval (Expression (Msg_Arg), String_From_Name_Buffer);\n-               end if;\n-            end if;\n-         end if;\n-\n-         return Check_Prag;\n-      end Build_Pragma_Check_Equivalent;\n-\n-      ----------------------------\n-      -- Process_Contract_Cases --\n-      ----------------------------\n-\n-      procedure Process_Contract_Cases (Stmts : in out List_Id) is\n-         procedure Process_Contract_Cases_For (Subp_Id : Entity_Id);\n-         --  Process pragma Contract_Cases for subprogram Subp_Id\n-\n-         --------------------------------\n-         -- Process_Contract_Cases_For --\n-         --------------------------------\n-\n-         procedure Process_Contract_Cases_For (Subp_Id : Entity_Id) is\n-            Items : constant Node_Id := Contract (Subp_Id);\n-            Prag  : Node_Id;\n-\n-         begin\n-            if Present (Items) then\n-               Prag := Contract_Test_Cases (Items);\n-               while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Contract_Cases then\n-                     Expand_Pragma_Contract_Cases\n-                       (CCs     => Prag,\n-                        Subp_Id => Subp_Id,\n-                        Decls   => Declarations (N),\n-                        Stmts   => Stmts);\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-            end if;\n-         end Process_Contract_Cases_For;\n-\n-      --  Start of processing for Process_Contract_Cases\n-\n-      begin\n-         Process_Contract_Cases_For (Body_Id);\n-\n-         if Present (Spec_Id) then\n-            Process_Contract_Cases_For (Spec_Id);\n-         end if;\n-      end Process_Contract_Cases;\n-\n-      ----------------------------\n-      -- Process_Postconditions --\n-      ----------------------------\n-\n-      procedure Process_Postconditions (Stmts : in out List_Id) is\n-         procedure Process_Body_Postconditions (Post_Nam : Name_Id);\n-         --  Collect all [refined] postconditions of a specific kind denoted\n-         --  by Post_Nam that belong to the body and generate pragma Check\n-         --  equivalents in list Stmts.\n-\n-         procedure Process_Spec_Postconditions;\n-         --  Collect all [inherited] postconditions of the spec and generate\n-         --  pragma Check equivalents in list Stmts.\n-\n-         ---------------------------------\n-         -- Process_Body_Postconditions --\n-         ---------------------------------\n-\n-         procedure Process_Body_Postconditions (Post_Nam : Name_Id) is\n-            Items     : constant Node_Id := Contract (Body_Id);\n-            Unit_Decl : constant Node_Id := Parent (N);\n-            Decl      : Node_Id;\n-            Prag      : Node_Id;\n-\n-         begin\n-            --  Process the contract\n-\n-            if Present (Items) then\n-               Prag := Pre_Post_Conditions (Items);\n-               while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Post_Nam then\n-                     Append_Enabled_Item\n-                       (Item => Build_Pragma_Check_Equivalent (Prag),\n-                        List => Stmts);\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-            end if;\n-\n-            --  The subprogram body being processed is actually the proper body\n-            --  of a stub with a corresponding spec. The subprogram stub may\n-            --  carry a postcondition pragma in which case it must be taken\n-            --  into account. The pragma appears after the stub.\n-\n-            if Present (Spec_Id) and then Nkind (Unit_Decl) = N_Subunit then\n-               Decl := Next (Corresponding_Stub (Unit_Decl));\n-               while Present (Decl) loop\n-\n-                  --  Note that non-matching pragmas are skipped\n-\n-                  if Nkind (Decl) = N_Pragma then\n-                     if Pragma_Name (Decl) = Post_Nam then\n-                        Append_Enabled_Item\n-                          (Item => Build_Pragma_Check_Equivalent (Decl),\n-                           List => Stmts);\n-                     end if;\n-\n-                  --  Skip internally generated code\n-\n-                  elsif not Comes_From_Source (Decl) then\n-                     null;\n-\n-                  --  Postcondition pragmas are usually grouped together. There\n-                  --  is no need to inspect the whole declarative list.\n-\n-                  else\n-                     exit;\n-                  end if;\n-\n-                  Next (Decl);\n-               end loop;\n-            end if;\n-         end Process_Body_Postconditions;\n-\n-         ---------------------------------\n-         -- Process_Spec_Postconditions --\n-         ---------------------------------\n-\n-         procedure Process_Spec_Postconditions is\n-            Subps   : constant Subprogram_List :=\n-                        Inherited_Subprograms (Spec_Id);\n-            Items   : Node_Id;\n-            Prag    : Node_Id;\n-            Subp_Id : Entity_Id;\n-\n-         begin\n-            --  Process the contract\n-\n-            Items := Contract (Spec_Id);\n-\n-            if Present (Items) then\n-               Prag := Pre_Post_Conditions (Items);\n-               while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Postcondition then\n-                     Append_Enabled_Item\n-                       (Item => Build_Pragma_Check_Equivalent (Prag),\n-                        List => Stmts);\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-            end if;\n-\n-            --  Process the contracts of all inherited subprograms, looking for\n-            --  class-wide postconditions.\n-\n-            for Index in Subps'Range loop\n-               Subp_Id := Subps (Index);\n-               Items   := Contract (Subp_Id);\n-\n-               if Present (Items) then\n-                  Prag := Pre_Post_Conditions (Items);\n-                  while Present (Prag) loop\n-                     if Pragma_Name (Prag) = Name_Postcondition\n-                       and then Class_Present (Prag)\n-                     then\n-                        Append_Enabled_Item\n-                          (Item =>\n-                             Build_Pragma_Check_Equivalent\n-                               (Prag     => Prag,\n-                                Subp_Id  => Spec_Id,\n-                                Inher_Id => Subp_Id),\n-                           List => Stmts);\n-                     end if;\n-\n-                     Prag := Next_Pragma (Prag);\n-                  end loop;\n-               end if;\n-            end loop;\n-         end Process_Spec_Postconditions;\n-\n-      --  Start of processing for Process_Postconditions\n-\n-      begin\n-         --  The processing of postconditions is done in reverse order (body\n-         --  first) to ensure the following arrangement:\n-\n-         --    <refined postconditions from body>\n-         --    <postconditions from body>\n-         --    <postconditions from spec>\n-         --    <inherited postconditions>\n-\n-         Process_Body_Postconditions (Name_Refined_Post);\n-         Process_Body_Postconditions (Name_Postcondition);\n-\n-         if Present (Spec_Id) then\n-            Process_Spec_Postconditions;\n-         end if;\n-      end Process_Postconditions;\n-\n-      ---------------------------\n-      -- Process_Preconditions --\n-      ---------------------------\n-\n-      procedure Process_Preconditions is\n-         Class_Pre : Node_Id := Empty;\n-         --  The sole [inherited] class-wide precondition pragma that applies\n-         --  to the subprogram.\n-\n-         Insert_Node : Node_Id := Empty;\n-         --  The insertion node after which all pragma Check equivalents are\n-         --  inserted.\n-\n-         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id);\n-         --  Merge two class-wide preconditions by \"or else\"-ing them. The\n-         --  changes are accumulated in parameter Into. Update the error\n-         --  message of Into.\n-\n-         procedure Prepend_To_Decls (Item : Node_Id);\n-         --  Prepend a single item to the declarations of the subprogram body\n-\n-         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id);\n-         --  Save a class-wide precondition into Class_Pre or prepend a normal\n-         --  precondition ot the declarations of the body and analyze it.\n-\n-         procedure Process_Inherited_Preconditions;\n-         --  Collect all inherited class-wide preconditions and merge them into\n-         --  one big precondition to be evaluated as pragma Check.\n-\n-         procedure Process_Preconditions_For (Subp_Id : Entity_Id);\n-         --  Collect all preconditions of subprogram Subp_Id and prepend their\n-         --  pragma Check equivalents to the declarations of the body.\n-\n-         -------------------------\n-         -- Merge_Preconditions --\n-         -------------------------\n-\n-         procedure Merge_Preconditions (From : Node_Id; Into : Node_Id) is\n-            function Expression_Arg (Prag : Node_Id) return Node_Id;\n-            --  Return the boolean expression argument of a precondition while\n-            --  updating its parenteses count for the subsequent merge.\n-\n-            function Message_Arg (Prag : Node_Id) return Node_Id;\n-            --  Return the message argument of a precondition\n-\n-            --------------------\n-            -- Expression_Arg --\n-            --------------------\n-\n-            function Expression_Arg (Prag : Node_Id) return Node_Id is\n-               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-               Arg  : constant Node_Id := Get_Pragma_Arg (Next (First (Args)));\n-\n-            begin\n-               if Paren_Count (Arg) = 0 then\n-                  Set_Paren_Count (Arg, 1);\n-               end if;\n-\n-               return Arg;\n-            end Expression_Arg;\n-\n-            -----------------\n-            -- Message_Arg --\n-            -----------------\n-\n-            function Message_Arg (Prag : Node_Id) return Node_Id is\n-               Args : constant List_Id := Pragma_Argument_Associations (Prag);\n-            begin\n-               return Get_Pragma_Arg (Last (Args));\n-            end Message_Arg;\n-\n-            --  Local variables\n-\n-            From_Expr : constant Node_Id := Expression_Arg (From);\n-            From_Msg  : constant Node_Id := Message_Arg    (From);\n-            Into_Expr : constant Node_Id := Expression_Arg (Into);\n-            Into_Msg  : constant Node_Id := Message_Arg    (Into);\n-            Loc       : constant Source_Ptr := Sloc (Into);\n-\n-         --  Start of processing for Merge_Preconditions\n-\n-         begin\n-            --  Merge the two preconditions by \"or else\"-ing them\n-\n-            Rewrite (Into_Expr,\n-              Make_Or_Else (Loc,\n-                Right_Opnd => Relocate_Node (Into_Expr),\n-                Left_Opnd  => From_Expr));\n-\n-            --  Merge the two error messages to produce a single message of the\n-            --  form:\n-\n-            --    failed precondition from ...\n-            --      also failed inherited precondition from ...\n-\n-            if not Exception_Locations_Suppressed then\n-               Start_String (Strval (Into_Msg));\n-               Store_String_Char (ASCII.LF);\n-               Store_String_Chars (\"  also \");\n-               Store_String_Chars (Strval (From_Msg));\n-\n-               Set_Strval (Into_Msg, End_String);\n-            end if;\n-         end Merge_Preconditions;\n-\n-         ----------------------\n-         -- Prepend_To_Decls --\n-         ----------------------\n-\n-         procedure Prepend_To_Decls (Item : Node_Id) is\n-            Decls : List_Id := Declarations (N);\n-\n-         begin\n-            --  Ensure that the body has a declarative list\n-\n-            if No (Decls) then\n-               Decls := New_List;\n-               Set_Declarations (N, Decls);\n-            end if;\n-\n-            Prepend_To (Decls, Item);\n-         end Prepend_To_Decls;\n-\n-         ------------------------------\n-         -- Prepend_To_Decls_Or_Save --\n-         ------------------------------\n-\n-         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id) is\n-            Check_Prag : Node_Id;\n-\n-         begin\n-            Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n-\n-            --  Save the sole class-wide precondition (if any) for the next\n-            --  step where it will be merged with inherited preconditions.\n-\n-            if Class_Present (Prag) then\n-               pragma Assert (No (Class_Pre));\n-               Class_Pre := Check_Prag;\n-\n-            --  Accumulate the corresponding Check pragmas at the top of the\n-            --  declarations. Prepending the items ensures that they will be\n-            --  evaluated in their original order.\n-\n-            else\n-               if Present (Insert_Node) then\n-                  Insert_After (Insert_Node, Check_Prag);\n-               else\n-                  Prepend_To_Decls (Check_Prag);\n-               end if;\n-\n-               Analyze (Check_Prag);\n-            end if;\n-         end Prepend_To_Decls_Or_Save;\n-\n-         -------------------------------------\n-         -- Process_Inherited_Preconditions --\n-         -------------------------------------\n-\n-         procedure Process_Inherited_Preconditions is\n-            Subps      : constant Subprogram_List :=\n-                           Inherited_Subprograms (Spec_Id);\n-            Check_Prag : Node_Id;\n-            Items      : Node_Id;\n-            Prag       : Node_Id;\n-            Subp_Id    : Entity_Id;\n-\n-         begin\n-            --  Process the contracts of all inherited subprograms, looking for\n-            --  class-wide preconditions.\n-\n-            for Index in Subps'Range loop\n-               Subp_Id := Subps (Index);\n-               Items   := Contract (Subp_Id);\n-\n-               if Present (Items) then\n-                  Prag := Pre_Post_Conditions (Items);\n-                  while Present (Prag) loop\n-                     if Pragma_Name (Prag) = Name_Precondition\n-                       and then Class_Present (Prag)\n-                     then\n-                        Check_Prag :=\n-                          Build_Pragma_Check_Equivalent\n-                            (Prag     => Prag,\n-                             Subp_Id  => Spec_Id,\n-                             Inher_Id => Subp_Id);\n-\n-                        --  The spec or an inherited subprogram already yielded\n-                        --  a class-wide precondition. Merge the existing\n-                        --  precondition with the current one using \"or else\".\n-\n-                        if Present (Class_Pre) then\n-                           Merge_Preconditions (Check_Prag, Class_Pre);\n-                        else\n-                           Class_Pre := Check_Prag;\n-                        end if;\n-                     end if;\n-\n-                     Prag := Next_Pragma (Prag);\n-                  end loop;\n-               end if;\n-            end loop;\n-\n-            --  Add the merged class-wide preconditions\n-\n-            if Present (Class_Pre) then\n-               Prepend_To_Decls (Class_Pre);\n-               Analyze (Class_Pre);\n-            end if;\n-         end Process_Inherited_Preconditions;\n-\n-         -------------------------------\n-         -- Process_Preconditions_For --\n-         -------------------------------\n-\n-         procedure Process_Preconditions_For (Subp_Id : Entity_Id) is\n-            Items     : constant Node_Id := Contract (Subp_Id);\n-            Decl      : Node_Id;\n-            Prag      : Node_Id;\n-            Subp_Decl : Node_Id;\n-\n-         begin\n-            --  Process the contract\n-\n-            if Present (Items) then\n-               Prag := Pre_Post_Conditions (Items);\n-               while Present (Prag) loop\n-                  if Pragma_Name (Prag) = Name_Precondition then\n-                     Prepend_To_Decls_Or_Save (Prag);\n-                  end if;\n-\n-                  Prag := Next_Pragma (Prag);\n-               end loop;\n-            end if;\n-\n-            --  The subprogram declaration being processed is actually a body\n-            --  stub. The stub may carry a precondition pragma in which case it\n-            --  must be taken into account. The pragma appears after the stub.\n-\n-            Subp_Decl := Unit_Declaration_Node (Subp_Id);\n-\n-            if Nkind (Subp_Decl) = N_Subprogram_Body_Stub then\n-\n-               --  Inspect the declarations following the body stub\n-\n-               Decl := Next (Subp_Decl);\n-               while Present (Decl) loop\n-\n-                  --  Note that non-matching pragmas are skipped\n-\n-                  if Nkind (Decl) = N_Pragma then\n-                     if Pragma_Name (Decl) = Name_Precondition then\n-                        Prepend_To_Decls_Or_Save (Decl);\n-                     end if;\n-\n-                  --  Skip internally generated code\n-\n-                  elsif not Comes_From_Source (Decl) then\n-                     null;\n-\n-                  --  Preconditions are usually grouped together. There is no\n-                  --  need to inspect the whole declarative list.\n-\n-                  else\n-                     exit;\n-                  end if;\n-\n-                  Next (Decl);\n-               end loop;\n-            end if;\n-         end Process_Preconditions_For;\n-\n-         --  Local variables\n-\n-         Decls : constant List_Id := Declarations (N);\n-         Decl  : Node_Id;\n-\n-      --  Start of processing for Process_Preconditions\n-\n-      begin\n-         --  Find the last internally generate declaration starting from the\n-         --  top of the body declarations. This ensures that discriminals and\n-         --  subtypes are properly visible to the pragma Check equivalents.\n-\n-         if Present (Decls) then\n-            Decl := First (Decls);\n-            while Present (Decl) loop\n-               exit when Comes_From_Source (Decl);\n-               Insert_Node := Decl;\n-               Next (Decl);\n-            end loop;\n-         end if;\n-\n-         --  The processing of preconditions is done in reverse order (body\n-         --  first) because each pragma Check equivalent is inserted at the\n-         --  top of the declarations. This ensures that the final order is\n-         --  consistent with following diagram:\n-\n-         --    <inherited preconditions>\n-         --    <preconditions from spec>\n-         --    <preconditions from body>\n-\n-         Process_Preconditions_For (Body_Id);\n-\n-         if Present (Spec_Id) then\n-            Process_Preconditions_For (Spec_Id);\n-            Process_Inherited_Preconditions;\n-         end if;\n-      end Process_Preconditions;\n-\n-      --  Local variables\n-\n-      Restore_Scope : Boolean := False;\n-      Result        : Entity_Id;\n-      Stmts         : List_Id := No_List;\n-      Subp_Id       : Entity_Id;\n-\n-   --  Start of processing for Expand_Subprogram_Contract\n-\n-   begin\n-      --  Obtain the entity of the initial declaration\n-\n-      if Present (Spec_Id) then\n-         Subp_Id := Spec_Id;\n-      else\n-         Subp_Id := Body_Id;\n-      end if;\n-\n-      --  Do not perform expansion activity when it is not needed\n-\n-      if not Expander_Active then\n-         return;\n-\n-      --  ASIS requires an unaltered tree\n-\n-      elsif ASIS_Mode then\n-         return;\n-\n-      --  GNATprove does not need the executable semantics of a contract\n-\n-      elsif GNATprove_Mode then\n-         return;\n-\n-      --  The contract of a generic subprogram or one declared in a generic\n-      --  context is not expanded as the corresponding instance will provide\n-      --  the executable semantics of the contract.\n-\n-      elsif Is_Generic_Subprogram (Subp_Id) or else Inside_A_Generic then\n-         return;\n-\n-      --  All subprograms carry a contract, but for some it is not significant\n-      --  and should not be processed. This is a small optimization.\n-\n-      elsif not Has_Significant_Contract (Subp_Id) then\n-         return;\n-\n-      --  The contract of an ignored Ghost subprogram does not need expansion\n-      --  because the subprogram and all calls to it will be removed.\n-\n-      elsif Is_Ignored_Ghost_Entity (Subp_Id) then\n-         return;\n-      end if;\n-\n-      --  Do not re-expand the same contract. This scenario occurs when a\n-      --  construct is rewritten into something else during its analysis\n-      --  (expression functions for instance).\n-\n-      if Has_Expanded_Contract (Subp_Id) then\n-         return;\n-\n-      --  Otherwise mark the subprogram\n-\n-      else\n-         Set_Has_Expanded_Contract (Subp_Id);\n-      end if;\n-\n-      --  Ensure that the formal parameters are visible when expanding all\n-      --  contract items.\n-\n-      if not In_Open_Scopes (Subp_Id) then\n-         Restore_Scope := True;\n-         Push_Scope (Subp_Id);\n-\n-         if Is_Generic_Subprogram (Subp_Id) then\n-            Install_Generic_Formals (Subp_Id);\n-         else\n-            Install_Formals (Subp_Id);\n-         end if;\n-      end if;\n-\n-      --  The expansion of a subprogram contract involves the creation of Check\n-      --  pragmas to verify the contract assertions of the spec and body in a\n-      --  particular order. The order is as follows:\n-\n-      --    function Example (...) return ... is\n-      --       procedure _Postconditions (...) is\n-      --       begin\n-      --          <refined postconditions from body>\n-      --          <postconditions from body>\n-      --          <postconditions from spec>\n-      --          <inherited postconditions>\n-      --          <contract case consequences>\n-      --          <invariant check of function result>\n-      --          <invariant and predicate checks of parameters>\n-      --       end _Postconditions;\n-\n-      --       <inherited preconditions>\n-      --       <preconditions from spec>\n-      --       <preconditions from body>\n-      --       <contract case conditions>\n-\n-      --       <source declarations>\n-      --    begin\n-      --       <source statements>\n-\n-      --       _Preconditions (Result);\n-      --       return Result;\n-      --    end Example;\n-\n-      --  Routine _Postconditions holds all contract assertions that must be\n-      --  verified on exit from the related subprogram.\n-\n-      --  Step 1: Handle all preconditions. This action must come before the\n-      --  processing of pragma Contract_Cases because the pragma prepends items\n-      --  to the body declarations.\n-\n-      Process_Preconditions;\n-\n-      --  Step 2: Handle all postconditions. This action must come before the\n-      --  processing of pragma Contract_Cases because the pragma appends items\n-      --  to list Stmts.\n-\n-      Process_Postconditions (Stmts);\n-\n-      --  Step 3: Handle pragma Contract_Cases. This action must come before\n-      --  the processing of invariants and predicates because those append\n-      --  items to list Smts.\n-\n-      Process_Contract_Cases (Stmts);\n-\n-      --  Step 4: Apply invariant and predicate checks on a function result and\n-      --  all formals. The resulting checks are accumulated in list Stmts.\n-\n-      Add_Invariant_And_Predicate_Checks (Subp_Id, Stmts, Result);\n-\n-      --  Step 5: Construct procedure _Postconditions\n-\n-      Build_Postconditions_Procedure (Subp_Id, Stmts, Result);\n-\n-      if Restore_Scope then\n-         End_Scope;\n-      end if;\n-   end Expand_Subprogram_Contract;\n-\n    --------------------------------------------\n    -- Has_Unconstrained_Access_Discriminants --\n    --------------------------------------------"}, {"sha": "2184d5863abb0db1065f5d47ad059c901438afa2", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -41,12 +41,6 @@ package Exp_Ch6 is\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call.\n \n-   procedure Expand_Subprogram_Contract (N : Node_Id);\n-   --  Expand the contracts of a subprogram body and its correspoding spec (if\n-   --  any). This routine processes all [refined] pre- and postconditions as\n-   --  well as Contract_Cases, invariants and predicates. N denotes the body of\n-   --  the subprogram.\n-\n    procedure Freeze_Subprogram (N : Node_Id);\n    --  generate the appropriate expansions related to Subprogram freeze\n    --  nodes (e.g. the filling of the corresponding Dispatch Table for"}, {"sha": "a8ce6722491bc4b11e35cc1109f1d5999a639e15", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -243,6 +243,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/casing.o\t\\\n  ada/checks.o\t\\\n  ada/comperr.o\t\\\n+ ada/contracts.o\t\\\n  ada/csets.o\t\\\n  ada/cstand.o\t\\\n  ada/debug.o\t\\"}, {"sha": "243f3b80d57f4397d7e7257022fdd899c67f7379", "filename": "gcc/ada/init.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -110,6 +110,7 @@ char *__gl_interrupt_states              = 0;\n int   __gl_num_interrupt_states          = 0;\n int   __gl_unreserve_all_interrupts      = 0;\n int   __gl_exception_tracebacks          = 0;\n+int   __gl_exception_tracebacks_symbolic = 0;\n int   __gl_detect_blocking               = 0;\n int   __gl_default_stack_size            = -1;\n int   __gl_leap_seconds_support          = 0;"}, {"sha": "e99c6b71b25bb2320440a7e16665ae6eb2159f25", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -595,7 +595,12 @@ package Opt is\n \n    Exception_Tracebacks : Boolean := False;\n    --  GNATBIND\n-   --  Set to True to store tracebacks in exception occurrences (-E)\n+   --  Set to True to store tracebacks in exception occurrences (-Ea or -E)\n+\n+   Exception_Tracebacks_Symbolic : Boolean := False;\n+   --  GNATBIND\n+   --  Set to True to store tracebacks in exception occurrences and enable\n+   --  symbolic tracebacks (-Es).\n \n    Extensions_Allowed : Boolean := False;\n    --  GNAT"}, {"sha": "ae6936e93ddb216a2cbcb124a01c8f04a43c90c2", "filename": "gcc/ada/s-exctra.ads", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fs-exctra.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fs-exctra.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-exctra.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -48,6 +48,10 @@\n --  may return any string output in association with a provided call chain.\n --  The decorator replaces the default backtrace mentioned above.\n \n+--  On systems that use DWARF debugging output, then if the \"-g\" compiler\n+--  switch and the \"-Es\" binder switch are used, the decorator is automatically\n+--  set to Symbolic_Traceback.\n+\n with System.Traceback_Entries;\n \n package System.Exception_Traces is\n@@ -89,12 +93,15 @@ package System.Exception_Traces is\n    --  output for a call chain provided by way of a tracebacks array.\n \n    procedure Set_Trace_Decorator (Decorator : Traceback_Decorator);\n-   --  Set the decorator to be used for future automatic outputs. Restore\n-   --  the default behavior (output of raw addresses) if the provided\n-   --  access value is null.\n+   --  Set the decorator to be used for future automatic outputs. Restore the\n+   --  default behavior if the provided access value is null.\n    --\n    --  Note: System.Traceback.Symbolic.Symbolic_Traceback may be used as the\n    --  Decorator, to get a symbolic traceback. This will cause a significant\n-   --  cpu and memory overhead.\n+   --  cpu and memory overhead on some platforms.\n+   --\n+   --  Note: The Decorator is called when constructing the\n+   --  Exception_Information; that needs to be taken into account\n+   --  if the Decorator has any side effects.\n \n end System.Exception_Traces;"}, {"sha": "41ceb3d4cabd9ed021c41e9c628c7c69a4970169", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 44, "deletions": 86, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -23,50 +23,50 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Errout;   use Errout;\n-with Exp_Util; use Exp_Util;\n-with Elists;   use Elists;\n-with Fname;    use Fname;\n-with Fname.UF; use Fname.UF;\n-with Freeze;   use Freeze;\n-with Impunit;  use Impunit;\n-with Inline;   use Inline;\n-with Lib;      use Lib;\n-with Lib.Load; use Lib.Load;\n-with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-with Par_SCO;  use Par_SCO;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch7;  use Sem_Ch7;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch12; use Sem_Ch12;\n-with Sem_Dist; use Sem_Dist;\n-with Sem_Prag; use Sem_Prag;\n-with Sem_Util; use Sem_Util;\n-with Sem_Warn; use Sem_Warn;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinfo.CN; use Sinfo.CN;\n-with Sinput;   use Sinput;\n-with Snames;   use Snames;\n-with Style;    use Style;\n-with Stylesw;  use Stylesw;\n-with Tbuild;   use Tbuild;\n-with Uname;    use Uname;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Errout;    use Errout;\n+with Exp_Util;  use Exp_Util;\n+with Elists;    use Elists;\n+with Fname;     use Fname;\n+with Fname.UF;  use Fname.UF;\n+with Freeze;    use Freeze;\n+with Impunit;   use Impunit;\n+with Inline;    use Inline;\n+with Lib;       use Lib;\n+with Lib.Load;  use Lib.Load;\n+with Lib.Xref;  use Lib.Xref;\n+with Namet;     use Namet;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Output;    use Output;\n+with Par_SCO;   use Par_SCO;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch7;   use Sem_Ch7;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Dist;  use Sem_Dist;\n+with Sem_Prag;  use Sem_Prag;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Warn;  use Sem_Warn;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n+with Sinfo.CN;  use Sinfo.CN;\n+with Sinput;    use Sinput;\n+with Snames;    use Snames;\n+with Style;     use Style;\n+with Stylesw;   use Stylesw;\n+with Tbuild;    use Tbuild;\n+with Uname;     use Uname;\n \n package body Sem_Ch10 is\n \n@@ -940,15 +940,6 @@ package body Sem_Ch10 is\n                               N_Subprogram_Declaration)\n       then\n          Analyze_Subprogram_Contract (Defining_Entity (Unit_Node));\n-\n-         --  Capture all global references in a generic subprogram that acts as\n-         --  a compilation unit now that the contract has been analyzed.\n-\n-         if Is_Generic_Declaration_Or_Body (Unit_Node) then\n-            Save_Global_References_In_Contract\n-              (Templ  => Original_Node (Unit_Node),\n-               Gen_Id => Defining_Entity (Unit_Node));\n-         end if;\n       end if;\n \n       --  Generate distribution stubs if requested and no error\n@@ -2006,39 +1997,6 @@ package body Sem_Ch10 is\n       Restore_Opt_Config_Switches (Opts);\n    end Analyze_Subprogram_Body_Stub;\n \n-   -------------------------------------------\n-   -- Analyze_Subprogram_Body_Stub_Contract --\n-   -------------------------------------------\n-\n-   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id) is\n-      Stub_Decl : constant Node_Id   := Parent (Parent (Stub_Id));\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of_Stub (Stub_Decl);\n-\n-   begin\n-      --  A subprogram body stub may act as its own spec or as the completion\n-      --  of a previous declaration. Depending on the context, the contract of\n-      --  the stub may contain two sets of pragmas.\n-\n-      --  The stub is a completion, the applicable pragmas are:\n-      --    Refined_Depends\n-      --    Refined_Global\n-\n-      if Present (Spec_Id) then\n-         Analyze_Subprogram_Body_Contract (Stub_Id);\n-\n-      --  The stub acts as its own spec, the applicable pragmas are:\n-      --    Contract_Cases\n-      --    Depends\n-      --    Global\n-      --    Postcondition\n-      --    Precondition\n-      --    Test_Case\n-\n-      else\n-         Analyze_Subprogram_Contract (Stub_Id);\n-      end if;\n-   end Analyze_Subprogram_Body_Stub_Contract;\n-\n    ---------------------\n    -- Analyze_Subunit --\n    ---------------------"}, {"sha": "d4b28cde8af07cb93e136d25d308413f081fd796", "filename": "gcc/ada/sem_ch10.ads", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch10.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch10.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -24,6 +24,7 @@\n ------------------------------------------------------------------------------\n \n with Types; use Types;\n+\n package Sem_Ch10 is\n    procedure Analyze_Compilation_Unit                   (N : Node_Id);\n    procedure Analyze_With_Clause                        (N : Node_Id);\n@@ -33,19 +34,6 @@ package Sem_Ch10 is\n    procedure Analyze_Protected_Body_Stub                (N : Node_Id);\n    procedure Analyze_Subunit                            (N : Node_Id);\n \n-   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of a subprogram body\n-   --  stub Stub_Id as if they appeared at the end of a declarative region. The\n-   --  aspects in question are:\n-   --    Contract_Cases\n-   --    Depends\n-   --    Global\n-   --    Postcondition\n-   --    Precondition\n-   --    Refined_Depends\n-   --    Refined_Global\n-   --    Test_Case\n-\n    procedure Install_Context (N : Node_Id);\n    --  Installs the entities from the context clause of the given compilation\n    --  unit into the visibility chains. This is done before analyzing a unit."}, {"sha": "6891c64b2250a4cc9cf5ba3366680fde75087680", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 90, "deletions": 193, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -23,60 +23,61 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Expander; use Expander;\n-with Exp_Disp; use Exp_Disp;\n-with Fname;    use Fname;\n-with Fname.UF; use Fname.UF;\n-with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n-with Itypes;   use Itypes;\n-with Lib;      use Lib;\n-with Lib.Load; use Lib.Load;\n-with Lib.Xref; use Lib.Xref;\n-with Nlists;   use Nlists;\n-with Namet;    use Namet;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Rident;   use Rident;\n-with Restrict; use Restrict;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Cat;  use Sem_Cat;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch7;  use Sem_Ch7;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch10; use Sem_Ch10;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Dim;  use Sem_Dim;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Elab; use Sem_Elab;\n-with Sem_Elim; use Sem_Elim;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Prag; use Sem_Prag;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Type; use Sem_Type;\n-with Sem_Util; use Sem_Util;\n-with Sem_Warn; use Sem_Warn;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinfo.CN; use Sinfo.CN;\n-with Sinput;   use Sinput;\n-with Sinput.L; use Sinput.L;\n-with Snames;   use Snames;\n-with Stringt;  use Stringt;\n-with Uname;    use Uname;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Contracts; use Contracts;\n+with Einfo;     use Einfo;\n+with Elists;    use Elists;\n+with Errout;    use Errout;\n+with Expander;  use Expander;\n+with Exp_Disp;  use Exp_Disp;\n+with Fname;     use Fname;\n+with Fname.UF;  use Fname.UF;\n+with Freeze;    use Freeze;\n+with Ghost;     use Ghost;\n+with Itypes;    use Itypes;\n+with Lib;       use Lib;\n+with Lib.Load;  use Lib.Load;\n+with Lib.Xref;  use Lib.Xref;\n+with Nlists;    use Nlists;\n+with Namet;     use Namet;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Rident;    use Rident;\n+with Restrict;  use Restrict;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Cat;   use Sem_Cat;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch7;   use Sem_Ch7;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch10;  use Sem_Ch10;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Dim;   use Sem_Dim;\n+with Sem_Disp;  use Sem_Disp;\n+with Sem_Elab;  use Sem_Elab;\n+with Sem_Elim;  use Sem_Elim;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Prag;  use Sem_Prag;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Type;  use Sem_Type;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Warn;  use Sem_Warn;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n+with Sinfo.CN;  use Sinfo.CN;\n+with Sinput;    use Sinput;\n+with Sinput.L;  use Sinput.L;\n+with Snames;    use Snames;\n+with Stringt;   use Stringt;\n+with Uname;     use Uname;\n with Table;\n-with Tbuild;   use Tbuild;\n-with Uintp;    use Uintp;\n-with Urealp;   use Urealp;\n-with Warnsw;   use Warnsw;\n+with Tbuild;    use Tbuild;\n+with Uintp;     use Uintp;\n+with Urealp;    use Urealp;\n+with Warnsw;    use Warnsw;\n \n with GNAT.HTable;\n \n@@ -842,10 +843,6 @@ package body Sem_Ch12 is\n    --  Restore suffix 'P' to primitives of Prims_List and leave Prims_List\n    --  set to No_Elist.\n \n-   procedure Save_Global_References_In_Aspects (N : Node_Id);\n-   --  Save all global references found within the expressions of all aspects\n-   --  that appear on node N.\n-\n    procedure Set_Instance_Env\n      (Gen_Unit : Entity_Id;\n       Act_Unit : Entity_Id);\n@@ -4803,11 +4800,6 @@ package body Sem_Ch12 is\n       --  aspects that appear in the generic. This renaming declaration is\n       --  inserted after the instance declaration which it renames.\n \n-      procedure Instantiate_Subprogram_Contract (Templ : Node_Id);\n-      --  Instantiate all source pragmas found in the contract of the generic\n-      --  subprogram declaration template denoted by Templ. The instantiated\n-      --  pragmas are added to list Renaming_List.\n-\n       ------------------------------------\n       -- Analyze_Instance_And_Renamings --\n       ------------------------------------\n@@ -5009,53 +5001,6 @@ package body Sem_Ch12 is\n          end if;\n       end Build_Subprogram_Renaming;\n \n-      -------------------------------------\n-      -- Instantiate_Subprogram_Contract --\n-      -------------------------------------\n-\n-      procedure Instantiate_Subprogram_Contract (Templ : Node_Id) is\n-         procedure Instantiate_Pragmas (First_Prag : Node_Id);\n-         --  Instantiate all contract-related source pragmas found in the list\n-         --  starting with pragma First_Prag. Each instantiated pragma is added\n-         --  to list Renaming_List.\n-\n-         -------------------------\n-         -- Instantiate_Pragmas --\n-         -------------------------\n-\n-         procedure Instantiate_Pragmas (First_Prag : Node_Id) is\n-            Inst_Prag : Node_Id;\n-            Prag      : Node_Id;\n-\n-         begin\n-            Prag := First_Prag;\n-            while Present (Prag) loop\n-               if Is_Generic_Contract_Pragma (Prag) then\n-                  Inst_Prag :=\n-                    Copy_Generic_Node (Prag, Empty, Instantiating => True);\n-\n-                  Set_Analyzed (Inst_Prag, False);\n-                  Append_To (Renaming_List, Inst_Prag);\n-               end if;\n-\n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-         end Instantiate_Pragmas;\n-\n-         --  Local variables\n-\n-         Items : constant Node_Id := Contract (Defining_Entity (Templ));\n-\n-      --  Start of processing for Instantiate_Subprogram_Contract\n-\n-      begin\n-         if Present (Items) then\n-            Instantiate_Pragmas (Pre_Post_Conditions (Items));\n-            Instantiate_Pragmas (Contract_Test_Cases (Items));\n-            Instantiate_Pragmas (Classifications     (Items));\n-         end if;\n-      end Instantiate_Subprogram_Contract;\n-\n       --  Local variables\n \n       Save_IPSM : constant Boolean := Ignore_Pragma_SPARK_Mode;\n@@ -5227,9 +5172,10 @@ package body Sem_Ch12 is\n          --  must be instantiated explicitly because they are not part of the\n          --  subprogram template.\n \n-         Instantiate_Subprogram_Contract (Original_Node (Gen_Decl));\n-         Build_Subprogram_Renaming;\n+         Instantiate_Subprogram_Contract\n+           (Original_Node (Gen_Decl), Renaming_List);\n \n+         Build_Subprogram_Renaming;\n          Analyze_Instance_And_Renamings;\n \n          --  If the generic is marked Import (Intrinsic), then so is the\n@@ -10888,9 +10834,12 @@ package body Sem_Ch12 is\n            Copy_Generic_Node\n              (Original_Node (Gen_Body), Empty, Instantiating => True);\n \n-         --  Build new name (possibly qualified) for body declaration\n+         --  Create proper (possibly qualified) defining name for the body, to\n+         --  correspond to the one in the spec.\n \n-         Act_Body_Id := New_Copy (Act_Decl_Id);\n+         Act_Body_Id :=\n+           Make_Defining_Identifier (Sloc (Act_Decl_Id), Chars (Act_Decl_Id));\n+         Set_Comes_From_Source (Act_Body_Id, Comes_From_Source (Act_Decl_Id));\n \n          --  Some attributes of spec entity are not inherited by body entity\n \n@@ -10901,7 +10850,8 @@ package body Sem_Ch12 is\n          then\n             Act_Body_Name :=\n               Make_Defining_Program_Unit_Name (Loc,\n-                Name => New_Copy_Tree (Name (Defining_Unit_Name (Act_Spec))),\n+                Name                =>\n+                  New_Copy_Tree (Name (Defining_Unit_Name (Act_Spec))),\n                 Defining_Identifier => Act_Body_Id);\n          else\n             Act_Body_Name := Act_Body_Id;\n@@ -11109,7 +11059,7 @@ package body Sem_Ch12 is\n       Gen_Id      : constant Node_Id    := Name (Inst_Node);\n       Gen_Unit    : constant Entity_Id  := Get_Generic_Entity (Inst_Node);\n       Gen_Decl    : constant Node_Id    := Unit_Declaration_Node (Gen_Unit);\n-      Anon_Id     : constant Entity_Id  :=\n+      Act_Decl_Id : constant Entity_Id  :=\n                       Defining_Unit_Name (Specification (Act_Decl));\n       Pack_Id     : constant Entity_Id  :=\n                       Defining_Unit_Name (Parent (Act_Decl));\n@@ -11119,6 +11069,7 @@ package body Sem_Ch12 is\n       Saved_Warnings    : constant Warning_Record := Save_Warnings;\n \n       Act_Body    : Node_Id;\n+      Act_Body_Id : Entity_Id;\n       Gen_Body    : Node_Id;\n       Gen_Body_Id : Node_Id;\n       Pack_Body   : Node_Id;\n@@ -11160,11 +11111,11 @@ package body Sem_Ch12 is\n          --  the spec entity appropriately.\n \n          if Is_Imported (Gen_Unit) then\n-            Set_Is_Imported (Anon_Id);\n-            Set_First_Rep_Item (Anon_Id, First_Rep_Item (Gen_Unit));\n-            Set_Interface_Name (Anon_Id, Interface_Name (Gen_Unit));\n-            Set_Convention     (Anon_Id, Convention     (Gen_Unit));\n-            Set_Has_Completion (Anon_Id);\n+            Set_Is_Imported (Act_Decl_Id);\n+            Set_First_Rep_Item (Act_Decl_Id, First_Rep_Item (Gen_Unit));\n+            Set_Interface_Name (Act_Decl_Id, Interface_Name (Gen_Unit));\n+            Set_Convention     (Act_Decl_Id, Convention     (Gen_Unit));\n+            Set_Has_Completion (Act_Decl_Id);\n             return;\n \n          --  For other cases, compile the body\n@@ -11194,11 +11145,11 @@ package body Sem_Ch12 is\n                  (\"missing proper body for instantiation\", Gen_Body);\n             end if;\n \n-            Set_Has_Completion (Anon_Id);\n+            Set_Has_Completion (Act_Decl_Id);\n             return;\n          end if;\n \n-         Save_Env (Gen_Unit, Anon_Id);\n+         Save_Env (Gen_Unit, Act_Decl_Id);\n          Style_Check := False;\n \n          --  If the context of the instance is subject to SPARK_Mode \"off\" or\n@@ -11221,14 +11172,17 @@ package body Sem_Ch12 is\n            Copy_Generic_Node\n              (Original_Node (Gen_Body), Empty, Instantiating => True);\n \n-         --  Create proper defining name for the body, to correspond to\n-         --  the one in the spec.\n+         --  Create proper defining name for the body, to correspond to the one\n+         --  in the spec.\n+\n+         Act_Body_Id :=\n+           Make_Defining_Identifier (Sloc (Act_Decl_Id), Chars (Act_Decl_Id));\n \n-         Set_Defining_Unit_Name (Specification (Act_Body),\n-           Make_Defining_Identifier\n-             (Sloc (Defining_Entity (Inst_Node)), Chars (Anon_Id)));\n-         Set_Corresponding_Spec (Act_Body, Anon_Id);\n-         Set_Has_Completion (Anon_Id);\n+         Set_Comes_From_Source (Act_Body_Id, Comes_From_Source (Act_Decl_Id));\n+         Set_Defining_Unit_Name (Specification (Act_Body), Act_Body_Id);\n+\n+         Set_Corresponding_Spec (Act_Body, Act_Decl_Id);\n+         Set_Has_Completion (Act_Decl_Id);\n          Check_Generic_Actuals (Pack_Id, False);\n \n          --  Generate a reference to link the visible subprogram instance to\n@@ -11327,16 +11281,16 @@ package body Sem_Ch12 is\n          if Body_Optional then\n             return;\n \n-         elsif Ekind (Anon_Id) = E_Procedure then\n+         elsif Ekind (Act_Decl_Id) = E_Procedure then\n             Act_Body :=\n               Make_Subprogram_Body (Loc,\n                  Specification              =>\n                    Make_Procedure_Specification (Loc,\n                      Defining_Unit_Name         =>\n-                       Make_Defining_Identifier (Loc, Chars (Anon_Id)),\n+                       Make_Defining_Identifier (Loc, Chars (Act_Decl_Id)),\n                        Parameter_Specifications =>\n                        New_Copy_List\n-                         (Parameter_Specifications (Parent (Anon_Id)))),\n+                         (Parameter_Specifications (Parent (Act_Decl_Id)))),\n \n                  Declarations               => Empty_List,\n                  Handled_Statement_Sequence =>\n@@ -11352,20 +11306,20 @@ package body Sem_Ch12 is\n               Make_Raise_Program_Error (Loc,\n                 Reason => PE_Access_Before_Elaboration);\n \n-            Set_Etype (Ret_Expr, (Etype (Anon_Id)));\n+            Set_Etype (Ret_Expr, (Etype (Act_Decl_Id)));\n             Set_Analyzed (Ret_Expr);\n \n             Act_Body :=\n               Make_Subprogram_Body (Loc,\n                 Specification =>\n                   Make_Function_Specification (Loc,\n                      Defining_Unit_Name         =>\n-                       Make_Defining_Identifier (Loc, Chars (Anon_Id)),\n+                       Make_Defining_Identifier (Loc, Chars (Act_Decl_Id)),\n                        Parameter_Specifications =>\n                        New_Copy_List\n-                         (Parameter_Specifications (Parent (Anon_Id))),\n+                         (Parameter_Specifications (Parent (Act_Decl_Id))),\n                      Result_Definition =>\n-                       New_Occurrence_Of (Etype (Anon_Id), Loc)),\n+                       New_Occurrence_Of (Etype (Act_Decl_Id), Loc)),\n \n                   Declarations               => Empty_List,\n                   Handled_Statement_Sequence =>\n@@ -14970,63 +14924,6 @@ package body Sem_Ch12 is\n       end loop;\n    end Save_Global_References_In_Aspects;\n \n-   ----------------------------------------\n-   -- Save_Global_References_In_Contract --\n-   ----------------------------------------\n-\n-   procedure Save_Global_References_In_Contract\n-     (Templ  : Node_Id;\n-      Gen_Id : Entity_Id)\n-   is\n-      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n-      --  Save all global references in contract-related source pragmas found\n-      --  in the list starting with pragma First_Prag.\n-\n-      ------------------------------------\n-      -- Save_Global_References_In_List --\n-      ------------------------------------\n-\n-      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n-         Prag : Node_Id;\n-\n-      begin\n-         Prag := First_Prag;\n-         while Present (Prag) loop\n-            if Is_Generic_Contract_Pragma (Prag) then\n-               Save_Global_References (Prag);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end Save_Global_References_In_List;\n-\n-      --  Local variables\n-\n-      Items : constant Node_Id := Contract (Defining_Entity (Templ));\n-\n-   --  Start of processing for Save_Global_References_In_Contract\n-\n-   begin\n-      --  The entity of the analyzed generic copy must be on the scope stack\n-      --  to ensure proper detection of global references.\n-\n-      Push_Scope (Gen_Id);\n-\n-      if Permits_Aspect_Specifications (Templ)\n-        and then Has_Aspects (Templ)\n-      then\n-         Save_Global_References_In_Aspects (Templ);\n-      end if;\n-\n-      if Present (Items) then\n-         Save_Global_References_In_List (Pre_Post_Conditions (Items));\n-         Save_Global_References_In_List (Contract_Test_Cases (Items));\n-         Save_Global_References_In_List (Classifications     (Items));\n-      end if;\n-\n-      Pop_Scope;\n-   end Save_Global_References_In_Contract;\n-\n    --------------------------------------\n    -- Set_Copied_Sloc_For_Inlined_Body --\n    --------------------------------------"}, {"sha": "c54d7359dee7bf31243e345de7fe3ad8315fb0b5", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -152,12 +152,9 @@ package Sem_Ch12 is\n    --  restored in stack-like fashion. Front-end inlining also uses these\n    --  structures for the management of private/full views.\n \n-   procedure Save_Global_References_In_Contract\n-     (Templ  : Node_Id;\n-      Gen_Id : Entity_Id);\n-   --  Save all global references found within the aspect specifications and\n-   --  the contract-related source pragmas assocated with generic template\n-   --  Templ. Gen_Id denotes the entity of the analyzed generic copy.\n+   procedure Save_Global_References_In_Aspects (N : Node_Id);\n+   --  Save all global references found within the expressions of all aspects\n+   --  that appear on node N.\n \n    procedure Set_Copied_Sloc_For_Inlined_Body (N : Node_Id; E : Entity_Id);\n    --  This procedure is used when a subprogram body is inlined. This process"}, {"sha": "43553290f69a05d7a450f059fa35206f313f28e4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 63, "deletions": 268, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -23,64 +23,62 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Checks;   use Checks;\n-with Debug;    use Debug;\n-with Elists;   use Elists;\n-with Einfo;    use Einfo;\n-with Errout;   use Errout;\n-with Eval_Fat; use Eval_Fat;\n-with Exp_Ch3;  use Exp_Ch3;\n-with Exp_Ch9;  use Exp_Ch9;\n-with Exp_Disp; use Exp_Disp;\n-with Exp_Dist; use Exp_Dist;\n-with Exp_Tss;  use Exp_Tss;\n-with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n-with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n-with Itypes;   use Itypes;\n-with Layout;   use Layout;\n-with Lib;      use Lib;\n-with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Case; use Sem_Case;\n-with Sem_Cat;  use Sem_Cat;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch7;  use Sem_Ch7;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch10; use Sem_Ch10;\n-with Sem_Ch12; use Sem_Ch12;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Dim;  use Sem_Dim;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Dist; use Sem_Dist;\n-with Sem_Elim; use Sem_Elim;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Mech; use Sem_Mech;\n-with Sem_Prag; use Sem_Prag;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Smem; use Sem_Smem;\n-with Sem_Type; use Sem_Type;\n-with Sem_Util; use Sem_Util;\n-with Sem_Warn; use Sem_Warn;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinput;   use Sinput;\n-with Snames;   use Snames;\n-with Targparm; use Targparm;\n-with Tbuild;   use Tbuild;\n-with Ttypes;   use Ttypes;\n-with Uintp;    use Uintp;\n-with Urealp;   use Urealp;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Checks;    use Checks;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Elists;    use Elists;\n+with Einfo;     use Einfo;\n+with Errout;    use Errout;\n+with Eval_Fat;  use Eval_Fat;\n+with Exp_Ch3;   use Exp_Ch3;\n+with Exp_Ch9;   use Exp_Ch9;\n+with Exp_Disp;  use Exp_Disp;\n+with Exp_Dist;  use Exp_Dist;\n+with Exp_Tss;   use Exp_Tss;\n+with Exp_Util;  use Exp_Util;\n+with Fname;     use Fname;\n+with Freeze;    use Freeze;\n+with Ghost;     use Ghost;\n+with Itypes;    use Itypes;\n+with Layout;    use Layout;\n+with Lib;       use Lib;\n+with Lib.Xref;  use Lib.Xref;\n+with Namet;     use Namet;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Case;  use Sem_Case;\n+with Sem_Cat;   use Sem_Cat;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch7;   use Sem_Ch7;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Dim;   use Sem_Dim;\n+with Sem_Disp;  use Sem_Disp;\n+with Sem_Dist;  use Sem_Dist;\n+with Sem_Elim;  use Sem_Elim;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Mech;  use Sem_Mech;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Smem;  use Sem_Smem;\n+with Sem_Type;  use Sem_Type;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Warn;  use Sem_Warn;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n+with Sinput;    use Sinput;\n+with Snames;    use Snames;\n+with Targparm;  use Targparm;\n+with Tbuild;    use Tbuild;\n+with Ttypes;    use Ttypes;\n+with Uintp;     use Uintp;\n+with Urealp;    use Urealp;\n \n package body Sem_Ch3 is\n \n@@ -93,16 +91,6 @@ package body Sem_Ch3 is\n    --  abstract interface types implemented by a record type or a derived\n    --  record type.\n \n-   procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n-   --  Analyze all delayed pragmas chained on the contract of object Obj_Id as\n-   --  if they appeared at the end of the declarative region. The pragmas to be\n-   --  considered are:\n-   --    Async_Readers\n-   --    Async_Writers\n-   --    Effective_Reads\n-   --    Effective_Writes\n-   --    Part_Of\n-\n    procedure Build_Derived_Type\n      (N             : Node_Id;\n       Parent_Type   : Entity_Id;\n@@ -2306,7 +2294,6 @@ package body Sem_Ch3 is\n       Context     : Node_Id   := Empty;\n       Freeze_From : Entity_Id := Empty;\n       Next_Decl   : Node_Id;\n-      Pack_Decl   : Node_Id   := Empty;\n \n       Body_Seen : Boolean := False;\n       --  Flag set when the first body [stub] is encountered\n@@ -2477,7 +2464,6 @@ package body Sem_Ch3 is\n          Context := Parent (L);\n \n          if Nkind (Context) = N_Package_Specification then\n-            Pack_Decl := Parent (Context);\n \n             --  When a package has private declarations, its contract must be\n             --  analyzed at the end of the said declarations. This way both the\n@@ -2506,14 +2492,12 @@ package body Sem_Ch3 is\n             end if;\n \n          elsif Nkind (Context) = N_Package_Body then\n-            Pack_Decl := Context;\n             Analyze_Package_Body_Contract (Defining_Entity (Context));\n          end if;\n \n          --  Analyze the contracts of all subprogram declarations, subprogram\n-         --  bodies and variables now due to the delayed visibility needs of\n-         --  of their aspects and pragmas. Capture global references in generic\n-         --  subprograms or bodies.\n+         --  bodies and variables due to the delayed visibility needs of their\n+         --  aspects and pragmas.\n \n          Decl := First (L);\n          while Present (Decl) loop\n@@ -2533,43 +2517,21 @@ package body Sem_Ch3 is\n                Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n             end if;\n \n-            --  Capture all global references in a generic subprogram or a body\n-            --  [stub] now that the contract has been analyzed.\n-\n-            if Nkind_In (Decl, N_Generic_Subprogram_Declaration,\n-                               N_Subprogram_Body,\n-                               N_Subprogram_Body_Stub)\n-              and then Is_Generic_Declaration_Or_Body (Decl)\n-            then\n-               Save_Global_References_In_Contract\n-                 (Templ  => Original_Node (Decl),\n-                  Gen_Id => Corresponding_Spec_Of (Decl));\n-            end if;\n-\n             Next (Decl);\n          end loop;\n \n-         --  The owner of the declarations is a package [body]\n+         if Nkind (Context) = N_Package_Body then\n \n-         if Present (Pack_Decl) then\n+            --  Ensure that all abstract states and objects declared in the\n+            --  state space of a package body are utilized as constituents.\n \n-            --  Capture all global references in a generic package or a body\n-            --  after all nested generic subprograms and bodies were subjected\n-            --  to the same processing.\n-\n-            if Is_Generic_Declaration_Or_Body (Pack_Decl) then\n-               Save_Global_References_In_Contract\n-                 (Templ  => Original_Node (Pack_Decl),\n-                  Gen_Id => Corresponding_Spec_Of (Pack_Decl));\n-            end if;\n+            Check_Unused_Body_States (Defining_Entity (Context));\n \n             --  State refinements are visible upto the end the of the package\n             --  body declarations. Hide the state refinements from visibility\n             --  to restore the original state conditions.\n \n-            if Nkind (Pack_Decl) = N_Package_Body then\n-               Remove_Visible_Refinements (Corresponding_Spec (Pack_Decl));\n-            end if;\n+            Remove_Visible_Refinements (Corresponding_Spec (Context));\n          end if;\n       end if;\n    end Analyze_Declarations;\n@@ -3288,173 +3250,6 @@ package body Sem_Ch3 is\n       end if;\n    end Analyze_Number_Declaration;\n \n-   -----------------------------\n-   -- Analyze_Object_Contract --\n-   -----------------------------\n-\n-   procedure Analyze_Object_Contract (Obj_Id : Entity_Id) is\n-      Obj_Typ : constant Entity_Id := Etype (Obj_Id);\n-      AR_Val  : Boolean := False;\n-      AW_Val  : Boolean := False;\n-      ER_Val  : Boolean := False;\n-      EW_Val  : Boolean := False;\n-      Prag    : Node_Id;\n-      Seen    : Boolean := False;\n-\n-   begin\n-      --  The loop parameter in an element iterator over a formal container\n-      --  is declared with an object declaration but no contracts apply.\n-\n-      if Ekind (Obj_Id) = E_Loop_Parameter then\n-         return;\n-      end if;\n-\n-      --  Constant related checks\n-\n-      if Ekind (Obj_Id) = E_Constant then\n-\n-         --  A constant cannot be effectively volatile (SPARK RM 7.1.3(4)).\n-         --  This check is relevant only when SPARK_Mode is on as it is not a\n-         --  standard Ada legality rule. Internally-generated constants that\n-         --  map generic formals to actuals in instantiations are allowed to\n-         --  be volatile.\n-\n-         if SPARK_Mode = On\n-           and then Comes_From_Source (Obj_Id)\n-           and then Is_Effectively_Volatile (Obj_Id)\n-           and then No (Corresponding_Generic_Association (Parent (Obj_Id)))\n-         then\n-            Error_Msg_N (\"constant cannot be volatile\", Obj_Id);\n-         end if;\n-\n-      --  Variable related checks\n-\n-      else pragma Assert (Ekind (Obj_Id) = E_Variable);\n-\n-         --  The following checks are relevant only when SPARK_Mode is on as\n-         --  they are not standard Ada legality rules. Internally generated\n-         --  temporaries are ignored.\n-\n-         if SPARK_Mode = On and then Comes_From_Source (Obj_Id) then\n-            if Is_Effectively_Volatile (Obj_Id) then\n-\n-               --  The declaration of an effectively volatile object must\n-               --  appear at the library level (SPARK RM 7.1.3(3), C.6(6)).\n-\n-               if not Is_Library_Level_Entity (Obj_Id) then\n-                  Error_Msg_N\n-                    (\"volatile variable & must be declared at library level\",\n-                     Obj_Id);\n-\n-               --  An object of a discriminated type cannot be effectively\n-               --  volatile except for protected objects (SPARK RM 7.1.3(5)).\n-\n-               elsif Has_Discriminants (Obj_Typ)\n-                 and then not Is_Protected_Type (Obj_Typ)\n-               then\n-                  Error_Msg_N\n-                    (\"discriminated object & cannot be volatile\", Obj_Id);\n-\n-               --  An object of a tagged type cannot be effectively volatile\n-               --  (SPARK RM C.6(5)).\n-\n-               elsif Is_Tagged_Type (Obj_Typ) then\n-                  Error_Msg_N (\"tagged object & cannot be volatile\", Obj_Id);\n-               end if;\n-\n-            --  The object is not effectively volatile\n-\n-            else\n-               --  A non-effectively volatile object cannot have effectively\n-               --  volatile components (SPARK RM 7.1.3(6)).\n-\n-               if not Is_Effectively_Volatile (Obj_Id)\n-                 and then Has_Volatile_Component (Obj_Typ)\n-               then\n-                  Error_Msg_N\n-                    (\"non-volatile object & cannot have volatile components\",\n-                     Obj_Id);\n-               end if;\n-            end if;\n-         end if;\n-\n-         if Is_Ghost_Entity (Obj_Id) then\n-\n-            --  A Ghost object cannot be effectively volatile (SPARK RM 6.9(8))\n-\n-            if Is_Effectively_Volatile (Obj_Id) then\n-               Error_Msg_N (\"ghost variable & cannot be volatile\", Obj_Id);\n-\n-            --  A Ghost object cannot be imported or exported (SPARK RM 6.9(8))\n-\n-            elsif Is_Imported (Obj_Id) then\n-               Error_Msg_N (\"ghost object & cannot be imported\", Obj_Id);\n-\n-            elsif Is_Exported (Obj_Id) then\n-               Error_Msg_N (\"ghost object & cannot be exported\", Obj_Id);\n-            end if;\n-         end if;\n-\n-         --  Analyze all external properties\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Async_Readers);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, AR_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Async_Writers);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, AW_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Reads);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, ER_Val);\n-            Seen := True;\n-         end if;\n-\n-         Prag := Get_Pragma (Obj_Id, Pragma_Effective_Writes);\n-\n-         if Present (Prag) then\n-            Analyze_External_Property_In_Decl_Part (Prag, EW_Val);\n-            Seen := True;\n-         end if;\n-\n-         --  Verify the mutual interaction of the various external properties\n-\n-         if Seen then\n-            Check_External_Properties (Obj_Id, AR_Val, AW_Val, ER_Val, EW_Val);\n-         end if;\n-      end if;\n-\n-      --  Check whether the lack of indicator Part_Of agrees with the placement\n-      --  of the object with respect to the state space.\n-\n-      Prag := Get_Pragma (Obj_Id, Pragma_Part_Of);\n-\n-      if No (Prag) then\n-         Check_Missing_Part_Of (Obj_Id);\n-      end if;\n-\n-      --  A ghost object cannot be imported or exported (SPARK RM 6.9(8)). One\n-      --  exception to this is the object that represents the dispatch table of\n-      --  a Ghost tagged type as the symbol needs to be exported.\n-\n-      if Comes_From_Source (Obj_Id) and then Is_Ghost_Entity (Obj_Id) then\n-         if Is_Exported (Obj_Id) then\n-            Error_Msg_N (\"ghost object & cannot be exported\", Obj_Id);\n-\n-         elsif Is_Imported (Obj_Id) then\n-            Error_Msg_N (\"ghost object & cannot be imported\", Obj_Id);\n-         end if;\n-      end if;\n-   end Analyze_Object_Contract;\n-\n    --------------------------------\n    -- Analyze_Object_Declaration --\n    --------------------------------"}, {"sha": "283b770d61102a71f108b908fd97daf5d86a75c8", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 90, "deletions": 301, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -23,70 +23,71 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Checks;   use Checks;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Expander; use Expander;\n-with Exp_Ch6;  use Exp_Ch6;\n-with Exp_Ch7;  use Exp_Ch7;\n-with Exp_Ch9;  use Exp_Ch9;\n-with Exp_Dbug; use Exp_Dbug;\n-with Exp_Disp; use Exp_Disp;\n-with Exp_Tss;  use Exp_Tss;\n-with Exp_Util; use Exp_Util;\n-with Fname;    use Fname;\n-with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n-with Inline;   use Inline;\n-with Itypes;   use Itypes;\n-with Lib.Xref; use Lib.Xref;\n-with Layout;   use Layout;\n-with Namet;    use Namet;\n-with Lib;      use Lib;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Cat;  use Sem_Cat;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch4;  use Sem_Ch4;\n-with Sem_Ch5;  use Sem_Ch5;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch10; use Sem_Ch10;\n-with Sem_Ch12; use Sem_Ch12;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Dim;  use Sem_Dim;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Dist; use Sem_Dist;\n-with Sem_Elim; use Sem_Elim;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Mech; use Sem_Mech;\n-with Sem_Prag; use Sem_Prag;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Util; use Sem_Util;\n-with Sem_Type; use Sem_Type;\n-with Sem_Warn; use Sem_Warn;\n-with Sinput;   use Sinput;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinfo.CN; use Sinfo.CN;\n-with Snames;   use Snames;\n-with Stringt;  use Stringt;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Checks;    use Checks;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Elists;    use Elists;\n+with Errout;    use Errout;\n+with Expander;  use Expander;\n+with Exp_Ch6;   use Exp_Ch6;\n+with Exp_Ch7;   use Exp_Ch7;\n+with Exp_Ch9;   use Exp_Ch9;\n+with Exp_Dbug;  use Exp_Dbug;\n+with Exp_Disp;  use Exp_Disp;\n+with Exp_Tss;   use Exp_Tss;\n+with Exp_Util;  use Exp_Util;\n+with Fname;     use Fname;\n+with Freeze;    use Freeze;\n+with Ghost;     use Ghost;\n+with Inline;    use Inline;\n+with Itypes;    use Itypes;\n+with Lib.Xref;  use Lib.Xref;\n+with Layout;    use Layout;\n+with Namet;     use Namet;\n+with Lib;       use Lib;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Opt;       use Opt;\n+with Output;    use Output;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Cat;   use Sem_Cat;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch4;   use Sem_Ch4;\n+with Sem_Ch5;   use Sem_Ch5;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch10;  use Sem_Ch10;\n+with Sem_Ch12;  use Sem_Ch12;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Dim;   use Sem_Dim;\n+with Sem_Disp;  use Sem_Disp;\n+with Sem_Dist;  use Sem_Dist;\n+with Sem_Elim;  use Sem_Elim;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Mech;  use Sem_Mech;\n+with Sem_Prag;  use Sem_Prag;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Type;  use Sem_Type;\n+with Sem_Warn;  use Sem_Warn;\n+with Sinput;    use Sinput;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n+with Sinfo.CN;  use Sinfo.CN;\n+with Snames;    use Snames;\n+with Stringt;   use Stringt;\n with Style;\n-with Stylesw;  use Stylesw;\n-with Tbuild;   use Tbuild;\n-with Uintp;    use Uintp;\n-with Urealp;   use Urealp;\n-with Validsw;  use Validsw;\n+with Stylesw;   use Stylesw;\n+with Tbuild;    use Tbuild;\n+with Uintp;     use Uintp;\n+with Urealp;    use Urealp;\n+with Validsw;   use Validsw;\n \n package body Sem_Ch6 is\n \n@@ -1377,23 +1378,11 @@ package body Sem_Ch6 is\n          Analyze_Declarations (Declarations (N));\n          Check_Completion;\n \n-         --  When a generic subprogram body appears inside a package, its\n-         --  contract is analyzed at the end of the package body declarations.\n-         --  This is due to the delay with respect of the package contract upon\n-         --  which the body contract may depend. When the generic subprogram\n-         --  body is a compilation unit, this delay is not necessary.\n+         --  Process the contract of the subprogram body after all declarations\n+         --  have been analyzed. This ensures that any contract-related pragmas\n+         --  are available through the N_Contract node of the body.\n \n-         if Nkind (Parent (N)) = N_Compilation_Unit then\n-            Analyze_Subprogram_Body_Contract (Body_Id);\n-\n-            --  Capture all global references in a generic subprogram body\n-            --  that acts as a compilation unit now that the contract has\n-            --  been analyzed.\n-\n-            Save_Global_References_In_Contract\n-              (Templ  => Original_Node (N),\n-               Gen_Id => Gen_Id);\n-         end if;\n+         Analyze_Subprogram_Body_Contract (Body_Id);\n \n          Analyze (Handled_Statement_Sequence (N));\n          Save_Global_References (Original_Node (N));\n@@ -2220,102 +2209,6 @@ package body Sem_Ch6 is\n       end if;\n    end Analyze_Subprogram_Body;\n \n-   --------------------------------------\n-   -- Analyze_Subprogram_Body_Contract --\n-   --------------------------------------\n-\n-   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n-      Items       : constant Node_Id := Contract (Body_Id);\n-      Mode        : SPARK_Mode_Type;\n-      Prag        : Node_Id;\n-      Prag_Nam    : Name_Id;\n-      Ref_Depends : Node_Id := Empty;\n-      Ref_Global  : Node_Id := Empty;\n-\n-   begin\n-      --  When a subprogram body declaration is illegal, its defining entity is\n-      --  left unanalyzed. There is nothing left to do in this case because the\n-      --  body lacks a contract, or even a proper Ekind.\n-\n-      if Ekind (Body_Id) = E_Void then\n-         return;\n-      end if;\n-\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related subprogram body.\n-\n-      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n-\n-      --  All subprograms carry a contract, but for some it is not significant\n-      --  and should not be processed.\n-\n-      if not Has_Significant_Contract (Body_Id) then\n-         null;\n-\n-      --  The subprogram body is a completion, analyze all delayed pragmas that\n-      --  apply. Note that when the body is stand alone, the pragmas are always\n-      --  analyzed on the spot.\n-\n-      elsif Present (Items) then\n-\n-         --  Locate and store pragmas Refined_Depends and Refined_Global since\n-         --  their order of analysis matters.\n-\n-         Prag := Classifications (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Refined_Depends then\n-               Ref_Depends := Prag;\n-\n-            elsif Prag_Nam = Name_Refined_Global then\n-               Ref_Global := Prag;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze Refined_Global first as Refined_Depends may mention items\n-         --  classified in the global refinement.\n-\n-         if Present (Ref_Global) then\n-            Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n-         end if;\n-\n-         --  Refined_Depends must be analyzed after Refined_Global in order to\n-         --  see the modes of all global refinements.\n-\n-         if Present (Ref_Depends) then\n-            Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n-         end if;\n-      end if;\n-\n-      --  Ensure that the contract cases or postconditions mention 'Result or\n-      --  define a post-state.\n-\n-      Check_Result_And_Post_State (Body_Id);\n-\n-      --  A stand alone non-volatile function body cannot have an effectively\n-      --  volatile formal parameter or return type (SPARK RM 7.1.3(9)). This\n-      --  check is relevant only when SPARK_Mode is on as it is not a standard\n-      --  legality rule. The check is performed here because Volatile_Function\n-      --  is processed after the analysis of the related subprogram body.\n-\n-      if SPARK_Mode = On\n-        and then Ekind_In (Body_Id, E_Function, E_Generic_Function)\n-        and then not Is_Volatile_Function (Body_Id)\n-      then\n-         Check_Nonvolatile_Function_Profile (Body_Id);\n-      end if;\n-\n-      --  Restore the SPARK_Mode of the enclosing context after all delayed\n-      --  pragmas have been analyzed.\n-\n-      Restore_SPARK_Mode (Mode);\n-   end Analyze_Subprogram_Body_Contract;\n-\n    ------------------------------------\n    -- Analyze_Subprogram_Body_Helper --\n    ------------------------------------\n@@ -3102,6 +2995,24 @@ package body Sem_Ch6 is\n    --  Start of processing for Analyze_Subprogram_Body_Helper\n \n    begin\n+      --  A [generic] subprogram body \"freezes\" the contract of the nearest\n+      --  enclosing package body:\n+\n+      --    package body Nearest_Enclosing_Package\n+      --      with Refined_State => (State => Constit)\n+      --    is\n+      --       Constit : ...;\n+\n+      --       procedure Freezes_Enclosing_Package_Body\n+      --         with Refined_Depends => (Input => Constit) ...\n+\n+      --  This ensures that any annotations referenced by the contract of the\n+      --  [generic] subprogram body are available. This form of \"freezing\" is\n+      --  decoupled from the usual Freeze_xxx mechanism because it must also\n+      --  work in the context of generics where normal freezing is disabled.\n+\n+      Analyze_Enclosing_Package_Body_Contract (N);\n+\n       --  Generic subprograms are handled separately. They always have a\n       --  generic specification. Determine whether current scope has a\n       --  previous declaration.\n@@ -3842,23 +3753,11 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  When a subprogram body appears inside a package, its contract is\n-      --  analyzed at the end of the package body declarations. This is due\n-      --  to the delay with respect of the package contract upon which the\n-      --  body contract may depend. When the subprogram body is stand alone\n-      --  and acts as a compilation unit, this delay is not necessary.\n+      --  A subprogram body \"freezes\" its own contract. Analyze the contract\n+      --  after the declarations of the body have been processed as pragmas\n+      --  are now chained on the contract of the subprogram body.\n \n-      if Nkind (Parent (N)) = N_Compilation_Unit then\n-         Analyze_Subprogram_Body_Contract (Body_Id);\n-      end if;\n-\n-      --  Deal with preconditions, [refined] postconditions, Contract_Cases,\n-      --  invariants and predicates associated with body and its spec. Since\n-      --  there is no routine Expand_Declarations which would otherwise deal\n-      --  with the contract expansion, generate all necessary mechanisms to\n-      --  verify the contract assertions now.\n-\n-      Expand_Subprogram_Contract (N);\n+      Analyze_Subprogram_Body_Contract (Body_Id);\n \n       --  If SPARK_Mode for body is not On, disable frontend inlining for this\n       --  subprogram in GNATprove mode, as its body should not be analyzed.\n@@ -4096,116 +3995,6 @@ package body Sem_Ch6 is\n       Ghost_Mode := Save_Ghost_Mode;\n    end Analyze_Subprogram_Body_Helper;\n \n-   ---------------------------------\n-   -- Analyze_Subprogram_Contract --\n-   ---------------------------------\n-\n-   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id) is\n-      Items    : constant Node_Id := Contract (Subp_Id);\n-      Depends  : Node_Id := Empty;\n-      Global   : Node_Id := Empty;\n-      Mode     : SPARK_Mode_Type;\n-      Prag     : Node_Id;\n-      Prag_Nam : Name_Id;\n-\n-   begin\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related subprogram body.\n-\n-      Save_SPARK_Mode_And_Set (Subp_Id, Mode);\n-\n-      --  All subprograms carry a contract, but for some it is not significant\n-      --  and should not be processed.\n-\n-      if not Has_Significant_Contract (Subp_Id) then\n-         null;\n-\n-      elsif Present (Items) then\n-\n-         --  Analyze pre- and postconditions\n-\n-         Prag := Pre_Post_Conditions (Items);\n-         while Present (Prag) loop\n-            Analyze_Pre_Post_Condition_In_Decl_Part (Prag);\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze contract-cases and test-cases\n-\n-         Prag := Contract_Test_Cases (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Contract_Cases then\n-               Analyze_Contract_Cases_In_Decl_Part (Prag);\n-            else\n-               pragma Assert (Prag_Nam = Name_Test_Case);\n-               Analyze_Test_Case_In_Decl_Part (Prag);\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze classification pragmas\n-\n-         Prag := Classifications (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Depends then\n-               Depends := Prag;\n-\n-            elsif Prag_Nam = Name_Global then\n-               Global := Prag;\n-\n-            --  Note that pragma Extensions_Visible has already been analyzed\n-\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze Global first as Depends may mention items classified in\n-         --  the global categorization.\n-\n-         if Present (Global) then\n-            Analyze_Global_In_Decl_Part (Global);\n-         end if;\n-\n-         --  Depends must be analyzed after Global in order to see the modes of\n-         --  all global items.\n-\n-         if Present (Depends) then\n-            Analyze_Depends_In_Decl_Part (Depends);\n-         end if;\n-\n-         --  Ensure that the contract cases or postconditions mention 'Result\n-         --  or define a post-state.\n-\n-         Check_Result_And_Post_State (Subp_Id);\n-      end if;\n-\n-      --  A non-volatile function cannot have an effectively volatile formal\n-      --  parameter or return type (SPARK RM 7.1.3(9)). This check is relevant\n-      --  only when SPARK_Mode is on as it is not a standard legality rule. The\n-      --  check is performed here because pragma Volatile_Function is processed\n-      --  after the analysis of the related subprogram declaration.\n-\n-      if SPARK_Mode = On\n-        and then Ekind_In (Subp_Id, E_Function, E_Generic_Function)\n-        and then not Is_Volatile_Function (Subp_Id)\n-      then\n-         Check_Nonvolatile_Function_Profile (Subp_Id);\n-      end if;\n-\n-      --  Restore the SPARK_Mode of the enclosing context after all delayed\n-      --  pragmas have been analyzed.\n-\n-      Restore_SPARK_Mode (Mode);\n-   end Analyze_Subprogram_Contract;\n-\n    ------------------------------------\n    -- Analyze_Subprogram_Declaration --\n    ------------------------------------"}, {"sha": "ff24ed83acc18c6aab0a1f1ad76ab3b21bfb5c50", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -45,31 +45,6 @@ package Sem_Ch6 is\n    procedure Analyze_Subprogram_Declaration          (N : Node_Id);\n    procedure Analyze_Subprogram_Body                 (N : Node_Id);\n \n-   procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of subprogram body\n-   --  Body_Id as if they appeared at the end of a declarative region. Aspects\n-   --  in question are:\n-   --    Contract_Cases   (stand alone body)\n-   --    Depends          (stand alone body)\n-   --    Global           (stand alone body)\n-   --    Postcondition    (stand alone body)\n-   --    Precondition     (stand alone body)\n-   --    Refined_Depends\n-   --    Refined_Global\n-   --    Refined_Post\n-   --    Test_Case        (stand alone body)\n-\n-   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of subprogram\n-   --  Subp_Id as if they appeared at the end of a declarative region. The\n-   --  aspects in question are:\n-   --    Contract_Cases\n-   --    Depends\n-   --    Global\n-   --    Postcondition\n-   --    Precondition\n-   --    Test_Case\n-\n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id;\n    --  Analyze subprogram specification in both subprogram declarations\n    --  and body declarations. Returns the defining entity for the"}, {"sha": "5814bc8eee31ff84ef28b0fe8aeddfda6119bbd2", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 62, "deletions": 146, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -28,44 +28,45 @@\n --  handling of private and full declarations, and the construction of dispatch\n --  tables for tagged types.\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Exp_Disp; use Exp_Disp;\n-with Exp_Dist; use Exp_Dist;\n-with Exp_Dbug; use Exp_Dbug;\n-with Ghost;    use Ghost;\n-with Lib;      use Lib;\n-with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n-with Nmake;    use Nmake;\n-with Nlists;   use Nlists;\n-with Opt;      use Opt;\n-with Output;   use Output;\n-with Restrict; use Restrict;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Cat;  use Sem_Cat;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch10; use Sem_Ch10;\n-with Sem_Ch12; use Sem_Ch12;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Prag; use Sem_Prag;\n-with Sem_Util; use Sem_Util;\n-with Sem_Warn; use Sem_Warn;\n-with Snames;   use Snames;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinput;   use Sinput;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Contracts; use Contracts;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Elists;    use Elists;\n+with Errout;    use Errout;\n+with Exp_Disp;  use Exp_Disp;\n+with Exp_Dist;  use Exp_Dist;\n+with Exp_Dbug;  use Exp_Dbug;\n+with Ghost;     use Ghost;\n+with Lib;       use Lib;\n+with Lib.Xref;  use Lib.Xref;\n+with Namet;     use Namet;\n+with Nmake;     use Nmake;\n+with Nlists;    use Nlists;\n+with Opt;       use Opt;\n+with Output;    use Output;\n+with Restrict;  use Restrict;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Cat;   use Sem_Cat;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch10;  use Sem_Ch10;\n+with Sem_Ch12;  use Sem_Ch12;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Disp;  use Sem_Disp;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Prag;  use Sem_Prag;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Warn;  use Sem_Warn;\n+with Snames;    use Snames;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n+with Sinput;    use Sinput;\n with Style;\n-with Uintp;    use Uintp;\n+with Uintp;     use Uintp;\n \n package body Sem_Ch7 is\n \n@@ -182,47 +183,6 @@ package body Sem_Ch7 is\n       end if;\n    end Analyze_Package_Body;\n \n-   -----------------------------------\n-   -- Analyze_Package_Body_Contract --\n-   -----------------------------------\n-\n-   procedure Analyze_Package_Body_Contract (Body_Id : Entity_Id) is\n-      Spec_Id   : constant Entity_Id := Spec_Entity (Body_Id);\n-      Mode      : SPARK_Mode_Type;\n-      Ref_State : Node_Id;\n-\n-   begin\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related package body.\n-\n-      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n-\n-      Ref_State := Get_Pragma (Body_Id, Pragma_Refined_State);\n-\n-      --  The analysis of pragma Refined_State detects whether the spec has\n-      --  abstract states available for refinement.\n-\n-      if Present (Ref_State) then\n-         Analyze_Refined_State_In_Decl_Part (Ref_State);\n-\n-      --  State refinement is required when the package declaration defines at\n-      --  least one abstract state. Null states are not considered. Refinement\n-      --  is not envorced when SPARK checks are turned off.\n-\n-      elsif SPARK_Mode /= Off\n-        and then Requires_State_Refinement (Spec_Id, Body_Id)\n-      then\n-         Error_Msg_N (\"package & requires state refinement\", Spec_Id);\n-      end if;\n-\n-      --  Restore the SPARK_Mode of the enclosing context after all delayed\n-      --  pragmas have been analyzed.\n-\n-      Restore_SPARK_Mode (Mode);\n-   end Analyze_Package_Body_Contract;\n-\n    ---------------------------------\n    -- Analyze_Package_Body_Helper --\n    ---------------------------------\n@@ -582,6 +542,30 @@ package body Sem_Ch7 is\n    --  Start of processing for Analyze_Package_Body_Helper\n \n    begin\n+      --  A [generic] package body \"freezes\" the contract of the nearest\n+      --  enclosing package body:\n+\n+      --    package body Nearest_Enclosing_Package\n+      --      with Refined_State => (State => Constit)\n+      --    is\n+      --       Constit : ...;\n+\n+      --       package body Freezes_Enclosing_Package_Body\n+      --         with Refined_State => (State_2 => Constit_2)\n+      --       is\n+      --          Constit_2 : ...;\n+\n+      --          procedure Proc\n+      --            with Refined_Depends => (Input => (Constit, Constit_2)) ...\n+\n+      --  This ensures that any annotations referenced by the contract of a\n+      --  [generic] subprogram body declared within the current package body\n+      --  are available. This form of \"freezing\" is decoupled from the usual\n+      --  Freeze_xxx mechanism because it must also work in the context of\n+      --  generics where normal freezing is disabled.\n+\n+      Analyze_Enclosing_Package_Body_Contract (N);\n+\n       --  Find corresponding package specification, and establish the current\n       --  scope. The visible defining entity for the package is the defining\n       --  occurrence in the spec. On exit from the package body, all body\n@@ -944,74 +928,6 @@ package body Sem_Ch7 is\n       Ghost_Mode := Save_Ghost_Mode;\n    end Analyze_Package_Body_Helper;\n \n-   ------------------------------\n-   -- Analyze_Package_Contract --\n-   ------------------------------\n-\n-   procedure Analyze_Package_Contract (Pack_Id : Entity_Id) is\n-      Items     : constant Node_Id := Contract (Pack_Id);\n-      Init      : Node_Id := Empty;\n-      Init_Cond : Node_Id := Empty;\n-      Mode      : SPARK_Mode_Type;\n-      Prag      : Node_Id;\n-      Prag_Nam  : Name_Id;\n-\n-   begin\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related package.\n-\n-      Save_SPARK_Mode_And_Set (Pack_Id, Mode);\n-\n-      if Present (Items) then\n-\n-         --  Locate and store pragmas Initial_Condition and Initializes since\n-         --  their order of analysis matters.\n-\n-         Prag := Classifications (Items);\n-         while Present (Prag) loop\n-            Prag_Nam := Pragma_Name (Prag);\n-\n-            if Prag_Nam = Name_Initial_Condition then\n-               Init_Cond := Prag;\n-\n-            elsif Prag_Nam = Name_Initializes then\n-               Init := Prag;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Analyze the initialization related pragmas. Initializes must come\n-         --  before Initial_Condition due to item dependencies.\n-\n-         if Present (Init) then\n-            Analyze_Initializes_In_Decl_Part (Init);\n-         end if;\n-\n-         if Present (Init_Cond) then\n-            Analyze_Initial_Condition_In_Decl_Part (Init_Cond);\n-         end if;\n-      end if;\n-\n-      --  Check whether the lack of indicator Part_Of agrees with the placement\n-      --  of the package instantiation with respect to the state space.\n-\n-      if Is_Generic_Instance (Pack_Id) then\n-         Prag := Get_Pragma (Pack_Id, Pragma_Part_Of);\n-\n-         if No (Prag) then\n-            Check_Missing_Part_Of (Pack_Id);\n-         end if;\n-      end if;\n-\n-      --  Restore the SPARK_Mode of the enclosing context after all delayed\n-      --  pragmas have been analyzed.\n-\n-      Restore_SPARK_Mode (Mode);\n-   end Analyze_Package_Contract;\n-\n    ---------------------------------\n    -- Analyze_Package_Declaration --\n    ---------------------------------"}, {"sha": "59f27b086bb8662beebfe74194450d010e9ba639", "filename": "gcc/ada/sem_ch7.ads", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch7.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_ch7.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,20 +32,6 @@ package Sem_Ch7 is\n    procedure Analyze_Package_Specification              (N : Node_Id);\n    procedure Analyze_Private_Type_Declaration           (N : Node_Id);\n \n-   procedure Analyze_Package_Body_Contract (Body_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of package body\n-   --  Body_Id as if they appeared at the end of a declarative region. The\n-   --  aspects that are considered are:\n-   --    Refined_State\n-\n-   procedure Analyze_Package_Contract (Pack_Id : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of package Pack_Id\n-   --  as if they appeared at the end of a declarative region. The aspects\n-   --  that are considered are:\n-   --    Initial_Condition\n-   --    Initializes\n-   --    Part_Of\n-\n    procedure End_Package_Scope (P : Entity_Id);\n    --  Calls Uninstall_Declarations, and then pops the scope stack\n "}, {"sha": "d97bc86de6cc04c105f7fa2e30fa28cde3b110a4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 150, "deletions": 272, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -29,62 +29,63 @@\n --  to complete the syntax checks. Certain pragmas are handled partially or\n --  completely by the parser (see Par.Prag for further details).\n \n-with Aspects;  use Aspects;\n-with Atree;    use Atree;\n-with Casing;   use Casing;\n-with Checks;   use Checks;\n-with Csets;    use Csets;\n-with Debug;    use Debug;\n-with Einfo;    use Einfo;\n-with Elists;   use Elists;\n-with Errout;   use Errout;\n-with Exp_Dist; use Exp_Dist;\n-with Exp_Util; use Exp_Util;\n-with Freeze;   use Freeze;\n-with Ghost;    use Ghost;\n-with Lib;      use Lib;\n-with Lib.Writ; use Lib.Writ;\n-with Lib.Xref; use Lib.Xref;\n-with Namet.Sp; use Namet.Sp;\n-with Nlists;   use Nlists;\n-with Nmake;    use Nmake;\n-with Output;   use Output;\n-with Par_SCO;  use Par_SCO;\n-with Restrict; use Restrict;\n-with Rident;   use Rident;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch6;  use Sem_Ch6;\n-with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch12; use Sem_Ch12;\n-with Sem_Ch13; use Sem_Ch13;\n-with Sem_Disp; use Sem_Disp;\n-with Sem_Dist; use Sem_Dist;\n-with Sem_Elim; use Sem_Elim;\n-with Sem_Eval; use Sem_Eval;\n-with Sem_Intr; use Sem_Intr;\n-with Sem_Mech; use Sem_Mech;\n-with Sem_Res;  use Sem_Res;\n-with Sem_Type; use Sem_Type;\n-with Sem_Util; use Sem_Util;\n-with Sem_Warn; use Sem_Warn;\n-with Stand;    use Stand;\n-with Sinfo;    use Sinfo;\n-with Sinfo.CN; use Sinfo.CN;\n-with Sinput;   use Sinput;\n-with Stringt;  use Stringt;\n-with Stylesw;  use Stylesw;\n+with Aspects;   use Aspects;\n+with Atree;     use Atree;\n+with Casing;    use Casing;\n+with Checks;    use Checks;\n+with Contracts; use Contracts;\n+with Csets;     use Csets;\n+with Debug;     use Debug;\n+with Einfo;     use Einfo;\n+with Elists;    use Elists;\n+with Errout;    use Errout;\n+with Exp_Dist;  use Exp_Dist;\n+with Exp_Util;  use Exp_Util;\n+with Freeze;    use Freeze;\n+with Ghost;     use Ghost;\n+with Lib;       use Lib;\n+with Lib.Writ;  use Lib.Writ;\n+with Lib.Xref;  use Lib.Xref;\n+with Namet.Sp;  use Namet.Sp;\n+with Nlists;    use Nlists;\n+with Nmake;     use Nmake;\n+with Output;    use Output;\n+with Par_SCO;   use Par_SCO;\n+with Restrict;  use Restrict;\n+with Rident;    use Rident;\n+with Rtsfind;   use Rtsfind;\n+with Sem;       use Sem;\n+with Sem_Aux;   use Sem_Aux;\n+with Sem_Ch3;   use Sem_Ch3;\n+with Sem_Ch6;   use Sem_Ch6;\n+with Sem_Ch8;   use Sem_Ch8;\n+with Sem_Ch12;  use Sem_Ch12;\n+with Sem_Ch13;  use Sem_Ch13;\n+with Sem_Disp;  use Sem_Disp;\n+with Sem_Dist;  use Sem_Dist;\n+with Sem_Elim;  use Sem_Elim;\n+with Sem_Eval;  use Sem_Eval;\n+with Sem_Intr;  use Sem_Intr;\n+with Sem_Mech;  use Sem_Mech;\n+with Sem_Res;   use Sem_Res;\n+with Sem_Type;  use Sem_Type;\n+with Sem_Util;  use Sem_Util;\n+with Sem_Warn;  use Sem_Warn;\n+with Stand;     use Stand;\n+with Sinfo;     use Sinfo;\n+with Sinfo.CN;  use Sinfo.CN;\n+with Sinput;    use Sinput;\n+with Stringt;   use Stringt;\n+with Stylesw;   use Stylesw;\n with Table;\n-with Targparm; use Targparm;\n-with Tbuild;   use Tbuild;\n+with Targparm;  use Targparm;\n+with Tbuild;    use Tbuild;\n with Ttypes;\n-with Uintp;    use Uintp;\n-with Uname;    use Uname;\n-with Urealp;   use Urealp;\n-with Validsw;  use Validsw;\n-with Warnsw;   use Warnsw;\n+with Uintp;     use Uintp;\n+with Uname;     use Uname;\n+with Urealp;    use Urealp;\n+with Validsw;   use Validsw;\n+with Warnsw;    use Warnsw;\n \n package body Sem_Prag is\n \n@@ -165,11 +166,6 @@ package body Sem_Prag is\n    -- Local Subprograms and Variables --\n    -------------------------------------\n \n-   procedure Add_Item (Item : Entity_Id; To_List : in out Elist_Id);\n-   --  Subsidiary routine to the analysis of pragmas Depends, Global and\n-   --  Refined_State. Append an entity to a list. If the list is empty, create\n-   --  a new list.\n-\n    function Adjust_External_Name_Case (N : Node_Id) return Node_Id;\n    --  This routine is used for possible casing adjustment of an explicit\n    --  external name supplied as a string literal (the node N), according to\n@@ -277,15 +273,6 @@ package body Sem_Prag is\n    --  pragma in the source program, a breakpoint on rv catches this place in\n    --  the source, allowing convenient stepping to the point of interest.\n \n-   --------------\n-   -- Add_Item --\n-   --------------\n-\n-   procedure Add_Item (Item : Entity_Id; To_List : in out Elist_Id) is\n-   begin\n-      Append_New_Elmt (Item, To => To_List);\n-   end Add_Item;\n-\n    -------------------------------\n    -- Adjust_External_Name_Case --\n    -------------------------------\n@@ -826,7 +813,7 @@ package body Sem_Prag is\n                         SPARK_Msg_NE\n                           (\"duplicate use of item &\", Item, Item_Id);\n                      else\n-                        Add_Item (Item_Id, Seen);\n+                        Append_New_Elmt (Item_Id, Seen);\n                      end if;\n \n                      --  Detect illegal use of an input related to a null\n@@ -846,7 +833,7 @@ package body Sem_Prag is\n                      --  of all processed inputs.\n \n                      if Is_Input or else Self_Ref then\n-                        Add_Item (Item_Id, All_Inputs_Seen);\n+                        Append_New_Elmt (Item_Id, All_Inputs_Seen);\n                      end if;\n \n                      --  State related checks (SPARK RM 6.1.5(3))\n@@ -901,15 +888,15 @@ package body Sem_Prag is\n                      --  processed items.\n \n                      if Ekind (Item_Id) = E_Abstract_State then\n-                        Add_Item (Item_Id, States_Seen);\n+                        Append_New_Elmt (Item_Id, States_Seen);\n                      end if;\n \n                      if Ekind_In (Item_Id, E_Abstract_State,\n                                            E_Constant,\n                                            E_Variable)\n                        and then Present (Encapsulating_State (Item_Id))\n                      then\n-                        Add_Item (Item_Id, Constits_Seen);\n+                        Append_New_Elmt (Item_Id, Constits_Seen);\n                      end if;\n \n                   --  All other input/output items are illegal\n@@ -2016,16 +2003,16 @@ package body Sem_Prag is\n             --  items.\n \n             else\n-               Add_Item (Item_Id, Seen);\n+               Append_New_Elmt (Item_Id, Seen);\n \n                if Ekind (Item_Id) = E_Abstract_State then\n-                  Add_Item (Item_Id, States_Seen);\n+                  Append_New_Elmt (Item_Id, States_Seen);\n                end if;\n \n                if Ekind_In (Item_Id, E_Abstract_State, E_Constant, E_Variable)\n                  and then Present (Encapsulating_State (Item_Id))\n                then\n-                  Add_Item (Item_Id, Constits_Seen);\n+                  Append_New_Elmt (Item_Id, Constits_Seen);\n                end if;\n             end if;\n          end Analyze_Global_Item;\n@@ -2396,14 +2383,14 @@ package body Sem_Prag is\n                   --  and variables.\n \n                   else\n-                     Add_Item (Item_Id, Items_Seen);\n+                     Append_New_Elmt (Item_Id, Items_Seen);\n \n                      if Ekind (Item_Id) = E_Abstract_State then\n-                        Add_Item (Item_Id, States_Seen);\n+                        Append_New_Elmt (Item_Id, States_Seen);\n                      end if;\n \n                      if Present (Encapsulating_State (Item_Id)) then\n-                        Add_Item (Item_Id, Constits_Seen);\n+                        Append_New_Elmt (Item_Id, Constits_Seen);\n                      end if;\n                   end if;\n \n@@ -2504,18 +2491,18 @@ package body Sem_Prag is\n                      --  Input is legal, add it to the list of processed inputs\n \n                      else\n-                        Add_Item (Input_Id, Inputs_Seen);\n+                        Append_New_Elmt (Input_Id, Inputs_Seen);\n \n                         if Ekind (Input_Id) = E_Abstract_State then\n-                           Add_Item (Input_Id, States_Seen);\n+                           Append_New_Elmt (Input_Id, States_Seen);\n                         end if;\n \n                         if Ekind_In (Input_Id, E_Abstract_State,\n                                                E_Constant,\n                                                E_Variable)\n                           and then Present (Encapsulating_State (Input_Id))\n                         then\n-                           Add_Item (Input_Id, Constits_Seen);\n+                           Append_New_Elmt (Input_Id, Constits_Seen);\n                         end if;\n                      end if;\n \n@@ -2610,7 +2597,7 @@ package body Sem_Prag is\n                if Comes_From_Source (Decl)\n                  and then Nkind (Decl) = N_Object_Declaration\n                then\n-                  Add_Item (Defining_Entity (Decl), States_And_Objs);\n+                  Append_New_Elmt (Defining_Entity (Decl), States_And_Objs);\n                end if;\n \n                Next (Decl);\n@@ -3481,8 +3468,8 @@ package body Sem_Prag is\n \n                if not Is_Child_Or_Sibling (Pack_Id, Scope (State_Id)) then\n                   SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote an abstract state of& \"\n-                     & \"or public descendant (SPARK RM 7.2.6(3))\",\n+                    (\"indicator Part_Of must denote an abstract state or \"\n+                     & \"public descendant of & (SPARK RM 7.2.6(3))\",\n                        Indic, Parent_Unit);\n \n                elsif Scope (State_Id) = Parent_Unit\n@@ -3494,8 +3481,8 @@ package body Sem_Prag is\n \n                else\n                   SPARK_Msg_NE\n-                    (\"indicator Part_Of must denote an abstract state of& \"\n-                     & \"or public descendant (SPARK RM 7.2.6(3))\",\n+                    (\"indicator Part_Of must denote an abstract state or \"\n+                     & \"public descendant of & (SPARK RM 7.2.6(3))\",\n                        Indic, Parent_Unit);\n                end if;\n \n@@ -22493,7 +22480,7 @@ package body Sem_Prag is\n          procedure Record_Item (Item_Id : Entity_Id) is\n          begin\n             if not Contains (Matched_Items, Item_Id) then\n-               Add_Item (Item_Id, Matched_Items);\n+               Append_New_Elmt (Item_Id, Matched_Items);\n             end if;\n          end Record_Item;\n \n@@ -23664,16 +23651,16 @@ package body Sem_Prag is\n              and then Has_Visible_Refinement (Encapsulating_State (Item_Id))\n             then\n                if Global_Mode = Name_Input then\n-                  Add_Item (Item_Id, In_Constits);\n+                  Append_New_Elmt (Item_Id, In_Constits);\n \n                elsif Global_Mode = Name_In_Out then\n-                  Add_Item (Item_Id, In_Out_Constits);\n+                  Append_New_Elmt (Item_Id, In_Out_Constits);\n \n                elsif Global_Mode = Name_Output then\n-                  Add_Item (Item_Id, Out_Constits);\n+                  Append_New_Elmt (Item_Id, Out_Constits);\n \n                elsif Global_Mode = Name_Proof_In then\n-                  Add_Item (Item_Id, Proof_In_Constits);\n+                  Append_New_Elmt (Item_Id, Proof_In_Constits);\n                end if;\n \n             --  When not a constituent, ensure that both occurrences of the\n@@ -23821,13 +23808,13 @@ package body Sem_Prag is\n             --  Add the item to the proper list\n \n             if Item_Mode = Name_Input then\n-               Add_Item (Item_Id, In_Items);\n+               Append_New_Elmt (Item_Id, In_Items);\n             elsif Item_Mode = Name_In_Out then\n-               Add_Item (Item_Id, In_Out_Items);\n+               Append_New_Elmt (Item_Id, In_Out_Items);\n             elsif Item_Mode = Name_Output then\n-               Add_Item (Item_Id, Out_Items);\n+               Append_New_Elmt (Item_Id, Out_Items);\n             elsif Item_Mode = Name_Proof_In then\n-               Add_Item (Item_Id, Proof_In_Items);\n+               Append_New_Elmt (Item_Id, Proof_In_Items);\n             end if;\n          end Collect_Global_Item;\n \n@@ -24091,7 +24078,10 @@ package body Sem_Prag is\n    -- Analyze_Refined_State_In_Decl_Part --\n    ----------------------------------------\n \n-   procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id) is\n+   procedure Analyze_Refined_State_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n       Body_Decl : constant Node_Id   := Find_Related_Package_Or_Body (N);\n       Body_Id   : constant Entity_Id := Defining_Entity (Body_Decl);\n       Spec_Id   : constant Entity_Id := Corresponding_Spec (Body_Decl);\n@@ -24109,23 +24099,20 @@ package body Sem_Prag is\n       --  A list that contains all constituents processed so far. The list is\n       --  used to detect multiple uses of the same constituent.\n \n+      Freeze_Posted : Boolean := False;\n+      --  A flag that controls the output of a freezing-related error (see use\n+      --  below).\n+\n       Refined_States_Seen : Elist_Id := No_Elist;\n       --  A list that contains all refined states processed so far. The list is\n       --  used to detect duplicate refinements.\n \n       procedure Analyze_Refinement_Clause (Clause : Node_Id);\n       --  Perform full analysis of a single refinement clause\n \n-      function Collect_Body_States (Pack_Id : Entity_Id) return Elist_Id;\n-      --  Gather the entities of all abstract states and objects declared in\n-      --  the body state space of package Pack_Id.\n-\n       procedure Report_Unrefined_States (States : Elist_Id);\n       --  Emit errors for all unrefined abstract states found in list States\n \n-      procedure Report_Unused_States (States : Elist_Id);\n-      --  Emit errors for all unused states found in list States\n-\n       -------------------------------\n       -- Analyze_Refinement_Clause --\n       -------------------------------\n@@ -24190,10 +24177,10 @@ package body Sem_Prag is\n \n             procedure Check_Matching_Constituent (Constit_Id : Entity_Id);\n             --  Determine whether constituent Constit denoted by its entity\n-            --  Constit_Id appears in Hidden_States. Emit an error when the\n+            --  Constit_Id appears in Body_States. Emit an error when the\n             --  constituent is not a valid hidden state of the related package\n             --  or when it is used more than once. Otherwise remove the\n-            --  constituent from Hidden_States.\n+            --  constituent from Body_States.\n \n             --------------------------------\n             -- Check_Matching_Constituent --\n@@ -24212,7 +24199,7 @@ package body Sem_Prag is\n                   --  Add the constituent to the list of processed items to aid\n                   --  with the detection of duplicates.\n \n-                  Add_Item (Constit_Id, Constituents_Seen);\n+                  Append_New_Elmt (Constit_Id, Constituents_Seen);\n \n                   --  Collect the constituent in the list of refinement items\n                   --  and establish a relation between the refined state and\n@@ -24436,12 +24423,56 @@ package body Sem_Prag is\n                if Is_Entity_Name (Constit) then\n                   Constit_Id := Entity_Of (Constit);\n \n-                  if Ekind_In (Constit_Id, E_Abstract_State,\n-                                           E_Constant,\n-                                           E_Variable)\n+                  --  When a constituent is declared after a subprogram body\n+                  --  that caused \"freezing\" of the related contract where\n+                  --  pragma Refined_State resides, the constituent appears\n+                  --  undefined and carries Any_Id as its entity.\n+\n+                  --    package body Pack\n+                  --      with Refined_State => (State => Constit)\n+                  --    is\n+                  --       procedure Proc\n+                  --         with Refined_Global => (Input => Constit)\n+                  --       is\n+                  --          ...\n+                  --       end Proc;\n+\n+                  --       Constit : ...;\n+                  --    end Pack;\n+\n+                  if Constit_Id = Any_Id then\n+                     SPARK_Msg_NE (\"& is undefined\", Constit, Constit_Id);\n+\n+                     --  Emit a specialized info message when the contract of\n+                     --  the related package body was \"frozen\" by another body.\n+                     --  Note that it is not possible to precisely identify why\n+                     --  the constituent is undefined because it is not visible\n+                     --  when pragma Refined_State is analyzed. This message is\n+                     --  a reasonable approximation.\n+\n+                     if Present (Freeze_Id) and then not Freeze_Posted then\n+                        Freeze_Posted := True;\n+\n+                        Error_Msg_Name_1 := Chars (Body_Id);\n+                        Error_Msg_Sloc   := Sloc (Freeze_Id);\n+                        SPARK_Msg_NE\n+                          (\"body & declared # freezes the contract of %\",\n+                           N, Freeze_Id);\n+                        SPARK_Msg_N\n+                          (\"\\all constituents must be declared before body #\",\n+                           N);\n+                     end if;\n+\n+                  --  The constituent is a valid state or object\n+\n+                  elsif Ekind_In (Constit_Id, E_Abstract_State,\n+                                              E_Constant,\n+                                              E_Variable)\n                   then\n                      Check_Matching_Constituent (Constit_Id);\n \n+                  --  Otherwise the constituent is illegal\n+\n                   else\n                      SPARK_Msg_NE\n                        (\"constituent & must denote object or state\",\n@@ -24519,7 +24550,7 @@ package body Sem_Prag is\n                --  been refined.\n \n                if Node (State_Elmt) = State_Id then\n-                  Add_Item (State_Id, Refined_States_Seen);\n+                  Append_New_Elmt (State_Id, Refined_States_Seen);\n                   Remove_Elmt (Available_States, State_Elmt);\n                   return;\n                end if;\n@@ -24754,104 +24785,6 @@ package body Sem_Prag is\n          Report_Unused_Constituents (Part_Of_Constits);\n       end Analyze_Refinement_Clause;\n \n-      -------------------------\n-      -- Collect_Body_States --\n-      -------------------------\n-\n-      function Collect_Body_States (Pack_Id : Entity_Id) return Elist_Id is\n-         Result : Elist_Id := No_Elist;\n-         --  A list containing all body states of Pack_Id\n-\n-         procedure Collect_Visible_States (Pack_Id : Entity_Id);\n-         --  Gather the entities of all abstract states and objects declared in\n-         --  the visible state space of package Pack_Id.\n-\n-         ----------------------------\n-         -- Collect_Visible_States --\n-         ----------------------------\n-\n-         procedure Collect_Visible_States (Pack_Id : Entity_Id) is\n-            Item_Id : Entity_Id;\n-\n-         begin\n-            --  Traverse the entity chain of the package and inspect all\n-            --  visible items.\n-\n-            Item_Id := First_Entity (Pack_Id);\n-            while Present (Item_Id) and then not In_Private_Part (Item_Id) loop\n-\n-               --  Do not consider internally generated items as those cannot\n-               --  be named and participate in refinement.\n-\n-               if not Comes_From_Source (Item_Id) then\n-                  null;\n-\n-               elsif Ekind (Item_Id) = E_Abstract_State then\n-                  Add_Item (Item_Id, Result);\n-\n-               --  Do not consider constants or variables that map generic\n-               --  formals to their actuals, as the formals cannot be named\n-               --  from the outside and participate in refinement.\n-\n-               elsif Ekind_In (Item_Id, E_Constant, E_Variable)\n-                 and then No (Corresponding_Generic_Association\n-                                (Declaration_Node (Item_Id)))\n-               then\n-                  Add_Item (Item_Id, Result);\n-\n-               --  Recursively gather the visible states of a nested package\n-\n-               elsif Ekind (Item_Id) = E_Package then\n-                  Collect_Visible_States (Item_Id);\n-               end if;\n-\n-               Next_Entity (Item_Id);\n-            end loop;\n-         end Collect_Visible_States;\n-\n-         --  Local variables\n-\n-         Pack_Body : constant Node_Id :=\n-                       Declaration_Node (Body_Entity (Pack_Id));\n-         Decl      : Node_Id;\n-         Item_Id   : Entity_Id;\n-\n-      --  Start of processing for Collect_Body_States\n-\n-      begin\n-         --  Inspect the declarations of the body looking for source objects,\n-         --  packages and package instantiations.\n-\n-         Decl := First (Declarations (Pack_Body));\n-         while Present (Decl) loop\n-\n-            --  Capture source objects as internally generated temporaries\n-            --  cannot be named and participate in refinement.\n-\n-            if Nkind (Decl) = N_Object_Declaration then\n-               Item_Id := Defining_Entity (Decl);\n-\n-               if Comes_From_Source (Item_Id) then\n-                  Add_Item (Item_Id, Result);\n-               end if;\n-\n-            --  Capture the visible abstract states and objects of a source\n-            --  package [instantiation].\n-\n-            elsif Nkind (Decl) = N_Package_Declaration then\n-               Item_Id := Defining_Entity (Decl);\n-\n-               if Comes_From_Source (Item_Id) then\n-                  Collect_Visible_States (Item_Id);\n-               end if;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-\n-         return Result;\n-      end Collect_Body_States;\n-\n       -----------------------------\n       -- Report_Unrefined_States --\n       -----------------------------\n@@ -24871,61 +24804,6 @@ package body Sem_Prag is\n          end if;\n       end Report_Unrefined_States;\n \n-      --------------------------\n-      -- Report_Unused_States --\n-      --------------------------\n-\n-      procedure Report_Unused_States (States : Elist_Id) is\n-         Posted     : Boolean := False;\n-         State_Elmt : Elmt_Id;\n-         State_Id   : Entity_Id;\n-\n-      begin\n-         if Present (States) then\n-            State_Elmt := First_Elmt (States);\n-            while Present (State_Elmt) loop\n-               State_Id := Node (State_Elmt);\n-\n-               --  Constants are part of the hidden state of a package, but the\n-               --  compiler cannot determine whether they have variable input\n-               --  (SPARK RM 7.1.1(2)) and cannot classify them properly as a\n-               --  hidden state. Do not emit an error when a constant does not\n-               --  participate in a state refinement, even though it acts as a\n-               --  hidden state.\n-\n-               if Ekind (State_Id) = E_Constant then\n-                  null;\n-\n-               --  Generate an error message of the form:\n-\n-               --    body of package ... has unused hidden states\n-               --      abstract state ... defined at ...\n-               --      variable ... defined at ...\n-\n-               else\n-                  if not Posted then\n-                     Posted := True;\n-                     SPARK_Msg_N\n-                       (\"body of package & has unused hidden states\", Body_Id);\n-                  end if;\n-\n-                  Error_Msg_Sloc := Sloc (State_Id);\n-\n-                  if Ekind (State_Id) = E_Abstract_State then\n-                     SPARK_Msg_NE\n-                       (\"\\abstract state & defined #\", Body_Id, State_Id);\n-\n-                  else\n-                     pragma Assert (Ekind (State_Id) = E_Variable);\n-                     SPARK_Msg_NE (\"\\variable & defined #\", Body_Id, State_Id);\n-                  end if;\n-               end if;\n-\n-               Next_Elmt (State_Elmt);\n-            end loop;\n-         end if;\n-      end Report_Unused_States;\n-\n       --  Local declarations\n \n       Clauses : constant Node_Id := Expression (Get_Argument (N, Spec_Id));\n@@ -24945,7 +24823,7 @@ package body Sem_Prag is\n       --  state space of the package body. These items must be utilized as\n       --  constituents in a state refinement.\n \n-      Body_States := Collect_Body_States (Spec_Id);\n+      Body_States := Collect_Body_States (Body_Id);\n \n       --  Multiple non-null state refinements appear as an aggregate\n \n@@ -24977,7 +24855,7 @@ package body Sem_Prag is\n       --  Ensure that all abstract states and objects declared in the body\n       --  state space of the related package are utilized as constituents.\n \n-      Report_Unused_States (Body_States);\n+      Report_Unused_Body_States (Body_Id, Body_States);\n    end Analyze_Refined_State_In_Decl_Part;\n \n    ------------------------------------\n@@ -25857,9 +25735,9 @@ package body Sem_Prag is\n \n             else\n                if Is_Input then\n-                  Add_Item (Item, Subp_Inputs);\n+                  Append_New_Elmt (Item, Subp_Inputs);\n                else\n-                  Add_Item (Item, Subp_Outputs);\n+                  Append_New_Elmt (Item, Subp_Outputs);\n                end if;\n             end if;\n          end Collect_Dependency_Item;\n@@ -25908,11 +25786,11 @@ package body Sem_Prag is\n          procedure Collect_Global_Item (Item : Node_Id; Mode : Name_Id) is\n          begin\n             if Nam_In (Mode, Name_In_Out, Name_Input) then\n-               Add_Item (Item, Subp_Inputs);\n+               Append_New_Elmt (Item, Subp_Inputs);\n             end if;\n \n             if Nam_In (Mode, Name_In_Out, Name_Output) then\n-               Add_Item (Item, Subp_Outputs);\n+               Append_New_Elmt (Item, Subp_Outputs);\n             end if;\n          end Collect_Global_Item;\n \n@@ -25988,14 +25866,14 @@ package body Sem_Prag is\n                               E_In_Out_Parameter,\n                               E_In_Parameter)\n          then\n-            Add_Item (Formal, Subp_Inputs);\n+            Append_New_Elmt (Formal, Subp_Inputs);\n          end if;\n \n          if Ekind_In (Formal, E_Generic_In_Out_Parameter,\n                               E_In_Out_Parameter,\n                               E_Out_Parameter)\n          then\n-            Add_Item (Formal, Subp_Outputs);\n+            Append_New_Elmt (Formal, Subp_Outputs);\n \n             --  Out parameters can act as inputs when the related type is\n             --  tagged, unconstrained array, unconstrained record or record\n@@ -26004,7 +25882,7 @@ package body Sem_Prag is\n             if Ekind (Formal) = E_Out_Parameter\n               and then Is_Unconstrained_Or_Tagged_Item (Formal)\n             then\n-               Add_Item (Formal, Subp_Inputs);\n+               Append_New_Elmt (Formal, Subp_Inputs);\n             end if;\n          end if;\n "}, {"sha": "45a3ebcc2eae5c853379e8d518420d4be53d368f", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -209,8 +209,12 @@ package Sem_Prag is\n    --  uses Analyze_Global_In_Decl_Part as a starting point, then performs\n    --  various consistency checks between Global and Refined_Global.\n \n-   procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of delayed pragma Refined_State\n+   procedure Analyze_Refined_State_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty);\n+   --  Perform full analysis of delayed pragma Refined_State. Freeze_Id denotes\n+   --  the entity of [generic] package body or [generic] subprogram body which\n+   --  caused \"freezing\" of the related contract where the pragma resides.\n \n    procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n    --  Perform preanalysis of pragma Test_Case"}, {"sha": "634b4790c61ad1c1a8e4d1f7d74ff62cc40d9e0d", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 282, "deletions": 392, "changes": 674, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -52,7 +52,6 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Attr; use Sem_Attr;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_Ch12; use Sem_Ch12;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n@@ -250,209 +249,6 @@ package body Sem_Util is\n       end if;\n    end Add_Block_Identifier;\n \n-   -----------------------\n-   -- Add_Contract_Item --\n-   -----------------------\n-\n-   procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id) is\n-      Items : Node_Id := Contract (Id);\n-\n-      procedure Add_Classification;\n-      --  Prepend Prag to the list of classifications\n-\n-      procedure Add_Contract_Test_Case;\n-      --  Prepend Prag to the list of contract and test cases\n-\n-      procedure Add_Pre_Post_Condition;\n-      --  Prepend Prag to the list of pre- and postconditions\n-\n-      ------------------------\n-      -- Add_Classification --\n-      ------------------------\n-\n-      procedure Add_Classification is\n-      begin\n-         Set_Next_Pragma (Prag, Classifications (Items));\n-         Set_Classifications (Items, Prag);\n-      end Add_Classification;\n-\n-      ----------------------------\n-      -- Add_Contract_Test_Case --\n-      ----------------------------\n-\n-      procedure Add_Contract_Test_Case is\n-      begin\n-         Set_Next_Pragma (Prag, Contract_Test_Cases (Items));\n-         Set_Contract_Test_Cases (Items, Prag);\n-      end Add_Contract_Test_Case;\n-\n-      ----------------------------\n-      -- Add_Pre_Post_Condition --\n-      ----------------------------\n-\n-      procedure Add_Pre_Post_Condition is\n-      begin\n-         Set_Next_Pragma (Prag, Pre_Post_Conditions (Items));\n-         Set_Pre_Post_Conditions (Items, Prag);\n-      end Add_Pre_Post_Condition;\n-\n-      --  Local variables\n-\n-      Prag_Nam : Name_Id;\n-\n-   --  Start of processing for Add_Contract_Item\n-\n-   begin\n-      --  A contract must contain only pragmas\n-\n-      pragma Assert (Nkind (Prag) = N_Pragma);\n-      Prag_Nam := Pragma_Name (Prag);\n-\n-      --  Create a new contract when adding the first item\n-\n-      if No (Items) then\n-         Items := Make_Contract (Sloc (Id));\n-         Set_Contract (Id, Items);\n-      end if;\n-\n-      --  Contract items related to constants. Applicable pragmas are:\n-      --    Part_Of\n-\n-      if Ekind (Id) = E_Constant then\n-         if Prag_Nam = Name_Part_Of then\n-            Add_Classification;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n-      --  Contract items related to [generic] packages or instantiations. The\n-      --  applicable pragmas are:\n-      --    Abstract_States\n-      --    Initial_Condition\n-      --    Initializes\n-      --    Part_Of (instantiation only)\n-\n-      elsif Ekind_In (Id, E_Generic_Package, E_Package) then\n-         if Nam_In (Prag_Nam, Name_Abstract_State,\n-                              Name_Initial_Condition,\n-                              Name_Initializes)\n-         then\n-            Add_Classification;\n-\n-         --  Indicator Part_Of must be associated with a package instantiation\n-\n-         elsif Prag_Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n-            Add_Classification;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n-      --  Contract items related to package bodies. The applicable pragmas are:\n-      --    Refined_States\n-\n-      elsif Ekind (Id) = E_Package_Body then\n-         if Prag_Nam = Name_Refined_State then\n-            Add_Classification;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n-      --  Contract items related to subprogram or entry declarations. The\n-      --  applicable pragmas are:\n-      --    Contract_Cases\n-      --    Depends\n-      --    Extensions_Visible\n-      --    Global\n-      --    Postcondition\n-      --    Precondition\n-      --    Test_Case\n-      --    Volatile_Function\n-\n-      elsif Ekind_In (Id, E_Entry, E_Entry_Family)\n-        or else Is_Generic_Subprogram (Id)\n-        or else Is_Subprogram (Id)\n-      then\n-         if Nam_In (Prag_Nam, Name_Postcondition, Name_Precondition) then\n-            Add_Pre_Post_Condition;\n-\n-         elsif Nam_In (Prag_Nam, Name_Contract_Cases, Name_Test_Case) then\n-            Add_Contract_Test_Case;\n-\n-         elsif Nam_In (Prag_Nam, Name_Depends,\n-                                 Name_Extensions_Visible,\n-                                 Name_Global)\n-         then\n-            Add_Classification;\n-\n-         elsif Prag_Nam = Name_Volatile_Function\n-           and then Ekind_In (Id, E_Function, E_Generic_Function)\n-         then\n-            Add_Classification;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n-      --  Contract items related to subprogram bodies. Applicable pragmas are:\n-      --    Postcondition\n-      --    Precondition\n-      --    Refined_Depends\n-      --    Refined_Global\n-      --    Refined_Post\n-\n-      elsif Ekind (Id) = E_Subprogram_Body then\n-         if Nam_In (Prag_Nam, Name_Refined_Depends, Name_Refined_Global) then\n-            Add_Classification;\n-\n-         elsif Nam_In (Prag_Nam, Name_Postcondition,\n-                                 Name_Precondition,\n-                                 Name_Refined_Post)\n-         then\n-            Add_Pre_Post_Condition;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-\n-      --  Contract items related to variables. Applicable pragmas are:\n-      --    Async_Readers\n-      --    Async_Writers\n-      --    Constant_After_Elaboration\n-      --    Effective_Reads\n-      --    Effective_Writes\n-      --    Part_Of\n-\n-      elsif Ekind (Id) = E_Variable then\n-         if Nam_In (Prag_Nam, Name_Async_Readers,\n-                              Name_Async_Writers,\n-                              Name_Constant_After_Elaboration,\n-                              Name_Effective_Reads,\n-                              Name_Effective_Writes,\n-                              Name_Part_Of)\n-         then\n-            Add_Classification;\n-\n-         --  The pragma is not a proper contract item\n-\n-         else\n-            raise Program_Error;\n-         end if;\n-      end if;\n-   end Add_Contract_Item;\n-\n    ----------------------------\n    -- Add_Global_Declaration --\n    ----------------------------\n@@ -3692,6 +3488,231 @@ package body Sem_Util is\n       end if;\n    end Check_Unprotected_Access;\n \n+   ------------------------------\n+   -- Check_Unused_Body_States --\n+   ------------------------------\n+\n+   procedure Check_Unused_Body_States (Body_Id : Entity_Id) is\n+      Legal_Constits : Boolean := True;\n+      --  This flag designates whether all constituents of pragma Refined_State\n+      --  are legal. The flag is used to suppress the generation of potentially\n+      --  misleading error messages due to a malformed pragma.\n+\n+      procedure Process_Refinement_Clause\n+        (Clause : Node_Id;\n+         States : Elist_Id);\n+      --  Inspect all constituents of refinement clause Clause and remove any\n+      --  matches from body state list States.\n+\n+      -------------------------------\n+      -- Process_Refinement_Clause --\n+      -------------------------------\n+\n+      procedure Process_Refinement_Clause\n+        (Clause : Node_Id;\n+         States : Elist_Id)\n+      is\n+         procedure Process_Constituent (Constit : Node_Id);\n+         --  Remove constituent Constit from body state list States\n+\n+         -------------------------\n+         -- Process_Constituent --\n+         -------------------------\n+\n+         procedure Process_Constituent (Constit : Node_Id) is\n+            Constit_Id : Entity_Id;\n+\n+         begin\n+            if Error_Posted (Constit) then\n+               Legal_Constits := False;\n+            end if;\n+\n+            --  Guard against illegal constituents. Only abstract states and\n+            --  objects can appear on the right hand side of a refinement.\n+\n+            if Is_Entity_Name (Constit) then\n+               Constit_Id := Entity_Of (Constit);\n+\n+               if Present (Constit_Id)\n+                 and then Ekind_In (Constit_Id, E_Abstract_State,\n+                                                E_Constant,\n+                                                E_Variable)\n+               then\n+                  Remove (States, Constit_Id);\n+               end if;\n+            end if;\n+         end Process_Constituent;\n+\n+         --  Local variables\n+\n+         Constit : Node_Id;\n+\n+      --  Start of processing for Process_Refinement_Clause\n+\n+      begin\n+         if Nkind (Clause) = N_Component_Association then\n+            Constit := Expression (Clause);\n+\n+            --  Multiple constituents appear as an aggregate\n+\n+            if Nkind (Constit) = N_Aggregate then\n+               Constit := First (Expressions (Constit));\n+               while Present (Constit) loop\n+                  Process_Constituent (Constit);\n+                  Next (Constit);\n+               end loop;\n+\n+            --  Various forms of a single constituent\n+\n+            else\n+               Process_Constituent (Constit);\n+            end if;\n+         end if;\n+      end Process_Refinement_Clause;\n+\n+      --  Local variables\n+\n+      Prag    : constant Node_Id   :=\n+                  Get_Pragma (Body_Id, Pragma_Refined_State);\n+      Spec_Id : constant Entity_Id := Spec_Entity (Body_Id);\n+      Clause  : Node_Id;\n+      States  : Elist_Id;\n+\n+   --  Start of processing for Check_Unused_Body_States\n+\n+   begin\n+      --  Inspect the clauses of pragma Refined_State and determine whether all\n+      --  visible states declared within the body of the package participate in\n+      --  the refinement.\n+\n+      if Present (Prag) then\n+         Clause := Expression (Get_Argument (Prag, Spec_Id));\n+         States := Collect_Body_States (Body_Id);\n+\n+         --  Multiple non-null state refinements appear as an aggregate\n+\n+         if Nkind (Clause) = N_Aggregate then\n+            Clause := First (Component_Associations (Clause));\n+            while Present (Clause) loop\n+               Process_Refinement_Clause (Clause, States);\n+               Next (Clause);\n+            end loop;\n+\n+         --  Various forms of a single state refinement\n+\n+         else\n+            Process_Refinement_Clause (Clause, States);\n+         end if;\n+\n+         --  Ensure that all abstract states and objects declared in the body\n+         --  state space of the related package are utilized as constituents.\n+\n+         if Legal_Constits then\n+            Report_Unused_Body_States (Body_Id, States);\n+         end if;\n+      end if;\n+   end Check_Unused_Body_States;\n+\n+   -------------------------\n+   -- Collect_Body_States --\n+   -------------------------\n+\n+   function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id is\n+      procedure Collect_Visible_States\n+        (Pack_Id : Entity_Id;\n+         States  : in out Elist_Id);\n+      --  Gather the entities of all abstract states and objects declared in\n+      --  the visible state space of package Pack_Id.\n+\n+      ----------------------------\n+      -- Collect_Visible_States --\n+      ----------------------------\n+\n+      procedure Collect_Visible_States\n+        (Pack_Id : Entity_Id;\n+         States  : in out Elist_Id)\n+      is\n+         Item_Id : Entity_Id;\n+\n+      begin\n+         --  Traverse the entity chain of the package and inspect all visible\n+         --  items.\n+\n+         Item_Id := First_Entity (Pack_Id);\n+         while Present (Item_Id) and then not In_Private_Part (Item_Id) loop\n+\n+            --  Do not consider internally generated items as those cannot be\n+            --  named and participate in refinement.\n+\n+            if not Comes_From_Source (Item_Id) then\n+               null;\n+\n+            elsif Ekind (Item_Id) = E_Abstract_State then\n+               Append_New_Elmt (Item_Id, States);\n+\n+            --  Do not consider objects that map generic formals to their\n+            --  actuals, as the formals cannot be named from the outside and\n+            --  participate in refinement.\n+\n+            elsif Ekind_In (Item_Id, E_Constant, E_Variable)\n+              and then No (Corresponding_Generic_Association\n+                             (Declaration_Node (Item_Id)))\n+            then\n+               Append_New_Elmt (Item_Id, States);\n+\n+            --  Recursively gather the visible states of a nested package\n+\n+            elsif Ekind (Item_Id) = E_Package then\n+               Collect_Visible_States (Item_Id, States);\n+            end if;\n+\n+            Next_Entity (Item_Id);\n+         end loop;\n+      end Collect_Visible_States;\n+\n+      --  Local variables\n+\n+      Body_Decl : constant Node_Id := Unit_Declaration_Node (Body_Id);\n+      Decl      : Node_Id;\n+      Item_Id   : Entity_Id;\n+      States    : Elist_Id := No_Elist;\n+\n+   --  Start of processing for Collect_Body_States\n+\n+   begin\n+      --  Inspect the declarations of the body looking for source objects,\n+      --  packages and package instantiations.\n+\n+      Decl := First (Declarations (Body_Decl));\n+      while Present (Decl) loop\n+\n+         --  Capture source objects as internally generated temporaries cannot\n+         --  be named and participate in refinement.\n+\n+         if Nkind (Decl) = N_Object_Declaration then\n+            Item_Id := Defining_Entity (Decl);\n+\n+            if Comes_From_Source (Item_Id) then\n+               Append_New_Elmt (Item_Id, States);\n+            end if;\n+\n+         --  Capture the visible abstract states and objects of a source\n+         --  package [instantiation].\n+\n+         elsif Nkind (Decl) = N_Package_Declaration then\n+            Item_Id := Defining_Entity (Decl);\n+\n+            if Comes_From_Source (Item_Id) then\n+               Collect_Visible_States (Item_Id, States);\n+            end if;\n+         end if;\n+\n+         Next (Decl);\n+      end loop;\n+\n+      return States;\n+   end Collect_Body_States;\n+\n    ------------------------\n    -- Collect_Interfaces --\n    ------------------------\n@@ -4766,147 +4787,6 @@ package body Sem_Util is\n       end if;\n    end Corresponding_Spec_Of;\n \n-   -----------------------------\n-   -- Create_Generic_Contract --\n-   -----------------------------\n-\n-   procedure Create_Generic_Contract (Unit : Node_Id) is\n-      Templ    : constant Node_Id   := Original_Node (Unit);\n-      Templ_Id : constant Entity_Id := Defining_Entity (Templ);\n-\n-      procedure Add_Generic_Contract_Pragma (Prag : Node_Id);\n-      --  Add a single contract-related source pragma Prag to the contract of\n-      --  generic template Templ_Id.\n-\n-      ---------------------------------\n-      -- Add_Generic_Contract_Pragma --\n-      ---------------------------------\n-\n-      procedure Add_Generic_Contract_Pragma (Prag : Node_Id) is\n-         Prag_Templ : Node_Id;\n-\n-      begin\n-         --  Mark the pragma to prevent the premature capture of global\n-         --  references when capturing global references of the context\n-         --  (see Save_References_In_Pragma).\n-\n-         Set_Is_Generic_Contract_Pragma (Prag);\n-\n-         --  Pragmas that apply to a generic subprogram declaration are not\n-         --  part of the semantic structure of the generic template:\n-\n-         --    generic\n-         --    procedure Example (Formal : Integer);\n-         --    pragma Precondition (Formal > 0);\n-\n-         --  Create a generic template for such pragmas and link the template\n-         --  of the pragma with the generic template.\n-\n-         if Nkind (Templ) = N_Generic_Subprogram_Declaration then\n-            Rewrite\n-              (Prag, Copy_Generic_Node (Prag, Empty, Instantiating => False));\n-            Prag_Templ := Original_Node (Prag);\n-\n-            Set_Is_Generic_Contract_Pragma (Prag_Templ);\n-            Add_Contract_Item (Prag_Templ, Templ_Id);\n-\n-         --  Otherwise link the pragma with the generic template\n-\n-         else\n-            Add_Contract_Item (Prag, Templ_Id);\n-         end if;\n-      end Add_Generic_Contract_Pragma;\n-\n-      --  Local variables\n-\n-      Context : constant Node_Id   := Parent (Unit);\n-      Decl    : Node_Id := Empty;\n-\n-   --  Start of processing for Create_Generic_Contract\n-\n-   begin\n-      --  A generic package declaration carries contract-related source pragmas\n-      --  in its visible declarations.\n-\n-      if Nkind (Templ) = N_Generic_Package_Declaration then\n-         Set_Ekind (Templ_Id, E_Generic_Package);\n-\n-         if Present (Visible_Declarations (Specification (Templ))) then\n-            Decl := First (Visible_Declarations (Specification (Templ)));\n-         end if;\n-\n-      --  A generic package body carries contract-related source pragmas in its\n-      --  declarations.\n-\n-      elsif Nkind (Templ) = N_Package_Body then\n-         Set_Ekind (Templ_Id, E_Package_Body);\n-\n-         if Present (Declarations (Templ)) then\n-            Decl := First (Declarations (Templ));\n-         end if;\n-\n-      --  Generic subprogram declaration\n-\n-      elsif Nkind (Templ) = N_Generic_Subprogram_Declaration then\n-         if Nkind (Specification (Templ)) = N_Function_Specification then\n-            Set_Ekind (Templ_Id, E_Generic_Function);\n-         else\n-            Set_Ekind (Templ_Id, E_Generic_Procedure);\n-         end if;\n-\n-         --  When the generic subprogram acts as a compilation unit, inspect\n-         --  the Pragmas_After list for contract-related source pragmas.\n-\n-         if Nkind (Context) = N_Compilation_Unit then\n-            if Present (Aux_Decls_Node (Context))\n-              and then Present (Pragmas_After (Aux_Decls_Node (Context)))\n-            then\n-               Decl := First (Pragmas_After (Aux_Decls_Node (Context)));\n-            end if;\n-\n-         --  Otherwise inspect the successive declarations for contract-related\n-         --  source pragmas.\n-\n-         else\n-            Decl := Next (Unit);\n-         end if;\n-\n-      --  A generic subprogram body carries contract-related source pragmas in\n-      --  its declarations.\n-\n-      elsif Nkind (Templ) = N_Subprogram_Body then\n-         Set_Ekind (Templ_Id, E_Subprogram_Body);\n-\n-         if Present (Declarations (Templ)) then\n-            Decl := First (Declarations (Templ));\n-         end if;\n-      end if;\n-\n-      --  Inspect the relevant declarations looking for contract-related source\n-      --  pragmas and add them to the contract of the generic unit.\n-\n-      while Present (Decl) loop\n-         if Comes_From_Source (Decl) then\n-            if Nkind (Decl) = N_Pragma then\n-\n-               --  The source pragma is a contract annotation\n-\n-               if Is_Contract_Annotation (Decl) then\n-                  Add_Generic_Contract_Pragma (Decl);\n-               end if;\n-\n-            --  The region where a contract-related source pragma may appear\n-            --  ends with the first source non-pragma declaration or statement.\n-\n-            else\n-               exit;\n-            end if;\n-         end if;\n-\n-         Next (Decl);\n-      end loop;\n-   end Create_Generic_Contract;\n-\n    --------------------\n    -- Current_Entity --\n    --------------------\n@@ -10249,53 +10129,6 @@ package body Sem_Util is\n       end if;\n    end Inherit_Rep_Item_Chain;\n \n-   ---------------------------------\n-   -- Inherit_Subprogram_Contract --\n-   ---------------------------------\n-\n-   procedure Inherit_Subprogram_Contract\n-     (Subp      : Entity_Id;\n-      From_Subp : Entity_Id)\n-   is\n-      procedure Inherit_Pragma (Prag_Id : Pragma_Id);\n-      --  Propagate a pragma denoted by Prag_Id from From_Subp's contract to\n-      --  Subp's contract.\n-\n-      --------------------\n-      -- Inherit_Pragma --\n-      --------------------\n-\n-      procedure Inherit_Pragma (Prag_Id : Pragma_Id) is\n-         Prag     : constant Node_Id := Get_Pragma (From_Subp, Prag_Id);\n-         New_Prag : Node_Id;\n-\n-      begin\n-         --  A pragma cannot be part of more than one First_Pragma/Next_Pragma\n-         --  chains, therefore the node must be replicated. The new pragma is\n-         --  flagged is inherited for distrinction purposes.\n-\n-         if Present (Prag) then\n-            New_Prag := New_Copy_Tree (Prag);\n-            Set_Is_Inherited (New_Prag);\n-\n-            Add_Contract_Item (New_Prag, Subp);\n-         end if;\n-      end Inherit_Pragma;\n-\n-   --   Start of processing for Inherit_Subprogram_Contract\n-\n-   begin\n-      --  Inheritance is carried out only when both entities are subprograms\n-      --  with contracts.\n-\n-      if Is_Subprogram_Or_Generic_Subprogram (Subp)\n-        and then Is_Subprogram_Or_Generic_Subprogram (From_Subp)\n-        and then Present (Contract (From_Subp))\n-      then\n-         Inherit_Pragma (Pragma_Extensions_Visible);\n-      end if;\n-   end Inherit_Subprogram_Contract;\n-\n    ---------------------------------\n    -- Insert_Explicit_Dereference --\n    ---------------------------------\n@@ -17171,6 +17004,63 @@ package body Sem_Util is\n                (Boolean_Literals (not Range_Checks_Suppressed (E)), Loc);\n    end Rep_To_Pos_Flag;\n \n+   -------------------------------\n+   -- Report_Unused_Body_States --\n+   -------------------------------\n+\n+   procedure Report_Unused_Body_States\n+     (Body_Id : Entity_Id;\n+      States  : Elist_Id)\n+   is\n+      Posted     : Boolean := False;\n+      State_Elmt : Elmt_Id;\n+      State_Id   : Entity_Id;\n+\n+   begin\n+      if Present (States) then\n+         State_Elmt := First_Elmt (States);\n+         while Present (State_Elmt) loop\n+            State_Id := Node (State_Elmt);\n+\n+            --  Constants are part of the hidden state of a package, but the\n+            --  compiler cannot determine whether they have variable input\n+            --  (SPARK RM 7.1.1(2)) and cannot classify them properly as a\n+            --  hidden state. Do not emit an error when a constant does not\n+            --  participate in a state refinement, even though it acts as a\n+            --  hidden state.\n+\n+            if Ekind (State_Id) = E_Constant then\n+               null;\n+\n+            --  Generate an error message of the form:\n+\n+            --    body of package ... has unused hidden states\n+            --      abstract state ... defined at ...\n+            --      variable ... defined at ...\n+\n+            else\n+               if not Posted then\n+                  Posted := True;\n+                  SPARK_Msg_N\n+                    (\"body of package & has unused hidden states\", Body_Id);\n+               end if;\n+\n+               Error_Msg_Sloc := Sloc (State_Id);\n+\n+               if Ekind (State_Id) = E_Abstract_State then\n+                  SPARK_Msg_NE\n+                    (\"\\abstract state & defined #\", Body_Id, State_Id);\n+\n+               else\n+                  SPARK_Msg_NE (\"\\variable & defined #\", Body_Id, State_Id);\n+               end if;\n+            end if;\n+\n+            Next_Elmt (State_Elmt);\n+         end loop;\n+      end if;\n+   end Report_Unused_Body_States;\n+\n    --------------------\n    -- Require_Entity --\n    --------------------"}, {"sha": "81e63ed73d7cd6994debfd60bf42bd2975a20b58", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 24, "deletions": 47, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -49,32 +49,6 @@ package Sem_Util is\n    --  it the identifier of the block. Id denotes the generated entity. If the\n    --  block already has an identifier, Id returns the entity of its label.\n \n-   procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id);\n-   --  Add pragma Prag to the contract of a constant, entry, package [body],\n-   --  subprogram [body] or variable denoted by Id. The following are valid\n-   --  pragmas:\n-   --    Abstract_State\n-   --    Async_Readers\n-   --    Async_Writers\n-   --    Constant_After_Elaboration\n-   --    Contract_Cases\n-   --    Depends\n-   --    Effective_Reads\n-   --    Effective_Writes\n-   --    Extensions_Visible\n-   --    Global\n-   --    Initial_Condition\n-   --    Initializes\n-   --    Part_Of\n-   --    Postcondition\n-   --    Precondition\n-   --    Refined_Depends\n-   --    Refined_Global\n-   --    Refined_Post\n-   --    Refined_States\n-   --    Test_Case\n-   --    Volatile_Function\n-\n    procedure Add_Global_Declaration (N : Node_Id);\n    --  These procedures adds a declaration N at the library level, to be\n    --  elaborated before any other code in the unit. It is used for example\n@@ -276,6 +250,14 @@ package Sem_Util is\n    --  error message on node N. Used in object declarations, type conversions\n    --  and qualified expressions.\n \n+   procedure Check_Function_With_Address_Parameter (Subp_Id : Entity_Id);\n+   --  A subprogram that has an Address parameter and is declared in a Pure\n+   --  package is not considered Pure, because the parameter may be used as a\n+   --  pointer and the referenced data may change even if the address value\n+   --  itself does not.\n+   --  If the programmer gave an explicit Pure_Function pragma, then we respect\n+   --  the pragma and leave the subprogram Pure.\n+\n    procedure Check_Function_Writable_Actuals (N : Node_Id);\n    --  (Ada 2012): If the construct N has two or more direct constituents that\n    --  are names or expressions whose evaluation may occur in an arbitrary\n@@ -322,19 +304,20 @@ package Sem_Util is\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n \n-   procedure Check_Function_With_Address_Parameter (Subp_Id : Entity_Id);\n-   --  A subprogram that has an Address parameter and is declared in a Pure\n-   --  package is not considered Pure, because the parameter may be used as a\n-   --  pointer and the referenced data may change even if the address value\n-   --  itself does not.\n-   --  If the programmer gave an explicit Pure_Function pragma, then we respect\n-   --  the pragma and leave the subprogram Pure.\n-\n    procedure Check_Result_And_Post_State (Subp_Id : Entity_Id);\n    --  Determine whether the contract of subprogram Subp_Id mentions attribute\n    --  'Result and it contains an expression that evaluates differently in pre-\n    --  and post-state.\n \n+   procedure Check_Unused_Body_States (Body_Id : Entity_Id);\n+   --  Verify that all abstract states and object declared in the state space\n+   --  of a package body denoted by entity Body_Id are used as constituents.\n+   --  Emit an error if this is not the case.\n+\n+   function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id;\n+   --  Gather the entities of all abstract states and objects declared in the\n+   --  body state space of package body Body_Id.\n+\n    procedure Check_Unprotected_Access\n      (Context : Node_Id;\n       Expr    : Node_Id);\n@@ -434,11 +417,6 @@ package Sem_Util is\n    --  Return the corresponding spec of Decl when it denotes a package or a\n    --  subprogram [stub], or the defining entity of Decl.\n \n-   procedure Create_Generic_Contract (Unit : Node_Id);\n-   --  Create a contract node for a generic package, generic subprogram or a\n-   --  generic body denoted by Unit by collecting all source contract-related\n-   --  pragmas in the contract of the unit.\n-\n    function Current_Entity (N : Node_Id) return Entity_Id;\n    pragma Inline (Current_Entity);\n    --  Find the currently visible definition for a given identifier, that is to\n@@ -1159,14 +1137,6 @@ package Sem_Util is\n    --  Inherit the rep item chain of type From_Typ without clobbering any\n    --  existing rep items on Typ's chain. Typ is the destination type.\n \n-   procedure Inherit_Subprogram_Contract\n-     (Subp      : Entity_Id;\n-      From_Subp : Entity_Id);\n-   --  Inherit relevant contract items from source subprogram From_Subp. Subp\n-   --  denotes the destination subprogram. The inherited items are:\n-   --    Extensions_Visible\n-   --  ??? it would be nice if this routine handles Pre'Class and Post'Class\n-\n    procedure Insert_Explicit_Dereference (N : Node_Id);\n    --  In a context that requires a composite or subprogram type and where a\n    --  prefix is an access type, rewrite the access type node N (which is the\n@@ -1877,6 +1847,13 @@ package Sem_Util is\n    --  more there is at least one case in the generated code (the code for\n    --  array assignment in a loop) that depends on this suppression.\n \n+   procedure Report_Unused_Body_States\n+     (Body_Id : Entity_Id;\n+      States  : Elist_Id);\n+   --  Emit errors for each abstract state or object found in list States that\n+   --  is declared in package body Body_Id, but is not used as constituent in a\n+   --  state refinement.\n+\n    procedure Require_Entity (N : Node_Id);\n    --  N is a node which should have an entity value if it is an entity name.\n    --  If not, then check if there were previous errors. If so, just fill"}, {"sha": "0fc3851bac7e7d32f574153ed283aa94adeb3732", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -1860,6 +1860,14 @@ package body Sinfo is\n       return Flag11 (N);\n    end Is_Expanded_Build_In_Place_Call;\n \n+   function Is_Expanded_Contract\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      return Flag1 (N);\n+   end Is_Expanded_Contract;\n+\n    function Is_Finalization_Wrapper\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5073,6 +5081,14 @@ package body Sinfo is\n       Set_Flag11 (N, Val);\n    end Set_Is_Expanded_Build_In_Place_Call;\n \n+   procedure Set_Is_Expanded_Contract\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Contract);\n+      Set_Flag1 (N, Val);\n+   end Set_Is_Expanded_Contract;\n+\n    procedure Set_Is_Finalization_Wrapper\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "5f2f0920eaff1258f436a63c0ff962f431cc8f19", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -1542,6 +1542,10 @@ package Sinfo is\n    --    is called in a dispatching context. Used to prevent a formal/actual\n    --    mismatch when the call is rewritten as a dispatching call.\n \n+   --  Is_Expanded_Contract (Flag1-Sem)\n+   --    Present in N_Contract nodes. Set if the contract has already undergone\n+   --    expansion activities.\n+\n    --  Is_Asynchronous_Call_Block (Flag7-Sem)\n    --    A flag set in a Block_Statement node to indicate that it is the\n    --    expansion of an asynchronous entry call. Such a block needs cleanup\n@@ -7564,6 +7568,7 @@ package Sinfo is\n       --  Pre_Post_Conditions (Node1-Sem) (set to Empty if none)\n       --  Contract_Test_Cases (Node2-Sem) (set to Empty if none)\n       --  Classifications (Node3-Sem) (set to Empty if none)\n+      --  Is_Expanded_Contract (Flag1-Sem)\n \n       --  Pre_Post_Conditions contains a collection of pragmas that correspond\n       --  to pre- and postconditions associated with an entry or a subprogram\n@@ -7592,16 +7597,19 @@ package Sinfo is\n       --    Abstract_States\n       --    Async_Readers\n       --    Async_Writers\n+      --    Constant_After_Elaboration\n       --    Depends\n       --    Effective_Reads\n       --    Effective_Writes\n+      --    Extensions_Visible\n       --    Global\n       --    Initial_Condition\n       --    Initializes\n       --    Part_Of\n       --    Refined_Depends\n       --    Refined_Global\n       --    Refined_States\n+      --    Volatile_Function\n       --  The ordering is in LIFO fashion.\n \n       -------------------\n@@ -9322,6 +9330,9 @@ package Sinfo is\n    function Is_Expanded_Build_In_Place_Call\n      (N : Node_Id) return Boolean;    -- Flag11\n \n+   function Is_Expanded_Contract\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function Is_Finalization_Wrapper\n      (N : Node_Id) return Boolean;    -- Flag9\n \n@@ -10348,6 +10359,9 @@ package Sinfo is\n    procedure Set_Is_Expanded_Build_In_Place_Call\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n+   procedure Set_Is_Expanded_Contract\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_Is_Finalization_Wrapper\n      (N : Node_Id; Val : Boolean := True);    -- Flag9\n \n@@ -12748,6 +12762,7 @@ package Sinfo is\n    pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n+   pragma Inline (Is_Expanded_Contract);\n    pragma Inline (Is_Finalization_Wrapper);\n    pragma Inline (Is_Folded_In_Parser);\n    pragma Inline (Is_Generic_Contract_Pragma);\n@@ -13085,6 +13100,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);\n+   pragma Inline (Set_Is_Expanded_Contract);\n    pragma Inline (Set_Is_Finalization_Wrapper);\n    pragma Inline (Set_Is_Folded_In_Parser);\n    pragma Inline (Set_Is_Generic_Contract_Pragma);"}, {"sha": "b26c583ea93c1086fea92830c714bab6fdaa5434", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -127,7 +127,7 @@ package body Switch.B is\n       --  A little check, \"gnat\" at the start of a switch is not allowed except\n       --  for the compiler\n \n-      if Switch_Chars'Last >= Ptr + 3\n+      if Max >= Ptr + 3\n         and then Switch_Chars (Ptr .. Ptr + 3) = \"gnat\"\n       then\n          Osint.Fail (\"invalid switch: \"\"\" & Switch_Chars & \"\"\"\"\n@@ -229,8 +229,28 @@ package body Switch.B is\n          --  Processing for E switch\n \n          when 'E' =>\n-            Ptr := Ptr + 1;\n+\n+            --  -E is equivalent to -Ea (see below)\n+\n             Exception_Tracebacks := True;\n+            Ptr := Ptr + 1;\n+\n+            if Ptr <= Max then\n+               case Switch_Chars (Ptr) is\n+\n+                  --  -Ea sets Exception_Tracebacks\n+\n+                  when 'a' => null;\n+\n+                  --  -Es sets both Exception_Tracebacks and\n+                  --  Exception_Tracebacks_Symbolic.\n+\n+                  when 's' => Exception_Tracebacks_Symbolic := True;\n+                  when others => Bad_Switch (Switch_Chars);\n+               end case;\n+\n+               Ptr := Ptr + 1;\n+            end if;\n \n          --  Processing for F switch\n \n@@ -542,13 +562,11 @@ package body Switch.B is\n                   declare\n                      Src_Path_Name : constant String_Ptr :=\n                                        Get_RTS_Search_Dir\n-                                         (Switch_Chars\n-                                           (Ptr + 1 .. Switch_Chars'Last),\n+                                         (Switch_Chars (Ptr + 1 .. Max),\n                                           Include);\n                      Lib_Path_Name : constant String_Ptr :=\n                                        Get_RTS_Search_Dir\n-                                         (Switch_Chars\n-                                           (Ptr + 1 .. Switch_Chars'Last),\n+                                         (Switch_Chars (Ptr + 1 .. Max),\n                                           Objects);\n \n                   begin"}, {"sha": "e22296a15b4eefaed211a0ff956b0507dd2cd446", "filename": "gcc/ada/switch-b.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fswitch-b.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/879ac954ef76a1af1888abfaa44257f6f728372b/gcc%2Fada%2Fswitch-b.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.ads?ref=879ac954ef76a1af1888abfaa44257f6f728372b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2001-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,7 +32,7 @@\n package Switch.B is\n \n    procedure Scan_Binder_Switches (Switch_Chars : String);\n-   --  Procedures to scan out binder switches stored in the given string.\n+   --  Procedure to scan out binder switches stored in the given string.\n    --  The first character is known to be a valid switch character, and there\n    --  are no blanks or other switch terminator characters in the string, so\n    --  the entire string should consist of valid switch characters, except that"}]}