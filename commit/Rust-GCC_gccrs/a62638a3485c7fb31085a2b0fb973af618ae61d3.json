{"sha": "a62638a3485c7fb31085a2b0fb973af618ae61d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYyNjM4YTM0ODVjN2ZiMzEwODVhMmIwZmI5NzNhZjYxOGFlNjFkMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2015-03-24T11:49:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-24T11:49:20Z"}, "message": "building_executable_programs_with_gnat.rst, [...]: Doc improvements.\n\n\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst,\n\tdoc/gnat_ugn/gnat_utility_programs.rst\n\tdoc/gnat_rm/implementation_defined_attributes.rst\n\tdoc/gnat_rm/implementation_defined_pragmas.rst\n\tdoc/gnat_rm/representation_clauses_and_pragmas.rst\n\tdoc/gnat_rm/about_this_guide.rst\n\tdoc/gnat_rm/implementation_of_ada_2012_features.rst: Doc improvements.\n\t* gnat_rm.texi, gnat_ugn.texi: Regenerate.\n\nFrom-SVN: r221628", "tree": {"sha": "8b77280a83f0d06beef96f0387602fbe37fe9a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b77280a83f0d06beef96f0387602fbe37fe9a43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a62638a3485c7fb31085a2b0fb973af618ae61d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62638a3485c7fb31085a2b0fb973af618ae61d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a62638a3485c7fb31085a2b0fb973af618ae61d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a62638a3485c7fb31085a2b0fb973af618ae61d3/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2581005856d53ccff513e04c05a85c97ef474df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2581005856d53ccff513e04c05a85c97ef474df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2581005856d53ccff513e04c05a85c97ef474df"}], "stats": {"total": 1831, "additions": 959, "deletions": 872}, "files": [{"sha": "dc0f8537f9d133a1e488c812cd847dea462cb5d8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -1,3 +1,14 @@\n+2015-03-24  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst,\n+\tdoc/gnat_ugn/gnat_utility_programs.rst\n+\tdoc/gnat_rm/implementation_defined_attributes.rst\n+\tdoc/gnat_rm/implementation_defined_pragmas.rst\n+\tdoc/gnat_rm/representation_clauses_and_pragmas.rst\n+\tdoc/gnat_rm/about_this_guide.rst\n+\tdoc/gnat_rm/implementation_of_ada_2012_features.rst: Doc improvements.\n+\t* gnat_rm.texi, gnat_ugn.texi: Regenerate.\n+\n 2015-03-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/65522"}, {"sha": "09eacebe0e451ba40f0b72ce39be5e106eabb7c8", "filename": "gcc/ada/doc/gnat_rm/about_this_guide.rst", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fabout_this_guide.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -115,10 +115,9 @@ This reference manual contains the following chapters:\n This reference manual assumes a basic familiarity with the Ada 95 language, as\n described in the \n :title:`International Standard ANSI/ISO/IEC-8652:1995`.\n-It does not require knowledge of the new features introduced by Ada 2005,\n-(officially known as `ISO/IEC 8652:1995 with Technical Corrigendum 1\n-and Amendment 1`).\n-Both reference manuals are included in the GNAT documentation\n+It does not require knowledge of the new features introduced by Ada 2005 or\n+Ada 2012.\n+All three reference manuals are included in the GNAT documentation\n package.\n \n Conventions"}, {"sha": "94bb129ffd5ed7d10d185ea9e163a2f893c4b2f0", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_attributes.rst", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_attributes.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -146,7 +146,7 @@ an address clause as in the following example:\n   procedure L;\n   for L'Address use K'Address;\n   pragma Import (Ada, L);\n-  \n+\n \n A call to `L` is then expected to result in a call to `K`.\n In Ada 83, where there were no access-to-subprogram values, this was\n@@ -186,6 +186,7 @@ attribute in the generic instance when applied to a scalar type or a\n record type without discriminants is always `True`. This usage is\n compatible with older Ada compilers, including notably DEC Ada.\n \n+\n Attribute Default_Bit_Order\n ===========================\n .. index:: Big endian\n@@ -214,6 +215,16 @@ order (as specified using pragma `Default_Scalar_Storage_Order`, or\n equal to `Default_Bit_Order` if unspecified) as a\n `System.Bit_Order` value. This is a static attribute.\n \n+Attribute Deref\n+===============\n+.. index:: Deref\n+\n+The attribute `typ'Deref(expr)` where `expr` is of type `System.Address` yields\n+the variable of type `typ` that is located at the given address. It is similar\n+to `(totyp (expr).all)`, where `totyp` is an unchecked conversion from address to\n+a named access-to-`typ` type, except that it yields a variable, so it can be\n+used on the left side of an assignment.\n+\n Attribute Descriptor_Size\n =========================\n .. index:: Descriptor\n@@ -232,7 +243,7 @@ the first element of the array.\n \n   type Unconstr_Array is array (Positive range <>) of Boolean;\n   Put_Line (\"Descriptor size = \" & Unconstr_Array'Descriptor_Size'Img);\n-  \n+\n \n The attribute takes into account any additional padding due to type alignment.\n In the example above, the descriptor contains two values of type\n@@ -331,7 +342,7 @@ function with the following spec:\n .. code-block:: ada\n \n   function S'Enum_Rep (Arg : S'Base) return <Universal_Integer>;\n-  \n+\n \n It is also allowable to apply `Enum_Rep` directly to an object of an\n enumeration type or to a non-overloaded enumeration\n@@ -366,7 +377,7 @@ function with the following spec:\n .. code-block:: ada\n \n   function S'Enum_Val (Arg : <Universal_Integer>) return S'Base;\n-  \n+\n \n The function returns the enumeration value whose representation matches the\n argument, or raises Constraint_Error if no enumeration literal of the type\n@@ -403,11 +414,11 @@ function with the following specification:\n .. code-block:: ada\n \n   function S'Fixed_Value (Arg : <Universal_Integer>) return S;\n-  \n+\n The value returned is the fixed-point value `V` such that::\n \n   V = Arg * S'Small\n-  \n+\n \n The effect is thus similar to first converting the argument to the\n integer type used to represent `S`, and then doing an unchecked\n@@ -461,14 +472,14 @@ debugging:\n .. code-block:: ada\n \n   Put_Line (\"X = \" & X'Img);\n-  \n+\n \n has the same meaning as the more verbose:\n \n .. code-block:: ada\n \n   Put_Line (\"X = \" & T'Image (X));\n-  \n+\n where `T` is the (sub)type of the object `X`.\n \n Note that technically, in analogy to `Image`,\n@@ -491,7 +502,7 @@ function with the following spec:\n The value returned is the integer value `V`, such that::\n \n   Arg = V * T'Small\n-  \n+\n \n where `T` is the type of `Arg`.\n The effect is thus similar to first doing an unchecked conversion from\n@@ -550,7 +561,7 @@ in this example:\n        \"Gen can only be instantiated at library level\");\n     ...\n   end Gen;\n-  \n+\n \n Attribute Lock_Free\n ===================\n@@ -566,7 +577,7 @@ Attribute Loop_Entry\n Syntax::\n \n   X'Loop_Entry [(loop_name)]\n-  \n+\n \n The `Loop_Entry` attribute is used to refer to the value that an\n expression had upon entry to a given loop in much the same way that the\n@@ -678,7 +689,7 @@ Similarly, a record containing an integer and a character:\n      I : Integer;\n      C : Character;\n   end record;\n-  \n+\n \n will have a size of 40 (that is `Rec'Size` will be 40).  The\n alignment will be 4, because of the\n@@ -715,7 +726,7 @@ Consider this example:\n              type \"R1\" defined at line 3\n \n   13. end;\n-  \n+\n \n In the absence of lines 5 and 6,\n types `R1` and `R2` statically match and\n@@ -765,8 +776,8 @@ bounds are allocated just before the first component,\n whereas ``X'Address`` returns the address of the first\n component.\n \n-Here, we are interpreting 'storage pool' broadly to mean \n-``wherever the object is allocated``, which could be a \n+Here, we are interpreting 'storage pool' broadly to mean\n+``wherever the object is allocated``, which could be a\n user-defined storage pool,\n the global heap, on the stack, or in a static memory area.\n For an object created by `new`, ``Ptr.all'Pool_Address`` is\n@@ -803,7 +814,7 @@ There are two forms:\n \n   System'Restriction_Set (partition_boolean_restriction_NAME)\n   System'Restriction_Set (No_Dependence => library_unit_NAME);\n-  \n+\n \n In the case of the first form, the only restriction names\n allowed are parameterless restrictions that are checked\n@@ -839,7 +850,7 @@ So for example if you write\n   else\n      ...\n   end if;\n-  \n+\n \n And the result is False, so that the else branch is executed,\n you can assume that this restriction is not set for any unit\n@@ -939,7 +950,7 @@ of the use of this feature:\n      --  If Scalar_Storage_Order is specified, it must be consistent with\n      --  Bit_Order, so it's best to always define the latter explicitly if\n      --  the former is used.\n-  \n+\n \n Other properties are as for standard representation attribute `Bit_Order`,\n as defined by Ada RM 13.5.3(4). The default is `System.Default_Bit_Order`.\n@@ -1020,7 +1031,7 @@ via an attribute_definition_clause (or by specifying the equivalent aspect):\n \n   for Acc'Simple_Storage_Pool use My_Pool;\n \n-  \n+\n \n The name given in an attribute_definition_clause for the\n `Simple_Storage_Pool` attribute shall denote a variable of\n@@ -1174,7 +1185,7 @@ corresponding actual subtype.  The value of this attribute is of type\n      Type_Class_Access,\n      Type_Class_Task,\n      Type_Class_Address);\n-  \n+\n \n Protected types yield the value `Type_Class_Task`, which thus\n applies to all concurrent types.  This attribute is designed to\n@@ -1241,7 +1252,7 @@ For example, the following program prints the first 50 digits of pi:\n   begin\n      Put (Ada.Numerics.Pi'Universal_Literal_String);\n   end;\n-  \n+\n \n Attribute Unrestricted_Access\n =============================\n@@ -1291,7 +1302,7 @@ has returned, such calls are erroneous. For example:\n      end P2;\n \n   end P;\n-  \n+\n \n When P1 is called from P2, the call via Global is OK, but if P1 were\n called after P2 returns, it would be an erroneous use of a dangling\n@@ -1348,7 +1359,7 @@ reject the use as illegal, as shown in the following example:\n \n      P (X2'Unrestricted_Access);         -- OK\n   end;\n-  \n+\n \n but other cases cannot be detected by the compiler, and are\n considered to be erroneous. Consider the following example:\n@@ -1376,7 +1387,7 @@ considered to be erroneous. Consider the following example:\n   begin\n      P (A (Y));\n   end;\n-  \n+\n \n A normal unconstrained array value\n or a constrained array object marked as aliased has the bounds in memory\n@@ -1408,7 +1419,7 @@ is not well-defined. Consider this example:\n   RV : R := P'Unrestricted_Access;\n   ..\n   RV.all := 3;\n-  \n+\n \n Here we attempt to modify the constant P from 4 to 3, but the compiler may\n or may not notice this attempt, and subsequent references to P may yield\n@@ -1425,7 +1436,7 @@ value of an `IN` parameter:\n   begin\n      RV.all := 'a';\n   end;\n-  \n+\n \n In general this is a risky approach. It may appear to \"work\" but such uses of\n `Unrestricted_Access` are potentially non-portable, even from one version\n@@ -1446,7 +1457,7 @@ with one or more modified components. The syntax is::\n   MULTIDIMENSIONAL_ARRAY_COMPONENT_ASSOCIATION ::= INDEX_EXPRESSION_LIST_LIST => EXPRESSION\n   INDEX_EXPRESSION_LIST_LIST                   ::= INDEX_EXPRESSION_LIST {| INDEX_EXPRESSION_LIST }\n   INDEX_EXPRESSION_LIST                        ::= ( EXPRESSION {, EXPRESSION } )\n-  \n+\n \n where `PREFIX` is the name of an array or record object, the\n association list in parentheses does not contain an `others`\n@@ -1463,7 +1474,7 @@ example:\n   ...\n   Avar1 : Arr := (1,2,3,4,5);\n   Avar2 : Arr := Avar1'Update (2 => 10, 3 .. 4 => 20);\n-  \n+\n \n yields a value for `Avar2` of 1,10,20,20,5 with `Avar1`\n begin unmodified. Similarly:\n@@ -1474,7 +1485,7 @@ begin unmodified. Similarly:\n   ...\n   Rvar1 : Rec := (A => 1, B => 2, C => 3);\n   Rvar2 : Rec := Rvar1'Update (B => 20);\n-  \n+\n \n yields a value for `Rvar2` of (A => 1, B => 20, C => 3),\n with `Rvar1` being unmodifed.\n@@ -1484,7 +1495,7 @@ completely before it is used. This means that if you write:\n .. code-block:: ada\n \n   Avar1 := Avar1'Update (1 => 10, 2 => Function_Call);\n-  \n+\n \n then the value of `Avar1` is not modified if `Function_Call`\n raises an exception, unlike the effect of a series of direct assignments\n@@ -1508,7 +1519,7 @@ Multi-dimensional arrays can be modified, as shown by this example:\n   A : array (1 .. 10, 1 .. 10) of Integer;\n   ..\n   A := A'Update ((1, 2) => 20, (3, 4) => 30);\n-  \n+\n \n which changes element (1,2) to 20 and (3,4) to 30.\n "}, {"sha": "707f76e350eb78dfe8990b693071ee2acfb6f04e", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -2196,6 +2196,25 @@ Syntax:\n This pragma is identical in effect to pragma `Comment`. It is provided\n for compatibility with other Ada compilers providing this pragma.\n \n+Pragma Ignore_Pragma\n+====================\n+\n+Syntax:\n+\n+\n+.. code-block:: ada\n+\n+  pragma Ignore_Pragma (pragma_IDENTIFIER);\n+\n+This is a configuration pragma\n+that takes a single argument that is a simple identifier. Any subsequent\n+use of a pragma whose pragma identifier matches this argument will be\n+silently ignored. This may be useful when legacy code or code intended\n+for compilation with some other compiler contains pragmas that match the\n+name, but not the exact implementation, of a `GNAT` pragma. The use of this\n+pragma allows such pragmas to be ignored, which may be useful in `CodePeer`\n+mode, or during porting of legacy code.\n+\n Pragma Implementation_Defined\n =============================\n \n@@ -5737,6 +5756,8 @@ names that are implementation defined (as permitted by the RM):\n   on addresses used in address clauses. Such checks can also be suppressed\n   by suppressing range checks, but the specific use of `Alignment_Check`\n   allows suppression of alignment checks without suppressing other range checks.\n+  Note that `Alignment_Check` is suppressed by default on machines (such as\n+  the x86) with non-strict alignment.\n \n *\n   `Atomic_Synchronization` can be used to suppress the special memory"}, {"sha": "d46c52c6d1c442002fe42129dda91e1b36ce4c3f", "filename": "gcc/ada/doc/gnat_rm/implementation_of_ada_2012_features.rst", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_of_ada_2012_features.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -15,8 +15,10 @@ Implementation of Ada 2012 Features\n .. index:: Ada_2012 configuration pragma\n \n This chapter contains a complete list of Ada 2012 features that have been\n-implemented as of GNAT version 6.4. Generally, these features are only\n-available if the *-gnat12* (Ada 2012 features enabled) flag is set\n+implemented.\n+Generally, these features are only\n+available if the *-gnat12* (Ada 2012 features enabled) option is set,\n+which is the default behavior,\n or if the configuration pragma `Ada_2012` is used.\n \n However, new pragmas, attributes, and restrictions are"}, {"sha": "8cd2c0fcac7a1cf3b32f80fbd5bb733f6d8c1e1a", "filename": "gcc/ada/doc/gnat_rm/representation_clauses_and_pragmas.rst", "status": "modified", "additions": 80, "deletions": 78, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Frepresentation_clauses_and_pragmas.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -84,7 +84,7 @@ values are as follows:\n           A, B : Character;\n        end record;\n        for Small'Size use 16;\n-    \n+\n   then the default alignment of the record type `Small` is 2, not 1. This\n   leads to more efficient code when the record is treated as a unit, and also\n   allows the type to specified as `Atomic` on architectures requiring\n@@ -122,7 +122,7 @@ to control this choice. Consider:\n      type R is range 1 .. 10_000;\n      for R'Alignment use 1;\n      subtype RS is R range 1 .. 1000;\n-  \n+\n The alignment clause specifies an alignment of 1 for the first named subtype\n `R` but this does not necessarily apply to `RS`. When writing\n portable Ada code, you should avoid writing code that explicitly or\n@@ -159,7 +159,7 @@ For example:\n         Y1 : integer;\n         Y2 : boolean;\n      end record;\n-  \n+\n In this example, `Smallint'Size` = `Smallint'Value_Size` = 3,\n as specified by the RM rules,\n but objects of this type will have a size of 8\n@@ -189,7 +189,7 @@ increasing it.  For example, if we have:\n \n      type My_Boolean is new Boolean;\n      for My_Boolean'Size use 32;\n-  \n+\n then values of this type will always be 32 bits long.  In the case of\n discrete types, the size can be increased up to 64 bits, with the effect\n that the entire specified field is used to hold the value, sign- or\n@@ -227,7 +227,7 @@ task definition a pragma of the form:\n .. code-block:: ada\n \n      pragma Storage_Size (Default_Stack_Size);\n-  \n+\n Then `Default_Stack_Size` can be defined in a global package, and\n modified as required. Any tasks requiring stack sizes different from the\n default can have an appropriate alternative reference in the pragma.\n@@ -269,7 +269,7 @@ size storage pool is eliminated.  Consider the following example:\n         --  ...\n         y := new R;\n      end;\n-  \n+\n As indicated in this example, these dummy storage pools are often useful in\n connection with interfacing where no object will ever be allocated.  If you\n compile the above example, you get the warning:\n@@ -278,7 +278,7 @@ compile the above example, you get the warning:\n \n      p.adb:16:09: warning: allocation from empty storage pool\n      p.adb:16:09: warning: Storage_Error will be raised at run time\n-  \n+\n \n Of course in practice, there will not be any explicit allocators in the\n case of such an access declaration.\n@@ -314,7 +314,7 @@ for any variant.  Consider the following program\n      Put_Line (Integer'Image (V1'Size));\n      Put_Line (Integer'Image (V2'Size));\n   end q;\n-  \n+\n Here we are dealing with a variant record, where the True variant\n requires 16 bits, and the False variant requires 8 bits.\n In the above example, both V1 and V2 contain the False variant,\n@@ -325,7 +325,7 @@ program is:\n \n   8\n   16\n-  \n+\n The reason for the difference here is that the discriminant value of\n V1 is fixed, and will always be False.  It is not possible to assign\n a True variant value to V1, therefore 8 bits is sufficient.  On the\n@@ -376,7 +376,7 @@ Consider the following modified version of the above program:\n      Put_Line (Integer'Image (V2'Size));\n      Put_Line (Integer'IMage (Size (V2)));\n   end q;\n-  \n+\n The output from this program is\n \n ::\n@@ -385,7 +385,7 @@ The output from this program is\n   8\n   16\n   16\n-  \n+\n Here we see that while the `'Size` attribute always returns\n the maximum size, regardless of the current variant value, the\n `Size` function does indeed return the size of the current\n@@ -413,7 +413,7 @@ For example, suppose we have the declaration:\n \n      type Small is range -7 .. -4;\n      for Small'Size use 2;\n-  \n+\n Although the default size of type `Small` is 4, the `Size`\n clause is accepted by GNAT and results in the following representation\n scheme:\n@@ -424,7 +424,7 @@ scheme:\n     -6 is represented as 2#01#\n     -5 is represented as 2#10#\n     -4 is represented as 2#11#\n-  \n+\n Biased representation is only used if the specified `Size` clause\n cannot be accepted in any other manner.  These reduced sizes that force\n biased representation can be used for all discrete types except for\n@@ -461,7 +461,7 @@ from Ada 83 to Ada 95 or Ada 2005.  For example, consider:\n         at 0  range 0 .. Natural'Size - 1;\n         at 0  range Natural'Size .. 2 * Natural'Size - 1;\n      end record;\n-  \n+\n In the above code, since the typical size of `Natural` objects\n is 32 bits and `Natural'Size` is 31, the above code can cause\n unexpected inefficient packing in Ada 95 and Ada 2005, and in general\n@@ -485,19 +485,19 @@ byte access instructions such as the Alpha.\n The default rules for the value of `Object_Size` for\n discrete types are as follows:\n \n-* \n+*\n   The `Object_Size` for base subtypes reflect the natural hardware\n   size in bits (run the compiler with *-gnatS* to find those values\n   for numeric types). Enumeration types and fixed-point base subtypes have\n   8, 16, 32 or 64 bits for this size, depending on the range of values\n   to be stored.\n \n-* \n+*\n   The `Object_Size` of a subtype is the same as the\n   `Object_Size` of\n   the type from which it is obtained.\n \n-* \n+*\n   The `Object_Size` of a derived base type is copied from the parent\n   base type, and the `Object_Size` of a derived first subtype is copied\n   from the parent first subtype.\n@@ -513,18 +513,18 @@ target dependent).\n \n The default rules for the value of `Value_Size` are as follows:\n \n-* \n+*\n   The `Value_Size` for a base subtype is the minimum number of bits\n   required to store all values of the type (including the sign bit\n   only if negative values are possible).\n \n-* \n+*\n   If a subtype statically matches the first subtype of a given type, then it has\n   by default the same `Value_Size` as the first subtype.  This is a\n   consequence of RM 13.1(14): \"if two subtypes statically match,\n   then their subtype-specific aspects are the same\".)\n \n-* \n+*\n   All other subtypes have a `Value_Size` corresponding to the minimum\n   number of bits required to store all values of the subtype.  For\n   dynamic bounds, it is assumed that the value can range down or up\n@@ -588,13 +588,13 @@ under what conditions must the RM `Size` be used.\n The following is a list\n of the occasions on which the RM `Size` must be used:\n \n-* \n+*\n   Component size for packed arrays or records\n \n-* \n+*\n   Value of the attribute `Size` for a type\n \n-* \n+*\n   Warning about sizes not matching for unchecked conversion\n \n For record types, the `Object_Size` is always a multiple of the\n@@ -608,7 +608,7 @@ alignment of the type (this is true for all types). In some cases the\n        X : Integer;\n        Y : Character;\n      end record;\n-  \n+\n \n On a typical 32-bit architecture, the X component will be four bytes, and\n require four-byte alignment, and the Y component will be one byte. In this\n@@ -632,7 +632,7 @@ for a particular subtype. Consider this example:\n      type R is (A, B, C, D, E, F);\n      subtype RAB is R range A .. B;\n      subtype REF is R range E .. F;\n-  \n+\n \n By default, `RAB`\n has a size of 1 (sufficient to accommodate the representation\n@@ -645,7 +645,7 @@ following `Value_Size` attribute definition clause:\n .. code-block:: ada\n \n      for REF'Value_Size use 1;\n-  \n+\n \n then biased representation is forced for `REF`,\n and 0 will represent `E` and 1 will represent `F`.\n@@ -676,7 +676,7 @@ honor all packing requests in this range.  For example, if we have:\n \n   type r is array (1 .. 8) of Natural;\n   for r'Component_Size use 31;\n-  \n+\n \n then the resulting array has a length of 31 bytes (248 bits = 8 * 31).\n Of course access to the components of such an array is considerably\n@@ -695,7 +695,7 @@ padded because of its default alignment.  For example, if we have:\n \n   type a is array (1 .. 8) of r;\n   for a'Component_Size use 72;\n-  \n+\n \n then the resulting array has a length of 72 bytes, instead of 96 bytes\n if the alignment of the record (4) was obeyed.\n@@ -758,7 +758,7 @@ restrictions placed on component clauses as follows:\n           A at 0 range 7 .. 7;\n           B at 0 range 0 .. 6;\n        end record;\n-    \n+\n \n   The useful application here is to write the second declaration with the\n   `Bit_Order` attribute definition clause, and know that it will be treated\n@@ -784,7 +784,7 @@ restrictions placed on component clauses as follows:\n        for R2 use record\n           A at 0 range 0 .. 31;\n        end record;\n-    \n+\n \n   This declaration will result in a little-endian integer on a\n   little-endian machine, and a big-endian integer on a big-endian machine.\n@@ -804,7 +804,7 @@ restrictions placed on component clauses as follows:\n Since the misconception that Bit_Order automatically deals with all\n endian-related incompatibilities is a common one, the specification of\n a component field that is an integral number of bytes will always\n-generate a warning.  This warning may be suppressed using `pragma Warnings (Off)` \n+generate a warning.  This warning may be suppressed using `pragma Warnings (Off)`\n if desired.  The following section contains additional\n details regarding the issue of byte ordering.\n \n@@ -907,7 +907,7 @@ On a big-endian machine, we can write the following representation clause\n         Slave_V6       at 1 range 6 .. 6;\n         Slave_V7       at 1 range 7 .. 7;\n      end record;\n-  \n+\n \n Now if we move this to a little endian machine, then the bit ordering within\n the byte is backwards, so we have to rewrite the record rep clause as:\n@@ -933,7 +933,7 @@ the byte is backwards, so we have to rewrite the record rep clause as:\n         Slave_V6       at 1 range 1 .. 1;\n         Slave_V7       at 1 range 0 .. 0;\n      end record;\n-  \n+\n \n It is a nuisance to have to rewrite the clause, especially if\n the code has to be maintained on both machines.  However,\n@@ -948,7 +948,7 @@ first record clause, together with the declaration\n .. code-block:: ada\n \n      for Data'Bit_Order use High_Order_First;\n-  \n+\n \n and the effect is what is desired, namely the layout is exactly the same,\n independent of whether the code is compiled on a big-endian or little-endian\n@@ -982,7 +982,7 @@ example as:\n         Slave_V6       at 0 range 14 .. 14;\n         Slave_V7       at 0 range 15 .. 15;\n      end record;\n-  \n+\n \n This is exactly equivalent to saying (a repeat of the first example):\n \n@@ -1008,7 +1008,7 @@ This is exactly equivalent to saying (a repeat of the first example):\n         Slave_V6       at 1 range 6 .. 6;\n         Slave_V7       at 1 range 7 .. 7;\n      end record;\n-  \n+\n \n Why are they equivalent? Well take a specific field, the `Slave_V2`\n field.  The storage place attributes are obtained by normalizing the\n@@ -1060,7 +1060,7 @@ some machines we might write:\n         Slave_V6       at Slave_Byte  range 6 .. 6;\n         Slave_V7       at Slave_Byte  range 7 .. 7;\n      end record;\n-  \n+\n Now to switch between machines, all that is necessary is\n to set the boolean constant `Master_Byte_First` in\n an appropriate manner.\n@@ -1076,13 +1076,13 @@ Pragma `Pack` applied to an array has no effect unless the component type\n is packable.  For a component type to be packable, it must be one of the\n following cases:\n \n-* \n+*\n   Any scalar type\n-* \n+*\n   Any type whose size is specified with a size clause\n-* \n+*\n   Any packed array type with a static size\n-* \n+*\n   Any record type padded because of its default alignment\n \n For all these cases, if the component subtype size is in the range\n@@ -1096,7 +1096,7 @@ For example if we have:\n \n      type ar is array (1 .. 8) of r;\n      pragma Pack (ar);\n-  \n+\n Then the component size of `ar` will be set to 5 (i.e., to `r'size`,\n and the size of the array `ar` will be exactly 40 bits.\n \n@@ -1154,7 +1154,7 @@ occurs with subtype `Natural`. Consider:\n \n      type Arr is array (1 .. 32) of Natural;\n      pragma Pack (Arr);\n-  \n+\n In all commonly used Ada 83 compilers, this pragma Pack would be ignored,\n since typically `Natural'Size` is 32 in Ada 83, and in any case most\n Ada 83 compilers did not attempt 31 bit packing.\n@@ -1170,7 +1170,7 @@ explicitly:\n \n      type Arr is array (1 .. 32) of Natural;\n      for Arr'Component_Size use 31;\n-  \n+\n Here 31-bit packing is achieved as required, and no warning is generated,\n since in this case the programmer intention is clear.\n \n@@ -1187,11 +1187,11 @@ taken by components.  We distinguish between *packable* components and\n *non-packable* components.\n Components of the following types are considered packable:\n \n-* \n+*\n   Components of a primitive type are packable unless they are aliased\n   or of an atomic type.\n \n-* \n+*\n   Small packed arrays, whose size does not exceed 64 bits, and where the\n   size is statically known at compile time, are represented internally\n   as modular integers, and so they are also packable.\n@@ -1226,7 +1226,7 @@ For example, consider the record\n         L6 : Rb2;\n      end record;\n      pragma Pack (X2);\n-  \n+\n The representation for the record X2 is as follows:\n \n .. code-block:: ada\n@@ -1282,7 +1282,7 @@ thus the same lack of restriction applies.  For example, if you declare:\n      type R is array (1 .. 49) of Boolean;\n      pragma Pack (R);\n      for R'Size use 49;\n-  \n+\n then a component clause for a component of type R may start on any\n specified bit boundary, and may specify a value of 49 bits or greater.\n \n@@ -1331,7 +1331,7 @@ so for example, the following is permitted:\n         L at 0 range  2 ..  81;\n         R at 0 range 82 .. 161;\n      end record;\n-  \n+\n Note: the above rules apply to recent releases of GNAT 5.\n In GNAT 3, there are more severe restrictions on larger components.\n For non-primitive types, including packed arrays with a size greater than\n@@ -1371,7 +1371,7 @@ or address overlays. For example\n      C : Character;\n      I : Integer;\n   end record;\n-  \n+\n On typical machines, integers need to be aligned on a four-byte\n boundary, resulting in three bytes of undefined rubbish following\n the 8-bit field for C. To ensure that the hole in a variable of\n@@ -1387,7 +1387,7 @@ you could for example do:\n   BaseVar : Base;\n   RealVar : Hrec;\n   for RealVar'Address use BaseVar'Address;\n-  \n+\n \n Now the 8-bytes of the value of RealVar start out containing all zero\n bits. A safer approach is to just define dummy fields, avoiding the\n@@ -1402,7 +1402,7 @@ holes, as in:\n      Dummy3 : Short_Short_Integer := 0;\n      I      : Integer;\n   end record;\n-  \n+\n And to make absolutely sure that the intent of this is followed, you\n can use representation clauses:\n \n@@ -1416,7 +1416,7 @@ can use representation clauses:\n      I      at 4 range 0 .. 31;\n   end record;\n   for Hrec'Size use 64;\n-  \n+\n \n .. _Enumeration_Clauses:\n \n@@ -1437,7 +1437,7 @@ be in the range:\n .. code-block:: ada\n \n      0 .. System.Max_Binary_Modulus;\n-  \n+\n \n A *confirming* representation clause is one in which the values range\n from 0 in sequence, i.e., a clause that confirms the default representation\n@@ -1455,7 +1455,7 @@ manner.  Consider the declarations:\n      type r is (A, B, C);\n      for r use (A => 1, B => 5, C => 10);\n      type t is array (r) of Character;\n-  \n+\n The array type t corresponds to a vector with exactly three elements and\n has a default size equal to `3*Character'Size`.  This ensures efficient\n use of space, but means that accesses to elements of the array will incur\n@@ -1519,14 +1519,14 @@ if one is present, is inexpensive).  In addition, if there is no implicit or\n explicit initialization, then there are no restrictions.  GNAT will reject\n only the case where all three of these conditions hold:\n \n-* \n+*\n   The type of the item is non-elementary (e.g., a record or array).\n \n-* \n+*\n   There is explicit or implicit initialization required for the object.\n   Note that access values are always implicitly initialized.\n \n-* \n+*\n   The address value is non-static.  Here GNAT is more permissive than the\n   RM, and allows the address value to be the address of a previously declared\n   stand-alone variable, as long as it does not itself have an address clause.\n@@ -1536,7 +1536,7 @@ only the case where all three of these conditions hold:\n                Anchor  : Some_Initialized_Type;\n                Overlay : Some_Initialized_Type;\n                for Overlay'Address use Anchor'Address;\n-    \n+\n   However, the prefix of the address clause cannot be an array component, or\n   a component of a discriminated record.\n \n@@ -1553,7 +1553,7 @@ expressions have identical values:\n \n      To_Address (16#1234_0000#)\n      System'To_Address (16#1234_0000#);\n-  \n+\n except that the second form is considered to be a static expression, and\n thus when used as an address clause value is always permitted.\n \n@@ -1569,13 +1569,15 @@ the same as the alignment of the type of the object).  If an address clause\n is given that specifies an inappropriately aligned address value, then the\n program execution is erroneous.\n \n-Since this source of erroneous behavior can have unfortunate effects, GNAT\n+Since this source of erroneous behavior can have unfortunate effects on\n+machines with strict alignment requirements, GNAT\n checks (at compile time if possible, generating a warning, or at execution\n time with a run-time check) that the alignment is appropriate.  If the\n run-time check fails, then `Program_Error` is raised.  This run-time\n check is suppressed if range checks are suppressed, or if the special GNAT\n check Alignment_Check is suppressed, or if\n-`pragma Restrictions (No_Elaboration_Code)` is in effect.\n+`pragma Restrictions (No_Elaboration_Code)` is in effect. It is also\n+suppressed by default on non-strict alignment machines (such as the x86).\n \n Finally, GNAT does not permit overlaying of objects of controlled types or\n composite types containing a controlled component. In most cases, the compiler\n@@ -1621,7 +1623,7 @@ programmer wants, so GNAT will output a warning:\n         initialization (RM B(24))\n \n     end G;\n-  \n+\n As indicated by the warning message, the solution is to use a (dummy) pragma\n Import to suppress this initialization.  The pragma tell the compiler that the\n object is declared and initialized elsewhere.  The following package compiles\n@@ -1639,7 +1641,7 @@ without warnings (and the initialization is suppressed):\n         for Ext'Address use System'To_Address (16#1234_1234#);\n         pragma Import (Ada, Ext);\n      end G;\n-  \n+\n \n A final issue with address clauses involves their use for overlaying\n variables, as in the following example:\n@@ -1651,7 +1653,7 @@ variables, as in the following example:\n     A : Integer;\n     B : Integer;\n     for B'Address use A'Address;\n-  \n+\n \n or alternatively, using the form recommended by the RM:\n \n@@ -1661,7 +1663,7 @@ or alternatively, using the form recommended by the RM:\n     Addr : constant Address := A'Address;\n     B    : Integer;\n     for B'Address use Addr;\n-  \n+\n \n In both of these cases, `A`\n and `B` become aliased to one another via the\n@@ -1702,7 +1704,7 @@ issue of unintentional initialization, as shown by this example:\n       suppress initialization (RM B.1(24))\n \n   end Overwrite_Record;\n-  \n+\n Here the default initialization of `Y` will clobber the value\n of `X`, which justifies the warning. The warning notes that\n this effect can be eliminated by adding a `pragma Import`\n@@ -1720,7 +1722,7 @@ which suppresses the initialization:\n      for Y'Address use X'Address;\n      pragma Import (Ada, Y);\n   end Overwrite_Record;\n-  \n+\n \n Note that the use of `pragma Initialize_Scalars` may cause variables to\n be initialized when they would not otherwise have been in the absence\n@@ -1751,7 +1753,7 @@ for the composite object:\n         Put_Line (\"X was not clobbered\");\n      end if;\n   end Overwrite_Array;\n-  \n+\n The above program generates the warning as shown, and at execution\n time, prints `X was clobbered`. If the `pragma Import` is\n added as suggested:\n@@ -1773,7 +1775,7 @@ added as suggested:\n         Put_Line (\"X was not clobbered\");\n      end if;\n   end Overwrite_Array;\n-  \n+\n then the program compiles without the warning and when run will generate\n the output `X was not clobbered`.\n \n@@ -1803,7 +1805,7 @@ operations, for example:\n       Temp := Mem;\n       Temp.A := 32;\n       Mem := Temp;\n-  \n+\n For a full access (reference or modification) of the variable (Mem) in\n this case, as in the above examples, GNAT guarantees that the entire atomic\n word will be accessed. It is not clear whether the RM requires this. For\n@@ -1816,7 +1818,7 @@ A problem arises with a component access such as:\n .. code-block:: ada\n \n       Mem.A := 32;\n-  \n+\n Note that the component A is not declared as atomic. This means that it is\n not clear what this assignment means. It could correspond to full word read\n and write as given in the first example, or on architectures that supported\n@@ -1831,7 +1833,7 @@ a warning in such a case:\n       |\n       >>> warning: access to non-atomic component of atomic array,\n           may cause unexpected accesses to atomic object\n-  \n+\n It is best to be explicit in this situation, by either declaring the\n components to be atomic if you want the byte store, or explicitly writing\n the full word access sequence if that is what the hardware requires.\n@@ -1869,7 +1871,7 @@ There are four exceptions to this general rule:\n   ::\n \n        type Color is (Red, Green, Blue);\n-    \n+\n   8 bits is sufficient to store all values of the type, so by default, objects\n   of type `Color` will be represented using 8 bits.  However, normal C\n   convention is to use 32 bits for all enum values in C, since enum values\n@@ -1902,7 +1904,7 @@ There are four exceptions to this general rule:\n \n        type C_Switch is new Boolean;\n        pragma Convention (C, C_Switch);\n-    \n+\n \n   then the GNAT generated code will treat any nonzero value as true.  For truth\n   values generated by GNAT, the conventional value 1 will be used for True, but\n@@ -1984,7 +1986,7 @@ The following program shows these conventions in action:\n   >>> subprogram \"F\" has wrong convention\n   >>> does not match access to subprogram declared at line 24\n        39. end ConvComp;\n-  \n+\n \n .. _Determining_the_Representations_chosen_by_GNAT:\n \n@@ -2058,7 +2060,7 @@ clauses.  For example, if we compile the package:\n      end record;\n      pragma Pack (x2);\n   end q;\n-  \n+\n using the switch *-gnatR* we obtain the following output:\n \n .. code-block:: ada\n@@ -2111,7 +2113,7 @@ using the switch *-gnatR* we obtain the following output:\n      l5 at 16 range  1 .. 13;\n      l6 at 18 range  0 .. 71;\n   end record;\n-  \n+\n The Size values are actually the Object_Size, i.e., the default size that\n will be allocated for objects of the type.\n The ``??`` size for type r indicates that we have a variant record, and the"}, {"sha": "4c6e137ddcd0d288885a9e007046aa6dbb844cad", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -4676,8 +4676,12 @@ checks to be performed. The following checks are defined:\n :samp:`-gnatyO`\n   *Check that overriding subprograms are explicitly marked as such.*\n \n-  The declaration of a primitive operation of a type extension that overrides\n-  an inherited operation must carry an overriding indicator.\n+  This applies to all subprograms of a derived type that override a primitive\n+  operation of the type, for both tagged and untagged types. In particular,\n+  the declaration of a primitive operation of a type extension that overrides\n+  an inherited operation must carry an overriding indicator. Another case is\n+  the declaration of a function that overrides a predefined operator (such\n+  as an equality operator).\n \n \n .. index:: -gnatyp (gcc)"}, {"sha": "cbbebad1b3d464897bbba3b2b9367b8e1b2a7851", "filename": "gcc/ada/doc/gnat_ugn/gnat_utility_programs.rst", "status": "modified", "additions": 65, "deletions": 75, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_utility_programs.rst?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -57,7 +57,7 @@ The `gnatclean` command has the form:\n   ::\n \n       $ gnatclean switches `names`\n-  \n+\n where `names` is a list of source file names. Suffixes :file:`.ads` and\n :file:`adb` may be omitted. If a project file is specified using switch\n :samp:`-P`, then `names` may be completely omitted.\n@@ -465,7 +465,7 @@ building specialized scripts.\n       /home/comar/local/adainclude/s-tasoli.ads\n       /home/comar/local/adainclude/s-unstyp.ads\n       /home/comar/local/adainclude/unchconv.ads\n-  \n+\n \n .. _The_Cross-Referencing_Tools_gnatxref_and_gnatfind:\n \n@@ -511,7 +511,7 @@ The command invocation for `gnatxref` is:\n   ::\n \n       $ gnatxref [`switches`] `sourcefile1` [`sourcefile2` ...]\n-  \n+\n where\n \n *sourcefile1* [, *sourcefile2* ...]\n@@ -939,7 +939,7 @@ account.\n     [default: `\"\"`].\n     Specifies the name of the executable for the application. This variable can\n     be referred to in the following lines by using the :samp:`{${main}` notation.\n-  \n+\n \n * *comp_cmd=COMMAND*\n     [default: `\"gcc -c -I${src_dir} -g -gnatq\"`].\n@@ -1002,14 +1002,14 @@ are recognized:\n     ::\n \n         regexp ::= term {| term}   -- alternation (term or term ...)\n-  \n+\n         term ::= item {item}       -- concatenation (item then item)\n \n         item ::= elmt              -- match elmt\n         item ::= elmt *            -- zero or more elmt's\n         item ::= elmt +            -- one or more elmt's\n         item ::= elmt ?            -- matches elmt or nothing\n-  \n+\n         elmt ::= nschar            -- matches given character\n         elmt ::= [nschar {nschar}]   -- matches any character listed\n         elmt ::= [^ nschar {nschar}] -- matches any character not listed\n@@ -1020,7 +1020,7 @@ are recognized:\n \n         char ::= any character, including special characters\n         nschar ::= any character except ()[].*+?^\n-    \n+\n     Here are a few examples:\n \n       ``abcde|fghi``\n@@ -1111,7 +1111,7 @@ You can then issue any of the following commands:\n           Print                                                   Type: Unit\n             Decl: bar.ads           2:15\n             Ref:  main.adb          6:12     7:12\n-    \n+\n \n     This shows that the entity `Main` is declared in main.ads, line 2, column 9,\n     its body is in main.adb, line 1, column 14 and is not referenced any where.\n@@ -1137,15 +1137,15 @@ free implementation of *vi*, such as *vim*.\n   ::\n \n      $ gnatxref -v gnatfind.adb > tags\n-  \n+\n \n The following command will generate the tags file for `gnatfind` itself\n (if the sources are in the search path!):\n \n   ::\n \n      $ gnatxref -v gnatfind.adb > tags\n-  \n+\n From *vi*, you can then use the command :samp:`:tag {entity}`\n (replacing `entity` by whatever you are looking for), and vi will\n display a new file with the corresponding declaration of entity.\n@@ -1171,7 +1171,7 @@ Examples of `gnatfind` Usage\n        directory/main.ads:106:14: xyz <= declaration\n        directory/main.adb:24:10: xyz <= body\n        directory/foo.ads:45:23: xyz <= declaration\n-    \n+\n   I.e., one of the entities xyz found in main.adb is declared at\n   line 12 of main.ads (and its body is in main.adb), and another one is\n   declared at line 45 of foo.ads\n@@ -1190,7 +1190,7 @@ Examples of `gnatfind` Usage\n          procedure xyz is\n       directory/foo.ads:45:23: xyz <= declaration\n          xyz : Integer;\n-    \n+\n   This can make it easier to find exactly the location your are looking\n   for.\n \n@@ -1352,13 +1352,13 @@ is located. The syntax of this line is:\n   ::\n \n      #!full_path_name_to_perl\n-  \n+\n Alternatively, you may run the script using the following command line:\n \n   ::\n \n      $ perl gnathtml.pl [`switches`] `files`\n-  \n+\n \n \n \n@@ -1392,7 +1392,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n        $ gnat2xml [options] filenames [-files filename] [-cargs gcc_switches]\n-  \n+\n   Options:\n \n      :samp:`--help`\n@@ -1409,7 +1409,7 @@ Alternatively, you may run the script using the following command line:\n           the set of sources to be processed. The exact set of argument\n           sources depends on other options specified, see below.\n \n-     :samp:`-U` \n+     :samp:`-U`\n           If a project file is specified and no argument source is explicitly\n           specified, process all the units of the closure of the argument project.\n           Otherwise this option has no effect.\n@@ -1420,7 +1420,7 @@ Alternatively, you may run the script using the following command line:\n           option), process the closure of units rooted at `main_unit`.\n           Otherwise this option has no effect.\n \n-     :samp:`-X{name}={value}` \n+     :samp:`-X{name}={value}`\n           Indicates that external variable `name` in\n           the argument project has the value `value`. Has no effect if no\n           project is specified as tool argument.\n@@ -1437,7 +1437,7 @@ Alternatively, you may run the script using the following command line:\n           only compiles files that need to be recompiled. A project file\n           is required in this mode.\n \n-     :samp:`-j{n}` \n+     :samp:`-j{n}`\n            In *--incremental* mode, use `n` *gnat2xml*\n            processes to perform XML generation in parallel. If `n` is 0, then\n            the maximum number of parallel tree creations is the number of core\n@@ -1452,7 +1452,7 @@ Alternatively, you may run the script using the following command line:\n           Directories to search for dependencies.\n           You can also set the ADA_INCLUDE_PATH environment variable for this.\n \n-     :samp:`--compact` \n+     :samp:`--compact`\n           Debugging version, with interspersed source, and a more\n           compact representation of \"sloc\". This version does not conform\n           to any schema.\n@@ -1463,15 +1463,15 @@ Alternatively, you may run the script using the following command line:\n      :samp:`-files={filename}`\n          The name of a text file containing a list of Ada source files to process\n \n-     :samp:`-q` \n+     :samp:`-q`\n          Quiet\n \n-     :samp:`-v` \n+     :samp:`-v`\n          Verbose\n \n-     :samp:`-cargs` ... \n+     :samp:`-cargs` ...\n          Options to pass to gcc\n-   \n+\n   If a project file is specified and no argument source is explicitly\n   specified, and no *-U* is specified, then the set of processed\n   sources is all the immediate units of the argument project.\n@@ -1481,7 +1481,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n        $ gnat2xml -v -output-dir=xml-files *.ad[sb]\n-  \n+\n   The above will create \\*.xml files in the :file:`xml-files` subdirectory.\n   For example, if there is an Ada package Mumble.Dumble, whose spec and\n   body source code lives in mumble-dumble.ads and mumble-dumble.adb,\n@@ -1505,7 +1505,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n         $ gnat2xsd > ada-schema.xsd\n-  \n+\n \n   *gnat2xml* generates XML files that will validate against\n   :file:`ada-schema.xsd`.\n@@ -1549,7 +1549,7 @@ Alternatively, you may run the script using the following command line:\n \n        type T is range 1..10;\n        X, Y : constant T := 1;\n-  \n+\n \n   The first 'T' is the defining occurrence of a type. The 'X' is the\n   defining occurrence of a constant, as is the 'Y', and the second 'T' is\n@@ -1577,14 +1577,14 @@ Alternatively, you may run the script using the following command line:\n         ...\n         --  Returns Element_Kinds:\n         --       An_Expression\n-  \n+\n \n   The corresponding sub-element of type Assignment_Statement is:\n \n     ::\n \n         <xsd:element name=\"assignment_expression_q\" type=\"Expression_Class\"/>\n-  \n+\n   where Expression_Class is defined by an xsd:choice of all the\n   various kinds of expression.\n \n@@ -1774,7 +1774,7 @@ Alternatively, you may run the script using the following command line:\n         formal_function\n         formal_package\n         formal_package_declaration_with_box\n-  \n+\n   .. _Generating_Representation_Clauses:\n \n   Generating Representation Clauses\n@@ -1808,7 +1808,7 @@ Alternatively, you may run the script using the following command line:\n         ...\n         <comment text=\"--gen-\">\n         ...\n-  \n+\n \n .. only:: PRO or GPL\n \n@@ -2194,7 +2194,7 @@ Alternatively, you may run the script using the following command line:\n \n   * *Maximal static nesting level of inner program units*\n       According to :title:`Ada Reference Manual`, 10.1(1):\n-    \n+\n         \"A program unit is either a package, a task unit, a protected unit, a\n         protected entry, a generic unit, or an explicitly declared subprogram other\n         than an enumeration literal.\"\n@@ -2619,7 +2619,7 @@ Alternatively, you may run the script using the following command line:\n                 return F_1 (I);\n              end Fun;\n          end Pack;\n-    \n+\n   If we apply *gnatmetric* with the *--coupling-all* option to\n   these units, the result will be:\n \n@@ -2852,11 +2852,6 @@ Alternatively, you may run the script using the following command line:\n    You can specify various style directives via switches; e.g.,\n    identifier case conventions, rules of indentation, and comment layout.\n \n-   Note: A newly-redesigned set of formatting algorithms used by gnatpp\n-   is now available.\n-   To invoke the old formatting algorithms, use the ``--pp-old`` switch.\n-   Support for ``--pp-old`` will be removed in some future version.\n-\n    To produce a reformatted file, *gnatpp* invokes the Ada\n    compiler and generates and uses the ASIS tree for the input source;\n    thus the input must be legal Ada code, and the tool should have all the\n@@ -2875,7 +2870,7 @@ Alternatively, you may run the script using the following command line:\n      ::\n \n         $ gnatpp [`switches`] `filename` [-cargs `gcc_switches`]\n-     \n+\n    where\n \n    * `switches` is an optional sequence of switches defining such properties as\n@@ -3499,12 +3494,6 @@ Alternatively, you may run the script using the following command line:\n      of the default `--!pp on`.\n \n \n-   .. index:: --pp-old  (gnatpp)\n-\n-   :samp:`--pp-old`\n-     Use the old formatting algorithms.\n-\n-\n    .. index:: -files (gnatpp)\n \n    :samp:`-files {filename}`\n@@ -3597,12 +3586,12 @@ Alternatively, you may run the script using the following command line:\n                      Green_Interrupt_Kind);\n            --!pp on -- reenable pretty printing\n            ...\n-     \n+\n    You can specify different comment strings using the ``--pp-off``\n    and ``--pp-on`` switches. For example, if you say:\n \n      ::\n-     \n+\n         $ gnatpp --pp-off=' pp-' *.ad?\n \n    then gnatpp will recognize comments of the form\n@@ -3765,7 +3754,7 @@ Alternatively, you may run the script using the following command line:\n         `casing_schema` ::= `identifier` | `simple_identifier`\n \n         `simple_identifier` ::= `letter`{`letter_or_digit`}\n-     \n+\n \n    (See :title:`Ada Reference Manual`, Section 2.3) for the definition of the\n    `identifier` lexical element and the `letter_or_digit` category.)\n@@ -3804,7 +3793,7 @@ Alternatively, you may run the script using the following command line:\n    For example, suppose we have the following source to reformat:\n \n      .. code-block:: ada\n-     \n+\n         procedure test is\n            name1 : integer := 1;\n            name4_name3_name2 : integer := 2;\n@@ -3813,7 +3802,7 @@ Alternatively, you may run the script using the following command line:\n         begin\n            name2_name3_name4 := name4_name3_name2 > name1;\n         end;\n-     \n+\n    And suppose we have two dictionaries:\n \n      ::\n@@ -3825,13 +3814,13 @@ Alternatively, you may run the script using the following command line:\n \n         *dict2:*\n           *NAME3*\n-     \n+\n    If *gnatpp* is called with the following switches:\n \n      ::\n \n         $ gnatpp -nM -D dict1 -D dict2 test.adb\n-     \n+\n    then we will get the following name casing in the *gnatpp* output:\n \n \n@@ -3885,13 +3874,13 @@ Alternatively, you may run the script using the following command line:\n \n   Running *gnatstub*\n   ------------------\n-  \n+\n   *gnatstub* invocation has the following form:\n \n     ::\n \n        $ gnatstub [`switches`] `filename` [-cargs `gcc_switches`]\n-    \n+\n   where\n \n   * *filename*\n@@ -3912,7 +3901,7 @@ Alternatively, you may run the script using the following command line:\n       or creates the name file to generate using the standard GNAT\n       naming conventions.\n \n-  * *gcc_switches* is a list of switches for *gcc*. \n+  * *gcc_switches* is a list of switches for *gcc*.\n       They will be passed on to all compiler invocations made by\n       *gnatstub* to generate the ASIS trees. Here you can provide\n       ``-I`` switches to form the source search path,\n@@ -4212,7 +4201,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n         $ gnattest `-Pprojname` [`--harness-dir=dirname`] [`switches`] [`filename`] [-cargs `gcc_switches`]\n-    \n+\n   where\n \n   * :samp:`-P{projname}`\n@@ -4281,7 +4270,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n         $ gnattest `test_drivers.list` [`switches`]\n-    \n+\n   where\n \n   * :samp:`{test_drivers.list}`\n@@ -4557,31 +4546,31 @@ Alternatively, you may run the script using the following command line:\n   located in:\n \n     ::\n-    \n+\n         <install_prefix>/share/examples/gnattest/simple\n-    \n+\n   This project contains a simple package containing one subprogram. By running gnattest:\n \n     ::\n \n         $ gnattest --harness-dir=driver -Psimple.gpr\n-    \n+\n   a test driver is created in directory ``driver``. It can be compiled and run:\n \n     ::\n \n        $ cd obj/driver\n        $ gnatmake -Ptest_driver\n        $ test_runner\n-    \n+\n   One failed test with diagnosis ``test not implemented`` is reported.\n   Since no special output option was specified, the test package ``Simple.Tests``\n   is located in:\n \n     ::\n \n         <install_prefix>/share/examples/gnattest/simple/obj/gnattest/tests\n-    \n+\n \n   For each package containing visible subprograms, a child test package is\n   generated. It contains one test routine per tested subprogram. Each\n@@ -4601,7 +4590,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n         Assert (Inc (1) = 2, \"wrong incrementation\");\n-    \n+\n   After recompiling and running the test driver, one successfully passed test\n   is reported.\n \n@@ -4642,7 +4631,7 @@ Alternatively, you may run the script using the following command line:\n         $ cd obj/driver\n         $ gnatmake -Ptest_driver\n         $ test_runner\n-    \n+\n   The old test is not replaced with a stub, nor is it lost, but a new test\n   skeleton is created for function Dec.\n \n@@ -4668,11 +4657,11 @@ Alternatively, you may run the script using the following command line:\n   as passed to gnattest when generating the test driver.\n \n   Passing it to the driver generated on the first example:\n-   \n+\n     ::\n \n         $ test_runner --skeleton-default=pass\n-    \n+\n   makes both tests pass, even the unimplemented one.\n \n \n@@ -4695,7 +4684,7 @@ Alternatively, you may run the script using the following command line:\n \n         $ cd <install_prefix>/share/examples/gnattest/tagged_rec\n         $ gnattest --harness-dir=driver -Ptagged_rec.gpr\n-    \n+\n   Taking a closer look at the test type declared in the test package\n   Speed1.Controller_Test_Data is necessary. It is declared in:\n \n@@ -4741,7 +4730,7 @@ Alternatively, you may run the script using the following command line:\n         $ cd obj/driver\n         $ gnatmake -Ptest_driver\n         $ test_runner\n-    \n+\n   There are 6 passed tests while there are only 5 testable subprograms. The test\n   routine for function Speed has been inherited and run against objects of the\n   derived type.\n@@ -4784,7 +4773,7 @@ Alternatively, you may run the script using the following command line:\n         $ cd obj/driver\n         $ gnatmake -Ptest_driver\n         $ test_runner\n-    \n+\n   While all the tests pass by themselves, the parent test for Adjust_Speed fails\n   against objects of the derived type.\n \n@@ -4812,15 +4801,15 @@ Alternatively, you may run the script using the following command line:\n \n         $ cd <install_prefix>/share/examples/gnattest/contracts\n         $ gnattest --harness-dir=driver -Pcontracts.gpr\n-    \n+\n   Putting actual checks within the range of the contract does not cause any\n   error reports. For example, for the test routine which corresponds to\n   test case 1:\n \n     ::\n \n         Assert (Sqrt (9.0) = 3.0, \"wrong sqrt\");\n-    \n+\n   and for the test routine corresponding to test case 2:\n \n     ::\n@@ -4834,7 +4823,7 @@ Alternatively, you may run the script using the following command line:\n         $ cd obj/driver\n         $ gnatmake -Ptest_driver\n         $ test_runner\n-    \n+\n   However, by changing 9.0 to 25.0 and 3.0 to 5.0, for example, you can get\n   a precondition violation for test case one. Also, by using any otherwise\n   correct but positive pair of numbers in the second test routine, you can also\n@@ -4861,7 +4850,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n         <install_prefix>/share/examples/gnattest/additional_tests/\n-    \n+\n   To create a test driver for already-written tests, use the ``--harness-only``\n   option:\n \n@@ -4871,7 +4860,7 @@ Alternatively, you may run the script using the following command line:\n           --harness-only\n         gnatmake -Pharness_only/test_driver.gpr\n         harness_only/test_runner\n-    \n+\n   Additional tests can also be executed together with generated tests:\n \n     ::\n@@ -4983,7 +4972,7 @@ Alternatively, you may run the script using the following command line:\n     ::\n \n         $ powerpc-elf-gnattest -Psimple.gpr -XPLATFORM=powerpc-elf -XRUNTIME=zfp\n-    \n+\n \n   .. _Current_Limitations:\n \n@@ -4994,4 +4983,5 @@ Alternatively, you may run the script using the following command line:\n \n   * generic tests for nested generic packages and their instantiations\n   * tests for protected subprograms and entries\n-\n+  * if pragmas for C and C++ interaction are used, manual adjustments might be\n+    necessary to make the test driver compilable"}, {"sha": "5d523d134fb52ee82246d65d0d07336b91e383f5", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 720, "deletions": 677, "changes": 1397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3"}, {"sha": "d82df18783fd997e65e8d71d2c6eeabce135e9cc", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a62638a3485c7fb31085a2b0fb973af618ae61d3/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=a62638a3485c7fb31085a2b0fb973af618ae61d3", "patch": "@@ -21,7 +21,7 @@\n \n @copying\n @quotation\n-GNAT User's Guide for Native Platforms , March 01, 2015\n+GNAT User's Guide for Native Platforms , March 24, 2015\n \n AdaCore\n \n@@ -13300,8 +13300,12 @@ before Junk10).\n \n @emph{Check that overriding subprograms are explicitly marked as such.}\n \n-The declaration of a primitive operation of a type extension that overrides\n-an inherited operation must carry an overriding indicator.\n+This applies to all subprograms of a derived type that override a primitive\n+operation of the type, for both tagged and untagged types. In particular,\n+the declaration of a primitive operation of a type extension that overrides\n+an inherited operation must carry an overriding indicator. Another case is\n+the declaration of a function that overrides a predefined operator (such\n+as an equality operator).\n @end table\n \n @geindex -gnatyp (gcc)"}]}