{"sha": "e3b7eb58844c446d097ddee00ecd455d5537c6b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNiN2ViNTg4NDRjNDQ2ZDA5N2RkZWUwMGVjZDQ1NWQ1NTM3YzZiMg==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-10T14:44:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-10T14:44:42Z"}, "message": "Merge #669\n\n669: Fix bug with monomorphizing of trait items r=philberty a=philberty\n\nWhen we monomorphize functions we need to check if we have already\r\ngenerated this function already. All function items have a DefId which is\r\nunique for the crate and HIR item this means for generic implementations\r\nof an item we end up with mappings of:\r\n\r\n  DefId -> [ (concete-tyty-fntype, GCC::Function), ... ]\r\n\r\nSo for any function we can lookup for that DefId is there a suitable\r\nversion of this function already compiled. This was working untill we have\r\ngeneric trait items which also need to be handled in the same way.\r\n\r\nFixes #668\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "30186abaf20b28e107b78a93cddba7143c68d2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30186abaf20b28e107b78a93cddba7143c68d2b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3b7eb58844c446d097ddee00ecd455d5537c6b2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhO29aCRBK7hj4Ov3rIwAAaZEIAF2usSfL4Yy29XZ0Vnzw/vTz\nl7AsuLFUnFvdDA+W2VvKQfIBtLTonCRqUDAuy5HQYQXX8vnXm1CMzocOno4byiqR\nbSGAzfFVp0gU5+qKCodv91bG3QrYQf2yS3hGRPkFKVbohvEvu7XE72vSbCE8uORG\ngygqzAU/4y9CAnuUVVSrrakUfITdWSPUbhDGh0EpcwgMYdQaaaaKr/5b9K+uEOsJ\nvit+BTi6/Qisu8gvHsWbRetZmh1S/opSDIqY1qok+mSM7Ibi+cwlY67PKcCOY8j7\nWz+4pbPREtbKsZtAStu85lqUaMV7PbGJz5Q37fKSFjEoskr46Kg6ghKjwnU2OAE=\n=/DsK\n-----END PGP SIGNATURE-----\n", "payload": "tree 30186abaf20b28e107b78a93cddba7143c68d2b8\nparent 2bf19c1b20bfad19136e17c0c7fa765e161b789c\nparent 0c409fcf5678709303126aba07932f9f2a8519da\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631285082 +0000\ncommitter GitHub <noreply@github.com> 1631285082 +0000\n\nMerge #669\n\n669: Fix bug with monomorphizing of trait items r=philberty a=philberty\n\nWhen we monomorphize functions we need to check if we have already\r\ngenerated this function already. All function items have a DefId which is\r\nunique for the crate and HIR item this means for generic implementations\r\nof an item we end up with mappings of:\r\n\r\n  DefId -> [ (concete-tyty-fntype, GCC::Function), ... ]\r\n\r\nSo for any function we can lookup for that DefId is there a suitable\r\nversion of this function already compiled. This was working untill we have\r\ngeneric trait items which also need to be handled in the same way.\r\n\r\nFixes #668\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b7eb58844c446d097ddee00ecd455d5537c6b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3b7eb58844c446d097ddee00ecd455d5537c6b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3b7eb58844c446d097ddee00ecd455d5537c6b2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf19c1b20bfad19136e17c0c7fa765e161b789c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf19c1b20bfad19136e17c0c7fa765e161b789c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf19c1b20bfad19136e17c0c7fa765e161b789c"}, {"sha": "0c409fcf5678709303126aba07932f9f2a8519da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c409fcf5678709303126aba07932f9f2a8519da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c409fcf5678709303126aba07932f9f2a8519da"}], "stats": {"total": 88, "additions": 49, "deletions": 39}, "files": [{"sha": "3a92c32430218525072e142497ba140c5145e005", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=e3b7eb58844c446d097ddee00ecd455d5537c6b2", "patch": "@@ -160,32 +160,41 @@ class Context\n     return true;\n   }\n \n-  void insert_function_decl (HirId id, ::Bfunction *fn,\n-\t\t\t     const TyTy::BaseType *ref)\n+  void insert_function_decl (const TyTy::FnType *ref, ::Bfunction *fn)\n   {\n+    auto id = ref->get_ty_ref ();\n+    auto dId = ref->get_id ();\n+\n     rust_assert (compiled_fn_map.find (id) == compiled_fn_map.end ());\n     compiled_fn_map[id] = fn;\n-    if (ref != nullptr)\n-      {\n-\tstd::pair<HirId, ::Bfunction *> elem (id, fn);\n-\tmono_fns[ref] = std::move (elem);\n-      }\n+\n+    auto it = mono_fns.find (dId);\n+    if (it == mono_fns.end ())\n+      mono_fns[dId] = {};\n+\n+    mono_fns[dId].push_back ({ref, fn});\n   }\n \n   bool lookup_function_decl (HirId id, ::Bfunction **fn,\n+\t\t\t     DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     // for for any monomorphized fns\n     if (ref != nullptr)\n       {\n-\tfor (auto it = mono_fns.begin (); it != mono_fns.end (); it++)\n+\trust_assert (dId != UNKNOWN_DEFID);\n+\n+\tauto it = mono_fns.find (dId);\n+\tif (it == mono_fns.end ())\n+\t  return false;\n+\n+\tfor (auto &e : mono_fns[dId])\n \t  {\n-\t    std::pair<HirId, ::Bfunction *> &val = it->second;\n-\t    const TyTy::BaseType *r = it->first;\n+\t    const TyTy::BaseType *r = e.first;\n+\t    ::Bfunction *f = e.second;\n \t    if (ref->is_equal (*r))\n \t      {\n-\t\t*fn = val.second;\n-\n+\t\t*fn = f;\n \t\treturn true;\n \t      }\n \t  }\n@@ -316,18 +325,19 @@ class Context\n   std::map<HirId, ::Bfunction *> compiled_fn_map;\n   std::map<HirId, ::Bexpression *> compiled_consts;\n   std::map<HirId, ::Blabel *> compiled_labels;\n-  std::vector< ::std::vector<Bstatement *> > statements;\n-  std::vector< ::Bblock *> scope_stack;\n-  std::vector< ::Bvariable *> loop_value_stack;\n-  std::vector< ::Blabel *> loop_begin_labels;\n-  std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *> > mono;\n-  std::map<const TyTy::BaseType *, std::pair<HirId, ::Bfunction *> > mono_fns;\n+  std::vector<::std::vector<Bstatement *>> statements;\n+  std::vector<::Bblock *> scope_stack;\n+  std::vector<::Bvariable *> loop_value_stack;\n+  std::vector<::Blabel *> loop_begin_labels;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *>> mono;\n+  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, ::Bfunction *>>>\n+    mono_fns;\n \n   // To GCC middle-end\n-  std::vector< ::Btype *> type_decls;\n-  std::vector< ::Bvariable *> var_decls;\n-  std::vector< ::Bexpression *> const_decls;\n-  std::vector< ::Bfunction *> func_decls;\n+  std::vector<::Btype *> type_decls;\n+  std::vector<::Bvariable *> var_decls;\n+  std::vector<::Bexpression *> const_decls;\n+  std::vector<::Bfunction *> func_decls;\n };\n \n class TyTyResolveCompile : public TyTy::TyVisitor"}, {"sha": "b8a8faf2a2eee28ab20a21e260cc04f90ad8d109", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=e3b7eb58844c446d097ddee00ecd455d5537c6b2", "patch": "@@ -100,14 +100,15 @@ class CompileExternItem : public HIRCompileBase\n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n     Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\t      ctx->insert_function_decl (fntype, lookup);\n \n \t    return;\n \t  }\n@@ -123,7 +124,7 @@ class CompileExternItem : public HIRCompileBase\n       {\n \tIntrinsics compile (ctx);\n \tBfunction *fndecl = compile.compile (fntype);\n-\tctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+\tctx->insert_function_decl (fntype, fndecl);\n \treturn;\n       }\n \n@@ -141,8 +142,7 @@ class CompileExternItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+    ctx->insert_function_decl (fntype, fndecl);\n   }\n \n private:"}, {"sha": "1d3ad0282e676564f148e121854f841a411133a7", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=e3b7eb58844c446d097ddee00ecd455d5537c6b2", "patch": "@@ -113,16 +113,16 @@ class CompileInherentImplItem : public HIRCompileBase\n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n     Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n-\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n-\t\t\t\t\t   fntype);\n+\t\tctx->insert_function_decl (fntype, lookup);\n \t      }\n \t    reference\n \t      = ctx->get_backend ()->function_code_expression (lookup,\n@@ -160,7 +160,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+    ctx->insert_function_decl (fntype, fndecl);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();\n@@ -381,16 +381,16 @@ class CompileTraitItem : public HIRCompileBase\n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n     Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup))\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n-\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n-\t\t\t\t\t   fntype);\n+\t\tctx->insert_function_decl (fntype, lookup);\n \t      }\n \t    reference\n \t      = ctx->get_backend ()->function_code_expression (lookup,\n@@ -422,7 +422,7 @@ class CompileTraitItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, func.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+    ctx->insert_function_decl (fntype, fndecl);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}, {"sha": "b263cf6c41c1cc6744f523efdee27054c5d0cd35", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3b7eb58844c446d097ddee00ecd455d5537c6b2/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=e3b7eb58844c446d097ddee00ecd455d5537c6b2", "patch": "@@ -150,16 +150,16 @@ class CompileItem : public HIRCompileBase\n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n     Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n \t    Bfunction *dummy = nullptr;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n-\t\tctx->insert_function_decl (fntype->get_ty_ref (), lookup,\n-\t\t\t\t\t   fntype);\n+\t\tctx->insert_function_decl (fntype, lookup);\n \t      }\n \n \t    reference\n@@ -205,7 +205,7 @@ class CompileItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n+    ctx->insert_function_decl (fntype, fndecl);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}]}