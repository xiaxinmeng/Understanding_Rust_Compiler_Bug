{"sha": "9a15d3beace26d68561cb3481b70b0bbcb122ca5", "node_id": "C_kwDOANBUbNoAKDlhMTVkM2JlYWNlMjZkNjg1NjFjYjM0ODFiNzBiMGJiY2IxMjJjYTU", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-06-29T23:00:54Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-07-15T15:30:38Z"}, "message": "c++: Add __reference_con{struc,ver}ts_from_temporary [PR104477]\n\nThis patch implements C++23 P2255R2, which adds two new type traits to\ndetect reference binding to a temporary.  They can be used to detect code\nlike\n\n  std::tuple<const std::string&> t(\"meow\");\n\nwhich is incorrect because it always creates a dangling reference, because\nthe std::string temporary is created inside the selected constructor of\nstd::tuple, and not outside it.\n\nThere are two new compiler builtins, __reference_constructs_from_temporary\nand __reference_converts_from_temporary.  The former is used to simulate\ndirect- and the latter copy-initialization context.  But I had a hard time\nfinding a test where there's actually a difference.  Under DR 2267, both\nof these are invalid:\n\n  struct A { } a;\n  struct B { explicit B(const A&); };\n  const B &b1{a};\n  const B &b2(a);\n\nso I had to peruse [over.match.ref], and eventually realized that the\ndifference can be seen here:\n\n  struct G {\n    operator int(); // #1\n    explicit operator int&&(); // #2\n  };\n\nint&& r1(G{}); // use #2 (no temporary)\nint&& r2 = G{}; // use #1 (a temporary is created to be bound to int&&)\n\nThe implementation itself was rather straightforward because we already\nhave the conv_binds_ref_to_prvalue function.  The main function here is\nref_xes_from_temporary.\nI've changed the return type of ref_conv_binds_directly to tristate, because\npreviously the function didn't distinguish between an invalid conversion and\none that binds to a prvalue.  Since it no longer returns a bool, I removed\nthe _p suffix.\n\nThe patch also adds the relevant class and variable templates to <type_traits>.\n\n\tPR c++/104477\n\ngcc/c-family/ChangeLog:\n\n\t* c-common.cc (c_common_reswords): Add\n\t__reference_constructs_from_temporary and\n\t__reference_converts_from_temporary.\n\t* c-common.h (enum rid): Add RID_REF_CONSTRUCTS_FROM_TEMPORARY and\n\tRID_REF_CONVERTS_FROM_TEMPORARY.\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (ref_conv_binds_directly_p): Rename to ...\n\t(ref_conv_binds_directly): ... this.  Add a new bool parameter.  Change\n\tthe return type to tristate.\n\t* constraint.cc (diagnose_trait_expr): Handle\n\tCPTK_REF_CONSTRUCTS_FROM_TEMPORARY and CPTK_REF_CONVERTS_FROM_TEMPORARY.\n\t* cp-tree.h: Include \"tristate.h\".\n\t(enum cp_trait_kind): Add CPTK_REF_CONSTRUCTS_FROM_TEMPORARY\n\tand CPTK_REF_CONVERTS_FROM_TEMPORARY.\n\t(ref_conv_binds_directly_p): Rename to ...\n\t(ref_conv_binds_directly): ... this.\n\t(ref_xes_from_temporary): Declare.\n\t* cxx-pretty-print.cc (pp_cxx_trait_expression): Handle\n\tCPTK_REF_CONSTRUCTS_FROM_TEMPORARY and CPTK_REF_CONVERTS_FROM_TEMPORARY.\n\t* method.cc (ref_xes_from_temporary): New.\n\t* parser.cc (cp_parser_primary_expression): Handle\n\tRID_REF_CONSTRUCTS_FROM_TEMPORARY and RID_REF_CONVERTS_FROM_TEMPORARY.\n\t(cp_parser_trait_expr): Likewise.\n\t(warn_for_range_copy): Adjust to call ref_conv_binds_directly.\n\t* semantics.cc (trait_expr_value): Handle\n\tCPTK_REF_CONSTRUCTS_FROM_TEMPORARY and CPTK_REF_CONVERTS_FROM_TEMPORARY.\n\t(finish_trait_expr): Likewise.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/type_traits (reference_constructs_from_temporary,\n\treference_converts_from_temporary): New class templates.\n\t(reference_constructs_from_temporary_v,\n\treference_converts_from_temporary_v): New variable templates.\n\t(__cpp_lib_reference_from_temporary): Define for C++23.\n\t* include/std/version (__cpp_lib_reference_from_temporary): Define for\n\tC++23.\n\t* testsuite/20_util/variable_templates_for_traits.cc: Test\n\treference_constructs_from_temporary_v and\n\treference_converts_from_temporary_v.\n\t* testsuite/20_util/reference_from_temporary/value.cc: New test.\n\t* testsuite/20_util/reference_from_temporary/value2.cc: New test.\n\t* testsuite/20_util/reference_from_temporary/version.cc: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/reference_constructs_from_temporary1.C: New test.\n\t* g++.dg/ext/reference_converts_from_temporary1.C: New test.", "tree": {"sha": "7db269b8e6e93169326693418b3ac42c50c0d62d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7db269b8e6e93169326693418b3ac42c50c0d62d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a15d3beace26d68561cb3481b70b0bbcb122ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a15d3beace26d68561cb3481b70b0bbcb122ca5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a15d3beace26d68561cb3481b70b0bbcb122ca5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a15d3beace26d68561cb3481b70b0bbcb122ca5/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a8edfbd37d399d1103d86e134ba0a92f8c873c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a8edfbd37d399d1103d86e134ba0a92f8c873c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a8edfbd37d399d1103d86e134ba0a92f8c873c3"}], "stats": {"total": 768, "additions": 744, "deletions": 24}, "files": [{"sha": "655c3aefee6727b803cc276c5f7d44f1dd6315ce", "filename": "gcc/c-family/c-common.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fc-family%2Fc-common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fc-family%2Fc-common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -537,6 +537,10 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__is_constructible\", RID_IS_CONSTRUCTIBLE, D_CXXONLY },\n   { \"__is_nothrow_assignable\", RID_IS_NOTHROW_ASSIGNABLE, D_CXXONLY },\n   { \"__is_nothrow_constructible\", RID_IS_NOTHROW_CONSTRUCTIBLE, D_CXXONLY },\n+  { \"__reference_constructs_from_temporary\", RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n+\t\t\t\t\tD_CXXONLY },\n+  { \"__reference_converts_from_temporary\", RID_REF_CONVERTS_FROM_TEMPORARY,\n+\t\t\t\t\tD_CXXONLY },\n \n   /* C++ transactional memory.  */\n   { \"synchronized\",\tRID_SYNCHRONIZED, D_CXX_OBJC | D_TRANSMEM },"}, {"sha": "f9064393b4e030fdd8d166babfd077a7fa7d2c6e", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -184,6 +184,8 @@ enum rid\n   RID_IS_UNION,                RID_UNDERLYING_TYPE,\n   RID_IS_ASSIGNABLE,           RID_IS_CONSTRUCTIBLE,\n   RID_IS_NOTHROW_ASSIGNABLE,   RID_IS_NOTHROW_CONSTRUCTIBLE,\n+  RID_REF_CONSTRUCTS_FROM_TEMPORARY,\n+  RID_REF_CONVERTS_FROM_TEMPORARY,\n \n   /* C++11 */\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,"}, {"sha": "191c68cdcfd692debbec2217b7efca047ab79983", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -9109,21 +9109,27 @@ conv_binds_ref_to_prvalue (conversion *c)\n   return conv_is_prvalue (next_conversion (c));\n }\n \n-/* True iff converting EXPR to a reference type TYPE does not involve\n-   creating a temporary.  */\n+/* Return tristate::TS_TRUE if converting EXPR to a reference type TYPE does\n+   not involve creating a temporary.  Return tristate::TS_FALSE if converting\n+   EXPR to a reference type TYPE binds the reference to a temporary.  If the\n+   conversion is invalid or bad, return tristate::TS_UNKNOWN.  DIRECT_INIT_P\n+   says whether the conversion should be done in direct- or copy-initialization\n+   context.  */\n \n-bool\n-ref_conv_binds_directly_p (tree type, tree expr)\n+tristate\n+ref_conv_binds_directly (tree type, tree expr, bool direct_init_p /*= false*/)\n {\n   gcc_assert (TYPE_REF_P (type));\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   void *p = conversion_obstack_alloc (0);\n \n+  const int flags = direct_init_p ? LOOKUP_NORMAL : LOOKUP_IMPLICIT;\n   conversion *conv = implicit_conversion (type, TREE_TYPE (expr), expr,\n-\t\t\t\t\t  /*c_cast_p=*/false,\n-\t\t\t\t\t  LOOKUP_IMPLICIT, tf_none);\n-  bool ret = conv && !conv->bad_p && !conv_binds_ref_to_prvalue (conv);\n+\t\t\t\t\t  /*c_cast_p=*/false, flags, tf_none);\n+  tristate ret (tristate::TS_UNKNOWN);\n+  if (conv && !conv->bad_p)\n+    ret = tristate (!conv_binds_ref_to_prvalue (conv));\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);"}, {"sha": "568318f0ba1d67b765dad321994b3082441370fa", "filename": "gcc/cp/constraint.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fconstraint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fconstraint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstraint.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -3697,6 +3697,14 @@ diagnose_trait_expr (tree expr, tree args)\n     case CPTK_HAS_UNIQUE_OBJ_REPRESENTATIONS:\n       inform (loc, \"  %qT does not have unique object representations\", t1);\n       break;\n+    case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n+      inform (loc, \"  %qT is not a reference that binds to a temporary \"\n+\t      \"object of type %qT (direct-initialization)\", t1, t2);\n+      break;\n+    case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n+      inform (loc, \"  %qT is not a reference that binds to a temporary \"\n+\t      \"object of type %qT (copy-initialization)\", t1, t2);\n+      break;\n     case CPTK_BASES:\n     case CPTK_DIRECT_BASES:\n     case CPTK_UNDERLYING_TYPE:"}, {"sha": "cf51c39dc90c2feef3040ac76b9a440acdae4f33", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"hard-reg-set.h\"\n #include \"function.h\"\n+#include \"tristate.h\"\n \n /* In order for the format checking to accept the C++ front end\n    diagnostic framework extensions, you must include this file before\n@@ -1397,7 +1398,9 @@ enum cp_trait_kind\n   CPTK_IS_ASSIGNABLE,\n   CPTK_IS_CONSTRUCTIBLE,\n   CPTK_IS_NOTHROW_ASSIGNABLE,\n-  CPTK_IS_NOTHROW_CONSTRUCTIBLE\n+  CPTK_IS_NOTHROW_CONSTRUCTIBLE,\n+  CPTK_REF_CONSTRUCTS_FROM_TEMPORARY,\n+  CPTK_REF_CONVERTS_FROM_TEMPORARY\n };\n \n /* The types that we are processing.  */\n@@ -6520,7 +6523,7 @@ extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree extract_call_expr\t\t\t(tree);\n extern tree build_trivial_dtor_call\t\t(tree, bool = false);\n-extern bool ref_conv_binds_directly_p\t\t(tree, tree);\n+extern tristate ref_conv_binds_directly\t\t(tree, tree, bool = false);\n extern tree build_user_type_conversion\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_new_function_call\t\t(tree, vec<tree, va_gc> **,\n@@ -7105,6 +7108,7 @@ extern tree forward_parm\t\t\t(tree);\n extern bool is_trivially_xible\t\t\t(enum tree_code, tree, tree);\n extern bool is_nothrow_xible\t\t\t(enum tree_code, tree, tree);\n extern bool is_xible\t\t\t\t(enum tree_code, tree, tree);\n+extern bool ref_xes_from_temporary\t\t(tree, tree, bool);\n extern tree get_defaulted_eh_spec\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern bool maybe_explain_implicit_delete\t(tree);\n extern void explain_implicit_non_constexpr\t(tree);"}, {"sha": "44590830a615b57f0dfbc3e806be5e10b23ccc98", "filename": "gcc/cp/cxx-pretty-print.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fcxx-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fcxx-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -2696,6 +2696,12 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n       pp_cxx_ws_string (pp, \"__is_nothrow_constructible\");\n       break;\n+    case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n+      pp_cxx_ws_string (pp, \"__reference_constructs_from_temporary\");\n+      break;\n+    case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n+      pp_cxx_ws_string (pp, \"__reference_converts_from_temporary\");\n+      break;\n \n     default:\n       gcc_unreachable ();"}, {"sha": "f2050f6e970325208a579b95f612fc272feb5f2f", "filename": "gcc/cp/method.cc", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fmethod.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fmethod.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -2211,6 +2211,31 @@ is_xible (enum tree_code code, tree to, tree from)\n   return !!expr;\n }\n \n+/* Return true iff conjunction_v<is_reference<T>, is_constructible<T, U>> is\n+   true, and the initialization\n+     T t(VAL<U>); // DIRECT_INIT_P\n+   or\n+     T t = VAL<U>; // !DIRECT_INIT_P\n+   binds t to a temporary object whose lifetime is extended.\n+   VAL<T> is defined in [meta.unary.prop]:\n+   -- If T is a reference or function type, VAL<T> is an expression with the\n+   same type and value category as declval<T>().\n+   -- Otherwise, VAL<T> is a prvalue that initially has type T.   */\n+\n+bool\n+ref_xes_from_temporary (tree to, tree from, bool direct_init_p)\n+{\n+  /* Check is_reference<T>.  */\n+  if (!TYPE_REF_P (to))\n+    return false;\n+  /* We don't check is_constructible<T, U>: if T isn't constructible\n+     from U, we won't be able to create a conversion.  */\n+  tree val = build_stub_object (from);\n+  if (!TYPE_REF_P (from) && TREE_CODE (from) != FUNCTION_TYPE)\n+    val = CLASS_TYPE_P (from) ? force_rvalue (val, tf_none) : rvalue (val);\n+  return ref_conv_binds_directly (to, val, direct_init_p).is_false ();\n+}\n+\n /* Categorize various special_function_kinds.  */\n #define SFK_CTOR_P(sfk) \\\n   ((sfk) >= sfk_constructor && (sfk) <= sfk_move_constructor)"}, {"sha": "4f67441eeb13405a32ea6b9ed7d0a1cf77c39326", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -5917,6 +5917,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_CONSTRUCTIBLE:\n \tcase RID_IS_NOTHROW_ASSIGNABLE:\n \tcase RID_IS_NOTHROW_CONSTRUCTIBLE:\n+\tcase RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n+\tcase RID_REF_CONVERTS_FROM_TEMPORARY:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n \n \t// C++ concepts\n@@ -10988,6 +10990,14 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n       kind = CPTK_IS_NOTHROW_CONSTRUCTIBLE;\n       variadic = true;\n       break;\n+    case RID_REF_CONSTRUCTS_FROM_TEMPORARY:\n+      kind = CPTK_REF_CONSTRUCTS_FROM_TEMPORARY;\n+      binary = true;\n+      break;\n+    case RID_REF_CONVERTS_FROM_TEMPORARY:\n+      kind = CPTK_REF_CONVERTS_FROM_TEMPORARY;\n+      binary = true;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -13811,7 +13821,7 @@ warn_for_range_copy (tree decl, tree expr)\n \n   if (TYPE_REF_P (type))\n     {\n-      if (glvalue_p (expr) && !ref_conv_binds_directly_p (type, expr))\n+      if (glvalue_p (expr) && ref_conv_binds_directly (type, expr).is_false ())\n \t{\n \t  auto_diagnostic_group d;\n \t  if (warning_at (loc, OPT_Wrange_loop_construct,\n@@ -13839,20 +13849,20 @@ warn_for_range_copy (tree decl, tree expr)\n \t  && trivially_copyable_p (type)))\n     return;\n \n+  /* If we can initialize a reference directly, suggest that to avoid the\n+     copy.  */\n   tree rtype = cp_build_reference_type (type, /*rval*/false);\n-  /* If we could initialize the reference directly, it wouldn't involve any\n-     copies.  */\n-  if (!ref_conv_binds_directly_p (rtype, expr))\n-    return;\n-\n-  auto_diagnostic_group d;\n-  if (warning_at (loc, OPT_Wrange_loop_construct,\n-\t\t  \"loop variable %qD creates a copy from type %qT\",\n-\t\t  decl, type))\n+  if (ref_conv_binds_directly (rtype, expr).is_true ())\n     {\n-      gcc_rich_location richloc (loc);\n-      richloc.add_fixit_insert_before (\"&\");\n-      inform (&richloc, \"use reference type to prevent copying\");\n+      auto_diagnostic_group d;\n+      if (warning_at (loc, OPT_Wrange_loop_construct,\n+\t\t      \"loop variable %qD creates a copy from type %qT\",\n+\t\t      decl, type))\n+\t{\n+\t  gcc_rich_location richloc (loc);\n+\t  richloc.add_fixit_insert_before (\"&\");\n+\t  inform (&richloc, \"use reference type to prevent copying\");\n+\t}\n     }\n }\n "}, {"sha": "96037c21b857b5dd1f42502a66ddadf3c3e019e7", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -12007,6 +12007,12 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n       return is_nothrow_xible (INIT_EXPR, type1, type2);\n \n+    case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n+      return ref_xes_from_temporary (type1, type2, /*direct_init=*/true);\n+\n+    case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n+      return ref_xes_from_temporary (type1, type2, /*direct_init=*/false);\n+\n     default:\n       gcc_unreachable ();\n       return false;\n@@ -12088,6 +12094,8 @@ finish_trait_expr (location_t loc, cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n     case CPTK_IS_NOTHROW_ASSIGNABLE:\n     case CPTK_IS_NOTHROW_CONSTRUCTIBLE:\n+    case CPTK_REF_CONSTRUCTS_FROM_TEMPORARY:\n+    case CPTK_REF_CONVERTS_FROM_TEMPORARY:\n       if (!check_trait_type (type1)\n \t  || !check_trait_type (type2))\n \treturn error_mark_node;"}, {"sha": "76de905a35dc03b01e0572931b7f99b11dc6037e", "filename": "gcc/testsuite/g++.dg/ext/reference_constructs_from_temporary1.C", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Freference_constructs_from_temporary1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Freference_constructs_from_temporary1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Freference_constructs_from_temporary1.C?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -0,0 +1,214 @@\n+// P2255R2\n+// PR c++/104477\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert((X),#X)\n+\n+struct A { A(); };\n+struct B { operator A(); };\n+struct C { explicit C(); };\n+struct D { explicit operator A(); };\n+struct E { explicit operator A&(); };\n+struct F { explicit operator A&&(); };\n+// Could use a class template with explicit(bool), but then this would need\n+// C++20.\n+struct G {\n+  operator int();\n+  explicit operator int&&();\n+};\n+struct G2 {\n+  explicit operator int();\n+  operator int&&();\n+};\n+struct H {\n+  operator int();\n+  explicit operator int&();\n+};\n+struct H2 {\n+  explicit operator int();\n+  operator int&();\n+};\n+\n+struct Base { };\n+struct Der : Base { };\n+\n+template<typename T, typename RT>\n+struct morph {\n+  mutable T val{};\n+  operator RT() const { return static_cast<RT>(val); }\n+};\n+\n+template<typename T> using id = T;\n+\n+// Built-in types.\n+SA(!__reference_constructs_from_temporary(int, int));\n+SA(!__reference_constructs_from_temporary(int&, void));\n+SA(!__reference_constructs_from_temporary(int&, const void));\n+SA(!__reference_constructs_from_temporary(int&, volatile void));\n+SA(!__reference_constructs_from_temporary(int&, const volatile void));\n+SA(!__reference_constructs_from_temporary(void, void));\n+SA(!__reference_constructs_from_temporary(void, int));\n+SA(!__reference_constructs_from_temporary(int&, int));\n+SA(!__reference_constructs_from_temporary(int&, int&));\n+SA(!__reference_constructs_from_temporary(int&, int&&));\n+SA(!__reference_constructs_from_temporary(int&, long));\n+// non-const lvalue reference to type 'int' cannot bind to a value of unrelated type 'long'\n+SA(!__reference_constructs_from_temporary(int&, long&));\n+SA(!__reference_constructs_from_temporary(int&, long&&));\n+SA( __reference_constructs_from_temporary(const int&, int));\n+SA(!__reference_constructs_from_temporary(const int&, int&));\n+SA(!__reference_constructs_from_temporary(const int&, const int&));\n+SA(!__reference_constructs_from_temporary(const int&, int&&));\n+SA( __reference_constructs_from_temporary(const int&, long));\n+SA( __reference_constructs_from_temporary(const int&, long&));\n+SA( __reference_constructs_from_temporary(const int&, long&&));\n+SA( __reference_constructs_from_temporary(int&&, int));\n+SA(!__reference_constructs_from_temporary(int&&, int&));\n+SA(!__reference_constructs_from_temporary(int&&, int&&));\n+SA( __reference_constructs_from_temporary(int&&, long));\n+SA( __reference_constructs_from_temporary(int&&, long&));\n+SA( __reference_constructs_from_temporary(int&&, long&&));\n+SA(!__reference_constructs_from_temporary(unsigned int&, double));\n+SA(!__reference_constructs_from_temporary(volatile int&, int));\n+SA(!__reference_constructs_from_temporary(const volatile int&, int));\n+SA(!__reference_constructs_from_temporary(volatile int&, int&));\n+SA(!__reference_constructs_from_temporary(const volatile int&, int&));\n+SA(!__reference_constructs_from_temporary(volatile int&, int&&));\n+SA(!__reference_constructs_from_temporary(const volatile int&, int&&));\n+\n+// Classes.\n+SA(!__reference_constructs_from_temporary(A, A));\n+// A& r(A{}); doesn't construct.\n+SA(!__reference_constructs_from_temporary(A&, A));\n+SA(!__reference_constructs_from_temporary(A&, A&));\n+SA(!__reference_constructs_from_temporary(A&, A&&));\n+// Here we get const struct A & r = (const struct A &) &D.2414;\n+SA( __reference_constructs_from_temporary(const A&, A));\n+SA(!__reference_constructs_from_temporary(const A&, A&));\n+SA(!__reference_constructs_from_temporary(const A&, const A&));\n+SA(!__reference_constructs_from_temporary(const A&, A&&));\n+// Here we get struct A & r = (struct A &) &D.2439;\n+SA( __reference_constructs_from_temporary(A&&, A));\n+SA(!__reference_constructs_from_temporary(A&&, A&));\n+SA(!__reference_constructs_from_temporary(A&&, const A&));\n+SA(!__reference_constructs_from_temporary(A&&, A&&));\n+\n+SA(!__reference_constructs_from_temporary(A, B));\n+SA(!__reference_constructs_from_temporary(A&, B));\n+SA(!__reference_constructs_from_temporary(A&, B&));\n+SA(!__reference_constructs_from_temporary(A&, const B&));\n+SA(!__reference_constructs_from_temporary(A&, B&&));\n+SA( __reference_constructs_from_temporary(const A&, B));\n+SA( __reference_constructs_from_temporary(const A&, B&));\n+// Doesn't construct, so it's false.\n+SA(!__reference_constructs_from_temporary(const A&, const B&));\n+SA( __reference_constructs_from_temporary(const A&, B&&));\n+SA( __reference_constructs_from_temporary(A&&, B));\n+SA( __reference_constructs_from_temporary(A&&, B&));\n+SA(!__reference_constructs_from_temporary(A&&, const B&));\n+SA( __reference_constructs_from_temporary(A&&, B&&));\n+\n+SA(!__reference_constructs_from_temporary(const A&, C));\n+SA(!__reference_constructs_from_temporary(const A&, C&));\n+\n+// Doesn't construct, so it's false.\n+SA(!__reference_constructs_from_temporary(int&, morph<int, int>));\n+// Here we get\n+//   const int & r2 = D.2580 = morph<int, int>::operator int\n+//     (&TARGET_EXPR <D.2578, {.val=0}>); (const int &) &D.2580;\n+SA( __reference_constructs_from_temporary(const int&, morph<int, int>));\n+SA(!__reference_constructs_from_temporary(int&, morph<int, int&>));\n+SA(!__reference_constructs_from_temporary(int&, morph<int, const int&>));\n+SA(!__reference_constructs_from_temporary(int&, morph<int, int&&>));\n+SA( __reference_constructs_from_temporary(const int&, morph<long, long&>));\n+\n+// These are like const C& c(cref); so the explicit ctor C isn't a problem\n+// even in copy-init context.  const C& r = {}; would be a different story.\n+SA(!__reference_constructs_from_temporary(C, C));\n+SA(!__reference_constructs_from_temporary(C&, C));\n+SA(!__reference_constructs_from_temporary(C&, C&));\n+SA(!__reference_constructs_from_temporary(C&, C&&));\n+SA( __reference_constructs_from_temporary(const C&, C));\n+SA(!__reference_constructs_from_temporary(const C&, C&));\n+SA(!__reference_constructs_from_temporary(const C&, const C&));\n+SA(!__reference_constructs_from_temporary(const C&, C&&));\n+SA( __reference_constructs_from_temporary(C&&, C));\n+SA(!__reference_constructs_from_temporary(C&&, C&));\n+SA(!__reference_constructs_from_temporary(C&&, const C&));\n+SA(!__reference_constructs_from_temporary(C&&, C&&));\n+\n+// These are all false ultimately because of CWG 2267, which we implement.\n+SA(!__reference_constructs_from_temporary(A, D));\n+SA(!__reference_constructs_from_temporary(A&, D));\n+SA(!__reference_constructs_from_temporary(A&, D&));\n+SA(!__reference_constructs_from_temporary(A&, const D&));\n+SA(!__reference_constructs_from_temporary(A&, D&&));\n+SA(!__reference_constructs_from_temporary(const A&, D));\n+SA(!__reference_constructs_from_temporary(const A&, D&));\n+SA(!__reference_constructs_from_temporary(const A&, const D&));\n+SA(!__reference_constructs_from_temporary(const A&, D&&));\n+SA(!__reference_constructs_from_temporary(A&&, D));\n+SA(!__reference_constructs_from_temporary(A&&, D&));\n+SA(!__reference_constructs_from_temporary(A&&, const D&));\n+SA(!__reference_constructs_from_temporary(A&&, D&&));\n+\n+SA(!__reference_constructs_from_temporary(A, E));\n+/* A& a1(E{}); compiles, but A& a2 = E{}; doesn't.\n+   With the former, we get A& a = E::operator A& (&TARGET_EXPR <D.2715, {}>)\n+   so we're not binding the reference to a temporary, although there is\n+   a temporary involved.  So the result is false in both copy- and direct-\n+   init, albeit for different reasons!  */\n+SA(!__reference_constructs_from_temporary(A&, E));\n+// A& a = E::operator A& ((struct E *) r)); copy-init doesn't compile.\n+SA(!__reference_constructs_from_temporary(A&, E&));\n+SA(!__reference_constructs_from_temporary(A&, const E&));\n+SA(!__reference_constructs_from_temporary(A&, E&&));\n+// direct-init:\n+// const A& a = (const struct A &) E::operator A& (&TARGET_EXPR <D.2720, {}>)\n+SA(!__reference_constructs_from_temporary(const A&, E));\n+SA(!__reference_constructs_from_temporary(const A&, E&));\n+SA(!__reference_constructs_from_temporary(const A&, const E&));\n+SA(!__reference_constructs_from_temporary(const A&, E&&));\n+SA(!__reference_constructs_from_temporary(A&&, E));\n+SA(!__reference_constructs_from_temporary(A&&, E&));\n+SA(!__reference_constructs_from_temporary(A&&, const E&));\n+SA(!__reference_constructs_from_temporary(A&&, E&&));\n+\n+SA(!__reference_constructs_from_temporary(A, F));\n+// A& a1(F{}); and A& a2 = F{}; both invalid.\n+SA(!__reference_constructs_from_temporary(A&, F));\n+SA(!__reference_constructs_from_temporary(A&, F&));\n+SA(!__reference_constructs_from_temporary(A&, const F&));\n+SA(!__reference_constructs_from_temporary(A&, F&&));\n+SA(!__reference_constructs_from_temporary(const A&, F));\n+SA(!__reference_constructs_from_temporary(const A&, F&));\n+SA(!__reference_constructs_from_temporary(const A&, const F&));\n+SA(!__reference_constructs_from_temporary(const A&, F&&));\n+SA(!__reference_constructs_from_temporary(A&&, F));\n+SA(!__reference_constructs_from_temporary(A&&, F&));\n+SA(!__reference_constructs_from_temporary(A&&, const F&));\n+SA(!__reference_constructs_from_temporary(A&&, F&&));\n+\n+/* This is where _converts_ and _constructs_ will differ:\n+   in direct-init we use G::operator int&& (no temporary),\n+   but in copy-init we use G::operator int, where a temporary is created\n+   to be bound to int&&.  */\n+SA(!__reference_constructs_from_temporary(int&&, G));\n+// Similar to the previous one.\n+SA(!__reference_constructs_from_temporary(const int&, H));\n+/* And here I've switched the explicit-ness.  In both copy- and direct-init\n+   we call operator int&, so no temporary.  */\n+SA(!__reference_constructs_from_temporary(int&&, G2));\n+SA(!__reference_constructs_from_temporary(const int&, H2));\n+\n+SA(!__reference_constructs_from_temporary(const Base&, Der));\n+\n+// This fails because std::is_constructible_v<int&&, id<int[3]>> is false.\n+SA(!__reference_constructs_from_temporary(int&&, id<int[3]>));\n+\n+// Arrays.\n+SA(!__reference_constructs_from_temporary(int, int[]));\n+SA(!__reference_constructs_from_temporary(int[], int[]));\n+SA(!__reference_constructs_from_temporary(int&, int[]));\n+SA(!__reference_constructs_from_temporary(int&&, int[]));\n+SA(!__reference_constructs_from_temporary(const int&, int[]));"}, {"sha": "90196c387428fabf55d811682b19c740f65a47f1", "filename": "gcc/testsuite/g++.dg/ext/reference_converts_from_temporary1.C", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Freference_converts_from_temporary1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Freference_converts_from_temporary1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Freference_converts_from_temporary1.C?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -0,0 +1,214 @@\n+// P2255R2\n+// PR c++/104477\n+// { dg-do compile { target c++11 } }\n+\n+#define SA(X) static_assert((X),#X)\n+\n+struct A { A(); };\n+struct B { operator A(); };\n+struct C { explicit C(); };\n+struct D { explicit operator A(); };\n+struct E { explicit operator A&(); };\n+struct F { explicit operator A&&(); };\n+// Could use a class template with explicit(bool), but then this would need\n+// C++20.\n+struct G {\n+  operator int();\n+  explicit operator int&&();\n+};\n+struct G2 {\n+  explicit operator int();\n+  operator int&&();\n+};\n+struct H {\n+  operator int();\n+  explicit operator int&();\n+};\n+struct H2 {\n+  explicit operator int();\n+  operator int&();\n+};\n+\n+struct Base { };\n+struct Der : Base { };\n+\n+template<typename T, typename RT>\n+struct morph {\n+  mutable T val{};\n+  operator RT() const { return static_cast<RT>(val); }\n+};\n+\n+template<typename T> using id = T;\n+\n+// Built-in types.\n+SA(!__reference_converts_from_temporary(int, int));\n+SA(!__reference_converts_from_temporary(int&, void));\n+SA(!__reference_converts_from_temporary(int&, const void));\n+SA(!__reference_converts_from_temporary(int&, volatile void));\n+SA(!__reference_converts_from_temporary(int&, const volatile void));\n+SA(!__reference_converts_from_temporary(void, void));\n+SA(!__reference_converts_from_temporary(void, int));\n+SA(!__reference_converts_from_temporary(int&, int));\n+SA(!__reference_converts_from_temporary(int&, int&));\n+SA(!__reference_converts_from_temporary(int&, int&&));\n+SA(!__reference_converts_from_temporary(int&, long));\n+// non-const lvalue reference to type 'int' cannot bind to a value of unrelated type 'long'\n+SA(!__reference_converts_from_temporary(int&, long&));\n+SA(!__reference_converts_from_temporary(int&, long&&));\n+SA( __reference_converts_from_temporary(const int&, int));\n+SA(!__reference_converts_from_temporary(const int&, int&));\n+SA(!__reference_converts_from_temporary(const int&, const int&));\n+SA(!__reference_converts_from_temporary(const int&, int&&));\n+SA( __reference_converts_from_temporary(const int&, long));\n+SA( __reference_converts_from_temporary(const int&, long&));\n+SA( __reference_converts_from_temporary(const int&, long&&));\n+SA( __reference_converts_from_temporary(int&&, int));\n+SA(!__reference_converts_from_temporary(int&&, int&));\n+SA(!__reference_converts_from_temporary(int&&, int&&));\n+SA( __reference_converts_from_temporary(int&&, long));\n+SA( __reference_converts_from_temporary(int&&, long&));\n+SA( __reference_converts_from_temporary(int&&, long&&));\n+SA(!__reference_converts_from_temporary(unsigned int&, double));\n+SA(!__reference_converts_from_temporary(volatile int&, int));\n+SA(!__reference_converts_from_temporary(const volatile int&, int));\n+SA(!__reference_converts_from_temporary(volatile int&, int&));\n+SA(!__reference_converts_from_temporary(const volatile int&, int&));\n+SA(!__reference_converts_from_temporary(volatile int&, int&&));\n+SA(!__reference_converts_from_temporary(const volatile int&, int&&));\n+\n+// Classes.\n+SA(!__reference_converts_from_temporary(A, A));\n+// A& r(A{}); doesn't construct.\n+SA(!__reference_converts_from_temporary(A&, A));\n+SA(!__reference_converts_from_temporary(A&, A&));\n+SA(!__reference_converts_from_temporary(A&, A&&));\n+// Here we get const struct A & r = (const struct A &) &D.2414;\n+SA( __reference_converts_from_temporary(const A&, A));\n+SA(!__reference_converts_from_temporary(const A&, A&));\n+SA(!__reference_converts_from_temporary(const A&, const A&));\n+SA(!__reference_converts_from_temporary(const A&, A&&));\n+// Here we get struct A & r = (struct A &) &D.2439;\n+SA( __reference_converts_from_temporary(A&&, A));\n+SA(!__reference_converts_from_temporary(A&&, A&));\n+SA(!__reference_converts_from_temporary(A&&, const A&));\n+SA(!__reference_converts_from_temporary(A&&, A&&));\n+\n+SA(!__reference_converts_from_temporary(A, B));\n+SA(!__reference_converts_from_temporary(A&, B));\n+SA(!__reference_converts_from_temporary(A&, B&));\n+SA(!__reference_converts_from_temporary(A&, const B&));\n+SA(!__reference_converts_from_temporary(A&, B&&));\n+SA( __reference_converts_from_temporary(const A&, B));\n+SA( __reference_converts_from_temporary(const A&, B&));\n+// Doesn't construct, so it's false.\n+SA(!__reference_converts_from_temporary(const A&, const B&));\n+SA( __reference_converts_from_temporary(const A&, B&&));\n+SA( __reference_converts_from_temporary(A&&, B));\n+SA( __reference_converts_from_temporary(A&&, B&));\n+SA(!__reference_converts_from_temporary(A&&, const B&));\n+SA( __reference_converts_from_temporary(A&&, B&&));\n+\n+SA(!__reference_converts_from_temporary(const A&, C));\n+SA(!__reference_converts_from_temporary(const A&, C&));\n+\n+// Doesn't construct, so it's false.\n+SA(!__reference_converts_from_temporary(int&, morph<int, int>));\n+// Here we get\n+//   const int & r2 = D.2580 = morph<int, int>::operator int\n+//     (&TARGET_EXPR <D.2578, {.val=0}>); (const int &) &D.2580;\n+SA( __reference_converts_from_temporary(const int&, morph<int, int>));\n+SA(!__reference_converts_from_temporary(int&, morph<int, int&>));\n+SA(!__reference_converts_from_temporary(int&, morph<int, const int&>));\n+SA(!__reference_converts_from_temporary(int&, morph<int, int&&>));\n+SA( __reference_converts_from_temporary(const int&, morph<long, long&>));\n+\n+// These are like const C& c(cref); so the explicit ctor C isn't a problem\n+// even in copy-init context.  const C& r = {}; would be a different story.\n+SA(!__reference_converts_from_temporary(C, C));\n+SA(!__reference_converts_from_temporary(C&, C));\n+SA(!__reference_converts_from_temporary(C&, C&));\n+SA(!__reference_converts_from_temporary(C&, C&&));\n+SA( __reference_converts_from_temporary(const C&, C));\n+SA(!__reference_converts_from_temporary(const C&, C&));\n+SA(!__reference_converts_from_temporary(const C&, const C&));\n+SA(!__reference_converts_from_temporary(const C&, C&&));\n+SA( __reference_converts_from_temporary(C&&, C));\n+SA(!__reference_converts_from_temporary(C&&, C&));\n+SA(!__reference_converts_from_temporary(C&&, const C&));\n+SA(!__reference_converts_from_temporary(C&&, C&&));\n+\n+// These are all false ultimately because of CWG 2267, which we implement.\n+SA(!__reference_converts_from_temporary(A, D));\n+SA(!__reference_converts_from_temporary(A&, D));\n+SA(!__reference_converts_from_temporary(A&, D&));\n+SA(!__reference_converts_from_temporary(A&, const D&));\n+SA(!__reference_converts_from_temporary(A&, D&&));\n+SA(!__reference_converts_from_temporary(const A&, D));\n+SA(!__reference_converts_from_temporary(const A&, D&));\n+SA(!__reference_converts_from_temporary(const A&, const D&));\n+SA(!__reference_converts_from_temporary(const A&, D&&));\n+SA(!__reference_converts_from_temporary(A&&, D));\n+SA(!__reference_converts_from_temporary(A&&, D&));\n+SA(!__reference_converts_from_temporary(A&&, const D&));\n+SA(!__reference_converts_from_temporary(A&&, D&&));\n+\n+SA(!__reference_converts_from_temporary(A, E));\n+/* A& a1(E{}); compiles, but A& a2 = E{}; doesn't.\n+   With the former, we get A& a = E::operator A& (&TARGET_EXPR <D.2715, {}>)\n+   so we're not binding the reference to a temporary, although there is\n+   a temporary involved.  So the result is false in both copy- and direct-\n+   init, albeit for different reasons!  */\n+SA(!__reference_converts_from_temporary(A&, E));\n+// A& a = E::operator A& ((struct E *) r)); copy-init doesn't compile.\n+SA(!__reference_converts_from_temporary(A&, E&));\n+SA(!__reference_converts_from_temporary(A&, const E&));\n+SA(!__reference_converts_from_temporary(A&, E&&));\n+// direct-init:\n+// const A& a = (const struct A &) E::operator A& (&TARGET_EXPR <D.2720, {}>)\n+SA(!__reference_converts_from_temporary(const A&, E));\n+SA(!__reference_converts_from_temporary(const A&, E&));\n+SA(!__reference_converts_from_temporary(const A&, const E&));\n+SA(!__reference_converts_from_temporary(const A&, E&&));\n+SA(!__reference_converts_from_temporary(A&&, E));\n+SA(!__reference_converts_from_temporary(A&&, E&));\n+SA(!__reference_converts_from_temporary(A&&, const E&));\n+SA(!__reference_converts_from_temporary(A&&, E&&));\n+\n+SA(!__reference_converts_from_temporary(A, F));\n+// A& a1(F{}); and A& a2 = F{}; both invalid.\n+SA(!__reference_converts_from_temporary(A&, F));\n+SA(!__reference_converts_from_temporary(A&, F&));\n+SA(!__reference_converts_from_temporary(A&, const F&));\n+SA(!__reference_converts_from_temporary(A&, F&&));\n+SA(!__reference_converts_from_temporary(const A&, F));\n+SA(!__reference_converts_from_temporary(const A&, F&));\n+SA(!__reference_converts_from_temporary(const A&, const F&));\n+SA(!__reference_converts_from_temporary(const A&, F&&));\n+SA(!__reference_converts_from_temporary(A&&, F));\n+SA(!__reference_converts_from_temporary(A&&, F&));\n+SA(!__reference_converts_from_temporary(A&&, const F&));\n+SA(!__reference_converts_from_temporary(A&&, F&&));\n+\n+/* This is where _converts_ and _constructs_ will differ:\n+   in direct-init we use G::operator int&& (no temporary),\n+   but in copy-init we use G::operator int, where a temporary is created\n+   to be bound to int&&.  */\n+SA( __reference_converts_from_temporary(int&&, G));\n+// Similar to the previous one.\n+SA( __reference_converts_from_temporary(const int&, H));\n+/* And here I've switched the explicit-ness.  In both copy- and direct-init\n+   we call operator int&, so no temporary.  */\n+SA(!__reference_converts_from_temporary(int&&, G2));\n+SA(!__reference_converts_from_temporary(const int&, H2));\n+\n+SA(!__reference_converts_from_temporary(const Base&, Der));\n+\n+// This fails because std::is_constructible_v<int&&, id<int[3]>> is false.\n+SA(!__reference_converts_from_temporary(int&&, id<int[3]>));\n+\n+// Arrays.\n+SA(!__reference_converts_from_temporary(int, int[]));\n+SA(!__reference_converts_from_temporary(int[], int[]));\n+SA(!__reference_converts_from_temporary(int&, int[]));\n+SA(!__reference_converts_from_temporary(int&&, int[]));\n+SA(!__reference_converts_from_temporary(const int&, int[]));"}, {"sha": "b1a1deecf664911ba84eba57320d8014d15da8f0", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -3505,6 +3505,45 @@ template<typename _Ret, typename _Fn, typename... _Args>\n   template<typename _Tp>\n     inline constexpr bool is_scoped_enum_v = is_scoped_enum<_Tp>::value;\n \n+#define __cpp_lib_reference_from_temporary 202202L\n+\n+  /// True if _Tp is a reference type, a _Up value can be bound to _Tp in\n+  /// direct-initialization, and a temporary object would be bound to\n+  /// the reference, false otherwise.\n+  /// @since C++23\n+  template<typename _Tp, typename _Up>\n+    struct reference_constructs_from_temporary\n+    : public bool_constant<__reference_constructs_from_temporary(_Tp, _Up)>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{})\n+\t\t    && std::__is_complete_or_unbounded(__type_identity<_Up>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n+\n+  /// True if _Tp is a reference type, a _Up value can be bound to _Tp in\n+  /// copy-initialization, and a temporary object would be bound to\n+  /// the reference, false otherwise.\n+  /// @since C++23\n+  template<typename _Tp, typename _Up>\n+    struct reference_converts_from_temporary\n+    : public bool_constant<__reference_converts_from_temporary(_Tp, _Up)>\n+    {\n+      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{})\n+\t\t    && std::__is_complete_or_unbounded(__type_identity<_Up>{}),\n+\t\"template argument must be a complete class or an unbounded array\");\n+    };\n+\n+  /// @ingroup variable_templates\n+  /// @since C++23\n+  template<typename _Tp, typename _Up>\n+    inline constexpr bool reference_constructs_from_temporary_v\n+      = reference_constructs_from_temporary<_Tp, _Up>::value;\n+\n+  /// @ingroup variable_templates\n+  /// @since C++23\n+  template<typename _Tp, typename _Up>\n+    inline constexpr bool reference_converts_from_temporary_v\n+      = reference_converts_from_temporary<_Tp, _Up>::value;\n #endif // C++23\n \n #if _GLIBCXX_HAVE_IS_CONSTANT_EVALUATED"}, {"sha": "5edca2f3007ac5780fe68a3c063d2f26a76f4f98", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -300,10 +300,11 @@\n #endif\n \n #if __cplusplus > 202002L\n-// c++2b\n+// c++23\n #define __cpp_lib_byteswap 202110L\n #define __cpp_lib_constexpr_typeinfo 202106L\n #define __cpp_lib_is_scoped_enum 202011L\n+#define __cpp_lib_reference_from_temporary 202202L\n \n #if _GLIBCXX_HOSTED\n #define __cpp_lib_adaptor_iterator_pair_constructor 202106L\n@@ -335,7 +336,7 @@\n #define __cpp_lib_to_underlying 202102L\n #define __cpp_lib_unreachable 202202L\n #endif\n-#endif // C++2b\n+#endif // C++23\n #endif // C++20\n #endif // C++17\n #endif // C++14"}, {"sha": "2f62e54d46d4d9f237c2cf30e3a1a5c20790dbb6", "filename": "libstdc++-v3/testsuite/20_util/reference_from_temporary/value.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fvalue.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -0,0 +1,110 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <type_traits>\n+#include <testsuite_tr1.h>\n+\n+#ifndef __cpp_lib_reference_from_temporary\n+# error \"Feature test macro for reference_from_temporary is missing in <version>\"\n+#elif __cpp_lib_reference_from_temporary < 202202L\n+# error \"Feature test macro for reference_from_temporary has wrong value in <version>\"\n+#endif\n+\n+void test01()\n+{\n+  using std::reference_constructs_from_temporary;\n+  using std::reference_converts_from_temporary;\n+  using namespace __gnu_test;\n+\n+  struct A { A(); };\n+\n+  struct B {\n+    operator int();\n+    explicit operator int&&();\n+  };\n+\n+  struct C {\n+    operator int();\n+    explicit operator int&();\n+  };\n+\n+  static_assert(test_property<reference_constructs_from_temporary, int, int>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, void>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, const volatile void>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, void, void>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, int>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, int&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, int&&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, long>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, long&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, long&&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, int>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, int&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, int&&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, long>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, long&>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, long&&>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, int>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, int&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, int&&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, long>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, long&>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, long&&>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const A&, A>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const A&, A&&>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, A&&, A>(true), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&, int[]>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, int[]>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, int[]>(false), \"\");\n+\n+  static_assert(test_property<reference_converts_from_temporary, int, int>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, void>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, const volatile void>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, void, void>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, int>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, int&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, int&&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, long>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, long&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, long&&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, int>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, int&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, int&&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, long>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, long&>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, long&&>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, int>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, int&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, int&&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, long>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, long&>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, long&&>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const A&, A>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const A&, A&&>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, A&&, A>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&, int[]>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, int[]>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, int[]>(false), \"\");\n+\n+  static_assert(test_property<reference_constructs_from_temporary, int&&, B>(false), \"\");\n+  static_assert(test_property<reference_constructs_from_temporary, const int&, C>(false), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, int&&, B>(true), \"\");\n+  static_assert(test_property<reference_converts_from_temporary, const int&, C>(true), \"\");\n+}"}, {"sha": "657707542995838d4b8127c2d42c60db97f99d4f", "filename": "libstdc++-v3/testsuite/20_util/reference_from_temporary/value2.cc", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fvalue2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fvalue2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fvalue2.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -0,0 +1,28 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <type_traits>\n+#include <string>\n+\n+void test01()\n+{\n+  static_assert(std::reference_converts_from_temporary_v<const std::string&, const char*>);\n+  static_assert(std::reference_constructs_from_temporary_v<const std::string&, const char*>);\n+}"}, {"sha": "f56e7c0dabc90c0dd764bc363d270a18c322df82", "filename": "libstdc++-v3/testsuite/20_util/reference_from_temporary/version.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fversion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fversion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Freference_from_temporary%2Fversion.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright (C) 2022 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do compile { target c++23 } }\n+\n+#include <version>\n+\n+#ifndef __cpp_lib_reference_from_temporary\n+# error \"Feature test macro for reference_from_temporary is missing in <version>\"\n+#elif __cpp_lib_reference_from_temporary < 202202L\n+# error \"Feature test macro for reference_from_temporary has wrong value in <version>\"\n+#endif"}, {"sha": "2b03ad7067dd0c9e6eaaa31939583022e9095c54", "filename": "libstdc++-v3/testsuite/20_util/variable_templates_for_traits.cc", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariable_templates_for_traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a15d3beace26d68561cb3481b70b0bbcb122ca5/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariable_templates_for_traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariable_templates_for_traits.cc?ref=9a15d3beace26d68561cb3481b70b0bbcb122ca5", "patch": "@@ -346,3 +346,17 @@ static_assert(disjunction_v<false_type, false_type,\n               true_type>, \"\");\n static_assert(!disjunction_v<false_type, false_type,\n               false_type>, \"\");\n+#if __cpp_lib_reference_from_temporary >= 202202L\n+static_assert(std::reference_converts_from_temporary_v<int&&, int>\n+\t      && std::reference_converts_from_temporary_v<const int&, int>\n+\t      && !std::reference_converts_from_temporary_v<int&&, int&&>\n+\t      && !std::reference_converts_from_temporary_v<const int&, int&&>\n+\t      && std::reference_converts_from_temporary_v<int&&, long&&>\n+\t      && std::reference_converts_from_temporary_v<int&&, long>, \"\");\n+static_assert(std::reference_constructs_from_temporary_v<int&&, int>\n+\t      && std::reference_constructs_from_temporary_v<const int&, int>\n+\t      && !std::reference_constructs_from_temporary_v<int&&, int&&>\n+\t      && !std::reference_constructs_from_temporary_v<const int&, int&&>\n+\t      && std::reference_constructs_from_temporary_v<int&&, long&&>\n+\t      && std::reference_constructs_from_temporary_v<int&&, long>, \"\");\n+#endif"}]}