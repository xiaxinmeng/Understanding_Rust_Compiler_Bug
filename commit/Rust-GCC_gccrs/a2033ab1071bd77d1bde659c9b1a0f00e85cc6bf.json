{"sha": "a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIwMzNhYjEwNzFiZDc3ZDFiZGU2NTljOWIxYTBmMDBlODVjYzZiZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-26T21:58:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-26T21:58:38Z"}, "message": "Allow partial specialization of variable templates.\n\n\t* cp-tree.h (TINFO_USED_TEMPLATE_ID): New.\n\t* decl.c (duplicate_decls): Copy it.\n\t* error.c (dump_decl) [TEMPLATE_ID_EXPR]: Handle variables.\n\t* parser.c (cp_parser_decltype_expr): Do call finish_id_expression\n\ton template-ids.\n\t* pt.c (register_specialization): Remember variable template insts.\n\t(instantiate_template_1): Find the matching partial specialization.\n\t(check_explicit_specialization): Allow variable partial specialization.\n\t(process_partial_specialization): Likewise.\n\t(push_template_decl_real): Likewise.\n\t(more_specialized_partial_spec): Rename from more_specialized_class.\n\t(most_specialized_partial_spec): Rename from most_specialized_class.\n\t(get_partial_spec_bindings): Rename from get_class_bindings.\n\nFrom-SVN: r218104", "tree": {"sha": "5545278ced316fbb528d4e891ecfe7d300975c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5545278ced316fbb528d4e891ecfe7d300975c53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d896cc4d45203f639fe95c7c3af14ad3f2d26673", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d896cc4d45203f639fe95c7c3af14ad3f2d26673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d896cc4d45203f639fe95c7c3af14ad3f2d26673"}], "stats": {"total": 290, "additions": 214, "deletions": 76}, "files": [{"sha": "9c6427963e77c9db850ee41c4e8fa32504d4ab00", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -1,3 +1,20 @@\n+2014-11-26  Jason Merrill  <jason@redhat.com>\n+\n+\tAllow partial specialization of variable templates.\n+\t* cp-tree.h (TINFO_USED_TEMPLATE_ID): New.\n+\t* decl.c (duplicate_decls): Copy it.\n+\t* error.c (dump_decl) [TEMPLATE_ID_EXPR]: Handle variables.\n+\t* parser.c (cp_parser_decltype_expr): Do call finish_id_expression\n+\ton template-ids.\n+\t* pt.c (register_specialization): Remember variable template insts.\n+\t(instantiate_template_1): Find the matching partial specialization.\n+\t(check_explicit_specialization): Allow variable partial specialization.\n+\t(process_partial_specialization): Likewise.\n+\t(push_template_decl_real): Likewise.\n+\t(more_specialized_partial_spec): Rename from more_specialized_class.\n+\t(most_specialized_partial_spec): Rename from most_specialized_class.\n+\t(get_partial_spec_bindings): Rename from get_class_bindings.\n+\n 2014-11-26  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/63757"}, {"sha": "edd1d5d8443188f7874ca1e088998f3cb2e29e41", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -99,6 +99,7 @@ c-common.h, not after.\n       QUALIFIED_NAME_IS_TEMPLATE (in SCOPE_REF)\n       DECLTYPE_FOR_INIT_CAPTURE (in DECLTYPE_TYPE)\n       CONSTRUCTOR_NO_IMPLICIT_ZERO (in CONSTRUCTOR)\n+      TINFO_USED_TEMPLATE_ID (in TEMPLATE_INFO)\n    2: IDENTIFIER_OPNAME_P (in IDENTIFIER_NODE)\n       ICS_THIS_FLAG (in _CONV)\n       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (in VAR_DECL)\n@@ -801,6 +802,12 @@ typedef struct qualified_typedef_usage_s qualified_typedef_usage_t;\n #define FNDECL_HAS_ACCESS_ERRORS(NODE) \\\n   (TINFO_HAS_ACCESS_ERRORS (DECL_TEMPLATE_INFO (NODE)))\n \n+/* Non-zero if this variable template specialization was specified using a\n+   template-id, so it's a partial or full specialization and not a definition\n+   of the member template of a particular class specialization.  */\n+#define TINFO_USED_TEMPLATE_ID(NODE) \\\n+  (TREE_LANG_FLAG_1 (TEMPLATE_INFO_CHECK (NODE)))\n+\n struct GTY(()) tree_template_info {\n   struct tree_common common;\n   vec<qualified_typedef_usage_t, va_gc> *typedefs_needing_access_checking;"}, {"sha": "455097e1182bb1a70a8fad41298eda97477f6c7d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -2137,7 +2137,14 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \t  DECL_LANG_SPECIFIC (newdecl)->u.min.u2 =\n \t    DECL_LANG_SPECIFIC (olddecl)->u.min.u2;\n \t  if (DECL_TEMPLATE_INFO (newdecl))\n-\t    new_template_info = DECL_TEMPLATE_INFO (newdecl);\n+\t    {\n+\t      new_template_info = DECL_TEMPLATE_INFO (newdecl);\n+\t      if (DECL_TEMPLATE_INSTANTIATION (olddecl)\n+\t\t  && DECL_TEMPLATE_SPECIALIZATION (newdecl))\n+\t\t/* Remember the presence of explicit specialization args.  */\n+\t\tTINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))\n+\t\t  = TINFO_USED_TEMPLATE_ID (new_template_info);\n+\t    }\n \t  DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);\n \t}\n       /* Only functions have these fields.  */"}, {"sha": "5dcc149e1854b6133c5a417000744afdf8b19d79", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -1212,7 +1212,9 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n \ttree args = TREE_OPERAND (t, 1);\n \n \tif (is_overloaded_fn (name))\n-\t  name = DECL_NAME (get_first_fn (name));\n+\t  name = get_first_fn (name);\n+\tif (DECL_P (name))\n+\t  name = DECL_NAME (name);\n \tdump_decl (pp, name, flags);\n \tpp_cxx_begin_template_argument_list (pp);\n \tif (args == error_mark_node)"}, {"sha": "d1cd63f1ca62e53809129d7933cde3ce1f452dca", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -12175,7 +12175,6 @@ cp_parser_decltype_expr (cp_parser *parser,\n \n       if (expr\n           && expr != error_mark_node\n-          && TREE_CODE (expr) != TEMPLATE_ID_EXPR\n           && TREE_CODE (expr) != TYPE_DECL\n \t  && (TREE_CODE (expr) != BIT_NOT_EXPR\n \t      || !TYPE_P (TREE_OPERAND (expr, 0)))"}, {"sha": "8e71fcb7cfca8a38ee96125d2c172286a4a872c1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 142, "deletions": 69, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -129,7 +129,7 @@ static int unify (tree, tree, tree, tree, int, bool);\n static void add_pending_template (tree);\n static tree reopen_tinst_level (struct tinst_level *);\n static tree tsubst_initializer_list (tree, tree);\n-static tree get_class_bindings (tree, tree, tree, tree);\n+static tree get_partial_spec_bindings (tree, tree, tree, tree);\n static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t,\n \t\t\t\t   bool, bool);\n static tree coerce_innermost_template_parms (tree, tree, tree, tsubst_flags_t,\n@@ -173,7 +173,7 @@ static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n static void regenerate_decl_from_template (tree, tree);\n-static tree most_specialized_class (tree, tsubst_flags_t);\n+static tree most_specialized_partial_spec (tree, tsubst_flags_t);\n static tree tsubst_aggr_type (tree, tree, tsubst_flags_t, tree, int);\n static tree tsubst_arg_types (tree, tree, tree, tsubst_flags_t, tree);\n static tree tsubst_function_type (tree, tree, tsubst_flags_t, tree);\n@@ -1485,12 +1485,17 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n       gcc_assert (tmpl && args && spec);\n       *entry = elt;\n       *slot = entry;\n-      if (TREE_CODE (spec) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (spec)\n-\t  && PRIMARY_TEMPLATE_P (tmpl)\n-\t  && DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (tmpl)) == NULL_TREE)\n-\t/* TMPL is a forward declaration of a template function; keep a list\n+      if ((TREE_CODE (spec) == FUNCTION_DECL && DECL_NAMESPACE_SCOPE_P (spec)\n+\t   && PRIMARY_TEMPLATE_P (tmpl)\n+\t   && DECL_SAVED_TREE (DECL_TEMPLATE_RESULT (tmpl)) == NULL_TREE)\n+\t  || variable_template_p (tmpl))\n+\t/* If TMPL is a forward declaration of a template function, keep a list\n \t   of all specializations in case we need to reassign them to a friend\n-\t   template later in tsubst_friend_function.  */\n+\t   template later in tsubst_friend_function.\n+\n+\t   Also keep a list of all variable template instantiations so that\n+\t   process_partial_specialization can check whether a later partial\n+\t   specialization would have used it.  */\n \tDECL_TEMPLATE_INSTANTIATIONS (tmpl)\n \t  = tree_cons (args, spec, DECL_TEMPLATE_INSTANTIATIONS (tmpl));\n     }\n@@ -2471,13 +2476,24 @@ check_explicit_specialization (tree declarator,\n \t  /* This case handles bogus declarations like template <>\n \t     template <class T> void f<int>(); */\n \n-\t  if (uses_template_parms (declarator))\n+\t  if (!uses_template_parms (declarator))\n+\t    error (\"template-id %qD in declaration of primary template\",\n+\t\t   declarator);\n+\t  else if (variable_template_p (TREE_OPERAND (declarator, 0)))\n+\t    {\n+\t      /* Partial specialization of variable template.  */\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t      specialization = 1;\n+\t      goto ok;\n+\t    }\n+\t  else if (cxx_dialect < cxx14)\n \t    error (\"non-type partial specialization %qD \"\n \t\t   \"is not allowed\", declarator);\n \t  else\n-\t    error (\"template-id %qD in declaration of primary template\",\n-\t\t   declarator);\n+\t    error (\"non-class, non-variable partial specialization %qD \"\n+\t\t   \"is not allowed\", declarator);\n \t  return decl;\n+\tok:;\n \t}\n \n       if (ctype && CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n@@ -2516,9 +2532,10 @@ check_explicit_specialization (tree declarator,\n     {\n       tree tmpl = NULL_TREE;\n       tree targs = NULL_TREE;\n+      bool was_template_id = (TREE_CODE (declarator) == TEMPLATE_ID_EXPR);\n \n       /* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */\n-      if (TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n+      if (!was_template_id)\n \t{\n \t  tree fns;\n \n@@ -2585,7 +2602,7 @@ check_explicit_specialization (tree declarator,\n       else if (ctype != NULL_TREE\n \t       && (identifier_p (TREE_OPERAND (declarator, 0))))\n \t{\n-\t  // Ignore variable templates.\n+\t  // We'll match variable templates in start_decl.\n \t  if (VAR_P (decl))\n \t    return decl;\n \n@@ -2722,7 +2739,7 @@ check_explicit_specialization (tree declarator,\n \t  /* If this is a specialization of a member template of a\n \t     template class, we want to return the TEMPLATE_DECL, not\n \t     the specialization of it.  */\n-\t  if (tsk == tsk_template)\n+\t  if (tsk == tsk_template && !was_template_id)\n \t    {\n \t      tree result = DECL_TEMPLATE_RESULT (tmpl);\n \t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n@@ -2747,6 +2764,9 @@ check_explicit_specialization (tree declarator,\n \t  /* Set up the DECL_TEMPLATE_INFO for DECL.  */\n \t  DECL_TEMPLATE_INFO (decl) = build_template_info (tmpl, targs);\n \n+\t  if (was_template_id)\n+\t    TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (decl)) = true;\n+\n \t  /* Inherit default function arguments from the template\n \t     DECL is specializing.  */\n \t  if (DECL_FUNCTION_TEMPLATE_P (tmpl))\n@@ -4087,8 +4107,9 @@ static tree\n process_partial_specialization (tree decl)\n {\n   tree type = TREE_TYPE (decl);\n-  tree maintmpl = CLASSTYPE_TI_TEMPLATE (type);\n-  tree specargs = CLASSTYPE_TI_ARGS (type);\n+  tree tinfo = get_template_info (decl);\n+  tree maintmpl = TI_TEMPLATE (tinfo);\n+  tree specargs = TI_ARGS (tinfo);\n   tree inner_args = INNERMOST_TEMPLATE_ARGS (specargs);\n   tree main_inner_parms = DECL_INNERMOST_TEMPLATE_PARMS (maintmpl);\n   tree inner_parms;\n@@ -4173,11 +4194,11 @@ process_partial_specialization (tree decl)\n \n      The argument list of the specialization shall not be identical to\n      the implicit argument list of the primary template.  */\n-  if (comp_template_args\n-      (inner_args,\n-       INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE\n-\t\t\t\t\t\t   (maintmpl)))))\n-    error (\"partial specialization %qT does not specialize any template arguments\", type);\n+  tree main_args\n+    = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (maintmpl)));\n+  if (comp_template_args (inner_args, INNERMOST_TEMPLATE_ARGS (main_args)))\n+    error (\"partial specialization %qD does not specialize \"\n+\t   \"any template arguments\", decl);\n \n   /* A partial specialization that replaces multiple parameters of the\n      primary template with a pack expansion is less specialized for those\n@@ -4317,7 +4338,8 @@ process_partial_specialization (tree decl)\n     }\n \n   /* We should only get here once.  */\n-  gcc_assert (!COMPLETE_TYPE_P (type));\n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    gcc_assert (!COMPLETE_TYPE_P (type));\n \n   tree tmpl = build_template_decl (decl, current_template_parms,\n \t\t\t\t   DECL_MEMBER_TEMPLATE_P (maintmpl));\n@@ -4335,15 +4357,21 @@ process_partial_specialization (tree decl)\n   for (inst = DECL_TEMPLATE_INSTANTIATIONS (maintmpl); inst;\n        inst = TREE_CHAIN (inst))\n     {\n-      tree inst_type = TREE_VALUE (inst);\n-      if (COMPLETE_TYPE_P (inst_type)\n-\t  && CLASSTYPE_IMPLICIT_INSTANTIATION (inst_type))\n+      tree instance = TREE_VALUE (inst);\n+      if (TYPE_P (instance)\n+\t  ? (COMPLETE_TYPE_P (instance)\n+\t     && CLASSTYPE_IMPLICIT_INSTANTIATION (instance))\n+\t  : DECL_TEMPLATE_INSTANTIATION (instance))\n \t{\n-\t  tree spec = most_specialized_class (inst_type, tf_none);\n-\t  if (spec && TREE_TYPE (spec) == type)\n-\t    permerror (input_location,\n-\t\t       \"partial specialization of %qT after instantiation \"\n-\t\t       \"of %qT\", type, inst_type);\n+\t  tree spec = most_specialized_partial_spec (instance, tf_none);\n+\t  if (spec && TREE_VALUE (spec) == tmpl)\n+\t    {\n+\t      tree inst_decl = (DECL_P (instance)\n+\t\t\t\t? instance : TYPE_NAME (instance));\n+\t      permerror (input_location,\n+\t\t\t \"partial specialization of %qD after instantiation \"\n+\t\t\t \"of %qD\", decl, inst_decl);\n+\t    }\n \t}\n     }\n \n@@ -4692,9 +4720,13 @@ push_template_decl_real (tree decl, bool is_friend)\n     return error_mark_node;\n \n   /* See if this is a partial specialization.  */\n-  is_partial = (DECL_IMPLICIT_TYPEDEF_P (decl)\n-\t\t&& TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n-\t\t&& CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)));\n+  is_partial = ((DECL_IMPLICIT_TYPEDEF_P (decl)\n+\t\t && TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n+\t\t && CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)))\n+\t\t|| (TREE_CODE (decl) == VAR_DECL\n+\t\t    && DECL_LANG_SPECIFIC (decl)\n+\t\t    && DECL_TEMPLATE_SPECIALIZATION (decl)\n+\t\t    && TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (decl))));\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl))\n     is_friend = true;\n@@ -9057,7 +9089,7 @@ instantiate_class_template_1 (tree type)\n \n   /* Determine what specialization of the original template to\n      instantiate.  */\n-  t = most_specialized_class (type, tf_warning_or_error);\n+  t = most_specialized_partial_spec (type, tf_warning_or_error);\n   if (t == error_mark_node)\n     {\n       TYPE_BEING_DEFINED (type) = 1;\n@@ -10519,7 +10551,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    if (new_type == error_mark_node)\n \t      RETURN (error_mark_node);\n \t    /* If we get a real template back, return it.  This can happen in\n-\t       the context of most_specialized_class.  */\n+\t       the context of most_specialized_partial_spec.  */\n \t    if (TREE_CODE (new_type) == TEMPLATE_DECL)\n \t      return new_type;\n \n@@ -15878,9 +15910,28 @@ instantiate_template_1 (tree tmpl, tree orig_args, tsubst_flags_t complain)\n \t\t\t\t   complain, gen_tmpl, true);\n       push_nested_class (ctx);\n     }\n+\n+  tree pattern = DECL_TEMPLATE_RESULT (gen_tmpl);\n+\n+  if (VAR_P (pattern))\n+    {\n+      /* We need to determine if we're using a partial or explicit\n+\t specialization now, because the type of the variable could be\n+\t different.  */\n+      tree tid = lookup_template_variable (gen_tmpl, targ_ptr);\n+      tree elt = most_specialized_partial_spec (tid, complain);\n+      if (elt == error_mark_node)\n+\tpattern = error_mark_node;\n+      else if (elt)\n+\t{\n+\t  tmpl = TREE_VALUE (elt);\n+\t  pattern = DECL_TEMPLATE_RESULT (tmpl);\n+\t  targ_ptr = TREE_PURPOSE (elt);\n+\t}\n+    }\n+\n   /* Substitute template parameters to obtain the specialization.  */\n-  fndecl = tsubst (DECL_TEMPLATE_RESULT (gen_tmpl),\n-\t\t   targ_ptr, complain, gen_tmpl);\n+  fndecl = tsubst (pattern, targ_ptr, complain, gen_tmpl);\n   if (DECL_CLASS_SCOPE_P (gen_tmpl))\n     pop_nested_class ();\n   pop_from_top_level ();\n@@ -18881,8 +18932,8 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n /* Determine which of two partial specializations of TMPL is more\n    specialized.\n \n-   PAT1 is a TREE_LIST whose TREE_TYPE is the _TYPE node corresponding\n-   to the first partial specialization.  The TREE_VALUE is the\n+   PAT1 is a TREE_LIST whose TREE_VALUE is the TEMPLATE_DECL corresponding\n+   to the first partial specialization.  The TREE_PURPOSE is the\n    innermost set of template parameters for the partial\n    specialization.  PAT2 is similar, but for the second template.\n \n@@ -18894,41 +18945,40 @@ more_specialized_fn (tree pat1, tree pat2, int len)\n    two templates is more specialized.  */\n \n static int\n-more_specialized_class (tree tmpl, tree pat1, tree pat2)\n+more_specialized_partial_spec (tree tmpl, tree pat1, tree pat2)\n {\n   tree targs;\n-  tree tmpl1, tmpl2;\n   int winner = 0;\n   bool any_deductions = false;\n \n-  tmpl1 = TREE_TYPE (pat1);\n-  tmpl2 = TREE_TYPE (pat2);\n+  tree tmpl1 = TREE_VALUE (pat1);\n+  tree tmpl2 = TREE_VALUE (pat2);\n+  tree parms1 = DECL_INNERMOST_TEMPLATE_PARMS (tmpl1);\n+  tree parms2 = DECL_INNERMOST_TEMPLATE_PARMS (tmpl2);\n+  tree specargs1 = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (tmpl1)));\n+  tree specargs2 = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (tmpl2)));\n \n   /* Just like what happens for functions, if we are ordering between\n-     different class template specializations, we may encounter dependent\n+     different template specializations, we may encounter dependent\n      types in the arguments, and we need our dependency check functions\n      to behave correctly.  */\n   ++processing_template_decl;\n-  targs = get_class_bindings (tmpl, TREE_VALUE (pat1),\n-\t\t\t      CLASSTYPE_TI_ARGS (tmpl1),\n-\t\t\t      CLASSTYPE_TI_ARGS (tmpl2));\n+  targs = get_partial_spec_bindings (tmpl, parms1, specargs1, specargs2);\n   if (targs)\n     {\n       --winner;\n       any_deductions = true;\n     }\n \n-  targs = get_class_bindings (tmpl, TREE_VALUE (pat2),\n-\t\t\t      CLASSTYPE_TI_ARGS (tmpl2),\n-\t\t\t      CLASSTYPE_TI_ARGS (tmpl1));\n+  targs = get_partial_spec_bindings (tmpl, parms2, specargs2, specargs1);\n   if (targs)\n     {\n       ++winner;\n       any_deductions = true;\n     }\n   --processing_template_decl;\n \n-  /* In the case of a tie where at least one of the class templates\n+  /* In the case of a tie where at least one of the templates\n      has a parameter pack at the end, the template with the most\n      non-packed parameters wins.  */\n   if (winner == 0\n@@ -19014,7 +19064,7 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n    is bound to `double'.  */\n \n static tree\n-get_class_bindings (tree tmpl, tree tparms, tree spec_args, tree args)\n+get_partial_spec_bindings (tree tmpl, tree tparms, tree spec_args, tree args)\n {\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n   tree deduced_args;\n@@ -19197,31 +19247,50 @@ most_general_template (tree decl)\n   return decl;\n }\n \n-/* Return the most specialized of the class template partial\n-   specializations which can produce TYPE, a specialization of some class\n-   template.  The value returned is actually a TREE_LIST; the TREE_TYPE is\n-   a _TYPE node corresponding to the partial specialization, while the\n-   TREE_PURPOSE is the set of template arguments that must be\n-   substituted into the TREE_TYPE in order to generate TYPE.\n+/* Return the most specialized of the template partial specializations\n+   which can produce TARGET, a specialization of some class or variable\n+   template.  The value returned is actually a TREE_LIST; the TREE_VALUE is\n+   a TEMPLATE_DECL node corresponding to the partial specialization, while\n+   the TREE_PURPOSE is the set of template arguments that must be\n+   substituted into the template pattern in order to generate TARGET.\n \n    If the choice of partial specialization is ambiguous, a diagnostic\n    is issued, and the error_mark_node is returned.  If there are no\n-   partial specializations matching TYPE, then NULL_TREE is\n+   partial specializations matching TARGET, then NULL_TREE is\n    returned, indicating that the primary template should be used.  */\n \n static tree\n-most_specialized_class (tree type, tsubst_flags_t complain)\n+most_specialized_partial_spec (tree target, tsubst_flags_t complain)\n {\n   tree list = NULL_TREE;\n   tree t;\n   tree champ;\n   int fate;\n   bool ambiguous_p;\n   tree outer_args = NULL_TREE;\n+  tree tmpl, args;\n+\n+  if (TYPE_P (target))\n+    {\n+      tree tinfo = CLASSTYPE_TEMPLATE_INFO (target);\n+      tmpl = TI_TEMPLATE (tinfo);\n+      args = TI_ARGS (tinfo);\n+    }\n+  else if (TREE_CODE (target) == TEMPLATE_ID_EXPR)\n+    {\n+      tmpl = TREE_OPERAND (target, 0);\n+      args = TREE_OPERAND (target, 1);\n+    }\n+  else if (VAR_P (target))\n+    {\n+      tree tinfo = DECL_TEMPLATE_INFO (target);\n+      tmpl = TI_TEMPLATE (tinfo);\n+      args = TI_ARGS (tinfo);\n+    }\n+  else\n+    gcc_unreachable ();\n \n-  tree tmpl = CLASSTYPE_TI_TEMPLATE (type);\n   tree main_tmpl = most_general_template (tmpl);\n-  tree args = CLASSTYPE_TI_ARGS (type);\n \n   /* For determining which partial specialization to use, only the\n      innermost args are interesting.  */\n@@ -19236,9 +19305,8 @@ most_specialized_class (tree type, tsubst_flags_t complain)\n       tree partial_spec_args;\n       tree spec_args;\n       tree spec_tmpl = TREE_VALUE (t);\n-      tree orig_parms = DECL_INNERMOST_TEMPLATE_PARMS (spec_tmpl);\n \n-      partial_spec_args = CLASSTYPE_TI_ARGS (TREE_TYPE (t));\n+      partial_spec_args = TREE_PURPOSE (t);\n \n       ++processing_template_decl;\n \n@@ -19269,14 +19337,14 @@ most_specialized_class (tree type, tsubst_flags_t complain)\n \treturn error_mark_node;\n \n       tree parms = DECL_INNERMOST_TEMPLATE_PARMS (spec_tmpl);\n-      spec_args = get_class_bindings (tmpl, parms,\n+      spec_args = get_partial_spec_bindings (tmpl, parms,\n \t\t\t\t      partial_spec_args,\n \t\t\t\t      args);\n       if (spec_args)\n \t{\n \t  if (outer_args)\n \t    spec_args = add_to_template_args (outer_args, spec_args);\n-\t  list = tree_cons (spec_args, orig_parms, list);\n+\t  list = tree_cons (spec_args, TREE_VALUE (t), list);\n \t  TREE_TYPE (list) = TREE_TYPE (t);\n \t}\n     }\n@@ -19290,7 +19358,7 @@ most_specialized_class (tree type, tsubst_flags_t complain)\n   t = TREE_CHAIN (t);\n   for (; t; t = TREE_CHAIN (t))\n     {\n-      fate = more_specialized_class (tmpl, champ, t);\n+      fate = more_specialized_partial_spec (tmpl, champ, t);\n       if (fate == 1)\n \t;\n       else\n@@ -19311,7 +19379,7 @@ most_specialized_class (tree type, tsubst_flags_t complain)\n   if (!ambiguous_p)\n     for (t = list; t && t != champ; t = TREE_CHAIN (t))\n       {\n-\tfate = more_specialized_class (tmpl, champ, t);\n+\tfate = more_specialized_partial_spec (tmpl, champ, t);\n \tif (fate != 1)\n \t  {\n \t    ambiguous_p = true;\n@@ -19325,11 +19393,16 @@ most_specialized_class (tree type, tsubst_flags_t complain)\n       char *spaces = NULL;\n       if (!(complain & tf_error))\n \treturn error_mark_node;\n-      error (\"ambiguous class template instantiation for %q#T\", type);\n+      if (TYPE_P (target))\n+\terror (\"ambiguous template instantiation for %q#T\", target);\n+      else\n+\terror (\"ambiguous template instantiation for %q#D\", target);\n       str = ngettext (\"candidate is:\", \"candidates are:\", list_length (list));\n       for (t = list; t; t = TREE_CHAIN (t))\n         {\n-          error (\"%s %+#T\", spaces ? spaces : str, TREE_TYPE (t));\n+\t  tree subst = build_tree_list (TREE_VALUE (t), TREE_PURPOSE (t));\n+          inform (DECL_SOURCE_LOCATION (TREE_VALUE (t)),\n+\t\t  \"%s %#S\", spaces ? spaces : str, subst);\n           spaces = spaces ? spaces : get_spaces (str);\n         }\n       free (spaces);"}, {"sha": "4932e66be1eacf5ff1ed087dfa2ea907dd853336", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic20.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic20.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic20.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic20.C?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -13,25 +13,25 @@ struct metatuple<add_pointer> {\n };\n \n template<template<class T> class Meta>\n-struct metatuple<Meta, Meta> { // { dg-error \"candidates\" }\n+struct metatuple<Meta, Meta> { // { dg-message \"candidates\" }\n   static const int value = 2;\n };\n \n template<template<class T> class... Metafunctions>\n-struct metatuple<add_pointer, Metafunctions...> { // { dg-error \"\" }\n+struct metatuple<add_pointer, Metafunctions...> { // { dg-message \"\" }\n   static const int value = 3;\n };\n \n template<template<class T> class First,\n          template<class T> class... Metafunctions>\n-struct metatuple<First, Metafunctions...> { // { dg-error \"struct\" }\n+struct metatuple<First, Metafunctions...> { // { dg-message \"struct\" }\n   static const int value = 4;\n };\n \n template<template<class T> class First,\n          template<class T> class Second,\n          template<class T> class... Metafunctions>\n-struct metatuple<First, Second, Metafunctions...> { // { dg-error \"struct\" }\n+struct metatuple<First, Second, Metafunctions...> { // { dg-message \"struct\" }\n   static const int value = 5;\n };\n "}, {"sha": "9fd560891b49c766e19fe796a5a85066505f75d0", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ16.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ16.C?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -0,0 +1,6 @@\n+// { dg-do compile { target c++14 } }\n+\n+template <class T> T t = 42;\n+template <class T> T* t<T*> = nullptr;\n+\n+void *p = t<void*>;"}, {"sha": "415a7d5e84073728a1d90ad347882ad15e7f7aff", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ18.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ18.C?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -0,0 +1,9 @@\n+// DR 1727: a specialization doesn't need to have the same type\n+// { dg-do compile { target c++14 } }\n+\n+template <class T> T t = 42;\n+template <class T> int t<T*> = 0;\n+\n+template<class T, class U> struct same;\n+template<class T> struct same<T,T> {};\n+same<int,decltype(t<void*>)> s;"}, {"sha": "862752ad3382043ab4b2190d8cac261209486b24", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ19.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ19.C?ref=a2033ab1071bd77d1bde659c9b1a0f00e85cc6bf", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++14 } }\n+\n+template <class T> T t1 = 42;\n+template <class T> T* t1<T> = nullptr; // { dg-error \"partial\" }\n+\n+template <class T> T t2 = 42;\n+template <class T> T* t2<T*> = nullptr;\n+template <class T> T* t2<T*> = nullptr; // { dg-error \"redefinition\" }\n+\n+template <class T, class U> T t3 = U();\n+template <class T> T t3<T,int> = 42;\n+template <class U> int t3<int,U> = U();\n+\n+int i = t3<int,int>;\t\t// { dg-error \"ambiguous\" }\n+\n+template <class T> T t4 = T();\n+void *p = t4<void*>;\n+template <class T> T* t4<T*> = nullptr; // { dg-error \"after instantiation\" }"}]}