{"sha": "e7b655e8fdf3c32e01a97588445211254c52b6c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdiNjU1ZThmZGYzYzMyZTAxYTk3NTg4NDQ1MjExMjU0YzUyYjZjMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-16T10:33:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-16T10:33:48Z"}, "message": "cfgloopmanip.c (duplicate_loop_to_header_edge): Cleanup profile manipulation.\n\n\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Cleanup profile\n\tmanipulation.\n\nFrom-SVN: r254806", "tree": {"sha": "2f883a49c8a63c2eaef2b60e0baf2920fdc05730", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f883a49c8a63c2eaef2b60e0baf2920fdc05730"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7b655e8fdf3c32e01a97588445211254c52b6c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7b655e8fdf3c32e01a97588445211254c52b6c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7b655e8fdf3c32e01a97588445211254c52b6c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7b655e8fdf3c32e01a97588445211254c52b6c2/comments", "author": null, "committer": null, "parents": [{"sha": "1554ed7ea429be444e74d5306be6692f517acf02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1554ed7ea429be444e74d5306be6692f517acf02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1554ed7ea429be444e74d5306be6692f517acf02"}], "stats": {"total": 128, "additions": 60, "deletions": 68}, "files": [{"sha": "452a9a4c0bfd452c9c351d4024177c3c447f19c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7b655e8fdf3c32e01a97588445211254c52b6c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7b655e8fdf3c32e01a97588445211254c52b6c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7b655e8fdf3c32e01a97588445211254c52b6c2", "patch": "@@ -1,3 +1,8 @@\n+2017-11-14  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Cleanup profile\n+\tmanipulation.\n+\n 2017-11-16  Chung-Ju Wu  <jasonwucj@gmail.com>\n \t    Kito Cheng  <kito.cheng@gmail.com>\n "}, {"sha": "2ecd37cdff186ca883c94e253b2d785afdaae79d", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 55, "deletions": 68, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7b655e8fdf3c32e01a97588445211254c52b6c2/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7b655e8fdf3c32e01a97588445211254c52b6c2/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=e7b655e8fdf3c32e01a97588445211254c52b6c2", "patch": "@@ -1096,14 +1096,16 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n   basic_block new_bb, bb, first_active_latch = NULL;\n   edge ae, latch_edge;\n   edge spec_edges[2], new_spec_edges[2];\n-#define SE_LATCH 0\n-#define SE_ORIG 1\n+  const int SE_LATCH = 0;\n+  const int SE_ORIG = 1;\n   unsigned i, j, n;\n   int is_latch = (latch == e->src);\n-  int scale_act = 0, *scale_step = NULL, scale_main = 0;\n-  int scale_after_exit = 0;\n-  int p, freq_in, freq_le, freq_out_orig;\n-  int prob_pass_thru, prob_pass_wont_exit, prob_pass_main;\n+  profile_probability *scale_step = NULL;\n+  profile_probability scale_main = profile_probability::always ();\n+  profile_probability scale_act = profile_probability::always ();\n+  profile_count after_exit_num = profile_count::zero (),\n+\t        after_exit_den = profile_count::zero ();\n+  bool scale_after_exit = false;\n   int add_irreducible_flag;\n   basic_block place_after;\n   bitmap bbs_to_scale = NULL;\n@@ -1142,33 +1144,26 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \n   if (flags & DLTHE_FLAG_UPDATE_FREQ)\n     {\n-      /* Calculate coefficients by that we have to scale frequencies\n+      /* Calculate coefficients by that we have to scale counts\n \t of duplicated loop bodies.  */\n-      freq_in = header->count.to_frequency (cfun);\n-      freq_le = EDGE_FREQUENCY (latch_edge);\n-      if (freq_in == 0)\n-\tfreq_in = 1;\n-      if (freq_in < freq_le)\n-\tfreq_in = freq_le;\n-      freq_out_orig = orig ? EDGE_FREQUENCY (orig) : freq_in - freq_le;\n-      if (freq_out_orig > freq_in - freq_le)\n-\tfreq_out_orig = freq_in - freq_le;\n-      prob_pass_thru = RDIV (REG_BR_PROB_BASE * freq_le, freq_in);\n-      prob_pass_wont_exit =\n-\t      RDIV (REG_BR_PROB_BASE * (freq_le + freq_out_orig), freq_in);\n+      profile_count count_in = header->count;\n+      profile_count count_le = latch_edge->count ();\n+      profile_count count_out_orig = orig ? orig->count () : count_in - count_le;\n+      profile_probability prob_pass_thru = count_le.probability_in (count_in);\n+      profile_probability prob_pass_wont_exit =\n+\t      (count_le + count_out_orig).probability_in (count_in);\n \n       if (orig && orig->probability.initialized_p ()\n \t  && !(orig->probability == profile_probability::always ()))\n \t{\n \t  /* The blocks that are dominated by a removed exit edge ORIG have\n \t     frequencies scaled by this.  */\n-\t  if (orig->probability.initialized_p ())\n-\t    scale_after_exit\n-                = GCOV_COMPUTE_SCALE (REG_BR_PROB_BASE,\n-                                      REG_BR_PROB_BASE\n-\t\t\t\t      - orig->probability.to_reg_br_prob_base ());\n-\t  else\n-\t    scale_after_exit = REG_BR_PROB_BASE;\n+\t  if (orig->count ().initialized_p ())\n+\t    {\n+\t      after_exit_num = orig->src->count;\n+\t      after_exit_den = after_exit_num - orig->count ();\n+\t      scale_after_exit = true;\n+\t    }\n \t  bbs_to_scale = BITMAP_ALLOC (NULL);\n \t  for (i = 0; i < n; i++)\n \t    {\n@@ -1178,7 +1173,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t    }\n \t}\n \n-      scale_step = XNEWVEC (int, ndupl);\n+      scale_step = XNEWVEC (profile_probability, ndupl);\n \n       for (i = 1; i <= ndupl; i++)\n \tscale_step[i - 1] = bitmap_bit_p (wont_exit, i)\n@@ -1189,52 +1184,48 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t copy becomes 1.  */\n       if (flags & DLTHE_FLAG_COMPLETTE_PEEL)\n \t{\n-\t  int wanted_freq = EDGE_FREQUENCY (e);\n-\n-\t  if (wanted_freq > freq_in)\n-\t    wanted_freq = freq_in;\n+\t  profile_count wanted_count = e->count ();\n \n \t  gcc_assert (!is_latch);\n-\t  /* First copy has frequency of incoming edge.  Each subsequent\n-\t     frequency should be reduced by prob_pass_wont_exit.  Caller\n+\t  /* First copy has count of incoming edge.  Each subsequent\n+\t     count should be reduced by prob_pass_wont_exit.  Caller\n \t     should've managed the flags so all except for original loop\n \t     has won't exist set.  */\n-\t  scale_act = GCOV_COMPUTE_SCALE (wanted_freq, freq_in);\n+\t  scale_act = wanted_count.probability_in (count_in);\n \t  /* Now simulate the duplication adjustments and compute header\n \t     frequency of the last copy.  */\n \t  for (i = 0; i < ndupl; i++)\n-\t    wanted_freq = combine_probabilities (wanted_freq, scale_step[i]);\n-\t  scale_main = GCOV_COMPUTE_SCALE (wanted_freq, freq_in);\n+\t    wanted_count = wanted_count.apply_probability (scale_step [i]);\n+\t  scale_main = wanted_count.probability_in (count_in);\n \t}\n+      /* Here we insert loop bodies inside the loop itself (for loop unrolling).\n+\t First iteration will be original loop followed by duplicated bodies.\n+\t It is necessary to scale down the original so we get right overall\n+\t number of iterations.  */\n       else if (is_latch)\n \t{\n-\t  prob_pass_main = bitmap_bit_p (wont_exit, 0)\n-\t\t\t\t? prob_pass_wont_exit\n-\t\t\t\t: prob_pass_thru;\n-\t  p = prob_pass_main;\n-\t  scale_main = REG_BR_PROB_BASE;\n+\t  profile_probability prob_pass_main = bitmap_bit_p (wont_exit, 0)\n+\t\t\t\t\t\t\t? prob_pass_wont_exit\n+\t\t\t\t\t\t\t: prob_pass_thru;\n+\t  profile_probability p = prob_pass_main;\n+\t  profile_count scale_main_den = count_in;\n \t  for (i = 0; i < ndupl; i++)\n \t    {\n-\t      scale_main += p;\n-\t      p = combine_probabilities (p, scale_step[i]);\n+\t      scale_main_den += count_in.apply_probability (p);\n+\t      p = p * scale_step[i];\n \t    }\n-\t  scale_main = GCOV_COMPUTE_SCALE (REG_BR_PROB_BASE, scale_main);\n-\t  scale_act = combine_probabilities (scale_main, prob_pass_main);\n+\t  /* If original loop is executed COUNT_IN times, the unrolled\n+\t     loop will account SCALE_MAIN_DEN times.  */\n+\t  scale_main = count_in.probability_in (scale_main_den);\n+\t  scale_act = scale_main * prob_pass_main;\n \t}\n       else\n \t{\n-\t  int preheader_freq = EDGE_FREQUENCY (e);\n-\t  scale_main = REG_BR_PROB_BASE;\n+\t  profile_count preheader_count = e->count ();\n \t  for (i = 0; i < ndupl; i++)\n-\t    scale_main = combine_probabilities (scale_main, scale_step[i]);\n-\t  if (preheader_freq > freq_in)\n-\t    preheader_freq = freq_in;\n-\t  scale_act = GCOV_COMPUTE_SCALE (preheader_freq, freq_in);\n+\t    scale_main = scale_main * scale_step[i];\n+\t  scale_act = preheader_count.probability_in (count_in);\n \t}\n-      for (i = 0; i < ndupl; i++)\n-\tgcc_assert (scale_step[i] >= 0 && scale_step[i] <= REG_BR_PROB_BASE);\n-      gcc_assert (scale_main >= 0 && scale_main <= REG_BR_PROB_BASE\n-\t\t  && scale_act >= 0  && scale_act <= REG_BR_PROB_BASE);\n     }\n \n   /* Loop the new bbs will belong to.  */\n@@ -1327,13 +1318,11 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t  force_edge_cold (new_spec_edges[SE_ORIG], true);\n \n \t  /* Scale the frequencies of the blocks dominated by the exit.  */\n-\t  if (bbs_to_scale)\n+\t  if (bbs_to_scale && scale_after_exit)\n \t    {\n \t      EXECUTE_IF_SET_IN_BITMAP (bbs_to_scale, 0, i, bi)\n-\t\t{\n-\t\t  scale_bbs_frequencies_int (new_bbs + i, 1, scale_after_exit,\n-\t\t\t\t\t     REG_BR_PROB_BASE);\n-\t\t}\n+\t\tscale_bbs_frequencies_profile_count (new_bbs + i, 1, after_exit_num,\n+\t\t\t\t\t\t     after_exit_den);\n \t    }\n \t}\n \n@@ -1348,8 +1337,8 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       /* Set counts and frequencies.  */\n       if (flags & DLTHE_FLAG_UPDATE_FREQ)\n \t{\n-\t  scale_bbs_frequencies_int (new_bbs, n, scale_act, REG_BR_PROB_BASE);\n-\t  scale_act = combine_probabilities (scale_act, scale_step[j]);\n+\t  scale_bbs_frequencies (new_bbs, n, scale_act);\n+\t  scale_act = scale_act * scale_step[j];\n \t}\n     }\n   free (new_bbs);\n@@ -1363,13 +1352,11 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n       force_edge_cold (orig, true);\n \n       /* Scale the frequencies of the blocks dominated by the exit.  */\n-      if (bbs_to_scale)\n+      if (bbs_to_scale && scale_after_exit)\n \t{\n \t  EXECUTE_IF_SET_IN_BITMAP (bbs_to_scale, 0, i, bi)\n-\t    {\n-\t      scale_bbs_frequencies_int (bbs + i, 1, scale_after_exit,\n-\t\t\t\t\t REG_BR_PROB_BASE);\n-\t    }\n+\t    scale_bbs_frequencies_profile_count (bbs + i, 1, after_exit_num,\n+\t\t\t\t\t\t after_exit_den);\n \t}\n     }\n \n@@ -1378,7 +1365,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e,\n     set_immediate_dominator (CDI_DOMINATORS, e->dest, e->src);\n   if (flags & DLTHE_FLAG_UPDATE_FREQ)\n     {\n-      scale_bbs_frequencies_int (bbs, n, scale_main, REG_BR_PROB_BASE);\n+      scale_bbs_frequencies (bbs, n, scale_main);\n       free (scale_step);\n     }\n "}]}