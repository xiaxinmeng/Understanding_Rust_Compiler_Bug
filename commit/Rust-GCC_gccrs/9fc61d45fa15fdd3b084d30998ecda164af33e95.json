{"sha": "9fc61d45fa15fdd3b084d30998ecda164af33e95", "node_id": "C_kwDOANBUbNoAKDlmYzYxZDQ1ZmExNWZkZDNiMDg0ZDMwOTk4ZWNkYTE2NGFmMzNlOTU", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-22T00:37:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-22T23:34:20Z"}, "message": "libstdc++: Implement C++20 time zone support in <chrono>\n\nThis is the largest missing piece of C++20 support. Only the cxx11 ABI\nis supported, due to the use of std::string in the API for time zones.\nFor the old gcc4 ABI, utc_clock and leap seconds are supported, but only\nusing a hardcoded list of leap seconds, no up-to-date tzdb::leap_seconds\ninformation is available, and no time zones or zoned_time conversions.\n\nThe implementation currently depends on a tzdata.zi file being provided\nby the OS or the user. The expected location is /usr/share/zoneinfo but\nthat can be changed using --with-libstdcxx-zoneinfo-dir=PATH. On targets\nthat support it there is also a weak symbol that users can override in\ntheir own program (which also helps with testing):\n\nextern \"C++\" const char* __gnu_cxx::zoneinfo_dir_override();\n\nIf no file is found, a fallback tzdb object will be created which only\ncontains the \"Etc/UTC\" and \"Etc/GMT\" time zones.\n\nA leapseconds file is also expected in the same directory, but if that\nisn't present then a hardcoded list of leapseconds is used, which is\ncorrect at least as far as 2023-06-28 (and it currently looks like no\nleap second will be inserted for a few years).\n\nThe tzdata.zi and leapseconds files from https://www.iana.org/time-zones\nare in the public domain, so shipping copies of them with GCC would be\nan option. However, the tzdata.zi file will rapidly become outdated, so\nusers should really provide it themselves (or convince their OS vendor\nto do so). It would also be possible to implement an alternative parser\nfor the compiled tzdata files (one per time zone) under\n/usr/share/zoneinfo. Those files are present on more operating systems,\nbut do not contain all the information present in tzdata.zi.\nSpecifically, the \"links\" are not present, so that e.g. \"UTC\" and\n\"Universal\" are distinct time zones, rather than both being links to the\ncanonical \"Etc/UTC\" zone. For some platforms those files are hard links\nto the same file, but there's no indication which zone is the canonical\nname and which is a link. Other platforms just store them in different\ninodes anyway. I do not plan to add such an alternative parser for the\ncompiled files. That would need to be contributed by maintainers or\nusers of targets that require it, if making tzdata.zi available is not\nan option. The library ABI would not need to change for a new tzdb\nimplementation, because everything in tzdb_list, tzdb and time_zone is\nimplemented as a pimpl (except for the shared_ptr links between nodes,\ndescribed below). That means the new exported symbols added by this\ncommit should be stable even if the implementation is completely\nrewritten.\n\nThe information from tzdata.zi is parsed and stored in data structures\nthat closely model the info in the file. This is a space-efficient\nrepresentation that uses less memory that storing every transition for\nevery time zone.  It also avoids spending time expanding that\ninformation into time zone transitions that might never be needed by the\nprogram.  When a conversion to/from a local time to UTC is requested the\ninformation will be processed to determine the time zone transitions\nclose to the time being converted.\n\nThere is a bug in some time zone transitions. When generating a sys_info\nobject immediately after one that was previously generated, we need to\nfind the previous rule that was in effect and note its offset and\nletters. This is so that the start time and abbreviation of the new\nsys_info will be correct. This only affects time zones that use a format\nlike \"C%sT\" where the LETTERS replacing %s are non-empty for standard\ntime, e.g. \"Asia/Shanghai\" which uses \"CST\" for standard time and \"CDT\"\nfor daylight time.\n\nThe tzdb_list structure maintains a linked list of tzdb nodes using\nshared_ptr links. This allows the iterators into the list to share\nownership with the list itself. This offers a non-portable solution to a\nlifetime issue in the API. Because tzdb objects can be erased from the\nlist using tzdb_list::erase_after, separate modules/libraries in a large\nprogram cannot guarantee that any const tzdb& or const time_zone*\nremains valid indefinitely. Holding onto a tzdb_list::const_iterator\nwill extend the tzdb object's lifetime, even if it's erased from the\nlist. An alternative design would be for the list iterator to hold a\nweak_ptr. This would allow users to test whether the tzdb still exists\nwhen the iterator is dereferenced, which is better than just having a\ndangling raw pointer. That doesn't actually extend the tzdb's lifetime\nthough, and every use of it would need to be preceded by checking the\nweak_ptr. Using shared_ptr adds a little bit of overhead but allows\nusers to solve the lifetime issue if they rely on the libstdc++-specific\niterator property.\n\nlibstdc++-v3/ChangeLog:\n\n\t* acinclude.m4 (GLIBCXX_ZONEINFO_DIR): New macro.\n\t* config.h.in: Regenerate.\n\t* config/abi/pre/gnu.ver: Export new symbols.\n\t* configure: Regenerate.\n\t* configure.ac (GLIBCXX_ZONEINFO_DIR): Use new macro.\n\t* include/std/chrono (utc_clock::from_sys): Correct handling\n\tof leap seconds.\n\t(nonexistent_local_time::_M_make_what_str): Define.\n\t(ambiguous_local_time::_M_make_what_str): Define.\n\t(__throw_bad_local_time): Define new function.\n\t(time_zone, tzdb_list, tzdb): Implement all members.\n\t(remote_version, zoned_time, get_leap_second_info): Define.\n\t* include/std/version: Add comment for __cpp_lib_chrono.\n\t* src/c++20/Makefile.am: Add new file.\n\t* src/c++20/Makefile.in: Regenerate.\n\t* src/c++20/tzdb.cc: New file.\n\t* testsuite/lib/libstdc++.exp: Define effective target tzdb.\n\t* testsuite/std/time/clock/file/members.cc: Check file_time\n\talias and file_clock::now() member.\n\t* testsuite/std/time/clock/gps/1.cc: Likewise for gps_clock.\n\t* testsuite/std/time/clock/tai/1.cc: Likewise for tai_clock.\n\t* testsuite/std/time/syn_c++20.cc: Uncomment everything except\n\tparse.\n\t* testsuite/std/time/clock/utc/leap_second_info.cc: New test.\n\t* testsuite/std/time/exceptions.cc: New test.\n\t* testsuite/std/time/time_zone/get_info_local.cc: New test.\n\t* testsuite/std/time/time_zone/get_info_sys.cc: New test.\n\t* testsuite/std/time/time_zone/requirements.cc: New test.\n\t* testsuite/std/time/tzdb/1.cc: New test.\n\t* testsuite/std/time/tzdb/leap_seconds.cc: New test.\n\t* testsuite/std/time/tzdb_list/1.cc: New test.\n\t* testsuite/std/time/tzdb_list/requirements.cc: New test.\n\t* testsuite/std/time/zoned_time/1.cc: New test.\n\t* testsuite/std/time/zoned_time/custom.cc: New test.\n\t* testsuite/std/time/zoned_time/deduction.cc: New test.\n\t* testsuite/std/time/zoned_time/req_neg.cc: New test.\n\t* testsuite/std/time/zoned_time/requirements.cc: New test.\n\t* testsuite/std/time/zoned_traits.cc: New test.", "tree": {"sha": "e37ab1f0cdb4d912c6d9c1f48fcc686b72bd11ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e37ab1f0cdb4d912c6d9c1f48fcc686b72bd11ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fc61d45fa15fdd3b084d30998ecda164af33e95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc61d45fa15fdd3b084d30998ecda164af33e95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc61d45fa15fdd3b084d30998ecda164af33e95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc61d45fa15fdd3b084d30998ecda164af33e95/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "907c84cb1d4f0f6b3c4df6af2afb173797e58262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/907c84cb1d4f0f6b3c4df6af2afb173797e58262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/907c84cb1d4f0f6b3c4df6af2afb173797e58262"}], "stats": {"total": 4038, "additions": 3868, "deletions": 170}, "files": [{"sha": "f73946a491818c94d652d45a682c18f667f0a931", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -5140,6 +5140,33 @@ AC_DEFUN([GLIBCXX_EMERGENCY_EH_ALLOC], [\n   AC_SUBST(EH_POOL_FLAGS)\n ])\n \n+dnl\n+dnl Allow the location of tzdata files to be configured.\n+dnl\n+dnl --with-libstdcxx-zoneinfo-dir=PATH will set the directory to PATH.\n+dnl\n+dnl Defines:\n+dnl  _GLIBCXX_ZONEINFO_DIR if std::chrono::tzdb should use a non-default\n+dnl    directory for the tzdata.zi and leapseconds files.\n+dnl\n+AC_DEFUN([GLIBCXX_ZONEINFO_DIR], [\n+  AC_ARG_WITH([libstdcxx-zoneinfo-dir],\n+    AC_HELP_STRING([--with-libstdcxx-zoneinfo-dir],\n+\t\t   [the directory to search for tzdata files]),\n+    [zoneinfo_dir=\"${withval}\"\n+     AC_DEFINE(_GLIBCXX_ZONEINFO_DIR, \"${withval}\",\n+       [Define if a non-default location should be used for tzdata files.])\n+    ],\n+    [\n+    case \"$host\" in\n+      # *-*-aix*) zoneinfo_dir=\"/usr/share/lib/zoneinfo\" ;;\n+      *) zoneinfo_dir=\"/usr/share/zoneinfo\" ;;\n+    esac\n+    ])\n+\n+  AC_MSG_NOTICE([zoneinfo data directory: ${zoneinfo_dir}])\n+])\n+\n # Macros from the top-level gcc directory.\n m4_include([../config/gc++filt.m4])\n m4_include([../config/tls.m4])"}, {"sha": "759378e3a2c29321f4ce37fd222be2df5bea1be9", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -1037,6 +1037,9 @@\n /* Defined if as can handle rdseed. */\n #undef _GLIBCXX_X86_RDSEED\n \n+/* Define if a non-default location should be used for tzdata files. */\n+#undef _GLIBCXX_ZONEINFO_DIR\n+\n /* Define to 1 if mutex_timedlock is available. */\n #undef _GTHREAD_USE_MUTEX_TIMEDLOCK\n "}, {"sha": "570ffca871020a56073d3f879844c1815158c9cb", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -28,7 +28,8 @@ GLIBCXX_3.4 {\n       std::a[a-c]*;\n       std::ad[a-n]*;\n       std::ad[p-z]*;\n-      std::a[e-z]*;\n+      std::a[e-s]*;\n+      std::a[u-z]*;\n #     std::ba[a-r]*;\n       std::basic_[a-e]*;\n       std::basic_f[a-h]*;\n@@ -2485,6 +2486,23 @@ GLIBCXX_3.4.31 {\n \n     _ZSt15__try_use_facet*;\n \n+    _ZNSt6chrono11reload_tzdbEv;\n+    _ZNSt6chrono8get_tzdbEv;\n+    _ZNSt6chrono13get_tzdb_listEv;\n+    _ZNSt6chrono14remote_version*;\n+    _ZNSt6chrono12current_zoneEv;\n+    _ZNSt6chrono11locate_zoneESt17basic_string_viewIcSt11char_traitsIcEE;\n+    _ZNKSt6chrono9time_zone15_M_get_sys_info*;\n+    _ZNKSt6chrono9time_zone17_M_get_local_info*;\n+    _ZNKSt6chrono4tzdb12current_zoneEv;\n+    _ZNKSt6chrono4tzdb11locate_zoneESt17basic_string_viewIcSt11char_traitsIcEE;\n+    _ZNKSt6chrono9tzdb_list5beginEv;\n+    _ZNKSt6chrono9tzdb_list5frontEv;\n+    _ZNSt6chrono9tzdb_list11erase_afterENS0_14const_iteratorE;\n+    _ZNKSt6chrono9tzdb_list14const_iteratordeEv;\n+    _ZNSt6chrono9tzdb_list14const_iteratorppEv;\n+    _ZNSt6chrono9tzdb_list14const_iteratorppEi;\n+\n } GLIBCXX_3.4.30;\n \n # Symbols in the support library (libsupc++) have their own tag."}, {"sha": "4b0ee147f409c9e3dd76558b3c68695a18ebf93d", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -961,6 +961,7 @@ enable_libstdcxx_filesystem_ts\n enable_libstdcxx_backtrace\n enable_libstdcxx_static_eh_pool\n with_libstdcxx_eh_pool_obj_count\n+with_libstdcxx_zoneinfo_dir\n enable_cet\n with_gxx_include_dir\n enable_version_specific_runtime_libs\n@@ -1704,6 +1705,8 @@ Optional Packages:\n   --with-libstdcxx-eh-pool-obj-count\n                           the number of exceptions that can be allocated from\n                           the pool if malloc fails\n+  --with-libstdcxx-zoneinfo-dir\n+                          the directory to search for tzdata files\n   --with-gxx-include-dir=DIR\n                           installation directory for include files\n   --with-toolexeclibdir=DIR\n@@ -12182,7 +12185,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12185 \"configure\"\n+#line 12188 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12288,7 +12291,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12291 \"configure\"\n+#line 12294 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16012,7 +16015,7 @@ $as_echo \"$glibcxx_cv_atomic_long_long\" >&6; }\n   # Fake what AC_TRY_COMPILE does.\n \n     cat > conftest.$ac_ext << EOF\n-#line 16015 \"configure\"\n+#line 16018 \"configure\"\n int main()\n {\n   typedef bool atomic_type;\n@@ -16047,7 +16050,7 @@ $as_echo \"$glibcxx_cv_atomic_bool\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 16050 \"configure\"\n+#line 16053 \"configure\"\n int main()\n {\n   typedef short atomic_type;\n@@ -16082,7 +16085,7 @@ $as_echo \"$glibcxx_cv_atomic_short\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 16085 \"configure\"\n+#line 16088 \"configure\"\n int main()\n {\n   // NB: _Atomic_word not necessarily int.\n@@ -16118,7 +16121,7 @@ $as_echo \"$glibcxx_cv_atomic_int\" >&6; }\n     rm -f conftest*\n \n     cat > conftest.$ac_ext << EOF\n-#line 16121 \"configure\"\n+#line 16124 \"configure\"\n int main()\n {\n   typedef long long atomic_type;\n@@ -16274,7 +16277,7 @@ $as_echo \"mutex\" >&6; }\n   # unnecessary for this test.\n \n     cat > conftest.$ac_ext << EOF\n-#line 16277 \"configure\"\n+#line 16280 \"configure\"\n int main()\n {\n   _Decimal32 d1;\n@@ -16316,7 +16319,7 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n   # unnecessary for this test.\n \n   cat > conftest.$ac_ext << EOF\n-#line 16319 \"configure\"\n+#line 16322 \"configure\"\n template<typename T1, typename T2>\n   struct same\n   { typedef T2 type; };\n@@ -71511,6 +71514,30 @@ fi\n \n \n \n+# For src/c++20/tzdb.cc defaults.\n+\n+\n+# Check whether --with-libstdcxx-zoneinfo-dir was given.\n+if test \"${with_libstdcxx_zoneinfo_dir+set}\" = set; then :\n+  withval=$with_libstdcxx_zoneinfo_dir; zoneinfo_dir=\"${withval}\"\n+\n+$as_echo \"#define _GLIBCXX_ZONEINFO_DIR \\\"\\${withval}\\\"\" >>confdefs.h\n+\n+\n+else\n+\n+    case \"$host\" in\n+      # *-*-aix*) zoneinfo_dir=\"/usr/share/lib/zoneinfo\" ;;\n+      *) zoneinfo_dir=\"/usr/share/zoneinfo\" ;;\n+    esac\n+\n+fi\n+\n+\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: zoneinfo data directory: ${zoneinfo_dir}\" >&5\n+$as_echo \"$as_me: zoneinfo data directory: ${zoneinfo_dir}\" >&6;}\n+\n+\n # Define documentation rules conditionally.\n \n # See if makeinfo has been installed and is modern enough"}, {"sha": "0dd550a4b4b1f5e31c4a84f4af258e723744657c", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -535,6 +535,9 @@ GLIBCXX_CHECK_EXCEPTION_PTR_SYMVER\n # For libsupc++/eh_alloc.cc defaults.\n GLIBCXX_EMERGENCY_EH_ALLOC\n \n+# For src/c++20/tzdb.cc defaults.\n+GLIBCXX_ZONEINFO_DIR\n+\n # Define documentation rules conditionally.\n \n # See if makeinfo has been installed and is modern enough"}, {"sha": "aeb8f6f462fa54b765769d9181202c18c6d902be", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 549, "deletions": 147, "changes": 696, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -46,11 +46,17 @@\n # include <string>\n # include <vector>\n # include <bits/charconv.h> // __to_chars_len, __to_chars_10_impl\n-# include <bits/stl_algo.h> // upper_bound TODO: move leap_second_info to .so\n+# include <bits/stl_algo.h> // upper_bound\n # include <bits/shared_ptr.h>\n # include <bits/unique_ptr.h>\n #endif\n \n+#if __cplusplus >= 202002L\n+// TODO formatting and parsing\n+// # undef __cpp_lib_chrono\n+// # define __cpp_lib_chrono 201907L\n+#endif\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -140,7 +146,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  using _CDur = common_type_t<_Duration, seconds>;\n \t  const auto __li = chrono::get_leap_second_info(__t);\n-\t  sys_time<_CDur> __s{__t.time_since_epoch() - seconds{__li.elapsed}};\n+\t  sys_time<_CDur> __s{__t.time_since_epoch() - __li.elapsed};\n \t  if (__li.is_leap_second)\n \t    __s = chrono::floor<seconds>(__s) + seconds{1} - _CDur{1};\n \t  return __s;\n@@ -149,13 +155,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Duration>\n \t[[nodiscard]]\n \tstatic utc_time<common_type_t<_Duration, seconds>>\n-\tfrom_sys(const sys_time<_Duration>& __t)\n-\t{\n-\t  using _CDur = common_type_t<_Duration, seconds>;\n-\t  utc_time<_Duration> __u(__t.time_since_epoch());\n-\t  const auto __li = chrono::get_leap_second_info(__u);\n-\t  return utc_time<_CDur>{__u} + seconds{__li.elapsed};\n-\t}\n+\tfrom_sys(const sys_time<_Duration>& __t);\n     };\n \n     /** A clock that measures International Atomic Time.\n@@ -2056,7 +2056,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    - chrono::weekday{sys_days{_M_y / _M_m / 1}}\n \t\t    + days((_M_wdi.index()-1)*7 + 1));\n \t__glibcxx_assert(__d.count() >= 1);\n-\treturn __d.count() <= unsigned{(_M_y / _M_m / last).day()};\n+\treturn (unsigned)__d.count() <= (unsigned)(_M_y / _M_m / last).day();\n       }\n \n       friend constexpr bool\n@@ -2500,8 +2500,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n+#if _GLIBCXX_USE_CXX11_ABI || ! _GLIBCXX_USE_DUAL_ABI\n     // C++20 [time.zones] Time zones\n \n+    struct tzdb;\n+\n     struct sys_info\n     {\n       sys_seconds begin;\n@@ -2532,26 +2535,70 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ __glibcxx_assert(__i.result == local_info::nonexistent); }\n \n     private:\n-      template<typename _Duration> // TODO\n+      template<typename _Duration>\n \tstatic string\n-\t_S_make_what_str(const local_time<_Duration>&, const local_info&);\n+\t_S_make_what_str(const local_time<_Duration>& __tp,\n+\t\t\t const local_info& __i)\n+\t{\n+#if 1\n+\t  return \"local time is non-existent\";\n+#else\n+\t  std::ostringstream __os;\n+\t  __os << __tp << \" is in a gap between\\n\"\n+\t       << local_seconds(__i.first.end.time_since_epoch())\n+\t       + __i.first.offset << ' ' << __i.first.abbrev << \" and\\n\"\n+\t       << local_seconds(__i.second.begin.time_since_epoch())\n+\t       + __i.second.offset << ' ' << __i.second.abbrev\n+\t       << \" which are both equivalent to\\n\"\n+\t       << __i.first.end << \" UTC\";\n+\t  return std::move(__os).str();\n+#endif\n+\t}\n     };\n \n     class ambiguous_local_time : public runtime_error\n     {\n     public:\n       template<typename _Duration>\n \tambiguous_local_time(const local_time<_Duration>& __tp,\n-\t\t\t       const local_info& __i)\n+\t\t\t     const local_info& __i)\n \t: runtime_error(_S_make_what_str(__tp, __i))\n-\t{ __glibcxx_assert(__i.result == local_info::nonexistent); }\n+\t{ __glibcxx_assert(__i.result == local_info::ambiguous); }\n \n     private:\n-      template<typename _Duration> // TODO\n+      template<typename _Duration>\n \tstatic string\n-\t_S_make_what_str(const local_time<_Duration>&, const local_info&);\n+\t_S_make_what_str(const local_time<_Duration>& __tp,\n+\t\t\t const local_info& __i)\n+\t{\n+#if 1\n+\t  return \"local time is ambiguous\";\n+#else\n+\t  std::ostringstream __os;\n+\t  __os << __tp << \" is ambiguous.  It could be\\n\"\n+\t       << __tp << ' ' << __i.first.abbrev << \" == \"\n+\t       << __tp - __i.first.offset << \" UTC or\\n\"\n+\t       << __tp << ' ' << __i.second.abbrev << \" == \"\n+\t       << __tp - __i.second.offset << \" UTC\";\n+\t  return std::move(__os).str();\n+#endif\n+\t}\n     };\n \n+    template<typename _Duration>\n+      [[noreturn]] void\n+      __throw_bad_local_time(const local_time<_Duration>& __tp,\n+\t\t\t     const local_info& __i)\n+      {\n+#if __cpp_exceptions\n+\tif (__i.result == local_info::nonexistent)\n+\t  throw nonexistent_local_time(__tp, __i);\n+\tthrow ambiguous_local_time(__tp, __i);\n+#else\n+\t__builtin_abort();\n+#endif\n+      }\n+\n     enum class choose { earliest, latest };\n \n     class time_zone\n@@ -2560,46 +2607,188 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       time_zone(time_zone&&) = default;\n       time_zone& operator=(time_zone&&) = default;\n \n+      ~time_zone();\n+\n+      [[nodiscard]]\n       string_view name() const noexcept { return _M_name; }\n \n       template<typename _Duration>\n \tsys_info\n-\tget_info(const sys_time<_Duration>& __st) const;\n+\tget_info(const sys_time<_Duration>& __st) const\n+\t{ return _M_get_sys_info(chrono::floor<seconds>(__st)); }\n \n       template<typename _Duration>\n \tlocal_info\n-\tget_info(const local_time<_Duration>& __tp) const;\n+\tget_info(const local_time<_Duration>& __tp) const\n+\t{ return _M_get_local_info(chrono::floor<seconds>(__tp)); }\n \n       template<typename _Duration>\n \tsys_time<common_type_t<_Duration, seconds>>\n-\tto_sys(const local_time<_Duration>& __tp) const;\n+\tto_sys(const local_time<_Duration>& __tp) const\n+\t{\n+\t  local_info __info = get_info(__tp);\n+\n+\t  if (__info.result != local_info::unique)\n+\t    __throw_bad_local_time(__tp, __info);\n+\n+\t  return sys_time<_Duration>(__tp.time_since_epoch())\n+\t\t   - __info.first.offset;\n+\t}\n \n       template<typename _Duration>\n \tsys_time<common_type_t<_Duration, seconds>>\n-\tto_sys(const local_time<_Duration>& __tp, choose __z) const;\n+\tto_sys(const local_time<_Duration>& __tp, choose __z) const\n+\t{\n+\t  local_info __info = get_info(__tp);\n+\n+\t  if (__info.result == local_info::nonexistent)\n+\t    return __info.first.end; // Last second of the previous sys_info.\n+\n+\t  sys_time<_Duration> __st(__tp.time_since_epoch());\n+\n+\t  if (__info.result == local_info::ambiguous && __z == choose::latest)\n+\t    return __st - __info.second.offset; // Time in the later sys_info.\n+\t  // else if __z == earliest, use __info.first.offset as below:\n+\n+\t  return __st - __info.first.offset;\n+\t}\n \n       template<typename _Duration>\n \tlocal_time<common_type_t<_Duration, seconds>>\n-\tto_local(const sys_time<_Duration>& __tp) const;\n+\tto_local(const sys_time<_Duration>& __tp) const\n+\t{\n+\t  auto __d = (__tp + get_info(__tp).offset).time_since_epoch();\n+\t  return local_time<common_type_t<_Duration, seconds>>(__d);\n+\t}\n \n-      friend bool\n+      [[nodiscard]] friend bool\n       operator==(const time_zone& __x, const time_zone& __y) noexcept\n-      { return __x.name() == __y.name(); }\n+      { return __x._M_name == __y._M_name; }\n \n-      friend strong_ordering\n+      [[nodiscard]] friend strong_ordering\n       operator<=>(const time_zone& __x, const time_zone& __y) noexcept\n-      { return __x.name() <=> __y.name(); }\n+      { return __x._M_name <=> __y._M_name; }\n \n     private:\n-      string _M_name;\n+      sys_info _M_get_sys_info(sys_seconds) const;\n+      local_info _M_get_local_info(local_seconds) const;\n+\n+      friend const tzdb& reload_tzdb();\n+      friend struct tzdb;\n+      friend class tzdb_list;\n+\n       struct _Impl;\n+\n+      explicit time_zone(unique_ptr<_Impl> __p);\n+      string _M_name;\n       unique_ptr<_Impl> _M_impl;\n     };\n \n-    struct tzdb;\n     const time_zone* locate_zone(string_view __tz_name);\n     const time_zone* current_zone();\n \n+    /** The list of `chrono::tzdb` objects\n+     *\n+     * A single object of this type is constructed by the C++ runtime,\n+     * and can be accessed by calling `chrono::get_tzdb_list()`.\n+     *\n+     * The front of the list is the current `tzdb` object and can be accessed\n+     * via `chrono::get_tzdb_list().front()` or `chrono::get_tzdb()` or\n+     * `*chrono::get_tzdb_list().begin()`.\n+     *\n+     * The `chrono::reload_tzdb()` function will check for a newer version\n+     * and if found, insert it at the front of the list.\n+     *\n+     * @since C++20\n+     */\n+    class tzdb_list\n+    {\n+      struct _Node;\n+\n+    public:\n+      tzdb_list(const tzdb_list&) = delete;\n+      tzdb_list& operator=(const tzdb_list&) = delete;\n+\n+      /** An iterator into the `tzdb_list`\n+       *\n+       * As a extension, in libstdc++ each `tzdb` is reference-counted\n+       * and the `const_iterator` type shares ownership of the object it\n+       * refers to. This ensures that a `tzdb` erased from the list will\n+       * not be destroyed while there is an iterator that refers to it.\n+       */\n+      class const_iterator\n+      {\n+      public:\n+\tusing value_type        = tzdb;\n+\tusing reference         = const tzdb&;\n+\tusing pointer           = const tzdb*;\n+\tusing difference_type   = ptrdiff_t;\n+\tusing iterator_category = forward_iterator_tag;\n+\n+\tconstexpr const_iterator() = default;\n+\tconst_iterator(const const_iterator&) = default;\n+\tconst_iterator(const_iterator&&) = default;\n+\tconst_iterator& operator=(const const_iterator&) = default;\n+\tconst_iterator& operator=(const_iterator&&) = default;\n+\n+\treference operator*() const noexcept;\n+\tpointer operator->() const noexcept { return &**this; }\n+\tconst_iterator& operator++();\n+\tconst_iterator operator++(int);\n+\n+\tbool operator==(const const_iterator&) const noexcept = default;\n+\n+      private:\n+\texplicit const_iterator(const shared_ptr<_Node>&) noexcept;\n+\n+\tfriend class tzdb_list;\n+\n+\tshared_ptr<_Node> _M_node;\n+\tvoid* _M_reserved = nullptr;\n+      };\n+\n+      /** Access the current `tzdb` at the front of the list.\n+       *\n+       * This returns a reference to the same object as `chrono::get_tzdb()`.\n+       *\n+       * @returns A reference to the current tzdb object.\n+       * @since C++20\n+       */\n+      const tzdb& front() const noexcept;\n+\n+      /** Remove the tzdb object _after_ the one the iterator refers to.\n+       *\n+       * Calling this function concurently with any of `front()`, `begin()`,\n+       * or `end()` does not cause a data race, but in general this function\n+       * is not thread-safe. The behaviour may be undefined if erasing an\n+       * element from the list while another thread is calling the same\n+       * function, or incrementing an iterator into the list, or accessing\n+       * the element being erased (unless it is accessed through an iterator).\n+       *\n+       * @param __p A dereferenceable iterator.\n+       * @returns An iterator the element after the one that was erased\n+       *          (or `end()` if there is no such element).\n+       * @since C++20\n+       */\n+      const_iterator erase_after(const_iterator __p);\n+\n+      const_iterator begin() const noexcept;\n+      const_iterator end() const noexcept { return {}; }\n+      const_iterator cbegin() const noexcept { return begin(); }\n+      const_iterator cend() const noexcept { return end(); }\n+\n+    private:\n+      constexpr explicit tzdb_list(nullptr_t);\n+\n+      friend tzdb_list& get_tzdb_list();\n+      friend const tzdb& get_tzdb();\n+      friend const tzdb& reload_tzdb();\n+      friend struct tzdb;\n+      friend class leap_second;\n+      friend struct time_zone::_Impl;\n+      friend class time_zone_link;\n+    };\n+\n     class time_zone_link\n     {\n     public:\n@@ -2619,7 +2808,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       friend const tzdb& reload_tzdb();\n-      // TODO unspecified additional constructors\n+      friend class tzdb_list::_Node;\n+\n+      explicit time_zone_link(nullptr_t) { }\n+\n       string _M_name;\n       string _M_target;\n     };\n@@ -2720,10 +2912,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     private:\n       explicit leap_second(seconds::rep __s) : _M_s(__s) { }\n \n+      friend class tzdb_list::_Node;\n+\n       friend const tzdb& reload_tzdb();\n-      template<typename _Dur>\n+\n+      template<typename _Duration>\n \tfriend leap_second_info\n-\tget_leap_second_info(const utc_time<_Dur>&);\n+\tget_leap_second_info(const utc_time<_Duration>&);\n \n       seconds _M_s; // == date().time_since_epoch() * value().count()\n     };\n@@ -2745,9 +2940,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct tzdb\n     {\n       string version;\n-      vector<time_zone> zones;\n-      vector<time_zone_link> links;\n-      vector<leap_second> leap_seconds;\n+      _GLIBCXX_STD_C::vector<time_zone> zones;\n+      _GLIBCXX_STD_C::vector<time_zone_link> links;\n+      _GLIBCXX_STD_C::vector<leap_second> leap_seconds;\n \n       const time_zone*\n       locate_zone(string_view __tz_name) const;\n@@ -2757,146 +2952,353 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       friend const tzdb& reload_tzdb();\n-\n-      struct _Rule;\n-      vector<_Rule> _M_rules;\n+      friend class time_zone;\n+      friend class tzdb_list::_Node;\n     };\n \n-    class tzdb_list\n-    {\n-      struct _Node;\n-    public:\n-      tzdb_list(const tzdb_list&) = delete;\n-      tzdb_list& operator=(const tzdb_list&) = delete;\n+    tzdb_list& get_tzdb_list();\n+    const tzdb& get_tzdb();\n \n-      class const_iterator\n+    const tzdb& reload_tzdb();\n+    string remote_version();\n+\n+    template<typename _Duration, typename _TimeZonePtr = const time_zone*>\n+      class zoned_time\n       {\n+\tstatic_assert(__is_duration_v<_Duration>);\n+\n+\tusing _Traits = zoned_traits<_TimeZonePtr>;\n+\n+\t// Every constructor that accepts a string_view as its first parameter\n+\t// does not participate in class template argument deduction.\n+\tusing string_view = type_identity_t<std::string_view>;\n+\n       public:\n-\tusing value_type        = tzdb;\n-\tusing reference         = const tzdb&;\n-\tusing pointer           = const tzdb*;\n-\tusing difference_type   = ptrdiff_t;\n-\tusing iterator_category = forward_iterator_tag;\n+\tusing duration = common_type_t<_Duration, seconds>;\n \n-\tconstexpr const_iterator() = default;\n-\tconst_iterator(const const_iterator&) = default;\n-\tconst_iterator(const_iterator&&) = default;\n-\tconst_iterator& operator=(const const_iterator&) = default;\n-\tconst_iterator& operator=(const_iterator&&) = default;\n+\tzoned_time() requires requires { _Traits::default_zone(); }\n+\t{ }\n \n-\treference operator*() const noexcept;\n-\tpointer operator->() const noexcept { return &**this; }\n-\tconst_iterator& operator++();\n-\tconst_iterator operator++(int);\n+\tzoned_time(const zoned_time&) = default;\n+\tzoned_time& operator=(const zoned_time&) = default;\n \n-\tbool operator==(const const_iterator&) const noexcept = default;\n+\tzoned_time(const sys_time<_Duration>& __st)\n+\t  requires requires { _Traits::default_zone(); }\n+\t: _M_tp(__st)\n+\t{ }\n \n-      private:\n-\texplicit const_iterator(const shared_ptr<_Node>&) noexcept;\n+\texplicit\n+\tzoned_time(_TimeZonePtr __z) : _M_zone(std::move(__z)) { }\n \n-\tshared_ptr<_Node> _M_node;\n-\tvoid* _M_reserved = nullptr;\n-      };\n+\texplicit\n+\tzoned_time(string_view __name)\n+\t  requires requires {\n+\t    _TimeZonePtr{_Traits::locate_zone(std::string_view{})};\n+\t  }\n+\t: _M_zone(_Traits::locate_zone(__name))\n+\t{ }\n \n-      // TODO const tzdb& front() const noexcept;\n+\ttemplate<typename _Duration2>\n+\t  zoned_time(const zoned_time<_Duration2, _TimeZonePtr>& __zt)\n+\t  requires is_convertible_v<sys_time<_Duration2>, sys_time<_Duration>>\n+\t  : _M_zone(__zt._M_zone), _M_tp(__zt._M_tp)\n+\t  { }\n \n-      const_iterator erase_after(const_iterator);\n+\tzoned_time(_TimeZonePtr __z, const sys_time<_Duration>& __st)\n+\t: _M_zone(std::move(__z)), _M_tp(__st)\n+\t{ }\n \n-      const_iterator begin() const noexcept;\n-      const_iterator end() const noexcept { return {}; }\n-      const_iterator cbegin() const noexcept { return begin(); }\n-      const_iterator cend() const noexcept { return end(); }\n+\tzoned_time(string_view __name, const sys_time<_Duration>& __st)\n+\t: zoned_time(_Traits::locate_zone(__name), __st)\n+\t{ }\n \n-    private:\n-      constexpr explicit tzdb_list(nullptr_t);\n+\tzoned_time(_TimeZonePtr __z, const local_time<_Duration>& __tp)\n+\trequires requires {\n+\t  { __z->to_sys(__tp) } -> convertible_to<sys_time<_Duration>>;\n+\t}\n+\t: _M_zone(std::move(__z)), _M_tp(_M_zone->to_sys(__tp))\n+\t{ }\n \n-      friend const tzdb_list& get_tzdb_list();\n-      friend const tzdb& get_tzdb();\n-      friend const tzdb& reload_tzdb();\n+\tzoned_time(string_view __name, const local_time<_Duration>& __tp)\n+\trequires requires (_TimeZonePtr __z) {\n+\t  { _Traits::locate_zone(__name) } -> convertible_to<_TimeZonePtr>;\n+\t  { __z->to_sys(__tp) } -> convertible_to<sys_time<_Duration>>;\n+\t}\n+\t: zoned_time(_Traits::locate_zone(__name), __tp)\n+\t{ }\n \n-      static _Node* _S_head;\n-      static shared_ptr<_Node> _S_head_owner;\n-    };\n+\tzoned_time(_TimeZonePtr __z, const local_time<_Duration>& __tp,\n+\t\t   choose __c)\n+\trequires requires {\n+\t  { __z->to_sys(__tp, __c) } -> convertible_to<sys_time<_Duration>>;\n+\t}\n+\t: _M_zone(std::move(__z)), _M_tp(_M_zone->to_sys(__tp, __c))\n+\t{ }\n \n-    // TODO\n-    // const tzdb_list& get_tzdb_list();\n-    // const tzdb& get_tzdb();\n+\tzoned_time(string_view __name, const local_time<_Duration>& __tp,\n+\t\t   choose __c)\n+\trequires requires (_TimeZonePtr __z) {\n+\t  { _Traits::locate_zone(__name) } -> convertible_to<_TimeZonePtr>;\n+\t  { __z->to_sys(__tp, __c) } -> convertible_to<sys_time<_Duration>>;\n+\t}\n+\t: _M_zone(_Traits::locate_zone(__name)),\n+\t  _M_tp(_M_zone->to_sys(__tp, __c))\n+\t{ }\n \n-    // const tzdb& reload_tzdb();\n-    // string remove_version();\n+\ttemplate<typename _Duration2, typename _TimeZonePtr2>\n+\t  zoned_time(_TimeZonePtr __z,\n+\t\t     const zoned_time<_Duration2, _TimeZonePtr2>& __zt)\n+\t  requires is_convertible_v<sys_time<_Duration2>, sys_time<_Duration>>\n+\t  : _M_zone(__z), _M_tp(__zt._M_tp)\n+\t  { }\n+\n+\ttemplate<typename _Duration2, typename _TimeZonePtr2>\n+\t  zoned_time(_TimeZonePtr __z,\n+\t\t     const zoned_time<_Duration2, _TimeZonePtr2>& __zt,\n+\t\t     choose __c)\n+\t  requires is_convertible_v<sys_time<_Duration2>, sys_time<_Duration>>\n+\t  : _M_zone(__z), _M_tp(__zt._M_tp)\n+\t  { }\n+\n+\ttemplate<typename _Duration2, typename _TimeZonePtr2>\n+\t  zoned_time(string_view __name,\n+\t\t     const zoned_time<_Duration2, _TimeZonePtr2>& __zt)\n+\t  requires is_convertible_v<sys_time<_Duration2>, sys_time<_Duration>>\n+\t  && requires {\n+\t    { _Traits::locate_zone(__name) } -> convertible_to<_TimeZonePtr>;\n+\t  }\n+\t  : _M_zone(_Traits::locate_zone(__name)), _M_tp(__zt._M_tp)\n+\t  { }\n+\n+\ttemplate<typename _Duration2, typename _TimeZonePtr2>\n+\t  zoned_time(string_view __name,\n+\t\t     const zoned_time<_Duration2, _TimeZonePtr2>& __zt,\n+\t\t     choose __c)\n+\t  requires is_convertible_v<sys_time<_Duration2>, sys_time<_Duration>>\n+\t  && requires {\n+\t    { _Traits::locate_zone(__name) } -> convertible_to<_TimeZonePtr>;\n+\t  }\n+\t  : _M_zone(_Traits::locate_zone(__name)), _M_tp(__zt._M_tp)\n+\t  { }\n \n-    template<typename _Duration, typename _TimeZonePtr = const time_zone*>\n-      class zoned_time; // TODO\n+\tzoned_time&\n+\toperator=(const sys_time<_Duration>& __st)\n+\t{\n+\t  _M_tp = __st;\n+\t  return *this;\n+\t}\n+\n+\tzoned_time&\n+\toperator=(const local_time<_Duration>& __lt)\n+\t{\n+\t  _M_tp = _M_zone->to_sys(__lt);\n+\t  return *this;\n+\t}\n+\n+\t[[nodiscard]]\n+\toperator sys_time<duration>() const { return _M_tp; }\n+\n+\t[[nodiscard]]\n+\texplicit operator local_time<duration>() const\n+\t{ return get_local_time(); }\n+\n+\t[[nodiscard]]\n+\t_TimeZonePtr\n+\tget_time_zone() const\n+\t{ return _M_zone; }\n+\n+\t[[nodiscard]]\n+\tlocal_time<duration>\n+\tget_local_time() const\n+\t{ return _M_zone->to_local(_M_tp); }\n+\n+\t[[nodiscard]]\n+\tsys_time<duration>\n+\tget_sys_time() const\n+\t{ return _M_tp; }\n+\n+\t[[nodiscard]]\n+\tsys_info\n+\tget_info() const\n+\t{ return _M_zone->get_info(_M_tp); }\n+\n+\t[[nodiscard]] friend bool\n+\toperator==(const zoned_time&, const zoned_time&) = default;\n+\n+      private:\n+\t_TimeZonePtr       _M_zone{ _Traits::default_zone() };\n+\tsys_time<duration> _M_tp{};\n+\n+\ttemplate<typename _Duration2, typename _TimeZonePtr2>\n+\t  friend class zoned_time;\n+      };\n+\n+    zoned_time() -> zoned_time<seconds>;\n+\n+    template<typename _Duration>\n+    zoned_time(sys_time<_Duration>)\n+      -> zoned_time<common_type_t<_Duration, seconds>>;\n+\n+  /// @cond undocumented\n+  template<typename _TimeZonePtrOrName>\n+    using __time_zone_representation\n+      = __conditional_t<is_convertible_v<_TimeZonePtrOrName, string_view>,\n+\t\t\tconst time_zone*,\n+\t\t\tremove_cvref_t<_TimeZonePtrOrName>>;\n+  /// @endcond\n+\n+  template<typename _TimeZonePtrOrName>\n+    zoned_time(_TimeZonePtrOrName&&)\n+      -> zoned_time<seconds, __time_zone_representation<_TimeZonePtrOrName>>;\n+\n+  template<typename _TimeZonePtrOrName, typename _Duration>\n+    zoned_time(_TimeZonePtrOrName&&, sys_time<_Duration>)\n+      -> zoned_time<common_type_t<_Duration, seconds>,\n+                    __time_zone_representation<_TimeZonePtrOrName>>;\n+\n+  template<typename _TimeZonePtrOrName, typename _Duration>\n+    zoned_time(_TimeZonePtrOrName&&, local_time<_Duration>,\n+               choose = choose::earliest)\n+      -> zoned_time<common_type_t<_Duration, seconds>,\n+                    __time_zone_representation<_TimeZonePtrOrName>>;\n+\n+  template<typename _Duration, typename _TimeZonePtrOrName,\n+\t   typename _TimeZonePtr2>\n+    zoned_time(_TimeZonePtrOrName&&, zoned_time<_Duration, _TimeZonePtr2>,\n+               choose = choose::earliest)\n+      -> zoned_time<common_type_t<_Duration, seconds>,\n+                    __time_zone_representation<_TimeZonePtrOrName>>;\n+\n+  template<typename _Dur1, typename _TZPtr1, typename _Dur2, typename _TZPtr2>\n+    [[nodiscard]]\n+    inline bool\n+    operator==(const zoned_time<_Dur1, _TZPtr1>& __x,\n+\t       const zoned_time<_Dur2, _TZPtr2>& __y)\n+    {\n+      return __x.get_time_zone() == __y.get_time_zone()\n+\t       && __x.get_sys_time() == __y.get_sys_time();\n+    }\n \n     using zoned_seconds = zoned_time<seconds>;\n+#endif // _GLIBCXX_USE_CXX11_ABI || ! _GLIBCXX_USE_DUAL_ABI\n+\n+namespace __detail\n+{\n+    inline leap_second_info\n+    __get_leap_second_info(sys_seconds __ss, bool __is_utc)\n+    {\n+      if (__ss < sys_seconds{}) [[unlikely]]\n+\treturn {};\n+\n+      const seconds::rep __leaps[] {\n+\t  78796800, // 1 Jul 1972\n+\t  94694400, // 1 Jan 1973\n+\t 126230400, // 1 Jan 1974\n+\t 157766400, // 1 Jan 1975\n+\t 189302400, // 1 Jan 1976\n+\t 220924800, // 1 Jan 1977\n+\t 252460800, // 1 Jan 1978\n+\t 283996800, // 1 Jan 1979\n+\t 315532800, // 1 Jan 1980\n+\t 362793600, // 1 Jul 1981\n+\t 394329600, // 1 Jul 1982\n+\t 425865600, // 1 Jul 1983\n+\t 489024000, // 1 Jul 1985\n+\t 567993600, // 1 Jan 1988\n+\t 631152000, // 1 Jan 1990\n+\t 662688000, // 1 Jan 1991\n+\t 709948800, // 1 Jul 1992\n+\t 741484800, // 1 Jul 1993\n+\t 773020800, // 1 Jul 1994\n+\t 820454400, // 1 Jan 1996\n+\t 867715200, // 1 Jul 1997\n+\t 915148800, // 1 Jan 1999\n+\t1136073600, // 1 Jan 2006\n+\t1230768000, // 1 Jan 2009\n+\t1341100800, // 1 Jul 2012\n+\t1435708800, // 1 Jul 2015\n+\t1483228800, // 1 Jan 2017\n+      };\n+      // The list above is known to be valid until (at least) this date\n+      // and only contains positive leap seconds.\n+      const sys_seconds __expires(1687910400s); // 2023-06-28 00:00:00 UTC\n+\n+#if _GLIBCXX_USE_CXX11_ABI || ! _GLIBCXX_USE_DUAL_ABI\n+      if (__ss > __expires)\n+\t{\n+\t  // Use updated leap_seconds from tzdb.\n+\t  size_t __n = std::size(__leaps);\n+\n+\t  auto __db = get_tzdb_list().begin();\n+\t  auto __first = __db->leap_seconds.begin() + __n;\n+\t  auto __last = __db->leap_seconds.end();\n+\t  auto __pos = std::upper_bound(__first, __last, __ss);\n+\t  seconds __elapsed(__n);\n+\t  for (auto __i = __first; __i != __pos; ++__i)\n+\t    __elapsed += __i->value();\n+\n+\t  if (__is_utc)\n+\t    {\n+\t      // Convert utc_time to sys_time:\n+\t      __ss -= __elapsed;\n+\t      // See if that sys_time is before (or during) previous leap sec:\n+\t      if (__pos != __first && __ss < __pos[-1])\n+\t\t{\n+\t\t  if ((__ss + 1s) >= __pos[-1])\n+\t\t    return {true, __elapsed};\n+\t\t  __elapsed -= __pos[-1].value();\n+\t\t}\n+\t    }\n+\t  return {false, __elapsed};\n+\t}\n+      else\n+#endif\n+\t{\n+\t  seconds::rep __s = __ss.time_since_epoch().count();\n+\t  const seconds::rep* __first = std::begin(__leaps);\n+\t  const seconds::rep* __last = std::end(__leaps);\n+\n+\t  // Don't bother searching the list if we're after the last one.\n+\t  if (__s > (__last[-1] + (__last - __first) + 1))\n+\t    return { false, seconds(__last - __first) };\n+\n+\t  auto __pos = std::upper_bound(__first, __last, __s);\n+\t  seconds __elapsed{__pos - __first};\n+\t  if (__is_utc)\n+\t    {\n+\t      // Convert utc_time to sys_time:\n+\t      __s -= __elapsed.count();\n+\t      // See if that sys_time is before (or during) previous leap sec:\n+\t      if (__pos != __first && __s < __pos[-1])\n+\t\t{\n+\t\t  if ((__s + 1) >= __pos[-1])\n+\t\t    return {true, __elapsed};\n+\t\t  --__elapsed;\n+\t\t}\n+\t    }\n+\t  return {false, __elapsed};\n+\t}\n+    }\n+} // namespace __detail\n \n     template<typename _Duration>\n-      leap_second_info\n+      [[nodiscard]]\n+      inline leap_second_info\n       get_leap_second_info(const utc_time<_Duration>& __ut)\n       {\n-\tif constexpr (is_same_v<_Duration, seconds>)\n-\t  {\n-\t    const seconds::rep __leaps[] {\n-\t\t78796800, // 1 Jul 1972\n-\t\t94694400, // 1 Jan 1973\n-\t       126230400, // 1 Jan 1974\n-\t       157766400, // 1 Jan 1975\n-\t       189302400, // 1 Jan 1976\n-\t       220924800, // 1 Jan 1977\n-\t       252460800, // 1 Jan 1978\n-\t       283996800, // 1 Jan 1979\n-\t       315532800, // 1 Jan 1980\n-\t       362793600, // 1 Jul 1981\n-\t       394329600, // 1 Jul 1982\n-\t       425865600, // 1 Jul 1983\n-\t       489024000, // 1 Jul 1985\n-\t       567993600, // 1 Jan 1988\n-\t       631152000, // 1 Jan 1990\n-\t       662688000, // 1 Jan 1991\n-\t       709948800, // 1 Jul 1992\n-\t       741484800, // 1 Jul 1993\n-\t       773020800, // 1 Jul 1994\n-\t       820454400, // 1 Jan 1996\n-\t       867715200, // 1 Jul 1997\n-\t       915148800, // 1 Jan 1999\n-\t      1136073600, // 1 Jan 2006\n-\t      1230768000, // 1 Jan 2009\n-\t      1341100800, // 1 Jul 2012\n-\t      1435708800, // 1 Jul 2015\n-\t      1483228800, // 1 Jan 2017\n-\t    };\n-\t    // The list above is known to be valid until 2023-06-28 00:00:00 UTC\n-\t    const seconds::rep __expires = 1687910400;\n-\t    const seconds::rep __s = __ut.time_since_epoch().count();\n-\n-\t    const seconds::rep* __first = std::begin(__leaps);\n-\t    const seconds::rep* __last = std::end(__leaps);\n-\n-\t    if (__s > __expires)\n-\t      {\n-\t\t// TODO: use updated leap_seconds from tzdb\n-#if 0\n-\t\tauto __db = get_tzdb_list().begin();\n-\t\t__first = __db->leap_seconds.data();\n-\t\t__last = __first + __db->leap_seconds.size();\n-#endif\n-\t      }\n-\n-\t    // Don't bother searching the list if we're after the last one.\n-\t    if (__s > __last[-1])\n-\t      return { false, seconds(__last - __first) };\n+\tauto __s = chrono::duration_cast<seconds>(__ut.time_since_epoch());\n+\treturn __detail::__get_leap_second_info(sys_seconds(__s), true);\n+      }\n \n-\t    auto __pos = std::upper_bound(__first, __last, __s);\n-\t    return {\n-\t      __pos != begin(__leaps) && __pos[-1] == __s,\n-\t      seconds{__pos - __first}\n-\t    };\n-\t  }\n-\telse\n-\t  {\n-\t    auto __s = chrono::time_point_cast<seconds>(__ut);\n-\t    return chrono::get_leap_second_info(__s);\n-\t  }\n+    template<typename _Duration>\n+      [[nodiscard]]\n+      inline utc_time<common_type_t<_Duration, seconds>>\n+      utc_clock::from_sys(const sys_time<_Duration>& __t)\n+      {\n+\tusing _CDur = common_type_t<_Duration, seconds>;\n+\tauto __s = chrono::time_point_cast<seconds>(__t);\n+\tconst auto __li = __detail::__get_leap_second_info(__s, false);\n+\treturn utc_time<_CDur>{__t.time_since_epoch()} + __li.elapsed;\n       }\n \n     /// @} group chrono"}, {"sha": "c1a9896b0c228fffbbbd7465420bbdf636a0397f", "filename": "libstdc++-v3/include/std/version", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fversion?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -251,6 +251,8 @@\n #  define __cpp_lib_barrier 201907L\n # endif\n #endif\n+// #undef __cpp_lib_chrono\n+// #define __cpp_lib_chrono 201907L\n // FIXME: #define __cpp_lib_execution 201902L\n #define __cpp_lib_constexpr_algorithms 201806L\n #ifdef __cpp_lib_is_constant_evaluated"}, {"sha": "a95b8c24d2108c843925df88ed78e5025b7a8e7f", "filename": "libstdc++-v3/src/c++20/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2FMakefile.am?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -36,7 +36,7 @@ else\n inst_sources =\n endif\n \n-sources =\n+sources = tzdb.cc\n \n vpath % $(top_srcdir)/src/c++20\n "}, {"sha": "2adc1eb712ea27473acfd18e786254c8fd45bf5d", "filename": "libstdc++-v3/src/c++20/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2FMakefile.in?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -121,7 +121,7 @@ CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n libc__20convenience_la_LIBADD =\n-am__objects_1 =\n+am__objects_1 = tzdb.lo\n @ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_2 = sstream-inst.lo\n am_libc__20convenience_la_OBJECTS = $(am__objects_1) $(am__objects_2)\n libc__20convenience_la_OBJECTS = $(am_libc__20convenience_la_OBJECTS)\n@@ -431,7 +431,7 @@ headers =\n @ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \\\n @ENABLE_EXTERN_TEMPLATE_TRUE@\tsstream-inst.cc\n \n-sources = \n+sources = tzdb.cc\n libc__20convenience_la_SOURCES = $(sources)  $(inst_sources)\n \n # AM_CXXFLAGS needs to be in each subdirectory so that it can be"}, {"sha": "dcff021d9d49557989cfa0cb34db70348acefb85", "filename": "libstdc++-v3/src/c++20/tzdb.cc", "status": "added", "additions": 1806, "deletions": 0, "changes": 1806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B20%2Ftzdb.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,1806 @@\n+// chrono::tzdb -*- C++ -*-\n+\n+// Copyright The GNU Toolchain Authors\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+// The -Wabi warnings in this file are all for non-exported symbols.\n+#pragma GCC diagnostic ignored \"-Wabi\"\n+\n+#include <chrono>\n+#include <fstream>    // ifstream\n+#include <sstream>    // istringstream\n+#include <algorithm>  // ranges::upper_bound, ranges::lower_bound, ranges::sort\n+#include <atomic>     // atomic<T*>, atomic<int_least32_t>\n+#include <memory>     // atomic<shared_ptr<T>>\n+#include <mutex>      // mutex\n+#include <filesystem> // filesystem::read_symlink\n+\n+#ifdef __GTHREADS\n+# if _WIN32\n+// std::mutex cannot be constinit, so Windows must use atomic<shared_ptr<>>.\n+#  define USE_ATOMIC_SHARED_PTR 1\n+# else\n+// TODO benchmark atomic<shared_ptr<>> vs mutex.\n+#  define USE_ATOMIC_SHARED_PTR 1\n+# endif\n+#endif\n+\n+#if ! __cpp_constinit\n+# if __has_cpp_attribute(clang::require_constant_initialization)\n+#  define constinit [[clang::require_constant_initialization]]\n+#else // YOLO\n+# define constinit\n+# endif\n+#endif\n+\n+namespace __gnu_cxx\n+{\n+#ifdef _AIX\n+  // Cannot override weak symbols on AIX.\n+  const char* (*zoneinfo_dir_override)() = nullptr;\n+#else\n+  [[gnu::weak]] const char* zoneinfo_dir_override();\n+#endif\n+}\n+\n+namespace std::chrono\n+{\n+  namespace\n+  {\n+    struct Rule;\n+  }\n+\n+  // The tzdb list is a singly-linked list of _Node objects, using shared_ptr\n+  // for the links. Iterators into the list share ownership of the nodes.\n+  // Each _Node contains a tzdb and a vector<Rule> with the rule set.\n+  struct tzdb_list::_Node\n+  {\n+    shared_ptr<_Node> next;\n+    tzdb db;\n+    vector<Rule> rules;\n+\n+    // The following static members are here because making them members\n+    // of this type gives them access to the private members of time_zone\n+    // and tzdb, without needing them declared in the <chrono> header.\n+\n+    static tzdb_list _S_the_list;\n+\n+#if USE_ATOMIC_SHARED_PTR\n+    using head_ptr = atomic<shared_ptr<_Node>>;\n+#else\n+    // Non-atomic, list_mutex must be locked to access it.\n+    using head_ptr = shared_ptr<_Node>;\n+#endif\n+    // This is the owning reference to the first tzdb in the list.\n+    static head_ptr _S_head_owner;\n+\n+    // Lock-free access to the head of the list.\n+    static atomic<_Node*> _S_head;\n+\n+    static const tzdb& _S_init_tzdb();\n+    static const tzdb& _S_replace_head(shared_ptr<_Node>, shared_ptr<_Node>);\n+\n+    static pair<vector<leap_second>, bool> _S_read_leap_seconds();\n+  };\n+\n+  // Implementation of the private constructor used for the singleton object.\n+  constexpr tzdb_list::tzdb_list(nullptr_t) { }\n+\n+  // The tzdb_list singleton. This doesn't contain the actual linked list,\n+  // but it has member functions that give access to it.\n+  constinit tzdb_list tzdb_list::_Node::_S_the_list(nullptr);\n+\n+  // Shared pointer to the first Node in the list.\n+  constinit tzdb_list::_Node::head_ptr tzdb_list::_Node::_S_head_owner{nullptr};\n+\n+  // Lock-free access to the first Node in the list.\n+  constinit atomic<tzdb_list::_Node*> tzdb_list::_Node::_S_head{nullptr};\n+\n+  // The data structures defined in this file (Rule, on_day, at_time etc.)\n+  // are used to represent the information parsed from the tzdata.zi file\n+  // described at https://man7.org/linux/man-pages/man8/zic.8.html#FILES\n+\n+  // N.B. Most stream extraction operations for time zones, rules etc.\n+  // assume that setting failbit will throw an exception, so individual\n+  // input operations are not always checked for success.\n+\n+  namespace\n+  {\n+#if ! USE_ATOMIC_SHARED_PTR\n+#ifndef __GTHREADS\n+    // Dummy no-op mutex type for single-threaded targets.\n+    struct mutex { void lock() { } void unlock() { } };\n+#endif\n+    /// XXX std::mutex::mutex() not constexpr on Windows, so can't be constinit\n+    constinit mutex list_mutex;\n+#endif\n+\n+    // Used for reading a possibly-quoted string from a stream.\n+    struct quoted\n+    {\n+      string& str;\n+\n+      friend istream& operator>>(istream& in, quoted&& q)\n+      {\n+\tif (ws(in).peek() == '\"')\n+\t  in >> std::quoted(q.str);\n+\telse\n+\t  in >> q.str;\n+\treturn in;\n+      }\n+    };\n+\n+    // 32-bit version of chrono::seconds for offsets in the range [-24h,24h].\n+    // Care must be taken to avoid overflow when using this in arithmetic.\n+    // For example, if sys_days::rep is also 32-bit then the result of\n+    // sys_days(1850y/January/1) + sec32_t(0) will be incorrect.\n+    using sec32_t = duration<int_least32_t>;\n+\n+    // A time relative to midnight, as measured by the indicator clock.\n+    struct at_time\n+    {\n+      sec32_t time{};\n+      enum Indicator : unsigned char { Wall, Universal, Standard, Daylight };\n+      Indicator indicator = Wall;\n+\n+      static pair<Indicator, bool> is_indicator(int c) noexcept\n+      {\n+\tswitch (c)\n+\t{\n+\t  case 's':\n+\t    return {Standard, true};\n+\t  case 'u':\n+\t  case 'g':\n+\t  case 'z':\n+\t    return {Universal, true};\n+\t  case 'w':\n+\t    return {Wall, true};\n+\t  case 'd':\n+\t    return {Daylight, true};\n+\t  default:\n+\t    return {Wall, false};\n+\t}\n+      }\n+\n+      // Checks if the next character in the stream is an indicator.\n+      // If not, indic is unchanged. Callers should set a default first.\n+      friend istream& operator>>(istream& in, Indicator& indic)\n+      {\n+\tauto [val, yes] = at_time::is_indicator(in.peek());\n+\tif (yes)\n+\t  {\n+\t    in.ignore(1);\n+\t    indic = val;\n+\t  }\n+\treturn in;\n+      }\n+\n+      friend istream& operator>>(istream& in, at_time& at);\n+    };\n+\n+    // Wrapper for chrono::month that can be extracted from an istream\n+    // as an abbreviated month name.\n+    // The month name can be any unambiguous portion of a month name,\n+    // e.g. \"S\" (September) or \"Ja\" (January), but not \"Ju\" (June/July).\n+    struct abbrev_month\n+    {\n+      month m;\n+\n+      friend istream& operator>>(istream& in, abbrev_month& am);\n+    };\n+\n+    // The IN and ON fields of a RULE record, e.g. \"March lastSunday\".\n+    struct on_day\n+    {\n+      using rep = uint_least16_t;\n+      // Equivalent to Kind, chrono::month, chrono::day, chrono::weekday,\n+      // but half the size.\n+      enum Kind : rep { DayOfMonth=0, LastWeekday, LessEq, GreaterEq };\n+      Kind kind : 2 = DayOfMonth;\n+      rep month : 4 = 0;        // [1,12]\n+      rep day_of_month : 5 = 0; // [1,31]\n+      rep day_of_week : 3 = 0;  // [0,6]\n+\n+      chrono::month\n+      get_month() const noexcept\n+      { return chrono::month{month}; }\n+\n+      chrono::day\n+      get_day() const noexcept\n+      { return chrono::day{day_of_month}; }\n+\n+      chrono::month_day\n+      get_month_day() const noexcept\n+      { return chrono::month_day{get_month(), get_day()}; }\n+\n+      bool ok() const noexcept\n+      {\n+\tswitch (kind)\n+\t{\n+\tcase DayOfMonth:\n+\t  return day_of_month != 0;\n+\tcase LastWeekday:\n+\t  return day_of_week != 7 && day_of_month == 0;\n+\tcase LessEq:\n+\tcase GreaterEq:\n+\t  return day_of_week != 7 && day_of_month != 0;\n+\t}\n+      }\n+\n+      // Convert date like \"last Sunday in June\" or \"Sunday <= June 30\"\n+      // to a specific date in the given year.\n+      year_month_day pin(year y) const\n+      {\n+\tyear_month_day ymd;\n+\tif (kind == LastWeekday) // Last Sunday in June\n+\t  {\n+\t    month_weekday_last mwdl{get_month(),\n+\t\t\t\t    weekday_last{weekday{day_of_week}}};\n+\t    ymd = year_month_day{sys_days{y/mwdl}};\n+\t  }\n+\telse if (kind != DayOfMonth) // Sunday <= June 30 or Sunday >= June 30\n+\t  {\n+\t    sys_days date{y/get_month_day()};\n+\t    days diff;\n+\t    if (kind == LessEq)\n+\t      diff = -(weekday{date} - weekday{day_of_week});\n+\t    else\n+\t      diff = weekday{day_of_week} - weekday{date};\n+\t    // XXX need to handle underflow/overflow to another year?\n+\t    ymd = year_month_day{date + diff};\n+\t  }\n+\telse\n+\t  ymd = year_month_day{y, get_month(), get_day()};\n+\treturn ymd;\n+      }\n+\n+      friend istream& operator>>(istream&, on_day&);\n+    };\n+\n+    // Wrapper for chrono::year that reads a year, or one of the keywords\n+    // \"minimum\" or \"maximum\", or an unambiguous prefix of a keyword.\n+    struct minmax_year\n+    {\n+      year& y;\n+\n+      friend istream& operator>>(istream& in, minmax_year&& y)\n+      {\n+\tif (ws(in).peek() == 'm') // keywords \"minimum\" or \"maximum\"\n+\t  {\n+\t    string s;\n+\t    in >> s; // extract the rest of the word, but only look at s[1]\n+\t    if (s[1] == 'a')\n+\t      y.y = year::max();\n+\t    else if (s[1] == 'i')\n+\t      y.y = year::min();\n+\t    else\n+\t      in.setstate(ios::failbit);\n+\t  }\n+\telse if (int num = 0; in >> num)\n+\t  y.y = year{num};\n+\treturn in;\n+      }\n+    };\n+\n+    // As above for minmax_year, but also supports the keyword \"only\",\n+    // meaning that the TO year is the same as the FROM year.\n+    struct minmax_year2\n+    {\n+      minmax_year to;\n+      year from;\n+\n+      friend istream& operator>>(istream& in, minmax_year2&& y)\n+      {\n+\tif (ws(in).peek() == 'o') // keyword \"only\"\n+\t  {\n+\t    string s;\n+\t    in >> s; // extract the whole keyword\n+\t    y.to.y = y.from;\n+\t  }\n+\telse\n+\t  in >> std::move(y.to);\n+\treturn in;\n+      }\n+    };\n+\n+    // A time zone information record.\n+    // Zone  NAME        STDOFF  RULES   FORMAT  [UNTIL]\n+    // Zone  Asia/Amman  2:00    Jordan  EE%sT   2017 Oct 27 01:00\n+    // Will be lazily expanded into sys_info objects as needed.\n+    struct ZoneInfo\n+    {\n+      ZoneInfo() = default;\n+\n+      ZoneInfo(sys_info&& info)\n+      : m_buf(std::move(info.abbrev)), m_expanded(true), m_save(info.save),\n+\tm_offset(info.offset), m_until(info.end)\n+      { }\n+\n+      ZoneInfo(const pair<sys_info, string_view>& info)\n+      : m_expanded(true), m_save(info.first.save), m_offset(info.first.offset),\n+\tm_until(info.first.end)\n+      {\n+\tif (info.second.size())\n+\t  {\n+\t    m_buf = info.second; // LETTERS field\n+\t    m_buf += ' ';\n+\t    m_pos = m_buf.size();\n+\t  }\n+\tm_buf += info.first.abbrev;\n+      }\n+\n+      // STDOFF: Seconds from UTC during standard time.\n+      seconds\n+      offset() const noexcept { return m_offset; }\n+\n+      // RULES: The name of the rules that apply for this period.\n+      string_view\n+      rules() const noexcept\n+      {\n+\tstring_view r;\n+\tif (m_pos != 0)\n+\t  r = {m_buf.data(), m_pos - 1u};\n+\treturn r;\n+      }\n+\n+      // FORMAT: The name of the time zone (might contain %s or %z).\n+      string_view\n+      format() const noexcept\n+      { return {m_buf.data() + m_pos, m_buf.size() - m_pos}; }\n+\n+      // UNTIL: The time when this info no longer applies.\n+      sys_seconds\n+      until() const noexcept { return m_until; }\n+\n+      friend istream& operator>>(istream&, ZoneInfo&);\n+\n+      bool\n+      expanded() const noexcept\n+      { return m_expanded; }\n+\n+      // For an expanded ZoneInfo this returns the LETTERS that apply to the\n+      // **next** sys_info after this one.\n+      string_view\n+      next_letters() const noexcept\n+      { return m_expanded ? rules() : string_view{}; }\n+\n+\n+      bool\n+      to(sys_info& info) const\n+      {\n+\t// If this object references a named Rule then we can't populate\n+\t// a sys_info yet.\n+\tif (!m_expanded)\n+\t  return false;\n+\n+\tinfo.end = until();\n+\tinfo.offset = offset();\n+\tinfo.save = minutes(m_save);\n+\tinfo.abbrev = format();\n+\treturn true;\n+      }\n+\n+    private:\n+      friend class time_zone;\n+\n+      void\n+      set_abbrev(const string& abbrev)\n+      {\n+\t// In practice, the FORMAT field never needs expanding here.\n+\tif (abbrev.find_first_of(\"/%\") != abbrev.npos)\n+\t  __throw_runtime_error(\"std::chrono::time_zone: invalid data\");\n+\tm_buf = abbrev;\n+\tm_pos = 0;\n+\tm_expanded = true;\n+      }\n+\n+      void\n+      set_rules_and_format(const string& rls, const string& fmt)\n+      {\n+\t// Both strings are typically short enough to fit in one SSO string.\n+\t// As of tzdata 2022f the maximum is 14 chars, e.g. \"AU +0845/+0945\".\n+\tm_buf.reserve(rls.size() + 1 + fmt.size());\n+\tm_buf = rls;\n+\tm_buf += ' ';\n+\tm_buf += fmt;\n+\tm_pos = rls.size() + 1;\n+      }\n+\n+      string m_buf;     // rules() + ' ' + format() OR letters + ' ' + format()\n+      uint_least16_t m_pos : 15 = 0; // offset of format() in m_buf\n+      uint_least16_t m_expanded : 1 = 0;\n+      duration<int_least16_t, ratio<60>> m_save{};\n+      sec32_t m_offset{};\n+      sys_seconds m_until{};\n+\n+#if 0\n+      // Consider making this class more compact, e.g.\n+      int_least64_t offset_seconds : 18;\n+      int_least64_t until_sys_seconds : 46;\n+      uint_least32_t save_minutes : 12;\n+      uint_least32_t pos : 20;\n+      string buf; // abbrev OR \"rules format\"\n+#endif\n+    };\n+\n+    // A RULE record from the tzdata.zi timezone info file.\n+    struct Rule\n+    {\n+      // This allows on_day to reuse padding of at_time.\n+      // This keeps the size to 8 bytes and the alignment to 4 bytes.\n+      struct datetime : at_time { on_day day; };\n+      static_assert(sizeof(datetime) == 8 && alignof(datetime) == 4);\n+\n+      // TODO combining name+letters into a single string (like in ZoneInfo)\n+      // would save sizeof(string) and make Rule fit in a single cacheline.\n+      // Or don't store name in the Rule, and replace vector<Rule> with\n+      // vector<pair<string,vector<Rule>>> i.e. map-like structure.\n+\n+      string name;    // the name of the rule set\n+      year from{};    // first year in which the rule applies\n+      year to{};      // final year in which the rule applies\n+      datetime when;  // the day and time on which the rule takes effect\n+      sec32_t save{}; // amount of time to be added when the rule is in effect\n+      string letters; // variable part of TZ abbreviations when rule in effect\n+\n+      // Combine y + this->when + offset to give a UTC timestamp.\n+      sys_seconds\n+      start_time(year y, seconds offset) const\n+      {\n+\tauto time = when.time;\n+\tif (when.indicator == at_time::Wall\n+\t      || when.indicator == at_time::Standard)\n+\t  time -= offset; // Convert local time to sys time.\n+\treturn sys_days(when.day.pin(y)) + time;\n+      }\n+\n+      friend istream& operator>>(istream& in, Rule& rule)\n+      {\n+\tstring str;\n+\n+\t// Rule  NAME  FROM  TO  TYPE  IN  ON  AT  SAVE  LETTER/S\n+\n+\tin >> quoted(rule.name)\n+\t   >> minmax_year{rule.from}\n+\t   >> minmax_year2{rule.to, rule.from};\n+\n+\tif (char type; in >> type && type != '-')\n+\t  in.setstate(ios::failbit);\n+\tin >> rule.when.day >> static_cast<at_time&>(rule.when);\n+\tat_time save_time;\n+\tsave_time.indicator = at_time::Wall; // not valid for this field\n+\tin >> save_time;\n+\tif (save_time.indicator != at_time::Wall)\n+\t  {\n+\t    // We don't actually store the save_time.indicator, because we\n+\t    // assume that it's always deducable from the actual offset value.\n+\t    auto expected = save_time.time == 0s\n+\t\t\t      ? at_time::Standard\n+\t\t\t      : at_time::Daylight;\n+\t    __glibcxx_assert(save_time.indicator == expected);\n+\t  }\n+\n+\trule.save = save_time.time;\n+\n+\tin >> rule.letters;\n+\tif (rule.letters == \"-\")\n+\t  rule.letters.clear();\n+\treturn in;\n+      }\n+\n+#ifdef _GLIBCXX_ASSERTIONS\n+      friend ostream& operator<<(ostream& out, const Rule& r)\n+      {\n+\tout << \"Rule \" << r.name << ' ' << (int)r.from << ' ' << (int)r.to\n+\t    << ' ' << (unsigned)r.when.day.get_month() << ' ';\n+\tswitch (r.when.day.kind)\n+\t{\n+\tcase on_day::DayOfMonth:\n+\t  out << (unsigned)r.when.day.get_day();\n+\t  break;\n+\tcase on_day::LastWeekday:\n+\t  out << \"last\" << weekday(r.when.day.day_of_week).c_encoding();\n+\t  break;\n+\tcase on_day::LessEq:\n+\t  out << weekday(r.when.day.day_of_week).c_encoding() << \" <= \"\n+\t    << r.when.day.day_of_month;\n+\t  break;\n+\tcase on_day::GreaterEq:\n+\t  out << weekday(r.when.day.day_of_week).c_encoding() << \" >= \"\n+\t    << r.when.day.day_of_month;\n+\t  break;\n+\t}\n+\thh_mm_ss hms(r.when.time);\n+\tout << ' ' << hms.hours().count() << ':' << hms.minutes().count()\n+\t    << ':' << hms.seconds().count() << \"wusd\"[r.when.indicator];\n+\tout << ' ' << r.save.count();\n+\tif (!r.letters.empty())\n+\t  out << ' ' << r.letters;\n+\telse\n+\t  out << \" -\";\n+\treturn out;\n+      }\n+#endif\n+    };\n+  } // namespace\n+\n+  // Private constructor used by reload_tzdb() to create time_zone objects.\n+  time_zone::time_zone(unique_ptr<_Impl> __p) : _M_impl(std::move(__p)) { }\n+\n+  time_zone::~time_zone() = default;\n+\n+  // The opaque pimpl class stored in a time_zone object.\n+  struct time_zone::_Impl\n+  {\n+    explicit\n+    _Impl(weak_ptr<tzdb_list::_Node> node) : node(std::move(node)) { }\n+\n+    vector<ZoneInfo> infos; // Definitions of the time zone's transitions.\n+\n+    // Non-owning reference back to the tzdb that owns this time_zone.\n+    // Needed to access the list of rules for the time zones.\n+    weak_ptr<tzdb_list::_Node> node;\n+\n+#ifndef __GTHREADS\n+    // Don't need synchronization for accessing the infos vector.\n+#elif __cpp_lib_atomic_wait\n+    atomic<int_least32_t> rules_counter;\n+#else\n+    mutex infos_mutex;\n+#endif\n+  };\n+\n+  namespace\n+  {\n+    bool\n+    select_std_or_dst_abbrev(string& abbrev, minutes save)\n+    {\n+      if (size_t pos = abbrev.find('/'); pos != string::npos)\n+\t{\n+\t  // Select one of \"STD/DST\" for standard or daylight.\n+\t  if (save == 0min)\n+\t    abbrev.erase(pos);\n+\t  else\n+\t    abbrev.erase(0, pos + 1);\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+    // Set the sys_info::abbrev string by expanding any placeholders.\n+    void\n+    format_abbrev_str(sys_info& info, string_view letters = {})\n+    {\n+      if (size_t pos = info.abbrev.find(\"%s\"); pos != string::npos)\n+\t{\n+\t  // Expand \"%s\" to the variable part, given by Rule::letters.\n+\t  info.abbrev.replace(pos, 2, letters);\n+\t}\n+      else if (size_t pos = info.abbrev.find(\"%z\"); pos != string::npos)\n+\t{\n+\t  // Expand \"%z\" to the UT offset as +/-hh, +/-hhmm, or +/-hhmmss.\n+\t  hh_mm_ss<seconds> t(info.offset);\n+\t  string z(1, \"+-\"[t.is_negative()]);\n+\t  long val = t.hours().count();\n+\t  if (minutes m = t.minutes(); m != m.zero())\n+\t    {\n+\t      val *= 100;\n+\t      val += m.count();\n+\t      if (seconds s = t.seconds(); s != s.zero())\n+\t\t{\n+\t\t  val *= 100;\n+\t\t  val += s.count();\n+\t\t}\n+\t    }\n+\t  z += std::to_string(val);\n+\t  info.abbrev.replace(pos, 2, z);\n+\t}\n+      else\n+\tselect_std_or_dst_abbrev(info.abbrev, info.save);\n+    }\n+  }\n+\n+  // Implementation of std::chrono::time_zone::get_info(const sys_time<D>&)\n+  sys_info\n+  time_zone::_M_get_sys_info(sys_seconds tp) const\n+  {\n+    // This gives us access to the node->rules vector, but also ensures\n+    // that the tzdb node won't get erased while we're still using it.\n+    const auto node = _M_impl->node.lock();\n+    auto& infos = _M_impl->infos;\n+\n+#ifndef __GTHREADS\n+#elif __cpp_lib_atomic_wait\n+    // Prevent concurrent access to _M_impl->infos if it might need to change.\n+    struct Lock\n+    {\n+      Lock(atomic<int_least32_t>& counter) : counter(counter)\n+      {\n+\t// If counter is non-zero then the contents of _M_impl->info might\n+\t// need to be changed, so only one thread is allowed to access it.\n+\tfor (auto c = counter.load(memory_order::relaxed); c != 0;)\n+\t  {\n+\t    // Setting counter to negative means this thread has the lock.\n+\t    if (c > 0 && counter.compare_exchange_strong(c, -c))\n+\t      return;\n+\n+\t    if (c < 0)\n+\t      {\n+\t\t// Counter is negative, another thread already has the lock.\n+\t\tcounter.wait(c);\n+\t\tc = counter.load();\n+\t      }\n+\t  }\n+      }\n+\n+      ~Lock()\n+      {\n+\tif (auto c = counter.load(memory_order::relaxed); c < 0)\n+\t  {\n+\t    counter.store(-c, memory_order::release);\n+\t    counter.notify_one();\n+\t  }\n+      }\n+\n+      atomic<int_least32_t>& counter;\n+    };\n+    Lock lock{_M_impl->rules_counter};\n+#else\n+    // Keep it simple, just use a mutex for all access.\n+    lock_guard<mutex> lock(_M_impl->infos_mutex);\n+#endif\n+\n+    // Find the transition info for the time point.\n+    auto i = ranges::upper_bound(infos, tp, ranges::less{}, &ZoneInfo::until);\n+\n+    if (i == infos.end())\n+      {\n+\tif (infos.empty())\n+\t  __throw_runtime_error(\"std::chrono::time_zone::get_info: invalid data\");\n+\ttp = (--i)->until();\n+    }\n+\n+    sys_info info;\n+\n+    if (i == infos.begin())\n+      info.begin = sys_days(year::min()/January/1);\n+    else\n+      info.begin = i[-1].until();\n+\n+    if (i->to(info)) // We already know a sys_info for this time.\n+      return info;\n+\n+    // Otherwise, we have a ZoneInfo object that describes the applicable\n+    // transitions in terms of a set of named rules that vary by year.\n+    // Replace that rules-based ZoneInfo object with a sequence of one or more\n+    // objects that map directly to a sys_info value.\n+    const ZoneInfo& ri = *i;\n+\n+    // Find the rules named by ri.rules()\n+    auto rules = ranges::equal_range(node->rules, ri.rules(),\n+\t\t\t\t     ranges::less{}, &Rule::name);\n+\n+    if (ranges::empty(rules))\n+      __throw_runtime_error(\"std::chrono::time_zone::get_info: invalid data\");\n+\n+    vector<pair<sys_info, string_view>> new_infos;\n+    if (int n = ceil<years>(tp - info.begin).count())\n+      new_infos.reserve(std::min(100, n * 2));\n+    long result_index = -1;\n+    int num_after = 4; // number of sys_info to generate past tp.\n+\n+    // The following initial values for info.offset, info.save, and letters\n+    // are only valid if the first sys_info we are generating uses the time\n+    // zone's standard time, because daylight time would need non-zero offset.\n+    // This is true by construction, because this function always tries to\n+    // finish so that the last ZoneInfo object expanded is for daylight time.\n+    // This means that i[-1] is either an expanded ZoneInfo for a DST sys_info\n+    // or is an unexpanded (rule-based) ZoneInfo for a different rule, and\n+    // rule changes always occur between periods of standard time.\n+    info.offset = ri.offset();\n+    info.save = 0min;\n+    // XXX The ri.until() time point should be\n+    // \"interpreted using the rules in effect just before the transition\"\n+    info.end = ri.until();\n+    info.abbrev = ri.format();\n+\n+    string_view letters;\n+    if (i != infos.begin())\n+      {\n+\tif (i[-1].expanded())\n+\t  letters = i[-1].next_letters();\n+\t// XXX else need to find Rule active before this time and use it\n+\t// to know the initial offset, save, and letters.\n+      }\n+\n+    const Rule* curr_rule = nullptr;\n+\n+    while (info.begin < info.end && num_after > 0)\n+      {\n+\tsys_seconds t = info.begin;\n+\tconst year_month_day date(chrono::floor<days>(t));\n+\tconst Rule* next_rule = nullptr;\n+\n+\t// Check every rule to find the next transition after t.\n+\tfor (const auto& rule : rules)\n+\t  {\n+\t    if (&rule == curr_rule) // don't bother checking this one again\n+\t      continue;\n+\n+\t    if (date.year() > rule.to) // rule no longer applies at time t\n+\t      continue;\n+\n+\t    sys_seconds rule_start;\n+\n+\t    seconds offset{}; // appropriate for at_time::Universal\n+\t    if (rule.when.indicator == at_time::Wall)\n+\t      offset = info.offset;\n+\t    else if (rule.when.indicator == at_time::Standard)\n+\t      offset = ri.offset();\n+\n+\t    if (date.year() < rule.from) // rule doesn't apply yet at time t\n+\t      {\n+\t\t// Find first transition for this rule:\n+\t\trule_start = rule.start_time(rule.from, offset);\n+\t      }\n+\t    else // rule applies in the year that contains time t\n+\t      {\n+\t\tyear y = date.year();\n+\t\t// Time the rule takes effect this year:\n+\t\trule_start = rule.start_time(y, offset);\n+\n+\t\tif (rule_start < t && rule.to > y)\n+\t\t  {\n+\t\t    // Try this rule in the following year.\n+\t\t    rule_start = rule.start_time(++y, offset);\n+\t\t  }\n+\t      }\n+\n+\t    if (t < rule_start && rule_start < info.end)\n+\t      {\n+\t\tif (rule_start - t < days(1)) // XXX shouldn't be needed!\n+\t\t  continue;\n+\n+\t\t// Found a closer transition than the previous info.end.\n+\t\tinfo.end = rule_start;\n+\t\tnext_rule = &rule;\n+\t      }\n+\t  }\n+\n+\tformat_abbrev_str(info, letters);\n+\n+\tbool merged = false;\n+#if 0\n+\tif (!new_infos.empty())\n+\t  {\n+\t    auto& back = new_infos.back();\n+\t    if (back.offset == info.offset && back.abbrev == info.abbrev\n+\t\t  && back.save == info.save)\n+\t      {\n+\t\t// This is a continuation of the previous sys_info.\n+\t\tback.end = info.end;\n+\t\tmerged = true;\n+\t      }\n+\t  }\n+#endif\n+\n+\tif (next_rule)\n+\t  letters = next_rule->letters;\n+\telse\n+\t  letters = {};\n+\n+\tif (!merged)\n+\t  new_infos.emplace_back(info, letters);\n+\n+\tif (info.begin <= tp && tp < info.end) // Found the result.\n+\t  result_index = new_infos.size() - 1;\n+\telse if (result_index >= 0 && !merged)\n+\t  {\n+\t    // Finish on a DST sys_info if possible, so that if we resume\n+\t    // generating sys_info objects after this time point, save=0\n+\t    // should be correct for the next sys_info.\n+\t    if (num_after > 1 || info.save != 0min)\n+\t      --num_after;\n+\t  }\n+\n+\tinfo.begin = info.end;\n+\tif (next_rule)\n+\t  {\n+\t    info.end = ri.until();\n+\t    info.offset = ri.offset() + next_rule->save;\n+\t    info.save = duration_cast<minutes>(next_rule->save);\n+\t    info.abbrev = ri.format();\n+\t    letters = next_rule->letters;\n+\t    curr_rule = next_rule;\n+\t  }\n+      }\n+\n+    if (new_infos.empty() || result_index < 0)\n+      __throw_runtime_error(\"time_zone::get_info\");\n+\n+    info = new_infos[result_index].first;\n+\n+    if (new_infos.back().first.end < ri.until())\n+      {\n+\t// Insert the new sys_info objects but don't remove the rules_info.\n+\tinfos.insert(i, new_infos.begin(), new_infos.end());\n+      }\n+    else\n+      {\n+\t// Replace the rules_info at *i with the sys_info objects in new_infos.\n+\n+\t// First note the index of *i because we will invalidate i.\n+\tresult_index = i - infos.begin();\n+\t// Insert everything except new_infos.front() at the end of infos:\n+\ti = infos.insert(infos.end(), new_infos.begin() + 1, new_infos.end());\n+\t// Then rotate those new elements into place:\n+\tstd::rotate(infos.begin() + result_index + 1, i, infos.end());\n+\t// Then replace the original rules_info object with new_infos.front():\n+\tinfos[result_index] = ZoneInfo(new_infos.front());\n+#if defined __GTHREADS && __cpp_lib_atomic_wait\n+\tif (++_M_impl->rules_counter == 0) // No more unexpanded infos.\n+\t  _M_impl->rules_counter.notify_all();\n+#endif\n+      }\n+\n+    return info;\n+  }\n+\n+  // Implementation of std::chrono::time_zone::get_info(const local_time<D>&)\n+  local_info\n+  time_zone::_M_get_local_info(local_seconds tp) const\n+  {\n+    const auto node = _M_impl->node.lock();\n+\n+    local_info info{};\n+    // Get sys_info assuming no offset between local time and UTC:\n+    info.first = _M_get_sys_info(sys_seconds(tp.time_since_epoch()));\n+\n+    // Convert to UTC using the real offset:\n+    sys_seconds st(tp.time_since_epoch() - info.first.offset);\n+\n+    if ((st - info.first.begin) <= days(1))\n+      {\n+\tsys_info prev = _M_get_sys_info(info.first.begin - 1s);\n+\tsys_seconds prevst(tp.time_since_epoch() - prev.offset);\n+\tif (st < info.first.begin)\n+\t  {\n+\t    if (prevst < info.first.begin)\n+\t      {\n+\t\t// tp is a unique local time, prev is the correct sys_info.\n+\t\tinfo.first = prev;\n+\t      }\n+\t    else\n+\t      {\n+\t\t// The local time is nonexistent, falling within a clock change\n+\t\t// e.g. there is no 1:30am if DST moves clock from 1am to 2am.\n+\t\t__glibcxx_assert(prev.offset < info.first.offset); // start DST\n+\t\tinfo.result = local_info::nonexistent;\n+\t\tinfo.second = info.first;\n+\t\tinfo.first = prev;\n+\t      }\n+\t  }\n+\telse if (prevst < info.first.begin)\n+\t  {\n+\t    // The local time is ambiguous, referring to two possible UTC times\n+\t    // e.g. 1:30am happens twice if clock moves back from 2am to 1am.\n+\t    __glibcxx_assert(prev.offset > info.first.offset); // DST ended\n+\t    info.result = local_info::ambiguous;\n+\t    info.second = info.first;\n+\t    info.first = prev;\n+\t  }\n+\t// else tp is a unique local time, info.first is the correct sys_info.\n+      }\n+    else if ((info.first.end - st) <= days(1))\n+      {\n+\tsys_info next = _M_get_sys_info(info.first.end);\n+\tsys_seconds nextst(tp.time_since_epoch() - next.offset);\n+\tif (st >= info.first.end)\n+\t  {\n+\t    if (nextst >= info.first.end)\n+\t      {\n+\t\t// tp is a unique local time, next is the correct sys_info.\n+\t\tinfo.first = next;\n+\t      }\n+\t    else\n+\t      {\n+\t\tinfo.result = local_info::nonexistent;\n+\t\tinfo.second = next;\n+\t      }\n+\t  }\n+\telse if (nextst >= info.first.end)\n+\t  {\n+\t    info.result = local_info::ambiguous;\n+\t    info.second = next;\n+\t  }\n+\t// else tp is a unique local time, info.first is the correct sys_info.\n+      }\n+    return info;\n+  }\n+\n+#ifndef _GLIBCXX_ZONEINFO_DIR\n+# define _GLIBCXX_ZONEINFO_DIR \"/usr/share/zoneinfo\"\n+#endif\n+ namespace\n+ {\n+    string\n+    zoneinfo_dir()\n+    {\n+      static const string dir = __gnu_cxx::zoneinfo_dir_override\n+\t\t\t\t  ? __gnu_cxx::zoneinfo_dir_override()\n+\t\t\t\t  : _GLIBCXX_ZONEINFO_DIR;\n+      return dir;\n+    }\n+\n+    const string tzdata_file = \"/tzdata.zi\";\n+    const string leaps_file = \"/leapseconds\";\n+  }\n+\n+  // Return leap_second values, and a bool indicating whether the values are\n+  // current (true), or potentially out of date (false).\n+  pair<vector<leap_second>, bool>\n+  tzdb_list::_Node::_S_read_leap_seconds()\n+  {\n+    const string filename = zoneinfo_dir() + leaps_file;\n+\n+    // This list is valid until at least 2023-06-28 00:00:00 UTC.\n+    auto expires = sys_days{2023y/6/28};\n+    vector<leap_second> leaps\n+    {\n+      (leap_second)  78796800, // 1 Jul 1972\n+      (leap_second)  94694400, // 1 Jan 1973\n+      (leap_second) 126230400, // 1 Jan 1974\n+      (leap_second) 157766400, // 1 Jan 1975\n+      (leap_second) 189302400, // 1 Jan 1976\n+      (leap_second) 220924800, // 1 Jan 1977\n+      (leap_second) 252460800, // 1 Jan 1978\n+      (leap_second) 283996800, // 1 Jan 1979\n+      (leap_second) 315532800, // 1 Jan 1980\n+      (leap_second) 362793600, // 1 Jul 1981\n+      (leap_second) 394329600, // 1 Jul 1982\n+      (leap_second) 425865600, // 1 Jul 1983\n+      (leap_second) 489024000, // 1 Jul 1985\n+      (leap_second) 567993600, // 1 Jan 1988\n+      (leap_second) 631152000, // 1 Jan 1990\n+      (leap_second) 662688000, // 1 Jan 1991\n+      (leap_second) 709948800, // 1 Jul 1992\n+      (leap_second) 741484800, // 1 Jul 1993\n+      (leap_second) 773020800, // 1 Jul 1994\n+      (leap_second) 820454400, // 1 Jan 1996\n+      (leap_second) 867715200, // 1 Jul 1997\n+      (leap_second) 915148800, // 1 Jan 1999\n+      (leap_second)1136073600, // 1 Jan 2006\n+      (leap_second)1230768000, // 1 Jan 2009\n+      (leap_second)1341100800, // 1 Jul 2012\n+      (leap_second)1435708800, // 1 Jul 2015\n+      (leap_second)1483228800, // 1 Jan 2017\n+    };\n+\n+#if 0\n+    // This optimization isn't valid if the file has additional leap seconds\n+    // defined since the library was compiled, but the system clock has been\n+    // set to a time before the hardcoded expiration date.\n+    if (system_clock::now() < expires)\n+      return {std::move(leaps), true};\n+#endif\n+\n+    auto exp_year = year_month_day(expires).year();\n+\n+    if (ifstream ls{filename})\n+      {\n+\tstd::string s, w;\n+\ts.reserve(80); // Avoid later reallocations.\n+\twhile (std::getline(ls, s))\n+\t  {\n+\t    // Leap  YEAR  MONTH  DAY  HH:MM:SS  CORR  R/S\n+\n+\t    if (!s.starts_with(\"Leap\"))\n+\t      continue;\n+\t    istringstream li(std::move(s));\n+\t    li.exceptions(ios::failbit);\n+\t    li.ignore(4);\n+\t    unsigned yval;\n+\t    if (li >> yval)\n+\t      {\n+\t\tif (year y(yval); y >= exp_year) // Only process new entries.\n+\t\t  {\n+\t\t    li >> w;\n+\t\t    char m = w[0];\n+\t\t    if (m != 'J' && m != 'D')\n+\t\t      return {std::move(leaps), false};\n+\n+\t\t    const int is_december = m == 'D';\n+\t\t    year_month_day ymd{y, month(6 + 6 * is_december),\n+\t\t\t\t       day(30 + is_december)};\n+\t\t    sys_seconds secs(sys_days(ymd) + days(1));\n+\t\t    li >> w >> w >> m;\n+\n+\t\t    if (m != '+' && m != '-')\n+\t\t      return {std::move(leaps), false};\n+\n+\t\t    seconds::rep val = secs.time_since_epoch().count();\n+\t\t    if (m == '-') [[unlikely]]\n+\t\t      val = -(val - 1); // -ve leap second happens at 23:59:59\n+\n+\t\t    if (leap_second ls{val}; ls > leaps.back())\n+\t\t      leaps.push_back(ls);\n+\t\t  }\n+\t      }\n+\t    s = std::move(li).str(); // return storage to s\n+\t  }\n+\treturn {std::move(leaps), true};\n+      }\n+    else\n+      return {std::move(leaps), false};\n+  }\n+\n+  namespace\n+  {\n+    // Read the version number from a tzdata.zi file.\n+    string\n+    remote_version(istream* zif)\n+    {\n+#if defined __NetBSD__\n+    if (string ver; ifstream(zoneinfo_dir() + \"/TZDATA_VERSION\") >> ver)\n+      return ver;\n+#elif defined __APPLE__\n+    if (string ver; ifstream(zoneinfo_dir() + \"/+VERSION\") >> ver)\n+      return ver;\n+#else\n+      ifstream f;\n+      if (!zif)\n+\t{\n+\t  f.open(zoneinfo_dir() + tzdata_file);\n+\t  zif = &f;\n+\t}\n+      char hash;\n+      string label;\n+      string version;\n+      if (*zif >> hash >> label >> version)\n+\tif (hash == '#' && label == \"version\")\n+\t  return version;\n+#endif\n+      __throw_runtime_error(\"tzdb: no version found in tzdata.zi\");\n+    }\n+  }\n+\n+  // Definition of std::chrono::remote_version()\n+  string remote_version()\n+  {\n+    return remote_version(nullptr);\n+  }\n+\n+  // Used by chrono::reload_tzdb() to add a new node to the front of the list.\n+  const tzdb&\n+  tzdb_list::_Node::_S_replace_head(shared_ptr<_Node> curr [[maybe_unused]],\n+\t\t\t\t    shared_ptr<_Node> new_head)\n+  {\n+#if USE_ATOMIC_SHARED_PTR\n+    new_head->next = curr;\n+    while (!_S_head_owner.compare_exchange_strong(curr, new_head))\n+      {\n+\tif (curr->db.version == new_head->db.version)\n+\t  return curr->db;\n+\tnew_head->next = curr;\n+      }\n+    // XXX small window here where _S_head still points to previous tzdb.\n+    _Node::_S_head = new_head.get();\n+    return new_head->db;\n+#else\n+    lock_guard<mutex> l(list_mutex);\n+    if (const _Node* h = _S_head)\n+      {\n+\tif (h->db.version == new_head->db.version)\n+\t  return h->db;\n+\tnew_head->next = _S_head_owner;\n+      }\n+    auto* pnode = new_head.get();\n+    _S_head_owner = std::move(new_head);\n+    _S_head = pnode;\n+    return pnode->db;\n+#endif\n+  }\n+\n+  // Called to populate the list for the first time. If reload_tzdb() fails,\n+  // it creates a tzdb that only contains the UTC and GMT time zones.\n+  const tzdb&\n+  tzdb_list::_Node::_S_init_tzdb()\n+  {\n+    try\n+      {\n+\treturn reload_tzdb();\n+      }\n+    catch (const std::exception&)\n+      {\n+\tauto [leaps, ok] = _S_read_leap_seconds();\n+\n+\tusing Node = tzdb_list::_Node;\n+\tauto node = std::make_shared<tzdb_list::_Node>();\n+\tnode->db.version = \"ersatz\";\n+\tnode->db.leap_seconds = std::move(leaps);\n+\tnode->db.zones.reserve(2);\n+\tnode->db.links.reserve(7);\n+\n+\ttime_zone zone(nullptr);\n+\ttime_zone_link link(nullptr);\n+\tsys_info info{sys_seconds::min(), sys_seconds::max(), 0s, 0min, \"\"};\n+\n+\tzone._M_impl = std::make_unique<time_zone::_Impl>(node);\n+\tzone._M_name = \"Etc/UTC\";\n+\tinfo.abbrev = \"UTC\";\n+\tzone._M_impl->infos.push_back(std::move(info));\n+\n+\tlink._M_target = zone._M_name;\n+\tlink._M_name = \"UTC\";\n+\tnode->db.links.push_back(std::move(link));\n+\tfor (auto name : {\"Etc/UCT\", \"Etc/Universal\", \"Etc/Zulu\"})\n+\t  {\n+\t    link._M_target = zone._M_name;\n+\t    link._M_name = name;\n+\t    node->db.links.push_back(std::move(link));\n+\t    link._M_target = zone._M_name;\n+\t    link._M_name = name + 4;\n+\t    node->db.links.push_back(std::move(link));\n+\t  }\n+\tnode->db.zones.emplace_back(std::move(zone));\n+\n+\tzone._M_impl = std::make_unique<time_zone::_Impl>(node);\n+\tzone._M_name = \"Etc/GMT\";\n+\tinfo.abbrev = \"GMT\";\n+\tzone._M_impl->infos.push_back(std::move(info));\n+\n+\tlink._M_target = zone._M_name;\n+\tlink._M_name = \"GMT\";\n+\tnode->db.links.push_back(std::move(link));\n+\tfor (auto name : {\"Etc/GMT+0\", \"Etc/GMT-0\", \"Etc/GMT0\", \"Etc/Greenwich\"})\n+\t  {\n+\t    link._M_target = zone._M_name;\n+\t    link._M_name = name;\n+\t    node->db.links.push_back(std::move(link));\n+\t    link._M_target = zone._M_name;\n+\t    link._M_name = name + 4;\n+\t    node->db.links.push_back(std::move(link));\n+\t  }\n+\tnode->db.zones.emplace_back(std::move(zone));\n+\n+\tranges::sort(node->db.zones);\n+\tranges::sort(node->db.links);\n+\treturn Node::_S_replace_head(nullptr, std::move(node));\n+      }\n+  }\n+\n+  // There are only three ways for users to access the tzdb list.\n+  // get_tzdb_list() returns a reference to the list itself.\n+  // get_tzdb() returns a reference to the front of the list.\n+  // reload_tzdb() returns a reference to the (possibly new) front of the list.\n+  // Those are the only functions that need to check whether the list has\n+  // been populated already.\n+\n+  // Implementation of std::chrono::get_tzdb_list()\n+  tzdb_list&\n+  get_tzdb_list()\n+  {\n+    using Node = tzdb_list::_Node;\n+    if (Node::_S_head.load(memory_order::acquire) == nullptr) [[unlikely]]\n+      Node::_S_init_tzdb(); // populates list\n+    return Node::_S_the_list;\n+  }\n+\n+  // Implementation of std::chrono::get_tzdb()\n+  const tzdb&\n+  get_tzdb()\n+  {\n+    using Node = tzdb_list::_Node;\n+    if (auto* __p = Node::_S_head.load(memory_order::acquire)) [[likely]]\n+      return __p->db;\n+    return Node::_S_init_tzdb(); // populates list\n+  }\n+\n+  // Implementation of std::chrono::reload_tzdb()\n+  const tzdb&\n+  reload_tzdb()\n+  {\n+    using Node = tzdb_list::_Node;\n+\n+    ifstream zif(zoneinfo_dir() + tzdata_file);\n+    const string version = remote_version(&zif);\n+\n+#if USE_ATOMIC_SHARED_PTR\n+    auto head = Node::_S_head_owner.load(memory_order::acquire);\n+    if (head != nullptr && head->db.version == version)\n+      return head->db;\n+#else\n+    if (Node::_S_head.load(memory_order::relaxed) != nullptr) [[likely]]\n+    {\n+      lock_guard<mutex> l(list_mutex);\n+      const tzdb& current = Node::_S_head_owner->db;\n+      if (current.version == version)\n+\treturn current;\n+    }\n+#endif\n+\n+    auto [leaps, leaps_ok] = Node::_S_read_leap_seconds();\n+    if (!leaps_ok)\n+      __throw_runtime_error(\"tzdb: cannot parse leapseconds file\");\n+\n+    auto node = std::make_shared<Node>();\n+    node->db.version = std::move(version);\n+    node->db.leap_seconds = std::move(leaps);\n+\n+    string line, type;\n+    line.reserve(80); // Maximum allowed line is 511 but much less in practice.\n+    istringstream is;\n+    is.exceptions(ios::failbit);\n+    int lineno = 0;\n+    while (std::getline(zif, line))\n+      {\n+\t++lineno;\n+\tif (line.empty())\n+\t  continue;\n+\tis.str(std::move(line));\n+\tis.clear();\n+\tws(is);\n+\tint c = is.eof() ? '#' : is.peek();\n+\t__try\n+\t  {\n+\t    switch (c)\n+\t    {\n+\t      case '#':\n+\t\tbreak;\n+\t      case 'R':\n+\t      {\n+\t\t// Rule  NAME  FROM  TO  TYPE  IN  ON  AT  SAVE  LETTER/S\n+\t\tis >> type; // extract the \"Rule\" or \"R\" marker\n+\t\tRule rule;\n+\t\tis >> rule;\n+\t\tnode->rules.push_back(std::move(rule));\n+\t\tbreak;\n+\t      }\n+\t      case 'L':\n+\t      {\n+\t\t// Link  TARGET           LINK-NAME\n+\t\tis >> type; // extract the \"Link\" or \"L\" marker\n+\t\ttime_zone_link link(nullptr);\n+\t\tis >> quoted(link._M_target) >> quoted(link._M_name);\n+\t\tnode->db.links.push_back(std::move(link));\n+\t\tbreak;\n+\t      }\n+\t      case 'Z':\n+\t      {\n+\t\t// Zone  NAME        STDOFF  RULES   FORMAT  [UNTIL]\n+\t\tis >> type; // extract the \"Zone\" or \"Z\" marker\n+\t\ttime_zone tz(std::make_unique<time_zone::_Impl>(node));\n+\t\tis >> quoted(tz._M_name);\n+\t\tnode->db.zones.push_back(time_zone(std::move(tz)));\n+\t\t[[fallthrough]]; // Use default case to parse rest of line ...\n+\t      }\n+\t      default: // Continuation of the previous Zone line.\n+\t      {\n+\t\t// STDOFF  RULES   FORMAT  [UNTIL]\n+\t\tif (type[0] != 'Z')\n+\t\t  is.setstate(ios::failbit);\n+\n+\t\tauto& impl = *node->db.zones.back()._M_impl;\n+\t\tZoneInfo& info = impl.infos.emplace_back();\n+\t\tis >> info;\n+\n+#if defined __GTHREADS && __cpp_lib_atomic_wait\n+\t\t// Keep count of ZoneInfo objects that refer to named Rules.\n+\t\tif (!info.rules().empty())\n+\t\t    impl.rules_counter.fetch_add(1, memory_order::relaxed);\n+#endif\n+\t      }\n+\t    }\n+\t  }\n+\t__catch (const ios::failure&)\n+\t  {\n+\t    ostringstream ss;\n+\t    ss << \"std::chrono::reload_tzdb: parse error at line \" << lineno\n+\t       << \": \" << std::move(is).str();\n+\t    __throw_runtime_error(std::move(ss).str().c_str());\n+\t  }\n+\n+\tline = std::move(is).str(); // return storage to line\n+      }\n+\n+    ranges::sort(node->db.zones, {}, &time_zone::name);\n+    ranges::sort(node->db.links, {}, &time_zone_link::name);\n+    ranges::stable_sort(node->rules, {}, &Rule::name);\n+\n+#if ! USE_ATOMIC_SHARED_PTR\n+    shared_ptr<Node> head;\n+#endif\n+    return Node::_S_replace_head(std::move(head), std::move(node));\n+  }\n+\n+  // Any call to tzdb_list::front() or tzdb_list::begin() must follow\n+  // a call to get_tzdb_list() so the list has already been populated.\n+\n+  // Implementation of std::chrono::tzdb_list::front().\n+  const tzdb&\n+  tzdb_list::front() const noexcept\n+  {\n+    return _Node::_S_head.load()->db;\n+  }\n+\n+  // Implementation of std::chrono::tzdb_list::begin().\n+  auto\n+  tzdb_list::begin() const noexcept\n+  -> const_iterator\n+  {\n+#if USE_ATOMIC_SHARED_PTR\n+    return const_iterator{_Node::_S_head_owner.load()};\n+#else\n+    lock_guard<mutex> l(list_mutex);\n+    return const_iterator{_Node::_S_head_owner};\n+#endif\n+  }\n+\n+  // Implementation of std::chrono::tzdb_list::erase_after(const_iterator).\n+  auto\n+  tzdb_list::erase_after(const_iterator p)\n+  -> const_iterator\n+  {\n+    if (p._M_node) [[likely]]\n+    {\n+#if ! USE_ATOMIC_SHARED_PTR\n+      lock_guard<mutex> l(list_mutex);\n+#endif\n+      if (auto next = p._M_node->next) [[likely]]\n+\treturn const_iterator{p._M_node->next = std::move(next->next)};\n+    }\n+\n+    // This is undefined, but let's be kind:\n+    std::__throw_logic_error(\"std::tzdb_list::erase_after: iterator is not \"\n+\t\t\t     \"dereferenceable\");\n+  }\n+\n+  // Private constructor for tzdb_list::const_iterator.\n+  // Only used within this file, so can be inline.\n+  inline\n+  tzdb_list::\n+  const_iterator::const_iterator(const shared_ptr<_Node>& __p) noexcept\n+  : _M_node(__p)\n+  { }\n+\n+  // Implementation of std::chrono::tzdb_list::const_iterator::operator*().\n+  auto\n+  tzdb_list::const_iterator::operator*() const noexcept\n+  -> reference\n+  {\n+    return _M_node->db;\n+  }\n+\n+  // Implementation of std::chrono::tzdb_list::const_iterator::operator++().\n+  auto\n+  tzdb_list::const_iterator::operator++()\n+  -> const_iterator&\n+  {\n+    auto cur = std::move(_M_node);\n+    _M_node = cur->next;\n+    return *this;\n+  }\n+\n+  // Implementation of std::chrono::tzdb_list::const_iterator::operator++(int).\n+  auto\n+  tzdb_list::const_iterator::operator++(int)\n+  -> const_iterator\n+  {\n+    auto tmp = std::move(*this);\n+    _M_node = tmp._M_node->next;\n+    return tmp;\n+  }\n+\n+  namespace\n+  {\n+    const time_zone*\n+    do_locate_zone(const vector<time_zone>& zones,\n+\t\t   const vector<time_zone_link>& links,\n+\t\t   string_view tz_name) noexcept\n+    {\n+      // Lambda mangling changed between -fabi-version=2 and -fabi-version=18\n+      auto search = []<class Vec>(const Vec& v, string_view name) {\n+\tauto pos = ranges::lower_bound(v, name, {}, &Vec::value_type::name);\n+\tauto ptr = pos.base();\n+\tif (pos == v.end() || pos->name() != name)\n+\t  ptr = nullptr;\n+\treturn ptr;\n+      };\n+\n+      if (auto tz = search(zones, tz_name))\n+\treturn tz;\n+\n+      if (auto tz_l = search(links, tz_name))\n+\treturn search(zones, tz_l->target());\n+\n+      return nullptr;\n+    }\n+  } // namespace\n+\n+  // Implementation of std::chrono::tzdb::locate_zone(string_view).\n+  const time_zone*\n+  tzdb::locate_zone(string_view tz_name) const\n+  {\n+    if (auto tz = do_locate_zone(zones, links, tz_name))\n+      return tz;\n+    string_view err = \"tzdb: cannot locate zone: \";\n+    string str;\n+    str.reserve(err.size() + tz_name.size());\n+    str += err;\n+    str += tz_name;\n+    __throw_runtime_error(str.c_str());\n+  }\n+\n+  // Implementation of std::chrono::tzdb::current_zone().\n+  const time_zone*\n+  tzdb::current_zone() const\n+  {\n+    // TODO cache this function's result?\n+\n+    error_code ec;\n+    // This should be a symlink to e.g. /usr/share/zoneinfo/Europe/London\n+    auto path = filesystem::read_symlink(\"/etc/localtime\", ec);\n+    if (!ec)\n+      {\n+\tauto first = path.begin(), last = path.end();\n+\tif (std::distance(first, last) > 2)\n+\t  {\n+\t    --last;\n+\t    string name = std::prev(last)->string() + '/';\n+\t    name += last->string();\n+\t    if (auto tz = do_locate_zone(this->zones, this->links, name))\n+\t      return tz;\n+\t  }\n+      }\n+    // Otherwise, look for a file naming the time zone.\n+    string_view files[] {\n+      \"/etc/timezone\",    // Debian derivates\n+      \"/var/db/zoneinfo\", // FreeBSD\n+    };\n+    for (auto f : files)\n+      {\n+\tstd::ifstream tzf{string{f}};\n+\tif (std::string name; std::getline(tzf, name))\n+\t  if (auto tz = do_locate_zone(this->zones, this->links, name))\n+\t    return tz;\n+      }\n+\n+    // TODO AIX stores current zone in $TZ in /etc/environment but the value\n+    // is typically a POSIX time zone name, not IANA zone.\n+    // https://developer.ibm.com/articles/au-aix-posix/\n+    // https://www.ibm.com/support/pages/managing-time-zone-variable-posix\n+\n+    __throw_runtime_error(\"tzdb: cannot determine current zone\");\n+  }\n+\n+  // Implementation of std::chrono::locate_zone(string_view)\n+  // TODO define this inline in the header instead?\n+  const time_zone*\n+  locate_zone(string_view tz_name)\n+  {\n+    // Use begin() so the tzdb cannot be erased while this operation runs.\n+    return get_tzdb_list().begin()->locate_zone(tz_name);\n+  }\n+\n+  // Implementation of std::chrono::current_zone()\n+  // TODO define this inline in the header instead?\n+  const time_zone*\n+  current_zone()\n+  {\n+    // Use begin() so the tzdb cannot be erased while this operation runs.\n+    return get_tzdb_list().begin()->current_zone();\n+  }\n+\n+  namespace\n+  {\n+    istream& operator>>(istream& in, abbrev_month& am)\n+    {\n+      string s;\n+      in >> s;\n+      switch (s[0])\n+      {\n+      case 'J':\n+\tswitch (s[1])\n+\t{\n+\tcase 'a':\n+\t  am.m = January;\n+\t  return in;\n+\tcase 'u':\n+\t  switch (s[2])\n+\t  {\n+\t  case 'n':\n+\t    am.m = June;\n+\t    return in;\n+\t  case 'l':\n+\t    am.m = July;\n+\t    return in;\n+\t  }\n+\t  break;\n+\t}\n+\tbreak;\n+      case 'F':\n+\tam.m = February;\n+\treturn in;\n+      case 'M':\n+\tif (s[1] == 'a') [[likely]]\n+\t  switch (s[2])\n+\t  {\n+\t  case 'r':\n+\t    am.m = March;\n+\t    return in;\n+\t  case 'y':\n+\t    am.m = May;\n+\t    return in;\n+\t  }\n+\tbreak;\n+      case 'A':\n+\tswitch (s[1])\n+\t{\n+\tcase 'p':\n+\t  am.m = April;\n+\t  return in;\n+\tcase 'u':\n+\t  am.m = August;\n+\t  return in;\n+\t}\n+\tbreak;\n+      case 'S':\n+\tam.m = September;\n+\treturn in;\n+      case 'O':\n+\tam.m = October;\n+\treturn in;\n+      case 'N':\n+\tam.m = November;\n+\treturn in;\n+      case 'D':\n+\tam.m = December;\n+\treturn in;\n+      }\n+      in.setstate(ios::failbit);\n+      return in;\n+    }\n+\n+    // Wrapper for chrono::weekday that can be extracted from an istream\n+    // as an abbreviated weekday name.\n+    // The weekday name can be any unambiguous portion of a weekday name,\n+    // e.g. \"M\" (Monday) or \"Su\" (Sunday), but not \"T\" (Tuesday/Thursday).\n+    struct abbrev_weekday\n+    {\n+      weekday wd;\n+\n+      friend istream& operator>>(istream& in, abbrev_weekday& aw)\n+      {\n+\t// Do not read a whole word from the stream, in some cases\n+\t// the weekday is only part of a larger word like \"Sun<=25\".\n+\t// Just peek at one char at a time.\n+\tswitch (in.peek())\n+\t{\n+\tcase 'M':\n+\t  aw.wd = Monday;\n+\t  break;\n+\tcase 'T':\n+\t  in.ignore(1); // Discard the 'T'\n+\t  switch (in.peek())\n+\t  {\n+\t  case 'u':\n+\t    aw.wd = Tuesday;\n+\t    break;\n+\t  case 'h':\n+\t    aw.wd = Thursday;\n+\t    break;\n+\t  default:\n+\t    in.setstate(ios::failbit);\n+\t  }\n+\t  break;\n+\tcase 'W':\n+\t  aw.wd = Wednesday;\n+\t  break;\n+\tcase 'F':\n+\t  aw.wd = Friday;\n+\t  break;\n+\tcase 'S':\n+\t  in.ignore(1); // Discard the 'S'\n+\t  switch (in.peek())\n+\t  {\n+\t  case 'a':\n+\t    aw.wd = Saturday;\n+\t    break;\n+\t  case 'u':\n+\t    aw.wd = Sunday;\n+\t    break;\n+\t  default:\n+\t    in.setstate(ios::failbit);\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  in.setstate(ios::failbit);\n+\t}\n+\tin.ignore(1); // Discard whichever char we just looked at.\n+\n+\t// Discard any remaining chars from weekday, e.g. \"onday\".\n+\tstring_view day_chars = \"ondayesritu\";\n+\tauto is_day_char = [&day_chars](int c) {\n+\t  return c != char_traits<char>::eof()\n+\t\t   && day_chars.find((char)c) != day_chars.npos;\n+\t};\n+\twhile (is_day_char(in.peek()))\n+\t  in.ignore(1);\n+\n+\treturn in;\n+      }\n+    };\n+\n+    istream& operator>>(istream& in, on_day& to)\n+    {\n+      on_day on{};\n+      abbrev_month m{};\n+      in >> m;\n+      on.month = static_cast<unsigned>(m.m);\n+      int c = ws(in).peek();\n+      if ('0' <= c && c <= '9')\n+\t{\n+\t  on.kind = on_day::DayOfMonth;\n+\t  unsigned d;\n+\t  in >> d;\n+\t  if (d <= 31) [[likely]]\n+\t    {\n+\t      on.day_of_month = d;\n+\t      to = on;\n+\t      return in;\n+\t    }\n+\t}\n+      else if (c == 'l') // lastSunday, lastWed, ...\n+\t{\n+\t  in.ignore(4);\n+\t  if (abbrev_weekday w{}; in >> w) [[likely]]\n+\t    {\n+\t      on.kind = on_day::LastWeekday;\n+\t      on.day_of_week = w.wd.c_encoding();\n+\t      to = on;\n+\t      return in;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  abbrev_weekday w;\n+\t  in >> w;\n+\t  if (auto c = in.get(); c == '<' || c == '>')\n+\t    {\n+\t      if (in.get() == '=')\n+\t\t{\n+\t\t  on.kind = c == '<' ? on_day::LessEq : on_day::GreaterEq;\n+\t\t  on.day_of_week = w.wd.c_encoding();\n+\t\t  unsigned d;\n+\t\t  in >> d;\n+\t\t  if (d <= 31) [[likely]]\n+\t\t    {\n+\t\t      on.day_of_month = d;\n+\t\t      to = on;\n+\t\t      return in;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+      in.setstate(ios::failbit);\n+      return in;\n+    }\n+\n+    istream& operator>>(istream& in, at_time& at)\n+    {\n+      int sign = 1;\n+      if (in.peek() == '-')\n+\t{\n+\t  in.ignore(1);\n+\t  if (auto [val, yes] = at_time::is_indicator(in.peek()); yes)\n+\t    {\n+\t      in.ignore(1);\n+\t      at.time = 0s;\n+\t      at.indicator = val;\n+\t      return in;\n+\t    }\n+\t  sign = -1;\n+\t}\n+      int i;\n+      in >> i;\n+      hours h{i};\n+      minutes m{};\n+      seconds s{};\n+      if (!in.eof() && in.peek() == ':')\n+\t{\n+\t  in.ignore(1); // discard the colon.\n+\t  in >> i;\n+\t  m = minutes{i};\n+\t  if (in.peek() == ':')\n+\t    {\n+\t      in.ignore(1); // discard the colon.\n+\t      in >> i;\n+\t      if (in.peek() == '.')\n+\t\t{\n+\t\t  double frac;\n+\t\t  in >> frac;\n+\t\t  // zic(8) rounds to nearest second, rounding ties to even.\n+\t\t  s = chrono::round<seconds>(duration<double>(i + frac));\n+\t\t}\n+\t      else\n+\t\ts = seconds{i};\n+\t    }\n+\t}\n+      if (in >> at.indicator)\n+\tat.time = sign * (h + m + s);\n+      return in;\n+    }\n+\n+    istream& operator>>(istream& in, ZoneInfo& inf)\n+    {\n+      // STDOFF  RULES  FORMAT  [UNTIL]\n+      at_time off;\n+      string rules;\n+      string fmt;\n+\n+      in >> off >> quoted{rules} >> fmt;\n+      inf.m_offset = off.time;\n+      if (rules == \"-\")\n+\t{\n+\t  // Standard time always applies, no DST.\n+\t  inf.set_abbrev(fmt);\n+\t}\n+      else if (string_view(\"0123456789-+\").find(rules[0]) != string_view::npos)\n+\t{\n+\t  // rules specifies the difference from standard time.\n+\t  at_time rules_time;\n+\t  istringstream in2(std::move(rules));\n+\t  in2 >> rules_time;\n+\t  inf.m_save = duration_cast<minutes>(rules_time.time);\n+\t  select_std_or_dst_abbrev(fmt, inf.m_save);\n+\t  inf.set_abbrev(fmt);\n+\t}\n+      else\n+\t{\n+\t  // rules refers to a named Rule which describes transitions.\n+\t  inf.set_rules_and_format(rules, fmt);\n+\t}\n+\n+      // YEAR [MONTH [DAY [TIME]]]\n+      ios::iostate ex = in.exceptions();\n+      in.exceptions(ios::goodbit); // Don't throw ios::failure if YEAR absent.\n+      if (int y = int(year::max()); in >> y)\n+\t{\n+\t  abbrev_month m{January};\n+\t  int d = 1;\n+\t  at_time t{};\n+\t  in >> m >> d >> t;\n+\t  inf.m_until = sys_days(year(y)/m.m/day(d)) + seconds(t.time);\n+\t}\n+      else\n+\tinf.m_until = sys_days(year::max()/December/31);\n+\n+      in.clear(in.rdstate() & ios::eofbit);\n+      in.exceptions(ex);\n+      if (!in.eof())\n+\t// Not actually necessary, as we're only parsing a single line:\n+\tin.ignore(numeric_limits<streamsize>::max(), '\\n');\n+      return in;\n+    }\n+  } // namespace\n+\n+} // namespace std::chrono"}, {"sha": "ed5733afb9fa79b00cff9680b350a37d96fe37ce", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -1397,6 +1397,20 @@ proc check_effective_target_hosted { } {\n     }]\n }\n \n+# Return 1 if std::chrono::tzdb is supported.\n+proc check_effective_target_tzdb { } {\n+    if {![check_effective_target_cxx11_abi]} {\n+\treturn 0\n+    }\n+    return [check_v3_target_prop_cached et_tzdb {\n+\tset cond \"defined _GLIBCXX_ZONEINFO_DIR\"\n+\tif {[v3_check_preprocessor_condition tzdb $cond]} {\n+\t    return 1\n+\t}\n+\treturn [file exists /usr/share/zoneinfo/tzdata.zi]\n+    }]\n+}\n+\n set additional_prunes \"\"\n \n if { [info exists env(GCC_RUNTEST_PARALLELIZE_DIR)] \\"}, {"sha": "0d36efcff7002b88b665a9b01e172bd60a8d65b6", "filename": "libstdc++-v3/testsuite/std/time/clock/file/members.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ffile%2Fmembers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ffile%2Fmembers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ffile%2Fmembers.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -32,8 +32,19 @@ test01()\n   VERIFY( d2 == d1 );\n }\n \n+void\n+test02()\n+{\n+  using namespace std::chrono;\n+\n+  file_time<file_clock::duration> t = file_clock::now();\n+  file_time<seconds> s = floor<seconds>(t);\n+  VERIFY( t - s < 1s );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n }"}, {"sha": "f6bfe49207d3ee1b768a7ad74a5c4543ab8e5e88", "filename": "libstdc++-v3/testsuite/std/time/clock/gps/1.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Fgps%2F1.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -31,8 +31,26 @@ test02()\n   VERIFY( clock_cast<gps_clock>(clock_cast<utc_clock>(t)) == t );\n }\n \n+void\n+test03()\n+{\n+  using namespace std::chrono;\n+\n+  gps_time<gps_clock::duration> gps1 = gps_clock::now();\n+  utc_time<utc_clock::duration> utc = utc_clock::now();\n+  gps_time<gps_clock::duration> gps2 = gps_clock::now();\n+\n+  auto delta = gps2 - gps1;\n+  VERIFY( (utc - clock_cast<utc_clock>(gps1)) <= delta );\n+  VERIFY( (clock_cast<utc_clock>(gps2) - utc) <= delta );\n+\n+  gps_seconds s = time_point_cast<seconds>(gps1);\n+  VERIFY( gps1 - s < 1s );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n }"}, {"sha": "08fc972c5503940866959ef002ca017df174bf7d", "filename": "libstdc++-v3/testsuite/std/time/clock/tai/1.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Ftai%2F1.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -34,8 +34,26 @@ test02()\n   VERIFY( clock_cast<tai_clock>(clock_cast<utc_clock>(t)) == t );\n }\n \n+void\n+test03()\n+{\n+  using namespace std::chrono;\n+\n+  tai_time<tai_clock::duration> tai1 = tai_clock::now();\n+  utc_time<utc_clock::duration> utc = utc_clock::now();\n+  tai_time<tai_clock::duration> tai2 = tai_clock::now();\n+\n+  auto delta = tai2 - tai1;\n+  VERIFY( (utc - clock_cast<utc_clock>(tai1)) <= delta );\n+  VERIFY( (clock_cast<utc_clock>(tai2) - utc) <= delta );\n+\n+  tai_seconds s = time_point_cast<seconds>(tai1);\n+  VERIFY( tai1 - s < 1s );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n }"}, {"sha": "0140c756dabdd6ca9de066d1eb9af2a99421ae63", "filename": "libstdc++-v3/testsuite/std/time/clock/utc/leap_second_info.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2Fleap_second_info.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2Fleap_second_info.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fclock%2Futc%2Fleap_second_info.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-additional-options \"-DHAVE_TZDB\" { target tzdb } }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::chrono_literals;\n+\n+void\n+test_before()\n+{\n+  // No leaps seconds defined before the epoch.\n+  auto s = std::chrono::utc_seconds(-1s);\n+  auto lsi = get_leap_second_info(s);\n+  VERIFY( lsi.is_leap_second == false );\n+  VERIFY( lsi.elapsed == 0s );\n+\n+  auto ms = std::chrono::utc_time<std::chrono::milliseconds>(s - 5500ms);\n+  lsi = get_leap_second_info(ms);\n+  VERIFY( lsi.is_leap_second == false );\n+  VERIFY( lsi.elapsed == 0s );\n+}\n+\n+void\n+test_after()\n+{\n+#ifdef HAVE_TZDB\n+  const auto& leaps = std::chrono::get_tzdb().leap_seconds;\n+  std::chrono::seconds sum(0);\n+  for (auto leap : leaps)\n+    sum += leap.value();\n+\n+  // After the last defined leap second.\n+  auto last = leaps.back().date().time_since_epoch();\n+  auto ut = std::chrono::utc_time<std::chrono::milliseconds>(last + 72h + 10ms);\n+  auto lsi = get_leap_second_info(ut);\n+  VERIFY( lsi.is_leap_second == false );\n+  VERIFY( lsi.elapsed == sum );\n+#endif\n+}\n+\n+void\n+test_between()\n+{\n+  std::chrono::sys_days st(1995y/9/4);\n+  auto ut = std::chrono::clock_cast<std::chrono::utc_clock>(st);\n+  auto lsi = get_leap_second_info(ut);\n+  VERIFY( lsi.is_leap_second == false );\n+  VERIFY( lsi.elapsed == 19s );\n+}\n+\n+void\n+test_during()\n+{\n+#ifdef HAVE_TZDB\n+  // Verify that leap_second_info::is_leap_second is true for each leap second.\n+  const auto& leaps = std::chrono::get_tzdb().leap_seconds;\n+  for (const auto& leap : leaps)\n+  {\n+    // N.B. this assumes all leap seconds are positive:\n+    std::chrono::seconds elapsed(&leap - &leaps.front());\n+    std::chrono::utc_seconds ut(leap.date().time_since_epoch() + elapsed);\n+    auto lsi = get_leap_second_info(ut);\n+    VERIFY( lsi.is_leap_second == true );\n+    VERIFY( lsi.elapsed == elapsed + 1s );\n+    lsi = get_leap_second_info(ut + 999ms);\n+    VERIFY( lsi.is_leap_second == true );\n+    VERIFY( lsi.elapsed == elapsed + 1s );\n+  }\n+#endif\n+}\n+\n+int main()\n+{\n+  test_before();\n+  test_after();\n+  test_between();\n+  test_during();\n+}"}, {"sha": "1b81d5ee27a03069af88ea90cff979b941cf1fb6", "filename": "libstdc++-v3/testsuite/std/time/exceptions.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fexceptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fexceptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fexceptions.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target tzdb }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_nonexistent()\n+{\n+    std::string expected\n+      = \"2016-03-13 02:30:00 is in a gap between\\n\"\n+\t\"2016-03-13 02:00:00 EST and\\n\"\n+\t\"2016-03-13 03:00:00 EDT which are both equivalent to\\n\"\n+\t\"2016-03-13 07:00:00 UTC\";\n+\n+  using namespace std::chrono;\n+  try {\n+    auto zt = zoned_time{\"America/New_York\",\n+\t\t\t local_days{Sunday[2]/March/2016} + 2h + 30min};\n+    VERIFY(false);\n+  } catch (const nonexistent_local_time& e) {\n+    // VERIFY( e.what() == expected );\n+  }\n+}\n+\n+void\n+test_ambiguous()\n+{\n+    std::string expected\n+      = \"2016-11-06 01:30:00 is ambiguous.  It could be\\n\"\n+\t\"2016-11-06 01:30:00 EDT == 2016-11-06 05:30:00 UTC or\\n\"\n+\t\"2016-11-06 01:30:00 EST == 2016-11-06 06:30:00 UTC\";\n+\n+  using namespace std::chrono;\n+  try {\n+    auto zt = zoned_time{\"America/New_York\",\n+\t\t\t local_days{Sunday[1]/November/2016} + 1h + 30min};\n+    VERIFY(false);\n+  } catch (const ambiguous_local_time& e) {\n+    // VERIFY( e.what() == expected );\n+  }\n+}\n+\n+int main()\n+{\n+  test_nonexistent();\n+  test_ambiguous();\n+}"}, {"sha": "c91723bebd608adba81564112d47557f5e4eaa74", "filename": "libstdc++-v3/testsuite/std/time/syn_c++20.cc", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fsyn_c%2B%2B20.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fsyn_c%2B%2B20.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fsyn_c%2B%2B20.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -43,8 +43,6 @@ namespace __gnu_test\n   using std::chrono::sys_seconds;\n   using std::chrono::sys_days;\n \n-  // FIXME\n-#if 0\n   using std::chrono::utc_clock;\n   using std::chrono::utc_time;\n   using std::chrono::utc_seconds;\n@@ -59,7 +57,6 @@ namespace __gnu_test\n   using std::chrono::gps_clock;\n   using std::chrono::gps_time;\n   using std::chrono::gps_seconds;\n-#endif\n \n   using std::chrono::file_clock;\n   using std::chrono::file_time;\n@@ -69,13 +66,10 @@ namespace __gnu_test\n   using std::chrono::local_seconds;\n   using std::chrono::local_days;\n \n-  // FIXME\n-#if 0\n   using std::chrono::clock_time_conversion;\n   using std::chrono::clock_cast;\n \n   using std::chrono::last_spec;\n-#endif\n \n   using std::chrono::day;\n   using std::chrono::month;\n@@ -101,8 +95,7 @@ namespace __gnu_test\n   using std::chrono::make12;\n   using std::chrono::make24;\n \n-  // FIXME\n-#if 0\n+#if _GLIBCXX_USE_CXX11_ABI\n   using std::chrono::tzdb;\n   using std::chrono::tzdb_list;\n   using std::chrono::get_tzdb;\n@@ -129,11 +122,13 @@ namespace __gnu_test\n   using std::chrono::leap_second;\n \n   using std::chrono::time_zone_link;\n+#endif\n \n-  using std::chrono::local_time_format;\n+  // FIXME\n+  // using std::chrono::local_time_format;\n \n-  using std::chrono::parse;\n-#endif\n+  // FIXME\n+  // using std::chrono::parse;\n \n   using std::chrono::last;\n   using std::chrono::Sunday;"}, {"sha": "d15e1c7036ef673c392cac655750a823b7be5989", "filename": "libstdc++-v3/testsuite/std/time/time_zone/get_info_local.cc", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_local.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_local.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_local.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,222 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target tzdb }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::chrono;\n+\n+struct empty_tag { } empty;\n+\n+bool operator==(const sys_info& info, empty_tag)\n+{\n+  return info.begin == sys_seconds() && info.end == info.begin\n+    && info.offset == 0s && info.save == 0min && info.abbrev.empty();\n+}\n+\n+void\n+test_utc()\n+{\n+  auto tz = locate_zone(\"UTC\");\n+  auto now = time_point_cast<seconds>(system_clock::now());\n+  local_info info = tz->get_info(local_seconds(now.time_since_epoch()));\n+  VERIFY( info.result == local_info::unique );\n+  VERIFY( info.first.begin < now );\n+  VERIFY( info.first.end > now );\n+  VERIFY( info.first.offset == 0h );\n+  VERIFY( info.first.save == 0h );\n+  VERIFY( info.first.abbrev == \"UTC\" );\n+  VERIFY( info.second == empty );\n+}\n+\n+auto dst_start = March/Sunday[last];\n+auto dst_end = October/Sunday[last];\n+\n+void\n+test_unique()\n+{\n+  auto tz = locate_zone(\"Europe/London\");\n+  local_days feb1(sys_days(2022y/February/1).time_since_epoch());\n+  local_info info;\n+\n+  info = tz->get_info(feb1);\n+  VERIFY( info.result == local_info::unique );\n+  VERIFY( info.first.begin == sys_days(2021y/dst_end) + 1h );\n+  VERIFY( info.first.end == sys_days(2022y/dst_start) + 1h );\n+  VERIFY( info.first.offset == 0h );\n+  VERIFY( info.first.save == 0h );\n+  VERIFY( info.first.abbrev == \"GMT\" );\n+  VERIFY( info.second == empty );\n+\n+  info = tz->get_info(feb1 + months(4));\n+  VERIFY( info.result == local_info::unique );\n+  VERIFY( info.first.begin == sys_days(2022y/dst_start) + 1h );\n+  VERIFY( info.first.end == sys_days(2022y/dst_end) + 1h );\n+  VERIFY( info.first.offset == 1h );\n+  VERIFY( info.first.save == 1h );\n+  VERIFY( info.first.abbrev == \"BST\" );\n+  VERIFY( info.second == empty );\n+}\n+\n+void\n+test_nonexistent()\n+{\n+  auto tz = locate_zone(\"Europe/Helsinki\");\n+  sys_time<hours> change = sys_days(2022y/dst_start) + 1h;\n+  local_seconds nonesuch(change.time_since_epoch() + 2h + 30min);\n+  local_info info;\n+\n+  info = tz->get_info(nonesuch);\n+  VERIFY( info.result == local_info::nonexistent );\n+  VERIFY( info.first.end == change );\n+  VERIFY( info.first.offset == 2h );\n+  VERIFY( info.first.save == 0h );\n+  VERIFY( info.first.abbrev == \"EET\" );\n+  VERIFY( info.second.begin == info.first.end );\n+  VERIFY( info.second.offset == 3h );\n+  VERIFY( info.second.save == 1h );\n+  VERIFY( info.second.abbrev == \"EEST\" );\n+\n+  tz = locate_zone(\"America/New_York\");\n+  nonesuch = local_days(Sunday[2]/March/2016) + 2h + 30min;\n+  info = tz->get_info(nonesuch);\n+  VERIFY( info.result == local_info::nonexistent );\n+  VERIFY( info.first.end == sys_days(Sunday[2]/March/2016) + 5h + 2h );\n+  VERIFY( info.first.offset == -5h );\n+  VERIFY( info.first.save == 0h );\n+  VERIFY( info.first.abbrev == \"EST\" );\n+  VERIFY( info.second.begin == info.first.end );\n+  VERIFY( info.second.offset == -4h );\n+  VERIFY( info.second.save == 1h );\n+  VERIFY( info.second.abbrev == \"EDT\" );\n+}\n+\n+void\n+test_ambiguous()\n+{\n+  auto tz = locate_zone(\"Europe/Helsinki\");\n+  sys_time<hours> change = sys_days(2022y/dst_end) + 1h;\n+  local_seconds twix(change.time_since_epoch() + 2h + 30min);\n+  local_info info;\n+\n+  info = tz->get_info(twix);\n+  VERIFY( info.result == local_info::ambiguous );\n+  VERIFY( info.first.end == change );\n+  VERIFY( info.first.offset == 3h );\n+  VERIFY( info.first.save == 1h );\n+  VERIFY( info.first.abbrev == \"EEST\" );\n+  VERIFY( info.second.begin == info.first.end );\n+  VERIFY( info.second.offset == 2h );\n+  VERIFY( info.second.save == 0h );\n+  VERIFY( info.second.abbrev == \"EET\" );\n+\n+  tz = locate_zone(\"America/New_York\");\n+  twix = local_days(Sunday[2]/March/2016) + 2h + 30min;\n+  info = tz->get_info(twix);\n+  VERIFY( info.result == local_info::nonexistent );\n+  VERIFY( info.first.end == sys_days(Sunday[2]/March/2016) + 5h + 2h );\n+  VERIFY( info.first.offset == -5h );\n+  VERIFY( info.first.save == 0h );\n+  VERIFY( info.first.abbrev == \"EST\" );\n+  VERIFY( info.second.begin == info.first.end );\n+  VERIFY( info.second.offset == -4h );\n+  VERIFY( info.second.save == 1h );\n+  VERIFY( info.second.abbrev == \"EDT\" );\n+}\n+\n+void\n+test_egypt()\n+{\n+  local_days d(2010y/May/1);\n+  auto tz = locate_zone(\"Egypt\");\n+  local_info info = tz->get_info(d);\n+  VERIFY( info.result == local_info::unique );\n+  VERIFY( info.first.begin == sys_days(2010y/April/29) + 22h );\n+  VERIFY( info.first.offset == 3h );\n+  VERIFY( info.first.save == 1h );\n+  VERIFY( info.first.abbrev == \"EEST\" );\n+\n+  info = tz->get_info(d - 24h);\n+  VERIFY( info.result == local_info::nonexistent );\n+  VERIFY( info.first.begin == sys_days(2009y/August/20) + 21h );\n+  VERIFY( info.first.offset == 2h );\n+  VERIFY( info.first.save == 0h );\n+  VERIFY( info.first.abbrev == \"EET\" );\n+  VERIFY( info.second.begin == sys_days(2010y/April/29) + 22h );\n+  VERIFY( info.second.offset == 3h );\n+  VERIFY( info.second.save == 1h );\n+  VERIFY( info.second.abbrev == \"EEST\" );\n+\n+#if 0\n+  std::ostringstream out;\n+  local_seconds lt(local_days(2001y/January/1));\n+  const local_days end(2021y/January/1);\n+\n+  while (lt < end)\n+  {\n+    local_info i = tz->get_info(lt);\n+\n+    out << '\\n' << i;\n+\n+    auto next = i.first.end;\n+    if (i.result != local_info::unique)\n+      next = i.second.begin + 24h;\n+    lt = zoned_time(tz, next).get_local_time();\n+  }\n+  out << '\\n';\n+\n+  std::string expected = R\"(\n+[[2000-09-28 21:00:00,2001-04-26 22:00:00,02:00:00,0min,EET]]\n+[[2001-04-26 22:00:00,2001-09-27 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2001-04-26 22:00:00,2001-09-27 21:00:00,03:00:00,60min,EEST] and [2001-09-27 21:00:00,2002-04-25 22:00:00,02:00:00,0min,EET]]\n+[[2001-09-27 21:00:00,2002-04-25 22:00:00,02:00:00,0min,EET]]\n+[[2002-04-25 22:00:00,2002-09-26 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2002-04-25 22:00:00,2002-09-26 21:00:00,03:00:00,60min,EEST] and [2002-09-26 21:00:00,2003-04-24 22:00:00,02:00:00,0min,EET]]\n+[[2002-09-26 21:00:00,2003-04-24 22:00:00,02:00:00,0min,EET]]\n+[[2003-04-24 22:00:00,2003-09-25 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2003-04-24 22:00:00,2003-09-25 21:00:00,03:00:00,60min,EEST] and [2003-09-25 21:00:00,2004-04-29 22:00:00,02:00:00,0min,EET]]\n+[[2003-09-25 21:00:00,2004-04-29 22:00:00,02:00:00,0min,EET]]\n+[[2004-04-29 22:00:00,2004-09-30 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2004-04-29 22:00:00,2004-09-30 21:00:00,03:00:00,60min,EEST] and [2004-09-30 21:00:00,2005-04-28 22:00:00,02:00:00,0min,EET]]\n+[[2004-09-30 21:00:00,2005-04-28 22:00:00,02:00:00,0min,EET]]\n+[[2005-04-28 22:00:00,2005-09-29 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2005-04-28 22:00:00,2005-09-29 21:00:00,03:00:00,60min,EEST] and [2005-09-29 21:00:00,2006-04-27 22:00:00,02:00:00,0min,EET]]\n+[[2005-09-29 21:00:00,2006-04-27 22:00:00,02:00:00,0min,EET]]\n+[[2006-04-27 22:00:00,2006-09-21 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2006-04-27 22:00:00,2006-09-21 21:00:00,03:00:00,60min,EEST] and [2006-09-21 21:00:00,2007-04-26 22:00:00,02:00:00,0min,EET]]\n+[[2006-09-21 21:00:00,2007-04-26 22:00:00,02:00:00,0min,EET]]\n+[[2007-04-26 22:00:00,2007-09-06 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2007-04-26 22:00:00,2007-09-06 21:00:00,03:00:00,60min,EEST] and [2007-09-06 21:00:00,2008-04-24 22:00:00,02:00:00,0min,EET]]\n+[[2007-09-06 21:00:00,2008-04-24 22:00:00,02:00:00,0min,EET]]\n+[[2008-04-24 22:00:00,2008-08-28 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2008-04-24 22:00:00,2008-08-28 21:00:00,03:00:00,60min,EEST] and [2008-08-28 21:00:00,2009-04-23 22:00:00,02:00:00,0min,EET]]\n+[[2008-08-28 21:00:00,2009-04-23 22:00:00,02:00:00,0min,EET]]\n+[[2009-04-23 22:00:00,2009-08-20 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2009-04-23 22:00:00,2009-08-20 21:00:00,03:00:00,60min,EEST] and [2009-08-20 21:00:00,2010-04-29 22:00:00,02:00:00,0min,EET]]\n+[[2009-08-20 21:00:00,2010-04-29 22:00:00,02:00:00,0min,EET]]\n+[[2010-04-29 22:00:00,2010-08-10 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2010-04-29 22:00:00,2010-08-10 21:00:00,03:00:00,60min,EEST] and [2010-08-10 21:00:00,2010-09-09 22:00:00,02:00:00,0min,EET]]\n+[[2010-08-10 21:00:00,2010-09-09 22:00:00,02:00:00,0min,EET]]\n+[[2010-09-09 22:00:00,2010-09-30 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2010-09-09 22:00:00,2010-09-30 21:00:00,03:00:00,60min,EEST] and [2010-09-30 21:00:00,2014-05-15 22:00:00,02:00:00,0min,EET]]\n+[[2010-09-30 21:00:00,2014-05-15 22:00:00,02:00:00,0min,EET]]\n+[[2014-05-15 22:00:00,2014-06-26 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2014-05-15 22:00:00,2014-06-26 21:00:00,03:00:00,60min,EEST] and [2014-06-26 21:00:00,2014-07-31 22:00:00,02:00:00,0min,EET]]\n+[[2014-06-26 21:00:00,2014-07-31 22:00:00,02:00:00,0min,EET]]\n+[[2014-07-31 22:00:00,2014-09-25 21:00:00,03:00:00,60min,EEST]]\n+[ambiguous local time between [2014-07-31 22:00:00,2014-09-25 21:00:00,03:00:00,60min,EEST] and [2014-09-25 21:00:00,32767-12-31 00:00:00,02:00:00,0min,EET]]\n+[[2014-09-25 21:00:00,32767-12-31 00:00:00,02:00:00,0min,EET]]\n+)\";\n+  VERIFY( out.str() == expected );\n+#endif\n+}\n+\n+int main()\n+{\n+  test_utc();\n+  test_unique();\n+  test_nonexistent();\n+  test_ambiguous();\n+  test_egypt();\n+}"}, {"sha": "a669b68e4401f26508d56e08749c77282ed68bdf", "filename": "libstdc++-v3/testsuite/std/time/time_zone/get_info_sys.cc", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_sys.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_sys.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Fget_info_sys.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,219 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target tzdb }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_zurich()\n+{\n+  using namespace std::chrono;\n+\n+  const time_zone* const tz = locate_zone(\"Europe/Zurich\");\n+\n+  {\n+    sys_days d = 1853y/July/16;\n+\n+    auto info = tz->get_info(d - 1s);\n+    VERIFY( info.offset == (34min + 8s) );\n+    VERIFY( info.abbrev == \"LMT\" );\n+\n+    info = tz->get_info(d);\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+\n+    info = tz->get_info(d + 1s);\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+\n+    info = tz->get_info(d + 0.001s);\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+  }\n+\n+  {\n+    sys_days d = 1894y/June/1;\n+\n+    auto info = tz->get_info(d - 1s);\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+\n+    info = tz->get_info(d);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1941y/May/Monday[1];\n+\n+    auto info = tz->get_info(d - 1s);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    // CEST daylight savings time starts at 1am local time (UTC+1).\n+    info = tz->get_info(d);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+  }\n+\n+  {\n+    sys_days d = 1941y/October/Monday[1];\n+\n+    auto info = tz->get_info(d - 1s);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CET standard time starts at 2am local time (UTC+2).\n+    info = tz->get_info(d);\n+    VERIFY( info.offset == 1h  );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1942y/May/Monday[1];\n+\n+    auto info = tz->get_info(d - 1s);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    // CEST daylight savings time starts at 1am local time (UTC+1).\n+    info = tz->get_info(d);\n+    VERIFY( info.offset == 2h  );\n+    VERIFY( info.abbrev == \"CEST\" );\n+  }\n+\n+  {\n+    sys_days d = 1942y/October/Monday[1];\n+\n+    auto info = tz->get_info(d - 1s);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CET standard time starts at 2am local time (UTC+2).\n+    info = tz->get_info(d);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1943y/May/Monday[1];\n+\n+    // No daylight savings from 1943 until 1981.\n+    auto info = tz->get_info(d);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    info = tz->get_info(d + days(60));\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    info = tz->get_info(d + years(10));\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    info = tz->get_info(sys_days(1979y/June/3));\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    // Switzerland uses EU rules from 1981\n+    sys_days d = 1981y/March/Sunday[last];\n+\n+    auto info = tz->get_info(d);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    info = tz->get_info(d + 59min + 59s);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    // CEST begins at 1am UTC\n+    info = tz->get_info(d + 1h);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+  }\n+\n+  {\n+    sys_days d = 1981y/September/Sunday[last];\n+\n+    auto info = tz->get_info(d + 59min + 59s);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CEST ends at 1am UTC\n+    info = tz->get_info(d + 1h);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1994y/September/Sunday[last];\n+\n+    auto info = tz->get_info(d + 59min + 59s);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CEST ends at 1am UTC\n+    info = tz->get_info(d + 1h);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    d = 1995y/September/Sunday[last];\n+    info = tz->get_info(d + 59min + 59s);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CEST ends at 1am UTC\n+    info = tz->get_info(d + 1h);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    d = 1996y/September/Sunday[last];\n+    // CEST ends in October since 1996\n+    info = tz->get_info(d + 1h);\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    d = 1996y/October/Sunday[last];\n+    // CEST ends at 1am UTC\n+    info = tz->get_info(d + 1h);\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+}\n+\n+void\n+test_iterate()\n+{\n+  using namespace std::chrono;\n+  auto tz = locate_zone(\"Europe/Zurich\");\n+  sys_seconds start(sys_days(1850y/January/1));\n+  const sys_seconds finish(sys_days(1982y/January/1));\n+  long count = 0;\n+  do\n+  {\n+    VERIFY(++count < 100); // Fail if we get stuck in a loop.\n+    auto info = tz->get_info(start);\n+    start = info.end;\n+  } while (start < finish);\n+\n+  VERIFY(count == 10); // Would be 9 if identical adjacent sys_info get merged.\n+}\n+\n+void\n+test_shanghai()\n+{\n+  using namespace std::chrono;\n+  auto tz = locate_zone(\"Asia/Shanghai\");\n+  sys_info info = tz->get_info(sys_days(1949y/January/1));\n+  VERIFY( info.abbrev == \"CST\" );\n+}\n+\n+int main()\n+{\n+  test_zurich();\n+  test_iterate();\n+  test_shanghai();\n+}"}, {"sha": "9bbe3193b2d2d4b73e1cca4ac695f98f2ba04081", "filename": "libstdc++-v3/testsuite/std/time/time_zone/requirements.cc", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftime_zone%2Frequirements.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,25 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+\n+using std::chrono::time_zone;\n+\n+static_assert( std::is_move_constructible_v<time_zone> );\n+static_assert( std::is_move_assignable_v<time_zone> );\n+\n+static_assert( ! std::is_default_constructible_v<time_zone> );\n+static_assert( ! std::is_copy_constructible_v<time_zone> );\n+static_assert( ! std::is_copy_assignable_v<time_zone> );\n+\n+extern const time_zone* tz;\n+\n+static_assert( std::is_same_v<decltype(tz->name()), std::string_view> );\n+static_assert( noexcept(tz->name()) );\n+\n+static_assert( std::is_same_v<decltype(*tz == *tz), bool> );\n+static_assert( noexcept(*tz == *tz) );\n+\n+static_assert( std::is_same_v<decltype(*tz <=> *tz), std::strong_ordering> );\n+static_assert( noexcept(*tz <=> *tz) );"}, {"sha": "64e42701d3b93907867862640a6cb3a226c221e7", "filename": "libstdc++-v3/testsuite/std/time/tzdb/1.cc", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb%2F1.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,56 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+// { dg-additional-options \"-DHAVE_TZDB\" { target tzdb } }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::chrono;\n+\n+void\n+test_version()\n+{\n+  const tzdb& db = get_tzdb();\n+  VERIFY( &db == &get_tzdb_list().front() );\n+\n+#ifdef HAVE_TZDB\n+  VERIFY( db.version == remote_version() );\n+  const tzdb& reloaded = reload_tzdb();\n+  if (reloaded.version == db.version)\n+    VERIFY( &reloaded == &db );\n+#endif\n+}\n+\n+void\n+test_current()\n+{\n+#ifdef HAVE_TZDB\n+  const tzdb& db = get_tzdb();\n+  const time_zone* tz = db.current_zone();\n+  VERIFY( tz == std::chrono::current_zone() );\n+#endif\n+}\n+\n+void\n+test_locate()\n+{\n+  const tzdb& db = get_tzdb();\n+  const time_zone* tz = db.locate_zone(\"GMT\");\n+  VERIFY( tz != nullptr );\n+  VERIFY( tz->name() == \"Etc/GMT\" );\n+  VERIFY( tz == std::chrono::locate_zone(\"GMT\") );\n+  VERIFY( tz == db.locate_zone(\"Etc/GMT\") );\n+  VERIFY( tz == db.locate_zone(\"Etc/GMT+0\") );\n+\n+#ifdef HAVE_TZDB\n+  VERIFY( db.locate_zone(db.current_zone()->name()) == db.current_zone() );\n+#endif\n+}\n+\n+int main()\n+{\n+  test_version();\n+  test_current();\n+  test_locate();\n+}"}, {"sha": "82303e8bdf0324af3cef662cc64c2328d73aff30", "filename": "libstdc++-v3/testsuite/std/time/tzdb/leap_seconds.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb%2Fleap_seconds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb%2Fleap_seconds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb%2Fleap_seconds.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+// { dg-xfail-run-if \"no weak override on AIX\" { powerpc-ibm-aix* } }\n+\n+#include <chrono>\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+static bool override_used = true;\n+\n+namespace __gnu_cxx\n+{\n+  const char* zoneinfo_dir_override() {\n+    override_used = true;\n+    return \"./\";\n+  }\n+}\n+\n+void\n+test_load_leapseconds()\n+{\n+  std::ofstream(\"leapseconds\") << R\"(\n+# These are all the real leap seconds as of 2022:\n+Leap\t1972\tJun\t30\t23:59:60\t+\tS\n+Leap\t1972\tDec\t31\t23:59:60\t+\tS\n+Leap\t1973\tDec\t31\t23:59:60\t+\tS\n+Leap\t1974\tDec\t31\t23:59:60\t+\tS\n+Leap\t1975\tDec\t31\t23:59:60\t+\tS\n+Leap\t1976\tDec\t31\t23:59:60\t+\tS\n+Leap\t1977\tDec\t31\t23:59:60\t+\tS\n+Leap\t1978\tDec\t31\t23:59:60\t+\tS\n+Leap\t1979\tDec\t31\t23:59:60\t+\tS\n+Leap\t1981\tJun\t30\t23:59:60\t+\tS\n+Leap\t1982\tJun\t30\t23:59:60\t+\tS\n+Leap\t1983\tJun\t30\t23:59:60\t+\tS\n+Leap\t1985\tJun\t30\t23:59:60\t+\tS\n+Leap\t1987\tDec\t31\t23:59:60\t+\tS\n+Leap\t1989\tDec\t31\t23:59:60\t+\tS\n+Leap\t1990\tDec\t31\t23:59:60\t+\tS\n+Leap\t1992\tJun\t30\t23:59:60\t+\tS\n+Leap\t1993\tJun\t30\t23:59:60\t+\tS\n+Leap\t1994\tJun\t30\t23:59:60\t+\tS\n+Leap\t1995\tDec\t31\t23:59:60\t+\tS\n+Leap\t1997\tJun\t30\t23:59:60\t+\tS\n+Leap\t1998\tDec\t31\t23:59:60\t+\tS\n+Leap\t2005\tDec\t31\t23:59:60\t+\tS\n+Leap\t2008\tDec\t31\t23:59:60\t+\tS\n+Leap\t2012\tJun\t30\t23:59:60\t+\tS\n+Leap\t2015\tJun\t30\t23:59:60\t+\tS\n+Leap\t2016\tDec\t31\t23:59:60\t+\tS\n+# These are fake leap seconds for testing purposes:\n+Leap\t2093\tJun\t30\t23:59:59\t-\tS\n+Leap\t2093\tDec\t31\t23:59:60\t+\tS\n+)\";\n+\n+  const auto& db = std::chrono::get_tzdb();\n+  VERIFY( override_used ); // If this fails then XFAIL for the target.\n+\n+  using namespace std::chrono;\n+  // XXX update this value if the number of hardcoded leap seconds changes:\n+  VERIFY( db.leap_seconds.size() == 29 );\n+\n+  auto i = db.leap_seconds.end() - 2;\n+\n+  VERIFY( i[0].date() == sys_days(2093y/July/1) - 1s );\n+  VERIFY( i[0].value() == -1s );\n+\n+  VERIFY( i[1].date() == sys_days(2094y/January/1) );\n+  VERIFY( i[1].value() == 1s );\n+}\n+\n+int main()\n+{\n+  test_load_leapseconds();\n+}"}, {"sha": "4cbd656efbd390e3560ba61eeff4bbed861f88be", "filename": "libstdc++-v3/testsuite/std/time/tzdb_list/1.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb_list%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb_list%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb_list%2F1.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,123 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+// { dg-xfail-run-if \"no weak override on AIX\" { powerpc-ibm-aix* } }\n+\n+#include <chrono>\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+static bool override_used = true;\n+\n+namespace __gnu_cxx\n+{\n+  const char* zoneinfo_dir_override() {\n+    override_used = true;\n+    return \"./\";\n+  }\n+}\n+\n+std::string tzdata_zi = R\"(\n+ # version test1\n+ # Rule  NAME  FROM  TO    TYPE  IN   ON       AT    SAVE  LETTER/S\n+ Rule    Swiss 1941  1942  -     May  Mon>=1   1:00  1:00  S\n+ Rule    Swiss 1941  1942  -     Oct  Mon>=1   2:00  0     -\n+ Rule    EU    1977  1980  -     Apr  Sun>=1   1:00u 1:00  S\n+ Rule    EU    1977  only  -     Sep  lastSun  1:00u 0     -\n+ Rule    EU    1978  only  -     Oct   1       1:00u 0     -\n+ Rule    EU    1979  1995  -     Sep  lastSun  1:00u 0     -\n+ Rule    EU    1981  max   -     Mar  lastSun  1:00u 1:00  S\n+ Rule    EU    1996  max   -     Oct  lastSun  1:00u 0     -\n+\n+ # Zone  NAME           STDOFF      RULES  FORMAT  [UNTIL]\n+ Zone    Europe/Zurich  0:34:08     -      LMT     1853 Jul 16\n+                        0:29:45.50  -      BMT     1894 Jun\n+                        1:00        Swiss  CE%sT   1981\n+                        1:00        EU     CE%sT\n+\n+ Link    Europe/Zurich  Europe/Vaduz\n+\n+)\";\n+\n+using namespace std::chrono;\n+\n+void\n+test_access()\n+{\n+  tzdb_list& list = get_tzdb_list();\n+  tzdb_list::const_iterator first = list.begin();\n+  tzdb_list::const_iterator last = list.end();\n+  VERIFY( list.cbegin() == first );\n+  VERIFY( list.cend() == last );\n+  VERIFY( first != last );\n+  VERIFY( &*first == &get_tzdb() );\n+  VERIFY( &*first == &list.front() );\n+  VERIFY( std::next(first) == last );\n+  first++;\n+  VERIFY( first == last );\n+}\n+\n+void\n+test_reload()\n+{\n+  tzdb_list& list = get_tzdb_list();\n+  tzdb_list::const_iterator test1 = list.begin();\n+  reload_tzdb();\n+  VERIFY( list.begin() == test1 );\n+  VERIFY( std::distance(list.begin(), list.end()) == 1 );\n+\n+  std::string new_tzdata_zi = tzdata_zi;\n+  auto pos = new_tzdata_zi.find(\"test\");\n+  new_tzdata_zi[pos + 4] = '2';\n+  std::ofstream(\"tzdata.zi\") << new_tzdata_zi;\n+  VERIFY( remote_version() == \"test2\" );\n+\n+  // List doesn't reload until requested to.\n+  VERIFY( get_tzdb_list().begin() == test1 );\n+  VERIFY( &get_tzdb() == &*test1 );\n+  reload_tzdb();\n+  VERIFY( list.begin() != test1 );\n+  VERIFY( std::distance(list.begin(), list.end()) == 2 );\n+  VERIFY( test1 == std::next(list.begin()) );\n+  VERIFY( &get_tzdb() == &*list.begin() );\n+  VERIFY( list.begin()->version == \"test2\" );\n+  VERIFY( test1->version == \"test1\" );\n+}\n+\n+void\n+test_erase()\n+{\n+  tzdb_list& list = get_tzdb_list();\n+  const int count = std::distance(list.begin(), list.end());\n+  tzdb_list::const_iterator test2 = list.begin();\n+\n+  std::string new_tzdata_zi = tzdata_zi;\n+  auto pos = new_tzdata_zi.find(\"test\");\n+  new_tzdata_zi[pos + 4] = '3';\n+  std::ofstream(\"tzdata.zi\") << new_tzdata_zi;\n+\n+  reload_tzdb();\n+  VERIFY( std::distance(list.begin(), list.end()) == count + 1 );\n+  VERIFY( list.begin()->version == \"test3\" );\n+  list.erase_after(list.begin());\n+  VERIFY( std::distance(list.begin(), list.end()) == count );\n+  VERIFY( list.begin()->version == \"test3\" );\n+  VERIFY( std::next(list.begin())->version == \"test1\" );\n+\n+  // As a GCC extension, the erased node is not destroyed\n+  // while there are iterators referring to it.\n+  VERIFY( test2->version == \"test2\" );\n+  VERIFY( test2->leap_seconds == list.begin()->leap_seconds );\n+  // But the iterator points to an unlinked list node now:\n+  VERIFY( std::next(test2) == tzdb_list::const_iterator() );\n+}\n+\n+int main()\n+{\n+  std::ofstream(\"leapseconds\") << '\\n';\n+  std::ofstream(\"tzdata.zi\") << tzdata_zi;\n+\n+  test_access();\n+  test_reload();\n+  test_erase();\n+}"}, {"sha": "a2fd8a4eb575bf97be22989b0f2d7a24e9322327", "filename": "libstdc++-v3/testsuite/std/time/tzdb_list/requirements.cc", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb_list%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb_list%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Ftzdb_list%2Frequirements.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+\n+using std::chrono::tzdb_list;\n+\n+static_assert( ! std::is_default_constructible_v<tzdb_list> );\n+static_assert( ! std::is_copy_constructible_v<tzdb_list> );\n+static_assert( ! std::is_copy_assignable_v<tzdb_list> );\n+static_assert( ! std::is_move_constructible_v<tzdb_list> );\n+static_assert( ! std::is_move_assignable_v<tzdb_list> );\n+static_assert( std::is_destructible_v<tzdb_list> );\n+\n+using IterTraits = std::iterator_traits<tzdb_list::const_iterator>;\n+\n+static_assert( std::is_same_v<IterTraits::iterator_category,\n+\t\t\t      std::forward_iterator_tag> );\n+static_assert( std::is_same_v<IterTraits::value_type, std::chrono::tzdb> );"}, {"sha": "d9083048b5461660e941bb7130c59df98516f90d", "filename": "libstdc++-v3/testsuite/std/time/zoned_time/1.cc", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2F1.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,255 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target tzdb }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+void\n+test_members()\n+{\n+  using namespace std::chrono;\n+\n+  const time_zone* const zone = locate_zone(\"Europe/London\");\n+\n+  sys_time<minutes> t = sys_days(2022y/February/1) + 1h + 23min;\n+  zoned_time<minutes> zt(\"Europe/London\", t);\n+  VERIFY( zt.get_time_zone() == zone );\n+  VERIFY( zt.get_sys_time() == t);\n+  VERIFY( zt.get_local_time().time_since_epoch() == t.time_since_epoch() );\n+  VERIFY( zt.get_info().offset == 0h );\n+  VERIFY( zt.get_info().abbrev == \"GMT\" );\n+  VERIFY( static_cast<sys_seconds>(zt) == t );\n+  VERIFY( static_cast<local_seconds>(zt) == zt.get_local_time() );\n+\n+  t = sys_days(2022y/June/1);\n+  zt = t;\n+  VERIFY( zt.get_time_zone() == zone );\n+  VERIFY( zt.get_sys_time() == t);\n+  VERIFY( zt.get_local_time().time_since_epoch() == t.time_since_epoch() + 1h );\n+  VERIFY( zt.get_info().offset == 1h );\n+  VERIFY( zt.get_info().abbrev == \"BST\" );\n+  VERIFY( static_cast<sys_seconds>(zt) == t );\n+  VERIFY( static_cast<local_seconds>(zt) == zt.get_local_time() );\n+\n+  zoned_seconds zs(zt);\n+  VERIFY( zs == zt );\n+\n+  local_time<seconds> local(zt.get_local_time() + days(1) + hours(2));\n+  zt = time_point_cast<minutes>(local);\n+  VERIFY( zt.get_sys_time() == zs.get_sys_time() + days(1) + hours(2) );\n+}\n+\n+void\n+test_zurich()\n+{\n+  using namespace std::chrono;\n+\n+  const time_zone* const zurich = locate_zone(\"Europe/Zurich\");\n+\n+  {\n+    sys_days d = 1853y/July/16;\n+\n+    auto z = zoned_seconds(zurich, sys_seconds(d) - 1s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == (34min + 8s) );\n+    VERIFY( info.abbrev == \"LMT\" );\n+\n+    z = zoned_seconds(zurich, d);\n+    info = z.get_info();\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+\n+    z = zoned_seconds(zurich, d + 1s);\n+    info = z.get_info();\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+\n+    auto z2 = zoned_time(zurich, d + 0.001s);\n+    info = z2.get_info();\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+  }\n+\n+  {\n+    sys_days d = 1894y/June/1;\n+\n+    auto z = zoned_seconds(zurich, sys_seconds(d) - 1s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == (29min + 46s) );\n+    VERIFY( info.abbrev == \"BMT\" );\n+\n+    z = zoned_seconds(zurich, d);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1941y/May/Monday[1];\n+\n+    auto z = zoned_seconds(zurich, d - 1s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    // CEST daylight savings time starts at 1am local time (UTC+1).\n+    z = zoned_seconds(zurich, d);\n+    info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+  }\n+\n+  {\n+    sys_days d = 1941y/October/Monday[1];\n+\n+    auto z = zoned_seconds(zurich, d - 1s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CET standard time starts at 2am local time (UTC+2).\n+    z = zoned_seconds(zurich, d);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h  );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1942y/May/Monday[1];\n+\n+    auto z = zoned_seconds(zurich, d - 1s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    // CEST daylight savings time starts at 1am local time (UTC+1).\n+    z = zoned_seconds(zurich, d);\n+    info = z.get_info();\n+    VERIFY( info.offset == 2h  );\n+    VERIFY( info.abbrev == \"CEST\" );\n+  }\n+\n+  {\n+    sys_days d = 1942y/October/Monday[1];\n+\n+    auto z = zoned_seconds(zurich, d - 1s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CET standard time starts at 2am local time (UTC+2).\n+    z = zoned_seconds(zurich, d);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1943y/May/Monday[1];\n+\n+    // No daylight savings from 1943 until 1981.\n+    auto z = zoned_seconds(zurich, d);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    z = zoned_seconds(zurich, d + days(60));\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    z = zoned_seconds(zurich, d + years(10));\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    z = zoned_seconds(zurich, sys_days(1979y/June/3));\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    // Switzerland uses EU rules from 1981\n+    sys_days d = 1981y/March/Sunday[last];\n+\n+    auto z = zoned_seconds(zurich, d);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    z = zoned_seconds(zurich, d + 59min + 59s);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    // CEST begins at 1am UTC\n+    z = zoned_seconds(zurich, d + 1h);\n+    info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+  }\n+\n+  {\n+    sys_days d = 1981y/September/Sunday[last];\n+\n+    auto z = zoned_seconds(zurich, d + 59min + 59s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CEST ends at 1am UTC\n+    z = zoned_seconds(zurich, d + 1h);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+\n+  {\n+    sys_days d = 1994y/September/Sunday[last];\n+\n+    auto z = zoned_seconds(zurich, d + 59min + 59s);\n+    auto info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    // CEST ends at 1am UTC\n+    z = zoned_seconds(zurich, d + 1h);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    d = 1995y/September/Sunday[last];\n+    z = zoned_seconds(zurich, d + 59min + 59s);\n+    info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+    // CEST ends at 1am UTC\n+    z = zoned_seconds(zurich, d + 1h);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+\n+    d = 1996y/September/Sunday[last];\n+    // CEST ends in October since 1996\n+    z = zoned_seconds(zurich, d + 1h);\n+    info = z.get_info();\n+    VERIFY( info.offset == 2h );\n+    VERIFY( info.abbrev == \"CEST\" );\n+\n+    d = 1996y/October/Sunday[last];\n+    // CEST ends at 1am UTC\n+    z = zoned_seconds(zurich, d + 1h);\n+    info = z.get_info();\n+    VERIFY( info.offset == 1h );\n+    VERIFY( info.abbrev == \"CET\" );\n+  }\n+}\n+\n+int main()\n+{\n+  test_members();\n+  test_zurich();\n+}"}, {"sha": "dc2d9c00c8d2ad1110adf66aea3193d18cdaa4ba", "filename": "libstdc++-v3/testsuite/std/time/zoned_time/custom.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Fcustom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Fcustom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Fcustom.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target tzdb }\n+\n+#include <chrono>\n+#include <set>\n+#include <stdexcept>\n+#include <testsuite_hooks.h>\n+\n+struct local_tz\n+{\n+  local_tz() : name(std::chrono::current_zone()->name()) { }\n+\n+  explicit local_tz(std::string_view name) : name(name) { }\n+\n+  template<typename Dur>\n+    std::chrono::sys_time<Dur> to_sys(const std::chrono::local_time<Dur>& d)\n+    { return std::chrono::locate_zone(name)->to_sys(d); }\n+\n+  template<typename Dur>\n+    std::chrono::sys_time<Dur> to_local(const std::chrono::sys_time<Dur>& d)\n+    { return std::chrono::locate_zone(name)->to_sys(d); }\n+\n+  template<typename Dur>\n+    std::chrono::sys_info get_info(const std::chrono::sys_time<Dur>& d)\n+    { return std::chrono::locate_zone(name)->get_info(d); }\n+\n+  struct indirect_cmp\n+  {\n+    bool operator()(const local_tz* lhs, const local_tz* rhs) const\n+    { return lhs->name < rhs->name; }\n+  };\n+\n+  bool eq(const std::chrono::time_zone* tz) const noexcept\n+  { return name == tz->name(); }\n+\n+private:\n+  std::string_view name;\n+};\n+\n+template<> struct std::chrono::zoned_traits<const local_tz*>\n+{\n+  static const local_tz* default_zone()\n+  {\n+    return locate_zone(std::chrono::current_zone()->name());\n+  }\n+\n+  static const local_tz* locate_zone(std::string_view name)\n+  {\n+    static std::set<const local_tz*, local_tz::indirect_cmp> zones;\n+    local_tz tz(name);\n+    if (auto z = zones.find(&tz); z != zones.end())\n+      return *z;\n+    if (std::chrono::locate_zone(name))\n+      return *zones.insert(new local_tz(tz)).first;\n+    throw std::runtime_error(\"zone not found\");\n+  }\n+};\n+\n+void\n+test_custom_tzptr()\n+{\n+  using namespace std::chrono;\n+\n+  zoned_time<seconds, const local_tz*> z;\n+  VERIFY( z.get_time_zone()->eq(std::chrono::current_zone()) );\n+\n+  zoned_time<seconds, const local_tz*> z2(std::string_view(\"Europe/London\"));\n+  VERIFY( z2.get_time_zone()->eq(std::chrono::locate_zone(\"Europe/London\")) );\n+}\n+\n+int main()\n+{\n+  test_custom_tzptr();\n+}"}, {"sha": "a26a6f49d77cb16501a8e4352f73ea0122faa7b9", "filename": "libstdc++-v3/testsuite/std/time/zoned_time/deduction.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Fdeduction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Fdeduction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Fdeduction.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+\n+using namespace std::chrono;\n+\n+struct local_tz : time_zone { local_tz(); };\n+\n+template<> struct std::chrono::zoned_traits<const local_tz*>\n+{\n+  static auto default_zone() { return current_zone(); }\n+\n+  static auto locate_zone(std::string_view name)\n+  { return std::chrono::locate_zone(name); }\n+};\n+\n+void\n+test_ctad()\n+{\n+  zoned_time z1;\n+  static_assert( std::is_same_v<decltype(z1), zoned_time<seconds>> );\n+  zoned_time z2 = z1;\n+  static_assert( std::is_same_v<decltype(z2), decltype(z1)> );\n+\n+  zoned_time z3 = sys_time<milliseconds>();\n+  static_assert( std::is_same_v<decltype(z3), zoned_time<milliseconds>> );\n+\n+  const local_tz ltz;\n+  zoned_time z4(&ltz);\n+  static_assert( std::is_same_v<decltype(z4),\n+\t\t\t\tzoned_time<seconds, const local_tz*>> );\n+\n+  zoned_time z5(\"GMT\");\n+  static_assert( std::is_same_v<decltype(z5), zoned_time<seconds>> );\n+\n+  zoned_time z6(&ltz, sys_time<minutes>());\n+  static_assert( std::is_same_v<decltype(z6),\n+\t\t\t\tzoned_time<seconds, const local_tz*>> );\n+\n+  zoned_time z7(&ltz, sys_time<milliseconds>());\n+  static_assert( std::is_same_v<decltype(z7),\n+\t\t\t\tzoned_time<milliseconds, const local_tz*>> );\n+\n+  zoned_time z8(\"GMT\", sys_time<minutes>());\n+  static_assert( std::is_same_v<decltype(z8), zoned_time<seconds>> );\n+\n+  zoned_time z9(\"GMT\", sys_time<microseconds>());\n+  static_assert( std::is_same_v<decltype(z9), zoned_time<microseconds>> );\n+\n+  zoned_time z10(&ltz, local_time<minutes>());\n+  static_assert( std::is_same_v<decltype(z10),\n+\t\t\t\tzoned_time<seconds, const local_tz*>> );\n+\n+  zoned_time z11(&ltz, local_time<nanoseconds>(), choose::earliest);\n+  static_assert( std::is_same_v<decltype(z11),\n+\t\t\t\tzoned_time<nanoseconds, const local_tz*>> );\n+\n+  zoned_time z12(\"GMT\", local_time<minutes>());\n+  static_assert( std::is_same_v<decltype(z12), zoned_time<seconds>> );\n+\n+  zoned_time z13(\"GMT\", local_time<nanoseconds>(), choose::earliest);\n+  static_assert( std::is_same_v<decltype(z13), zoned_time<nanoseconds>> );\n+\n+  zoned_time z14(&ltz, z13);\n+  static_assert( std::is_same_v<decltype(z14),\n+\t\t\t\tzoned_time<nanoseconds, const local_tz*>> );\n+\n+  zoned_time z15(&ltz, z12, choose::earliest);\n+  static_assert( std::is_same_v<decltype(z15),\n+\t\t\t\tzoned_time<seconds, const local_tz*>> );\n+\n+  zoned_time z16(\"GMT\", z14);\n+  static_assert( std::is_same_v<decltype(z16), zoned_time<nanoseconds>> );\n+\n+  zoned_time z17(\"GMT\", z12, choose::earliest);\n+  static_assert( std::is_same_v<decltype(z17), zoned_time<seconds>> );\n+}"}, {"sha": "ae51a250ee9f7b213a4570e829a60ab07786b48a", "filename": "libstdc++-v3/testsuite/std/time/zoned_time/req_neg.cc", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Freq_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Freq_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Freq_neg.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,9 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+\n+std::chrono::zoned_time<std::chrono::year> z; // { dg-error \"here\" }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 0 }\n+// { dg-prune-output \"common_type\" }"}, {"sha": "6334e5895439b7561ce11ec70fd5dd6350da2587", "filename": "libstdc++-v3/testsuite/std/time/zoned_time/requirements.cc", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_time%2Frequirements.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,27 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+\n+using namespace std::chrono;\n+\n+static_assert( std::is_default_constructible_v<zoned_time<seconds>> );\n+static_assert( std::is_copy_constructible_v<zoned_time<seconds>> );\n+static_assert( std::is_copy_assignable_v<zoned_time<seconds>> );\n+static_assert( std::is_move_constructible_v<zoned_time<seconds>> );\n+static_assert( std::is_move_assignable_v<zoned_time<seconds>> );\n+static_assert( std::is_destructible_v<zoned_time<seconds>> );\n+\n+static_assert( std::is_same_v<zoned_time<seconds>::duration, seconds> );\n+static_assert( std::is_same_v<zoned_time<nanoseconds>::duration, nanoseconds> );\n+static_assert( std::is_same_v<zoned_time<minutes>::duration, seconds> );\n+\n+extern zoned_time<minutes> z;\n+static_assert( std::is_same_v<decltype(z == z), bool> );\n+\n+// requires zoned_traits<time_zone*>::default_zone().\n+static_assert( ! std::is_default_constructible_v<zoned_time<seconds, time_zone*>> );\n+// requires zoned_traits<time_zone*>::locate_zone(string_view).\n+static_assert( ! std::is_constructible_v<zoned_time<seconds, time_zone*>,\n+\t\t\t\t\t std::string_view> );"}, {"sha": "0cab8a2d47f8c78d69ec18707b7c9576350121b1", "filename": "libstdc++-v3/testsuite/std/time/zoned_traits.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fc61d45fa15fdd3b084d30998ecda164af33e95/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fzoned_traits.cc?ref=9fc61d45fa15fdd3b084d30998ecda164af33e95", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do run { target c++20 } }\n+// { dg-require-effective-target cxx11_abi }\n+\n+#include <chrono>\n+#include <testsuite_hooks.h>\n+\n+using namespace std::chrono;\n+\n+static_assert( std::is_empty_v<zoned_traits<const time_zone*>> );\n+static_assert(std::is_default_constructible_v<zoned_traits<const time_zone*>>);\n+\n+// The primary template is a complete type, it just has no members.\n+static_assert( std::is_empty_v<zoned_traits<time_zone*>> );\n+static_assert(std::is_default_constructible_v<zoned_traits<time_zone*>>);\n+static_assert( std::is_empty_v<zoned_traits<int>> );\n+static_assert(std::is_default_constructible_v<zoned_traits<int>>);\n+\n+void\n+test_default_zone()\n+{\n+  auto p = zoned_traits<const time_zone*>::default_zone();\n+  static_assert( std::is_same_v<decltype(p), const time_zone*> );\n+  VERIFY( p == locate_zone(\"UTC\") );\n+}\n+\n+void\n+test_locate_zone()\n+{\n+  auto p = zoned_traits<const time_zone*>::locate_zone(\"GMT\");\n+  static_assert( std::is_same_v<decltype(p), const time_zone*> );\n+  VERIFY( p == locate_zone(\"GMT\") );\n+}\n+\n+int main()\n+{\n+  test_default_zone();\n+  test_locate_zone();\n+}"}]}