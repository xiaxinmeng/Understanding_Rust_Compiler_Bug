{"sha": "012a7a78174b3612ea3a63944d70ee714bb4e9cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDEyYTdhNzgxNzRiMzYxMmVhM2E2Mzk0NGQ3MGVlNzE0YmI0ZTljZg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-10-04T03:02:19Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-10-04T03:02:19Z"}, "message": "re PR tree-optimization/23445 (ICE with -O1 -ftree-vrp -fdelete-null-pointer-checks)\n\n\n\tPR 23445\n\t* tree-vrp.c (extract_range_from_assert): If the new numeric\n\trange created out of the assertion contradicts the existing\n\tnumeric range of the ASSERT_EXPR variable, make the new range\n\tvarying.\n\ntestsuite/\n\tPR 23445\n\t* gcc.c-torture/compile/pr23445.c: New test.\n\nFrom-SVN: r104936", "tree": {"sha": "bad0acaaba7970ed145f998726734ce13187ad34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bad0acaaba7970ed145f998726734ce13187ad34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/012a7a78174b3612ea3a63944d70ee714bb4e9cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012a7a78174b3612ea3a63944d70ee714bb4e9cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/012a7a78174b3612ea3a63944d70ee714bb4e9cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/012a7a78174b3612ea3a63944d70ee714bb4e9cf/comments", "author": null, "committer": null, "parents": [{"sha": "5c06c5cef5a993cd7f35daecf6a2e43447a2a476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c06c5cef5a993cd7f35daecf6a2e43447a2a476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c06c5cef5a993cd7f35daecf6a2e43447a2a476"}], "stats": {"total": 125, "additions": 106, "deletions": 19}, "files": [{"sha": "229ef27c46ef056b76de6fdb91e56e2125cb4f6d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=012a7a78174b3612ea3a63944d70ee714bb4e9cf", "patch": "@@ -1,3 +1,11 @@\n+2005-10-03  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 23445\n+\t* tree-vrp.c (extract_range_from_assert): If the new numeric\n+\trange created out of the assertion contradicts the existing\n+\tnumeric range of the ASSERT_EXPR variable, make the new range\n+\tvarying.\n+\n 2005-10-03  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.c (sh_register_move_cost): Add case for moving"}, {"sha": "6aa6e81b5e977cf09c54026ffa1ca1e5adbaed20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=012a7a78174b3612ea3a63944d70ee714bb4e9cf", "patch": "@@ -1,3 +1,8 @@\n+2005-10-03  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 23445\n+\t* gcc.c-torture/compile/pr23445.c: New test.\n+\n 2005-10-03  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* g++.dg/overload/unknown1.C: New."}, {"sha": "3ddf9b702c7b7f62b556b7a5280b4b5716476535", "filename": "gcc/testsuite/gcc.c-torture/compile/pr23445.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr23445.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr23445.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr23445.c?ref=012a7a78174b3612ea3a63944d70ee714bb4e9cf", "patch": "@@ -0,0 +1,10 @@\n+ struct buffer_head {\n+   char *b_data;\n+ };\n+   void asfs_deletebnode( struct buffer_head *bhsec)  {\n+     if (bhsec == 0)   {\n+     void *bnc2 = (void *) bhsec->b_data;\n+     if (bnc2)       return;\n+     if (bhsec)       __brelse(bhsec);\n+   }\n+ }"}, {"sha": "e9d6c81c7d478512f31d270f4a26da9014debe1b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 83, "deletions": 19, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/012a7a78174b3612ea3a63944d70ee714bb4e9cf/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=012a7a78174b3612ea3a63944d70ee714bb4e9cf", "patch": "@@ -880,29 +880,93 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n   else\n     gcc_unreachable ();\n \n-  /* If VAR already had a known range and the two ranges have a\n-     non-empty intersection, we can refine the resulting range.\n-     Since the assert expression creates an equivalency and at the\n-     same time it asserts a predicate, we can take the intersection of\n-     the two ranges to get better precision.  */\n+  /* If VAR already had a known range, it may happen that the new\n+     range we have computed and VAR's range are not compatible.  For\n+     instance,\n+\n+\tif (p_5 == NULL)\n+\t  p_6 = ASSERT_EXPR <p_5, p_5 == NULL>;\n+\t  x_7 = p_6->fld;\n+\t  p_8 = ASSERT_EXPR <p_6, p_6 != NULL>;\n+\n+     While the above comes from a faulty program, it will cause an ICE\n+     later because p_8 and p_6 will have incompatible ranges and at\n+     the same time will be considered equivalent.  A similar situation\n+     would arise from\n+\n+     \tif (i_5 > 10)\n+\t  i_6 = ASSERT_EXPR <i_5, i_5 > 10>;\n+\t  if (i_5 < 5)\n+\t    i_7 = ASSERT_EXPR <i_6, i_6 < 5>;\n+\n+     Again i_6 and i_7 will have incompatible ranges.  It would be\n+     pointless to try and do anything with i_7's range because\n+     anything dominated by 'if (i_5 < 5)' will be optimized away.\n+     Note, due to the wa in which simulation proceeds, the statement\n+     i_7 = ASSERT_EXPR <...> we would never be visited because the\n+     conditiona 'if (i_5 < 5)' always evaluates to false.  However,\n+     this extra check does not hurt and may protect against future\n+     changes to VRP that may get into a situation similar to the\n+     NULL pointer dereference example.\n+\n+     Note that these compatibility tests are only needed when dealing\n+     with ranges or a mix of range and anti-range.  If VAR_VR and VR_P\n+     are both anti-ranges, they will always be compatible, because two\n+     anti-ranges will always have a non-empty intersection.  */\n+\n   var_vr = get_value_range (var);\n-  if (var_vr->type == VR_RANGE\n-      && vr_p->type == VR_RANGE\n-      && value_ranges_intersect_p (var_vr, vr_p))\n+\n+  /* We may need to make adjustments when VR_P and VAR_VR are numeric\n+     ranges or anti-ranges.  */\n+  if (vr_p->type == VR_VARYING\n+      || vr_p->type == VR_UNDEFINED\n+      || var_vr->type == VR_VARYING\n+      || var_vr->type == VR_UNDEFINED\n+      || symbolic_range_p (vr_p)\n+      || symbolic_range_p (var_vr))\n+    return;\n+\n+  if (var_vr->type == VR_RANGE && vr_p->type == VR_RANGE)\n     {\n-      /* Use the larger of the two minimums.  */\n-      if (compare_values (vr_p->min, var_vr->min) == -1)\n-\tmin = var_vr->min;\n-      else\n-\tmin = vr_p->min;\n+      /* If the two ranges have a non-empty intersection, we can\n+\t refine the resulting range.  Since the assert expression\n+\t creates an equivalency and at the same time it asserts a\n+\t predicate, we can take the intersection of the two ranges to\n+\t get better precision.  */\n+      if (value_ranges_intersect_p (var_vr, vr_p))\n+\t{\n+\t  /* Use the larger of the two minimums.  */\n+\t  if (compare_values (vr_p->min, var_vr->min) == -1)\n+\t    min = var_vr->min;\n+\t  else\n+\t    min = vr_p->min;\n \n-      /* Use the smaller of the two maximums.  */\n-      if (compare_values (vr_p->max, var_vr->max) == 1)\n-\tmax = var_vr->max;\n-      else\n-\tmax = vr_p->max;\n+\t  /* Use the smaller of the two maximums.  */\n+\t  if (compare_values (vr_p->max, var_vr->max) == 1)\n+\t    max = var_vr->max;\n+\t  else\n+\t    max = vr_p->max;\n \n-      set_value_range (vr_p, vr_p->type, min, max, vr_p->equiv);\n+\t  set_value_range (vr_p, vr_p->type, min, max, vr_p->equiv);\n+\t}\n+      else\n+\t{\n+\t  /* The two ranges do not intersect, set the new range to\n+\t     VARYING, because we will not be able to do anything\n+\t     meaningful with it.  */\n+\t  set_value_range_to_varying (vr_p);\n+\t}\n+    }\n+  else if ((var_vr->type == VR_RANGE && vr_p->type == VR_ANTI_RANGE)\n+           || (var_vr->type == VR_ANTI_RANGE && vr_p->type == VR_RANGE))\n+    {\n+      /* A range and an anti-range will cancel each other only if\n+\t their ends are the same.  For instance, in the example above,\n+\t p_8's range ~[0, 0] and p_6's range [0, 0] are incompatible,\n+\t so VR_P should be set to VR_VARYING.  */\n+      if (compare_values (var_vr->min, vr_p->min) == 0\n+\t  && compare_values (var_vr->max, vr_p->max) == 0)\n+\tset_value_range_to_varying (vr_p);\n     }\n }\n "}]}