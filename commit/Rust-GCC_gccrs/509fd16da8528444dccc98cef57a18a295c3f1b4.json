{"sha": "509fd16da8528444dccc98cef57a18a295c3f1b4", "node_id": "C_kwDOANBUbNoAKDUwOWZkMTZkYTg1Mjg0NDRkY2NjOThjZWY1N2ExOGEyOTVjM2YxYjQ", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-04-28T17:10:56Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-04-28T17:10:56Z"}, "message": "c++: partial ordering and dependent operator expr [PR105425]\n\nHere ever since r12-6022-gbb2a7f80a98de3 we stopped deeming the partial\nspecialization #2 to be more specialized than #1 ultimately because\ndependent operator expressions now have a DEPENDENT_OPERATOR_TYPE type\ninstead of an empty type, and this made unify stop deducing T(2) == 1\nfor K during partial ordering for #1 and #2.\n\nThis minimal patch fixes this by making the relevant logic in unify\ntreat DEPENDENT_OPERATOR_TYPE like an empty type.\n\n\tPR c++/105425\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (unify) <case TEMPLATE_PARM_INDEX>: Treat\n\tDEPENDENT_OPERATOR_TYPE like an empty type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/template/partial-specialization13.C: New test.", "tree": {"sha": "f8705575195f374406e713769eaaa49bce3a80a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8705575195f374406e713769eaaa49bce3a80a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/509fd16da8528444dccc98cef57a18a295c3f1b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509fd16da8528444dccc98cef57a18a295c3f1b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509fd16da8528444dccc98cef57a18a295c3f1b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509fd16da8528444dccc98cef57a18a295c3f1b4/comments", "author": null, "committer": null, "parents": [{"sha": "1a5ae012ff3303a8232a03ac9a0925c709775076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a5ae012ff3303a8232a03ac9a0925c709775076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a5ae012ff3303a8232a03ac9a0925c709775076"}], "stats": {"total": 14, "additions": 13, "deletions": 1}, "files": [{"sha": "81f7ef5c42b5fa42db467c97966b97a41df2686f", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509fd16da8528444dccc98cef57a18a295c3f1b4/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509fd16da8528444dccc98cef57a18a295c3f1b4/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=509fd16da8528444dccc98cef57a18a295c3f1b4", "patch": "@@ -24276,7 +24276,8 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t    }\n \t}\n \n-      if (!TREE_TYPE (arg))\n+      if (!TREE_TYPE (arg)\n+\t  || TREE_CODE (TREE_TYPE (arg)) == DEPENDENT_OPERATOR_TYPE)\n \t/* Template-parameter dependent expression.  Just accept it for now.\n \t   It will later be processed in convert_template_argument.  */\n \t;"}, {"sha": "b0903f0d60afcb1a8a4c8bb598e5b0c96cf22c19", "filename": "gcc/testsuite/g++.dg/template/partial-specialization13.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/509fd16da8528444dccc98cef57a18a295c3f1b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial-specialization13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/509fd16da8528444dccc98cef57a18a295c3f1b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial-specialization13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpartial-specialization13.C?ref=509fd16da8528444dccc98cef57a18a295c3f1b4", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/105425\n+// { dg-do compile { target c++11 } }\n+\n+template<bool> struct when;\n+template<class, class> struct A;\n+template<class T, bool K> struct A<T, when<K>>;            // #1\n+template<class T>         struct A<T, when<T(2) == 1>> {}; // #2\n+A<int, when<true>> a1; // { dg-error \"incomplete\" }\n+A<int, when<false>> a2;\n+A<bool, when<true>> a3;\n+A<bool, when<false>> a4; // { dg-error \"incomplete\" }"}]}