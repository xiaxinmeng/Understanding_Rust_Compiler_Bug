{"sha": "9fa6d012c05feb0f76406b9b3d088fd1708bc721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZhNmQwMTJjMDVmZWIwZjc2NDA2YjliM2QwODhmZDE3MDhiYzcyMQ==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-04-03T23:19:41Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-04-03T23:19:41Z"}, "message": "(force_to_mode, case PLUS): Sign extend masks that are negative in OP_MODE.\n\n(simplify_and_const_int): Sign-extend constants when they have the\nmost significant bit set for the target.\n(merge_outer_ops): Likewise.\n(simplify_shift_const): Likewise.\n\nFrom-SVN: r9310", "tree": {"sha": "d01dc8b076d58e1e9ac979e164a08471027a2efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d01dc8b076d58e1e9ac979e164a08471027a2efd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fa6d012c05feb0f76406b9b3d088fd1708bc721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa6d012c05feb0f76406b9b3d088fd1708bc721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fa6d012c05feb0f76406b9b3d088fd1708bc721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fa6d012c05feb0f76406b9b3d088fd1708bc721/comments", "author": null, "committer": null, "parents": [{"sha": "ad89d6f68a89f4370430e37a22c60dc62c946623", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad89d6f68a89f4370430e37a22c60dc62c946623", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad89d6f68a89f4370430e37a22c60dc62c946623"}], "stats": {"total": 74, "additions": 66, "deletions": 8}, "files": [{"sha": "48e5a87c2ac86e424d7728a42bd93cf6a7c36e95", "filename": "gcc/combine.c", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fa6d012c05feb0f76406b9b3d088fd1708bc721/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fa6d012c05feb0f76406b9b3d088fd1708bc721/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=9fa6d012c05feb0f76406b9b3d088fd1708bc721", "patch": "@@ -5795,13 +5795,26 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t low-order bits (as in an alignment operation) and FOO is already\n \t aligned to that boundary, mask C1 to that boundary as well.\n \t This may eliminate that PLUS and, later, the AND.  */\n-      if (GET_CODE (XEXP (x, 1)) == CONST_INT\n-\t  && exact_log2 (- mask) >= 0\n-\t  && (nonzero_bits (XEXP (x, 0), mode) & ~ mask) == 0\n-\t  && (INTVAL (XEXP (x, 1)) & ~ mask) != 0)\n-\treturn force_to_mode (plus_constant (XEXP (x, 0),\n-\t\t\t\t\t     INTVAL (XEXP (x, 1)) & mask),\n-\t\t\t      mode, mask, reg, next_select);\n+\n+      {\n+\tint width = GET_MODE_BITSIZE (mode);\n+\tunsigned HOST_WIDE_INT smask = mask;\n+\n+\t/* If MODE is narrower than HOST_WIDE_INT and mask is a negative\n+\t   number, sign extend it.  */\n+\n+\tif (width < HOST_BITS_PER_WIDE_INT\n+\t    && (smask & ((HOST_WIDE_INT) 1 << (width - 1))) != 0)\n+\t  smask |= (HOST_WIDE_INT) -1 << width;\n+\n+\tif (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t    && exact_log2 (- smask) >= 0\n+\t    && (nonzero_bits (XEXP (x, 0), mode) & ~ mask) == 0\n+\t    && (INTVAL (XEXP (x, 1)) & ~ mask) != 0)\n+\t  return force_to_mode (plus_constant (XEXP (x, 0),\n+\t\t\t\t\t       INTVAL (XEXP (x, 1)) & mask),\n+\t\t\t\tmode, mask, reg, next_select);\n+      }\n \n       /* ... fall through ... */\n \n@@ -6598,6 +6611,7 @@ simplify_and_const_int (x, mode, varop, constop)\n      unsigned HOST_WIDE_INT constop;\n {\n   unsigned HOST_WIDE_INT nonzero;\n+  int width = GET_MODE_BITSIZE (mode);\n   int i;\n \n   /* Simplify VAROP knowing that we will be only looking at some of the\n@@ -6615,6 +6629,19 @@ simplify_and_const_int (x, mode, varop, constop)\n \n   nonzero = nonzero_bits (varop, mode) & GET_MODE_MASK (mode);\n \n+  /* If this would be an entire word for the target, but is not for\n+     the host, then sign-extend on the host so that the number will look\n+     the same way on the host that it would on the target.\n+\n+     For example, when building a 64 bit alpha hosted 32 bit sparc\n+     targeted compiler, then we want the 32 bit unsigned value -1 to be\n+     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n+     The later confuses the sparc backend.  */\n+\n+  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n+      && (nonzero & ((HOST_WIDE_INT) 1 << (width - 1))))\n+    nonzero |= ((HOST_WIDE_INT) (-1) << width);\n+\n   /* Turn off all bits in the constant that are known to already be zero.\n      Thus, if the AND isn't needed at all, we will have CONSTOP == NONZERO_BITS\n      which is tested below.  */\n@@ -7408,6 +7435,7 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n {\n   enum rtx_code op0 = *pop0;\n   HOST_WIDE_INT const0 = *pconst0;\n+  int width = GET_MODE_BITSIZE (mode);\n \n   const0 &= GET_MODE_MASK (mode);\n   const1 &= GET_MODE_MASK (mode);\n@@ -7497,6 +7525,19 @@ merge_outer_ops (pop0, pconst0, op1, const1, mode, pcomp_p)\n   else if (const0 == GET_MODE_MASK (mode) && op0 == AND)\n     op0 = NIL;\n \n+  /* If this would be an entire word for the target, but is not for\n+     the host, then sign-extend on the host so that the number will look\n+     the same way on the host that it would on the target.\n+\n+     For example, when building a 64 bit alpha hosted 32 bit sparc\n+     targeted compiler, then we want the 32 bit unsigned value -1 to be\n+     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n+     The later confuses the sparc backend.  */\n+\n+  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n+      && (const0 & ((HOST_WIDE_INT) 1 << (width - 1))))\n+    const0 |= ((HOST_WIDE_INT) (-1) << width);\n+\n   *pop0 = op0;\n   *pconst0 = const0;\n \n@@ -8179,7 +8220,24 @@ simplify_shift_const (x, code, result_mode, varop, count)\n   if (outer_op != NIL)\n     {\n       if (GET_MODE_BITSIZE (result_mode) < HOST_BITS_PER_WIDE_INT)\n-\touter_const &= GET_MODE_MASK (result_mode);\n+\t{\n+\t  int width = GET_MODE_BITSIZE (result_mode);\n+\n+\t  outer_const &= GET_MODE_MASK (result_mode);\n+\n+\t  /* If this would be an entire word for the target, but is not for\n+\t     the host, then sign-extend on the host so that the number will\n+\t     look the same way on the host that it would on the target.\n+\n+\t     For example, when building a 64 bit alpha hosted 32 bit sparc\n+\t     targeted compiler, then we want the 32 bit unsigned value -1 to be\n+\t     represented as a 64 bit value -1, and not as 0x00000000ffffffff.\n+\t     The later confuses the sparc backend.  */\n+\n+\t  if (BITS_PER_WORD < HOST_BITS_PER_WIDE_INT && BITS_PER_WORD == width\n+\t      && (outer_const & ((HOST_WIDE_INT) 1 << (width - 1))))\n+\t    outer_const |= ((HOST_WIDE_INT) (-1) << width);\n+\t}\n \n       if (outer_op == AND)\n \tx = simplify_and_const_int (NULL_RTX, result_mode, x, outer_const);"}]}