{"sha": "85c4c3aa87682e9664cf3d94d7e51067cf3f8a45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVjNGMzYWE4NzY4MmU5NjY0Y2YzZDk0ZDdlNTEwNjdjZjNmOGE0NQ==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-11-26T02:48:07Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1991-11-26T02:48:07Z"}, "message": "entered into RCS\n\nFrom-SVN: r73", "tree": {"sha": "bd79e341c9c849a7d062215d44373a7c8c5c01c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd79e341c9c849a7d062215d44373a7c8c5c01c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85c4c3aa87682e9664cf3d94d7e51067cf3f8a45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c4c3aa87682e9664cf3d94d7e51067cf3f8a45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85c4c3aa87682e9664cf3d94d7e51067cf3f8a45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85c4c3aa87682e9664cf3d94d7e51067cf3f8a45/comments", "author": null, "committer": null, "parents": [{"sha": "8c2425e1e43f3d098a348cb147fb27cb8b9f5fe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c2425e1e43f3d098a348cb147fb27cb8b9f5fe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c2425e1e43f3d098a348cb147fb27cb8b9f5fe7"}], "stats": {"total": 2480, "additions": 2480, "deletions": 0}, "files": [{"sha": "df8fa11db8351a6351ec9a7203db1da3efeaaa52", "filename": "gcc/config/fx80/fx80.md", "status": "added", "additions": 2480, "deletions": 0, "changes": 2480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85c4c3aa87682e9664cf3d94d7e51067cf3f8a45/gcc%2Fconfig%2Ffx80%2Ffx80.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85c4c3aa87682e9664cf3d94d7e51067cf3f8a45/gcc%2Fconfig%2Ffx80%2Ffx80.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.md?ref=85c4c3aa87682e9664cf3d94d7e51067cf3f8a45", "patch": "@@ -0,0 +1,2480 @@\n+;;- Machine description for GNU C compiler for Alliant FX systems\n+;;   Copyright (C) 1989 Free Software Foundation, Inc.\n+;;   Adapted from m68k.md by Paul Petersen (petersen@uicsrd.csrd.uiuc.edu)\n+;;   and Joe Weening (weening@gang-of-four.stanford.edu).\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- instruction definitions\n+\n+;;- @@The original PO technology requires these to be ordered by speed,\n+;;- @@    so that assigner will pick the fastest.\n+\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+;;- When naming insn's (operand 0 of define_insn) be careful about using\n+;;- names from other targets machine descriptions.\n+\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;;- Operand classes for the register allocator:\n+;;- 'a' one of the address registers can be used.\n+;;- 'd' one of the data registers can be used.\n+;;- 'f' one of the CE floating point registers can be used\n+;;- 'r' either a data or an address register can be used.\n+\n+;;- Immediate integer operand constraints:\n+;;- 'I'  1 .. 8\n+;;- 'J'  -32768 .. 32767\n+;;- 'K'  -128 .. 127\n+;;- 'L'  -8 .. -1\n+\n+;;- Some remnants of constraint codes for the m68k ('x','y','G','H')\n+;;- may remain in the insn definitions.\n+\n+;;- Some of these insn's are composites of several Alliant op codes.\n+;;- The assembler (or final @@??) insures that the appropriate one is\n+;;- selected.\n+\f\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n+    return \\\"tst%.l %0\\\";\n+  /* If you think that the 68020 does not support tstl a0,\n+     reread page B-167 of the 68020 manual more carefully.  */\n+  /* On an address reg, cmpw may replace cmpl.  */\n+  return \\\"cmp%.w %#0,%0\\\";\n+}\")\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"nonimmediate_operand\" \"rm\"))]\n+  \"\"\n+  \"*\n+{\n+  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n+    return \\\"tst%.w %0\\\";\n+  return \\\"cmp%.w %#0,%0\\\";\n+}\")\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"nonimmediate_operand\" \"dm\"))]\n+  \"\"\n+  \"tst%.b %0\")\n+\n+(define_insn \"tstsf\"\n+  [(set (cc0)\n+\t(match_operand:SF 0 \"nonimmediate_operand\" \"fm\"))]\n+  \"TARGET_CE\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FP;\n+  return \\\"ftest%.s %0\\\";\n+}\")\n+\n+(define_insn \"tstdf\"\n+  [(set (cc0)\n+\t(match_operand:DF 0 \"nonimmediate_operand\" \"fm\"))]\n+  \"TARGET_CE\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FP;\n+  return \\\"ftest%.d %0\\\";\n+}\")\n+\f\n+;; compare instructions.\n+\n+;; A composite of the cmp, cmpa, & cmpi m68000 op codes.\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"rKs,mr,>\")\n+\t\t (match_operand:SI 1 \"general_operand\" \"mr,Ksr,>\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    return \\\"cmpm%.l %1,%0\\\";\n+  if (REG_P (operands[1])\n+      || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      return \\\"cmp%.l %d0,%d1\\\"; \n+    }\n+  return \\\"cmp%.l %d1,%d0\\\";\n+}\")\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"rnm,d,n,m\")\n+\t\t (match_operand:HI 1 \"general_operand\" \"d,rnm,m,n\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    return \\\"cmpm%.w %1,%0\\\";\n+  if ((REG_P (operands[1]) && !ADDRESS_REG_P (operands[1]))\n+      || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n+    { cc_status.flags |= CC_REVERSED;\n+      return \\\"cmp%.w %d0,%d1\\\"; \n+    }\n+  return \\\"cmp%.w %d1,%d0\\\";\n+}\")\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"dn,md,>\")\n+\t\t (match_operand:QI 1 \"general_operand\" \"dm,nd,>\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n+    return \\\"cmpm%.b %1,%0\\\";\n+  if (REG_P (operands[1])\n+      || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n+    {\n+      cc_status.flags |= CC_REVERSED;\n+      return \\\"cmp%.b %d0,%d1\\\";\n+    }\n+  return \\\"cmp%.b %d1,%d0\\\";\n+}\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"nonimmediate_operand\" \"f,m\")\n+\t\t (match_operand:DF 1 \"nonimmediate_operand\" \"fm,f\")))]\n+  \"TARGET_CE\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FP;\n+  if (FP_REG_P (operands[0]))\n+    return \\\"fcmp%.d %1,%0\\\";\n+  cc_status.flags |= CC_REVERSED;\n+  return \\\"fcmp%.d %0,%1\\\";\n+}\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"nonimmediate_operand\" \"f,m\")\n+\t\t (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f\")))]\n+  \"TARGET_CE\"\n+  \"*\n+{\n+  cc_status.flags = CC_IN_FP;\n+  if (FP_REG_P (operands[0]))\n+    return \\\"fcmp%.s %1,%0\\\";\n+  cc_status.flags |= CC_REVERSED;\n+  return \\\"fcmp%.s %0,%1\\\";\n+}\")\n+\f\n+;; Recognizers for btst instructions.\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"nonimmediate_operand\" \"do\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (minus:SI (const_int 7)\n+\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n+  \"\"\n+  \"* { return output_btst (operands, operands[1], operands[0], insn, 7); }\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"d\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (minus:SI (const_int 31)\n+\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n+  \"\"\n+  \"* { return output_btst (operands, operands[1], operands[0], insn, 31); }\")\n+\n+;; The following two patterns are like the previous two\n+;; except that they use the fact that bit-number operands\n+;; are automatically masked to 3 or 5 bits.\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"nonimmediate_operand\" \"do\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (minus:SI (const_int 7)\n+\t\t\t\t      (and:SI\n+\t\t\t\t       (match_operand:SI 1 \"general_operand\" \"d\")\n+\t\t\t\t       (const_int 7)))))]\n+  \"\"\n+  \"* { return output_btst (operands, operands[1], operands[0], insn, 7); }\")\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"d\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (minus:SI (const_int 31)\n+\t\t\t\t      (and:SI\n+\t\t\t\t       (match_operand:SI 1 \"general_operand\" \"d\")\n+\t\t\t\t       (const_int 31)))))]\n+  \"\"\n+  \"* { return output_btst (operands, operands[1], operands[0], insn, 31); }\")\n+\n+;; Nonoffsettable mem refs are ok in this one pattern\n+;; since we don't try to adjust them.\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"nonimmediate_operand\" \"md\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"i\")))]\n+  \"GET_CODE (operands[1]) == CONST_INT\n+   && (unsigned) INTVAL (operands[1]) < 8\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode, 7 - INTVAL (operands[1]));\n+  return output_btst (operands, operands[1], operands[0], insn, 7);\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:SI 0 \"nonimmediate_operand\" \"do\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"i\")))]\n+  \"GET_CODE (operands[1]) == CONST_INT\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      operands[0] = adj_offsettable_operand (operands[0],\n+\t\t\t\t\t     INTVAL (operands[1]) / 8);\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, \n+\t\t\t     7 - INTVAL (operands[1]) % 8);\n+      return output_btst (operands, operands[1], operands[0], insn, 7);\n+    }\n+  operands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t 31 - INTVAL (operands[1]));\n+  return output_btst (operands, operands[1], operands[0], insn, 31);\n+}\")\n+\n+\f\n+;; move instructions\n+\n+;; A special case in which it is not desirable\n+;; to reload the constant into a data register.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+\t(match_operand:SI 1 \"general_operand\" \"J\"))]\n+  \"GET_CODE (operands[1]) == CONST_INT\n+   && INTVAL (operands[1]) >= -0x8000\n+   && INTVAL (operands[1]) < 0x8000\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clr%.l %0\\\";\n+  return \\\"pea %a1\\\";\n+}\")\n+\n+;This is never used.\n+;(define_insn \"swapsi\"\n+;  [(set (match_operand:SI 0 \"general_operand\" \"r\")\n+;\t(match_operand:SI 1 \"general_operand\" \"r\"))\n+;   (set (match_dup 1) (match_dup 0))]\n+;  \"\"\n+;  \"exg %1,%0\")\n+\n+;; Special case of fullword move when source is zero.\n+;; The reason this is special is to avoid loading a zero\n+;; into a data reg with moveq in order to store it elsewhere.\n+   \n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=a,g\")\n+\t(const_int 0))]\n+  \"\"\n+  \"@\n+   sub%.l %0,%0\n+   clr%.l %0\")\n+\n+;; General case of fullword move.  The register constraints\n+;; force integer constants in range for a moveq to be reloaded\n+;; if they are headed for memory.\n+(define_insn \"movsi\"\n+  ;; Notes: make sure no alternative allows g vs g.\n+  ;; We don't allow f-regs since fixed point cannot go in them.\n+  ;; We do allow y and x regs since fixed point is allowed in them.\n+  [(set (match_operand:SI 0 \"general_operand\" \"=g,da,y,!*x*r*m\")\n+\t(match_operand:SI 1 \"general_operand\" \"daymKs,i,g,*x*r*m\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (operands[1] == const0_rtx\n+\t  && (DATA_REG_P (operands[0])\n+\t      || GET_CODE (operands[0]) == MEM))\n+\treturn \\\"clr%.l %0\\\";\n+      else if (DATA_REG_P (operands[0])\n+\t       && INTVAL (operands[1]) < 128\n+\t       && INTVAL (operands[1]) >= -128)\n+\treturn \\\"moveq %1,%0\\\";\n+      else if (ADDRESS_REG_P (operands[0])\n+\t       && INTVAL (operands[1]) < 0x8000\n+\t       && INTVAL (operands[1]) >= -0x8000)\n+\treturn \\\"mov%.w %1,%0\\\";\n+      else if (push_operand (operands[0], SImode)\n+\t       && INTVAL (operands[1]) < 0x8000\n+\t       && INTVAL (operands[1]) >= -0x8000)\n+        return \\\"pea %a1\\\";\n+    }\n+  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n+\t    || GET_CODE (operands[1]) == CONST)\n+\t   && push_operand (operands[0], SImode))\n+    return \\\"pea %a1\\\";\n+  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n+\t    || GET_CODE (operands[1]) == CONST)\n+\t   && ADDRESS_REG_P (operands[0]))\n+    return \\\"lea %a1,%0\\\";\n+  return \\\"mov%.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n+\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      if (operands[1] == const0_rtx\n+\t  && (DATA_REG_P (operands[0])\n+\t      || GET_CODE (operands[0]) == MEM))\n+\treturn \\\"clr%.w %0\\\";\n+      else if (DATA_REG_P (operands[0])\n+\t       && INTVAL (operands[1]) < 128\n+\t       && INTVAL (operands[1]) >= -128)\n+        {\n+\t  return \\\"moveq %1,%0\\\";\n+\t}\n+      else if (INTVAL (operands[1]) < 0x8000\n+\t       && INTVAL (operands[1]) >= -0x8000)\n+\treturn \\\"mov%.w %1,%0\\\";\n+    }\n+  else if (CONSTANT_P (operands[1]))\n+    return \\\"mov%.l %1,%0\\\";\n+  /* Recognize the insn before a tablejump, one that refers\n+     to a table of offsets.  Such an insn will need to refer\n+     to a label on the insn.  So output one.  Use the label-number\n+     of the table of offsets to generate this label.  */\n+  if (GET_CODE (operands[1]) == MEM\n+      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF)\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS\n+      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) != PLUS)\n+    {\n+      rtx labelref;\n+      if (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF)\n+\tlabelref = XEXP (XEXP (operands[1], 0), 0);\n+      else\n+\tlabelref = XEXP (XEXP (operands[1], 0), 1);\n+      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LI\\\",\n+\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+    }\n+  return \\\"mov%.w %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+dm\"))\n+\t(match_operand:HI 1 \"general_operand\" \"rmn\"))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clr%.w %0\\\";\n+  return \\\"mov%.w %1,%0\\\";\n+}\")\n+\n+(define_insn \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m,m,?*a\")\n+\t(match_operand:QI 1 \"general_operand\" \"dmi*a,d*a,dmi,?*a,m\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[4];\n+  if (ADDRESS_REG_P (operands[0]) && GET_CODE (operands[1]) == MEM)\n+    {\n+      xoperands[1] = operands[1];\n+      xoperands[2]\n+        = gen_rtx (MEM, QImode,\n+\t\t   gen_rtx (PLUS, VOIDmode, stack_pointer_rtx, const1_rtx));\n+      xoperands[3] = stack_pointer_rtx;\n+      /* Just pushing a byte puts it in the high byte of the halfword.  */\n+      /* We must put it in the low half, the second byte.  */\n+      output_asm_insn (\\\"subq%.w %#2,%3\\;mov%.b %1,%2\\\", xoperands);\n+      return \\\"mov%.w %+,%0\\\";\n+    }\n+  if (ADDRESS_REG_P (operands[1]) && GET_CODE (operands[0]) == MEM)\n+    {\n+      xoperands[0] = operands[0];\n+      xoperands[1] = operands[1];\n+      xoperands[2]\n+        = gen_rtx (MEM, QImode,\n+\t\t   gen_rtx (PLUS, VOIDmode, stack_pointer_rtx, const1_rtx));\n+      xoperands[3] = stack_pointer_rtx;\n+      output_asm_insn (\\\"mov%.w %1,%-\\;mov%.b %2,%0\\;addq%.w %#2,%3\\\", xoperands);\n+      return \\\"\\\";\n+    }\n+  if (operands[1] == const0_rtx)\n+    return \\\"clr%.b %0\\\";\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && INTVAL (operands[1]) == -1)\n+    return \\\"st %0\\\";\n+  if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n+    return \\\"mov%.l %1,%0\\\";\n+  if (ADDRESS_REG_P (operands[0]) || ADDRESS_REG_P (operands[1]))\n+    return \\\"mov%.w %1,%0\\\";\n+  return \\\"mov%.b %1,%0\\\";\n+}\")\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+dm\"))\n+\t(match_operand:QI 1 \"general_operand\" \"dmn\"))]\n+  \"\"\n+  \"*\n+{\n+  if (operands[1] == const0_rtx)\n+    return \\\"clr%.b %0\\\";\n+  return \\\"mov%.b %1,%0\\\";\n+}\")\n+\n+;; Floating-point moves on a CE are faster using an FP register than\n+;; with movl instructions.  (Especially for double floats, but also\n+;; for single floats, even though it takes an extra instruction.)  But\n+;; on an IP, the FP registers are simulated and so should be avoided.\n+;; We do this by using define_expand for movsf and movdf, and using\n+;; different constraints for each target type.  The constraints for\n+;; TARGET_CE allow general registers because they sometimes need to\n+;; hold floats, but they are not preferable.\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,m,!*r,!f*m\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"fm,f,f*r*m,*r\"))]\n+  \"TARGET_CE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmove%.s %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\treturn \\\"mov%.l %1,%-\\;fmove%.s %+,%0\\\";\n+      return \\\"fmove%.s %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\treturn \\\"fmove%.s %1,%-\\;mov%.l %+,%0\\\";\n+      return \\\"fmove%.s %1,%0\\\";\n+    }\n+  return \\\"mov%.l %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=frm\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"frm\"))]\n+  \"!TARGET_CE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmove%.s %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\treturn \\\"mov%.l %1,%-\\;fmove%.s %+,%0\\\";\n+      return \\\"fmove%.s %1,%0\\\";\n+    }\n+  if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\treturn \\\"fmove%.s %1,%-\\;mov%.l %+,%0\\\";\n+      return \\\"fmove%.s %1,%0\\\";\n+    }\n+  return \\\"mov%.l %1,%0\\\";\n+}\")\n+\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f,m,!*r,!f*m\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"fm,f,f*r*m,*r\"))]\n+  \"TARGET_CE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmove%.d %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"mov%.l %1,%-\\\", xoperands);\n+\t  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n+\t  return \\\"fmove%.d %+,%0\\\";\n+\t}\n+      return \\\"fmove%.d %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\\\"fmove%.d %1,%-\\;mov%.l %+,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"mov%.l %+,%0\\\";\n+\t}\n+      return \\\"fmove%.d %1,%0\\\";\n+    }\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=frm\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"frm\"))]\n+  \"!TARGET_CE\"\n+  \"*\n+{\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\n+\treturn \\\"fmove%.d %1,%0\\\";\n+      if (REG_P (operands[1]))\n+\t{\n+\t  rtx xoperands[2];\n+\t  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+\t  output_asm_insn (\\\"mov%.l %1,%-\\\", xoperands);\n+\t  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n+\t  return \\\"fmove%.d %+,%0\\\";\n+\t}\n+      return \\\"fmove%.d %1,%0\\\";\n+    }\n+  else if (FP_REG_P (operands[1]))\n+    {\n+      if (REG_P (operands[0]))\n+\t{\n+\t  output_asm_insn (\\\"fmove%.d %1,%-\\;mov%.l %+,%0\\\", operands);\n+\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\t  return \\\"mov%.l %+,%0\\\";\n+\t}\n+      return \\\"fmove%.d %1,%0\\\";\n+    }\n+  return output_move_double (operands);\n+}\")\n+\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&r,&ro<>\")\n+\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>\"))]\n+  \"\"\n+  \"*\n+{\n+  return output_move_double (operands);\n+}\n+\")\n+\n+;; This goes after the move instructions\n+;; because the move instructions are better (require no spilling)\n+;; when they can apply.  It goes before the add/sub insns\n+;; so we will prefer it to them.\n+\n+(define_insn \"pushasi\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n+\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"pea %a1\")\n+\f\n+;; truncation instructions\n+(define_insn \"truncsiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm,d\")\n+\t(truncate:QI\n+\t (match_operand:SI 1 \"general_operand\" \"doJ,i\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG)\n+    return \\\"mov%.l %1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    operands[1] = adj_offsettable_operand (operands[1], 3);\n+  return \\\"mov%.b %1,%0\\\";\n+}\")\n+\n+(define_insn \"trunchiqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm,d\")\n+\t(truncate:QI\n+\t (match_operand:HI 1 \"general_operand\" \"doJ,i\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG\n+      && (GET_CODE (operands[1]) == MEM\n+\t  || GET_CODE (operands[1]) == CONST_INT))\n+    return \\\"mov%.w %1,%0\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    return \\\"mov%.l %1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    operands[1] = adj_offsettable_operand (operands[1], 1);\n+  return \\\"mov%.b %1,%0\\\";\n+}\")\n+\n+(define_insn \"truncsihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dm,d\")\n+\t(truncate:HI\n+\t (match_operand:SI 1 \"general_operand\" \"roJ,i\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[0]) == REG)\n+    return \\\"mov%.l %1,%0\\\";\n+  if (GET_CODE (operands[1]) == MEM)\n+    operands[1] = adj_offsettable_operand (operands[1], 2);\n+  return \\\"mov%.w %1,%0\\\";\n+}\")\n+\f\n+;; zero extension instructions\n+\n+(define_expand \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(const_int 0))\n+   (set (strict_low_part (subreg:HI (match_dup 0) 0))\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"operands[1] = make_safe_from (operands[1], operands[0]);\")\n+\n+(define_expand \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(const_int 0))\n+   (set (strict_low_part (subreg:QI (match_dup 0) 0))\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"operands[1] = make_safe_from (operands[1], operands[0]);\")\n+\n+(define_expand \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(const_int 0))\n+   (set (strict_low_part (subreg:QI (match_dup 0) 0))\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \" operands[1] = make_safe_from (operands[1], operands[0]); \")\n+\f\n+;; Patterns to recognize zero-extend insns produced by the combiner.\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=do<>\")\n+\t(zero_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n+  \"\"\n+  \"*\n+{\n+  if (DATA_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG\n+\t  && REGNO (operands[0]) == REGNO (operands[1]))\n+\treturn \\\"and%.l %#0xFFFF,%0\\\";\n+      if (reg_mentioned_p (operands[0], operands[1]))\n+        return \\\"mov%.w %1,%0\\;and%.l %#0xFFFF,%0\\\";\n+      return \\\"clr%.l %0\\;mov%.w %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    return \\\"mov%.w %1,%0\\;clr%.w %0\\\";\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    return \\\"clr%.w %0\\;mov%.w %1,%0\\\";\n+  else\n+    {\n+      output_asm_insn (\\\"clr%.w %0\\\", operands);\n+      operands[0] = adj_offsettable_operand (operands[0], 2);\n+      return \\\"mov%.w %1,%0\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=do<>\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"\"\n+  \"*\n+{\n+  if (DATA_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG\n+\t  && REGNO (operands[0]) == REGNO (operands[1]))\n+\treturn \\\"and%.w %#0xFF,%0\\\";\n+      if (reg_mentioned_p (operands[0], operands[1]))\n+        return \\\"mov%.b %1,%0\\;and%.w %#0xFF,%0\\\";\n+      return \\\"clr%.w %0\\;mov%.b %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    {\n+      if (REGNO (XEXP (XEXP (operands[0], 0), 0))\n+\t  == STACK_POINTER_REGNUM)\n+\treturn \\\"clr%.w %-\\;mov%.b %1,%0\\\";\n+      else\n+\treturn \\\"mov%.b %1,%0\\;clr%.b %0\\\";\n+    }\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    return \\\"clr%.b %0\\;mov%.b %1,%0\\\";\n+  else\n+    {\n+      output_asm_insn (\\\"clr%.b %0\\\", operands);\n+      operands[0] = adj_offsettable_operand (operands[0], 1);\n+      return \\\"mov%.b %1,%0\\\";\n+    }\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=do<>\")\n+\t(zero_extend:SI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"\"\n+  \"*\n+{\n+  if (DATA_REG_P (operands[0]))\n+    {\n+      if (GET_CODE (operands[1]) == REG\n+\t  && REGNO (operands[0]) == REGNO (operands[1]))\n+\treturn \\\"and%.l %#0xFF,%0\\\";\n+      if (reg_mentioned_p (operands[0], operands[1]))\n+        return \\\"mov%.b %1,%0\\;and%.l %#0xFF,%0\\\";\n+      return \\\"clr%.l %0\\;mov%.b %1,%0\\\";\n+    }\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      return \\\"clr%.l %0@-\\;mov%.b %1,%0@(3)\\\";\n+    }\n+  else if (GET_CODE (operands[0]) == MEM\n+\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n+    {\n+      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n+      return \\\"clr%.l %0@+\\;mov%.b %1,%0@(-1)\\\";\n+    }\n+  else\n+    {\n+      output_asm_insn (\\\"clr%.l %0\\\", operands);\n+      operands[0] = adj_offsettable_operand (operands[0], 3);\n+      return \\\"mov%.b %1,%0\\\";\n+    }\n+}\")\n+\f\n+;; sign extension instructions\n+\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=*d,a\")\n+\t(sign_extend:SI\n+\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,rmn\")))]\n+  \"\"\n+  \"@\n+   ext%.l %0\n+   mov%.w %1,%0\")\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n+  \"\"\n+  \"ext%.w %0\")\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(sign_extend:SI\n+\t (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n+  \"TARGET_68020\"\n+  \"extb%.l %0\")\n+\f\n+;; Conversions between float and double.\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"=f,m\")\n+\t(float_extend:DF\n+\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f\")))]\n+  \"TARGET_CE\"\n+  \"fmovesd %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"=f,m\")\n+\t(float_truncate:SF\n+\t  (match_operand:DF 1 \"nonimmediate_operand\" \"fm,f\")))]\n+  \"TARGET_CE\"\n+  \"fmoveds %1,%0\")\n+\f\n+;; Conversion between fixed point and floating point.\n+;; Note that among the fix-to-float insns\n+;; the ones that start with SImode come first.\n+;; That is so that an operand that is a CONST_INT\n+;; (and therefore lacks a specific machine mode).\n+;; will be recognized as SImode (which is always valid)\n+;; rather than as QImode or HImode.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"TARGET_CE\"\n+  \"fmovels %1,%0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"TARGET_CE\"\n+  \"fmoveld %1,%0\")\n+\n+(define_insn \"floathisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float:SF (match_operand:HI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"TARGET_CE\"\n+  \"fmovews %1,%0\")\n+\n+(define_insn \"floathidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float:DF (match_operand:HI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"TARGET_CE\"\n+  \"fmovewd %1,%0\")\n+\n+(define_insn \"floatqisf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(float:SF (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"TARGET_CE\"\n+  \"fmovebs %1,%0\")\n+\n+(define_insn \"floatqidf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(float:DF (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n+  \"TARGET_CE\"\n+  \"fmovebd %1,%0\")\n+\f\n+;; Float-to-fix conversion insns.\n+\n+(define_insn \"fix_truncsfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n+\t(fix:QI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_CE\"\n+  \"fmovesb %1,%0\")\n+\n+(define_insn \"fix_truncsfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n+\t(fix:HI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_CE\"\n+  \"fmovesw %1,%0\")\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_CE\"\n+  \"fmovesl %1,%0\")\n+\n+(define_insn \"fix_truncdfqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n+\t(fix:QI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_CE\"\n+  \"fmovedb %1,%0\")\n+\n+(define_insn \"fix_truncdfhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n+\t(fix:HI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_CE\"\n+  \"fmovedw %1,%0\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n+  \"TARGET_CE\"\n+  \"fmovedl %1,%0\")\n+\f\n+;; add instructions\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,r,!a,!a\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,a,rJK\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"dIKLs,mrIKLs,rJK,a\")))]\n+  \"\"\n+  \"*\n+{\n+  if (! operands_match_p (operands[0], operands[1]))\n+    {\n+      if (!ADDRESS_REG_P (operands[1]))\n+\t{\n+\t  rtx tmp = operands[1];\n+\n+\t  operands[1] = operands[2];\n+\t  operands[2] = tmp;\n+\t}\n+\n+      /* These insns can result from reloads to access\n+\t stack slots over 64k from the frame pointer.  */\n+      if (GET_CODE (operands[2]) == CONST_INT\n+\t  && INTVAL (operands[2]) + 0x8000 >= (unsigned) 0x10000)\n+        return \\\"mov%.l %2,%0\\;add%.l %1,%0\\\";\n+      if (GET_CODE (operands[2]) == REG)\n+\treturn \\\"lea %1@[%2:L:B],%0\\\";\n+      else\n+\treturn \\\"lea %1@(%c2),%0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[2]) > 0\n+\t  && INTVAL (operands[2]) <= 8)\n+\treturn (ADDRESS_REG_P (operands[0])\n+\t\t? \\\"addq%.w %2,%0\\\"\n+\t\t: \\\"addq%.l %2,%0\\\");\n+      if (INTVAL (operands[2]) < 0\n+\t  && INTVAL (operands[2]) >= -8)\n+        {\n+\t  operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t         - INTVAL (operands[2]));\n+\t  return (ADDRESS_REG_P (operands[0])\n+\t\t  ? \\\"subq%.w %2,%0\\\"\n+\t\t  : \\\"subq%.l %2,%0\\\");\n+\t}\n+      if (ADDRESS_REG_P (operands[0])\n+\t  && INTVAL (operands[2]) >= -0x8000\n+\t  && INTVAL (operands[2]) < 0x8000)\n+\treturn \\\"add%.w %2,%0\\\";\n+    }\n+  return \\\"add%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n+\t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmn\"))))]\n+  \"\"\n+  \"add%.w %2,%0\")\n+\n+(define_insn \"addhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=mr,mr,m,r\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"I,L,dn,rmn\")))]\n+  \"\"\n+  \"@\n+   addq%.w %2,%0\n+   subq%.w #%n2,%0\n+   add%.w %2,%0\n+   add%.w %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n+\t(plus:HI (match_dup 0)\n+\t\t (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n+  \"\"\n+  \"add%.w %1,%0\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=md,mr,m,d\")\n+\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0\")\n+\t\t (match_operand:QI 2 \"general_operand\" \"I,L,dn,dmn\")))]\n+  \"\"\n+  \"@\n+   addq%.b %2,%0\n+   subq%.b #%n2,%0\n+   add%.b %2,%0\n+   add%.b %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n+\t(plus:QI (match_dup 0)\n+\t\t (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"add%.b %1,%0\")\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"%f\")\n+\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fadd%.d %2,%1,%0\")\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"nonimmediate_operand\" \"%f\")\n+\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fadd%.s %2,%1,%0\")\n+\f\n+;; subtract instructions\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,r,!a,?d\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,a,mrIKs\")\n+\t\t  (match_operand:SI 2 \"general_operand\" \"dIKs,mrIKs,J,0\")))]\n+  \"\"\n+  \"*\n+{\n+  if (! operands_match_p (operands[0], operands[1]))\n+    {\n+      if (operands_match_p (operands[0], operands[2]))\n+\t{\n+\t  if (GET_CODE (operands[1]) == CONST_INT)\n+\t    {\n+\t      if (INTVAL (operands[1]) > 0\n+\t\t  && INTVAL (operands[1]) <= 8)\n+\t\treturn \\\"subq%.l %1,%0\\;neg%.l %0\\\";\n+\t    }\n+\t  return \\\"sub%.l %1,%0\\;neg%.l %0\\\";\n+\t}\n+      /* This case is matched by J, but negating -0x8000\n+         in an lea would give an invalid displacement.\n+\t So do this specially.  */\n+      if (INTVAL (operands[2]) == -0x8000)\n+\treturn \\\"mov%.l %1,%0\\;sub%.l %2,%0\\\";\n+      return \\\"lea %1@(%n2),%0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      if (INTVAL (operands[2]) > 0\n+\t  && INTVAL (operands[2]) <= 8)\n+\treturn \\\"subq%.l %2,%0\\\";\n+      if (ADDRESS_REG_P (operands[0])\n+\t  && INTVAL (operands[2]) >= -0x8000\n+\t  && INTVAL (operands[2]) < 0x8000)\n+\treturn \\\"sub%.w %2,%0\\\";\n+    }\n+  return \\\"sub%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n+\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmn\"))))]\n+  \"\"\n+  \"sub%.w %2,%0\")\n+\n+(define_insn \"subhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=m,r\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n+\t\t  (match_operand:HI 2 \"general_operand\" \"dn,rmn\")))]\n+  \"\"\n+  \"sub%.w %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n+\t(minus:HI (match_dup 0)\n+\t\t  (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n+  \"\"\n+  \"sub%.w %1,%0\")\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n+\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n+\t\t  (match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"sub%.b %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n+\t(minus:QI (match_dup 0)\n+\t\t  (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"sub%.b %1,%0\")\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n+\t(minus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"f,f,m\")\n+\t\t  (match_operand:DF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n+  \"TARGET_CE\"\n+  \"@\n+   fsub%.d %2,%1,%0\n+   fsub%.d %2,%1,%0\n+   frsub%.d %1,%2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n+\t(minus:SF (match_operand:SF 1 \"nonimmediate_operand\" \"f,f,m\")\n+\t\t  (match_operand:SF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n+  \"TARGET_CE\"\n+  \"@\n+   fsub%.s %2,%1,%0\n+   fsub%.s %2,%1,%0\n+   frsub%.s %1,%2,%0\")\n+\f\n+;; multiply instructions\n+\n+(define_insn \"mulhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n+  \"\"\n+  \"muls %2,%0\")\n+\n+(define_insn \"mulhisi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\"))))]\n+  \"\"\n+  \"muls %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"muls %2,%0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n+  \"TARGET_68020\"\n+  \"muls%.l %2,%0\")\n+\n+(define_insn \"umulhisi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(mult:SI (zero_extend:SI\n+\t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t (zero_extend:SI\n+\t\t  (match_operand:HI 2 \"nonimmediate_operand\" \"dm\"))))]\n+  \"\"\n+  \"mulu %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(mult:SI (zero_extend:SI\n+\t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n+\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"mulu %2,%0\")\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"nonimmediate_operand\" \"%f\")\n+\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fmul%.d %2,%1,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"nonimmediate_operand\" \"%f\")\n+\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fmul%.s %2,%1,%0\")\n+\f\n+;; divide instructions\n+\n+(define_insn \"divhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"dmn\")))]\n+  \"\"\n+  \"extl %0\\;divs %2,%0\")\n+\n+(define_insn \"divhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI\n+\t (div:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n+  \"\"\n+  \"divs %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI (div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n+  \"\"\n+  \"divs %2,%0\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n+  \"TARGET_68020\"\n+  \"divs%.l %2,%0,%0\")\n+\n+(define_insn \"udivhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n+  \"\"\n+  \"and%.l %#0xFFFF,%0\\;divu %2,%0\")\n+\n+(define_insn \"udivhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI\n+\t (udiv:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (zero_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n+  \"\"\n+  \"divu %2,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI (udiv:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n+\t\t\t      (match_operand:HI 2 \"const_int_operand\" \"n\"))))]\n+  \"\"\n+  \"divu %2,%0\")\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n+  \"TARGET_68020\"\n+  \"divu%.l %2,%0,%0\")\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n+\t(div:DF (match_operand:DF 1 \"nonimmediate_operand\" \"f,f,m\")\n+\t\t(match_operand:DF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n+  \"TARGET_CE\"\n+  \"@\n+   fdiv%.d %2,%1,%0\n+   fdiv%.d %2,%1,%0\n+   frdiv%.d %1,%2,%0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n+\t(div:SF (match_operand:SF 1 \"nonimmediate_operand\" \"f,f,m\")\n+\t\t(match_operand:SF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n+  \"TARGET_CE\"\n+  \"@\n+   fdiv%.s %2,%1,%0\n+   fdiv%.s %2,%1,%0\n+   frdiv%.s %1,%2,%0\")\n+\f\n+;; Remainder instructions.\n+\n+(define_insn \"modhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(mod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"dmn\")))]\n+  \"\"\n+  \"extl %0\\;divs %2,%0\\;swap %0\")\n+\n+(define_insn \"modhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI\n+\t (mod:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n+  \"\"\n+  \"divs %2,%0\\;swap %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI (mod:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n+  \"\"\n+  \"divs %2,%0\\;swap %0\")\n+\n+(define_insn \"umodhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(umod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n+  \"\"\n+  \"and%.l %#0xFFFF,%0\\;divu %2,%0\\;swap %0\")\n+\n+(define_insn \"umodhisi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI\n+\t (umod:SI\n+\t  (match_operand:SI 1 \"general_operand\" \"0\")\n+\t  (zero_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n+  \"\"\n+  \"divu %2,%0\\;swap %0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(truncate:HI (umod:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t\t      (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n+  \"\"\n+  \"divu %2,%0\\;swap %0\")\n+\n+(define_insn \"divmodsi4\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"dmsK\")))\n+   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+\t(mod:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_68020\"\n+  \"divs%.l %2,%0,%3\")\n+\n+(define_insn \"udivmodsi4\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n+   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_68020\"\n+  \"divu%.l %2,%0,%3\")\n+\f\n+;; logical-and instructions\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n+\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmKs\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n+      && (DATA_REG_P (operands[0])\n+\t  || offsettable_memref_p (operands[0])))\n+    { \n+      if (GET_CODE (operands[0]) != REG)\n+        operands[0] = adj_offsettable_operand (operands[0], 2);\n+      operands[2] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t     INTVAL (operands[2]) & 0xffff);\n+      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n+      CC_STATUS_INIT;\n+      if (operands[2] == const0_rtx)\n+        return \\\"clr%.w %0\\\";\n+      return \\\"and%.w %2,%0\\\";\n+    }\n+  return \\\"and%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=m,d\")\n+\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"and%.w %2,%0\")\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"and%.b %2,%0\")\n+\n+\f\n+;; inclusive-or instructions\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n+\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmKs\")))]\n+  \"\"\n+  \"*\n+{\n+  register int logval;\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) >> 16 == 0\n+      && (DATA_REG_P (operands[0])\n+\t  || offsettable_memref_p (operands[0])))\n+    { \n+      if (GET_CODE (operands[0]) != REG)\n+        operands[0] = adj_offsettable_operand (operands[0], 2);\n+      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n+      CC_STATUS_INIT;\n+      return \\\"or%.w %2,%0\\\";\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && (logval = exact_log2 (INTVAL (operands[2]))) >= 0\n+      && (DATA_REG_P (operands[0])\n+\t  || offsettable_memref_p (operands[0])))\n+    { \n+      if (DATA_REG_P (operands[0]))\n+\toperands[1] = gen_rtx (CONST_INT, VOIDmode, logval);\n+      else\n+        {\n+\t  operands[0] = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n+\t  operands[1] = gen_rtx (CONST_INT, VOIDmode, logval % 8);\n+\t}\n+      return \\\"bset %1,%0\\\";\n+    }\n+  return \\\"or%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=m,d\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"or%.w %2,%0\")\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n+  \"\"\n+  \"or%.b %2,%0\")\n+\f\n+;; xor instructions\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=do,m\")\n+\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"general_operand\" \"di,dKs\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT\n+      && INTVAL (operands[2]) >> 16 == 0\n+      && (offsettable_memref_p (operands[0]) || DATA_REG_P (operands[0])))\n+    { \n+      if (! DATA_REG_P (operands[0]))\n+\toperands[0] = adj_offsettable_operand (operands[0], 2);\n+      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n+      CC_STATUS_INIT;\n+      return \\\"eor%.w %2,%0\\\";\n+    }\n+  return \\\"eor%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"dn\")))]\n+  \"\"\n+  \"eor%.w %2,%0\")\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"dn\")))]\n+  \"\"\n+  \"eor%.b %2,%0\")\n+\f\n+;; negation instructions\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n+\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg%.l %0\")\n+\n+(define_insn \"neghi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n+\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg%.w %0\")\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg%.b %0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fneg%.s %1,%0\")\n+\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fneg%.d %1,%0\")\n+\f\n+;; Absolute value instructions\n+\n+(define_insn \"abssf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fabs%.s %1,%0\")\n+\n+(define_insn \"absdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fabs%.d %1,%0\")\n+\f\n+;; Square root instructions\n+\n+(define_insn \"sqrtsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(sqrt:SF (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fsqrt%.s %1,%0\")\n+\n+(define_insn \"sqrtdf2\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n+  \"TARGET_CE\"\n+  \"fsqrt%.d %1,%0\")\n+\f\n+;; one complement instructions\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not%.l %0\")\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not%.w %0\")\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n+\t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not%.b %0\")\n+\f\n+\f\n+;; arithmetic shift instructions\n+;; We don't need the shift memory by 1 bit instruction\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"asl%.l %2,%0\")\n+\n+(define_insn \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"asl%.w %2,%0\")\n+\n+(define_insn \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"asl%.b %2,%0\")\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"asr%.l %2,%0\")\n+\n+(define_insn \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"asr%.w %2,%0\")\n+\n+(define_insn \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"asr%.b %2,%0\")\n+\f\n+;; logical shift instructions\n+\n+(define_insn \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(lshift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"lsl%.l %2,%0\")\n+\n+(define_insn \"lshlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(lshift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"lsl%.w %2,%0\")\n+\n+(define_insn \"lshlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(lshift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"lsl%.b %2,%0\")\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"lsr%.l %2,%0\")\n+\n+(define_insn \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"lsr%.w %2,%0\")\n+\n+(define_insn \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"lsr%.b %2,%0\")\n+\f\n+;; rotate instructions\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:SI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"rol%.l %2,%0\")\n+\n+(define_insn \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"rol%.w %2,%0\")\n+\n+(define_insn \"rotlqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"rol%.b %2,%0\")\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"ror%.l %2,%0\")\n+\n+(define_insn \"rotrhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n+\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"ror%.w %2,%0\")\n+\n+(define_insn \"rotrqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n+  \"\"\n+  \"ror%.b %2,%0\")\n+\f\n+;; Special cases of bit-field insns which we should\n+;; recognize in preference to the general case.\n+;; These handle aligned 8-bit and 16-bit fields,\n+;; which can usually be done with move instructions.\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+do\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n+\t(match_operand:SI 3 \"general_operand\" \"d\"))]\n+  \"TARGET_68020 && TARGET_BITFIELD\n+   && (INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n+   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n+   && (GET_CODE (operands[0]) == REG\n+       || ! mode_dependent_address_p (XEXP (operands[0], 0)))\"\n+  \"*\n+{\n+  if (REG_P (operands[0]))\n+    {\n+      if (INTVAL (operands[1]) + INTVAL (operands[2]) != 32)\n+        return \\\"bfins %3,[%c2,%c1]%0\\\";\n+    }\n+  else\n+    operands[0]\n+      = adj_offsettable_operand (operands[0], INTVAL (operands[2]) / 8);\n+\n+  if (GET_CODE (operands[3]) == MEM)\n+    operands[3] = adj_offsettable_operand (operands[3],\n+\t\t\t\t\t   (32 - INTVAL (operands[1])) / 8);\n+  if (INTVAL (operands[1]) == 8)\n+    return \\\"mov%.b %3,%0\\\";\n+  return \\\"mov%.w %3,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=&d\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"do\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\n+   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n+   && (GET_CODE (operands[1]) == REG\n+       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    {\n+      if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n+\treturn \\\"bfextu [%c3,%c2]%1,%0\\\";\n+    }\n+  else\n+    operands[1]\n+      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n+\n+  output_asm_insn (\\\"clrl %0\\\", operands);\n+  if (GET_CODE (operands[0]) == MEM)\n+    operands[0] = adj_offsettable_operand (operands[0],\n+\t\t\t\t\t   (32 - INTVAL (operands[1])) / 8);\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"mov%.b %1,%0\\\";\n+  return \\\"mov%.w %1,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"do\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\n+   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n+   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n+   && (GET_CODE (operands[1]) == REG\n+       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n+  \"*\n+{\n+  if (REG_P (operands[1]))\n+    {\n+      if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n+\treturn \\\"bfexts [%c3,%c2]%1,%0\\\";\n+    }\n+  else\n+    operands[1]\n+      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n+\n+  if (INTVAL (operands[2]) == 8)\n+    return \\\"mov%.b %1,%0\\;extb%.l %0\\\";\n+  return \\\"mov%.w %1,%0\\;ext%.l %0\\\";\n+}\")\n+\f\n+;; Bit field instructions, general cases.\n+;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n+;; so that its address is reloaded.\n+\n+(define_insn \"extv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n+\t(sign_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"o,d\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di,di\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"di,di\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"bfexts [%c3,%c2]%1,%0\")\n+\n+(define_insn \"extzv\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n+\t(zero_extract:SI (match_operand:QI 1 \"nonimmediate_operand\" \"o,d\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di,di\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"di,di\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"bfextu [%c3,%c2]%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"+o,d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di,di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di,di\"))\n+        (xor:SI (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))\n+\t\t(match_operand:SI 3 \"const_int_operand\" \"i,i\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\n+   && (INTVAL (operands[3]) == -1\n+       || (GET_CODE (operands[1]) == CONST_INT\n+           && (~ INTVAL (operands[3]) & ((1 << INTVAL (operands[1]))- 1)) == 0))\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"bfchg [%c2,%c1]%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"+o,d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di,di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di,di\"))\n+\t(const_int 0))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"bfclr [%c2,%c1]%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"+o,d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di,di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di,di\"))\n+\t(const_int -1))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"bfset [%c2,%c1]%0\\\";\n+}\")\n+\n+(define_insn \"insv\"\n+  [(set (zero_extract:SI (match_operand:QI 0 \"nonimmediate_operand\" \"+o,d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di,di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di,di\"))\n+\t(match_operand:SI 3 \"general_operand\" \"d,d\"))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"bfins %3,[%c2,%c1]%0\")\n+\n+;; Now recognize bit field insns that operate on registers\n+;; (or at least were intended to do so).\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(sign_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"di\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"bfexts [%c3,%c2]%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n+\t(zero_extract:SI (match_operand:SI 1 \"nonimmediate_operand\" \"d\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")\n+\t\t\t (match_operand:SI 3 \"general_operand\" \"di\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"bfextu [%c3,%c2]%1,%0\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n+\t(const_int 0))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"bfclr [%c2,%c1]%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n+\t(const_int -1))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  CC_STATUS_INIT;\n+  return \\\"bfset [%c2,%c1]%0\\\";\n+}\")\n+\n+(define_insn \"\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"+d\")\n+\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n+\t(match_operand:SI 3 \"general_operand\" \"d\"))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  return \\\"bfins %3,[%c2,%c1]%0\\\";\n+}\")\n+\f\n+;; Special patterns for optimizing bit-field instructions.\n+\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  if (operands[1] == const1_rtx\n+      && GET_CODE (operands[2]) == CONST_INT)\n+    {    \n+      int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n+      return output_btst (operands,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t   width - INTVAL (operands[2])),\n+\t\t\t  operands[0],\n+\t\t\t  insn, 1000);\n+      /* Pass 1000 as SIGNPOS argument so that btst will\n+         not think we are testing the sign bit for an `and'\n+\t and assume that nonzero implies a negative result.  */\n+    }\n+  if (INTVAL (operands[1]) != 32)\n+    cc_status.flags = CC_NOT_NEGATIVE;\n+  return \\\"bftst [%c2,%c1]%0\\\";\n+}\")\n+\n+;;; now handle the register cases\n+(define_insn \"\"\n+  [(set (cc0)\n+\t(zero_extract:SI (match_operand:SI 0 \"nonimmediate_operand\" \"d\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")))]\n+  \"TARGET_68020 && TARGET_BITFIELD\"\n+  \"*\n+{\n+  if (operands[1] == const1_rtx\n+      && GET_CODE (operands[2]) == CONST_INT)\n+    {    \n+      int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n+      return output_btst (operands,\n+\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t\t   width - INTVAL (operands[2])),\n+\t\t\t  operands[0],\n+\t\t\t  insn, 1000);\n+      /* Pass 1000 as SIGNPOS argument so that btst will\n+         not think we are testing the sign bit for an `and'\n+\t and assume that nonzero implies a negative result.  */\n+    }\n+  if (INTVAL (operands[1]) != 32)\n+    cc_status.flags = CC_NOT_NEGATIVE;\n+  return \\\"bftst [%c2,%c1]%0\\\";\n+}\")\n+\n+\f\n+(define_insn \"seq\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(eq:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+  cc_status = cc_prev_status;\n+  OUTPUT_JUMP (\\\"seq %0\\\", \\\"fseq %0\\\", \\\"seq %0\\\");\n+\")\n+\n+(define_insn \"sne\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(ne:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+  cc_status = cc_prev_status;\n+  OUTPUT_JUMP (\\\"sne %0\\\", \\\"fsneq %0\\\", \\\"sne %0\\\");\n+\")\n+\n+(define_insn \"sgt\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(gt:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+  cc_status = cc_prev_status;\n+  OUTPUT_JUMP (\\\"sgt %0\\\", \\\"fsgt %0\\\", \\\"and%.b %#0xc,%!\\;sgt %0\\\");\n+\")\n+\n+(define_insn \"sgtu\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(gtu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"* cc_status = cc_prev_status;\n+     return \\\"shi %0\\\"; \")\n+\n+(define_insn \"slt\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(lt:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"* cc_status = cc_prev_status;\n+     OUTPUT_JUMP (\\\"slt %0\\\", \\\"fslt %0\\\", \\\"smi %0\\\"); \")\n+\n+(define_insn \"sltu\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(ltu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"* cc_status = cc_prev_status;\n+     return \\\"scs %0\\\"; \")\n+\n+(define_insn \"sge\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(ge:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"* cc_status = cc_prev_status;\n+     OUTPUT_JUMP (\\\"sge %0\\\", \\\"fsge %0\\\", \\\"spl %0\\\"); \")\n+\n+(define_insn \"sgeu\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(geu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"* cc_status = cc_prev_status;\n+     return \\\"scc %0\\\"; \")\n+\n+(define_insn \"sle\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(le:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"*\n+  cc_status = cc_prev_status;\n+  OUTPUT_JUMP (\\\"sle %0\\\", \\\"fsle %0\\\", \\\"and%.b %#0xc,%!\\;sle %0\\\");\n+\")\n+\n+(define_insn \"sleu\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n+\t(leu:QI (cc0) (const_int 0)))]\n+  \"\"\n+  \"* cc_status = cc_prev_status;\n+     return \\\"sls %0\\\"; \")\n+\f\n+;; Basic conditional jump instructions.\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"jeq %l0\\\", \\\"fbeq %l0\\\", \\\"jeq %l0\\\");\n+}\")\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"jne %l0\\\", \\\"fbneq %l0\\\", \\\"jne %l0\\\");\n+}\")\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jgt %l0\\\", \\\"fbgt %l0\\\", \\\"and%.b %#0xc,%!\\;jgt %l0\\\");\n+\")\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  return \\\"jhi %l0\\\";\n+\")\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jlt %l0\\\", \\\"fblt %l0\\\", \\\"jmi %l0\\\");\n+\")\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  return \\\"jcs %l0\\\";\n+\")\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"fbge %l0\\\", \\\"jpl %l0\\\");\n+\")\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  return \\\"jcc %l0\\\";\n+\")\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"fble %l0\\\", \\\"and%.b %#0xc,%!\\;jle %l0\\\");\n+\")\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"*\n+  return \\\"jls %l0\\\";\n+\")\n+\f\n+;; Negated conditional jump instructions.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"jne %l0\\\", \\\"fbneq %l0\\\", \\\"jne %l0\\\");\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  OUTPUT_JUMP (\\\"jeq %l0\\\", \\\"fbeq %l0\\\", \\\"jeq %l0\\\");\n+}\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"fbngt %l0\\\", \\\"and%.b %#0xc,%!\\;jle %l0\\\");\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return \\\"jls %l0\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"fbnlt %l0\\\", \\\"jpl %l0\\\");\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return \\\"jcc %l0\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jlt %l0\\\", \\\"fbnge %l0\\\", \\\"jmi %l0\\\");\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return \\\"jcs %l0\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  OUTPUT_JUMP (\\\"jgt %l0\\\", \\\"fbnle %l0\\\", \\\"and%.b %#0xc,%!\\;jgt %l0\\\");\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+  return \\\"jhi %l0\\\";\n+\")\n+\f\n+;; Subroutines of \"casesi\".\n+\n+(define_expand \"casesi_1\"\n+  [(set (match_operand:SI 3 \"general_operand\" \"\")\n+\t(plus:SI (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t ;; Note operand 1 has been negated!\n+\t\t (match_operand:SI 1 \"immediate_operand\" \"\")))\n+   (set (cc0) (compare (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n+\t\t       (match_dup 3)))\n+   (set (pc) (if_then_else (ltu (cc0) (const_int 0))\n+\t\t\t   (label_ref (match_operand 4 \"\" \"\")) (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"casesi_2\"\n+  [(set (match_operand:SI 0 \"\" \"\") (mem:HI (match_operand:SI 1 \"\" \"\")))\n+   ;; The USE here is so that at least one jump-insn will refer to the label,\n+   ;; to keep it alive in jump_optimize.\n+   (parallel [(set (pc)\n+\t\t   (plus:SI (pc) (match_dup 0)))\n+\t      (use (label_ref (match_operand 2 \"\" \"\")))])]\n+  \"\"\n+  \"\")\n+\n+;; Operand 0 is index (in bytes); operand 1 is minimum, operand 2 the maximum;\n+;; operand 3 is CODE_LABEL for the table;\n+;; operand 4 is the CODE_LABEL to go to if index out of range.\n+(define_expand \"casesi\"\n+  ;; We don't use these for generating the RTL, but we must describe\n+  ;; the operands here.\n+  [(match_operand:SI 0 \"general_operand\" \"\")\n+   (match_operand:SI 1 \"immediate_operand\" \"\")\n+   (match_operand:SI 2 \"general_operand\" \"\")\n+   (match_operand 3 \"\" \"\")\n+   (match_operand 4 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx table_elt_addr;\n+  rtx index_diff;\n+\n+  operands[1] = negate_rtx (SImode, operands[1]);\n+  index_diff = gen_reg_rtx (SImode);\n+  /* Emit the first few insns.  */\n+  emit_insn (gen_casesi_1 (operands[0], operands[1], operands[2],\n+\t\t\t   index_diff, operands[4]));\n+  /* Construct a memory address.  This may emit some insns.  */\n+  table_elt_addr\n+    = memory_address_noforce\n+        (HImode,\n+\t gen_rtx (PLUS, Pmode,\n+\t\t  gen_rtx (MULT, Pmode, index_diff,\n+\t\t\t   gen_rtx (CONST_INT, VOIDmode, 2)),\n+\t\t  gen_rtx (LABEL_REF, VOIDmode, operands[3])));\n+  /* Emit the last few insns.  */\n+  emit_insn (gen_casesi_2 (gen_reg_rtx (HImode), table_elt_addr, operands[3]));\n+  DONE;\n+}\")\n+\n+;; Recognize one of the insns resulting from casesi_2.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(plus:SI (pc) (match_operand:HI 0 \"general_operand\" \"r\")))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"*\n+  return \\\"jmp pc@(2:B)[%0:W:B]\\\";\n+\")\n+\f\n+;; Unconditional and other jump instructions\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+  return \\\"jra %l0\\\";\n+\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:HI 0 \"general_operand\" \"d,m,g\")\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"\"\n+  \"@\n+   dbra %0,%l1\n+   subq%.w %#1,%0\\;jcc %l1\n+   subq%.w %#1,%0\\;cmp%.w %#-1,%0\\;jne %l1\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:SI 0 \"general_operand\" \"d,m,g\")\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"\"\n+  \"@\n+   dbra %0,%l1\\;clr%.w %0\\;subq%.l %#1,%0\\;jcc %l1\n+   subq%.l %#1,%0\\;jcc %l1\n+   subq%.l %#1,%0\\;cmp%.l %#-1,%0\\;jne %l1\")\n+\n+;; dbra patterns that use REG_NOTES info generated by strength_reduce.\n+\n+(define_insn \"decrement_and_branch_until_zero\"\n+  [(set (pc)\n+\t(if_then_else\n+\t  (ge (match_operand:SI 0 \"general_operand\" \"d,m,g\")\n+\t      (const_int 1))\n+\t  (label_ref (match_operand 1 \"\" \"\"))\n+\t  (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"@\n+   dbra %0,%l1\\;clrw %0\\;subql %#1,%0\\;jcc %l1\n+   subq%.l %#1,%0\\;jcc %l1\n+   subq%.l %#1,%0\\;cmp%.l %#-1,%0\\;jne %l1\")\n+\n+;; Call subroutine with no return value.\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"o\")\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[2];\n+  int size = XINT(operands[1],0);\n+\n+  if (size == 0) \n+    output_asm_insn (\\\"sub%.l a0,a0\\;jbsr %0\\\", operands);\n+  else\n+  {\n+    xoperands[1] = gen_rtx (CONST_INT, VOIDmode, size/4);\n+    output_asm_insn (\\\"mov%.l sp,a0\\;pea %a1\\\", xoperands);\n+    output_asm_insn (\\\"jbsr %0\\\", operands);\n+    size = size + 4;\n+    xoperands[1] = gen_rtx (CONST_INT, VOIDmode, size);\n+    if (size <= 8)\n+      output_asm_insn (\\\"addq%.l %1,sp\\\", xoperands);\n+    else if (size < 0x8000)\n+      output_asm_insn (\\\"add%.w %1,sp\\\", xoperands);\n+    else\n+      output_asm_insn (\\\"add%.l %1,sp\\\", xoperands);\n+  }\n+  return \\\"mov%.l a6@(-4),a0\\\";\n+}\")\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"o\")\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[3];\n+  int size = XINT(operands[2],0);\n+\n+  if (size == 0)\n+    output_asm_insn(\\\"sub%.l a0,a0\\;jbsr %1\\\", operands);\n+  else\n+  {\n+    xoperands[2] = gen_rtx (CONST_INT, VOIDmode, size/4);\n+    output_asm_insn (\\\"mov%.l sp,a0\\;pea %a2\\\", xoperands);\n+    output_asm_insn (\\\"jbsr %1\\\", operands);\n+    size = size + 4;\n+    xoperands[2] = gen_rtx (CONST_INT, VOIDmode, size);\n+    if (size <= 8)\n+      output_asm_insn (\\\"addq%.l %2,sp\\\", xoperands);\n+    else if (size < 0x8000)\n+      output_asm_insn (\\\"add%.w %2,sp\\\", xoperands);\n+    else\n+      output_asm_insn (\\\"add%.l %2,sp\\\", xoperands);\n+  }\n+  return \\\"mov%.l a6@(-4),a0\\\";\n+}\")\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\")\n+\f\n+;; This should not be used unless the add/sub insns can't be.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n+\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n+  \"\"\n+  \"lea %a1,%0\")\n+\f\n+;; This is the first machine-dependent peephole optimization.\n+;; It is useful when a floating value is returned from a function call\n+;; and then is moved into an FP register.\n+;; But it is mainly intended to test the support for these optimizations.\n+\n+;Not applicable to Alliant -- floating results are returned in fp0\n+;(define_peephole\n+;  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))\n+;   (set (match_operand:DF 0 \"register_operand\" \"f\")\n+;\t(match_operand:DF 1 \"register_operand\" \"ad\"))]\n+;  \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n+;  \"*\n+;{\n+;  rtx xoperands[2];\n+;  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+;  output_asm_insn (\\\"mov%.l %1,%@\\\", xoperands);\n+;  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n+;  return \\\"fmove%.d %+,%0\\\";\n+;}\n+;\")\n+\f\n+\n+;;- Local variables:\n+;;- mode:emacs-lisp\n+;;- comment-start: \";;- \"\n+;;- comment-start-skip: \";+- *\"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:\n+"}]}