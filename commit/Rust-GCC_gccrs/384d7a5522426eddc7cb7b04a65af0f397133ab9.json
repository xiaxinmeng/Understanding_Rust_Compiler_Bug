{"sha": "384d7a5522426eddc7cb7b04a65af0f397133ab9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg0ZDdhNTUyMjQyNmVkZGM3Y2I3YjA0YTY1YWYwZjM5NzEzM2FiOQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:24:50Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2011-04-04T18:24:50Z"}, "message": "cprop.c (implicit_set_cond_p): Assume nothing about COND...\n\n\t* cprop.c (implicit_set_cond_p): Assume nothing about COND, move\n\tchecks on form of COND from find_implicit_sets to here.\n\t(find_implicit_sets): Cleanup control flow. Split critical edges\n\tif it exposes implicit sets.  Allocate/resize implicit_sets as\n\tnecessary.\n\t(one_cprop_pass): Only delete unreachable blocks if local_cprop_pass\n\tchanged something.  Run df_analyze after find_implicit_sets if any\n\tedges were split.  Do not allocate implicit_sets here.\n\nFrom-SVN: r171946", "tree": {"sha": "3b2e6e2fd36117581af20d553fc1d00a97d4b8a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b2e6e2fd36117581af20d553fc1d00a97d4b8a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/384d7a5522426eddc7cb7b04a65af0f397133ab9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/384d7a5522426eddc7cb7b04a65af0f397133ab9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/384d7a5522426eddc7cb7b04a65af0f397133ab9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/384d7a5522426eddc7cb7b04a65af0f397133ab9/comments", "author": null, "committer": null, "parents": [{"sha": "3084ce6991ded2bf850baa84fa1bf975d9982dd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3084ce6991ded2bf850baa84fa1bf975d9982dd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3084ce6991ded2bf850baa84fa1bf975d9982dd4"}], "stats": {"total": 151, "additions": 103, "deletions": 48}, "files": [{"sha": "1c27c17548082aba11fc5a7fe92eee5cb589b2a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/384d7a5522426eddc7cb7b04a65af0f397133ab9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/384d7a5522426eddc7cb7b04a65af0f397133ab9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=384d7a5522426eddc7cb7b04a65af0f397133ab9", "patch": "@@ -1,5 +1,14 @@\n 2011-04-04  Steven Bosscher  <steven@gcc.gnu.org>\n \n+\t* cprop.c (implicit_set_cond_p): Assume nothing about COND, move\n+\tchecks on form of COND from find_implicit_sets to here.\n+\t(find_implicit_sets): Cleanup control flow. Split critical edges\n+\tif it exposes implicit sets.  Allocate/resize implicit_sets as\n+\tnecessary.\n+\t(one_cprop_pass): Only delete unreachable blocks if local_cprop_pass\n+\tchanged something.  Run df_analyze after find_implicit_sets if any\n+\tedges were split.  Do not allocate implicit_sets here.\n+\n \t* cprop.c: s/gcse/cprop/ everywhere except for flag_gcse.\n \t(gcse_obstack): Renamed to cprop_obstack.\n \t(GNEW, GNEWVEC, GNEWVAR): Remove."}, {"sha": "340d2356eeb60a7ffe805b14790c7051b3ed4921", "filename": "gcc/cprop.c", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/384d7a5522426eddc7cb7b04a65af0f397133ab9/gcc%2Fcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/384d7a5522426eddc7cb7b04a65af0f397133ab9/gcc%2Fcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcprop.c?ref=384d7a5522426eddc7cb7b04a65af0f397133ab9", "patch": "@@ -1343,14 +1343,27 @@ fis_get_condition (rtx jump)\n   return get_condition (jump, NULL, false, true);\n }\n \n-/* Check the comparison COND to see if we can safely form an implicit set from\n-   it.  COND is either an EQ or NE comparison.  */\n+/* Check the comparison COND to see if we can safely form an implicit\n+   set from it.  */\n \n static bool\n implicit_set_cond_p (const_rtx cond)\n {\n-  const enum machine_mode mode = GET_MODE (XEXP (cond, 0));\n-  const_rtx cst = XEXP (cond, 1);\n+  enum machine_mode mode;\n+  rtx cst;\n+\n+  /* COND must be either an EQ or NE comparison.  */\n+  if (GET_CODE (cond) != EQ && GET_CODE (cond) != NE)\n+    return false;\n+\n+  /* The first operand of COND must be a pseudo-reg.  */\n+  if (! REG_P (XEXP (cond, 0))\n+      || HARD_REGISTER_P (XEXP (cond, 0)))\n+    return false;\n+\n+  /* The second operand of COND must be a suitable constant.  */\n+  mode = GET_MODE (XEXP (cond, 0));\n+  cst = XEXP (cond, 1);\n \n   /* We can't perform this optimization if either operand might be or might\n      contain a signed zero.  */\n@@ -1382,55 +1395,78 @@ implicit_set_cond_p (const_rtx cond)\n    function records the set patterns that are implicit at the start of each\n    basic block.\n \n-   FIXME: This would be more effective if critical edges are pre-split.  As\n-\t  it is now, we can't record implicit sets for blocks that have\n-\t  critical successor edges.  This results in missed optimizations\n-\t  and in more (unnecessary) work in cfgcleanup.c:thread_jump().  */\n+   If an implicit set is found but the set is implicit on a critical edge,\n+   this critical edge is split.\n \n-static void\n+   Return true if the CFG was modified, false otherwise.  */\n+\n+static bool\n find_implicit_sets (void)\n {\n   basic_block bb, dest;\n-  unsigned int count;\n   rtx cond, new_rtx;\n+  unsigned int count = 0;\n+  bool edges_split = false;\n+  size_t implicit_sets_size = last_basic_block + 10;\n+\n+  implicit_sets = XCNEWVEC (rtx, implicit_sets_size);\n \n-  count = 0;\n   FOR_EACH_BB (bb)\n-    /* Check for more than one successor.  */\n-    if (EDGE_COUNT (bb->succs) > 1)\n-      {\n-\tcond = fis_get_condition (BB_END (bb));\n+    {\n+      /* Check for more than one successor.  */\n+      if (! EDGE_COUNT (bb->succs) > 1)\n+\tcontinue;\n \n-\tif (cond\n-\t    && (GET_CODE (cond) == EQ || GET_CODE (cond) == NE)\n-\t    && REG_P (XEXP (cond, 0))\n-\t    && REGNO (XEXP (cond, 0)) >= FIRST_PSEUDO_REGISTER\n-\t    && implicit_set_cond_p (cond))\n-\t  {\n-\t    dest = GET_CODE (cond) == EQ ? BRANCH_EDGE (bb)->dest\n-\t\t\t\t\t : FALLTHRU_EDGE (bb)->dest;\n+      cond = fis_get_condition (BB_END (bb));\n \n-\t    if (dest\n-\t\t/* Record nothing for a critical edge.  */\n-\t\t&& single_pred_p (dest)\n-\t\t&& dest != EXIT_BLOCK_PTR)\n-\t      {\n-\t\tnew_rtx = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n-\t\t\t\t\t     XEXP (cond, 1));\n-\t\timplicit_sets[dest->index] = new_rtx;\n-\t\tif (dump_file)\n-\t\t  {\n-\t\t    fprintf(dump_file, \"Implicit set of reg %d in \",\n-\t\t\t    REGNO (XEXP (cond, 0)));\n-\t\t    fprintf(dump_file, \"basic block %d\\n\", dest->index);\n-\t\t  }\n-\t\tcount++;\n-\t      }\n-\t  }\n+      /* If no condition is found or if it isn't of a suitable form,\n+\t ignore it.  */\n+      if (! cond || ! implicit_set_cond_p (cond))\n+\tcontinue;\n+\n+      dest = GET_CODE (cond) == EQ\n+\t? BRANCH_EDGE (bb)->dest : FALLTHRU_EDGE (bb)->dest;\n+\n+      /* If DEST doesn't go anywhere, ignore it.  */\n+      if (! dest || dest == EXIT_BLOCK_PTR)\n+\tcontinue;\n+\n+      /* We have found a suitable implicit set.  Try to record it now as\n+\t a SET in DEST.  If DEST has more than one predecessor, the edge\n+\t between BB and DEST is a critical edge and we must split it,\n+\t because we can only record one implicit set per DEST basic block.  */\n+      if (! single_pred_p (dest))\n+        {\n+\t  dest = split_edge (find_edge (bb, dest));\n+\t  edges_split = true;\n+\t}\n+\n+      if (implicit_sets_size <= (size_t) dest->index)\n+      {\n+        size_t old_implicit_sets_size = implicit_sets_size;\n+\timplicit_sets_size *= 2;\n+\timplicit_sets = XRESIZEVEC (rtx, implicit_sets, implicit_sets_size);\n+\tmemset (implicit_sets + old_implicit_sets_size, 0,\n+\t\t(implicit_sets_size - old_implicit_sets_size) * sizeof (rtx));\n       }\n \n+      new_rtx = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n+\t\t\t     XEXP (cond, 1));\n+      implicit_sets[dest->index] = new_rtx;\n+      if (dump_file)\n+\t{\n+\t  fprintf(dump_file, \"Implicit set of reg %d in \",\n+\t\t  REGNO (XEXP (cond, 0)));\n+\t  fprintf(dump_file, \"basic block %d\\n\", dest->index);\n+\t}\n+      count++;\n+    }\n+\n   if (dump_file)\n     fprintf (dump_file, \"Found %d implicit sets\\n\", count);\n+\n+  /* Confess our sins.  */\n+  return edges_split;\n }\n \n /* Bypass conditional jumps.  */\n@@ -1797,14 +1833,24 @@ one_cprop_pass (void)\n \t    the solver implemented in this file.  */\n   changed |= local_cprop_pass ();\n   if (changed)\n-    {\n-      delete_unreachable_blocks ();\n-      df_analyze ();\n-    }\n-\n-  /* Determine implicit sets.  */\n-  implicit_sets = XCNEWVEC (rtx, last_basic_block);\n-  find_implicit_sets ();\n+    delete_unreachable_blocks ();\n+\n+  /* Determine implicit sets.  This may change the CFG (split critical\n+     edges if that exposes an implicit set).\n+     Note that find_implicit_sets() does not rely on up-to-date DF caches\n+     so that we do not have to re-run df_analyze() even if local CPROP\n+     changed something.\n+     ??? This could run earlier so that any uncovered implicit sets\n+\t sets could be exploited in local_cprop_pass() also.  Later.  */\n+  changed |= find_implicit_sets ();\n+\n+  /* If local_cprop_pass() or find_implicit_sets() changed something,\n+     run df_analyze() to bring all insn caches up-to-date, and to take\n+     new basic blocks from edge splitting on the DF radar.\n+     NB: This also runs the fast DCE pass, because execute_rtl_cprop\n+     sets DF_LR_RUN_DCE.  */\n+  if (changed)\n+    df_analyze ();\n \n   alloc_hash_table (&set_hash_table);\n   compute_hash_table (&set_hash_table);"}]}