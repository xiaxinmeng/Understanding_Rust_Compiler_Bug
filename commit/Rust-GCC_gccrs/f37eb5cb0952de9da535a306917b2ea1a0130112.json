{"sha": "f37eb5cb0952de9da535a306917b2ea1a0130112", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM3ZWI1Y2IwOTUyZGU5ZGE1MzVhMzA2OTE3YjJlYTFhMDEzMDExMg==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl@gnu.org", "date": "1998-04-20T00:01:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-20T00:01:15Z"}, "message": "reg-stack.c (subst_asm_stack_regs): Change to return the last new insn generated by this function.\n\n\t* reg-stack.c (subst_asm_stack_regs): Change to return the last\n\tnew insn generated by this function.\n\t(subst_stack_regs): Likewise.\n\t(convert_regs): Record the last newly generated insn and use\n\tit for change_stack () instead of INSN.\n\nFrom-SVN: r19328", "tree": {"sha": "bfc9519a6966822770663a8f9ffb24fa192df9c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfc9519a6966822770663a8f9ffb24fa192df9c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f37eb5cb0952de9da535a306917b2ea1a0130112", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37eb5cb0952de9da535a306917b2ea1a0130112", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37eb5cb0952de9da535a306917b2ea1a0130112", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37eb5cb0952de9da535a306917b2ea1a0130112/comments", "author": null, "committer": null, "parents": [{"sha": "0620228c243d5292571fd3d925a8ca24c7091942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0620228c243d5292571fd3d925a8ca24c7091942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0620228c243d5292571fd3d925a8ca24c7091942"}], "stats": {"total": 44, "additions": 31, "deletions": 13}, "files": [{"sha": "17eab4d5ba7f2172c63287fc76fdf4e9e7483380", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37eb5cb0952de9da535a306917b2ea1a0130112/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37eb5cb0952de9da535a306917b2ea1a0130112/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f37eb5cb0952de9da535a306917b2ea1a0130112", "patch": "@@ -1,3 +1,11 @@\n+Mon Apr 20 01:00:05 1998  H.J. Lu  (hjl@gnu.org)\n+\n+\t* reg-stack.c (subst_asm_stack_regs): Change to return the last\n+\tnew insn generated by this function.\n+\t(subst_stack_regs): Likewise.\n+\t(convert_regs): Record the last newly generated insn and use\n+\tit for change_stack () instead of INSN.\n+\n Sun Apr 19 15:41:24 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n \t* fix-header.c (enum special_file): Undefine enumerators if they"}, {"sha": "d4ef06bd4a112ab8a86228102f10d9ad5a9459c2", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f37eb5cb0952de9da535a306917b2ea1a0130112/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f37eb5cb0952de9da535a306917b2ea1a0130112/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=f37eb5cb0952de9da535a306917b2ea1a0130112", "patch": "@@ -262,9 +262,9 @@ static void move_for_stack_reg\t\tPROTO((rtx, stack, rtx));\n static void swap_rtx_condition\t\tPROTO((rtx));\n static void compare_for_stack_reg\tPROTO((rtx, stack, rtx));\n static void subst_stack_regs_pat\tPROTO((rtx, stack, rtx));\n-static void subst_asm_stack_regs\tPROTO((rtx, stack, rtx *, rtx **,\n+static rtx subst_asm_stack_regs\t\tPROTO((rtx, stack, rtx *, rtx **,\n \t\t\t\t\t       char **, int, int));\n-static void subst_stack_regs\t\tPROTO((rtx, stack));\n+static rtx subst_stack_regs\t\tPROTO((rtx, stack));\n static void change_stack\t\tPROTO((rtx, stack, stack, rtx (*) ()));\n \n static void goto_block_pat\t\tPROTO((rtx, stack, rtx));\n@@ -2411,9 +2411,11 @@ subst_stack_regs_pat (insn, regstack, pat)\n    stack-like regs in asm statements.  These rules are enforced by\n    record_asm_stack_regs; see comments there for details.  Any\n    asm_operands left in the RTL at this point may be assume to meet the\n-   requirements, since record_asm_stack_regs removes any problem asm.  */\n+   requirements, since record_asm_stack_regs removes any problem asm.\n \n-static void\n+   It returns the last new insn generated by this function. */\n+\n+static rtx\n subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t\t      n_inputs, n_outputs)\n      rtx insn;\n@@ -2692,14 +2694,18 @@ subst_asm_stack_regs (insn, regstack, operands, operands_loc, constraints,\n \t      break;\n \t    }\n       }\n+\n+  return insn;\n }\n \f\n /* Substitute stack hard reg numbers for stack virtual registers in\n    INSN.  Non-stack register numbers are not changed.  REGSTACK is the\n    current stack content.  Insns may be emitted as needed to arrange the\n-   stack for the 387 based on the contents of the insn.  */\n+   stack for the 387 based on the contents of the insn.\n \n-static void\n+   It returns the last new insn generated by this function. */\n+\n+static rtx\n subst_stack_regs (insn, regstack)\n      rtx insn;\n      stack regstack;\n@@ -2755,9 +2761,9 @@ subst_stack_regs (insn, regstack)\n \t  decode_asm_operands (body, operands, operands_loc,\n \t\t\t       constraints, NULL_PTR);\n \t  get_asm_operand_lengths (body, n_operands, &n_inputs, &n_outputs);\n-\t  subst_asm_stack_regs (insn, regstack, operands, operands_loc,\n-\t\t\t\tconstraints, n_inputs, n_outputs);\n-\t  return;\n+\t  return subst_asm_stack_regs (insn, regstack, operands,\n+\t\t\t\t       operands_loc, constraints,\n+\t\t\t\t       n_inputs, n_outputs);\n \t}\n \n       if (GET_CODE (PATTERN (insn)) == PARALLEL)\n@@ -2775,7 +2781,7 @@ subst_stack_regs (insn, regstack)\n      REG_UNUSED will already have been dealt with, so just return.  */\n \n   if (GET_CODE (insn) == NOTE)\n-    return;\n+    return insn;\n \n   /* If there is a REG_UNUSED note on a stack register on this insn,\n      the indicated reg must be popped.  The REG_UNUSED note is removed,\n@@ -2791,6 +2797,8 @@ subst_stack_regs (insn, regstack)\n       }\n     else\n       note_link = &XEXP (note, 1);\n+\n+  return insn;\n }\n \f\n /* Change the organization of the stack so that it fits a new basic\n@@ -3031,7 +3039,7 @@ static void\n convert_regs ()\n {\n   register int block, reg;\n-  register rtx insn, next;\n+  register rtx insn, next, new;\n   struct stack_def regstack;\n \n   for (block = 0; block < blocks; block++)\n@@ -3057,14 +3065,16 @@ convert_regs ()\n       do\n \t{\n \t  insn = next;\n+\t  new = insn;\n \t  next = NEXT_INSN (insn);\n \n \t  /* Don't bother processing unless there is a stack reg\n \t     mentioned or if it's a CALL_INSN (register passing of\n \t     floating point values).  */\n \n \t  if (GET_MODE (insn) == QImode || GET_CODE (insn) == CALL_INSN)\n-\t    subst_stack_regs (insn, &regstack);\n+\t    /* We may have generated some new instructions here. */\n+\t    new = subst_stack_regs (insn, &regstack);\n \n \t} while (insn != block_end[block]);\n \n@@ -3087,7 +3097,7 @@ convert_regs ()\n       /* Likewise handle the case where we fall into the next block.  */\n \n       if ((block < blocks - 1) && block_drops_in[block+1])\n-\tchange_stack (insn, &regstack, &block_stack_in[block+1],\n+\tchange_stack (new, &regstack, &block_stack_in[block+1],\n \t\t      emit_insn_after);\n     }\n "}]}