{"sha": "daa6e488c2f9611ac88611aac6f49e4090eb4902", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFhNmU0ODhjMmY5NjExYWM4ODYxMWFhYzZmNDllNDA5MGViNDkwMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-11-19T15:50:46Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-11-19T15:50:46Z"}, "message": "Convert gimple types from a union to C++ inheritance\n\nPatch partially autogenerated by refactor_gimple.py from\nhttps://github.com/davidmalcolm/gcc-refactoring-scripts\nrevision 05fc808c61bd8ddd2372f29b79ceb2491360d298\n\n\t* Makefile.in (GIMPLE_H): Add dep on is-a.h.\n\t* coretypes.h (union gimple_statement_d): Remove declaration.\n\t(gimple): Convert from being a \"union gimple_statement_d *\"\n\tto a \"struct gimple_statement_base *\".\n\t(const_gimple): Likewise (with \"const\").\n\t* ggc.h (ggc_alloc_cleared_gimple_statement_d_stat): Replace\n\twith...\n\t(ggc_alloc_cleared_gimple_statement_stat): ...this.\n\t* gimple-pretty-print.c (debug): Change parameter from a\n\t\"gimple_statement_d &\" to a \"gimple_statement_base &\".\n\t(debug): Change parameter from a \"gimple_statement_d *\" to\n\ta \"gimple_statement_base *\".\n\t* gimple-pretty-print.h (debug): Update declarations as above.\n\t* gimple.c (gimple_alloc_stat): Update for renaming of\n\tggc_alloc_cleared_gimple_statement_d_stat to\n\tggc_alloc_cleared_gimple_statement_stat.\n\t* gimple.h: Include \"is-a.h\" for use by is_a_helper\n\tspecializations in followup autogenerated patch.\n\t(struct gimple statement_base): Make this type usable as a base\n\tclass by adding \"desc\", \"tag\" and \"variable_size\" to GTY, thus\n\tusing opting-in to gengtype's support for simple inheritance.\n\t(gimple_statement_with_ops_base): Convert to a subclass of\n\tgimple_statement_base, dropping initial \"gsbase\" field.  Note\n\tthat this type is abstract, with no GSS_ value, and thus no GTY\n\ttag value.\n\t(gimple_statement_with_ops): Convert to a subclass of\n\tgimple_statement_with_ops_base, dropping initial \"opbase\" field.\n\tAdd tag value to GTY marking.  Update marking of op field to\n\treflect how num_ops field is accessed via inheritance.\n\t(gimple_statement_with_memory_ops_base): Convert to a subclass of\n\tgimple_statement_with_ops_base, dropping initial \"opbase\" field.\n\tAdd tag value to GTY marking.\n\t(gimple_statement_with_memory_ops): Convert to a subclass of\n\tpublic gimple_statement_with_memory_ops_base, dropping initial\n\t\"membase\" field.  Add tag value to GTY marking.  Update marking\n\tof op field to reflect how num_ops field is accessed via\n\tinheritance.\n\t(gimple_statement_call): Analogous changes that also update the\n\tmarking of the \"u\" union.\n\t(gimple_statement_omp): Convert to a subclass of\n\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n\ttag value to GTY marking.\n\t(gimple_statement_bind): Likewise.\n\t(gimple_statement_catch): Likewise.\n\t(gimple_statement_eh_filter): Likewise.\n\t(gimple_statement_eh_else): Likewise.\n\t(gimple_statement_eh_mnt): Likewise.\n\t(gimple_statement_phi): Likewise.\n\t(gimple_statement_eh_ctrl): Likewise.\n\t(gimple_statement_try): Likewise.\n\t(gimple_statement_wce): Likewise.\n\t(gimple_statement_asm): Convert to a subclass of\n\tgimple_statement_with_memory_ops_base, dropping initial\n\t\"membase\" field, adding tag value to GTY marking, and updating\n\tmarking of op field.\n\t(gimple_statement_omp_critical): Convert to a subclass of\n\tgimple_statement_omp, dropping initial \"omp\" field, adding tag\n\tvalue to GTY marking.\n\t(gimple_statement_omp_for): Likewise.\n\t(gimple_statement_omp_parallel): Likewise.\n\t(gimple_statement_omp_task): Convert to a subclass of\n\tgimple_statement_omp_parallel, dropping initial \"par\" field,\n\tadding tag value to GTY marking.\n\t(gimple_statement_omp_sections): Convert to a subclass of\n\tgimple_statement_omp, dropping initial \"omp\" field, adding\n\ttag value to GTY marking.\n\t(gimple_statement_omp_continue): Convert to a subclass of\n\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n\ttag value to GTY marking.\n\t(gimple_statement_omp_single): Convert to a subclass of\n\tgimple_statement_omp, dropping initial \"omp\" field, adding\n\ttag value to GTY marking.\n\t(gimple_statement_omp_atomic_load): Convert to a subclass of\n\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n\ttag value to GTY marking.\n\t(gimple_statement_omp_atomic_store): Convert to a subclass of\n\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n\ttag value to GTY marking.\n\t(gimple_statement_transaction): Convert to a subclass of\n\tgimple_statement_with_memory_ops_base, dropping initial \"gsbase\"\n\tfield, adding tag value to GTY marking.\n\t(union gimple_statement_d): Remove.\n\t* system.h (CONST_CAST_GIMPLE): Update to use\n\t\"struct gimple_statement_base *\" rather than\n\t\"union gimple_statement_d *\".\n\t* tree-ssa-ccp.c (gimple_htab): Convert underlying type from\n\tgimple_statement_d to gimple_statement_base.\n\n\t* gimple.h (gimple_use_ops): Port from union to usage of\n\tdyn_cast.\n\t(gimple_set_use_ops): Port from union to usage of as_a.\n\t(gimple_set_vuse): Likewise.\n\t(gimple_set_vdef): Likewise.\n\t(gimple_call_internal_fn): Port from union to a static_cast,\n\tgiven that the type has already been asserted.\n\t(gimple_omp_body_ptr): Port from unchecked union usage to\n\ta static_cast.\n\t(gimple_omp_set_body): Likewise.\n\n\t* gimple-iterator.c (update_bb_for_stmts): Update for conversion of\n\tgimple types to a true class hierarchy.\n\t(update_call_edge_frequencies): Likewise.\n\t(gsi_insert_seq_nodes_before): Likewise.\n\t(gsi_insert_seq_nodes_after): Likewise.\n\t(gsi_split_seq_after): Likewise.\n\t(gsi_set_stmt): Likewise.\n\t(gsi_split_seq_before): Likewise.\n\t(gsi_remove): Likewise.\n\t* gimple-iterator.h (gsi_one_before_end_p): Likewise.\n\t(gsi_next): Likewise.\n\t(gsi_prev): Likewise.\n\t* gimple-pretty-print.c (dump_gimple_debug): Likewise.\n\t* gimple-ssa.h (gimple_vuse_op): Likewise.\n\t(gimple_vdef_op): Likewise.\n\t* gimple-streamer-in.c (input_gimple_stmt): Likewise.\n\t* gimple-streamer-out.c (output_gimple_stmt): Likewise.\n\t* gimple.c (gimple_set_code): Likewise.\n\t(gimple_alloc_stat): Likewise.\n\t(gimple_set_subcode): Likewise.\n\t(gimple_build_call_internal_1): Likewise.\n\t(gimple_check_failed): Likewise.\n\t(gimple_call_flags): Likewise.\n\t(gimple_set_bb): Likewise.\n\t* gimple.h (is_a_helper <gimple_statement_asm> (gimple)): New.\n\t(is_a_helper <gimple_statement_bind> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_call> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_catch> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_eh_ctrl> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_eh_else> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_eh_filter> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_eh_mnt> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_atomic_load> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_atomic_store> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_continue> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_critical> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_for> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_parallel> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_sections> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_single> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_omp_task> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_phi> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_transaction> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_try> (gimple)): Likewise.\n\t(is_a_helper <gimple_statement_wce> (gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_asm> (const_gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_bind> (const_gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_call> (const_gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_catch> (const_gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_eh_ctrl> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_eh_filter> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_atomic_load> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_atomic_store>\n\t(const_gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_omp_continue> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_critical> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_for> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_parallel> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_sections> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_single> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_omp_task> (const_gimple)):\n\tLikewise.\n\t(is_a_helper <const gimple_statement_phi> (const_gimple)): Likewise.\n\t(is_a_helper <const gimple_statement_transaction> (const_gimple)):\n\tLikewise.\n\t(gimple_seq_last): Update for conversion of gimple types to a true\n\tclass hierarchy.\n\t(gimple_seq_set_last): Likewise.\n\t(gimple_code): Likewise.\n\t(gimple_bb): Likewise.\n\t(gimple_block): Likewise.\n\t(gimple_set_block): Likewise.\n\t(gimple_location): Likewise.\n\t(gimple_location_ptr): Likewise.\n\t(gimple_set_location): Likewise.\n\t(gimple_no_warning_p): Likewise.\n\t(gimple_set_no_warning): Likewise.\n\t(gimple_set_visited): Likewise.\n\t(gimple_visited_p): Likewise.\n\t(gimple_set_plf): Likewise.\n\t(gimple_plf): Likewise.\n\t(gimple_set_uid): Likewise.\n\t(gimple_uid): Likewise.\n\t(gimple_init_singleton): Likewise.\n\t(gimple_modified_p): Likewise.\n\t(gimple_set_modified): Likewise.\n\t(gimple_expr_code): Likewise.\n\t(gimple_has_volatile_ops): Likewise.\n\t(gimple_set_has_volatile_ops): Likewise.\n\t(gimple_omp_subcode): Likewise.\n\t(gimple_omp_set_subcode): Likewise.\n\t(gimple_omp_return_set_nowait): Likewise.\n\t(gimple_omp_section_set_last): Likewise.\n\t(gimple_omp_parallel_set_combined_p): Likewise.\n\t(gimple_omp_atomic_set_need_value): Likewise.\n\t(gimple_omp_atomic_set_seq_cst): Likewise.\n\t(gimple_num_ops): Likewise.\n\t(gimple_set_num_ops): Likewise.\n\t(gimple_assign_nontemporal_move_p): Likewise.\n\t(gimple_assign_set_nontemporal_move): Likewise.\n\t(gimple_assign_rhs_code): Likewise.\n\t(gimple_assign_set_rhs_code): Likewise.\n\t(gimple_call_internal_p): Likewise.\n\t(gimple_call_with_bounds_p): Likewise.\n\t(gimple_call_set_with_bounds): Likewise.\n\t(gimple_call_set_tail): Likewise.\n\t(gimple_call_tail_p): Likewise.\n\t(gimple_call_set_return_slot_opt): Likewise.\n\t(gimple_call_return_slot_opt_p): Likewise.\n\t(gimple_call_set_from_thunk): Likewise.\n\t(gimple_call_from_thunk_p): Likewise.\n\t(gimple_call_set_va_arg_pack): Likewise.\n\t(gimple_call_va_arg_pack_p): Likewise.\n\t(gimple_call_set_nothrow): Likewise.\n\t(gimple_call_set_alloca_for_var): Likewise.\n\t(gimple_call_alloca_for_var_p): Likewise.\n\t(gimple_call_copy_flags): Likewise.\n\t(gimple_cond_code): Likewise.\n\t(gimple_cond_set_code): Likewise.\n\t(gimple_cond_make_false): Likewise.\n\t(gimple_cond_make_true): Likewise.\n\t(gimple_asm_volatile_p): Likewise.\n\t(gimple_asm_set_volatile): Likewise.\n\t(gimple_asm_set_input): Likewise.\n\t(gimple_asm_input_p): Likewise.\n\t(gimple_try_kind): Likewise.\n\t(gimple_try_set_kind): Likewise.\n\t(gimple_try_catch_is_cleanup): Likewise.\n\t(gimple_try_set_catch_is_cleanup): Likewise.\n\t(gimple_wce_cleanup_eh_only): Likewise.\n\t(gimple_wce_set_cleanup_eh_only): Likewise.\n\t(gimple_debug_bind_p): Likewise.\n\t(gimple_debug_source_bind_p): Likewise.\n\t(gimple_omp_for_set_kind): Likewise.\n\t(gimple_omp_for_set_combined_p): Likewise.\n\t(gimple_omp_for_set_combined_into_p): Likewise.\n\t(gimple_omp_target_set_kind): Likewise.\n\t(gimple_transaction_subcode): Likewise.\n\t(gimple_transaction_set_subcode): Likewise.\n\t(gimple_predict_predictor): Likewise.\n\t(gimple_predict_set_predictor): Likewise.\n\t(gimple_predict_outcome): Likewise.\n\t(gimple_predict_set_outcome): Likewise.\n\t(gimple_transaction_set_label): Likewise.\n\t(gimple_transaction_set_body): Likewise.\n\t(gimple_transaction_label_ptr): Likewise.\n\t(gimple_transaction_label): Likewise.\n\t(gimple_transaction_body_ptr): Likewise.\n\t(gimple_omp_continue_set_control_use): Likewise.\n\t(gimple_omp_continue_control_use_ptr): Likewise.\n\t(gimple_omp_continue_control_use): Likewise.\n\t(gimple_omp_continue_set_control_def): Likewise.\n\t(gimple_omp_continue_control_def_ptr): Likewise.\n\t(gimple_omp_continue_control_def): Likewise.\n\t(gimple_omp_atomic_load_rhs_ptr): Likewise.\n\t(gimple_omp_atomic_load_rhs): Likewise.\n\t(gimple_omp_atomic_load_set_rhs): Likewise.\n\t(gimple_omp_atomic_load_lhs_ptr): Likewise.\n\t(gimple_omp_atomic_load_lhs): Likewise.\n\t(gimple_omp_atomic_load_set_lhs): Likewise.\n\t(gimple_omp_atomic_store_val_ptr): Likewise.\n\t(gimple_omp_atomic_store_val): Likewise.\n\t(gimple_omp_atomic_store_set_val): Likewise.\n\t(gimple_omp_for_cond): Likewise.\n\t(gimple_omp_for_set_cond): Likewise.\n\t(gimple_omp_sections_set_control): Likewise.\n\t(gimple_omp_sections_control_ptr): Likewise.\n\t(gimple_omp_sections_control): Likewise.\n\t(gimple_omp_sections_set_clauses): Likewise.\n\t(gimple_omp_sections_clauses_ptr): Likewise.\n\t(gimple_omp_sections_clauses): Likewise.\n\t(gimple_omp_teams_set_clauses): Likewise.\n\t(gimple_omp_teams_clauses_ptr): Likewise.\n\t(gimple_omp_teams_clauses): Likewise.\n\t(gimple_omp_target_set_data_arg): Likewise.\n\t(gimple_omp_target_data_arg_ptr): Likewise.\n\t(gimple_omp_target_data_arg): Likewise.\n\t(gimple_omp_target_set_child_fn): Likewise.\n\t(gimple_omp_target_child_fn_ptr): Likewise.\n\t(gimple_omp_target_child_fn): Likewise.\n\t(gimple_omp_target_set_clauses): Likewise.\n\t(gimple_omp_target_clauses_ptr): Likewise.\n\t(gimple_omp_target_clauses): Likewise.\n\t(gimple_omp_single_set_clauses): Likewise.\n\t(gimple_omp_single_clauses_ptr): Likewise.\n\t(gimple_omp_single_clauses): Likewise.\n\t(gimple_omp_task_set_arg_align): Likewise.\n\t(gimple_omp_task_arg_align_ptr): Likewise.\n\t(gimple_omp_task_arg_align): Likewise.\n\t(gimple_omp_task_set_arg_size): Likewise.\n\t(gimple_omp_task_arg_size_ptr): Likewise.\n\t(gimple_omp_task_arg_size): Likewise.\n\t(gimple_omp_task_set_copy_fn): Likewise.\n\t(gimple_omp_task_copy_fn_ptr): Likewise.\n\t(gimple_omp_task_copy_fn): Likewise.\n\t(gimple_omp_task_set_data_arg): Likewise.\n\t(gimple_omp_task_data_arg_ptr): Likewise.\n\t(gimple_omp_task_data_arg): Likewise.\n\t(gimple_omp_task_set_child_fn): Likewise.\n\t(gimple_omp_task_child_fn_ptr): Likewise.\n\t(gimple_omp_task_child_fn): Likewise.\n\t(gimple_omp_task_set_clauses): Likewise.\n\t(gimple_omp_task_clauses_ptr): Likewise.\n\t(gimple_omp_task_clauses): Likewise.\n\t(gimple_omp_parallel_set_data_arg): Likewise.\n\t(gimple_omp_parallel_data_arg_ptr): Likewise.\n\t(gimple_omp_parallel_data_arg): Likewise.\n\t(gimple_omp_parallel_set_child_fn): Likewise.\n\t(gimple_omp_parallel_child_fn_ptr): Likewise.\n\t(gimple_omp_parallel_child_fn): Likewise.\n\t(gimple_omp_parallel_set_clauses): Likewise.\n\t(gimple_omp_parallel_clauses_ptr): Likewise.\n\t(gimple_omp_parallel_clauses): Likewise.\n\t(gimple_omp_for_set_pre_body): Likewise.\n\t(gimple_omp_for_pre_body_ptr): Likewise.\n\t(gimple_omp_for_set_incr): Likewise.\n\t(gimple_omp_for_incr_ptr): Likewise.\n\t(gimple_omp_for_incr): Likewise.\n\t(gimple_omp_for_set_final): Likewise.\n\t(gimple_omp_for_final_ptr): Likewise.\n\t(gimple_omp_for_final): Likewise.\n\t(gimple_omp_for_set_initial): Likewise.\n\t(gimple_omp_for_initial_ptr): Likewise.\n\t(gimple_omp_for_initial): Likewise.\n\t(gimple_omp_for_set_index): Likewise.\n\t(gimple_omp_for_index_ptr): Likewise.\n\t(gimple_omp_for_index): Likewise.\n\t(gimple_omp_for_collapse): Likewise.\n\t(gimple_omp_for_set_clauses): Likewise.\n\t(gimple_omp_for_clauses_ptr): Likewise.\n\t(gimple_omp_for_clauses): Likewise.\n\t(gimple_omp_critical_set_name): Likewise.\n\t(gimple_omp_critical_name_ptr): Likewise.\n\t(gimple_omp_critical_name): Likewise.\n\t(gimple_eh_dispatch_set_region): Likewise.\n\t(gimple_eh_dispatch_region): Likewise.\n\t(gimple_resx_set_region): Likewise.\n\t(gimple_resx_region): Likewise.\n\t(gimple_phi_set_arg): Likewise.\n\t(gimple_phi_arg): Likewise.\n\t(gimple_phi_set_result): Likewise.\n\t(gimple_phi_result_ptr): Likewise.\n\t(gimple_phi_result): Likewise.\n\t(gimple_phi_num_args): Likewise.\n\t(gimple_phi_capacity): Likewise.\n\t(gimple_wce_set_cleanup): Likewise.\n\t(gimple_wce_cleanup_ptr): Likewise.\n\t(gimple_try_set_cleanup): Likewise.\n\t(gimple_try_set_eval): Likewise.\n\t(gimple_try_cleanup_ptr): Likewise.\n\t(gimple_try_eval_ptr): Likewise.\n\t(gimple_eh_else_set_e_body): Likewise.\n\t(gimple_eh_else_set_n_body): Likewise.\n\t(gimple_eh_else_e_body_ptr): Likewise.\n\t(gimple_eh_else_n_body_ptr): Likewise.\n\t(gimple_eh_must_not_throw_set_fndecl): Likewise.\n\t(gimple_eh_must_not_throw_fndecl): Likewise.\n\t(gimple_eh_filter_set_failure): Likewise.\n\t(gimple_eh_filter_set_types): Likewise.\n\t(gimple_eh_filter_failure_ptr): Likewise.\n\t(gimple_eh_filter_types_ptr): Likewise.\n\t(gimple_eh_filter_types): Likewise.\n\t(gimple_catch_set_handler): Likewise.\n\t(gimple_catch_set_types): Likewise.\n\t(gimple_catch_handler_ptr): Likewise.\n\t(gimple_catch_types_ptr): Likewise.\n\t(gimple_catch_types): Likewise.\n\t(gimple_asm_string): Likewise.\n\t(gimple_asm_set_label_op): Likewise.\n\t(gimple_asm_label_op): Likewise.\n\t(gimple_asm_set_clobber_op): Likewise.\n\t(gimple_asm_clobber_op): Likewise.\n\t(gimple_asm_set_output_op): Likewise.\n\t(gimple_asm_output_op_ptr): Likewise.\n\t(gimple_asm_output_op): Likewise.\n\t(gimple_asm_set_input_op): Likewise.\n\t(gimple_asm_input_op_ptr): Likewise.\n\t(gimple_asm_input_op): Likewise.\n\t(gimple_asm_nlabels): Likewise.\n\t(gimple_asm_nclobbers): Likewise.\n\t(gimple_asm_noutputs): Likewise.\n\t(gimple_asm_ninputs): Likewise.\n\t(gimple_bind_set_block): Likewise.\n\t(gimple_bind_block): Likewise.\n\t(gimple_bind_add_seq): Likewise.\n\t(gimple_bind_add_stmt): Likewise.\n\t(gimple_bind_set_body): Likewise.\n\t(gimple_bind_body_ptr): Likewise.\n\t(gimple_bind_append_vars): Likewise.\n\t(gimple_bind_set_vars): Likewise.\n\t(gimple_bind_vars): Likewise.\n\t(gimple_call_clobber_set): Likewise.\n\t(gimple_call_use_set): Likewise.\n\t(gimple_call_set_internal_fn): Likewise.\n\t(gimple_call_set_fntype): Likewise.\n\t(gimple_call_fntype): Likewise.\n\t(gimple_omp_return_lhs_ptr): Likewise.\n\t(gimple_omp_return_lhs): Likewise.\n\t(gimple_omp_return_set_lhs): Likewise.\n\t(gimple_omp_taskreg_set_data_arg): Likewise.\n\t(gimple_omp_taskreg_data_arg_ptr): Likewise.\n\t(gimple_omp_taskreg_data_arg): Likewise.\n\t(gimple_omp_taskreg_set_child_fn): Likewise.\n\t(gimple_omp_taskreg_child_fn_ptr): Likewise.\n\t(gimple_omp_taskreg_child_fn): Likewise.\n\t(gimple_omp_taskreg_set_clauses): Likewise.\n\t(gimple_omp_taskreg_clauses_ptr): Likewise.\n\t(gimple_omp_taskreg_clauses): Likewise.\n\t(gimple_vuse): Likewise.\n\t(gimple_vdef): Likewise.\n\t(gimple_vuse_ptr): Likewise.\n\t(gimple_vdef_ptr): Likewise.\n\t* tree-inline.c (copy_debug_stmt): Likewise.\n\t* tree-phinodes.c (make_phi_node): Likewise.\n\n\t* gimple.h (is_a_helper <const gimple_statement_with_ops>::test): New.\n\t(is_a_helper <gimple_statement_with_ops>::test): New.\n\t(is_a_helper <const gimple_statement_with_memory_ops>::test): New.\n\t(is_a_helper <gimple_statement_with_memory_ops>::test): New.\n\n\t* gimple-streamer-in.c (input_gimple_stmt): Port from union\n\taccess to use of as_a.\n\t* gimple.c (gimple_build_asm_1): Likewise.\n\t(gimple_build_try): Likewise.  Also, return a specific subclass\n\trather than just gimple.\n\t(gimple_build_resx): Port from union access to use of as_a.\n\t(gimple_build_eh_dispatch): Likewise.\n\t(gimple_build_omp_for): Likewise.  Also, convert allocation of iter\n\tnow that gengtype no longer provides a typed allocator function.\n\t(gimple_copy): Likewise.\n\t* gimple.h (gimple_build_try): Return a specific subclass rather\n\tthan just gimple.\n\t* gimplify.c (gimplify_cleanup_point_expr): Replace union access\n\twith subclass access by making use of new return type of\n\tgimple_build_try.\n\t* tree-phinodes.c: (allocate_phi_node): Return a\n\t\"gimple_statement_phi *\" rather than just a gimple.\n\t(resize_phi_node): Likewise.\n\t(make_phi_node): Replace union access with subclass access by\n\tmaking use of new return type of allocate_phi_node.\n\t(reserve_phi_args_for_new_edge): Replace union access with as_a.\n\t(remove_phi_arg_num): Accept a \"gimple_statement_phi *\" rather\n\tthan just a gimple.\n\t(remove_phi_args): Update for change to remove_phi_arg_num.\n\n\t* gdbhooks.py (GimplePrinter.to_string): Update lookup of\n\tcode field to reflect inheritance, rather than embedding of\n\tthe base gimple type.\n\nFrom-SVN: r205034", "tree": {"sha": "925852cc0a168d316a3da569b148e3c143e97b54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/925852cc0a168d316a3da569b148e3c143e97b54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daa6e488c2f9611ac88611aac6f49e4090eb4902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa6e488c2f9611ac88611aac6f49e4090eb4902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daa6e488c2f9611ac88611aac6f49e4090eb4902", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daa6e488c2f9611ac88611aac6f49e4090eb4902/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "660dca797a8202336a5510ee27a971dda8832ba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660dca797a8202336a5510ee27a971dda8832ba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/660dca797a8202336a5510ee27a971dda8832ba6"}], "stats": {"total": 2376, "additions": 1660, "deletions": 716}, "files": [{"sha": "98bd87e6e2d51625592e8105e7a0fa091efa84d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -1,3 +1,463 @@\n+2013-11-19  David Malcolm  <dmalcolm@redhat.com>\n+\n+\tConvert gimple types from a union to C++ inheritance.\n+\t* Makefile.in (GIMPLE_H): Add dep on is-a.h.\n+\t* coretypes.h (union gimple_statement_d): Remove declaration.\n+\t(gimple): Convert from being a \"union gimple_statement_d *\"\n+\tto a \"struct gimple_statement_base *\".\n+\t(const_gimple): Likewise (with \"const\").\n+\t* ggc.h (ggc_alloc_cleared_gimple_statement_d_stat): Replace\n+\twith...\n+\t(ggc_alloc_cleared_gimple_statement_stat): ...this.\n+\t* gimple-pretty-print.c (debug): Change parameter from a\n+\t\"gimple_statement_d &\" to a \"gimple_statement_base &\".\n+\t(debug): Change parameter from a \"gimple_statement_d *\" to\n+\ta \"gimple_statement_base *\".\n+\t* gimple-pretty-print.h (debug): Update declarations as above.\n+\t* gimple.c (gimple_alloc_stat): Update for renaming of\n+\tggc_alloc_cleared_gimple_statement_d_stat to\n+\tggc_alloc_cleared_gimple_statement_stat.\n+\t* gimple.h: Include \"is-a.h\" for use by is_a_helper\n+\tspecializations in followup autogenerated patch.\n+\t(struct gimple statement_base): Make this type usable as a base\n+\tclass by adding \"desc\", \"tag\" and \"variable_size\" to GTY, thus\n+\tusing opting-in to gengtype's support for simple inheritance.\n+\t(gimple_statement_with_ops_base): Convert to a subclass of\n+\tgimple_statement_base, dropping initial \"gsbase\" field.  Note\n+\tthat this type is abstract, with no GSS_ value, and thus no GTY\n+\ttag value.\n+\t(gimple_statement_with_ops): Convert to a subclass of\n+\tgimple_statement_with_ops_base, dropping initial \"opbase\" field.\n+\tAdd tag value to GTY marking.  Update marking of op field to\n+\treflect how num_ops field is accessed via inheritance.\n+\t(gimple_statement_with_memory_ops_base): Convert to a subclass of\n+\tgimple_statement_with_ops_base, dropping initial \"opbase\" field.\n+\tAdd tag value to GTY marking.\n+\t(gimple_statement_with_memory_ops): Convert to a subclass of\n+\tpublic gimple_statement_with_memory_ops_base, dropping initial\n+\t\"membase\" field.  Add tag value to GTY marking.  Update marking\n+\tof op field to reflect how num_ops field is accessed via\n+\tinheritance.\n+\t(gimple_statement_call): Analogous changes that also update the\n+\tmarking of the \"u\" union.\n+\t(gimple_statement_omp): Convert to a subclass of\n+\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n+\ttag value to GTY marking.\n+\t(gimple_statement_bind): Likewise.\n+\t(gimple_statement_catch): Likewise.\n+\t(gimple_statement_eh_filter): Likewise.\n+\t(gimple_statement_eh_else): Likewise.\n+\t(gimple_statement_eh_mnt): Likewise.\n+\t(gimple_statement_phi): Likewise.\n+\t(gimple_statement_eh_ctrl): Likewise.\n+\t(gimple_statement_try): Likewise.\n+\t(gimple_statement_wce): Likewise.\n+\t(gimple_statement_asm): Convert to a subclass of\n+\tgimple_statement_with_memory_ops_base, dropping initial\n+\t\"membase\" field, adding tag value to GTY marking, and updating\n+\tmarking of op field.\n+\t(gimple_statement_omp_critical): Convert to a subclass of\n+\tgimple_statement_omp, dropping initial \"omp\" field, adding tag\n+\tvalue to GTY marking.\n+\t(gimple_statement_omp_for): Likewise.\n+\t(gimple_statement_omp_parallel): Likewise.\n+\t(gimple_statement_omp_task): Convert to a subclass of\n+\tgimple_statement_omp_parallel, dropping initial \"par\" field,\n+\tadding tag value to GTY marking.\n+\t(gimple_statement_omp_sections): Convert to a subclass of\n+\tgimple_statement_omp, dropping initial \"omp\" field, adding\n+\ttag value to GTY marking.\n+\t(gimple_statement_omp_continue): Convert to a subclass of\n+\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n+\ttag value to GTY marking.\n+\t(gimple_statement_omp_single): Convert to a subclass of\n+\tgimple_statement_omp, dropping initial \"omp\" field, adding\n+\ttag value to GTY marking.\n+\t(gimple_statement_omp_atomic_load): Convert to a subclass of\n+\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n+\ttag value to GTY marking.\n+\t(gimple_statement_omp_atomic_store): Convert to a subclass of\n+\tgimple_statement_base, dropping initial \"gsbase\" field, adding\n+\ttag value to GTY marking.\n+\t(gimple_statement_transaction): Convert to a subclass of\n+\tgimple_statement_with_memory_ops_base, dropping initial \"gsbase\"\n+\tfield, adding tag value to GTY marking.\n+\t(union gimple_statement_d): Remove.\n+\t* system.h (CONST_CAST_GIMPLE): Update to use\n+\t\"struct gimple_statement_base *\" rather than\n+\t\"union gimple_statement_d *\".\n+\t* tree-ssa-ccp.c (gimple_htab): Convert underlying type from\n+\tgimple_statement_d to gimple_statement_base.\n+\n+\t* gimple.h (gimple_use_ops): Port from union to usage of\n+\tdyn_cast.\n+\t(gimple_set_use_ops): Port from union to usage of as_a.\n+\t(gimple_set_vuse): Likewise.\n+\t(gimple_set_vdef): Likewise.\n+\t(gimple_call_internal_fn): Port from union to a static_cast,\n+\tgiven that the type has already been asserted.\n+\t(gimple_omp_body_ptr): Port from unchecked union usage to\n+\ta static_cast.\n+\t(gimple_omp_set_body): Likewise.\n+\n+\t* gimple-iterator.c (update_bb_for_stmts): Update for conversion of\n+\tgimple types to a true class hierarchy.\n+\t(update_call_edge_frequencies): Likewise.\n+\t(gsi_insert_seq_nodes_before): Likewise.\n+\t(gsi_insert_seq_nodes_after): Likewise.\n+\t(gsi_split_seq_after): Likewise.\n+\t(gsi_set_stmt): Likewise.\n+\t(gsi_split_seq_before): Likewise.\n+\t(gsi_remove): Likewise.\n+\t* gimple-iterator.h (gsi_one_before_end_p): Likewise.\n+\t(gsi_next): Likewise.\n+\t(gsi_prev): Likewise.\n+\t* gimple-pretty-print.c (dump_gimple_debug): Likewise.\n+\t* gimple-ssa.h (gimple_vuse_op): Likewise.\n+\t(gimple_vdef_op): Likewise.\n+\t* gimple-streamer-in.c (input_gimple_stmt): Likewise.\n+\t* gimple-streamer-out.c (output_gimple_stmt): Likewise.\n+\t* gimple.c (gimple_set_code): Likewise.\n+\t(gimple_alloc_stat): Likewise.\n+\t(gimple_set_subcode): Likewise.\n+\t(gimple_build_call_internal_1): Likewise.\n+\t(gimple_check_failed): Likewise.\n+\t(gimple_call_flags): Likewise.\n+\t(gimple_set_bb): Likewise.\n+\t* gimple.h (is_a_helper <gimple_statement_asm> (gimple)): New.\n+\t(is_a_helper <gimple_statement_bind> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_call> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_catch> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_eh_ctrl> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_eh_else> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_eh_filter> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_eh_mnt> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_atomic_load> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_atomic_store> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_continue> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_critical> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_for> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_parallel> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_sections> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_single> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_omp_task> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_phi> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_transaction> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_try> (gimple)): Likewise.\n+\t(is_a_helper <gimple_statement_wce> (gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_asm> (const_gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_bind> (const_gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_call> (const_gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_catch> (const_gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_eh_ctrl> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_eh_filter> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_atomic_load> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_atomic_store>\n+\t(const_gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_omp_continue> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_critical> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_for> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_parallel> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_sections> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_single> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_omp_task> (const_gimple)):\n+\tLikewise.\n+\t(is_a_helper <const gimple_statement_phi> (const_gimple)): Likewise.\n+\t(is_a_helper <const gimple_statement_transaction> (const_gimple)):\n+\tLikewise.\n+\t(gimple_seq_last): Update for conversion of gimple types to a true\n+\tclass hierarchy.\n+\t(gimple_seq_set_last): Likewise.\n+\t(gimple_code): Likewise.\n+\t(gimple_bb): Likewise.\n+\t(gimple_block): Likewise.\n+\t(gimple_set_block): Likewise.\n+\t(gimple_location): Likewise.\n+\t(gimple_location_ptr): Likewise.\n+\t(gimple_set_location): Likewise.\n+\t(gimple_no_warning_p): Likewise.\n+\t(gimple_set_no_warning): Likewise.\n+\t(gimple_set_visited): Likewise.\n+\t(gimple_visited_p): Likewise.\n+\t(gimple_set_plf): Likewise.\n+\t(gimple_plf): Likewise.\n+\t(gimple_set_uid): Likewise.\n+\t(gimple_uid): Likewise.\n+\t(gimple_init_singleton): Likewise.\n+\t(gimple_modified_p): Likewise.\n+\t(gimple_set_modified): Likewise.\n+\t(gimple_expr_code): Likewise.\n+\t(gimple_has_volatile_ops): Likewise.\n+\t(gimple_set_has_volatile_ops): Likewise.\n+\t(gimple_omp_subcode): Likewise.\n+\t(gimple_omp_set_subcode): Likewise.\n+\t(gimple_omp_return_set_nowait): Likewise.\n+\t(gimple_omp_section_set_last): Likewise.\n+\t(gimple_omp_parallel_set_combined_p): Likewise.\n+\t(gimple_omp_atomic_set_need_value): Likewise.\n+\t(gimple_omp_atomic_set_seq_cst): Likewise.\n+\t(gimple_num_ops): Likewise.\n+\t(gimple_set_num_ops): Likewise.\n+\t(gimple_assign_nontemporal_move_p): Likewise.\n+\t(gimple_assign_set_nontemporal_move): Likewise.\n+\t(gimple_assign_rhs_code): Likewise.\n+\t(gimple_assign_set_rhs_code): Likewise.\n+\t(gimple_call_internal_p): Likewise.\n+\t(gimple_call_with_bounds_p): Likewise.\n+\t(gimple_call_set_with_bounds): Likewise.\n+\t(gimple_call_set_tail): Likewise.\n+\t(gimple_call_tail_p): Likewise.\n+\t(gimple_call_set_return_slot_opt): Likewise.\n+\t(gimple_call_return_slot_opt_p): Likewise.\n+\t(gimple_call_set_from_thunk): Likewise.\n+\t(gimple_call_from_thunk_p): Likewise.\n+\t(gimple_call_set_va_arg_pack): Likewise.\n+\t(gimple_call_va_arg_pack_p): Likewise.\n+\t(gimple_call_set_nothrow): Likewise.\n+\t(gimple_call_set_alloca_for_var): Likewise.\n+\t(gimple_call_alloca_for_var_p): Likewise.\n+\t(gimple_call_copy_flags): Likewise.\n+\t(gimple_cond_code): Likewise.\n+\t(gimple_cond_set_code): Likewise.\n+\t(gimple_cond_make_false): Likewise.\n+\t(gimple_cond_make_true): Likewise.\n+\t(gimple_asm_volatile_p): Likewise.\n+\t(gimple_asm_set_volatile): Likewise.\n+\t(gimple_asm_set_input): Likewise.\n+\t(gimple_asm_input_p): Likewise.\n+\t(gimple_try_kind): Likewise.\n+\t(gimple_try_set_kind): Likewise.\n+\t(gimple_try_catch_is_cleanup): Likewise.\n+\t(gimple_try_set_catch_is_cleanup): Likewise.\n+\t(gimple_wce_cleanup_eh_only): Likewise.\n+\t(gimple_wce_set_cleanup_eh_only): Likewise.\n+\t(gimple_debug_bind_p): Likewise.\n+\t(gimple_debug_source_bind_p): Likewise.\n+\t(gimple_omp_for_set_kind): Likewise.\n+\t(gimple_omp_for_set_combined_p): Likewise.\n+\t(gimple_omp_for_set_combined_into_p): Likewise.\n+\t(gimple_omp_target_set_kind): Likewise.\n+\t(gimple_transaction_subcode): Likewise.\n+\t(gimple_transaction_set_subcode): Likewise.\n+\t(gimple_predict_predictor): Likewise.\n+\t(gimple_predict_set_predictor): Likewise.\n+\t(gimple_predict_outcome): Likewise.\n+\t(gimple_predict_set_outcome): Likewise.\n+\t(gimple_transaction_set_label): Likewise.\n+\t(gimple_transaction_set_body): Likewise.\n+\t(gimple_transaction_label_ptr): Likewise.\n+\t(gimple_transaction_label): Likewise.\n+\t(gimple_transaction_body_ptr): Likewise.\n+\t(gimple_omp_continue_set_control_use): Likewise.\n+\t(gimple_omp_continue_control_use_ptr): Likewise.\n+\t(gimple_omp_continue_control_use): Likewise.\n+\t(gimple_omp_continue_set_control_def): Likewise.\n+\t(gimple_omp_continue_control_def_ptr): Likewise.\n+\t(gimple_omp_continue_control_def): Likewise.\n+\t(gimple_omp_atomic_load_rhs_ptr): Likewise.\n+\t(gimple_omp_atomic_load_rhs): Likewise.\n+\t(gimple_omp_atomic_load_set_rhs): Likewise.\n+\t(gimple_omp_atomic_load_lhs_ptr): Likewise.\n+\t(gimple_omp_atomic_load_lhs): Likewise.\n+\t(gimple_omp_atomic_load_set_lhs): Likewise.\n+\t(gimple_omp_atomic_store_val_ptr): Likewise.\n+\t(gimple_omp_atomic_store_val): Likewise.\n+\t(gimple_omp_atomic_store_set_val): Likewise.\n+\t(gimple_omp_for_cond): Likewise.\n+\t(gimple_omp_for_set_cond): Likewise.\n+\t(gimple_omp_sections_set_control): Likewise.\n+\t(gimple_omp_sections_control_ptr): Likewise.\n+\t(gimple_omp_sections_control): Likewise.\n+\t(gimple_omp_sections_set_clauses): Likewise.\n+\t(gimple_omp_sections_clauses_ptr): Likewise.\n+\t(gimple_omp_sections_clauses): Likewise.\n+\t(gimple_omp_teams_set_clauses): Likewise.\n+\t(gimple_omp_teams_clauses_ptr): Likewise.\n+\t(gimple_omp_teams_clauses): Likewise.\n+\t(gimple_omp_target_set_data_arg): Likewise.\n+\t(gimple_omp_target_data_arg_ptr): Likewise.\n+\t(gimple_omp_target_data_arg): Likewise.\n+\t(gimple_omp_target_set_child_fn): Likewise.\n+\t(gimple_omp_target_child_fn_ptr): Likewise.\n+\t(gimple_omp_target_child_fn): Likewise.\n+\t(gimple_omp_target_set_clauses): Likewise.\n+\t(gimple_omp_target_clauses_ptr): Likewise.\n+\t(gimple_omp_target_clauses): Likewise.\n+\t(gimple_omp_single_set_clauses): Likewise.\n+\t(gimple_omp_single_clauses_ptr): Likewise.\n+\t(gimple_omp_single_clauses): Likewise.\n+\t(gimple_omp_task_set_arg_align): Likewise.\n+\t(gimple_omp_task_arg_align_ptr): Likewise.\n+\t(gimple_omp_task_arg_align): Likewise.\n+\t(gimple_omp_task_set_arg_size): Likewise.\n+\t(gimple_omp_task_arg_size_ptr): Likewise.\n+\t(gimple_omp_task_arg_size): Likewise.\n+\t(gimple_omp_task_set_copy_fn): Likewise.\n+\t(gimple_omp_task_copy_fn_ptr): Likewise.\n+\t(gimple_omp_task_copy_fn): Likewise.\n+\t(gimple_omp_task_set_data_arg): Likewise.\n+\t(gimple_omp_task_data_arg_ptr): Likewise.\n+\t(gimple_omp_task_data_arg): Likewise.\n+\t(gimple_omp_task_set_child_fn): Likewise.\n+\t(gimple_omp_task_child_fn_ptr): Likewise.\n+\t(gimple_omp_task_child_fn): Likewise.\n+\t(gimple_omp_task_set_clauses): Likewise.\n+\t(gimple_omp_task_clauses_ptr): Likewise.\n+\t(gimple_omp_task_clauses): Likewise.\n+\t(gimple_omp_parallel_set_data_arg): Likewise.\n+\t(gimple_omp_parallel_data_arg_ptr): Likewise.\n+\t(gimple_omp_parallel_data_arg): Likewise.\n+\t(gimple_omp_parallel_set_child_fn): Likewise.\n+\t(gimple_omp_parallel_child_fn_ptr): Likewise.\n+\t(gimple_omp_parallel_child_fn): Likewise.\n+\t(gimple_omp_parallel_set_clauses): Likewise.\n+\t(gimple_omp_parallel_clauses_ptr): Likewise.\n+\t(gimple_omp_parallel_clauses): Likewise.\n+\t(gimple_omp_for_set_pre_body): Likewise.\n+\t(gimple_omp_for_pre_body_ptr): Likewise.\n+\t(gimple_omp_for_set_incr): Likewise.\n+\t(gimple_omp_for_incr_ptr): Likewise.\n+\t(gimple_omp_for_incr): Likewise.\n+\t(gimple_omp_for_set_final): Likewise.\n+\t(gimple_omp_for_final_ptr): Likewise.\n+\t(gimple_omp_for_final): Likewise.\n+\t(gimple_omp_for_set_initial): Likewise.\n+\t(gimple_omp_for_initial_ptr): Likewise.\n+\t(gimple_omp_for_initial): Likewise.\n+\t(gimple_omp_for_set_index): Likewise.\n+\t(gimple_omp_for_index_ptr): Likewise.\n+\t(gimple_omp_for_index): Likewise.\n+\t(gimple_omp_for_collapse): Likewise.\n+\t(gimple_omp_for_set_clauses): Likewise.\n+\t(gimple_omp_for_clauses_ptr): Likewise.\n+\t(gimple_omp_for_clauses): Likewise.\n+\t(gimple_omp_critical_set_name): Likewise.\n+\t(gimple_omp_critical_name_ptr): Likewise.\n+\t(gimple_omp_critical_name): Likewise.\n+\t(gimple_eh_dispatch_set_region): Likewise.\n+\t(gimple_eh_dispatch_region): Likewise.\n+\t(gimple_resx_set_region): Likewise.\n+\t(gimple_resx_region): Likewise.\n+\t(gimple_phi_set_arg): Likewise.\n+\t(gimple_phi_arg): Likewise.\n+\t(gimple_phi_set_result): Likewise.\n+\t(gimple_phi_result_ptr): Likewise.\n+\t(gimple_phi_result): Likewise.\n+\t(gimple_phi_num_args): Likewise.\n+\t(gimple_phi_capacity): Likewise.\n+\t(gimple_wce_set_cleanup): Likewise.\n+\t(gimple_wce_cleanup_ptr): Likewise.\n+\t(gimple_try_set_cleanup): Likewise.\n+\t(gimple_try_set_eval): Likewise.\n+\t(gimple_try_cleanup_ptr): Likewise.\n+\t(gimple_try_eval_ptr): Likewise.\n+\t(gimple_eh_else_set_e_body): Likewise.\n+\t(gimple_eh_else_set_n_body): Likewise.\n+\t(gimple_eh_else_e_body_ptr): Likewise.\n+\t(gimple_eh_else_n_body_ptr): Likewise.\n+\t(gimple_eh_must_not_throw_set_fndecl): Likewise.\n+\t(gimple_eh_must_not_throw_fndecl): Likewise.\n+\t(gimple_eh_filter_set_failure): Likewise.\n+\t(gimple_eh_filter_set_types): Likewise.\n+\t(gimple_eh_filter_failure_ptr): Likewise.\n+\t(gimple_eh_filter_types_ptr): Likewise.\n+\t(gimple_eh_filter_types): Likewise.\n+\t(gimple_catch_set_handler): Likewise.\n+\t(gimple_catch_set_types): Likewise.\n+\t(gimple_catch_handler_ptr): Likewise.\n+\t(gimple_catch_types_ptr): Likewise.\n+\t(gimple_catch_types): Likewise.\n+\t(gimple_asm_string): Likewise.\n+\t(gimple_asm_set_label_op): Likewise.\n+\t(gimple_asm_label_op): Likewise.\n+\t(gimple_asm_set_clobber_op): Likewise.\n+\t(gimple_asm_clobber_op): Likewise.\n+\t(gimple_asm_set_output_op): Likewise.\n+\t(gimple_asm_output_op_ptr): Likewise.\n+\t(gimple_asm_output_op): Likewise.\n+\t(gimple_asm_set_input_op): Likewise.\n+\t(gimple_asm_input_op_ptr): Likewise.\n+\t(gimple_asm_input_op): Likewise.\n+\t(gimple_asm_nlabels): Likewise.\n+\t(gimple_asm_nclobbers): Likewise.\n+\t(gimple_asm_noutputs): Likewise.\n+\t(gimple_asm_ninputs): Likewise.\n+\t(gimple_bind_set_block): Likewise.\n+\t(gimple_bind_block): Likewise.\n+\t(gimple_bind_add_seq): Likewise.\n+\t(gimple_bind_add_stmt): Likewise.\n+\t(gimple_bind_set_body): Likewise.\n+\t(gimple_bind_body_ptr): Likewise.\n+\t(gimple_bind_append_vars): Likewise.\n+\t(gimple_bind_set_vars): Likewise.\n+\t(gimple_bind_vars): Likewise.\n+\t(gimple_call_clobber_set): Likewise.\n+\t(gimple_call_use_set): Likewise.\n+\t(gimple_call_set_internal_fn): Likewise.\n+\t(gimple_call_set_fntype): Likewise.\n+\t(gimple_call_fntype): Likewise.\n+\t(gimple_omp_return_lhs_ptr): Likewise.\n+\t(gimple_omp_return_lhs): Likewise.\n+\t(gimple_omp_return_set_lhs): Likewise.\n+\t(gimple_omp_taskreg_set_data_arg): Likewise.\n+\t(gimple_omp_taskreg_data_arg_ptr): Likewise.\n+\t(gimple_omp_taskreg_data_arg): Likewise.\n+\t(gimple_omp_taskreg_set_child_fn): Likewise.\n+\t(gimple_omp_taskreg_child_fn_ptr): Likewise.\n+\t(gimple_omp_taskreg_child_fn): Likewise.\n+\t(gimple_omp_taskreg_set_clauses): Likewise.\n+\t(gimple_omp_taskreg_clauses_ptr): Likewise.\n+\t(gimple_omp_taskreg_clauses): Likewise.\n+\t(gimple_vuse): Likewise.\n+\t(gimple_vdef): Likewise.\n+\t(gimple_vuse_ptr): Likewise.\n+\t(gimple_vdef_ptr): Likewise.\n+\t* tree-inline.c (copy_debug_stmt): Likewise.\n+\t* tree-phinodes.c (make_phi_node): Likewise.\n+\n+\t* gimple.h (is_a_helper <const gimple_statement_with_ops>::test): New.\n+\t(is_a_helper <gimple_statement_with_ops>::test): New.\n+\t(is_a_helper <const gimple_statement_with_memory_ops>::test): New.\n+\t(is_a_helper <gimple_statement_with_memory_ops>::test): New.\n+\n+\t* gimple-streamer-in.c (input_gimple_stmt): Port from union\n+\taccess to use of as_a.\n+\t* gimple.c (gimple_build_asm_1): Likewise.\n+\t(gimple_build_try): Likewise.  Also, return a specific subclass\n+\trather than just gimple.\n+\t(gimple_build_resx): Port from union access to use of as_a.\n+\t(gimple_build_eh_dispatch): Likewise.\n+\t(gimple_build_omp_for): Likewise.  Also, convert allocation of iter\n+\tnow that gengtype no longer provides a typed allocator function.\n+\t(gimple_copy): Likewise.\n+\t* gimple.h (gimple_build_try): Return a specific subclass rather\n+\tthan just gimple.\n+\t* gimplify.c (gimplify_cleanup_point_expr): Replace union access\n+\twith subclass access by making use of new return type of\n+\tgimple_build_try.\n+\t* tree-phinodes.c: (allocate_phi_node): Return a\n+\t\"gimple_statement_phi *\" rather than just a gimple.\n+\t(resize_phi_node): Likewise.\n+\t(make_phi_node): Replace union access with subclass access by\n+\tmaking use of new return type of allocate_phi_node.\n+\t(reserve_phi_args_for_new_edge): Replace union access with as_a.\n+\t(remove_phi_arg_num): Accept a \"gimple_statement_phi *\" rather\n+\tthan just a gimple.\n+\t(remove_phi_args): Update for change to remove_phi_arg_num.\n+\n+\t* gdbhooks.py (GimplePrinter.to_string): Update lookup of\n+\tcode field to reflect inheritance, rather than embedding of\n+\tthe base gimple type.\n+\n 2013-11-19  Richard Biener  <rguenther@suse.de>\n \n \t* cfgloop.h (struct loop_iterator): C++-ify, add constructor"}, {"sha": "34e07a0d0755fa6ac1e5f9078c3ca37e278f92d5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -888,7 +888,7 @@ BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) \\\n \tcfg-flags.def cfghooks.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n \t$(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n-\ttree-ssa-alias.h $(INTERNAL_FN_H) $(HASH_TABLE_H)\n+\ttree-ssa-alias.h $(INTERNAL_FN_H) $(HASH_TABLE_H) is-a.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n RECOG_H = recog.h\n EMIT_RTL_H = emit-rtl.h"}, {"sha": "5d60240c4f155d4b8199d5867e7b15a2847bf8d3", "filename": "gcc/coretypes.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -61,9 +61,8 @@ typedef const struct rtvec_def *const_rtvec;\n union tree_node;\n typedef union tree_node *tree;\n typedef const union tree_node *const_tree;\n-union gimple_statement_d;\n-typedef union gimple_statement_d *gimple;\n-typedef const union gimple_statement_d *const_gimple;\n+typedef struct gimple_statement_base *gimple;\n+typedef const struct gimple_statement_base *const_gimple;\n typedef gimple gimple_seq;\n struct gimple_stmt_iterator_d;\n typedef struct gimple_stmt_iterator_d gimple_stmt_iterator;"}, {"sha": "8ddaf3d856ed65d14541f893b3e5b7c30dcf14df", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -240,7 +240,7 @@ def __init__(self, gdbval):\n     def to_string (self):\n         if long(self.gdbval) == 0:\n             return '<gimple 0x0>'\n-        val_gimple_code = self.gdbval['gsbase']['code']\n+        val_gimple_code = self.gdbval['code']\n         val_gimple_code_name = gdb.parse_and_eval('gimple_code_name')\n         val_code_name = val_gimple_code_name[long(val_gimple_code)]\n         result = '<%s 0x%x' % (val_code_name.string(),"}, {"sha": "bb8f939513d850ca96ecf24e6fa4d19c65b40cc9", "filename": "gcc/ggc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -269,10 +269,10 @@ ggc_alloc_cleared_tree_node_stat (size_t s MEM_STAT_DECL)\n   return (union tree_node *) ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n }\n \n-static inline union gimple_statement_d *\n-ggc_alloc_cleared_gimple_statement_d_stat (size_t s MEM_STAT_DECL)\n+static inline struct gimple_statement_base *\n+ggc_alloc_cleared_gimple_statement_stat (size_t s MEM_STAT_DECL)\n {\n-  return (union gimple_statement_d *)\n+  return (struct gimple_statement_base *)\n     ggc_internal_cleared_alloc_stat (s PASS_MEM_STAT);\n }\n "}, {"sha": "557bf35f0153f1c63cdc692d0b84b530804f4e8e", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -68,7 +68,7 @@ update_bb_for_stmts (gimple_seq_node first, gimple_seq_node last,\n {\n   gimple_seq_node n;\n \n-  for (n = first; n; n = n->gsbase.next)\n+  for (n = first; n; n = n->next)\n     {\n       gimple_set_bb (n, bb);\n       if (n == last)\n@@ -86,7 +86,7 @@ update_call_edge_frequencies (gimple_seq_node first, basic_block bb)\n   int bb_freq = 0;\n   gimple_seq_node n;\n \n-  for (n = first; n ; n = n->gsbase.next)\n+  for (n = first; n ; n = n->next)\n     if (is_gimple_call (n))\n       {\n \tstruct cgraph_edge *e;\n@@ -124,21 +124,21 @@ gsi_insert_seq_nodes_before (gimple_stmt_iterator *i,\n   basic_block bb;\n   gimple_seq_node cur = i->ptr;\n \n-  gcc_assert (!cur || cur->gsbase.prev);\n+  gcc_assert (!cur || cur->prev);\n \n   if ((bb = gsi_bb (*i)) != NULL)\n     update_bb_for_stmts (first, last, bb);\n \n   /* Link SEQ before CUR in the sequence.  */\n   if (cur)\n     {\n-      first->gsbase.prev = cur->gsbase.prev;\n-      if (first->gsbase.prev->gsbase.next)\n-\tfirst->gsbase.prev->gsbase.next = first;\n+      first->prev = cur->prev;\n+      if (first->prev->next)\n+\tfirst->prev->next = first;\n       else\n \tgimple_seq_set_first (i->seq, first);\n-      last->gsbase.next = cur;\n-      cur->gsbase.prev = last;\n+      last->next = cur;\n+      cur->prev = last;\n     }\n   else\n     {\n@@ -149,11 +149,11 @@ gsi_insert_seq_nodes_before (gimple_stmt_iterator *i,\n \t labels, so it returns an iterator after the end of the block, and\n \t we need to insert before it; it might be cleaner to add a flag to the\n \t iterator saying whether we are at the start or end of the list).  */\n-      last->gsbase.next = NULL;\n+      last->next = NULL;\n       if (itlast)\n \t{\n-\t  first->gsbase.prev = itlast;\n-\t  itlast->gsbase.next = first;\n+\t  first->prev = itlast;\n+\t  itlast->next = first;\n \t}\n       else\n \tgimple_seq_set_first (i->seq, first);\n@@ -242,7 +242,7 @@ gsi_insert_seq_nodes_after (gimple_stmt_iterator *i,\n   basic_block bb;\n   gimple_seq_node cur = i->ptr;\n \n-  gcc_assert (!cur || cur->gsbase.prev);\n+  gcc_assert (!cur || cur->prev);\n \n   /* If the iterator is inside a basic block, we need to update the\n      basic block information for all the nodes between FIRST and LAST.  */\n@@ -252,20 +252,20 @@ gsi_insert_seq_nodes_after (gimple_stmt_iterator *i,\n   /* Link SEQ after CUR.  */\n   if (cur)\n     {\n-      last->gsbase.next = cur->gsbase.next;\n-      if (last->gsbase.next)\n+      last->next = cur->next;\n+      if (last->next)\n \t{\n-\t  last->gsbase.next->gsbase.prev = last;\n+\t  last->next->prev = last;\n \t}\n       else\n \tgimple_seq_set_last (i->seq, last);\n-      first->gsbase.prev = cur;\n-      cur->gsbase.next = first;\n+      first->prev = cur;\n+      cur->next = first;\n     }\n   else\n     {\n       gcc_assert (!gimple_seq_last (*i->seq));\n-      last->gsbase.next = NULL;\n+      last->next = NULL;\n       gimple_seq_set_first (i->seq, first);\n       gimple_seq_set_last (i->seq, last);\n     }\n@@ -347,15 +347,15 @@ gsi_split_seq_after (gimple_stmt_iterator i)\n   cur = i.ptr;\n \n   /* How can we possibly split after the end, or before the beginning?  */\n-  gcc_assert (cur && cur->gsbase.next);\n-  next = cur->gsbase.next;\n+  gcc_assert (cur && cur->next);\n+  next = cur->next;\n \n   pold_seq = i.seq;\n \n   gimple_seq_set_first (&new_seq, next);\n   gimple_seq_set_last (&new_seq, gimple_seq_last (*pold_seq));\n   gimple_seq_set_last (pold_seq, cur);\n-  cur->gsbase.next = NULL;\n+  cur->next = NULL;\n \n   return new_seq;\n }\n@@ -371,17 +371,17 @@ gsi_set_stmt (gimple_stmt_iterator *gsi, gimple stmt)\n   gimple orig_stmt = gsi_stmt (*gsi);\n   gimple prev, next;\n \n-  stmt->gsbase.next = next = orig_stmt->gsbase.next;\n-  stmt->gsbase.prev = prev = orig_stmt->gsbase.prev;\n+  stmt->next = next = orig_stmt->next;\n+  stmt->prev = prev = orig_stmt->prev;\n   /* Note how we don't clear next/prev of orig_stmt.  This is so that\n      copies of *GSI our callers might still hold (to orig_stmt)\n      can be advanced as if they too were replaced.  */\n-  if (prev->gsbase.next)\n-    prev->gsbase.next = stmt;\n+  if (prev->next)\n+    prev->next = stmt;\n   else\n     gimple_seq_set_first (gsi->seq, stmt);\n   if (next)\n-    next->gsbase.prev = stmt;\n+    next->prev = stmt;\n   else\n     gimple_seq_set_last (gsi->seq, stmt);\n \n@@ -402,10 +402,10 @@ gsi_split_seq_before (gimple_stmt_iterator *i, gimple_seq *pnew_seq)\n \n   /* How can we possibly split after the end?  */\n   gcc_assert (cur);\n-  prev = cur->gsbase.prev;\n+  prev = cur->prev;\n \n   old_seq = *i->seq;\n-  if (!prev->gsbase.next)\n+  if (!prev->next)\n     *i->seq = NULL;\n   i->seq = pnew_seq;\n \n@@ -415,8 +415,8 @@ gsi_split_seq_before (gimple_stmt_iterator *i, gimple_seq *pnew_seq)\n \n   /* Cut OLD_SEQ before I.  */\n   gimple_seq_set_last (&old_seq, prev);\n-  if (prev->gsbase.next)\n-    prev->gsbase.next = NULL;\n+  if (prev->next)\n+    prev->next = NULL;\n }\n \n \n@@ -576,20 +576,20 @@ gsi_remove (gimple_stmt_iterator *i, bool remove_permanently)\n \n   /* Update the iterator and re-wire the links in I->SEQ.  */\n   cur = i->ptr;\n-  next = cur->gsbase.next;\n-  prev = cur->gsbase.prev;\n+  next = cur->next;\n+  prev = cur->prev;\n   /* See gsi_set_stmt for why we don't reset prev/next of STMT.  */\n \n   if (next)\n     /* Cur is not last.  */\n-    next->gsbase.prev = prev;\n-  else if (prev->gsbase.next)\n+    next->prev = prev;\n+  else if (prev->next)\n     /* Cur is last but not first.  */\n     gimple_seq_set_last (i->seq, prev);\n \n-  if (prev->gsbase.next)\n+  if (prev->next)\n     /* Cur is not first.  */\n-    prev->gsbase.next = next;\n+    prev->next = next;\n   else\n     /* Cur is first.  */\n     *i->seq = next;"}, {"sha": "11b1276350541f08e8aa2387d5bbb89e304c7d60", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -168,24 +168,24 @@ gsi_end_p (gimple_stmt_iterator i)\n static inline bool\n gsi_one_before_end_p (gimple_stmt_iterator i)\n {\n-  return i.ptr != NULL && i.ptr->gsbase.next == NULL;\n+  return i.ptr != NULL && i.ptr->next == NULL;\n }\n \n /* Advance the iterator to the next gimple statement.  */\n \n static inline void\n gsi_next (gimple_stmt_iterator *i)\n {\n-  i->ptr = i->ptr->gsbase.next;\n+  i->ptr = i->ptr->next;\n }\n \n /* Advance the iterator to the previous gimple statement.  */\n \n static inline void\n gsi_prev (gimple_stmt_iterator *i)\n {\n-  gimple prev = i->ptr->gsbase.prev;\n-  if (prev->gsbase.next)\n+  gimple prev = i->ptr->prev;\n+  if (prev->next)\n     i->ptr = prev;\n   else\n     i->ptr = NULL;"}, {"sha": "4529e79205ebafb7bc6da9b8f6c633419f007632", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -88,13 +88,13 @@ print_gimple_stmt (FILE *file, gimple g, int spc, int flags)\n }\n \n DEBUG_FUNCTION void\n-debug (gimple_statement_d &ref)\n+debug (gimple_statement_base &ref)\n {\n   print_gimple_stmt (stderr, &ref, 0, 0);\n }\n \n DEBUG_FUNCTION void\n-debug (gimple_statement_d *ptr)\n+debug (gimple_statement_base *ptr)\n {\n   if (ptr)\n     debug (*ptr);\n@@ -1073,7 +1073,7 @@ dump_gimple_eh_dispatch (pretty_printer *buffer, gimple gs, int spc, int flags)\n static void\n dump_gimple_debug (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n-  switch (gs->gsbase.subcode)\n+  switch (gs->subcode)\n     {\n     case GIMPLE_DEBUG_BIND:\n       if (flags & TDF_RAW)"}, {"sha": "edb23e61c71ef11cf08e0e06c6f0b1087d791882", "filename": "gcc/gimple-pretty-print.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -29,8 +29,8 @@ extern void debug_gimple_stmt (gimple);\n extern void debug_gimple_seq (gimple_seq);\n extern void print_gimple_seq (FILE *, gimple_seq, int, int);\n extern void print_gimple_stmt (FILE *, gimple, int, int);\n-extern void debug (gimple_statement_d &ref);\n-extern void debug (gimple_statement_d *ptr);\n+extern void debug (gimple_statement_base &ref);\n+extern void debug (gimple_statement_base *ptr);\n extern void print_gimple_expr (FILE *, gimple, int, int);\n extern void pp_gimple_stmt_1 (pretty_printer *, gimple, int, int);\n extern void gimple_dump_bb (FILE *, basic_block, int, int);"}, {"sha": "50b48bb6228fc51a1a136d2361858945f0c4d39b", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -108,11 +108,13 @@ static inline use_operand_p\n gimple_vuse_op (const_gimple g)\n {\n   struct use_optype_d *ops;\n-  if (!gimple_has_mem_ops (g))\n+  const gimple_statement_with_memory_ops *mem_ops_stmt =\n+     dyn_cast <const gimple_statement_with_memory_ops> (g);\n+  if (!mem_ops_stmt)\n     return NULL_USE_OPERAND_P;\n-  ops = g->gsops.opbase.use_ops;\n+  ops = mem_ops_stmt->use_ops;\n   if (ops\n-      && USE_OP_PTR (ops)->use == &g->gsmembase.vuse)\n+      && USE_OP_PTR (ops)->use == &mem_ops_stmt->vuse)\n     return USE_OP_PTR (ops);\n   return NULL_USE_OPERAND_P;\n }\n@@ -122,10 +124,12 @@ gimple_vuse_op (const_gimple g)\n static inline def_operand_p\n gimple_vdef_op (gimple g)\n {\n-  if (!gimple_has_mem_ops (g))\n+  gimple_statement_with_memory_ops *mem_ops_stmt =\n+     dyn_cast <gimple_statement_with_memory_ops> (g);\n+  if (!mem_ops_stmt)\n     return NULL_DEF_OPERAND_P;\n-  if (g->gsmembase.vdef)\n-    return &g->gsmembase.vdef;\n+  if (mem_ops_stmt->vdef)\n+    return &mem_ops_stmt->vdef;\n   return NULL_DEF_OPERAND_P;\n }\n "}, {"sha": "a5c8dd8fd39840f746fe6294ba1916d2bfa1cbb8", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -100,12 +100,12 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n   bp = streamer_read_bitpack (ib);\n   num_ops = bp_unpack_var_len_unsigned (&bp);\n   stmt = gimple_alloc (code, num_ops);\n-  stmt->gsbase.no_warning = bp_unpack_value (&bp, 1);\n+  stmt->no_warning = bp_unpack_value (&bp, 1);\n   if (is_gimple_assign (stmt))\n-    stmt->gsbase.nontemporal_move = bp_unpack_value (&bp, 1);\n-  stmt->gsbase.has_volatile_ops = bp_unpack_value (&bp, 1);\n+    stmt->nontemporal_move = bp_unpack_value (&bp, 1);\n+  stmt->has_volatile_ops = bp_unpack_value (&bp, 1);\n   has_hist = bp_unpack_value (&bp, 1);\n-  stmt->gsbase.subcode = bp_unpack_var_len_unsigned (&bp);\n+  stmt->subcode = bp_unpack_var_len_unsigned (&bp);\n \n   /* Read location information.  */\n   gimple_set_location (stmt, stream_input_location (&bp, data_in));\n@@ -131,13 +131,14 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n     case GIMPLE_ASM:\n       {\n \t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n+\tgimple_statement_asm *asm_stmt = as_a <gimple_statement_asm> (stmt);\n \ttree str;\n-\tstmt->gimple_asm.ni = streamer_read_uhwi (ib);\n-\tstmt->gimple_asm.no = streamer_read_uhwi (ib);\n-\tstmt->gimple_asm.nc = streamer_read_uhwi (ib);\n-\tstmt->gimple_asm.nl = streamer_read_uhwi (ib);\n+\tasm_stmt->ni = streamer_read_uhwi (ib);\n+\tasm_stmt->no = streamer_read_uhwi (ib);\n+\tasm_stmt->nc = streamer_read_uhwi (ib);\n+\tasm_stmt->nl = streamer_read_uhwi (ib);\n \tstr = streamer_read_string_cst (data_in, ib);\n-\tstmt->gimple_asm.string = TREE_STRING_POINTER (str);\n+\tasm_stmt->string = TREE_STRING_POINTER (str);\n       }\n       /* Fallthru  */\n "}, {"sha": "0d6b6a6ae95252e51b17abe7025e0afac5c32c1c", "filename": "gcc/gimple-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-out.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -78,7 +78,7 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n   bp_pack_value (&bp, gimple_has_volatile_ops (stmt), 1);\n   hist = gimple_histogram_value (cfun, stmt);\n   bp_pack_value (&bp, hist != NULL, 1);\n-  bp_pack_var_len_unsigned (&bp, stmt->gsbase.subcode);\n+  bp_pack_var_len_unsigned (&bp, stmt->subcode);\n \n   /* Emit location information for the statement.  */\n   stream_output_location (ob, &bp, LOCATION_LOCUS (gimple_location (stmt)));"}, {"sha": "d48ca6bcd10bb007a2b8fd413eea2777853fc554", "filename": "gcc/gimple.c", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -96,7 +96,7 @@ static const char * const gimple_alloc_kind_names[] = {\n static inline void\n gimple_set_code (gimple g, enum gimple_code code)\n {\n-  g->gsbase.code = code;\n+  g->code = code;\n }\n \n /* Return the number of bytes needed to hold a GIMPLE statement with\n@@ -128,13 +128,13 @@ gimple_alloc_stat (enum gimple_code code, unsigned num_ops MEM_STAT_DECL)\n       gimple_alloc_sizes[(int) kind] += size;\n     }\n \n-  stmt = ggc_alloc_cleared_gimple_statement_d_stat (size PASS_MEM_STAT);\n+  stmt = ggc_alloc_cleared_gimple_statement_stat (size PASS_MEM_STAT);\n   gimple_set_code (stmt, code);\n   gimple_set_num_ops (stmt, num_ops);\n \n   /* Do not call gimple_set_modified here as it has other side\n      effects and this tuple is still not completely built.  */\n-  stmt->gsbase.modified = 1;\n+  stmt->modified = 1;\n   gimple_init_singleton (stmt);\n \n   return stmt;\n@@ -148,7 +148,7 @@ gimple_set_subcode (gimple g, unsigned subcode)\n   /* We only have 16 bits for the RHS code.  Assert that we are not\n      overflowing it.  */\n   gcc_assert (subcode < (1 << 16));\n-  g->gsbase.subcode = subcode;\n+  g->subcode = subcode;\n }\n \n \n@@ -283,7 +283,7 @@ static inline gimple\n gimple_build_call_internal_1 (enum internal_fn fn, unsigned nargs)\n {\n   gimple s = gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK, nargs + 3);\n-  s->gsbase.subcode |= GF_CALL_INTERNAL;\n+  s->subcode |= GF_CALL_INTERNAL;\n   gimple_call_set_internal_fn (s, fn);\n   gimple_call_reset_alias_info (s);\n   return s;\n@@ -533,21 +533,22 @@ static inline gimple\n gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n                     unsigned nclobbers, unsigned nlabels)\n {\n-  gimple p;\n+  gimple_statement_asm *p;\n   int size = strlen (string);\n \n   /* ASMs with labels cannot have outputs.  This should have been\n      enforced by the front end.  */\n   gcc_assert (nlabels == 0 || noutputs == 0);\n \n-  p = gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n-\t\t\t     ninputs + noutputs + nclobbers + nlabels);\n+  p = as_a <gimple_statement_asm> (\n+        gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n+\t\t\t       ninputs + noutputs + nclobbers + nlabels));\n \n-  p->gimple_asm.ni = ninputs;\n-  p->gimple_asm.no = noutputs;\n-  p->gimple_asm.nc = nclobbers;\n-  p->gimple_asm.nl = nlabels;\n-  p->gimple_asm.string = ggc_alloc_string (string, size);\n+  p->ni = ninputs;\n+  p->no = noutputs;\n+  p->nc = nclobbers;\n+  p->nl = nlabels;\n+  p->string = ggc_alloc_string (string, size);\n \n   if (GATHER_STATISTICS)\n     gimple_alloc_sizes[(int) gimple_alloc_kind (GIMPLE_ASM)] += size;\n@@ -659,14 +660,14 @@ gimple_build_eh_else (gimple_seq n_body, gimple_seq e_body)\n    KIND is either GIMPLE_TRY_CATCH or GIMPLE_TRY_FINALLY depending on\n    whether this is a try/catch or a try/finally respectively.  */\n \n-gimple\n+gimple_statement_try *\n gimple_build_try (gimple_seq eval, gimple_seq cleanup,\n     \t\t  enum gimple_try_flags kind)\n {\n-  gimple p;\n+  gimple_statement_try *p;\n \n   gcc_assert (kind == GIMPLE_TRY_CATCH || kind == GIMPLE_TRY_FINALLY);\n-  p = gimple_alloc (GIMPLE_TRY, 0);\n+  p = as_a <gimple_statement_try> (gimple_alloc (GIMPLE_TRY, 0));\n   gimple_set_subcode (p, kind);\n   if (eval)\n     gimple_try_set_eval (p, eval);\n@@ -696,8 +697,10 @@ gimple_build_wce (gimple_seq cleanup)\n gimple\n gimple_build_resx (int region)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_RESX, ERROR_MARK, 0);\n-  p->gimple_eh_ctrl.region = region;\n+  gimple_statement_eh_ctrl *p =\n+    as_a <gimple_statement_eh_ctrl> (\n+      gimple_build_with_ops (GIMPLE_RESX, ERROR_MARK, 0));\n+  p->region = region;\n   return p;\n }\n \n@@ -744,8 +747,10 @@ gimple_build_switch (tree index, tree default_label, vec<tree> args)\n gimple\n gimple_build_eh_dispatch (int region)\n {\n-  gimple p = gimple_build_with_ops (GIMPLE_EH_DISPATCH, ERROR_MARK, 0);\n-  p->gimple_eh_ctrl.region = region;\n+  gimple_statement_eh_ctrl *p =\n+    as_a <gimple_statement_eh_ctrl> (\n+      gimple_build_with_ops (GIMPLE_EH_DISPATCH, ERROR_MARK, 0));\n+  p->region = region;\n   return p;\n }\n \n@@ -819,14 +824,17 @@ gimple\n gimple_build_omp_for (gimple_seq body, int kind, tree clauses, size_t collapse,\n \t\t      gimple_seq pre_body)\n {\n-  gimple p = gimple_alloc (GIMPLE_OMP_FOR, 0);\n+  gimple_statement_omp_for *p =\n+    as_a <gimple_statement_omp_for> (gimple_alloc (GIMPLE_OMP_FOR, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_for_set_clauses (p, clauses);\n   gimple_omp_for_set_kind (p, kind);\n-  p->gimple_omp_for.collapse = collapse;\n-  p->gimple_omp_for.iter\n-      = ggc_alloc_cleared_vec_gimple_omp_for_iter (collapse);\n+  p->collapse = collapse;\n+  p->iter =  static_cast <struct gimple_omp_for_iter *> (\n+   ggc_internal_cleared_vec_alloc_stat (sizeof (*p->iter),\n+\t\t\t\t\tcollapse MEM_STAT_INFO));\n+\n   if (pre_body)\n     gimple_omp_for_set_pre_body (p, pre_body);\n \n@@ -1114,8 +1122,8 @@ gimple_check_failed (const_gimple gs, const char *file, int line,\n       \t\t  gimple_code_name[code],\n \t\t  get_tree_code_name (subcode),\n \t\t  gimple_code_name[gimple_code (gs)],\n-\t\t  gs->gsbase.subcode > 0\n-\t\t    ? get_tree_code_name ((enum tree_code) gs->gsbase.subcode)\n+\t\t  gs->subcode > 0\n+\t\t    ? get_tree_code_name ((enum tree_code) gs->subcode)\n \t\t    : \"\",\n \t\t  function, trim_filename (file), line);\n }\n@@ -1309,7 +1317,7 @@ gimple_call_flags (const_gimple stmt)\n   else\n     flags = flags_from_decl_or_type (gimple_call_fntype (stmt));\n \n-  if (stmt->gsbase.subcode & GF_CALL_NOTHROW)\n+  if (stmt->subcode & GF_CALL_NOTHROW)\n     flags |= ECF_NOTHROW;\n \n   return flags;\n@@ -1450,7 +1458,7 @@ gimple_assign_unary_nop_p (gimple gs)\n void\n gimple_set_bb (gimple stmt, basic_block bb)\n {\n-  stmt->gsbase.bb = bb;\n+  stmt->bb = bb;\n \n   /* If the statement is a label, add the label to block-to-labels map\n      so that we can speed up edge creation for GIMPLE_GOTOs.  */\n@@ -1645,9 +1653,15 @@ gimple_copy (gimple stmt)\n \t  gimple_omp_for_set_pre_body (copy, new_seq);\n \t  t = unshare_expr (gimple_omp_for_clauses (stmt));\n \t  gimple_omp_for_set_clauses (copy, t);\n-\t  copy->gimple_omp_for.iter\n-\t    = ggc_alloc_vec_gimple_omp_for_iter\n-\t    (gimple_omp_for_collapse (stmt));\n+\t  {\n+\t    gimple_statement_omp_for *omp_for_copy =\n+\t      as_a <gimple_statement_omp_for> (copy);\n+\t    omp_for_copy->iter =\n+\t      static_cast <struct gimple_omp_for_iter *> (\n+\t\t  ggc_internal_vec_alloc_stat (sizeof (struct gimple_omp_for_iter),\n+\t\t\t\t\t       gimple_omp_for_collapse (stmt)\n+\t\t\t\t\t       MEM_STAT_INFO));\n+          }\n \t  for (i = 0; i < gimple_omp_for_collapse (stmt); i++)\n \t    {\n \t      gimple_omp_for_set_cond (copy, i,"}, {"sha": "0eb23fc39e893eda890e3b5a78d81783d7f31501", "filename": "gcc/gimple.h", "status": "modified", "additions": 1056, "deletions": 593, "changes": 1649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902"}, {"sha": "5c71d2c360501ed7c26eeae23ef93077e0a7163a", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -5009,7 +5009,7 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n \t    }\n \t  else\n \t    {\n-\t      gimple gtry;\n+\t      gimple_statement_try *gtry;\n \t      gimple_seq seq;\n \t      enum gimple_try_flags kind;\n \n@@ -5023,7 +5023,7 @@ gimplify_cleanup_point_expr (tree *expr_p, gimple_seq *pre_p)\n               /* Do not use gsi_replace here, as it may scan operands.\n                  We want to do a simple structural modification only.  */\n \t      gsi_set_stmt (&iter, gtry);\n-\t      iter = gsi_start (gtry->gimple_try.eval);\n+\t      iter = gsi_start (gtry->eval);\n \t    }\n \t}\n       else"}, {"sha": "87ebe3cbb04d9edf49b4cbe1c483f1ba7b6ed7a9", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -1013,7 +1013,7 @@ helper_const_non_const_cast (const char *p)\n #define CONST_CAST_TREE(X) CONST_CAST (union tree_node *, (X))\n #define CONST_CAST_RTX(X) CONST_CAST (struct rtx_def *, (X))\n #define CONST_CAST_BB(X) CONST_CAST (struct basic_block_def *, (X))\n-#define CONST_CAST_GIMPLE(X) CONST_CAST (union gimple_statement_d *, (X))\n+#define CONST_CAST_GIMPLE(X) CONST_CAST (struct gimple_statement_base *, (X))\n \n /* Activate certain diagnostics as warnings (not errors via the\n    -Werror flag).  */"}, {"sha": "6ef8bb456157feac7a0f196a0525f8d8b69b0f8a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -2635,7 +2635,7 @@ copy_debug_stmt (gimple stmt, copy_body_data *id)\n \t\t    && TREE_CODE ((**debug_args)[i + 1]) == DEBUG_EXPR_DECL)\n \t\t  {\n \t\t    t = (**debug_args)[i + 1];\n-\t\t    stmt->gsbase.subcode = GIMPLE_DEBUG_BIND;\n+\t\t    stmt->subcode = GIMPLE_DEBUG_BIND;\n \t\t    gimple_debug_bind_set_value (stmt, t);\n \t\t    break;\n \t\t  }"}, {"sha": "bf024ac976c3f259decede6a8ad223c1e3b1e6a9", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -94,10 +94,10 @@ phinodes_print_statistics (void)\n    happens to contain a PHI node with LEN arguments or more, return\n    that one.  */\n \n-static inline gimple\n+static inline gimple_statement_phi *\n allocate_phi_node (size_t len)\n {\n-  gimple phi;\n+  gimple_statement_phi *phi;\n   size_t bucket = NUM_BUCKETS - 2;\n   size_t size = sizeof (struct gimple_statement_phi)\n \t        + (len - 1) * sizeof (struct phi_arg_d);\n@@ -112,15 +112,16 @@ allocate_phi_node (size_t len)\n       && gimple_phi_capacity ((*free_phinodes[bucket])[0]) >= len)\n     {\n       free_phinode_count--;\n-      phi = free_phinodes[bucket]->pop ();\n+      phi = as_a <gimple_statement_phi> (free_phinodes[bucket]->pop ());\n       if (free_phinodes[bucket]->is_empty ())\n \tvec_free (free_phinodes[bucket]);\n       if (GATHER_STATISTICS)\n \tphi_nodes_reused++;\n     }\n   else\n     {\n-      phi = ggc_alloc_gimple_statement_d (size);\n+      phi = static_cast <gimple_statement_phi *> (\n+\tggc_internal_alloc_stat (size MEM_STAT_INFO));\n       if (GATHER_STATISTICS)\n \t{\n \t  enum gimple_alloc_kind kind = gimple_alloc_kind (GIMPLE_PHI);\n@@ -172,7 +173,7 @@ ideal_phi_node_len (int len)\n static gimple\n make_phi_node (tree var, int len)\n {\n-  gimple phi;\n+  gimple_statement_phi *phi;\n   int capacity, i;\n \n   capacity = ideal_phi_node_len (len);\n@@ -185,10 +186,10 @@ make_phi_node (tree var, int len)\n   memset (phi, 0, (sizeof (struct gimple_statement_phi)\n \t\t   - sizeof (struct phi_arg_d)\n \t\t   + sizeof (struct phi_arg_d) * len));\n-  phi->gsbase.code = GIMPLE_PHI;\n+  phi->code = GIMPLE_PHI;\n   gimple_init_singleton (phi);\n-  phi->gimple_phi.nargs = len;\n-  phi->gimple_phi.capacity = capacity;\n+  phi->nargs = len;\n+  phi->capacity = capacity;\n   if (!var)\n     ;\n   else if (TREE_CODE (var) == SSA_NAME)\n@@ -237,11 +238,11 @@ release_phi_node (gimple phi)\n /* Resize an existing PHI node.  The only way is up.  Return the\n    possibly relocated phi.  */\n \n-static gimple\n-resize_phi_node (gimple phi, size_t len)\n+static gimple_statement_phi *\n+resize_phi_node (gimple_statement_phi *phi, size_t len)\n {\n   size_t old_size, i;\n-  gimple new_phi;\n+  gimple_statement_phi *new_phi;\n \n   gcc_assert (len > gimple_phi_capacity (phi));\n \n@@ -264,7 +265,7 @@ resize_phi_node (gimple phi, size_t len)\n       relink_imm_use_stmt (imm, old_imm, new_phi);\n     }\n \n-  new_phi->gimple_phi.capacity = len;\n+  new_phi->capacity = len;\n \n   for (i = gimple_phi_num_args (new_phi); i < len; i++)\n     {\n@@ -292,11 +293,12 @@ reserve_phi_args_for_new_edge (basic_block bb)\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n-      gimple stmt = gsi_stmt (gsi);\n+      gimple_statement_phi *stmt =\n+\tas_a <gimple_statement_phi> (gsi_stmt (gsi));\n \n       if (len > gimple_phi_capacity (stmt))\n \t{\n-\t  gimple new_phi = resize_phi_node (stmt, cap);\n+\t  gimple_statement_phi *new_phi = resize_phi_node (stmt, cap);\n \n \t  /* The result of the PHI is defined by this PHI node.  */\n \t  SSA_NAME_DEF_STMT (gimple_phi_result (new_phi)) = new_phi;\n@@ -316,7 +318,7 @@ reserve_phi_args_for_new_edge (basic_block bb)\n       SET_PHI_ARG_DEF (stmt, len - 1, NULL_TREE);\n       gimple_phi_arg_set_location (stmt, len - 1, UNKNOWN_LOCATION);\n \n-      stmt->gimple_phi.nargs++;\n+      stmt->nargs++;\n     }\n }\n \n@@ -392,7 +394,7 @@ add_phi_arg (gimple phi, tree def, edge e, source_location locus)\n    is consistent with how we remove an edge from the edge vector.  */\n \n static void\n-remove_phi_arg_num (gimple phi, int i)\n+remove_phi_arg_num (gimple_statement_phi *phi, int i)\n {\n   int num_elem = gimple_phi_num_args (phi);\n \n@@ -419,7 +421,7 @@ remove_phi_arg_num (gimple phi, int i)\n   /* Shrink the vector and return.  Note that we do not have to clear\n      PHI_ARG_DEF because the garbage collector will not look at those\n      elements beyond the first PHI_NUM_ARGS elements of the array.  */\n-  phi->gimple_phi.nargs--;\n+  phi->nargs--;\n }\n \n \n@@ -431,7 +433,8 @@ remove_phi_args (edge e)\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    remove_phi_arg_num (gsi_stmt (gsi), e->dest_idx);\n+    remove_phi_arg_num (as_a <gimple_statement_phi> (gsi_stmt (gsi)),\n+\t\t\te->dest_idx);\n }\n \n "}, {"sha": "6a542b8da79788ce3283fac254b93b0e75e4bb6d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daa6e488c2f9611ac88611aac6f49e4090eb4902/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=daa6e488c2f9611ac88611aac6f49e4090eb4902", "patch": "@@ -1766,7 +1766,7 @@ evaluate_stmt (gimple stmt)\n   return val;\n }\n \n-typedef hash_table <pointer_hash <gimple_statement_d> > gimple_htab;\n+typedef hash_table <pointer_hash <gimple_statement_base> > gimple_htab;\n \n /* Given a BUILT_IN_STACK_SAVE value SAVED_VAL, insert a clobber of VAR before\n    each matching BUILT_IN_STACK_RESTORE.  Mark visited phis in VISITED.  */"}]}