{"sha": "6e701822708dbcd9ec935a536830a522d24f8151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU3MDE4MjI3MDhkYmNkOWVjOTM1YTUzNjgzMGE1MjJkMjRmODE1MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-01-11T17:29:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-01-11T17:29:52Z"}, "message": "re PR lto/45721 (ICE: in function_and_variable_visibility, at ipa.c:673 with -flto)\n\n\n\tPR lto/45721\n\tPR lto/45375\n\t* tree.h (symbol_alias_set_t): Move typedef here from varasm.c\n\t(symbol_alias_set_destroy, symbol_alias_set_contains,\n\tpropagate_aliases_backward): Declare.\n\t* lto-streamer-out.c (struct sets): New sturcture.\n\t(trivally_defined_alias): New function.\n\t(output_alias_pair_p): Rewrite.\n\t(output_unreferenced_globals): Fix output of alias pairs.\n\t(produce_symtab): Likewise.\n\t* ipa.c (function_and_variable_visibility): Set weak alias destination\n\tas needed in lto.\n\t* varasm.c (symbol_alias_set_t): Remove.\n\t(symbol_alias_set_destroy): Export.\n\t(propagate_aliases_forward, propagate_aliases_backward): New functions\n\tbased on ...\n\t(compute_visible_aliases): ... this one; remove.\n\t(trivially_visible_alias): New\n\t(trivially_defined_alias): New.\n\t(remove_unreachable_alias_pairs): Rewrite.\n\t(finish_aliases_1): Reorganize code checking if alias is defined.\n\t* passes.c (rest_of_decl_compilation): Do not call assemble_alias when\n\tin LTO mode.\n\n\t* lto.c (partition_cgraph_node_p, partition_varpool_node_p): Weakrefs are\n\tnot partitioned.\n\n\t* testsuite/gcc.dg/lto/pr45721_1.c: New file.\n\t* testsuite/gcc.dg/lto/pr45721_0.c: New file.\n\nFrom-SVN: r168666", "tree": {"sha": "8a0441a53aaf0333716ca7449a404e95b3435f3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a0441a53aaf0333716ca7449a404e95b3435f3e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e701822708dbcd9ec935a536830a522d24f8151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e701822708dbcd9ec935a536830a522d24f8151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e701822708dbcd9ec935a536830a522d24f8151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e701822708dbcd9ec935a536830a522d24f8151/comments", "author": null, "committer": null, "parents": [{"sha": "1b248907583f1cf4e02ce4168ad35cf3fe7637ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b248907583f1cf4e02ce4168ad35cf3fe7637ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b248907583f1cf4e02ce4168ad35cf3fe7637ba"}], "stats": {"total": 302, "additions": 243, "deletions": 59}, "files": [{"sha": "7c42fabc95035463fb6e660433326c258c90c1b6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -1,3 +1,29 @@\n+2011-01-11  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/45721\n+\tPR lto/45375\n+\t* tree.h (symbol_alias_set_t): Move typedef here from varasm.c\n+\t(symbol_alias_set_destroy, symbol_alias_set_contains,\n+\tpropagate_aliases_backward): Declare.\n+\t* lto-streamer-out.c (struct sets): New sturcture.\n+\t(trivally_defined_alias): New function.\n+\t(output_alias_pair_p): Rewrite.\n+\t(output_unreferenced_globals): Fix output of alias pairs.\n+\t(produce_symtab): Likewise.\n+\t* ipa.c (function_and_variable_visibility): Set weak alias destination\n+\tas needed in lto.\n+\t* varasm.c (symbol_alias_set_t): Remove.\n+\t(symbol_alias_set_destroy): Export.\n+\t(propagate_aliases_forward, propagate_aliases_backward): New functions\n+\tbased on ...\n+\t(compute_visible_aliases): ... this one; remove.\n+\t(trivially_visible_alias): New\n+\t(trivially_defined_alias): New.\n+\t(remove_unreachable_alias_pairs): Rewrite.\n+\t(finish_aliases_1): Reorganize code checking if alias is defined.\n+\t* passes.c (rest_of_decl_compilation): Do not call assemble_alias when\n+\tin LTO mode.\n+\n 2011-01-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46076"}, {"sha": "7c0029334fd1384e0c82cd8fc3562f98fa11f1e7", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 73, "deletions": 14, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -2007,6 +2007,13 @@ output_function (struct cgraph_node *node)\n }\n \n \n+/* Used to pass data to trivally_defined_alias callback.  */\n+struct sets {\n+  cgraph_node_set set;\n+  varpool_node_set vset;\n+};\n+\n+\n /* Return true if alias pair P belongs to the set of cgraph nodes in\n    SET.  If P is a an alias for a VAR_DECL, it can always be emitted.\n    However, for FUNCTION_DECL aliases, we should only output the pair\n@@ -2016,16 +2023,51 @@ output_function (struct cgraph_node *node)\n    the file processed by LTRANS.  */\n \n static bool\n-output_alias_pair_p (alias_pair *p, cgraph_node_set set, varpool_node_set vset)\n+trivally_defined_alias (tree decl ATTRIBUTE_UNUSED,\n+\t\t\ttree target, void *data)\n {\n-  if (TREE_CODE (p->decl) == VAR_DECL)\n-    return varpool_node_in_set_p (varpool_node_for_asm (p->target), vset);\n+  struct sets *set = (struct sets *) data;\n+  struct cgraph_node *fnode = NULL;\n+  struct varpool_node *vnode = NULL;\n \n-  /* Check if the assembler name for P->TARGET has its cgraph node in SET.  */\n-  gcc_assert (TREE_CODE (p->decl) == FUNCTION_DECL);\n-  return cgraph_node_in_set_p (cgraph_node_for_asm (p->target), set);\n+  fnode = cgraph_node_for_asm (target);\n+  if (fnode)\n+    return cgraph_node_in_set_p (fnode, set->set);\n+  vnode = varpool_node_for_asm (target);\n+  return vnode && varpool_node_in_set_p (vnode, set->vset);\n }\n \n+/* Return true if alias pair P should be output in the current\n+   partition contains cgrpah nodes SET and varpool nodes VSET.\n+   DEFINED is set of all aliases whose targets are defined in\n+   the partition.\n+\n+   Normal aliases are output when they are defined, while WEAKREF\n+   aliases are output when they are used.  */\n+\n+static bool\n+output_alias_pair_p (alias_pair *p, symbol_alias_set_t *defined,\n+\t\t     cgraph_node_set set, varpool_node_set vset)\n+{\n+  struct cgraph_node *node;\n+  struct varpool_node *vnode;\n+\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (p->decl)))\n+    {\n+      if (TREE_CODE (p->decl) == VAR_DECL)\n+\t{\n+\t  vnode = varpool_get_node (p->decl);\n+\t  return (vnode\n+\t\t  && referenced_from_this_partition_p (&vnode->ref_list, set, vset));\n+\t}\n+      node = cgraph_get_node (p->decl);\n+      return (node\n+\t      && (referenced_from_this_partition_p (&node->ref_list, set, vset)\n+\t\t  || reachable_from_this_partition_p (node, set)));\n+    }\n+  else\n+    return symbol_alias_set_contains (defined, p->decl);\n+}\n \n /* Output any unreferenced global symbol defined in SET, alias pairs\n    and labels.  */\n@@ -2037,6 +2079,11 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n   alias_pair *p;\n   unsigned i;\n   struct varpool_node *vnode;\n+  symbol_alias_set_t *defined;\n+  struct sets setdata;\n+\n+  setdata.set = set;\n+  setdata.vset = vset;\n \n   ob = create_output_block (LTO_section_static_initializer);\n   ob->cgraph_node = NULL;\n@@ -2070,15 +2117,20 @@ output_unreferenced_globals (cgraph_node_set set, varpool_node_set vset)\n \n   output_zero (ob);\n \n+  /* We really need to propagate in both directoins:\n+     for normal aliases we propagate from first defined alias to\n+     all aliases defined based on it.  For weakrefs we propagate in\n+     the oposite direction.  */\n+  defined = propagate_aliases_backward (trivally_defined_alias, &setdata);\n+\n   /* Emit the alias pairs for the nodes in SET.  */\n   FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n-    {\n-      if (output_alias_pair_p (p, set, vset))\n-\t{\n-\t  lto_output_tree_ref (ob, p->decl);\n-\t  lto_output_tree_ref (ob, p->target);\n-\t}\n-    }\n+    if (output_alias_pair_p (p, defined, set, vset))\n+      {\n+\tlto_output_tree_ref (ob, p->decl);\n+\tlto_output_tree_ref (ob, p->target);\n+      }\n+  symbol_alias_set_destroy (defined);\n \n   output_zero (ob);\n \n@@ -2476,6 +2528,11 @@ produce_symtab (struct output_block *ob,\n   lto_cgraph_encoder_t encoder = ob->decl_state->cgraph_node_encoder;\n   int i;\n   alias_pair *p;\n+  struct sets setdata;\n+  symbol_alias_set_t *defined;\n+\n+  setdata.set = set;\n+  setdata.vset = vset;\n \n   lto_begin_section (section_name, false);\n   free (section_name);\n@@ -2553,9 +2610,11 @@ produce_symtab (struct output_block *ob,\n     }\n \n   /* Write all aliases.  */\n+  defined = propagate_aliases_backward (trivally_defined_alias, &setdata);\n   FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n-    if (output_alias_pair_p (p, set, vset))\n+    if (output_alias_pair_p (p, defined, set, vset))\n       write_symbol (cache, &stream, p->decl, seen, true);\n+  symbol_alias_set_destroy (defined);\n \n   lto_write_stream (&stream);\n   pointer_set_destroy (seen);"}, {"sha": "4cb66feedad8876b8346be0b7290158a620d0da7", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -1,3 +1,10 @@\n+2011-01-11  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/45721\n+\tPR lto/45375\n+\t* lto.c (partition_cgraph_node_p, partition_varpool_node_p): Weakrefs are\n+\tnot partitioned.\n+\n 2010-12-22  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* lto-lang.c (handle_nonnull_attribute, handle_sentinel_attribute):"}, {"sha": "cbc192a664493a7a0e8e042c4b30f9384db94fa9", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -837,6 +837,8 @@ partition_cgraph_node_p (struct cgraph_node *node)\n       || (DECL_COMDAT (node->decl)\n \t  && !cgraph_used_from_object_file_p (node)))\n     return false;\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->decl)))\n+    return false;\n   return true;\n }\n \n@@ -854,6 +856,8 @@ partition_varpool_node_p (struct varpool_node *vnode)\n \t  && !vnode->force_output\n \t  && !varpool_used_from_object_file_p (vnode)))\n     return false;\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->decl)))\n+    return false;\n   return true;\n }\n "}, {"sha": "090110e25906b5130894211afa776c3bf45bea05", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -144,6 +144,7 @@ rest_of_decl_compilation (tree decl,\n {\n   /* We deferred calling assemble_alias so that we could collect\n      other attributes such as visibility.  Emit the alias now.  */\n+  if (!in_lto_p)\n   {\n     tree alias;\n     alias = lookup_attribute (\"alias\", DECL_ATTRIBUTES (decl));"}, {"sha": "18a4873c9c16f19fec566e2ac9be3fdf814a4636", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -1,3 +1,10 @@\n+2011-01-11  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/45721\n+\tPR lto/45375\n+\t* testsuite/gcc.dg/lto/pr45721_1.c: New file.\n+\t* testsuite/gcc.dg/lto/pr45721_0.c: New file.\n+\n 2011-01-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/46076"}, {"sha": "0af1620e84976cc9c49c3cef05c033b1c96ef7c6", "filename": "gcc/testsuite/gcc.dg/lto/pr45721_0.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr45721_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr45721_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr45721_0.c?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-lto-do assemble }  */\n+void baz(void) {}\n+void *y = (void *)baz;\n+int main () { return 0; }\n+/* { dg-lto-do assemble }  */\n+void baz(void) {}\n+void *y = (void *)baz;\n+int main () { return 0; }"}, {"sha": "63cbfeff9fc8b0e4b7ff2b9c0b2d5763adb38d20", "filename": "gcc/testsuite/gcc.dg/lto/pr45721_1.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr45721_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr45721_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fpr45721_1.c?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -0,0 +1,4 @@\n+static void bar(void) __attribute__ ((weakref(\"baz\")));\n+void *x = (void *)bar;\n+static void bar(void) __attribute__ ((weakref(\"baz\")));\n+void *x = (void *)bar;"}, {"sha": "a49e3358275fa66db81305991ecd5b48fed2c849", "filename": "gcc/tree.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -5389,6 +5389,18 @@ extern void remove_unreachable_alias_pairs (void);\n extern bool decl_replaceable_p (tree);\n extern bool decl_binds_to_current_def_p (tree);\n \n+/* Derived type for use by compute_visible_aliases and callers.  A symbol\n+   alias set is a pointer set into which we enter IDENTIFIER_NODES bearing\n+   the canonicalised assembler-level symbol names corresponding to decls\n+   and their aliases.  */\n+typedef struct pointer_set_t symbol_alias_set_t;\n+\n+extern void symbol_alias_set_destroy (symbol_alias_set_t *);\n+extern int symbol_alias_set_contains (const symbol_alias_set_t *, tree);\n+extern symbol_alias_set_t * propagate_aliases_backward (bool (*)\n+\t\t\t\t\t\t\t (tree, tree, void *),\n+\t\t\t\t\t\t\tvoid *);\n+\n /* In stmt.c */\n extern void expand_computed_goto (tree);\n extern bool parse_output_constraint (const char **, int, int, int,"}, {"sha": "bbebd876bd08f729f7c642e3ca0ac6105605ffec", "filename": "gcc/varasm.c", "status": "modified", "additions": 101, "deletions": 45, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e701822708dbcd9ec935a536830a522d24f8151/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=6e701822708dbcd9ec935a536830a522d24f8151", "patch": "@@ -5504,12 +5504,6 @@ do_assemble_alias (tree decl, tree target)\n #endif\n }\n \n-/* Derived type for use by compute_visible_aliases and callers.  A symbol\n-   alias set is a pointer set into which we enter IDENTIFIER_NODES bearing\n-   the canonicalised assembler-level symbol names corresponding to decls\n-   and their aliases.  */\n-\n-typedef struct pointer_set_t symbol_alias_set_t;\n \n /* Allocate and construct a symbol alias set.  */\n \n@@ -5521,15 +5515,15 @@ symbol_alias_set_create (void)\n \n /* Destruct and free a symbol alias set.  */\n \n-static void\n+void\n symbol_alias_set_destroy (symbol_alias_set_t *aset)\n {\n   pointer_set_destroy (aset);\n }\n \n /* Test if a symbol alias set contains a given name.  */\n \n-static int\n+int\n symbol_alias_set_contains (const symbol_alias_set_t *aset, tree t)\n {\n   /* We accept either a DECL or an IDENTIFIER directly.  */\n@@ -5551,40 +5545,110 @@ symbol_alias_set_insert (symbol_alias_set_t *aset, tree t)\n   return pointer_set_insert (aset, t);\n }\n \n-/* Compute the set of indentifier nodes that is generated by aliases\n-   whose targets are reachable.  */\n+/* IN_SET_P is a predicate function assuming to be taken\n+   alias_pair->decl, alias_pair->target and DATA arguments.\n+\n+   Compute set of aliases by including everything where TRIVIALLY_VISIBLE\n+   predeicate is true and propagate across aliases such that when\n+   alias DECL is included, its TARGET is included too.  */\n \n static symbol_alias_set_t *\n-compute_visible_aliases (void)\n+propagate_aliases_forward (bool (*in_set_p)\n+\t\t\t     (tree decl, tree target, void *data),\n+\t\t           void *data)\n {\n-  symbol_alias_set_t *visible;\n+  symbol_alias_set_t *set;\n   unsigned i;\n   alias_pair *p;\n   bool changed;\n \n-  /* We have to compute the set of visible nodes including aliases\n+  set = symbol_alias_set_create ();\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n+    if (in_set_p (p->decl, p->target, data))\n+      symbol_alias_set_insert (set, p->decl);\n+  do\n+    {\n+      changed = false;\n+      for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n+\tif (symbol_alias_set_contains (set, p->decl)\n+\t    && !symbol_alias_set_insert (set, p->target))\n+\t  changed = true;\n+    }\n+  while (changed);\n+\n+  return set;\n+}\n+\n+/* Like propagate_aliases_forward but do backward propagation.  */\n+\n+symbol_alias_set_t *\n+propagate_aliases_backward (bool (*in_set_p)\n+\t\t\t     (tree decl, tree target, void *data),\n+\t\t           void *data)\n+{\n+  symbol_alias_set_t *set;\n+  unsigned i;\n+  alias_pair *p;\n+  bool changed;\n+\n+  /* We have to compute the set of set nodes including aliases\n      themselves.  */\n-  visible = symbol_alias_set_create ();\n+  set = symbol_alias_set_create ();\n+  for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n+    if (in_set_p (p->decl, p->target, data))\n+      symbol_alias_set_insert (set, p->target);\n   do\n     {\n       changed = false;\n       for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); ++i)\n-\t{\n-\t  struct cgraph_node *fnode = NULL;\n-\t  struct varpool_node *vnode = NULL;\n-\n-\t  fnode = cgraph_node_for_asm (p->target);\n-\t  vnode = (fnode == NULL) ? varpool_node_for_asm (p->target) : NULL;\n-\t  if ((fnode\n-\t       || vnode\n-\t       || symbol_alias_set_contains (visible, p->target))\n-\t      && !symbol_alias_set_insert (visible, p->decl))\n-\t    changed = true;\n-\t}\n+\tif (symbol_alias_set_contains (set, p->target)\n+\t    && !symbol_alias_set_insert (set, p->decl))\n+\t  changed = true;\n     }\n   while (changed);\n \n-  return visible;\n+  return set;\n+}\n+/* See if the alias is trivially visible.  This means\n+     1) alias is expoerted from the unit or\n+     2) alias is used in the code.\n+   We assume that unused cgraph/varpool nodes has been\n+   removed.\n+   Used as callback for propagate_aliases.  */\n+\n+static bool\n+trivially_visible_alias (tree decl, tree target ATTRIBUTE_UNUSED,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  struct cgraph_node *fnode = NULL;\n+  struct varpool_node *vnode = NULL;\n+\n+  if (!TREE_PUBLIC (decl))\n+    {\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\tfnode = cgraph_get_node (decl);\n+      else\n+\tvnode = varpool_get_node (decl);\n+      return vnode || fnode;\n+    }\n+  else\n+    return true;\n+}\n+\n+/* See if the target of alias is defined in this unit.\n+   Used as callback for propagate_aliases.  */\n+\n+static bool\n+trivially_defined_alias (tree decl ATTRIBUTE_UNUSED,\n+\t\t\t tree target,\n+\t\t\t void *data ATTRIBUTE_UNUSED)\n+{\n+  struct cgraph_node *fnode = NULL;\n+  struct varpool_node *vnode = NULL;\n+\n+  fnode = cgraph_node_for_asm (target);\n+  vnode = (fnode == NULL) ? varpool_node_for_asm (target) : NULL;\n+  return (fnode && fnode->analyzed) || (vnode && vnode->finalized);\n }\n \n /* Remove the alias pairing for functions that are no longer in the call\n@@ -5602,23 +5666,15 @@ remove_unreachable_alias_pairs (void)\n \n   /* We have to compute the set of visible nodes including aliases\n      themselves.  */\n-  visible = compute_visible_aliases ();\n+  visible = propagate_aliases_forward (trivially_visible_alias, NULL);\n \n   for (i = 0; VEC_iterate (alias_pair, alias_pairs, i, p); )\n     {\n-      if (!DECL_EXTERNAL (p->decl))\n+      if (!DECL_EXTERNAL (p->decl)\n+\t  && !symbol_alias_set_contains (visible, p->decl))\n \t{\n-\t  struct cgraph_node *fnode = NULL;\n-\t  struct varpool_node *vnode = NULL;\n-\t  fnode = cgraph_node_for_asm (p->target);\n-\t  vnode = (fnode == NULL) ? varpool_node_for_asm (p->target) : NULL;\n-\t  if (!fnode\n-\t      && !vnode\n-\t      && !symbol_alias_set_contains (visible, p->target))\n-\t    {\n-\t      VEC_unordered_remove (alias_pair, alias_pairs, i);\n-\t      continue;\n-\t    }\n+\t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n+\t  continue;\n \t}\n \n       i++;\n@@ -5634,16 +5690,16 @@ remove_unreachable_alias_pairs (void)\n void\n finish_aliases_1 (void)\n {\n-  symbol_alias_set_t *visible;\n+  symbol_alias_set_t *defined;\n   unsigned i;\n   alias_pair *p;\n \n   if (alias_pairs == NULL)\n     return;\n \n-  /* We have to compute the set of visible nodes including aliases\n+  /* We have to compute the set of defined nodes including aliases\n      themselves.  */\n-  visible = compute_visible_aliases ();\n+  defined = propagate_aliases_backward (trivially_defined_alias, NULL);\n \n   FOR_EACH_VEC_ELT (alias_pair, alias_pairs, i, p)\n     {\n@@ -5652,7 +5708,7 @@ finish_aliases_1 (void)\n       target_decl = find_decl_and_mark_needed (p->decl, p->target);\n       if (target_decl == NULL)\n \t{\n-\t  if (symbol_alias_set_contains (visible, p->target))\n+\t  if (symbol_alias_set_contains (defined, p->target))\n \t    continue;\n \n \t  if (! (p->emitted_diags & ALIAS_DIAG_TO_UNDEF)\n@@ -5678,7 +5734,7 @@ finish_aliases_1 (void)\n \t}\n     }\n \n-  symbol_alias_set_destroy (visible);\n+  symbol_alias_set_destroy (defined);\n }\n \n /* Second pass of completing pending aliases.  Emit the actual assembly."}]}