{"sha": "08ec56cb647b543c033b76d1447a83123fb94c3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhlYzU2Y2I2NDdiNTQzYzAzM2I3NmQxNDQ3YTgzMTIzZmI5NGMzZA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2004-03-17T17:54:33Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2004-03-17T17:54:33Z"}, "message": "* gcc.dg/torture/builtin-convert-1.c: New test.\n\nFrom-SVN: r79591", "tree": {"sha": "42fe84b2adda6bdd030129c30cbd5c7a7ed5bc72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42fe84b2adda6bdd030129c30cbd5c7a7ed5bc72"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08ec56cb647b543c033b76d1447a83123fb94c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ec56cb647b543c033b76d1447a83123fb94c3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08ec56cb647b543c033b76d1447a83123fb94c3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08ec56cb647b543c033b76d1447a83123fb94c3d/comments", "author": null, "committer": null, "parents": [{"sha": "d3daf7bbb28baa580689b8a1f5fe5b166e4f001a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3daf7bbb28baa580689b8a1f5fe5b166e4f001a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3daf7bbb28baa580689b8a1f5fe5b166e4f001a"}], "stats": {"total": 120, "additions": 120, "deletions": 0}, "files": [{"sha": "b2f0ee11ab96a2f58a152c69d8af130c2f9b0e91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ec56cb647b543c033b76d1447a83123fb94c3d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ec56cb647b543c033b76d1447a83123fb94c3d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08ec56cb647b543c033b76d1447a83123fb94c3d", "patch": "@@ -1,3 +1,7 @@\n+2004-03-17  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gcc.dg/torture/builtin-convert-1.c: New test.\n+\n 2004-03-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* gcc.dg/torture/builtin-integral-1.c: Also check for `rint'."}, {"sha": "d66d634071a398c03e75142d7284c1e65df93679", "filename": "gcc/testsuite/gcc.dg/torture/builtin-convert-1.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08ec56cb647b543c033b76d1447a83123fb94c3d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-convert-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08ec56cb647b543c033b76d1447a83123fb94c3d/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-convert-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-convert-1.c?ref=08ec56cb647b543c033b76d1447a83123fb94c3d", "patch": "@@ -0,0 +1,116 @@\n+/* Copyright (C) 2004  Free Software Foundation.\n+\n+   Verify that built-in math function conversion to smaller FP types\n+   is correctly performed by the compiler.\n+\n+   Written by Kaveh Ghazi, 2004-03-17.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-ffast-math\" } */\n+\n+#include \"../builtins-config.h\"\n+\n+/* This check is necessary when converting to a C99 function.  */\n+#ifdef HAVE_C99_RUNTIME\n+#define C99CODE(CODE) (CODE)\n+#define MAYBEC99(CODE, C99) (CODE)\n+#else\n+#define C99CODE(CODE) 0\n+#define MAYBEC99(CODE, C99) (!(C99) && (CODE))\n+#endif\n+\n+#define PROTOTYPE1(FN) extern double FN(double); extern float FN##f(float); \\\n+  extern long double FN##l(long double);\n+\n+void test(double d1, float f1, long double ld1)\n+{\n+  /* Test converting math builtins to narrower FP types based on a\n+     narrowing cast on the outside of the call.  MATHFN is the\n+     function to test, and C99 is 0/1 depending on whether the\n+     `double' version of MATHFN is a C99 function.  The optimization\n+     is only performed if the replacement function is actually\n+     narrower in width, so check that first.  */\n+#define OUTER_CAST1(MATHFN, C99) \\\n+ PROTOTYPE1 (MATHFN) \\\n+ extern void link_failure_outer_##MATHFN##l_##MATHFN##_1(void); \\\n+ extern void link_failure_outer_##MATHFN##l_##MATHFN##_2(void); \\\n+ extern void link_failure_outer_##MATHFN##l_##MATHFN##f_1(void); \\\n+ extern void link_failure_outer_##MATHFN##l_##MATHFN##f_2(void); \\\n+ extern void link_failure_outer_##MATHFN##_##MATHFN##f_1(void); \\\n+ extern void link_failure_outer_##MATHFN##_##MATHFN##f_2(void); \\\n+ if (sizeof (long double) > sizeof (double) \\\n+     && MAYBEC99 ((double) MATHFN##l((double)ld1) != MATHFN(ld1), C99)) \\\n+    link_failure_outer_##MATHFN##l_##MATHFN##_1(); \\\n+ if (sizeof (long double) > sizeof (double) \\\n+     && MAYBEC99 ((double) MATHFN##l(d1) != MATHFN(d1), C99)) \\\n+    link_failure_outer_##MATHFN##l_##MATHFN##_1(); \\\n+ if (sizeof (long double) > sizeof (double) \\\n+     && MAYBEC99 ((double) MATHFN##l(f1) != MATHFN(f1), C99)) \\\n+    link_failure_outer_##MATHFN##l_##MATHFN##_2(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && C99CODE ((float) MATHFN##l((float) ld1) != MATHFN##f(ld1))) \\\n+    link_failure_outer_##MATHFN##l_##MATHFN##f_1(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && C99CODE ((float) MATHFN##l((float) d1) != MATHFN##f(d1))) \\\n+    link_failure_outer_##MATHFN##l_##MATHFN##f_1(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && C99CODE ((float) MATHFN##l(f1) != MATHFN##f(f1))) \\\n+    link_failure_outer_##MATHFN##l_##MATHFN##f_2(); \\\n+ if (sizeof (double) > sizeof (float) \\\n+     && C99CODE ((float) MATHFN((float) ld1) != MATHFN##f(ld1))) \\\n+    link_failure_outer_##MATHFN##_##MATHFN##f_1(); \\\n+ if (sizeof (double) > sizeof (float) \\\n+     && C99CODE ((float) MATHFN((float) d1) != MATHFN##f(d1))) \\\n+    link_failure_outer_##MATHFN##_##MATHFN##f_1(); \\\n+ if (sizeof (double) > sizeof (float) \\\n+     && C99CODE ((float) MATHFN(f1) != MATHFN##f(f1))) \\\n+    link_failure_outer_##MATHFN##_##MATHFN##f_2()\n+\n+  /* Test converting math builtins to narrower FP types based on if\n+     the argument is a narrower type (perhaps implicitly) cast to a\n+     wider one.  */\n+#define INNER_CAST1(MATHFN, C99) \\\n+ PROTOTYPE1 (MATHFN) \\\n+ extern void link_failure_inner_##MATHFN##l_##MATHFN(void); \\\n+ extern void link_failure_inner_##MATHFN##l_##MATHFN##f(void); \\\n+ extern void link_failure_inner_##MATHFN##_##MATHFN##f(void); \\\n+ if (sizeof (long double) > sizeof (double) \\\n+     && MAYBEC99 (MATHFN##l(d1) != (long double) MATHFN(d1), C99)) \\\n+    link_failure_inner_##MATHFN##l_##MATHFN(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && C99CODE (MATHFN##l(f1) != (long double) MATHFN##f(f1))) \\\n+    link_failure_inner_##MATHFN##l_##MATHFN##f(); \\\n+ if (sizeof (long double) > sizeof (float) \\\n+     && C99CODE (MATHFN##l((double)f1) != (long double) MATHFN##f(f1))) \\\n+    link_failure_inner_##MATHFN##l_##MATHFN##f(); \\\n+ if (sizeof (double) > sizeof (float) \\\n+     && C99CODE (MATHFN(f1) != (double) MATHFN##f(f1))) \\\n+    link_failure_inner_##MATHFN##_##MATHFN##f()\n+\n+\n+#ifdef __OPTIMIZE__\n+  OUTER_CAST1 (cos, /*C99=*/ 0);\n+  OUTER_CAST1 (exp, /*C99=*/ 0);\n+  OUTER_CAST1 (log, /*C99=*/ 0);\n+  OUTER_CAST1 (sin, /*C99=*/ 0);\n+  OUTER_CAST1 (sqrt, /*C99=*/ 0);\n+\n+  INNER_CAST1 (ceil, /*C99=*/ 0);\n+  OUTER_CAST1 (ceil, /*C99=*/ 0);\n+  INNER_CAST1 (floor, /*C99=*/ 0);\n+  OUTER_CAST1 (floor, /*C99=*/ 0);\n+  INNER_CAST1 (nearbyint, /*C99=*/ 1);\n+  OUTER_CAST1 (nearbyint, /*C99=*/ 1);\n+  INNER_CAST1 (rint, /*C99=*/ 1);\n+  OUTER_CAST1 (rint, /*C99=*/ 1);\n+  INNER_CAST1 (round, /*C99=*/ 1);\n+  OUTER_CAST1 (round, /*C99=*/ 1);\n+  INNER_CAST1 (trunc, /*C99=*/ 1);\n+  OUTER_CAST1 (trunc, /*C99=*/ 1);\n+#endif /* __OPTIMIZE__ */\n+}\n+\n+int main (void)\n+{\n+  return 0;\n+}"}]}