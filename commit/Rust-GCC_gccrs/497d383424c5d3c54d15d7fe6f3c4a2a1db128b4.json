{"sha": "497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDk3ZDM4MzQyNGM1ZDNjNTRkMTVkN2ZlNmYzYzRhMmExZGIxMjhiNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2009-11-20T21:40:39Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2009-11-20T21:40:39Z"}, "message": "Undo part of 2009-10-23 change\n\nFrom-SVN: r154380", "tree": {"sha": "2ea2794fbe9e67c76c8dba67c1a37f47d9a485a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ea2794fbe9e67c76c8dba67c1a37f47d9a485a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/comments", "author": null, "committer": null, "parents": [{"sha": "2282976b05c99c73fff7d23cb1af92b07113f078", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2282976b05c99c73fff7d23cb1af92b07113f078", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2282976b05c99c73fff7d23cb1af92b07113f078"}], "stats": {"total": 111, "additions": 19, "deletions": 92}, "files": [{"sha": "0375dbe23e35b5f7874c090455d7a6c182bb37ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "patch": "@@ -1,3 +1,12 @@\n+2009-11-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/41787\n+\t* config/rs6000/rs6000.c (struct machine_function): Revert\n+\t2009-10-23 change to set VRSAVE to non-0 if we use VSX.\n+\t(rs6000_expand_to_rtl_hook): Ditto.\n+\t(rs6000_check_vector_mode): Ditto.\n+\t(compute_vrsave_mask): Ditto.\n+\n 2009-11-20  Paul Brook  <paul@codesourcery.com>\n \n \t* doc/invoke.texi: Document ARM -mcpu=cortex-a5."}, {"sha": "9b03a9bfe68b0d0bd400b474456bc7fe3604249e", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 72, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "patch": "@@ -130,8 +130,6 @@ typedef struct GTY(()) machine_function\n      64-bits wide and is allocated early enough so that the offset\n      does not overflow the 16-bit load/store offset field.  */\n   rtx sdmode_stack_slot;\n-  /* True if any VSX or ALTIVEC vector type was used.  */\n-  bool vsx_or_altivec_used_p;\n } machine_function;\n \n /* Target cpu type */\n@@ -915,7 +913,7 @@ static void rs6000_elf_encode_section_info (tree, rtx, int)\n      ATTRIBUTE_UNUSED;\n #endif\n static bool rs6000_use_blocks_for_constant_p (enum machine_mode, const_rtx);\n-static void rs6000_expand_to_rtl_hook (void);\n+static void rs6000_alloc_sdmode_stack_slot (void);\n static void rs6000_instantiate_decls (void);\n #if TARGET_XCOFF\n static void rs6000_xcoff_asm_output_anchor (rtx);\n@@ -1507,7 +1505,7 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #define TARGET_BUILTIN_RECIPROCAL rs6000_builtin_reciprocal\n \n #undef TARGET_EXPAND_TO_RTL_HOOK\n-#define TARGET_EXPAND_TO_RTL_HOOK rs6000_expand_to_rtl_hook\n+#define TARGET_EXPAND_TO_RTL_HOOK rs6000_alloc_sdmode_stack_slot\n \n #undef TARGET_INSTANTIATE_DECLS\n #define TARGET_INSTANTIATE_DECLS rs6000_instantiate_decls\n@@ -13192,38 +13190,6 @@ rs6000_check_sdmode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n   return NULL_TREE;\n }\n \n-static tree\n-rs6000_check_vector_mode (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n-{\n-  /* Don't walk into types.  */\n-  if (*tp == NULL_TREE || *tp == error_mark_node || TYPE_P (*tp))\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  switch (TREE_CODE (*tp))\n-    {\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case FIELD_DECL:\n-    case RESULT_DECL:\n-    case SSA_NAME:\n-    case REAL_CST:\n-    case INDIRECT_REF:\n-    case ALIGN_INDIRECT_REF:\n-    case MISALIGNED_INDIRECT_REF:\n-    case VIEW_CONVERT_EXPR:\n-      if (VECTOR_MODE_P (TYPE_MODE (TREE_TYPE (*tp))))\n-\treturn *tp;\n-      break;\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n enum reload_reg_type {\n   GPR_REGISTER_TYPE,\n   VECTOR_REGISTER_TYPE,\n@@ -13664,42 +13630,18 @@ rs6000_ira_cover_classes (void)\n   return (TARGET_VSX) ? cover_vsx : cover_pre_vsx;\n }\n \n-/* Scan the trees looking for certain types.\n-\n-   Allocate a 64-bit stack slot to be used for copying SDmode values through if\n-   this function has any SDmode references.\n-\n-   If VSX, note whether any vector operation was done so we can set VRSAVE to\n-   non-zero, even if we just use the floating point registers to tell the\n-   kernel to save the vector registers.  */\n+/* Allocate a 64-bit stack slot to be used for copying SDmode\n+   values through if this function has any SDmode references.  */\n \n static void\n-rs6000_expand_to_rtl_hook (void)\n+rs6000_alloc_sdmode_stack_slot (void)\n {\n   tree t;\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n \n   gcc_assert (cfun->machine->sdmode_stack_slot == NULL_RTX);\n \n-  /* Check for vectors.  */\n-  if (TARGET_VSX)\n-    {\n-      FOR_EACH_BB (bb)\n-\tfor (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  {\n-\t    if (walk_gimple_op (gsi_stmt (gsi), rs6000_check_vector_mode,\n-\t\t\t\tNULL))\n-\t      {\n-\t\tcfun->machine->vsx_or_altivec_used_p = true;\n-\t\tgoto found_vector;\n-\t      }\n-\t  }\n-    found_vector:\n-      ;\n-    }\n-\n-  /* Check for SDmode being used.  */\n   FOR_EACH_BB (bb)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n@@ -16841,15 +16783,6 @@ compute_vrsave_mask (void)\n     if (df_regs_ever_live_p (i))\n       mask |= ALTIVEC_REG_BIT (i);\n \n-  /* If VSX is used, we might have used a traditional floating point register\n-     in a vector mode without using any altivec registers.  However the VRSAVE\n-     register does not have room to indicate the floating point registers.\n-     Modern kernels only look to see if the value is non-zero to determine if\n-     they need to save the vector registers, so we just set an arbitrary\n-     value if any vector type was used.  */\n-  if (mask == 0 && TARGET_VSX && cfun->machine->vsx_or_altivec_used_p)\n-    mask = 0xFFF;\n-\n   if (mask == 0)\n     return mask;\n "}, {"sha": "1af8b0ff2417f6d72bca59c8c305d478d179fb0b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/497d383424c5d3c54d15d7fe6f3c4a2a1db128b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=497d383424c5d3c54d15d7fe6f3c4a2a1db128b4", "patch": "@@ -1,3 +1,8 @@\n+2009-11-20  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc/testsuite/gcc.target/powerpc/vsx-vrsave.c: Delete,\n+\t2009-10-23 change to set VRSAVE if VSX has been reverted.\n+\n 2009-11-20  Simon Martin  <simartin@users.sourceforge.net>\n \n \tPR c++/38646"}, {"sha": "83125f67fcc64fe0bd8b32e4aeb20e0062eaa780", "filename": "gcc/testsuite/gcc.target/powerpc/vsx-vrsave.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2282976b05c99c73fff7d23cb1af92b07113f078/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vrsave.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2282976b05c99c73fff7d23cb1af92b07113f078/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vrsave.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fvsx-vrsave.c?ref=2282976b05c99c73fff7d23cb1af92b07113f078", "patch": "@@ -1,20 +0,0 @@\n-/* { dg-do compile { target { powerpc*-*-* } } } */\n-/* { dg-skip-if \"\" { powerpc*-*-darwin* } { \"*\" } { \"\" } } */\n-/* { dg-require-effective-target powerpc_vsx_ok } */\n-/* { dg-options \"-O2 -mcpu=power7\" } */\n-/* { dg-final { scan-assembler-times \"mtvrsave\" 2 } } */\n-\n-/* Check whether VRSAVE is set to non-zero if VSX vector operations were\n-   used, but it should not be set if there are no vector operations.  */\n-\n-void\n-generates_vrsave (vector double *a, vector double *b, vector double *c)\n-{\n-  *a = *b + *c;\n-}\n-\n-void\n-no_vrsave (double *a, double *b, double *c)\n-{\n-  *a = *b + *c;\n-}"}]}