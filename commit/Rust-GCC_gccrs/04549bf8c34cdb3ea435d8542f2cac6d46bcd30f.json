{"sha": "04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ1NDliZjhjMzRjZGIzZWE0MzVkODU0MmYyY2FjNmQ0NmJjZDMwZg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-15T15:16:55Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-09-15T15:27:21Z"}, "message": "Fix bug when calling method from generic reciever type-bound\n\nWhen we have a generic function with a specified type bound, this means the\nmethod resolution can only resolve this to the trait item. During code\ngeneration we must then monomorphize this and lookup the associated impl\nblock item for this trait (if it exists) and call this function.\n\nFixes #678", "tree": {"sha": "49df4a8cb24256fa97180bcd464a0cd5ba71f0ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49df4a8cb24256fa97180bcd464a0cd5ba71f0ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4493f1c927c79e5b0933d26e9597044790c22f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4493f1c927c79e5b0933d26e9597044790c22f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4493f1c927c79e5b0933d26e9597044790c22f12"}], "stats": {"total": 64, "additions": 58, "deletions": 6}, "files": [{"sha": "f0e26dc9b44e53727ef39ff5754d184f1a10f58d", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-dot-operator.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -171,10 +172,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t  // item so its up to us to figure out if this path should resolve\n \t  // to an trait-impl-block-item or if it can be defaulted to the\n \t  // trait-impl-item's definition\n+\n+\t  auto root = receiver->get_root ();\n \t  std::vector<Resolver::PathProbeCandidate> candidates\n \t    = Resolver::PathProbeType::Probe (\n-\t      receiver, expr.get_method_name ().get_segment (), true, false,\n-\t      true);\n+\t      root, expr.get_method_name ().get_segment (), true, false, true);\n \n \t  if (candidates.size () == 0)\n \t    {\n@@ -186,6 +188,11 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t      rust_assert (ok);\t\t\t\t    // found\n \t      rust_assert (trait_item_ref->is_optional ()); // has definition\n \n+\t      // FIXME Optional means it has a definition and an associated\n+\t      // block which can be a default implementation, if it does not\n+\t      // contain an implementation we should actually return\n+\t      // error_mark_node\n+\n \t      TyTy::BaseType *self_type = nullptr;\n \t      if (!ctx->get_tyctx ()->lookup_type (\n \t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n@@ -209,10 +216,19 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t    }\n \t  else\n \t    {\n-\t      Resolver::PathProbeCandidate &candidate = candidates.at (0);\n-\t      rust_assert (candidate.is_impl_candidate ());\n-\n-\t      HIR::ImplItem *impl_item = candidate.item.impl.impl_item;\n+\t      std::vector<Resolver::Adjustment> adjustments;\n+\t      Resolver::PathProbeCandidate *candidate\n+\t\t= Resolver::MethodResolution::Select (candidates, root,\n+\t\t\t\t\t\t      adjustments);\n+\n+\t      // FIXME this will be a case to return error_mark_node, there is\n+\t      // an error scenario where a Trait Foo has a method Bar, but this\n+\t      // receiver does not implement this trait or has an incompatible\n+\t      // implementation and we should just return error_mark_node\n+\t      rust_assert (candidate != nullptr);\n+\t      rust_assert (candidate->is_impl_candidate ());\n+\n+\t      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n \n \t      TyTy::BaseType *self_type = nullptr;\n \t      if (!ctx->get_tyctx ()->lookup_type ("}, {"sha": "8c9b7409c2063363a0d6a9d11acc7f47418a634c", "filename": "gcc/testsuite/rust/execute/torture/trait4.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04549bf8c34cdb3ea435d8542f2cac6d46bcd30f/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait4.rs?ref=04549bf8c34cdb3ea435d8542f2cac6d46bcd30f", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-output \"123\\n\" }*/\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn type_bound<T: Bar>(t: &T) {\n+    t.baz();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+\n+    a = &Foo(123);\n+    type_bound(a);\n+\n+    0\n+}"}]}