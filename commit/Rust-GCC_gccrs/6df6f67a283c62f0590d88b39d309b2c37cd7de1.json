{"sha": "6df6f67a283c62f0590d88b39d309b2c37cd7de1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRmNmY2N2EyODNjNjJmMDU5MGQ4OGIzOWQzMDliMmMzN2NkN2RlMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-17T17:50:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-05-17T17:50:55Z"}, "message": "re PR fortran/54613 ([F08] Add FINDLOC plus support MAXLOC/MINLOC with KIND=/BACK=)\n\n\tPR fortran/54613\n\t* gfortran.map (GFORTRAN_9.2): Export _gfortran_{,m,s}findloc{0,1}_r10.\n\t* Makefile.am (i_findloc0_c): Add $(srcdir)/generated/findloc0_r10.c.\n\t(i_findloc1_c): Add $(srcdir)/generated/findloc1_r10.c.\n\t* Makefile.in: Regenerated.\n\t* generated/findloc0_r10.c: Generated.\n\t* generated/findloc1_r10.c: Generated.\n\nFrom-SVN: r271336", "tree": {"sha": "a90848dc8ec8695aed6657f3905b174eb4b38f17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a90848dc8ec8695aed6657f3905b174eb4b38f17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6df6f67a283c62f0590d88b39d309b2c37cd7de1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df6f67a283c62f0590d88b39d309b2c37cd7de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6df6f67a283c62f0590d88b39d309b2c37cd7de1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6df6f67a283c62f0590d88b39d309b2c37cd7de1/comments", "author": null, "committer": null, "parents": [{"sha": "9f65885a938c6efe5365ae63ff246115baa263cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f65885a938c6efe5365ae63ff246115baa263cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f65885a938c6efe5365ae63ff246115baa263cc"}], "stats": {"total": 898, "additions": 898, "deletions": 0}, "files": [{"sha": "747ca3cf6fa5df0728f19b61ec9f49cefa4e04c6", "filename": "libgfortran/generated/findloc0_r10.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df6f67a283c62f0590d88b39d309b2c37cd7de1/libgfortran%2Fgenerated%2Ffindloc0_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df6f67a283c62f0590d88b39d309b2c37cd7de1/libgfortran%2Fgenerated%2Ffindloc0_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc0_r10.c?ref=6df6f67a283c62f0590d88b39d309b2c37cd7de1", "patch": "@@ -0,0 +1,375 @@\n+\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_10)\n+extern void findloc0_r10 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t\t\t GFC_LOGICAL_4);\n+export_proto(findloc0_r10);\n+\n+void\n+findloc0_r10 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_10 *base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t\"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      n++;\n+\t      if (n >= rank)\n+\t        return;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n] * 1;\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void mfindloc0_r10 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t\t\t gfc_array_l1 *const restrict, GFC_LOGICAL_4);\n+export_proto(mfindloc0_r10);\n+\n+void\n+mfindloc0_r10 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t    gfc_array_l1 *const restrict mask, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride;\n+  const GFC_REAL_10 *base;\n+  index_type * restrict dest;\n+  GFC_LOGICAL_1 *mbase;\n+  index_type rank;\n+  index_type n;\n+  int mask_kind;\n+  index_type sz;\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+  if (rank <= 0)\n+    runtime_error (\"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else\n+    {\n+      if (unlikely (compile_options.bounds_check))\n+\t{\n+\t  bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t\t  \"FINDLOC\");\n+\t  bounds_equal_extents ((array_t *) mask, (array_t *) array,\n+\t\t\t\t\"MASK argument\", \"FINDLOC\");\n+\t}\n+    }\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  mbase = mask->base_addr;\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+\n+  /* Set the return value.  */\n+  for (n = 0; n < rank; n++)\n+    dest[n * dstride] = 0;\n+\n+  sz = 1;\n+  for (n = 0; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+      sz *= extent[n];\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+    for (n = 0; n < rank; n++)\n+      count[n] = 0;\n+\n+  if (back)\n+    {\n+      base = array->base_addr + (sz - 1) * 1;\n+      mbase = mbase + (sz - 1) * mask_kind;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = extent[n] - count[n];\n+\n+\t\t  return;\n+\t\t}\n+\t      base -= sstride[0] * 1;\n+\t      mbase -= mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base += sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base -= sstride[n] * 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);      \n+\t}\n+    }\n+  else\n+    {\n+      base = array->base_addr;\n+      while (1)\n+        {\n+\t  do\n+\t    {\n+\t      if (unlikely(*mbase && *base == value))\n+\t        {\n+\t\t  for (n = 0; n < rank; n++)\n+\t\t    dest[n * dstride] = count[n] + 1;\n+\n+\t\t  return;\n+\t\t}\n+\t      base += sstride[0] * 1;\n+\t      mbase += mstride[0];\n+\t    } while(++count[0] != extent[0]);\n+\n+\t  n = 0;\n+\t  do\n+\t    {\n+\t      /* When we get to the end of a dimension, reset it and increment\n+\t\t the next dimension.  */\n+\t      count[n] = 0;\n+\t      /* We could precalculate these products, but this is a less\n+\t\t frequently used path so probably not worth it.  */\n+\t      base -= sstride[n] * extent[n] * 1;\n+\t      mbase -= mstride[n] * extent[n];\n+\t      n++;\n+\t      if (n >= rank)\n+\t\treturn;\n+\t      else\n+\t\t{\n+\t\t  count[n]++;\n+\t\t  base += sstride[n]* 1;\n+\t\t  mbase += mstride[n];\n+\t\t}\n+\t    } while (count[n] == extent[n]);\n+\t}\n+    }\n+  return;\n+}\n+\n+extern void sfindloc0_r10 (gfc_array_index_type * const restrict retarray,\n+       \t    \t\tgfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t\t\t GFC_LOGICAL_4 *, GFC_LOGICAL_4);\n+export_proto(sfindloc0_r10);\n+\n+void\n+sfindloc0_r10 (gfc_array_index_type * const restrict retarray,\n+    \t    gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t    GFC_LOGICAL_4 * mask, GFC_LOGICAL_4 back)\n+{\n+  index_type rank;\n+  index_type dstride;\n+  index_type * restrict dest;\n+  index_type n;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc0_r10 (retarray, array, value, back);\n+      return;\n+    }\n+\n+  rank = GFC_DESCRIPTOR_RANK (array);\n+\n+  if (rank <= 0)\n+    internal_error (NULL, \"Rank of array needs to be > 0\");\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      GFC_DIMENSION_SET(retarray->dim[0], 0, rank-1, 1);\n+      retarray->dtype.rank = 1;\n+      retarray->offset = 0;\n+      retarray->base_addr = xmallocarray (rank, sizeof (index_type));\n+    }\n+  else if (unlikely (compile_options.bounds_check))\n+    {\n+       bounds_iforeach_return ((array_t *) retarray, (array_t *) array,\n+\t\t\t       \"FINDLOC\");\n+    }\n+\n+  dstride = GFC_DESCRIPTOR_STRIDE(retarray,0);\n+  dest = retarray->base_addr;\n+  for (n = 0; n<rank; n++)\n+    dest[n * dstride] = 0 ;\n+}\n+\n+#endif"}, {"sha": "933a66ece87484664b5abc2204e6f67dd6e230b8", "filename": "libgfortran/generated/findloc1_r10.c", "status": "added", "additions": 523, "deletions": 0, "changes": 523, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6df6f67a283c62f0590d88b39d309b2c37cd7de1/libgfortran%2Fgenerated%2Ffindloc1_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6df6f67a283c62f0590d88b39d309b2c37cd7de1/libgfortran%2Fgenerated%2Ffindloc1_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Ffindloc1_r10.c?ref=6df6f67a283c62f0590d88b39d309b2c37cd7de1", "patch": "@@ -0,0 +1,523 @@\n+/* Implementation of the FINDLOC intrinsic\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+   Contributed by Thomas K\u00f6nig <tk@tkoenig.net>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 3 of the License, or (at your option) any later version.\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libgfortran.h\"\n+#include <assert.h>\n+\n+#if defined (HAVE_GFC_REAL_10)\n+extern void findloc1_r10 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 back);\n+export_proto(findloc1_r10);\n+\n+extern void\n+findloc1_r10 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_10 * restrict base;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type dim;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_10 * restrict src;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  for (n = len; n > 0; n--, src -= delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  for (n = 1; n <= len; n++, src += delta * 1)\n+\t    {\n+\t      if (*src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void mfindloc1_r10 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t\t\t const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(mfindloc1_r10);\n+\n+extern void\n+mfindloc1_r10 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t    const index_type * restrict pdim, gfc_array_l1 *const restrict mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type mstride[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  const GFC_REAL_10 * restrict base;\n+  const GFC_LOGICAL_1 * restrict mbase;\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type delta;\n+  index_type mdelta;\n+  index_type dim;\n+  int mask_kind;\n+  int continue_loop;\n+\n+  /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  delta = GFC_DESCRIPTOR_STRIDE(array,dim);\n+  mdelta = GFC_DESCRIPTOR_STRIDE_BYTES(mask,dim);\n+\n+  mbase = mask->base_addr;\n+\n+  mask_kind = GFC_DESCRIPTOR_SIZE (mask);\n+\n+  if (mask_kind == 1 || mask_kind == 2 || mask_kind == 4 || mask_kind == 8\n+#ifdef HAVE_GFC_LOGICAL_16\n+      || mask_kind == 16\n+#endif\n+      )\n+    mbase = GFOR_POINTER_TO_L1 (mbase, mask_kind);\n+  else\n+    internal_error (NULL, \"Funny sized logical array\");\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array,n);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask,n);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+  for (n = dim; n < rank; n++)\n+    {\n+      sstride[n] = GFC_DESCRIPTOR_STRIDE(array, n + 1);\n+      mstride[n] = GFC_DESCRIPTOR_STRIDE_BYTES(mask, n + 1);\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array, n + 1);\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+    }\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  base = array->base_addr;\n+  while (continue_loop)\n+    {\n+      const GFC_REAL_10 * restrict src;\n+      const GFC_LOGICAL_1 * restrict msrc;\n+      index_type result;\n+\n+      result = 0;\n+      if (back)\n+\t{\n+\t  src = base + (len - 1) * delta * 1;\n+\t  msrc = mbase + (len - 1) * mdelta; \n+\t  for (n = len; n > 0; n--, src -= delta * 1, msrc -= mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  src = base;\n+\t  msrc = mbase;\n+\t  for (n = 1; n <= len; n++, src += delta * 1, msrc += mdelta)\n+\t    {\n+\t      if (*msrc && *src == value)\n+\t\t{\n+\t\t  result = n;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      *dest = result;\n+\n+      count[0]++;\n+      base += sstride[0] * 1;\n+      mbase += mstride[0];\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  base -= sstride[n] * extent[n] * 1;\n+\t  mbase -= mstride[n] * extent[n];\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      base += sstride[n] * 1;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+extern void sfindloc1_r10 (gfc_array_index_type * const restrict retarray,\n+\t\t         gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t\t\t const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict mask,\n+\t\t\t GFC_LOGICAL_4 back);\n+export_proto(sfindloc1_r10);\n+\n+extern void\n+sfindloc1_r10 (gfc_array_index_type * const restrict retarray,\n+\t    gfc_array_r10 * const restrict array, GFC_REAL_10 value,\n+\t    const index_type * restrict pdim, GFC_LOGICAL_4 *const restrict  mask,\n+\t    GFC_LOGICAL_4 back)\n+{\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dstride[GFC_MAX_DIMENSIONS];\n+  index_type * restrict dest;\n+  index_type rank;\n+  index_type n;\n+  index_type len;\n+  index_type dim;\n+  bool continue_loop;\n+\n+  if (mask == NULL || *mask)\n+    {\n+      findloc1_r10 (retarray, array, value, pdim, back);\n+      return;\n+    }\n+    /* Make dim zero based to avoid confusion.  */\n+  rank = GFC_DESCRIPTOR_RANK (array) - 1;\n+  dim = (*pdim) - 1;\n+\n+  if (unlikely (dim < 0 || dim > rank))\n+    {\n+      runtime_error (\"Dim argument incorrect in FINDLOC intrinsic: \"\n+ \t\t     \"is %ld, should be between 1 and %ld\",\n+\t\t     (long int) dim + 1, (long int) rank + 1);\n+    }\n+\n+  len = GFC_DESCRIPTOR_EXTENT(array,dim);\n+  if (len < 0)\n+    len = 0;\n+\n+  for (n = 0; n < dim; n++)\n+    {\n+      extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+  for (n = dim; n < rank; n++)\n+    {\n+      extent[n] =\n+\tGFC_DESCRIPTOR_EXTENT(array,n + 1);\n+\n+      if (extent[n] <= 0)\n+\textent[n] = 0;\n+    }\n+\n+\n+  if (retarray->base_addr == NULL)\n+    {\n+      size_t alloc_size, str;\n+\n+      for (n = 0; n < rank; n++)\n+\t{\n+\t  if (n == 0)\n+\t    str = 1;\n+\t  else\n+\t    str = GFC_DESCRIPTOR_STRIDE(retarray,n-1) * extent[n-1];\n+\n+\t  GFC_DIMENSION_SET(retarray->dim[n], 0, extent[n] - 1, str);\n+\t}\n+\n+      retarray->offset = 0;\n+      retarray->dtype.rank = rank;\n+\n+      alloc_size = GFC_DESCRIPTOR_STRIDE(retarray,rank-1) * extent[rank-1];\n+\n+      retarray->base_addr = xmallocarray (alloc_size, sizeof (index_type));\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  GFC_DIMENSION_SET(retarray->dim[0], 0, -1, 1);\n+\t  return;\n+\t}\n+    }\n+  else\n+    {\n+      if (rank != GFC_DESCRIPTOR_RANK (retarray))\n+\truntime_error (\"rank of return array incorrect in\"\n+\t\t       \" FINDLOC intrinsic: is %ld, should be %ld\",\n+\t\t       (long int) (GFC_DESCRIPTOR_RANK (retarray)),\n+\t\t       (long int) rank);\n+\n+      if (unlikely (compile_options.bounds_check))\n+\tbounds_ifunction_return ((array_t *) retarray, extent,\n+\t\t\t\t \"return value\", \"FINDLOC\");\n+    }\n+\n+  for (n = 0; n < rank; n++)\n+    {\n+      count[n] = 0;\n+      dstride[n] = GFC_DESCRIPTOR_STRIDE(retarray,n);\n+      if (extent[n] <= 0)\n+\treturn;\n+    }\n+  dest = retarray->base_addr;\n+  continue_loop = 1;\n+\n+  while (continue_loop)\n+    {\n+      *dest = 0;\n+\n+      count[0]++;\n+      dest += dstride[0];\n+      n = 0;\n+      while (count[n] == extent[n])\n+\t{\n+\t  count[n] = 0;\n+\t  dest -= dstride[n] * extent[n];\n+\t  n++;\n+\t  if (n >= rank)\n+\t    {\n+\t      continue_loop = 0;\n+\t      break;\n+\t    }\n+\t  else\n+\t    {\n+\t      count[n]++;\n+\t      dest += dstride[n];\n+\t    }\n+\t}\n+    }\n+}\n+#endif"}]}