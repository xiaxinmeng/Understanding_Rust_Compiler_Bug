{"sha": "c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI3MjNiZGViMGQ0ZTJlZDMyOWZlZjFiNTRhY2Y3NDQxMGM0ZGU2Mw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2012-04-18T12:25:17Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-04-18T12:25:17Z"}, "message": "re PR tree-optimization/52976 (Revision 186384 breaks the polyhedron tests aermod.f90 and doduc.f90 at -O3 -ffast-math)\n\ngcc:\n\n2012-04-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/52976\n\t* tree-ssa-reassoc.c (stmt_is_power_of_op): New function.\n\t(decrement_power): Likewise.\n\t(propagate_op_to_single_use): Likewise.\n\t(zero_one_operation): Handle __builtin_pow* calls in linearized\n\texpression trees; factor logic into propagate_op_to_single_use.\n\t(undistribute_ops_list): Allow operands with repeat counts > 1.\n\n\ngcc/testsuite:\n\n2012-04-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\tPR tree-optimization/52976\n\tgfortran.dg/reassoc_7.f: New test.\n\tgfortran.dg/reassoc_8.f: Likewise.\n\tgfortran.dg/reassoc_9.f: Likewise.\n\tgfortran.dg/reassoc_10.f: Likewise.\n\nFrom-SVN: r186567", "tree": {"sha": "24f945ec17043bf3649ef743ced01d53a287b3e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24f945ec17043bf3649ef743ced01d53a287b3e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03fd03d5bcb647dac06dd8e30a4660d4621e1d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03fd03d5bcb647dac06dd8e30a4660d4621e1d2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03fd03d5bcb647dac06dd8e30a4660d4621e1d2e"}], "stats": {"total": 223, "additions": 205, "deletions": 18}, "files": [{"sha": "46cf8e4834617922be08efebb2460a1a72c98bff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -1,3 +1,13 @@\n+2012-04-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/52976\n+\t* tree-ssa-reassoc.c (stmt_is_power_of_op): New function.\n+\t(decrement_power): Likewise.\n+\t(propagate_op_to_single_use): Likewise.\n+\t(zero_one_operation): Handle __builtin_pow* calls in linearized\n+\texpression trees; factor logic into propagate_op_to_single_use.\n+\t(undistribute_ops_list): Allow operands with repeat counts > 1.\n+\n 2012-04-18  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/44688"}, {"sha": "8c8202e6b46544e34b3615fcc149d4948dd70e8f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -1,3 +1,11 @@\n+2012-04-18  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/52976\n+\tgfortran.dg/reassoc_7.f: New test.\n+\tgfortran.dg/reassoc_8.f: Likewise.\n+\tgfortran.dg/reassoc_9.f: Likewise.\n+\tgfortran.dg/reassoc_10.f: Likewise.\n+\n 2012-04-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/52422"}, {"sha": "698e2c49bb47af1b53a8ff289e415231b1f9da4e", "filename": "gcc/testsuite/gfortran.dg/reassoc_10.f", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_10.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_10.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_10.f?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+\n+      SUBROUTINE S55199(P,Q,Dvdph)\n+      implicit none\n+      real(8) :: c1,c2,c3,P,Q,Dvdph\n+      c1=0.1d0\n+      c2=0.2d0\n+      c3=0.3d0\n+      Dvdph = c1 + 2.*P*c2 + 3.*P**2*Q**3*c3\n+      END\n+\n+! There should be five multiplies following un-distribution\n+! and power expansion.\n+\n+! { dg-final { scan-tree-dump-times \" \\\\\\* \" 5 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "4f70ef6f9dd0cd51aedaff445a66277f4e9715dd", "filename": "gcc/testsuite/gfortran.dg/reassoc_7.f", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_7.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_7.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_7.f?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+\n+      SUBROUTINE S55199(P,Dvdph)\n+      implicit none\n+      real(8) :: c1,c2,c3,P,Dvdph\n+      c1=0.1d0\n+      c2=0.2d0\n+      c3=0.3d0\n+      Dvdph = c1 + 2.*P*c2 + 3.*P**2*c3\n+      END\n+\n+! There should be two multiplies following un-distribution.\n+\n+! { dg-final { scan-tree-dump-times \" \\\\\\* \" 2 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "4a6ea72f220f251e4a997fa5f95ed4f78804be10", "filename": "gcc/testsuite/gfortran.dg/reassoc_8.f", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_8.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_8.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_8.f?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+\n+      SUBROUTINE S55199(P,Dvdph)\n+      implicit none\n+      real(8) :: c1,c2,c3,P,Dvdph\n+      c1=0.1d0\n+      c2=0.2d0\n+      c3=0.3d0\n+      Dvdph = c1 + 2.*P**2*c2 + 3.*P**3*c3\n+      END\n+\n+! There should be three multiplies following un-distribution\n+! and power expansion.\n+\n+! { dg-final { scan-tree-dump-times \" \\\\\\* \" 3 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "53950ee9bc91f5066c74ed134a7cf217e1f66de2", "filename": "gcc/testsuite/gfortran.dg/reassoc_9.f", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_9.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_9.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_9.f?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! { dg-options \"-O3 -ffast-math -fdump-tree-optimized\" }\n+\n+      SUBROUTINE S55199(P,Dvdph)\n+      implicit none\n+      real(8) :: c1,c2,c3,P,Dvdph\n+      c1=0.1d0\n+      c2=0.2d0\n+      c3=0.3d0\n+      Dvdph = c1 + 2.*P**2*c2 + 3.*P**4*c3\n+      END\n+\n+! There should be three multiplies following un-distribution\n+! and power expansion.\n+\n+! { dg-final { scan-tree-dump-times \" \\\\\\* \" 3 \"optimized\" } }\n+! { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "314b8041d9ba2a7635c6e5d70ccc3592d48b1477", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 120, "deletions": 18, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2723bdeb0d4e2ed329fef1b54acf74410c4de63/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=c2723bdeb0d4e2ed329fef1b54acf74410c4de63", "patch": "@@ -1020,6 +1020,98 @@ oecount_cmp (const void *p1, const void *p2)\n     return c1->id - c2->id;\n }\n \n+/* Return TRUE iff STMT represents a builtin call that raises OP\n+   to some exponent.  */\n+\n+static bool\n+stmt_is_power_of_op (gimple stmt, tree op)\n+{\n+  tree fndecl;\n+\n+  if (!is_gimple_call (stmt))\n+    return false;\n+\n+  fndecl = gimple_call_fndecl (stmt);\n+\n+  if (!fndecl\n+      || DECL_BUILT_IN_CLASS (fndecl) != BUILT_IN_NORMAL)\n+    return false;\n+\n+  switch (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)))\n+    {\n+    CASE_FLT_FN (BUILT_IN_POW):\n+    CASE_FLT_FN (BUILT_IN_POWI):\n+      return (operand_equal_p (gimple_call_arg (stmt, 0), op, 0));\n+      \n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Given STMT which is a __builtin_pow* call, decrement its exponent\n+   in place and return the result.  Assumes that stmt_is_power_of_op\n+   was previously called for STMT and returned TRUE.  */\n+\n+static HOST_WIDE_INT\n+decrement_power (gimple stmt)\n+{\n+  REAL_VALUE_TYPE c, cint;\n+  HOST_WIDE_INT power;\n+  tree arg1;\n+\n+  switch (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)))\n+    {\n+    CASE_FLT_FN (BUILT_IN_POW):\n+      arg1 = gimple_call_arg (stmt, 1);\n+      c = TREE_REAL_CST (arg1);\n+      power = real_to_integer (&c) - 1;\n+      real_from_integer (&cint, VOIDmode, power, 0, 0);\n+      gimple_call_set_arg (stmt, 1, build_real (TREE_TYPE (arg1), cint));\n+      return power;\n+\n+    CASE_FLT_FN (BUILT_IN_POWI):\n+      arg1 = gimple_call_arg (stmt, 1);\n+      power = TREE_INT_CST_LOW (arg1) - 1;\n+      gimple_call_set_arg (stmt, 1, build_int_cst (TREE_TYPE (arg1), power));\n+      return power;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Find the single immediate use of STMT's LHS, and replace it\n+   with OP.  Remove STMT.  If STMT's LHS is the same as *DEF,\n+   replace *DEF with OP as well.  */\n+\n+static void\n+propagate_op_to_single_use (tree op, gimple stmt, tree *def)\n+{\n+  tree lhs;\n+  gimple use_stmt;\n+  use_operand_p use;\n+  gimple_stmt_iterator gsi;\n+\n+  if (is_gimple_call (stmt))\n+    lhs = gimple_call_lhs (stmt);\n+  else\n+    lhs = gimple_assign_lhs (stmt);\n+\n+  gcc_assert (has_single_use (lhs));\n+  single_imm_use (lhs, &use, &use_stmt);\n+  if (lhs == *def)\n+    *def = op;\n+  SET_USE (use, op);\n+  if (TREE_CODE (op) != SSA_NAME)\n+    update_stmt (use_stmt);\n+  gsi = gsi_for_stmt (stmt);\n+  gsi_remove (&gsi, true);\n+  release_defs (stmt);\n+\n+  if (is_gimple_call (stmt))\n+    unlink_stmt_vdef (stmt);\n+}\n+\n /* Walks the linear chain with result *DEF searching for an operation\n    with operand OP and code OPCODE removing that from the chain.  *DEF\n    is updated if there is only one operand but no operation left.  */\n@@ -1031,7 +1123,17 @@ zero_one_operation (tree *def, enum tree_code opcode, tree op)\n \n   do\n     {\n-      tree name = gimple_assign_rhs1 (stmt);\n+      tree name;\n+\n+      if (opcode == MULT_EXPR\n+\t  && stmt_is_power_of_op (stmt, op))\n+\t{\n+\t  if (decrement_power (stmt) == 1)\n+\t    propagate_op_to_single_use (op, stmt, def);\n+\t  return;\n+\t}\n+\n+      name = gimple_assign_rhs1 (stmt);\n \n       /* If this is the operation we look for and one of the operands\n          is ours simply propagate the other operand into the stmts\n@@ -1040,24 +1142,27 @@ zero_one_operation (tree *def, enum tree_code opcode, tree op)\n \t  && (name == op\n \t      || gimple_assign_rhs2 (stmt) == op))\n \t{\n-\t  gimple use_stmt;\n-\t  use_operand_p use;\n-\t  gimple_stmt_iterator gsi;\n \t  if (name == op)\n \t    name = gimple_assign_rhs2 (stmt);\n-\t  gcc_assert (has_single_use (gimple_assign_lhs (stmt)));\n-\t  single_imm_use (gimple_assign_lhs (stmt), &use, &use_stmt);\n-\t  if (gimple_assign_lhs (stmt) == *def)\n-\t    *def = name;\n-\t  SET_USE (use, name);\n-\t  if (TREE_CODE (name) != SSA_NAME)\n-\t    update_stmt (use_stmt);\n-\t  gsi = gsi_for_stmt (stmt);\n-\t  gsi_remove (&gsi, true);\n-\t  release_defs (stmt);\n+\t  propagate_op_to_single_use (name, stmt, def);\n \t  return;\n \t}\n \n+      /* We might have a multiply of two __builtin_pow* calls, and\n+\t the operand might be hiding in the rightmost one.  */\n+      if (opcode == MULT_EXPR\n+\t  && gimple_assign_rhs_code (stmt) == opcode\n+\t  && TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME)\n+\t{\n+\t  gimple stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));\n+\t  if (stmt_is_power_of_op (stmt2, op))\n+\t    {\n+\t      if (decrement_power (stmt2) == 1)\n+\t\tpropagate_op_to_single_use (op, stmt2, def);\n+\t      return;\n+\t    }\n+\t}\n+\n       /* Continue walking the chain.  */\n       gcc_assert (name != op\n \t\t  && TREE_CODE (name) == SSA_NAME);\n@@ -1222,7 +1327,6 @@ undistribute_ops_list (enum tree_code opcode,\n       dcode = gimple_assign_rhs_code (oe1def);\n       if ((dcode != MULT_EXPR\n \t   && dcode != RDIV_EXPR)\n-\t  || oe1->count != 1\n \t  || !is_reassociable_op (oe1def, dcode, loop))\n \tcontinue;\n \n@@ -1266,8 +1370,6 @@ undistribute_ops_list (enum tree_code opcode,\n \t  oecount c;\n \t  void **slot;\n \t  size_t idx;\n-\t  if (oe1->count != 1)\n-\t    continue;\n \t  c.oecode = oecode;\n \t  c.cnt = 1;\n \t  c.id = next_oecount_id++;\n@@ -1336,7 +1438,7 @@ undistribute_ops_list (enum tree_code opcode,\n \n \t  FOR_EACH_VEC_ELT (operand_entry_t, subops[i], j, oe1)\n \t    {\n-\t      if (oe1->op == c->op && oe1->count == 1)\n+\t      if (oe1->op == c->op)\n \t\t{\n \t\t  SET_BIT (candidates2, i);\n \t\t  ++nr_candidates2;"}]}