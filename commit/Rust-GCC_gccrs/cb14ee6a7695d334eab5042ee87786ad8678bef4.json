{"sha": "cb14ee6a7695d334eab5042ee87786ad8678bef4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IxNGVlNmE3Njk1ZDMzNGVhYjUwNDJlZTg3Nzg2YWQ4Njc4YmVmNA==", "commit": {"author": {"name": "Bryce McKinlay", "email": "mckinlay@redhat.com", "date": "2005-07-07T14:43:59Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2005-07-07T14:43:59Z"}, "message": "re PR java/18119 (Private inner class is visible when it shouldn't be)\n\n2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n\n\tPR java/18119\n\t* parse.y (inner_class_accessible): New function. Logic moved from\n\tcheck_inner_class_access.\n\t(check_inner_class_access): Use inner_class_accessible.\n\t(resolve_inner_class): Simplify arguments. Create circularity hash\n\there. Keep looking for classes if we found one that was\n\tinaccessible. Return the inaccessible class only if there is no other\n\tmatch.\n\t(do_resolve_class): Update for new resolve_inner_class arguments.\n\tDon't create circularity_hash here.\n\nFrom-SVN: r101715", "tree": {"sha": "23cd22739e5ec754982f27e1dd67c2c4aa2e7712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23cd22739e5ec754982f27e1dd67c2c4aa2e7712"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb14ee6a7695d334eab5042ee87786ad8678bef4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb14ee6a7695d334eab5042ee87786ad8678bef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb14ee6a7695d334eab5042ee87786ad8678bef4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb14ee6a7695d334eab5042ee87786ad8678bef4/comments", "author": null, "committer": null, "parents": [{"sha": "90475fe0fc9f86f93f961c29050af9a7c1545396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90475fe0fc9f86f93f961c29050af9a7c1545396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90475fe0fc9f86f93f961c29050af9a7c1545396"}], "stats": {"total": 197, "additions": 116, "deletions": 81}, "files": [{"sha": "2e0fecd54655baad4d191cbb13ee6267d81c506a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb14ee6a7695d334eab5042ee87786ad8678bef4/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb14ee6a7695d334eab5042ee87786ad8678bef4/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=cb14ee6a7695d334eab5042ee87786ad8678bef4", "patch": "@@ -1,3 +1,15 @@\n+2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\tPR java/18119\n+\t* parse.y (inner_class_accessible): New function. Logic moved from\n+\tcheck_inner_class_access.\n+\t(check_inner_class_access): Use inner_class_accessible.\n+\t(resolve_inner_class): Simplify arguments. Create circularity hash\n+\there. Keep looking for classes if we found one that was inaccessible. \n+\tReturn the inaccessible class only if there is no other match.\n+\t(do_resolve_class): Update for new resolve_inner_class arguments.\n+\tDon't create circularity_hash here.\n+\n 2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n \n         PR java/21045"}, {"sha": "6007b18a11d38f925834c2b304363772184a655b", "filename": "gcc/java/parse.y", "status": "modified", "additions": 99, "deletions": 77, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb14ee6a7695d334eab5042ee87786ad8678bef4/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb14ee6a7695d334eab5042ee87786ad8678bef4/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=cb14ee6a7695d334eab5042ee87786ad8678bef4", "patch": "@@ -112,6 +112,7 @@ static int process_imports (void);\n static void read_import_dir (tree);\n static int find_in_imports_on_demand (tree, tree);\n static void find_in_imports (tree, tree);\n+static bool inner_class_accessible (tree, tree);\n static void check_inner_class_access (tree, tree, tree);\n static int check_pkg_class_access (tree, tree, bool, tree);\n static tree resolve_package (tree, tree *, tree *);\n@@ -311,7 +312,7 @@ static int pop_current_osb (struct parser_ctxt *);\n static tree maybe_make_nested_class_name (tree);\n static int make_nested_class_name (tree);\n static void link_nested_class_to_enclosing (void);\n-static tree resolve_inner_class (htab_t, tree, tree *, tree *, tree);\n+static tree resolve_inner_class (tree, tree, tree, tree);\n static tree find_as_inner_class (tree, tree, tree);\n static tree find_as_inner_class_do (tree, tree);\n static int check_inner_class_redefinition (tree, tree);\n@@ -3663,46 +3664,52 @@ check_inner_class_redefinition (tree raw_name, tree cl)\n   return 0;\n }\n \n-/* Tries to find a decl for CLASS_TYPE within ENCLOSING. If we fail,\n-   we remember ENCLOSING and SUPER.  */\n+/* Tries to find a decl for CLASS_TYPE within ENCLOSING.  May return an\n+   invisible/non-accessible matching decl when an accessible one could not be \n+   found, in order to give a better error message when accessibility is \n+   checked later.  */\n \n static tree\n-resolve_inner_class (htab_t circularity_hash, tree cl, tree *enclosing,\n-\t\t     tree *super, tree class_type)\n+resolve_inner_class (tree context, tree cl, tree enclosing, tree class_type)\n {\n-  tree local_enclosing = *enclosing;\n   tree local_super = NULL_TREE;\n+  tree candidate = NULL_TREE;\n \n-  while (local_enclosing)\n+  /* This hash table is used to register the classes we're going\n+     through when searching the current class as an inner class, in\n+     order to detect circular references.  */\n+  htab_t circularity_hash = htab_create (20, htab_hash_pointer, htab_eq_pointer,\n+\t\t\t\t\t NULL);\n+\n+  while (enclosing)\n     {\n-      tree intermediate, decl;\n+      tree decl;\n \n-      *htab_find_slot (circularity_hash, local_enclosing, INSERT) =\n-\tlocal_enclosing;\n+      *htab_find_slot (circularity_hash, enclosing, INSERT) = enclosing;\n \n-      if ((decl = find_as_inner_class (local_enclosing, class_type, cl)))\n-\treturn decl;\n-\n-      intermediate = local_enclosing;\n-      /* Explore enclosing contexts. */\n-      while (INNER_CLASS_DECL_P (intermediate))\n-\t{\n-\t  intermediate = DECL_CONTEXT (intermediate);\n-\t  if ((decl = find_as_inner_class (intermediate, class_type, cl)))\n-\t    return decl;\n-\t}\n+      if ((decl = find_as_inner_class (enclosing, class_type, cl)))\n+        {\n+\t  if (inner_class_accessible (decl, context))\n+\t    {\n+\t      candidate = decl;\n+\t      break;\n+\t    }\n+\t  else\n+\t    if (candidate == NULL_TREE)\n+\t      candidate = decl;\n+\t}\t\n \n       /* Now go to the upper classes, bail out if necessary.  We will\n \t analyze the returned SUPER and act accordingly (see\n \t do_resolve_class).  */\n-      if (JPRIMITIVE_TYPE_P (TREE_TYPE (local_enclosing))\n-\t  || TREE_TYPE (local_enclosing) == void_type_node)\n+      if (JPRIMITIVE_TYPE_P (TREE_TYPE (enclosing))\n+\t  || TREE_TYPE (enclosing) == void_type_node)\n \t{\n \t  parse_error_context (cl, \"Qualifier must be a reference\");\n-\t  local_enclosing = NULL_TREE;\n+\t  enclosing = NULL_TREE;\n \t  break;\n \t}\n-      local_super = CLASSTYPE_SUPER (TREE_TYPE (local_enclosing));\n+      local_super = CLASSTYPE_SUPER (TREE_TYPE (enclosing));\n       if (!local_super || local_super == object_type_node)\n         break;\n \n@@ -3716,22 +3723,22 @@ resolve_inner_class (htab_t circularity_hash, tree cl, tree *enclosing,\n       if (htab_find (circularity_hash, local_super) != NULL)\n         {\n           if (!cl)\n-            cl = lookup_cl (local_enclosing);\n+            cl = lookup_cl (enclosing);\n \n           parse_error_context\n             (cl, \"Cyclic inheritance involving %s\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (local_enclosing)));\n-\t  local_enclosing = NULL_TREE;\n+\t     IDENTIFIER_POINTER (DECL_NAME (enclosing)));\n+\t  enclosing = NULL_TREE;\n         }\n       else\n-\tlocal_enclosing = local_super;\n+\tenclosing = local_super;\n     }\n \n-  /* We failed. Return LOCAL_SUPER and LOCAL_ENCLOSING. */\n-  *super = local_super;\n-  *enclosing = local_enclosing;\n+  htab_delete (circularity_hash);\n \n-  return NULL_TREE;\n+  /* We failed, but we might have found a matching class that wasn't \n+     accessible.  Return that to get a better error message.  */\n+  return candidate;\n }\n \n /* Within ENCLOSING, find a decl for NAME and return it. NAME can be\n@@ -5866,10 +5873,10 @@ tree\n do_resolve_class (tree enclosing, tree import_type, tree class_type, tree decl,\n \t\t  tree cl)\n {\n-  tree new_class_decl = NULL_TREE, super = NULL_TREE;\n+  tree new_class_decl = NULL_TREE;\n   tree saved_enclosing_type = enclosing ? TREE_TYPE (enclosing) : NULL_TREE;\n+  tree candidate = NULL_TREE;\n   tree decl_result;\n-  htab_t circularity_hash;\n \n   if (QUALIFIED_P (TYPE_NAME (class_type)))\n     {\n@@ -5893,35 +5900,31 @@ do_resolve_class (tree enclosing, tree import_type, tree class_type, tree decl,\n \n   if (enclosing)\n     {\n-      /* This hash table is used to register the classes we're going\n-\t through when searching the current class as an inner class, in\n-\t order to detect circular references. Remember to free it before\n-\t returning the section 0- of this function. */\n-      circularity_hash = htab_create (20, htab_hash_pointer, htab_eq_pointer,\n-\t\t\t\t      NULL);\n+      tree context = enclosing;\n \n       /* 0- Search in the current class as an inner class.\n \t Maybe some code here should be added to load the class or\n \t something, at least if the class isn't an inner class and ended\n \t being loaded from class file. FIXME. */\n       while (enclosing)\n \t{\n-\t  new_class_decl = resolve_inner_class (circularity_hash, cl, &enclosing,\n-\t\t\t\t\t\t&super, class_type);\n+\t  new_class_decl = resolve_inner_class (context, cl, enclosing, class_type);\n+\t  \n \t  if (new_class_decl)\n-\t    break;\n+\t    {\n+\t      if (inner_class_accessible (new_class_decl, context))\n+\t        break;\n+\t      else\n+\t        if (candidate == NULL_TREE)\n+\t\t  candidate = new_class_decl;\n+\t\tnew_class_decl = NULL_TREE;\n+\t    }\n \n-\t  /* If we haven't found anything because SUPER reached Object and\n-\t     ENCLOSING happens to be an innerclass, try the enclosing context. */\n-\t  if ((!super || super == object_type_node) &&\n-\t      enclosing && INNER_CLASS_DECL_P (enclosing))\n-\t    enclosing = DECL_CONTEXT (enclosing);\n-\t  else\n-\t    enclosing = NULL_TREE;\n+\t  /* Now that we've looked through all superclasses, try the enclosing\n+\t     context. */\n+\t  enclosing = DECL_CONTEXT (enclosing);\n \t}\n \n-      htab_delete (circularity_hash);\n-\n       if (new_class_decl)\n \treturn new_class_decl;\n     }\n@@ -6007,7 +6010,10 @@ do_resolve_class (tree enclosing, tree import_type, tree class_type, tree decl,\n          }\n       } while (!decl_result && separator);\n     }\n-  return decl_result;\n+  if (decl_result)\n+    return decl_result;\n+  else\n+    return candidate;\n }\n \n static tree\n@@ -7263,25 +7269,14 @@ resolve_package (tree pkg, tree *next, tree *type_name)\n   return decl;\n }\n \n+/* Check accessibility of inner class DECL, from the context ENCLOSING_DECL,\n+   according to member access rules.  */\n \n-/* Check accessibility of inner classes according to member access rules.\n-   DECL is the inner class, ENCLOSING_DECL is the class from which the\n-   access is being attempted. */\n-\n-static void\n-check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n+static bool\n+inner_class_accessible (tree decl, tree enclosing_decl)\n {\n-  const char *access;\n   tree enclosing_decl_type;\n \n-  /* We don't issue an error message when CL is null. CL can be null\n-     as a result of processing a JDEP crafted by source_start_java_method\n-     for the purpose of patching its parm decl. But the error would\n-     have been already trapped when fixing the method's signature.\n-     DECL can also be NULL in case of earlier errors. */\n-  if (!decl || !cl)\n-    return;\n-\n   enclosing_decl_type = TREE_TYPE (enclosing_decl);\n \n   if (CLASS_PRIVATE (decl))\n@@ -7294,15 +7289,14 @@ check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n       while (DECL_CONTEXT (enclosing_decl))\n         enclosing_decl = DECL_CONTEXT (enclosing_decl);\n       if (top_level == enclosing_decl)\n-        return;\n-      access = \"private\";\n+        return true;\n     }\n   else if (CLASS_PROTECTED (decl))\n     {\n       tree decl_context;\n       /* Access is permitted from within the same package... */\n       if (in_same_package (decl, enclosing_decl))\n-        return;\n+        return true;\n \n       /* ... or from within the body of a subtype of the context in which\n          DECL is declared. */\n@@ -7313,30 +7307,58 @@ check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n \t    {\n \t      if (interface_of_p (TREE_TYPE (decl_context),\n \t\t\t\t  enclosing_decl_type))\n-\t\treturn;\n+\t\treturn true;\n \t    }\n \t  else\n \t    {\n \t      /* Eww. The order of the arguments is different!! */\n \t      if (inherits_from_p (enclosing_decl_type,\n \t\t\t\t   TREE_TYPE (decl_context)))\n-\t\treturn;\n+\t\treturn true;\n \t    }\n \t  enclosing_decl = DECL_CONTEXT (enclosing_decl);\n \t}\n-      access = \"protected\";\n     }\n   else if (! CLASS_PUBLIC (decl))\n     {\n       /* Access is permitted only from within the same package as DECL. */\n       if (in_same_package (decl, enclosing_decl))\n-        return;\n-      access = \"non-public\";\n+        return true;\n     }\n   else\n     /* Class is public. */\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Check accessibility of inner classes according to member access rules.\n+   DECL is the inner class, ENCLOSING_DECL is the class from which the\n+   access is being attempted. */\n+\n+static void\n+check_inner_class_access (tree decl, tree enclosing_decl, tree cl)\n+{\n+  const char *access;\n+\n+  /* We don't issue an error message when CL is null. CL can be null\n+     as a result of processing a JDEP crafted by source_start_java_method\n+     for the purpose of patching its parm decl. But the error would\n+     have been already trapped when fixing the method's signature.\n+     DECL can also be NULL in case of earlier errors. */\n+  if (!decl || !cl)\n     return;\n \n+  if (inner_class_accessible (decl, enclosing_decl))\n+    return;\n+\n+  if (CLASS_PRIVATE (decl))\n+      access = \"private\";\n+  else if (CLASS_PROTECTED (decl))\n+      access = \"protected\";\n+  else\n+      access = \"non-public\";\n+\n   parse_error_context (cl, \"Nested %s %s is %s; cannot be accessed from here\",\n \t\t       (CLASS_INTERFACE (decl) ? \"interface\" : \"class\"),\n \t\t       lang_printable_name (decl, 2), access);"}, {"sha": "4e173ee8c164644474c60371714514f5e725cbac", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb14ee6a7695d334eab5042ee87786ad8678bef4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb14ee6a7695d334eab5042ee87786ad8678bef4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=cb14ee6a7695d334eab5042ee87786ad8678bef4", "patch": "@@ -1,3 +1,8 @@\n+2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n+\n+\t* testsuite/libjava.jacks/jacks.xfail: Remove 6.5.5.1-nested-4,\n+\t6.5.5.1-nested-7, 6.5.5.1-nested-16, 6.5.5.1-nested-17.\n+\n 2005-07-07  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* testsuite/libjava.compile/PR21045.java: New test."}, {"sha": "0472b55a26dc20a73628d57299b88b670b564c25", "filename": "libjava/testsuite/libjava.jacks/jacks.xfail", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb14ee6a7695d334eab5042ee87786ad8678bef4/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb14ee6a7695d334eab5042ee87786ad8678bef4/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jacks%2Fjacks.xfail?ref=cb14ee6a7695d334eab5042ee87786ad8678bef4", "patch": "@@ -466,14 +466,10 @@\n 6.5.5.1-import-2\n 6.5.5.1-import-3\n 6.5.5.1-nested-14\n-6.5.5.1-nested-16\n-6.5.5.1-nested-17\n 6.5.5.1-nested-19\n 6.5.5.1-nested-20\n 6.5.5.1-nested-21\n 6.5.5.1-nested-23\n-6.5.5.1-nested-4\n-6.5.5.1-nested-7\n 6.5.5.1-nested-8\n 6.5.5.1-nested-9\n 6.5.5.2-type-4"}]}