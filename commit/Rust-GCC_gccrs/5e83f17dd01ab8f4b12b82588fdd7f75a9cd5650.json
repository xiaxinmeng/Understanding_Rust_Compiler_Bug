{"sha": "5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU4M2YxN2RkMDFhYjhmNGIxMmI4MjU4OGZkZDdmNzVhOWNkNTY1MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-11-21T03:57:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-11-21T03:57:48Z"}, "message": "ipa-icf.c (sem_item::add_type): Do not look for TYPE_CANONICAL...\n\n\n\t* ipa-icf.c (sem_item::add_type): Do not look for TYPE_CANONICAL;\n\tdo not check AGGREGATE_TYPE_P when adding TYPE_MODE;\n\tCheck that all record types are complete.\n\t* ipa-icf-gimple.c (func_checker::compatible_types_p): Do not\n\tcompare alias sets for types w/o alias sets.\n\nFrom-SVN: r230698", "tree": {"sha": "a975c099504f1b5234058364c3c726a01923b4b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a975c099504f1b5234058364c3c726a01923b4b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/comments", "author": null, "committer": null, "parents": [{"sha": "65310691f80bb61e561f34d7500cd6336d625f49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65310691f80bb61e561f34d7500cd6336d625f49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65310691f80bb61e561f34d7500cd6336d625f49"}], "stats": {"total": 24, "additions": 19, "deletions": 5}, "files": [{"sha": "1b7c5d238222d42c14c0db154e8c87cc215d67d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "patch": "@@ -1,3 +1,11 @@\n+2015-11-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-icf.c (sem_item::add_type): Do not look for TYPE_CANONICAL;\n+\tdo not check AGGREGATE_TYPE_P when adding TYPE_MODE;\n+\tCheck that all record types are complete.\n+\t* ipa-icf-gimple.c (func_checker::compatible_types_p): Do not\n+\tcompare alias sets for types w/o alias sets.\n+\n 2015-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.md (umulxhi_vis): Move around."}, {"sha": "992ee7acb4ca9baeacde7112adb1ab7ef6331e6d", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "patch": "@@ -233,7 +233,15 @@ func_checker::compatible_types_p (tree t1, tree t2)\n   if (!types_compatible_p (t1, t2))\n     return return_false_with_msg (\"types are not compatible\");\n \n-  if (get_alias_set (t1) != get_alias_set (t2))\n+  /* We do a lot of unnecesary matching of types that are not being\n+     accessed and thus do not need to be compatible.  In longer term we should\n+     remove these checks on all types which are not accessed as memory\n+     locations.\n+\n+     For time being just avoid calling get_alias_set on types that are not\n+     having alias sets defined at all.  */\n+  if (type_with_alias_set_p (t1) && type_with_alias_set_p (t2)\n+      && get_alias_set (t1) != get_alias_set (t2))\n     return return_false_with_msg (\"alias sets are different\");\n \n   return true;"}, {"sha": "0c76672a2c631fdd852e4b50215edc63bf2ddd6c", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=5e83f17dd01ab8f4b12b82588fdd7f75a9cd5650", "patch": "@@ -1543,11 +1543,8 @@ sem_item::add_type (const_tree type, inchash::hash &hstate)\n     }\n \n   type = TYPE_MAIN_VARIANT (type);\n-  if (TYPE_CANONICAL (type))\n-    type = TYPE_CANONICAL (type);\n \n-  if (!AGGREGATE_TYPE_P (type))\n-    hstate.add_int (TYPE_MODE (type));\n+  hstate.add_int (TYPE_MODE (type));\n \n   if (TREE_CODE (type) == COMPLEX_TYPE)\n     {\n@@ -1574,6 +1571,7 @@ sem_item::add_type (const_tree type, inchash::hash &hstate)\n     }\n   else if (RECORD_OR_UNION_TYPE_P (type))\n     {\n+      gcc_checking_assert (COMPLETE_TYPE_P (type));\n       hashval_t *val = optimizer->m_type_hash_cache.get (type);\n \n       if (!val)"}]}