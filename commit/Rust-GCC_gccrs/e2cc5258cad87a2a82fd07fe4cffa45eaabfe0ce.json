{"sha": "e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJjYzUyNThjYWQ4N2EyYTgyZmQwN2ZlNGNmZmE0NWVhYWJmZTBjZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T09:01:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T09:01:32Z"}, "message": "[multiple changes]\n\n2010-06-23  Olivier Hainque  <hainque@adacore.com>\n\n\t* einfo.adb (Has_Foreign_Convention): Consider Intrinsic with\n\tInterface_Name as foreign. These are GCC builtin imports for\n\twhich Ada specific processing doesn't apply.\n\n2010-06-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch12.adb: Minor reformatting.\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Is_VMS_Operator): Use scope of system extension to\n\tdetermine whether an intrinsic subprogram is VMS specific.\n\n2010-06-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* treepr.adb (Print_Entity_Info): Output the contents of Field28 if it\n\tis present in the entity.\n\nFrom-SVN: r161262", "tree": {"sha": "47ee806dd8fb95243c84dee353eada67ae6fb03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47ee806dd8fb95243c84dee353eada67ae6fb03c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/comments", "author": null, "committer": null, "parents": [{"sha": "2503cb81eefe3d14714b243c49bf36e5f7256597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2503cb81eefe3d14714b243c49bf36e5f7256597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2503cb81eefe3d14714b243c49bf36e5f7256597"}], "stats": {"total": 86, "additions": 61, "deletions": 25}, "files": [{"sha": "d6ea81998767dc1e581c567bb7a17ef1780199b3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "patch": "@@ -1,3 +1,23 @@\n+2010-06-23  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* einfo.adb (Has_Foreign_Convention): Consider Intrinsic with\n+\tInterface_Name as foreign. These are GCC builtin imports for\n+\twhich Ada specific processing doesn't apply.\n+\n+2010-06-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch12.adb: Minor reformatting.\n+\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Is_VMS_Operator): Use scope of system extension to\n+\tdetermine whether an intrinsic subprogram is VMS specific.\n+\n+2010-06-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* treepr.adb (Print_Entity_Info): Output the contents of Field28 if it\n+\tis present in the entity.\n+\n 2010-06-23  Arnaud Charlet  <charlet@adacore.com>\n \n \t* xr_tabls.adb, xref_lib.adb: Update to latest lib-xref.ads"}, {"sha": "7769ff1b2bd3ba5f7623aba551c4a98fa78fdb76", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "patch": "@@ -5850,7 +5850,13 @@ package body Einfo is\n \n    function Has_Foreign_Convention (Id : E) return B is\n    begin\n-      return Convention (Id) in Foreign_Convention;\n+      --  While regular Intrinsics such as the Standard operators fit in the\n+      --  \"Ada\" convention, those with an Interface_Name materialize GCC\n+      --  builtin imports for which Ada special treatments shouldn't apply.\n+\n+      return Convention (Id) in Foreign_Convention\n+        or else (Convention (Id) = Convention_Intrinsic\n+                 and then Present (Interface_Name (Id)));\n    end Has_Foreign_Convention;\n \n    ---------------------------"}, {"sha": "ceb4dacd22fe91b64dba478e9466178289a1bd29", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "patch": "@@ -10864,17 +10864,17 @@ package body Sem_Ch12 is\n                             Get_Body_Name (Get_Unit_Name (Unit (Comp_Unit)));\n \n                begin\n-                  --  In CodePeer mode, the missing body may make the\n-                  --  analysis incomplete, but we do not treat it as fatal.\n+                  --  In CodePeer mode, the missing body may make the analysis\n+                  --  incomplete, but we do not treat it as fatal.\n \n                   if CodePeer_Mode then\n                      return;\n \n                   else\n                      Error_Msg_Unit_1 := Bname;\n                      Error_Msg_N (\"this instantiation requires$!\", N);\n-                     Error_Msg_File_1\n-                       := Get_File_Name (Bname, Subunit => False);\n+                     Error_Msg_File_1 :=\n+                       Get_File_Name (Bname, Subunit => False);\n                      Error_Msg_N (\"\\but file{ was not found!\", N);\n                      raise Unrecoverable_Error;\n                   end if;"}, {"sha": "45f4e832a10030e2fa27039569603f12c6b614aa", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "patch": "@@ -7214,10 +7214,14 @@ package body Sem_Util is\n \n    function Is_VMS_Operator (Op : Entity_Id) return Boolean is\n    begin\n+      --  The VMS operators are declared in a child of System that is loaded\n+      --  through pragma Extend_System. In some rare cases a program is run\n+      --  with this extension but without indicating that the target is VMS.\n+\n       return Ekind (Op) = E_Function\n         and then Is_Intrinsic_Subprogram (Op)\n-        and then Chars (Scope (Scope (Op))) = Name_System\n-        and then OpenVMS_On_Target;\n+        and then Present_System_Aux\n+        and then Scope (Op) = System_Aux_Id;\n    end Is_VMS_Operator;\n \n    -----------------\n@@ -7234,14 +7238,14 @@ package body Sem_Util is\n       --  expansion.\n \n       function In_Protected_Function (E : Entity_Id) return Boolean;\n-      --  Within a protected function, the private components of the\n-      --  enclosing protected type are constants. A function nested within\n-      --  a (protected) procedure is not itself protected.\n+      --  Within a protected function, the private components of the enclosing\n+      --  protected type are constants. A function nested within a (protected)\n+      --  procedure is not itself protected.\n \n       function Is_Variable_Prefix (P : Node_Id) return Boolean;\n-      --  Prefixes can involve implicit dereferences, in which case we\n-      --  must test for the case of a reference of a constant access\n-      --  type, which can never be a variable.\n+      --  Prefixes can involve implicit dereferences, in which case we must\n+      --  test for the case of a reference of a constant access type, which can\n+      --  can never be a variable.\n \n       ---------------------------\n       -- In_Protected_Function --\n@@ -7257,9 +7261,7 @@ package body Sem_Util is\n          else\n             S := Current_Scope;\n             while Present (S) and then S /= Prot loop\n-               if Ekind (S) = E_Function\n-                 and then Scope (S) = Prot\n-               then\n+               if Ekind (S) = E_Function and then Scope (S) = Prot then\n                   return True;\n                end if;\n \n@@ -7304,16 +7306,16 @@ package body Sem_Util is\n       if Nkind (N) in N_Subexpr and then Assignment_OK (N) then\n          return True;\n \n-      --  Normally we go to the original node, but there is one exception\n-      --  where we use the rewritten node, namely when it is an explicit\n-      --  dereference. The generated code may rewrite a prefix which is an\n-      --  access type with an explicit dereference. The dereference is a\n-      --  variable, even though the original node may not be (since it could\n-      --  be a constant of the access type).\n+      --  Normally we go to the original node, but there is one exception where\n+      --  we use the rewritten node, namely when it is an explicit dereference.\n+      --  The generated code may rewrite a prefix which is an access type with\n+      --  an explicit dereference. The dereference is a variable, even though\n+      --  the original node may not be (since it could be a constant of the\n+      --  access type).\n \n-      --  In Ada 2005 we have a further case to consider: the prefix may be\n-      --  a function call given in prefix notation. The original node appears\n-      --  to be a selected component, but we need to examine the call.\n+      --  In Ada 2005 we have a further case to consider: the prefix may be a\n+      --  function call given in prefix notation. The original node appears to\n+      --  be a selected component, but we need to examine the call.\n \n       elsif Nkind (N) = N_Explicit_Dereference\n         and then Nkind (Orig_Node) /= N_Explicit_Dereference"}, {"sha": "087170f69fe2d676cbf4422e16fba5bf00800f7a", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=e2cc5258cad87a2a82fd07fe4cffa45eaabfe0ce", "patch": "@@ -627,6 +627,14 @@ package body Treepr is\n          Print_Eol;\n       end if;\n \n+      if Field_Present (Field28 (Ent)) then\n+         Print_Str (Prefix);\n+         Write_Field28_Name (Ent);\n+         Write_Str (\" = \");\n+         Print_Field (Field28 (Ent));\n+         Print_Eol;\n+      end if;\n+\n       Write_Entity_Flags (Ent, Prefix);\n    end Print_Entity_Info;\n "}]}