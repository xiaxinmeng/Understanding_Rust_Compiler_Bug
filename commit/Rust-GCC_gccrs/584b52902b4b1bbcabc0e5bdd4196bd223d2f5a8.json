{"sha": "584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTg0YjUyOTAyYjRiMWJiY2FiYzBlNWJkZDQxOTZiZDIyM2QyZjVhOA==", "commit": {"author": {"name": "Claire Dross", "email": "dross@adacore.com", "date": "2019-07-05T07:01:45Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-05T07:01:45Z"}, "message": "[Ada] Ada.Containers.Formal_Vectors: make vectors always bounded\n\n2019-07-05  Claire Dross  <dross@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-cofove.ads, libgnat/a-cofove.adb: Definite formal\n\tvectors are now always bounded so that they do not need to be\n\tlimited anymore.\n\nFrom-SVN: r273102", "tree": {"sha": "cc72e32c51c46b6d0c7b1c34cda7143817fec774", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc72e32c51c46b6d0c7b1c34cda7143817fec774"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/comments", "author": {"login": "clairedross", "id": 8180017, "node_id": "MDQ6VXNlcjgxODAwMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/8180017?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clairedross", "html_url": "https://github.com/clairedross", "followers_url": "https://api.github.com/users/clairedross/followers", "following_url": "https://api.github.com/users/clairedross/following{/other_user}", "gists_url": "https://api.github.com/users/clairedross/gists{/gist_id}", "starred_url": "https://api.github.com/users/clairedross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clairedross/subscriptions", "organizations_url": "https://api.github.com/users/clairedross/orgs", "repos_url": "https://api.github.com/users/clairedross/repos", "events_url": "https://api.github.com/users/clairedross/events{/privacy}", "received_events_url": "https://api.github.com/users/clairedross/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9328056ba3cbc5cddef1d7ef6b57ae97bbefb808", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9328056ba3cbc5cddef1d7ef6b57ae97bbefb808", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9328056ba3cbc5cddef1d7ef6b57ae97bbefb808"}], "stats": {"total": 248, "additions": 44, "deletions": 204}, "files": [{"sha": "42fa71bddd43acbfca31168c5e6c2166cd1fb3ad", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "patch": "@@ -1,3 +1,9 @@\n+2019-07-05  Claire Dross  <dross@adacore.com>\n+\n+\t* libgnat/a-cofove.ads, libgnat/a-cofove.adb: Definite formal\n+\tvectors are now always bounded so that they do not need to be\n+\tlimited anymore.\n+\n 2019-07-05  Dmitriy Anisimkov  <anisimko@adacore.com>\n \n \t* libgnat/g-traceb.ads, libgnat/g-traceb.adb (Call_Chain): New"}, {"sha": "c848ad839905a183d3e52a494f8402ea42406dac", "filename": "gcc/ada/libgnat/a-cofove.adb", "status": "modified", "additions": 29, "deletions": 154, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.adb?ref=584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "patch": "@@ -26,49 +26,17 @@\n ------------------------------------------------------------------------------\n \n with Ada.Containers.Generic_Array_Sort;\n-with Ada.Unchecked_Deallocation;\n \n with System; use type System.Address;\n \n package body Ada.Containers.Formal_Vectors with\n   SPARK_Mode => Off\n is\n \n-   Growth_Factor : constant := 2;\n-   --  When growing a container, multiply current capacity by this. Doubling\n-   --  leads to amortized linear-time copying.\n-\n    type Int is range System.Min_Int .. System.Max_Int;\n \n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n-\n-   type Maximal_Array_Ptr is access all Elements_Array (Array_Index)\n-     with Storage_Size => 0;\n-   type Maximal_Array_Ptr_Const is access constant Elements_Array (Array_Index)\n-     with Storage_Size => 0;\n-\n-   function Elems (Container : in out Vector) return Maximal_Array_Ptr;\n-   function Elemsc\n-     (Container : Vector) return Maximal_Array_Ptr_Const;\n-   --  Returns a pointer to the Elements array currently in use -- either\n-   --  Container.Elements_Ptr or a pointer to Container.Elements. We work with\n-   --  pointers to a bogus array subtype that is constrained with the maximum\n-   --  possible bounds. This means that the pointer is a thin pointer. This is\n-   --  necessary because 'Unrestricted_Access doesn't work when it produces\n-   --  access-to-unconstrained and is returned from a function.\n-   --\n-   --  Note that this is dangerous: make sure calls to this use an indexed\n-   --  component or slice that is within the bounds 1 .. Length (Container).\n-\n-   function Get_Element\n-     (Container : Vector;\n-      Position  : Capacity_Range) return Element_Type;\n-\n    function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base;\n \n-   function Current_Capacity (Container : Vector) return Capacity_Range;\n-\n    procedure Insert_Space\n      (Container : in out Vector;\n       Before    : Extended_Index;\n@@ -89,7 +57,7 @@ is\n       end if;\n \n       for J in 1 .. Length (Left) loop\n-         if Get_Element (Left, J) /= Get_Element (Right, J) then\n+         if Left.Elements (J) /= Right.Elements (J) then\n             return False;\n          end if;\n       end loop;\n@@ -148,7 +116,7 @@ is\n          return;\n       end if;\n \n-      if Bounded and then Target.Capacity < LS then\n+      if Target.Capacity < LS then\n          raise Constraint_Error;\n       end if;\n \n@@ -162,11 +130,7 @@ is\n \n    function Capacity (Container : Vector) return Capacity_Range is\n    begin\n-      return\n-        (if Bounded then\n-            Container.Capacity\n-         else\n-            Capacity_Range'Last);\n+      return Container.Capacity;\n    end Capacity;\n \n    -----------\n@@ -176,10 +140,6 @@ is\n    procedure Clear (Container : in out Vector) is\n    begin\n       Container.Last := No_Index;\n-\n-      --  Free element, note that this is OK if Elements_Ptr is null\n-\n-      Free (Container.Elements_Ptr);\n    end Clear;\n \n    --------------\n@@ -215,24 +175,11 @@ is\n       end if;\n \n       return Target : Vector (C) do\n-         Elems (Target) (1 .. LS) := Elemsc (Source) (1 .. LS);\n+         Target.Elements (1 .. LS) := Source.Elements (1 .. LS);\n          Target.Last := Source.Last;\n       end return;\n    end Copy;\n \n-   ----------------------\n-   -- Current_Capacity --\n-   ----------------------\n-\n-   function Current_Capacity (Container : Vector) return Capacity_Range is\n-   begin\n-      return\n-        (if Container.Elements_Ptr = null then\n-            Container.Elements'Length\n-         else\n-            Container.Elements_Ptr.all'Length);\n-   end Current_Capacity;\n-\n    ------------\n    -- Delete --\n    ------------\n@@ -333,7 +280,7 @@ is\n       --  so we just slide down to Index the elements that weren't deleted.\n \n       declare\n-         EA  : Maximal_Array_Ptr renames Elems (Container);\n+         EA  : Elements_Array renames Container.Elements;\n          Idx : constant Count_Type := EA'First + Off;\n       begin\n          EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n@@ -418,32 +365,10 @@ is\n          II : constant Int'Base := Int (Index) - Int (No_Index);\n          I  : constant Capacity_Range := Capacity_Range (II);\n       begin\n-         return Get_Element (Container, I);\n+         return Container.Elements (I);\n       end;\n    end Element;\n \n-   -----------\n-   -- Elems --\n-   -----------\n-\n-   function Elems (Container : in out Vector) return Maximal_Array_Ptr is\n-   begin\n-      return\n-        (if Container.Elements_Ptr = null then\n-            Container.Elements'Unrestricted_Access\n-         else\n-            Container.Elements_Ptr.all'Unrestricted_Access);\n-   end Elems;\n-\n-   function Elemsc (Container : Vector) return Maximal_Array_Ptr_Const is\n-   begin\n-      return\n-        (if Container.Elements_Ptr = null then\n-            Container.Elements'Unrestricted_Access\n-         else\n-            Container.Elements_Ptr.all'Unrestricted_Access);\n-   end Elemsc;\n-\n    ----------------\n    -- Find_Index --\n    ----------------\n@@ -459,7 +384,7 @@ is\n    begin\n       K := Capacity_Range (Int (Index) - Int (No_Index));\n       for Indx in Index .. Last loop\n-         if Get_Element (Container, K) = Item then\n+         if Container.Elements (K) = Item then\n             return Indx;\n          end if;\n \n@@ -478,7 +403,7 @@ is\n       if Is_Empty (Container) then\n          raise Constraint_Error with \"Container is empty\";\n       else\n-         return Get_Element (Container, 1);\n+         return Container.Elements (1);\n       end if;\n    end First_Element;\n \n@@ -622,7 +547,7 @@ is\n \n       begin\n          for Position in 1 .. Length (Container) loop\n-            R := M.Add (R, Elemsc (Container) (Position));\n+            R := M.Add (R, Container.Elements (Position));\n          end loop;\n \n          return R;\n@@ -684,8 +609,8 @@ is\n \n       begin\n          for J in 1 .. L - 1 loop\n-            if Get_Element (Container, J + 1) <\n-               Get_Element (Container, J)\n+            if Container.Elements (J + 1) <\n+               Container.Elements (J)\n             then\n                return False;\n             end if;\n@@ -712,7 +637,7 @@ is\n          if Container.Last <= Index_Type'First then\n             return;\n          else\n-            Sort (Elems (Container) (1 .. Len));\n+            Sort (Container.Elements (1 .. Len));\n          end if;\n       end Sort;\n \n@@ -744,16 +669,6 @@ is\n             New_Length : constant Count_Type := I + Length (Source);\n \n          begin\n-            if not Bounded\n-              and then Current_Capacity (Target) < Capacity_Range (New_Length)\n-            then\n-               Reserve_Capacity\n-                 (Target,\n-                  Capacity_Range'Max\n-                    (Current_Capacity (Target) * Growth_Factor,\n-                     Capacity_Range (New_Length)));\n-            end if;\n-\n             if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n                Target.Last := No_Index + Index_Type'Base (New_Length);\n \n@@ -764,8 +679,8 @@ is\n          end;\n \n          declare\n-            TA : Maximal_Array_Ptr renames Elems (Target);\n-            SA : Maximal_Array_Ptr renames Elems (Source);\n+            TA : Elements_Array renames Target.Elements;\n+            SA : Elements_Array renames Source.Elements;\n \n          begin\n             J := Length (Target);\n@@ -792,18 +707,6 @@ is\n \n    end Generic_Sorting;\n \n-   -----------------\n-   -- Get_Element --\n-   -----------------\n-\n-   function Get_Element\n-     (Container : Vector;\n-      Position  : Capacity_Range) return Element_Type\n-   is\n-   begin\n-      return Elemsc (Container) (Position);\n-   end Get_Element;\n-\n    -----------------\n    -- Has_Element --\n    -----------------\n@@ -844,7 +747,7 @@ is\n \n       J := To_Array_Index (Before);\n \n-      Elems (Container) (J .. J - 1 + Count) := (others => New_Item);\n+      Container.Elements (J .. J - 1 + Count) := (others => New_Item);\n    end Insert;\n \n    procedure Insert\n@@ -876,7 +779,7 @@ is\n \n       B := To_Array_Index (Before);\n \n-      Elems (Container) (B .. B + N - 1) := Elemsc (New_Item) (1 .. N);\n+      Container.Elements (B .. B + N - 1) := New_Item.Elements (1 .. N);\n    end Insert;\n \n    ------------------\n@@ -1053,19 +956,8 @@ is\n \n       J := To_Array_Index (Before);\n \n-      --  Increase the capacity of container if needed\n-\n-      if not Bounded\n-        and then Current_Capacity (Container) < Capacity_Range (New_Length)\n-      then\n-         Reserve_Capacity\n-           (Container,\n-            Capacity_Range'Max (Current_Capacity (Container) * Growth_Factor,\n-                                Capacity_Range (New_Length)));\n-      end if;\n-\n       declare\n-         EA : Maximal_Array_Ptr renames Elems (Container);\n+         EA : Elements_Array renames Container.Elements;\n \n       begin\n          if Before <= Container.Last then\n@@ -1105,7 +997,7 @@ is\n       if Is_Empty (Container) then\n          raise Constraint_Error with \"Container is empty\";\n       else\n-         return Get_Element (Container, Length (Container));\n+         return Container.Elements (Length (Container));\n       end if;\n    end Last_Element;\n \n@@ -1143,7 +1035,7 @@ is\n          return;\n       end if;\n \n-      if Bounded and then Target.Capacity < LS then\n+      if Target.Capacity < LS then\n          raise Constraint_Error;\n       end if;\n \n@@ -1194,7 +1086,7 @@ is\n          I  : constant Capacity_Range := Capacity_Range (II);\n \n       begin\n-         Elems (Container) (I) := New_Item;\n+         Container.Elements (I) := New_Item;\n       end;\n    end Replace_Element;\n \n@@ -1207,24 +1099,8 @@ is\n       Capacity  : Capacity_Range)\n    is\n    begin\n-      if Bounded then\n-         if Capacity > Container.Capacity then\n-            raise Constraint_Error with \"Capacity is out of range\";\n-         end if;\n-\n-      else\n-         if Capacity > Formal_Vectors.Current_Capacity (Container) then\n-            declare\n-               New_Elements : constant Elements_Array_Ptr :=\n-                                new Elements_Array (1 .. Capacity);\n-               L            : constant Capacity_Range := Length (Container);\n-\n-            begin\n-               New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n-               Free (Container.Elements_Ptr);\n-               Container.Elements_Ptr := New_Elements;\n-            end;\n-         end if;\n+      if Capacity > Container.Capacity then\n+         raise Constraint_Error with \"Capacity is out of range\";\n       end if;\n    end Reserve_Capacity;\n \n@@ -1241,7 +1117,7 @@ is\n       declare\n          I, J : Capacity_Range;\n          E    : Elements_Array renames\n-                  Elems (Container) (1 .. Length (Container));\n+                  Container.Elements (1 .. Length (Container));\n \n       begin\n          I := 1;\n@@ -1282,7 +1158,7 @@ is\n \n       K := Capacity_Range (Int (Last) - Int (No_Index));\n       for Indx in reverse Index_Type'First .. Last loop\n-         if Get_Element (Container, K) = Item then\n+         if Container.Elements (K) = Item then\n             return Indx;\n          end if;\n \n@@ -1318,8 +1194,8 @@ is\n          II : constant Int'Base := Int (I) - Int (No_Index);\n          JJ : constant Int'Base := Int (J) - Int (No_Index);\n \n-         EI : Element_Type renames Elems (Container) (Capacity_Range (II));\n-         EJ : Element_Type renames Elems (Container) (Capacity_Range (JJ));\n+         EI : Element_Type renames Container.Elements (Capacity_Range (II));\n+         EJ : Element_Type renames Container.Elements (Capacity_Range (JJ));\n \n          EI_Copy : constant Element_Type := EI;\n \n@@ -1388,10 +1264,9 @@ is\n          Last := Index_Type (Last_As_Int);\n \n          return\n-           (Capacity     => Length,\n-            Last         => Last,\n-            Elements_Ptr => <>,\n-            Elements     => (others => New_Item));\n+           (Capacity => Length,\n+            Last     => Last,\n+            Elements => (others => New_Item));\n       end;\n    end To_Vector;\n "}, {"sha": "5b62664097c8556662ef7ee5566f649549c7bb2f", "filename": "gcc/ada/libgnat/a-cofove.ads", "status": "modified", "additions": 9, "deletions": 50, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.ads?ref=584b52902b4b1bbcabc0e5bdd4196bd223d2f5a8", "patch": "@@ -40,12 +40,6 @@ with Ada.Containers.Functional_Vectors;\n generic\n    type Index_Type is range <>;\n    type Element_Type is private;\n-\n-   Bounded : Boolean := True;\n-   --  If True, the containers are bounded; the initial capacity is the maximum\n-   --  size, and heap allocation will be avoided. If False, the containers can\n-   --  grow via heap allocation.\n-\n package Ada.Containers.Formal_Vectors with\n   SPARK_Mode\n is\n@@ -73,17 +67,8 @@ is\n \n    subtype Capacity_Range is Count_Type range 0 .. Last_Count;\n \n-   type Vector (Capacity : Capacity_Range) is limited private with\n+   type Vector (Capacity : Capacity_Range) is private with\n      Default_Initial_Condition => Is_Empty (Vector);\n-   --  In the bounded case, Capacity is the capacity of the container, which\n-   --  never changes. In the unbounded case, Capacity is the initial capacity\n-   --  of the container, and operations such as Reserve_Capacity and Append can\n-   --  increase the capacity. The capacity never shrinks, except in the case of\n-   --  Clear.\n-   --\n-   --  Note that all objects of type Vector are constrained, including in the\n-   --  unbounded case; you can't assign from one object to another if the\n-   --  Capacity is different.\n \n    function Length (Container : Vector) return Capacity_Range with\n      Global => null,\n@@ -220,19 +205,15 @@ is\n    function Capacity (Container : Vector) return Capacity_Range with\n      Global => null,\n      Post   =>\n-       Capacity'Result =\n-         (if Bounded then\n-             Container.Capacity\n-          else\n-             Capacity_Range'Last);\n+       Capacity'Result = Container.Capacity;\n    pragma Annotate (GNATprove, Inline_For_Proof, Capacity);\n \n    procedure Reserve_Capacity\n      (Container : in out Vector;\n       Capacity  : Capacity_Range)\n    with\n      Global => null,\n-     Pre    => (if Bounded then Capacity <= Container.Capacity),\n+     Pre    => Capacity <= Container.Capacity,\n      Post   => Model (Container) = Model (Container)'Old;\n \n    function Is_Empty (Container : Vector) return Boolean with\n@@ -242,21 +223,18 @@ is\n    procedure Clear (Container : in out Vector) with\n      Global => null,\n      Post   => Length (Container) = 0;\n-   --  Note that this reclaims storage in the unbounded case. You need to call\n-   --  this before a container goes out of scope in order to avoid storage\n-   --  leaks. In addition, \"X := ...\" can leak unless you Clear(X) first.\n \n    procedure Assign (Target : in out Vector; Source : Vector) with\n      Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Target.Capacity),\n+     Pre    => Length (Source) <= Target.Capacity,\n      Post   => Model (Target) = Model (Source);\n \n    function Copy\n      (Source   : Vector;\n       Capacity : Capacity_Range := 0) return Vector\n    with\n      Global => null,\n-     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity)),\n+     Pre    => (Capacity = 0 or Length (Source) <= Capacity),\n      Post   =>\n        Model (Copy'Result) = Model (Source)\n          and (if Capacity = 0 then\n@@ -267,7 +245,7 @@ is\n    procedure Move (Target : in out Vector; Source : in out Vector)\n    with\n      Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Capacity (Target)),\n+     Pre    => Length (Source) <= Capacity (Target),\n      Post   => Model (Target) = Model (Source)'Old and Length (Source) = 0;\n \n    function Element\n@@ -894,30 +872,11 @@ private\n    type Elements_Array is array (Array_Index range <>) of Element_Type;\n    function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n-   type Elements_Array_Ptr is access all Elements_Array;\n-\n-   type Vector (Capacity : Capacity_Range) is limited record\n-\n-      --  In the bounded case, the elements are stored in Elements. In the\n-      --  unbounded case, the elements are initially stored in Elements, until\n-      --  we run out of room, then we switch to Elements_Ptr.\n-\n-      Last         : Extended_Index := No_Index;\n-      Elements_Ptr : Elements_Array_Ptr := null;\n-      Elements     : aliased Elements_Array (1 .. Capacity);\n+   type Vector (Capacity : Capacity_Range) is record\n+      Last     : Extended_Index := No_Index;\n+      Elements : Elements_Array (1 .. Capacity);\n    end record;\n \n-   --  The primary reason Vector is limited is that in the unbounded case, once\n-   --  Elements_Ptr is in use, assignment statements won't work. \"X := Y;\" will\n-   --  cause X and Y to share state; that is, X.Elements_Ptr = Y.Elements_Ptr,\n-   --  so for example \"Append (X, ...);\" will modify BOTH X and Y. That would\n-   --  allow SPARK to \"prove\" things that are false. We could fix that by\n-   --  making Vector a controlled type, and override Adjust to make a deep\n-   --  copy, but finalization is not allowed in SPARK.\n-   --\n-   --  Note that (unfortunately) this means that 'Old and 'Loop_Entry are not\n-   --  allowed on Vectors.\n-\n    function Empty_Vector return Vector is\n      ((Capacity => 0, others => <>));\n "}]}