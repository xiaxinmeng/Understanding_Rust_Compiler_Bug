{"sha": "9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI0MWViYmNkZjllMzMyODVhMGVlYmViN2M4NDFhZmUyMGU0YTdjMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2019-11-15T14:51:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2019-11-15T14:51:05Z"}, "message": "Implement P1816R0, class template argument deduction for aggregates.\n\nRather than reimplement brace elision here, we call reshape_init and then\ndiscard the result.  We needed to set CLASSTYPE_NON_AGGREGATE a bit more in\nthis patch, since outside a template it's set in check_bases_and_members.\n\n\t* pt.c (maybe_aggr_guide, collect_ctor_idx_types): New.\n\t(is_spec_or_derived): Split out from do_class_deduction.\n\t(build_deduction_guide): Handle aggregate guide.\n\t* class.c (finish_struct): Set CLASSTYPE_NON_AGGREGATE in a\n\ttemplate.\n\t* cp-tree.h (CP_AGGREGATE_TYPE_P): An incomplete class is not an\n\taggregate.\n\nFrom-SVN: r278298", "tree": {"sha": "63d5b9a564430d47fdbe55993a501c3fa8fa098e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63d5b9a564430d47fdbe55993a501c3fa8fa098e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6e20012ef792d659fec65fafecc29736c57f79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6e20012ef792d659fec65fafecc29736c57f79c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6e20012ef792d659fec65fafecc29736c57f79c"}], "stats": {"total": 289, "additions": 254, "deletions": 35}, "files": [{"sha": "0129731503bbbb854effeb233aa6d97f4be882b3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -1,3 +1,14 @@\n+2019-11-14  Jason Merrill  <jason@redhat.com>\n+\n+\tImplement P1816R0, class template argument deduction for aggregates.\n+\t* pt.c (maybe_aggr_guide, collect_ctor_idx_types): New.\n+\t(is_spec_or_derived): Split out from do_class_deduction.\n+\t(build_deduction_guide): Handle aggregate guide.\n+\t* class.c (finish_struct): Set CLASSTYPE_NON_AGGREGATE in a\n+\ttemplate.\n+\t* cp-tree.h (CP_AGGREGATE_TYPE_P): An incomplete class is not an\n+\taggregate.\n+\n 2019-11-14  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* call.c (build_conditional_expr_1): Use truth_type_for instead"}, {"sha": "ef1d51369637357d6ddb37063e10508f1fa95e6c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -7349,7 +7349,16 @@ finish_struct (tree t, tree attributes)\n \t\tadd_method (t, *iter, true);\n \t  }\n \telse if (DECL_DECLARES_FUNCTION_P (x))\n-\t  DECL_IN_AGGR_P (x) = false;\n+\t  {\n+\t    DECL_IN_AGGR_P (x) = false;\n+\t    if (DECL_VIRTUAL_P (x))\n+\t      CLASSTYPE_NON_AGGREGATE (t) = true;\n+\t  }\n+\telse if (TREE_CODE (x) == FIELD_DECL)\n+\t  {\n+\t    if (TREE_PROTECTED (x) || TREE_PRIVATE (x))\n+\t      CLASSTYPE_NON_AGGREGATE (t) = true;\n+\t  }\n \n       /* Also add a USING_DECL for operator=.  We know there'll be (at\n \t least) one, but we don't know the signature(s).  We want name\n@@ -7387,6 +7396,9 @@ finish_struct (tree t, tree attributes)\n       /* Remember current #pragma pack value.  */\n       TYPE_PRECISION (t) = maximum_field_alignment;\n \n+      if (TYPE_HAS_USER_CONSTRUCTOR (t))\n+\tCLASSTYPE_NON_AGGREGATE (t) = 1;\n+\n       /* Fix up any variants we've already built.  */\n       for (x = TYPE_NEXT_VARIANT (t); x; x = TYPE_NEXT_VARIANT (x))\n \t{"}, {"sha": "56b75ca51f586c6075a0c2ffab2069c3658c4caf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -4251,7 +4251,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define CP_AGGREGATE_TYPE_P(TYPE)\t\t\t\t\\\n   (TREE_CODE (TYPE) == VECTOR_TYPE\t\t\t\t\\\n    || TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\\\n-   || (CLASS_TYPE_P (TYPE) && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n+   || (CLASS_TYPE_P (TYPE) && COMPLETE_TYPE_P (TYPE) && !CLASSTYPE_NON_AGGREGATE (TYPE)))\n \n /* Nonzero for a class type means that the class type has a\n    user-declared constructor.  */"}, {"sha": "8f7734a7a4196ac34c56c42fe0028e6b8b76e058", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 140, "deletions": 32, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -27724,28 +27724,39 @@ rewrite_template_parm (tree olddecl, unsigned index, unsigned level,\n \n /* Returns a C++17 class deduction guide template based on the constructor\n    CTOR.  As a special case, CTOR can be a RECORD_TYPE for an implicit default\n-   guide, or REFERENCE_TYPE for an implicit copy/move guide.  */\n+   guide, REFERENCE_TYPE for an implicit copy/move guide, or TREE_LIST for an\n+   aggregate initialization guide.  */\n \n static tree\n-build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n+build_deduction_guide (tree type, tree ctor, tree outer_args, tsubst_flags_t complain)\n {\n-  tree type, tparms, targs, fparms, fargs, ci;\n+  tree tparms, targs, fparms, fargs, ci;\n   bool memtmpl = false;\n   bool explicit_p;\n   location_t loc;\n   tree fn_tmpl = NULL_TREE;\n \n-  if (TYPE_P (ctor))\n+  if (outer_args)\n     {\n-      type = ctor;\n-      bool copy_p = TYPE_REF_P (type);\n-      if (copy_p)\n+      ++processing_template_decl;\n+      type = tsubst (type, outer_args, complain, CLASSTYPE_TI_TEMPLATE (type));\n+      --processing_template_decl;\n+    }\n+\n+  if (!DECL_DECLARES_FUNCTION_P (ctor))\n+    {\n+      if (TYPE_P (ctor))\n \t{\n-\t  type = TREE_TYPE (type);\n-\t  fparms = tree_cons (NULL_TREE, type, void_list_node);\n+\t  bool copy_p = TYPE_REF_P (ctor);\n+\t  if (copy_p)\n+\t    fparms = tree_cons (NULL_TREE, type, void_list_node);\n+\t  else\n+\t    fparms = void_list_node;\n \t}\n+      else if (TREE_CODE (ctor) == TREE_LIST)\n+\tfparms = ctor;\n       else\n-\tfparms = void_list_node;\n+\tgcc_unreachable ();\n \n       tree ctmpl = CLASSTYPE_TI_TEMPLATE (type);\n       tparms = DECL_TEMPLATE_PARMS (ctmpl);\n@@ -27767,8 +27778,6 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n \tfn_tmpl = tsubst (fn_tmpl, outer_args, complain, ctor);\n       ctor = DECL_TEMPLATE_RESULT (fn_tmpl);\n \n-      type = DECL_CONTEXT (ctor);\n-\n       tparms = DECL_TEMPLATE_PARMS (fn_tmpl);\n       /* If type is a member class template, DECL_TI_ARGS (ctor) will have\n \t fully specialized args for the enclosing class.  Strip those off, as\n@@ -27889,6 +27898,103 @@ build_deduction_guide (tree ctor, tree outer_args, tsubst_flags_t complain)\n   return ded_tmpl;\n }\n \n+/* Add to LIST the member types for the reshaped initializer CTOR.  */\n+\n+static tree\n+collect_ctor_idx_types (tree ctor, tree list)\n+{\n+  vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (ctor);\n+  tree idx, val; unsigned i;\n+  FOR_EACH_CONSTRUCTOR_ELT (v, i, idx, val)\n+    {\n+      if (BRACE_ENCLOSED_INITIALIZER_P (val)\n+\t  && CONSTRUCTOR_NELTS (val))\n+\tif (tree subidx = CONSTRUCTOR_ELT (val, 0)->index)\n+\t  if (TREE_CODE (subidx) == FIELD_DECL)\n+\t    {\n+\t      list = collect_ctor_idx_types (val, list);\n+\t      continue;\n+\t    }\n+      tree ftype = finish_decltype_type (idx, true, tf_none);\n+      list = tree_cons (NULL_TREE, ftype, list);\n+    }\n+\n+  return list;\n+}\n+\n+/* Return a C++20 aggregate deduction candidate for TYPE initialized from\n+   INIT.  */\n+\n+static tree\n+maybe_aggr_guide (tree type, tree init)\n+{\n+  if (cxx_dialect < cxx2a)\n+    return NULL_TREE;\n+\n+  if (init == NULL_TREE)\n+    return NULL_TREE;\n+  if (!CP_AGGREGATE_TYPE_P (type))\n+    return NULL_TREE;\n+\n+  /* If we encounter a problem, we just won't add the candidate.  */\n+  tsubst_flags_t complain = tf_none;\n+\n+  tree parms = NULL_TREE;\n+  if (TREE_CODE (init) == CONSTRUCTOR)\n+    {\n+      init = reshape_init (type, init, complain);\n+      if (init == error_mark_node)\n+\treturn NULL_TREE;\n+      parms = collect_ctor_idx_types (init, parms);\n+    }\n+  else if (TREE_CODE (init) == TREE_LIST)\n+    {\n+      int len = list_length (init);\n+      for (tree field = TYPE_FIELDS (type);\n+\t   len;\n+\t   --len, field = DECL_CHAIN (field))\n+\t{\n+\t  field = next_initializable_field (field);\n+\t  if (!field)\n+\t    return NULL_TREE;\n+\t  tree ftype = finish_decltype_type (field, true, complain);\n+\t  parms = tree_cons (NULL_TREE, ftype, parms);\n+\t}\n+    }\n+  else\n+    /* Aggregate initialization doesn't apply to an initializer expression.  */\n+    return NULL_TREE;\n+\n+  if (parms)\n+    {\n+      tree last = parms;\n+      parms = nreverse (parms);\n+      TREE_CHAIN (last) = void_list_node;\n+      tree guide = build_deduction_guide (type, parms, NULL_TREE, complain);\n+      return guide;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return whether ETYPE is, or is derived from, a specialization of TMPL.  */\n+\n+static bool\n+is_spec_or_derived (tree etype, tree tmpl)\n+{\n+  if (!etype || !CLASS_TYPE_P (etype))\n+    return false;\n+\n+  tree type = TREE_TYPE (tmpl);\n+  tree tparms = (INNERMOST_TEMPLATE_PARMS\n+\t\t (DECL_TEMPLATE_PARMS (tmpl)));\n+  tree targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n+  int err = unify (tparms, targs, type, etype,\n+\t\t   UNIFY_ALLOW_DERIVED, /*explain*/false);\n+  ggc_free (targs);\n+  return !err;\n+}\n+\n /* Deduce template arguments for the class template placeholder PTYPE for\n    template TMPL based on the initializer INIT, and return the resulting\n    type.  */\n@@ -27913,43 +28019,40 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n   tree type = TREE_TYPE (tmpl);\n \n   bool try_list_ctor = false;\n+  bool copy_init = false;\n \n   releasing_vec rv_args = NULL;\n   vec<tree,va_gc> *&args = *&rv_args;\n-  if (init == NULL_TREE\n-      || TREE_CODE (init) == TREE_LIST)\n-    args = make_tree_vector_from_list (init);\n+  if (init == NULL_TREE)\n+    args = make_tree_vector ();\n   else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n     {\n-      try_list_ctor = TYPE_HAS_LIST_CTOR (type);\n-      if (try_list_ctor && CONSTRUCTOR_NELTS (init) == 1)\n+      if (CONSTRUCTOR_NELTS (init) == 1)\n \t{\n \t  /* As an exception, the first phase in 16.3.1.7 (considering the\n \t     initializer list as a single argument) is omitted if the\n \t     initializer list consists of a single expression of type cv U,\n \t     where U is a specialization of C or a class derived from a\n \t     specialization of C.  */\n \t  tree elt = CONSTRUCTOR_ELT (init, 0)->value;\n-\t  if (!BRACE_ENCLOSED_INITIALIZER_P (elt))\n-\t    {\n-\t      tree etype = TREE_TYPE (elt);\n-\t      tree tparms = (INNERMOST_TEMPLATE_PARMS\n-\t\t\t     (DECL_TEMPLATE_PARMS (tmpl)));\n-\t      tree targs = make_tree_vec (TREE_VEC_LENGTH (tparms));\n-\t      int err = unify (tparms, targs, type, etype,\n-\t\t\t       UNIFY_ALLOW_DERIVED, /*explain*/false);\n-\t      if (err == 0)\n-\t\ttry_list_ctor = false;\n-\t      ggc_free (targs);\n-\t    }\n+\t  copy_init = is_spec_or_derived (TREE_TYPE (elt), tmpl);\n \t}\n+      try_list_ctor = !copy_init && TYPE_HAS_LIST_CTOR (type);\n       if (try_list_ctor || is_std_init_list (type))\n \targs = make_tree_vector_single (init);\n       else\n \targs = make_tree_vector_from_ctor (init);\n     }\n   else\n-    args = make_tree_vector_single (init);\n+    {\n+      if (TREE_CODE (init) == TREE_LIST)\n+\targs = make_tree_vector_from_list (init);\n+      else\n+\targs = make_tree_vector_single (init);\n+\n+      if (args->length() == 1)\n+\tcopy_init = is_spec_or_derived (TREE_TYPE ((*args)[0]), tmpl);\n+    }\n \n   tree dname = dguide_name (tmpl);\n   tree cands = lookup_qualified_name (CP_DECL_CONTEXT (tmpl), dname,\n@@ -27994,7 +28097,7 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n       if (iter.using_p ())\n \tcontinue;\n \n-      tree guide = build_deduction_guide (*iter, outer_args, complain);\n+      tree guide = build_deduction_guide (type, *iter, outer_args, complain);\n       if (guide == error_mark_node)\n \treturn error_mark_node;\n       if ((flags & LOOKUP_ONLYCONVERTING)\n@@ -28006,6 +28109,10 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n       saw_ctor = true;\n     }\n \n+  if (!copy_init)\n+    if (tree guide = maybe_aggr_guide (type, init))\n+      cands = lookup_add (guide, cands);\n+\n   tree call = error_mark_node;\n \n   /* If this is list-initialization and the class has a list constructor, first\n@@ -28047,7 +28154,8 @@ do_class_deduction (tree ptype, tree tmpl, tree init, int flags,\n \n       if (gtype)\n \t{\n-\t  tree guide = build_deduction_guide (gtype, outer_args, complain);\n+\t  tree guide = build_deduction_guide (type, gtype, outer_args,\n+\t\t\t\t\t      complain);\n \t  if (guide == error_mark_node)\n \t    return error_mark_node;\n \t  cands = lookup_add (guide, cands);"}, {"sha": "2585eb6194ac8fcd592fe8c8f9a71df00e7591b0", "filename": "gcc/testsuite/g++.dg/cpp1z/class-deduction43.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fclass-deduction43.C?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -7,4 +7,4 @@ struct array\n   int a [N];\n };\n \n-array a = { 1, 2, 3 };  // { dg-error \"cannot deduce\" }\n+array a = { 1, 2, 3 };  // { dg-error \"\" }"}, {"sha": "61ba65a1333d24eb1f6991ec69e33780667e99d6", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr1.C?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -0,0 +1,36 @@\n+// Testcase from P1816R0\n+// { dg-do compile { target c++2a } }\n+\n+template <typename T>\n+struct S {\n+  T x;\n+  T y;\n+};\n+\n+S s = { 1, 2 };\n+\n+template <typename T>\n+struct C {\n+  S<T> s;\n+  T t;\n+};\n+template <typename T>\n+struct D {\n+  S<int> s;\n+  T t;\n+};\n+C c1 = {1, 2};\t\t\t// { dg-error \"\" \"deduction failed\" }\n+C c2 = {1, 2, 3};\t\t// { dg-error \"\" \"deduction failed\" }\n+C c3 = {{1u, 2u}, 3};\t\t// { dg-bogus \"\" \"OK, C<int> deduced\" }\n+D d1 = {1, 2};\t\t\t// { dg-error \"\" \"deduction failed\" }\n+D d2 = {1, 2, 3};\t // { dg-bogus \"\" \"OK, braces elided, D<int> deduced\" }\n+template <typename T>\n+struct I {\n+  using type = T;\n+};\n+template <typename T>\n+struct E {\n+  typename I<T>::type i;\n+  T t;\n+};\n+E e1 = {1, 2};\t\t\t// { dg-bogus \"\" \"OK, E<int> deduced\" }"}, {"sha": "896554f610a55b20f5fd028a4ec79508181b15cc", "filename": "gcc/testsuite/g++.dg/cpp2a/class-deduction-aggr2.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fclass-deduction-aggr2.C?ref=9b41ebbcdf9e33285a0eebeb7c841afe20e4a7c1", "patch": "@@ -0,0 +1,52 @@\n+// Test that non-aggregates don't get the aggregate deduction.\n+// { dg-do compile { target c++2a } }\n+// { dg-prune-output \"no matching function\" }\n+\n+struct A { A(); };\n+\n+template <typename T>\n+struct S1 {\n+  T x;\n+};\n+\n+S1 s1 = {1};\t\t\t// OK\n+\n+template <typename T>\n+struct S2 {\n+  S2 ();\n+  T x;\n+};\n+\n+S2 s2 = {1};\t\t\t// { dg-error \"deduction failed\" }\n+\n+template <typename T>\n+struct S3 {\n+private:\n+  T x;\n+};\n+\n+S3 s3 = {1};\t\t\t// { dg-error \"deduction failed\" }\n+\n+template <typename T>\n+struct S4 {\n+  virtual void f();\n+  T x;\n+};\n+\n+S4 s4 = {1};\t\t\t// { dg-error \"deduction failed\" }\n+\n+template <typename T>\n+struct S5: public A {\n+  using A::A;\n+  T x;\n+};\n+\n+S5 s5 = {1};\t\t\t// { dg-error \"deduction failed\" }\n+\n+template <typename T>\n+struct S6: virtual A {\n+  T x;\n+};\n+\n+S6 s6 = {1};\t\t\t// { dg-error \"deduction failed\" }\n+"}]}