{"sha": "db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIxMGRmM2RmY2Q5ZWVjNWJjNDc3YmYzZWM2ODllNjJmOGMxMmRiNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-12-24T21:46:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-12-24T21:46:14Z"}, "message": "PR c++/41305, DR 384\n\n\tPR c++/41305, DR 384\n\t* name-lookup.c (arg_assoc_class): Split out arg_assoc_class_only\n\tand arg_assoc_bases.\n\t(friend_of_associated_class_p): Remove.\n\t(arg_assoc_namespace): Don't call it.\n\t(arg_assoc_template_arg): Use arg_assoc_class_only for member\n\ttemplate context.\n\t(arg_assoc_type): Handle UNION_TYPE and ENUMERAL_TYPE properly.\n\n\t* name-lookup.c (arg_assoc): Handle TEMPLATE_ID_EXPR properly.\n\nFrom-SVN: r155461", "tree": {"sha": "c487a6204121c71d9afe1c113f2b34f12c97fdc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c487a6204121c71d9afe1c113f2b34f12c97fdc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17fad3611f3624776fc617e7734a80f7abba0562", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17fad3611f3624776fc617e7734a80f7abba0562", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17fad3611f3624776fc617e7734a80f7abba0562"}], "stats": {"total": 278, "additions": 174, "deletions": 104}, "files": [{"sha": "57a464345c7144f927765f00f1ce9601f8ec30cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -1,3 +1,16 @@\n+2009-12-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/41305, DR 384\n+\t* name-lookup.c (arg_assoc_class): Split out arg_assoc_class_only\n+\tand arg_assoc_bases.\n+\t(friend_of_associated_class_p): Remove.\n+\t(arg_assoc_namespace): Don't call it.\n+\t(arg_assoc_template_arg): Use arg_assoc_class_only for member\n+\ttemplate context.\n+\t(arg_assoc_type): Handle UNION_TYPE and ENUMERAL_TYPE properly.\n+\n+\t* name-lookup.c (arg_assoc): Handle TEMPLATE_ID_EXPR properly.\n+\n 2009-12-23  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/42260"}, {"sha": "8f693464875c473a7f713230317aede111d2676c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 86, "deletions": 104, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -4549,6 +4549,8 @@ static bool arg_assoc_args_vec (struct arg_lookup*, VEC(tree,gc) *);\n static bool arg_assoc_type (struct arg_lookup*, tree);\n static bool add_function (struct arg_lookup *, tree);\n static bool arg_assoc_namespace (struct arg_lookup *, tree);\n+static bool arg_assoc_class_only (struct arg_lookup *, tree);\n+static bool arg_assoc_bases (struct arg_lookup *, tree);\n static bool arg_assoc_class (struct arg_lookup *, tree);\n static bool arg_assoc_template_arg (struct arg_lookup*, tree);\n \n@@ -4606,53 +4608,6 @@ is_associated_namespace (tree current, tree scope)\n     }\n }\n \n-/* Return whether FN is a friend of an associated class of ARG.  */\n-\n-static bool\n-friend_of_associated_class_p (tree arg, tree fn)\n-{\n-  tree type;\n-\n-  if (TYPE_P (arg))\n-    type = arg;\n-  else if (type_unknown_p (arg))\n-    return false;\n-  else\n-    type = TREE_TYPE (arg);\n-\n-  /* If TYPE is a class, the class itself and all base classes are\n-     associated classes.  */\n-  if (CLASS_TYPE_P (type))\n-    {\n-      if (is_friend (type, fn))\n-\treturn true;\n-\n-      if (TYPE_BINFO (type))\n-\t{\n-\t  tree binfo, base_binfo;\n-\t  int i;\n-\n-\t  for (binfo = TYPE_BINFO (type), i = 0;\n-\t       BINFO_BASE_ITERATE (binfo, i, base_binfo);\n-\t       i++)\n-\t    if (is_friend (BINFO_TYPE (base_binfo), fn))\n-\t      return true;\n-\t}\n-    }\n-\n-  /* If TYPE is a class member, the class of which it is a member is\n-     an associated class.  */\n-  if ((CLASS_TYPE_P (type)\n-       || TREE_CODE (type) == UNION_TYPE\n-       || TREE_CODE (type) == ENUMERAL_TYPE)\n-      && TYPE_CONTEXT (type)\n-      && CLASS_TYPE_P (TYPE_CONTEXT (type))\n-      && is_friend (TYPE_CONTEXT (type), fn))\n-    return true;\n-\n-  return false;\n-}\n-\n /* Add functions of a namespace to the lookup structure.\n    Returns true on error.  */\n \n@@ -4686,18 +4641,9 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n     {\n       /* We don't want to find arbitrary hidden functions via argument\n \t dependent lookup.  We only want to find friends of associated\n-\t classes.  */\n+\t classes, which we'll do via arg_assoc_class.  */\n       if (hidden_name_p (OVL_CURRENT (value)))\n-\t{\n-\t  unsigned int ix;\n-\t  tree arg;\n-\n-\t  for (ix = 0; VEC_iterate (tree, k->args, ix, arg); ++ix)\n-\t    if (friend_of_associated_class_p (arg, OVL_CURRENT (value)))\n-\t      break;\n-\t  if (ix >= VEC_length (tree, k->args))\n-\t    continue;\n-\t}\n+\tcontinue;\n \n       if (add_function (k, OVL_CURRENT (value)))\n \treturn true;\n@@ -4736,7 +4682,7 @@ arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n \treturn arg_assoc_namespace (k, ctx);\n       /* Otherwise, it must be member template.  */\n       else\n-\treturn arg_assoc_class (k, ctx);\n+\treturn arg_assoc_class_only (k, ctx);\n     }\n   /* It's an argument pack; handle it recursively.  */\n   else if (ARGUMENT_PACK_P (arg))\n@@ -4758,41 +4704,25 @@ arg_assoc_template_arg (struct arg_lookup *k, tree arg)\n     return false;\n }\n \n-/* Adds everything associated with class to the lookup structure.\n+/* Adds the class and its friends to the lookup structure.\n    Returns true on error.  */\n \n static bool\n-arg_assoc_class (struct arg_lookup *k, tree type)\n+arg_assoc_class_only (struct arg_lookup *k, tree type)\n {\n   tree list, friends, context;\n-  int i;\n \n-  /* Backend build structures, such as __builtin_va_list, aren't\n+  /* Backend-built structures, such as __builtin_va_list, aren't\n      affected by all this.  */\n   if (!CLASS_TYPE_P (type))\n     return false;\n \n-  if (purpose_member (type, k->classes))\n-    return false;\n-  k->classes = tree_cons (type, NULL_TREE, k->classes);\n-\n   context = decl_namespace_context (type);\n   if (arg_assoc_namespace (k, context))\n     return true;\n \n   complete_type (type);\n \n-  if (TYPE_BINFO (type))\n-    {\n-      /* Process baseclasses.  */\n-      tree binfo, base_binfo;\n-\n-      for (binfo = TYPE_BINFO (type), i = 0;\n-\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-\tif (arg_assoc_class (k, BINFO_TYPE (base_binfo)))\n-\t  return true;\n-    }\n-\n   /* Process friends.  */\n   for (list = DECL_FRIENDLIST (TYPE_MAIN_DECL (type)); list;\n        list = TREE_CHAIN (list))\n@@ -4815,13 +4745,79 @@ arg_assoc_class (struct arg_lookup *k, tree type)\n \t    return true;\n \t}\n \n+  return false;\n+}\n+\n+/* Adds the class and its bases to the lookup structure.\n+   Returns true on error.  */\n+\n+static bool\n+arg_assoc_bases (struct arg_lookup *k, tree type)\n+{\n+  if (arg_assoc_class_only (k, type))\n+    return true;\n+\n+  if (TYPE_BINFO (type))\n+    {\n+      /* Process baseclasses.  */\n+      tree binfo, base_binfo;\n+      int i;\n+\n+      for (binfo = TYPE_BINFO (type), i = 0;\n+\t   BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+\tif (arg_assoc_bases (k, BINFO_TYPE (base_binfo)))\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Adds everything associated with a class argument type to the lookup\n+   structure.  Returns true on error.\n+\n+   If T is a class type (including unions), its associated classes are: the\n+   class itself; the class of which it is a member, if any; and its direct\n+   and indirect base classes. Its associated namespaces are the namespaces\n+   of which its associated classes are members. Furthermore, if T is a\n+   class template specialization, its associated namespaces and classes\n+   also include: the namespaces and classes associated with the types of\n+   the template arguments provided for template type parameters (excluding\n+   template template parameters); the namespaces of which any template\n+   template arguments are members; and the classes of which any member\n+   templates used as template template arguments are members. [ Note:\n+   non-type template arguments do not contribute to the set of associated\n+   namespaces.  --end note] */\n+\n+static bool\n+arg_assoc_class (struct arg_lookup *k, tree type)\n+{\n+  tree list;\n+  int i;\n+\n+  /* Backend build structures, such as __builtin_va_list, aren't\n+     affected by all this.  */\n+  if (!CLASS_TYPE_P (type))\n+    return false;\n+\n+  if (purpose_member (type, k->classes))\n+    return false;\n+  k->classes = tree_cons (type, NULL_TREE, k->classes);\n+\n+  if (TYPE_CLASS_SCOPE_P (type)\n+      && arg_assoc_class_only (k, TYPE_CONTEXT (type)))\n+    return true;\n+\n+  if (arg_assoc_bases (k, type))\n+    return true;\n+\n   /* Process template arguments.  */\n   if (CLASSTYPE_TEMPLATE_INFO (type)\n       && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (type)))\n     {\n       list = INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (type));\n       for (i = 0; i < TREE_VEC_LENGTH (list); ++i)\n-\targ_assoc_template_arg (k, TREE_VEC_ELT (list, i));\n+\tif (arg_assoc_template_arg (k, TREE_VEC_ELT (list, i)))\n+\t  return true;\n     }\n \n   return false;\n@@ -4861,13 +4857,16 @@ arg_assoc_type (struct arg_lookup *k, tree type)\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (type))\n \treturn arg_assoc_type (k, TYPE_PTRMEMFUNC_FN_TYPE (type));\n+    case UNION_TYPE:\n       return arg_assoc_class (k, type);\n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n     case ARRAY_TYPE:\n       return arg_assoc_type (k, TREE_TYPE (type));\n-    case UNION_TYPE:\n     case ENUMERAL_TYPE:\n+      if (TYPE_CLASS_SCOPE_P (type)\n+\t  && arg_assoc_class_only (k, TYPE_CONTEXT (type)))\n+\treturn true;\n       return arg_assoc_namespace (k, decl_namespace_context (type));\n     case METHOD_TYPE:\n       /* The basetype is referenced in the first arg type, so just\n@@ -4951,34 +4950,17 @@ arg_assoc (struct arg_lookup *k, tree n)\n     return arg_assoc_type (k, TREE_TYPE (n));\n   if (TREE_CODE (n) == TEMPLATE_ID_EXPR)\n     {\n-      /* [basic.lookup.koenig]\n-\n-\t If T is a template-id, its associated namespaces and classes\n-\t are the namespace in which the template is defined; for\n-\t member templates, the member template's class...  */\n+      /* The working paper doesn't currently say how to handle template-id\n+\t arguments.  The sensible thing would seem to be to handle the list\n+\t of template candidates like a normal overload set, and handle the\n+\t template arguments like we do for class template\n+\t specializations.  */\n       tree templ = TREE_OPERAND (n, 0);\n       tree args = TREE_OPERAND (n, 1);\n-      tree ctx;\n       int ix;\n \n-      if (TREE_CODE (templ) == COMPONENT_REF)\n-\ttempl = TREE_OPERAND (templ, 1);\n-\n-      /* First, the template.  There may actually be more than one if\n-\t this is an overloaded function template.  But, in that case,\n-\t we only need the first; all the functions will be in the same\n-\t namespace.  */\n-      templ = OVL_CURRENT (templ);\n-\n-      ctx = CP_DECL_CONTEXT (templ);\n-\n-      if (TREE_CODE (ctx) == NAMESPACE_DECL)\n-\t{\n-\t  if (arg_assoc_namespace (k, ctx) == 1)\n-\t    return true;\n-\t}\n-      /* It must be a member template.  */\n-      else if (arg_assoc_class (k, ctx) == 1)\n+      /* First the templates.  */\n+      if (arg_assoc (k, templ))\n \treturn true;\n \n       /* Now the arguments.  */"}, {"sha": "14bc7b7913cfc61a735e12eafef218ee0f155c95", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -1,3 +1,11 @@\n+2009-12-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/41305\n+\t* g++.dg/lookup/koenig9.C: New test.\n+\t* g++.dg/lookup/koenig10.C: New test.\n+\t* g++.dg/lookup/koenig11.C: New test.\n+\t* g++.dg/lookup/koenig12.C: New test.\n+\n 2009-12-24  Julian Brown  <julian@codesourcery.com>\n             Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n "}, {"sha": "f2fce9cf74f62063c07a41bc84b97858c3f240e6", "filename": "gcc/testsuite/g++.dg/lookup/koenig10.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig10.C?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -0,0 +1,12 @@\n+// Test for proper handling of class-scope enums.\n+\n+struct A\n+{\n+  enum E { e };\n+  friend void f (E);\n+};\n+\n+int main()\n+{\n+  f(A::e);\n+}"}, {"sha": "dab853bf0f73d8bbefd1d33018acc01aa5309ba9", "filename": "gcc/testsuite/g++.dg/lookup/koenig11.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig11.C?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -0,0 +1,12 @@\n+// Test that we treat unions like other classes in arg-dep lookup.\n+\n+union U\n+{\n+  friend void f (U);\n+};\n+\n+int main()\n+{\n+  U u;\n+  f(u);\n+}"}, {"sha": "c1358993909fe55afe1572757bcf8c372f1f938f", "filename": "gcc/testsuite/g++.dg/lookup/koenig12.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig12.C?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -0,0 +1,18 @@\n+// PR c++/41305\n+// We got into infinite recursion instantiating the B<U> series.\n+\n+template <class T> struct A { };\n+template <class T, class U = A<T> > struct B;\n+template <class T> struct C { };\n+\n+template <class T, class U> struct B: C<B<U> >\n+{\n+  friend void f(B) { }\n+};\n+\n+B<int> b;\n+\n+int main()\n+{\n+  f(b);\n+}"}, {"sha": "f867a32ecc8e250419be040c82a08cb71c077733", "filename": "gcc/testsuite/g++.dg/lookup/koenig9.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db10df3dfcd9eec5bc477bf3ec689e62f8c12db5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fkoenig9.C?ref=db10df3dfcd9eec5bc477bf3ec689e62f8c12db5", "patch": "@@ -0,0 +1,25 @@\n+// Test for sensible handling of template-ids with arg-dep lookup.\n+// This is still an open issue.\n+\n+namespace N\n+{\n+  struct A { };\n+  void f(void (*)(int, N::A));\n+}\n+\n+namespace M\n+{\n+  struct B { };\n+  void f(void (*)(B, N::A));\n+}\n+\n+template <class T>\n+void g(T, N::A);\n+\n+void g();\n+\n+int main()\n+{\n+  f(g<int>);\n+  f(g<M::B>);\n+}"}]}