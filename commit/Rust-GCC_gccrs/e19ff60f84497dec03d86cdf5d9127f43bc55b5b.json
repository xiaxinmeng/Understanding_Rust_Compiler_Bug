{"sha": "e19ff60f84497dec03d86cdf5d9127f43bc55b5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5ZmY2MGY4NDQ5N2RlYzAzZDg2Y2RmNWQ5MTI3ZjQzYmM1NWI1Yg==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-04T18:06:11Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-04T18:06:11Z"}, "message": "(type attribute): Add fmadd.\n\n(cpu attribute): Add r8000.\n(umaddi+1, ..., umadddi+8): Add pattern for multiply accumulate.\n(movdi): Legitimize addresses, just like movsi does.\n(loadgp): New pattern for 64 bit ABI.\n(shift patterns): Use INTVAL instead of XINT for constants.\n(jump, tablejump_interal[12]): Add 64 bit ABI support.\n(movsicc-8, ..., movsicc): Add patterns for conditional moves.\n\nFrom-SVN: r8864", "tree": {"sha": "11c3a077e1856ef3e78518752427b14c4fdde21f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11c3a077e1856ef3e78518752427b14c4fdde21f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e19ff60f84497dec03d86cdf5d9127f43bc55b5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19ff60f84497dec03d86cdf5d9127f43bc55b5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e19ff60f84497dec03d86cdf5d9127f43bc55b5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19ff60f84497dec03d86cdf5d9127f43bc55b5b/comments", "author": null, "committer": null, "parents": [{"sha": "335634874738d42760f1966133810dd7c069cab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335634874738d42760f1966133810dd7c069cab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335634874738d42760f1966133810dd7c069cab8"}], "stats": {"total": 402, "additions": 384, "deletions": 18}, "files": [{"sha": "ff7bd404c3f5c8d5905b0ad45c47ff28fbabd610", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 384, "deletions": 18, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19ff60f84497dec03d86cdf5d9127f43bc55b5b/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19ff60f84497dec03d86cdf5d9127f43bc55b5b/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=e19ff60f84497dec03d86cdf5d9127f43bc55b5b", "patch": "@@ -21,6 +21,15 @@\n ;; along with GNU CC; see the file COPYING.  If not, write to\n ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n \n+;; ??? MIPS4 has 8 floating point condition codes.  This is not supported yet.\n+\n+;; ??? MIPS4 has floating point doubleword/word load/stores that accept a\n+;; base+index addressing mode.  There are no such load/stores for the integer\n+;; registers.  This is not supported yet.\n+\n+;; ??? Currently does not have define_function_unit support for the R8000.\n+;; Must include new entries for fmadd in addition to existing entries.\n+\n \f\n \n ;; ....................\n@@ -45,6 +54,7 @@\n ;; icmp\t\tinteger compare\n ;; fadd\t\tfloating point add/subtract\n ;; fmul\t\tfloating point multiply\n+;; fmadd\tfloating point multiply-add\n ;; fdiv\t\tfloating point divide\n ;; fabs\t\tfloating point absolute value\n ;; fneg\t\tfloating point negation\n@@ -55,7 +65,7 @@\n ;; nop\t\tno operation\n \n (define_attr \"type\"\n-  \"unknown,branch,jump,call,load,store,move,xfer,hilo,arith,darith,imul,idiv,icmp,fadd,fmul,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,multi,nop\"\n+  \"unknown,branch,jump,call,load,store,move,xfer,hilo,arith,darith,imul,idiv,icmp,fadd,fmul,fmadd,fdiv,fabs,fneg,fcmp,fcvt,fsqrt,multi,nop\"\n   (const_string \"unknown\"))\n \n ;; Main data type used by the insn\n@@ -81,7 +91,8 @@\n ;;           (eq (symbol_ref \"mips_cpu\") (symbol_ref \"PROCESSOR_R6000\"))   (const_string \"r6000\")]\n ;;          (const_string \"default\"))))\n \n-(define_attr \"cpu\" \"default,r3000,r6000,r4000,r4600\"\n+;; ??? Fix everything that tests this attribute.\n+(define_attr \"cpu\" \"default,r3000,r6000,r4000,r4600,r8000\"\n   (const (symbol_ref \"mips_cpu_attr\")))\n \n ;; Attribute defining whether or not we can use the branch-likely instructions\n@@ -1060,6 +1071,97 @@\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"   \"1\")])\n+\n+;; Floating point multiply accumulate instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(plus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t\t  (match_operand:DF 2 \"register_operand\" \"f\"))\n+\t\t (match_operand:DF 3 \"register_operand\" \"f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"madd.d\\\\t%0,%3,%1,%2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t\t  (match_operand:SF 2 \"register_operand\" \"f\"))\n+\t\t (match_operand:SF 3 \"register_operand\" \"f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"madd.s\\\\t%0,%3,%1,%2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(minus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t\t   (match_operand:DF 2 \"register_operand\" \"f\"))\n+\t\t  (match_operand:DF 3 \"register_operand\" \"f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"msub.d\\\\t%0,%3,%1,%2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t\t   (match_operand:SF 2 \"register_operand\" \"f\"))\n+\t\t  (match_operand:SF 3 \"register_operand\" \"f\")))]\n+\t\t  \n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"msub.s\\\\t%0,%3,%1,%2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(neg:DF (plus:DF (mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t\t\t  (match_operand:DF 2 \"register_operand\" \"f\"))\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"f\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"nmadd.d\\\\t%0,%3,%1,%2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(neg:SF (plus:SF (mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t\t\t  (match_operand:SF 2 \"register_operand\" \"f\"))\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"f\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"nmadd.s\\\\t%0,%3,%1,%2\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n+\t\t  (mult:DF (match_operand:DF 2 \"register_operand\" \"f\")\n+\t\t\t   (match_operand:DF 3 \"register_operand\" \"f\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"nmsub.d\\\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"DF\")\n+   (set_attr \"length\"\t\"1\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n+\t\t  (mult:SF (match_operand:SF 2 \"register_operand\" \"f\")\n+\t\t\t   (match_operand:SF 3 \"register_operand\" \"f\"))))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"nmsub.s\\\\t%0,%1,%2,%3\"\n+  [(set_attr \"type\"\t\"fmadd\")\n+   (set_attr \"mode\"\t\"SF\")\n+   (set_attr \"length\"\t\"1\")])\n \f\n ;;\n ;;  ....................\n@@ -2767,6 +2869,37 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"\"\n   \"\n {\n+  /* If we are generating embedded PIC code, and we are referring to a\n+     symbol in the .text section, we must use an offset from the start\n+     of the function.  */\n+  if (TARGET_EMBEDDED_PIC\n+      && (GET_CODE (operands[1]) == LABEL_REF\n+\t  || (GET_CODE (operands[1]) == SYMBOL_REF\n+\t      && ! SYMBOL_REF_FLAG (operands[1]))))\n+    {\n+      rtx temp;\n+\n+      temp = embedded_pic_offset (operands[1]);\n+      temp = gen_rtx (PLUS, Pmode, embedded_pic_fnaddr_rtx,\n+\t\t      force_reg (DImode, temp));\n+      emit_move_insn (operands[0], force_reg (DImode, temp));\n+      DONE;\n+    }\n+\n+  /* If operands[1] is a constant address illegal for pic, then we need to\n+     handle it just like LEGITIMIZE_ADDRESS does.  */\n+  if (flag_pic && pic_address_needs_scratch (operands[1]))\n+    {\n+      rtx temp = force_reg (DImode, XEXP (XEXP (operands[1], 0), 0));\n+      rtx temp2 = XEXP (XEXP (operands[1], 0), 1);\n+\n+      if (! SMALL_INT (temp2))\n+\ttemp2 = force_reg (DImode, temp2);\n+\n+      emit_move_insn (operands[0], gen_rtx (PLUS, DImode, temp, temp2));\n+      DONE;\n+    }\n+\n   if ((reload_in_progress | reload_completed) == 0\n       && !register_operand (operands[0], DImode)\n       && !register_operand (operands[1], DImode)\n@@ -3139,6 +3272,19 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set (subreg:SI (match_dup 0) 1) (subreg:SI (match_dup 1) 1))]\n   \"\")\n \n+;; Instructions to load the global pointer register.\n+;; This is volatile to make sure that the scheduler won't move any symbol_ref\n+;; uses in front of it.  All symbol_refs implicitly use the gp reg.\n+\n+(define_insn \"loadgp\"\n+  [(set (reg:DI 28)\n+\t(unspec_volatile [(match_operand:DI 0 \"address_operand\" \"\")] 2))\n+   (clobber (reg:DI 1))]\n+  \"\"\n+  \"%[lui\\\\t$1,%%hi(%%neg(%%gp_rel(%a0)))\\\\n\\\\taddiu\\\\t$1,$1,%%lo(%%neg(%%gp_rel(%a0)))\\\\n\\\\tdaddu\\\\t$gp,$1,$25%]\"\n+  [(set_attr \"type\"\t\"move\")\n+   (set_attr \"mode\"\t\"DI\")\n+   (set_attr \"length\"\t\"3\")])\n \f\n ;; Block moves, see mips.c for more details.\n ;; Argument 0 is the destination\n@@ -3270,7 +3416,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\n \n   return \\\"sll\\\\t%0,%1,%2\\\";\n }\"\n@@ -3340,7 +3486,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && (INTVAL (operands[2]) & 32) != 0\"\n   \"*\n {\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\n   operands[4] = const0_rtx;\n   return \\\"sll\\\\t%M0,%L1,%2\\;move\\\\t%L0,%z4\\\";\n }\"\n@@ -3362,7 +3508,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (subreg:SI (match_dup 0) 1) (ashift:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n \n-  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\")\n+  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\")\n \n \n (define_split\n@@ -3378,7 +3524,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (subreg:SI (match_dup 0) 0) (ashift:SI (subreg:SI (match_dup 1) 1) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 1) (const_int 0))]\n \n-  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\")\n+  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\")\n \n \n (define_insn \"ashldi3_internal3\"\n@@ -3497,7 +3643,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\n \n   return \\\"sra\\\\t%0,%1,%2\\\";\n }\"\n@@ -3567,7 +3713,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && (INTVAL (operands[2]) & 32) != 0\"\n   \"*\n {\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\n   return \\\"sra\\\\t%L0,%M1,%2\\;sra\\\\t%M0,%M1,31\\\";\n }\"\n   [(set_attr \"type\"\t\"darith\")\n@@ -3588,7 +3734,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 1) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 1) (ashiftrt:SI (subreg:SI (match_dup 1) 1) (const_int 31)))]\n \n-  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\")\n+  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\")\n \n \n (define_split\n@@ -3604,7 +3750,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (subreg:SI (match_dup 0) 1) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 0) (ashiftrt:SI (subreg:SI (match_dup 1) 0) (const_int 31)))]\n \n-  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\")\n+  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\")\n \n \n (define_insn \"ashrdi3_internal3\"\n@@ -3722,7 +3868,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n-    operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\n+    operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\n \n   return \\\"srl\\\\t%0,%1,%2\\\";\n }\"\n@@ -3792,7 +3938,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"!TARGET_64BIT && !TARGET_DEBUG_G_MODE && (INTVAL (operands[2]) & 32) != 0\"\n   \"*\n {\n-  operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\n+  operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\n   operands[4] = const0_rtx;\n   return \\\"srl\\\\t%L0,%M1,%2\\;move\\\\t%M0,%z4\\\";\n }\"\n@@ -3814,7 +3960,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (subreg:SI (match_dup 0) 0) (lshiftrt:SI (subreg:SI (match_dup 1) 1) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 1) (const_int 0))]\n \n-  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\")\n+  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\")\n \n \n (define_split\n@@ -3830,7 +3976,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   [(set (subreg:SI (match_dup 0) 1) (lshiftrt:SI (subreg:SI (match_dup 1) 0) (match_dup 2)))\n    (set (subreg:SI (match_dup 0) 0) (const_int 0))]\n \n-  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, (XINT (operands[2], 0))& 0x1f);\")\n+  \"operands[2] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[2]) & 0x1f);\")\n \n \n (define_insn \"lshrdi3_internal3\"\n@@ -5384,7 +5530,12 @@ move\\\\t%0,%z4\\\\n\\\\\n {\n   if (GET_CODE (operands[0]) == REG)\n     return \\\"%*j\\\\t%0\\\";\n-  else\n+  /* ??? I don't know why this is necessary.  This works around an\n+     assembler problem that appears when a label is defined, then referenced\n+     in a switch table, then used in a `j' instruction.  */\n+  else if (ABI_64BIT && mips_isa >= 3)\n+    return \\\"%*b\\\\t%l0\\\";\n+  else\t\n     return \\\"%*j\\\\t%l0\\\";\n }\"\n   [(set_attr \"type\"\t\"jump\")\n@@ -5460,7 +5611,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   /* .cpadd expands to add REG,REG,$gp when pic, and nothing when not pic.  */\n-  if (TARGET_ABICALLS)\n+  if (TARGET_ABICALLS && (! ABI_64BIT || mips_isa < 3))\n     output_asm_insn (\\\".cpadd\\\\t%0\\\", operands);\n   return \\\"%*j\\\\t%0\\\";\n }\"\n@@ -5479,8 +5630,9 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   /* .cpdadd expands to dadd REG,REG,$gp when pic, and nothing when not pic. */\n-  if (TARGET_ABICALLS)\n-    output_asm_insn (\\\".cpdadd\\\\t%0\\\", operands);\n+  /*  ??? SGI as does not have a .cpdadd.  */\n+  if (TARGET_ABICALLS && (! ABI_64BIT || mips_isa < 3))\n+    output_asm_insn (\\\".cpadd\\\\t%0\\\", operands);\n   return \\\"%*j\\\\t%0\\\";\n }\"\n   [(set_attr \"type\"\t\"jump\")\n@@ -6031,3 +6183,217 @@ move\\\\t%0,%z4\\\\n\\\\\n \n   /* fall through and generate default code */\n }\")\n+\f\n+;;\n+;; MIPS4 Conditional move instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(if_then_else:SI\n+\t (match_operator 4 \"equality_op\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand:SI 2 \"reg_or_0_operand\" \"dJ,0\")\n+\t (match_operand:SI 3 \"reg_or_0_operand\" \"0,dJ\")))]\n+  \"mips_isa >= 4\"\n+  \"@\n+    mov%B4\\\\t%0,%z2,%1\n+    mov%b4\\\\t%0,%z3,%1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+\t(if_then_else:SI\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operand:SI 1 \"reg_or_0_operand\" \"dJ,0\")\n+\t (match_operand:SI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n+  \"mips_isa >= 4\"\n+  \"@\n+    mov%T3\\\\t%0,%z1,$fcc0\n+    mov%t3\\\\t%0,%z2,$fcc0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"SI\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+\t(if_then_else:DI\n+\t (match_operator 4 \"equality_op\"\n+\t\t\t [(match_operand:DI 1 \"register_operand\" \"d,d\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand:DI 2 \"reg_or_0_operand\" \"dJ,0\")\n+\t (match_operand:DI 3 \"reg_or_0_operand\" \"0,dJ\")))]\n+  \"mips_isa >= 4\"\n+  \"@\n+    mov%B4\\\\t%0,%z2,%1\n+    mov%b4\\\\t%0,%z3,%1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=d,d\")\n+\t(if_then_else:DI\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operand:DI 1 \"reg_or_0_operand\" \"dJ,0\")\n+\t (match_operand:DI 2 \"reg_or_0_operand\" \"0,dJ\")))]\n+  \"mips_isa >= 4\"\n+  \"@\n+    mov%T3\\\\t%0,%z1,$fcc0\n+    mov%t3\\\\t%0,%z2,$fcc0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(if_then_else:SF\n+\t (match_operator 4 \"equality_op\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand:SF 2 \"register_operand\" \"f,0\")\n+\t (match_operand:SF 3 \"register_operand\" \"0,f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"@\n+    mov%B4.s\\\\t%0,%2,%1\n+    mov%b4.s\\\\t%0,%3,%1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(if_then_else:SF\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operand:SF 1 \"register_operand\" \"f,0\")\n+\t (match_operand:SF 2 \"register_operand\" \"0,f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"@\n+    mov%T3.s\\\\t%0,%1,$fcc0\n+    mov%t3.s\\\\t%0,%2,$fcc0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(if_then_else:DF\n+\t (match_operator 4 \"equality_op\"\n+\t\t\t [(match_operand:SI 1 \"register_operand\" \"d,d\")\n+\t\t\t  (const_int 0)])\n+\t (match_operand:DF 2 \"register_operand\" \"f,0\")\n+\t (match_operand:DF 3 \"register_operand\" \"0,f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"@\n+    mov%B4.d\\\\t%0,%2,%1\n+    mov%b4.d\\\\t%0,%3,%1\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(if_then_else:DF\n+\t (match_operator 3 \"equality_op\" [(reg:CC_FP 66) (const_int 0)])\n+\t (match_operand:DF 1 \"register_operand\" \"f,0\")\n+\t (match_operand:DF 2 \"register_operand\" \"0,f\")))]\n+  \"mips_isa >= 4 && TARGET_HARD_FLOAT\"\n+  \"@\n+    mov%T3.d\\\\t%0,%1,$fcc0\n+    mov%t3.d\\\\t%0,%2,$fcc0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+;; These are the main define_expand's used to make conditional moves.\n+\n+(define_expand \"movsicc\"\n+  [(set (match_dup 4) (match_operand 1 \"comparison_operator\" \"\"))\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(if_then_else:SI (match_dup 5)\n+\t\t\t (match_operand:SI 2 \"reg_or_0_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"reg_or_0_operand\" \"\")))]\n+  \"mips_isa >= 4\"\n+  \"\n+{\n+  rtx op0 = branch_cmp[0];\n+  rtx op1 = branch_cmp[1];\n+  enum machine_mode mode = GET_MODE (branch_cmp[0]);\n+  enum rtx_code compare_code = GET_CODE (operands[1]);\n+  enum rtx_code move_code = NE;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_FLOAT)\n+    {\n+      switch (compare_code)\n+\t{\n+\tcase EQ:\n+\t  compare_code = XOR;\n+\t  move_code = EQ;\n+\t  break;\n+\tcase NE:\n+\t  compare_code = XOR;\n+\t  break;\n+\tcase LT:\n+\t  break;\n+\tcase GE:\n+\t  compare_code = LT;\n+\t  move_code = EQ;\n+\t  break;\n+\tcase GT:\n+\t  compare_code = LT;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  break;\n+\tcase LE:\n+\t  compare_code = LT;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  move_code = EQ;\n+\t  break;\n+\tcase LTU:\n+\t  break;\n+\tcase GEU:\n+\t  compare_code = LTU;\n+\t  move_code = EQ;\n+\t  break;\n+\tcase GTU:\n+\t  compare_code = LTU;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  break;\n+\tcase LEU:\n+\t  compare_code = LTU;\n+\t  op0 = force_reg (mode, branch_cmp[1]);\n+\t  op1 = branch_cmp[0];\n+\t  move_code = EQ;\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  else\n+    {\n+      if (compare_code == NE)\n+\t{\n+\t  /* ??? Perhaps we need to use CC_FP_REVmode here?  */\n+\t  compare_code = EQ;\n+\t  move_code = EQ;\n+\t}\n+    }\n+\t  \n+  if (mode == SImode || mode == DImode)\n+    {\n+      operands[1] = gen_rtx (compare_code, mode, op0, op1);\n+      operands[4] = gen_reg_rtx (mode);\n+    }\n+  else if (mode == SFmode || mode == DFmode)\n+    {\n+      operands[1] = gen_rtx (compare_code, CC_FPmode, op0, op1);\n+      operands[4] = gen_rtx (REG, CC_FPmode, FPSW_REGNUM);\n+    }\n+\n+  if (mode == DImode)\n+    operands[5] = gen_rtx (move_code, VOIDmode,\n+\t\t\t   gen_lowpart (SImode, operands[4]),\n+\t\t\t   CONST0_RTX (SImode));\n+  else\n+    operands[5] = gen_rtx (move_code, VOIDmode, operands[4],\n+\t\t\t   CONST0_RTX (SImode));\n+}\")\n+\n+;; ??? Need movdicc, movsfcc, and movdfcc patterns.  They should be\n+;; very similar to the above movsicc pattern."}]}