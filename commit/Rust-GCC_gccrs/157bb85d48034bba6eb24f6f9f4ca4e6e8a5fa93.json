{"sha": "157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU3YmI4NWQ0ODAzNGJiYTZlYjI0ZjZmOWY0Y2E0ZTZlOGE1ZmE5Mw==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2015-12-02T19:52:53Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2015-12-02T19:52:53Z"}, "message": "configure.ac: Check assembler support for R_PPC64_ENTRY relocation.\n\n\t* configure.ac: Check assembler support for R_PPC64_ENTRY relocation.\n\t* configure: Regenerate.\n\t* config.in: Regenerate.\n\t* config/rs6000/rs6000.c (rs6000_global_entry_point_needed_p): New\n\tfunction.\n\t(rs6000_output_function_prologue): Use it instead of checking\n\tcfun->machine->r2_setup_needed.  Use internal labels instead of\n\tGNU as local label extension.  Handle ELFv2 large code model.\n\t(rs6000_output_mi_thunk): Do not set cfun->machine->r2_setup_needed.\n\t(rs6000_elf_declare_function_name): Handle ELFv2 large code model.\n\nFrom-SVN: r231202", "tree": {"sha": "15fd340dce2472a8f70811827a1383045c344076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15fd340dce2472a8f70811827a1383045c344076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/comments", "author": null, "committer": null, "parents": [{"sha": "8923e02ee4fb1207f63254e975a8e96dce177c9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8923e02ee4fb1207f63254e975a8e96dce177c9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8923e02ee4fb1207f63254e975a8e96dce177c9d"}], "stats": {"total": 150, "additions": 140, "deletions": 10}, "files": [{"sha": "28ba7fba7dba3bb53abf5a192f0edbb9d722041d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "patch": "@@ -1,3 +1,16 @@\n+2015-12-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* configure.ac: Check assembler support for R_PPC64_ENTRY relocation.\n+\t* configure: Regenerate.\n+\t* config.in: Regenerate.\n+\t* config/rs6000/rs6000.c (rs6000_global_entry_point_needed_p): New\n+\tfunction.\n+\t(rs6000_output_function_prologue): Use it instead of checking\n+\tcfun->machine->r2_setup_needed.  Use internal labels instead of\n+\tGNU as local label extension.  Handle ELFv2 large code model.\n+\t(rs6000_output_mi_thunk): Do not set cfun->machine->r2_setup_needed.\n+\t(rs6000_elf_declare_function_name): Handle ELFv2 large code model.\n+\n 2015-12-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/68647"}, {"sha": "a1762bec4367a53460e8ea77029783e9d6c4c9d2", "filename": "gcc/config.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "patch": "@@ -327,6 +327,12 @@\n #endif\n \n \n+/* Define if your assembler supports the R_PPC64_ENTRY relocation. */\n+#ifndef USED_FOR_TARGET\n+#undef HAVE_AS_ENTRY_MARKERS\n+#endif\n+\n+\n /* Define if your assembler supports explicit relocations. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_AS_EXPLICIT_RELOCS"}, {"sha": "22eb0e5b713a3fb28747b601d188cc9ce786a044", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "patch": "@@ -24888,6 +24888,31 @@ split_stack_arg_pointer_used_p (void)\n   return bitmap_bit_p (DF_LR_OUT (bb), 12);\n }\n \n+/* Return whether we need to emit an ELFv2 global entry point prologue.  */\n+\n+static bool\n+rs6000_global_entry_point_needed_p (void)\n+{\n+  /* Only needed for the ELFv2 ABI.  */\n+  if (DEFAULT_ABI != ABI_ELFv2)\n+    return false;\n+\n+  /* With -msingle-pic-base, we assume the whole program shares the same\n+     TOC, so no global entry point prologues are needed anywhere.  */\n+  if (TARGET_SINGLE_PIC_BASE)\n+    return false;\n+\n+  /* Ensure we have a global entry point for thunks.   ??? We could\n+     avoid that if the target routine doesn't need a global entry point,\n+     but we do not know whether this is the case at this point.  */\n+  if (cfun->is_thunk)\n+    return true;\n+\n+  /* For regular functions, rs6000_emit_prologue sets this flag if the\n+     routine ever uses the TOC pointer.  */\n+  return cfun->machine->r2_setup_needed;\n+}\n+\n /* Emit function prologue as insns.  */\n \n void\n@@ -25951,12 +25976,52 @@ rs6000_output_function_prologue (FILE *file,\n \n   /* ELFv2 ABI r2 setup code and local entry point.  This must follow\n      immediately after the global entry point label.  */\n-  if (DEFAULT_ABI == ABI_ELFv2 && cfun->machine->r2_setup_needed)\n+  if (rs6000_global_entry_point_needed_p ())\n     {\n       const char *name = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n \n-      fprintf (file, \"0:\\taddis 2,12,.TOC.-0b@ha\\n\");\n-      fprintf (file, \"\\taddi 2,2,.TOC.-0b@l\\n\");\n+      (*targetm.asm_out.internal_label) (file, \"LCF\", rs6000_pic_labelno);\n+\n+      if (TARGET_CMODEL != CMODEL_LARGE)\n+\t{\n+\t  /* In the small and medium code models, we assume the TOC is less\n+\t     2 GB away from the text section, so it can be computed via the\n+\t     following two-instruction sequence.  */\n+\t  char buf[256];\n+\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n+\t  fprintf (file, \"0:\\taddis 2,12,.TOC.-\");\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"@ha\\n\");\n+\t  fprintf (file, \"\\taddi 2,2,.TOC.-\");\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"@l\\n\");\n+\t}\n+      else\n+\t{\n+\t  /* In the large code model, we allow arbitrary offsets between the\n+\t     TOC and the text section, so we have to load the offset from\n+\t     memory.  The data field is emitted directly before the global\n+\t     entry point in rs6000_elf_declare_function_name.  */\n+\t  char buf[256];\n+\n+#ifdef HAVE_AS_ENTRY_MARKERS\n+\t  /* If supported by the linker, emit a marker relocation.  If the\n+\t     total code size of the final executable or shared library\n+\t     happens to fit into 2 GB after all, the linker will replace\n+\t     this code sequence with the sequence for the small or medium\n+\t     code model.  */\n+\t  fprintf (file, \"\\t.reloc .,R_PPC64_ENTRY\\n\");\n+#endif\n+\t  fprintf (file, \"\\tld 2,\");\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCL\", rs6000_pic_labelno);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"-\");\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n+\t  assemble_name (file, buf);\n+\t  fprintf (file, \"(12)\\n\");\n+\t  fprintf (file, \"\\tadd 2,2,12\\n\");\n+\t}\n \n       fputs (\"\\t.localentry\\t\", file);\n       assemble_name (file, name);\n@@ -27620,13 +27685,6 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   SIBLING_CALL_P (insn) = 1;\n   emit_barrier ();\n \n-  /* Ensure we have a global entry point for the thunk.   ??? We could\n-     avoid that if the target routine doesn't need a global entry point,\n-     but we do not know whether this is the case at this point.  */\n-  if (DEFAULT_ABI == ABI_ELFv2\n-      && !TARGET_SINGLE_PIC_BASE)\n-    cfun->machine->r2_setup_needed = true;\n-\n   /* Run just enough of rest_of_compilation to get the insns emitted.\n      There's not really enough bulk here to make other passes such as\n      instruction scheduling worth while.  Note that use_thunk calls\n@@ -31493,6 +31551,18 @@ rs6000_elf_declare_function_name (FILE *file, const char *name, tree decl)\n   ASM_OUTPUT_TYPE_DIRECTIVE (file, name, \"function\");\n   ASM_DECLARE_RESULT (file, DECL_RESULT (decl));\n \n+  if (TARGET_CMODEL == CMODEL_LARGE && rs6000_global_entry_point_needed_p ())\n+    {\n+      char buf[256];\n+\n+      (*targetm.asm_out.internal_label) (file, \"LCL\", rs6000_pic_labelno);\n+\n+      fprintf (file, \"\\t.quad .TOC.-\");\n+      ASM_GENERATE_INTERNAL_LABEL (buf, \"LCF\", rs6000_pic_labelno);\n+      assemble_name (file, buf);\n+      putc ('\\n', file);\n+    }\n+\n   if (DEFAULT_ABI == ABI_AIX)\n     {\n       const char *desc_name, *orig_name;"}, {"sha": "b21c864466d7d19cd8b4aaf35a199519eea029c6", "filename": "gcc/configure", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "patch": "@@ -26532,6 +26532,41 @@ if test $gcc_cv_as_powerpc_tls_markers = yes; then\n \n $as_echo \"#define HAVE_AS_TLS_MARKERS 1\" >>confdefs.h\n \n+fi\n+\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler for prologue entry point marker support\" >&5\n+$as_echo_n \"checking assembler for prologue entry point marker support... \" >&6; }\n+if test \"${gcc_cv_as_powerpc_entry_markers+set}\" = set; then :\n+  $as_echo_n \"(cached) \" >&6\n+else\n+  gcc_cv_as_powerpc_entry_markers=no\n+    if test $in_tree_gas = yes; then\n+    if test $gcc_cv_gas_vers -ge `expr \\( \\( 2 \\* 1000 \\) + 26 \\) \\* 1000 + 0`\n+  then gcc_cv_as_powerpc_entry_markers=yes\n+fi\n+  elif test x$gcc_cv_as != x; then\n+    $as_echo ' .reloc .,R_PPC64_ENTRY; nop' > conftest.s\n+    if { ac_try='$gcc_cv_as $gcc_cv_as_flags -a64 --fatal-warnings -o conftest.o conftest.s >&5'\n+  { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n+  test $ac_status = 0; }; }\n+    then\n+\tgcc_cv_as_powerpc_entry_markers=yes\n+    else\n+      echo \"configure: failed program was\" >&5\n+      cat conftest.s >&5\n+    fi\n+    rm -f conftest.o conftest.s\n+  fi\n+fi\n+{ $as_echo \"$as_me:${as_lineno-$LINENO}: result: $gcc_cv_as_powerpc_entry_markers\" >&5\n+$as_echo \"$gcc_cv_as_powerpc_entry_markers\" >&6; }\n+if test $gcc_cv_as_powerpc_entry_markers = yes; then\n+\n+$as_echo \"#define HAVE_AS_ENTRY_MARKERS 1\" >>confdefs.h\n+\n fi\n \n     case $target in"}, {"sha": "cff95bc9c6d37c433f262f6d985be36bc5f0a02c", "filename": "gcc/configure.ac", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=157bb85d48034bba6eb24f6f9f4ca4e6e8a5fa93", "patch": "@@ -4371,6 +4371,12 @@ LCF0:\n       [AC_DEFINE(HAVE_AS_TLS_MARKERS, 1,\n \t  [Define if your assembler supports arg info for __tls_get_addr.])])\n \n+    gcc_GAS_CHECK_FEATURE([prologue entry point marker support],\n+      gcc_cv_as_powerpc_entry_markers, [2,26,0],-a64 --fatal-warnings,\n+      [ .reloc .,R_PPC64_ENTRY; nop],,\n+      [AC_DEFINE(HAVE_AS_ENTRY_MARKERS, 1,\n+\t  [Define if your assembler supports the R_PPC64_ENTRY relocation.])])\n+\n     case $target in\n       *-*-aix*)\n \tgcc_GAS_CHECK_FEATURE([.ref support],"}]}