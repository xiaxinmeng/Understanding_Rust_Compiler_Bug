{"sha": "f7e531cf982da6f84f670916abe453f993757c8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlNTMxY2Y5ODJkYTZmODRmNjcwOTE2YWJlNDUzZjk5Mzc1N2M4ZA==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-11-06T09:01:45Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-11-06T09:01:45Z"}, "message": "tree-vectorizer.h (vectorizable_condition): Add argument.\n\n\n        * tree-vectorizer.h (vectorizable_condition): Add argument.\n        * tree-vect-loop.c (vectorizable_reduction): Fail for condition\n        in SLP.  Update calls to vectorizable_condition.\n        * tree-vect-stmts.c (vect_is_simple_cond): Add basic block info\n        to the arguments.  Pass it to vect_is_simple_use_1.\n        (vectorizable_condition): Add slp_node to the arguments.\n        Support vectorization of basic blocks.  Fail for reduction in\n        SLP.  Update calls to vect_is_simple_cond and\n        vect_is_simple_use.  Support SLP: call vect_get_slp_defs to get\n        vector operands.\n        (vect_analyze_stmt): Update calls to vectorizable_condition.\n        (vect_transform_stmt): Likewise.\n        * tree-vect-slp.c (vect_create_new_slp_node): Handle COND_EXPR.\n        (vect_get_and_check_slp_defs): Handle COND_EXPR.  Allow pattern\n        def stmts.\n        (vect_build_slp_tree): Handle COND_EXPR.\n        (vect_analyze_slp_instance): Push pattern statements to root\n        node.\n        (vect_get_constant_vectors): Fix comments.  Handle COND_EXPR.\n\nFrom-SVN: r181026", "tree": {"sha": "6b7d1314dddf8d842d6c82f9e473a7263d89ac37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b7d1314dddf8d842d6c82f9e473a7263d89ac37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e531cf982da6f84f670916abe453f993757c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e531cf982da6f84f670916abe453f993757c8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e531cf982da6f84f670916abe453f993757c8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e531cf982da6f84f670916abe453f993757c8d/comments", "author": null, "committer": null, "parents": [{"sha": "79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79cad86dca731ab4d8d0ea57e3436a4c7eca224d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79cad86dca731ab4d8d0ea57e3436a4c7eca224d"}], "stats": {"total": 640, "additions": 561, "deletions": 79}, "files": [{"sha": "0b3c31098c38562b4628739a14a70038146d91ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -1,3 +1,23 @@\n+2011-11-06  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vectorizer.h (vectorizable_condition): Add argument.\n+\t* tree-vect-loop.c (vectorizable_reduction): Fail for condition\n+\tin SLP.  Update calls to vectorizable_condition.\n+\t* tree-vect-stmts.c (vect_is_simple_cond): Add basic block info to\n+\tthe arguments.  Pass it to vect_is_simple_use_1.\n+\t(vectorizable_condition): Add slp_node to the arguments.  Support\n+\tvectorization of basic blocks.  Fail for reduction in SLP.  Update\n+\tcalls to vect_is_simple_cond and vect_is_simple_use.  Support SLP:\n+\tcall vect_get_slp_defs to get vector operands.\n+\t(vect_analyze_stmt): Update calls to vectorizable_condition.\n+\t(vect_transform_stmt): Likewise.\n+\t* tree-vect-slp.c (vect_create_new_slp_node): Handle COND_EXPR.\n+\t(vect_get_and_check_slp_defs): Handle COND_EXPR.  Allow pattern\n+\tdef stmts.\n+\t(vect_build_slp_tree): Handle COND_EXPR.\n+\t(vect_analyze_slp_instance): Push pattern statements to root node.\n+\t(vect_get_constant_vectors): Fix comments.  Handle COND_EXPR.\n+\n 2011-11-05  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc.md (UNSPEC_SHORT_LOAD): New unspec."}, {"sha": "3b75995a1af313d7549c94a1ab30871f23bd3c32", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -1,3 +1,9 @@\n+2011-11-06  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* gcc.dg/vect/bb-slp-cond-1.c: New test.\n+\t* gcc.dg/vect/slp-cond-1.c: New test.\n+\t* gcc.dg/vect/slp-cond-2.c: New test.\n+\n 2011-11-05  David S. Miller  <davem@davemloft.net>\n \n \t* lib/test-supports.exp"}, {"sha": "ae833e53dc0b998eb96c5b1cc8b65983fef8ba61", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-cond-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-cond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-cond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-cond-1.c?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+__attribute__((noinline, noclone)) void\n+foo (int *a, int stride)\n+{\n+  int i;\n+\n+  for (i = 0; i < N/stride; i++, a += stride)\n+   {\n+     a[0] = a[0] ? 1 : 5;\n+     a[1] = a[1] ? 2 : 6;\n+     a[2] = a[2] ? 3 : 7;\n+     a[3] = a[3] ? 4 : 8;\n+   }\n+}\n+\n+\n+int a[N];\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    a[i] = i;\n+\n+  foo (a, 4);\n+\n+  for (i = 1; i < N; i++)\n+    if (a[i] != i%4 + 1)\n+      abort ();\n+\n+  if (a[0] != 5)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect_element_align } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+"}, {"sha": "4b8e3d3b6a319188bed3177b1da2cd90577ae28f", "filename": "gcc/testsuite/gcc.dg/vect/slp-cond-1.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-1.c?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-require-effective-target vect_condition } */\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+int a[N], b[N];\n+int d[N], e[N];\n+int k[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      k[4*i] = a[4*i] < b[4*i] ? 17 : 0;\n+      k[4*i+1] = a[4*i+1] < b[4*i+1] ? 17 : 0;\n+      k[4*i+2] = a[4*i+2] < b[4*i+2] ? 17 : 0;\n+      k[4*i+3] = a[4*i+3] < b[4*i+3] ? 17 : 0;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/2; ++i)\n+    {\n+      k[2*i] = a[2*i] < b[2*i] ? 0 : 24;\n+      k[2*i+1] = a[2*i+1] < b[2*i+1] ? 7 : 4;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/2; ++i)\n+    {\n+      k[2*i] = a[2*i] < b[2*i] ? 51 : 12;\n+      k[2*i+1] = a[2*i+1] > b[2*i+1] ? 51 : 12;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/2; ++i)\n+    {\n+      int d0 = d[2*i], e0 = e[2*i];\n+      int d1 = d[2*i+1], e1 = e[2*i+1];\n+      k[2*i] = a[2*i] >= b[2*i] ? d0 : e0;\n+      k[2*i+1] = a[2*i+1] >= b[2*i+1] ? d1 : e1;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+\t{\n+\tcase 0: asm (\"\"); a[i] = - i - 1; b[i] = i + 1; break;\n+\tcase 1: a[i] = 0; b[i] = 0; break;\n+\tcase 2: a[i] = i + 1; b[i] = - i - 1; break;\n+\tcase 3: a[i] = i; b[i] = i + 7; break;\n+\tcase 4: a[i] = i; b[i] = i; break;\n+\tcase 5: a[i] = i + 16; b[i] = i + 3; break;\n+\tcase 6: a[i] = - i - 5; b[i] = - i; break;\n+\tcase 7: a[i] = - i; b[i] = - i; break;\n+\tcase 8: a[i] = - i; b[i] = - i - 7; break;\n+\t}\n+      d[i] = i;\n+      e[i] = 2 * i;\n+    }\n+  f1 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 ? 17 : 0))\n+      abort ();\n+\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+        {\n+        case 0:\n+\tcase 6:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 0 : 7))\n+\t    abort ();\n+\t  break;\n+        case 1:\n+        case 5:\n+        case 7:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 4 : 24))\n+            abort ();\n+          break;\n+        case 2:\n+        case 4:\n+        case 8:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 24 : 4))\n+            abort ();\n+          break;\n+        case 3:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 7 : 0))\n+            abort ();\n+          break;\n+        }\n+    }\n+\n+  f3 ();\n+\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 ? e[i] : d[i]))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "c73933fce0fe94cbeb5c98fbc633cd97680e7ba2", "filename": "gcc/testsuite/gcc.dg/vect/slp-cond-2.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-2.c?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -0,0 +1,127 @@\n+/* { dg-require-effective-target vect_cond_mixed } */\n+#include \"tree-vect.h\"\n+\n+#define N 32\n+int d[N], e[N], f[N];\n+unsigned char k[N];\n+float a[N], b[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/4; i++)\n+    {\n+      k[4*i] = a[4*i] < b[4*i] ? 17 : 0;\n+      k[4*i+1] = a[4*i+1] < b[4*i+1] ? 17 : 0;\n+      k[4*i+2] = a[4*i+2] < b[4*i+2] ? 17 : 0;\n+      k[4*i+3] = a[4*i+3] < b[4*i+3] ? 17 : 0;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/2; ++i)\n+    {\n+      k[2*i] = a[2*i] < b[2*i] ? 0 : 24;\n+      k[2*i+1] = a[2*i+1] < b[2*i+1] ? 7 : 4;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/2; ++i)\n+    {\n+      k[2*i] = a[2*i] < b[2*i] ? 51 : 12;\n+      k[2*i+1] = a[2*i+1] > b[2*i+1] ? 51 : 12;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N/2; ++i)\n+    {\n+      int d0 = d[2*i], e0 = e[2*i];\n+      int d1 = d[2*i+1], e1 = e[2*i+1];\n+      f[2*i] = a[2*i] >= b[2*i] ? d0 : e0;\n+      f[2*i+1] = a[2*i+1] >= b[2*i+1] ? d1 : e1;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+\t{\n+\tcase 0: asm (\"\"); a[i] = - i - 1; b[i] = i + 1; break;\n+\tcase 1: a[i] = 0; b[i] = 0; break;\n+\tcase 2: a[i] = i + 1; b[i] = - i - 1; break;\n+\tcase 3: a[i] = i; b[i] = i + 7; break;\n+\tcase 4: a[i] = i; b[i] = i; break;\n+\tcase 5: a[i] = i + 16; b[i] = i + 3; break;\n+\tcase 6: a[i] = - i - 5; b[i] = - i; break;\n+\tcase 7: a[i] = - i; b[i] = - i; break;\n+\tcase 8: a[i] = - i; b[i] = - i - 7; break;\n+\t}\n+      d[i] = i;\n+      e[i] = 2 * i;\n+    }\n+\n+  f1 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 ? 17 : 0))\n+      abort ();\n+\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+        {\n+        case 0:\n+\tcase 6:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 0 : 7))\n+\t    abort ();\n+\t  break;\n+        case 1:\n+        case 5:\n+        case 7:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 4 : 24))\n+            abort ();\n+          break;\n+        case 2:\n+        case 4:\n+        case 8:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 24 : 4))\n+            abort ();\n+          break;\n+        case 3:\n+\t  if (k[i] != ((i/9 % 2) == 0 ? 7 : 0))\n+            abort ();\n+          break;\n+        }\n+    }\n+\n+  f3 ();\n+\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (f[i] != ((i % 3) == 0 ? e[i] : d[i]))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 3 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "a209b4bb14db2433f0e84e9591cc56f66d8bfa03", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -4416,6 +4416,9 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       gcc_unreachable ();\n     }\n \n+  if (code == COND_EXPR && slp_node)\n+    return false;\n+\n   scalar_dest = gimple_assign_lhs (stmt);\n   scalar_type = TREE_TYPE (scalar_dest);\n   if (!POINTER_TYPE_P (scalar_type) && !INTEGRAL_TYPE_P (scalar_type)\n@@ -4502,7 +4505,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (code == COND_EXPR)\n     {\n-      if (!vectorizable_condition (stmt, gsi, NULL, ops[reduc_index], 0))\n+      if (!vectorizable_condition (stmt, gsi, NULL, ops[reduc_index], 0, NULL))\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"unsupported condition in reduction\");\n@@ -4774,7 +4777,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n           gcc_assert (!slp_node);\n           vectorizable_condition (stmt, gsi, vec_stmt, \n                                   PHI_RESULT (VEC_index (gimple, phis, 0)), \n-                                  reduc_index);\n+                                  reduc_index, NULL);\n           /* Multiple types are not supported for condition.  */\n           break;\n         }"}, {"sha": "6628a6fd66df1d5820096fe062fcbd63d11add4e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 102, "deletions": 13, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -109,7 +109,11 @@ vect_create_new_slp_node (VEC (gimple, heap) *scalar_stmts)\n   if (is_gimple_call (stmt))\n     nops = gimple_call_num_args (stmt);\n   else if (is_gimple_assign (stmt))\n-    nops = gimple_num_ops (stmt) - 1;\n+    {\n+      nops = gimple_num_ops (stmt) - 1;\n+      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\tnops++;\n+    }\n   else\n     return NULL;\n \n@@ -191,20 +195,41 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   bool different_types = false;\n   bool pattern = false;\n   slp_oprnd_info oprnd_info, oprnd0_info, oprnd1_info;\n+  int op_idx = 1;\n+  tree compare_rhs = NULL_TREE;\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n   if (is_gimple_call (stmt))\n     number_of_oprnds = gimple_call_num_args (stmt);\n+  else if (is_gimple_assign (stmt))\n+    {\n+      number_of_oprnds = gimple_num_ops (stmt) - 1;\n+      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+        number_of_oprnds++;\n+    }\n   else\n-    number_of_oprnds = gimple_num_ops (stmt) - 1;\n+    return false;\n \n   for (i = 0; i < number_of_oprnds; i++)\n     {\n-      oprnd = gimple_op (stmt, i + 1);\n+      if (compare_rhs)\n+\t{\n+\t  oprnd = compare_rhs;\n+\t  compare_rhs = NULL_TREE;\n+\t}\n+      else\n+        oprnd = gimple_op (stmt, op_idx++);\n+\n       oprnd_info = VEC_index (slp_oprnd_info, *oprnds_info, i);\n \n+      if (COMPARISON_CLASS_P (oprnd))\n+        {\n+          compare_rhs = TREE_OPERAND (oprnd, 1);\n+          oprnd = TREE_OPERAND (oprnd, 0);\n+\t}\n+\n       if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def,\n                                &dt)\n \t  || (!def_stmt && dt != vect_constant_def))\n@@ -244,8 +269,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           def_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n           dt = STMT_VINFO_DEF_TYPE (vinfo_for_stmt (def_stmt));\n \n-          if (dt == vect_unknown_def_type\n-\t      || STMT_VINFO_PATTERN_DEF_STMT (vinfo_for_stmt (def_stmt)))\n+          if (dt == vect_unknown_def_type)\n             {\n               if (vect_print_dump_info (REPORT_DETAILS))\n                 fprintf (vect_dump, \"Unsupported pattern.\");\n@@ -424,6 +448,7 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   VEC (gimple, heap) *stmts = SLP_TREE_SCALAR_STMTS (*node);\n   gimple stmt = VEC_index (gimple, stmts, 0);\n   enum tree_code first_stmt_code = ERROR_MARK, rhs_code = ERROR_MARK;\n+  enum tree_code first_cond_code = ERROR_MARK;\n   tree lhs;\n   bool stop_recursion = false, need_same_oprnds = false;\n   tree vectype, scalar_type, first_op1 = NULL_TREE;\n@@ -440,11 +465,18 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   VEC (slp_oprnd_info, heap) *oprnds_info;\n   unsigned int nops;\n   slp_oprnd_info oprnd_info;\n+  tree cond;\n \n   if (is_gimple_call (stmt))\n     nops = gimple_call_num_args (stmt);\n+  else if (is_gimple_assign (stmt))\n+    {\n+      nops = gimple_num_ops (stmt) - 1;\n+      if (gimple_assign_rhs_code (stmt) == COND_EXPR)\n+\tnops++;\n+    }\n   else\n-    nops = gimple_num_ops (stmt) - 1;\n+    return false;\n \n   oprnds_info = vect_create_oprnd_info (nops, group_size);\n \n@@ -485,6 +517,22 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t  return false;\n \t}\n \n+       if (is_gimple_assign (stmt)\n+\t   && gimple_assign_rhs_code (stmt) == COND_EXPR\n+           && (cond = gimple_assign_rhs1 (stmt))\n+           && !COMPARISON_CLASS_P (cond))\n+        {\n+          if (vect_print_dump_info (REPORT_SLP))\n+            {\n+              fprintf (vect_dump,\n+                       \"Build SLP failed: condition is not comparison \");\n+              print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+            }\n+\n+          vect_free_oprnd_info (&oprnds_info, true);\n+          return false;\n+        }\n+\n       scalar_type = vect_get_smallest_scalar_type (stmt, &dummy, &dummy);\n       vectype = get_vectype_for_scalar_type (scalar_type);\n       if (!vectype)\n@@ -737,7 +785,8 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \n \t  /* Not memory operation.  */\n \t  if (TREE_CODE_CLASS (rhs_code) != tcc_binary\n-\t      && TREE_CODE_CLASS (rhs_code) != tcc_unary)\n+\t      && TREE_CODE_CLASS (rhs_code) != tcc_unary\n+              && rhs_code != COND_EXPR)\n \t    {\n \t      if (vect_print_dump_info (REPORT_SLP))\n \t\t{\n@@ -750,6 +799,26 @@ vect_build_slp_tree (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      return false;\n \t    }\n \n+          if (rhs_code == COND_EXPR)\n+            {\n+              tree cond_expr = gimple_assign_rhs1 (stmt);\n+\n+\t      if (i == 0)\n+\t\tfirst_cond_code = TREE_CODE (cond_expr);\n+              else if (first_cond_code != TREE_CODE (cond_expr))\n+                {\n+                  if (vect_print_dump_info (REPORT_SLP))\n+                    {\n+                      fprintf (vect_dump, \"Build SLP failed: different\"\n+\t\t\t\t\t  \" operation\");\n+                      print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+                    }\n+\n+\t\t  vect_free_oprnd_info (&oprnds_info, true);\n+                  return false;\n+\t\t}\n+            }\n+\n \t  /* Find the def-stmts.  */\n \t  if (!vect_get_and_check_slp_defs (loop_vinfo, bb_vinfo, *node, stmt,\n \t\t\t\t\t    ncopies_for_cost, (i == 0),\n@@ -1402,7 +1471,12 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n       while (next)\n         {\n-          VEC_safe_push (gimple, heap, scalar_stmts, next);\n+\t  if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (next))\n+\t      && STMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)))\n+\t    VEC_safe_push (gimple, heap, scalar_stmts,\n+\t\t\tSTMT_VINFO_RELATED_STMT (vinfo_for_stmt (next)));\n+\t  else\n+            VEC_safe_push (gimple, heap, scalar_stmts, next);\n           next = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n         }\n     }\n@@ -1411,7 +1485,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       /* Collect reduction statements.  */\n       VEC (gimple, heap) *reductions = LOOP_VINFO_REDUCTIONS (loop_vinfo);\n       for (i = 0; VEC_iterate (gimple, reductions, i, next); i++)\n-        VEC_safe_push (gimple, heap, scalar_stmts, next);\n+\tVEC_safe_push (gimple, heap, scalar_stmts, next);\n     }\n \n   node = vect_create_new_slp_node (scalar_stmts);\n@@ -2150,15 +2224,15 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \n      For example, we have two scalar operands, s1 and s2 (e.g., group of\n      strided accesses of size two), while NUNITS is four (i.e., four scalars\n-     of this type can be packed in a vector). The output vector will contain\n-     two copies of each scalar operand: {s1, s2, s1, s2}. (NUMBER_OF_COPIES\n+     of this type can be packed in a vector).  The output vector will contain\n+     two copies of each scalar operand: {s1, s2, s1, s2}.  (NUMBER_OF_COPIES\n      will be 2).\n \n      If GROUP_SIZE > NUNITS, the scalars will be split into several vectors\n      containing the operands.\n \n      For example, NUNITS is four as before, and the group size is 8\n-     (s1, s2, ..., s8). We will create two vectors {s1, s2, s3, s4} and\n+     (s1, s2, ..., s8).  We will create two vectors {s1, s2, s3, s4} and\n      {s5, s6, s7, s8}.  */\n \n   number_of_copies = least_common_multiple (nunits, group_size) / group_size;\n@@ -2170,8 +2244,23 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n         {\n           if (is_store)\n             op = gimple_assign_rhs1 (stmt);\n-          else\n+          else if (gimple_assign_rhs_code (stmt) != COND_EXPR)\n             op = gimple_op (stmt, op_num + 1);\n+\t  else\n+\t    {\n+\t      if (op_num == 0 || op_num == 1)\n+\t\t{\n+\t\t  tree cond = gimple_assign_rhs1 (stmt);\n+\t\t  op = TREE_OPERAND (cond, op_num);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (op_num == 2)\n+\t\t    op = gimple_assign_rhs2 (stmt);\n+\t\t  else\n+\t\t    op = gimple_assign_rhs3 (stmt);\n+\t\t}\n+\t    }\n \n           if (reduc_index != -1)\n             {"}, {"sha": "dd65636b10f12c3aed7321292ff683149d4131d9", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 128, "deletions": 63, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -4606,7 +4606,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, tree *comp_vectype)\n+vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n+\t\t     tree *comp_vectype)\n {\n   tree lhs, rhs;\n   tree def;\n@@ -4622,7 +4623,7 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, tree *comp_vectype)\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       gimple lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use_1 (lhs, loop_vinfo, NULL, &lhs_def_stmt, &def,\n+      if (!vect_is_simple_use_1 (lhs, loop_vinfo, bb_vinfo, &lhs_def_stmt, &def,\n \t\t\t\t &dt, &vectype1))\n \treturn false;\n     }\n@@ -4633,11 +4634,11 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, tree *comp_vectype)\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use_1 (rhs, loop_vinfo, NULL, &rhs_def_stmt, &def,\n+      if (!vect_is_simple_use_1 (rhs, loop_vinfo, bb_vinfo, &rhs_def_stmt, &def,\n \t\t\t\t &dt, &vectype2))\n \treturn false;\n     }\n-  else if (TREE_CODE (rhs) != INTEGER_CST  && TREE_CODE (rhs) != REAL_CST\n+  else if (TREE_CODE (rhs) != INTEGER_CST && TREE_CODE (rhs) != REAL_CST\n \t   && TREE_CODE (rhs) != FIXED_CST)\n     return false;\n \n@@ -4660,7 +4661,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, tree *comp_vectype)\n \n bool\n vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n-\t\t\tgimple *vec_stmt, tree reduc_def, int reduc_index)\n+\t\t\tgimple *vec_stmt, tree reduc_def, int reduc_index,\n+\t\t\tslp_tree slp_node)\n {\n   tree scalar_dest = NULL_TREE;\n   tree vec_dest = NULL_TREE;\n@@ -4676,23 +4678,27 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   tree def;\n   enum vect_def_type dt, dts[4];\n   int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  int ncopies;\n   enum tree_code code;\n   stmt_vec_info prev_stmt_info = NULL;\n-  int j;\n-\n-  /* FORNOW: unsupported in basic block SLP.  */\n-  gcc_assert (loop_vinfo);\n+  int i, j;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  VEC (tree, heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n+  VEC (tree, heap) *vec_oprnds2 = NULL, *vec_oprnds3 = NULL;\n \n-  /* FORNOW: SLP not supported.  */\n-  if (STMT_SLP_TYPE (stmt_info))\n-    return false;\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n \n   gcc_assert (ncopies >= 1);\n   if (reduc_index && ncopies > 1)\n     return false; /* FORNOW */\n \n-  if (!STMT_VINFO_RELEVANT_P (stmt_info))\n+  if (reduc_index && STMT_SLP_TYPE (stmt_info))\n+    return false;\n+\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n     return false;\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n@@ -4721,14 +4727,14 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, loop_vinfo, &comp_vectype)\n+  if (!vect_is_simple_cond (cond_expr, loop_vinfo, bb_vinfo, &comp_vectype)\n       || !comp_vectype)\n     return false;\n \n   if (TREE_CODE (then_clause) == SSA_NAME)\n     {\n       gimple then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n-      if (!vect_is_simple_use (then_clause, loop_vinfo, NULL,\n+      if (!vect_is_simple_use (then_clause, loop_vinfo, bb_vinfo,\n \t\t\t       &then_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -4740,7 +4746,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (else_clause) == SSA_NAME)\n     {\n       gimple else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n-      if (!vect_is_simple_use (else_clause, loop_vinfo, NULL,\n+      if (!vect_is_simple_use (else_clause, loop_vinfo, bb_vinfo,\n \t\t\t       &else_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -4755,7 +4761,15 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n       return expand_vec_cond_expr_p (vectype, comp_vectype);\n     }\n \n-  /* Transform */\n+  /* Transform.  */\n+\n+  if (!slp_node)\n+    {\n+      vec_oprnds0 = VEC_alloc (tree, heap, 1);\n+      vec_oprnds1 = VEC_alloc (tree, heap, 1);\n+      vec_oprnds2 = VEC_alloc (tree, heap, 1);\n+      vec_oprnds3 = VEC_alloc (tree, heap, 1);\n+    }\n \n   /* Handle def.  */\n   scalar_dest = gimple_assign_lhs (stmt);\n@@ -4764,67 +4778,118 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   /* Handle cond expr.  */\n   for (j = 0; j < ncopies; j++)\n     {\n-      gimple new_stmt;\n+      gimple new_stmt = NULL;\n       if (j == 0)\n \t{\n-\t  gimple gtemp;\n-\t  vec_cond_lhs =\n+          if (slp_node)\n+            {\n+              VEC (tree, heap) *ops = VEC_alloc (tree, heap, 4);\n+              VEC (slp_void_p, heap) *vec_defs;\n+\n+\t      vec_defs = VEC_alloc (slp_void_p, heap, 4);\n+              VEC_safe_push (tree, heap, ops, TREE_OPERAND (cond_expr, 0));\n+              VEC_safe_push (tree, heap, ops, TREE_OPERAND (cond_expr, 1));\n+              VEC_safe_push (tree, heap, ops, then_clause);\n+              VEC_safe_push (tree, heap, ops, else_clause);\n+              vect_get_slp_defs (ops, slp_node, &vec_defs, -1);\n+              vec_oprnds3 = (VEC (tree, heap) *) VEC_pop (slp_void_p, vec_defs);\n+              vec_oprnds2 = (VEC (tree, heap) *) VEC_pop (slp_void_p, vec_defs);\n+              vec_oprnds1 = (VEC (tree, heap) *) VEC_pop (slp_void_p, vec_defs);\n+              vec_oprnds0 = (VEC (tree, heap) *) VEC_pop (slp_void_p, vec_defs);\n+\n+              VEC_free (tree, heap, ops);\n+              VEC_free (slp_void_p, heap, vec_defs);\n+            }\n+          else\n+            {\n+\t      gimple gtemp;\n+\t      vec_cond_lhs =\n \t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n \t\t\t\t\t    stmt, NULL);\n-\t  vect_is_simple_use (TREE_OPERAND (cond_expr, 0), loop_vinfo,\n+\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0), loop_vinfo,\n \t\t\t      NULL, &gtemp, &def, &dts[0]);\n-\t  vec_cond_rhs =\n-\t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n-\t\t\t\t\t    stmt, NULL);\n-\t  vect_is_simple_use (TREE_OPERAND (cond_expr, 1), loop_vinfo,\n-\t\t\t      NULL, &gtemp, &def, &dts[1]);\n-\t  if (reduc_index == 1)\n-\t    vec_then_clause = reduc_def;\n-\t  else\n-\t    {\n-\t      vec_then_clause = vect_get_vec_def_for_operand (then_clause,\n-\t\t\t\t\t\t\t      stmt, NULL);\n-\t      vect_is_simple_use (then_clause, loop_vinfo,\n-\t\t\t\t  NULL, &gtemp, &def, &dts[2]);\n-\t    }\n-\t  if (reduc_index == 2)\n-\t    vec_else_clause = reduc_def;\n-\t  else\n-\t    {\n-\t      vec_else_clause = vect_get_vec_def_for_operand (else_clause,\n+\n+\t      vec_cond_rhs =\n+\t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n+\t\t\t\t\t\tstmt, NULL);\n+\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1), loop_vinfo,\n+\t\t\t\t\tNULL, &gtemp, &def, &dts[1]);\n+\t      if (reduc_index == 1)\n+\t\tvec_then_clause = reduc_def;\n+\t      else\n+\t\t{\n+\t\t  vec_then_clause = vect_get_vec_def_for_operand (then_clause,\n+\t\t \t\t  \t\t\t      stmt, NULL);\n+\t          vect_is_simple_use (then_clause, loop_vinfo,\n+\t\t\t\t\t  NULL, &gtemp, &def, &dts[2]);\n+\t\t}\n+\t      if (reduc_index == 2)\n+\t\tvec_else_clause = reduc_def;\n+\t      else\n+\t\t{\n+\t\t  vec_else_clause = vect_get_vec_def_for_operand (else_clause,\n \t\t\t\t\t\t\t      stmt, NULL);\n-\t      vect_is_simple_use (else_clause, loop_vinfo,\n+\t\t  vect_is_simple_use (else_clause, loop_vinfo,\n \t\t\t\t  NULL, &gtemp, &def, &dts[3]);\n+\t\t}\n \t    }\n \t}\n       else\n \t{\n-\t  vec_cond_lhs = vect_get_vec_def_for_stmt_copy (dts[0], vec_cond_lhs);\n-\t  vec_cond_rhs = vect_get_vec_def_for_stmt_copy (dts[1], vec_cond_rhs);\n+\t  vec_cond_lhs = vect_get_vec_def_for_stmt_copy (dts[0],\n+\t\t\t\t\t\tVEC_pop (tree, vec_oprnds0));\n+\t  vec_cond_rhs = vect_get_vec_def_for_stmt_copy (dts[1],\n+\t\t\t\t\t\tVEC_pop (tree, vec_oprnds1));\n \t  vec_then_clause = vect_get_vec_def_for_stmt_copy (dts[2],\n-\t\t\t\t\t\t\t    vec_then_clause);\n+\t\t\t\t\t\tVEC_pop (tree, vec_oprnds2));\n \t  vec_else_clause = vect_get_vec_def_for_stmt_copy (dts[3],\n-\t\t\t\t\t\t\t    vec_else_clause);\n+\t\t\t\t\t\tVEC_pop (tree, vec_oprnds3));\n+\t}\n+\n+      if (!slp_node)\n+        {\n+\t  VEC_quick_push (tree, vec_oprnds0, vec_cond_lhs);\n+\t  VEC_quick_push (tree, vec_oprnds1, vec_cond_rhs);\n+\t  VEC_quick_push (tree, vec_oprnds2, vec_then_clause);\n+\t  VEC_quick_push (tree, vec_oprnds3, vec_else_clause);\n \t}\n \n       /* Arguments are ready.  Create the new vector stmt.  */\n-      vec_compare = build2 (TREE_CODE (cond_expr), vectype,\n-\t\t\t    vec_cond_lhs, vec_cond_rhs);\n-      vec_cond_expr = build3 (VEC_COND_EXPR, vectype,\n-\t\t\t      vec_compare, vec_then_clause, vec_else_clause);\n+      FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vec_cond_lhs)\n+        {\n+          vec_cond_rhs = VEC_index (tree, vec_oprnds1, i);\n+          vec_then_clause = VEC_index (tree, vec_oprnds2, i);\n+          vec_else_clause = VEC_index (tree, vec_oprnds3, i);\n \n-      new_stmt = gimple_build_assign (vec_dest, vec_cond_expr);\n-      new_temp = make_ssa_name (vec_dest, new_stmt);\n-      gimple_assign_set_lhs (new_stmt, new_temp);\n-      vect_finish_stmt_generation (stmt, new_stmt, gsi);\n-      if (j == 0)\n-        STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n-      else\n-        STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+          vec_compare = build2 (TREE_CODE (cond_expr), vectype,\n+  \t\t\t       vec_cond_lhs, vec_cond_rhs);\n+          vec_cond_expr = build3 (VEC_COND_EXPR, vectype,\n+ \t\t         vec_compare, vec_then_clause, vec_else_clause);\n \n-      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+          new_stmt = gimple_build_assign (vec_dest, vec_cond_expr);\n+          new_temp = make_ssa_name (vec_dest, new_stmt);\n+          gimple_assign_set_lhs (new_stmt, new_temp);\n+          vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+          if (slp_node)\n+            VEC_quick_push (gimple, SLP_TREE_VEC_STMTS (slp_node), new_stmt);\n+        }\n+\n+        if (slp_node)\n+          continue;\n+\n+        if (j == 0)\n+          STMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+        else\n+          STMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+        prev_stmt_info = vinfo_for_stmt (new_stmt);\n     }\n \n+  VEC_free (tree, heap, vec_oprnds0);\n+  VEC_free (tree, heap, vec_oprnds1);\n+  VEC_free (tree, heap, vec_oprnds2);\n+  VEC_free (tree, heap, vec_oprnds3);\n+\n   return true;\n }\n \n@@ -4996,7 +5061,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n             || vectorizable_call (stmt, NULL, NULL)\n             || vectorizable_store (stmt, NULL, NULL, NULL)\n             || vectorizable_reduction (stmt, NULL, NULL, NULL)\n-            || vectorizable_condition (stmt, NULL, NULL, NULL, 0));\n+            || vectorizable_condition (stmt, NULL, NULL, NULL, 0, NULL));\n     else\n       {\n         if (bb_vinfo)\n@@ -5005,7 +5070,8 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                 || vectorizable_operation (stmt, NULL, NULL, node)\n                 || vectorizable_assignment (stmt, NULL, NULL, node)\n                 || vectorizable_load (stmt, NULL, NULL, node, NULL)\n-                || vectorizable_store (stmt, NULL, NULL, node));\n+                || vectorizable_store (stmt, NULL, NULL, node)\n+                || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node));\n       }\n \n   if (!ok)\n@@ -5113,8 +5179,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n       break;\n \n     case condition_vec_info_type:\n-      gcc_assert (!slp_node);\n-      done = vectorizable_condition (stmt, gsi, &vec_stmt, NULL, 0);\n+      done = vectorizable_condition (stmt, gsi, &vec_stmt, NULL, 0, slp_node);\n       gcc_assert (done);\n       break;\n "}, {"sha": "1d61d9d9af2d6bb56426c5cd5caff7f0631d6d14", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e531cf982da6f84f670916abe453f993757c8d/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f7e531cf982da6f84f670916abe453f993757c8d", "patch": "@@ -837,7 +837,7 @@ extern bool vect_transform_stmt (gimple, gimple_stmt_iterator *,\n extern void vect_remove_stores (gimple);\n extern bool vect_analyze_stmt (gimple, bool *, slp_tree);\n extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *,\n-                                    tree, int);\n+                                    tree, int, slp_tree);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n                                 unsigned int *, unsigned int *);\n extern void vect_get_store_cost (struct data_reference *, int, unsigned int *);"}]}