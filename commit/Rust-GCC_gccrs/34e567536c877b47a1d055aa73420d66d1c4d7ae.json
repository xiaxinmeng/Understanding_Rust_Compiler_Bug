{"sha": "34e567536c877b47a1d055aa73420d66d1c4d7ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRlNTY3NTM2Yzg3N2I0N2ExZDA1NWFhNzM0MjBkNjZkMWM0ZDdhZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-17T23:19:29Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-17T23:19:29Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r204", "tree": {"sha": "b384e599fc3ef596a91e50d7389cf9fa3720fbfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b384e599fc3ef596a91e50d7389cf9fa3720fbfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34e567536c877b47a1d055aa73420d66d1c4d7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e567536c877b47a1d055aa73420d66d1c4d7ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34e567536c877b47a1d055aa73420d66d1c4d7ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34e567536c877b47a1d055aa73420d66d1c4d7ae/comments", "author": null, "committer": null, "parents": [{"sha": "6c65299b5eb54054e639c3f2523e30542fe25555", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c65299b5eb54054e639c3f2523e30542fe25555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c65299b5eb54054e639c3f2523e30542fe25555"}], "stats": {"total": 841, "additions": 475, "deletions": 366}, "files": [{"sha": "25df390eec151a28188e11b4b56d3a045b490f62", "filename": "gcc/global.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=34e567536c877b47a1d055aa73420d66d1c4d7ae", "patch": "@@ -1,5 +1,5 @@\n /* Allocate registers for pseudo-registers that span basic blocks.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -394,9 +394,17 @@ global_alloc (file)\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_allocno[i] < 0 && reg_renumber[i] >= 0)\n       {\n-\tlocal_reg_n_refs[reg_renumber[i]] += reg_n_refs[i];\n-\tlocal_reg_live_length[reg_renumber[i]] += reg_live_length[i];\n+\tint regno = reg_renumber[i];\n+\tint endregno = regno + HARD_REGNO_NREGS (regno, PSEUDO_REGNO_MODE (i));\n+\tint j;\n+\n+\tfor (j = regno; j < endregno; j++)\n+\t  {\n+\t    local_reg_n_refs[j] += reg_n_refs[i];\n+\t    local_reg_live_length[j] += reg_live_length[i];\n+\t  }\n       }\n+\n   /* We can't override local-alloc for a reg used not just by local-alloc.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (regs_ever_live[i])\n@@ -1016,8 +1024,16 @@ find_reg (allocno, losers, all_regs_p, accept_call_clobbered, retrying)\n \t       than it would be used by this one allocno!  */\n \t    int k;\n \t    for (k = 0; k < max_regno; k++)\n-\t      if (reg_renumber[k] == i)\n-\t\treg_renumber[k] = -1;\n+\t      if (reg_renumber[k] >= 0)\n+\t\t{\n+\t\t  int regno = reg_renumber[k];\n+\t\t  int endregno\n+\t\t    = regno + HARD_REGNO_NREGS (regno, PSEUDO_REGNO_MODE (k));\n+\n+\t\t  if (i >= regno && i < endregno)\n+\t\t    reg_renumber[k] = -1;\n+\t\t}\n+\n \t    best_reg = i;\n \t    break;\n \t  }"}, {"sha": "6e50650020aa9c2b427ba8240cb11671f0837996", "filename": "gcc/integrate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=34e567536c877b47a1d055aa73420d66d1c4d7ae", "patch": "@@ -1,5 +1,5 @@\n /* Procedure integration for GNU CC.\n-   Copyright (C) 1988, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1991 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC."}, {"sha": "9092c958ecebe0b295e55955674e229b7c360139", "filename": "gcc/optabs.c", "status": "modified", "additions": 136, "deletions": 151, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=34e567536c877b47a1d055aa73420d66d1c4d7ae", "patch": "@@ -1,5 +1,5 @@\n /* Expand the basic unary and binary arithmetic operations, for GNU compiler.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -189,7 +189,6 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n {\n   enum mode_class class;\n   enum machine_mode wider_mode;\n-  enum machine_mode submode = mode_for_size (BITS_PER_WORD, MODE_INT, 0);\n   register rtx temp;\n   int commutative_op = 0;\n   int shift_op = (binoptab->code ==  ASHIFT\n@@ -219,10 +218,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n     op0 = force_reg (mode, op0);\n \n   if (CONSTANT_P (op1) && preserve_subexpressions_p () && rtx_cost (op1) > 2)\n-    op1 = force_reg ((shift_op\n-\t\t      ? mode_for_size (BITS_PER_WORD, MODE_INT, 0)\n-\t\t      : mode),\n-\t\t     op1);\n+    op1 = force_reg (shift_op ? word_mode : mode, op1);\n \n #if 0  /* Turned off because it seems to be a kludgy method.  */\n   /* If subtracting integer from pointer, and the pointer has a special mode,\n@@ -341,7 +337,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n   if ((binoptab == and_optab || binoptab == ior_optab || binoptab == xor_optab)\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && binoptab->handlers[(int) submode].insn_code != CODE_FOR_nothing)\n+      && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n       int i;\n       rtx insns;\n@@ -358,7 +354,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n       for (i = 0; i < GET_MODE_BITSIZE (mode) / BITS_PER_WORD; i++)\n \t{\n \t  rtx target_piece = operand_subword (target, i, 1, mode);\n-\t  rtx x = expand_binop (submode, binoptab,\n+\t  rtx x = expand_binop (word_mode, binoptab,\n \t\t\t\toperand_subword_force (op0, i, mode),\n \t\t\t\toperand_subword_force (op1, i, mode),\n \t\t\t\ttarget_piece, unsignedp, methods);\n@@ -382,10 +378,10 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n   if ((binoptab == add_optab || binoptab == sub_optab)\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) >= 2 * UNITS_PER_WORD\n-      && binoptab->handlers[(int) submode].insn_code != CODE_FOR_nothing)\n+      && binoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n       int i;\n-      rtx carry_tmp = gen_reg_rtx (submode);\n+      rtx carry_tmp = gen_reg_rtx (word_mode);\n       optab otheroptab = binoptab == add_optab ? sub_optab : add_optab;\n       int nwords = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n       rtx carry_in, carry_out;\n@@ -417,7 +413,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  rtx x;\n \n \t  /* Main add/subtract of the input operands.  */\n-\t  x = expand_binop (submode, binoptab,\n+\t  x = expand_binop (word_mode, binoptab,\n \t\t\t    op0_piece, op1_piece,\n \t\t\t    target_piece, unsignedp, methods);\n \t  if (x == 0)\n@@ -426,19 +422,19 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (i + 1 < nwords)\n \t    {\n \t      /* Store carry from main add/subtract.  */\n-\t      carry_out = gen_reg_rtx (submode);\n+\t      carry_out = gen_reg_rtx (word_mode);\n \t      carry_out = emit_store_flag (carry_out,\n \t\t\t\t\t   binoptab == add_optab ? LTU : GTU,\n \t\t\t\t\t   x, op0_piece,\n-\t\t\t\t\t   submode, 1, normalizep);\n+\t\t\t\t\t   word_mode, 1, normalizep);\n \t      if (!carry_out)\n \t\tbreak;\n \t    }\n \n \t  if (i > 0)\n \t    {\n \t      /* Add/subtract previous carry to main result.  */\n-\t      x = expand_binop (submode,\n+\t      x = expand_binop (word_mode,\n \t\t\t\tnormalizep == 1 ? binoptab : otheroptab,\n \t\t\t\tx, carry_in,\n \t\t\t\ttarget_piece, 1, methods);\n@@ -453,9 +449,9 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t\t\t\t\t       binoptab == add_optab\n \t\t\t\t\t         ? LTU : GTU,\n \t\t\t\t\t       x, carry_in,\n-\t\t\t\t\t       submode, 1, normalizep);\n+\t\t\t\t\t       word_mode, 1, normalizep);\n \t\t  /* Logical-ior the two poss. carry together.  */\n-\t\t  carry_out = expand_binop (submode, ior_optab,\n+\t\t  carry_out = expand_binop (word_mode, ior_optab,\n \t\t\t\t\t    carry_out, carry_tmp,\n \t\t\t\t\t    carry_out, 0, methods);\n \t\t  if (!carry_out)\n@@ -486,19 +482,19 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n      because we are not operating on one word at a time. \n \n      The multiplication proceeds as follows:\n-\t\t\t     _______________________\n-\t\t\t    [__op0_high_|__op0_low__]\n-\t\t\t     _______________________\n-    *\t\t\t    [__op1_high_|__op1_low__]\n-    _______________________________________________\n-\t\t\t     _______________________\n-(1)\t\t\t    [__op0_low__*__op1_low__]\n-\t\t _______________________\n-(2a)\t\t[__op0_low__*__op1_high_]\n-\t\t _______________________\n-(2b)\t\t[__op0_high_*__op1_low__]\n-     _______________________\n-(3) [__op0_high_*__op1_high_]\n+\t\t\t         _______________________\n+\t\t\t        [__op0_high_|__op0_low__]\n+\t\t\t         _______________________\n+        *\t\t\t    [__op1_high_|__op1_low__]\n+        _______________________________________________\n+\t\t\t         _______________________\n+    (1)\t\t\t    [__op0_low__*__op1_low__]\n+\t\t     _______________________\n+    (2a)\t\t[__op0_low__*__op1_high_]\n+\t\t     _______________________\n+    (2b)\t\t[__op0_high_*__op1_low__]\n+         _______________________\n+    (3) [__op0_high_*__op1_high_]\n \n \n     This gives a 4-word result.  Since we are only interested in the\n@@ -533,8 +529,8 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n   if (binoptab == smul_optab\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) == 2 * UNITS_PER_WORD\n-      && smul_optab->handlers[(int) submode].insn_code != CODE_FOR_nothing\n-      && add_optab->handlers[(int) submode].insn_code != CODE_FOR_nothing\n+      && smul_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n+      && add_optab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing\n       && ((umul_widen_optab->handlers[(int) mode].insn_code\n \t   != CODE_FOR_nothing)\n \t  || (smul_widen_optab->handlers[(int) mode].insn_code\n@@ -578,32 +574,32 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  rtx wordm1 = gen_rtx (CONST_INT, VOIDmode, BITS_PER_WORD - 1);\n \t  product = expand_binop (mode, smul_widen_optab, op0_low, op1_low,\n \t\t\t\t  target, 1, OPTAB_DIRECT);\n-\t  op0_xhigh = expand_binop (submode, lshr_optab, op0_low, wordm1,\n+\t  op0_xhigh = expand_binop (word_mode, lshr_optab, op0_low, wordm1,\n \t\t\t\t    0, 1, OPTAB_DIRECT);\n \t  if (op0_xhigh)\n-\t    op0_xhigh = expand_binop (submode, add_optab, op0_high, op0_xhigh,\n-\t\t\t\t      op0_xhigh, 0, OPTAB_DIRECT);\n+\t    op0_xhigh = expand_binop (word_mode, add_optab, op0_high,\n+\t\t\t\t      op0_xhigh, op0_xhigh, 0, OPTAB_DIRECT);\n \t  else\n \t    {\n-\t      op0_xhigh = expand_binop (submode, ashr_optab, op0_low, wordm1,\n+\t      op0_xhigh = expand_binop (word_mode, ashr_optab, op0_low, wordm1,\n \t\t\t\t\t0, 0, OPTAB_DIRECT);\n \t      if (op0_xhigh)\n-\t\top0_xhigh = expand_binop (submode, sub_optab, op0_high,\n+\t\top0_xhigh = expand_binop (word_mode, sub_optab, op0_high,\n \t\t\t\t\t  op0_xhigh, op0_xhigh, 0,\n \t\t\t\t\t  OPTAB_DIRECT);\n \t    }\n \n-\t  op1_xhigh = expand_binop (submode, lshr_optab, op1_low, wordm1,\n+\t  op1_xhigh = expand_binop (word_mode, lshr_optab, op1_low, wordm1,\n \t\t\t\t    0, 1, OPTAB_DIRECT);\n \t  if (op1_xhigh)\n-\t    op1_xhigh = expand_binop (SImode, add_optab, op1_high, op1_xhigh,\n-\t\t\t\t      op1_xhigh, 0, OPTAB_DIRECT);\n+\t    op1_xhigh = expand_binop (word_mode, add_optab, op1_high,\n+\t\t\t\t      op1_xhigh, op1_xhigh, 0, OPTAB_DIRECT);\n \t  else\n \t    {\n-\t      op1_xhigh = expand_binop (submode, ashr_optab, op1_low, wordm1,\n+\t      op1_xhigh = expand_binop (word_mode, ashr_optab, op1_low, wordm1,\n \t\t\t\t\t0, 0, OPTAB_DIRECT);\n \t      if (op1_xhigh)\n-\t\top1_xhigh = expand_binop (SImode, sub_optab, op1_high,\n+\t\top1_xhigh = expand_binop (word_mode, sub_optab, op1_high,\n \t\t\t\t\t  op1_xhigh, op1_xhigh, 0,\n \t\t\t\t\t  OPTAB_DIRECT);\n \t    }\n@@ -623,21 +619,21 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t{\n \t  rtx product_piece;\n \t  rtx product_high = operand_subword (product, high, 1, mode);\n-\t  rtx temp = expand_binop (submode, binoptab, op0_low, op1_xhigh, 0,\n+\t  rtx temp = expand_binop (word_mode, binoptab, op0_low, op1_xhigh, 0,\n \t\t\t\t   0, OPTAB_DIRECT);\n \n \t  if (temp)\n \t    {\n-\t      product_piece = expand_binop (submode, add_optab, temp,\n+\t      product_piece = expand_binop (word_mode, add_optab, temp,\n \t\t\t\t\t    product_high, product_high,\n \t\t\t\t\t    0, OPTAB_LIB_WIDEN);\n \t      if (product_piece != product_high)\n \t\temit_move_insn (product_high, product_piece);\n \n-\t      temp = expand_binop (submode, binoptab, op1_low, op0_xhigh, 0,\n+\t      temp = expand_binop (word_mode, binoptab, op1_low, op0_xhigh, 0,\n \t\t\t\t   0, OPTAB_DIRECT);\n \n-\t      product_piece = expand_binop (submode, add_optab, temp,\n+\t      product_piece = expand_binop (word_mode, add_optab, temp,\n \t\t\t\t\t    product_high, product_high,\n \t\t\t\t\t    0, OPTAB_LIB_WIDEN);\n \t      if (product_piece != product_high)\n@@ -674,9 +670,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t if the libcall is cse'd or moved.  */\n       emit_library_call (binoptab->handlers[(int) mode].libfunc,\n \t\t\t 1, mode, 2, op0, mode, op1,\n-\t\t\t (shift_op\n-\t\t\t  ? mode_for_size (BITS_PER_WORD, MODE_INT, 0)\n-\t\t\t  : mode));\n+\t\t\t (shift_op ? word_mode : mode));\n \n       insns = get_insns ();\n       end_sequence ();\n@@ -701,15 +695,12 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n   methods = (methods == OPTAB_LIB_WIDEN ? OPTAB_LIB : OPTAB_DIRECT);\n \n-  /* Widening is now independent of specific machine modes.\n-     It is assumed that widening may be performed to any\n-     higher numbered mode in the same mode class.  */\n+  /* Look for a wider mode of the same class for which it appears we can do\n+     the operation.  */\n \n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   ((int) wider_mode < (int) MAX_MACHINE_MODE\n-\t    && GET_MODE_CLASS (wider_mode) == class);\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if ((binoptab->handlers[(int) wider_mode].insn_code\n@@ -720,53 +711,39 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t      rtx xop0 = op0, xop1 = op1;\n \t      int no_extend = 0;\n \n-\t      /* For certain operations, we need not actually extend\n+\t      /* For certain integer operations, we need not actually extend\n \t\t the narrow operands, as long as we will truncate\n \t\t the results to the same narrowness.  */\n \n-\t      if (binoptab == ior_optab || binoptab == and_optab\n-\t\t  || binoptab == xor_optab\n-\t\t  || binoptab == add_optab || binoptab == sub_optab\n-\t\t  || binoptab == smul_optab\n-\t\t  || binoptab == ashl_optab || binoptab == lshl_optab)\n+\t      if ((binoptab == ior_optab || binoptab == and_optab\n+\t\t   || binoptab == xor_optab\n+\t\t   || binoptab == add_optab || binoptab == sub_optab\n+\t\t   || binoptab == smul_optab\n+\t\t   || binoptab == ashl_optab || binoptab == lshl_optab)\n+\t\t  && class == MODE_INT)\n \t\tno_extend = 1;\n \n-\t      if (GET_MODE (xop0) != VOIDmode\n-\t\t  && GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_INT)\n-\t\t{\n-\t\t  if (no_extend)\n-\t\t    {\n-\t\t      temp = force_reg (GET_MODE (xop0), xop0);\n-\t\t      xop0 = gen_rtx (SUBREG, wider_mode, temp, 0);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      temp = gen_reg_rtx (wider_mode);\n-\t\t      convert_move (temp, xop0, unsignedp);\n-\t\t      xop0 = temp;\n-\t\t    }\n-\t\t}\n-\t      if (GET_MODE (xop1) != VOIDmode\n-\t\t  && GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_INT)\n-\t\t{\n-\t\t  if (no_extend)\n-\t\t    {\n-\t\t      temp = force_reg (GET_MODE (xop1), xop1);\n-\t\t      xop1 = gen_rtx (SUBREG, wider_mode, temp, 0);\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      temp = gen_reg_rtx (wider_mode);\n-\t\t      convert_move (temp, xop1, unsignedp);\n-\t\t      xop1 = temp;\n-\t\t    }\n-\t\t}\n+\t      /* If an operand is a constant integer, we might as well\n+\t\t convert it since that is more efficient than using a SUBREG,\n+\t\t unlike the case for other operands.  */\n+\n+\t      if (no_extend && GET_MODE (xop0) != VOIDmode)\n+\t\txop0 = gen_rtx (SUBREG, wider_mode,\n+\t\t\t\tforce_reg (GET_MODE (xop0), xop0), 0);\n+\t      else\n+\t\txop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n+\n+\t      if (no_extend && GET_MODE (xop1) != VOIDmode)\n+\t\txop1 = gen_rtx (SUBREG, wider_mode,\n+\t\t\t\tforce_reg (GET_MODE (xop1), xop1), 0);\n+\t      else\n+\t\txop1 = convert_to_mode (wider_mode, xop1, unsignedp);\n \n \t      temp = expand_binop (wider_mode, binoptab, xop0, xop1, 0,\n \t\t\t\t   unsignedp, methods);\n \t      if (temp)\n \t\t{\n-\t\t  if (class == MODE_FLOAT)\n+\t\t  if (class != MODE_INT)\n \t\t    {\n \t\t      if (target == 0)\n \t\t\ttarget = gen_reg_rtx (mode);\n@@ -940,8 +917,7 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n \n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   GET_MODE_CLASS (wider_mode) == class;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if (binoptab->handlers[(int) wider_mode].insn_code\n@@ -991,7 +967,6 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n {\n   enum mode_class class;\n   enum machine_mode wider_mode;\n-  enum machine_mode submode = mode_for_size (BITS_PER_WORD, MODE_INT, 0);\n   register rtx temp;\n   rtx last = get_last_insn ();\n   rtx pat;\n@@ -1053,7 +1028,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n   if (unoptab == one_cmpl_optab\n       && class == MODE_INT\n       && GET_MODE_SIZE (mode) > UNITS_PER_WORD\n-      && unoptab->handlers[(int) submode].insn_code != CODE_FOR_nothing)\n+      && unoptab->handlers[(int) word_mode].insn_code != CODE_FOR_nothing)\n     {\n       int i;\n       rtx insns;\n@@ -1067,7 +1042,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       for (i = 0; i < GET_MODE_BITSIZE (mode) / BITS_PER_WORD; i++)\n \t{\n \t  rtx target_piece = operand_subword (target, i, 1, mode);\n-\t  rtx x = expand_unop (submode, unoptab,\n+\t  rtx x = expand_unop (word_mode, unoptab,\n \t\t\t       operand_subword_force (op0, i, mode),\n \t\t\t       target_piece, unsignedp);\n \t  if (target_piece != x)\n@@ -1107,32 +1082,41 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n \n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   GET_MODE_CLASS (wider_mode) == class;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if ((unoptab->handlers[(int) wider_mode].insn_code\n \t       != CODE_FOR_nothing)\n \t      || unoptab->handlers[(int) wider_mode].libfunc)\n \t    {\n-\t      if (GET_MODE (op0) != VOIDmode\n-\t\t  && GET_MODE_BITSIZE (wider_mode) <= HOST_BITS_PER_INT)\n-\t\t{\n-\t\t  temp = gen_reg_rtx (wider_mode);\n-\t\t  convert_move (temp, op0, unsignedp);\n-\t\t  op0 = temp;\n-\t\t}\n+\t      rtx xop0 = op0;\n+\n+\t      /* For certain operations, we need not actually extend\n+\t\t the narrow operand, as long as we will truncate the\n+\t\t results to the same narrowness.  */\n+\n+\t      if ((unoptab == neg_optab || unoptab == one_cmpl_optab)\n+\t\t  && class == MODE_INT)\n+\t\txop0 = gen_rtx (SUBREG, wider_mode, force_reg (mode, xop0), 0);\n+\t      else\n+\t\txop0 = convert_to_mode (wider_mode, xop0, unsignedp);\n \t      \n-\t      target = expand_unop (wider_mode, unoptab, op0, 0, unsignedp);\n-\t      if (class == MODE_FLOAT)\n+\t      temp = expand_unop (wider_mode, unoptab, xop0, 0, unsignedp);\n+\n+\t      if (temp)\n \t\t{\n-\t\t  if (target == 0)\n-\t\t    target = gen_reg_rtx (mode);\n-\t\t  convert_move (target, temp, 0);\n-\t\t  return target;\n+\t\t  if (class != MODE_INT)\n+\t\t    {\n+\t\t      if (target == 0)\n+\t\t\ttarget = gen_reg_rtx (mode);\n+\t\t      convert_move (target, temp, 0);\n+\t\t      return target;\n+\t\t    }\n+\t\t  else\n+\t\t    return gen_lowpart (mode, temp);\n \t\t}\n \t      else\n-\t\treturn gen_lowpart (mode, target);\n+\t\tdelete_insns_since (last);\n \t    }\n \t}\n     }\n@@ -1563,8 +1547,7 @@ emit_cmp_insn (x, y, comparison, size, mode, unsignedp, align)\n \n   if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   GET_MODE_CLASS (wider_mode) == class;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if (cmp_optab->handlers[(int) wider_mode].insn_code\n@@ -1695,8 +1678,7 @@ emit_float_lib_cmp (x, y, comparison)\n     {\n       enum machine_mode wider_mode;\n \n-      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n-\t   GET_MODE_CLASS (wider_mode) == MODE_FLOAT;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if ((cmp_optab->handlers[(int) wider_mode].insn_code\n@@ -1863,21 +1845,18 @@ gen_move_insn (x, y)\n }\n \f\n /* Tables of patterns for extending one integer mode to another.  */\n-static enum insn_code zero_extend_codes[MAX_MACHINE_MODE][MAX_MACHINE_MODE];\n-static enum insn_code sign_extend_codes[MAX_MACHINE_MODE][MAX_MACHINE_MODE];\n+static enum insn_code extendtab[MAX_MACHINE_MODE][MAX_MACHINE_MODE][2];\n \n-/* Return nonzero if it's possible to extend FROM_MODE to TO_MODE.\n-   UNSIGNEDP specifies zero-extension instead of sign-extension.\n+/* Return the insn code used to extend FROM_MODE to TO_MODE.\n+   UNSIGNEDP specifies zero-extension instead of sign-extension.  If\n+   no such operation exists, CODE_FOR_nothing will be returned.  */\n \n-   Actually, the value is the instruction code for the extension pattern.  */\n-\n-int\n+enum insn_code\n can_extend_p (to_mode, from_mode, unsignedp)\n      enum machine_mode to_mode, from_mode;\n      int unsignedp;\n {\n-  return ((unsignedp ? zero_extend_codes : sign_extend_codes)\n-\t  [(int) to_mode][(int) from_mode]);\n+  return extendtab[(int) to_mode][(int) from_mode][unsignedp];\n }\n \n /* Generate the body of an insn to extend Y (with mode MFROM)\n@@ -1889,97 +1868,99 @@ gen_extend_insn (x, y, mto, mfrom, unsignedp)\n      enum machine_mode mto, mfrom;\n      int unsignedp;\n {\n-  return (GEN_FCN ((unsignedp ? zero_extend_codes : sign_extend_codes)\n-\t\t   [(int)mto][(int)mfrom])\n-\t  (x, y));\n+  return (GEN_FCN (extendtab[(int) mto][(int) mfrom][unsignedp]) (x, y));\n }\n \n static void\n init_extends ()\n {\n-  bzero (sign_extend_codes, sizeof sign_extend_codes);\n-  bzero (zero_extend_codes, sizeof zero_extend_codes);\n+  enum insn_code *p;\n+\n+  for (p = extendtab[0][0];\n+       p < extendtab[0][0] + sizeof extendtab / sizeof extendtab[0][0][0];\n+       p++)\n+    *p = CODE_FOR_nothing;\n \n #ifdef HAVE_extendditi2\n   if (HAVE_extendditi2)\n-    sign_extend_codes[(int) TImode][(int) DImode] = CODE_FOR_extendditi2;\n+    extendtab[(int) TImode][(int) DImode][0] = CODE_FOR_extendditi2;\n #endif\n #ifdef HAVE_extendsiti2\n   if (HAVE_extendsiti2)\n-    sign_extend_codes[(int) TImode][(int) SImode] = CODE_FOR_extendsiti2;\n+    extendtab[(int) TImode][(int) SImode][0] = CODE_FOR_extendsiti2;\n #endif\n #ifdef HAVE_extendhiti2\n   if (HAVE_extendhiti2)\n-    sign_extend_codes[(int) TImode][(int) HImode] = CODE_FOR_extendhiti2;\n+    extendtab[(int) TImode][(int) HImode][0] = CODE_FOR_extendhiti2;\n #endif\n #ifdef HAVE_extendqiti2\n   if (HAVE_extendqiti2)\n-    sign_extend_codes[(int) TImode][(int) QImode] = CODE_FOR_extendqiti2;\n+    extendtab[(int) TImode][(int) QImode][0] = CODE_FOR_extendqiti2;\n #endif\n #ifdef HAVE_extendsidi2\n   if (HAVE_extendsidi2)\n-    sign_extend_codes[(int) DImode][(int) SImode] = CODE_FOR_extendsidi2;\n+    extendtab[(int) DImode][(int) SImode][0] = CODE_FOR_extendsidi2;\n #endif\n #ifdef HAVE_extendhidi2\n   if (HAVE_extendhidi2)\n-    sign_extend_codes[(int) DImode][(int) HImode] = CODE_FOR_extendhidi2;\n+    extendtab[(int) DImode][(int) HImode][0] = CODE_FOR_extendhidi2;\n #endif\n #ifdef HAVE_extendqidi2\n   if (HAVE_extendqidi2)\n-    sign_extend_codes[(int) DImode][(int) QImode] = CODE_FOR_extendqidi2;\n+    extendtab[(int) DImode][(int) QImode][0] = CODE_FOR_extendqidi2;\n #endif\n #ifdef HAVE_extendhisi2\n   if (HAVE_extendhisi2)\n-    sign_extend_codes[(int) SImode][(int) HImode] = CODE_FOR_extendhisi2;\n+    extendtab[(int) SImode][(int) HImode][0] = CODE_FOR_extendhisi2;\n #endif\n #ifdef HAVE_extendqisi2\n   if (HAVE_extendqisi2)\n-    sign_extend_codes[(int) SImode][(int) QImode] = CODE_FOR_extendqisi2;\n+    extendtab[(int) SImode][(int) QImode][0] = CODE_FOR_extendqisi2;\n #endif\n #ifdef HAVE_extendqihi2\n   if (HAVE_extendqihi2)\n-    sign_extend_codes[(int) HImode][(int) QImode] = CODE_FOR_extendqihi2;\n+    extendtab[(int) HImode][(int) QImode][0] = CODE_FOR_extendqihi2;\n #endif\n \n #ifdef HAVE_zero_extendditi2\n   if (HAVE_zero_extendsiti2)\n-    zero_extend_codes[(int) TImode][(int) DImode] = CODE_FOR_zero_extendditi2;\n+    extendtab[(int) TImode][(int) DImode][1] = CODE_FOR_zero_extendditi2;\n #endif\n #ifdef HAVE_zero_extendsiti2\n   if (HAVE_zero_extendsiti2)\n-    zero_extend_codes[(int) TImode][(int) SImode] = CODE_FOR_zero_extendsiti2;\n+    extendtab[(int) TImode][(int) SImode][1] = CODE_FOR_zero_extendsiti2;\n #endif\n #ifdef HAVE_zero_extendhiti2\n   if (HAVE_zero_extendhiti2)\n-    zero_extend_codes[(int) TImode][(int) HImode] = CODE_FOR_zero_extendhiti2;\n+    extendtab[(int) TImode][(int) HImode][1] = CODE_FOR_zero_extendhiti2;\n #endif\n #ifdef HAVE_zero_extendqiti2\n   if (HAVE_zero_extendqiti2)\n-    zero_extend_codes[(int) TImode][(int) QImode] = CODE_FOR_zero_extendqiti2;\n+    extendtab[(int) TImode][(int) QImode][1] = CODE_FOR_zero_extendqiti2;\n #endif\n #ifdef HAVE_zero_extendsidi2\n   if (HAVE_zero_extendsidi2)\n-    zero_extend_codes[(int) DImode][(int) SImode] = CODE_FOR_zero_extendsidi2;\n+    extendtab[(int) DImode][(int) SImode][1] = CODE_FOR_zero_extendsidi2;\n #endif\n #ifdef HAVE_zero_extendhidi2\n   if (HAVE_zero_extendhidi2)\n-    zero_extend_codes[(int) DImode][(int) HImode] = CODE_FOR_zero_extendhidi2;\n+    extendtab[(int) DImode][(int) HImode][1] = CODE_FOR_zero_extendhidi2;\n #endif\n #ifdef HAVE_zero_extendqidi2\n   if (HAVE_zero_extendqidi2)\n-    zero_extend_codes[(int) DImode][(int) QImode] = CODE_FOR_zero_extendqidi2;\n+    extendtab[(int) DImode][(int) QImode][1] = CODE_FOR_zero_extendqidi2;\n #endif\n #ifdef HAVE_zero_extendhisi2\n   if (HAVE_zero_extendhisi2)\n-    zero_extend_codes[(int) SImode][(int) HImode] = CODE_FOR_zero_extendhisi2;\n+    extendtab[(int) SImode][(int) HImode][1] = CODE_FOR_zero_extendhisi2;\n #endif\n #ifdef HAVE_zero_extendqisi2\n   if (HAVE_zero_extendqisi2)\n-    zero_extend_codes[(int) SImode][(int) QImode] = CODE_FOR_zero_extendqisi2;\n+    extendtab[(int) SImode][(int) QImode][1] = CODE_FOR_zero_extendqisi2;\n #endif\n #ifdef HAVE_zero_extendqihi2\n   if (HAVE_zero_extendqihi2)\n-    zero_extend_codes[(int) HImode][(int) QImode] = CODE_FOR_zero_extendqihi2;\n+    extendtab[(int) HImode][(int) QImode][1] = CODE_FOR_zero_extendqihi2;\n #endif\n }\n \f\n@@ -2421,7 +2402,7 @@ init_floattab ()\n }\n \f\n /* Generate code to convert FROM to floating point\n-   and store in TO.  FROM must be fixed point.\n+   and store in TO.  FROM must be fixed point and not VOIDmode.\n    UNSIGNEDP nonzero means regard FROM as unsigned.\n    Normally this is done by correcting the final value\n    if it is negative.  */\n@@ -2435,6 +2416,10 @@ expand_float (to, from, unsignedp)\n   register rtx target = to;\n   enum machine_mode fmode, imode;\n \n+  /* Crash now, because we won't be able to decide which mode to use.  */\n+  if (GET_MODE (from) == VOIDmode)\n+    abort ();\n+\n   /* Look for an insn to do the conversion.  Do it in the specified\n      modes if possible; otherwise convert either input, output or both to\n      wider mode.  If the integer mode is wider than the mode of FROM,"}, {"sha": "50983a9e76bea7c32e604d5f4316de76f80d7136", "filename": "gcc/print-tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=34e567536c877b47a1d055aa73420d66d1c4d7ae", "patch": "@@ -1,5 +1,5 @@\n /* Prints out tree in human readable form - GNU C-compiler\n-   Copyright (C) 1990 Free Software Foundation, Inc.\n+   Copyright (C) 1990, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "b74c3d46be17687a0d1620fddf2c3f959b526acf", "filename": "gcc/protoize.c", "status": "modified", "additions": 316, "deletions": 208, "changes": 524, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fprotoize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34e567536c877b47a1d055aa73420d66d1c4d7ae/gcc%2Fprotoize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprotoize.c?ref=34e567536c877b47a1d055aa73420d66d1c4d7ae", "patch": "@@ -2,7 +2,7 @@\n    and Computer Technology Corporation (MCC).  The author's current\n    E-mail address is <rfg@ncd.com>.\n \n-   Copyright (C) 1989, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -34,44 +34,44 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define VOLATILE\n #endif\n \n-/* It is incorrect to include config.h here, because this file is being\n-   compiled for the target, and hence definitions concerning only the host\n-   do not apply.  Instead we include tconfig.h, which is the xm file\n-   *for the target*, which also includes the tm.h file *for the target*.\n-   This way, we get definitions of POSIX, USG and VMS for the target.  */\n+#ifndef __STDC__\n+#define const\n+#endif\n \n-#include \"tconfig.h\"\n+#include \"config.h\"\n \n-/* The documentation says to use TARGET_POSIX, so check for it as well\n-   as POSIX.  */\n-#if defined(TARGET_POSIX) && !defined(POSIX)\n-#define POSIX\n+#ifdef POSIX /* We should be able to define _POSIX_SOURCE unconditionally,\n+\t\tbut some systems respond in buggy ways to it,\n+\t\tincluding Sunos 4.1.1.  Which we don't classify as POSIX.  */\n+/* In case this is a POSIX system with an ANSI C compiler,\n+   ask for definition of all POSIX facilities.  */\n+#define _POSIX_SOURCE\n #endif\n \n+#if 0\n+/* Users are not supposed to use _POSIX_SOURCE to say the\n+   system is a POSIX system.  That is not what _POSIX_SOURCE means! -- rms  */ \n /* If the user asked for POSIX via _POSIX_SOURCE, turn on POSIX code.  */\n #if defined(_POSIX_SOURCE) && !defined(POSIX)\n #define POSIX\n #endif\n-\n-/* On a POSIX system, request definition of all the POSIX facilities.  */\n-#if defined(POSIX) && !defined(_POSIX_SOURCE)\n-#define _POSIX_SOURCE\n-#endif\n+#endif /* 0 */\n \n #include <stdio.h>\n #include <ctype.h>\n #include <errno.h>\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <sys/dir.h>\n+#if ! defined (USG) || defined (SVR4)\n #include <sys/wait.h>\n+#endif\n #include <setjmp.h>\n #include \"gvarargs.h\"\n #include \"getopt.h\"\n \n #ifndef PATH_MAX\t/* <limits.h> defines this on most POSIX systems.  */\n #include <sys/param.h>\n-#define PATH_MAX MAXPATHLEN\n /* Sometimes <sys/param.h> defines these macros.  */\n #undef CHAR_BIT\n #undef CHAR_MAX\n@@ -95,32 +95,46 @@ extern int errno;\n extern char *sys_errlist[];\n extern char *version_string;\n \n-#if defined(POSIX)\n-\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <signal.h>\n-#include <fcntl.h>\n-#include <string.h>\n-\n /* Systems which are compatible only with POSIX 1003.1-1988 (but *not*\n    with POSIX 1003.1-1990), e.g. Ultrix 4.2, might not have\n    const qualifiers in the prototypes in the system include files.\n    Unfortunately, this can lead to GCC issuing lots of warnings for\n    calls to the following functions.  To eliminate these warnings we\n    provide the following #defines.  */\n \n-#if (_POSIX_VERSION < 199009)\n+#define my_access(file,flag)\taccess((char *)file, flag)\n+#define my_stat(file,pkt)\tstat((char *)file, pkt)\n+#define my_execvp(prog,argv)\texecvp((char *)prog, (char **)argv)\n+#define my_link(file1, file2)\tlink((char *)file1, (char *)file2)\n+#define my_unlink(file)\t\tunlink((char *)file)\n+#define my_open(file, mode, flag)\topen((char *)file, mode, flag)\n+#define my_chmod(file, mode)\tchmod((char *)file, mode)\n+\n+#if !(defined (USG) || defined (VMS) || defined (POSIX))\n+#define GUESSPATHLEN (MAXPATHLEN + 1)\n+#else /* (defined (USG) || defined (VMS) || defined (POSIX)) */\n+/* We actually use this as a starting point, not a limit.  */\n+#define GUESSPATHLEN 200\n+#endif /* (defined (USG) || defined (VMS) || defined (POSIX)) */\n \n-#define access(file,flag)\taccess((char *)file, flag)\n-#define stat(file,pkt)\t\tstat((char *)file, pkt)\n-#define execvp(prog,argv)\texecvp((char *)prog, (char **)argv)\n-#define link(file1, file2)\tlink((char *)file1, (char *)file2)\n-#define unlink(file)\t\tunlink((char *)file)\n-#define open(file, mode, flag)\topen((char *)file, mode, flag)\n-#define chmod(file, mode)\tchmod((char *)file, mode)\n+/* Aliases for pointers to void.\n+   These were made to facilitate compilation with other compilers.  */\n \n-#endif /* (_POSIX_VERSION < 199009) */\n+#ifdef __STDC__\n+typedef void * pointer_type;\n+typedef const void * const_pointer_type;\n+#else\n+typedef char * pointer_type;\n+typedef char * const_pointer_type;\n+#endif\n+\n+#if defined(POSIX)\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <signal.h>\n+#include <fcntl.h>\n+#include <string.h>\n \n #else /* !defined(POSIX) */\n \n@@ -137,61 +151,58 @@ extern char *version_string;\n    the few exceptions to the general rule here.  */\n \n #if !(defined (USG) || defined (VMS))\n-extern char *getwd (char *);\n+extern char *getwd ();\n #define getcwd(buf,len) getwd(buf)\n #else /* (defined (USG) || defined (VMS)) */\n-extern char *getcwd (char *, size_t);\n+extern char *getcwd ();\n #endif /* (defined (USG) || defined (VMS)) */\n \n /* Declaring stat or __flsbuf with a prototype\n    causes conflicts with system headers on some systems.  */\n \n #ifndef abort\n-extern VOLATILE void abort (void);\n+extern VOLATILE void abort ();\n #endif\n-extern int kill(int, int);\n-extern int creat (const char *, int);\n-extern int open (const char *, int, ...);\n+extern int kill();\n+extern int creat ();\n #if 0 /* These conflict with stdio.h on some systems.  */\n extern int fprintf (FILE *, const char *, ...);\n extern int printf (const char *, ...);\n #endif /* 0 */\n-extern void exit (int);\n-extern void *malloc (size_t);\n-extern void *realloc (void *, size_t);\n-extern void free (void *);\n-extern int read (int, void *, size_t);\n-extern int write (int, const void *, size_t);\n-extern int close (int);\n-extern int link (const char *, const char *);\n-extern int unlink (const char *);\n-extern int fflush (FILE *);\n-extern int atoi (const char *);\n-extern int access (const char *, int);\n-extern int puts (const char *);\n-extern int fputs (const char *, FILE *);\n-extern int fputc (int, FILE *);\n-extern int execvp (const char *, char *const *);\n-extern int setjmp (jmp_buf);\n-extern void longjmp (jmp_buf, int);\n-\n-extern char *   strcat(char *, const char *);\n-extern int      strcmp(const char *, const char *);\n-extern char *   strcpy(char *, const char *);\n+extern void exit ();\n+extern pointer_type malloc ();\n+extern pointer_type realloc ();\n+extern void free ();\n+extern int read ();\n+extern int write ();\n+extern int close ();\n+extern int fflush ();\n+extern int atoi ();\n+extern int puts ();\n+extern int fputs ();\n+extern int fputc ();\n+#if 0 /* Causes trouble on some systems that define setjmp as a macro.  */\n+extern int setjmp ();\n+extern void longjmp ();\n+#endif\n+\n+extern char *   strcat();\n+extern int      strcmp();\n+extern char *   strcpy();\n #if 0 /* size_t from sys/types.h may fail to match GCC.\n \t If so, we would get a warning from this.\n \t So do without the prototype.  */\n extern size_t   strlen(const char *);\n #endif\n-extern int      strncmp(const char *, const char *, size_t);\n-extern char *   strncpy(char *, const char *, size_t);\n-extern char *   strrchr(const char *, int);\n+extern int      strncmp();\n+extern char *   strncpy();\n+extern char *   strrchr();\n \n #if !(defined (USG) || defined (VMS))\n-extern int vfork (void);\n+extern int vfork ();\n #define fork vfork\n #else\n-extern int fork (void);\n+extern int fork ();\n #endif /* !(defined (USG) || defined (VMS)) */\n \n #endif /* !defined(POSIX) */\n@@ -200,15 +211,13 @@ extern int fork (void);\n \n #define NONCONST\n \n-/* Aliases for pointers to void.\n-   These were made to facilitate compilation with other compilers.  */\n-\n-typedef void * pointer_type;\n-typedef const void * const_pointer_type;\n-\n-/* Define a STRINGIFY macro that's right for ANSI C.  */\n+/* Define a STRINGIFY macro that's right for ANSI or traditional C.  */\n \n+#ifdef __STDC__\n #define STRINGIFY(STRING) #STRING\n+#else\n+#define STRINGIFY(STRING) \"STRING\"\n+#endif\n \n /* POSIX systems will not have definitions for WIFEXITED or WEXITSTATUS.\n    Define them correctly and so that they work for all environments.  */\n@@ -471,22 +480,22 @@ static int errors = 0;\n /* ??? These comments should say what the flag mean as well as the options\n    that set them.  */\n \n-static int version_flag = 0;\t\t/* set by -V option */\n-static int quiet_flag = 0;\t\t/* set by -q option */\n-#if 0\n-static int force_flag = 0;\t\t/* set by -f option */\n-#endif\n-static int nochange_flag = 0;\t\t/* set by -n option */\n-static int nosave_flag = 0;\t\t/* set by -N option */\n-static int keep_flag = 0;\t\t/* set by -k option */\n-static const char ** compile_params = 0;\t/* set by -c option */\n+static int version_flag = 0;\t\t/* Print our version number.  */\n+static int quiet_flag = 0;\t\t/* Don't print messages normally.  */\n+static int nochange_flag = 0;\t\t/* Don't convert, just say what files\n+\t\t\t\t\t   we would have converted.  */\n+static int nosave_flag = 0;\t\t/* Don't save the old version.  */\n+static int keep_flag = 0;\t\t/* Don't delete the .X files.  */\n+static const char ** compile_params = 0;\t/* Option string for gcc.  */\n #ifdef UNPROTOIZE\n-static const char *indent_string = \"     \";\t/* set by -i option */\n+static const char *indent_string = \"     \";\t/* Indentation for newly\n+\t\t\t\t\t\t   inserted parm decls.  */\n #else /* !defined(UNPROTOIZE) */\n-static int local_flag = 0;\t\t/* set by -l option */\n+static int local_flag = 0;\t\t/* Insert new local decls (when?).  */\n static int global_flag = 0;\t\t/* set by -g option */\n-static int cplusplus_flag = 0;\t\t/* set by -C option */\n-static const char* nondefault_syscalls_dir = 0; /* set by -B option */\n+static int cplusplus_flag = 0;\t\t/* Rename converted files to *.C.  */\n+static const char* nondefault_syscalls_dir = 0; /* Dir to look for\n+\t\t\t\t\t\t   SYSCALLS.c.X in.  */\n #endif /* !defined(UNPROTOIZE) */\n \n /* An index into the compile_params array where we should insert the filename\n@@ -602,16 +611,18 @@ static char * saved_repl_write_ptr;\n \n /* Forward declaration.  */\n \n-static const char *shortpath (const char *cwd, const char *filename);\n+static const char *shortpath ();\n \f\n /* Allocate some space, but check that the allocation was successful.  */\n \n static pointer_type\n-xmalloc (size_t byte_count)\n+xmalloc (byte_count)\n+     size_t byte_count;\n {\n   pointer_type rv;\n \n-  if ((rv = malloc (byte_count)) == NULL)\n+  rv = malloc (byte_count);\n+  if (rv == NULL)\n     {\n       fprintf (stderr, \"\\n%s: fatal error: can't allocate %u more bytes of memory\\n\",\n \t       pname, byte_count);\n@@ -625,11 +636,14 @@ xmalloc (size_t byte_count)\n /* Reallocate some space, but check that the reallocation was successful.  */\n \n static pointer_type\n-xrealloc (pointer_type old_space, size_t byte_count)\n+xrealloc (old_space, byte_count)\n+     pointer_type old_space;\n+     size_t byte_count;\n {\n   pointer_type rv;\n \n-  if ((rv = realloc (old_space, byte_count)) == NULL)\n+  rv = realloc (old_space, byte_count);\n+  if (rv == NULL)\n     {\n       fprintf (stderr, \"\\n%s: fatal error: can't allocate %u more bytes of memory\\n\",\n \t       pname, byte_count);\n@@ -645,7 +659,8 @@ xrealloc (pointer_type old_space, size_t byte_count)\n    is non-null.  */\n \n static void\n-xfree (const_pointer_type p)\n+xfree (p)\n+     const_pointer_type p;\n {\n   if (p)\n     free ((NONCONST pointer_type) p);\n@@ -654,7 +669,9 @@ xfree (const_pointer_type p)\n /* Make a copy of a string INPUT with size SIZE.  */\n \n static char *\n-savestring (const char *input, int size)\n+savestring (input, size)\n+     const char *input;\n+     int size;\n {\n   char *output = (char *) xmalloc (size + 1);\n   strcpy (output, input);\n@@ -674,7 +691,8 @@ fancy_abort ()\n /* Make a duplicate of a given string in a newly allocated area.  */\n \n static char *\n-dupstr (const char *s)\n+dupstr (s)\n+     const char *s;\n {\n   return strcpy ((char *) xmalloc (strlen (s) + 1), s);\n }\n@@ -683,7 +701,9 @@ dupstr (const char *s)\n    allocated area.  */\n \n static char *\n-dupnstr (const char *s, size_t n)\n+dupnstr (s, n)\n+     const char *s;\n+     size_t n;\n {\n   char *ret_val = strncpy ((char *) xmalloc (n + 1), s, n);\n \n@@ -695,7 +715,9 @@ dupnstr (const char *s, size_t n)\n    does not occur within s1.  Assume neither s1 nor s2 are null pointers.  */\n \n static const char *\n-substr (const char *s1, const char *const s2)\n+substr (s1, s2)\n+     const char *s1;\n+     const char *const s2;\n {\n   for (; *s1 ; s1++)\n     {\n@@ -716,7 +738,7 @@ substr (const char *s1, const char *const s2)\n /* Get setup to recover in case the edit we are about to do goes awry.  */\n \n void\n-save_pointers (void)\n+save_pointers ()\n {\n   saved_clean_read_ptr = clean_read_ptr;\n   saved_repl_write_ptr = repl_write_ptr;\n@@ -726,16 +748,17 @@ save_pointers (void)\n    too confusing in the source code we are trying to edit.  */\n \n void\n-restore_pointers (void)\n+restore_pointers ()\n {\n   clean_read_ptr = saved_clean_read_ptr;\n   repl_write_ptr = saved_repl_write_ptr;\n }\n \n /* Return true if the given character is a legal identifier character.  */\n \n-inline static int\n-is_id_char (char ch)\n+static int\n+is_id_char (ch)\n+     char ch;\n {\n   return (isalnum (ch) || (ch == '_') || (ch == '$'));\n }\n@@ -744,7 +767,7 @@ is_id_char (char ch)\n    exit with non-zero status.  */\n \n static void\n-usage (void)\n+usage ()\n {\n #ifdef UNPROTOIZE\n   fprintf (stderr, \"%s: usage '%s [ -VqfnkN ] [ -i <istring> ] [ filename ... ]'\\n\",\n@@ -761,7 +784,8 @@ usage (void)\n    include directories.  */\n \n static int\n-in_system_include_dir (const char *path)\n+in_system_include_dir (path)\n+     const char *path;\n {\n   struct default_include *p;\n \n@@ -785,7 +809,7 @@ file_could_be_converted (const char *path)\n {\n   char *const dir_name = (char *) alloca (strlen (path) + 1);\n \n-  if (access (path, R_OK))\n+  if (my_access (path, R_OK))\n     return 0;\n \n   {\n@@ -799,7 +823,7 @@ file_could_be_converted (const char *path)\n       abort ();  /* Should have been an absolutized filename.  */\n   }\n \n-  if (access (path, W_OK))\n+  if (my_access (path, W_OK))\n     return 0;\n \n   return 1;\n@@ -833,23 +857,23 @@ file_normally_convertable (const char *path)\n       abort ();  /* Should have been an absolutized filename.  */\n   }\n \n-  if (access (path, R_OK))\n+  if (my_access (path, R_OK))\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no read access for file `%s'\\n\",\n \t\t pname, shortpath (NULL, path));\n       return 0;\n     }\n \n-  if (access (path, W_OK))\n+  if (my_access (path, W_OK))\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no write access for file `%s'\\n\",\n \t\t pname, shortpath (NULL, path));\n       return 0;\n     }\n \n-  if (access (dir_name, W_OK))\n+  if (my_access (dir_name, W_OK))\n     {\n       if (!quiet_flag)\n         fprintf (stderr, \"%s: warning: no write access for dir containing `%s'\\n\",\n@@ -867,7 +891,8 @@ file_normally_convertable (const char *path)\n    file.  Return false otherwise.  */\n \n static int\n-is_syscalls_file (const file_info *fi_p)\n+is_syscalls_file (fi_p)\n+     const file_info *fi_p;\n {\n   return (substr (fi_p->hash_entry->symbol, syscalls_filename) != NULL);\n }\n@@ -884,7 +909,8 @@ is_syscalls_file (const file_info *fi_p)\n    by connect_defs_and_decs().  */\n \n static int\n-needs_to_be_converted (const file_info *file_p)\n+needs_to_be_converted (file_p)\n+     const file_info *file_p;\n {\n   const def_dec_info *ddp;\n \n@@ -922,7 +948,8 @@ needs_to_be_converted (const file_info *file_p)\n    that should be converted.  */\n \n static int\n-directory_specified_p (const char *name)\n+directory_specified_p (name)\n+     const char *name;\n {\n   struct string_list *p;\n \n@@ -937,7 +964,8 @@ directory_specified_p (const char *name)\n /* Return 1 if the file named NAME should be excluded from conversion.  */\n \n static int\n-file_excluded_p (const char *name)\n+file_excluded_p (name)\n+     const char *name;\n {\n   struct string_list *p;\n   int len = strlen (name);\n@@ -954,9 +982,13 @@ file_excluded_p (const char *name)\n    STRING is the new element value, and REST holds the remaining elements.  */\n \n static struct string_list *\n-string_list_cons (char *string, struct string_list *rest)      \n+string_list_cons (string, rest)\n+     char *string;\n+     struct string_list *rest;      \n {\n-  struct string_list *temp = xmalloc (sizeof (struct string_list));\n+  struct string_list *temp\n+    = (struct string_list *) xmalloc (sizeof (struct string_list));\n+\n   temp->next = rest;\n   temp->name = string;\n   return temp;\n@@ -972,7 +1004,9 @@ string_list_cons (char *string, struct string_list *rest)\n    argument.  */\n \n static void\n-visit_each_hash_node (const hash_table_entry *hash_tab_p, void (*func) (const hash_table_entry *))\n+visit_each_hash_node (hash_tab_p, func)\n+     const hash_table_entry *hash_tab_p;\n+     void (*func)();\n {\n   const hash_table_entry *primary;\n \n@@ -993,7 +1027,9 @@ visit_each_hash_node (const hash_table_entry *hash_tab_p, void (*func) (const ha\n    called.  */\n \n static hash_table_entry *\n-add_symbol (hash_table_entry *p, const char *s)\n+add_symbol (p, s)\n+     hash_table_entry *p;\n+     const char *s;\n {\n   p->hash_next = NULL;\n   p->symbol = dupstr (s);\n@@ -1008,7 +1044,9 @@ add_symbol (hash_table_entry *p, const char *s)\n    hash table entry for the given name.  */\n \n static hash_table_entry *\n-lookup (hash_table_entry *hash_tab_p, const char *search_symbol)\n+lookup (hash_tab_p, search_symbol)\n+     hash_table_entry *hash_tab_p;\n+     const char *search_symbol;\n {\n   int hash_value = 0;\n   const char *search_symbol_char_p = search_symbol;\n@@ -1038,8 +1076,9 @@ lookup (hash_table_entry *hash_tab_p, const char *search_symbol)\n    Also, since we are not using this record anymore, free up all of the\n    stuff it pointed to.  */\n \n-inline static void\n-free_def_dec (def_dec_info *p)\n+static void\n+free_def_dec (p)\n+     def_dec_info *p;\n {\n   xfree (p->ansi_decl);\n \n@@ -1065,7 +1104,8 @@ free_def_dec (def_dec_info *p)\n    return a pointer to the unexpanded copy.  Otherwise return NULL.  */\n \n static char *\n-unexpand_if_needed (const char *aux_info_line)\n+unexpand_if_needed (aux_info_line)\n+     const char *aux_info_line;\n {\n   static char *line_buf = 0;\n   static int line_buf_size = 0;\n@@ -1147,7 +1187,9 @@ continue_outer: ;\n    NULL.  */\n \n static char *\n-abspath (const char *cwd, const char *rel_filename)\n+abspath (cwd, rel_filename)\n+     const char *cwd;\n+     const char *rel_filename;\n {\n   /* Setup the current working directory as needed.  */\n   const char *cwd2 = (cwd) ? cwd : cwd_buffer;\n@@ -1250,7 +1292,9 @@ abspath (const char *cwd, const char *rel_filename)\n    subpart of the original filename is actually a symbolic link.  */\n \n static const char *\n-shortpath (const char *cwd, const char *filename)\n+shortpath (cwd, filename)\n+     const char *cwd;\n+     const char *filename;\n {\n   char *rel_buffer;\n   char *rel_buf_p;\n@@ -1302,12 +1346,10 @@ shortpath (const char *cwd, const char *filename)\n       --rel_buf_p;\n       if (*(rel_buf_p-1) == '/')\n         *--rel_buf_p = '\\0';\n-      if (strlen (rel_buffer) > strlen (filename))\n+      if (strlen (rel_buffer) > (unsigned) strlen (filename))\n \tstrcpy (rel_buffer, filename);\n       return rel_buffer;\n     }\n-  /* NOTREACHED */\n-  return 0;\t/* Prevent warnings for old versions of GCC.  */\n }\n \f\n /* Lookup the given filename in the hash table for filenames.  If it is a\n@@ -1316,7 +1358,9 @@ shortpath (const char *cwd, const char *filename)\n    that record with some reasonable values.  */\n \n static file_info *\n-find_file (char *filename, int do_not_stat)\n+find_file (filename, do_not_stat)\n+     char *filename;\n+     int do_not_stat;\n /* FILENAME was const, but that causes a warning on AIX when calling stat.\n    That is probably a bug in AIX, but might as well avoid the warning.  */\n {\n@@ -1337,7 +1381,7 @@ find_file (char *filename, int do_not_stat)\n         stat_buf.st_mtime = (time_t) 0;\n       else\n         {\n-          if (stat (filename, &stat_buf) == -1)\n+          if (my_stat (filename, &stat_buf) == -1)\n             {\n               fprintf (stderr, \"%s: error: can't get status of `%s': %s\\n\",\n \t\t       pname, shortpath (NULL, filename), sys_errlist[errno]);\n@@ -1357,7 +1401,7 @@ find_file (char *filename, int do_not_stat)\n    messed up.  */\n \n static void\n-aux_info_corrupted (void)\n+aux_info_corrupted ()\n {\n   fprintf (stderr, \"\\n%s: fatal error: aux info file corrupted at line %d\\n\",\n \t   pname, current_aux_info_lineno);\n@@ -1367,8 +1411,9 @@ aux_info_corrupted (void)\n /* ??? This comment is vague.  Say what the condition is for.  */\n /* Check to see that a condition is true.  This is kind of like an assert().  */\n \n-inline static void\n-check_aux_info (int cond)\n+static void\n+check_aux_info (cond)\n+     int cond;\n {\n   if (! cond)\n     aux_info_corrupted ();\n@@ -1379,7 +1424,8 @@ check_aux_info (int cond)\n    return a pointer to it.  */\n \n static const char *\n-find_corresponding_lparen (const char *p)\n+find_corresponding_lparen (p)\n+     const char *p;\n {\n   const char *q;\n   int paren_depth;\n@@ -1405,7 +1451,9 @@ find_corresponding_lparen (const char *p)\n    file was created.  If so, return non-zero, else return zero.  */\n \n static int\n-referenced_file_is_newer (const char *l, time_t aux_info_mtime)\n+referenced_file_is_newer (l, aux_info_mtime)\n+     const char *l;\n+     time_t aux_info_mtime;\n {\n   const char *p;\n   file_info *fi_p;\n@@ -1451,7 +1499,9 @@ referenced_file_is_newer (const char *l, time_t aux_info_mtime)\n    pertaining to this particular function name.  */\n \n static void\n-save_def_or_dec (const char *l, int is_syscalls)\n+save_def_or_dec (l, is_syscalls)\n+     const char *l;\n+     int is_syscalls;\n {\n   const char *p;\n   const char *semicolon_p;\n@@ -1638,7 +1688,7 @@ save_def_or_dec (const char *l, int is_syscalls)\n     /* p now points to the leftmost character of the function name.  */\n \n     {\n-      char fn_string[past_fn - p + 1];\n+      char *fn_string = (char *) alloca (past_fn - p + 1);\n \n       strncpy (fn_string, p, (size_t) (past_fn - p));\n       fn_string[past_fn-p] = '\\0';\n@@ -1827,9 +1877,10 @@ save_def_or_dec (const char *l, int is_syscalls)\n    adding a final group of options like '-fgen-aux-info -S  -o /dev/null'.  */\n \n static void\n-munge_compile_params (const char *params_list)\n+munge_compile_params (params_list)\n+     const char *params_list;\n {\n-  const char *temp_params[strlen (params_list) + 10];\n+  char **temp_params = (char **) alloca (strlen (params_list) + 10);\n   int param_count = 0;\n   const char *param;\n \n@@ -1881,15 +1932,17 @@ munge_compile_params (const char *params_list)\n \n   /* Make a copy of the compile_params in heap space.  */\n \n-  compile_params = xmalloc (sizeof (char *) * (param_count+1));\n+  compile_params\n+    = (char **) xmalloc (sizeof (char *) * (param_count+1));\n   memcpy (compile_params, temp_params, sizeof (char *) * param_count);\n }\n \n /* Do a recompilation for the express purpose of generating a new aux_info\n    file to go with a specific base source file.  */\n \n static int\n-gen_aux_info_file (const char *base_filename)\n+gen_aux_info_file (base_filename)\n+     const char *base_filename;\n {\n   int child_pid;\n \n@@ -1948,7 +2001,7 @@ gen_aux_info_file (const char *base_filename)\n     }\n   else\n     {\n-      if (execvp (compile_params[0], (char *const *) compile_params))\n+      if (my_execvp (compile_params[0], (char *const *) compile_params))\n         {\n           fprintf (stderr, \"%s: error: execvp returned: %s\\n\",\n \t\t   pname, sys_errlist[errno]);\n@@ -1962,7 +2015,10 @@ gen_aux_info_file (const char *base_filename)\n    Save all of the important stuff for later.  */\n \n static void\n-process_aux_info_file (const char *base_source_filename, int keep_it, int is_syscalls)\n+process_aux_info_file (base_source_filename, keep_it, is_syscalls)\n+     const char *base_source_filename;\n+     int keep_it;\n+     int is_syscalls;\n {\n   char *const aux_info_filename\n     = (char *) alloca (strlen (base_source_filename)\n@@ -1987,7 +2043,7 @@ start_over: ;\n     int retries = 0;\n \n retry:\n-    if (access (aux_info_filename, R_OK) == -1)\n+    if (my_access (aux_info_filename, R_OK) == -1)\n       {\n         if (errno == ENOENT && retries == 0)\n           {\n@@ -2018,7 +2074,7 @@ start_over: ;\n \n     /* Get some status information about this aux_info file.  */\n   \n-    if (stat (aux_info_filename, &stat_buf) == -1)\n+    if (my_stat (aux_info_filename, &stat_buf) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't get status of aux info file `%s': %s\\n\",\n \t\t pname, shortpath (NULL, aux_info_filename),\n@@ -2045,7 +2101,7 @@ start_over: ;\n \n     /* Open the aux_info file.  */\n   \n-    if ((aux_info_file = open (aux_info_filename, O_RDONLY, 0444 )) == -1)\n+    if ((aux_info_file = my_open (aux_info_filename, O_RDONLY, 0444 )) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't open aux info file `%s' for reading: %s\\n\",\n \t\t pname, shortpath (NULL, aux_info_filename),\n@@ -2088,7 +2144,7 @@ start_over: ;\n      fails for some reason, don't even worry about it.  */\n \n   if (!keep_it)\n-    if (unlink (aux_info_filename) == -1)\n+    if (my_unlink (aux_info_filename) == -1)\n       fprintf (stderr, \"%s: error: can't delete aux info file `%s': %s\\n\",\n \t       pname, shortpath (NULL, aux_info_filename),\n \t       sys_errlist[errno]);\n@@ -2136,7 +2192,7 @@ start_over: ;\n             if (referenced_file_is_newer (aux_info_p, aux_info_mtime))\n               {\n                 free (aux_info_base);\n-                if (unlink (aux_info_filename) == -1)\n+                if (my_unlink (aux_info_filename) == -1)\n                   {\n                     fprintf (stderr, \"%s: error: can't delete file `%s': %s\\n\",\n \t\t\t     pname, shortpath (NULL, aux_info_filename),\n@@ -2191,7 +2247,8 @@ start_over: ;\n    function implements the -C option.  */\n \n static void\n-rename_c_file (const hash_table_entry *hp)\n+rename_c_file (hp)\n+     const hash_table_entry *hp;\n {\n   const char *filename = hp->symbol;\n   int last_char_index = strlen (filename) - 1;\n@@ -2209,7 +2266,7 @@ rename_c_file (const hash_table_entry *hp)\n   strcpy (new_filename, filename);\n   new_filename[last_char_index] = 'C';\n \n-  if (link (filename, new_filename) == -1)\n+  if (my_link (filename, new_filename) == -1)\n     {\n       fprintf (stderr, \"%s: warning: can't link file `%s' to `%s': %s\\n\",\n \t       pname, shortpath (NULL, filename),\n@@ -2218,7 +2275,7 @@ rename_c_file (const hash_table_entry *hp)\n       return;\n     }\n \n-  if (unlink (filename) == -1)\n+  if (my_unlink (filename) == -1)\n     {\n       fprintf (stderr, \"%s: warning: can't delete file `%s': %s\\n\",\n \t       pname, shortpath (NULL, filename), sys_errlist[errno]);\n@@ -2238,7 +2295,8 @@ rename_c_file (const hash_table_entry *hp)\n    order here.  */\n \n static void\n-reverse_def_dec_list (const hash_table_entry *hp)\n+reverse_def_dec_list (hp)\n+     const hash_table_entry *hp;\n {\n   file_info *file_p = hp->fip;\n   const def_dec_info *prev = NULL;\n@@ -2279,7 +2337,9 @@ reverse_def_dec_list (const hash_table_entry *hp)\n    contains all of the correct prototypes for system functions.  */\n \n static const def_dec_info *\n-find_extern_def (const def_dec_info *head, const def_dec_info *user)\n+find_extern_def (head, user)\n+     const def_dec_info *head;\n+     const def_dec_info *user;\n {\n   const def_dec_info *dd_p;\n   const def_dec_info *extern_def_p = NULL;\n@@ -2408,13 +2468,13 @@ find_extern_def (const def_dec_info *head, const def_dec_info *user)\n               {\n \t\t/* Why copy this string into `needed' at all?\n \t\t   Why not just use user->ansi_decl without copying?  */\n-                char needed[strlen (user->ansi_decl) + 1];\n+\t\tchar *needed = (char *) alloca (strlen (user->ansi_decl) + 1);\n                 char *p;\n \n                 strcpy (needed, user->ansi_decl);\n                 p = (NONCONST char *) substr (needed, user->hash_entry->symbol)\n                     + strlen (user->hash_entry->symbol) + 2;\n-                strcpy (p, \"???);\");\n+                strcpy (p, \"??\\?);\");\n \n                 fprintf (stderr, \"%s: %d: `%s' used but missing from SYSCALLS\\n\",\n \t\t\t shortpath (NULL, file), user->line,\n@@ -2434,7 +2494,8 @@ find_extern_def (const def_dec_info *head, const def_dec_info *user)\n    from the def_dec_info record pointer which is passed in. */\n \n static const def_dec_info *\n-find_static_definition (const def_dec_info *user)\n+find_static_definition (user)\n+     const def_dec_info *user;\n {\n   const def_dec_info *head = user->hash_entry->ddip;\n   const def_dec_info *dd_p;\n@@ -2483,7 +2544,8 @@ find_static_definition (const def_dec_info *user)\n    more details.  */\n \n static void\n-connect_defs_and_decs (const hash_table_entry *hp)\n+connect_defs_and_decs (hp)\n+     const hash_table_entry *hp;\n {\n   const def_dec_info *dd_p;\n   const def_dec_info *extern_def_p = NULL;\n@@ -2607,7 +2669,8 @@ connect_defs_and_decs (const hash_table_entry *hp)\n    original source line number that the given pointer points into.  */\n \n static int\n-identify_lineno (const char *clean_p)\n+identify_lineno (clean_p)\n+     const char *clean_p;\n {\n   int line_num = 1;\n   const char *scan_p;\n@@ -2621,7 +2684,8 @@ identify_lineno (const char *clean_p)\n /* Issue an error message and give up on doing this particular edit.  */\n \n static void\n-declare_source_confusing (const char *clean_p)\n+declare_source_confusing (clean_p)\n+     const char *clean_p;\n {\n   if (!quiet_flag)\n     {\n@@ -2640,8 +2704,10 @@ declare_source_confusing (const char *clean_p)\n    code is in fact true.  If not, issue an error message and give up on\n    converting this particular source file.  */\n \n-inline static void\n-check_source (int cond, const char *clean_p)\n+static void\n+check_source (cond, clean_p)\n+     int cond;\n+     const char *clean_p;\n {\n   if (!cond)\n     declare_source_confusing (clean_p);\n@@ -2663,7 +2729,8 @@ check_source (int cond, const char *clean_p)\n    of the in-core cleaned buffer again.  */\n \n static const char *\n-seek_to_line (int n)\n+seek_to_line (n)\n+     int n;\n {\n   if (n < last_known_line_number)\n     abort ();\n@@ -2682,7 +2749,8 @@ seek_to_line (int n)\n    to the next non-whitepace character which follows it.  */\n \n static const char *\n-forward_to_next_token_char (const char *ptr)\n+forward_to_next_token_char (ptr)\n+     const char *ptr;\n {\n   for (++ptr; isspace (*ptr); check_source (++ptr < clean_text_limit, 0))\n     continue;\n@@ -2694,7 +2762,9 @@ forward_to_next_token_char (const char *ptr)\n    buffer ultimately go through here.  */\n \n static void\n-output_bytes (const char *str, size_t len)\n+output_bytes (str, len)\n+     const char *str;\n+     size_t len;\n {\n   if ((repl_write_ptr + 1) + len >= repl_text_limit)\n     {\n@@ -2713,7 +2783,8 @@ output_bytes (const char *str, size_t len)\n    the current output buffer.  */\n \n static void\n-output_string (const char *str)\n+output_string (str)\n+     const char *str;\n {\n   output_bytes (str, strlen (str));\n }\n@@ -2738,7 +2809,8 @@ output_string (const char *str)\n    byte pointed to by the argument pointer `p'.  */\n \n static void\n-output_up_to (const char *p)\n+output_up_to (p)\n+     const char *p;\n {\n   size_t copy_length = (size_t) (p - clean_read_ptr);\n   const char *copy_start = orig_text_base+(clean_read_ptr-clean_text_base)+1;\n@@ -2757,7 +2829,8 @@ output_up_to (const char *p)\n    otherwise.  */\n \n static int\n-other_variable_style_function (const char *ansi_header)\n+other_variable_style_function (ansi_header)\n+     const char *ansi_header;\n {\n #ifdef UNPROTOIZE\n \n@@ -2795,8 +2868,9 @@ other_variable_style_function (const char *ansi_header)\n    below.  */\n \n static void\n-edit_fn_declaration (const def_dec_info *def_dec_p,\n-\t\t     const char *volatile clean_text_p)\n+edit_fn_declaration (def_dec_p, clean_text_p)\n+     const def_dec_info *def_dec_p;\n+     const char *VOLATILE clean_text_p;\n {\n   const char *start_formals;\n   const char *end_formals;\n@@ -3010,7 +3084,10 @@ edit_fn_declaration (const def_dec_info *def_dec_p,\n    function doesn't match the one expected).  */\n \n static int\n-edit_formals_lists (const char *end_formals, unsigned f_list_count, const def_dec_info *def_dec_p)\n+edit_formals_lists (end_formals, f_list_count, def_dec_p)\n+     const char *end_formals;\n+     unsigned int f_list_count;\n+     const def_dec_info *def_dec_p;\n {\n   const char *start_formals;\n   int depth;\n@@ -3117,7 +3194,8 @@ edit_formals_lists (const char *end_formals, unsigned f_list_count, const def_de\n */\n \n static const char *\n-find_rightmost_formals_list (const char *clean_text_p)\n+find_rightmost_formals_list (clean_text_p)\n+     const char *clean_text_p;\n {\n   const char *end_formals;\n \n@@ -3145,10 +3223,41 @@ find_rightmost_formals_list (const char *clean_text_p)\n     continue;\n   end_formals--;\n \n+#ifdef UNPROTOIZE\n+\n   /* Now scan backwards while looking for the right end of the rightmost\n      formals list associated with this function definition.  */\n \n-  for (;;)\n+  {\n+    char ch;\n+    const char *l_brace_p;\n+\n+    /* Look leftward and try to find a right-paren.  */\n+\n+    while (*end_formals != ')')\n+      {\n+\tif (isspace (*end_formals))\n+\t  while (isspace (*end_formals))\n+\t    check_source (--end_formals > clean_read_ptr, 0);\n+\telse\n+\t  check_source (--end_formals > clean_read_ptr, 0);\n+      }\n+\n+    ch = *(l_brace_p = forward_to_next_token_char (end_formals));\n+    /* Since we are unprotoizing an ANSI-style (prototyped) function\n+       definition, there had better not be anything (except whitespace)\n+       between the end of the ANSI formals list and the beginning of the\n+       function body (i.e. the '{').  */\n+\n+    check_source (ch == '{', l_brace_p);\n+  }\n+\n+#else /* !defined(UNPROTOIZE) */\n+\n+  /* Now scan backwards while looking for the right end of the rightmost\n+     formals list associated with this function definition.  */\n+\n+  while (1)\n     {\n       char ch;\n       const char *l_brace_p;\n@@ -3166,18 +3275,6 @@ find_rightmost_formals_list (const char *clean_text_p)\n \n       ch = *(l_brace_p = forward_to_next_token_char (end_formals));\n \n-#ifdef UNPROTOIZE\n-\n-      /* Since we are unprotoizing an ANSI-style (prototyped) function\n-         definition, there had better not be anything (except whitespace)\n-         between the end of the ANSI formals list and the beginning of the\n-         function body (i.e. the '{').  */\n-\n-      check_source (ch == '{', l_brace_p);\n-      break;\n-\n-#else /* !defined(UNPROTOIZE) */\n-\n       /* Since it is possible that we found a right paren before the starting\n          '{' of the body which IS NOT the one at the end of the real K&R\n          formals list (say for instance, we found one embedded inside one of\n@@ -3196,11 +3293,10 @@ find_rightmost_formals_list (const char *clean_text_p)\n          looking.  */\n \n       check_source (--end_formals > clean_read_ptr, 0);\n+    }\n \n #endif /* !defined(UNPROTOIZE) */\n \n-    }\n-\n   return end_formals;\n }\n \n@@ -3216,7 +3312,9 @@ find_rightmost_formals_list (const char *clean_text_p)\n    parameter type checking.  */\n \n static void\n-add_local_decl (const def_dec_info *def_dec_p, const char *clean_text_p)\n+add_local_decl (def_dec_p, clean_text_p)\n+     const def_dec_info *def_dec_p;\n+     const char *clean_text_p;\n {\n   const char *start_of_block;\n   const char *function_to_edit = def_dec_p->hash_entry->symbol;\n@@ -3322,7 +3420,9 @@ add_local_decl (const def_dec_info *def_dec_p, const char *clean_text_p)\n    and then insert the new explicit declaration at that point in the file.  */\n \n static void\n-add_global_decls (const file_info *file_p, const char *clean_text_p)\n+add_global_decls (file_p, clean_text_p)\n+     const file_info *file_p;\n+     const char *clean_text_p;\n {\n   const def_dec_info *dd_p;\n   const char *scan_p;\n@@ -3411,7 +3511,9 @@ add_global_decls (const file_info *file_p, const char *clean_text_p)\n    separate routine above.  */\n \n static void\n-edit_fn_definition (const def_dec_info *def_dec_p, const char *clean_text_p)\n+edit_fn_definition (def_dec_p, clean_text_p)\n+     const def_dec_info *def_dec_p;\n+     const char *clean_text_p;\n {\n   const char *end_formals;\n   const char *function_to_edit = def_dec_p->hash_entry->symbol;\n@@ -3553,7 +3655,9 @@ edit_fn_definition (const def_dec_info *def_dec_p, const char *clean_text_p)\n    into whitespace.  Also, whiteout string and character literals.  */\n \n static void\n-do_cleaning (char *new_clean_text_base, char *new_clean_text_limit)\n+do_cleaning (new_clean_text_base, new_clean_text_limit)\n+     char *new_clean_text_base;\n+     char *new_clean_text_limit;\n {\n   char *scan_p;\n   int non_whitespace_since_newline = 0;\n@@ -3653,7 +3757,8 @@ do_cleaning (char *new_clean_text_base, char *new_clean_text_limit)\n    and return a pointer to it.  */\n \n static const char *\n-careful_find_l_paren (const char *p)\n+careful_find_l_paren (p)\n+     const char *p;\n {\n   const char *q;\n   int paren_depth;\n@@ -3691,7 +3796,8 @@ careful_find_l_paren (const char *p)\n    I will probably try to do this in a later version though.  */\n \n static void\n-scan_for_missed_items (const file_info *file_p)\n+scan_for_missed_items (file_p)\n+     const file_info *file_p;\n {\n   static const char *scan_p;\n   const char *limit = clean_text_limit - 3;\n@@ -3747,7 +3853,7 @@ scan_for_missed_items (const file_info *file_p)\n                     goto not_missed;\n \n \t\t  {\n-\t\t    char func_name[id_length + 1];\n+\t\t    char *func_name = (char *) alloca (id_length + 1);\n \t\t    static const char * const stmt_keywords[]\n \t\t      = { \"if\", \"while\", \"for\", \"switch\", \"return\", 0 };\n \t\t    const char * const *stmt_keyword;\n@@ -3805,7 +3911,8 @@ scan_for_missed_items (const file_info *file_p)\n    preprocessor directives make the editing a whole lot easier.  */\n    \n static void\n-edit_file (const hash_table_entry *hp)\n+edit_file (hp)\n+     const hash_table_entry *hp;\n {\n   struct stat stat_buf;\n   const file_info *file_p = hp->fip;\n@@ -3848,18 +3955,17 @@ edit_file (const hash_table_entry *hp)\n   /* Let the user know what we are up to.  */\n \n   if (nochange_flag)\n-      puts (shortpath (NULL, convert_filename));\n+    fprintf (stderr, \"%s: would convert file `%s'\\n\",\n+\t     pname, shortpath (NULL, convert_filename));\n   else\n-    {\n-      fprintf (stderr, \"%s: converting file `%s'\\n\",\n-\t       pname, shortpath (NULL, convert_filename));\n-      fflush (stderr);\n-    }\n+    fprintf (stderr, \"%s: converting file `%s'\\n\",\n+\t     pname, shortpath (NULL, convert_filename));\n+  fflush (stderr);\n \n   /* Find out the size (in bytes) of the original file.  */\n \n   /* The cast avoids an erroneous warning on AIX.  */\n-  if (stat ((char *)convert_filename, &stat_buf) == -1)\n+  if (my_stat ((char *)convert_filename, &stat_buf) == -1)\n     {\n       fprintf (stderr, \"%s: error: can't get status for file `%s': %s\\n\",\n \t       pname, shortpath (NULL, convert_filename), sys_errlist[errno]);\n@@ -3893,7 +3999,7 @@ edit_file (const hash_table_entry *hp)\n \n     /* Open the file to be converted in READ ONLY mode.  */\n \n-    if ((input_file = open (convert_filename, O_RDONLY, 0444)) == -1)\n+    if ((input_file = my_open (convert_filename, O_RDONLY, 0444)) == -1)\n       {\n         fprintf (stderr, \"%s: error: can't open file `%s' for reading: %s\\n\",\n \t\t pname, shortpath (NULL, convert_filename),\n@@ -4038,7 +4144,7 @@ edit_file (const hash_table_entry *hp)\n   \n       strcpy (new_filename, convert_filename);\n       strcat (new_filename, save_suffix);\n-      if (link (convert_filename, new_filename) == -1)\n+      if (my_link (convert_filename, new_filename) == -1)\n         {\n           if (errno == EEXIST)\n             {\n@@ -4060,7 +4166,7 @@ edit_file (const hash_table_entry *hp)\n         }\n     }\n \n-  if (unlink (convert_filename) == -1)\n+  if (my_unlink (convert_filename) == -1)\n     {\n       fprintf (stderr, \"%s: error: can't delete file `%s': %s\\n\",\n \t       pname, shortpath (NULL, convert_filename), sys_errlist[errno]);\n@@ -4103,7 +4209,7 @@ edit_file (const hash_table_entry *hp)\n   /* Change the mode of the output file to match the original file.  */\n \n   /* The cast avoids an erroneous warning on AIX.  */\n-  if (chmod ((char *)convert_filename, stat_buf.st_mode) == -1)\n+  if (my_chmod ((char *)convert_filename, stat_buf.st_mode) == -1)\n     fprintf (stderr, \"%s: error: can't change mode of file `%s': %s\\n\",\n \t     pname, shortpath (NULL, convert_filename), sys_errlist[errno]);\n \n@@ -4118,7 +4224,7 @@ edit_file (const hash_table_entry *hp)\n    in the command line.  */\n \n static void\n-do_processing (void)\n+do_processing ()\n {\n   const char * const *base_pp;\n   const char * const * const end_pps\n@@ -4145,18 +4251,18 @@ do_processing (void)\n     {\n       syscalls_absolute_filename\n         = (char *) xmalloc (strlen (nondefault_syscalls_dir)\n-                            + strlen (syscalls_filename) + 1);\n+                            + strlen (syscalls_filename) + 2);\n       strcpy (syscalls_absolute_filename, nondefault_syscalls_dir);\n     }\n   else\n     {\n       syscalls_absolute_filename\n         = (char *) xmalloc (strlen (default_syscalls_dir)\n-                            + strlen (syscalls_filename) + 1);\n+                            + strlen (syscalls_filename) + 2);\n       strcpy (syscalls_absolute_filename, default_syscalls_dir);\n     }\n \n-  syscalls_len = strlen (syscalls_filename);\n+  syscalls_len = strlen (syscalls_absolute_filename);\n   if (*(syscalls_absolute_filename + syscalls_len - 1) != '/')\n     {\n       *(syscalls_absolute_filename + syscalls_len++) = '/';\n@@ -4232,7 +4338,9 @@ static struct option longopts[] =\n };\n \n int\n-main (int argc, char **const argv)\n+main (argc, argv)\n+     int argc;\n+     char **const argv;\n {\n   int longind;\n   int c;\n@@ -4242,7 +4350,7 @@ main (int argc, char **const argv)\n   pname = pname ? pname+1 : argv[0];\n \n   /* Read the working directory, avoiding arbitrary limit.  */\n-  size = 100;\n+  size = GUESSPATHLEN;\n   while (1)\n     {\n       char *value;"}]}