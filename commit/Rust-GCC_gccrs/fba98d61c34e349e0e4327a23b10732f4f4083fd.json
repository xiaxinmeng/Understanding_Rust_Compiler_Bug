{"sha": "fba98d61c34e349e0e4327a23b10732f4f4083fd", "node_id": "C_kwDOANBUbNoAKGZiYTk4ZDYxYzM0ZTM0OWUwZTQzMjdhMjNiMTA3MzJmNGY0MDgzZmQ", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-01-14T23:22:59Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-02-05T00:06:43Z"}, "message": "gccrs: Refactor SubstitutionRef base class into its own CC file\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: update the makefile\n\t* typecheck/rust-tyty.cc (SubstitutionParamMapping::need_substitution): likewise\n\t(SubstitutionParamMapping::override_context): likewise\n\t(SubstitutionRef::get_mappings_from_generic_args): likewise\n\t(SubstitutionRef::infer_substitions): likewise\n\t(SubstitutionRef::are_mappings_bound): likewise\n\t(SubstitutionRef::solve_missing_mappings_from_this): likewise\n\t(SubstitutionRef::monomorphize): likewise\n\t* typecheck/rust-tyty.h (class SubstitutionParamMapping): likewise\n\t(class SubstitutionArg): likewise\n\t(std::function<void): likewise\n\t(class SubstitutionArgumentMappings): likewise\n\t(class SubstitutionRef): likewise\n\t* typecheck/rust-tyty-subst.cc: New file.\n\t* typecheck/rust-tyty-subst.h: New file.", "tree": {"sha": "a168befe3f70dfb335966a894b39de493fa65710", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a168befe3f70dfb335966a894b39de493fa65710"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fba98d61c34e349e0e4327a23b10732f4f4083fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba98d61c34e349e0e4327a23b10732f4f4083fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba98d61c34e349e0e4327a23b10732f4f4083fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba98d61c34e349e0e4327a23b10732f4f4083fd/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fbf184bb9221f91a8c921ab868d8e1e5d2b56c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fbf184bb9221f91a8c921ab868d8e1e5d2b56c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fbf184bb9221f91a8c921ab868d8e1e5d2b56c3"}], "stats": {"total": 2174, "additions": 1245, "deletions": 929}, "files": [{"sha": "82d5c5d8b0af412fc45b9795a9549d61ff3269f2", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=fba98d61c34e349e0e4327a23b10732f4f4083fd", "patch": "@@ -117,6 +117,7 @@ GRS_OBJS = \\\n     rust/rust-tyty.o \\\n     rust/rust-tyty-util.o \\\n     rust/rust-tyty-call.o \\\n+    rust/rust-tyty-subst.o \\\n     rust/rust-tyctx.o \\\n     rust/rust-tyty-bounds.o \\\n     rust/rust-hir-type-check-util.o \\"}, {"sha": "64001459b4d7467619dc9cb702ee91bacc02ec1e", "filename": "gcc/rust/typecheck/rust-tyty-subst.cc", "status": "added", "additions": 927, "deletions": 0, "changes": 927, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc?ref=fba98d61c34e349e0e4327a23b10732f4f4083fd", "patch": "@@ -0,0 +1,927 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-tyty-subst.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-hir-type-check.h\"\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-check-type.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+SubstitutionParamMapping::SubstitutionParamMapping (\n+  const HIR::TypeParam &generic, ParamType *param)\n+  : generic (generic), param (param)\n+{}\n+\n+SubstitutionParamMapping::SubstitutionParamMapping (\n+  const SubstitutionParamMapping &other)\n+  : generic (other.generic), param (other.param)\n+{}\n+\n+std::string\n+SubstitutionParamMapping::as_string () const\n+{\n+  if (param == nullptr)\n+    return \"nullptr\";\n+\n+  return param->get_name ();\n+}\n+\n+SubstitutionParamMapping\n+SubstitutionParamMapping::clone () const\n+{\n+  return SubstitutionParamMapping (generic,\n+\t\t\t\t   static_cast<ParamType *> (param->clone ()));\n+}\n+\n+ParamType *\n+SubstitutionParamMapping::get_param_ty ()\n+{\n+  return param;\n+}\n+\n+const ParamType *\n+SubstitutionParamMapping::get_param_ty () const\n+{\n+  return param;\n+}\n+\n+const HIR::TypeParam &\n+SubstitutionParamMapping::get_generic_param ()\n+{\n+  return generic;\n+};\n+\n+bool\n+SubstitutionParamMapping::needs_substitution () const\n+{\n+  return !(get_param_ty ()->is_concrete ());\n+}\n+\n+Location\n+SubstitutionParamMapping::get_param_locus () const\n+{\n+  return generic.get_locus ();\n+}\n+\n+bool\n+SubstitutionParamMapping::param_has_default_ty () const\n+{\n+  return generic.has_type ();\n+}\n+\n+BaseType *\n+SubstitutionParamMapping::get_default_ty () const\n+{\n+  TyVar var (generic.get_type_mappings ().get_hirid ());\n+  return var.get_tyty ();\n+}\n+\n+bool\n+SubstitutionParamMapping::need_substitution () const\n+{\n+  if (!param->can_resolve ())\n+    return true;\n+\n+  auto resolved = param->resolve ();\n+  return !resolved->is_concrete ();\n+}\n+\n+bool\n+SubstitutionParamMapping::fill_param_ty (\n+  SubstitutionArgumentMappings &subst_mappings, Location locus)\n+{\n+  SubstitutionArg arg = SubstitutionArg::error ();\n+  bool ok = subst_mappings.get_argument_for_symbol (get_param_ty (), &arg);\n+  if (!ok)\n+    return true;\n+\n+  TyTy::BaseType &type = *arg.get_tyty ();\n+  if (type.get_kind () == TyTy::TypeKind::INFER)\n+    {\n+      type.inherit_bounds (*param);\n+    }\n+  else\n+    {\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+    }\n+\n+  if (type.get_kind () == TypeKind::PARAM)\n+    {\n+      // delete param;\n+      param = static_cast<ParamType *> (type.clone ());\n+    }\n+  else\n+    {\n+      // check the substitution is compatible with bounds\n+      if (!param->bounds_compatible (type, locus, true))\n+\treturn false;\n+\n+      // recursively pass this down to all HRTB's\n+      for (auto &bound : param->get_specified_bounds ())\n+\tbound.handle_substitions (subst_mappings);\n+\n+      param->set_ty_ref (type.get_ref ());\n+    }\n+\n+  return true;\n+}\n+\n+void\n+SubstitutionParamMapping::override_context ()\n+{\n+  if (!param->can_resolve ())\n+    return;\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = Resolver::TypeCheckContext::get ();\n+\n+  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t       UNKNOWN_NODEID,\n+\t\t\t\t\t       param->get_ref (),\n+\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n+\t\t\tparam->resolve ());\n+}\n+\n+SubstitutionArg::SubstitutionArg (const SubstitutionParamMapping *param,\n+\t\t\t\t  BaseType *argument)\n+  : param (param), argument (argument)\n+{}\n+\n+SubstitutionArg::SubstitutionArg (const SubstitutionArg &other)\n+  : param (other.param), argument (other.argument)\n+{}\n+\n+SubstitutionArg &\n+SubstitutionArg::operator= (const SubstitutionArg &other)\n+{\n+  param = other.param;\n+  argument = other.argument;\n+  return *this;\n+}\n+\n+BaseType *\n+SubstitutionArg::get_tyty ()\n+{\n+  return argument;\n+}\n+\n+const BaseType *\n+SubstitutionArg::get_tyty () const\n+{\n+  return argument;\n+}\n+\n+const SubstitutionParamMapping *\n+SubstitutionArg::get_param_mapping () const\n+{\n+  return param;\n+}\n+\n+SubstitutionArg\n+SubstitutionArg::error ()\n+{\n+  return SubstitutionArg (nullptr, nullptr);\n+}\n+\n+bool\n+SubstitutionArg::is_error () const\n+{\n+  return param == nullptr || argument == nullptr;\n+}\n+\n+bool\n+SubstitutionArg::is_conrete () const\n+{\n+  if (argument != nullptr)\n+    return true;\n+\n+  if (argument->get_kind () == TyTy::TypeKind::PARAM)\n+    return false;\n+\n+  return argument->is_concrete ();\n+}\n+\n+std::string\n+SubstitutionArg::as_string () const\n+{\n+  return param->as_string ()\n+\t + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n+}\n+\n+// SubstitutionArgumentMappings\n+\n+SubstitutionArgumentMappings::SubstitutionArgumentMappings (\n+  std::vector<SubstitutionArg> mappings,\n+  std::map<std::string, BaseType *> binding_args, Location locus,\n+  ParamSubstCb param_subst_cb, bool trait_item_flag)\n+  : mappings (mappings), binding_args (binding_args), locus (locus),\n+    param_subst_cb (param_subst_cb), trait_item_flag (trait_item_flag)\n+{}\n+\n+SubstitutionArgumentMappings::SubstitutionArgumentMappings (\n+  const SubstitutionArgumentMappings &other)\n+  : mappings (other.mappings), binding_args (other.binding_args),\n+    locus (other.locus), param_subst_cb (other.param_subst_cb),\n+    trait_item_flag (other.trait_item_flag)\n+{}\n+\n+SubstitutionArgumentMappings &\n+SubstitutionArgumentMappings::operator= (\n+  const SubstitutionArgumentMappings &other)\n+{\n+  mappings = other.mappings;\n+  binding_args = other.binding_args;\n+  locus = other.locus;\n+  param_subst_cb = other.param_subst_cb;\n+  trait_item_flag = other.trait_item_flag;\n+\n+  return *this;\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionArgumentMappings::error ()\n+{\n+  return SubstitutionArgumentMappings ({}, {}, Location (), nullptr, false);\n+}\n+\n+bool\n+SubstitutionArgumentMappings::is_error () const\n+{\n+  return mappings.size () == 0;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::get_argument_for_symbol (\n+  const ParamType *param_to_find, SubstitutionArg *argument)\n+{\n+  for (auto &mapping : mappings)\n+    {\n+      const SubstitutionParamMapping *param = mapping.get_param_mapping ();\n+      const ParamType *p = param->get_param_ty ();\n+\n+      if (p->get_symbol ().compare (param_to_find->get_symbol ()) == 0)\n+\t{\n+\t  *argument = mapping;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::get_argument_at (size_t index,\n+\t\t\t\t\t       SubstitutionArg *argument)\n+{\n+  if (index > mappings.size ())\n+    return false;\n+\n+  *argument = mappings.at (index);\n+  return true;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::is_concrete () const\n+{\n+  for (auto &mapping : mappings)\n+    {\n+      if (!mapping.is_conrete ())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+Location\n+SubstitutionArgumentMappings::get_locus () const\n+{\n+  return locus;\n+}\n+\n+size_t\n+SubstitutionArgumentMappings::size () const\n+{\n+  return mappings.size ();\n+}\n+\n+bool\n+SubstitutionArgumentMappings::is_empty () const\n+{\n+  return size () == 0;\n+}\n+\n+std::vector<SubstitutionArg> &\n+SubstitutionArgumentMappings::get_mappings ()\n+{\n+  return mappings;\n+}\n+\n+const std::vector<SubstitutionArg> &\n+SubstitutionArgumentMappings::get_mappings () const\n+{\n+  return mappings;\n+}\n+\n+std::map<std::string, BaseType *> &\n+SubstitutionArgumentMappings::get_binding_args ()\n+{\n+  return binding_args;\n+}\n+\n+const std::map<std::string, BaseType *> &\n+SubstitutionArgumentMappings::get_binding_args () const\n+{\n+  return binding_args;\n+}\n+\n+std::string\n+SubstitutionArgumentMappings::as_string () const\n+{\n+  std::string buffer;\n+  for (auto &mapping : mappings)\n+    {\n+      buffer += mapping.as_string () + \", \";\n+    }\n+  return \"<\" + buffer + \">\";\n+}\n+\n+void\n+SubstitutionArgumentMappings::on_param_subst (const ParamType &p,\n+\t\t\t\t\t      const SubstitutionArg &a) const\n+{\n+  if (param_subst_cb == nullptr)\n+    return;\n+\n+  param_subst_cb (p, a);\n+}\n+\n+ParamSubstCb\n+SubstitutionArgumentMappings::get_subst_cb () const\n+{\n+  return param_subst_cb;\n+}\n+\n+bool\n+SubstitutionArgumentMappings::trait_item_mode () const\n+{\n+  return trait_item_flag;\n+}\n+\n+// SubstitutionRef\n+\n+SubstitutionRef::SubstitutionRef (\n+  std::vector<SubstitutionParamMapping> substitutions,\n+  SubstitutionArgumentMappings arguments)\n+  : substitutions (substitutions), used_arguments (arguments)\n+{}\n+\n+bool\n+SubstitutionRef::has_substitutions () const\n+{\n+  return substitutions.size () > 0;\n+}\n+\n+std::string\n+SubstitutionRef::subst_as_string () const\n+{\n+  std::string buffer;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      const SubstitutionParamMapping &sub = substitutions.at (i);\n+      buffer += sub.as_string ();\n+\n+      if ((i + 1) < substitutions.size ())\n+\tbuffer += \", \";\n+    }\n+\n+  return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n+}\n+\n+bool\n+SubstitutionRef::supports_associated_bindings () const\n+{\n+  return get_num_associated_bindings () > 0;\n+}\n+\n+size_t\n+SubstitutionRef::get_num_associated_bindings () const\n+{\n+  return 0;\n+}\n+\n+TypeBoundPredicateItem\n+SubstitutionRef::lookup_associated_type (const std::string &search)\n+{\n+  return TypeBoundPredicateItem::error ();\n+}\n+\n+size_t\n+SubstitutionRef::get_num_substitutions () const\n+{\n+  return substitutions.size ();\n+}\n+\n+std::vector<SubstitutionParamMapping> &\n+SubstitutionRef::get_substs ()\n+{\n+  return substitutions;\n+}\n+\n+const std::vector<SubstitutionParamMapping> &\n+SubstitutionRef::get_substs () const\n+{\n+  return substitutions;\n+}\n+\n+std::vector<SubstitutionParamMapping>\n+SubstitutionRef::clone_substs () const\n+{\n+  std::vector<SubstitutionParamMapping> clone;\n+\n+  for (auto &sub : substitutions)\n+    clone.push_back (sub.clone ());\n+\n+  return clone;\n+}\n+\n+void\n+SubstitutionRef::override_context ()\n+{\n+  for (auto &sub : substitutions)\n+    {\n+      sub.override_context ();\n+    }\n+}\n+\n+bool\n+SubstitutionRef::needs_substitution () const\n+{\n+  for (auto &sub : substitutions)\n+    {\n+      if (sub.need_substitution ())\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+bool\n+SubstitutionRef::was_substituted () const\n+{\n+  return !needs_substitution ();\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_substitution_arguments () const\n+{\n+  return used_arguments;\n+}\n+\n+size_t\n+SubstitutionRef::num_required_substitutions () const\n+{\n+  size_t n = 0;\n+  for (auto &p : substitutions)\n+    {\n+      if (p.needs_substitution ())\n+\tn++;\n+    }\n+  return n;\n+}\n+\n+size_t\n+SubstitutionRef::min_required_substitutions () const\n+{\n+  size_t n = 0;\n+  for (auto &p : substitutions)\n+    {\n+      if (p.needs_substitution () && !p.param_has_default_ty ())\n+\tn++;\n+    }\n+  return n;\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_used_arguments () const\n+{\n+  return used_arguments;\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n+{\n+  std::map<std::string, BaseType *> binding_arguments;\n+  if (args.get_binding_args ().size () > 0)\n+    {\n+      if (supports_associated_bindings ())\n+\t{\n+\t  if (args.get_binding_args ().size () > get_num_associated_bindings ())\n+\t    {\n+\t      RichLocation r (args.get_locus ());\n+\n+\t      rust_error_at (r,\n+\t\t\t     \"generic item takes at most %lu type binding \"\n+\t\t\t     \"arguments but %lu were supplied\",\n+\t\t\t     (unsigned long) get_num_associated_bindings (),\n+\t\t\t     (unsigned long) args.get_binding_args ().size ());\n+\t      return SubstitutionArgumentMappings::error ();\n+\t    }\n+\n+\t  for (auto &binding : args.get_binding_args ())\n+\t    {\n+\t      BaseType *resolved\n+\t\t= Resolver::TypeCheckType::Resolve (binding.get_type ().get ());\n+\t      if (resolved == nullptr\n+\t\t  || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t{\n+\t\t  rust_error_at (binding.get_locus (),\n+\t\t\t\t \"failed to resolve type arguments\");\n+\t\t  return SubstitutionArgumentMappings::error ();\n+\t\t}\n+\n+\t      // resolve to relevant binding\n+\t      auto binding_item\n+\t\t= lookup_associated_type (binding.get_identifier ());\n+\t      if (binding_item.is_error ())\n+\t\t{\n+\t\t  rust_error_at (binding.get_locus (),\n+\t\t\t\t \"unknown associated type binding: %s\",\n+\t\t\t\t binding.get_identifier ().c_str ());\n+\t\t  return SubstitutionArgumentMappings::error ();\n+\t\t}\n+\n+\t      binding_arguments[binding.get_identifier ()] = resolved;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  RichLocation r (args.get_locus ());\n+\t  for (auto &binding : args.get_binding_args ())\n+\t    r.add_range (binding.get_locus ());\n+\n+\t  rust_error_at (r, \"associated type bindings are not allowed here\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+    }\n+\n+  // for inherited arguments\n+  size_t offs = used_arguments.size ();\n+  if (args.get_type_args ().size () + offs > substitutions.size ())\n+    {\n+      RichLocation r (args.get_locus ());\n+      r.add_range (substitutions.front ().get_param_locus ());\n+\n+      rust_error_at (\n+\tr,\n+\t\"generic item takes at most %lu type arguments but %lu were supplied\",\n+\t(unsigned long) substitutions.size (),\n+\t(unsigned long) args.get_type_args ().size ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  if (args.get_type_args ().size () + offs < min_required_substitutions ())\n+    {\n+      RichLocation r (args.get_locus ());\n+      r.add_range (substitutions.front ().get_param_locus ());\n+\n+      rust_error_at (\n+\tr,\n+\t\"generic item takes at least %lu type arguments but %lu were supplied\",\n+\t(unsigned long) (min_required_substitutions () - offs),\n+\t(unsigned long) args.get_type_args ().size ());\n+      return SubstitutionArgumentMappings::error ();\n+    }\n+\n+  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n+  for (auto &arg : args.get_type_args ())\n+    {\n+      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n+      if (resolved == nullptr || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t{\n+\t  rust_error_at (args.get_locus (), \"failed to resolve type arguments\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n+\n+      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n+      offs++;\n+      mappings.push_back (std::move (subst_arg));\n+    }\n+\n+  // we must need to fill out defaults\n+  size_t left_over\n+    = num_required_substitutions () - min_required_substitutions ();\n+  if (left_over > 0)\n+    {\n+      for (size_t offs = mappings.size (); offs < substitutions.size (); offs++)\n+\t{\n+\t  SubstitutionParamMapping &param = substitutions.at (offs);\n+\t  rust_assert (param.param_has_default_ty ());\n+\n+\t  BaseType *resolved = param.get_default_ty ();\n+\t  if (resolved->get_kind () == TypeKind::ERROR)\n+\t    return SubstitutionArgumentMappings::error ();\n+\n+\t  // this resolved default might already contain default parameters\n+\t  if (resolved->contains_type_parameters ())\n+\t    {\n+\t      SubstitutionArgumentMappings intermediate (mappings,\n+\t\t\t\t\t\t\t binding_arguments,\n+\t\t\t\t\t\t\t args.get_locus ());\n+\t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n+\t\t\t\t\t\t\t\t intermediate);\n+\n+\t      if (resolved->get_kind () == TypeKind::ERROR)\n+\t\treturn SubstitutionArgumentMappings::error ();\n+\t    }\n+\n+\t  SubstitutionArg subst_arg (&param, resolved);\n+\t  mappings.push_back (std::move (subst_arg));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (mappings, binding_arguments,\n+\t\t\t\t       args.get_locus ());\n+}\n+\n+BaseType *\n+SubstitutionRef::infer_substitions (Location locus)\n+{\n+  std::vector<SubstitutionArg> args;\n+  std::map<std::string, BaseType *> argument_mappings;\n+  for (auto &p : get_substs ())\n+    {\n+      if (p.needs_substitution ())\n+\t{\n+\t  const std::string &symbol = p.get_param_ty ()->get_symbol ();\n+\t  auto it = argument_mappings.find (symbol);\n+\t  bool have_mapping = it != argument_mappings.end ();\n+\n+\t  if (have_mapping)\n+\t    {\n+\t      args.push_back (SubstitutionArg (&p, it->second));\n+\t    }\n+\t  else\n+\t    {\n+\t      TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n+\t      args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n+\t      argument_mappings[symbol] = infer_var.get_tyty ();\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  args.push_back (SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n+\t}\n+    }\n+\n+  // FIXME do we need to add inference variables to all the possible bindings?\n+  // it might just lead to inference variable hell not 100% sure if rustc does\n+  // this i think the language might needs this to be explicitly set\n+\n+  SubstitutionArgumentMappings infer_arguments (std::move (args),\n+\t\t\t\t\t\t{} /* binding_arguments */,\n+\t\t\t\t\t\tlocus);\n+  return handle_substitions (std::move (infer_arguments));\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::adjust_mappings_for_this (\n+  SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  if (resolved_mappings.empty ())\n+    return SubstitutionArgumentMappings::error ();\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_binding_args (),\n+\t\t\t\t       mappings.get_locus (),\n+\t\t\t\t       mappings.get_subst_cb (),\n+\t\t\t\t       mappings.trait_item_mode ());\n+}\n+\n+bool\n+SubstitutionRef::are_mappings_bound (SubstitutionArgumentMappings &mappings)\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+  for (size_t i = 0; i < substitutions.size (); i++)\n+    {\n+      auto &subst = substitutions.at (i);\n+\n+      SubstitutionArg arg = SubstitutionArg::error ();\n+      if (mappings.size () == substitutions.size ())\n+\t{\n+\t  mappings.get_argument_at (i, &arg);\n+\t}\n+      else\n+\t{\n+\t  if (subst.needs_substitution ())\n+\t    {\n+\t      // get from passed in mappings\n+\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n+\t    }\n+\t  else\n+\t    {\n+\t      // we should already have this somewhere\n+\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n+\t\t\t\t\t\t      &arg);\n+\t    }\n+\t}\n+\n+      bool ok = !arg.is_error ();\n+      if (ok)\n+\t{\n+\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return !resolved_mappings.empty ();\n+}\n+\n+// this function assumes that the mappings being passed are for the same type as\n+// this new substitution reference so ordering matters here\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_mappings_from_receiver_for_self (\n+  SubstitutionArgumentMappings &mappings) const\n+{\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  rust_assert (mappings.size () == get_num_substitutions ());\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      const SubstitutionParamMapping &param_mapping = substitutions.at (i);\n+      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n+\n+      if (param_mapping.needs_substitution ())\n+\t{\n+\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n+\t  resolved_mappings.push_back (std::move (adjusted));\n+\t}\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_binding_args (),\n+\t\t\t\t       mappings.get_locus ());\n+}\n+\n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n+\t\t\t\t\t\t   SubstitutionRef &to)\n+{\n+  rust_assert (!ref.needs_substitution ());\n+  rust_assert (needs_substitution ());\n+  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n+\n+  Location locus = used_arguments.get_locus ();\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &a = substitutions.at (i);\n+      SubstitutionParamMapping &b = ref.substitutions.at (i);\n+\n+      if (a.need_substitution ())\n+\t{\n+\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n+\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n+\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+\n+\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n+\t\t\t\t      b.get_param_ty ()->resolve ()};\n+\t}\n+    }\n+\n+  for (auto it = substs.begin (); it != substs.end (); it++)\n+    {\n+      HirId param_id = it->first;\n+      BaseType *arg = it->second.second;\n+\n+      const SubstitutionParamMapping *associate_param = nullptr;\n+      for (SubstitutionParamMapping &p : to.substitutions)\n+\t{\n+\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n+\t    {\n+\t      associate_param = &p;\n+\t      break;\n+\t    }\n+\t}\n+\n+      rust_assert (associate_param != nullptr);\n+      SubstitutionArg argument (associate_param, arg);\n+      resolved_mappings.push_back (std::move (argument));\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings, {}, locus);\n+}\n+\n+bool\n+SubstitutionRef::monomorphize ()\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  for (const auto &subst : get_substs ())\n+    {\n+      const TyTy::ParamType *pty = subst.get_param_ty ();\n+\n+      if (!pty->can_resolve ())\n+\tcontinue;\n+\n+      const TyTy::BaseType *binding = pty->resolve ();\n+      if (binding->get_kind () == TyTy::TypeKind::PARAM)\n+\tcontinue;\n+\n+      for (const auto &bound : pty->get_specified_bounds ())\n+\t{\n+\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n+\n+\t  // setup any associated type mappings for the specified bonds and this\n+\t  // type\n+\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n+\n+\t  Resolver::AssociatedImplTrait *associated_impl_trait = nullptr;\n+\t  for (auto &probed_bound : candidates)\n+\t    {\n+\t      const Resolver::TraitReference *bound_trait_ref\n+\t\t= probed_bound.first;\n+\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+\t      HirId impl_block_id\n+\t\t= associated_impl->get_mappings ().get_hirid ();\n+\t      Resolver::AssociatedImplTrait *associated = nullptr;\n+\t      bool found_impl_trait\n+\t\t= context->lookup_associated_trait_impl (impl_block_id,\n+\t\t\t\t\t\t\t &associated);\n+\t      if (found_impl_trait)\n+\t\t{\n+\t\t  bool found_trait\n+\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t\t  bool found_self\n+\t\t    = associated->get_self ()->can_eq (binding, false);\n+\t\t  if (found_trait && found_self)\n+\t\t    {\n+\t\t      associated_impl_trait = associated;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\n+\t  if (associated_impl_trait != nullptr)\n+\t    {\n+\t      associated_impl_trait->setup_associated_types (binding, bound);\n+\t    }\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+} // namespace TyTy\n+} // namespace Rust"}, {"sha": "4d09a3013e7b3376116de85e53c8de45c29d7536", "filename": "gcc/rust/typecheck/rust-tyty-subst.h", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h?ref=fba98d61c34e349e0e4327a23b10732f4f4083fd", "patch": "@@ -0,0 +1,316 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_SUBST_H\n+#define RUST_TYTY_SUBST_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-tyty-bounds.h\"\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseType;\n+class ParamType;\n+class SubstitutionArgumentMappings;\n+class SubstitutionParamMapping\n+{\n+public:\n+  SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param);\n+\n+  SubstitutionParamMapping (const SubstitutionParamMapping &other);\n+\n+  std::string as_string () const;\n+\n+  bool fill_param_ty (SubstitutionArgumentMappings &subst_mappings,\n+\t\t      Location locus);\n+\n+  SubstitutionParamMapping clone () const;\n+\n+  ParamType *get_param_ty ();\n+\n+  const ParamType *get_param_ty () const;\n+\n+  const HIR::TypeParam &get_generic_param ();\n+\n+  // this is used for the backend to override the HirId ref of the param to\n+  // what the concrete type is for the rest of the context\n+  void override_context ();\n+\n+  bool needs_substitution () const;\n+\n+  Location get_param_locus () const;\n+\n+  bool param_has_default_ty () const;\n+\n+  BaseType *get_default_ty () const;\n+\n+  bool need_substitution () const;\n+\n+private:\n+  const HIR::TypeParam &generic;\n+  ParamType *param;\n+};\n+\n+class SubstitutionArg\n+{\n+public:\n+  SubstitutionArg (const SubstitutionParamMapping *param, BaseType *argument);\n+\n+  // FIXME\n+  // the copy constructors need removed - they are unsafe see\n+  // TypeBoundPredicate\n+  SubstitutionArg (const SubstitutionArg &other);\n+\n+  SubstitutionArg &operator= (const SubstitutionArg &other);\n+\n+  BaseType *get_tyty ();\n+\n+  const BaseType *get_tyty () const;\n+\n+  const SubstitutionParamMapping *get_param_mapping () const;\n+\n+  static SubstitutionArg error ();\n+\n+  bool is_error () const;\n+\n+  bool is_conrete () const;\n+\n+  std::string as_string () const;\n+\n+private:\n+  const SubstitutionParamMapping *param;\n+  BaseType *argument;\n+};\n+\n+typedef std::function<void (const ParamType &, const SubstitutionArg &)>\n+  ParamSubstCb;\n+class SubstitutionArgumentMappings\n+{\n+public:\n+  SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n+\t\t\t\tstd::map<std::string, BaseType *> binding_args,\n+\t\t\t\tLocation locus,\n+\t\t\t\tParamSubstCb param_subst_cb = nullptr,\n+\t\t\t\tbool trait_item_flag = false);\n+\n+  SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other);\n+  SubstitutionArgumentMappings &\n+  operator= (const SubstitutionArgumentMappings &other);\n+\n+  SubstitutionArgumentMappings (SubstitutionArgumentMappings &&other) = default;\n+  SubstitutionArgumentMappings &operator= (SubstitutionArgumentMappings &&other)\n+    = default;\n+\n+  static SubstitutionArgumentMappings error ();\n+\n+  bool is_error () const;\n+\n+  bool get_argument_for_symbol (const ParamType *param_to_find,\n+\t\t\t\tSubstitutionArg *argument);\n+\n+  bool get_argument_at (size_t index, SubstitutionArg *argument);\n+\n+  // is_concrete means if the used args is non error, ie: non empty this will\n+  // verify if actual real types have been put in place of are they still\n+  // ParamTy\n+  bool is_concrete () const;\n+\n+  Location get_locus () const;\n+\n+  size_t size () const;\n+\n+  bool is_empty () const;\n+\n+  std::vector<SubstitutionArg> &get_mappings ();\n+\n+  const std::vector<SubstitutionArg> &get_mappings () const;\n+\n+  std::map<std::string, BaseType *> &get_binding_args ();\n+\n+  const std::map<std::string, BaseType *> &get_binding_args () const;\n+\n+  std::string as_string () const;\n+\n+  void on_param_subst (const ParamType &p, const SubstitutionArg &a) const;\n+\n+  ParamSubstCb get_subst_cb () const;\n+\n+  bool trait_item_mode () const;\n+\n+private:\n+  std::vector<SubstitutionArg> mappings;\n+  std::map<std::string, BaseType *> binding_args;\n+  Location locus;\n+  ParamSubstCb param_subst_cb;\n+  bool trait_item_flag;\n+};\n+\n+class SubstitutionRef\n+{\n+public:\n+  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions,\n+\t\t   SubstitutionArgumentMappings arguments);\n+\n+  bool has_substitutions () const;\n+\n+  std::string subst_as_string () const;\n+\n+  bool supports_associated_bindings () const;\n+\n+  // this is overridden in TypeBoundPredicate\n+  // which support bindings we don't add them directly to the SubstitutionRef\n+  // base class because this class represents the fn<X: Foo, Y: Bar>. The only\n+  // construct which supports associated types\n+  virtual size_t get_num_associated_bindings () const;\n+\n+  // this is overridden in TypeBoundPredicate\n+  virtual TypeBoundPredicateItem\n+  lookup_associated_type (const std::string &search);\n+\n+  size_t get_num_substitutions () const;\n+\n+  std::vector<SubstitutionParamMapping> &get_substs ();\n+\n+  const std::vector<SubstitutionParamMapping> &get_substs () const;\n+\n+  std::vector<SubstitutionParamMapping> clone_substs () const;\n+\n+  void override_context ();\n+\n+  bool needs_substitution () const;\n+\n+  bool was_substituted () const;\n+\n+  SubstitutionArgumentMappings get_substitution_arguments () const;\n+\n+  // this is the count of type params that are not substituted fuly\n+  size_t num_required_substitutions () const;\n+\n+  // this is the count of type params that need substituted taking into account\n+  // possible defaults\n+  size_t min_required_substitutions () const;\n+\n+  // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n+  // in the case of Foo<i32,f32>{...}\n+  //\n+  // the substitions we have here define X,Y but the arguments have no bindings\n+  // so its a matter of ordering\n+  SubstitutionArgumentMappings\n+  get_mappings_from_generic_args (HIR::GenericArgs &args);\n+\n+  // Recursive substitutions\n+  // Foo <A,B> { a:A, b: B}; Bar <X,Y,Z>{a:X, b: Foo<Y,Z>}\n+  //\n+  // we have bindings for X Y Z and need to propagate the binding Y,Z into Foo\n+  // Which binds to A,B\n+  SubstitutionArgumentMappings\n+  adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n+\n+  // Are the mappings here actually bound to this type. For example imagine the\n+  // case:\n+  //\n+  // struct Foo<T>(T);\n+  // impl<T> Foo<T> {\n+  //   fn test(self) { ... }\n+  // }\n+  //\n+  // In this case we have a generic ADT of Foo and an impl block of a generic T\n+  // on Foo for the Self type. When we it comes to path resolution we can have:\n+  //\n+  // Foo::<i32>::test()\n+  //\n+  // This means the first segment of Foo::<i32> returns the ADT Foo<i32> not the\n+  // Self ADT bound to the T from the impl block. This means when it comes to\n+  // the next segment of test which resolves to the function we need to check\n+  // wether the arguments in the struct definition of foo can be bound here\n+  // before substituting the previous segments type here. This functions acts as\n+  // a guard for the solve_mappings_from_receiver_for_self to handle the case\n+  // where arguments are not bound. This is important for this next case:\n+  //\n+  // struct Baz<A, B>(A, B);\n+  // impl Baz<i32, f32> {\n+  //   fn test<X>(a: X) -> X {\n+  //       a\n+  //   }\n+  // }\n+  //\n+  // In this case Baz has been already substituted for the impl's Self to become\n+  // ADT<i32, f32> so that the function test only has 1 generic argument of X.\n+  // The path for this will be:\n+  //\n+  // Baz::test::<_>(123)\n+  //\n+  // So the first segment here will be Baz<_, _> to try and infer the arguments\n+  // which will be taken from the impl's Self type in this case since it is\n+  // already substituted and like the previous case the check to see if we need\n+  // to inherit the previous segments generic arguments takes place but the\n+  // generic arguments are not bound to this type as they have already been\n+  // substituted.\n+  //\n+  // Its important to remember from the first example the FnType actually looks\n+  // like:\n+  //\n+  // fn <T>test(self :Foo<T>(T))\n+  //\n+  // As the generic parameters are \"bound\" to each of the items in the impl\n+  // block. So this check is about wether the arguments we have here can\n+  // actually be bound to this type.\n+  bool are_mappings_bound (SubstitutionArgumentMappings &mappings);\n+\n+  // struct Foo<A, B>(A, B);\n+  //\n+  // impl<T> Foo<T, f32>;\n+  //     -> fn test<X>(self, a: X) -> X\n+  //\n+  // We might invoke this via:\n+  //\n+  // a = Foo(123, 456f32);\n+  // b = a.test::<bool>(false);\n+  //\n+  // we need to figure out relevant generic arguemts for self to apply to the\n+  // fntype\n+  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n+    SubstitutionArgumentMappings &mappings) const;\n+\n+  // TODO comment\n+  SubstitutionArgumentMappings\n+  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n+\n+  // TODO comment\n+  BaseType *infer_substitions (Location locus);\n+\n+  // TODO comment\n+  bool monomorphize ();\n+\n+  // TODO comment\n+  virtual BaseType *handle_substitions (SubstitutionArgumentMappings mappings)\n+    = 0;\n+\n+  SubstitutionArgumentMappings get_used_arguments () const;\n+\n+protected:\n+  std::vector<SubstitutionParamMapping> substitutions;\n+  SubstitutionArgumentMappings used_arguments;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+#endif // RUST_TYTY_SUBST_H"}, {"sha": "7b86112d276fc11e403b287d6a14da1287a52816", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 0, "deletions": 466, "changes": 466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=fba98d61c34e349e0e4327a23b10732f4f4083fd", "patch": "@@ -514,472 +514,6 @@ StructFieldType::monomorphized_clone () const\n \t\t\t      get_field_type ()->monomorphized_clone (), locus);\n }\n \n-bool\n-SubstitutionParamMapping::need_substitution () const\n-{\n-  if (!param->can_resolve ())\n-    return true;\n-\n-  auto resolved = param->resolve ();\n-  return !resolved->is_concrete ();\n-}\n-\n-bool\n-SubstitutionParamMapping::fill_param_ty (\n-  SubstitutionArgumentMappings &subst_mappings, Location locus)\n-{\n-  SubstitutionArg arg = SubstitutionArg::error ();\n-  bool ok = subst_mappings.get_argument_for_symbol (get_param_ty (), &arg);\n-  if (!ok)\n-    return true;\n-\n-  TyTy::BaseType &type = *arg.get_tyty ();\n-  if (type.get_kind () == TyTy::TypeKind::INFER)\n-    {\n-      type.inherit_bounds (*param);\n-    }\n-  else\n-    {\n-      if (!param->bounds_compatible (type, locus, true))\n-\treturn false;\n-    }\n-\n-  if (type.get_kind () == TypeKind::PARAM)\n-    {\n-      // delete param;\n-      param = static_cast<ParamType *> (type.clone ());\n-    }\n-  else\n-    {\n-      // check the substitution is compatible with bounds\n-      if (!param->bounds_compatible (type, locus, true))\n-\treturn false;\n-\n-      // recursively pass this down to all HRTB's\n-      for (auto &bound : param->get_specified_bounds ())\n-\tbound.handle_substitions (subst_mappings);\n-\n-      param->set_ty_ref (type.get_ref ());\n-    }\n-\n-  return true;\n-}\n-\n-void\n-SubstitutionParamMapping::override_context ()\n-{\n-  if (!param->can_resolve ())\n-    return;\n-\n-  auto mappings = Analysis::Mappings::get ();\n-  auto context = Resolver::TypeCheckContext::get ();\n-\n-  context->insert_type (Analysis::NodeMapping (mappings->get_current_crate (),\n-\t\t\t\t\t       UNKNOWN_NODEID,\n-\t\t\t\t\t       param->get_ref (),\n-\t\t\t\t\t       UNKNOWN_LOCAL_DEFID),\n-\t\t\tparam->resolve ());\n-}\n-\n-SubstitutionArgumentMappings\n-SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n-{\n-  std::map<std::string, BaseType *> binding_arguments;\n-  if (args.get_binding_args ().size () > 0)\n-    {\n-      if (supports_associated_bindings ())\n-\t{\n-\t  if (args.get_binding_args ().size () > get_num_associated_bindings ())\n-\t    {\n-\t      RichLocation r (args.get_locus ());\n-\n-\t      rust_error_at (r,\n-\t\t\t     \"generic item takes at most %lu type binding \"\n-\t\t\t     \"arguments but %lu were supplied\",\n-\t\t\t     (unsigned long) get_num_associated_bindings (),\n-\t\t\t     (unsigned long) args.get_binding_args ().size ());\n-\t      return SubstitutionArgumentMappings::error ();\n-\t    }\n-\n-\t  for (auto &binding : args.get_binding_args ())\n-\t    {\n-\t      BaseType *resolved\n-\t\t= Resolver::TypeCheckType::Resolve (binding.get_type ().get ());\n-\t      if (resolved == nullptr\n-\t\t  || resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t\t{\n-\t\t  rust_error_at (binding.get_locus (),\n-\t\t\t\t \"failed to resolve type arguments\");\n-\t\t  return SubstitutionArgumentMappings::error ();\n-\t\t}\n-\n-\t      // resolve to relevant binding\n-\t      auto binding_item\n-\t\t= lookup_associated_type (binding.get_identifier ());\n-\t      if (binding_item.is_error ())\n-\t\t{\n-\t\t  rust_error_at (binding.get_locus (),\n-\t\t\t\t \"unknown associated type binding: %s\",\n-\t\t\t\t binding.get_identifier ().c_str ());\n-\t\t  return SubstitutionArgumentMappings::error ();\n-\t\t}\n-\n-\t      binding_arguments[binding.get_identifier ()] = resolved;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  RichLocation r (args.get_locus ());\n-\t  for (auto &binding : args.get_binding_args ())\n-\t    r.add_range (binding.get_locus ());\n-\n-\t  rust_error_at (r, \"associated type bindings are not allowed here\");\n-\t  return SubstitutionArgumentMappings::error ();\n-\t}\n-    }\n-\n-  // for inherited arguments\n-  size_t offs = used_arguments.size ();\n-  if (args.get_type_args ().size () + offs > substitutions.size ())\n-    {\n-      RichLocation r (args.get_locus ());\n-      r.add_range (substitutions.front ().get_param_locus ());\n-\n-      rust_error_at (\n-\tr,\n-\t\"generic item takes at most %lu type arguments but %lu were supplied\",\n-\t(unsigned long) substitutions.size (),\n-\t(unsigned long) args.get_type_args ().size ());\n-      return SubstitutionArgumentMappings::error ();\n-    }\n-\n-  if (args.get_type_args ().size () + offs < min_required_substitutions ())\n-    {\n-      RichLocation r (args.get_locus ());\n-      r.add_range (substitutions.front ().get_param_locus ());\n-\n-      rust_error_at (\n-\tr,\n-\t\"generic item takes at least %lu type arguments but %lu were supplied\",\n-\t(unsigned long) (min_required_substitutions () - offs),\n-\t(unsigned long) args.get_type_args ().size ());\n-      return SubstitutionArgumentMappings::error ();\n-    }\n-\n-  std::vector<SubstitutionArg> mappings = used_arguments.get_mappings ();\n-  for (auto &arg : args.get_type_args ())\n-    {\n-      BaseType *resolved = Resolver::TypeCheckType::Resolve (arg.get ());\n-      if (resolved == nullptr || resolved->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_error_at (args.get_locus (), \"failed to resolve type arguments\");\n-\t  return SubstitutionArgumentMappings::error ();\n-\t}\n-\n-      SubstitutionArg subst_arg (&substitutions.at (offs), resolved);\n-      offs++;\n-      mappings.push_back (std::move (subst_arg));\n-    }\n-\n-  // we must need to fill out defaults\n-  size_t left_over\n-    = num_required_substitutions () - min_required_substitutions ();\n-  if (left_over > 0)\n-    {\n-      for (size_t offs = mappings.size (); offs < substitutions.size (); offs++)\n-\t{\n-\t  SubstitutionParamMapping &param = substitutions.at (offs);\n-\t  rust_assert (param.param_has_default_ty ());\n-\n-\t  BaseType *resolved = param.get_default_ty ();\n-\t  if (resolved->get_kind () == TypeKind::ERROR)\n-\t    return SubstitutionArgumentMappings::error ();\n-\n-\t  // this resolved default might already contain default parameters\n-\t  if (resolved->contains_type_parameters ())\n-\t    {\n-\t      SubstitutionArgumentMappings intermediate (mappings,\n-\t\t\t\t\t\t\t binding_arguments,\n-\t\t\t\t\t\t\t args.get_locus ());\n-\t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n-\t\t\t\t\t\t\t\t intermediate);\n-\n-\t      if (resolved->get_kind () == TypeKind::ERROR)\n-\t\treturn SubstitutionArgumentMappings::error ();\n-\t    }\n-\n-\t  SubstitutionArg subst_arg (&param, resolved);\n-\t  mappings.push_back (std::move (subst_arg));\n-\t}\n-    }\n-\n-  return SubstitutionArgumentMappings (mappings, binding_arguments,\n-\t\t\t\t       args.get_locus ());\n-}\n-\n-BaseType *\n-SubstitutionRef::infer_substitions (Location locus)\n-{\n-  std::vector<SubstitutionArg> args;\n-  std::map<std::string, BaseType *> argument_mappings;\n-  for (auto &p : get_substs ())\n-    {\n-      if (p.needs_substitution ())\n-\t{\n-\t  const std::string &symbol = p.get_param_ty ()->get_symbol ();\n-\t  auto it = argument_mappings.find (symbol);\n-\t  bool have_mapping = it != argument_mappings.end ();\n-\n-\t  if (have_mapping)\n-\t    {\n-\t      args.push_back (SubstitutionArg (&p, it->second));\n-\t    }\n-\t  else\n-\t    {\n-\t      TyVar infer_var = TyVar::get_implicit_infer_var (locus);\n-\t      args.push_back (SubstitutionArg (&p, infer_var.get_tyty ()));\n-\t      argument_mappings[symbol] = infer_var.get_tyty ();\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  args.push_back (SubstitutionArg (&p, p.get_param_ty ()->resolve ()));\n-\t}\n-    }\n-\n-  // FIXME do we need to add inference variables to all the possible bindings?\n-  // it might just lead to inference variable hell not 100% sure if rustc does\n-  // this i think the language might needs this to be explicitly set\n-\n-  SubstitutionArgumentMappings infer_arguments (std::move (args),\n-\t\t\t\t\t\t{} /* binding_arguments */,\n-\t\t\t\t\t\tlocus);\n-  return handle_substitions (std::move (infer_arguments));\n-}\n-\n-SubstitutionArgumentMappings\n-SubstitutionRef::adjust_mappings_for_this (\n-  SubstitutionArgumentMappings &mappings)\n-{\n-  std::vector<SubstitutionArg> resolved_mappings;\n-  for (size_t i = 0; i < substitutions.size (); i++)\n-    {\n-      auto &subst = substitutions.at (i);\n-\n-      SubstitutionArg arg = SubstitutionArg::error ();\n-      if (mappings.size () == substitutions.size ())\n-\t{\n-\t  mappings.get_argument_at (i, &arg);\n-\t}\n-      else\n-\t{\n-\t  if (subst.needs_substitution ())\n-\t    {\n-\t      // get from passed in mappings\n-\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n-\t    }\n-\t  else\n-\t    {\n-\t      // we should already have this somewhere\n-\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n-\t\t\t\t\t\t      &arg);\n-\t    }\n-\t}\n-\n-      bool ok = !arg.is_error ();\n-      if (ok)\n-\t{\n-\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n-\t  resolved_mappings.push_back (std::move (adjusted));\n-\t}\n-    }\n-\n-  if (resolved_mappings.empty ())\n-    return SubstitutionArgumentMappings::error ();\n-\n-  return SubstitutionArgumentMappings (resolved_mappings,\n-\t\t\t\t       mappings.get_binding_args (),\n-\t\t\t\t       mappings.get_locus (),\n-\t\t\t\t       mappings.get_subst_cb (),\n-\t\t\t\t       mappings.trait_item_mode ());\n-}\n-\n-bool\n-SubstitutionRef::are_mappings_bound (SubstitutionArgumentMappings &mappings)\n-{\n-  std::vector<SubstitutionArg> resolved_mappings;\n-  for (size_t i = 0; i < substitutions.size (); i++)\n-    {\n-      auto &subst = substitutions.at (i);\n-\n-      SubstitutionArg arg = SubstitutionArg::error ();\n-      if (mappings.size () == substitutions.size ())\n-\t{\n-\t  mappings.get_argument_at (i, &arg);\n-\t}\n-      else\n-\t{\n-\t  if (subst.needs_substitution ())\n-\t    {\n-\t      // get from passed in mappings\n-\t      mappings.get_argument_for_symbol (subst.get_param_ty (), &arg);\n-\t    }\n-\t  else\n-\t    {\n-\t      // we should already have this somewhere\n-\t      used_arguments.get_argument_for_symbol (subst.get_param_ty (),\n-\t\t\t\t\t\t      &arg);\n-\t    }\n-\t}\n-\n-      bool ok = !arg.is_error ();\n-      if (ok)\n-\t{\n-\t  SubstitutionArg adjusted (&subst, arg.get_tyty ());\n-\t  resolved_mappings.push_back (std::move (adjusted));\n-\t}\n-    }\n-\n-  return !resolved_mappings.empty ();\n-}\n-\n-// this function assumes that the mappings being passed are for the same type as\n-// this new substitution reference so ordering matters here\n-SubstitutionArgumentMappings\n-SubstitutionRef::solve_mappings_from_receiver_for_self (\n-  SubstitutionArgumentMappings &mappings) const\n-{\n-  std::vector<SubstitutionArg> resolved_mappings;\n-\n-  rust_assert (mappings.size () == get_num_substitutions ());\n-  for (size_t i = 0; i < get_num_substitutions (); i++)\n-    {\n-      const SubstitutionParamMapping &param_mapping = substitutions.at (i);\n-      SubstitutionArg &arg = mappings.get_mappings ().at (i);\n-\n-      if (param_mapping.needs_substitution ())\n-\t{\n-\t  SubstitutionArg adjusted (&param_mapping, arg.get_tyty ());\n-\t  resolved_mappings.push_back (std::move (adjusted));\n-\t}\n-    }\n-\n-  return SubstitutionArgumentMappings (resolved_mappings,\n-\t\t\t\t       mappings.get_binding_args (),\n-\t\t\t\t       mappings.get_locus ());\n-}\n-\n-SubstitutionArgumentMappings\n-SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n-\t\t\t\t\t\t   SubstitutionRef &to)\n-{\n-  rust_assert (!ref.needs_substitution ());\n-  rust_assert (needs_substitution ());\n-  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n-\n-  Location locus = used_arguments.get_locus ();\n-  std::vector<SubstitutionArg> resolved_mappings;\n-\n-  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n-  for (size_t i = 0; i < get_num_substitutions (); i++)\n-    {\n-      SubstitutionParamMapping &a = substitutions.at (i);\n-      SubstitutionParamMapping &b = ref.substitutions.at (i);\n-\n-      if (a.need_substitution ())\n-\t{\n-\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n-\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n-\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n-\n-\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n-\t\t\t\t      b.get_param_ty ()->resolve ()};\n-\t}\n-    }\n-\n-  for (auto it = substs.begin (); it != substs.end (); it++)\n-    {\n-      HirId param_id = it->first;\n-      BaseType *arg = it->second.second;\n-\n-      const SubstitutionParamMapping *associate_param = nullptr;\n-      for (SubstitutionParamMapping &p : to.substitutions)\n-\t{\n-\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n-\t    {\n-\t      associate_param = &p;\n-\t      break;\n-\t    }\n-\t}\n-\n-      rust_assert (associate_param != nullptr);\n-      SubstitutionArg argument (associate_param, arg);\n-      resolved_mappings.push_back (std::move (argument));\n-    }\n-\n-  return SubstitutionArgumentMappings (resolved_mappings, {}, locus);\n-}\n-\n-bool\n-SubstitutionRef::monomorphize ()\n-{\n-  auto context = Resolver::TypeCheckContext::get ();\n-  for (const auto &subst : get_substs ())\n-    {\n-      const TyTy::ParamType *pty = subst.get_param_ty ();\n-\n-      if (!pty->can_resolve ())\n-\tcontinue;\n-\n-      const TyTy::BaseType *binding = pty->resolve ();\n-      if (binding->get_kind () == TyTy::TypeKind::PARAM)\n-\tcontinue;\n-\n-      for (const auto &bound : pty->get_specified_bounds ())\n-\t{\n-\t  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n-\n-\t  // setup any associated type mappings for the specified bonds and this\n-\t  // type\n-\t  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n-\n-\t  Resolver::AssociatedImplTrait *associated_impl_trait = nullptr;\n-\t  for (auto &probed_bound : candidates)\n-\t    {\n-\t      const Resolver::TraitReference *bound_trait_ref\n-\t\t= probed_bound.first;\n-\t      const HIR::ImplBlock *associated_impl = probed_bound.second;\n-\n-\t      HirId impl_block_id\n-\t\t= associated_impl->get_mappings ().get_hirid ();\n-\t      Resolver::AssociatedImplTrait *associated = nullptr;\n-\t      bool found_impl_trait\n-\t\t= context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t\t &associated);\n-\t      if (found_impl_trait)\n-\t\t{\n-\t\t  bool found_trait\n-\t\t    = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t\t  bool found_self\n-\t\t    = associated->get_self ()->can_eq (binding, false);\n-\t\t  if (found_trait && found_self)\n-\t\t    {\n-\t\t      associated_impl_trait = associated;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  if (associated_impl_trait != nullptr)\n-\t    {\n-\t      associated_impl_trait->setup_associated_types (binding, bound);\n-\t    }\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n void\n ADTType::accept_vis (TyVisitor &vis)\n {"}, {"sha": "a97bfb7632ad74609421adc47a246971b55d9761", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 1, "deletions": 463, "changes": 464, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba98d61c34e349e0e4327a23b10732f4f4083fd/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=fba98d61c34e349e0e4327a23b10732f4f4083fd", "patch": "@@ -27,6 +27,7 @@\n #include \"rust-identifier.h\"\n #include \"rust-tyty-bounds.h\"\n #include \"rust-tyty-util.h\"\n+#include \"rust-tyty-subst.h\"\n \n namespace Rust {\n \n@@ -462,469 +463,6 @@ class TupleType : public BaseType\n   std::vector<TyVar> fields;\n };\n \n-class SubstitutionParamMapping\n-{\n-public:\n-  SubstitutionParamMapping (const HIR::TypeParam &generic, ParamType *param)\n-    : generic (generic), param (param)\n-  {}\n-\n-  SubstitutionParamMapping (const SubstitutionParamMapping &other)\n-    : generic (other.generic), param (other.param)\n-  {}\n-\n-  std::string as_string () const\n-  {\n-    if (param == nullptr)\n-      return \"nullptr\";\n-\n-    return param->get_name ();\n-  }\n-\n-  bool fill_param_ty (SubstitutionArgumentMappings &subst_mappings,\n-\t\t      Location locus);\n-\n-  SubstitutionParamMapping clone () const\n-  {\n-    return SubstitutionParamMapping (generic, static_cast<ParamType *> (\n-\t\t\t\t\t\tparam->clone ()));\n-  }\n-\n-  ParamType *get_param_ty () { return param; }\n-\n-  const ParamType *get_param_ty () const { return param; }\n-\n-  const HIR::TypeParam &get_generic_param () { return generic; };\n-\n-  // this is used for the backend to override the HirId ref of the param to\n-  // what the concrete type is for the rest of the context\n-  void override_context ();\n-\n-  bool needs_substitution () const\n-  {\n-    return !(get_param_ty ()->is_concrete ());\n-  }\n-\n-  Location get_param_locus () const { return generic.get_locus (); }\n-\n-  bool param_has_default_ty () const { return generic.has_type (); }\n-\n-  BaseType *get_default_ty () const\n-  {\n-    TyVar var (generic.get_type_mappings ().get_hirid ());\n-    return var.get_tyty ();\n-  }\n-\n-  bool need_substitution () const;\n-\n-private:\n-  const HIR::TypeParam &generic;\n-  ParamType *param;\n-};\n-\n-class SubstitutionArg\n-{\n-public:\n-  SubstitutionArg (const SubstitutionParamMapping *param, BaseType *argument)\n-    : param (param), argument (argument)\n-  {}\n-\n-  // FIXME\n-  // the copy constructors need removed - they are unsafe see\n-  // TypeBoundPredicate\n-  SubstitutionArg (const SubstitutionArg &other)\n-    : param (other.param), argument (other.argument)\n-  {}\n-\n-  SubstitutionArg &operator= (const SubstitutionArg &other)\n-  {\n-    param = other.param;\n-    argument = other.argument;\n-    return *this;\n-  }\n-\n-  BaseType *get_tyty () { return argument; }\n-\n-  const BaseType *get_tyty () const { return argument; }\n-\n-  const SubstitutionParamMapping *get_param_mapping () const { return param; }\n-\n-  static SubstitutionArg error () { return SubstitutionArg (nullptr, nullptr); }\n-\n-  bool is_error () const { return param == nullptr || argument == nullptr; }\n-\n-  bool is_conrete () const\n-  {\n-    if (argument != nullptr)\n-      return true;\n-\n-    if (argument->get_kind () == TyTy::TypeKind::PARAM)\n-      return false;\n-\n-    return argument->is_concrete ();\n-  }\n-\n-  std::string as_string () const\n-  {\n-    return param->as_string ()\n-\t   + (argument != nullptr ? \":\" + argument->as_string () : \"\");\n-  }\n-\n-private:\n-  const SubstitutionParamMapping *param;\n-  BaseType *argument;\n-};\n-\n-typedef std::function<void (const ParamType &, const SubstitutionArg &)>\n-  ParamSubstCb;\n-class SubstitutionArgumentMappings\n-{\n-public:\n-  SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n-\t\t\t\tstd::map<std::string, BaseType *> binding_args,\n-\t\t\t\tLocation locus,\n-\t\t\t\tParamSubstCb param_subst_cb = nullptr,\n-\t\t\t\tbool trait_item_flag = false)\n-    : mappings (mappings), binding_args (binding_args), locus (locus),\n-      param_subst_cb (param_subst_cb), trait_item_flag (trait_item_flag)\n-  {}\n-\n-  SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n-    : mappings (other.mappings), binding_args (other.binding_args),\n-      locus (other.locus), param_subst_cb (other.param_subst_cb),\n-      trait_item_flag (other.trait_item_flag)\n-  {}\n-\n-  SubstitutionArgumentMappings &\n-  operator= (const SubstitutionArgumentMappings &other)\n-  {\n-    mappings = other.mappings;\n-    binding_args = other.binding_args;\n-    locus = other.locus;\n-    param_subst_cb = other.param_subst_cb;\n-    trait_item_flag = other.trait_item_flag;\n-\n-    return *this;\n-  }\n-\n-  SubstitutionArgumentMappings (SubstitutionArgumentMappings &&other) = default;\n-  SubstitutionArgumentMappings &operator= (SubstitutionArgumentMappings &&other)\n-    = default;\n-\n-  static SubstitutionArgumentMappings error ()\n-  {\n-    return SubstitutionArgumentMappings ({}, {}, Location (), nullptr, false);\n-  }\n-\n-  bool is_error () const { return mappings.size () == 0; }\n-\n-  bool get_argument_for_symbol (const ParamType *param_to_find,\n-\t\t\t\tSubstitutionArg *argument)\n-  {\n-    for (auto &mapping : mappings)\n-      {\n-\tconst SubstitutionParamMapping *param = mapping.get_param_mapping ();\n-\tconst ParamType *p = param->get_param_ty ();\n-\n-\tif (p->get_symbol ().compare (param_to_find->get_symbol ()) == 0)\n-\t  {\n-\t    *argument = mapping;\n-\t    return true;\n-\t  }\n-      }\n-    return false;\n-  }\n-\n-  bool get_argument_at (size_t index, SubstitutionArg *argument)\n-  {\n-    if (index > mappings.size ())\n-      return false;\n-\n-    *argument = mappings.at (index);\n-    return true;\n-  }\n-\n-  // is_concrete means if the used args is non error, ie: non empty this will\n-  // verify if actual real types have been put in place of are they still\n-  // ParamTy\n-  bool is_concrete () const\n-  {\n-    for (auto &mapping : mappings)\n-      {\n-\tif (!mapping.is_conrete ())\n-\t  return false;\n-      }\n-    return true;\n-  }\n-\n-  Location get_locus () const { return locus; }\n-\n-  size_t size () const { return mappings.size (); }\n-\n-  bool is_empty () const { return size () == 0; }\n-\n-  std::vector<SubstitutionArg> &get_mappings () { return mappings; }\n-\n-  const std::vector<SubstitutionArg> &get_mappings () const { return mappings; }\n-\n-  std::map<std::string, BaseType *> &get_binding_args ()\n-  {\n-    return binding_args;\n-  }\n-\n-  const std::map<std::string, BaseType *> &get_binding_args () const\n-  {\n-    return binding_args;\n-  }\n-\n-  std::string as_string () const\n-  {\n-    std::string buffer;\n-    for (auto &mapping : mappings)\n-      {\n-\tbuffer += mapping.as_string () + \", \";\n-      }\n-    return \"<\" + buffer + \">\";\n-  }\n-\n-  void on_param_subst (const ParamType &p, const SubstitutionArg &a) const\n-  {\n-    if (param_subst_cb == nullptr)\n-      return;\n-\n-    param_subst_cb (p, a);\n-  }\n-\n-  ParamSubstCb get_subst_cb () const { return param_subst_cb; }\n-\n-  bool trait_item_mode () const { return trait_item_flag; }\n-\n-private:\n-  std::vector<SubstitutionArg> mappings;\n-  std::map<std::string, BaseType *> binding_args;\n-  Location locus;\n-  ParamSubstCb param_subst_cb;\n-  bool trait_item_flag;\n-};\n-\n-class SubstitutionRef\n-{\n-public:\n-  SubstitutionRef (std::vector<SubstitutionParamMapping> substitutions,\n-\t\t   SubstitutionArgumentMappings arguments)\n-    : substitutions (substitutions), used_arguments (arguments)\n-  {}\n-\n-  bool has_substitutions () const { return substitutions.size () > 0; }\n-\n-  std::string subst_as_string () const\n-  {\n-    std::string buffer;\n-    for (size_t i = 0; i < substitutions.size (); i++)\n-      {\n-\tconst SubstitutionParamMapping &sub = substitutions.at (i);\n-\tbuffer += sub.as_string ();\n-\n-\tif ((i + 1) < substitutions.size ())\n-\t  buffer += \", \";\n-      }\n-\n-    return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n-  }\n-\n-  bool supports_associated_bindings () const\n-  {\n-    return get_num_associated_bindings () > 0;\n-  }\n-\n-  // this is overridden in TypeBoundPredicate\n-  // which support bindings we don't add them directly to the SubstitutionRef\n-  // base class because this class represents the fn<X: Foo, Y: Bar>. The only\n-  // construct which supports associated types\n-  virtual size_t get_num_associated_bindings () const { return 0; }\n-\n-  // this is overridden in TypeBoundPredicate\n-  virtual TypeBoundPredicateItem\n-  lookup_associated_type (const std::string &search)\n-  {\n-    return TypeBoundPredicateItem::error ();\n-  }\n-\n-  size_t get_num_substitutions () const { return substitutions.size (); }\n-\n-  std::vector<SubstitutionParamMapping> &get_substs () { return substitutions; }\n-\n-  const std::vector<SubstitutionParamMapping> &get_substs () const\n-  {\n-    return substitutions;\n-  }\n-\n-  std::vector<SubstitutionParamMapping> clone_substs () const\n-  {\n-    std::vector<SubstitutionParamMapping> clone;\n-\n-    for (auto &sub : substitutions)\n-      clone.push_back (sub.clone ());\n-\n-    return clone;\n-  }\n-\n-  void override_context ()\n-  {\n-    for (auto &sub : substitutions)\n-      {\n-\tsub.override_context ();\n-      }\n-  }\n-\n-  bool needs_substitution () const\n-  {\n-    for (auto &sub : substitutions)\n-      {\n-\tif (sub.need_substitution ())\n-\t  return true;\n-      }\n-    return false;\n-  }\n-\n-  bool was_substituted () const { return !needs_substitution (); }\n-\n-  SubstitutionArgumentMappings get_substitution_arguments () const\n-  {\n-    return used_arguments;\n-  }\n-\n-  // this is the count of type params that are not substituted fuly\n-  size_t num_required_substitutions () const\n-  {\n-    size_t n = 0;\n-    for (auto &p : substitutions)\n-      {\n-\tif (p.needs_substitution ())\n-\t  n++;\n-      }\n-    return n;\n-  }\n-\n-  // this is the count of type params that need substituted taking into account\n-  // possible defaults\n-  size_t min_required_substitutions () const\n-  {\n-    size_t n = 0;\n-    for (auto &p : substitutions)\n-      {\n-\tif (p.needs_substitution () && !p.param_has_default_ty ())\n-\t  n++;\n-      }\n-    return n;\n-  }\n-\n-  // We are trying to subst <i32, f32> into Struct Foo<X,Y> {}\n-  // in the case of Foo<i32,f32>{...}\n-  //\n-  // the substitions we have here define X,Y but the arguments have no bindings\n-  // so its a matter of ordering\n-  SubstitutionArgumentMappings\n-  get_mappings_from_generic_args (HIR::GenericArgs &args);\n-\n-  // Recursive substitutions\n-  // Foo <A,B> { a:A, b: B}; Bar <X,Y,Z>{a:X, b: Foo<Y,Z>}\n-  //\n-  // we have bindings for X Y Z and need to propagate the binding Y,Z into Foo\n-  // Which binds to A,B\n-  SubstitutionArgumentMappings\n-  adjust_mappings_for_this (SubstitutionArgumentMappings &mappings);\n-\n-  // Are the mappings here actually bound to this type. For example imagine the\n-  // case:\n-  //\n-  // struct Foo<T>(T);\n-  // impl<T> Foo<T> {\n-  //   fn test(self) { ... }\n-  // }\n-  //\n-  // In this case we have a generic ADT of Foo and an impl block of a generic T\n-  // on Foo for the Self type. When we it comes to path resolution we can have:\n-  //\n-  // Foo::<i32>::test()\n-  //\n-  // This means the first segment of Foo::<i32> returns the ADT Foo<i32> not the\n-  // Self ADT bound to the T from the impl block. This means when it comes to\n-  // the next segment of test which resolves to the function we need to check\n-  // wether the arguments in the struct definition of foo can be bound here\n-  // before substituting the previous segments type here. This functions acts as\n-  // a guard for the solve_mappings_from_receiver_for_self to handle the case\n-  // where arguments are not bound. This is important for this next case:\n-  //\n-  // struct Baz<A, B>(A, B);\n-  // impl Baz<i32, f32> {\n-  //   fn test<X>(a: X) -> X {\n-  //       a\n-  //   }\n-  // }\n-  //\n-  // In this case Baz has been already substituted for the impl's Self to become\n-  // ADT<i32, f32> so that the function test only has 1 generic argument of X.\n-  // The path for this will be:\n-  //\n-  // Baz::test::<_>(123)\n-  //\n-  // So the first segment here will be Baz<_, _> to try and infer the arguments\n-  // which will be taken from the impl's Self type in this case since it is\n-  // already substituted and like the previous case the check to see if we need\n-  // to inherit the previous segments generic arguments takes place but the\n-  // generic arguments are not bound to this type as they have already been\n-  // substituted.\n-  //\n-  // Its important to remember from the first example the FnType actually looks\n-  // like:\n-  //\n-  // fn <T>test(self :Foo<T>(T))\n-  //\n-  // As the generic parameters are \"bound\" to each of the items in the impl\n-  // block. So this check is about wether the arguments we have here can\n-  // actually be bound to this type.\n-  bool are_mappings_bound (SubstitutionArgumentMappings &mappings);\n-\n-  // struct Foo<A, B>(A, B);\n-  //\n-  // impl<T> Foo<T, f32>;\n-  //     -> fn test<X>(self, a: X) -> X\n-  //\n-  // We might invoke this via:\n-  //\n-  // a = Foo(123, 456f32);\n-  // b = a.test::<bool>(false);\n-  //\n-  // we need to figure out relevant generic arguemts for self to apply to the\n-  // fntype\n-  SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n-    SubstitutionArgumentMappings &mappings) const;\n-\n-  // TODO comment\n-  SubstitutionArgumentMappings\n-  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n-\n-  // TODO comment\n-  BaseType *infer_substitions (Location locus);\n-\n-  // TODO comment\n-  bool monomorphize ();\n-\n-  // TODO comment\n-  virtual BaseType *handle_substitions (SubstitutionArgumentMappings mappings)\n-    = 0;\n-\n-  SubstitutionArgumentMappings get_used_arguments () const\n-  {\n-    return used_arguments;\n-  }\n-\n-protected:\n-  std::vector<SubstitutionParamMapping> substitutions;\n-  SubstitutionArgumentMappings used_arguments;\n-};\n-\n class TypeBoundPredicate : public SubstitutionRef\n {\n public:"}]}