{"sha": "c76b3bc55b4603d38cc948f4076264af5c0b95aa", "node_id": "C_kwDOANBUbNoAKGM3NmIzYmM1NWI0NjAzZDM4Y2M5NDhmNDA3NjI2NGFmNWMwYjk1YWE", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-01-14T18:49:21Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-01-14T18:53:04Z"}, "message": "Fix reverse scalar storage order issues in IPA-SRA\n\nThe IPA-SRA pass introduced in GCC 10 does not always play nice with the\nreverse scalar storage order that can be used in structures/records/unions.\nReading the code, the pass apparently correctly detects it but fails to\npropagate the information to the rewriting phase in some cases and, in\nparticular, does not stream it for LTO.\n\ngcc/\n\t* ipa-param-manipulation.c (ipa_dump_adjusted_parameters): Dump\n\treverse flag as \"reverse\" for the sake of consistency.\n\t* ipa-sra.c: Fix copyright year.\n\t(ipa_sra_function_summaries::duplicate): Copy the reverse flag.\n\t(dump_isra_access): Tweak dump line.\n\t(isra_write_node_summary): Write the reverse flag.\n\t(isra_read_node_info): Read it.\n\t(pull_accesses_from_callee): Test its consistency and copy it.\n\ngcc/testsuite/\n\t* gnat.dg/lto25.adb: New test.\n\t* gnat.dg/opt96.adb: Likewise.\n\t* gnat.dg/opt96_pkg.ads, gnat.dg/opt96_pkg.adb: New helper.", "tree": {"sha": "b33fbef0a608638c445184716d20616b41ed26f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b33fbef0a608638c445184716d20616b41ed26f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c76b3bc55b4603d38cc948f4076264af5c0b95aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76b3bc55b4603d38cc948f4076264af5c0b95aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c76b3bc55b4603d38cc948f4076264af5c0b95aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c76b3bc55b4603d38cc948f4076264af5c0b95aa/comments", "author": null, "committer": null, "parents": [{"sha": "79ae13067f6afabcbae4784ada07dcbb7f00953e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79ae13067f6afabcbae4784ada07dcbb7f00953e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79ae13067f6afabcbae4784ada07dcbb7f00953e"}], "stats": {"total": 134, "additions": 105, "deletions": 29}, "files": [{"sha": "fa6815e094179712b644201aef15edb684552b84", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=c76b3bc55b4603d38cc948f4076264af5c0b95aa", "patch": "@@ -228,7 +228,7 @@ ipa_dump_adjusted_parameters (FILE *f,\n \t  fprintf (f, \" prefix: %s\",\n \t\t   ipa_param_prefixes[apm->param_prefix_index]);\n \t  if (apm->reverse)\n-\t    fprintf (f, \", reverse-sso\");\n+\t    fprintf (f, \", reverse\");\n \t  break;\n \t}\n       fprintf (f, \"\\n\");"}, {"sha": "f300a328f2b861a9486dad0c53ac49d337794a4f", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=c76b3bc55b4603d38cc948f4076264af5c0b95aa", "patch": "@@ -1,6 +1,5 @@\n /* Interprocedural scalar replacement of aggregates\n-   Copyright (C) 2008-2022 Free Software Foundation, Inc.\n-\n+   Copyright (C) 2019-2022 Free Software Foundation, Inc.\n    Contributed by Martin Jambor <mjambor@suse.cz>\n \n This file is part of GCC.\n@@ -21,7 +20,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* IPA-SRA is an interprocedural pass that removes unused function return\n    values (turning functions returning a value which is never used into void\n-   functions), removes unused function parameters.  It can also replace an\n+   functions) and removes unused function parameters.  It can also replace an\n    aggregate parameter by a set of other parameters representing part of the\n    original, turning those passed by reference into new ones which pass the\n    value directly.\n@@ -57,7 +56,6 @@ along with GCC; see the file COPYING3.  If not see\n    ipa-param-manipulation.h for more details.  */\n \n \n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -93,7 +91,7 @@ static void ipa_sra_summarize_function (cgraph_node *);\n #define ISRA_ARG_SIZE_LIMIT_BITS 16\n #define ISRA_ARG_SIZE_LIMIT (1 << ISRA_ARG_SIZE_LIMIT_BITS)\n /* How many parameters can feed into a call actual argument and still be\n-   tracked. */\n+   tracked.  */\n #define IPA_SRA_MAX_PARAM_FLOW_LEN 7\n \n /* Structure describing accesses to a specific portion of an aggregate\n@@ -122,7 +120,7 @@ struct GTY(()) param_access\n      transformed function - initially not set for portions of formal parameters\n      that are only used as actual function arguments passed to callees.  */\n   unsigned certain : 1;\n-  /* Set if the access has a reversed scalar storage order.  */\n+  /* Set if the access has reverse scalar storage order.  */\n   unsigned reverse : 1;\n };\n \n@@ -156,7 +154,7 @@ struct gensum_param_access\n      arguments to a function call that can be tracked.  */\n   bool nonarg;\n \n-  /* Set if the access has a reversed scalar storage order.  */\n+  /* Set if the access has reverse scalar storage order.  */\n   bool reverse;\n };\n \n@@ -219,8 +217,8 @@ struct gensum_param_desc\n };\n \n /* Properly deallocate accesses of DESC.  TODO: Since this data structure is\n-   not in GC memory, this is not necessary and we can consider removing the\n-   function.  */\n+   allocated in GC memory, this is not necessary and we can consider removing\n+   the function.  */\n \n static void\n free_param_decl_accesses (isra_param_desc *desc)\n@@ -275,9 +273,9 @@ class GTY((for_user)) isra_func_summary\n   unsigned m_queued : 1;\n };\n \n-/* Clean up and deallocate isra_func_summary points to.  TODO: Since this data\n-   structure is not in GC memory, this is not necessary and we can consider\n-   removing the destructor.  */\n+/* Deallocate the memory pointed to by isra_func_summary.  TODO: Since this\n+   data structure is allocated in GC memory, this is not necessary and we can\n+   consider removing the destructor.  */\n \n isra_func_summary::~isra_func_summary ()\n {\n@@ -287,7 +285,6 @@ isra_func_summary::~isra_func_summary ()\n   vec_free (m_parameters);\n }\n \n-\n /* Mark the function as not a candidate for any IPA-SRA transformation.  Return\n    true if it was a candidate until now.  */\n \n@@ -297,6 +294,7 @@ isra_func_summary::zap ()\n   bool ret = m_candidate;\n   m_candidate = false;\n \n+  /* TODO: see the destructor above.  */\n   unsigned len = vec_safe_length (m_parameters);\n   for (unsigned i = 0; i < len; ++i)\n     free_param_decl_accesses (&(*m_parameters)[i]);\n@@ -306,7 +304,7 @@ isra_func_summary::zap ()\n }\n \n /* Structure to describe which formal parameters feed into a particular actual\n-   arguments.  */\n+   argument.  */\n \n struct isra_param_flow\n {\n@@ -426,6 +424,7 @@ ipa_sra_function_summaries::duplicate (cgraph_node *, cgraph_node *,\n \t  to->unit_offset = from->unit_offset;\n \t  to->unit_size = from->unit_size;\n \t  to->certain = from->certain;\n+\t  to->reverse = from->reverse;\n \t  d->accesses->quick_push (to);\n \t}\n     }\n@@ -552,7 +551,7 @@ namespace {\n \n hash_map<tree, gensum_param_desc *> *decl2desc;\n \n-/* Countdown of allowed Alias analysis steps during summary building.  */\n+/* Countdown of allowed Alias Analysis steps during summary building.  */\n \n int aa_walking_limit;\n \n@@ -665,7 +664,7 @@ dump_isra_access (FILE *f, param_access *access)\n   if (access->certain)\n     fprintf (f, \", certain\");\n   else\n-    fprintf (f, \", not-certain\");\n+    fprintf (f, \", not certain\");\n   if (access->reverse)\n     fprintf (f, \", reverse\");\n   fprintf (f, \"\\n\");\n@@ -927,8 +926,7 @@ isra_track_scalar_value_uses (function *fun, cgraph_node *node, tree name,\n \n    This function is similar to ptr_parm_has_nonarg_uses but its results are\n    meant for unused parameter removal, as opposed to splitting of parameters\n-   passed by reference or converting them to passed by value.\n-  */\n+   passed by reference or converting them to passed by value.  */\n \n static bool\n isra_track_scalar_param_local_uses (function *fun, cgraph_node *node, tree parm,\n@@ -968,8 +966,7 @@ isra_track_scalar_param_local_uses (function *fun, cgraph_node *node, tree parm,\n    This function is similar to isra_track_scalar_param_local_uses but its\n    results are meant for splitting of parameters passed by reference or turning\n    them into bits passed by value, as opposed to generic unused parameter\n-   removal.\n- */\n+   removal.  */\n \n static bool\n ptr_parm_has_nonarg_uses (cgraph_node *node, function *fun, tree parm,\n@@ -1650,7 +1647,7 @@ record_nonregister_call_use (gensum_param_desc *desc,\n }\n \n /* Callback of walk_aliased_vdefs, just mark that there was a possible\n-   modification. */\n+   modification.  */\n \n static bool\n mark_maybe_modified (ao_ref *, tree, void *data)\n@@ -2195,7 +2192,7 @@ static bool\n check_gensum_access (tree parm, gensum_param_desc *desc,\n \t\t     gensum_param_access *access,\n \t\t     HOST_WIDE_INT *nonarg_acc_size, bool *only_calls,\n-\t\t      int entry_bb_index)\n+\t\t     int entry_bb_index)\n {\n   if (access->nonarg)\n     {\n@@ -2363,8 +2360,8 @@ process_scan_results (cgraph_node *node, struct function *fun,\n      offset in this function at IPA level.\n \n      TODO: Measure the overhead and the effect of just being pessimistic.\n-     Maybe this is only -O3 material?\n-  */\n+     Maybe this is only -O3 material?  */\n+\n   bool pdoms_calculated = false;\n   if (check_pass_throughs)\n     for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n@@ -2584,6 +2581,7 @@ isra_write_node_summary (output_block *ob, cgraph_node *node)\n \t  streamer_write_uhwi (ob, acc->unit_size);\n \t  bitpack_d bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, acc->certain, 1);\n+\t  bp_pack_value (&bp, acc->reverse, 1);\n \t  streamer_write_bitpack (&bp);\n \t}\n       streamer_write_uhwi (ob, desc->param_size_limit);\n@@ -2702,6 +2700,7 @@ isra_read_node_info (struct lto_input_block *ib, cgraph_node *node,\n \t  acc->unit_size = streamer_read_uhwi (ib);\n \t  bitpack_d bp = streamer_read_bitpack (ib);\n \t  acc->certain = bp_unpack_value (&bp, 1);\n+\t  acc->reverse = bp_unpack_value (&bp, 1);\n \t  vec_safe_push (desc->accesses, acc);\n \t}\n       desc->param_size_limit = streamer_read_uhwi (ib);\n@@ -3161,7 +3160,7 @@ isra_mark_caller_param_used (isra_func_summary *from_ifs, int input_idx,\n \n /* Propagate information that any parameter is not used only locally within a\n    SCC across CS to the caller, which must be in the same SCC as the\n-   callee. Push any callers that need to be re-processed to STACK.  */\n+   callee.  Push any callers that need to be re-processed to STACK.  */\n \n static void\n propagate_used_across_scc_edge (cgraph_edge *cs, vec<cgraph_node *> *stack)\n@@ -3199,7 +3198,7 @@ propagate_used_across_scc_edge (cgraph_edge *cs, vec<cgraph_node *> *stack)\n \n /* Propagate information that any parameter is not used only locally within a\n    SCC (i.e. is used also elsewhere) to all callers of NODE that are in the\n-   same SCC. Push any callers that need to be re-processed to STACK.  */\n+   same SCC.  Push any callers that need to be re-processed to STACK.  */\n \n static bool\n propagate_used_to_scc_callers (cgraph_node *node, void *data)\n@@ -3292,7 +3291,8 @@ pull_accesses_from_callee (cgraph_node *caller, isra_param_desc *param_desc,\n \t      && pacc->unit_size == argacc->unit_size)\n \t    {\n \t      if (argacc->alias_ptr_type != pacc->alias_ptr_type\n-\t\t  || !types_compatible_p (argacc->type, pacc->type))\n+\t\t  || !types_compatible_p (argacc->type, pacc->type)\n+\t\t  || argacc->reverse != pacc->reverse)\n \t\treturn \"propagated access types would not match existing ones\";\n \n \t      exact_match = true;\n@@ -3349,6 +3349,7 @@ pull_accesses_from_callee (cgraph_node *caller, isra_param_desc *param_desc,\n \t  copy->type = argacc->type;\n \t  copy->alias_ptr_type = argacc->alias_ptr_type;\n \t  copy->certain = true;\n+\t  copy->reverse = argacc->reverse;\n \t  vec_safe_push (param_desc->accesses, copy);\n \t}\n       else if (prop_kinds[j] == ACC_PROP_CERTAIN)\n@@ -3610,7 +3611,6 @@ retval_used_p (cgraph_node *node, void *)\n    PREV_ADJUSTMENT.  If the parent clone is the original function,\n    PREV_ADJUSTMENT is NULL and PREV_CLONE_INDEX is equal to BASE_INDEX.  */\n \n-\n static void\n push_param_adjustments_for_index (isra_func_summary *ifs, unsigned base_index,\n \t\t\t\t  unsigned prev_clone_index,"}, {"sha": "242c8d68650e7b6b6faf0d446fa91d91add7bb3b", "filename": "gcc/testsuite/gnat.dg/lto25.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Flto25.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Flto25.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Flto25.adb?ref=c76b3bc55b4603d38cc948f4076264af5c0b95aa", "patch": "@@ -0,0 +1,14 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2 -flto\" { target lto } }\n+\n+with Opt96_Pkg; use Opt96_Pkg;\n+\n+procedure Lto25 is\n+   R : Rec;\n+   D : Data;\n+begin\n+   D.Foo.Bar := (0.02, 0.01);\n+   if R.F (D) /= 30 then\n+     raise Program_Error;\n+   end if;\n+end;"}, {"sha": "d91368b93f7f2e505db96e2db19c39d88749cbe9", "filename": "gcc/testsuite/gnat.dg/opt96.adb", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96.adb?ref=c76b3bc55b4603d38cc948f4076264af5c0b95aa", "patch": "@@ -0,0 +1,14 @@\n+-- { dg-do run }\n+-- { dg-options \"-O2\" }\n+\n+with Opt96_Pkg; use Opt96_Pkg;\n+\n+procedure Opt96 is\n+   R : Rec;\n+   D : Data;\n+begin\n+   D.Foo.Bar := (0.02, 0.01);\n+   if R.F (D) /= 30 then\n+     raise Program_Error;\n+   end if;\n+end;"}, {"sha": "60fdb0deb847b12c774ca96f6df9069bb67dd453", "filename": "gcc/testsuite/gnat.dg/opt96_pkg.adb", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96_pkg.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96_pkg.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96_pkg.adb?ref=c76b3bc55b4603d38cc948f4076264af5c0b95aa", "patch": "@@ -0,0 +1,16 @@\n+package body Opt96_Pkg is\n+\n+   function F (D : Data) return Integer is\n+      X : constant Long_Float := Long_Float (D.Foo.Bar.X);\n+      Y : constant Long_Float := Long_Float (D.Foo.Bar.Y);\n+   begin\n+      return Integer ((X * 1000.0) + (Y * 1000.0));\n+   end;\n+\n+   function F (Self : Rec; D  : Data'Class) return Integer is\n+      Base_Data : constant Data := Data (D);\n+   begin\n+      return F (Base_Data);\n+   end;\n+\n+end Opt96_Pkg;"}, {"sha": "7939c386ada8f650437910d59c8c619c16a5f27a", "filename": "gcc/testsuite/gnat.dg/opt96_pkg.ads", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c76b3bc55b4603d38cc948f4076264af5c0b95aa/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt96_pkg.ads?ref=c76b3bc55b4603d38cc948f4076264af5c0b95aa", "patch": "@@ -0,0 +1,32 @@\n+with System;\n+\n+package Opt96_Pkg is\n+\n+   type Baz_Type is delta (1.0 / 2.0**16) range 0.0 .. 1.0 - (1.0 / 2.0**16);\n+   for Baz_Type'Small use (1.0 / 2.0**16);\n+   for Baz_Type'Size use 16;\n+\n+   type Bar_Type is record\n+     X : Baz_Type;\n+     Y : Baz_Type;\n+   end record;\n+   for Bar_Type use record\n+     X at 0 range 0 .. 15;\n+     Y at 2 range 0 .. 15;\n+   end record;\n+   for Bar_Type'Bit_Order use System.High_Order_First;\n+   for Bar_Type'Scalar_Storage_Order use System.High_Order_First;\n+\n+   type Foo_Type is record\n+      Bar : Bar_Type;\n+   end record;\n+\n+   type Data is tagged record\n+     Foo : Foo_Type;\n+   end record;\n+\n+   type Rec is tagged null record;\n+\n+   function F (Self : Rec; D  : Data'Class) return Integer;\n+\n+end Opt96_Pkg;"}]}