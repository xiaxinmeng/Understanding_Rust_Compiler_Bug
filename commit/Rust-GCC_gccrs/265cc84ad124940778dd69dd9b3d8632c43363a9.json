{"sha": "265cc84ad124940778dd69dd9b3d8632c43363a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY1Y2M4NGFkMTI0OTQwNzc4ZGQ2OWRkOWIzZDg2MzJjNDMzNjNhOQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-11T22:24:26Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-03-11T22:24:26Z"}, "message": "Initial revision\n\nFrom-SVN: r443", "tree": {"sha": "7ad603bbe9791a5b5a390f58a41f5e00ae7e4934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ad603bbe9791a5b5a390f58a41f5e00ae7e4934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/265cc84ad124940778dd69dd9b3d8632c43363a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265cc84ad124940778dd69dd9b3d8632c43363a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/265cc84ad124940778dd69dd9b3d8632c43363a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/265cc84ad124940778dd69dd9b3d8632c43363a9/comments", "author": null, "committer": null, "parents": [{"sha": "ad3f8945c508a5eb8ef07d9056482efef4f29887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad3f8945c508a5eb8ef07d9056482efef4f29887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad3f8945c508a5eb8ef07d9056482efef4f29887"}], "stats": {"total": 444, "additions": 444, "deletions": 0}, "files": [{"sha": "1adbb7a4c876b330fb11a93a87945bcc6edcd8bc", "filename": "gcc/xcoffout.c", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/265cc84ad124940778dd69dd9b3d8632c43363a9/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/265cc84ad124940778dd69dd9b3d8632c43363a9/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=265cc84ad124940778dd69dd9b3d8632c43363a9", "patch": "@@ -0,0 +1,444 @@\n+/* Output xcoff-format symbol table information from GNU compiler.\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Output xcoff-format symbol table data.  The main functionality is contained\n+   in dbxout.c.  This file implements the sdbout-like parts of the xcoff\n+   interface.  Many functions are very similar to their counterparts in\n+   sdbout.c.  */\n+\n+/* Include this first, because it may define MIN and MAX.  */\n+#include <stdio.h>\n+\n+#include \"config.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"flags.h\"\n+\n+#ifdef XCOFF_DEBUGGING_INFO\n+\n+/* This defines the C_* storage classes.  */\n+#include <dbxstclass.h>\n+\n+#include \"xcoff.h\"\n+\n+#ifdef USG\n+#include \"gstab.h\"\n+#else\n+#include <stab.h>\n+\n+/* This is a GNU extension we need to reference in this file.  */\n+#ifndef N_CATCH\n+#define N_CATCH 0x54\n+#endif\n+#endif\n+\n+/* These are GNU extensions we need to reference in this file.  */\n+#ifndef N_DSLINE\n+#define N_DSLINE 0x46\n+#endif\n+#ifndef N_BSLINE\n+#define N_BSLINE 0x48\n+#endif\n+\n+/* Line number of beginning of current function, minus one.\n+   Negative means not in a function or not using xcoff.  */\n+\n+int xcoff_begin_function_line = -1;\n+\n+/* Name of the current include file.  */\n+\n+char *xcoff_current_include_file;\n+\n+/* Name of the current function file.  This is the file the `.bf' is\n+   emitted from.  In case a line is emitted from a different file,\n+   (by including that file of course), then the line number will be\n+   absolute.  */\n+\n+char *xcoff_current_function_file;\n+\n+/* Names of bss and data sections.  These should be unique names for each\n+   compilation unit.  */\n+\n+char *xcoff_bss_section_name;\n+char *xcoff_private_data_section_name;\n+char *xcoff_read_only_section_name;\n+\f\n+/* Macro definitions used below.  */\n+/* Ensure we don't output a negative line number.  */\n+#define MAKE_LINE_SAFE(LINE)  \\\n+  if (LINE <= xcoff_begin_function_line)\t\\\n+    LINE = xcoff_begin_function_line + 1\t\\\n+\n+#define ASM_OUTPUT_LFB(FILE,LINENUM) \\\n+{\t\t\t\t\t\t\\\n+  if (xcoff_begin_function_line == -1)\t\t\\\n+    {\t\t\t\t\t\t\\\n+      xcoff_begin_function_line = (LINENUM) - 1;\\\n+      fprintf (FILE, \"\\t.bf\\t%d\\n\", (LINENUM));\t\\\n+    }\t\t\t\t\t\t\\\n+  xcoff_current_function_file\t\t\t\\\n+    = (xcoff_current_include_file\t\t\\\n+       ? xcoff_current_include_file : main_input_filename); \\\n+}\n+\n+#define ASM_OUTPUT_LFE(FILE,LINENUM) \\\n+  do {\t\t\t\t\t\t\\\n+    int linenum = LINENUM;\t\t\t\t\\\n+    MAKE_LINE_SAFE (linenum);\t\t\t\\\n+    fprintf (FILE, \"\\t.ef\\t%d\\n\", ABS_OR_RELATIVE_LINENO (linenum)); \\\n+    xcoff_begin_function_line = -1;\t\t\\\n+  } while (0)\n+\n+#define ASM_OUTPUT_LBB(FILE,LINENUM,BLOCKNUM) \\\n+  do {\t\t\t\t\t\t\\\n+    int linenum = LINENUM;\t\t\t\t\\\n+    MAKE_LINE_SAFE (linenum);\t\t\t\\\n+    fprintf (FILE, \"\\t.bb\\t%d\\n\", ABS_OR_RELATIVE_LINENO (linenum)); \\\n+  } while (0)\n+\n+#define ASM_OUTPUT_LBE(FILE,LINENUM,BLOCKNUM) \\\n+  do {\t\t\t\t\t\t\\\n+    int linenum = LINENUM;\t\t\t\t\\\n+    MAKE_LINE_SAFE (linenum);\t\t\t\\\n+    fprintf (FILE, \"\\t.eb\\t%d\\n\", ABS_OR_RELATIVE_LINENO (linenum)); \\\n+  } while (0)\n+\f\n+/* Support routines for XCOFF debugging info.  */\n+\n+/* Assign NUMBER as the stabx type number for the type described by NAME.\n+   Search all decls in the list SYMS to find the type NAME.  */\n+\n+static void\n+assign_type_number (syms, name, number)\n+     tree syms;\n+     char *name;\n+     int number;\n+{\n+  tree decl;\n+\n+  for (decl = syms; decl; decl = TREE_CHAIN (decl))\n+    if (!strcmp (IDENTIFIER_POINTER (DECL_NAME (decl)), name))\n+      {\n+\tTREE_ASM_WRITTEN (decl) = 1;\n+\tTYPE_SYMTAB_ADDRESS (TREE_TYPE (decl)) = number;\n+      }\n+}\n+\n+/* Setup gcc primitive types to use the XCOFF built-in type numbers where\n+   possible.  */\n+\n+void\n+xcoff_output_standard_types (syms)\n+     tree syms;\n+{\n+  /* Handle built-in C types here.  */\n+\n+  assign_type_number (syms, \"int\", -1);\n+  assign_type_number (syms, \"char\", -2);\n+  assign_type_number (syms, \"short int\", -3);\n+  assign_type_number (syms, \"long int\", -4);\n+  assign_type_number (syms, \"unsigned char\", -5);\n+  assign_type_number (syms, \"signed char\", -6);\n+  assign_type_number (syms, \"short unsigned int\", -7);\n+  assign_type_number (syms, \"unsigned int\", -8);\n+  /* No such type \"unsigned\".  */\n+  assign_type_number (syms, \"long unsigned int\", -10);\n+  assign_type_number (syms, \"void\", -11);\n+  assign_type_number (syms, \"float\", -12);\n+  assign_type_number (syms, \"double\", -13);\n+  assign_type_number (syms, \"long double\", -14);\n+  /* Pascal and Fortran types run from -15 to -29.  */\n+  /* No such type \"wchar\".  */\n+\n+  /* \"long long int\", and \"long long unsigned int\", are not handled here,\n+     because there are no predefined types that match them.  */\n+\n+  /* ??? Should also handle built-in C++ and Obj-C types.  There perhaps\n+     aren't any that C doesn't already have.  */\n+}\n+\n+/* Print an error message for unrecognized stab codes.  */\n+\n+#define UNKNOWN_STAB(STR)\t\\\n+   do { \\\n+     fprintf(stderr, \"Error, unknown stab %s: : 0x%x\\n\", STR, stab); \\\n+     fflush (stderr);\t\\\n+   } while (0)\n+\n+/* Conversion routine from BSD stabs to AIX storage classes.  */\n+\n+int\n+stab_to_sclass (stab)\n+     int stab;\n+{\n+  switch (stab)\n+    {\n+    case N_GSYM:\n+      return C_GSYM;\n+\n+    case N_FNAME:\n+      UNKNOWN_STAB (\"N_FNAME\"); \n+      abort();\n+\n+    case N_FUN:\n+      return C_FUN;\n+\n+    case N_STSYM:\n+    case N_LCSYM:\n+      return C_STSYM;\n+\n+    case N_MAIN:\n+      UNKNOWN_STAB (\"N_MAIN\"); \n+      abort ();\n+\n+    case N_RSYM:\n+      return C_RSYM;\n+\n+    case N_SSYM:\n+      UNKNOWN_STAB (\"N_SSYM\"); \n+      abort ();\n+\n+    case N_RPSYM:\n+      return C_RPSYM;\n+\n+    case N_PSYM:\n+      return C_PSYM;\n+    case N_LSYM:\n+      return C_LSYM;\n+    case N_DECL:\n+      return C_DECL;\n+    case N_ENTRY:\n+      return C_ENTRY;\n+\n+    case N_SO:\n+      UNKNOWN_STAB (\"N_SO\"); \n+      abort ();\n+\n+    case N_SOL:\n+      UNKNOWN_STAB (\"N_SOL\"); \n+      abort ();\n+\n+    case N_SLINE:\n+      UNKNOWN_STAB (\"N_SLINE\"); \n+      abort ();\n+\n+    case N_DSLINE:\n+      UNKNOWN_STAB (\"N_DSLINE\"); \n+      abort ();\n+\n+    case N_BSLINE:\n+      UNKNOWN_STAB (\"N_BSLINE\"); \n+      abort ();\n+#if 0\n+      /* This has the same value as N_BSLINE.  */\n+    case N_BROWS:\n+      UNKNOWN_STAB (\"N_BROWS\"); \n+      abort ();\n+#endif\n+\n+    case N_BINCL:\n+      UNKNOWN_STAB (\"N_BINCL\"); \n+      abort ();\n+\n+    case N_EINCL:\n+      UNKNOWN_STAB (\"N_EINCL\"); \n+      abort ();\n+\n+    case N_EXCL:\n+      UNKNOWN_STAB (\"N_EXCL\"); \n+      abort ();\n+\n+    case N_LBRAC:\n+      UNKNOWN_STAB (\"N_LBRAC\"); \n+      abort ();\n+\n+    case N_RBRAC:\n+      UNKNOWN_STAB (\"N_RBRAC\"); \n+      abort ();\n+\n+    case N_BCOMM:\n+      return C_BCOMM;\n+    case N_ECOMM:\n+      return C_ECOMM;\n+    case N_ECOML:\n+      return C_ECOML;\n+\n+    case N_LENG:\n+      UNKNOWN_STAB (\"N_LENG\"); \n+      abort ();\n+\n+    case N_PC:\n+      UNKNOWN_STAB (\"N_PC\"); \n+      abort ();\n+\n+    case N_M2C:\n+      UNKNOWN_STAB (\"N_M2C\"); \n+      abort ();\n+\n+    case N_SCOPE:\n+      UNKNOWN_STAB (\"N_SCOPE\"); \n+      abort ();\n+\n+    case N_CATCH:\n+      UNKNOWN_STAB (\"N_CATCH\"); \n+      abort ();\n+\n+    default:\n+      UNKNOWN_STAB (\"default\"); \n+      abort ();\n+  }\n+}\n+\n+/* In XCOFF, we have to have this .bf before the function prologue.\n+   Rely on the value of `dbx_begin_function_line' not to duplicate .bf.  */\n+\n+void\n+xcoffout_output_first_source_line (file, last_linenum)\n+     FILE *file;\n+     int last_linenum;\n+{\n+  ASM_OUTPUT_LFB (file, last_linenum);\n+  dbxout_parms (DECL_ARGUMENTS (current_function_decl));\n+  ASM_OUTPUT_SOURCE_LINE (file, last_linenum);\n+}\n+\n+/* Output the symbols defined in block number DO_BLOCK.\n+   Set NEXT_BLOCK_NUMBER to 0 before calling.\n+\n+   This function works by walking the tree structure of blocks,\n+   counting blocks until it finds the desired block.  */\n+\n+static int do_block = 0;\n+\n+static int next_block_number;\n+\n+static void\n+xcoffout_block (block, depth, args)\n+     register tree block;\n+     int depth;\n+     tree args;\n+{\n+  while (block)\n+    {\n+      /* Ignore blocks never expanded or otherwise marked as real.  */\n+      if (TREE_USED (block))\n+\t{\n+\t  /* When we reach the specified block, output its symbols.  */\n+\t  if (next_block_number == do_block)\n+\t    {\n+\t      /* Output the syms of the block.  */\n+\t      if (debug_info_level != DINFO_LEVEL_TERSE || depth == 0)\n+\t\tdbxout_syms (BLOCK_VARS (block));\n+\t      if (args)\n+\t\tdbxout_reg_parms (args);\n+\n+\t      /* We are now done with the block.  Don't go to inner blocks.  */\n+\t      return;\n+\t    }\n+\t  /* If we are past the specified block, stop the scan.  */\n+\t  else if (next_block_number >= do_block)\n+\t    return;\n+\n+\t  next_block_number++;\n+\n+\t  /* Output the subblocks.  */\n+\t  xcoffout_block (BLOCK_SUBBLOCKS (block), depth + 1, 0);\n+\t}\n+      block = BLOCK_CHAIN (block);\n+    }\n+}\n+\n+/* Describe the beginning of an internal block within a function.\n+   Also output descriptions of variables defined in this block.\n+\n+   N is the number of the block, by order of beginning, counting from 1,\n+   and not counting the outermost (function top-level) block.\n+   The blocks match the BLOCKs in DECL_INITIAL (current_function_decl),\n+   if the count starts at 0 for the outermost one.  */\n+\n+void\n+xcoffout_begin_block (file, line, n)\n+     FILE *file;\n+     int line;\n+     int n;\n+{\n+  tree decl = current_function_decl;\n+\n+  ASM_OUTPUT_LBB (file, line, n);\n+\n+  do_block = n;\n+  next_block_number = 0;\n+  xcoffout_block (DECL_INITIAL (decl), 0, DECL_ARGUMENTS (decl));\n+}\n+\n+/* Describe the end line-number of an internal block within a function.  */\n+\n+void\n+xcoffout_end_block (file, line, n)\n+     FILE *file;\n+     int line;\n+     int n;\n+{\n+  ASM_OUTPUT_LBE (file, line, n);\n+}\n+\n+/* Called at beginning of function body (after prologue).\n+   Record the function's starting line number, so we can output\n+   relative line numbers for the other lines.\n+   Record the file name that this function is contained in.  */\n+\n+void\n+xcoffout_begin_function (file, last_linenum)\n+     FILE *file;\n+     int last_linenum;\n+{\n+  ASM_OUTPUT_LFB (file, last_linenum);\n+}\n+\n+/* Called at end of function (before epilogue).\n+   Describe end of outermost block.  */\n+\n+void\n+xcoffout_end_function (file, last_linenum)\n+     FILE *file;\n+     int last_linenum;\n+{\n+  ASM_OUTPUT_LFE (file, last_linenum);\n+}\n+\n+/* Output xcoff info for the absolute end of a function.\n+   Called after the epilogue is output.  */\n+\n+void\n+xcoffout_end_epilogue (file)\n+     FILE *file;\n+{\n+  /* We need to pass the correct function size to .function, otherwise,\n+     the xas assembler can't figure out the correct size for the function\n+     aux entry.  So, we emit a label after the last instruction which can\n+     be used by the .function psuedo op to calculate the function size.  */\n+\n+  char *fname = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  if (*fname == '*')\n+    ++fname;\n+  fprintf (file, \"L..end_\");\n+  ASM_OUTPUT_LABEL (file, fname);\n+}\n+#endif /* XCOFF_DEBUGGING_INFO */"}]}