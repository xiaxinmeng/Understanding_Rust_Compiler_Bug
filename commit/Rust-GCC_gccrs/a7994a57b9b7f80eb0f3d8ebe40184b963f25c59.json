{"sha": "a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc5OTRhNTdiOWI3ZjgwZWIwZjNkOGViZTQwMTg0Yjk2M2YyNWM1OQ==", "commit": {"author": {"name": "Ramana Radhakrishnan", "email": "ramana.radhakrishnan@arm.com", "date": "2009-05-20T05:40:17Z"}, "committer": {"name": "Ramana Radhakrishnan", "email": "ramana@gcc.gnu.org", "date": "2009-05-20T05:40:17Z"}, "message": "Fix Thumb2 bic orn\n\n2009-05-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n    \n\t* config/arm/arm.md (*arm_iorsi3): Refactored for only ARM.\n        (peephole ior (reg, int) -> mov, ior): Refactored for only ARM.\n        * config/arm/thumb2.md (*thumb_andsi_not_shiftsi_si): Allow bic\n        with shifts for Thumb2.\n        (orsi_notsi): New for orn.\n        (*thumb_orsi_notshiftsi_si): Allow orn with shifts.\n        (*thumb2_iorsi3): Rewrite support for iorsi for Thumb2.\n        * config/arm/arm.c (const_ok_for_op): Split case for IOR for\n        Thumb2.\n        (arm_gen_constant): Set can_invert for IOR and Thumb2, Add\n        comments. Don't invert remainder for IOR.\n\nFrom-SVN: r147729", "tree": {"sha": "07ff4c1506b8be5787e9300cdec1fc410507712f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07ff4c1506b8be5787e9300cdec1fc410507712f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/comments", "author": null, "committer": null, "parents": [{"sha": "875d0f10a6fb79b1b4387baedeae9a21bc0b14a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/875d0f10a6fb79b1b4387baedeae9a21bc0b14a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/875d0f10a6fb79b1b4387baedeae9a21bc0b14a1"}], "stats": {"total": 110, "additions": 105, "deletions": 5}, "files": [{"sha": "b64bdcef28bc9640321606379f2d7bc95fa97660", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "patch": "@@ -1,3 +1,17 @@\n+2009-05-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n+    \n+\t* config/arm/arm.md (*arm_iorsi3): Refactored for only ARM.\n+        (peephole ior (reg, int) -> mov, ior): Refactored for only ARM.\n+        * config/arm/thumb2.md (*thumb_andsi_not_shiftsi_si): Allow bic\n+        with shifts for Thumb2.\n+        (orsi_notsi): New for orn.\n+        (*thumb_orsi_notshiftsi_si): Allow orn with shifts.\n+        (*thumb2_iorsi3): Rewrite support for iorsi for Thumb2.\n+        * config/arm/arm.c (const_ok_for_op): Split case for IOR for\n+        Thumb2.\n+        (arm_gen_constant): Set can_invert for IOR and Thumb2, Add\n+        comments. Don't invert remainder for IOR.\n+\t\n 2009-05-19  Zdenek Dvorak  <ook@ucw.cz>\n \n \tPR tree-optimization/40087"}, {"sha": "eda5ceaace9ccf561d7dde5e0a2c93e99ab7020f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "patch": "@@ -2008,7 +2008,11 @@ const_ok_for_op (HOST_WIDE_INT i, enum rtx_code code)\n \n     case MINUS:\t\t/* Should only occur with (MINUS I reg) => rsb */\n     case XOR:\n+      return 0;\n+\n     case IOR:\n+      if (TARGET_THUMB2)\n+\treturn const_ok_for_arm (ARM_SIGN_EXTEND (~i));\n       return 0;\n \n     case AND:\n@@ -2185,15 +2189,20 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t\t\t\t\t     GEN_INT (ARM_SIGN_EXTEND (val))));\n \t  return 1;\n \t}\n+\n       if (remainder == 0)\n \t{\n \t  if (reload_completed && rtx_equal_p (target, source))\n \t    return 0;\n+\n \t  if (generate)\n \t    emit_constant_insn (cond,\n \t\t\t\tgen_rtx_SET (VOIDmode, target, source));\n \t  return 1;\n \t}\n+\n+      if (TARGET_THUMB2)\n+\tcan_invert = 1;\n       break;\n \n     case AND:\n@@ -2281,6 +2290,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \n   /* Calculate a few attributes that may be useful for specific\n      optimizations.  */\n+  /* Count number of leading zeros.  */\n   for (i = 31; i >= 0; i--)\n     {\n       if ((remainder & (1 << i)) == 0)\n@@ -2289,6 +2299,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \tbreak;\n     }\n \n+  /* Count number of leading 1's.  */\n   for (i = 31; i >= 0; i--)\n     {\n       if ((remainder & (1 << i)) != 0)\n@@ -2297,6 +2308,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \tbreak;\n     }\n \n+  /* Count number of trailing zero's.  */\n   for (i = 0; i <= 31; i++)\n     {\n       if ((remainder & (1 << i)) == 0)\n@@ -2305,6 +2317,7 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \tbreak;\n     }\n \n+  /* Count number of trailing 1's.  */\n   for (i = 0; i <= 31; i++)\n     {\n       if ((remainder & (1 << i)) != 0)\n@@ -2492,6 +2505,17 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n       if (code == XOR)\n \tbreak;\n \n+      /*  Convert.\n+\t  x = y | constant ( which is composed of set_sign_bit_copies of leading 1s\n+\t                     and the remainder 0s for e.g. 0xfff00000)\n+\t  x = ~(~(y ashift set_sign_bit_copies) lshiftrt set_sign_bit_copies)\n+\n+\t  This can be done in 2 instructions by using shifts with mov or mvn.\n+\t  e.g. for\n+\t  x = x | 0xfff00000;\n+\t  we generate.\n+\t  mvn\tr0, r0, asl #12\n+\t  mvn\tr0, r0, lsr #12  */\n       if (set_sign_bit_copies > 8\n \t  && (val & (-1 << (32 - set_sign_bit_copies))) == val)\n \t{\n@@ -2517,6 +2541,16 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t  return 2;\n \t}\n \n+      /* Convert\n+\t  x = y | constant (which has set_zero_bit_copies number of trailing ones).\n+\t   to\n+\t  x = ~((~y lshiftrt set_zero_bit_copies) ashift set_zero_bit_copies).\n+\n+\t  For eg. r0 = r0 | 0xfff\n+\t       mvn\tr0, r0, lsr #12\n+\t       mvn\tr0, r0, asl #12\n+\n+      */\n       if (set_zero_bit_copies > 8\n \t  && (remainder & ((1 << set_zero_bit_copies) - 1)) == remainder)\n \t{\n@@ -2542,6 +2576,13 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n \t  return 2;\n \t}\n \n+      /* This will never be reached for Thumb2 because orn is a valid\n+\t instruction. This is for Thumb1 and the ARM 32 bit cases.\n+\n+\t x = y | constant (such that ~constant is a valid constant)\n+\t Transform this to\n+\t x = ~(~y & ~constant).\n+      */\n       if (const_ok_for_arm (temp1 = ARM_SIGN_EXTEND (~val)))\n \t{\n \t  if (generate)\n@@ -2651,7 +2692,8 @@ arm_gen_constant (enum rtx_code code, enum machine_mode mode, rtx cond,\n     if (remainder & (1 << i))\n       num_bits_set++;\n \n-  if (code == AND || (can_invert && num_bits_set > 16))\n+  if ((code == AND)\n+      || (code != IOR && can_invert && num_bits_set > 16))\n     remainder = (~remainder) & 0xffffffff;\n   else if (code == PLUS && num_bits_set > 16)\n     remainder = (-remainder) & 0xffffffff;"}, {"sha": "de78d2866f87061433bae1e71d2ca2c91e22891c", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "patch": "@@ -2615,11 +2615,11 @@\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r,r\")\n \t(ior:SI (match_operand:SI 1 \"s_register_operand\" \"r,r\")\n \t\t(match_operand:SI 2 \"reg_or_int_operand\" \"rI,?n\")))]\n-  \"TARGET_32BIT\"\n+  \"TARGET_ARM\"\n   \"@\n    orr%?\\\\t%0, %1, %2\n    #\"\n-  \"TARGET_32BIT\n+  \"TARGET_ARM\n    && GET_CODE (operands[2]) == CONST_INT\n    && !const_ok_for_arm (INTVAL (operands[2]))\"\n   [(clobber (const_int 0))]\n@@ -2646,7 +2646,7 @@\n    (set (match_operand:SI 0 \"arm_general_register_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"arm_general_register_operand\" \"\")\n \t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_32BIT\n+  \"TARGET_ARM\n    && !const_ok_for_arm (INTVAL (operands[2]))\n    && const_ok_for_arm (~INTVAL (operands[2]))\"\n   [(set (match_dup 3) (match_dup 2))"}, {"sha": "935ca08dd8797ae4377ae40aaf706af78fb2f6ae", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7994a57b9b7f80eb0f3d8ebe40184b963f25c59/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=a7994a57b9b7f80eb0f3d8ebe40184b963f25c59", "patch": "@@ -57,7 +57,7 @@\n \t\t\t [(match_operand:SI 2 \"s_register_operand\" \"r\")\n \t\t\t  (match_operand:SI 3 \"const_int_operand\" \"M\")]))\n \t\t(match_operand:SI 1 \"s_register_operand\" \"r\")))]\n-  \"TARGET_ARM\"\n+  \"TARGET_THUMB2\"\n   \"bic%?\\\\t%0, %1, %2%S4\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"shift\" \"2\")\n@@ -1252,3 +1252,47 @@\n    (set_attr \"length\" \"2\")]\n )\n \n+(define_insn \"orsi_notsi_si\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operand:SI 2 \"s_register_operand\" \"r\"))\n+\t\t(match_operand:SI 1 \"reg_or_int_operand\" \"rK\")))]\n+  \"TARGET_THUMB2\"\n+  \"orn%?\\\\t%0, %1, %2\"\n+  [(set_attr \"predicable\" \"yes\")]\n+)\n+\n+(define_insn \"*thumb_orsi_not_shiftsi_si\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(ior:SI (not:SI (match_operator:SI 4 \"shift_operator\"\n+\t\t\t [(match_operand:SI 2 \"s_register_operand\" \"r\")\n+\t\t\t  (match_operand:SI 3 \"const_int_operand\" \"M\")]))\n+\t\t(match_operand:SI 1 \"s_register_operand\" \"r\")))]\n+  \"TARGET_THUMB2\"\n+  \"orn%?\\\\t%0, %1, %2%S4\"\n+  [(set_attr \"predicable\" \"yes\")\n+   (set_attr \"shift\" \"2\")\n+   (set_attr \"type\" \"alu_shift\")]\n+)\n+\n+(define_insn_and_split \"*thumb2_iorsi3\"\n+  [(set (match_operand:SI         0 \"s_register_operand\" \"=r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"s_register_operand\" \"r,r,r\")\n+\t\t(match_operand:SI 2 \"reg_or_int_operand\" \"rI,K,?n\")))]\n+  \"TARGET_THUMB2\"\n+  \"@\n+   orr%?\\\\t%0, %1, %2\n+   orn%?\\\\t%0, %1, #%B2\n+   #\"\n+  \"TARGET_THUMB2\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && !(const_ok_for_arm (INTVAL (operands[2]))\n+\t|| const_ok_for_arm (~INTVAL (operands[2])))\"\n+  [(clobber (const_int 0))]\n+  \"\n+  arm_split_constant  (IOR, SImode, curr_insn, \n+\t               INTVAL (operands[2]), operands[0], operands[1], 0);\n+  DONE;\n+  \"\n+  [(set_attr \"length\" \"4,4,16\")\n+   (set_attr \"predicable\" \"yes\")]\n+)"}]}