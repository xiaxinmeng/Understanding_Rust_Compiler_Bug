{"sha": "ec77d61fe3a2b7882aaaae413b25aea878bed33d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWM3N2Q2MWZlM2EyYjc4ODJhYWFhZTQxM2IyNWFlYTg3OGJlZDMzZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-02-11T22:54:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-11T22:54:21Z"}, "message": "re PR lto/59468 (ICE on invalid C++ code with LTO in gimple_get_virt_method_for_binfo, at gimple-fold.c:3224)\n\n\n\tPR lto/59468\n\t* ipa-utils.h (possible_polymorphic_call_targets): Update prototype\n\tand wrapper.\n\t* ipa-devirt.c: Include demangle.h\n\t(odr_violation_reported): New static variable.\n\t(add_type_duplicate): Update odr_violations.\n\t(maybe_record_node): Add completep parameter; update it.\n\t(record_target_from_binfo): Add COMPLETEP parameter;\n\tupdate it as needed.\n\t(possible_polymorphic_call_targets_1): Likewise.\n\t(struct polymorphic_call_target_d): Add nonconstruction_targets;\n\trename FINAL to COMPLETE.\n\t(record_targets_from_bases): Sanity check we found the binfo;\n\tfix COMPLETEP updating.\n\t(possible_polymorphic_call_targets): Add NONCONSTRUTION_TARGETSP\n\tparameter, fix computing of COMPLETEP.\n\t(dump_possible_polymorphic_call_targets): Imrove readability of dump; at\n\tLTO time do demangling.\n\t(ipa_devirt): Use nonconstruction_targets; Improve dumps.\n\t* gimple-fold.c (gimple_get_virt_method_for_vtable): Add can_refer\n\tparameter.\n\t(gimple_get_virt_method_for_binfo): Likewise.\n\t* gimple-fold.h (gimple_get_virt_method_for_binfo,\n\tgimple_get_virt_method_for_vtable): Update prototypes.\n\n\tPR lto/59468\n\t* g++.dg/ipa/devirt-27.C: New testcase.\n\t* g++.dg/ipa/devirt-26.C: New testcase.\n\nFrom-SVN: r207702", "tree": {"sha": "9df630d2652c935d26cf3f91eb9ed4ef6e67f462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9df630d2652c935d26cf3f91eb9ed4ef6e67f462"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec77d61fe3a2b7882aaaae413b25aea878bed33d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec77d61fe3a2b7882aaaae413b25aea878bed33d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec77d61fe3a2b7882aaaae413b25aea878bed33d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec77d61fe3a2b7882aaaae413b25aea878bed33d/comments", "author": null, "committer": null, "parents": [{"sha": "5a4dcd9bd902ebef3542a89eb6d71e1913052354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a4dcd9bd902ebef3542a89eb6d71e1913052354", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a4dcd9bd902ebef3542a89eb6d71e1913052354"}], "stats": {"total": 371, "additions": 286, "deletions": 85}, "files": [{"sha": "9b501585f67325ede6b250609d7868465068c7db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -1,3 +1,30 @@\n+2014-02-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/59468\n+\t* ipa-utils.h (possible_polymorphic_call_targets): Update prototype\n+\tand wrapper.\n+\t* ipa-devirt.c: Include demangle.h\n+\t(odr_violation_reported): New static variable.\n+\t(add_type_duplicate): Update odr_violations.\n+\t(maybe_record_node): Add completep parameter; update it.\n+\t(record_target_from_binfo): Add COMPLETEP parameter;\n+\tupdate it as needed.\n+\t(possible_polymorphic_call_targets_1): Likewise.\n+\t(struct polymorphic_call_target_d): Add nonconstruction_targets;\n+\trename FINAL to COMPLETE.\n+\t(record_targets_from_bases): Sanity check we found the binfo;\n+\tfix COMPLETEP updating.\n+\t(possible_polymorphic_call_targets): Add NONCONSTRUTION_TARGETSP\n+\tparameter, fix computing of COMPLETEP.\n+\t(dump_possible_polymorphic_call_targets): Imrove readability of dump; at\n+\tLTO time do demangling.\n+\t(ipa_devirt): Use nonconstruction_targets; Improve dumps.\n+\t* gimple-fold.c (gimple_get_virt_method_for_vtable): Add can_refer\n+\tparameter.\n+\t(gimple_get_virt_method_for_binfo): Likewise.\n+\t* gimple-fold.h (gimple_get_virt_method_for_binfo,\n+\tgimple_get_virt_method_for_vtable): Update prototypes.\n+\n 2014-02-11  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR target/49008"}, {"sha": "01a16d38a928cb0e00f3f217fc9a4dcdd88f59c5", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -2660,7 +2660,6 @@ import_export_decl (tree decl)\n \t\t  comdat_p = (targetm.cxx.class_data_always_comdat ()\n \t\t\t      || (CLASSTYPE_KEY_METHOD (type)\n \t\t\t\t  && DECL_DECLARED_INLINE_P (CLASSTYPE_KEY_METHOD (type))));\n-\t\t  mark_needed (decl);\n \t\t  if (!flag_weak)\n \t\t    {\n \t\t      comdat_p = false;"}, {"sha": "5de44457aa80ca539ce4ec5989a0bf1e07ab6041", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -3170,22 +3170,35 @@ fold_const_aggregate_ref (tree t)\n }\n \n /* Lookup virtual method with index TOKEN in a virtual table V\n-   at OFFSET.  */\n+   at OFFSET.  \n+   Set CAN_REFER if non-NULL to false if method\n+   is not referable or if the virtual table is ill-formed (such as rewriten\n+   by non-C++ produced symbol). Otherwise just return NULL in that calse.  */\n \n tree\n gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n \t\t\t\t   tree v,\n-\t\t\t\t   unsigned HOST_WIDE_INT offset)\n+\t\t\t\t   unsigned HOST_WIDE_INT offset,\n+\t\t\t\t   bool *can_refer)\n {\n   tree vtable = v, init, fn;\n   unsigned HOST_WIDE_INT size;\n   unsigned HOST_WIDE_INT elt_size, access_index;\n   tree domain_type;\n \n+  if (can_refer)\n+    *can_refer = true;\n+\n   /* First of all double check we have virtual table.  */\n   if (TREE_CODE (v) != VAR_DECL\n       || !DECL_VIRTUAL_P (v))\n-    return NULL_TREE;\n+    {\n+      gcc_assert (in_lto_p);\n+      /* Pass down that we lost track of the target.  */\n+      if (can_refer)\n+\t*can_refer = false;\n+      return NULL_TREE;\n+    }\n \n   init = ctor_for_folding (v);\n \n@@ -3197,6 +3210,9 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n   if (init == error_mark_node)\n     {\n       gcc_assert (in_lto_p);\n+      /* Pass down that we lost track of the target.  */\n+      if (can_refer)\n+\t*can_refer = false;\n       return NULL_TREE;\n     }\n   gcc_checking_assert (TREE_CODE (TREE_TYPE (v)) == ARRAY_TYPE);\n@@ -3247,7 +3263,14 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n \t ends up in other partition, because we found devirtualization\n \t possibility too late.  */\n       if (!can_refer_decl_in_current_unit_p (fn, vtable))\n-\treturn NULL_TREE;\n+\t{\n+\t  if (can_refer)\n+\t    {\n+\t      *can_refer = false;\n+\t      return fn;\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n     }\n \n   /* Make sure we create a cgraph node for functions we'll reference.\n@@ -3261,10 +3284,14 @@ gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n /* Return a declaration of a function which an OBJ_TYPE_REF references. TOKEN\n    is integer form of OBJ_TYPE_REF_TOKEN of the reference expression.\n    KNOWN_BINFO carries the binfo describing the true type of\n-   OBJ_TYPE_REF_OBJECT(REF).  */\n+   OBJ_TYPE_REF_OBJECT(REF).\n+   Set CAN_REFER if non-NULL to false if method\n+   is not referable or if the virtual table is ill-formed (such as rewriten\n+   by non-C++ produced symbol). Otherwise just return NULL in that calse.  */\n \n tree\n-gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n+gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo,\n+\t\t\t\t  bool *can_refer)\n {\n   unsigned HOST_WIDE_INT offset;\n   tree v;\n@@ -3275,9 +3302,12 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n     return NULL_TREE;\n \n   if (!vtable_pointer_value_to_vtable (v, &v, &offset))\n-    return NULL_TREE;\n-\n-  return gimple_get_virt_method_for_vtable (token, v, offset);\n+    {\n+      if (can_refer)\n+\t*can_refer = false;\n+      return NULL_TREE;\n+    }\n+  return gimple_get_virt_method_for_vtable (token, v, offset, can_refer);\n }\n \n /* Return true iff VAL is a gimple expression that is known to be"}, {"sha": "6b430668528554c6e65a1b8a6f84c19363f1c04d", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -36,9 +36,11 @@ extern tree gimple_fold_stmt_to_constant_1 (gimple, tree (*) (tree));\n extern tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n extern tree fold_const_aggregate_ref (tree);\n-extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n+extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree,\n+\t\t\t\t\t      bool *can_refer = NULL);\n extern tree gimple_get_virt_method_for_vtable (HOST_WIDE_INT, tree,\n-\t\t\t\t\t       unsigned HOST_WIDE_INT);\n+\t\t\t\t\t       unsigned HOST_WIDE_INT,\n+\t\t\t\t\t       bool *can_refer = NULL);\n extern bool gimple_val_nonnegative_real_p (tree);\n extern tree gimple_fold_indirect_ref (tree);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);"}, {"sha": "21649cb214ccc8b876d2303979701285459b55b2", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 148, "deletions": 70, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -128,6 +128,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"diagnostic.h\"\n #include \"tree-dfa.h\"\n+#include \"demangle.h\"\n+\n+static bool odr_violation_reported = false;\n \n /* Dummy polymorphic call context.  */\n \n@@ -297,6 +300,7 @@ add_type_duplicate (odr_type val, tree type)\n       if (!types_compatible_p (val->type, type))\n \t{\n \t  merge = false;\n+\t  odr_violation_reported = true;\n \t  if (BINFO_VTABLE (TYPE_BINFO (val->type))\n \t      && warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n \t\t\t     \"type %qD violates one definition rule  \",\n@@ -332,6 +336,7 @@ add_type_duplicate (odr_type val, tree type)\n       if (base_mismatch)\n \t{\n \t  merge = false;\n+\t  odr_violation_reported = true;\n \n \t  if (warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (type)), 0,\n \t\t\t  \"type %qD violates one definition rule  \",\n@@ -594,17 +599,31 @@ build_type_inheritance_graph (void)\n }\n \n /* If TARGET has associated node, record it in the NODES array.\n-   if TARGET can not be inserted (for example because its body was\n-   already removed and there is no way to refer to it), clear COMPLETEP.  */\n+   CAN_REFER specify if program can refer to the target directly.\n+   if TARGET is unknown (NULL) or it can not be inserted (for example because\n+   its body was already removed and there is no way to refer to it), clear\n+   COMPLETEP.  */\n \n static void\n maybe_record_node (vec <cgraph_node *> &nodes,\n \t\t   tree target, pointer_set_t *inserted,\n+\t\t   bool can_refer,\n \t\t   bool *completep)\n {\n   struct cgraph_node *target_node;\n   enum built_in_function fcode;\n \n+  if (!can_refer)\n+    {\n+      /* The only case when method of anonymous namespace becomes unreferable\n+\t is when we completely optimized it out.  */\n+      if (flag_ltrans\n+\t  || !target \n+          || !type_in_anonymous_namespace_p (DECL_CONTEXT (target)))\n+\t*completep = false;\n+      return;\n+    }\n+\n   if (!target\n       /* Those are used to mark impossible scenarios.  */\n       || (fcode = DECL_FUNCTION_CODE (target))\n@@ -649,6 +668,8 @@ maybe_record_node (vec <cgraph_node *> &nodes,\n    inserted.\n \n    ANONYMOUS is true if BINFO is part of anonymous namespace.\n+\n+   Clear COMPLETEP when we hit unreferable target.\n   */\n \n static void\n@@ -661,7 +682,8 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \t\t\t  HOST_WIDE_INT offset,\n \t\t\t  pointer_set_t *inserted,\n \t\t\t  pointer_set_t *matched_vtables,\n-\t\t\t  bool anonymous)\n+\t\t\t  bool anonymous,\n+\t\t\t  bool *completep)\n {\n   tree type = BINFO_TYPE (binfo);\n   int i;\n@@ -692,6 +714,11 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n \treturn;\n       tree inner_binfo = get_binfo_at_offset (type_binfo,\n \t\t\t\t\t      offset, otr_type);\n+      if (!inner_binfo)\n+\t{\n+\t  gcc_assert (odr_violation_reported);\n+\t  return;\n+\t}\n       /* For types in anonymous namespace first check if the respective vtable\n \t is alive. If not, we know the type can't be called.  */\n       if (!flag_ltrans && anonymous)\n@@ -708,9 +735,11 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n       gcc_assert (inner_binfo);\n       if (!pointer_set_insert (matched_vtables, BINFO_VTABLE (inner_binfo)))\n \t{\n-\t  tree target = gimple_get_virt_method_for_binfo (otr_token, inner_binfo);\n-\t  if (target)\n-\t    maybe_record_node (nodes, target, inserted, NULL);\n+\t  bool can_refer;\n+\t  tree target = gimple_get_virt_method_for_binfo (otr_token,\n+\t\t\t\t\t\t\t  inner_binfo,\n+\t\t\t\t\t\t\t  &can_refer);\n+\t  maybe_record_node (nodes, target, inserted, can_refer, completep);\n \t}\n       return;\n     }\n@@ -722,15 +751,16 @@ record_target_from_binfo (vec <cgraph_node *> &nodes,\n       record_target_from_binfo (nodes, base_binfo, otr_type,\n \t\t\t\ttype_binfos, \n \t\t\t\totr_token, outer_type, offset, inserted,\n-\t\t\t\tmatched_vtables, anonymous);\n+\t\t\t\tmatched_vtables, anonymous, completep);\n   if (BINFO_VTABLE (binfo))\n     type_binfos.pop ();\n }\n      \n /* Lookup virtual methods matching OTR_TYPE (with OFFSET and OTR_TOKEN)\n    of TYPE, insert them to NODES, recurse into derived nodes. \n    INSERTED is used to avoid duplicate insertions of methods into NODES.\n-   MATCHED_VTABLES are used to avoid duplicate walking vtables.  */\n+   MATCHED_VTABLES are used to avoid duplicate walking vtables.\n+   Clear COMPLETEP if unreferable target is found.  */\n \n static void\n possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n@@ -740,7 +770,8 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n \t\t\t\t     odr_type type,\n \t\t\t\t     HOST_WIDE_INT otr_token,\n \t\t\t\t     tree outer_type,\n-\t\t\t\t     HOST_WIDE_INT offset)\n+\t\t\t\t     HOST_WIDE_INT offset,\n+\t\t\t\t     bool *completep)\n {\n   tree binfo = TYPE_BINFO (type->type);\n   unsigned int i;\n@@ -749,14 +780,14 @@ possible_polymorphic_call_targets_1 (vec <cgraph_node *> &nodes,\n   record_target_from_binfo (nodes, binfo, otr_type, type_binfos, otr_token,\n \t\t\t    outer_type, offset,\n \t\t\t    inserted, matched_vtables,\n-\t\t\t    type->anonymous_namespace);\n+\t\t\t    type->anonymous_namespace, completep);\n   type_binfos.release ();\n   for (i = 0; i < type->derived_types.length (); i++)\n     possible_polymorphic_call_targets_1 (nodes, inserted, \n \t\t\t\t\t matched_vtables,\n \t\t\t\t\t otr_type,\n \t\t\t\t\t type->derived_types[i],\n-\t\t\t\t\t otr_token, outer_type, offset);\n+\t\t\t\t\t otr_token, outer_type, offset, completep);\n }\n \n /* Cache of queries for polymorphic call targets.\n@@ -771,7 +802,8 @@ struct polymorphic_call_target_d\n   ipa_polymorphic_call_context context;\n   odr_type type;\n   vec <cgraph_node *> targets;\n-  bool final;\n+  int nonconstruction_targets;\n+  bool complete;\n };\n \n /* Polymorphic call target cache helpers.  */\n@@ -1282,7 +1314,7 @@ record_targets_from_bases (tree otr_type,\n \t\t\t   HOST_WIDE_INT otr_token,\n \t\t\t   tree outer_type,\n \t\t\t   HOST_WIDE_INT offset,\n-\t\t\t   vec <cgraph_node *> nodes,\n+\t\t\t   vec <cgraph_node *> &nodes,\n \t\t\t   pointer_set_t *inserted,\n \t\t\t   pointer_set_t *matched_vtables,\n \t\t\t   bool *completep)\n@@ -1303,7 +1335,9 @@ record_targets_from_bases (tree otr_type,\n \n \t  pos = int_bit_position (fld);\n \t  size = tree_to_shwi (DECL_SIZE (fld));\n-\t  if (pos <= offset && (pos + size) > offset)\n+\t  if (pos <= offset && (pos + size) > offset\n+\t      /* Do not get confused by zero sized bases.  */\n+\t      && polymorphic_type_binfo_p (TYPE_BINFO (TREE_TYPE (fld))))\n \t    break;\n \t}\n       /* Within a class type we should always find correcponding fields.  */\n@@ -1317,16 +1351,19 @@ record_targets_from_bases (tree otr_type,\n \n       base_binfo = get_binfo_at_offset (TYPE_BINFO (outer_type),\n \t\t\t\t\toffset, otr_type);\n+      if (!base_binfo)\n+\t{\n+\t  gcc_assert (odr_violation_reported);\n+\t  return;\n+\t}\n       gcc_assert (base_binfo);\n       if (!pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo)))\n \t{\n-\t  tree target = gimple_get_virt_method_for_binfo (otr_token, base_binfo);\n-\t  if (target)\n-\t    maybe_record_node (nodes, target, inserted, completep);\n-\t  /* The only way method in anonymous namespace can become unreferable\n-\t     is that it has been fully optimized out.  */\n-\t  else if (flag_ltrans || !type_in_anonymous_namespace_p (outer_type))\n-\t    *completep = false;\n+\t  bool can_refer;\n+\t  tree target = gimple_get_virt_method_for_binfo (otr_token,\n+\t\t\t\t\t\t\t  base_binfo,\n+\t\t\t\t\t\t\t  &can_refer);\n+\t  maybe_record_node (nodes, target, inserted, can_refer, completep);\n \t  pointer_set_insert (matched_vtables, BINFO_VTABLE (base_binfo));\n \t}\n     }\n@@ -1357,6 +1394,10 @@ devirt_variable_node_removal_hook (varpool_node *n,\n    in the target cache.  If user needs to visit every target list\n    just once, it can memoize them.\n \n+   NONCONSTRUCTION_TARGETS specify number of targets with asumption that\n+   the type is not in the construction.  Those targets appear first in the\n+   vector returned.\n+\n    Returned vector is placed into cache.  It is NOT caller's responsibility\n    to free it.  The vector can be freed on cgraph_remove_node call if\n    the particular node is a virtual function present in the cache.  */\n@@ -1366,7 +1407,8 @@ possible_polymorphic_call_targets (tree otr_type,\n \t\t\t           HOST_WIDE_INT otr_token,\n \t\t\t\t   ipa_polymorphic_call_context context,\n \t\t\t           bool *completep,\n-\t\t\t           void **cache_token)\n+\t\t\t           void **cache_token,\n+\t\t\t\t   int *nonconstruction_targetsp)\n {\n   static struct cgraph_node_hook_list *node_removal_hook_holder;\n   pointer_set_t *inserted;\n@@ -1377,12 +1419,15 @@ possible_polymorphic_call_targets (tree otr_type,\n   polymorphic_call_target_d **slot;\n   unsigned int i;\n   tree binfo, target;\n-  bool final;\n+  bool complete;\n+  bool can_refer;\n \n   if (!odr_hash.is_created ())\n     {\n       if (completep)\n \t*completep = false;\n+      if (nonconstruction_targetsp)\n+\t*nonconstruction_targetsp = 0;\n       return nodes;\n     }\n \n@@ -1406,7 +1451,7 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* If outer and inner type match, there are no bases to see.  */\n   if (type == outer_type)\n     context.maybe_in_construction = false;\n-  /* If the type is final, there are no derivations.  */\n+  /* If the type is complete, there are no derivations.  */\n   if (TYPE_FINAL_P (outer_type->type))\n     context.maybe_derived_type = false;\n \n@@ -1434,11 +1479,13 @@ possible_polymorphic_call_targets (tree otr_type,\n   if (*slot)\n     {\n       if (completep)\n-\t*completep = (*slot)->final;\n+\t*completep = (*slot)->complete;\n+      if (nonconstruction_targetsp)\n+\t*nonconstruction_targetsp = (*slot)->nonconstruction_targets;\n       return (*slot)->targets;\n     }\n \n-  final = true;\n+  complete = true;\n \n   /* Do actual search.  */\n   timevar_push (TV_IPA_VIRTUAL_CALL);\n@@ -1455,49 +1502,58 @@ possible_polymorphic_call_targets (tree otr_type,\n   /* First see virtual method of type itself.  */\n   binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n \t\t\t       context.offset, otr_type);\n-  target = gimple_get_virt_method_for_binfo (otr_token, binfo);\n-  if (target)\n+  if (binfo)\n+    target = gimple_get_virt_method_for_binfo (otr_token, binfo,\n+\t\t\t\t\t       &can_refer);\n+  else\n     {\n-      maybe_record_node (nodes, target, inserted, &final);\n+      gcc_assert (odr_violation_reported);\n+      target = NULL;\n+    }\n \n-      /* In the case we get final method, we don't need \n+  maybe_record_node (nodes, target, inserted, can_refer, &complete);\n+\n+  if (target)\n+    {\n+      /* In the case we get complete method, we don't need \n \t to walk derivations.  */\n       if (DECL_FINAL_P (target))\n \tcontext.maybe_derived_type = false;\n     }\n-  /* The only way method in anonymous namespace can become unreferable\n-     is that it has been fully optimized out.  */\n-  else if (flag_ltrans || !type->anonymous_namespace)\n-    final = false;\n+  else\n+    gcc_assert (!complete);\n \n   pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n \n-  /* Next walk bases, if asked to.  */\n-  if (context.maybe_in_construction)\n-    record_targets_from_bases (otr_type, otr_token, outer_type->type,\n-\t\t\t       context.offset, nodes, inserted,\n-\t\t\t       matched_vtables, &final);\n-\n-  /* Finally walk recursively all derived types.  */\n+  /* Next walk recursively all derived types.  */\n   if (context.maybe_derived_type)\n     {\n       /* For anonymous namespace types we can attempt to build full type.\n \t All derivations must be in this unit (unless we see partial unit).  */\n       if (!type->anonymous_namespace || flag_ltrans)\n-\tfinal = false;\n+\tcomplete = false;\n       for (i = 0; i < outer_type->derived_types.length(); i++)\n \tpossible_polymorphic_call_targets_1 (nodes, inserted,\n \t\t\t\t\t     matched_vtables,\n \t\t\t\t\t     otr_type,\n \t\t\t\t\t     outer_type->derived_types[i],\n \t\t\t\t\t     otr_token, outer_type->type,\n-\t\t\t\t\t     context.offset);\n+\t\t\t\t\t     context.offset, &complete);\n     }\n \n+  /* Finally walk bases, if asked to.  */\n+  (*slot)->nonconstruction_targets = nodes.length();\n+  if (context.maybe_in_construction)\n+    record_targets_from_bases (otr_type, otr_token, outer_type->type,\n+\t\t\t       context.offset, nodes, inserted,\n+\t\t\t       matched_vtables, &complete);\n+\n   (*slot)->targets = nodes;\n-  (*slot)->final = final;\n+  (*slot)->complete = complete;\n   if (completep)\n-    *completep = final;\n+    *completep = complete;\n+  if (nonconstruction_targetsp)\n+    *nonconstruction_targetsp = (*slot)->nonconstruction_targets;\n \n   pointer_set_destroy (inserted);\n   pointer_set_destroy (matched_vtables);\n@@ -1517,28 +1573,46 @@ dump_possible_polymorphic_call_targets (FILE *f,\n   bool final;\n   odr_type type = get_odr_type (otr_type, false);\n   unsigned int i;\n+  int nonconstruction;\n \n   if (!type)\n     return;\n   targets = possible_polymorphic_call_targets (otr_type, otr_token,\n \t\t\t\t\t       ctx,\n-\t\t\t\t\t       &final);\n+\t\t\t\t\t       &final, NULL, &nonconstruction);\n   fprintf (f, \"  Targets of polymorphic call of type %i:\", type->id);\n   print_generic_expr (f, type->type, TDF_SLIM);\n-  fprintf (f, \" token %i\\n\"\n-\t   \"    Contained in type:\",\n-\t   (int)otr_token);\n-  print_generic_expr (f, ctx.outer_type, TDF_SLIM);\n-  fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\"\n-\t   \"    %s%s%s\\n      \",\n-\t   ctx.offset,\n-\t   final ? \"This is full list.\" :\n+  fprintf (f, \" token %i\\n\", (int)otr_token);\n+  if (ctx.outer_type || ctx.offset)\n+    {\n+      fprintf (f, \"    Contained in type:\");\n+      print_generic_expr (f, ctx.outer_type, TDF_SLIM);\n+      fprintf (f, \" at offset \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t       ctx.offset);\n+    }\n+\n+  fprintf (f, \"    %s%s%s\\n      \",\n+\t   final ? \"This is a complete list.\" :\n \t   \"This is partial list; extra targets may be defined in other units.\",\n \t   ctx.maybe_in_construction ? \" (base types included)\" : \"\",\n \t   ctx.maybe_derived_type ? \" (derived types included)\" : \"\");\n   for (i = 0; i < targets.length (); i++)\n-    fprintf (f, \" %s/%i\", targets[i]->name (),\n-\t     targets[i]->order);\n+    {\n+      char *name = NULL;\n+      if (i == (unsigned)nonconstruction)\n+\tfprintf (f, \"\\n     If the type is in construction,\"\n+\t\t \" then additional tarets are:\\n\"\n+\t\t \"      \");\n+      if (in_lto_p)\n+\tname = cplus_demangle_v3 (targets[i]->asm_name (), 0);\n+      fprintf (f, \" %s/%i\", name ? name : targets[i]->name (), targets[i]->order);\n+      if (in_lto_p)\n+\tfree (name);\n+      if (!targets[i]->definition)\n+\tfprintf (f, \" (no definition%s)\",\n+\t\t DECL_DECLARED_INLINE_P (targets[i]->decl)\n+\t\t ? \" inline\" : \"\");\n+    }\n   fprintf (f, \"\\n\\n\");\n }\n \n@@ -1650,9 +1724,10 @@ ipa_devirt (void)\n \t    struct cgraph_node *likely_target = NULL;\n \t    void *cache_token;\n \t    bool final;\n+\t    int nonconstruction_targets;\n \t    vec <cgraph_node *>targets\n \t       = possible_polymorphic_call_targets\n-\t\t    (e, &final, &cache_token);\n+\t\t    (e, &final, &cache_token, &nonconstruction_targets);\n \t    unsigned int i;\n \n \t    if (dump_file)\n@@ -1664,14 +1739,14 @@ ipa_devirt (void)\n \t    if (!cgraph_maybe_hot_edge_p (e))\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Call is cold\\n\");\n+\t\t  fprintf (dump_file, \"Call is cold\\n\\n\");\n \t\tncold++;\n \t\tcontinue;\n \t      }\n \t    if (e->speculative)\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Call is aready speculated\\n\");\n+\t\t  fprintf (dump_file, \"Call is aready speculated\\n\\n\");\n \t\tnspeculated++;\n \n \t\t/* When dumping see if we agree with speculation.  */\n@@ -1682,7 +1757,7 @@ ipa_devirt (void)\n \t\t\t\t      cache_token))\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Target list is known to be useless\\n\");\n+\t\t  fprintf (dump_file, \"Target list is known to be useless\\n\\n\");\n \t\tnmultiple++;\n \t\tcontinue;\n \t      }\n@@ -1691,10 +1766,13 @@ ipa_devirt (void)\n \t\t{\n \t\t  if (likely_target)\n \t\t    {\n-\t\t      likely_target = NULL;\n-\t\t      if (dump_file)\n-\t\t\tfprintf (dump_file, \"More than one likely target\\n\");\n-\t\t      nmultiple++;\n+\t\t      if (i < (unsigned) nonconstruction_targets)\n+\t\t\t{\n+\t\t\t  likely_target = NULL;\n+\t\t\t  if (dump_file)\n+\t\t\t    fprintf (dump_file, \"More than one likely target\\n\\n\");\n+\t\t\t  nmultiple++;\n+\t\t\t}\n \t\t      break;\n \t\t    }\n \t\t  likely_target = targets[i];\n@@ -1714,20 +1792,20 @@ ipa_devirt (void)\n \t\tif (cgraph_function_or_thunk_node (e2->callee, NULL)\n \t\t    == cgraph_function_or_thunk_node (likely_target, NULL))\n \t\t  {\n-\t\t    fprintf (dump_file, \"We agree with speculation\\n\");\n+\t\t    fprintf (dump_file, \"We agree with speculation\\n\\n\");\n \t\t    nok++;\n \t\t  }\n \t\telse\n \t\t  {\n-\t\t    fprintf (dump_file, \"We disagree with speculation\\n\");\n+\t\t    fprintf (dump_file, \"We disagree with speculation\\n\\n\");\n \t\t    nwrong++;\n \t\t  }\n \t\tcontinue;\n \t      }\n \t    if (!likely_target->definition)\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Target is not an definition\\n\");\n+\t\t  fprintf (dump_file, \"Target is not an definition\\n\\n\");\n \t\tnnotdefined++;\n \t\tcontinue;\n \t      }\n@@ -1738,7 +1816,7 @@ ipa_devirt (void)\n \t    if (DECL_EXTERNAL (likely_target->decl))\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Target is external\\n\");\n+\t\t  fprintf (dump_file, \"Target is external\\n\\n\");\n \t\tnexternal++;\n \t\tcontinue;\n \t      }\n@@ -1747,15 +1825,15 @@ ipa_devirt (void)\n \t\t&& symtab_can_be_discarded (likely_target))\n \t      {\n \t\tif (dump_file)\n-\t\t  fprintf (dump_file, \"Target is overwritable\\n\");\n+\t\t  fprintf (dump_file, \"Target is overwritable\\n\\n\");\n \t\tnoverwritable++;\n \t\tcontinue;\n \t      }\n \t    else\n \t      {\n \t\tif (dump_file)\n \t\t  fprintf (dump_file,\n-\t\t\t   \"Speculatively devirtualizing call in %s/%i to %s/%i\\n\",\n+\t\t\t   \"Speculatively devirtualizing call in %s/%i to %s/%i\\n\\n\",\n \t\t\t   n->name (), n->order,\n \t\t\t   likely_target->name (),\n \t\t\t   likely_target->order);"}, {"sha": "a2c985a4354b55cd113ae6ca2875e0ce9ffa1e63", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -76,7 +76,8 @@ vec <cgraph_node *>\n possible_polymorphic_call_targets (tree, HOST_WIDE_INT,\n \t\t\t\t   ipa_polymorphic_call_context,\n \t\t\t\t   bool *final = NULL,\n-\t\t\t\t   void **cache_token = NULL);\n+\t\t\t\t   void **cache_token = NULL,\n+\t\t\t\t   int *nonconstruction_targets = NULL);\n odr_type get_odr_type (tree, bool insert = false);\n void dump_possible_polymorphic_call_targets (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t     const ipa_polymorphic_call_context &);\n@@ -105,7 +106,8 @@ bool vtable_pointer_value_to_vtable (tree, tree *, unsigned HOST_WIDE_INT *);\n inline vec <cgraph_node *>\n possible_polymorphic_call_targets (struct cgraph_edge *e,\n \t\t\t\t   bool *final = NULL,\n-\t\t\t\t   void **cache_token = NULL)\n+\t\t\t\t   void **cache_token = NULL,\n+\t\t\t\t   int *nonconstruction_targets = NULL)\n {\n   gcc_checking_assert (e->indirect_info->polymorphic);\n   ipa_polymorphic_call_context context = {e->indirect_info->offset,\n@@ -115,7 +117,8 @@ possible_polymorphic_call_targets (struct cgraph_edge *e,\n   return possible_polymorphic_call_targets (e->indirect_info->otr_type,\n \t\t\t\t\t    e->indirect_info->otr_token,\n \t\t\t\t\t    context,\n-\t\t\t\t\t    final, cache_token);\n+\t\t\t\t\t    final, cache_token,\n+\t\t\t\t\t    nonconstruction_targets);\n }\n \n /* Same as above but taking OBJ_TYPE_REF as an parameter.  */"}, {"sha": "5705049af3adf249293b7b5e42941c895ff86483", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -1,3 +1,9 @@\n+2014-02-11  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR lto/59468\n+\t* g++.dg/ipa/devirt-27.C: New testcase.\n+\t* g++.dg/ipa/devirt-26.C: New testcase.\n+\n 2014-02-11  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/60137"}, {"sha": "2df429c34571c28105f7647a253263365af0ffb5", "filename": "gcc/testsuite/g++.dg/ipa/devirt-26.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-26.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-26.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-26.C?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-devirt\"  } */\n+struct A\n+ {\n+   int a;\n+   virtual int bar(void) {return a;}\n+ };\n+struct B\n+ {\n+   virtual int foo(void) {return b;}\n+   int b;\n+ };\n+struct C: A,B\n+ {\n+   virtual int foo(void) {return a;}\n+ };\n+\n+struct C c;\n+int test(void)\n+{\n+  struct C *d=&c;\n+  struct B *b=d;\n+  return d->foo()+b->foo();\n+}\n+/* The call to b->foo() is perfectly devirtualizable because C can not be in construction\n+   when &c was used, but we can not analyze that so far.  Test that we at least speculate\n+   that type is in the construction.  */\n+/* { dg-final { scan-ipa-dump \"Speculatively devirtualizing\" \"devirt\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"devirt\" } } */"}, {"sha": "1dcf76cc3c14a76a9c553a9a0885dd05dc532602", "filename": "gcc/testsuite/g++.dg/ipa/devirt-27.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-27.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec77d61fe3a2b7882aaaae413b25aea878bed33d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-27.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-27.C?ref=ec77d61fe3a2b7882aaaae413b25aea878bed33d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-devirt -fdump-tree-optimized\"  } */\n+struct A\n+ {\n+   int a;\n+ };\n+struct B\n+ {\n+  __attribute__ ((visibility(\"default\")))\n+   virtual int foo(void) {return 42;}\n+   int b;\n+ };\n+struct C: A,B\n+ {\n+  __attribute__ ((visibility(\"hidden\")))\n+   virtual int foo(void);\n+ };\n+\n+struct C c;\n+int test(void)\n+{\n+  struct C *d=&c;\n+  struct B *b=d;\n+  return d->foo()+b->foo();\n+}\n+/* { dg-final { scan-tree-dump \"OBJ_TYPE_REF\" \"optimized\"  } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}