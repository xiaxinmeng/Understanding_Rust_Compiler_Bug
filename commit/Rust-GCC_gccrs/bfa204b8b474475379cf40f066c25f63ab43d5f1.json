{"sha": "bfa204b8b474475379cf40f066c25f63ab43d5f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZhMjA0YjhiNDc0NDc1Mzc5Y2Y0MGYwNjZjMjVmNjNhYjQzZDVmMQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-18T20:52:48Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-18T20:52:48Z"}, "message": "re PR fortran/51634 ([OOP] ICE with polymorphic operators)\n\n2012-01-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/51634\n\t* trans-expr.c (gfc_conv_procedure_call): Deallocate allocatable\n\tcomponents of temporary class arguments.\n\n2012-01-18  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/51634\n\t* gfortran.dg/typebound_operator_12.f03: New.\n\t* gfortran.dg/typebound_operator_13.f03: New.\n\nFrom-SVN: r183287", "tree": {"sha": "a3d78f84c1b9f02092ed6ab668e8efeb4adcc36f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3d78f84c1b9f02092ed6ab668e8efeb4adcc36f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bfa204b8b474475379cf40f066c25f63ab43d5f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa204b8b474475379cf40f066c25f63ab43d5f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfa204b8b474475379cf40f066c25f63ab43d5f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfa204b8b474475379cf40f066c25f63ab43d5f1/comments", "author": null, "committer": null, "parents": [{"sha": "55e83c66c7cbe6ac0ef526d7c70462eacde9511d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55e83c66c7cbe6ac0ef526d7c70462eacde9511d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55e83c66c7cbe6ac0ef526d7c70462eacde9511d"}], "stats": {"total": 128, "additions": 127, "deletions": 1}, "files": [{"sha": "db01c0cfbe23f1c533f28147eb96918811c05875", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=bfa204b8b474475379cf40f066c25f63ab43d5f1", "patch": "@@ -1,3 +1,9 @@\n+2012-01-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/51634\n+\t* trans-expr.c (gfc_conv_procedure_call): Deallocate allocatable\n+\tcomponents of temporary class arguments.\n+\n 2012-01-17  Tobias Burnus  <burnus@net-b.de>\n \t    Janne Blomqvist  <jb@gcc.gnu.org>\n "}, {"sha": "15b6797c12b95181e1f788e8631a95e91c3466af", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=bfa204b8b474475379cf40f066c25f63ab43d5f1", "patch": "@@ -3736,7 +3736,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       /* Allocated allocatable components of derived types must be\n \t deallocated for non-variable scalars.  Non-variable arrays are\n \t dealt with in trans-array.c(gfc_conv_array_parameter).  */\n-      if (e && e->ts.type == BT_DERIVED\n+      if (e && (e->ts.type == BT_DERIVED || e->ts.type == BT_CLASS)\n \t    && e->ts.u.derived->attr.alloc_comp\n \t    && !(e->symtree && e->symtree->n.sym->attr.pointer)\n \t    && (e->expr_type != EXPR_VARIABLE && !e->rank))\n@@ -3768,6 +3768,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      gfc_add_expr_to_block (&se->post, local_tmp);\n \t    }\n \n+\t  if (e->ts.type == BT_DERIVED && fsym && fsym->ts.type == BT_CLASS)\n+\t    {\n+\t      /* The derived type is passed to gfc_deallocate_alloc_comp.\n+\t\t Therefore, class actuals can handled correctly but derived\n+\t\t types passed to class formals need the _data component.  */\n+\t      tmp = gfc_class_data_get (tmp);\n+\t      if (!CLASS_DATA (fsym)->attr.dimension)\n+\t\ttmp = build_fold_indirect_ref_loc (input_location, tmp);\n+\t    }\n+\n \t  tmp = gfc_deallocate_alloc_comp (e->ts.u.derived, tmp, parm_rank);\n \n \t  gfc_add_expr_to_block (&se->post, tmp);"}, {"sha": "1d982ecebe9c54e11a05a7a5ebd27189dea64a08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bfa204b8b474475379cf40f066c25f63ab43d5f1", "patch": "@@ -1,3 +1,9 @@\n+2012-01-18  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/51634\n+\t* gfortran.dg/typebound_operator_12.f03: New.\n+\t* gfortran.dg/typebound_operator_13.f03: New.\n+\n 2012-01-18  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/51225"}, {"sha": "3496ed38639d27a50342500a71d52f8b99249c43", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_12.f03", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_12.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_12.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_12.f03?ref=bfa204b8b474475379cf40f066c25f63ab43d5f1", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! PR51634 - Handle allocatable components correctly in expressions \n+! involving typebound operators. See comment 2 of PR.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+! \n+module soop_stars_class\n+  implicit none\n+  type soop_stars\n+    real, dimension(:), allocatable :: position,velocity\n+  contains\n+    procedure :: total\n+    procedure :: product\n+    generic :: operator(+) => total\n+    generic :: operator(*) => product\n+  end type\n+contains\n+  type(soop_stars) function product(lhs,rhs)\n+    class(soop_stars) ,intent(in) :: lhs\n+    real ,intent(in) :: rhs\n+    product%position = lhs%position*rhs\n+    product%velocity = lhs%velocity*rhs\n+  end function\n+\n+  type(soop_stars) function total(lhs,rhs)\n+    class(soop_stars) ,intent(in) :: lhs,rhs\n+    total%position = lhs%position + rhs%position\n+    total%velocity = lhs%velocity + rhs%velocity\n+  end function\n+end module\n+\n+program main\n+  use soop_stars_class ,only : soop_stars\n+  implicit none\n+  type(soop_stars) :: fireworks\n+  real :: dt\n+  fireworks%position = [1,2,3]\n+  fireworks%velocity = [4,5,6]\n+  dt = 5\n+  fireworks = fireworks + fireworks*dt\n+  if (any (fireworks%position .ne. [6, 12, 18])) call abort\n+  if (any (fireworks%velocity .ne. [24, 30, 36])) call abort\n+end program\n+! { dg-final { cleanup-modules \"soop_stars_class\" } }\n+"}, {"sha": "e1371c8a8178cc8c5a0aba3b229791eca077338b", "filename": "gcc/testsuite/gfortran.dg/typebound_operator_13.f03", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bfa204b8b474475379cf40f066c25f63ab43d5f1/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_operator_13.f03?ref=bfa204b8b474475379cf40f066c25f63ab43d5f1", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! PR51634 - Handle allocatable components correctly in expressions \n+! involving typebound operators. From comment 2 of PR but using\n+! classes throughout.\n+!\n+! Reported by Tobias Burnus  <burnus@gcc.gnu.org>\n+! \n+module soop_stars_class\n+  implicit none\n+  type soop_stars\n+    real, dimension(:), allocatable :: position,velocity\n+  contains\n+    procedure :: total\n+    procedure :: mult\n+    procedure :: assign\n+    generic :: operator(+) => total\n+    generic :: operator(*) => mult\n+    generic :: assignment(=) => assign\n+  end type\n+contains\n+  function mult(lhs,rhs)\n+    class(soop_stars) ,intent(in) :: lhs\n+    real ,intent(in) :: rhs\n+    class(soop_stars), allocatable :: mult\n+    type(soop_stars) :: tmp\n+    tmp = soop_stars (lhs%position*rhs, lhs%velocity*rhs)\n+    allocate (mult, source = tmp)\n+  end function\n+\n+  function total(lhs,rhs)\n+    class(soop_stars) ,intent(in) :: lhs,rhs\n+    class(soop_stars), allocatable :: total\n+    type(soop_stars) :: tmp\n+    tmp = soop_stars (lhs%position + rhs%position, &\n+                      lhs%velocity + rhs%velocity)\n+    allocate (total, source = tmp)\n+  end function\n+\n+  subroutine assign(lhs,rhs)\n+    class(soop_stars), intent(in) :: rhs\n+    class(soop_stars), intent(out) :: lhs\n+    lhs%position = rhs%position\n+    lhs%velocity = rhs%velocity\n+  end subroutine\n+end module\n+\n+program main\n+  use soop_stars_class ,only : soop_stars\n+  implicit none\n+  class(soop_stars), allocatable :: fireworks\n+  real :: dt\n+  allocate (fireworks, source = soop_stars ([1,2,3], [4,5,6]))\n+  dt = 5\n+  fireworks = fireworks + fireworks*dt\n+  if (any (fireworks%position .ne. [6, 12, 18])) call abort\n+  if (any (fireworks%velocity .ne. [24, 30, 36])) call abort\n+end program\n+! { dg-final { cleanup-modules \"soop_stars_class\" } }\n+"}]}