{"sha": "de12be17436e7a02a24b9e99da71fb6bfa9a8075", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUxMmJlMTc0MzZlN2EwMmEyNGI5ZTk5ZGE3MWZiNmJmYTlhODA3NQ==", "commit": {"author": {"name": "John Carr", "email": "jfc@mit.edu", "date": "1998-04-25T16:09:24Z"}, "committer": {"name": "John Carr", "email": "jfc@gcc.gnu.org", "date": "1998-04-25T16:09:24Z"}, "message": "alias.c (alias_invariant): New variable.\n\n\t* alias.c (alias_invariant): New variable.\n\t(record_base_value): New argument INVARIANT.\n\t(memrefs_conflict_p): If a register has an entry in the alias_invariant\n\tarray, try substituting that value for the register.\n\t* rtl.h: Declare record_base_value.\n\t* loop.c, unroll.c: Update callers of record_base_value.\n\t* alias.c (find_base_value, find_base_term): SIGN_EXTEND and\n\tZERO_EXTEND do not affect base values.\n\nFrom-SVN: r19408", "tree": {"sha": "d658c3788fb182034177eeb4f3e6c84128bbcd2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d658c3788fb182034177eeb4f3e6c84128bbcd2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de12be17436e7a02a24b9e99da71fb6bfa9a8075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de12be17436e7a02a24b9e99da71fb6bfa9a8075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de12be17436e7a02a24b9e99da71fb6bfa9a8075", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de12be17436e7a02a24b9e99da71fb6bfa9a8075/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fb2c5c00b8f4917f22e3d1ccd3575a2d12aa9360", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb2c5c00b8f4917f22e3d1ccd3575a2d12aa9360", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb2c5c00b8f4917f22e3d1ccd3575a2d12aa9360"}], "stats": {"total": 132, "additions": 96, "deletions": 36}, "files": [{"sha": "f98100817f84e76d6b12134bbc175d5e9c5eda12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de12be17436e7a02a24b9e99da71fb6bfa9a8075", "patch": "@@ -1,3 +1,17 @@\n+Sat Apr 25 17:55:54 1998  John Carr  <jfc@mit.edu>\n+\n+\t* alias.c (alias_invariant): New variable.\n+\t(record_base_value): New argument INVARIANT.\n+\t(memrefs_conflict_p): If a register has an entry in the alias_invariant\n+\tarray, try substituting that value for the register.\n+\n+\t* rtl.h: Declare record_base_value.\n+\n+\t* loop.c, unroll.c: Update callers of record_base_value.\n+\n+\t* alias.c (find_base_value, find_base_term): SIGN_EXTEND and\n+\tZERO_EXTEND do not affect base values.\n+\n Fri Apr 24 15:57:02 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* dbxout.c (dbxout_type): Fix typo."}, {"sha": "a9024b8c98f4ab9c2c2b1321d43526ece0f468bf", "filename": "gcc/alias.c", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=de12be17436e7a02a24b9e99da71fb6bfa9a8075", "patch": "@@ -68,6 +68,16 @@ unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n #define REG_BASE_VALUE(X) \\\n \t(REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n \n+/* Vector of known invariant relationships between registers.  Set in\n+   loop unrolling.  Indexed by register number, if nonzero the value\n+   is an expression describing this register in terms of another.\n+\n+   The length of this array is REG_BASE_VALUE_SIZE.\n+\n+   Because this array contains only pseudo registers it has no effect\n+   after reload.  */\n+static rtx *alias_invariant;\n+\n /* Vector indexed by N giving the initial (unchanging) value known\n    for pseudo-register N.  */\n rtx *reg_known_value;\n@@ -205,6 +215,8 @@ find_base_value (src)\n \treturn find_base_value (XEXP (src, 0));\n       return 0;\n \n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\t/* used for NT/Alpha pointers */\n     case HIGH:\n       return find_base_value (XEXP (src, 0));\n \n@@ -295,16 +307,26 @@ record_set (dest, set)\n \n /* Called from loop optimization when a new pseudo-register is created.  */\n void\n-record_base_value (regno, val)\n+record_base_value (regno, val, invariant)\n      int regno;\n      rtx val;\n+     int invariant;\n {\n   if (regno >= reg_base_value_size)\n     return;\n+\n+  /* If INVARIANT is true then this value also describes an invariant\n+     relationship which can be used to deduce that two registers with\n+     unknown values are different.  */\n+  if (invariant && alias_invariant)\n+    alias_invariant[regno] = val;\n+\n   if (GET_CODE (val) == REG)\n     {\n       if (REGNO (val) < reg_base_value_size)\n-\treg_base_value[regno] = reg_base_value[REGNO (val)];\n+\t{\n+\t  reg_base_value[regno] = reg_base_value[REGNO (val)];\n+\t}\n       return;\n     }\n   reg_base_value[regno] = find_base_value (val);\n@@ -397,6 +419,10 @@ rtx_equal_for_memref_p (x, y)\n     return XEXP (x, 0) == XEXP (y, 0);\n   if (code == SYMBOL_REF)\n     return XSTR (x, 0) == XSTR (y, 0);\n+  if (code == CONST_INT)\n+    return INTVAL (x) == INTVAL (y);\n+  if (code == ADDRESSOF)\n+    return REGNO (XEXP (x, 0)) == REGNO (XEXP (y, 0)) && XINT (x, 1) == XINT (y, 1);\n \n   /* For commutative operations, the RTX match if the operand match in any\n      order.  Also handle the simple binary and unary cases without a loop.  */\n@@ -412,25 +438,20 @@ rtx_equal_for_memref_p (x, y)\n     return rtx_equal_for_memref_p (XEXP (x, 0), XEXP (y, 0));\n \n   /* Compare the elements.  If any pair of corresponding elements\n-     fail to match, return 0 for the whole things.  */\n+     fail to match, return 0 for the whole things.\n+\n+     Limit cases to types which actually appear in addresses.  */\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       switch (fmt[i])\n \t{\n-\tcase 'w':\n-\t  if (XWINT (x, i) != XWINT (y, i))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'n':\n \tcase 'i':\n \t  if (XINT (x, i) != XINT (y, i))\n \t    return 0;\n \t  break;\n \n-\tcase 'V':\n \tcase 'E':\n \t  /* Two vectors must have the same length.  */\n \t  if (XVECLEN (x, i) != XVECLEN (y, i))\n@@ -447,19 +468,6 @@ rtx_equal_for_memref_p (x, y)\n \t    return 0;\n \t  break;\n \n-\tcase 'S':\n-\tcase 's':\n-\t  if (strcmp (XSTR (x, i), XSTR (y, i)))\n-\t    return 0;\n-\t  break;\n-\n-\tcase 'u':\n-\t  /* These are just backpointers, so they don't matter.  */\n-\t  break;\n-\n-\tcase '0':\n-\t  break;\n-\n \t  /* It is believed that rtx's at this level will never\n \t     contain anything but integers and other rtx's,\n \t     except for within LABEL_REFs and SYMBOL_REFs.  */\n@@ -513,9 +521,9 @@ find_base_term (x)\n     case REG:\n       return REG_BASE_VALUE (x);\n \n+    case ZERO_EXTEND:\n+    case SIGN_EXTEND:\t/* Used for Alpha/NT pointers */\n     case HIGH:\n-      return find_base_term (XEXP (x, 0));\n-\n     case PRE_INC:\n     case PRE_DEC:\n     case POST_INC:\n@@ -747,6 +755,25 @@ memrefs_conflict_p (xsize, x, ysize, y, c)\n \t  return memrefs_conflict_p (xsize, x0, ysize, y0, c);\n \t}\n \n+      case REG:\n+\t/* Are these registers known not to be equal?  */\n+\tif (alias_invariant)\n+\t  {\n+\t    int r_x = REGNO (x), r_y = REGNO (y);\n+\t    rtx i_x, i_y;\t/* invariant relationships of X and Y */\n+\n+\t    i_x = r_x >= reg_base_value_size ? 0 : alias_invariant[r_x];\n+\t    i_y = r_y >= reg_base_value_size ? 0 : alias_invariant[r_y];\n+\n+\t    if (i_x == 0 && i_y == 0)\n+\t      break;\n+\n+\t    if (! memrefs_conflict_p (xsize, i_x ? i_x : x,\n+\t\t\t\t      ysize, i_y ? i_y : y, c))\n+\t      return 0;\n+\t  }\n+\tbreak;\n+\n       default:\n \tbreak;\n       }\n@@ -1034,6 +1061,13 @@ init_alias_analysis ()\n   new_reg_base_value = (rtx *)alloca (reg_base_value_size * sizeof (rtx));\n   reg_seen = (char *)alloca (reg_base_value_size);\n   bzero ((char *) reg_base_value, reg_base_value_size * sizeof (rtx));\n+  if (! reload_completed && flag_unroll_loops)\n+    {\n+      alias_invariant = (rtx *)xrealloc (alias_invariant,\n+\t\t\t\t\t reg_base_value_size * sizeof (rtx));\n+      bzero ((char *)alias_invariant, reg_base_value_size * sizeof (rtx));\n+    }\n+    \n \n   /* The basic idea is that each pass through this loop will use the\n      \"constant\" information from the previous pass to propagate alias\n@@ -1203,4 +1237,9 @@ end_alias_analysis ()\n   reg_known_value = 0;\n   reg_base_value = 0;\n   reg_base_value_size = 0;\n+  if (alias_invariant)\n+    {\n+      free ((char *)alias_invariant);\n+      alias_invariant = 0;\n+    }\n }"}, {"sha": "6b66484647b160a66e4d59f713e957a6a16f48b5", "filename": "gcc/loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=de12be17436e7a02a24b9e99da71fb6bfa9a8075", "patch": "@@ -5986,7 +5986,7 @@ emit_iv_add_mult (b, m, a, reg, insert_before)\n \n   emit_insn_before (seq, insert_before);\n \n-  record_base_value (REGNO (reg), b);\n+  record_base_value (REGNO (reg), b, 0);\n }\n \f\n /* Test whether A * B can be computed without"}, {"sha": "76b15654c807837392633e903196e96106dbeb99", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=de12be17436e7a02a24b9e99da71fb6bfa9a8075", "patch": "@@ -1402,4 +1402,6 @@ extern void init_alias_once\t\tPROTO ((void));\n extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n \n+extern void record_base_value\t\tPROTO ((int, rtx, int));\n+\n #endif /* _RTL_H */"}, {"sha": "a6cd9bdd5290e3806b1ac844b22f0fb3890f47f7", "filename": "gcc/unroll.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de12be17436e7a02a24b9e99da71fb6bfa9a8075/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=de12be17436e7a02a24b9e99da71fb6bfa9a8075", "patch": "@@ -1054,7 +1054,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t  {\n \t\t    map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n \t\t    record_base_value (REGNO (map->reg_map[j]),\n-\t\t\t\t       regno_reg_rtx[j]);\n+\t\t\t\t       regno_reg_rtx[j], 0);\n \t\t  }\n \t      /* The last copy needs the compare/branch insns at the end,\n \t\t so reset copy_end here if the loop ends with a conditional\n@@ -1216,7 +1216,7 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  {\n \t    map->reg_map[j] = gen_reg_rtx (GET_MODE (regno_reg_rtx[j]));\n \t    record_base_value (REGNO (map->reg_map[j]),\n-\t\t\t       regno_reg_rtx[j]);\n+\t\t\t       regno_reg_rtx[j], 0);\n \t  }\n \n       /* If loop starts with a branch to the test, then fix it so that\n@@ -1861,7 +1861,12 @@ copy_loop_body (copy_start, copy_end, map, exit_label, last_iteration,\n \t\t      tem = gen_reg_rtx (GET_MODE (giv_src_reg));\n \t\t      giv_dest_reg = tem;\n \t\t      map->reg_map[regno] = tem;\n-\t\t      record_base_value (REGNO (tem), giv_src_reg);\n+\t\t      record_base_value (REGNO (tem),\n+\t\t\t\t\t giv_inc == const0_rtx\n+\t\t\t\t\t ? giv_src_reg\n+\t\t\t\t\t : gen_rtx_PLUS (GET_MODE (giv_src_reg),\n+\t\t\t\t\t\t\t giv_src_reg, giv_inc),\n+\t\t\t\t\t 1);\n \t\t    }\n \t\t  else\n \t\t    map->reg_map[regno] = giv_src_reg;\n@@ -2560,7 +2565,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (bl->biv->mode);\n \n-\t\t  record_base_value (REGNO (tem), bl->biv->add_val);\n+\t\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \t\t  emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n \t\t\t\t    loop_start);\n \n@@ -2617,7 +2622,7 @@ find_splittable_regs (unroll_type, loop_start, loop_end, end_insert_before,\n \t\t this insn will always be executed, no matter how the loop\n \t\t exits.  */\n \t      rtx tem = gen_reg_rtx (bl->biv->mode);\n-\t      record_base_value (REGNO (tem), bl->biv->add_val);\n+\t      record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \n \t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n \t\t\t\tloop_start);\n@@ -2799,7 +2804,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t    {\n \t      rtx tem = gen_reg_rtx (bl->biv->mode);\n \n-\t      record_base_value (REGNO (tem), bl->biv->add_val);\n+\t      record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n \t\t\t\tloop_start);\n \t      biv_initial_value = tem;\n@@ -2841,7 +2846,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t      || GET_CODE (XEXP (value, 1)) != CONST_INT))\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (v->mode);\n-\t\t  record_base_value (REGNO (tem), v->add_val);\n+\t\t  record_base_value (REGNO (tem), v->add_val, 0);\n \t\t  emit_iv_add_mult (bl->initial_value, v->mult_val,\n \t\t\t\t    v->add_val, tem, loop_start);\n \t\t  value = tem;\n@@ -2900,7 +2905,7 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t\t     Emit insn to initialize its value before loop start.  */\n \n \t\t  rtx tem = gen_reg_rtx (v->mode);\n-\t\t  record_base_value (REGNO (tem), v->add_val);\n+\t\t  record_base_value (REGNO (tem), v->add_val, 0);\n \t\t  v->unrolled = 1;\n \n \t\t  /* If the address giv has a constant in its new_reg value,\n@@ -3216,7 +3221,7 @@ final_biv_value (bl, loop_start, loop_end)\n \t     case it is needed later.  */\n \n \t  tem = gen_reg_rtx (bl->biv->mode);\n-\t  record_base_value (REGNO (tem), bl->biv->add_val);\n+\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \t  /* Make sure loop_end is not the last insn.  */\n \t  if (NEXT_INSN (loop_end) == 0)\n \t    emit_note_after (NOTE_INSN_DELETED, loop_end);\n@@ -3315,7 +3320,7 @@ final_giv_value (v, loop_start, loop_end)\n \n \t  /* Put the final biv value in tem.  */\n \t  tem = gen_reg_rtx (bl->biv->mode);\n-\t  record_base_value (REGNO (tem), bl->biv->add_val);\n+\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \t  emit_iv_add_mult (increment, GEN_INT (loop_n_iterations),\n \t\t\t    bl->initial_value, tem, insert_before);\n "}]}