{"sha": "aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWE4OTAxZTliYjAzOTlkMmMxNmY5ODhiYTJmZTQ2ZWIwYzBjNWQxMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2019-09-06T18:12:46Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-09-06T18:12:46Z"}, "message": "libgo: update to Go 1.13beta1 release\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/193497\n\nFrom-SVN: r275473", "tree": {"sha": "7e63b06d1eec92beec6997c9d3ab47a5d6a835be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e63b06d1eec92beec6997c9d3ab47a5d6a835be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "920ea3b8ba3164b61ac9490dfdfceb6936eda6dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd"}], "stats": {"total": 130359, "additions": 94654, "deletions": 35705}, "files": [{"sha": "7b2d17e56d9c8196ae764f94e3916940be5fe2ab", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1,4 +1,4 @@\n-ca0fdb4c7735a648b8f10f1248631adf9afb8454\n+8f2b844acda70330f7c50b360f8c983d2676ecbb\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c910555071fd745cbc3c0bff51e88f0dee710829", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1,3 +1,8 @@\n+2019-09-06  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* go.test/test/fixedbugs/bug369.go: Update to match libgo update\n+\tto Go 1.13beta1.\n+\n 2019-09-06  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* gcc.dg/torture/inf-compare-1.c: Skip AIX."}, {"sha": "7c9583a5888decc6ef70904be9138845d79922c0", "filename": "gcc/testsuite/go.test/test/fixedbugs/bug369.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug369.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug369.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Ffixedbugs%2Fbug369.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -38,6 +38,7 @@ func BenchmarkSlowNonASCII(b *testing.B) {\n }\n \n func main() {\n+\ttesting.Init()\n \tos.Args = []string{os.Args[0], \"-test.benchtime=100ms\"}\n \tflag.Parse()\n "}, {"sha": "b0e612daae4c90b754ba26afa50a945f1ffca529", "filename": "gotools/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1,3 +1,9 @@\n+2019-09-06  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (check-carchive-test): Just run \"go test\", not \"go\n+\ttest carchive_test.go\".\n+\t* Makefile.in: Regenerate.\n+\n 2019-05-27  Ian Lance Taylor  <iant@golang.org>\n \n \t* Makefile.am (check-go-tool): Only chmod check-go-dir if it"}, {"sha": "d36b61ca88e8c95a49672548d62fa6902ea5f8f2", "filename": "gotools/Makefile.am", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -248,7 +248,7 @@ check-runtime: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \t$(SHELL) $(libgosrcdir)/../testsuite/gotest --goarch=$${GOARCH} --goos=$${GOOS} --basedir=$(libgosrcdir)/.. --srcdir=$(libgosrcdir)/runtime --pkgpath=runtime --pkgfiles=\"$${files}\" $(GOTESTFLAGS) -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v >> runtime-testlog 2>&1 || echo \"--- $${fl}: go test runtime (0.00s)\" >> runtime-testlog\n \tgrep '^--- ' runtime-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n-# check-cgo-test runs `go test misc/cgo/test` in our environment.\n+# check-cgo-test runs `go test` in misc/cgo/test.\n check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf cgo-test-dir cgo-testlog\n \t$(MKDIR_P) cgo-test-dir/misc/cgo\n@@ -261,18 +261,18 @@ check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \t(cd cgo-test-dir/misc/cgo/test && $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v) >> cgo-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/test (0.00s)\" >> cgo-testlog\n \tgrep '^--- ' cgo-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n-# check-carchive-test runs `go test misc/cgo/testcarchive/carchive_test.go`\n+# check-carchive-test runs `go test` in misc/cgo/testcarchive.\n # in our environment.\n check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \trm -rf carchive-test-dir carchive-testlog\n \t$(MKDIR_P) carchive-test-dir/misc/cgo\n \tcp -r $(libgomiscdir)/cgo/testcarchive carchive-test-dir/misc/cgo/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n-\techo \"cd carchive-test-dir/misc/cgo/testcarchive && $(ECHO_ENV) LIBRARY_PATH=`echo $${abs_libgodir}/.libs` $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v carchive_test.go\" > carchive-testlog\n+\techo \"cd carchive-test-dir/misc/cgo/testcarchive && $(ECHO_ENV) LIBRARY_PATH=`echo $${abs_libgodir}/.libs` $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > carchive-testlog\n \t$(CHECK_ENV) \\\n \tLIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n \texport LIBRARY_PATH; \\\n-\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v carchive_test.go) >> carchive-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n+\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v) >> carchive-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n \tgrep '^--- ' carchive-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n # check-vet runs `go test cmd/vet` in our environment."}, {"sha": "b36dbfbde1b5b0df411166fb69409637367b30c8", "filename": "gotools/Makefile.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -919,7 +919,7 @@ mostlyclean-local:\n @NATIVE_TRUE@\t$(SHELL) $(libgosrcdir)/../testsuite/gotest --goarch=$${GOARCH} --goos=$${GOOS} --basedir=$(libgosrcdir)/.. --srcdir=$(libgosrcdir)/runtime --pkgpath=runtime --pkgfiles=\"$${files}\" $(GOTESTFLAGS) -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v >> runtime-testlog 2>&1 || echo \"--- $${fl}: go test runtime (0.00s)\" >> runtime-testlog\n @NATIVE_TRUE@\tgrep '^--- ' runtime-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n-# check-cgo-test runs `go test misc/cgo/test` in our environment.\n+# check-cgo-test runs `go test` in misc/cgo/test.\n @NATIVE_TRUE@check-cgo-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf cgo-test-dir cgo-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) cgo-test-dir/misc/cgo\n@@ -932,18 +932,18 @@ mostlyclean-local:\n @NATIVE_TRUE@\t(cd cgo-test-dir/misc/cgo/test && $(abs_builddir)/go$(EXEEXT) test -test.short -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v) >> cgo-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/test (0.00s)\" >> cgo-testlog\n @NATIVE_TRUE@\tgrep '^--- ' cgo-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n-# check-carchive-test runs `go test misc/cgo/testcarchive/carchive_test.go`\n+# check-carchive-test runs `go test` in misc/cgo/testcarchive.\n # in our environment.\n @NATIVE_TRUE@check-carchive-test: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n @NATIVE_TRUE@\trm -rf carchive-test-dir carchive-testlog\n @NATIVE_TRUE@\t$(MKDIR_P) carchive-test-dir/misc/cgo\n @NATIVE_TRUE@\tcp -r $(libgomiscdir)/cgo/testcarchive carchive-test-dir/misc/cgo/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n-@NATIVE_TRUE@\techo \"cd carchive-test-dir/misc/cgo/testcarchive && $(ECHO_ENV) LIBRARY_PATH=`echo $${abs_libgodir}/.libs` $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v carchive_test.go\" > carchive-testlog\n+@NATIVE_TRUE@\techo \"cd carchive-test-dir/misc/cgo/testcarchive && $(ECHO_ENV) LIBRARY_PATH=`echo $${abs_libgodir}/.libs` $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v\" > carchive-testlog\n @NATIVE_TRUE@\t$(CHECK_ENV) \\\n @NATIVE_TRUE@\tLIBRARY_PATH=`echo $${abs_libgodir}/.libs:$${LIBRARY_PATH} | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; \\\n @NATIVE_TRUE@\texport LIBRARY_PATH; \\\n-@NATIVE_TRUE@\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v carchive_test.go) >> carchive-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n+@NATIVE_TRUE@\t(cd carchive-test-dir/misc/cgo/testcarchive && $(abs_builddir)/go$(EXEEXT) test -test.timeout=$(GOTOOLS_TEST_TIMEOUT)s -test.v) >> carchive-testlog 2>&1 || echo \"--- $${fl}: go test misc/cgo/testcarchive (0.00s)\" >> carchive-testlog\n @NATIVE_TRUE@\tgrep '^--- ' carchive-testlog | sed -e 's/^--- \\(.*\\) ([^)]*)$$/\\1/' | sort -k 2\n \n # check-vet runs `go test cmd/vet` in our environment."}, {"sha": "533c99da98483052171040c22b2ef7a3cc76d59e", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1,4 +1,4 @@\n-ac02fdec7cd16ea8d3de1fc33def9cfabec5170d\n+60f14fddfee107dedd76c0be6b422a3d8ccc841a\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "7bdfaa9851369b84a95577ebcc486dc1917aedaa", "filename": "libgo/Makefile.am", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -187,6 +187,7 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/des.gox \\\n \tcrypto/dsa.gox \\\n \tcrypto/ecdsa.gox \\\n+\tcrypto/ed25519.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md5.gox \\\n@@ -399,8 +400,7 @@ toolexeclibgounicode_DATA = \\\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n noinst_DATA = \\\n-\tinternal/x/net/internal/nettest.gox \\\n-\tinternal/x/net/nettest.gox \\\n+\tgolang.org/x/net/nettest.gox \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\\n@@ -482,7 +482,6 @@ s-version: Makefile\n \techo \"  BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n \techo \"  CacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> version.go.tmp\n \techo \"  DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n-\techo \"  HugePageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) hugepagesize`\" >> version.go.tmp\n \techo \"  Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n \techo \"  MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n \techo \"  PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n@@ -516,14 +515,16 @@ s-objabi: Makefile\n \trm -f objabi.go.tmp\n \techo \"package objabi\" > objabi.go.tmp\n \techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n-\techo 'func init() { defaultGOROOT = `$(prefix)` }' >> objabi.go.tmp\n+\techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> objabi.go.tmp\n \techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n \techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS64 = `hardfloat`' >> objabi.go.tmp\n+\techo 'const defaultGOPPC64 = `power8`' >> objabi.go.tmp\n \techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n \techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n \techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n+\techo 'const defaultGO_LDSO = ``' >> objabi.go.tmp\n \techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n \techo 'const stackGuardMultiplierDefault = 1' >> objabi.go.tmp\n \techo 'const goexperiment = ``' >> objabi.go.tmp\n@@ -591,7 +592,7 @@ s-zstdpkglist: Makefile\n \techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n-\techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n+\techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_./]*_c\\.lo||g' | sed 's|\\([a-z0-9_./]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n \techo '}' >> zstdpkglist.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh zstdpkglist.go.tmp zstdpkglist.go\n \t$(STAMP) $@\n@@ -692,13 +693,14 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n-\t$(internal_x_net_lif_lo) \\\n-\t$(internal_x_net_route_lo) \\\n+\t$(golangorg_x_net_lif_lo) \\\n+\t$(golangorg_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n \truntime/internal/atomic_c.lo \\\n \tsync/atomic_c.lo \\\n-\tinternal/cpu/cpu_gccgo.lo\n+\tinternal/cpu/cpu_gccgo.lo \\\n+\tgolang.org/x/sys/cpu_gccgo.lo\n \n libgo_ldflags = \\\n \t-version-info $(libtool_VERSION) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n@@ -1020,6 +1022,11 @@ internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t@$(MKDIR_P) internal/cpu\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n \n+# Similarly, golang.org/x/sys/cpu needs some C code.\n+golang.org/x/sys/cpu_gccgo.lo: go/golang.org/x/sys/cpu/cpu_gccgo.c runtime.inc\n+\t@$(MKDIR_P) golang.org/x/sys\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/golang.org/x/sys/cpu/cpu_gccgo.c\n+\n # Solaris 11.4 changed the type of fields in struct stat.\n # Use a build tag, based on a configure check, to cope.\n if LIBGO_IS_SOLARIS\n@@ -1038,10 +1045,10 @@ if LIBGO_IS_BSD\n \n $(eval $(call PACKAGE_template,internal/x/net/route))\n \n-internal_x_net_route_lo = \\\n-\tinternal/x/net/route.lo\n-internal_x_net_route_check = \\\n-\tinternal/x/net/route/check\n+golangorg_x_net_route_lo = \\\n+\tgolang.org/net/route.lo\n+golangorg_x_net_route_check = \\\n+\tgolang.org/x/net/route/check\n \n endif\n \n@@ -1051,17 +1058,17 @@ if LIBGO_IS_SOLARIS\n \n $(eval $(call PACKAGE_template,internal/x/net/lif))\n \n-internal_x_net_lif_lo = \\\n-\tinternal/x/net/lif.lo\n-internal_x_net_lif_check = \\\n-\tinternal/x/net/lif/check\n+golangorg_x_net_lif_lo = \\\n+\tgolang.org/x/net/lif.lo\n+golangorg_x_net_lif_check = \\\n+\tgolang.org/x/net/lif/check\n \n endif\n \n TPACKAGES = $(shell cat $(srcdir)/check-packages.txt)\n TEST_PACKAGES = $(addsuffix /check,$(TPACKAGES)) \\\n-\t$(internal_x_net_lif_check) \\\n-\t$(internal_x_net_route_check)\n+\t$(golangorg_x_net_lif_check) \\\n+\t$(golangorg_x_net_route_check)\n \n check: check-tail\n check-recursive: check-head"}, {"sha": "751683887a3feb5fe41ad8c02bb5e6c0ea7c2eea", "filename": "libgo/Makefile.in", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -218,10 +218,10 @@ LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_2 = $(addsuffix .lo,$(PACKAGES)) \\\n \tinternal/bytealg/bytealg.lo reflect/makefunc_ffi_c.lo \\\n \t$(am__DEPENDENCIES_1) syscall/errno.lo syscall/signame.lo \\\n-\tsyscall/wait.lo $(internal_x_net_lif_lo) \\\n-\t$(internal_x_net_route_lo) log/syslog/syslog_c.lo \\\n+\tsyscall/wait.lo $(golangorg_x_net_lif_lo) \\\n+\t$(golangorg_x_net_route_lo) log/syslog/syslog_c.lo \\\n \truntime/internal/atomic_c.lo sync/atomic_c.lo \\\n-\tinternal/cpu/cpu_gccgo.lo\n+\tinternal/cpu/cpu_gccgo.lo golang.org/x/sys/cpu_gccgo.lo\n am__DEPENDENCIES_3 =\n am__DEPENDENCIES_4 = $(am__DEPENDENCIES_2) \\\n \t../libbacktrace/libbacktrace.la $(am__DEPENDENCIES_3) \\\n@@ -670,6 +670,7 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/des.gox \\\n \tcrypto/dsa.gox \\\n \tcrypto/ecdsa.gox \\\n+\tcrypto/ed25519.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md5.gox \\\n@@ -854,8 +855,7 @@ toolexeclibgounicode_DATA = \\\n # Some packages are only needed for tests, so unlike the other\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n-noinst_DATA = internal/x/net/internal/nettest.gox \\\n-\tinternal/x/net/nettest.gox internal/testenv.gox \\\n+noinst_DATA = golang.org/x/net/nettest.gox internal/testenv.gox \\\n \tinternal/trace.gox net/internal/socktest.gox \\\n \tos/signal/internal/pty.gox runtime/pprof/internal/profile.gox \\\n \tzdefaultcc.go\n@@ -915,13 +915,14 @@ libgo_go_objs = \\\n \tsyscall/errno.lo \\\n \tsyscall/signame.lo \\\n \tsyscall/wait.lo \\\n-\t$(internal_x_net_lif_lo) \\\n-\t$(internal_x_net_route_lo) \\\n+\t$(golangorg_x_net_lif_lo) \\\n+\t$(golangorg_x_net_route_lo) \\\n \tlog/syslog/syslog_c.lo \\\n \t$(os_lib_inotify_lo) \\\n \truntime/internal/atomic_c.lo \\\n \tsync/atomic_c.lo \\\n-\tinternal/cpu/cpu_gccgo.lo\n+\tinternal/cpu/cpu_gccgo.lo \\\n+\tgolang.org/x/sys/cpu_gccgo.lo\n \n libgo_ldflags = \\\n \t-version-info $(libtool_VERSION) $(PTHREAD_CFLAGS) $(AM_LDFLAGS)\n@@ -1114,22 +1115,22 @@ extra_check_libs_cmd_vet_internal_cfg = $(abs_builddir)/libgotool.a\n # Use a build tag, based on a configure check, to cope.\n @HAVE_STAT_TIMESPEC_TRUE@@LIBGO_IS_SOLARIS_TRUE@matchargs_os = --tag=solaristag\n @LIBGO_IS_SOLARIS_FALSE@matchargs_os = \n-@LIBGO_IS_BSD_TRUE@internal_x_net_route_lo = \\\n-@LIBGO_IS_BSD_TRUE@\tinternal/x/net/route.lo\n+@LIBGO_IS_BSD_TRUE@golangorg_x_net_route_lo = \\\n+@LIBGO_IS_BSD_TRUE@\tgolang.org/net/route.lo\n \n-@LIBGO_IS_BSD_TRUE@internal_x_net_route_check = \\\n-@LIBGO_IS_BSD_TRUE@\tinternal/x/net/route/check\n+@LIBGO_IS_BSD_TRUE@golangorg_x_net_route_check = \\\n+@LIBGO_IS_BSD_TRUE@\tgolang.org/x/net/route/check\n \n-@LIBGO_IS_SOLARIS_TRUE@internal_x_net_lif_lo = \\\n-@LIBGO_IS_SOLARIS_TRUE@\tinternal/x/net/lif.lo\n+@LIBGO_IS_SOLARIS_TRUE@golangorg_x_net_lif_lo = \\\n+@LIBGO_IS_SOLARIS_TRUE@\tgolang.org/x/net/lif.lo\n \n-@LIBGO_IS_SOLARIS_TRUE@internal_x_net_lif_check = \\\n-@LIBGO_IS_SOLARIS_TRUE@\tinternal/x/net/lif/check\n+@LIBGO_IS_SOLARIS_TRUE@golangorg_x_net_lif_check = \\\n+@LIBGO_IS_SOLARIS_TRUE@\tgolang.org/x/net/lif/check\n \n TPACKAGES = $(shell cat $(srcdir)/check-packages.txt)\n TEST_PACKAGES = $(addsuffix /check,$(TPACKAGES)) \\\n-\t$(internal_x_net_lif_check) \\\n-\t$(internal_x_net_route_check)\n+\t$(golangorg_x_net_lif_check) \\\n+\t$(golangorg_x_net_route_check)\n \n MOSTLYCLEANFILES = \\\n \ts-runtime_sysinfo s-sigtab s-runtime-inc s-zstdpkglist \\\n@@ -2597,7 +2598,6 @@ s-version: Makefile\n \techo \"  BigEndian = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) bigendian`\" >> version.go.tmp\n \techo \"  CacheLineSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) cachelinesize`\" >> version.go.tmp\n \techo \"  DefaultPhysPageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) defaultphyspagesize`\" >> version.go.tmp\n-\techo \"  HugePageSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) hugepagesize`\" >> version.go.tmp\n \techo \"  Int64Align = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) int64align`\" >> version.go.tmp\n \techo \"  MinFrameSize = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) minframesize`\" >> version.go.tmp\n \techo \"  PCQuantum = `$(SHELL) $(srcdir)/goarch.sh $(GOARCH) pcquantum`\" >> version.go.tmp\n@@ -2631,14 +2631,16 @@ s-objabi: Makefile\n \trm -f objabi.go.tmp\n \techo \"package objabi\" > objabi.go.tmp\n \techo \"import \\\"runtime\\\"\" >> objabi.go.tmp\n-\techo 'func init() { defaultGOROOT = `$(prefix)` }' >> objabi.go.tmp\n+\techo 'func defaultGOROOTValue() string { return `$(prefix)` }' >> objabi.go.tmp\n \techo 'const defaultGO386 = `sse2`' >> objabi.go.tmp\n \techo 'const defaultGOARM = `5`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS = `hardfloat`' >> objabi.go.tmp\n \techo 'const defaultGOMIPS64 = `hardfloat`' >> objabi.go.tmp\n+\techo 'const defaultGOPPC64 = `power8`' >> objabi.go.tmp\n \techo 'const defaultGOOS = runtime.GOOS' >> objabi.go.tmp\n \techo 'const defaultGOARCH = runtime.GOARCH' >> objabi.go.tmp\n \techo 'const defaultGO_EXTLINK_ENABLED = ``' >> objabi.go.tmp\n+\techo 'const defaultGO_LDSO = ``' >> objabi.go.tmp\n \techo 'const version = `'`cat $(srcdir)/VERSION | sed 1q`' '`$(GOC) --version | sed 1q`'`' >> objabi.go.tmp\n \techo 'const stackGuardMultiplierDefault = 1' >> objabi.go.tmp\n \techo 'const goexperiment = ``' >> objabi.go.tmp\n@@ -2700,7 +2702,7 @@ s-zstdpkglist: Makefile\n \techo 'package goroot' > zstdpkglist.go.tmp\n \techo \"\" >> zstdpkglist.go.tmp\n \techo 'var stdpkg = map[string]bool{' >> zstdpkglist.go.tmp\n-\techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_/]*_c\\.lo||g' | sed 's|\\([a-z0-9_/]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n+\techo $(libgo_go_objs) 'unsafe.lo' 'runtime/cgo.lo' | sed 's|[a-z0-9_./]*_c\\.lo||g' | sed 's|\\([a-z0-9_./]*\\)\\.lo|\"\\1\": true,|g' >> zstdpkglist.go.tmp\n \techo '}' >> zstdpkglist.go.tmp\n \t$(SHELL) $(srcdir)/mvifdiff.sh zstdpkglist.go.tmp zstdpkglist.go\n \t$(STAMP) $@\n@@ -2876,6 +2878,11 @@ internal/cpu/cpu_gccgo.lo: go/internal/cpu/cpu_gccgo.c runtime.inc\n \t@$(MKDIR_P) internal/cpu\n \t$(LTCOMPILE) -c -o $@ $(srcdir)/go/internal/cpu/cpu_gccgo.c\n \n+# Similarly, golang.org/x/sys/cpu needs some C code.\n+golang.org/x/sys/cpu_gccgo.lo: go/golang.org/x/sys/cpu/cpu_gccgo.c runtime.inc\n+\t@$(MKDIR_P) golang.org/x/sys\n+\t$(LTCOMPILE) -c -o $@ $(srcdir)/go/golang.org/x/sys/cpu/cpu_gccgo.c\n+\n # Build internal/x/net/route only on BSD systems.\n \n @LIBGO_IS_BSD_TRUE@$(eval $(call PACKAGE_template,internal/x/net/route))"}, {"sha": "a49377394febbccc7622f9baadcf636ae37747e9", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1 +1 @@\n-go1.12.2\n+go1.13beta1"}, {"sha": "a13624303dde9fb5d03473b94800508aa9e139e0", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -21,7 +21,6 @@ cmd/go/internal/par\n cmd/go/internal/search\n cmd/go/internal/semver\n cmd/go/internal/txtar\n-cmd/go/internal/web2\n cmd/go/internal/work\n cmd/internal/buildid\n cmd/internal/edit\n@@ -42,6 +41,7 @@ crypto/cipher\n crypto/des\n crypto/dsa\n crypto/ecdsa\n+crypto/ed25519\n crypto/elliptic\n crypto/hmac\n crypto/internal/subtle\n@@ -106,20 +106,11 @@ image/png\n index/suffixarray\n internal/cpu\n internal/fmtsort\n+internal/oserror\n internal/poll\n+internal/reflectlite\n internal/singleflight\n internal/trace\n-internal/x/crypto/chacha20poly1305\n-internal/x/crypto/cryptobyte\n-internal/x/crypto/curve25519\n-internal/x/crypto/hkdf\n-internal/x/crypto/internal/chacha20\n-internal/x/crypto/poly1305\n-internal/x/net/dns/dnsmessage\n-internal/x/net/http/httpguts\n-internal/x/net/http/httpproxy\n-internal/x/net/http2/hpack\n-internal/x/net/idna\n internal/xcoff\n io\n io/ioutil"}, {"sha": "ebdffa88437e558fad55b8f4cc1467b246c58853", "filename": "libgo/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -2542,7 +2542,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=14:0:0\n+libtool_VERSION=15:0:0\n \n \n # Default to --enable-multilib\n@@ -13887,7 +13887,7 @@ go_include=\"-include\"\n # All known GOOS values.  This is the union of all operating systems\n # supported by the gofrontend and all operating systems supported by\n # the gc toolchain.\n-ALLGOOS=\"aix android darwin dragonfly freebsd hurd irix js linux netbsd openbsd plan9 rtems solaris windows\"\n+ALLGOOS=\"aix android darwin dragonfly freebsd hurd illumos irix js linux netbsd openbsd plan9 rtems solaris windows\"\n \n is_darwin=no\n is_freebsd=no"}, {"sha": "8a0a04f77ab36779de1ac61ac344a00c66fc8c35", "filename": "libgo/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=14:0:0\n+libtool_VERSION=15:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)\n@@ -154,7 +154,7 @@ AC_SUBST(go_include)\n # All known GOOS values.  This is the union of all operating systems\n # supported by the gofrontend and all operating systems supported by\n # the gc toolchain.\n-ALLGOOS=\"aix android darwin dragonfly freebsd hurd irix js linux netbsd openbsd plan9 rtems solaris windows\"\n+ALLGOOS=\"aix android darwin dragonfly freebsd hurd illumos irix js linux netbsd openbsd plan9 rtems solaris windows\"\n \n is_darwin=no\n is_freebsd=no"}, {"sha": "0a910f33b9d68746e19992bf66bcb2091410b0cf", "filename": "libgo/go/archive/tar/strconv.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -244,7 +244,7 @@ func formatPAXTime(ts time.Time) (s string) {\n \tif secs < 0 {\n \t\tsign = \"-\"             // Remember sign\n \t\tsecs = -(secs + 1)     // Add a second to secs\n-\t\tnsecs = -(nsecs - 1E9) // Take that second away from nsecs\n+\t\tnsecs = -(nsecs - 1e9) // Take that second away from nsecs\n \t}\n \treturn strings.TrimRight(fmt.Sprintf(\"%s%d.%09d\", sign, secs, nsecs), \"0\")\n }"}, {"sha": "dd3505a758af8d5d17ceae4ecd1c11652952f6b0", "filename": "libgo/go/archive/tar/strconv_test.go", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Fstrconv_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -303,27 +303,27 @@ func TestFormatPAXTime(t *testing.T) {\n \t\t{1350244992, 300000000, \"1350244992.3\"},\n \t\t{1350244992, 23960100, \"1350244992.0239601\"},\n \t\t{1350244992, 23960108, \"1350244992.023960108\"},\n-\t\t{+1, +1E9 - 1E0, \"1.999999999\"},\n-\t\t{+1, +1E9 - 1E3, \"1.999999\"},\n-\t\t{+1, +1E9 - 1E6, \"1.999\"},\n-\t\t{+1, +0E0 - 0E0, \"1\"},\n-\t\t{+1, +1E6 - 0E0, \"1.001\"},\n-\t\t{+1, +1E3 - 0E0, \"1.000001\"},\n-\t\t{+1, +1E0 - 0E0, \"1.000000001\"},\n-\t\t{0, 1E9 - 1E0, \"0.999999999\"},\n-\t\t{0, 1E9 - 1E3, \"0.999999\"},\n-\t\t{0, 1E9 - 1E6, \"0.999\"},\n-\t\t{0, 0E0, \"0\"},\n-\t\t{0, 1E6 + 0E0, \"0.001\"},\n-\t\t{0, 1E3 + 0E0, \"0.000001\"},\n-\t\t{0, 1E0 + 0E0, \"0.000000001\"},\n-\t\t{-1, -1E9 + 1E0, \"-1.999999999\"},\n-\t\t{-1, -1E9 + 1E3, \"-1.999999\"},\n-\t\t{-1, -1E9 + 1E6, \"-1.999\"},\n-\t\t{-1, -0E0 + 0E0, \"-1\"},\n-\t\t{-1, -1E6 + 0E0, \"-1.001\"},\n-\t\t{-1, -1E3 + 0E0, \"-1.000001\"},\n-\t\t{-1, -1E0 + 0E0, \"-1.000000001\"},\n+\t\t{+1, +1e9 - 1e0, \"1.999999999\"},\n+\t\t{+1, +1e9 - 1e3, \"1.999999\"},\n+\t\t{+1, +1e9 - 1e6, \"1.999\"},\n+\t\t{+1, +0e0 - 0e0, \"1\"},\n+\t\t{+1, +1e6 - 0e0, \"1.001\"},\n+\t\t{+1, +1e3 - 0e0, \"1.000001\"},\n+\t\t{+1, +1e0 - 0e0, \"1.000000001\"},\n+\t\t{0, 1e9 - 1e0, \"0.999999999\"},\n+\t\t{0, 1e9 - 1e3, \"0.999999\"},\n+\t\t{0, 1e9 - 1e6, \"0.999\"},\n+\t\t{0, 0e0, \"0\"},\n+\t\t{0, 1e6 + 0e0, \"0.001\"},\n+\t\t{0, 1e3 + 0e0, \"0.000001\"},\n+\t\t{0, 1e0 + 0e0, \"0.000000001\"},\n+\t\t{-1, -1e9 + 1e0, \"-1.999999999\"},\n+\t\t{-1, -1e9 + 1e3, \"-1.999999\"},\n+\t\t{-1, -1e9 + 1e6, \"-1.999\"},\n+\t\t{-1, -0e0 + 0e0, \"-1\"},\n+\t\t{-1, -1e6 + 0e0, \"-1.001\"},\n+\t\t{-1, -1e3 + 0e0, \"-1.000001\"},\n+\t\t{-1, -1e0 + 0e0, \"-1.000000001\"},\n \t\t{-1350244992, 0, \"-1350244992\"},\n \t\t{-1350244992, -300000000, \"-1350244992.3\"},\n \t\t{-1350244992, -23960100, \"-1350244992.0239601\"},"}, {"sha": "686e79781acb69bcefd5017829d12fcf8ccd29a9", "filename": "libgo/go/archive/zip/struct.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fstruct.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -154,10 +154,15 @@ func (fi headerFileInfo) Size() int64 {\n \t}\n \treturn int64(fi.fh.UncompressedSize)\n }\n-func (fi headerFileInfo) IsDir() bool        { return fi.Mode().IsDir() }\n-func (fi headerFileInfo) ModTime() time.Time { return fi.fh.ModTime() }\n-func (fi headerFileInfo) Mode() os.FileMode  { return fi.fh.Mode() }\n-func (fi headerFileInfo) Sys() interface{}   { return fi.fh }\n+func (fi headerFileInfo) IsDir() bool { return fi.Mode().IsDir() }\n+func (fi headerFileInfo) ModTime() time.Time {\n+\tif fi.fh.Modified.IsZero() {\n+\t\treturn fi.fh.ModTime()\n+\t}\n+\treturn fi.fh.Modified.UTC()\n+}\n+func (fi headerFileInfo) Mode() os.FileMode { return fi.fh.Mode() }\n+func (fi headerFileInfo) Sys() interface{}  { return fi.fh }\n \n // FileInfoHeader creates a partially-populated FileHeader from an\n // os.FileInfo."}, {"sha": "b3a7caac7f2948d511d180d8c0163ab0aab45977", "filename": "libgo/go/archive/zip/zip_test.go", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Fzip_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"hash\"\n-\t\"internal/race\"\n \t\"internal/testenv\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -114,6 +113,47 @@ func TestFileHeaderRoundTrip64(t *testing.T) {\n \ttestHeaderRoundTrip(fh, uint32max, fh.UncompressedSize64, t)\n }\n \n+func TestFileHeaderRoundTripModified(t *testing.T) {\n+\tfh := &FileHeader{\n+\t\tName:             \"foo.txt\",\n+\t\tUncompressedSize: 987654321,\n+\t\tModified:         time.Now().Local(),\n+\t\tModifiedTime:     1234,\n+\t\tModifiedDate:     5678,\n+\t}\n+\tfi := fh.FileInfo()\n+\tfh2, err := FileInfoHeader(fi)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := fh2.Modified, fh.Modified.UTC(); got != want {\n+\t\tt.Errorf(\"Modified: got %s, want %s\\n\", got, want)\n+\t}\n+\tif got, want := fi.ModTime(), fh.Modified.UTC(); got != want {\n+\t\tt.Errorf(\"Modified: got %s, want %s\\n\", got, want)\n+\t}\n+}\n+\n+func TestFileHeaderRoundTripWithoutModified(t *testing.T) {\n+\tfh := &FileHeader{\n+\t\tName:             \"foo.txt\",\n+\t\tUncompressedSize: 987654321,\n+\t\tModifiedTime:     1234,\n+\t\tModifiedDate:     5678,\n+\t}\n+\tfi := fh.FileInfo()\n+\tfh2, err := FileInfoHeader(fi)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif got, want := fh2.ModTime(), fh.ModTime(); got != want {\n+\t\tt.Errorf(\"Modified: got %s, want %s\\n\", got, want)\n+\t}\n+\tif got, want := fi.ModTime(), fh.ModTime(); got != want {\n+\t\tt.Errorf(\"Modified: got %s, want %s\\n\", got, want)\n+\t}\n+}\n+\n type repeatedByte struct {\n \toff int64\n \tb   byte\n@@ -268,7 +308,7 @@ func TestZip64EdgeCase(t *testing.T) {\n // Tests that we generate a zip64 file if the directory at offset\n // 0xFFFFFFFF, but not before.\n func TestZip64DirectoryOffset(t *testing.T) {\n-\tif testing.Short() && race.Enabled {\n+\tif testing.Short() {\n \t\tt.Skip(\"skipping in short mode\")\n \t}\n \tt.Parallel()\n@@ -313,7 +353,7 @@ func TestZip64DirectoryOffset(t *testing.T) {\n \n // At 16k records, we need to generate a zip64 file.\n func TestZip64ManyRecords(t *testing.T) {\n-\tif testing.Short() && race.Enabled {\n+\tif testing.Short() {\n \t\tt.Skip(\"skipping in short mode\")\n \t}\n \tt.Parallel()"}, {"sha": "0f05d3b32211ea45417fd159d1817fcb82038d1b", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -197,6 +197,9 @@ func (b *Reader) Discard(n int) (discarded int, err error) {\n func (b *Reader) Read(p []byte) (n int, err error) {\n \tn = len(p)\n \tif n == 0 {\n+\t\tif b.Buffered() > 0 {\n+\t\t\treturn 0, nil\n+\t\t}\n \t\treturn 0, b.readErr()\n \t}\n \tif b.r == b.w {"}, {"sha": "782ca2149aa57bc68aee7221435a57d102fe3e31", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1481,6 +1481,60 @@ func newScriptedReader(steps ...func(p []byte) (n int, err error)) io.Reader {\n \treturn &sr\n }\n \n+// eofReader returns the number of bytes read and io.EOF for the read that consumes the last of the content.\n+type eofReader struct {\n+\tbuf []byte\n+}\n+\n+func (r *eofReader) Read(p []byte) (int, error) {\n+\tread := copy(p, r.buf)\n+\tr.buf = r.buf[read:]\n+\n+\tswitch read {\n+\tcase 0, len(r.buf):\n+\t\t// As allowed in the documentation, this will return io.EOF\n+\t\t// in the same call that consumes the last of the data.\n+\t\t// https://godoc.org/io#Reader\n+\t\treturn read, io.EOF\n+\t}\n+\n+\treturn read, nil\n+}\n+\n+func TestPartialReadEOF(t *testing.T) {\n+\tsrc := make([]byte, 10)\n+\teofR := &eofReader{buf: src}\n+\tr := NewReader(eofR)\n+\n+\t// Start by reading 5 of the 10 available bytes.\n+\tdest := make([]byte, 5)\n+\tread, err := r.Read(dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif n := len(dest); read != n {\n+\t\tt.Fatalf(\"read %d bytes; wanted %d bytes\", read, n)\n+\t}\n+\n+\t// The Reader should have buffered all the content from the io.Reader.\n+\tif n := len(eofR.buf); n != 0 {\n+\t\tt.Fatalf(\"got %d bytes left in bufio.Reader source; want 0 bytes\", n)\n+\t}\n+\t// To prove the point, check that there are still 5 bytes available to read.\n+\tif n := r.Buffered(); n != 5 {\n+\t\tt.Fatalf(\"got %d bytes buffered in bufio.Reader; want 5 bytes\", n)\n+\t}\n+\n+\t// This is the second read of 0 bytes.\n+\tread, err = r.Read([]byte{})\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif read != 0 {\n+\t\tt.Fatalf(\"read %d bytes; want 0 bytes\", read)\n+\t}\n+}\n+\n func BenchmarkReaderCopyOptimal(b *testing.B) {\n \t// Optimal case is where the underlying reader implements io.WriterTo\n \tsrcBuf := bytes.NewBuffer(make([]byte, 8192))"}, {"sha": "8885d40549f1532010a320d00964f19bffbb5846", "filename": "libgo/go/bufio/example_test.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fexample_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -31,6 +31,19 @@ func ExampleScanner_lines() {\n \t}\n }\n \n+// Return the most recent call to Scan as a []byte.\n+func ExampleScanner_Bytes() {\n+\tscanner := bufio.NewScanner(strings.NewReader(\"gopher\"))\n+\tfor scanner.Scan() {\n+\t\tfmt.Println(len(scanner.Bytes()) == 6)\n+\t}\n+\tif err := scanner.Err(); err != nil {\n+\t\tfmt.Fprintln(os.Stderr, \"shouldn't see an error scanning a string\")\n+\t}\n+\t// Output:\n+\t// true\n+}\n+\n // Use a Scanner to implement a simple word-count utility by scanning the\n // input as a sequence of space-delimited tokens.\n func ExampleScanner_words() {\n@@ -94,6 +107,9 @@ func ExampleScanner_emptyFinalToken() {\n \t\t\t\treturn i + 1, data[:i], nil\n \t\t\t}\n \t\t}\n+\t\tif !atEOF {\n+\t\t\treturn 0, nil, nil\n+\t\t}\n \t\t// There is one final token to be delivered, which may be the empty string.\n \t\t// Returning bufio.ErrFinalToken here tells Scan there are no more tokens after this\n \t\t// but does not trigger an error to be returned from Scan itself."}, {"sha": "4e787c4b0a427669527376127ea4140f1386bce5", "filename": "libgo/go/bufio/scan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbufio%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fscan.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -73,7 +73,7 @@ var (\n \n const (\n \t// MaxScanTokenSize is the maximum size used to buffer a token\n-\t// unless the user provides an explicit buffer with Scan.Buffer.\n+\t// unless the user provides an explicit buffer with Scanner.Buffer.\n \t// The actual maximum token size may be smaller as the buffer\n \t// may need to include, for instance, a newline.\n \tMaxScanTokenSize = 64 * 1024"}, {"sha": "01190e99002d441da5a477fa9ec7c8f36a0df44b", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -151,7 +151,7 @@ func delete(m map[Type]Type1, key Type)\n //\tSlice, or map: the number of elements in v; if v is nil, len(v) is zero.\n //\tString: the number of bytes in v.\n //\tChannel: the number of elements queued (unread) in the channel buffer;\n-//\tif v is nil, len(v) is zero.\n+//\t         if v is nil, len(v) is zero.\n // For some arguments, such as a string literal or a simple array expression, the\n // result can be a constant. See the Go language specification's \"Length and\n // capacity\" section for details.\n@@ -226,10 +226,9 @@ func close(c chan<- Type)\n // invocation of F then behaves like a call to panic, terminating G's\n // execution and running any deferred functions. This continues until all\n // functions in the executing goroutine have stopped, in reverse order. At\n-// that point, the program is terminated and the error condition is reported,\n-// including the value of the argument to panic. This termination sequence\n-// is called panicking and can be controlled by the built-in function\n-// recover.\n+// that point, the program is terminated with a non-zero exit code. This\n+// termination sequence is called panicking and can be controlled by the\n+// built-in function recover.\n func panic(v interface{})\n \n // The recover built-in function allows a program to manage behavior of a"}, {"sha": "f19a4cfff0926c7eba61cead788062b074b1a091", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -21,9 +21,6 @@ type Buffer struct {\n \tbuf      []byte // contents are the bytes buf[off : len(buf)]\n \toff      int    // read at &buf[off], write at &buf[len(buf)]\n \tlastRead readOp // last read operation, so that Unread* can work correctly.\n-\n-\t// FIXME: it would be advisable to align Buffer to cachelines to avoid false\n-\t// sharing.\n }\n \n // The readOp constants describe the last action performed on\n@@ -385,13 +382,15 @@ func (b *Buffer) UnreadRune() error {\n \treturn nil\n }\n \n+var errUnreadByte = errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a successful read\")\n+\n // UnreadByte unreads the last byte returned by the most recent successful\n // read operation that read at least one byte. If a write has happened since\n // the last read, if the last read returned an error, or if the read read zero\n // bytes, UnreadByte returns an error.\n func (b *Buffer) UnreadByte() error {\n \tif b.lastRead == opInvalid {\n-\t\treturn errors.New(\"bytes.Buffer: UnreadByte: previous operation was not a successful read\")\n+\t\treturn errUnreadByte\n \t}\n \tb.lastRead = opInvalid\n \tif b.off > 0 {"}, {"sha": "7626d277d4f489251303a53022ac258db89fdf13", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -131,20 +131,17 @@ func TestBasicOperations(t *testing.T) {\n \t\tcheck(t, \"TestBasicOperations (3)\", &buf, \"\")\n \n \t\tn, err := buf.Write(testBytes[0:1])\n-\t\tif n != 1 {\n-\t\t\tt.Errorf(\"wrote 1 byte, but n == %d\", n)\n-\t\t}\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"err should always be nil, but err == %s\", err)\n+\t\tif want := 1; err != nil || n != want {\n+\t\t\tt.Errorf(\"Write: got (%d, %v), want (%d, %v)\", n, err, want, nil)\n \t\t}\n \t\tcheck(t, \"TestBasicOperations (4)\", &buf, \"a\")\n \n \t\tbuf.WriteByte(testString[1])\n \t\tcheck(t, \"TestBasicOperations (5)\", &buf, \"ab\")\n \n \t\tn, err = buf.Write(testBytes[2:26])\n-\t\tif n != 24 {\n-\t\t\tt.Errorf(\"wrote 24 bytes, but n == %d\", n)\n+\t\tif want := 24; err != nil || n != want {\n+\t\t\tt.Errorf(\"Write: got (%d, %v), want (%d, %v)\", n, err, want, nil)\n \t\t}\n \t\tcheck(t, \"TestBasicOperations (6)\", &buf, testString[0:26])\n \n@@ -159,15 +156,12 @@ func TestBasicOperations(t *testing.T) {\n \n \t\tbuf.WriteByte(testString[1])\n \t\tc, err := buf.ReadByte()\n-\t\tif err != nil {\n-\t\t\tt.Error(\"ReadByte unexpected eof\")\n-\t\t}\n-\t\tif c != testString[1] {\n-\t\t\tt.Errorf(\"ReadByte wrong value c=%v\", c)\n+\t\tif want := testString[1]; err != nil || c != want {\n+\t\t\tt.Errorf(\"ReadByte: got (%q, %v), want (%q, %v)\", c, err, want, nil)\n \t\t}\n \t\tc, err = buf.ReadByte()\n-\t\tif err == nil {\n-\t\t\tt.Error(\"ReadByte unexpected not eof\")\n+\t\tif err != io.EOF {\n+\t\t\tt.Errorf(\"ReadByte: got (%q, %v), want (%q, %v)\", c, err, byte(0), io.EOF)\n \t\t}\n \t}\n }"}, {"sha": "eb13212384954a772dba3083612b3069e0fe60f4", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 173, "deletions": 24, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -12,23 +12,12 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// Equal returns a boolean reporting whether a and b\n+// Equal reports whether a and b\n // are the same length and contain the same bytes.\n // A nil argument is equivalent to an empty slice.\n func Equal(a, b []byte) bool {\n-\treturn bytealg.Equal(a, b)\n-}\n-\n-func equalPortable(a, b []byte) bool {\n-\tif len(a) != len(b) {\n-\t\treturn false\n-\t}\n-\tfor i, c := range a {\n-\t\tif c != b[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n+\t// Neither cmd/compile nor gccgo allocates for these string conversions.\n+\treturn string(a) == string(b)\n }\n \n // Compare returns an integer comparing two byte slices lexicographically.\n@@ -114,12 +103,34 @@ func indexBytePortable(s []byte, c byte) int {\n // LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n func LastIndex(s, sep []byte) int {\n \tn := len(sep)\n-\tif n == 0 {\n+\tswitch {\n+\tcase n == 0:\n \t\treturn len(s)\n+\tcase n == 1:\n+\t\treturn LastIndexByte(s, sep[0])\n+\tcase n == len(s):\n+\t\tif Equal(s, sep) {\n+\t\t\treturn 0\n+\t\t}\n+\t\treturn -1\n+\tcase n > len(s):\n+\t\treturn -1\n \t}\n-\tc := sep[0]\n-\tfor i := len(s) - n; i >= 0; i-- {\n-\t\tif s[i] == c && (n == 1 || Equal(s[i:i+n], sep)) {\n+\t// Rabin-Karp search from the end of the string\n+\thashss, pow := hashStrRev(sep)\n+\tlast := len(s) - n\n+\tvar h uint32\n+\tfor i := len(s) - 1; i >= last; i-- {\n+\t\th = h*primeRK + uint32(s[i])\n+\t}\n+\tif h == hashss && Equal(s[last:], sep) {\n+\t\treturn last\n+\t}\n+\tfor i := last - 1; i >= 0; i-- {\n+\t\th *= primeRK\n+\t\th += uint32(s[i])\n+\t\th -= pow * uint32(s[i+n])\n+\t\tif h == hashss && Equal(s[i:i+n], sep) {\n \t\t\treturn i\n \t\t}\n \t}\n@@ -477,13 +488,16 @@ func Map(mapping func(r rune) rune, s []byte) []byte {\n // It panics if count is negative or if\n // the result of (len(b) * count) overflows.\n func Repeat(b []byte, count int) []byte {\n+\tif count == 0 {\n+\t\treturn []byte{}\n+\t}\n \t// Since we cannot return an error on overflow,\n \t// we should panic if the repeat will generate\n \t// an overflow.\n \t// See Issue golang.org/issue/16237.\n \tif count < 0 {\n \t\tpanic(\"bytes: negative Repeat count\")\n-\t} else if count > 0 && len(b)*count/count != len(b) {\n+\t} else if len(b)*count/count != len(b) {\n \t\tpanic(\"bytes: Repeat count causes overflow\")\n \t}\n \n@@ -496,11 +510,66 @@ func Repeat(b []byte, count int) []byte {\n \treturn nb\n }\n \n-// ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n-func ToUpper(s []byte) []byte { return Map(unicode.ToUpper, s) }\n+// ToUpper returns a copy of the byte slice s with all Unicode letters mapped to\n+// their upper case.\n+func ToUpper(s []byte) []byte {\n+\tisASCII, hasLower := true, false\n+\tfor i := 0; i < len(s); i++ {\n+\t\tc := s[i]\n+\t\tif c >= utf8.RuneSelf {\n+\t\t\tisASCII = false\n+\t\t\tbreak\n+\t\t}\n+\t\thasLower = hasLower || ('a' <= c && c <= 'z')\n+\t}\n+\n+\tif isASCII { // optimize for ASCII-only byte slices.\n+\t\tif !hasLower {\n+\t\t\t// Just return a copy.\n+\t\t\treturn append([]byte(\"\"), s...)\n+\t\t}\n+\t\tb := make([]byte, len(s))\n+\t\tfor i := 0; i < len(s); i++ {\n+\t\t\tc := s[i]\n+\t\t\tif 'a' <= c && c <= 'z' {\n+\t\t\t\tc -= 'a' - 'A'\n+\t\t\t}\n+\t\t\tb[i] = c\n+\t\t}\n+\t\treturn b\n+\t}\n+\treturn Map(unicode.ToUpper, s)\n+}\n \n-// ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n-func ToLower(s []byte) []byte { return Map(unicode.ToLower, s) }\n+// ToLower returns a copy of the byte slice s with all Unicode letters mapped to\n+// their lower case.\n+func ToLower(s []byte) []byte {\n+\tisASCII, hasUpper := true, false\n+\tfor i := 0; i < len(s); i++ {\n+\t\tc := s[i]\n+\t\tif c >= utf8.RuneSelf {\n+\t\t\tisASCII = false\n+\t\t\tbreak\n+\t\t}\n+\t\thasUpper = hasUpper || ('A' <= c && c <= 'Z')\n+\t}\n+\n+\tif isASCII { // optimize for ASCII-only byte slices.\n+\t\tif !hasUpper {\n+\t\t\treturn append([]byte(\"\"), s...)\n+\t\t}\n+\t\tb := make([]byte, len(s))\n+\t\tfor i := 0; i < len(s); i++ {\n+\t\t\tc := s[i]\n+\t\t\tif 'A' <= c && c <= 'Z' {\n+\t\t\t\tc += 'a' - 'A'\n+\t\t\t}\n+\t\t\tb[i] = c\n+\t\t}\n+\t\treturn b\n+\t}\n+\treturn Map(unicode.ToLower, s)\n+}\n \n // ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n func ToTitle(s []byte) []byte { return Map(unicode.ToTitle, s) }\n@@ -523,6 +592,35 @@ func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte {\n \treturn Map(c.ToTitle, s)\n }\n \n+// ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes\n+// representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.\n+func ToValidUTF8(s, replacement []byte) []byte {\n+\tb := make([]byte, 0, len(s)+len(replacement))\n+\tinvalid := false // previous byte was from an invalid UTF-8 sequence\n+\tfor i := 0; i < len(s); {\n+\t\tc := s[i]\n+\t\tif c < utf8.RuneSelf {\n+\t\t\ti++\n+\t\t\tinvalid = false\n+\t\t\tb = append(b, byte(c))\n+\t\t\tcontinue\n+\t\t}\n+\t\t_, wid := utf8.DecodeRune(s[i:])\n+\t\tif wid == 1 {\n+\t\t\ti++\n+\t\t\tif !invalid {\n+\t\t\t\tinvalid = true\n+\t\t\t\tb = append(b, replacement...)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tinvalid = false\n+\t\tb = append(b, s[i:i+wid]...)\n+\t\ti += wid\n+\t}\n+\treturn b\n+}\n+\n // isSeparator reports whether the rune could mark a word boundary.\n // TODO: update when package unicode captures more of the properties.\n func isSeparator(r rune) bool {\n@@ -734,7 +832,41 @@ func TrimRight(s []byte, cutset string) []byte {\n // TrimSpace returns a subslice of s by slicing off all leading and\n // trailing white space, as defined by Unicode.\n func TrimSpace(s []byte) []byte {\n-\treturn TrimFunc(s, unicode.IsSpace)\n+\t// Fast path for ASCII: look for the first ASCII non-space byte\n+\tstart := 0\n+\tfor ; start < len(s); start++ {\n+\t\tc := s[start]\n+\t\tif c >= utf8.RuneSelf {\n+\t\t\t// If we run into a non-ASCII byte, fall back to the\n+\t\t\t// slower unicode-aware method on the remaining bytes\n+\t\t\treturn TrimFunc(s[start:], unicode.IsSpace)\n+\t\t}\n+\t\tif asciiSpace[c] == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// Now look for the first ASCII non-space byte from the end\n+\tstop := len(s)\n+\tfor ; stop > start; stop-- {\n+\t\tc := s[stop-1]\n+\t\tif c >= utf8.RuneSelf {\n+\t\t\treturn TrimFunc(s[start:stop], unicode.IsSpace)\n+\t\t}\n+\t\tif asciiSpace[c] == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\t// At this point s[start:stop] starts and ends with an ASCII\n+\t// non-space bytes, so we're done. Non-ASCII cases have already\n+\t// been handled above.\n+\tif start == stop {\n+\t\t// Special case to preserve previous TrimLeftFunc behavior,\n+\t\t// returning nil instead of empty slice if all spaces.\n+\t\treturn nil\n+\t}\n+\treturn s[start:stop]\n }\n \n // Runes interprets s as a sequence of UTF-8-encoded code points.\n@@ -987,3 +1119,20 @@ func hashStr(sep []byte) (uint32, uint32) {\n \t}\n \treturn hash, pow\n }\n+\n+// hashStrRev returns the hash of the reverse of sep and the\n+// appropriate multiplicative factor for use in Rabin-Karp algorithm.\n+func hashStrRev(sep []byte) (uint32, uint32) {\n+\thash := uint32(0)\n+\tfor i := len(sep) - 1; i >= 0; i-- {\n+\t\thash = hash*primeRK + uint32(sep[i])\n+\t}\n+\tvar pow, sq uint32 = 1, primeRK\n+\tfor i := len(sep); i > 0; i >>= 1 {\n+\t\tif i&1 != 0 {\n+\t\t\tpow *= sq\n+\t\t}\n+\t\tsq *= sq\n+\t}\n+\treturn hash, pow\n+}"}, {"sha": "ebff5f00e58054d587f7c0f9e51399b25455d670", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 250, "deletions": 87, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -52,15 +52,17 @@ type BinOpTest struct {\n }\n \n func TestEqual(t *testing.T) {\n-\tfor _, tt := range compareTests {\n-\t\teql := Equal(tt.a, tt.b)\n-\t\tif eql != (tt.i == 0) {\n-\t\t\tt.Errorf(`Equal(%q, %q) = %v`, tt.a, tt.b, eql)\n-\t\t}\n-\t\teql = EqualPortable(tt.a, tt.b)\n-\t\tif eql != (tt.i == 0) {\n-\t\t\tt.Errorf(`EqualPortable(%q, %q) = %v`, tt.a, tt.b, eql)\n+\t// Run the tests and check for allocation at the same time.\n+\tallocs := testing.AllocsPerRun(10, func() {\n+\t\tfor _, tt := range compareTests {\n+\t\t\teql := Equal(tt.a, tt.b)\n+\t\t\tif eql != (tt.i == 0) {\n+\t\t\t\tt.Errorf(`Equal(%q, %q) = %v`, tt.a, tt.b, eql)\n+\t\t\t}\n \t\t}\n+\t})\n+\tif allocs > 0 {\n+\t\tt.Errorf(\"Equal allocated %v times\", allocs)\n \t}\n }\n \n@@ -577,11 +579,6 @@ func BenchmarkEqual(b *testing.B) {\n \tbenchBytes(b, sizes, bmEqual(Equal))\n }\n \n-func BenchmarkEqualPort(b *testing.B) {\n-\tsizes := []int{1, 6, 32, 4 << 10, 4 << 20, 64 << 20}\n-\tbenchBytes(b, sizes, bmEqual(EqualPortable))\n-}\n-\n func bmEqual(equal func([]byte, []byte) bool) func(b *testing.B, n int) {\n \treturn func(b *testing.B, n int) {\n \t\tif len(bmbuf) < 2*n {\n@@ -682,34 +679,6 @@ func BenchmarkCountSingle(b *testing.B) {\n \t})\n }\n \n-type ExplodeTest struct {\n-\ts string\n-\tn int\n-\ta []string\n-}\n-\n-var explodetests = []ExplodeTest{\n-\t{\"\", -1, []string{}},\n-\t{abcd, -1, []string{\"a\", \"b\", \"c\", \"d\"}},\n-\t{faces, -1, []string{\"\u263a\", \"\u263b\", \"\u2639\"}},\n-\t{abcd, 2, []string{\"a\", \"bcd\"}},\n-}\n-\n-func TestExplode(t *testing.T) {\n-\tfor _, tt := range explodetests {\n-\t\ta := SplitN([]byte(tt.s), nil, tt.n)\n-\t\tresult := sliceOfString(a)\n-\t\tif !eq(result, tt.a) {\n-\t\t\tt.Errorf(`Explode(\"%s\", %d) = %v; want %v`, tt.s, tt.n, result, tt.a)\n-\t\t\tcontinue\n-\t\t}\n-\t\ts := Join(a, []byte{})\n-\t\tif string(s) != tt.s {\n-\t\t\tt.Errorf(`Join(Explode(\"%s\", %d), \"\") = \"%s\"`, tt.s, tt.n, s)\n-\t\t}\n-\t}\n-}\n-\n type SplitTest struct {\n \ts   string\n \tsep string\n@@ -718,7 +687,9 @@ type SplitTest struct {\n }\n \n var splittests = []SplitTest{\n+\t{\"\", \"\", -1, []string{}},\n \t{abcd, \"a\", 0, nil},\n+\t{abcd, \"\", 2, []string{\"a\", \"bcd\"}},\n \t{abcd, \"a\", -1, []string{\"\", \"bcd\"}},\n \t{abcd, \"z\", -1, []string{\"abcd\"}},\n \t{abcd, \"\", -1, []string{\"a\", \"b\", \"c\", \"d\"}},\n@@ -748,7 +719,7 @@ func TestSplit(t *testing.T) {\n \t\t\tt.Errorf(`Split(%q, %q, %d) = %v; want %v`, tt.s, tt.sep, tt.n, result, tt.a)\n \t\t\tcontinue\n \t\t}\n-\t\tif tt.n == 0 {\n+\t\tif tt.n == 0 || len(a) == 0 {\n \t\t\tcontinue\n \t\t}\n \n@@ -914,54 +885,72 @@ func TestFieldsFunc(t *testing.T) {\n }\n \n // Test case for any function which accepts and returns a byte slice.\n-// For ease of creation, we write the byte slices as strings.\n+// For ease of creation, we write the input byte slice as a string.\n type StringTest struct {\n-\tin, out string\n+\tin  string\n+\tout []byte\n }\n \n var upperTests = []StringTest{\n-\t{\"\", \"\"},\n-\t{\"abc\", \"ABC\"},\n-\t{\"AbC123\", \"ABC123\"},\n-\t{\"azAZ09_\", \"AZAZ09_\"},\n-\t{\"\\u0250\\u0250\\u0250\\u0250\\u0250\", \"\\u2C6F\\u2C6F\\u2C6F\\u2C6F\\u2C6F\"}, // grows one byte per char\n+\t{\"\", []byte(\"\")},\n+\t{\"ONLYUPPER\", []byte(\"ONLYUPPER\")},\n+\t{\"abc\", []byte(\"ABC\")},\n+\t{\"AbC123\", []byte(\"ABC123\")},\n+\t{\"azAZ09_\", []byte(\"AZAZ09_\")},\n+\t{\"longStrinGwitHmixofsmaLLandcAps\", []byte(\"LONGSTRINGWITHMIXOFSMALLANDCAPS\")},\n+\t{\"long\\u0250string\\u0250with\\u0250nonascii\\u2C6Fchars\", []byte(\"LONG\\u2C6FSTRING\\u2C6FWITH\\u2C6FNONASCII\\u2C6FCHARS\")},\n+\t{\"\\u0250\\u0250\\u0250\\u0250\\u0250\", []byte(\"\\u2C6F\\u2C6F\\u2C6F\\u2C6F\\u2C6F\")}, // grows one byte per char\n+\t{\"a\\u0080\\U0010FFFF\", []byte(\"A\\u0080\\U0010FFFF\")},                           // test utf8.RuneSelf and utf8.MaxRune\n }\n \n var lowerTests = []StringTest{\n-\t{\"\", \"\"},\n-\t{\"abc\", \"abc\"},\n-\t{\"AbC123\", \"abc123\"},\n-\t{\"azAZ09_\", \"azaz09_\"},\n-\t{\"\\u2C6D\\u2C6D\\u2C6D\\u2C6D\\u2C6D\", \"\\u0251\\u0251\\u0251\\u0251\\u0251\"}, // shrinks one byte per char\n+\t{\"\", []byte(\"\")},\n+\t{\"abc\", []byte(\"abc\")},\n+\t{\"AbC123\", []byte(\"abc123\")},\n+\t{\"azAZ09_\", []byte(\"azaz09_\")},\n+\t{\"longStrinGwitHmixofsmaLLandcAps\", []byte(\"longstringwithmixofsmallandcaps\")},\n+\t{\"LONG\\u2C6FSTRING\\u2C6FWITH\\u2C6FNONASCII\\u2C6FCHARS\", []byte(\"long\\u0250string\\u0250with\\u0250nonascii\\u0250chars\")},\n+\t{\"\\u2C6D\\u2C6D\\u2C6D\\u2C6D\\u2C6D\", []byte(\"\\u0251\\u0251\\u0251\\u0251\\u0251\")}, // shrinks one byte per char\n+\t{\"A\\u0080\\U0010FFFF\", []byte(\"a\\u0080\\U0010FFFF\")},                           // test utf8.RuneSelf and utf8.MaxRune\n }\n \n const space = \"\\t\\v\\r\\f\\n\\u0085\\u00a0\\u2000\\u3000\"\n \n var trimSpaceTests = []StringTest{\n-\t{\"\", \"\"},\n-\t{\"abc\", \"abc\"},\n-\t{space + \"abc\" + space, \"abc\"},\n-\t{\" \", \"\"},\n-\t{\" \\t\\r\\n \\t\\t\\r\\r\\n\\n \", \"\"},\n-\t{\" \\t\\r\\n x\\t\\t\\r\\r\\n\\n \", \"x\"},\n-\t{\" \\u2000\\t\\r\\n x\\t\\t\\r\\r\\ny\\n \\u3000\", \"x\\t\\t\\r\\r\\ny\"},\n-\t{\"1 \\t\\r\\n2\", \"1 \\t\\r\\n2\"},\n-\t{\" x\\x80\", \"x\\x80\"},\n-\t{\" x\\xc0\", \"x\\xc0\"},\n-\t{\"x \\xc0\\xc0 \", \"x \\xc0\\xc0\"},\n-\t{\"x \\xc0\", \"x \\xc0\"},\n-\t{\"x \\xc0 \", \"x \\xc0\"},\n-\t{\"x \\xc0\\xc0 \", \"x \\xc0\\xc0\"},\n-\t{\"x \u263a\\xc0\\xc0 \", \"x \u263a\\xc0\\xc0\"},\n-\t{\"x \u263a \", \"x \u263a\"},\n+\t{\"\", nil},\n+\t{\"  a\", []byte(\"a\")},\n+\t{\"b  \", []byte(\"b\")},\n+\t{\"abc\", []byte(\"abc\")},\n+\t{space + \"abc\" + space, []byte(\"abc\")},\n+\t{\" \", nil},\n+\t{\"\\u3000 \", nil},\n+\t{\" \\u3000\", nil},\n+\t{\" \\t\\r\\n \\t\\t\\r\\r\\n\\n \", nil},\n+\t{\" \\t\\r\\n x\\t\\t\\r\\r\\n\\n \", []byte(\"x\")},\n+\t{\" \\u2000\\t\\r\\n x\\t\\t\\r\\r\\ny\\n \\u3000\", []byte(\"x\\t\\t\\r\\r\\ny\")},\n+\t{\"1 \\t\\r\\n2\", []byte(\"1 \\t\\r\\n2\")},\n+\t{\" x\\x80\", []byte(\"x\\x80\")},\n+\t{\" x\\xc0\", []byte(\"x\\xc0\")},\n+\t{\"x \\xc0\\xc0 \", []byte(\"x \\xc0\\xc0\")},\n+\t{\"x \\xc0\", []byte(\"x \\xc0\")},\n+\t{\"x \\xc0 \", []byte(\"x \\xc0\")},\n+\t{\"x \\xc0\\xc0 \", []byte(\"x \\xc0\\xc0\")},\n+\t{\"x \u263a\\xc0\\xc0 \", []byte(\"x \u263a\\xc0\\xc0\")},\n+\t{\"x \u263a \", []byte(\"x \u263a\")},\n }\n \n // Execute f on each test case.  funcName should be the name of f; it's used\n // in failure reports.\n func runStringTests(t *testing.T, f func([]byte) []byte, funcName string, testCases []StringTest) {\n \tfor _, tc := range testCases {\n-\t\tactual := string(f([]byte(tc.in)))\n-\t\tif actual != tc.out {\n+\t\tactual := f([]byte(tc.in))\n+\t\tif actual == nil && tc.out != nil {\n+\t\t\tt.Errorf(\"%s(%q) = nil; want %q\", funcName, tc.in, tc.out)\n+\t\t}\n+\t\tif actual != nil && tc.out == nil {\n+\t\t\tt.Errorf(\"%s(%q) = %q; want nil\", funcName, tc.in, actual)\n+\t\t}\n+\t\tif !Equal(actual, tc.out) {\n \t\t\tt.Errorf(\"%s(%q) = %q; want %q\", funcName, tc.in, actual, tc.out)\n \t\t}\n \t}\n@@ -1049,6 +1038,64 @@ func TestToUpper(t *testing.T) { runStringTests(t, ToUpper, \"ToUpper\", upperTest\n \n func TestToLower(t *testing.T) { runStringTests(t, ToLower, \"ToLower\", lowerTests) }\n \n+func BenchmarkToUpper(b *testing.B) {\n+\tfor _, tc := range upperTests {\n+\t\ttin := []byte(tc.in)\n+\t\tb.Run(tc.in, func(b *testing.B) {\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tactual := ToUpper(tin)\n+\t\t\t\tif !Equal(actual, tc.out) {\n+\t\t\t\t\tb.Errorf(\"ToUpper(%q) = %q; want %q\", tc.in, actual, tc.out)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func BenchmarkToLower(b *testing.B) {\n+\tfor _, tc := range lowerTests {\n+\t\ttin := []byte(tc.in)\n+\t\tb.Run(tc.in, func(b *testing.B) {\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tactual := ToLower(tin)\n+\t\t\t\tif !Equal(actual, tc.out) {\n+\t\t\t\t\tb.Errorf(\"ToLower(%q) = %q; want %q\", tc.in, actual, tc.out)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var toValidUTF8Tests = []struct {\n+\tin   string\n+\trepl string\n+\tout  string\n+}{\n+\t{\"\", \"\\uFFFD\", \"\"},\n+\t{\"abc\", \"\\uFFFD\", \"abc\"},\n+\t{\"\\uFDDD\", \"\\uFFFD\", \"\\uFDDD\"},\n+\t{\"a\\xffb\", \"\\uFFFD\", \"a\\uFFFDb\"},\n+\t{\"a\\xffb\\uFFFD\", \"X\", \"aXb\\uFFFD\"},\n+\t{\"a\u263a\\xffb\u263a\\xC0\\xAFc\u263a\\xff\", \"\", \"a\u263ab\u263ac\u263a\"},\n+\t{\"a\u263a\\xffb\u263a\\xC0\\xAFc\u263a\\xff\", \"\u65e5\u672c\u8a9e\", \"a\u263a\u65e5\u672c\u8a9eb\u263a\u65e5\u672c\u8a9ec\u263a\u65e5\u672c\u8a9e\"},\n+\t{\"\\xC0\\xAF\", \"\\uFFFD\", \"\\uFFFD\"},\n+\t{\"\\xE0\\x80\\xAF\", \"\\uFFFD\", \"\\uFFFD\"},\n+\t{\"\\xed\\xa0\\x80\", \"abc\", \"abc\"},\n+\t{\"\\xed\\xbf\\xbf\", \"\\uFFFD\", \"\\uFFFD\"},\n+\t{\"\\xF0\\x80\\x80\\xaf\", \"\u263a\", \"\u263a\"},\n+\t{\"\\xF8\\x80\\x80\\x80\\xAF\", \"\\uFFFD\", \"\\uFFFD\"},\n+\t{\"\\xFC\\x80\\x80\\x80\\x80\\xAF\", \"\\uFFFD\", \"\\uFFFD\"},\n+}\n+\n+func TestToValidUTF8(t *testing.T) {\n+\tfor _, tc := range toValidUTF8Tests {\n+\t\tgot := ToValidUTF8([]byte(tc.in), []byte(tc.repl))\n+\t\tif !Equal(got, []byte(tc.out)) {\n+\t\t\tt.Errorf(\"ToValidUTF8(%q, %q) = %q; want %q\", tc.in, tc.repl, got, tc.out)\n+\t\t}\n+\t}\n+}\n+\n func TestTrimSpace(t *testing.T) { runStringTests(t, TrimSpace, \"TrimSpace\", trimSpaceTests) }\n \n type RepeatTest struct {\n@@ -1255,8 +1302,11 @@ var isValidRune = predicate{\n }\n \n type TrimFuncTest struct {\n-\tf       predicate\n-\tin, out string\n+\tf        predicate\n+\tin       string\n+\ttrimOut  []byte\n+\tleftOut  []byte\n+\trightOut []byte\n }\n \n func not(p predicate) predicate {\n@@ -1269,20 +1319,68 @@ func not(p predicate) predicate {\n }\n \n var trimFuncTests = []TrimFuncTest{\n-\t{isSpace, space + \" hello \" + space, \"hello\"},\n-\t{isDigit, \"\\u0e50\\u0e5212hello34\\u0e50\\u0e51\", \"hello\"},\n-\t{isUpper, \"\\u2C6F\\u2C6F\\u2C6F\\u2C6FABCDhelloEF\\u2C6F\\u2C6FGH\\u2C6F\\u2C6F\", \"hello\"},\n-\t{not(isSpace), \"hello\" + space + \"hello\", space},\n-\t{not(isDigit), \"hello\\u0e50\\u0e521234\\u0e50\\u0e51helo\", \"\\u0e50\\u0e521234\\u0e50\\u0e51\"},\n-\t{isValidRune, \"ab\\xc0a\\xc0cd\", \"\\xc0a\\xc0\"},\n-\t{not(isValidRune), \"\\xc0a\\xc0\", \"a\"},\n+\t{isSpace, space + \" hello \" + space,\n+\t\t[]byte(\"hello\"),\n+\t\t[]byte(\"hello \" + space),\n+\t\t[]byte(space + \" hello\")},\n+\t{isDigit, \"\\u0e50\\u0e5212hello34\\u0e50\\u0e51\",\n+\t\t[]byte(\"hello\"),\n+\t\t[]byte(\"hello34\\u0e50\\u0e51\"),\n+\t\t[]byte(\"\\u0e50\\u0e5212hello\")},\n+\t{isUpper, \"\\u2C6F\\u2C6F\\u2C6F\\u2C6FABCDhelloEF\\u2C6F\\u2C6FGH\\u2C6F\\u2C6F\",\n+\t\t[]byte(\"hello\"),\n+\t\t[]byte(\"helloEF\\u2C6F\\u2C6FGH\\u2C6F\\u2C6F\"),\n+\t\t[]byte(\"\\u2C6F\\u2C6F\\u2C6F\\u2C6FABCDhello\")},\n+\t{not(isSpace), \"hello\" + space + \"hello\",\n+\t\t[]byte(space),\n+\t\t[]byte(space + \"hello\"),\n+\t\t[]byte(\"hello\" + space)},\n+\t{not(isDigit), \"hello\\u0e50\\u0e521234\\u0e50\\u0e51helo\",\n+\t\t[]byte(\"\\u0e50\\u0e521234\\u0e50\\u0e51\"),\n+\t\t[]byte(\"\\u0e50\\u0e521234\\u0e50\\u0e51helo\"),\n+\t\t[]byte(\"hello\\u0e50\\u0e521234\\u0e50\\u0e51\")},\n+\t{isValidRune, \"ab\\xc0a\\xc0cd\",\n+\t\t[]byte(\"\\xc0a\\xc0\"),\n+\t\t[]byte(\"\\xc0a\\xc0cd\"),\n+\t\t[]byte(\"ab\\xc0a\\xc0\")},\n+\t{not(isValidRune), \"\\xc0a\\xc0\",\n+\t\t[]byte(\"a\"),\n+\t\t[]byte(\"a\\xc0\"),\n+\t\t[]byte(\"\\xc0a\")},\n+\t// The nils returned by TrimLeftFunc are odd behavior, but we need\n+\t// to preserve backwards compatibility.\n+\t{isSpace, \"\",\n+\t\tnil,\n+\t\tnil,\n+\t\t[]byte(\"\")},\n+\t{isSpace, \" \",\n+\t\tnil,\n+\t\tnil,\n+\t\t[]byte(\"\")},\n }\n \n func TestTrimFunc(t *testing.T) {\n \tfor _, tc := range trimFuncTests {\n-\t\tactual := string(TrimFunc([]byte(tc.in), tc.f.f))\n-\t\tif actual != tc.out {\n-\t\t\tt.Errorf(\"TrimFunc(%q, %q) = %q; want %q\", tc.in, tc.f.name, actual, tc.out)\n+\t\ttrimmers := []struct {\n+\t\t\tname string\n+\t\t\ttrim func(s []byte, f func(r rune) bool) []byte\n+\t\t\tout  []byte\n+\t\t}{\n+\t\t\t{\"TrimFunc\", TrimFunc, tc.trimOut},\n+\t\t\t{\"TrimLeftFunc\", TrimLeftFunc, tc.leftOut},\n+\t\t\t{\"TrimRightFunc\", TrimRightFunc, tc.rightOut},\n+\t\t}\n+\t\tfor _, trimmer := range trimmers {\n+\t\t\tactual := trimmer.trim([]byte(tc.in), tc.f.f)\n+\t\t\tif actual == nil && trimmer.out != nil {\n+\t\t\t\tt.Errorf(\"%s(%q, %q) = nil; want %q\", trimmer.name, tc.in, tc.f.name, trimmer.out)\n+\t\t\t}\n+\t\t\tif actual != nil && trimmer.out == nil {\n+\t\t\t\tt.Errorf(\"%s(%q, %q) = %q; want nil\", trimmer.name, tc.in, tc.f.name, actual)\n+\t\t\t}\n+\t\t\tif !Equal(actual, trimmer.out) {\n+\t\t\t\tt.Errorf(\"%s(%q, %q) = %q; want %q\", trimmer.name, tc.in, tc.f.name, actual, trimmer.out)\n+\t\t\t}\n \t\t}\n \t}\n }\n@@ -1622,9 +1720,41 @@ func BenchmarkFieldsFunc(b *testing.B) {\n }\n \n func BenchmarkTrimSpace(b *testing.B) {\n-\ts := []byte(\"  Some text.  \\n\")\n-\tfor i := 0; i < b.N; i++ {\n-\t\tTrimSpace(s)\n+\ttests := []struct {\n+\t\tname  string\n+\t\tinput []byte\n+\t}{\n+\t\t{\"NoTrim\", []byte(\"typical\")},\n+\t\t{\"ASCII\", []byte(\"  foo bar  \")},\n+\t\t{\"SomeNonASCII\", []byte(\"    \\u2000\\t\\r\\n x\\t\\t\\r\\r\\ny\\n \\u3000    \")},\n+\t\t{\"JustNonASCII\", []byte(\"\\u2000\\u2000\\u2000\u263a\u263a\u263a\u263a\\u3000\\u3000\\u3000\")},\n+\t}\n+\tfor _, test := range tests {\n+\t\tb.Run(test.name, func(b *testing.B) {\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tTrimSpace(test.input)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func BenchmarkToValidUTF8(b *testing.B) {\n+\ttests := []struct {\n+\t\tname  string\n+\t\tinput []byte\n+\t}{\n+\t\t{\"Valid\", []byte(\"typical\")},\n+\t\t{\"InvalidASCII\", []byte(\"foo\\xffbar\")},\n+\t\t{\"InvalidNonASCII\", []byte(\"\u65e5\u672c\u8a9e\\xff\u65e5\u672c\u8a9e\")},\n+\t}\n+\treplacement := []byte(\"\\uFFFD\")\n+\tb.ResetTimer()\n+\tfor _, test := range tests {\n+\t\tb.Run(test.name, func(b *testing.B) {\n+\t\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t\tToValidUTF8(test.input, replacement)\n+\t\t\t}\n+\t\t})\n \t}\n }\n \n@@ -1647,6 +1777,39 @@ func makeBenchInputHard() []byte {\n \n var benchInputHard = makeBenchInputHard()\n \n+func benchmarkIndexHard(b *testing.B, sep []byte) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tIndex(benchInputHard, sep)\n+\t}\n+}\n+\n+func benchmarkLastIndexHard(b *testing.B, sep []byte) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tLastIndex(benchInputHard, sep)\n+\t}\n+}\n+\n+func benchmarkCountHard(b *testing.B, sep []byte) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tCount(benchInputHard, sep)\n+\t}\n+}\n+\n+func BenchmarkIndexHard1(b *testing.B) { benchmarkIndexHard(b, []byte(\"<>\")) }\n+func BenchmarkIndexHard2(b *testing.B) { benchmarkIndexHard(b, []byte(\"</pre>\")) }\n+func BenchmarkIndexHard3(b *testing.B) { benchmarkIndexHard(b, []byte(\"<b>hello world</b>\")) }\n+func BenchmarkIndexHard4(b *testing.B) {\n+\tbenchmarkIndexHard(b, []byte(\"<pre><b>hello</b><strong>world</strong></pre>\"))\n+}\n+\n+func BenchmarkLastIndexHard1(b *testing.B) { benchmarkLastIndexHard(b, []byte(\"<>\")) }\n+func BenchmarkLastIndexHard2(b *testing.B) { benchmarkLastIndexHard(b, []byte(\"</pre>\")) }\n+func BenchmarkLastIndexHard3(b *testing.B) { benchmarkLastIndexHard(b, []byte(\"<b>hello world</b>\")) }\n+\n+func BenchmarkCountHard1(b *testing.B) { benchmarkCountHard(b, []byte(\"<>\")) }\n+func BenchmarkCountHard2(b *testing.B) { benchmarkCountHard(b, []byte(\"</pre>\")) }\n+func BenchmarkCountHard3(b *testing.B) { benchmarkCountHard(b, []byte(\"<b>hello world</b>\")) }\n+\n func BenchmarkSplitEmptySeparator(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tSplit(benchInputHard, nil)"}, {"sha": "5ba7077c1de8532ada65dbef0980f501bcd17e2d", "filename": "libgo/go/bytes/example_test.go", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexample_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -365,6 +365,16 @@ func ExampleToTitle() {\n \t// \u0425\u041b\u0415\u0411\n }\n \n+func ExampleToTitleSpecial() {\n+\tstr := []byte(\"ahoj v\u00fdvoj\u00e1ri golang\")\n+\ttotitle := bytes.ToTitleSpecial(unicode.AzeriCase, str)\n+\tfmt.Println(\"Original : \" + string(str))\n+\tfmt.Println(\"ToTitle : \" + string(totitle))\n+\t// Output:\n+\t// Original : ahoj v\u00fdvoj\u00e1ri golang\n+\t// ToTitle : AHOJ V\u00ddVOJ\u00c1R\u0130 GOLANG\n+}\n+\n func ExampleTrim() {\n \tfmt.Printf(\"[%q]\", bytes.Trim([]byte(\" !!! Achtung! Achtung! !!! \"), \"! \"))\n \t// Output: [\"Achtung! Achtung\"]\n@@ -438,11 +448,31 @@ func ExampleToUpper() {\n \t// Output: GOPHER\n }\n \n+func ExampleToUpperSpecial() {\n+\tstr := []byte(\"ahoj v\u00fdvoj\u00e1ri golang\")\n+\ttotitle := bytes.ToUpperSpecial(unicode.AzeriCase, str)\n+\tfmt.Println(\"Original : \" + string(str))\n+\tfmt.Println(\"ToUpper : \" + string(totitle))\n+\t// Output:\n+\t// Original : ahoj v\u00fdvoj\u00e1ri golang\n+\t// ToUpper : AHOJ V\u00ddVOJ\u00c1R\u0130 GOLANG\n+}\n+\n func ExampleToLower() {\n \tfmt.Printf(\"%s\", bytes.ToLower([]byte(\"Gopher\")))\n \t// Output: gopher\n }\n \n+func ExampleToLowerSpecial() {\n+\tstr := []byte(\"AHOJ V\u00ddVOJ\u00c1R\u0130 GOLANG\")\n+\ttotitle := bytes.ToLowerSpecial(unicode.AzeriCase, str)\n+\tfmt.Println(\"Original : \" + string(str))\n+\tfmt.Println(\"ToLower : \" + string(totitle))\n+\t// Output:\n+\t// Original : AHOJ V\u00ddVOJ\u00c1R\u0130 GOLANG\n+\t// ToLower : ahoj v\u00fdvoj\u00e1ri golang\n+}\n+\n func ExampleReader_Len() {\n \tfmt.Println(bytes.NewReader([]byte(\"Hi!\")).Len())\n \tfmt.Println(bytes.NewReader([]byte(\"\u3053\u3093\u306b\u3061\u306f!\")).Len())"}, {"sha": "b65428d9ce84894e05ecd063fa2a53b803a2c9f8", "filename": "libgo/go/bytes/export_test.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fbytes%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fexport_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,4 +6,3 @@ package bytes\n \n // Export func for testing\n var IndexBytePortable = indexBytePortable\n-var EqualPortable = equalPortable"}, {"sha": "f227d7f85026ab4cc4fd87116fc682cb9aa2d9a3", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -296,7 +296,7 @@ Go functions can be exported for use by C code in the following way:\n \n They will be available in the C code as:\n \n-\textern int64 MyFunction(int arg1, int arg2, GoString arg3);\n+\textern GoInt64 MyFunction(int arg1, int arg2, GoString arg3);\n \textern struct MyFunction2_return MyFunction2(int arg1, int arg2, GoString arg3);\n \n found in the _cgo_export.h generated header, after any preambles\n@@ -710,7 +710,7 @@ _cgo_main.c:\n \n \tint main() { return 0; }\n \tvoid crosscall2(void(*fn)(void*, int, uintptr_t), void *a, int c, uintptr_t ctxt) { }\n-\tuintptr_t _cgo_wait_runtime_init_done() { return 0; }\n+\tuintptr_t _cgo_wait_runtime_init_done(void) { return 0; }\n \tvoid _cgo_release_context(uintptr_t ctxt) { }\n \tchar* _cgo_topofstack(void) { return (char*)0; }\n \tvoid _cgo_allocate(void *a, int c) { }"}, {"sha": "70be6dc9a921f26ecbbaeedfefd9552cd7e59880", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -1274,6 +1274,8 @@ func (p *Package) isVariable(x ast.Expr) bool {\n \t\treturn true\n \tcase *ast.SelectorExpr:\n \t\treturn p.isVariable(x.X)\n+\tcase *ast.IndexExpr:\n+\t\treturn true\n \t}\n \treturn false\n }\n@@ -1609,6 +1611,7 @@ func (p *Package) gccCmd() []string {\n \tc = append(c, p.gccMachine()...)\n \tif goos == \"aix\" {\n \t\tc = append(c, \"-maix64\")\n+\t\tc = append(c, \"-mcmodel=large\")\n \t}\n \tc = append(c, \"-\") //read input from standard input\n \treturn c"}, {"sha": "b4fd9c5a6e326661b0383d77f80319b0a6bebac6", "filename": "libgo/go/cmd/cgo/godefs.go", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgodefs.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -136,21 +136,31 @@ func gofmt(n interface{}) string {\n // (due to the printer possibly inserting newlines because of position\n // information) operators.\n var gofmtLineReplacer = strings.NewReplacer(\n-\t\"{\\n\", \"{\",\n-\t\",\\n\", \",\",\n+\t// Want to replace \\n without ; after everything from\n+\t// https://golang.org/ref/spec#Operators_and_punctuation\n+\t// EXCEPT ++ -- ) ] }\n \t\"++\\n\", \"++;\",\n \t\"--\\n\", \"--;\",\n-\t\"+\\n\", \"+\",\n-\t\"-\\n\", \"-\",\n-\t\"*\\n\", \"*\",\n-\t\"/\\n\", \"/\",\n-\t\"%\\n\", \"%\",\n-\t\"&\\n\", \"&\",\n-\t\"|\\n\", \"|\",\n-\t\"^\\n\", \"^\",\n-\t\"<\\n\", \"<\",\n-\t\">\\n\", \">\",\n-\t\"=\\n\", \"=\",\n+\n+\t\"+\\n\", \"+ \",\n+\t\"-\\n\", \"- \",\n+\t\"*\\n\", \"* \",\n+\t\"/\\n\", \"/ \",\n+\t\"%\\n\", \"% \",\n+\t\"&\\n\", \"& \",\n+\t\"|\\n\", \"| \",\n+\t\"^\\n\", \"^ \",\n+\t\"<\\n\", \"< \",\n+\t\">\\n\", \"> \",\n+\t\"=\\n\", \"= \",\n+\t\"!\\n\", \"! \", // not possible in gofmt today\n+\t\"(\\n\", \"(\",\n+\t\"[\\n\", \"[\", // not possible in gofmt today\n+\t\"{\\n\", \"{\",\n+\t\",\\n\", \",\",\n+\t\".\\n\", \". \",\n+\t\":\\n\", \": \", // not possible in gofmt today\n+\n \t\"\\n\", \";\",\n )\n "}, {"sha": "77e9108dd23061343c30463117956522571f559f", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -64,14 +64,14 @@ func (p *Package) writeDefs() {\n \tfmt.Fprintf(fm, \"int main() { return 0; }\\n\")\n \tif *importRuntimeCgo {\n \t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int, __SIZE_TYPE__), void *a, int c, __SIZE_TYPE__ ctxt) { }\\n\")\n-\t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done() { return 0; }\\n\")\n+\t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done(void) { return 0; }\\n\")\n \t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__ ctxt) { }\\n\")\n \t\tfmt.Fprintf(fm, \"char* _cgo_topofstack(void) { return (char*)0; }\\n\")\n \t} else {\n \t\t// If we're not importing runtime/cgo, we *are* runtime/cgo,\n \t\t// which provides these functions. We just need a prototype.\n \t\tfmt.Fprintf(fm, \"void crosscall2(void(*fn)(void*, int, __SIZE_TYPE__), void *a, int c, __SIZE_TYPE__ ctxt);\\n\")\n-\t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done();\\n\")\n+\t\tfmt.Fprintf(fm, \"__SIZE_TYPE__ _cgo_wait_runtime_init_done(void);\\n\")\n \t\tfmt.Fprintf(fm, \"void _cgo_release_context(__SIZE_TYPE__);\\n\")\n \t}\n \tfmt.Fprintf(fm, \"void _cgo_allocate(void *a, int c) { }\\n\")\n@@ -341,6 +341,12 @@ func dynimport(obj string) {\n \t\t\tfatalf(\"cannot load imported symbols from XCOFF file %s: %v\", obj, err)\n \t\t}\n \t\tfor _, s := range sym {\n+\t\t\tif s.Name == \"runtime_rt0_go\" || s.Name == \"_rt0_ppc64_aix_lib\" {\n+\t\t\t\t// These symbols are imported by runtime/cgo but\n+\t\t\t\t// must not be added to _cgo_import.go as there are\n+\t\t\t\t// Go symbols.\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s.Name, s.Name, s.Library)\n \t\t}\n \t\tlib, err := f.ImportedLibraries()\n@@ -782,14 +788,14 @@ func (p *Package) writeExports(fgo2, fm, fgcc, fgcch io.Writer) {\n \tfmt.Fprintf(fgcc, \"#include \\\"_cgo_export.h\\\"\\n\\n\")\n \n \t// We use packed structs, but they are always aligned.\n-\t// The pragmas and address-of-packed-member are not recognized as warning groups in clang 3.4.1, so ignore unknown pragmas first.\n-\t// remove as part of #27619 (all: drop support for FreeBSD 10).\n+\t// The pragmas and address-of-packed-member are only recognized as\n+\t// warning groups in clang 4.0+, so ignore unknown pragmas first.\n \tfmt.Fprintf(fgcc, \"#pragma GCC diagnostic ignored \\\"-Wunknown-pragmas\\\"\\n\")\n \tfmt.Fprintf(fgcc, \"#pragma GCC diagnostic ignored \\\"-Wpragmas\\\"\\n\")\n \tfmt.Fprintf(fgcc, \"#pragma GCC diagnostic ignored \\\"-Waddress-of-packed-member\\\"\\n\")\n \n \tfmt.Fprintf(fgcc, \"extern void crosscall2(void (*fn)(void *, int, __SIZE_TYPE__), void *, int, __SIZE_TYPE__);\\n\")\n-\tfmt.Fprintf(fgcc, \"extern __SIZE_TYPE__ _cgo_wait_runtime_init_done();\\n\")\n+\tfmt.Fprintf(fgcc, \"extern __SIZE_TYPE__ _cgo_wait_runtime_init_done(void);\\n\")\n \tfmt.Fprintf(fgcc, \"extern void _cgo_release_context(__SIZE_TYPE__);\\n\\n\")\n \tfmt.Fprintf(fgcc, \"extern char* _cgo_topofstack(void);\")\n \tfmt.Fprintf(fgcc, \"%s\\n\", tsanProlog)\n@@ -1485,10 +1491,11 @@ __cgo_size_assert(double, 8)\n \n extern char* _cgo_topofstack(void);\n \n-/* We use packed structs, but they are always aligned.  */\n-/* The pragmas and address-of-packed-member are not recognized as warning groups in clang 3.4.1, so ignore unknown pragmas first. */\n-/* remove as part of #27619 (all: drop support for FreeBSD 10). */\n-\n+/*\n+  We use packed structs, but they are always aligned.\n+  The pragmas and address-of-packed-member are only recognized as warning\n+  groups in clang 4.0+, so ignore unknown pragmas first.\n+*/\n #pragma GCC diagnostic ignored \"-Wunknown-pragmas\"\n #pragma GCC diagnostic ignored \"-Wpragmas\"\n #pragma GCC diagnostic ignored \"-Waddress-of-packed-member\"\n@@ -1929,5 +1936,5 @@ static void GoInit(void) {\n \t\truntime_iscgo = 1;\n }\n \n-extern __SIZE_TYPE__ _cgo_wait_runtime_init_done() __attribute__ ((weak));\n+extern __SIZE_TYPE__ _cgo_wait_runtime_init_done(void) __attribute__ ((weak));\n `"}, {"sha": "fa60fb63b57cb1e2954a2c8a3b7154c41d4e9243", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 446, "deletions": 236, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -21,7 +21,7 @@\n // \tfix         update packages to use new APIs\n // \tfmt         gofmt (reformat) package sources\n // \tgenerate    generate Go files by processing source\n-// \tget         download and install packages and dependencies\n+// \tget         add dependencies to current module and install them\n // \tinstall     compile and install packages and dependencies\n // \tlist        list packages or modules\n // \tmod         module maintenance\n@@ -47,6 +47,8 @@\n // \timportpath  import path syntax\n // \tmodules     modules, module versions, and more\n // \tmodule-get  module-aware go get\n+// \tmodule-auth module authentication using go.sum\n+// \tmodule-private module configuration for non-public modules\n // \tpackages    package lists and patterns\n // \ttestflag    testing flags\n // \ttestfunc    testing functions\n@@ -73,8 +75,8 @@\n // Build compiles the packages named by the import paths,\n // along with their dependencies, but it does not install the results.\n //\n-// If the arguments to build are a list of .go files, build treats\n-// them as a list of source files specifying a single package.\n+// If the arguments to build are a list of .go files from a single directory,\n+// build treats them as a list of source files specifying a single package.\n //\n // When compiling a single main package, build writes\n // the resulting executable to an output file named after\n@@ -88,10 +90,10 @@\n //\n // When compiling packages, build ignores files that end in '_test.go'.\n //\n-// The -o flag, only allowed when compiling a single package,\n-// forces build to write the resulting executable or object\n-// to the named output file, instead of the default behavior described\n-// in the last two paragraphs.\n+// The -o flag forces build to write the resulting executable or object\n+// to the named output file or directory, instead of the default behavior described\n+// in the last two paragraphs. If the named output is a directory that exists,\n+// then any resulting executables will be written to that directory.\n //\n // The -i flag installs the packages that are dependencies of the target.\n //\n@@ -150,10 +152,18 @@\n // \t\tinstall and load all packages from dir instead of the usual locations.\n // \t\tFor example, when building with a non-standard configuration,\n // \t\tuse -pkgdir to keep generated packages in a separate location.\n-// \t-tags 'tag list'\n-// \t\ta space-separated list of build tags to consider satisfied during the\n+// \t-tags tag,list\n+// \t\ta comma-separated list of build tags to consider satisfied during the\n // \t\tbuild. For more information about build tags, see the description of\n // \t\tbuild constraints in the documentation for the go/build package.\n+// \t\t(Earlier versions of Go used a space-separated list, and that form\n+// \t\tis deprecated but still recognized.)\n+// \t-trimpath\n+// \t\tremove all file system paths from the resulting executable.\n+// \t\tInstead of absolute file system paths, the recorded file names\n+// \t\twill begin with either \"go\" (for the standard library),\n+// \t\tor a module path@version (when using modules),\n+// \t\tor a plain import path (when using GOPATH).\n // \t-toolexec 'cmd args'\n // \t\ta program to use to invoke toolchain programs like vet and asm.\n // \t\tFor example, instead of running asm, the go command will run\n@@ -201,7 +211,8 @@\n // so go clean is mainly concerned with object files left by other\n // tools or by manual invocations of go build.\n //\n-// Specifically, clean removes the following files from each of the\n+// If a package argument is given or the -i or -r flag is set,\n+// clean removes the following files from each of the\n // source directories corresponding to the import paths:\n //\n // \t_obj/            old object directory, left from Makefiles\n@@ -366,7 +377,7 @@\n //\n // Usage:\n //\n-// \tgo env [-json] [var ...]\n+// \tgo env [-json] [-u] [-w] [var ...]\n //\n // Env prints Go environment information.\n //\n@@ -378,6 +389,14 @@\n // The -json flag prints the environment in JSON format\n // instead of as a shell script.\n //\n+// The -u flag requires one or more arguments and unsets\n+// the default setting for the named environment variables,\n+// if one has been set with 'go env -w'.\n+//\n+// The -w flag requires one or more arguments of the\n+// form NAME=VALUE and changes the default settings\n+// of the named environment variables to the given values.\n+//\n // For more about environment variables, see 'go help environment'.\n //\n //\n@@ -503,11 +522,13 @@\n // \"go tool foo\".\n //\n // Generate processes packages in the order given on the command line,\n-// one at a time. If the command line lists .go files, they are treated\n-// as a single package. Within a package, generate processes the\n+// one at a time. If the command line lists .go files from a single directory,\n+// they are treated as a single package. Within a package, generate processes the\n // source files in a package in file name order, one at a time. Within\n // a source file, generate runs generators in the order they appear\n-// in the file, one at a time.\n+// in the file, one at a time. The go generate tool also sets the build\n+// tag \"generate\" so that files may be examined by go generate but ignored\n+// during build.\n //\n // If any generator returns an error exit status, \"go generate\" skips\n // all further processing for that package.\n@@ -533,67 +554,116 @@\n // For more about specifying packages, see 'go help packages'.\n //\n //\n-// Download and install packages and dependencies\n+// Add dependencies to current module and install them\n //\n // Usage:\n //\n-// \tgo get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]\n+// \tgo get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]\n //\n-// Get downloads the packages named by the import paths, along with their\n-// dependencies. It then installs the named packages, like 'go install'.\n+// Get resolves and adds dependencies to the current development module\n+// and then builds and installs them.\n //\n-// The -d flag instructs get to stop after downloading the packages; that is,\n-// it instructs get not to install the packages.\n+// The first step is to resolve which dependencies to add.\n //\n-// The -f flag, valid only when -u is set, forces get -u not to verify that\n-// each package has been checked out from the source control repository\n-// implied by its import path. This can be useful if the source is a local fork\n-// of the original.\n+// For each named package or package pattern, get must decide which version of\n+// the corresponding module to use. By default, get chooses the latest tagged\n+// release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n+// versions, get chooses the latest tagged pre-release version, such as\n+// v0.0.1-pre1. If there are no tagged versions at all, get chooses the latest\n+// known commit.\n //\n-// The -fix flag instructs get to run the fix tool on the downloaded packages\n-// before resolving dependencies or building the code.\n+// This default version selection can be overridden by adding an @version\n+// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n+// For modules stored in source control repositories, the version suffix can\n+// also be a commit hash, branch identifier, or other syntax known to the\n+// source control system, as in 'go get golang.org/x/text@master'.\n //\n-// The -insecure flag permits fetching from repositories and resolving\n-// custom domains using insecure schemes such as HTTP. Use with caution.\n+// If a module under consideration is already a dependency of the current\n+// development module, then get will update the required version.\n+// Specifying a version earlier than the current required version is valid and\n+// downgrades the dependency. The version suffix @none indicates that the\n+// dependency should be removed entirely, downgrading or removing modules\n+// depending on it as needed.\n //\n-// The -t flag instructs get to also download the packages required to build\n-// the tests for the specified packages.\n+// The version suffix @latest explicitly requests the latest minor release of the\n+// given path. The suffix @patch requests the latest patch release: if the path\n+// is already in the build list, the selected version will have the same minor\n+// version. If the path is not already in the build list, @patch is equivalent\n+// to @latest. Neither @latest nor @patch will cause 'go get' to downgrade a module\n+// in the build list if it is required at a newer pre-release version that is\n+// newer than the latest released version.\n //\n-// The -u flag instructs get to use the network to update the named packages\n-// and their dependencies. By default, get uses the network to check out\n-// missing packages but does not use it to look for updates to existing packages.\n+// Although get defaults to using the latest version of the module containing\n+// a named package, it does not use the latest version of that module's\n+// dependencies. Instead it prefers to use the specific dependency versions\n+// requested by that module. For example, if the latest A requires module\n+// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'\n+// will use the latest A but then use B v1.2.3, as requested by A. (If there\n+// are competing requirements for a particular module, then 'go get' resolves\n+// those requirements by taking the maximum requested version.)\n //\n-// The -v flag enables verbose progress and debug output.\n+// The -t flag instructs get to consider modules needed to build tests of\n+// packages specified on the command line.\n //\n-// Get also accepts build flags to control the installation. See 'go help build'.\n+// The -u flag instructs get to update modules providing dependencies\n+// of packages named on the command line to use newer minor or patch\n+// releases when available. Continuing the previous example, 'go get -u A'\n+// will use the latest A with B v1.3.1 (not B v1.2.3). If B requires module C,\n+// but C does not provide any packages needed to build packages in A\n+// (not including tests), then C will not be updated.\n //\n-// When checking out a new package, get creates the target directory\n-// GOPATH/src/<import-path>. If the GOPATH contains multiple entries,\n-// get uses the first one. For more details see: 'go help gopath'.\n+// The -u=patch flag (not -u patch) also instructs get to update dependencies,\n+// but changes the default to select patch releases.\n+// Continuing the previous example,\n+// 'go get -u=patch A@latest' will use the latest A with B v1.2.4 (not B v1.2.3),\n+// while 'go get -u=patch A' will use a patch release of A instead.\n //\n-// When checking out or updating a package, get looks for a branch or tag\n-// that matches the locally installed version of Go. The most important\n-// rule is that if the local installation is running version \"go1\", get\n-// searches for a branch or tag named \"go1\". If no such version exists\n-// it retrieves the default branch of the package.\n+// When the -t and -u flags are used together, get will update\n+// test dependencies as well.\n //\n-// When go get checks out or updates a Git repository,\n-// it also updates any git submodules referenced by the repository.\n+// In general, adding a new dependency may require upgrading\n+// existing dependencies to keep a working build, and 'go get' does\n+// this automatically. Similarly, downgrading one dependency may\n+// require downgrading other dependencies, and 'go get' does\n+// this automatically as well.\n //\n-// Get never checks out or updates code stored in vendor directories.\n+// The -insecure flag permits fetching from repositories and resolving\n+// custom domains using insecure schemes such as HTTP. Use with caution.\n //\n-// For more about specifying packages, see 'go help packages'.\n+// The second step is to download (if needed), build, and install\n+// the named packages.\n //\n-// For more about how 'go get' finds source code to\n-// download, see 'go help importpath'.\n+// If an argument names a module but not a package (because there is no\n+// Go source code in the module's root directory), then the install step\n+// is skipped for that argument, instead of causing a build failure.\n+// For example 'go get golang.org/x/perf' succeeds even though there\n+// is no code corresponding to that import path.\n //\n-// This text describes the behavior of get when using GOPATH\n-// to manage source code and dependencies.\n-// If instead the go command is running in module-aware mode,\n-// the details of get's flags and effects change, as does 'go help get'.\n-// See 'go help modules' and 'go help module-get'.\n+// Note that package patterns are allowed and are expanded after resolving\n+// the module versions. For example, 'go get golang.org/x/perf/cmd/...'\n+// adds the latest golang.org/x/perf and then installs the commands in that\n+// latest version.\n //\n-// See also: go build, go install, go clean.\n+// The -d flag instructs get to download the source code needed to build\n+// the named packages, including downloading necessary dependencies,\n+// but not to build and install them.\n+//\n+// With no package arguments, 'go get' applies to Go package in the\n+// current directory, if any. In particular, 'go get -u' and\n+// 'go get -u=patch' update all the dependencies of that package.\n+// With no package arguments and also without -u, 'go get' is not much more\n+// than 'go install', and 'go get -d' not much more than 'go list'.\n+//\n+// For more about modules, see 'go help modules'.\n+//\n+// For more about specifying packages, see 'go help packages'.\n+//\n+// This text describes the behavior of get using modules to manage source\n+// code and dependencies. If instead the go command is running in GOPATH\n+// mode, the details of get's flags and effects change, as does 'go help get'.\n+// See 'go help modules' and 'go help gopath-get'.\n+//\n+// See also: go build, go install, go clean, go mod.\n //\n //\n // Compile and install packages and dependencies\n@@ -604,6 +674,15 @@\n //\n // Install compiles and installs the packages named by the import paths.\n //\n+// Executables are installed in the directory named by the GOBIN environment\n+// variable, which defaults to $GOPATH/bin or $HOME/go/bin if the GOPATH\n+// environment variable is not set. Executables in $GOROOT\n+// are installed in $GOROOT/bin or $GOTOOLDIR instead of $GOBIN.\n+//\n+// When module-aware mode is disabled, other packages are installed in the\n+// directory $GOPATH/pkg/$GOOS_$GOARCH. When module-aware mode is enabled,\n+// other packages are built and cached but not installed.\n+//\n // The -i flag installs the dependencies of the named packages as well.\n //\n // For more about the build flags, see 'go help build'.\n@@ -648,7 +727,7 @@\n //         StaleReason   string   // explanation for Stale==true\n //         Root          string   // Go root or Go path dir containing this package\n //         ConflictDir   string   // this directory shadows Dir in $GOPATH\n-//         BinaryOnly    bool     // binary-only package: cannot be recompiled from sources\n+//         BinaryOnly    bool     // binary-only package (no longer supported)\n //         ForTest       string   // package is only for use in named test\n //         Export        string   // file containing export data (when using -export)\n //         Module        *Module  // info about package's containing module, if any (can be nil)\n@@ -790,17 +869,18 @@\n // applied to a Go struct, but now a Module struct:\n //\n //     type Module struct {\n-//         Path     string       // module path\n-//         Version  string       // module version\n-//         Versions []string     // available module versions (with -versions)\n-//         Replace  *Module      // replaced by this module\n-//         Time     *time.Time   // time version was created\n-//         Update   *Module      // available update, if any (with -u)\n-//         Main     bool         // is this the main module?\n-//         Indirect bool         // is this module only an indirect dependency of main module?\n-//         Dir      string       // directory holding files for this module, if any\n-//         GoMod    string       // path to go.mod file for this module, if any\n-//         Error    *ModuleError // error loading module\n+//         Path      string       // module path\n+//         Version   string       // module version\n+//         Versions  []string     // available module versions (with -versions)\n+//         Replace   *Module      // replaced by this module\n+//         Time      *time.Time   // time version was created\n+//         Update    *Module      // available update, if any (with -u)\n+//         Main      bool         // is this the main module?\n+//         Indirect  bool         // is this module only an indirect dependency of main module?\n+//         Dir       string       // directory holding files for this module, if any\n+//         GoMod     string       // path to go.mod file for this module, if any\n+//         GoVersion string       // go version used in module\n+//         Error     *ModuleError // error loading module\n //     }\n //\n //     type ModuleError struct {\n@@ -1129,7 +1209,7 @@\n // \tgo run [build flags] [-exec xprog] package [arguments...]\n //\n // Run compiles and runs the named main Go package.\n-// Typically the package is specified as a list of .go source files,\n+// Typically the package is specified as a list of .go source files from a single directory,\n // but it may also be an import path, file system path, or pattern\n // matching a single known package, as in 'go run .' or 'go run my/cmd'.\n //\n@@ -1213,7 +1293,10 @@\n // line. If a package test fails, go test prints the full test output.\n // If invoked with the -bench or -v flag, go test prints the full\n // output even for passing package tests, in order to display the\n-// requested benchmark results or verbose logging.\n+// requested benchmark results or verbose logging. After the package\n+// tests for all of the listed packages finish, and their output is\n+// printed, go test prints a final 'FAIL' status if any package test\n+// has failed.\n //\n // In package list mode only, go test caches successful package test\n // results to avoid unnecessary repeated running of tests. When the\n@@ -1293,9 +1376,27 @@\n //\n // Usage:\n //\n-// \tgo version\n+// \tgo version [-m] [-v] [file ...]\n+//\n+// Version prints the build information for Go executables.\n+//\n+// Go version reports the Go version used to build each of the named\n+// executable files.\n+//\n+// If no files are named on the command line, go version prints its own\n+// version information.\n+//\n+// If a directory is named, go version walks that directory, recursively,\n+// looking for recognized Go binaries and reporting their versions.\n+// By default, go version does not report unrecognized files found\n+// during a directory scan. The -v flag causes it to report unrecognized files.\n //\n-// Version prints the Go version, as reported by runtime.Version.\n+// The -m flag causes go version to print each executable's embedded\n+// module version information, when available. In the output, the module\n+// information consists of multiple lines following the version line, each\n+// indented by a leading tab character.\n+//\n+// See also: go doc runtime/debug.BuildInfo.\n //\n //\n // Report likely mistakes in packages\n@@ -1373,6 +1474,9 @@\n // \t\tBuild the listed main packages, plus all packages that they\n // \t\timport, into a Go plugin. Packages not named main are ignored.\n //\n+// On AIX, when linking a C program that uses a Go archive built with\n+// -buildmode=c-archive, you must pass -Wl,-bnoobjreorder to the C compiler.\n+//\n //\n // Calling between Go and C\n //\n@@ -1434,10 +1538,17 @@\n //\n // Environment variables\n //\n-// The go command, and the tools it invokes, examine a few different\n-// environment variables. For many of these, you can see the default\n-// value of on your system by running 'go env NAME', where NAME is the\n-// name of the variable.\n+// The go command and the tools it invokes consult environment variables\n+// for configuration. If an environment variable is unset, the go command\n+// uses a sensible default setting. To see the effective setting of the\n+// variable <NAME>, run 'go env <NAME>'. To change the default setting,\n+// run 'go env -w <NAME>=<VALUE>'. Defaults changed using 'go env -w'\n+// are recorded in a Go environment configuration file stored in the\n+// per-user configuration directory, as reported by os.UserConfigDir.\n+// The location of the configuration file can be changed by setting\n+// the environment variable GOENV, and 'go env GOENV' prints the\n+// effective location, but 'go env -w' cannot change the default location.\n+// See 'go help env' for details.\n //\n // General-purpose environment variables:\n //\n@@ -1451,33 +1562,43 @@\n // \tGOCACHE\n // \t\tThe directory where the go command will store cached\n // \t\tinformation for reuse in future builds.\n+// \tGOENV\n+// \t\tThe location of the Go environment configuration file.\n+// \t\tCannot be set using 'go env -w'.\n // \tGOFLAGS\n // \t\tA space-separated list of -flag=value settings to apply\n // \t\tto go commands by default, when the given flag is known by\n-// \t\tthe current command. Flags listed on the command-line\n+// \t\tthe current command. Each entry must be a standalone flag.\n+// \t\tBecause the entries are space-separated, flag values must\n+// \t\tnot contain spaces. Flags listed on the command line\n // \t\tare applied after this list and therefore override it.\n // \tGOOS\n // \t\tThe operating system for which to compile code.\n // \t\tExamples are linux, darwin, windows, netbsd.\n // \tGOPATH\n // \t\tFor more details see: 'go help gopath'.\n // \tGOPROXY\n-// \t\tURL of Go module proxy. See 'go help goproxy'.\n-// \tGORACE\n-// \t\tOptions for the race detector.\n-// \t\tSee https://golang.org/doc/articles/race_detector.html.\n+// \t\tURL of Go module proxy. See 'go help modules'.\n+// \tGOPRIVATE, GONOPROXY, GONOSUMDB\n+// \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n+// \t\tof module path prefixes that should always be fetched directly\n+// \t\tor that should not be compared against the checksum database.\n+// \t\tSee 'go help module-private'.\n // \tGOROOT\n // \t\tThe root of the go tree.\n+// \tGOSUMDB\n+// \t\tThe name of checksum database to use and optionally its public key and\n+// \t\tURL. See 'go help module-auth'.\n // \tGOTMPDIR\n // \t\tThe directory where the go command will write\n // \t\ttemporary source files, packages, and binaries.\n //\n-// Each entry in the GOFLAGS list must be a standalone flag.\n-// Because the entries are space-separated, flag values must\n-// not contain spaces.\n-//\n // Environment variables for use with cgo:\n //\n+// \tAR\n+// \t\tThe command to use to manipulate library archives when\n+// \t\tbuilding with the gccgo compiler.\n+// \t\tThe default is 'ar'.\n // \tCC\n // \t\tThe command to use to compile C code.\n // \tCGO_ENABLED\n@@ -1507,12 +1628,10 @@\n // \t\tbut for the linker.\n // \tCXX\n // \t\tThe command to use to compile C++ code.\n+// \tFC\n+// \t\tThe command to use to compile Fortran code.\n // \tPKG_CONFIG\n // \t\tPath to pkg-config tool.\n-// \tAR\n-// \t\tThe command to use to manipulate library archives when\n-// \t\tbuilding with the gccgo compiler.\n-// \t\tThe default is 'ar'.\n //\n // Architecture-specific environment variables:\n //\n@@ -1528,6 +1647,9 @@\n // \tGOMIPS64\n // \t\tFor GOARCH=mips64{,le}, whether to use floating point instructions.\n // \t\tValid values are hardfloat (default), softfloat.\n+// \tGOWASM\n+// \t\tFor GOARCH=wasm, comma-separated list of experimental WebAssembly features to use.\n+// \t\tValid values are satconv, signext.\n //\n // Special-purpose environment variables:\n //\n@@ -1544,14 +1666,18 @@\n // \t\twhen using -linkmode=auto with code that uses cgo.\n // \t\tSet to 0 to disable external linking mode, 1 to enable it.\n // \tGIT_ALLOW_PROTOCOL\n-// \t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n-// \t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n-// \t\tconsidered insecure by 'go get'.\n+// \t\tDefined by Git. A colon-separated list of schemes that are allowed\n+// \t\tto be used with git fetch/clone. If set, any scheme not explicitly\n+// \t\tmentioned will be considered insecure by 'go get'.\n+// \t\tBecause the variable is defined by Git, the default value cannot\n+// \t\tbe set using 'go env -w'.\n //\n // Additional information available from 'go env' but not read from the environment:\n //\n // \tGOEXE\n // \t\tThe executable file name suffix (\".exe\" on Windows, \"\" on other systems).\n+// \tGOGCCFLAGS\n+// \t\tA space-separated list of arguments supplied to the CC command.\n // \tGOHOSTARCH\n // \t\tThe architecture (GOARCH) of the Go toolchain binaries.\n // \tGOHOSTOS\n@@ -1598,15 +1724,6 @@\n // line comment. See the go/build package documentation for\n // more details.\n //\n-// Through the Go 1.12 release, non-test Go source files can also include\n-// a //go:binary-only-package comment, indicating that the package\n-// sources are included for documentation only and must not be used to\n-// build the package binary. This enables distribution of Go packages in\n-// their compiled form alone. Even binary-only packages require accurate\n-// import blocks listing required dependencies, so that those\n-// dependencies can be supplied when linking the resulting command.\n-// Note that this feature is scheduled to be removed after the Go 1.12 release.\n-//\n //\n // The go.mod file\n //\n@@ -1689,6 +1806,13 @@\n // including go build, go get, go install, go list, go test, go mod graph,\n // go mod tidy, and go mod why.\n //\n+// The expected language version, set by the go directive, determines\n+// which language features are available when compiling the module.\n+// Language features available in that version will be available for use.\n+// Language features removed in earlier versions, or added in later versions,\n+// will not be available. Note that the language version does not affect\n+// build tags, which are determined by the Go release being used.\n+//\n //\n // GOPATH environment variable\n //\n@@ -1845,17 +1969,73 @@\n // See https://golang.org/s/go15vendor for details.\n //\n //\n-// Module proxy protocol\n+// Legacy GOPATH go get\n+//\n+// The 'go get' command changes behavior depending on whether the\n+// go command is running in module-aware mode or legacy GOPATH mode.\n+// This help text, accessible as 'go help gopath-get' even in module-aware mode,\n+// describes 'go get' as it operates in legacy GOPATH mode.\n+//\n+// Usage: go get [-d] [-f] [-t] [-u] [-v] [-fix] [-insecure] [build flags] [packages]\n+//\n+// Get downloads the packages named by the import paths, along with their\n+// dependencies. It then installs the named packages, like 'go install'.\n //\n-// The go command by default downloads modules from version control systems\n-// directly, just as 'go get' always has. The GOPROXY environment variable allows\n-// further control over the download source. If GOPROXY is unset, is the empty string,\n-// or is the string \"direct\", downloads use the default direct connection to version\n-// control systems. Setting GOPROXY to \"off\" disallows downloading modules from\n-// any source. Otherwise, GOPROXY is expected to be the URL of a module proxy,\n-// in which case the go command will fetch all modules from that proxy.\n-// No matter the source of the modules, downloaded modules must match existing\n-// entries in go.sum (see 'go help modules' for discussion of verification).\n+// The -d flag instructs get to stop after downloading the packages; that is,\n+// it instructs get not to install the packages.\n+//\n+// The -f flag, valid only when -u is set, forces get -u not to verify that\n+// each package has been checked out from the source control repository\n+// implied by its import path. This can be useful if the source is a local fork\n+// of the original.\n+//\n+// The -fix flag instructs get to run the fix tool on the downloaded packages\n+// before resolving dependencies or building the code.\n+//\n+// The -insecure flag permits fetching from repositories and resolving\n+// custom domains using insecure schemes such as HTTP. Use with caution.\n+//\n+// The -t flag instructs get to also download the packages required to build\n+// the tests for the specified packages.\n+//\n+// The -u flag instructs get to use the network to update the named packages\n+// and their dependencies. By default, get uses the network to check out\n+// missing packages but does not use it to look for updates to existing packages.\n+//\n+// The -v flag enables verbose progress and debug output.\n+//\n+// Get also accepts build flags to control the installation. See 'go help build'.\n+//\n+// When checking out a new package, get creates the target directory\n+// GOPATH/src/<import-path>. If the GOPATH contains multiple entries,\n+// get uses the first one. For more details see: 'go help gopath'.\n+//\n+// When checking out or updating a package, get looks for a branch or tag\n+// that matches the locally installed version of Go. The most important\n+// rule is that if the local installation is running version \"go1\", get\n+// searches for a branch or tag named \"go1\". If no such version exists\n+// it retrieves the default branch of the package.\n+//\n+// When go get checks out or updates a Git repository,\n+// it also updates any git submodules referenced by the repository.\n+//\n+// Get never checks out or updates code stored in vendor directories.\n+//\n+// For more about specifying packages, see 'go help packages'.\n+//\n+// For more about how 'go get' finds source code to\n+// download, see 'go help importpath'.\n+//\n+// This text describes the behavior of get when using GOPATH\n+// to manage source code and dependencies.\n+// If instead the go command is running in module-aware mode,\n+// the details of get's flags and effects change, as does 'go help get'.\n+// See 'go help modules' and 'go help module-get'.\n+//\n+// See also: go build, go install, go clean.\n+//\n+//\n+// Module proxy protocol\n //\n // A Go module proxy is any web server that can respond to GET requests for\n // URLs of a specified form. The requests have no query parameters, so even\n@@ -2104,34 +2284,28 @@\n // Modules replace the old GOPATH-based approach to specifying\n // which source files are used in a given build.\n //\n-// Preliminary module support\n+// Module support\n //\n-// Go 1.11 includes preliminary support for Go modules,\n-// including a new module-aware 'go get' command.\n-// We intend to keep revising this support, while preserving compatibility,\n-// until it can be declared official (no longer preliminary),\n-// and then at a later point we may remove support for work\n-// in GOPATH and the old 'go get' command.\n+// Go 1.13 includes support for Go modules. Module-aware mode is active by default\n+// whenever a go.mod file is found in, or in a parent of, the current directory.\n //\n-// The quickest way to take advantage of the new Go 1.11 module support\n-// is to check out your repository into a directory outside GOPATH/src,\n-// create a go.mod file (described in the next section) there, and run\n+// The quickest way to take advantage of module support is to check out your\n+// repository, create a go.mod file (described in the next section) there, and run\n // go commands from within that file tree.\n //\n-// For more fine-grained control, the module support in Go 1.11 respects\n+// For more fine-grained control, Go 1.13 continues to respect\n // a temporary environment variable, GO111MODULE, which can be set to one\n // of three string values: off, on, or auto (the default).\n-// If GO111MODULE=off, then the go command never uses the\n-// new module support. Instead it looks in vendor directories and GOPATH\n-// to find dependencies; we now refer to this as \"GOPATH mode.\"\n // If GO111MODULE=on, then the go command requires the use of modules,\n-// never consulting GOPATH. We refer to this as the command being\n-// module-aware or running in \"module-aware mode\".\n-// If GO111MODULE=auto or is unset, then the go command enables or\n-// disables module support based on the current directory.\n-// Module support is enabled only when the current directory is outside\n-// GOPATH/src and itself contains a go.mod file or is below a directory\n-// containing a go.mod file.\n+// never consulting GOPATH. We refer to this as the command\n+// being module-aware or running in \"module-aware mode\".\n+// If GO111MODULE=off, then the go command never uses\n+// module support. Instead it looks in vendor directories and GOPATH\n+// to find dependencies; we now refer to this as \"GOPATH mode.\"\n+// If GO111MODULE=auto or is unset, then the go command enables or disables\n+// module support based on the current directory.\n+// Module support is enabled only when the current directory contains a\n+// go.mod file or is below a directory containing a go.mod file.\n //\n // In module-aware mode, GOPATH no longer defines the meaning of imports\n // during a build, but it still stores downloaded dependencies (in GOPATH/pkg/mod)\n@@ -2422,26 +2596,35 @@\n //\n // Module downloading and verification\n //\n-// The go command maintains, in the main module's root directory alongside\n-// go.mod, a file named go.sum containing the expected cryptographic checksums\n-// of the content of specific module versions. Each time a dependency is\n-// used, its checksum is added to go.sum if missing or else required to match\n-// the existing entry in go.sum.\n-//\n-// The go command maintains a cache of downloaded packages and computes\n-// and records the cryptographic checksum of each package at download time.\n-// In normal operation, the go command checks these pre-computed checksums\n-// against the main module's go.sum file, instead of recomputing them on\n-// each command invocation. The 'go mod verify' command checks that\n-// the cached copies of module downloads still match both their recorded\n-// checksums and the entries in go.sum.\n-//\n-// The go command can fetch modules from a proxy instead of connecting\n-// to source control systems directly, according to the setting of the GOPROXY\n-// environment variable.\n-//\n-// See 'go help goproxy' for details about the proxy and also the format of\n-// the cached downloaded packages.\n+// The go command can fetch modules from a proxy or connect to source control\n+// servers directly, according to the setting of the GOPROXY environment\n+// variable (see 'go help env'). The default setting for GOPROXY is\n+// \"https://proxy.golang.org,direct\", which means to try the\n+// Go module mirror run by Google and fall back to a direct connection\n+// if the proxy reports that it does not have the module (HTTP error 404 or 410).\n+// See https://proxy.golang.org/privacy for the service's privacy policy.\n+// If GOPROXY is set to the string \"direct\", downloads use a direct connection\n+// to source control servers. Setting GOPROXY to \"off\" disallows downloading\n+// modules from any source. Otherwise, GOPROXY is expected to be a comma-separated\n+// list of the URLs of module proxies, in which case the go command will fetch\n+// modules from those proxies. For each request, the go command tries each proxy\n+// in sequence, only moving to the next if the current proxy returns a 404 or 410\n+// HTTP response. The string \"direct\" may appear in the proxy list,\n+// to cause a direct connection to be attempted at that point in the search.\n+// Any proxies listed after \"direct\" are never consulted.\n+//\n+// The GOPRIVATE and GONOPROXY environment variables allow bypassing\n+// the proxy for selected modules. See 'go help module-private' for details.\n+//\n+// No matter the source of the modules, the go command checks downloads against\n+// known checksums, to detect unexpected changes in the content of any specific\n+// module version from one day to the next. This check first consults the current\n+// module's go.sum file but falls back to the Go checksum database, controlled by\n+// the GOSUMDB and GONOSUMDB environment variables. See 'go help module-auth'\n+// for details.\n+//\n+// See 'go help goproxy' for details about the proxy protocol and also\n+// the format of the cached downloaded packages.\n //\n // Modules and vendoring\n //\n@@ -2463,108 +2646,135 @@\n // are still ignored.\n //\n //\n-// Module-aware go get\n-//\n-// The 'go get' command changes behavior depending on whether the\n-// go command is running in module-aware mode or legacy GOPATH mode.\n-// This help text, accessible as 'go help module-get' even in legacy GOPATH mode,\n-// describes 'go get' as it operates in module-aware mode.\n-//\n-// Usage: go get [-d] [-m] [-u] [-v] [-insecure] [build flags] [packages]\n-//\n-// Get resolves and adds dependencies to the current development module\n-// and then builds and installs them.\n+// Module authentication using go.sum\n //\n-// The first step is to resolve which dependencies to add.\n+// The go command tries to authenticate every downloaded module,\n+// checking that the bits downloaded for a specific module version today\n+// match bits downloaded yesterday. This ensures repeatable builds\n+// and detects introduction of unexpected changes, malicious or not.\n //\n-// For each named package or package pattern, get must decide which version of\n-// the corresponding module to use. By default, get chooses the latest tagged\n-// release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n-// versions, get chooses the latest tagged prerelease version, such as\n-// v0.0.1-pre1. If there are no tagged versions at all, get chooses the latest\n-// known commit.\n+// In each module's root, alongside go.mod, the go command maintains\n+// a file named go.sum containing the cryptographic checksums of the\n+// module's dependencies.\n //\n-// This default version selection can be overridden by adding an @version\n-// suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n-// For modules stored in source control repositories, the version suffix can\n-// also be a commit hash, branch identifier, or other syntax known to the\n-// source control system, as in 'go get golang.org/x/text@master'.\n-// The version suffix @latest explicitly requests the default behavior\n-// described above.\n+// The form of each line in go.sum is three fields:\n //\n-// If a module under consideration is already a dependency of the current\n-// development module, then get will update the required version.\n-// Specifying a version earlier than the current required version is valid and\n-// downgrades the dependency. The version suffix @none indicates that the\n-// dependency should be removed entirely, downgrading or removing modules\n-// depending on it as needed.\n+// \t<module> <version>[/go.mod] <hash>\n //\n-// Although get defaults to using the latest version of the module containing\n-// a named package, it does not use the latest version of that module's\n-// dependencies. Instead it prefers to use the specific dependency versions\n-// requested by that module. For example, if the latest A requires module\n-// B v1.2.3, while B v1.2.4 and v1.3.1 are also available, then 'go get A'\n-// will use the latest A but then use B v1.2.3, as requested by A. (If there\n-// are competing requirements for a particular module, then 'go get' resolves\n-// those requirements by taking the maximum requested version.)\n+// Each known module version results in two lines in the go.sum file.\n+// The first line gives the hash of the module version's file tree.\n+// The second line appends \"/go.mod\" to the version and gives the hash\n+// of only the module version's (possibly synthesized) go.mod file.\n+// The go.mod-only hash allows downloading and authenticating a\n+// module version's go.mod file, which is needed to compute the\n+// dependency graph, without also downloading all the module's source code.\n //\n-// The -u flag instructs get to update dependencies to use newer minor or\n-// patch releases when available. Continuing the previous example,\n-// 'go get -u A' will use the latest A with B v1.3.1 (not B v1.2.3).\n+// The hash begins with an algorithm prefix of the form \"h<N>:\".\n+// The only defined algorithm prefix is \"h1:\", which uses SHA-256.\n //\n-// The -u=patch flag (not -u patch) instructs get to update dependencies\n-// to use newer patch releases when available. Continuing the previous example,\n-// 'go get -u=patch A' will use the latest A with B v1.2.4 (not B v1.2.3).\n+// Module authentication failures\n //\n-// In general, adding a new dependency may require upgrading\n-// existing dependencies to keep a working build, and 'go get' does\n-// this automatically. Similarly, downgrading one dependency may\n-// require downgrading other dependencies, and 'go get' does\n-// this automatically as well.\n-//\n-// The -m flag instructs get to stop here, after resolving, upgrading,\n-// and downgrading modules and updating go.mod. When using -m,\n-// each specified package path must be a module path as well,\n-// not the import path of a package below the module root.\n-//\n-// The -insecure flag permits fetching from repositories and resolving\n-// custom domains using insecure schemes such as HTTP. Use with caution.\n+// The go command maintains a cache of downloaded packages and computes\n+// and records the cryptographic checksum of each package at download time.\n+// In normal operation, the go command checks the main module's go.sum file\n+// against these precomputed checksums instead of recomputing them on\n+// each command invocation. The 'go mod verify' command checks that\n+// the cached copies of module downloads still match both their recorded\n+// checksums and the entries in go.sum.\n //\n-// The second step is to download (if needed), build, and install\n-// the named packages.\n+// In day-to-day development, the checksum of a given module version\n+// should never change. Each time a dependency is used by a given main\n+// module, the go command checks its local cached copy, freshly\n+// downloaded or not, against the main module's go.sum. If the checksums\n+// don't match, the go command reports the mismatch as a security error\n+// and refuses to run the build. When this happens, proceed with caution:\n+// code changing unexpectedly means today's build will not match\n+// yesterday's, and the unexpected change may not be beneficial.\n+//\n+// If the go command reports a mismatch in go.sum, the downloaded code\n+// for the reported module version does not match the one used in a\n+// previous build of the main module. It is important at that point\n+// to find out what the right checksum should be, to decide whether\n+// go.sum is wrong or the downloaded code is wrong. Usually go.sum is right:\n+// you want to use the same code you used yesterday.\n+//\n+// If a downloaded module is not yet included in go.sum and it is a publicly\n+// available module, the go command consults the Go checksum database to fetch\n+// the expected go.sum lines. If the downloaded code does not match those\n+// lines, the go command reports the mismatch and exits. Note that the\n+// database is not consulted for module versions already listed in go.sum.\n+//\n+// If a go.sum mismatch is reported, it is always worth investigating why\n+// the code downloaded today differs from what was downloaded yesterday.\n+//\n+// The GOSUMDB environment variable identifies the name of checksum database\n+// to use and optionally its public key and URL, as in:\n+//\n+// \tGOSUMDB=\"sum.golang.org\"\n+// \tGOSUMDB=\"sum.golang.org+<publickey>\"\n+// \tGOSUMDB=\"sum.golang.org+<publickey> https://sum.golang.org\"\n+//\n+// The go command knows the public key of sum.golang.org; use of any other\n+// database requires giving the public key explicitly. The URL defaults to\n+// \"https://\" followed by the database name.\n+//\n+// GOSUMDB defaults to \"sum.golang.org\", the Go checksum database run by Google.\n+// See https://sum.golang.org/privacy for the service's privacy policy.\n+//\n+// If GOSUMDB is set to \"off\", or if \"go get\" is invoked with the -insecure flag,\n+// the checksum database is not consulted, and all unrecognized modules are\n+// accepted, at the cost of giving up the security guarantee of verified repeatable\n+// downloads for all modules. A better way to bypass the checksum database\n+// for specific modules is to use the GOPRIVATE or GONOSUMDB environment\n+// variables. See 'go help module-private' for details.\n+//\n+// The 'go env -w' command (see 'go help env') can be used to set these variables\n+// for future go command invocations.\n+//\n+//\n+// Module configuration for non-public modules\n+//\n+// The go command defaults to downloading modules from the public Go module\n+// mirror at proxy.golang.org. It also defaults to validating downloaded modules,\n+// regardless of source, against the public Go checksum database at sum.golang.org.\n+// These defaults work well for publicly available source code.\n+//\n+// The GOPRIVATE environment variable controls which modules the go command\n+// considers to be private (not available publicly) and should therefore not use the\n+// proxy or checksum database. The variable is a comma-separated list of\n+// glob patterns (in the syntax of Go's path.Match) of module path prefixes.\n+// For example,\n //\n-// If an argument names a module but not a package (because there is no\n-// Go source code in the module's root directory), then the install step\n-// is skipped for that argument, instead of causing a build failure.\n-// For example 'go get golang.org/x/perf' succeeds even though there\n-// is no code corresponding to that import path.\n+// \tGOPRIVATE=*.corp.example.com,rsc.io/private\n //\n-// Note that package patterns are allowed and are expanded after resolving\n-// the module versions. For example, 'go get golang.org/x/perf/cmd/...'\n-// adds the latest golang.org/x/perf and then installs the commands in that\n-// latest version.\n+// causes the go command to treat as private any module with a path prefix\n+// matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private,\n+// and rsc.io/private/quux.\n //\n-// The -d flag instructs get to download the source code needed to build\n-// the named packages, including downloading necessary dependencies,\n-// but not to build and install them.\n+// The GOPRIVATE environment variable may be used by other tools as well to\n+// identify non-public modules. For example, an editor could use GOPRIVATE\n+// to decide whether to hyperlink a package import to a godoc.org page.\n //\n-// With no package arguments, 'go get' applies to the main module,\n-// and to the Go package in the current directory, if any. In particular,\n-// 'go get -u' and 'go get -u=patch' update all the dependencies of the\n-// main module. With no package arguments and also without -u,\n-// 'go get' is not much more than 'go install', and 'go get -d' not much\n-// more than 'go list'.\n+// For fine-grained control over module download and validation, the GONOPROXY\n+// and GONOSUMDB environment variables accept the same kind of glob list\n+// and override GOPRIVATE for the specific decision of whether to use the proxy\n+// and checksum database, respectively.\n //\n-// For more about modules, see 'go help modules'.\n+// For example, if a company ran a module proxy serving private modules,\n+// users would configure go using:\n //\n-// For more about specifying packages, see 'go help packages'.\n+// \tGOPRIVATE=*.corp.example.com\n+// \tGOPROXY=proxy.example.com\n+// \tGONOPROXY=none\n //\n-// This text describes the behavior of get using modules to manage source\n-// code and dependencies. If instead the go command is running in GOPATH\n-// mode, the details of get's flags and effects change, as does 'go help get'.\n-// See 'go help modules' and 'go help gopath-get'.\n+// This would tell the go command and other tools that modules beginning with\n+// a corp.example.com subdomain are private but that the company proxy should\n+// be used for downloading both public and private modules, because\n+// GONOPROXY has been set to a pattern that won't match any modules,\n+// overriding GOPRIVATE.\n //\n-// See also: go build, go install, go clean, go mod.\n+// The 'go env -w' command (see 'go help env') can be used to set these variables\n+// for future go command invocations.\n //\n //\n // Package lists and patterns"}, {"sha": "0ae2fa297eb02a34fe64a42c64063c33db538685", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 129, "deletions": 126, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,7 +6,6 @@ package main_test\n \n import (\n \t\"bytes\"\n-\t\"cmd/internal/sys\"\n \t\"context\"\n \t\"debug/elf\"\n \t\"debug/macho\"\n@@ -27,6 +26,11 @@ import (\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n+\n+\t\"cmd/go/internal/cache\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/robustio\"\n+\t\"cmd/internal/sys\"\n )\n \n var (\n@@ -118,6 +122,8 @@ var testCtx = context.Background()\n // The TestMain function creates a go command for testing purposes and\n // deletes it after the tests have been run.\n func TestMain(m *testing.M) {\n+\t// $GO_GCFLAGS a compiler debug flag known to cmd/dist, make.bash, etc.\n+\t// It is not a standard go command flag; use os.Getenv, not cfg.Getenv.\n \tif os.Getenv(\"GO_GCFLAGS\") != \"\" {\n \t\tfmt.Fprintf(os.Stderr, \"testing: warning: no tests to run\\n\") // magic string for cmd/go\n \t\tfmt.Printf(\"cmd/go test is not compatible with $GO_GCFLAGS being set\\n\")\n@@ -166,6 +172,7 @@ func TestMain(m *testing.M) {\n \t\tdefer removeAll(testTmpDir)\n \t}\n \n+\ttestGOCACHE = cache.DefaultDir()\n \tif canRun {\n \t\ttestBin = filepath.Join(testTmpDir, \"testbin\")\n \t\tif err := os.Mkdir(testBin, 0777); err != nil {\n@@ -212,7 +219,9 @@ func TestMain(m *testing.M) {\n \t\t\treturn\n \t\t}\n \n-\t\tout, err := exec.Command(gotool, args...).CombinedOutput()\n+\t\tbuildCmd := exec.Command(gotool, args...)\n+\t\tbuildCmd.Env = append(os.Environ(), \"GOFLAGS=-mod=vendor\")\n+\t\tout, err := buildCmd.CombinedOutput()\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"building testgo failed: %v\\n%s\", err, out)\n \t\t\tos.Exit(2)\n@@ -252,6 +261,7 @@ func TestMain(m *testing.M) {\n \t\t}\n \t}\n \t// Don't let these environment variables confuse the test.\n+\tos.Setenv(\"GOENV\", \"off\")\n \tos.Unsetenv(\"GOBIN\")\n \tos.Unsetenv(\"GOPATH\")\n \tos.Unsetenv(\"GIT_ALLOW_PROTOCOL\")\n@@ -260,7 +270,7 @@ func TestMain(m *testing.M) {\n \t// Setting HOME to a non-existent directory will break\n \t// those systems. Disable ccache and use real compiler. Issue 17668.\n \tos.Setenv(\"CCACHE_DISABLE\", \"1\")\n-\tif os.Getenv(\"GOCACHE\") == \"\" {\n+\tif cfg.Getenv(\"GOCACHE\") == \"\" {\n \t\tos.Setenv(\"GOCACHE\", testGOCACHE) // because $HOME is gone\n \t}\n \n@@ -422,6 +432,7 @@ func (tg *testgoData) setenv(name, val string) {\n func (tg *testgoData) unsetenv(name string) {\n \tif tg.env == nil {\n \t\ttg.env = append([]string(nil), os.Environ()...)\n+\t\ttg.env = append(tg.env, \"GO111MODULE=off\")\n \t}\n \tfor i, v := range tg.env {\n \t\tif strings.HasPrefix(v, name+\"=\") {\n@@ -675,7 +686,7 @@ func (tg *testgoData) creatingTemp(path string) {\n \tif tg.wd != \"\" && !filepath.IsAbs(path) {\n \t\tpath = filepath.Join(tg.pwd(), path)\n \t}\n-\ttg.must(os.RemoveAll(path))\n+\ttg.must(robustio.RemoveAll(path))\n \ttg.temps = append(tg.temps, path)\n }\n \n@@ -877,7 +888,7 @@ func removeAll(dir string) error {\n \t\t}\n \t\treturn nil\n \t})\n-\treturn os.RemoveAll(dir)\n+\treturn robustio.RemoveAll(dir)\n }\n \n // failSSH puts an ssh executable in the PATH that always fails.\n@@ -1171,7 +1182,7 @@ func testMove(t *testing.T, vcs, url, base, config string) {\n \tcase \"svn\":\n \t\t// SVN doesn't believe in text files so we can't just edit the config.\n \t\t// Check out a different repo into the wrong place.\n-\t\ttg.must(os.RemoveAll(tg.path(\"src/code.google.com/p/rsc-svn\")))\n+\t\ttg.must(robustio.RemoveAll(tg.path(\"src/code.google.com/p/rsc-svn\")))\n \t\ttg.run(\"get\", \"-d\", \"-u\", \"code.google.com/p/rsc-svn2/trunk\")\n \t\ttg.must(os.Rename(tg.path(\"src/code.google.com/p/rsc-svn2\"), tg.path(\"src/code.google.com/p/rsc-svn\")))\n \tdefault:\n@@ -1212,10 +1223,12 @@ func TestInternalCache(t *testing.T) {\n }\n \n func TestMoveGit(t *testing.T) {\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \ttestMove(t, \"git\", \"rsc.io/pdf\", \"pdf\", \"rsc.io/pdf/.git/config\")\n }\n \n func TestMoveHG(t *testing.T) {\n+\ttestenv.MustHaveExecPath(t, \"hg\")\n \ttestMove(t, \"hg\", \"vcs-test.golang.org/go/custom-hg-hello\", \"custom-hg-hello\", \"vcs-test.golang.org/go/custom-hg-hello/.hg/hgrc\")\n }\n \n@@ -1277,9 +1290,7 @@ func TestImportCycle(t *testing.T) {\n // cmd/go: custom import path checking should not apply to Go packages without import comment.\n func TestIssue10952(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1295,9 +1306,7 @@ func TestIssue10952(t *testing.T) {\n \n func TestIssue16471(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1313,9 +1322,7 @@ func TestIssue16471(t *testing.T) {\n // Test git clone URL that uses SCP-like syntax and custom import path checking.\n func TestIssue11457(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1340,9 +1347,7 @@ func TestIssue11457(t *testing.T) {\n \n func TestGetGitDefaultBranch(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1368,9 +1373,7 @@ func TestGetGitDefaultBranch(t *testing.T) {\n // Security issue. Don't disable. See golang.org/issue/22125.\n func TestAccidentalGitCheckout(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n-\tif _, err := exec.LookPath(\"git\"); err != nil {\n-\t\tt.Skip(\"skipping because git binary not found\")\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1644,6 +1647,7 @@ func TestInstallToGOBINCommandLinePackage(t *testing.T) {\n \n func TestGoGetNonPkg(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1660,6 +1664,7 @@ func TestGoGetNonPkg(t *testing.T) {\n \n func TestGoGetTestOnlyPkg(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1690,7 +1695,7 @@ func TestInstalls(t *testing.T) {\n \tgoarch := strings.TrimSpace(tg.getStdout())\n \ttg.setenv(\"GOARCH\", goarch)\n \tfixbin := filepath.Join(goroot, \"pkg\", \"tool\", goos+\"_\"+goarch, \"fix\") + exeSuffix\n-\ttg.must(os.RemoveAll(fixbin))\n+\ttg.must(robustio.RemoveAll(fixbin))\n \ttg.run(\"install\", \"cmd/fix\")\n \ttg.wantExecutable(fixbin, \"did not install cmd/fix to $GOROOT/pkg/tool\")\n \ttg.must(os.Remove(fixbin))\n@@ -1884,11 +1889,12 @@ func TestGoListTest(t *testing.T) {\n \ttg.grepStdout(`^runtime/cgo$`, \"missing runtime/cgo\")\n \n \ttg.run(\"list\", \"-deps\", \"-f\", \"{{if .DepOnly}}{{.ImportPath}}{{end}}\", \"sort\")\n-\ttg.grepStdout(`^reflect$`, \"missing reflect\")\n+\ttg.grepStdout(`^internal/reflectlite$`, \"missing internal/reflectlite\")\n \ttg.grepStdoutNot(`^sort`, \"unexpected sort\")\n }\n \n func TestGoListCompiledCgo(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2048,6 +2054,7 @@ func TestDefaultGOPATH(t *testing.T) {\n \n func TestDefaultGOPATHGet(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2060,13 +2067,13 @@ func TestDefaultGOPATHGet(t *testing.T) {\n \ttg.grepStderr(\"created GOPATH=\"+regexp.QuoteMeta(tg.path(\"home/go\"))+\"; see 'go help gopath'\", \"did not create GOPATH\")\n \n \t// no warning if directory already exists\n-\ttg.must(os.RemoveAll(tg.path(\"home/go\")))\n+\ttg.must(robustio.RemoveAll(tg.path(\"home/go\")))\n \ttg.tempDir(\"home/go\")\n \ttg.run(\"get\", \"github.com/golang/example/hello\")\n \ttg.grepStderrNot(\".\", \"expected no output on standard error\")\n \n \t// error if $HOME/go is a file\n-\ttg.must(os.RemoveAll(tg.path(\"home/go\")))\n+\ttg.must(robustio.RemoveAll(tg.path(\"home/go\")))\n \ttg.tempFile(\"home/go\", \"\")\n \ttg.runFail(\"get\", \"github.com/golang/example/hello\")\n \ttg.grepStderr(`mkdir .*[/\\\\]go: .*(not a directory|cannot find the path)`, \"expected error because $HOME/go is a file\")\n@@ -2429,6 +2436,7 @@ func TestSymlinkWarning(t *testing.T) {\n // Issue 8181.\n func TestGoGetDashTIssue8181(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2443,6 +2451,7 @@ func TestGoGetDashTIssue8181(t *testing.T) {\n func TestIssue11307(t *testing.T) {\n \t// go get -u was not working except in checkout directory\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -2528,6 +2537,7 @@ func TestCoverageRuns(t *testing.T) {\n \n func TestCoverageDotImport(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2610,6 +2620,14 @@ func TestCoverageDepLoop(t *testing.T) {\n \ttg.grepStdout(\"coverage: 100.0% of statements\", \"expected 100.0% coverage\")\n }\n \n+func TestCoverageNoStatements(t *testing.T) {\n+\ttooSlow(t)\n+\ttg := testgo(t)\n+\tdefer tg.cleanup()\n+\ttg.run(\"test\", \"-cover\", \"./testdata/testcover/pkg4\")\n+\ttg.grepStdout(\"[no statements]\", \"expected [no statements] for pkg4\")\n+}\n+\n func TestCoverageImportMainLoop(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttg := testgo(t)\n@@ -2699,6 +2717,7 @@ func TestCoverageFunc(t *testing.T) {\n // Issue 24588.\n func TestCoverageDashC(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -2855,7 +2874,7 @@ func TestCgoDependsOnSyscall(t *testing.T) {\n \tfiles, err := filepath.Glob(filepath.Join(runtime.GOROOT(), \"pkg\", \"*_race\"))\n \ttg.must(err)\n \tfor _, file := range files {\n-\t\ttg.check(os.RemoveAll(file))\n+\t\ttg.check(robustio.RemoveAll(file))\n \t}\n \ttg.tempFile(\"src/foo/foo.go\", `\n \t\tpackage foo\n@@ -2911,6 +2930,7 @@ func TestCgoPkgConfig(t *testing.T) {\n \n \ttg.run(\"env\", \"PKG_CONFIG\")\n \tpkgConfig := strings.TrimSpace(tg.getStdout())\n+\ttestenv.MustHaveExecPath(t, pkgConfig)\n \tif out, err := exec.Command(pkgConfig, \"--atleast-pkgconfig-version\", \"0.24\").CombinedOutput(); err != nil {\n \t\tt.Skipf(\"%s --atleast-pkgconfig-version 0.24: %v\\n%s\", pkgConfig, err, out)\n \t}\n@@ -3013,9 +3033,7 @@ func TestIssue7573(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n-\tif _, err := exec.LookPath(\"gccgo\"); err != nil {\n-\t\tt.Skip(\"skipping because no gccgo compiler found\")\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"gccgo\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3304,6 +3322,7 @@ func TestGoGenerateBadImports(t *testing.T) {\n \n func TestGoGetCustomDomainWildcard(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3315,6 +3334,7 @@ func TestGoGetCustomDomainWildcard(t *testing.T) {\n \n func TestGoGetInternalWildcard(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3374,6 +3394,7 @@ func TestVetWithOnlyCgoFiles(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n+\ttooSlow(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3386,6 +3407,7 @@ func TestVetWithOnlyCgoFiles(t *testing.T) {\n // Issue 9767, 19769.\n func TestGoGetDotSlashDownload(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3395,22 +3417,6 @@ func TestGoGetDotSlashDownload(t *testing.T) {\n \ttg.run(\"get\", \"./pprof_mac_fix\")\n }\n \n-// Issue 13037: Was not parsing <meta> tags in 404 served over HTTPS\n-func TestGoGetHTTPS404(t *testing.T) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\tswitch runtime.GOOS {\n-\tcase \"darwin\", \"linux\", \"freebsd\":\n-\tdefault:\n-\t\tt.Skipf(\"test case does not work on %s\", runtime.GOOS)\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.tempDir(\"src\")\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"bazil.org/fuse/fs/fstestutil\")\n-}\n-\n // Test that you cannot import a main package.\n // See golang.org/issue/4210 and golang.org/issue/17475.\n func TestImportMain(t *testing.T) {\n@@ -3625,7 +3631,7 @@ func TestImportLocal(t *testing.T) {\n \t\tvar _ = x.X\n \t`)\n \ttg.runFail(\"build\", \"dir/x\")\n-\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\ttg.grepStderr(\"cannot import current directory\", \"did not diagnose import current directory\")\n \n \t// ... even in a test.\n \ttg.tempFile(\"src/dir/x/xx.go\", `package x\n@@ -3638,7 +3644,7 @@ func TestImportLocal(t *testing.T) {\n \t`)\n \ttg.run(\"build\", \"dir/x\")\n \ttg.runFail(\"test\", \"dir/x\")\n-\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\ttg.grepStderr(\"cannot import current directory\", \"did not diagnose import current directory\")\n \n \t// ... even in an xtest.\n \ttg.tempFile(\"src/dir/x/xx.go\", `package x\n@@ -3651,12 +3657,13 @@ func TestImportLocal(t *testing.T) {\n \t`)\n \ttg.run(\"build\", \"dir/x\")\n \ttg.runFail(\"test\", \"dir/x\")\n-\ttg.grepStderr(\"local import.*in non-local package\", \"did not diagnose local import\")\n+\ttg.grepStderr(\"cannot import current directory\", \"did not diagnose import current directory\")\n }\n \n func TestGoGetInsecure(t *testing.T) {\n \ttest := func(t *testing.T, modules bool) {\n \t\ttestenv.MustHaveExternalNetwork(t)\n+\t\ttestenv.MustHaveExecPath(t, \"git\")\n \n \t\ttg := testgo(t)\n \t\tdefer tg.cleanup()\n@@ -3668,6 +3675,7 @@ func TestGoGetInsecure(t *testing.T) {\n \t\t\ttg.tempFile(\"go.mod\", \"module m\")\n \t\t\ttg.cd(tg.path(\".\"))\n \t\t\ttg.setenv(\"GO111MODULE\", \"on\")\n+\t\t\ttg.setenv(\"GOPROXY\", \"\")\n \t\t} else {\n \t\t\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n \t\t\ttg.setenv(\"GO111MODULE\", \"off\")\n@@ -3696,6 +3704,7 @@ func TestGoGetInsecure(t *testing.T) {\n \n func TestGoGetUpdateInsecure(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3720,6 +3729,7 @@ func TestGoGetUpdateInsecure(t *testing.T) {\n \n func TestGoGetUpdateUnknownProtocol(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3754,6 +3764,7 @@ func TestGoGetUpdateUnknownProtocol(t *testing.T) {\n \n func TestGoGetInsecureCustomDomain(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3856,6 +3867,7 @@ func TestGoGetUpdate(t *testing.T) {\n \t// former dependencies, not current ones.\n \n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3883,6 +3895,7 @@ func TestGoGetUpdate(t *testing.T) {\n // Issue #20512.\n func TestGoGetRace(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \tif !canRace {\n \t\tt.Skip(\"skipping because race detector not supported\")\n \t}\n@@ -3899,6 +3912,7 @@ func TestGoGetDomainRoot(t *testing.T) {\n \t// go get foo.io (not foo.io/subdir) was not working consistently.\n \n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3913,10 +3927,10 @@ func TestGoGetDomainRoot(t *testing.T) {\n \ttg.run(\"get\", \"go-get-issue-9357.appspot.com\")\n \ttg.run(\"get\", \"-u\", \"go-get-issue-9357.appspot.com\")\n \n-\ttg.must(os.RemoveAll(tg.path(\"src/go-get-issue-9357.appspot.com\")))\n+\ttg.must(robustio.RemoveAll(tg.path(\"src/go-get-issue-9357.appspot.com\")))\n \ttg.run(\"get\", \"go-get-issue-9357.appspot.com\")\n \n-\ttg.must(os.RemoveAll(tg.path(\"src/go-get-issue-9357.appspot.com\")))\n+\ttg.must(robustio.RemoveAll(tg.path(\"src/go-get-issue-9357.appspot.com\")))\n \ttg.run(\"get\", \"-u\", \"go-get-issue-9357.appspot.com\")\n }\n \n@@ -4131,7 +4145,7 @@ func TestCgoConsistentResults(t *testing.T) {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n \tswitch runtime.GOOS {\n-\tcase \"solaris\":\n+\tcase \"solaris\", \"illumos\":\n \t\ttestenv.SkipFlaky(t, 13247)\n \t}\n \n@@ -4203,9 +4217,9 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \n \t\tpackage p1\n \t`)\n-\ttg.wantStale(\"p1\", \"missing or invalid binary-only package\", \"p1 is binary-only but has no binary, should be stale\")\n+\ttg.wantStale(\"p1\", \"binary-only packages are no longer supported\", \"p1 is binary-only, and this message should always be printed\")\n \ttg.runFail(\"install\", \"p1\")\n-\ttg.grepStderr(\"missing or invalid binary-only package\", \"did not report attempt to compile binary-only package\")\n+\ttg.grepStderr(\"binary-only packages are no longer supported\", \"did not report attempt to compile binary-only package\")\n \n \ttg.tempFile(\"src/p1/p1.go\", `\n \t\tpackage p1\n@@ -4231,48 +4245,13 @@ func TestBinaryOnlyPackages(t *testing.T) {\n \t\timport _ \"fmt\"\n \t\tfunc G()\n \t`)\n-\ttg.wantNotStale(\"p1\", \"binary-only package\", \"should NOT want to rebuild p1 (first)\")\n-\ttg.run(\"install\", \"-x\", \"p1\") // no-op, up to date\n-\ttg.grepBothNot(`[\\\\/]compile`, \"should not have run compiler\")\n-\ttg.run(\"install\", \"p2\") // does not rebuild p1 (or else p2 will fail)\n-\ttg.wantNotStale(\"p2\", \"\", \"should NOT want to rebuild p2\")\n-\n-\t// changes to the non-source-code do not matter,\n-\t// and only one file needs the special comment.\n-\ttg.tempFile(\"src/p1/missing2.go\", `\n-\t\tpackage p1\n-\t\tfunc H()\n-\t`)\n-\ttg.wantNotStale(\"p1\", \"binary-only package\", \"should NOT want to rebuild p1 (second)\")\n-\ttg.wantNotStale(\"p2\", \"\", \"should NOT want to rebuild p2\")\n-\n-\ttg.tempFile(\"src/p3/p3.go\", `\n-\t\tpackage main\n-\t\timport (\n-\t\t\t\"p1\"\n-\t\t\t\"p2\"\n-\t\t)\n-\t\tfunc main() {\n-\t\t\tp1.F(false)\n-\t\t\tp2.F()\n-\t\t}\n-\t`)\n-\ttg.run(\"install\", \"p3\")\n-\n-\ttg.run(\"run\", tg.path(\"src/p3/p3.go\"))\n-\ttg.grepStdout(\"hello from p1\", \"did not see message from p1\")\n-\n-\ttg.tempFile(\"src/p4/p4.go\", `package main`)\n-\t// The odd string split below avoids vet complaining about\n-\t// a // +build line appearing too late in this source file.\n-\ttg.tempFile(\"src/p4/p4not.go\", `//go:binary-only-package\n-\n-\t\t/`+`/ +build asdf\n+\ttg.wantStale(\"p1\", \"binary-only package\", \"should NOT want to rebuild p1 (first)\")\n+\ttg.runFail(\"install\", \"p2\")\n+\ttg.grepStderr(\"p1: binary-only packages are no longer supported\", \"did not report error for binary-only p1\")\n \n-\t\tpackage main\n-\t`)\n-\ttg.run(\"list\", \"-f\", \"{{.BinaryOnly}}\", \"p4\")\n-\ttg.grepStdout(\"false\", \"did not see BinaryOnly=false for p4\")\n+\ttg.run(\"list\", \"-deps\", \"-f\", \"{{.ImportPath}}: {{.BinaryOnly}}\", \"p2\")\n+\ttg.grepStdout(\"p1: true\", \"p1 not listed as BinaryOnly\")\n+\ttg.grepStdout(\"p2: false\", \"p2 listed as BinaryOnly\")\n }\n \n // Issue 16050.\n@@ -4324,6 +4303,7 @@ func TestGenerateUsesBuildContext(t *testing.T) {\n // Issue 14450: go get -u .../ tried to import not downloaded package\n func TestGoGetUpdateWithWildcard(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -4535,8 +4515,9 @@ func TestLinkXImportPathEscape(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n+\ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\texe := \"./linkx\" + exeSuffix\n+\texe := tg.path(\"linkx\" + exeSuffix)\n \ttg.creatingTemp(exe)\n \ttg.run(\"build\", \"-o\", exe, \"-ldflags\", \"-X=my.pkg.Text=linkXworked\", \"my.pkg/main\")\n \tout, err := exec.Command(exe).CombinedOutput()\n@@ -4677,7 +4658,7 @@ func TestBuildTagsNoComma(t *testing.T) {\n \ttg.makeTempdir()\n \ttg.setenv(\"GOPATH\", tg.path(\"go\"))\n \ttg.run(\"build\", \"-tags\", \"tag1 tag2\", \"math\")\n-\ttg.runFail(\"build\", \"-tags\", \"tag1,tag2\", \"math\")\n+\ttg.runFail(\"build\", \"-tags\", \"tag1,tag2 tag3\", \"math\")\n \ttg.grepBoth(\"space-separated list contains comma\", \"-tags with a comma-separated list didn't error\")\n }\n \n@@ -4772,7 +4753,7 @@ func TestExecutableGOROOT(t *testing.T) {\n \t\tcheck(t, symGoTool, newRoot)\n \t})\n \n-\ttg.must(os.RemoveAll(tg.path(\"new/pkg\")))\n+\ttg.must(robustio.RemoveAll(tg.path(\"new/pkg\")))\n \n \t// Binaries built in the new tree should report the\n \t// new tree when they call runtime.GOROOT.\n@@ -4969,14 +4950,14 @@ func TestTestRegexps(t *testing.T) {\n     x_test.go:15: LOG: Y running N=10000\n     x_test.go:15: LOG: Y running N=1000000\n     x_test.go:15: LOG: Y running N=100000000\n-    x_test.go:15: LOG: Y running N=2000000000\n+    x_test.go:15: LOG: Y running N=1000000000\n --- BENCH: BenchmarkX/Y\n     x_test.go:15: LOG: Y running N=1\n     x_test.go:15: LOG: Y running N=100\n     x_test.go:15: LOG: Y running N=10000\n     x_test.go:15: LOG: Y running N=1000000\n     x_test.go:15: LOG: Y running N=100000000\n-    x_test.go:15: LOG: Y running N=2000000000\n+    x_test.go:15: LOG: Y running N=1000000000\n --- BENCH: BenchmarkX\n     x_test.go:13: LOG: X running N=1\n --- BENCH: BenchmarkXX\n@@ -5072,16 +5053,20 @@ func TestExecBuildX(t *testing.T) {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n \n-\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n-\t\tt.Skipf(\"skipping because unix shell is not supported on %s\", runtime.GOOS)\n-\t}\n+\ttestenv.MustHaveExecPath(t, \"/usr/bin/env\")\n+\ttestenv.MustHaveExecPath(t, \"bash\")\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n \ttg.tempDir(\"cache\")\n \ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n \n+\t// Before building our test main.go, ensure that an up-to-date copy of\n+\t// runtime/cgo is present in the cache. If it isn't, the 'go build' step below\n+\t// will fail with \"can't open import\". See golang.org/issue/29004.\n+\ttg.run(\"build\", \"runtime/cgo\")\n+\n \ttg.tempFile(\"main.go\", `package main; import \"C\"; func main() { print(\"hello\") }`)\n \tsrc := tg.path(\"main.go\")\n \tobj := tg.path(\"main\")\n@@ -5124,7 +5109,7 @@ func TestExecBuildX(t *testing.T) {\n \tif len(matches) == 0 {\n \t\tt.Fatal(\"no WORK directory\")\n \t}\n-\ttg.must(os.RemoveAll(matches[1]))\n+\ttg.must(robustio.RemoveAll(matches[1]))\n }\n \n func TestParallelNumber(t *testing.T) {\n@@ -5155,9 +5140,10 @@ func TestUpxCompression(t *testing.T) {\n \t\tt.Skipf(\"skipping upx test on %s/%s\", runtime.GOOS, runtime.GOARCH)\n \t}\n \n+\ttestenv.MustHaveExecPath(t, \"upx\")\n \tout, err := exec.Command(\"upx\", \"--version\").CombinedOutput()\n \tif err != nil {\n-\t\tt.Skip(\"skipping because upx is not available\")\n+\t\tt.Fatalf(\"upx --version failed: %v\", err)\n \t}\n \n \t// upx --version prints `upx <version>` in the first line of output:\n@@ -5166,13 +5152,13 @@ func TestUpxCompression(t *testing.T) {\n \tre := regexp.MustCompile(`([[:digit:]]+)\\.([[:digit:]]+)`)\n \tupxVersion := re.FindStringSubmatch(string(out))\n \tif len(upxVersion) != 3 {\n-\t\tt.Errorf(\"bad upx version string: %s\", upxVersion)\n+\t\tt.Fatalf(\"bad upx version string: %s\", upxVersion)\n \t}\n \n \tmajor, err1 := strconv.Atoi(upxVersion[1])\n \tminor, err2 := strconv.Atoi(upxVersion[2])\n \tif err1 != nil || err2 != nil {\n-\t\tt.Errorf(\"bad upx version string: %s\", upxVersion[0])\n+\t\tt.Fatalf(\"bad upx version string: %s\", upxVersion[0])\n \t}\n \n \t// Anything below 3.94 is known not to work with go binaries\n@@ -5225,26 +5211,29 @@ func TestQEMUUserMode(t *testing.T) {\n \tsrc, obj := tg.path(\"main.go\"), tg.path(\"main\")\n \n \tfor _, arch := range testArchs {\n-\t\tout, err := exec.Command(\"qemu-\"+arch.qemu, \"--version\").CombinedOutput()\n-\t\tif err != nil {\n-\t\t\tt.Logf(\"Skipping %s test (qemu-%s not available)\", arch.g, arch.qemu)\n-\t\t\tcontinue\n-\t\t}\n+\t\tarch := arch\n+\t\tt.Run(arch.g, func(t *testing.T) {\n+\t\t\tqemu := \"qemu-\" + arch.qemu\n+\t\t\ttestenv.MustHaveExecPath(t, qemu)\n \n-\t\ttg.setenv(\"GOARCH\", arch.g)\n-\t\ttg.run(\"build\", \"-o\", obj, src)\n+\t\t\tout, err := exec.Command(qemu, \"--version\").CombinedOutput()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"%s --version failed: %v\", qemu, err)\n+\t\t\t}\n \n-\t\tout, err = exec.Command(\"qemu-\"+arch.qemu, obj).CombinedOutput()\n-\t\tif err != nil {\n-\t\t\tt.Logf(\"qemu-%s output:\\n%s\\n\", arch.qemu, out)\n-\t\t\tt.Errorf(\"qemu-%s failed with %v\", arch.qemu, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif want := \"hello qemu-user\"; string(out) != want {\n-\t\t\tt.Errorf(\"bad output from qemu-%s:\\ngot %s; want %s\", arch.qemu, out, want)\n-\t\t}\n-\t}\n+\t\t\ttg.setenv(\"GOARCH\", arch.g)\n+\t\t\ttg.run(\"build\", \"-o\", obj, src)\n \n+\t\t\tout, err = exec.Command(qemu, obj).CombinedOutput()\n+\t\t\tif err != nil {\n+\t\t\t\tt.Logf(\"%s output:\\n%s\\n\", qemu, out)\n+\t\t\t\tt.Fatalf(\"%s failed with %v\", qemu, err)\n+\t\t\t}\n+\t\t\tif want := \"hello qemu-user\"; string(out) != want {\n+\t\t\t\tt.Errorf(\"bad output from %s:\\ngot %s; want %s\", qemu, out, want)\n+\t\t\t}\n+\t\t})\n+\t}\n }\n \n func TestCacheListStale(t *testing.T) {\n@@ -5296,8 +5285,14 @@ func TestCacheVet(t *testing.T) {\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n \t\tt.Skip(\"GODEBUG gocacheverify\")\n \t}\n-\tif os.Getenv(\"GOCACHE\") == \"off\" {\n-\t\ttooSlow(t)\n+\tif testing.Short() {\n+\t\t// In short mode, reuse cache.\n+\t\t// Test failures may be masked if the cache has just the right entries already\n+\t\t// (not a concern during all.bash, which runs in a clean cache).\n+\t\tif cfg.Getenv(\"GOCACHE\") == \"off\" {\n+\t\t\ttooSlow(t)\n+\t\t}\n+\t} else {\n \t\ttg.makeTempdir()\n \t\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n \t}\n@@ -5681,6 +5676,7 @@ func TestTestSkipVetAfterFailedBuild(t *testing.T) {\n }\n \n func TestTestVetRebuild(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -5960,6 +5956,7 @@ func TestBadCgoDirectives(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"no cgo\")\n \t}\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \n@@ -5992,7 +5989,7 @@ func TestBadCgoDirectives(t *testing.T) {\n \tif runtime.Compiler == \"gc\" {\n \t\ttg.runFail(\"build\", tg.path(\"src/x/_cgo_yy.go\")) // ... but if forced, the comment is rejected\n \t\t// Actually, today there is a separate issue that _ files named\n-\t\t// on the command-line are ignored. Once that is fixed,\n+\t\t// on the command line are ignored. Once that is fixed,\n \t\t// we want to see the cgo_ldflag error.\n \t\ttg.grepStderr(\"//go:cgo_ldflag only allowed in cgo-generated code|no Go files\", \"did not reject //go:cgo_ldflag directive\")\n \t}\n@@ -6074,6 +6071,7 @@ func TestTwoPkgConfigs(t *testing.T) {\n \tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\tt.Skipf(\"no shell scripts on %s\", runtime.GOOS)\n \t}\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -6104,6 +6102,8 @@ func TestCgoCache(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"no cgo\")\n \t}\n+\ttooSlow(t)\n+\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -6154,6 +6154,7 @@ func TestLinkerTmpDirIsDeleted(t *testing.T) {\n \tif !canCgo {\n \t\tt.Skip(\"skipping because cgo not enabled\")\n \t}\n+\ttooSlow(t)\n \n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -6243,6 +6244,7 @@ func TestGoTestWithoutTests(t *testing.T) {\n \n // Issue 25579.\n func TestGoBuildDashODevNull(t *testing.T) {\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()\n@@ -6255,6 +6257,7 @@ func TestGoBuildDashODevNull(t *testing.T) {\n // Issue 25093.\n func TestCoverpkgTestOnly(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n+\ttooSlow(t)\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n \ttg.parallel()"}, {"sha": "3999166ed98c72ecae268e18143c8ff007a501c6", "filename": "libgo/go/cmd/go/go_windows_test.go", "status": "modified", "additions": 8, "deletions": 81, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_windows_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,22 +5,25 @@\n package main\n \n import (\n-\t\"fmt\"\n \t\"internal/testenv\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n \t\"testing\"\n+\n+\t\"cmd/go/internal/robustio\"\n )\n \n func TestAbsolutePath(t *testing.T) {\n+\tt.Parallel()\n+\n \ttmp, err := ioutil.TempDir(\"\", \"TestAbsolutePath\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tdefer os.RemoveAll(tmp)\n+\tdefer robustio.RemoveAll(tmp)\n \n \tfile := filepath.Join(tmp, \"a.go\")\n \terr = ioutil.WriteFile(file, []byte{}, 0644)\n@@ -33,91 +36,15 @@ func TestAbsolutePath(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \n-\twd, err := os.Getwd()\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.Chdir(wd)\n-\n-\t// Chdir so current directory and a.go reside on the same drive.\n-\terr = os.Chdir(dir)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n \tnoVolume := file[len(filepath.VolumeName(file)):]\n \twrongPath := filepath.Join(dir, noVolume)\n-\toutput, err := exec.Command(testenv.GoToolPath(t), \"build\", noVolume).CombinedOutput()\n+\tcmd := exec.Command(testenv.GoToolPath(t), \"build\", noVolume)\n+\tcmd.Dir = dir\n+\toutput, err := cmd.CombinedOutput()\n \tif err == nil {\n \t\tt.Fatal(\"build should fail\")\n \t}\n \tif strings.Contains(string(output), wrongPath) {\n \t\tt.Fatalf(\"wrong output found: %v %v\", err, string(output))\n \t}\n }\n-\n-func runIcacls(t *testing.T, args ...string) string {\n-\tt.Helper()\n-\tout, err := exec.Command(\"icacls\", args...).CombinedOutput()\n-\tif err != nil {\n-\t\tt.Fatalf(\"icacls failed: %v\\n%v\", err, string(out))\n-\t}\n-\treturn string(out)\n-}\n-\n-func runGetACL(t *testing.T, path string) string {\n-\tt.Helper()\n-\tcmd := fmt.Sprintf(`Get-Acl \"%s\" | Select -expand AccessToString`, path)\n-\tout, err := exec.Command(\"powershell\", \"-Command\", cmd).CombinedOutput()\n-\tif err != nil {\n-\t\tt.Fatalf(\"Get-Acl failed: %v\\n%v\", err, string(out))\n-\t}\n-\treturn string(out)\n-}\n-\n-// For issue 22343: verify that executable file created by \"go build\" command\n-// has discretionary access control list (DACL) set as if the file\n-// was created in the destination directory.\n-func TestACL(t *testing.T) {\n-\ttmpdir, err := ioutil.TempDir(\"\", \"TestACL\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(tmpdir)\n-\n-\tnewtmpdir := filepath.Join(tmpdir, \"tmp\")\n-\terr = os.Mkdir(newtmpdir, 0777)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// When TestACL/tmp directory is created, it will have\n-\t// the same security attributes as TestACL.\n-\t// Add Guest account full access to TestACL/tmp - this\n-\t// will make all files created in TestACL/tmp have different\n-\t// security attributes to the files created in TestACL.\n-\trunIcacls(t, newtmpdir,\n-\t\t\"/grant\", \"*S-1-5-32-546:(oi)(ci)f\", // add Guests group to have full access\n-\t)\n-\n-\tsrc := filepath.Join(tmpdir, \"main.go\")\n-\terr = ioutil.WriteFile(src, []byte(\"package main; func main() { }\\n\"), 0644)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\texe := filepath.Join(tmpdir, \"main.exe\")\n-\tcmd := exec.Command(testenv.GoToolPath(t), \"build\", \"-o\", exe, src)\n-\tcmd.Env = append(os.Environ(),\n-\t\t\"TMP=\"+newtmpdir,\n-\t\t\"TEMP=\"+newtmpdir,\n-\t)\n-\tout, err := cmd.CombinedOutput()\n-\tif err != nil {\n-\t\tt.Fatalf(\"go command failed: %v\\n%v\", err, string(out))\n-\t}\n-\n-\t// exe file is expected to have the same security attributes as the src.\n-\tif got, expected := runGetACL(t, exe), runGetACL(t, src); got != expected {\n-\t\tt.Fatalf(\"expected Get-Acl output of \\n%v\\n, got \\n%v\\n\", expected, got)\n-\t}\n-}"}, {"sha": "9c0fa8411ee13ab4bad8e51457f2b414b41ecb6a", "filename": "libgo/go/cmd/go/help_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -12,9 +12,14 @@ import (\n \t\"testing\"\n \n \t\"cmd/go/internal/help\"\n+\t\"cmd/go/internal/modload\"\n )\n \n func TestDocsUpToDate(t *testing.T) {\n+\tif !modload.Enabled() {\n+\t\tt.Skipf(\"help.Help in GOPATH mode is configured by main.main\")\n+\t}\n+\n \tbuf := new(bytes.Buffer)\n \t// Match the command in mkalldocs.sh that generates alldocs.go.\n \thelp.Help(buf, []string{\"documentation\"})"}, {"sha": "ed90a7784161b9a0d99226b5b7287e1bfb6a899c", "filename": "libgo/go/cmd/go/init_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finit_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main_test\n+\n+import (\n+\t\"internal/testenv\"\n+\t\"os/exec\"\n+\t\"testing\"\n+)\n+\n+// BenchmarkExecGoEnv measures how long it takes for 'go env GOARCH' to run.\n+// Since 'go' is executed, remember to run 'go install cmd/go' before running\n+// the benchmark if any changes were done.\n+func BenchmarkExecGoEnv(b *testing.B) {\n+\ttestenv.MustHaveExec(b)\n+\tb.StopTimer()\n+\tgotool, err := testenv.GoTool()\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tcmd := exec.Command(gotool, \"env\", \"GOARCH\")\n+\n+\t\tb.StartTimer()\n+\t\terr := cmd.Run()\n+\t\tb.StopTimer()\n+\n+\t\tif err != nil {\n+\t\t\tb.Fatal(err)\n+\t\t}\n+\t}\n+}"}, {"sha": "12e3c74dcc75498720f32f3c49243d2994668888", "filename": "libgo/go/cmd/go/internal/auth/auth.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fauth.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package auth provides access to user-provided authentication credentials.\n+package auth\n+\n+import \"net/http\"\n+\n+// AddCredentials fills in the user's credentials for req, if any.\n+// The return value reports whether any matching credentials were found.\n+func AddCredentials(req *http.Request) (added bool) {\n+\t// TODO(golang.org/issue/26232): Support arbitrary user-provided credentials.\n+\tnetrcOnce.Do(readNetrc)\n+\tfor _, l := range netrc {\n+\t\tif l.machine == req.URL.Host {\n+\t\t\treq.SetBasicAuth(l.login, l.password)\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n+}"}, {"sha": "7a9bdbb72c8ac4f0ee9c936cd75a387023104dfb", "filename": "libgo/go/cmd/go/internal/auth/netrc.go", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package auth\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+type netrcLine struct {\n+\tmachine  string\n+\tlogin    string\n+\tpassword string\n+}\n+\n+var (\n+\tnetrcOnce sync.Once\n+\tnetrc     []netrcLine\n+\tnetrcErr  error\n+)\n+\n+func parseNetrc(data string) []netrcLine {\n+\t// See https://www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html\n+\t// for documentation on the .netrc format.\n+\tvar nrc []netrcLine\n+\tvar l netrcLine\n+\tinMacro := false\n+\tfor _, line := range strings.Split(data, \"\\n\") {\n+\t\tif inMacro {\n+\t\t\tif line == \"\" {\n+\t\t\t\tinMacro = false\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tf := strings.Fields(line)\n+\t\ti := 0\n+\t\tfor ; i < len(f)-1; i += 2 {\n+\t\t\t// Reset at each \"machine\" token.\n+\t\t\t// \u201cThe auto-login process searches the .netrc file for a machine token\n+\t\t\t// that matches [\u2026]. Once a match is made, the subsequent .netrc tokens\n+\t\t\t// are processed, stopping when the end of file is reached or another\n+\t\t\t// machine or a default token is encountered.\u201d\n+\t\t\tswitch f[i] {\n+\t\t\tcase \"machine\":\n+\t\t\t\tl = netrcLine{machine: f[i+1]}\n+\t\t\tcase \"default\":\n+\t\t\t\tbreak\n+\t\t\tcase \"login\":\n+\t\t\t\tl.login = f[i+1]\n+\t\t\tcase \"password\":\n+\t\t\t\tl.password = f[i+1]\n+\t\t\tcase \"macdef\":\n+\t\t\t\t// \u201cA macro is defined with the specified name; its contents begin with\n+\t\t\t\t// the next .netrc line and continue until a null line (consecutive\n+\t\t\t\t// new-line characters) is encountered.\u201d\n+\t\t\t\tinMacro = true\n+\t\t\t}\n+\t\t\tif l.machine != \"\" && l.login != \"\" && l.password != \"\" {\n+\t\t\t\tnrc = append(nrc, l)\n+\t\t\t\tl = netrcLine{}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif i < len(f) && f[i] == \"default\" {\n+\t\t\t// \u201cThere can be only one default token, and it must be after all machine tokens.\u201d\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn nrc\n+}\n+\n+func netrcPath() (string, error) {\n+\tif env := os.Getenv(\"NETRC\"); env != \"\" {\n+\t\treturn env, nil\n+\t}\n+\tdir, err := os.UserHomeDir()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tbase := \".netrc\"\n+\tif runtime.GOOS == \"windows\" {\n+\t\tbase = \"_netrc\"\n+\t}\n+\treturn filepath.Join(dir, base), nil\n+}\n+\n+func readNetrc() {\n+\tpath, err := netrcPath()\n+\tif err != nil {\n+\t\tnetrcErr = err\n+\t\treturn\n+\t}\n+\n+\tdata, err := ioutil.ReadFile(path)\n+\tif err != nil {\n+\t\tif !os.IsNotExist(err) {\n+\t\t\tnetrcErr = err\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tnetrc = parseNetrc(string(data))\n+}"}, {"sha": "e06c545390e0e9c465eef8ecb9ef7773a7516778", "filename": "libgo/go/cmd/go/internal/auth/netrc_test.go", "status": "renamed", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fauth%2Fnetrc_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -2,31 +2,54 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package web2\n+package auth\n \n import (\n \t\"reflect\"\n \t\"testing\"\n )\n \n var testNetrc = `\n+machine incomplete\n+password none\n+\n machine api.github.com\n   login user\n   password pwd\n \n machine incomlete.host\n   login justlogin\n-  \n+\n machine test.host\n login user2\n password pwd2\n+\n+machine oneline login user3 password pwd3\n+\n+machine ignore.host macdef ignore\n+  login nobody\n+  password nothing\n+\n+machine hasmacro.too macdef ignore-next-lines login user4 password pwd4\n+  login nobody\n+  password nothing\n+\n+default\n+login anonymous\n+password gopher@golang.org\n+\n+machine after.default\n+login oops\n+password too-late-in-file\n `\n \n-func TestReadNetrc(t *testing.T) {\n+func TestParseNetrc(t *testing.T) {\n \tlines := parseNetrc(testNetrc)\n \twant := []netrcLine{\n \t\t{\"api.github.com\", \"user\", \"pwd\"},\n \t\t{\"test.host\", \"user2\", \"pwd2\"},\n+\t\t{\"oneline\", \"user3\", \"pwd3\"},\n+\t\t{\"hasmacro.too\", \"user4\", \"pwd4\"},\n \t}\n \n \tif !reflect.DeepEqual(lines, want) {", "previous_filename": "libgo/go/cmd/go/internal/web2/web_test.go"}, {"sha": "272da55681258dff961bb67a6f1c13dbf36ba1e5", "filename": "libgo/go/cmd/go/internal/base/base.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fbase.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -30,7 +30,7 @@ type Command struct {\n \tRun func(cmd *Command, args []string)\n \n \t// UsageLine is the one-line usage message.\n-\t// The first word in the line is taken to be the command name.\n+\t// The words between \"go\" and the first flag or argument in the line are taken to be the command name.\n \tUsageLine string\n \n \t// Short is the short description shown in the 'go help' output.\n@@ -132,6 +132,10 @@ func SetExitStatus(n int) {\n \texitMu.Unlock()\n }\n \n+func GetExitStatus() int {\n+\treturn exitStatus\n+}\n+\n // Run runs the command, with stdout and stderr\n // connected to the go command's own stdout and stderr.\n // If the command fails, Run reports the error using Errorf."}, {"sha": "077295e0effcee5656192c2a39a0f4824be49f0b", "filename": "libgo/go/cmd/go/internal/base/env.go", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fenv.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -4,34 +4,12 @@\n \n package base\n \n-import \"strings\"\n-\n-// EnvForDir returns a copy of the environment\n-// suitable for running in the given directory.\n-// The environment is the current process's environment\n-// but with an updated $PWD, so that an os.Getwd in the\n-// child will be faster.\n+// EnvForDir returns a modified environment suitable for running in the given\n+// directory.\n+// The environment is the supplied base environment but with an updated $PWD, so\n+// that an os.Getwd in the child will be faster.\n func EnvForDir(dir string, base []string) []string {\n \t// Internally we only use rooted paths, so dir is rooted.\n \t// Even if dir is not rooted, no harm done.\n-\treturn MergeEnvLists([]string{\"PWD=\" + dir}, base)\n-}\n-\n-// MergeEnvLists merges the two environment lists such that\n-// variables with the same name in \"in\" replace those in \"out\".\n-// This always returns a newly allocated slice.\n-func MergeEnvLists(in, out []string) []string {\n-\tout = append([]string(nil), out...)\n-NextVar:\n-\tfor _, inkv := range in {\n-\t\tk := strings.SplitAfterN(inkv, \"=\", 2)[0]\n-\t\tfor i, outkv := range out {\n-\t\t\tif strings.HasPrefix(outkv, k) {\n-\t\t\t\tout[i] = inkv\n-\t\t\t\tcontinue NextVar\n-\t\t\t}\n-\t\t}\n-\t\tout = append(out, inkv)\n-\t}\n-\treturn out\n+\treturn append(base, \"PWD=\"+dir)\n }"}, {"sha": "187c2a1472734ca3a6cb0a162c187e165304c9a1", "filename": "libgo/go/cmd/go/internal/base/goflags.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fgoflags.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -7,7 +7,6 @@ package base\n import (\n \t\"flag\"\n \t\"fmt\"\n-\t\"os\"\n \t\"runtime\"\n \t\"strings\"\n \n@@ -62,7 +61,7 @@ func InitGOFLAGS() {\n \t// (Both will show the GOFLAGS setting if let succeed.)\n \thideErrors := cfg.CmdName == \"env\" || cfg.CmdName == \"bug\"\n \n-\tgoflags = strings.Fields(os.Getenv(\"GOFLAGS\"))\n+\tgoflags = strings.Fields(cfg.Getenv(\"GOFLAGS\"))\n \tif goflags == nil {\n \t\tgoflags = []string{} // avoid work on later InitGOFLAGS call\n \t}"}, {"sha": "fe71281ef054ebebf4a3f51c0f267acbdc4aa999", "filename": "libgo/go/cmd/go/internal/bug/bug.go", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbug%2Fbug.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\turlpkg \"net/url\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -19,7 +20,6 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/envcmd\"\n \t\"cmd/go/internal/web\"\n )\n \n@@ -43,48 +43,60 @@ func runBug(cmd *base.Command, args []string) {\n \t}\n \tvar buf bytes.Buffer\n \tbuf.WriteString(bugHeader)\n-\tinspectGoVersion(&buf)\n-\tfmt.Fprint(&buf, \"#### System details\\n\\n\")\n-\tfmt.Fprintln(&buf, \"```\")\n-\tfmt.Fprintf(&buf, \"go version %s %s/%s\\n\", runtime.Version(), runtime.GOOS, runtime.GOARCH)\n-\tenv := cfg.CmdEnv\n-\tenv = append(env, envcmd.ExtraEnvVars()...)\n-\tfor _, e := range env {\n-\t\t// Hide the TERM environment variable from \"go bug\".\n-\t\t// See issue #18128\n-\t\tif e.Name != \"TERM\" {\n-\t\t\tfmt.Fprintf(&buf, \"%s=\\\"%s\\\"\\n\", e.Name, e.Value)\n-\t\t}\n-\t}\n-\tprintGoDetails(&buf)\n-\tprintOSDetails(&buf)\n-\tprintCDetails(&buf)\n-\tfmt.Fprintln(&buf, \"```\")\n+\tprintGoVersion(&buf)\n+\tbuf.WriteString(\"### Does this issue reproduce with the latest release?\\n\\n\\n\")\n+\tprintEnvDetails(&buf)\n+\tbuf.WriteString(bugFooter)\n \n \tbody := buf.String()\n-\turl := \"https://github.com/golang/go/issues/new?body=\" + web.QueryEscape(body)\n+\turl := \"https://github.com/golang/go/issues/new?body=\" + urlpkg.QueryEscape(body)\n \tif !web.OpenBrowser(url) {\n \t\tfmt.Print(\"Please file a new issue at golang.org/issue/new using this template:\\n\\n\")\n \t\tfmt.Print(body)\n \t}\n }\n \n-const bugHeader = `Please answer these questions before submitting your issue. Thanks!\n+const bugHeader = `<!-- Please answer these questions before submitting your issue. Thanks! -->\n+\n+`\n+const bugFooter = `### What did you do?\n \n-#### What did you do?\n+<!--\n If possible, provide a recipe for reproducing the error.\n A complete runnable program is good.\n A link on play.golang.org is best.\n+-->\n+\n \n \n-#### What did you expect to see?\n+### What did you expect to see?\n \n \n-#### What did you see instead?\n \n+### What did you see instead?\n \n `\n \n+func printGoVersion(w io.Writer) {\n+\tfmt.Fprintf(w, \"### What version of Go are you using (`go version`)?\\n\\n\")\n+\tfmt.Fprintf(w, \"<pre>\\n\")\n+\tfmt.Fprintf(w, \"$ go version\\n\")\n+\tprintCmdOut(w, \"\", \"go\", \"version\")\n+\tfmt.Fprintf(w, \"</pre>\\n\")\n+\tfmt.Fprintf(w, \"\\n\")\n+}\n+\n+func printEnvDetails(w io.Writer) {\n+\tfmt.Fprintf(w, \"### What operating system and processor architecture are you using (`go env`)?\\n\\n\")\n+\tfmt.Fprintf(w, \"<details><summary><code>go env</code> Output</summary><br><pre>\\n\")\n+\tfmt.Fprintf(w, \"$ go env\\n\")\n+\tprintCmdOut(w, \"\", \"go\", \"env\")\n+\tprintGoDetails(w)\n+\tprintOSDetails(w)\n+\tprintCDetails(w)\n+\tfmt.Fprintf(w, \"</pre></details>\\n\\n\")\n+}\n+\n func printGoDetails(w io.Writer) {\n \tprintCmdOut(w, \"GOROOT/bin/go version: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"version\")\n \tprintCmdOut(w, \"GOROOT/bin/go tool compile -V: \", filepath.Join(runtime.GOROOT(), \"bin/go\"), \"tool\", \"compile\", \"-V\")\n@@ -101,7 +113,9 @@ func printOSDetails(w io.Writer) {\n \t\tprintGlibcVersion(w)\n \tcase \"openbsd\", \"netbsd\", \"freebsd\", \"dragonfly\":\n \t\tprintCmdOut(w, \"uname -v: \", \"uname\", \"-v\")\n-\tcase \"solaris\":\n+\tcase \"illumos\", \"solaris\":\n+\t\t// Be sure to use the OS-supplied uname, in \"/usr/bin\":\n+\t\tprintCmdOut(w, \"uname -srv: \", \"/usr/bin/uname\", \"-srv\")\n \t\tout, err := ioutil.ReadFile(\"/etc/release\")\n \t\tif err == nil {\n \t\t\tfmt.Fprintf(w, \"/etc/release: %s\\n\", out)\n@@ -129,30 +143,6 @@ func printCDetails(w io.Writer) {\n \t}\n }\n \n-func inspectGoVersion(w io.Writer) {\n-\tdata, err := web.Get(\"https://golang.org/VERSION?m=text\")\n-\tif err != nil {\n-\t\tif cfg.BuildV {\n-\t\t\tfmt.Printf(\"failed to read from golang.org/VERSION: %v\\n\", err)\n-\t\t}\n-\t\treturn\n-\t}\n-\n-\t// golang.org/VERSION currently returns a whitespace-free string,\n-\t// but just in case, protect against that changing.\n-\t// Similarly so for runtime.Version.\n-\trelease := string(bytes.TrimSpace(data))\n-\tvers := strings.TrimSpace(runtime.Version())\n-\n-\tif vers == release {\n-\t\t// Up to date\n-\t\treturn\n-\t}\n-\n-\t// Devel version or outdated release. Either way, this request is apropos.\n-\tfmt.Fprintf(w, \"#### Does this issue reproduce with the latest release (%s)?\\n\\n\\n\", release)\n-}\n-\n // printCmdOut prints the output of running the given command.\n // It ignores failures; 'go bug' is best effort.\n func printCmdOut(w io.Writer, prefix, path string, args ...string) {"}, {"sha": "116279c977d466041b4da1014d23e64e359b7e40", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -33,7 +33,6 @@ type OutputID [HashSize]byte\n // A Cache is a package cache, backed by a file system directory tree.\n type Cache struct {\n \tdir string\n-\tlog *os.File\n \tnow func() time.Time\n }\n \n@@ -63,13 +62,8 @@ func Open(dir string) (*Cache, error) {\n \t\t\treturn nil, err\n \t\t}\n \t}\n-\tf, err := os.OpenFile(filepath.Join(dir, \"log.txt\"), os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n \tc := &Cache{\n \t\tdir: dir,\n-\t\tlog: f,\n \t\tnow: time.Now,\n \t}\n \treturn c, nil\n@@ -141,7 +135,6 @@ type Entry struct {\n // get is Get but does not respect verify mode, so that Put can use it.\n func (c *Cache) get(id ActionID) (Entry, error) {\n \tmissing := func() (Entry, error) {\n-\t\tfmt.Fprintf(c.log, \"%d miss %x\\n\", c.now().Unix(), id)\n \t\treturn Entry{}, errMissing\n \t}\n \tf, err := os.Open(c.fileName(id, \"a\"))\n@@ -184,8 +177,6 @@ func (c *Cache) get(id ActionID) (Entry, error) {\n \t\treturn missing()\n \t}\n \n-\tfmt.Fprintf(c.log, \"%d get %x\\n\", c.now().Unix(), id)\n-\n \tc.used(c.fileName(id, \"a\"))\n \n \treturn Entry{buf, size, time.Unix(0, tm)}, nil\n@@ -270,7 +261,7 @@ func (c *Cache) Trim() {\n \t// We maintain in dir/trim.txt the time of the last completed cache trim.\n \t// If the cache has been trimmed recently enough, do nothing.\n \t// This is the common case.\n-\tdata, _ := ioutil.ReadFile(filepath.Join(c.dir, \"trim.txt\"))\n+\tdata, _ := renameio.ReadFile(filepath.Join(c.dir, \"trim.txt\"))\n \tt, err := strconv.ParseInt(strings.TrimSpace(string(data)), 10, 64)\n \tif err == nil && now.Sub(time.Unix(t, 0)) < trimInterval {\n \t\treturn\n@@ -287,7 +278,7 @@ func (c *Cache) Trim() {\n \n \t// Ignore errors from here: if we don't write the complete timestamp, the\n \t// cache will appear older than it is, and we'll trim it again next time.\n-\trenameio.WriteFile(filepath.Join(c.dir, \"trim.txt\"), []byte(fmt.Sprintf(\"%d\", now.Unix())))\n+\trenameio.WriteFile(filepath.Join(c.dir, \"trim.txt\"), []byte(fmt.Sprintf(\"%d\", now.Unix())), 0666)\n }\n \n // trimSubdir trims a single cache subdirectory.\n@@ -349,7 +340,6 @@ func (c *Cache) putIndexEntry(id ActionID, out OutputID, size int64, allowVerify\n \t}\n \tos.Chtimes(file, c.now(), c.now()) // mainly for tests\n \n-\tfmt.Fprintf(c.log, \"%d put %x %x %d\\n\", c.now().Unix(), id, out, size)\n \treturn nil\n }\n "}, {"sha": "1988c3450234e3c80a8d86701fc536710f2837d9", "filename": "libgo/go/cmd/go/internal/cache/cache_test.go", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -78,7 +78,7 @@ func TestGrowth(t *testing.T) {\n \n \tn := 10000\n \tif testing.Short() {\n-\t\tn = 1000\n+\t\tn = 10\n \t}\n \n \tfor i := 0; i < n; i++ {\n@@ -144,55 +144,6 @@ func TestVerifyPanic(t *testing.T) {\n \tt.Fatal(\"mismatched Put did not panic in verify mode\")\n }\n \n-func TestCacheLog(t *testing.T) {\n-\tdir, err := ioutil.TempDir(\"\", \"cachetest-\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\n-\tc, err := Open(dir)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Open: %v\", err)\n-\t}\n-\tc.now = func() time.Time { return time.Unix(1e9, 0) }\n-\n-\tid := ActionID(dummyID(1))\n-\tc.Get(id)\n-\tc.PutBytes(id, []byte(\"abc\"))\n-\tc.Get(id)\n-\n-\tc, err = Open(dir)\n-\tif err != nil {\n-\t\tt.Fatalf(\"Open #2: %v\", err)\n-\t}\n-\tc.now = func() time.Time { return time.Unix(1e9+1, 0) }\n-\tc.Get(id)\n-\n-\tid2 := ActionID(dummyID(2))\n-\tc.Get(id2)\n-\tc.PutBytes(id2, []byte(\"abc\"))\n-\tc.Get(id2)\n-\tc.Get(id)\n-\n-\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"log.txt\"))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\twant := `1000000000 miss 0100000000000000000000000000000000000000000000000000000000000000\n-1000000000 put 0100000000000000000000000000000000000000000000000000000000000000 ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad 3\n-1000000000 get 0100000000000000000000000000000000000000000000000000000000000000\n-1000000001 get 0100000000000000000000000000000000000000000000000000000000000000\n-1000000001 miss 0200000000000000000000000000000000000000000000000000000000000000\n-1000000001 put 0200000000000000000000000000000000000000000000000000000000000000 ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad 3\n-1000000001 get 0200000000000000000000000000000000000000000000000000000000000000\n-1000000001 get 0100000000000000000000000000000000000000000000000000000000000000\n-`\n-\tif string(data) != want {\n-\t\tt.Fatalf(\"log:\\n%s\\nwant:\\n%s\", string(data), want)\n-\t}\n-}\n-\n func dummyID(x int) [HashSize]byte {\n \tvar out [HashSize]byte\n \tbinary.LittleEndian.PutUint64(out[:], uint64(x))"}, {"sha": "9f8dd8af4b6b2dc02586c7bc19debab92c5ff6d2", "filename": "libgo/go/cmd/go/internal/cache/default.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fdefault.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"sync\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n )\n \n // Default returns the default cache to use, or nil if no cache should be used.\n@@ -73,7 +74,7 @@ func DefaultDir() string {\n \t// otherwise distinguish between an explicit \"off\" and a UserCacheDir error.\n \n \tdefaultDirOnce.Do(func() {\n-\t\tdefaultDir = os.Getenv(\"GOCACHE\")\n+\t\tdefaultDir = cfg.Getenv(\"GOCACHE\")\n \t\tif filepath.IsAbs(defaultDir) || defaultDir == \"off\" {\n \t\t\treturn\n \t\t}"}, {"sha": "a0b51a72c33d12cdcd5c3b8f7de5c82f8bb37233", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 241, "deletions": 29, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -7,11 +7,15 @@\n package cfg\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"go/build\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"strings\"\n+\t\"sync\"\n \n \t\"cmd/internal/objabi\"\n )\n@@ -34,18 +38,63 @@ var (\n \tBuildToolchainName     string\n \tBuildToolchainCompiler func() string\n \tBuildToolchainLinker   func() string\n+\tBuildTrimpath          bool // -trimpath flag\n \tBuildV                 bool // -v flag\n \tBuildWork              bool // -work flag\n \tBuildX                 bool // -x flag\n \n-\tCmdName string // \"build\", \"install\", \"list\", etc.\n+\tCmdName string // \"build\", \"install\", \"list\", \"mod tidy\", etc.\n \n \tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n )\n \n func defaultContext() build.Context {\n \tctxt := build.Default\n \tctxt.JoinPath = filepath.Join // back door to say \"do not use go command\"\n+\n+\tctxt.GOROOT = findGOROOT()\n+\tif runtime.Compiler != \"gccgo\" {\n+\t\t// Note that we must use runtime.GOOS and runtime.GOARCH here,\n+\t\t// as the tool directory does not move based on environment\n+\t\t// variables. This matches the initialization of ToolDir in\n+\t\t// go/build, except for using ctxt.GOROOT rather than\n+\t\t// runtime.GOROOT.\n+\t\tbuild.ToolDir = filepath.Join(ctxt.GOROOT, \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+\t}\n+\n+\tctxt.GOPATH = envOr(\"GOPATH\", ctxt.GOPATH)\n+\n+\t// Override defaults computed in go/build with defaults\n+\t// from go environment configuration file, if known.\n+\tctxt.GOOS = envOr(\"GOOS\", ctxt.GOOS)\n+\tctxt.GOARCH = envOr(\"GOARCH\", ctxt.GOARCH)\n+\n+\t// The go/build rule for whether cgo is enabled is:\n+\t//\t1. If $CGO_ENABLED is set, respect it.\n+\t//\t2. Otherwise, if this is a cross-compile, disable cgo.\n+\t//\t3. Otherwise, use built-in default for GOOS/GOARCH.\n+\t// Recreate that logic here with the new GOOS/GOARCH setting.\n+\tif v := Getenv(\"CGO_ENABLED\"); v == \"0\" || v == \"1\" {\n+\t\tctxt.CgoEnabled = v[0] == '1'\n+\t} else if ctxt.GOOS != runtime.GOOS || ctxt.GOARCH != runtime.GOARCH {\n+\t\tctxt.CgoEnabled = false\n+\t} else {\n+\t\t// Use built-in default cgo setting for GOOS/GOARCH.\n+\t\t// Note that ctxt.GOOS/GOARCH are derived from the preference list\n+\t\t// (1) environment, (2) go/env file, (3) runtime constants,\n+\t\t// while go/build.Default.GOOS/GOARCH are derived from the preference list\n+\t\t// (1) environment, (2) runtime constants.\n+\t\t// We know ctxt.GOOS/GOARCH == runtime.GOOS/GOARCH;\n+\t\t// no matter how that happened, go/build.Default will make the\n+\t\t// same decision (either the environment variables are set explicitly\n+\t\t// to match the runtime constants, or else they are unset, in which\n+\t\t// case go/build falls back to the runtime constants), so\n+\t\t// go/build.Default.GOOS/GOARCH == runtime.GOOS/GOARCH.\n+\t\t// So ctxt.CgoEnabled (== go/build.Default.CgoEnabled) is correct\n+\t\t// as is and can be left unmodified.\n+\t\t// Nothing to do here.\n+\t}\n+\n \treturn ctxt\n }\n \n@@ -70,54 +119,215 @@ var CmdEnv []EnvVar\n \n // Global build parameters (used during package load)\n var (\n-\tGoarch    = BuildContext.GOARCH\n-\tGoos      = BuildContext.GOOS\n-\tExeSuffix string\n-\tGopath    = filepath.SplitList(BuildContext.GOPATH)\n+\tGoarch = BuildContext.GOARCH\n+\tGoos   = BuildContext.GOOS\n+\n+\tExeSuffix = exeSuffix()\n \n \t// ModulesEnabled specifies whether the go command is running\n \t// in module-aware mode (as opposed to GOPATH mode).\n \t// It is equal to modload.Enabled, but not all packages can import modload.\n \tModulesEnabled bool\n-\n-\t// GoModInGOPATH records whether we've found a go.mod in GOPATH/src\n-\t// in GO111MODULE=auto mode. In that case, we don't use modules\n-\t// but people might expect us to, so 'go get' warns.\n-\tGoModInGOPATH string\n )\n \n-func init() {\n+func exeSuffix() string {\n \tif Goos == \"windows\" {\n-\t\tExeSuffix = \".exe\"\n+\t\treturn \".exe\"\n+\t}\n+\treturn \"\"\n+}\n+\n+var envCache struct {\n+\tonce sync.Once\n+\tm    map[string]string\n+}\n+\n+// EnvFile returns the name of the Go environment configuration file.\n+func EnvFile() (string, error) {\n+\tif file := os.Getenv(\"GOENV\"); file != \"\" {\n+\t\tif file == \"off\" {\n+\t\t\treturn \"\", fmt.Errorf(\"GOENV=off\")\n+\t\t}\n+\t\treturn file, nil\n+\t}\n+\tdir, err := os.UserConfigDir()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif dir == \"\" {\n+\t\treturn \"\", fmt.Errorf(\"missing user-config dir\")\n+\t}\n+\treturn filepath.Join(dir, \"go/env\"), nil\n+}\n+\n+func initEnvCache() {\n+\tenvCache.m = make(map[string]string)\n+\tfile, _ := EnvFile()\n+\tif file == \"\" {\n+\t\treturn\n+\t}\n+\tdata, err := ioutil.ReadFile(file)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tfor len(data) > 0 {\n+\t\t// Get next line.\n+\t\tline := data\n+\t\ti := bytes.IndexByte(data, '\\n')\n+\t\tif i >= 0 {\n+\t\t\tline, data = line[:i], data[i+1:]\n+\t\t} else {\n+\t\t\tdata = nil\n+\t\t}\n+\n+\t\ti = bytes.IndexByte(line, '=')\n+\t\tif i < 0 || line[0] < 'A' || 'Z' < line[0] {\n+\t\t\t// Line is missing = (or empty) or a comment or not a valid env name. Ignore.\n+\t\t\t// (This should not happen, since the file should be maintained almost\n+\t\t\t// exclusively by \"go env -w\", but better to silently ignore than to make\n+\t\t\t// the go command unusable just because somehow the env file has\n+\t\t\t// gotten corrupted.)\n+\t\t\tcontinue\n+\t\t}\n+\t\tkey, val := line[:i], line[i+1:]\n+\t\tenvCache.m[string(key)] = string(val)\n+\t}\n+}\n+\n+// Getenv gets the value for the configuration key.\n+// It consults the operating system environment\n+// and then the go/env file.\n+// If Getenv is called for a key that cannot be set\n+// in the go/env file (for example GODEBUG), it panics.\n+// This ensures that CanGetenv is accurate, so that\n+// 'go env -w' stays in sync with what Getenv can retrieve.\n+func Getenv(key string) string {\n+\tif !CanGetenv(key) {\n+\t\tswitch key {\n+\t\tcase \"CGO_TEST_ALLOW\", \"CGO_TEST_DISALLOW\", \"CGO_test_ALLOW\", \"CGO_test_DISALLOW\":\n+\t\t\t// used by internal/work/security_test.go; allow\n+\t\tdefault:\n+\t\t\tpanic(\"internal error: invalid Getenv \" + key)\n+\t\t}\n+\t}\n+\tval := os.Getenv(key)\n+\tif val != \"\" {\n+\t\treturn val\n \t}\n+\tenvCache.once.Do(initEnvCache)\n+\treturn envCache.m[key]\n }\n \n+// CanGetenv reports whether key is a valid go/env configuration key.\n+func CanGetenv(key string) bool {\n+\treturn strings.Contains(knownEnv, \"\\t\"+key+\"\\n\")\n+}\n+\n+var knownEnv = `\n+\tAR\n+\tCC\n+\tCGO_CFLAGS\n+\tCGO_CFLAGS_ALLOW\n+\tCGO_CFLAGS_DISALLOW\n+\tCGO_CPPFLAGS\n+\tCGO_CPPFLAGS_ALLOW\n+\tCGO_CPPFLAGS_DISALLOW\n+\tCGO_CXXFLAGS\n+\tCGO_CXXFLAGS_ALLOW\n+\tCGO_CXXFLAGS_DISALLOW\n+\tCGO_ENABLED\n+\tCGO_FFLAGS\n+\tCGO_FFLAGS_ALLOW\n+\tCGO_FFLAGS_DISALLOW\n+\tCGO_LDFLAGS\n+\tCGO_LDFLAGS_ALLOW\n+\tCGO_LDFLAGS_DISALLOW\n+\tCXX\n+\tFC\n+\tGCCGO\n+\tGO111MODULE\n+\tGO386\n+\tGOARCH\n+\tGOARM\n+\tGOBIN\n+\tGOCACHE\n+\tGOENV\n+\tGOEXE\n+\tGOFLAGS\n+\tGOGCCFLAGS\n+\tGOHOSTARCH\n+\tGOHOSTOS\n+\tGOMIPS\n+\tGOMIPS64\n+\tGONOPROXY\n+\tGONOSUMDB\n+\tGOOS\n+\tGOPATH\n+\tGOPPC64\n+\tGOPRIVATE\n+\tGOPROXY\n+\tGOROOT\n+\tGOSUMDB\n+\tGOTMPDIR\n+\tGOTOOLDIR\n+\tGOWASM\n+\tGO_EXTLINK_ENABLED\n+\tPKG_CONFIG\n+`\n+\n var (\n-\tGOROOT       = findGOROOT()\n-\tGOBIN        = os.Getenv(\"GOBIN\")\n+\tGOROOT       = BuildContext.GOROOT\n+\tGOBIN        = Getenv(\"GOBIN\")\n \tGOROOTbin    = filepath.Join(GOROOT, \"bin\")\n \tGOROOTpkg    = filepath.Join(GOROOT, \"pkg\")\n \tGOROOTsrc    = filepath.Join(GOROOT, \"src\")\n \tGOROOT_FINAL = findGOROOT_FINAL()\n \n \t// Used in envcmd.MkEnv and build ID computations.\n-\tGOARM    = fmt.Sprint(objabi.GOARM)\n-\tGO386    = objabi.GO386\n-\tGOMIPS   = objabi.GOMIPS\n-\tGOMIPS64 = objabi.GOMIPS64\n+\tGOARM    = envOr(\"GOARM\", fmt.Sprint(objabi.GOARM))\n+\tGO386    = envOr(\"GO386\", objabi.GO386)\n+\tGOMIPS   = envOr(\"GOMIPS\", objabi.GOMIPS)\n+\tGOMIPS64 = envOr(\"GOMIPS64\", objabi.GOMIPS64)\n+\tGOPPC64  = envOr(\"GOPPC64\", fmt.Sprintf(\"%s%d\", \"power\", objabi.GOPPC64))\n+\tGOWASM   = envOr(\"GOWASM\", fmt.Sprint(objabi.GOWASM))\n+\n+\tGOPROXY   = envOr(\"GOPROXY\", \"https://proxy.golang.org,direct\")\n+\tGOSUMDB   = envOr(\"GOSUMDB\", \"sum.golang.org\")\n+\tGOPRIVATE = Getenv(\"GOPRIVATE\")\n+\tGONOPROXY = envOr(\"GONOPROXY\", GOPRIVATE)\n+\tGONOSUMDB = envOr(\"GONOSUMDB\", GOPRIVATE)\n )\n \n-// Update build context to use our computed GOROOT.\n-func init() {\n-\tBuildContext.GOROOT = GOROOT\n-\tif runtime.Compiler != \"gccgo\" {\n-\t\t// Note that we must use runtime.GOOS and runtime.GOARCH here,\n-\t\t// as the tool directory does not move based on environment\n-\t\t// variables. This matches the initialization of ToolDir in\n-\t\t// go/build, except for using GOROOT rather than\n-\t\t// runtime.GOROOT.\n-\t\tbuild.ToolDir = filepath.Join(GOROOT, \"pkg/tool/\"+runtime.GOOS+\"_\"+runtime.GOARCH)\n+// GetArchEnv returns the name and setting of the\n+// GOARCH-specific architecture environment variable.\n+// If the current architecture has no GOARCH-specific variable,\n+// GetArchEnv returns empty key and value.\n+func GetArchEnv() (key, val string) {\n+\tswitch Goarch {\n+\tcase \"arm\":\n+\t\treturn \"GOARM\", GOARM\n+\tcase \"386\":\n+\t\treturn \"GO386\", GO386\n+\tcase \"mips\", \"mipsle\":\n+\t\treturn \"GOMIPS\", GOMIPS\n+\tcase \"mips64\", \"mips64le\":\n+\t\treturn \"GOMIPS64\", GOMIPS64\n+\tcase \"ppc64\", \"ppc64le\":\n+\t\treturn \"GOPPC64\", GOPPC64\n+\tcase \"wasm\":\n+\t\treturn \"GOWASM\", GOWASM\n+\t}\n+\treturn \"\", \"\"\n+}\n+\n+// envOr returns Getenv(key) if set, or else def.\n+func envOr(key, def string) string {\n+\tval := Getenv(key)\n+\tif val == \"\" {\n+\t\tval = def\n \t}\n+\treturn val\n }\n \n // There is a copy of findGOROOT, isSameDir, and isGOROOT in\n@@ -131,7 +341,7 @@ func init() {\n //\n // There is a copy of this code in x/tools/cmd/godoc/goroot.go.\n func findGOROOT() string {\n-\tif env := os.Getenv(\"GOROOT\"); env != \"\" {\n+\tif env := Getenv(\"GOROOT\"); env != \"\" {\n \t\treturn filepath.Clean(env)\n \t}\n \tdef := filepath.Clean(runtime.GOROOT())\n@@ -167,6 +377,8 @@ func findGOROOT() string {\n }\n \n func findGOROOT_FINAL() string {\n+\t// $GOROOT_FINAL is only for use during make.bash\n+\t// so it is not settable using go/env, so we use os.Getenv here.\n \tdef := GOROOT\n \tif env := os.Getenv(\"GOROOT_FINAL\"); env != \"\" {\n \t\tdef = filepath.Clean(env)"}, {"sha": "f7d80ff6dc8a13074110e28408dc54268dccbf66", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -33,7 +33,8 @@ The go command builds most objects in a temporary directory,\n so go clean is mainly concerned with object files left by other\n tools or by manual invocations of go build.\n \n-Specifically, clean removes the following files from each of the\n+If a package argument is given or the -i or -r flag is set,\n+clean removes the following files from each of the\n source directories corresponding to the import paths:\n \n \t_obj/            old object directory, left from Makefiles\n@@ -105,7 +106,16 @@ func init() {\n }\n \n func runClean(cmd *base.Command, args []string) {\n-\tif len(args) > 0 || !modload.Enabled() || modload.HasModRoot() {\n+\t// golang.org/issue/29925: only load packages before cleaning if\n+\t// either the flags and arguments explicitly imply a package,\n+\t// or no other target (such as a cache) was requested to be cleaned.\n+\tcleanPkg := len(args) > 0 || cleanI || cleanR\n+\tif (!modload.Enabled() || modload.HasModRoot()) &&\n+\t\t!cleanCache && !cleanModcache && !cleanTestcache {\n+\t\tcleanPkg = true\n+\t}\n+\n+\tif cleanPkg {\n \t\tfor _, pkg := range load.PackagesAndErrors(args) {\n \t\t\tclean(pkg)\n \t\t}\n@@ -122,11 +132,11 @@ func runClean(cmd *base.Command, args []string) {\n \t\t\t// and not something that we want to remove. Also, we'd like to preserve\n \t\t\t// the access log for future analysis, even if the cache is cleared.\n \t\t\tsubdirs, _ := filepath.Glob(filepath.Join(dir, \"[0-9a-f][0-9a-f]\"))\n+\t\t\tprintedErrors := false\n \t\t\tif len(subdirs) > 0 {\n \t\t\t\tif cfg.BuildN || cfg.BuildX {\n \t\t\t\t\tb.Showcmd(\"\", \"rm -r %s\", strings.Join(subdirs, \" \"))\n \t\t\t\t}\n-\t\t\t\tprintedErrors := false\n \t\t\t\tfor _, d := range subdirs {\n \t\t\t\t\t// Only print the first error - there may be many.\n \t\t\t\t\t// This also mimics what os.RemoveAll(dir) would do.\n@@ -136,6 +146,12 @@ func runClean(cmd *base.Command, args []string) {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tlogFile := filepath.Join(dir, \"log.txt\")\n+\t\t\tif err := os.RemoveAll(logFile); err != nil && !printedErrors {\n+\t\t\t\tprintedErrors = true\n+\t\t\t\tbase.Errorf(\"go clean -cache: %v\", err)\n+\t\t\t}\n \t\t}\n \t}\n "}, {"sha": "17852deed1e703a52118539316af10cb859c2629", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 222, "deletions": 19, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,10 +8,13 @@ package envcmd\n import (\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n+\t\"sort\"\n \t\"strings\"\n+\t\"unicode/utf8\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n@@ -22,7 +25,7 @@ import (\n )\n \n var CmdEnv = &base.Command{\n-\tUsageLine: \"go env [-json] [var ...]\",\n+\tUsageLine: \"go env [-json] [-u] [-w] [var ...]\",\n \tShort:     \"print Go environment information\",\n \tLong: `\n Env prints Go environment information.\n@@ -35,6 +38,14 @@ each named variable on its own line.\n The -json flag prints the environment in JSON format\n instead of as a shell script.\n \n+The -u flag requires one or more arguments and unsets\n+the default setting for the named environment variables,\n+if one has been set with 'go env -w'.\n+\n+The -w flag requires one or more arguments of the\n+form NAME=VALUE and changes the default settings\n+of the named environment variables to the given values.\n+\n For more about environment variables, see 'go help environment'.\n \t`,\n }\n@@ -43,26 +54,36 @@ func init() {\n \tCmdEnv.Run = runEnv // break init cycle\n }\n \n-var envJson = CmdEnv.Flag.Bool(\"json\", false, \"\")\n+var (\n+\tenvJson = CmdEnv.Flag.Bool(\"json\", false, \"\")\n+\tenvU    = CmdEnv.Flag.Bool(\"u\", false, \"\")\n+\tenvW    = CmdEnv.Flag.Bool(\"w\", false, \"\")\n+)\n \n func MkEnv() []cfg.EnvVar {\n \tvar b work.Builder\n \tb.Init()\n \n+\tenvFile, _ := cfg.EnvFile()\n \tenv := []cfg.EnvVar{\n+\t\t{Name: \"GO111MODULE\", Value: cfg.Getenv(\"GO111MODULE\")},\n \t\t{Name: \"GOARCH\", Value: cfg.Goarch},\n \t\t{Name: \"GOBIN\", Value: cfg.GOBIN},\n \t\t{Name: \"GOCACHE\", Value: cache.DefaultDir()},\n+\t\t{Name: \"GOENV\", Value: envFile},\n \t\t{Name: \"GOEXE\", Value: cfg.ExeSuffix},\n-\t\t{Name: \"GOFLAGS\", Value: os.Getenv(\"GOFLAGS\")},\n+\t\t{Name: \"GOFLAGS\", Value: cfg.Getenv(\"GOFLAGS\")},\n \t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n \t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n+\t\t{Name: \"GONOPROXY\", Value: cfg.GONOPROXY},\n+\t\t{Name: \"GONOSUMDB\", Value: cfg.GONOSUMDB},\n \t\t{Name: \"GOOS\", Value: cfg.Goos},\n \t\t{Name: \"GOPATH\", Value: cfg.BuildContext.GOPATH},\n-\t\t{Name: \"GOPROXY\", Value: os.Getenv(\"GOPROXY\")},\n-\t\t{Name: \"GORACE\", Value: os.Getenv(\"GORACE\")},\n+\t\t{Name: \"GOPRIVATE\", Value: cfg.GOPRIVATE},\n+\t\t{Name: \"GOPROXY\", Value: cfg.GOPROXY},\n \t\t{Name: \"GOROOT\", Value: cfg.GOROOT},\n-\t\t{Name: \"GOTMPDIR\", Value: os.Getenv(\"GOTMPDIR\")},\n+\t\t{Name: \"GOSUMDB\", Value: cfg.GOSUMDB},\n+\t\t{Name: \"GOTMPDIR\", Value: cfg.Getenv(\"GOTMPDIR\")},\n \t\t{Name: \"GOTOOLDIR\", Value: base.ToolDir},\n \t}\n \n@@ -72,25 +93,20 @@ func MkEnv() []cfg.EnvVar {\n \t\tenv = append(env, cfg.EnvVar{Name: \"GCCGO\", Value: work.GccgoName})\n \t}\n \n-\tswitch cfg.Goarch {\n-\tcase \"arm\":\n-\t\tenv = append(env, cfg.EnvVar{Name: \"GOARM\", Value: cfg.GOARM})\n-\tcase \"386\":\n-\t\tenv = append(env, cfg.EnvVar{Name: \"GO386\", Value: cfg.GO386})\n-\tcase \"mips\", \"mipsle\":\n-\t\tenv = append(env, cfg.EnvVar{Name: \"GOMIPS\", Value: cfg.GOMIPS})\n-\tcase \"mips64\", \"mips64le\":\n-\t\tenv = append(env, cfg.EnvVar{Name: \"GOMIPS64\", Value: cfg.GOMIPS64})\n+\tkey, val := cfg.GetArchEnv()\n+\tif key != \"\" {\n+\t\tenv = append(env, cfg.EnvVar{Name: key, Value: val})\n \t}\n \n \tcc := cfg.DefaultCC(cfg.Goos, cfg.Goarch)\n-\tif env := strings.Fields(os.Getenv(\"CC\")); len(env) > 0 {\n+\tif env := strings.Fields(cfg.Getenv(\"CC\")); len(env) > 0 {\n \t\tcc = env[0]\n \t}\n \tcxx := cfg.DefaultCXX(cfg.Goos, cfg.Goarch)\n-\tif env := strings.Fields(os.Getenv(\"CXX\")); len(env) > 0 {\n+\tif env := strings.Fields(cfg.Getenv(\"CXX\")); len(env) > 0 {\n \t\tcxx = env[0]\n \t}\n+\tenv = append(env, cfg.EnvVar{Name: \"AR\", Value: envOr(\"AR\", \"ar\")})\n \tenv = append(env, cfg.EnvVar{Name: \"CC\", Value: cc})\n \tenv = append(env, cfg.EnvVar{Name: \"CXX\", Value: cxx})\n \n@@ -103,6 +119,14 @@ func MkEnv() []cfg.EnvVar {\n \treturn env\n }\n \n+func envOr(name, def string) string {\n+\tval := cfg.Getenv(name)\n+\tif val != \"\" {\n+\t\treturn val\n+\t}\n+\treturn def\n+}\n+\n func findEnv(env []cfg.EnvVar, name string) string {\n \tfor _, e := range env {\n \t\tif e.Name == name {\n@@ -150,7 +174,25 @@ func ExtraEnvVarsCostly() []cfg.EnvVar {\n \t}\n }\n \n+// argKey returns the KEY part of the arg KEY=VAL, or else arg itself.\n+func argKey(arg string) string {\n+\ti := strings.Index(arg, \"=\")\n+\tif i < 0 {\n+\t\treturn arg\n+\t}\n+\treturn arg[:i]\n+}\n+\n func runEnv(cmd *base.Command, args []string) {\n+\tif *envJson && *envU {\n+\t\tbase.Fatalf(\"go env: cannot use -json with -u\")\n+\t}\n+\tif *envJson && *envW {\n+\t\tbase.Fatalf(\"go env: cannot use -json with -w\")\n+\t}\n+\tif *envU && *envW {\n+\t\tbase.Fatalf(\"go env: cannot use -u with -w\")\n+\t}\n \tenv := cfg.CmdEnv\n \tenv = append(env, ExtraEnvVars()...)\n \n@@ -161,7 +203,7 @@ func runEnv(cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tneedCostly = false\n \t\tfor _, arg := range args {\n-\t\t\tswitch arg {\n+\t\t\tswitch argKey(arg) {\n \t\t\tcase \"CGO_CFLAGS\",\n \t\t\t\t\"CGO_CPPFLAGS\",\n \t\t\t\t\"CGO_CXXFLAGS\",\n@@ -177,6 +219,55 @@ func runEnv(cmd *base.Command, args []string) {\n \t\tenv = append(env, ExtraEnvVarsCostly()...)\n \t}\n \n+\tif *envW {\n+\t\t// Process and sanity-check command line.\n+\t\tif len(args) == 0 {\n+\t\t\tbase.Fatalf(\"go env -w: no KEY=VALUE arguments given\")\n+\t\t}\n+\t\tosEnv := make(map[string]string)\n+\t\tfor _, e := range cfg.OrigEnv {\n+\t\t\tif i := strings.Index(e, \"=\"); i >= 0 {\n+\t\t\t\tosEnv[e[:i]] = e[i+1:]\n+\t\t\t}\n+\t\t}\n+\t\tadd := make(map[string]string)\n+\t\tfor _, arg := range args {\n+\t\t\ti := strings.Index(arg, \"=\")\n+\t\t\tif i < 0 {\n+\t\t\t\tbase.Fatalf(\"go env -w: arguments must be KEY=VALUE: invalid argument: %s\", arg)\n+\t\t\t}\n+\t\t\tkey, val := arg[:i], arg[i+1:]\n+\t\t\tif err := checkEnvWrite(key, val, env); err != nil {\n+\t\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n+\t\t\t}\n+\t\t\tif _, ok := add[key]; ok {\n+\t\t\t\tbase.Fatalf(\"go env -w: multiple values for key: %s\", key)\n+\t\t\t}\n+\t\t\tadd[key] = val\n+\t\t\tif osVal := osEnv[key]; osVal != \"\" && osVal != val {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"warning: go env -w %s=... does not override conflicting OS environment variable\\n\", key)\n+\t\t\t}\n+\t\t}\n+\t\tupdateEnvFile(add, nil)\n+\t\treturn\n+\t}\n+\n+\tif *envU {\n+\t\t// Process and sanity-check command line.\n+\t\tif len(args) == 0 {\n+\t\t\tbase.Fatalf(\"go env -u: no arguments given\")\n+\t\t}\n+\t\tdel := make(map[string]bool)\n+\t\tfor _, arg := range args {\n+\t\t\tif err := checkEnvWrite(arg, \"\", env); err != nil {\n+\t\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n+\t\t\t}\n+\t\t\tdel[arg] = true\n+\t\t}\n+\t\tupdateEnvFile(nil, del)\n+\t\treturn\n+\t}\n+\n \tif len(args) > 0 {\n \t\tif *envJson {\n \t\t\tvar es []cfg.EnvVar\n@@ -235,6 +326,118 @@ func printEnvAsJSON(env []cfg.EnvVar) {\n \tenc := json.NewEncoder(os.Stdout)\n \tenc.SetIndent(\"\", \"\\t\")\n \tif err := enc.Encode(m); err != nil {\n-\t\tbase.Fatalf(\"%s\", err)\n+\t\tbase.Fatalf(\"go env -json: %s\", err)\n+\t}\n+}\n+\n+func checkEnvWrite(key, val string, env []cfg.EnvVar) error {\n+\tswitch key {\n+\tcase \"GOEXE\", \"GOGCCFLAGS\", \"GOHOSTARCH\", \"GOHOSTOS\", \"GOMOD\", \"GOTOOLDIR\":\n+\t\treturn fmt.Errorf(\"%s cannot be modified\", key)\n+\tcase \"GOENV\":\n+\t\treturn fmt.Errorf(\"%s can only be set using the OS environment\", key)\n+\t}\n+\n+\t// To catch typos and the like, check that we know the variable.\n+\tif !cfg.CanGetenv(key) {\n+\t\treturn fmt.Errorf(\"unknown go command variable %s\", key)\n+\t}\n+\n+\tif !utf8.ValidString(val) {\n+\t\treturn fmt.Errorf(\"invalid UTF-8 in %s=... value\", key)\n+\t}\n+\tif strings.Contains(val, \"\\x00\") {\n+\t\treturn fmt.Errorf(\"invalid NUL in %s=... value\", key)\n+\t}\n+\tif strings.ContainsAny(val, \"\\v\\r\\n\") {\n+\t\treturn fmt.Errorf(\"invalid newline in %s=... value\", key)\n+\t}\n+\treturn nil\n+}\n+\n+func updateEnvFile(add map[string]string, del map[string]bool) {\n+\tfile, err := cfg.EnvFile()\n+\tif file == \"\" {\n+\t\tbase.Fatalf(\"go env: cannot find go env config: %v\", err)\n+\t}\n+\tdata, err := ioutil.ReadFile(file)\n+\tif err != nil && (!os.IsNotExist(err) || len(add) == 0) {\n+\t\tbase.Fatalf(\"go env: reading go env config: %v\", err)\n \t}\n+\n+\tlines := strings.SplitAfter(string(data), \"\\n\")\n+\tif lines[len(lines)-1] == \"\" {\n+\t\tlines = lines[:len(lines)-1]\n+\t} else {\n+\t\tlines[len(lines)-1] += \"\\n\"\n+\t}\n+\n+\t// Delete all but last copy of any duplicated variables,\n+\t// since the last copy is the one that takes effect.\n+\tprev := make(map[string]int)\n+\tfor l, line := range lines {\n+\t\tif key := lineToKey(line); key != \"\" {\n+\t\t\tif p, ok := prev[key]; ok {\n+\t\t\t\tlines[p] = \"\"\n+\t\t\t}\n+\t\t\tprev[key] = l\n+\t\t}\n+\t}\n+\n+\t// Add variables (go env -w). Update existing lines in file if present, add to end otherwise.\n+\tfor key, val := range add {\n+\t\tif p, ok := prev[key]; ok {\n+\t\t\tlines[p] = key + \"=\" + val + \"\\n\"\n+\t\t\tdelete(add, key)\n+\t\t}\n+\t}\n+\tfor key, val := range add {\n+\t\tlines = append(lines, key+\"=\"+val+\"\\n\")\n+\t}\n+\n+\t// Delete requested variables (go env -u).\n+\tfor key := range del {\n+\t\tif p, ok := prev[key]; ok {\n+\t\t\tlines[p] = \"\"\n+\t\t}\n+\t}\n+\n+\t// Sort runs of KEY=VALUE lines\n+\t// (that is, blocks of lines where blocks are separated\n+\t// by comments, blank lines, or invalid lines).\n+\tstart := 0\n+\tfor i := 0; i <= len(lines); i++ {\n+\t\tif i == len(lines) || lineToKey(lines[i]) == \"\" {\n+\t\t\tsortKeyValues(lines[start:i])\n+\t\t\tstart = i + 1\n+\t\t}\n+\t}\n+\n+\tdata = []byte(strings.Join(lines, \"\"))\n+\terr = ioutil.WriteFile(file, data, 0666)\n+\tif err != nil {\n+\t\t// Try creating directory.\n+\t\tos.MkdirAll(filepath.Dir(file), 0777)\n+\t\terr = ioutil.WriteFile(file, data, 0666)\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go env: writing go env config: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+// lineToKey returns the KEY part of the line KEY=VALUE or else an empty string.\n+func lineToKey(line string) string {\n+\ti := strings.Index(line, \"=\")\n+\tif i < 0 || strings.Contains(line[:i], \"#\") {\n+\t\treturn \"\"\n+\t}\n+\treturn line[:i]\n+}\n+\n+// sortKeyValues sorts a sequence of lines by key.\n+// It differs from sort.Strings in that GO386= sorts after GO=.\n+func sortKeyValues(lines []string) {\n+\tsort.Slice(lines, func(i, j int) bool {\n+\t\treturn lineToKey(lines[i]) < lineToKey(lines[j])\n+\t})\n }"}, {"sha": "f2ae80e5dc68f5e2764c07e6f2226fba743108ee", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -110,11 +110,13 @@ specifies that the command \"foo\" represents the generator\n \"go tool foo\".\n \n Generate processes packages in the order given on the command line,\n-one at a time. If the command line lists .go files, they are treated\n-as a single package. Within a package, generate processes the\n+one at a time. If the command line lists .go files from a single directory,\n+they are treated as a single package. Within a package, generate processes the\n source files in a package in file name order, one at a time. Within\n a source file, generate runs generators in the order they appear\n-in the file, one at a time.\n+in the file, one at a time. The go generate tool also sets the build\n+tag \"generate\" so that files may be examined by go generate but ignored\n+during build.\n \n If any generator returns an error exit status, \"go generate\" skips\n all further processing for that package.\n@@ -161,6 +163,9 @@ func runGenerate(cmd *base.Command, args []string) {\n \t\t\tlog.Fatalf(\"generate: %s\", err)\n \t\t}\n \t}\n+\n+\tcfg.BuildContext.BuildTags = append(cfg.BuildContext.BuildTags, \"generate\")\n+\n \t// Even if the arguments are .go files, this loop suffices.\n \tprinted := false\n \tfor _, pkg := range load.Packages(args) {\n@@ -374,7 +379,12 @@ Words:\n \t// Substitute command if required.\n \tif len(words) > 0 && g.commands[words[0]] != nil {\n \t\t// Replace 0th word by command substitution.\n-\t\twords = append(g.commands[words[0]], words[1:]...)\n+\t\t//\n+\t\t// Force a copy of the command definition to\n+\t\t// ensure words doesn't end up as a reference\n+\t\t// to the g.commands content.\n+\t\ttmpCmdWords := append([]string(nil), (g.commands[words[0]])...)\n+\t\twords = append(tmpCmdWords, words[1:]...)\n \t}\n \t// Substitute environment variables.\n \tfor i, word := range words {\n@@ -428,7 +438,7 @@ func (g *Generator) exec(words []string) {\n \tcmd.Stderr = os.Stderr\n \t// Run the command in the package directory.\n \tcmd.Dir = g.dir\n-\tcmd.Env = base.MergeEnvLists(g.env, cfg.OrigEnv)\n+\tcmd.Env = append(cfg.OrigEnv, g.env...)\n \terr := cmd.Run()\n \tif err != nil {\n \t\tg.errorf(\"running %q: %s\", words[0], err)"}, {"sha": "b546218a3c589f3c1da6566a38b7677a5407083d", "filename": "libgo/go/cmd/go/internal/generate/generate_test.go", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,6 +5,7 @@\n package generate\n \n import (\n+\t\"os\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"testing\"\n@@ -15,6 +16,15 @@ type splitTest struct {\n \tout []string\n }\n \n+// Same as above, except including source line number to set\n+type splitTestWithLine struct {\n+\tin         string\n+\tout        []string\n+\tlineNumber int\n+}\n+\n+const anyLineNo = 0\n+\n var splitTests = []splitTest{\n \t{\"\", nil},\n \t{\"x\", []string{\"x\"}},\n@@ -54,3 +64,191 @@ func TestGenerateCommandParse(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// These environment variables will be undefined before the splitTestWithLine tests\n+var undefEnvList = []string{\n+\t\"_XYZZY_\",\n+}\n+\n+// These environment variables will be defined before the splitTestWithLine tests\n+var defEnvMap = map[string]string{\n+\t\"_PLUGH_\": \"SomeVal\",\n+\t\"_X\":      \"Y\",\n+}\n+\n+// TestGenerateCommandShortHand - similar to TestGenerateCommandParse,\n+// except:\n+//    1. if the result starts with -command, record that shorthand\n+//       before moving on to the next test.\n+//    2. If a source line number is specified, set that in the parser\n+//       before executing the test.  i.e., execute the split as if it\n+//       processing that source line.\n+func TestGenerateCommandShorthand(t *testing.T) {\n+\tg := &Generator{\n+\t\tr:        nil, // Unused here.\n+\t\tpath:     \"/usr/ken/sys/proc.go\",\n+\t\tdir:      \"/usr/ken/sys\",\n+\t\tfile:     \"proc.go\",\n+\t\tpkg:      \"sys\",\n+\t\tcommands: make(map[string][]string),\n+\t}\n+\n+\tvar inLine string\n+\tvar expected, got []string\n+\n+\tg.setEnv()\n+\n+\t// Set up the system environment variables\n+\tfor i := range undefEnvList {\n+\t\tos.Unsetenv(undefEnvList[i])\n+\t}\n+\tfor k := range defEnvMap {\n+\t\tos.Setenv(k, defEnvMap[k])\n+\t}\n+\n+\t// simple command from environment variable\n+\tinLine = \"//go:generate -command CMD0 \\\"ab${_X}cd\\\"\"\n+\texpected = []string{\"-command\", \"CMD0\", \"abYcd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\t// try again, with an extra level of indirection (should leave variable in command)\n+\tinLine = \"//go:generate -command CMD0 \\\"ab${DOLLAR}{_X}cd\\\"\"\n+\texpected = []string{\"-command\", \"CMD0\", \"ab${_X}cd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\t// Now the interesting part, record that output as a command\n+\tg.setShorthand(got)\n+\n+\t// see that the command still substitutes correctly from env. variable\n+\tinLine = \"//go:generate CMD0\"\n+\texpected = []string{\"abYcd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\t// Now change the value of $X and see if the recorded definition is\n+\t// still intact (vs. having the $_X already substituted out)\n+\n+\tos.Setenv(\"_X\", \"Z\")\n+\tinLine = \"//go:generate CMD0\"\n+\texpected = []string{\"abZcd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\t// What if the variable is now undefined?  Should be empty substitution.\n+\n+\tos.Unsetenv(\"_X\")\n+\tinLine = \"//go:generate CMD0\"\n+\texpected = []string{\"abcd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\t// Try another undefined variable as an extra check\n+\tos.Unsetenv(\"_Z\")\n+\tinLine = \"//go:generate -command CMD1 \\\"ab${_Z}cd\\\"\"\n+\texpected = []string{\"-command\", \"CMD1\", \"abcd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\tg.setShorthand(got)\n+\n+\tinLine = \"//go:generate CMD1\"\n+\texpected = []string{\"abcd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\tconst val = \"someNewValue\"\n+\tos.Setenv(\"_Z\", val)\n+\n+\t// try again with the properly-escaped variable.\n+\n+\tinLine = \"//go:generate -command CMD2 \\\"ab${DOLLAR}{_Z}cd\\\"\"\n+\texpected = []string{\"-command\", \"CMD2\", \"ab${_Z}cd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+\n+\tg.setShorthand(got)\n+\n+\tinLine = \"//go:generate CMD2\"\n+\texpected = []string{\"ab\" + val + \"cd\"}\n+\tgot = g.split(inLine + \"\\n\")\n+\n+\tif !reflect.DeepEqual(got, expected) {\n+\t\tt.Errorf(\"split(%q): got %q expected %q\", inLine, got, expected)\n+\t}\n+}\n+\n+// Command-related tests for TestGenerateCommandShortHand2\n+// -- Note line numbers included to check substitutions from \"build-in\" variable - $GOLINE\n+var splitTestsLines = []splitTestWithLine{\n+\t{\"-command TEST1 $GOLINE\", []string{\"-command\", \"TEST1\", \"22\"}, 22},\n+\t{\"-command TEST2 ${DOLLAR}GOLINE\", []string{\"-command\", \"TEST2\", \"$GOLINE\"}, 26},\n+\t{\"TEST1\", []string{\"22\"}, 33},\n+\t{\"TEST2\", []string{\"66\"}, 66},\n+\t{\"TEST1 ''\", []string{\"22\", \"''\"}, 99},\n+\t{\"TEST2 ''\", []string{\"44\", \"''\"}, 44},\n+}\n+\n+// TestGenerateCommandShortHand - similar to TestGenerateCommandParse,\n+// except:\n+//    1. if the result starts with -command, record that shorthand\n+//       before moving on to the next test.\n+//    2. If a source line number is specified, set that in the parser\n+//       before executing the test.  i.e., execute the split as if it\n+//       processing that source line.\n+func TestGenerateCommandShortHand2(t *testing.T) {\n+\tg := &Generator{\n+\t\tr:        nil, // Unused here.\n+\t\tpath:     \"/usr/ken/sys/proc.go\",\n+\t\tdir:      \"/usr/ken/sys\",\n+\t\tfile:     \"proc.go\",\n+\t\tpkg:      \"sys\",\n+\t\tcommands: make(map[string][]string),\n+\t}\n+\tg.setEnv()\n+\tfor _, test := range splitTestsLines {\n+\t\t// if the test specified a line number, reflect that\n+\t\tif test.lineNumber != anyLineNo {\n+\t\t\tg.lineNum = test.lineNumber\n+\t\t\tg.setEnv()\n+\t\t}\n+\t\t// First with newlines.\n+\t\tgot := g.split(\"//go:generate \" + test.in + \"\\n\")\n+\t\tif !reflect.DeepEqual(got, test.out) {\n+\t\t\tt.Errorf(\"split(%q): got %q expected %q\", test.in, got, test.out)\n+\t\t}\n+\t\t// Then with CRLFs, thank you Windows.\n+\t\tgot = g.split(\"//go:generate \" + test.in + \"\\r\\n\")\n+\t\tif !reflect.DeepEqual(got, test.out) {\n+\t\t\tt.Errorf(\"split(%q): got %q expected %q\", test.in, got, test.out)\n+\t\t}\n+\t\tif got[0] == \"-command\" { // record commands\n+\t\t\tg.setShorthand(got)\n+\t\t}\n+\t}\n+}"}, {"sha": "e4945fe14404b7c69c640d743659af07a9c7479d", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -118,11 +118,6 @@ func runGet(cmd *base.Command, args []string) {\n \t\t// Should not happen: main.go should install the separate module-enabled get code.\n \t\tbase.Fatalf(\"go get: modules not implemented\")\n \t}\n-\tif cfg.GoModInGOPATH != \"\" {\n-\t\t// Warn about not using modules with GO111MODULE=auto when go.mod exists.\n-\t\t// To silence the warning, users can set GO111MODULE=off.\n-\t\tfmt.Fprintf(os.Stderr, \"go get: warning: modules disabled by GO111MODULE=auto in GOPATH/src;\\n\\tignoring %s;\\n\\tsee 'go help modules'\\n\", base.ShortPath(cfg.GoModInGOPATH))\n-\t}\n \n \twork.BuildInit()\n \n@@ -177,12 +172,6 @@ func runGet(cmd *base.Command, args []string) {\n \t// everything.\n \tload.ClearPackageCache()\n \n-\t// In order to rebuild packages information completely,\n-\t// we need to clear commands cache. Command packages are\n-\t// referring to evicted packages from the package cache.\n-\t// This leads to duplicated loads of the standard packages.\n-\tload.ClearCmdCache()\n-\n \tpkgs := load.PackagesForBuild(args)\n \n \t// Phase 3. Install.\n@@ -240,7 +229,8 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t}\n \tload1 := func(path string, mode int) *load.Package {\n \t\tif parent == nil {\n-\t\t\treturn load.LoadPackageNoFlags(path, stk)\n+\t\t\tmode := 0 // don't do module or vendor resolution\n+\t\t\treturn load.LoadImport(path, base.Cwd, nil, stk, nil, mode)\n \t\t}\n \t\treturn load.LoadImport(path, parent.Dir, parent, stk, nil, mode|load.ResolveModule)\n \t}\n@@ -397,7 +387,7 @@ func downloadPackage(p *load.Package) error {\n \t\tblindRepo      bool // set if the repo has unusual configuration\n \t)\n \n-\tsecurity := web.Secure\n+\tsecurity := web.SecureOnly\n \tif Insecure {\n \t\tsecurity = web.Insecure\n \t}"}, {"sha": "67d7b8a47c2957e8745e38ed6e123f88a32e3584", "filename": "libgo/go/cmd/go/internal/get/path.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -41,6 +41,9 @@ func checkPath(path string, fileName bool) error {\n \tif path == \"\" {\n \t\treturn fmt.Errorf(\"empty string\")\n \t}\n+\tif path[0] == '-' {\n+\t\treturn fmt.Errorf(\"leading dash\")\n+\t}\n \tif strings.Contains(path, \"..\") {\n \t\treturn fmt.Errorf(\"double dot\")\n \t}"}, {"sha": "fca78b515fd8ecb829f00b1edd818ca5e5fca7a7", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 102, "deletions": 74, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,9 +8,10 @@ import (\n \t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"internal/lazyregexp\"\n \t\"internal/singleflight\"\n \t\"log\"\n-\t\"net/url\"\n+\turlpkg \"net/url\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -53,7 +54,7 @@ var defaultSecureScheme = map[string]bool{\n }\n \n func (v *vcsCmd) isSecure(repo string) bool {\n-\tu, err := url.Parse(repo)\n+\tu, err := urlpkg.Parse(repo)\n \tif err != nil {\n \t\t// If repo is not a URL, it's not secure.\n \t\treturn false\n@@ -111,7 +112,7 @@ var vcsHg = &vcsCmd{\n \tname: \"Mercurial\",\n \tcmd:  \"hg\",\n \n-\tcreateCmd:   []string{\"clone -U {repo} {dir}\"},\n+\tcreateCmd:   []string{\"clone -U -- {repo} {dir}\"},\n \tdownloadCmd: []string{\"pull\"},\n \n \t// We allow both tag and branch names as 'tags'\n@@ -127,7 +128,7 @@ var vcsHg = &vcsCmd{\n \ttagSyncDefault: []string{\"update default\"},\n \n \tscheme:     []string{\"https\", \"http\", \"ssh\"},\n-\tpingCmd:    \"identify {scheme}://{repo}\",\n+\tpingCmd:    \"identify -- {scheme}://{repo}\",\n \tremoteRepo: hgRemoteRepo,\n }\n \n@@ -144,7 +145,7 @@ var vcsGit = &vcsCmd{\n \tname: \"Git\",\n \tcmd:  \"git\",\n \n-\tcreateCmd:   []string{\"clone {repo} {dir}\", \"-go-internal-cd {dir} submodule update --init --recursive\"},\n+\tcreateCmd:   []string{\"clone -- {repo} {dir}\", \"-go-internal-cd {dir} submodule update --init --recursive\"},\n \tdownloadCmd: []string{\"pull --ff-only\", \"submodule update --init --recursive\"},\n \n \ttagCmd: []tagCmd{\n@@ -164,13 +165,13 @@ var vcsGit = &vcsCmd{\n \ttagSyncDefault: []string{\"submodule update --init --recursive\"},\n \n \tscheme:     []string{\"git\", \"https\", \"http\", \"git+ssh\", \"ssh\"},\n-\tpingCmd:    \"ls-remote {scheme}://{repo}\",\n+\tpingCmd:    \"ls-remote -- {scheme}://{repo}\",\n \tremoteRepo: gitRemoteRepo,\n }\n \n // scpSyntaxRe matches the SCP-like addresses used by Git to access\n // repositories by SSH.\n-var scpSyntaxRe = regexp.MustCompile(`^([a-zA-Z0-9_]+)@([a-zA-Z0-9._-]+):(.*)$`)\n+var scpSyntaxRe = lazyregexp.New(`^([a-zA-Z0-9_]+)@([a-zA-Z0-9._-]+):(.*)$`)\n \n func gitRemoteRepo(vcsGit *vcsCmd, rootDir string) (remoteRepo string, err error) {\n \tcmd := \"config remote.origin.url\"\n@@ -187,19 +188,19 @@ func gitRemoteRepo(vcsGit *vcsCmd, rootDir string) (remoteRepo string, err error\n \t}\n \tout := strings.TrimSpace(string(outb))\n \n-\tvar repoURL *url.URL\n+\tvar repoURL *urlpkg.URL\n \tif m := scpSyntaxRe.FindStringSubmatch(out); m != nil {\n \t\t// Match SCP-like syntax and convert it to a URL.\n \t\t// Eg, \"git@github.com:user/repo\" becomes\n \t\t// \"ssh://git@github.com/user/repo\".\n-\t\trepoURL = &url.URL{\n+\t\trepoURL = &urlpkg.URL{\n \t\t\tScheme: \"ssh\",\n-\t\t\tUser:   url.User(m[1]),\n+\t\t\tUser:   urlpkg.User(m[1]),\n \t\t\tHost:   m[2],\n \t\t\tPath:   m[3],\n \t\t}\n \t} else {\n-\t\trepoURL, err = url.Parse(out)\n+\t\trepoURL, err = urlpkg.Parse(out)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n@@ -221,7 +222,7 @@ var vcsBzr = &vcsCmd{\n \tname: \"Bazaar\",\n \tcmd:  \"bzr\",\n \n-\tcreateCmd: []string{\"branch {repo} {dir}\"},\n+\tcreateCmd: []string{\"branch -- {repo} {dir}\"},\n \n \t// Without --overwrite bzr will not pull tags that changed.\n \t// Replace by --overwrite-tags after http://pad.lv/681792 goes in.\n@@ -232,7 +233,7 @@ var vcsBzr = &vcsCmd{\n \ttagSyncDefault: []string{\"update -r revno:-1\"},\n \n \tscheme:      []string{\"https\", \"http\", \"bzr\", \"bzr+ssh\"},\n-\tpingCmd:     \"info {scheme}://{repo}\",\n+\tpingCmd:     \"info -- {scheme}://{repo}\",\n \tremoteRepo:  bzrRemoteRepo,\n \tresolveRepo: bzrResolveRepo,\n }\n@@ -283,14 +284,14 @@ var vcsSvn = &vcsCmd{\n \tname: \"Subversion\",\n \tcmd:  \"svn\",\n \n-\tcreateCmd:   []string{\"checkout {repo} {dir}\"},\n+\tcreateCmd:   []string{\"checkout -- {repo} {dir}\"},\n \tdownloadCmd: []string{\"update\"},\n \n \t// There is no tag command in subversion.\n \t// The branch information is all in the path names.\n \n \tscheme:     []string{\"https\", \"http\", \"svn\", \"svn+ssh\"},\n-\tpingCmd:    \"info {scheme}://{repo}\",\n+\tpingCmd:    \"info -- {scheme}://{repo}\",\n \tremoteRepo: svnRemoteRepo,\n }\n \n@@ -333,7 +334,7 @@ var vcsFossil = &vcsCmd{\n \tname: \"Fossil\",\n \tcmd:  \"fossil\",\n \n-\tcreateCmd:   []string{\"-go-internal-mkdir {dir} clone {repo} \" + filepath.Join(\"{dir}\", fossilRepoName), \"-go-internal-cd {dir} open .fossil\"},\n+\tcreateCmd:   []string{\"-go-internal-mkdir {dir} clone -- {repo} \" + filepath.Join(\"{dir}\", fossilRepoName), \"-go-internal-cd {dir} open .fossil\"},\n \tdownloadCmd: []string{\"up\"},\n \n \ttagCmd:         []tagCmd{{\"tag ls\", `(.*)`}},\n@@ -424,8 +425,8 @@ func (v *vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool)\n \tcmd.Dir = dir\n \tcmd.Env = base.EnvForDir(cmd.Dir, os.Environ())\n \tif cfg.BuildX {\n-\t\tfmt.Printf(\"cd %s\\n\", dir)\n-\t\tfmt.Printf(\"%s %s\\n\", v.cmd, strings.Join(args, \" \"))\n+\t\tfmt.Fprintf(os.Stderr, \"cd %s\\n\", dir)\n+\t\tfmt.Fprintf(os.Stderr, \"%s %s\\n\", v.cmd, strings.Join(args, \" \"))\n \t}\n \tout, err := cmd.Output()\n \tif err != nil {\n@@ -525,13 +526,11 @@ func (v *vcsCmd) tagSync(dir, tag string) error {\n // version control system and repository name.\n type vcsPath struct {\n \tprefix string                              // prefix this description applies to\n-\tre     string                              // pattern for import path\n+\tregexp *lazyregexp.Regexp                  // compiled pattern for import path\n \trepo   string                              // repository to use (expand with match of re)\n \tvcs    string                              // version control system to use (expand with match of re)\n \tcheck  func(match map[string]string) error // additional checks\n \tping   bool                                // ping for scheme to use to download repo\n-\n-\tregexp *regexp.Regexp // cached compiled form of re\n }\n \n // vcsFromDir inspects dir and its parents to determine the\n@@ -632,7 +631,14 @@ type RepoRoot struct {\n \tvcs *vcsCmd // internal: vcs command access\n }\n \n-var httpPrefixRE = regexp.MustCompile(`^https?:`)\n+func httpPrefix(s string) string {\n+\tfor _, prefix := range [...]string{\"http:\", \"https:\"} {\n+\t\tif strings.HasPrefix(s, prefix) {\n+\t\t\treturn prefix\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n \n // ModuleMode specifies whether to prefer modules when looking up code sources.\n type ModuleMode int\n@@ -677,10 +683,10 @@ var errUnknownSite = errors.New(\"dynamic lookup required to find mapping\")\n func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode, vcsPaths []*vcsPath) (*RepoRoot, error) {\n \t// A common error is to use https://packagepath because that's what\n \t// hg and git require. Diagnose this helpfully.\n-\tif loc := httpPrefixRE.FindStringIndex(importPath); loc != nil {\n+\tif prefix := httpPrefix(importPath); prefix != \"\" {\n \t\t// The importPath has been cleaned, so has only one slash. The pattern\n \t\t// ignores the slashes; the error message puts them back on the RHS at least.\n-\t\treturn nil, fmt.Errorf(\"%q not allowed in import path\", importPath[loc[0]:loc[1]]+\"//\")\n+\t\treturn nil, fmt.Errorf(\"%q not allowed in import path\", prefix+\"//\")\n \t}\n \tfor _, srv := range vcsPaths {\n \t\tif !strings.HasPrefix(importPath, srv.prefix) {\n@@ -724,7 +730,7 @@ func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode,\n \t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n \t\t\t} else {\n \t\t\t\tfor _, scheme := range vcs.scheme {\n-\t\t\t\t\tif security == web.Secure && !vcs.isSecureScheme(scheme) {\n+\t\t\t\t\tif security == web.SecureOnly && !vcs.isSecureScheme(scheme) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n \t\t\t\t\tif vcs.pingCmd != \"\" && vcs.ping(scheme, match[\"repo\"]) == nil {\n@@ -748,27 +754,43 @@ func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode,\n \treturn nil, errUnknownSite\n }\n \n-// repoRootForImportDynamic finds a *RepoRoot for a custom domain that's not\n-// statically known by repoRootForImportPathStatic.\n+// urlForImportPath returns a partially-populated URL for the given Go import path.\n //\n-// This handles custom import paths like \"name.tld/pkg/foo\" or just \"name.tld\".\n-func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error) {\n+// The URL leaves the Scheme field blank so that web.Get will try any scheme\n+// allowed by the selected security mode.\n+func urlForImportPath(importPath string) (*urlpkg.URL, error) {\n \tslash := strings.Index(importPath, \"/\")\n \tif slash < 0 {\n \t\tslash = len(importPath)\n \t}\n-\thost := importPath[:slash]\n+\thost, path := importPath[:slash], importPath[slash:]\n \tif !strings.Contains(host, \".\") {\n \t\treturn nil, errors.New(\"import path does not begin with hostname\")\n \t}\n-\turlStr, body, err := web.GetMaybeInsecure(importPath, security)\n+\tif len(path) == 0 {\n+\t\tpath = \"/\"\n+\t}\n+\treturn &urlpkg.URL{Host: host, Path: path, RawQuery: \"go-get=1\"}, nil\n+}\n+\n+// repoRootForImportDynamic finds a *RepoRoot for a custom domain that's not\n+// statically known by repoRootForImportPathStatic.\n+//\n+// This handles custom import paths like \"name.tld/pkg/foo\" or just \"name.tld\".\n+func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error) {\n+\turl, err := urlForImportPath(importPath)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tresp, err := web.Get(security, url)\n \tif err != nil {\n \t\tmsg := \"https fetch: %v\"\n \t\tif security == web.Insecure {\n \t\t\tmsg = \"http/\" + msg\n \t\t}\n \t\treturn nil, fmt.Errorf(msg, err)\n \t}\n+\tbody := resp.Body\n \tdefer body.Close()\n \timports, err := parseMetaGoImports(body, mod)\n \tif err != nil {\n@@ -778,12 +800,12 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n \tmmi, err := matchGoImport(imports, importPath)\n \tif err != nil {\n \t\tif _, ok := err.(ImportMismatchError); !ok {\n-\t\t\treturn nil, fmt.Errorf(\"parse %s: %v\", urlStr, err)\n+\t\t\treturn nil, fmt.Errorf(\"parse %s: %v\", url, err)\n \t\t}\n-\t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags (%s)\", urlStr, err)\n+\t\treturn nil, fmt.Errorf(\"parse %s: no go-import meta tags (%s)\", resp.URL, err)\n \t}\n \tif cfg.BuildV {\n-\t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, mmi, urlStr)\n+\t\tlog.Printf(\"get %q: found meta tag %#v at %s\", importPath, mmi, url)\n \t}\n \t// If the import was \"uni.edu/bob/project\", which said the\n \t// prefix was \"uni.edu\" and the RepoRoot was \"evilroot.com\",\n@@ -795,24 +817,23 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n \t\tif cfg.BuildV {\n \t\t\tlog.Printf(\"get %q: verifying non-authoritative meta tag\", importPath)\n \t\t}\n-\t\turlStr0 := urlStr\n \t\tvar imports []metaImport\n-\t\turlStr, imports, err = metaImportsForPrefix(mmi.Prefix, mod, security)\n+\t\turl, imports, err = metaImportsForPrefix(mmi.Prefix, mod, security)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n \t\tmetaImport2, err := matchGoImport(imports, importPath)\n \t\tif err != nil || mmi != metaImport2 {\n-\t\t\treturn nil, fmt.Errorf(\"%s and %s disagree about go-import for %s\", urlStr0, urlStr, mmi.Prefix)\n+\t\t\treturn nil, fmt.Errorf(\"%s and %s disagree about go-import for %s\", resp.URL, url, mmi.Prefix)\n \t\t}\n \t}\n \n \tif err := validateRepoRoot(mmi.RepoRoot); err != nil {\n-\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q: %v\", urlStr, mmi.RepoRoot, err)\n+\t\treturn nil, fmt.Errorf(\"%s: invalid repo root %q: %v\", resp.URL, mmi.RepoRoot, err)\n \t}\n \tvcs := vcsByCmd(mmi.VCS)\n \tif vcs == nil && mmi.VCS != \"mod\" {\n-\t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", urlStr, mmi.VCS)\n+\t\treturn nil, fmt.Errorf(\"%s: unknown vcs %q\", resp.URL, mmi.VCS)\n \t}\n \n \trr := &RepoRoot{\n@@ -828,13 +849,16 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n // validateRepoRoot returns an error if repoRoot does not seem to be\n // a valid URL with scheme.\n func validateRepoRoot(repoRoot string) error {\n-\turl, err := url.Parse(repoRoot)\n+\turl, err := urlpkg.Parse(repoRoot)\n \tif err != nil {\n \t\treturn err\n \t}\n \tif url.Scheme == \"\" {\n \t\treturn errors.New(\"no scheme\")\n \t}\n+\tif url.Scheme == \"file\" {\n+\t\treturn errors.New(\"file scheme disallowed\")\n+\t}\n \treturn nil\n }\n \n@@ -850,9 +874,9 @@ var (\n //\n // The importPath is of the form \"golang.org/x/tools\".\n // It is an error if no imports are found.\n-// urlStr will still be valid if err != nil.\n-// The returned urlStr will be of the form \"https://golang.org/x/tools?go-get=1\"\n-func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.SecurityMode) (urlStr string, imports []metaImport, err error) {\n+// url will still be valid if err != nil.\n+// The returned url will be of the form \"https://golang.org/x/tools?go-get=1\"\n+func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.SecurityMode) (*urlpkg.URL, []metaImport, error) {\n \tsetCache := func(res fetchResult) (fetchResult, error) {\n \t\tfetchCacheMu.Lock()\n \t\tdefer fetchCacheMu.Unlock()\n@@ -868,25 +892,31 @@ func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.Secu\n \t\t}\n \t\tfetchCacheMu.Unlock()\n \n-\t\turlStr, body, err := web.GetMaybeInsecure(importPrefix, security)\n+\t\turl, err := urlForImportPath(importPrefix)\n+\t\tif err != nil {\n+\t\t\treturn setCache(fetchResult{err: err})\n+\t\t}\n+\t\tresp, err := web.Get(security, url)\n \t\tif err != nil {\n-\t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"fetch %s: %v\", urlStr, err)})\n+\t\t\treturn setCache(fetchResult{url: url, err: fmt.Errorf(\"fetch %s: %v\", resp.URL, err)})\n \t\t}\n+\t\tbody := resp.Body\n+\t\tdefer body.Close()\n \t\timports, err := parseMetaGoImports(body, mod)\n \t\tif err != nil {\n-\t\t\treturn setCache(fetchResult{urlStr: urlStr, err: fmt.Errorf(\"parsing %s: %v\", urlStr, err)})\n+\t\t\treturn setCache(fetchResult{url: url, err: fmt.Errorf(\"parsing %s: %v\", resp.URL, err)})\n \t\t}\n \t\tif len(imports) == 0 {\n-\t\t\terr = fmt.Errorf(\"fetch %s: no go-import meta tag\", urlStr)\n+\t\t\terr = fmt.Errorf(\"fetch %s: no go-import meta tag\", url)\n \t\t}\n-\t\treturn setCache(fetchResult{urlStr: urlStr, imports: imports, err: err})\n+\t\treturn setCache(fetchResult{url: url, imports: imports, err: err})\n \t})\n \tres := resi.(fetchResult)\n-\treturn res.urlStr, res.imports, res.err\n+\treturn res.url, res.imports, res.err\n }\n \n type fetchResult struct {\n-\turlStr  string // e.g. \"https://foo.com/x/bar?go-get=1\"\n+\turl     *urlpkg.URL\n \timports []metaImport\n \terr     error\n }\n@@ -975,7 +1005,7 @@ var vcsPaths = []*vcsPath{\n \t// Github\n \t{\n \t\tprefix: \"github.com/\",\n-\t\tre:     `^(?P<root>github\\.com/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(/[\\p{L}0-9_.\\-]+)*$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>github\\.com/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(/[\\p{L}0-9_.\\-]+)*$`),\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t\tcheck:  noVCSSuffix,\n@@ -984,15 +1014,15 @@ var vcsPaths = []*vcsPath{\n \t// Bitbucket\n \t{\n \t\tprefix: \"bitbucket.org/\",\n-\t\tre:     `^(?P<root>bitbucket\\.org/(?P<bitname>[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>bitbucket\\.org/(?P<bitname>[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`),\n \t\trepo:   \"https://{root}\",\n \t\tcheck:  bitbucketVCS,\n \t},\n \n \t// IBM DevOps Services (JazzHub)\n \t{\n \t\tprefix: \"hub.jazz.net/git/\",\n-\t\tre:     `^(?P<root>hub\\.jazz\\.net/git/[a-z0-9]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>hub\\.jazz\\.net/git/[a-z0-9]+/[A-Za-z0-9_.\\-]+)(/[A-Za-z0-9_.\\-]+)*$`),\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t\tcheck:  noVCSSuffix,\n@@ -1001,32 +1031,32 @@ var vcsPaths = []*vcsPath{\n \t// Git at Apache\n \t{\n \t\tprefix: \"git.apache.org/\",\n-\t\tre:     `^(?P<root>git\\.apache\\.org/[a-z0-9_.\\-]+\\.git)(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>git\\.apache\\.org/[a-z0-9_.\\-]+\\.git)(/[A-Za-z0-9_.\\-]+)*$`),\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t},\n \n \t// Git at OpenStack\n \t{\n \t\tprefix: \"git.openstack.org/\",\n-\t\tre:     `^(?P<root>git\\.openstack\\.org/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(\\.git)?(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>git\\.openstack\\.org/[A-Za-z0-9_.\\-]+/[A-Za-z0-9_.\\-]+)(\\.git)?(/[A-Za-z0-9_.\\-]+)*$`),\n \t\tvcs:    \"git\",\n \t\trepo:   \"https://{root}\",\n \t},\n \n \t// chiselapp.com for fossil\n \t{\n \t\tprefix: \"chiselapp.com/\",\n-\t\tre:     `^(?P<root>chiselapp\\.com/user/[A-Za-z0-9]+/repository/[A-Za-z0-9_.\\-]+)$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>chiselapp\\.com/user/[A-Za-z0-9]+/repository/[A-Za-z0-9_.\\-]+)$`),\n \t\tvcs:    \"fossil\",\n \t\trepo:   \"https://{root}\",\n \t},\n \n \t// General syntax for any server.\n \t// Must be last.\n \t{\n-\t\tre:   `^(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\\-]+)+?)\\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\\-]+)*$`,\n-\t\tping: true,\n+\t\tregexp: lazyregexp.New(`(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\\-]+)+?)\\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\\-]+)*$`),\n+\t\tping:   true,\n \t},\n }\n \n@@ -1038,25 +1068,13 @@ var vcsPathsAfterDynamic = []*vcsPath{\n \t// Launchpad. See golang.org/issue/11436.\n \t{\n \t\tprefix: \"launchpad.net/\",\n-\t\tre:     `^(?P<root>launchpad\\.net/((?P<project>[A-Za-z0-9_.\\-]+)(?P<series>/[A-Za-z0-9_.\\-]+)?|~[A-Za-z0-9_.\\-]+/(\\+junk|[A-Za-z0-9_.\\-]+)/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`,\n+\t\tregexp: lazyregexp.New(`^(?P<root>launchpad\\.net/((?P<project>[A-Za-z0-9_.\\-]+)(?P<series>/[A-Za-z0-9_.\\-]+)?|~[A-Za-z0-9_.\\-]+/(\\+junk|[A-Za-z0-9_.\\-]+)/[A-Za-z0-9_.\\-]+))(/[A-Za-z0-9_.\\-]+)*$`),\n \t\tvcs:    \"bzr\",\n \t\trepo:   \"https://{root}\",\n \t\tcheck:  launchpadVCS,\n \t},\n }\n \n-func init() {\n-\t// fill in cached regexps.\n-\t// Doing this eagerly discovers invalid regexp syntax\n-\t// without having to run a command that needs that regexp.\n-\tfor _, srv := range vcsPaths {\n-\t\tsrv.regexp = regexp.MustCompile(srv.re)\n-\t}\n-\tfor _, srv := range vcsPathsAfterDynamic {\n-\t\tsrv.regexp = regexp.MustCompile(srv.re)\n-\t}\n-}\n-\n // noVCSSuffix checks that the repository name does not\n // end in .foo for any version control system foo.\n // The usual culprit is \".git\".\n@@ -1080,8 +1098,13 @@ func bitbucketVCS(match map[string]string) error {\n \tvar resp struct {\n \t\tSCM string `json:\"scm\"`\n \t}\n-\turl := expand(match, \"https://api.bitbucket.org/2.0/repositories/{bitname}?fields=scm\")\n-\tdata, err := web.Get(url)\n+\turl := &urlpkg.URL{\n+\t\tScheme:   \"https\",\n+\t\tHost:     \"api.bitbucket.org\",\n+\t\tPath:     expand(match, \"/2.0/repositories/{bitname}\"),\n+\t\tRawQuery: \"fields=scm\",\n+\t}\n+\tdata, err := web.GetBytes(url)\n \tif err != nil {\n \t\tif httpErr, ok := err.(*web.HTTPError); ok && httpErr.StatusCode == 403 {\n \t\t\t// this may be a private repository. If so, attempt to determine which\n@@ -1123,7 +1146,12 @@ func launchpadVCS(match map[string]string) error {\n \tif match[\"project\"] == \"\" || match[\"series\"] == \"\" {\n \t\treturn nil\n \t}\n-\t_, err := web.Get(expand(match, \"https://code.launchpad.net/{project}{series}/.bzr/branch-format\"))\n+\turl := &urlpkg.URL{\n+\t\tScheme: \"https\",\n+\t\tHost:   \"code.launchpad.net\",\n+\t\tPath:   expand(match, \"/{project}{series}/.bzr/branch-format\"),\n+\t}\n+\t_, err := web.GetBytes(url)\n \tif err != nil {\n \t\tmatch[\"root\"] = expand(match, \"launchpad.net/{project}\")\n \t\tmatch[\"repo\"] = expand(match, \"https://{root}\")"}, {"sha": "91800baa83d216ce8ef82bc0228615aaa62b104b", "filename": "libgo/go/cmd/go/internal/get/vcs_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -181,7 +181,7 @@ func TestRepoRootForImportPath(t *testing.T) {\n \t}\n \n \tfor _, test := range tests {\n-\t\tgot, err := RepoRootForImportPath(test.path, IgnoreMod, web.Secure)\n+\t\tgot, err := RepoRootForImportPath(test.path, IgnoreMod, web.SecureOnly)\n \t\twant := test.want\n \n \t\tif want == nil {"}, {"sha": "d373771ab5a74789e3691dc36fd6f38f02aefac1", "filename": "libgo/go/cmd/go/internal/help/help.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelp.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"unicode/utf8\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n )\n \n // Help implements the 'help' command.\n@@ -35,8 +36,10 @@ func Help(w io.Writer, args []string) {\n \t\tusage := &base.Command{Long: buf.String()}\n \t\tcmds := []*base.Command{usage}\n \t\tfor _, cmd := range base.Go.Commands {\n-\t\t\tif cmd.UsageLine == \"gopath-get\" {\n-\t\t\t\t// Avoid duplication of the \"get\" documentation.\n+\t\t\t// Avoid duplication of the \"get\" documentation.\n+\t\t\tif cmd.UsageLine == \"module-get\" && modload.Enabled() {\n+\t\t\t\tcontinue\n+\t\t\t} else if cmd.UsageLine == \"gopath-get\" && !modload.Enabled() {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tcmds = append(cmds, cmd)"}, {"sha": "c2b5fb4b83071048221136d6cf3d581b37e8c288", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -469,10 +469,17 @@ var HelpEnvironment = &base.Command{\n \tShort:     \"environment variables\",\n \tLong: `\n \n-The go command, and the tools it invokes, examine a few different\n-environment variables. For many of these, you can see the default\n-value of on your system by running 'go env NAME', where NAME is the\n-name of the variable.\n+The go command and the tools it invokes consult environment variables\n+for configuration. If an environment variable is unset, the go command\n+uses a sensible default setting. To see the effective setting of the\n+variable <NAME>, run 'go env <NAME>'. To change the default setting,\n+run 'go env -w <NAME>=<VALUE>'. Defaults changed using 'go env -w'\n+are recorded in a Go environment configuration file stored in the\n+per-user configuration directory, as reported by os.UserConfigDir.\n+The location of the configuration file can be changed by setting\n+the environment variable GOENV, and 'go env GOENV' prints the\n+effective location, but 'go env -w' cannot change the default location.\n+See 'go help env' for details.\n \n General-purpose environment variables:\n \n@@ -486,33 +493,43 @@ General-purpose environment variables:\n \tGOCACHE\n \t\tThe directory where the go command will store cached\n \t\tinformation for reuse in future builds.\n+\tGOENV\n+\t\tThe location of the Go environment configuration file.\n+\t\tCannot be set using 'go env -w'.\n \tGOFLAGS\n \t\tA space-separated list of -flag=value settings to apply\n \t\tto go commands by default, when the given flag is known by\n-\t\tthe current command. Flags listed on the command-line\n+\t\tthe current command. Each entry must be a standalone flag.\n+\t\tBecause the entries are space-separated, flag values must\n+\t\tnot contain spaces. Flags listed on the command line\n \t\tare applied after this list and therefore override it.\n \tGOOS\n \t\tThe operating system for which to compile code.\n \t\tExamples are linux, darwin, windows, netbsd.\n \tGOPATH\n \t\tFor more details see: 'go help gopath'.\n \tGOPROXY\n-\t\tURL of Go module proxy. See 'go help goproxy'.\n-\tGORACE\n-\t\tOptions for the race detector.\n-\t\tSee https://golang.org/doc/articles/race_detector.html.\n+\t\tURL of Go module proxy. See 'go help modules'.\n+\tGOPRIVATE, GONOPROXY, GONOSUMDB\n+\t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n+\t\tof module path prefixes that should always be fetched directly\n+\t\tor that should not be compared against the checksum database.\n+\t\tSee 'go help module-private'.\n \tGOROOT\n \t\tThe root of the go tree.\n+\tGOSUMDB\n+\t\tThe name of checksum database to use and optionally its public key and\n+\t\tURL. See 'go help module-auth'.\n \tGOTMPDIR\n \t\tThe directory where the go command will write\n \t\ttemporary source files, packages, and binaries.\n \n-Each entry in the GOFLAGS list must be a standalone flag.\n-Because the entries are space-separated, flag values must\n-not contain spaces.\n-\n Environment variables for use with cgo:\n \n+\tAR\n+\t\tThe command to use to manipulate library archives when\n+\t\tbuilding with the gccgo compiler.\n+\t\tThe default is 'ar'.\n \tCC\n \t\tThe command to use to compile C code.\n \tCGO_ENABLED\n@@ -542,12 +559,10 @@ Environment variables for use with cgo:\n \t\tbut for the linker.\n \tCXX\n \t\tThe command to use to compile C++ code.\n+\tFC\n+\t\tThe command to use to compile Fortran code.\n \tPKG_CONFIG\n \t\tPath to pkg-config tool.\n-\tAR\n-\t\tThe command to use to manipulate library archives when\n-\t\tbuilding with the gccgo compiler.\n-\t\tThe default is 'ar'.\n \n Architecture-specific environment variables:\n \n@@ -563,6 +578,9 @@ Architecture-specific environment variables:\n \tGOMIPS64\n \t\tFor GOARCH=mips64{,le}, whether to use floating point instructions.\n \t\tValid values are hardfloat (default), softfloat.\n+\tGOWASM\n+\t\tFor GOARCH=wasm, comma-separated list of experimental WebAssembly features to use.\n+\t\tValid values are satconv, signext.\n \n Special-purpose environment variables:\n \n@@ -579,14 +597,18 @@ Special-purpose environment variables:\n \t\twhen using -linkmode=auto with code that uses cgo.\n \t\tSet to 0 to disable external linking mode, 1 to enable it.\n \tGIT_ALLOW_PROTOCOL\n-\t\tDefined by Git. A colon-separated list of schemes that are allowed to be used\n-\t\twith git fetch/clone. If set, any scheme not explicitly mentioned will be\n-\t\tconsidered insecure by 'go get'.\n+\t\tDefined by Git. A colon-separated list of schemes that are allowed\n+\t\tto be used with git fetch/clone. If set, any scheme not explicitly\n+\t\tmentioned will be considered insecure by 'go get'.\n+\t\tBecause the variable is defined by Git, the default value cannot\n+\t\tbe set using 'go env -w'.\n \n Additional information available from 'go env' but not read from the environment:\n \n \tGOEXE\n \t\tThe executable file name suffix (\".exe\" on Windows, \"\" on other systems).\n+\tGOGCCFLAGS\n+\t\tA space-separated list of arguments supplied to the CC command.\n \tGOHOSTARCH\n \t\tThe architecture (GOARCH) of the Go toolchain binaries.\n \tGOHOSTOS\n@@ -635,15 +657,6 @@ constraints, but the go command stops scanning for build constraints\n at the first item in the file that is not a blank line or //-style\n line comment. See the go/build package documentation for\n more details.\n-\n-Through the Go 1.12 release, non-test Go source files can also include\n-a //go:binary-only-package comment, indicating that the package\n-sources are included for documentation only and must not be used to\n-build the package binary. This enables distribution of Go packages in\n-their compiled form alone. Even binary-only packages require accurate\n-import blocks listing required dependencies, so that those\n-dependencies can be supplied when linking the resulting command.\n-Note that this feature is scheduled to be removed after the Go 1.12 release.\n \t`,\n }\n \n@@ -693,6 +706,9 @@ are:\n \t-buildmode=plugin\n \t\tBuild the listed main packages, plus all packages that they\n \t\timport, into a Go plugin. Packages not named main are ignored.\n+\n+On AIX, when linking a C program that uses a Go archive built with\n+-buildmode=c-archive, you must pass -Wl,-bnoobjreorder to the C compiler.\n `,\n }\n "}, {"sha": "3e9fe357e0792b7dc03ded1a6d93265d80b4c5cb", "filename": "libgo/go/cmd/go/internal/imports/build.go", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -138,6 +138,9 @@ func matchTag(name string, tags map[string]bool, want bool) bool {\n \tif name == \"linux\" {\n \t\thave = have || tags[\"android\"]\n \t}\n+\tif name == \"solaris\" {\n+\t\thave = have || tags[\"illumos\"]\n+\t}\n \treturn have == want\n }\n \n@@ -152,7 +155,9 @@ func matchTag(name string, tags map[string]bool, want bool) bool {\n //     name_$(GOARCH)_test.*\n //     name_$(GOOS)_$(GOARCH)_test.*\n //\n-// An exception: if GOOS=android, then files with GOOS=linux are also matched.\n+// Exceptions:\n+//     if GOOS=android, then files with GOOS=linux are also matched.\n+//     if GOOS=illumos, then files with GOOS=solaris are also matched.\n //\n // If tags[\"*\"] is true, then MatchFile will consider all possible\n // GOOS and GOARCH to be available and will consequently\n@@ -184,28 +189,58 @@ func MatchFile(name string, tags map[string]bool) bool {\n \t}\n \tn := len(l)\n \tif n >= 2 && KnownOS[l[n-2]] && KnownArch[l[n-1]] {\n-\t\treturn tags[l[n-2]] && tags[l[n-1]]\n+\t\treturn matchTag(l[n-2], tags, true) && matchTag(l[n-1], tags, true)\n \t}\n \tif n >= 1 && KnownOS[l[n-1]] {\n-\t\treturn tags[l[n-1]]\n+\t\treturn matchTag(l[n-1], tags, true)\n \t}\n \tif n >= 1 && KnownArch[l[n-1]] {\n-\t\treturn tags[l[n-1]]\n+\t\treturn matchTag(l[n-1], tags, true)\n \t}\n \treturn true\n }\n \n-var KnownOS = make(map[string]bool)\n-var KnownArch = make(map[string]bool)\n-\n-func init() {\n-\tfor _, v := range strings.Fields(goosList) {\n-\t\tKnownOS[v] = true\n-\t}\n-\tfor _, v := range strings.Fields(goarchList) {\n-\t\tKnownArch[v] = true\n-\t}\n+var KnownOS = map[string]bool{\n+\t\"aix\":       true,\n+\t\"android\":   true,\n+\t\"darwin\":    true,\n+\t\"dragonfly\": true,\n+\t\"freebsd\":   true,\n+\t\"hurd\":      true,\n+\t\"illumos\":   true,\n+\t\"js\":        true,\n+\t\"linux\":     true,\n+\t\"nacl\":      true,\n+\t\"netbsd\":    true,\n+\t\"openbsd\":   true,\n+\t\"plan9\":     true,\n+\t\"solaris\":   true,\n+\t\"windows\":   true,\n+\t\"zos\":       true,\n }\n \n-const goosList = \"aix android darwin dragonfly freebsd hurd js linux nacl netbsd openbsd plan9 solaris windows zos \"\n-const goarchList = \"386 amd64 amd64p32 arm armbe arm64 arm64be ppc64 ppc64le mips mipsle mips64 mips64le mips64p32 mips64p32le ppc riscv riscv64 s390 s390x sparc sparc64 wasm \"\n+var KnownArch = map[string]bool{\n+\t\"386\":         true,\n+\t\"amd64\":       true,\n+\t\"amd64p32\":    true,\n+\t\"arm\":         true,\n+\t\"armbe\":       true,\n+\t\"arm64\":       true,\n+\t\"arm64be\":     true,\n+\t\"ppc64\":       true,\n+\t\"ppc64le\":     true,\n+\t\"mips\":        true,\n+\t\"mipsle\":      true,\n+\t\"mips64\":      true,\n+\t\"mips64le\":    true,\n+\t\"mips64p32\":   true,\n+\t\"mips64p32le\": true,\n+\t\"ppc\":         true,\n+\t\"riscv\":       true,\n+\t\"riscv64\":     true,\n+\t\"s390\":        true,\n+\t\"s390x\":       true,\n+\t\"sparc\":       true,\n+\t\"sparc64\":     true,\n+\t\"wasm\":        true,\n+}"}, {"sha": "3d9b6132b121b3d8cbab28f8c46547c1692d600e", "filename": "libgo/go/cmd/go/internal/imports/scan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -26,7 +26,7 @@ func ScanDir(dir string, tags map[string]bool) ([]string, []string, error) {\n \t\t// If the directory entry is a symlink, stat it to obtain the info for the\n \t\t// link target instead of the link itself.\n \t\tif info.Mode()&os.ModeSymlink != 0 {\n-\t\t\tinfo, err = os.Stat(name)\n+\t\t\tinfo, err = os.Stat(filepath.Join(dir, name))\n \t\t\tif err != nil {\n \t\t\t\tcontinue // Ignore broken symlinks.\n \t\t\t}"}, {"sha": "e424656cae2ebd4a0262b7c75166bd95cfcb0221", "filename": "libgo/go/cmd/go/internal/imports/scan_test.go", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fscan_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,10 +5,13 @@\n package imports\n \n import (\n+\t\"bytes\"\n \t\"internal/testenv\"\n+\t\"io/ioutil\"\n+\t\"path\"\n \t\"path/filepath\"\n-\t\"reflect\"\n \t\"runtime\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n@@ -51,17 +54,41 @@ func TestScan(t *testing.T) {\n \t\tt.Errorf(\"json missing test import net/http (%q)\", testImports)\n \t}\n }\n-\n-func TestScanStar(t *testing.T) {\n+func TestScanDir(t *testing.T) {\n \ttestenv.MustHaveGoBuild(t)\n \n-\timports, _, err := ScanDir(\"testdata/import1\", map[string]bool{\"*\": true})\n+\tdirs, err := ioutil.ReadDir(\"testdata\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\tfor _, dir := range dirs {\n+\t\tif !dir.IsDir() || strings.HasPrefix(dir.Name(), \".\") {\n+\t\t\tcontinue\n+\t\t}\n+\t\tt.Run(dir.Name(), func(t *testing.T) {\n+\t\t\ttagsData, err := ioutil.ReadFile(filepath.Join(\"testdata\", dir.Name(), \"tags.txt\"))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error reading tags: %v\", err)\n+\t\t\t}\n+\t\t\ttags := make(map[string]bool)\n+\t\t\tfor _, t := range strings.Fields(string(tagsData)) {\n+\t\t\t\ttags[t] = true\n+\t\t\t}\n+\n+\t\t\twantData, err := ioutil.ReadFile(filepath.Join(\"testdata\", dir.Name(), \"want.txt\"))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error reading want: %v\", err)\n+\t\t\t}\n+\t\t\twant := string(bytes.TrimSpace(wantData))\n \n-\twant := []string{\"import1\", \"import2\", \"import3\", \"import4\"}\n-\tif !reflect.DeepEqual(imports, want) {\n-\t\tt.Errorf(\"ScanDir testdata/import1:\\nhave %v\\nwant %v\", imports, want)\n+\t\t\timports, _, err := ScanDir(path.Join(\"testdata\", dir.Name()), tags)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tgot := strings.Join(imports, \"\\n\")\n+\t\t\tif got != want {\n+\t\t\t\tt.Errorf(\"ScanDir: got imports:\\n%s\\n\\nwant:\\n%s\", got, want)\n+\t\t\t}\n+\t\t})\n \t}\n }"}, {"sha": "14b4e21a0244feb6c598c18ddb8f0c7de78125b9", "filename": "libgo/go/cmd/go/internal/imports/tags.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftags.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,6 +8,9 @@ import \"cmd/go/internal/cfg\"\n \n var tags map[string]bool\n \n+// Tags returns a set of build tags that are true for the target platform.\n+// It includes GOOS, GOARCH, the compiler, possibly \"cgo\",\n+// release tags like \"go1.13\", and user-specified build tags.\n func Tags() map[string]bool {\n \tif tags == nil {\n \t\ttags = loadTags()\n@@ -32,3 +35,15 @@ func loadTags() map[string]bool {\n \t}\n \treturn tags\n }\n+\n+var anyTags map[string]bool\n+\n+// AnyTags returns a special set of build tags that satisfy nearly all\n+// build tag expressions. Only \"ignore\" and malformed build tag requirements\n+// are considered false.\n+func AnyTags() map[string]bool {\n+\tif anyTags == nil {\n+\t\tanyTags = map[string]bool{\"*\": true}\n+\t}\n+\treturn anyTags\n+}"}, {"sha": "2ed972eca57cbd68bf94e254c891b9927c2225c6", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/a_android.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fa_android.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fa_android.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fa_android.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package android\n+\n+import _ \"a\""}, {"sha": "ee9c312b5d7497ae2df10291317b8a8b1be36fcb", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/b_android_arm64.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fb_android_arm64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fb_android_arm64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fb_android_arm64.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package android\n+\n+import _ \"b\""}, {"sha": "91624ce637ffc0d6bdebb995893e941bc2c7c354", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/c_linux.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fc_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fc_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fc_linux.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package android\n+\n+import _ \"c\""}, {"sha": "34e07df2477b727d3175fcca9773cc945439b525", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/d_linux_arm64.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fd_linux_arm64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fd_linux_arm64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fd_linux_arm64.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package android\n+\n+import _ \"d\""}, {"sha": "d9b2db769b5f0c7c529cfeb9e437689dab8821f7", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/e.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fe.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,5 @@\n+// +build android\n+\n+package android\n+\n+import _ \"e\""}, {"sha": "281e4dd6b9898ed971ba7b8d19d20d2004c92ae2", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/f.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Ff.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,5 @@\n+// +build linux\n+\n+package android\n+\n+import _ \"f\""}, {"sha": "66a789c0ada4b58abccdfac60c056417847cb058", "filename": "libgo/go/cmd/go/internal/imports/testdata/android/g.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fandroid%2Fg.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,5 @@\n+// +build !android\n+\n+package android\n+\n+import _ \"g\""}, {"sha": "2e6cb50805a491c88a0e26c83da6921e42f10651", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/a_illumos.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fa_illumos.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fa_illumos.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fa_illumos.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package illumos\n+\n+import _ \"a\""}, {"sha": "2834d80660c9db23846a518227cbb20ab1724315", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/b_illumos_amd64.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fb_illumos_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fb_illumos_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fb_illumos_amd64.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package illumos\n+\n+import _ \"b\""}, {"sha": "d7f9462f159cb35754fe68c40ed1461a08ccf064", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/c_solaris.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fc_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fc_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fc_solaris.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package illumos\n+\n+import _ \"c\""}, {"sha": "0f52c2bb484fdfa7ed0672008dd5dbc4a5a597e7", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/d_solaris_amd64.go", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fd_solaris_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fd_solaris_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fd_solaris_amd64.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,3 @@\n+package illumos\n+\n+import _ \"d\""}, {"sha": "5e1ed3cb9decae06303aa7ecbdc8f8410baa2bff", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/e.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fe.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,5 @@\n+// +build illumos\n+\n+package illumos\n+\n+import _ \"e\""}, {"sha": "f3e3f728bce5d837453f3f88ed6c2de34c6c49d7", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/f.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ff.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ff.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Ff.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,5 @@\n+// +build solaris\n+\n+package illumos\n+\n+import _ \"f\""}, {"sha": "b30f1eb4037322ce7501948f9f8deceddeb605cf", "filename": "libgo/go/cmd/go/internal/imports/testdata/illumos/g.go", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fillumos%2Fg.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,5 @@\n+// +build !illumos\n+\n+package illumos\n+\n+import _ \"g\""}, {"sha": "98f9191053bc3d970c7ef2c6f881e48e4f858ebc", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/x.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "previous_filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x.go"}, {"sha": "6a9594aed035e6570d51457d8428cd0fc0a0f73f", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/x1.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx1.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "previous_filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x1.go"}, {"sha": "a0c3fdd21b5f5cc2ce45bb9dc0272e7123f61b18", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/x_darwin.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx_darwin.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "previous_filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x_darwin.go"}, {"sha": "63c508248fbff9ce6e7ca9defb380209943cbaf7", "filename": "libgo/go/cmd/go/internal/imports/testdata/star/x_windows.go", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Ftestdata%2Fstar%2Fx_windows.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "previous_filename": "libgo/go/cmd/go/internal/imports/testdata/import1/x_windows.go"}, {"sha": "e7e78e7c597a097e48f21b16d9f4a925345b1590", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -60,7 +60,7 @@ to -f '{{.ImportPath}}'. The struct being passed to the template is:\n         StaleReason   string   // explanation for Stale==true\n         Root          string   // Go root or Go path dir containing this package\n         ConflictDir   string   // this directory shadows Dir in $GOPATH\n-        BinaryOnly    bool     // binary-only package: cannot be recompiled from sources\n+        BinaryOnly    bool     // binary-only package (no longer supported)\n         ForTest       string   // package is only for use in named test\n         Export        string   // file containing export data (when using -export)\n         Module        *Module  // info about package's containing module, if any (can be nil)\n@@ -202,17 +202,18 @@ When listing modules, the -f flag still specifies a format template\n applied to a Go struct, but now a Module struct:\n \n     type Module struct {\n-        Path     string       // module path\n-        Version  string       // module version\n-        Versions []string     // available module versions (with -versions)\n-        Replace  *Module      // replaced by this module\n-        Time     *time.Time   // time version was created\n-        Update   *Module      // available update, if any (with -u)\n-        Main     bool         // is this the main module?\n-        Indirect bool         // is this module only an indirect dependency of main module?\n-        Dir      string       // directory holding files for this module, if any\n-        GoMod    string       // path to go.mod file for this module, if any\n-        Error    *ModuleError // error loading module\n+        Path      string       // module path\n+        Version   string       // module version\n+        Versions  []string     // available module versions (with -versions)\n+        Replace   *Module      // replaced by this module\n+        Time      *time.Time   // time version was created\n+        Update    *Module      // available update, if any (with -u)\n+        Main      bool         // is this the main module?\n+        Indirect  bool         // is this module only an indirect dependency of main module?\n+        Dir       string       // directory holding files for this module, if any\n+        GoMod     string       // path to go.mod file for this module, if any\n+        GoVersion string       // go version used in module\n+        Error     *ModuleError // error loading module\n     }\n \n     type ModuleError struct {\n@@ -446,37 +447,34 @@ func runList(cmd *base.Command, args []string) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tif len(p.TestGoFiles)+len(p.XTestGoFiles) > 0 {\n-\t\t\t\tpmain, ptest, pxtest, err := load.GetTestPackagesFor(p, nil)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tif *listE {\n-\t\t\t\t\t\tpkgs = append(pkgs, &load.Package{\n-\t\t\t\t\t\t\tPackagePublic: load.PackagePublic{\n-\t\t\t\t\t\t\t\tImportPath: p.ImportPath + \".test\",\n-\t\t\t\t\t\t\t\tError:      &load.PackageError{Err: err.Error()},\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t})\n-\t\t\t\t\t\tcontinue\n+\t\t\t\tvar pmain, ptest, pxtest *load.Package\n+\t\t\t\tvar err error\n+\t\t\t\tif *listE {\n+\t\t\t\t\tpmain, ptest, pxtest = load.TestPackagesAndErrors(p, nil)\n+\t\t\t\t} else {\n+\t\t\t\t\tpmain, ptest, pxtest, err = load.TestPackagesFor(p, nil)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tbase.Errorf(\"can't load test package: %s\", err)\n \t\t\t\t\t}\n-\t\t\t\t\tbase.Errorf(\"can't load test package: %s\", err)\n-\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tpkgs = append(pkgs, pmain)\n-\t\t\t\tif ptest != nil {\n+\t\t\t\tif pmain != nil {\n+\t\t\t\t\tpkgs = append(pkgs, pmain)\n+\t\t\t\t\tdata := pmain.Internal.TestmainGo\n+\t\t\t\t\th := cache.NewHash(\"testmain\")\n+\t\t\t\t\th.Write([]byte(\"testmain\\n\"))\n+\t\t\t\t\th.Write(data)\n+\t\t\t\t\tout, _, err := c.Put(h.Sum(), bytes.NewReader(data))\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tbase.Fatalf(\"%s\", err)\n+\t\t\t\t\t}\n+\t\t\t\t\tpmain.GoFiles[0] = c.OutputFile(out)\n+\t\t\t\t}\n+\t\t\t\tif ptest != nil && ptest != p {\n \t\t\t\t\tpkgs = append(pkgs, ptest)\n \t\t\t\t}\n \t\t\t\tif pxtest != nil {\n \t\t\t\t\tpkgs = append(pkgs, pxtest)\n \t\t\t\t}\n-\n-\t\t\t\tdata := *pmain.Internal.TestmainGo\n-\t\t\t\th := cache.NewHash(\"testmain\")\n-\t\t\t\th.Write([]byte(\"testmain\\n\"))\n-\t\t\t\th.Write(data)\n-\t\t\t\tout, _, err := c.Put(h.Sum(), bytes.NewReader(data))\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tbase.Fatalf(\"%s\", err)\n-\t\t\t\t}\n-\t\t\t\tpmain.GoFiles[0] = c.OutputFile(out)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "584cdff89163253c02dbc76ee34b72587e0f798f", "filename": "libgo/go/cmd/go/internal/load/path.go", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpath.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,32 +6,8 @@ package load\n \n import (\n \t\"path/filepath\"\n-\t\"strings\"\n )\n \n-// hasSubdir reports whether dir is a subdirectory of\n-// (possibly multiple levels below) root.\n-// If so, it sets rel to the path fragment that must be\n-// appended to root to reach dir.\n-func hasSubdir(root, dir string) (rel string, ok bool) {\n-\tif p, err := filepath.EvalSymlinks(root); err == nil {\n-\t\troot = p\n-\t}\n-\tif p, err := filepath.EvalSymlinks(dir); err == nil {\n-\t\tdir = p\n-\t}\n-\tconst sep = string(filepath.Separator)\n-\troot = filepath.Clean(root)\n-\tif !strings.HasSuffix(root, sep) {\n-\t\troot += sep\n-\t}\n-\tdir = filepath.Clean(dir)\n-\tif !strings.HasPrefix(dir, root) {\n-\t\treturn \"\", false\n-\t}\n-\treturn filepath.ToSlash(dir[len(root):]), true\n-}\n-\n // expandPath returns the symlink-expanded form of path.\n func expandPath(p string) string {\n \tx, err := filepath.EvalSymlinks(p)"}, {"sha": "958356070c514331c43ea99e75429056326fe698", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 473, "deletions": 357, "changes": 830, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -7,13 +7,15 @@ package load\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"go/token\"\n \t\"io/ioutil\"\n \t\"os\"\n \tpathpkg \"path\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n@@ -23,6 +25,7 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modinfo\"\n+\t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/str\"\n )\n@@ -32,14 +35,14 @@ var (\n \tModInit func()\n \n \t// module hooks; nil if module use is disabled\n-\tModBinDir            func() string                                       // return effective bin directory\n-\tModLookup            func(path string) (dir, realPath string, err error) // lookup effective meaning of import\n-\tModPackageModuleInfo func(path string) *modinfo.ModulePublic             // return module info for Package struct\n-\tModImportPaths       func(args []string) []*search.Match                 // expand import paths\n-\tModPackageBuildInfo  func(main string, deps []string) string             // return module info to embed in binary\n-\tModInfoProg          func(info string) []byte                            // wrap module info in .go code for binary\n-\tModImportFromFiles   func([]string)                                      // update go.mod to add modules for imports in these files\n-\tModDirImportPath     func(string) string                                 // return effective import path for directory\n+\tModBinDir            func() string                                                                            // return effective bin directory\n+\tModLookup            func(parentPath string, parentIsStd bool, path string) (dir, realPath string, err error) // lookup effective meaning of import\n+\tModPackageModuleInfo func(path string) *modinfo.ModulePublic                                                  // return module info for Package struct\n+\tModImportPaths       func(args []string) []*search.Match                                                      // expand import paths\n+\tModPackageBuildInfo  func(main string, deps []string) string                                                  // return module info to embed in binary\n+\tModInfoProg          func(info string) []byte                                                                 // wrap module info in .go code for binary\n+\tModImportFromFiles   func([]string)                                                                           // update go.mod to add modules for imports in these files\n+\tModDirImportPath     func(string) string                                                                      // return effective import path for directory\n )\n \n var IgnoreImports bool // control whether we ignore imports in packages\n@@ -174,7 +177,8 @@ type PackageInternal struct {\n \tOmitDebug         bool                 // tell linker not to write debug information\n \tGobinSubdir       bool                 // install target would be subdir of GOBIN\n \tBuildInfo         string               // add this info to package main\n-\tTestmainGo        *[]byte              // content for _testmain.go\n+\tTestinginitGo     []byte               // content for _testinginit.go\n+\tTestmainGo        []byte               // content for _testmain.go\n \n \tAsmflags   []string // -asmflags for this package\n \tGcflags    []string // -gcflags for this package\n@@ -356,38 +360,56 @@ func (sp *ImportStack) shorterThan(t []string) bool {\n \treturn false // they are equal\n }\n \n-// packageCache is a lookup cache for loadPackage,\n+// packageCache is a lookup cache for LoadImport,\n // so that if we look up a package multiple times\n // we return the same pointer each time.\n var packageCache = map[string]*Package{}\n \n+// ClearPackageCache clears the in-memory package cache and the preload caches.\n+// It is only for use by GOPATH-based \"go get\".\n+// TODO(jayconrod): When GOPATH-based \"go get\" is removed, delete this function.\n func ClearPackageCache() {\n \tfor name := range packageCache {\n \t\tdelete(packageCache, name)\n \t}\n+\tresolvedImportCache.Clear()\n+\tpackageDataCache.Clear()\n }\n \n+// ClearPackageCachePartial clears packages with the given import paths from the\n+// in-memory package cache and the preload caches. It is only for use by\n+// GOPATH-based \"go get\".\n+// TODO(jayconrod): When GOPATH-based \"go get\" is removed, delete this function.\n func ClearPackageCachePartial(args []string) {\n+\tshouldDelete := make(map[string]bool)\n \tfor _, arg := range args {\n-\t\tp := packageCache[arg]\n-\t\tif p != nil {\n-\t\t\tdelete(packageCache, p.Dir)\n-\t\t\tdelete(packageCache, p.ImportPath)\n+\t\tshouldDelete[arg] = true\n+\t\tif p := packageCache[arg]; p != nil {\n+\t\t\tdelete(packageCache, arg)\n \t\t}\n \t}\n+\tresolvedImportCache.DeleteIf(func(key interface{}) bool {\n+\t\treturn shouldDelete[key.(importSpec).path]\n+\t})\n+\tpackageDataCache.DeleteIf(func(key interface{}) bool {\n+\t\treturn shouldDelete[key.(string)]\n+\t})\n }\n \n-// ReloadPackageNoFlags is like LoadPackageNoFlags but makes sure\n+// ReloadPackageNoFlags is like LoadImport but makes sure\n // not to use the package cache.\n // It is only for use by GOPATH-based \"go get\".\n // TODO(rsc): When GOPATH-based \"go get\" is removed, delete this function.\n func ReloadPackageNoFlags(arg string, stk *ImportStack) *Package {\n \tp := packageCache[arg]\n \tif p != nil {\n-\t\tdelete(packageCache, p.Dir)\n-\t\tdelete(packageCache, p.ImportPath)\n+\t\tdelete(packageCache, arg)\n+\t\tresolvedImportCache.DeleteIf(func(key interface{}) bool {\n+\t\t\treturn key.(importSpec).path == p.ImportPath\n+\t\t})\n+\t\tpackageDataCache.Delete(p.ImportPath)\n \t}\n-\treturn LoadPackageNoFlags(arg, stk)\n+\treturn LoadImport(arg, base.Cwd, nil, stk, nil, 0)\n }\n \n // dirToImportPath returns the pseudo-import path we use for a package\n@@ -440,132 +462,62 @@ const (\n // this package, as part of a bigger load operation, and by GOPATH-based \"go get\".\n // TODO(rsc): When GOPATH-based \"go get\" is removed, unexport this function.\n func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+\treturn loadImport(nil, path, srcDir, parent, stk, importPos, mode)\n+}\n+\n+func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n \tif path == \"\" {\n \t\tpanic(\"LoadImport called with empty package path\")\n \t}\n \n \tstk.Push(path)\n \tdefer stk.Pop()\n \n-\tif strings.HasPrefix(path, \"mod/\") {\n-\t\t// Paths beginning with \"mod/\" might accidentally\n-\t\t// look in the module cache directory tree in $GOPATH/pkg/mod/.\n-\t\t// This prefix is owned by the Go core for possible use in the\n-\t\t// standard library (since it does not begin with a domain name),\n-\t\t// so it's OK to disallow entirely.\n-\t\treturn &Package{\n-\t\t\tPackagePublic: PackagePublic{\n-\t\t\t\tImportPath: path,\n-\t\t\t\tError: &PackageError{\n-\t\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\t\tErr:         fmt.Sprintf(\"disallowed import path %q\", path),\n-\t\t\t\t},\n-\t\t\t},\n-\t\t}\n+\tvar parentPath, parentRoot string\n+\tparentIsStd := false\n+\tif parent != nil {\n+\t\tparentPath = parent.ImportPath\n+\t\tparentRoot = parent.Root\n+\t\tparentIsStd = parent.Standard\n \t}\n-\n-\tif strings.Contains(path, \"@\") {\n-\t\tvar text string\n-\t\tif cfg.ModulesEnabled {\n-\t\t\ttext = \"can only use path@version syntax with 'go get'\"\n-\t\t} else {\n-\t\t\ttext = \"cannot use path@version syntax in GOPATH mode\"\n-\t\t}\n+\tbp, loaded, err := loadPackageData(path, parentPath, srcDir, parentRoot, parentIsStd, mode)\n+\tif loaded && pre != nil && !IgnoreImports {\n+\t\tpre.preloadImports(bp.Imports, bp)\n+\t}\n+\tif bp == nil {\n \t\treturn &Package{\n \t\t\tPackagePublic: PackagePublic{\n \t\t\t\tImportPath: path,\n \t\t\t\tError: &PackageError{\n \t\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\t\tErr:         text,\n+\t\t\t\t\tErr:         err.Error(),\n \t\t\t\t},\n \t\t\t},\n \t\t}\n \t}\n \n-\tparentPath := \"\"\n-\tif parent != nil {\n-\t\tparentPath = parent.ImportPath\n-\t}\n-\n-\t// Determine canonical identifier for this package.\n-\t// For a local import the identifier is the pseudo-import path\n-\t// we create from the full directory to the package.\n-\t// Otherwise it is the usual import path.\n-\t// For vendored imports, it is the expanded form.\n-\timportPath := path\n-\torigPath := path\n-\tisLocal := build.IsLocalImport(path)\n-\tvar modDir string\n-\tvar modErr error\n-\tif isLocal {\n-\t\timportPath = dirToImportPath(filepath.Join(srcDir, path))\n-\t} else if cfg.ModulesEnabled {\n-\t\tvar p string\n-\t\tmodDir, p, modErr = ModLookup(path)\n-\t\tif modErr == nil {\n-\t\t\timportPath = p\n-\t\t}\n-\t} else if mode&ResolveImport != 0 {\n-\t\t// We do our own path resolution, because we want to\n-\t\t// find out the key to use in packageCache without the\n-\t\t// overhead of repeated calls to buildContext.Import.\n-\t\t// The code is also needed in a few other places anyway.\n-\t\tpath = ResolveImportPath(parent, path)\n-\t\timportPath = path\n-\t} else if mode&ResolveModule != 0 {\n-\t\tpath = ModuleImportPath(parent, path)\n-\t\timportPath = path\n-\t}\n-\n+\timportPath := bp.ImportPath\n \tp := packageCache[importPath]\n \tif p != nil {\n \t\tp = reusePackage(p, stk)\n \t} else {\n \t\tp = new(Package)\n-\t\tp.Internal.Local = isLocal\n+\t\tp.Internal.Local = build.IsLocalImport(path)\n \t\tp.ImportPath = importPath\n \t\tpackageCache[importPath] = p\n \n \t\t// Load package.\n-\t\t// Import always returns bp != nil, even if an error occurs,\n+\t\t// loadPackageData may return bp != nil even if an error occurs,\n \t\t// in order to return partial information.\n-\t\tvar bp *build.Package\n-\t\tvar err error\n-\t\tif modDir != \"\" {\n-\t\t\tbp, err = cfg.BuildContext.ImportDir(modDir, 0)\n-\t\t} else if modErr != nil {\n-\t\t\tbp = new(build.Package)\n-\t\t\terr = fmt.Errorf(\"unknown import path %q: %v\", importPath, modErr)\n-\t\t} else if cfg.ModulesEnabled && path != \"unsafe\" {\n-\t\t\tbp = new(build.Package)\n-\t\t\terr = fmt.Errorf(\"unknown import path %q: internal error: module loader did not resolve import\", importPath)\n-\t\t} else {\n-\t\t\tbuildMode := build.ImportComment\n-\t\t\tif mode&ResolveImport == 0 || path != origPath {\n-\t\t\t\t// Not vendoring, or we already found the vendored path.\n-\t\t\t\tbuildMode |= build.IgnoreVendor\n-\t\t\t}\n-\t\t\tbp, err = cfg.BuildContext.Import(path, srcDir, buildMode)\n-\t\t}\n-\t\tbp.ImportPath = importPath\n-\t\tif cfg.GOBIN != \"\" {\n-\t\t\tbp.BinDir = cfg.GOBIN\n-\t\t} else if cfg.ModulesEnabled {\n-\t\t\tbp.BinDir = ModBinDir()\n-\t\t}\n-\t\tif modDir == \"\" && err == nil && !isLocal && bp.ImportComment != \"\" && bp.ImportComment != path &&\n-\t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n-\t\t\terr = fmt.Errorf(\"code in directory %s expects import %q\", bp.Dir, bp.ImportComment)\n-\t\t}\n \t\tp.load(stk, bp, err)\n \t\tif p.Error != nil && p.Error.Pos == \"\" {\n \t\t\tp = setErrorPos(p, importPos)\n \t\t}\n \n-\t\tif modDir == \"\" && origPath != cleanImport(origPath) {\n+\t\tif !cfg.ModulesEnabled && path != cleanImport(path) {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", origPath, pathpkg.Clean(origPath)),\n+\t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", path, pathpkg.Clean(path)),\n \t\t\t}\n \t\t\tp.Incomplete = true\n \t\t}\n@@ -576,7 +528,7 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \t\treturn setErrorPos(perr, importPos)\n \t}\n \tif mode&ResolveImport != 0 {\n-\t\tif perr := disallowVendor(srcDir, parent, parentPath, origPath, p, stk); perr != p {\n+\t\tif perr := disallowVendor(srcDir, parent, parentPath, path, p, stk); perr != p {\n \t\t\treturn setErrorPos(perr, importPos)\n \t\t}\n \t}\n@@ -592,9 +544,13 @@ func LoadImport(path, srcDir string, parent *Package, stk *ImportStack, importPo\n \n \tif p.Internal.Local && parent != nil && !parent.Internal.Local {\n \t\tperr := *p\n+\t\terrMsg := fmt.Sprintf(\"local import %q in non-local package\", path)\n+\t\tif path == \".\" {\n+\t\t\terrMsg = \"cannot import current directory\"\n+\t\t}\n \t\tperr.Error = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"local import %q in non-local package\", path),\n+\t\t\tErr:         errMsg,\n \t\t}\n \t\treturn setErrorPos(&perr, importPos)\n \t}\n@@ -611,6 +567,250 @@ func setErrorPos(p *Package, importPos []token.Position) *Package {\n \treturn p\n }\n \n+// loadPackageData loads information needed to construct a *Package. The result\n+// is cached, and later calls to loadPackageData for the same package will return\n+// the same data.\n+//\n+// loadPackageData returns a non-nil package even if err is non-nil unless\n+// the package path is malformed (for example, the path contains \"mod/\" or \"@\").\n+//\n+// loadPackageData returns a boolean, loaded, which is true if this is the\n+// first time the package was loaded. Callers may preload imports in this case.\n+func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd bool, mode int) (bp *build.Package, loaded bool, err error) {\n+\tif path == \"\" {\n+\t\tpanic(\"loadPackageData called with empty package path\")\n+\t}\n+\n+\tif strings.HasPrefix(path, \"mod/\") {\n+\t\t// Paths beginning with \"mod/\" might accidentally\n+\t\t// look in the module cache directory tree in $GOPATH/pkg/mod/.\n+\t\t// This prefix is owned by the Go core for possible use in the\n+\t\t// standard library (since it does not begin with a domain name),\n+\t\t// so it's OK to disallow entirely.\n+\t\treturn nil, false, fmt.Errorf(\"disallowed import path %q\", path)\n+\t}\n+\n+\tif strings.Contains(path, \"@\") {\n+\t\tif cfg.ModulesEnabled {\n+\t\t\treturn nil, false, errors.New(\"can only use path@version syntax with 'go get'\")\n+\t\t} else {\n+\t\t\treturn nil, false, errors.New(\"cannot use path@version syntax in GOPATH mode\")\n+\t\t}\n+\t}\n+\n+\t// Determine canonical package path and directory.\n+\t// For a local import the identifier is the pseudo-import path\n+\t// we create from the full directory to the package.\n+\t// Otherwise it is the usual import path.\n+\t// For vendored imports, it is the expanded form.\n+\timportKey := importSpec{\n+\t\tpath:        path,\n+\t\tparentPath:  parentPath,\n+\t\tparentDir:   parentDir,\n+\t\tparentRoot:  parentRoot,\n+\t\tparentIsStd: parentIsStd,\n+\t\tmode:        mode,\n+\t}\n+\tr := resolvedImportCache.Do(importKey, func() interface{} {\n+\t\tvar r resolvedImport\n+\t\tif build.IsLocalImport(path) {\n+\t\t\tr.dir = filepath.Join(parentDir, path)\n+\t\t\tr.path = dirToImportPath(r.dir)\n+\t\t} else if cfg.ModulesEnabled {\n+\t\t\tr.dir, r.path, r.err = ModLookup(parentPath, parentIsStd, path)\n+\t\t} else if mode&ResolveImport != 0 {\n+\t\t\t// We do our own path resolution, because we want to\n+\t\t\t// find out the key to use in packageCache without the\n+\t\t\t// overhead of repeated calls to buildContext.Import.\n+\t\t\t// The code is also needed in a few other places anyway.\n+\t\t\tr.path = resolveImportPath(path, parentPath, parentDir, parentRoot, parentIsStd)\n+\t\t} else if mode&ResolveModule != 0 {\n+\t\t\tr.path = moduleImportPath(path, parentPath, parentDir, parentRoot)\n+\t\t}\n+\t\tif r.path == \"\" {\n+\t\t\tr.path = path\n+\t\t}\n+\t\treturn r\n+\t}).(resolvedImport)\n+\t// Invariant: r.path is set to the resolved import path. If the path cannot\n+\t// be resolved, r.path is set to path, the source import path.\n+\t// r.path is never empty.\n+\n+\t// Load the package from its directory. If we already found the package's\n+\t// directory when resolving its import path, use that.\n+\tdata := packageDataCache.Do(r.path, func() interface{} {\n+\t\tloaded = true\n+\t\tvar data packageData\n+\t\tif r.dir != \"\" {\n+\t\t\tvar buildMode build.ImportMode\n+\t\t\tif !cfg.ModulesEnabled {\n+\t\t\t\tbuildMode = build.ImportComment\n+\t\t\t}\n+\t\t\tdata.p, data.err = cfg.BuildContext.ImportDir(r.dir, buildMode)\n+\t\t} else if r.err != nil {\n+\t\t\tdata.p = new(build.Package)\n+\t\t\tdata.err = fmt.Errorf(\"unknown import path %q: %v\", r.path, r.err)\n+\t\t} else if cfg.ModulesEnabled && path != \"unsafe\" {\n+\t\t\tdata.p = new(build.Package)\n+\t\t\tdata.err = fmt.Errorf(\"unknown import path %q: internal error: module loader did not resolve import\", r.path)\n+\t\t} else {\n+\t\t\tbuildMode := build.ImportComment\n+\t\t\tif mode&ResolveImport == 0 || r.path != path {\n+\t\t\t\t// Not vendoring, or we already found the vendored path.\n+\t\t\t\tbuildMode |= build.IgnoreVendor\n+\t\t\t}\n+\t\t\tdata.p, data.err = cfg.BuildContext.Import(r.path, parentDir, buildMode)\n+\t\t}\n+\t\tdata.p.ImportPath = r.path\n+\n+\t\t// Set data.p.BinDir in cases where go/build.Context.Import\n+\t\t// may give us a path we don't want.\n+\t\tif !data.p.Goroot {\n+\t\t\tif cfg.GOBIN != \"\" {\n+\t\t\t\tdata.p.BinDir = cfg.GOBIN\n+\t\t\t} else if cfg.ModulesEnabled {\n+\t\t\t\tdata.p.BinDir = ModBinDir()\n+\t\t\t}\n+\t\t}\n+\n+\t\tif !cfg.ModulesEnabled && data.err == nil &&\n+\t\t\tdata.p.ImportComment != \"\" && data.p.ImportComment != path &&\n+\t\t\t!strings.Contains(path, \"/vendor/\") && !strings.HasPrefix(path, \"vendor/\") {\n+\t\t\tdata.err = fmt.Errorf(\"code in directory %s expects import %q\", data.p.Dir, data.p.ImportComment)\n+\t\t}\n+\t\treturn data\n+\t}).(packageData)\n+\n+\treturn data.p, loaded, data.err\n+}\n+\n+// importSpec describes an import declaration in source code. It is used as a\n+// cache key for resolvedImportCache.\n+type importSpec struct {\n+\tpath                              string\n+\tparentPath, parentDir, parentRoot string\n+\tparentIsStd                       bool\n+\tmode                              int\n+}\n+\n+// resolvedImport holds a canonical identifier for a package. It may also contain\n+// a path to the package's directory and an error if one occurred. resolvedImport\n+// is the value type in resolvedImportCache.\n+type resolvedImport struct {\n+\tpath, dir string\n+\terr       error\n+}\n+\n+// packageData holds information loaded from a package. It is the value type\n+// in packageDataCache.\n+type packageData struct {\n+\tp   *build.Package\n+\terr error\n+}\n+\n+// resolvedImportCache maps import strings (importSpec) to canonical package names\n+// (resolvedImport).\n+var resolvedImportCache par.Cache\n+\n+// packageDataCache maps canonical package names (string) to package metadata\n+// (packageData).\n+var packageDataCache par.Cache\n+\n+// preloadWorkerCount is the number of concurrent goroutines that can load\n+// packages. Experimentally, there are diminishing returns with more than\n+// 4 workers. This was measured on the following machines.\n+//\n+// * MacBookPro with a 4-core Intel Core i7 CPU\n+// * Linux workstation with 6-core Intel Xeon CPU\n+// * Linux workstation with 24-core Intel Xeon CPU\n+//\n+// It is very likely (though not confirmed) that this workload is limited\n+// by memory bandwidth. We don't have a good way to determine the number of\n+// workers that would saturate the bus though, so runtime.GOMAXPROCS\n+// seems like a reasonable default.\n+var preloadWorkerCount = runtime.GOMAXPROCS(0)\n+\n+// preload holds state for managing concurrent preloading of package data.\n+//\n+// A preload should be created with newPreload before loading a large\n+// package graph. flush must be called when package loading is complete\n+// to ensure preload goroutines are no longer active. This is necessary\n+// because of global mutable state that cannot safely be read and written\n+// concurrently. In particular, packageDataCache may be cleared by \"go get\"\n+// in GOPATH mode, and modload.loaded (accessed via ModLookup) may be\n+// modified by modload.ImportPaths (ModImportPaths).\n+type preload struct {\n+\tcancel chan struct{}\n+\tsema   chan struct{}\n+}\n+\n+// newPreload creates a new preloader. flush must be called later to avoid\n+// accessing global state while it is being modified.\n+func newPreload() *preload {\n+\tpre := &preload{\n+\t\tcancel: make(chan struct{}),\n+\t\tsema:   make(chan struct{}, preloadWorkerCount),\n+\t}\n+\treturn pre\n+}\n+\n+// preloadMatches loads data for package paths matched by patterns.\n+// When preloadMatches returns, some packages may not be loaded yet, but\n+// loadPackageData and loadImport are always safe to call.\n+func (pre *preload) preloadMatches(matches []*search.Match) {\n+\tfor _, m := range matches {\n+\t\tfor _, pkg := range m.Pkgs {\n+\t\t\tselect {\n+\t\t\tcase <-pre.cancel:\n+\t\t\t\treturn\n+\t\t\tcase pre.sema <- struct{}{}:\n+\t\t\t\tgo func(pkg string) {\n+\t\t\t\t\tmode := 0 // don't use vendoring or module import resolution\n+\t\t\t\t\tbp, loaded, err := loadPackageData(pkg, \"\", base.Cwd, \"\", false, mode)\n+\t\t\t\t\t<-pre.sema\n+\t\t\t\t\tif bp != nil && loaded && err == nil && !IgnoreImports {\n+\t\t\t\t\t\tpre.preloadImports(bp.Imports, bp)\n+\t\t\t\t\t}\n+\t\t\t\t}(pkg)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// preloadImports queues a list of imports for preloading.\n+// When preloadImports returns, some packages may not be loaded yet,\n+// but loadPackageData and loadImport are always safe to call.\n+func (pre *preload) preloadImports(imports []string, parent *build.Package) {\n+\tparentIsStd := parent.Goroot && parent.ImportPath != \"\" && search.IsStandardImportPath(parent.ImportPath)\n+\tfor _, path := range imports {\n+\t\tif path == \"C\" || path == \"unsafe\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tselect {\n+\t\tcase <-pre.cancel:\n+\t\t\treturn\n+\t\tcase pre.sema <- struct{}{}:\n+\t\t\tgo func(path string) {\n+\t\t\t\tbp, loaded, err := loadPackageData(path, parent.ImportPath, parent.Dir, parent.Root, parentIsStd, ResolveImport)\n+\t\t\t\t<-pre.sema\n+\t\t\t\tif bp != nil && loaded && err == nil && !IgnoreImports {\n+\t\t\t\t\tpre.preloadImports(bp.Imports, bp)\n+\t\t\t\t}\n+\t\t\t}(path)\n+\t\t}\n+\t}\n+}\n+\n+// flush stops pending preload operations. flush blocks until preload calls to\n+// loadPackageData have completed. The preloader will not make any new calls\n+// to loadPackageData.\n+func (pre *preload) flush() {\n+\tclose(pre.cancel)\n+\tfor i := 0; i < preloadWorkerCount; i++ {\n+\t\tpre.sema <- struct{}{}\n+\t}\n+}\n+\n func cleanImport(path string) string {\n \torig := path\n \tpath = pathpkg.Clean(path)\n@@ -620,18 +820,13 @@ func cleanImport(path string) string {\n \treturn path\n }\n \n-var isDirCache = map[string]bool{}\n+var isDirCache par.Cache\n \n func isDir(path string) bool {\n-\tresult, ok := isDirCache[path]\n-\tif ok {\n-\t\treturn result\n-\t}\n-\n-\tfi, err := os.Stat(path)\n-\tresult = err == nil && fi.IsDir()\n-\tisDirCache[path] = result\n-\treturn result\n+\treturn isDirCache.Do(path, func() interface{} {\n+\t\tfi, err := os.Stat(path)\n+\t\treturn err == nil && fi.IsDir()\n+\t}).(bool)\n }\n \n // ResolveImportPath returns the true meaning of path when it appears in parent.\n@@ -640,59 +835,72 @@ func isDir(path string) bool {\n // If vendor expansion doesn't trigger, then the path is also subject to\n // Go 1.11 module legacy conversion (golang.org/issue/25069).\n func ResolveImportPath(parent *Package, path string) (found string) {\n+\tvar parentPath, parentDir, parentRoot string\n+\tparentIsStd := false\n+\tif parent != nil {\n+\t\tparentPath = parent.ImportPath\n+\t\tparentDir = parent.Dir\n+\t\tparentRoot = parent.Root\n+\t\tparentIsStd = parent.Standard\n+\t}\n+\treturn resolveImportPath(path, parentPath, parentDir, parentRoot, parentIsStd)\n+}\n+\n+func resolveImportPath(path, parentPath, parentDir, parentRoot string, parentIsStd bool) (found string) {\n \tif cfg.ModulesEnabled {\n-\t\tif _, p, e := ModLookup(path); e == nil {\n+\t\tif _, p, e := ModLookup(parentPath, parentIsStd, path); e == nil {\n \t\t\treturn p\n \t\t}\n \t\treturn path\n \t}\n-\tfound = VendoredImportPath(parent, path)\n+\tfound = vendoredImportPath(path, parentPath, parentDir, parentRoot)\n \tif found != path {\n \t\treturn found\n \t}\n-\treturn ModuleImportPath(parent, path)\n+\treturn moduleImportPath(path, parentPath, parentDir, parentRoot)\n }\n \n // dirAndRoot returns the source directory and workspace root\n // for the package p, guaranteeing that root is a path prefix of dir.\n-func dirAndRoot(p *Package) (dir, root string) {\n-\tdir = filepath.Clean(p.Dir)\n-\troot = filepath.Join(p.Root, \"src\")\n-\tif !str.HasFilePathPrefix(dir, root) || p.ImportPath != \"command-line-arguments\" && filepath.Join(root, p.ImportPath) != dir {\n+func dirAndRoot(path string, dir, root string) (string, string) {\n+\torigDir, origRoot := dir, root\n+\tdir = filepath.Clean(dir)\n+\troot = filepath.Join(root, \"src\")\n+\tif !str.HasFilePathPrefix(dir, root) || path != \"command-line-arguments\" && filepath.Join(root, path) != dir {\n \t\t// Look for symlinks before reporting error.\n \t\tdir = expandPath(dir)\n \t\troot = expandPath(root)\n \t}\n \n-\tif !str.HasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || p.ImportPath != \"command-line-arguments\" && !p.Internal.Local && filepath.Join(root, p.ImportPath) != dir {\n+\tif !str.HasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator || path != \"command-line-arguments\" && !build.IsLocalImport(path) && filepath.Join(root, path) != dir {\n \t\tbase.Fatalf(\"unexpected directory layout:\\n\"+\n \t\t\t\"\timport path: %s\\n\"+\n \t\t\t\"\troot: %s\\n\"+\n \t\t\t\"\tdir: %s\\n\"+\n \t\t\t\"\texpand root: %s\\n\"+\n \t\t\t\"\texpand dir: %s\\n\"+\n \t\t\t\"\tseparator: %s\",\n-\t\t\tp.ImportPath,\n-\t\t\tfilepath.Join(p.Root, \"src\"),\n-\t\t\tfilepath.Clean(p.Dir),\n-\t\t\troot,\n-\t\t\tdir,\n+\t\t\tpath,\n+\t\t\tfilepath.Join(origRoot, \"src\"),\n+\t\t\tfilepath.Clean(origDir),\n+\t\t\torigRoot,\n+\t\t\torigDir,\n \t\t\tstring(filepath.Separator))\n \t}\n \n \treturn dir, root\n }\n \n-// VendoredImportPath returns the vendor-expansion of path when it appears in parent.\n+// vendoredImportPath returns the vendor-expansion of path when it appears in parent.\n // If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,\n // x/vendor/path, vendor/path, or else stay path if none of those exist.\n-// VendoredImportPath returns the expanded path or, if no expansion is found, the original.\n-func VendoredImportPath(parent *Package, path string) (found string) {\n-\tif parent == nil || parent.Root == \"\" {\n+// vendoredImportPath returns the expanded path or, if no expansion is found, the original.\n+func vendoredImportPath(path, parentPath, parentDir, parentRoot string) (found string) {\n+\tif parentRoot == \"\" {\n \t\treturn path\n \t}\n \n-\tdir, root := dirAndRoot(parent)\n+\tdir, root := dirAndRoot(parentPath, parentDir, parentRoot)\n \n \tvpath := \"vendor/\" + path\n \tfor i := len(dir); i >= len(root); i-- {\n@@ -708,7 +916,7 @@ func VendoredImportPath(parent *Package, path string) (found string) {\n \t\t}\n \t\ttarg := filepath.Join(dir[:i], vpath)\n \t\tif isDir(targ) && hasGoFiles(targ) {\n-\t\t\timportPath := parent.ImportPath\n+\t\t\timportPath := parentPath\n \t\t\tif importPath == \"command-line-arguments\" {\n \t\t\t\t// If parent.ImportPath is 'command-line-arguments'.\n \t\t\t\t// set to relative directory to root (also chopped root directory)\n@@ -738,54 +946,48 @@ func VendoredImportPath(parent *Package, path string) (found string) {\n \n var (\n \tmodulePrefix   = []byte(\"\\nmodule \")\n-\tgoModPathCache = make(map[string]string)\n+\tgoModPathCache par.Cache\n )\n \n // goModPath returns the module path in the go.mod in dir, if any.\n func goModPath(dir string) (path string) {\n-\tpath, ok := goModPathCache[dir]\n-\tif ok {\n-\t\treturn path\n-\t}\n-\tdefer func() {\n-\t\tgoModPathCache[dir] = path\n-\t}()\n-\n-\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"go.mod\"))\n-\tif err != nil {\n-\t\treturn \"\"\n-\t}\n-\tvar i int\n-\tif bytes.HasPrefix(data, modulePrefix[1:]) {\n-\t\ti = 0\n-\t} else {\n-\t\ti = bytes.Index(data, modulePrefix)\n-\t\tif i < 0 {\n+\treturn goModPathCache.Do(dir, func() interface{} {\n+\t\tdata, err := ioutil.ReadFile(filepath.Join(dir, \"go.mod\"))\n+\t\tif err != nil {\n \t\t\treturn \"\"\n \t\t}\n-\t\ti++\n-\t}\n-\tline := data[i:]\n+\t\tvar i int\n+\t\tif bytes.HasPrefix(data, modulePrefix[1:]) {\n+\t\t\ti = 0\n+\t\t} else {\n+\t\t\ti = bytes.Index(data, modulePrefix)\n+\t\t\tif i < 0 {\n+\t\t\t\treturn \"\"\n+\t\t\t}\n+\t\t\ti++\n+\t\t}\n+\t\tline := data[i:]\n \n-\t// Cut line at \\n, drop trailing \\r if present.\n-\tif j := bytes.IndexByte(line, '\\n'); j >= 0 {\n-\t\tline = line[:j]\n-\t}\n-\tif line[len(line)-1] == '\\r' {\n-\t\tline = line[:len(line)-1]\n-\t}\n-\tline = line[len(\"module \"):]\n+\t\t// Cut line at \\n, drop trailing \\r if present.\n+\t\tif j := bytes.IndexByte(line, '\\n'); j >= 0 {\n+\t\t\tline = line[:j]\n+\t\t}\n+\t\tif line[len(line)-1] == '\\r' {\n+\t\t\tline = line[:len(line)-1]\n+\t\t}\n+\t\tline = line[len(\"module \"):]\n \n-\t// If quoted, unquote.\n-\tpath = strings.TrimSpace(string(line))\n-\tif path != \"\" && path[0] == '\"' {\n-\t\ts, err := strconv.Unquote(path)\n-\t\tif err != nil {\n-\t\t\treturn \"\"\n+\t\t// If quoted, unquote.\n+\t\tpath = strings.TrimSpace(string(line))\n+\t\tif path != \"\" && path[0] == '\"' {\n+\t\t\ts, err := strconv.Unquote(path)\n+\t\t\tif err != nil {\n+\t\t\t\treturn \"\"\n+\t\t\t}\n+\t\t\tpath = s\n \t\t}\n-\t\tpath = s\n-\t}\n-\treturn path\n+\t\treturn path\n+\t}).(string)\n }\n \n // findVersionElement returns the slice indices of the final version element /vN in path.\n@@ -794,7 +996,7 @@ func findVersionElement(path string) (i, j int) {\n \tj = len(path)\n \tfor i = len(path) - 1; i >= 0; i-- {\n \t\tif path[i] == '/' {\n-\t\t\tif isVersionElement(path[i:j]) {\n+\t\t\tif isVersionElement(path[i+1 : j]) {\n \t\t\t\treturn i, j\n \t\t\t}\n \t\t\tj = i\n@@ -806,27 +1008,27 @@ func findVersionElement(path string) (i, j int) {\n // isVersionElement reports whether s is a well-formed path version element:\n // v2, v3, v10, etc, but not v0, v05, v1.\n func isVersionElement(s string) bool {\n-\tif len(s) < 3 || s[0] != '/' || s[1] != 'v' || s[2] == '0' || s[2] == '1' && len(s) == 3 {\n+\tif len(s) < 2 || s[0] != 'v' || s[1] == '0' || s[1] == '1' && len(s) == 2 {\n \t\treturn false\n \t}\n-\tfor i := 2; i < len(s); i++ {\n+\tfor i := 1; i < len(s); i++ {\n \t\tif s[i] < '0' || '9' < s[i] {\n \t\t\treturn false\n \t\t}\n \t}\n \treturn true\n }\n \n-// ModuleImportPath translates import paths found in go modules\n+// moduleImportPath translates import paths found in go modules\n // back down to paths that can be resolved in ordinary builds.\n //\n // Define \u201cnew\u201d code as code with a go.mod file in the same directory\n // or a parent directory. If an import in new code says x/y/v2/z but\n // x/y/v2/z does not exist and x/y/go.mod says \u201cmodule x/y/v2\u201d,\n // then go build will read the import as x/y/z instead.\n // See golang.org/issue/25069.\n-func ModuleImportPath(parent *Package, path string) (found string) {\n-\tif parent == nil || parent.Root == \"\" {\n+func moduleImportPath(path, parentPath, parentDir, parentRoot string) (found string) {\n+\tif parentRoot == \"\" {\n \t\treturn path\n \t}\n \n@@ -838,7 +1040,7 @@ func ModuleImportPath(parent *Package, path string) (found string) {\n \t\treturn path\n \t}\n \n-\tdir, root := dirAndRoot(parent)\n+\tdir, root := dirAndRoot(parentPath, parentDir, parentRoot)\n \n \t// Consider dir and parents, up to and including root.\n \tfor i := len(dir); i >= len(root); i-- {\n@@ -967,6 +1169,13 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \t\t}\n \t}\n \n+\t// The sort package depends on internal/reflectlite, but during bootstrap\n+\t// the path rewriting causes the normal internal checks to fail.\n+\t// Instead, just ignore the internal rules during bootstrap.\n+\tif p.Standard && strings.HasPrefix(importerPath, \"bootstrap/\") {\n+\t\treturn p\n+\t}\n+\n \t// The stack includes p.ImportPath.\n \t// If that's the only thing on the stack, we started\n \t// with a name given on the command line, not an\n@@ -1188,26 +1397,16 @@ var foldPath = make(map[string]string)\n // for a package with the import path importPath.\n //\n // The default executable name is the last element of the import path.\n-// In module-aware mode, an additional rule is used. If the last element\n-// is a vN path element specifying the major version, then the second last\n-// element of the import path is used instead.\n+// In module-aware mode, an additional rule is used on import paths\n+// consisting of two or more path elements. If the last element is\n+// a vN path element specifying the major version, then the\n+// second last element of the import path is used instead.\n func DefaultExecName(importPath string) string {\n \t_, elem := pathpkg.Split(importPath)\n \tif cfg.ModulesEnabled {\n-\t\t// If this is example.com/mycmd/v2, it's more useful to install it as mycmd than as v2.\n-\t\t// See golang.org/issue/24667.\n-\t\tisVersion := func(v string) bool {\n-\t\t\tif len(v) < 2 || v[0] != 'v' || v[1] < '1' || '9' < v[1] {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\tfor i := 2; i < len(v); i++ {\n-\t\t\t\tif c := v[i]; c < '0' || '9' < c {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn true\n-\t\t}\n-\t\tif isVersion(elem) {\n+\t\t// If this is example.com/mycmd/v2, it's more useful to\n+\t\t// install it as mycmd than as v2. See golang.org/issue/24667.\n+\t\tif elem != importPath && isVersionElement(elem) {\n \t\t\t_, elem = pathpkg.Split(pathpkg.Dir(importPath))\n \t\t}\n \t}\n@@ -1254,21 +1453,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t\tp.Error = &PackageError{Err: e}\n \t\t\treturn\n \t\t}\n-\t\t_, elem := filepath.Split(p.Dir)\n-\t\tif cfg.ModulesEnabled {\n-\t\t\t// NOTE(rsc,dmitshur): Using p.ImportPath instead of p.Dir\n-\t\t\t// makes sure we install a package in the root of a\n-\t\t\t// cached module directory as that package name\n-\t\t\t// not name@v1.2.3.\n-\t\t\t// Using p.ImportPath instead of p.Dir\n-\t\t\t// is probably correct all the time,\n-\t\t\t// even for non-module-enabled code,\n-\t\t\t// but I'm not brave enough to change the\n-\t\t\t// non-module behavior this late in the\n-\t\t\t// release cycle. Can be done for Go 1.13.\n-\t\t\t// See golang.org/issue/26869.\n-\t\t\telem = DefaultExecName(p.ImportPath)\n-\t\t}\n+\t\telem := DefaultExecName(p.ImportPath)\n \t\tfull := cfg.BuildContext.GOOS + \"_\" + cfg.BuildContext.GOARCH + \"/\" + elem\n \t\tif cfg.BuildContext.GOOS != base.ToolGOOS || cfg.BuildContext.GOARCH != base.ToolGOARCH {\n \t\t\t// Install cross-compiled binaries to subdirectories of bin.\n@@ -1420,16 +1605,6 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t\tcontinue\n \t\t}\n \t\tp1 := LoadImport(path, p.Dir, p, stk, p.Internal.Build.ImportPos[path], ResolveImport)\n-\t\tif p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {\n-\t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"non-standard import %q in standard package %q\", path, p.ImportPath),\n-\t\t\t}\n-\t\t\tpos := p.Internal.Build.ImportPos[path]\n-\t\t\tif len(pos) > 0 {\n-\t\t\t\tp.Error.Pos = pos[0].String()\n-\t\t\t}\n-\t\t}\n \n \t\tpath = p1.ImportPath\n \t\timportPaths[i] = path\n@@ -1443,41 +1618,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t}\n \t}\n \tp.Internal.Imports = imports\n-\n-\tdeps := make(map[string]*Package)\n-\tvar q []*Package\n-\tq = append(q, imports...)\n-\tfor i := 0; i < len(q); i++ {\n-\t\tp1 := q[i]\n-\t\tpath := p1.ImportPath\n-\t\t// The same import path could produce an error or not,\n-\t\t// depending on what tries to import it.\n-\t\t// Prefer to record entries with errors, so we can report them.\n-\t\tp0 := deps[path]\n-\t\tif p0 == nil || p1.Error != nil && (p0.Error == nil || len(p0.Error.ImportStack) > len(p1.Error.ImportStack)) {\n-\t\t\tdeps[path] = p1\n-\t\t\tfor _, p2 := range p1.Internal.Imports {\n-\t\t\t\tif deps[p2.ImportPath] != p2 {\n-\t\t\t\t\tq = append(q, p2)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tp.Deps = make([]string, 0, len(deps))\n-\tfor dep := range deps {\n-\t\tp.Deps = append(p.Deps, dep)\n-\t}\n-\tsort.Strings(p.Deps)\n-\tfor _, dep := range p.Deps {\n-\t\tp1 := deps[dep]\n-\t\tif p1 == nil {\n-\t\t\tpanic(\"impossible: missing entry in package cache for \" + dep + \" imported by \" + p.ImportPath)\n-\t\t}\n-\t\tif p1.Error != nil {\n-\t\t\tp.DepsErrors = append(p.DepsErrors, p1.Error)\n-\t\t}\n-\t}\n+\tp.collectDeps()\n \n \t// unsafe is a fake package.\n \tif p.Standard && (p.ImportPath == \"unsafe\" || cfg.BuildContext.Compiler == \"gccgo\") {\n@@ -1547,6 +1688,48 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t}\n }\n \n+// collectDeps populates p.Deps and p.DepsErrors by iterating over\n+// p.Internal.Imports.\n+//\n+// TODO(jayconrod): collectDeps iterates over transitive imports for every\n+// package. We should only need to visit direct imports.\n+func (p *Package) collectDeps() {\n+\tdeps := make(map[string]*Package)\n+\tvar q []*Package\n+\tq = append(q, p.Internal.Imports...)\n+\tfor i := 0; i < len(q); i++ {\n+\t\tp1 := q[i]\n+\t\tpath := p1.ImportPath\n+\t\t// The same import path could produce an error or not,\n+\t\t// depending on what tries to import it.\n+\t\t// Prefer to record entries with errors, so we can report them.\n+\t\tp0 := deps[path]\n+\t\tif p0 == nil || p1.Error != nil && (p0.Error == nil || len(p0.Error.ImportStack) > len(p1.Error.ImportStack)) {\n+\t\t\tdeps[path] = p1\n+\t\t\tfor _, p2 := range p1.Internal.Imports {\n+\t\t\t\tif deps[p2.ImportPath] != p2 {\n+\t\t\t\t\tq = append(q, p2)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tp.Deps = make([]string, 0, len(deps))\n+\tfor dep := range deps {\n+\t\tp.Deps = append(p.Deps, dep)\n+\t}\n+\tsort.Strings(p.Deps)\n+\tfor _, dep := range p.Deps {\n+\t\tp1 := deps[dep]\n+\t\tif p1 == nil {\n+\t\t\tpanic(\"impossible: missing entry in package cache for \" + dep + \" imported by \" + p.ImportPath)\n+\t\t}\n+\t\tif p1.Error != nil {\n+\t\t\tp.DepsErrors = append(p.DepsErrors, p1.Error)\n+\t\t}\n+\t}\n+}\n+\n // SafeArg reports whether arg is a \"safe\" command-line argument,\n // meaning that when it appears in a command-line, it probably\n // doesn't have some special meaning other than its own name.\n@@ -1700,7 +1883,7 @@ func PackageList(roots []*Package) []*Package {\n // TestPackageList returns the list of packages in the dag rooted at roots\n // as visited in a depth-first post-order traversal, including the test\n // imports of the roots. This ignores errors in test packages.\n-func GetTestPackageList(roots []*Package) []*Package {\n+func TestPackageList(roots []*Package) []*Package {\n \tseen := map[*Package]bool{}\n \tall := []*Package{}\n \tvar walk func(*Package)\n@@ -1733,99 +1916,17 @@ func GetTestPackageList(roots []*Package) []*Package {\n \treturn all\n }\n \n-var cmdCache = map[string]*Package{}\n-\n-func ClearCmdCache() {\n-\tfor name := range cmdCache {\n-\t\tdelete(cmdCache, name)\n-\t}\n-}\n-\n-// LoadPackage loads the package named by arg.\n-func LoadPackage(arg string, stk *ImportStack) *Package {\n-\tp := loadPackage(arg, stk)\n+// LoadImportWithFlags loads the package with the given import path and\n+// sets tool flags on that package. This function is useful loading implicit\n+// dependencies (like sync/atomic for coverage).\n+// TODO(jayconrod): delete this function and set flags automatically\n+// in LoadImport instead.\n+func LoadImportWithFlags(path, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) *Package {\n+\tp := LoadImport(path, srcDir, parent, stk, importPos, mode)\n \tsetToolFlags(p)\n \treturn p\n }\n \n-// LoadPackageNoFlags is like LoadPackage\n-// but does not guarantee that the build tool flags are set in the result.\n-// It is only for use by GOPATH-based \"go get\"\n-// and is only appropriate for preliminary loading of packages.\n-// A real load using LoadPackage or (more likely)\n-// Packages, PackageAndErrors, or PackagesForBuild\n-// must be done before passing the package to any build\n-// steps, so that the tool flags can be set properly.\n-// TODO(rsc): When GOPATH-based \"go get\" is removed, delete this function.\n-func LoadPackageNoFlags(arg string, stk *ImportStack) *Package {\n-\treturn loadPackage(arg, stk)\n-}\n-\n-// loadPackage is like loadImport but is used for command-line arguments,\n-// not for paths found in import statements. In addition to ordinary import paths,\n-// loadPackage accepts pseudo-paths beginning with cmd/ to denote commands\n-// in the Go command directory, as well as paths to those directories.\n-func loadPackage(arg string, stk *ImportStack) *Package {\n-\tif arg == \"\" {\n-\t\tpanic(\"loadPackage called with empty package path\")\n-\t}\n-\tif build.IsLocalImport(arg) {\n-\t\tdir := arg\n-\t\tif !filepath.IsAbs(dir) {\n-\t\t\tif abs, err := filepath.Abs(dir); err == nil {\n-\t\t\t\t// interpret relative to current directory\n-\t\t\t\tdir = abs\n-\t\t\t}\n-\t\t}\n-\t\tif sub, ok := hasSubdir(cfg.GOROOTsrc, dir); ok && strings.HasPrefix(sub, \"cmd/\") && !strings.Contains(sub[4:], \"/\") {\n-\t\t\targ = sub\n-\t\t}\n-\t}\n-\tif strings.HasPrefix(arg, \"cmd/\") && !strings.Contains(arg[4:], \"/\") {\n-\t\tif p := cmdCache[arg]; p != nil {\n-\t\t\treturn p\n-\t\t}\n-\t\tstk.Push(arg)\n-\t\tdefer stk.Pop()\n-\n-\t\tbp, err := cfg.BuildContext.ImportDir(filepath.Join(cfg.GOROOTsrc, arg), 0)\n-\t\tbp.ImportPath = arg\n-\t\tbp.Goroot = true\n-\t\tbp.BinDir = cfg.GOROOTbin\n-\t\tbp.Root = cfg.GOROOT\n-\t\tbp.SrcRoot = cfg.GOROOTsrc\n-\t\tp := new(Package)\n-\t\tcmdCache[arg] = p\n-\t\tp.load(stk, bp, err)\n-\t\tif p.Error == nil && p.Name != \"main\" {\n-\t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"expected package main but found package %s in %s\", p.Name, p.Dir),\n-\t\t\t}\n-\t\t}\n-\t\treturn p\n-\t}\n-\n-\t// Wasn't a command; must be a package.\n-\t// If it is a local import path but names a standard package,\n-\t// we treat it as if the user specified the standard package.\n-\t// This lets you run go test ./ioutil in package io and be\n-\t// referring to io/ioutil rather than a hypothetical import of\n-\t// \"./ioutil\".\n-\tif build.IsLocalImport(arg) || filepath.IsAbs(arg) {\n-\t\tdir := arg\n-\t\tif !filepath.IsAbs(arg) {\n-\t\t\tdir = filepath.Join(base.Cwd, arg)\n-\t\t}\n-\t\tbp, _ := cfg.BuildContext.ImportDir(dir, build.FindOnly)\n-\t\tif bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n-\t\t\targ = bp.ImportPath\n-\t\t}\n-\t}\n-\n-\treturn LoadImport(arg, base.Cwd, nil, stk, nil, 0)\n-}\n-\n // Packages returns the packages named by the\n // command line arguments 'args'. If a named package\n // cannot be loaded at all (for example, if the directory does not exist),\n@@ -1851,8 +1952,12 @@ func Packages(args []string) []*Package {\n // cannot be loaded at all.\n // The packages that fail to load will have p.Error != nil.\n func PackagesAndErrors(patterns []string) []*Package {\n-\tif len(patterns) > 0 && strings.HasSuffix(patterns[0], \".go\") {\n-\t\treturn []*Package{GoFilesPackage(patterns)}\n+\tif len(patterns) > 0 {\n+\t\tfor _, p := range patterns {\n+\t\t\tif strings.HasSuffix(p, \".go\") {\n+\t\t\t\treturn []*Package{GoFilesPackage(patterns)}\n+\t\t\t}\n+\t\t}\n \t}\n \n \tmatches := ImportPaths(patterns)\n@@ -1862,12 +1967,16 @@ func PackagesAndErrors(patterns []string) []*Package {\n \t\tseenPkg = make(map[*Package]bool)\n \t)\n \n+\tpre := newPreload()\n+\tdefer pre.flush()\n+\tpre.preloadMatches(matches)\n+\n \tfor _, m := range matches {\n \t\tfor _, pkg := range m.Pkgs {\n \t\t\tif pkg == \"\" {\n \t\t\t\tpanic(fmt.Sprintf(\"ImportPaths returned empty package for pattern %s\", m.Pattern))\n \t\t\t}\n-\t\t\tp := loadPackage(pkg, &stk)\n+\t\t\tp := loadImport(pre, pkg, base.Cwd, nil, &stk, nil, 0)\n \t\t\tp.Match = append(p.Match, m.Pattern)\n \t\t\tp.Internal.CmdlinePkg = true\n \t\t\tif m.Literal {\n@@ -1960,7 +2069,14 @@ func GoFilesPackage(gofiles []string) *Package {\n \n \tfor _, f := range gofiles {\n \t\tif !strings.HasSuffix(f, \".go\") {\n-\t\t\tbase.Fatalf(\"named files must be .go files\")\n+\t\t\tpkg := new(Package)\n+\t\t\tpkg.Internal.Local = true\n+\t\t\tpkg.Internal.CmdlineFiles = true\n+\t\t\tpkg.Name = f\n+\t\t\tpkg.Error = &PackageError{\n+\t\t\t\tErr: fmt.Sprintf(\"named files must be .go files: %s\", pkg.Name),\n+\t\t\t}\n+\t\t\treturn pkg\n \t\t}\n \t}\n "}, {"sha": "9ddc20d0500ee37b8ea737a5300320a79c097fa6", "filename": "libgo/go/cmd/go/internal/load/pkg_test.go", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,68 @@\n+package load\n+\n+import (\n+\t\"cmd/go/internal/cfg\"\n+\t\"testing\"\n+)\n+\n+func TestDefaultExecName(t *testing.T) {\n+\toldModulesEnabled := cfg.ModulesEnabled\n+\tdefer func() { cfg.ModulesEnabled = oldModulesEnabled }()\n+\tfor _, tt := range []struct {\n+\t\tin         string\n+\t\twantMod    string\n+\t\twantGopath string\n+\t}{\n+\t\t{\"example.com/mycmd\", \"mycmd\", \"mycmd\"},\n+\t\t{\"example.com/mycmd/v0\", \"v0\", \"v0\"},\n+\t\t{\"example.com/mycmd/v1\", \"v1\", \"v1\"},\n+\t\t{\"example.com/mycmd/v2\", \"mycmd\", \"v2\"}, // Semantic import versioning, use second last element in module mode.\n+\t\t{\"example.com/mycmd/v3\", \"mycmd\", \"v3\"}, // Semantic import versioning, use second last element in module mode.\n+\t\t{\"mycmd\", \"mycmd\", \"mycmd\"},\n+\t\t{\"mycmd/v0\", \"v0\", \"v0\"},\n+\t\t{\"mycmd/v1\", \"v1\", \"v1\"},\n+\t\t{\"mycmd/v2\", \"mycmd\", \"v2\"}, // Semantic import versioning, use second last element in module mode.\n+\t\t{\"v0\", \"v0\", \"v0\"},\n+\t\t{\"v1\", \"v1\", \"v1\"},\n+\t\t{\"v2\", \"v2\", \"v2\"},\n+\t} {\n+\t\t{\n+\t\t\tcfg.ModulesEnabled = true\n+\t\t\tgotMod := DefaultExecName(tt.in)\n+\t\t\tif gotMod != tt.wantMod {\n+\t\t\t\tt.Errorf(\"DefaultExecName(%q) in module mode = %v; want %v\", tt.in, gotMod, tt.wantMod)\n+\t\t\t}\n+\t\t}\n+\t\t{\n+\t\t\tcfg.ModulesEnabled = false\n+\t\t\tgotGopath := DefaultExecName(tt.in)\n+\t\t\tif gotGopath != tt.wantGopath {\n+\t\t\t\tt.Errorf(\"DefaultExecName(%q) in gopath mode = %v; want %v\", tt.in, gotGopath, tt.wantGopath)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestIsVersionElement(t *testing.T) {\n+\tt.Parallel()\n+\tfor _, tt := range []struct {\n+\t\tin   string\n+\t\twant bool\n+\t}{\n+\t\t{\"v0\", false},\n+\t\t{\"v05\", false},\n+\t\t{\"v1\", false},\n+\t\t{\"v2\", true},\n+\t\t{\"v3\", true},\n+\t\t{\"v9\", true},\n+\t\t{\"v10\", true},\n+\t\t{\"v11\", true},\n+\t\t{\"v\", false},\n+\t\t{\"vx\", false},\n+\t} {\n+\t\tgot := isVersionElement(tt.in)\n+\t\tif got != tt.want {\n+\t\t\tt.Errorf(\"isVersionElement(%q) = %v; want %v\", tt.in, got, tt.want)\n+\t\t}\n+\t}\n+}"}, {"sha": "c247d56c8127f5624c9610b6fcab94a9c36bc372", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 121, "deletions": 44, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -15,10 +15,10 @@ import (\n \t\"go/doc\"\n \t\"go/parser\"\n \t\"go/token\"\n+\t\"internal/lazytemplate\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n-\t\"text/template\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n )\n@@ -39,76 +39,115 @@ type TestCover struct {\n \tDeclVars func(*Package, ...string) map[string]*CoverVar\n }\n \n-// TestPackagesFor returns three packages:\n+// TestPackagesFor is like TestPackagesAndErrors but it returns\n+// an error if the test packages or their dependencies have errors.\n+// Only test packages without errors are returned.\n+func TestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n+\tpmain, ptest, pxtest = TestPackagesAndErrors(p, cover)\n+\tfor _, p1 := range []*Package{ptest, pxtest, pmain} {\n+\t\tif p1 == nil {\n+\t\t\t// pxtest may be nil\n+\t\t\tcontinue\n+\t\t}\n+\t\tif p1.Error != nil {\n+\t\t\terr = p1.Error\n+\t\t\tbreak\n+\t\t}\n+\t\tif len(p1.DepsErrors) > 0 {\n+\t\t\tperr := p1.DepsErrors[0]\n+\t\t\tperr.Pos = \"\" // show full import stack\n+\t\t\terr = perr\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\tif pmain.Error != nil || len(pmain.DepsErrors) > 0 {\n+\t\tpmain = nil\n+\t}\n+\tif ptest.Error != nil || len(ptest.DepsErrors) > 0 {\n+\t\tptest = nil\n+\t}\n+\tif pxtest != nil && (pxtest.Error != nil || len(pxtest.DepsErrors) > 0) {\n+\t\tpxtest = nil\n+\t}\n+\treturn pmain, ptest, pxtest, err\n+}\n+\n+// TestPackagesAndErrors returns three packages:\n+//\t- pmain, the package main corresponding to the test binary (running tests in ptest and pxtest).\n //\t- ptest, the package p compiled with added \"package p\" test files.\n //\t- pxtest, the result of compiling any \"package p_test\" (external) test files.\n-//\t- pmain, the package main corresponding to the test binary (running tests in ptest and pxtest).\n //\n // If the package has no \"package p_test\" test files, pxtest will be nil.\n // If the non-test compilation of package p can be reused\n // (for example, if there are no \"package p\" test files and\n // package p need not be instrumented for coverage or any other reason),\n // then the returned ptest == p.\n //\n+// An error is returned if the testmain source cannot be completely generated\n+// (for example, due to a syntax error in a test file). No error will be\n+// returned for errors loading packages, but the Error or DepsError fields\n+// of the returned packages may be set.\n+//\n // The caller is expected to have checked that len(p.TestGoFiles)+len(p.XTestGoFiles) > 0,\n // or else there's no point in any of this.\n-func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Package, err error) {\n+func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *Package) {\n+\tpre := newPreload()\n+\tdefer pre.flush()\n+\tallImports := append([]string{}, p.TestImports...)\n+\tallImports = append(allImports, p.XTestImports...)\n+\tpre.preloadImports(allImports, p.Internal.Build)\n+\n+\tvar ptestErr, pxtestErr *PackageError\n \tvar imports, ximports []*Package\n \tvar stk ImportStack\n \tstk.Push(p.ImportPath + \" (test)\")\n \trawTestImports := str.StringList(p.TestImports)\n+\tvar ptestImportsTesting, pxtestImportsTesting bool\n \tfor i, path := range p.TestImports {\n-\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n-\t\tif p1.Error != nil {\n-\t\t\treturn nil, nil, nil, p1.Error\n-\t\t}\n-\t\tif len(p1.DepsErrors) > 0 {\n-\t\t\terr := p1.DepsErrors[0]\n-\t\t\terr.Pos = \"\" // show full import stack\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n+\t\tp1 := loadImport(pre, path, p.Dir, p, &stk, p.Internal.Build.TestImportPos[path], ResolveImport)\n \t\tif str.Contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {\n \t\t\t// Same error that loadPackage returns (via reusePackage) in pkg.go.\n \t\t\t// Can't change that code, because that code is only for loading the\n \t\t\t// non-test copy of a package.\n-\t\t\terr := &PackageError{\n+\t\t\tptestErr = &PackageError{\n \t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n \t\t\t\tErr:           \"import cycle not allowed in test\",\n \t\t\t\tIsImportCycle: true,\n \t\t\t}\n-\t\t\treturn nil, nil, nil, err\n \t\t}\n \t\tp.TestImports[i] = p1.ImportPath\n \t\timports = append(imports, p1)\n+\t\tif path == \"testing\" {\n+\t\t\tptestImportsTesting = true\n+\t\t}\n \t}\n \tstk.Pop()\n \tstk.Push(p.ImportPath + \"_test\")\n \tpxtestNeedsPtest := false\n \trawXTestImports := str.StringList(p.XTestImports)\n \tfor i, path := range p.XTestImports {\n-\t\tp1 := LoadImport(path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n-\t\tif p1.Error != nil {\n-\t\t\treturn nil, nil, nil, p1.Error\n-\t\t}\n-\t\tif len(p1.DepsErrors) > 0 {\n-\t\t\terr := p1.DepsErrors[0]\n-\t\t\terr.Pos = \"\" // show full import stack\n-\t\t\treturn nil, nil, nil, err\n-\t\t}\n+\t\tp1 := loadImport(pre, path, p.Dir, p, &stk, p.Internal.Build.XTestImportPos[path], ResolveImport)\n \t\tif p1.ImportPath == p.ImportPath {\n \t\t\tpxtestNeedsPtest = true\n \t\t} else {\n \t\t\tximports = append(ximports, p1)\n \t\t}\n \t\tp.XTestImports[i] = p1.ImportPath\n+\t\tif path == \"testing\" {\n+\t\t\tpxtestImportsTesting = true\n+\t\t}\n \t}\n \tstk.Pop()\n \n \t// Test package.\n \tif len(p.TestGoFiles) > 0 || p.Name == \"main\" || cover != nil && cover.Local {\n \t\tptest = new(Package)\n \t\t*ptest = *p\n+\t\tptest.Error = ptestErr\n \t\tptest.ForTest = p.ImportPath\n+\t\tif ptestImportsTesting {\n+\t\t\tptest.Internal.TestinginitGo = formatTestinginit(p)\n+\t\t}\n \t\tptest.GoFiles = nil\n \t\tptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)\n \t\tptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)\n@@ -140,6 +179,7 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\t\tm[k] = append(m[k], v...)\n \t\t}\n \t\tptest.Internal.Build.ImportPos = m\n+\t\tptest.collectDeps()\n \t} else {\n \t\tptest = p\n \t}\n@@ -152,9 +192,11 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\t\t\tImportPath: p.ImportPath + \"_test\",\n \t\t\t\tRoot:       p.Root,\n \t\t\t\tDir:        p.Dir,\n+\t\t\t\tGoroot:     p.Goroot,\n \t\t\t\tGoFiles:    p.XTestGoFiles,\n \t\t\t\tImports:    p.XTestImports,\n \t\t\t\tForTest:    p.ImportPath,\n+\t\t\t\tError:      pxtestErr,\n \t\t\t},\n \t\t\tInternal: PackageInternal{\n \t\t\t\tLocalPrefix: p.Internal.LocalPrefix,\n@@ -170,9 +212,13 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\t\t\tGccgoflags: p.Internal.Gccgoflags,\n \t\t\t},\n \t\t}\n+\t\tif pxtestImportsTesting {\n+\t\t\tpxtest.Internal.TestinginitGo = formatTestinginit(pxtest)\n+\t\t}\n \t\tif pxtestNeedsPtest {\n \t\t\tpxtest.Internal.Imports = append(pxtest.Internal.Imports, ptest)\n \t\t}\n+\t\tpxtest.collectDeps()\n \t}\n \n \t// Build main package.\n@@ -206,10 +252,7 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\tif dep == ptest.ImportPath {\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, ptest)\n \t\t} else {\n-\t\t\tp1 := LoadImport(dep, \"\", nil, &stk, nil, 0)\n-\t\t\tif p1.Error != nil {\n-\t\t\t\treturn nil, nil, nil, p1.Error\n-\t\t\t}\n+\t\t\tp1 := loadImport(pre, dep, \"\", nil, &stk, nil, 0)\n \t\t\tpmain.Internal.Imports = append(pmain.Internal.Imports, p1)\n \t\t}\n \t}\n@@ -240,8 +283,8 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t// The list of imports is used by recompileForTest and by the loop\n \t// afterward that gathers t.Cover information.\n \tt, err := loadTestFuncs(ptest)\n-\tif err != nil {\n-\t\treturn nil, nil, nil, err\n+\tif err != nil && pmain.Error == nil {\n+\t\tpmain.Error = &PackageError{Err: err.Error()}\n \t}\n \tt.Cover = cover\n \tif len(ptest.GoFiles)+len(ptest.CgoFiles) > 0 {\n@@ -254,6 +297,7 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t\tpmain.Imports = append(pmain.Imports, pxtest.ImportPath)\n \t\tt.ImportXtest = true\n \t}\n+\tpmain.collectDeps()\n \n \t// Sort and dedup pmain.Imports.\n \t// Only matters for go list -test output.\n@@ -290,12 +334,12 @@ func GetTestPackagesFor(p *Package, cover *TestCover) (pmain, ptest, pxtest *Pac\n \t}\n \n \tdata, err := formatTestmain(t)\n-\tif err != nil {\n-\t\treturn nil, nil, nil, err\n+\tif err != nil && pmain.Error == nil {\n+\t\tpmain.Error = &PackageError{Err: err.Error()}\n \t}\n-\tpmain.Internal.TestmainGo = &data\n+\tpmain.Internal.TestmainGo = data\n \n-\treturn pmain, ptest, pxtest, nil\n+\treturn pmain, ptest, pxtest\n }\n \n func testImportStack(top string, p *Package, target string) []string {\n@@ -321,9 +365,10 @@ Search:\n // preal, packages that import the package under test should get ptest instead\n // of preal. This is particularly important if pxtest depends on functionality\n // exposed in test sources in ptest. Second, if there is a main package\n-// (other than pmain) anywhere, we need to clear p.Internal.BuildInfo in\n-// the test copy to prevent link conflicts. This may happen if both -coverpkg\n-// and the command line patterns include multiple main packages.\n+// (other than pmain) anywhere, we need to set p.Internal.ForceLibrary and\n+// clear p.Internal.BuildInfo in the test copy to prevent link conflicts.\n+// This may happen if both -coverpkg and the command line patterns include\n+// multiple main packages.\n func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \t// The \"test copy\" of preal is ptest.\n \t// For each package that depends on preal, make a \"test copy\"\n@@ -354,6 +399,7 @@ func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \t\t\tp = p1\n \t\t\tp.Target = \"\"\n \t\t\tp.Internal.BuildInfo = \"\"\n+\t\t\tp.Internal.ForceLibrary = true\n \t\t}\n \n \t\t// Update p.Internal.Imports to use test copies.\n@@ -419,21 +465,33 @@ type coverInfo struct {\n }\n \n // loadTestFuncs returns the testFuncs describing the tests that will be run.\n+// The returned testFuncs is always non-nil, even if an error occurred while\n+// processing test files.\n func loadTestFuncs(ptest *Package) (*testFuncs, error) {\n \tt := &testFuncs{\n \t\tPackage: ptest,\n \t}\n+\tvar err error\n \tfor _, file := range ptest.TestGoFiles {\n-\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_test\", &t.ImportTest, &t.NeedTest); err != nil {\n-\t\t\treturn nil, err\n+\t\tif lerr := t.load(filepath.Join(ptest.Dir, file), \"_test\", &t.ImportTest, &t.NeedTest); lerr != nil && err == nil {\n+\t\t\terr = lerr\n \t\t}\n \t}\n \tfor _, file := range ptest.XTestGoFiles {\n-\t\tif err := t.load(filepath.Join(ptest.Dir, file), \"_xtest\", &t.ImportXtest, &t.NeedXtest); err != nil {\n-\t\t\treturn nil, err\n+\t\tif lerr := t.load(filepath.Join(ptest.Dir, file), \"_xtest\", &t.ImportXtest, &t.NeedXtest); lerr != nil && err == nil {\n+\t\t\terr = lerr\n \t\t}\n \t}\n-\treturn t, nil\n+\treturn t, err\n+}\n+\n+// formatTestinginit returns the content of the _testinginit.go file for p.\n+func formatTestinginit(p *Package) []byte {\n+\tvar buf bytes.Buffer\n+\tif err := testinginitTmpl.Execute(&buf, p); err != nil {\n+\t\tpanic(\"testinginit template execution failed\") // shouldn't be possible\n+\t}\n+\treturn buf.Bytes()\n }\n \n // formatTestmain returns the content of the _testmain.go file for t.\n@@ -565,7 +623,26 @@ func checkTestFunc(fn *ast.FuncDecl, arg string) error {\n \treturn nil\n }\n \n-var testmainTmpl = template.Must(template.New(\"main\").Parse(`\n+var testinginitTmpl = lazytemplate.New(\"init\", `\n+package {{.Name}}\n+\n+import _go_testing \"testing\"\n+\n+{{/*\n+Call testing.Init before any other user initialization code runs.\n+(This file is passed to the compiler first.)\n+This provides the illusion of the old behavior where testing flags\n+were registered as part of the testing package's initialization.\n+*/}}\n+var _ = func() bool {\n+\t_go_testing.Init()\n+\treturn true\n+}()\n+`)\n+\n+var testmainTmpl = lazytemplate.New(\"main\", `\n+// Code generated by 'go test'. DO NOT EDIT.\n+\n package main\n \n import (\n@@ -666,4 +743,4 @@ func main() {\n {{end}}\n }\n \n-`))\n+`)"}, {"sha": "581a978ef8e632b7aa7a4eb75ceb305866be05a5", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -159,24 +159,27 @@ func TestRLockExcludesOnlyLock(t *testing.T) {\n \tf2 := mustOpen(t, f.Name())\n \tdefer f2.Close()\n \n-\tif runtime.GOOS == \"solaris\" || runtime.GOOS == \"aix\" {\n+\tdoUnlockTF := false\n+\tswitch runtime.GOOS {\n+\tcase \"aix\", \"illumos\", \"solaris\":\n \t\t// When using POSIX locks (as on Solaris), we can't safely read-lock the\n \t\t// same inode through two different descriptors at the same time: when the\n \t\t// first descriptor is closed, the second descriptor would still be open but\n \t\t// silently unlocked. So a second RLock must block instead of proceeding.\n \t\tlockF2 := mustBlock(t, \"RLock\", f2)\n \t\tunlock(t, f)\n \t\tlockF2(t)\n-\t} else {\n+\tdefault:\n \t\trLock(t, f2)\n+\t\tdoUnlockTF = true\n \t}\n \n \tother := mustOpen(t, f.Name())\n \tdefer other.Close()\n \tlockOther := mustBlock(t, \"Lock\", other)\n \n \tunlock(t, f2)\n-\tif runtime.GOOS != \"solaris\" && runtime.GOOS != \"aix\" {\n+\tif doUnlockTF {\n \t\tunlock(t, f)\n \t}\n \tlockOther(t)"}, {"sha": "180a36c62016ba045f1829680e91182ac6d716a7", "filename": "libgo/go/cmd/go/internal/lockedfile/mutex.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Fmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Fmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Fmutex.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -7,6 +7,7 @@ package lockedfile\n import (\n \t\"fmt\"\n \t\"os\"\n+\t\"sync\"\n )\n \n // A Mutex provides mutual exclusion within and across processes by locking a\n@@ -21,7 +22,8 @@ import (\n // must not be copied after first use. The Path field must be set before first\n // use and must not be change thereafter.\n type Mutex struct {\n-\tPath string // The path to the well-known lock file. Must be non-empty.\n+\tPath string     // The path to the well-known lock file. Must be non-empty.\n+\tmu   sync.Mutex // A redundant mutex. The race detector doesn't know about file locking, so in tests we may need to lock something that it understands.\n }\n \n // MutexAt returns a new Mutex with Path set to the given non-empty path.\n@@ -56,5 +58,10 @@ func (mu *Mutex) Lock() (unlock func(), err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn func() { f.Close() }, nil\n+\tmu.mu.Lock()\n+\n+\treturn func() {\n+\t\tmu.mu.Unlock()\n+\t\tf.Close()\n+\t}, nil\n }"}, {"sha": "71b660d6fde326e7f468794db4a5f1c8673fff43", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,13 +5,15 @@\n package modcmd\n \n import (\n+\t\"cmd/go/internal/cfg\"\n+\t\"encoding/json\"\n+\t\"os\"\n+\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n-\t\"encoding/json\"\n-\t\"os\"\n )\n \n var cmdDownload = &base.Command{\n@@ -66,6 +68,13 @@ type moduleJSON struct {\n }\n \n func runDownload(cmd *base.Command, args []string) {\n+\t// Check whether modules are enabled and whether we're in a module.\n+\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n+\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n+\t}\n+\tif !modload.HasModRoot() && len(args) == 0 {\n+\t\tbase.Fatalf(\"go mod download: no modules specified (see 'go help mod download')\")\n+\t}\n \tif len(args) == 0 {\n \t\targs = []string{\"all\"}\n \t}"}, {"sha": "1be8b7cb2fbbdf41d1277c7d338ec6787ca65c55", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -385,7 +385,9 @@ type replaceJSON struct {\n // editPrintJSON prints the -json output.\n func editPrintJSON(modFile *modfile.File) {\n \tvar f fileJSON\n-\tf.Module = modFile.Module.Mod\n+\tif modFile.Module != nil {\n+\t\tf.Module = modFile.Module.Mod\n+\t}\n \tif modFile.Go != nil {\n \t\tf.Go = modFile.Go.Version\n \t}"}, {"sha": "8fcb84f2801e658a7441e186b207a72d5c9685a6", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,6 +8,7 @@ package modcmd\n \n import (\n \t\"bufio\"\n+\t\"cmd/go/internal/cfg\"\n \t\"os\"\n \t\"sort\"\n \n@@ -33,6 +34,14 @@ func runGraph(cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go mod graph: graph takes no arguments\")\n \t}\n+\t// Checks go mod expected behavior\n+\tif !modload.Enabled() {\n+\t\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n+\t\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n+\t\t} else {\n+\t\t\tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n+\t\t}\n+\t}\n \tmodload.LoadBuildList()\n \n \treqs := modload.MinReqs()"}, {"sha": "b94453bab0cf623208524f6c79c3e15c52515cdc", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -35,6 +35,9 @@ func runInit(cmd *base.Command, args []string) {\n \tif len(args) == 1 {\n \t\tmodload.CmdModModule = args[0]\n \t}\n+\tif os.Getenv(\"GO111MODULE\") == \"off\" {\n+\t\tbase.Fatalf(\"go mod init: modules disabled by GO111MODULE=off; see 'go help modules'\")\n+\t}\n \tif _, err := os.Stat(\"go.mod\"); err == nil {\n \t\tbase.Fatalf(\"go mod init: go.mod already exists\")\n \t}"}, {"sha": "75513f1d9ca99138ada1f9bc7167dd5bfa2a5a78", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -11,10 +11,12 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"sort\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/module\"\n )\n@@ -71,6 +73,7 @@ func runVendor(cmd *base.Command, args []string) {\n \t\t\tif cfg.BuildV {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"# %s %s%s\\n\", m.Path, m.Version, repl)\n \t\t\t}\n+\t\t\tsort.Strings(pkgs)\n \t\t\tfor _, pkg := range pkgs {\n \t\t\t\tfmt.Fprintf(&buf, \"%s\\n\", pkg)\n \t\t\t\tif cfg.BuildV {\n@@ -100,7 +103,7 @@ func vendorPkg(vdir, pkg string) {\n \tif src == \"\" {\n \t\tfmt.Fprintf(os.Stderr, \"internal error: no pkg for %s -> %s\\n\", pkg, realPath)\n \t}\n-\tcopyDir(dst, src, matchNonTest)\n+\tcopyDir(dst, src, matchPotentialSourceFile)\n \tif m := modload.PackageModule(realPath); m.Path != \"\" {\n \t\tcopyMetadata(m.Path, realPath, dst, src)\n \t}\n@@ -153,7 +156,7 @@ var metaPrefixes = []string{\n }\n \n // matchMetadata reports whether info is a metadata file.\n-func matchMetadata(info os.FileInfo) bool {\n+func matchMetadata(dir string, info os.FileInfo) bool {\n \tname := info.Name()\n \tfor _, p := range metaPrefixes {\n \t\tif strings.HasPrefix(name, p) {\n@@ -163,13 +166,34 @@ func matchMetadata(info os.FileInfo) bool {\n \treturn false\n }\n \n-// matchNonTest reports whether info is any non-test file (including non-Go files).\n-func matchNonTest(info os.FileInfo) bool {\n-\treturn !strings.HasSuffix(info.Name(), \"_test.go\")\n+// matchPotentialSourceFile reports whether info may be relevant to a build operation.\n+func matchPotentialSourceFile(dir string, info os.FileInfo) bool {\n+\tif strings.HasSuffix(info.Name(), \"_test.go\") {\n+\t\treturn false\n+\t}\n+\tif strings.HasSuffix(info.Name(), \".go\") {\n+\t\tf, err := os.Open(filepath.Join(dir, info.Name()))\n+\t\tif err != nil {\n+\t\t\tbase.Fatalf(\"go mod vendor: %v\", err)\n+\t\t}\n+\t\tdefer f.Close()\n+\n+\t\tcontent, err := imports.ReadImports(f, false, nil)\n+\t\tif err == nil && !imports.ShouldBuild(content, imports.AnyTags()) {\n+\t\t\t// The file is explicitly tagged \"ignore\", so it can't affect the build.\n+\t\t\t// Leave it out.\n+\t\t\treturn false\n+\t\t}\n+\t\treturn true\n+\t}\n+\n+\t// We don't know anything about this file, so optimistically assume that it is\n+\t// needed.\n+\treturn true\n }\n \n // copyDir copies all regular files satisfying match(info) from src to dst.\n-func copyDir(dst, src string, match func(os.FileInfo) bool) {\n+func copyDir(dst, src string, match func(dir string, info os.FileInfo) bool) {\n \tfiles, err := ioutil.ReadDir(src)\n \tif err != nil {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n@@ -178,7 +202,7 @@ func copyDir(dst, src string, match func(os.FileInfo) bool) {\n \t\tbase.Fatalf(\"go mod vendor: %v\", err)\n \t}\n \tfor _, file := range files {\n-\t\tif file.IsDir() || !file.Mode().IsRegular() || !match(file) {\n+\t\tif file.IsDir() || !file.Mode().IsRegular() || !match(src, file) {\n \t\t\tcontinue\n \t\t}\n \t\tr, err := os.Open(filepath.Join(src, file.Name()))"}, {"sha": "81fc44dc97ae609cffc8e43b56ddaa1d9435f9e4", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,6 +6,7 @@ package modcmd\n \n import (\n \t\"bytes\"\n+\t\"cmd/go/internal/cfg\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -36,6 +37,14 @@ func runVerify(cmd *base.Command, args []string) {\n \t\t// NOTE(rsc): Could take a module pattern.\n \t\tbase.Fatalf(\"go mod verify: verify takes no arguments\")\n \t}\n+\t// Checks go mod expected behavior\n+\tif !modload.Enabled() {\n+\t\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n+\t\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n+\t\t} else {\n+\t\t\tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n+\t\t}\n+\t}\n \tok := true\n \tfor _, mod := range modload.LoadBuildList()[1:] {\n \t\tok = verifyMod(mod) && ok"}, {"sha": "558664a8b38616753203316b0e259716ac38bfc5", "filename": "libgo/go/cmd/go/internal/modconv/convert.go", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -41,19 +41,29 @@ func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error {\n \n \t// Convert requirements block, which may use raw SHA1 hashes as versions,\n \t// to valid semver requirement list, respecting major versions.\n-\tvar work par.Work\n+\tvar (\n+\t\twork    par.Work\n+\t\tmu      sync.Mutex\n+\t\tneed    = make(map[string]string)\n+\t\treplace = make(map[string]*modfile.Replace)\n+\t)\n+\n+\tfor _, r := range mf.Replace {\n+\t\treplace[r.New.Path] = r\n+\t\treplace[r.Old.Path] = r\n+\t}\n \tfor _, r := range mf.Require {\n \t\tm := r.Mod\n \t\tif m.Path == \"\" {\n \t\t\tcontinue\n \t\t}\n+\t\tif re, ok := replace[m.Path]; ok {\n+\t\t\twork.Add(re.New)\n+\t\t\tcontinue\n+\t\t}\n \t\twork.Add(r.Mod)\n \t}\n \n-\tvar (\n-\t\tmu   sync.Mutex\n-\t\tneed = make(map[string]string)\n-\t)\n \twork.Do(10, func(item interface{}) {\n \t\tr := item.(module.Version)\n \t\trepo, info, err := modfetch.ImportRepoRev(r.Path, r.Version)\n@@ -76,15 +86,15 @@ func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error {\n \t}\n \tsort.Strings(paths)\n \tfor _, path := range paths {\n+\t\tif re, ok := replace[path]; ok {\n+\t\t\terr := f.AddReplace(re.Old.Path, re.Old.Version, path, need[path])\n+\t\t\tif err != nil {\n+\t\t\t\treturn fmt.Errorf(\"add replace: %v\", err)\n+\t\t\t}\n+\t\t}\n \t\tf.AddNewRequire(path, need[path], false)\n \t}\n \n-\tfor _, r := range mf.Replace {\n-\t\terr := f.AddReplace(r.Old.Path, r.Old.Version, r.New.Path, r.New.Version)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"add replace: %v\", err)\n-\t\t}\n-\t}\n \tf.Cleanup()\n \treturn nil\n }"}, {"sha": "8ff229bd148578c2a557da7827d963eed2269af2", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -28,6 +28,8 @@ func TestMain(m *testing.M) {\n }\n \n func testMain(m *testing.M) int {\n+\tcfg.GOPROXY = \"direct\"\n+\n \tif _, err := exec.LookPath(\"git\"); err != nil {\n \t\tfmt.Fprintln(os.Stderr, \"skipping because git binary not found\")\n \t\tfmt.Println(\"PASS\")\n@@ -104,19 +106,19 @@ func TestConvertLegacyConfig(t *testing.T) {\n \t\t\t\tgithub.com/AdRoll/goamz v0.0.0-20150130162828-d3664b76d905\n \t\t\t\tgithub.com/MSOpenTech/azure-sdk-for-go v0.0.0-20150323223030-d90753bcad2e\n \t\t\t\tgithub.com/Sirupsen/logrus v0.7.3\n-\t\t\t\tgithub.com/bugsnag/bugsnag-go v0.0.0-20141110184014-b1d153021fcd\n+\t\t\t\tgithub.com/bugsnag/bugsnag-go v1.0.3-0.20141110184014-b1d153021fcd\n \t\t\t\tgithub.com/bugsnag/osext v0.0.0-20130617224835-0dd3f918b21b\n \t\t\t\tgithub.com/bugsnag/panicwrap v0.0.0-20141110184334-e5f9854865b9\n-\t\t\t\tgithub.com/codegangsta/cli v0.0.0-20150131031259-6086d7927ec3\n-\t\t\t\tgithub.com/docker/docker v0.0.0-20150204013315-165ea5c158cf\n+\t\t\t\tgithub.com/codegangsta/cli v1.4.2-0.20150131031259-6086d7927ec3\n+\t\t\t\tgithub.com/docker/docker v1.4.2-0.20150204013315-165ea5c158cf\n \t\t\t\tgithub.com/docker/libtrust v0.0.0-20150114040149-fa567046d9b1\n \t\t\t\tgithub.com/garyburd/redigo v0.0.0-20150301180006-535138d7bcd7\n \t\t\t\tgithub.com/gorilla/context v0.0.0-20140604161150-14f550f51af5\n \t\t\t\tgithub.com/gorilla/handlers v0.0.0-20140825150757-0e84b7d810c1\n \t\t\t\tgithub.com/gorilla/mux v0.0.0-20140926153814-e444e69cbd2e\n \t\t\t\tgithub.com/jlhawn/go-crypto v0.0.0-20150401213827-cd738dde20f0\n \t\t\t\tgithub.com/yvasiyarov/go-metrics v0.0.0-20140926110328-57bccd1ccd43\n-\t\t\t\tgithub.com/yvasiyarov/gorelic v0.0.0-20141212073537-a9bba5b9ab50\n+\t\t\t\tgithub.com/yvasiyarov/gorelic v0.0.7-0.20141212073537-a9bba5b9ab50\n \t\t\t\tgithub.com/yvasiyarov/newrelic_platform_go v0.0.0-20140908184405-b21fdbd4370f\n \t\t\t\tgolang.org/x/net v0.0.0-20150202051010-1dfe7915deaf\n \t\t\t\tgopkg.in/check.v1 v1.0.0-20141024133853-64131543e789\n@@ -126,7 +128,7 @@ func TestConvertLegacyConfig(t *testing.T) {\n \n \t\t{\n \t\t\t// golang.org/issue/24585 - confusion about v2.0.0 tag in legacy non-v2 module\n-\t\t\t\"github.com/fishy/gcsbucket\", \"v0.0.0-20150410205453-618d60fe84e0\",\n+\t\t\t\"github.com/fishy/gcsbucket\", \"v0.0.0-20180217031846-618d60fe84e0\",\n \t\t\t`module github.com/fishy/gcsbucket\n \n \t\t\trequire (\n@@ -136,7 +138,7 @@ func TestConvertLegacyConfig(t *testing.T) {\n \t\t\t\tgithub.com/googleapis/gax-go v2.0.0+incompatible\n \t\t\t\tgolang.org/x/net v0.0.0-20180216171745-136a25c244d3\n \t\t\t\tgolang.org/x/oauth2 v0.0.0-20180207181906-543e37812f10\n-\t\t\t\tgolang.org/x/text v0.0.0-20180208041248-4e4a3210bb54\n+\t\t\t\tgolang.org/x/text v0.3.1-0.20180208041248-4e4a3210bb54\n \t\t\t\tgoogle.golang.org/api v0.0.0-20180217000815-c7a403bb5fe1\n \t\t\t\tgoogle.golang.org/appengine v1.0.0\n \t\t\t\tgoogle.golang.org/genproto v0.0.0-20180206005123-2b5a72b8730b"}, {"sha": "ccd1fc7b7594ff6af0e2d2d90c207cbcb7afed94", "filename": "libgo/go/cmd/go/internal/modconv/dep.go", "status": "modified", "additions": 62, "deletions": 4, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,6 +6,9 @@ package modconv\n \n import (\n \t\"fmt\"\n+\t\"internal/lazyregexp\"\n+\t\"net/url\"\n+\t\"path\"\n \t\"strconv\"\n \t\"strings\"\n \n@@ -15,17 +18,22 @@ import (\n )\n \n func ParseGopkgLock(file string, data []byte) (*modfile.File, error) {\n+\ttype pkg struct {\n+\t\tPath    string\n+\t\tVersion string\n+\t\tSource  string\n+\t}\n \tmf := new(modfile.File)\n-\tvar list []module.Version\n-\tvar r *module.Version\n+\tvar list []pkg\n+\tvar r *pkg\n \tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n \t\tlineno++\n \t\tif i := strings.Index(line, \"#\"); i >= 0 {\n \t\t\tline = line[:i]\n \t\t}\n \t\tline = strings.TrimSpace(line)\n \t\tif line == \"[[projects]]\" {\n-\t\t\tlist = append(list, module.Version{})\n+\t\t\tlist = append(list, pkg{})\n \t\t\tr = &list[len(list)-1]\n \t\t\tcontinue\n \t\t}\n@@ -52,6 +60,8 @@ func ParseGopkgLock(file string, data []byte) (*modfile.File, error) {\n \t\tswitch key {\n \t\tcase \"name\":\n \t\t\tr.Path = val\n+\t\tcase \"source\":\n+\t\t\tr.Source = val\n \t\tcase \"revision\", \"version\":\n \t\t\t// Note: key \"version\" should take priority over \"revision\",\n \t\t\t// and it does, because dep writes toml keys in alphabetical order,\n@@ -68,7 +78,55 @@ func ParseGopkgLock(file string, data []byte) (*modfile.File, error) {\n \t\tif r.Path == \"\" || r.Version == \"\" {\n \t\t\treturn nil, fmt.Errorf(\"%s: empty [[projects]] stanza (%s)\", file, r.Path)\n \t\t}\n-\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: r})\n+\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: r.Path, Version: r.Version}})\n+\n+\t\tif r.Source != \"\" {\n+\t\t\t// Convert \"source\" to import path, such as\n+\t\t\t// git@test.com:x/y.git and https://test.com/x/y.git.\n+\t\t\t// We get \"test.com/x/y\" at last.\n+\t\t\tsource, err := decodeSource(r.Source)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\told := module.Version{Path: r.Path, Version: r.Version}\n+\t\t\tnew := module.Version{Path: source, Version: r.Version}\n+\t\t\tmf.Replace = append(mf.Replace, &modfile.Replace{Old: old, New: new})\n+\t\t}\n \t}\n \treturn mf, nil\n }\n+\n+var scpSyntaxReg = lazyregexp.New(`^([a-zA-Z0-9_]+)@([a-zA-Z0-9._-]+):(.*)$`)\n+\n+func decodeSource(source string) (string, error) {\n+\tvar u *url.URL\n+\tvar p string\n+\tif m := scpSyntaxReg.FindStringSubmatch(source); m != nil {\n+\t\t// Match SCP-like syntax and convert it to a URL.\n+\t\t// Eg, \"git@github.com:user/repo\" becomes\n+\t\t// \"ssh://git@github.com/user/repo\".\n+\t\tu = &url.URL{\n+\t\t\tScheme: \"ssh\",\n+\t\t\tUser:   url.User(m[1]),\n+\t\t\tHost:   m[2],\n+\t\t\tPath:   \"/\" + m[3],\n+\t\t}\n+\t} else {\n+\t\tvar err error\n+\t\tu, err = url.Parse(source)\n+\t\tif err != nil {\n+\t\t\treturn \"\", fmt.Errorf(\"%q is not a valid URI\", source)\n+\t\t}\n+\t}\n+\n+\t// If no scheme was passed, then the entire path will have been put into\n+\t// u.Path. Either way, construct the normalized path correctly.\n+\tif u.Host == \"\" {\n+\t\tp = source\n+\t} else {\n+\t\tp = path.Join(u.Host, u.Path)\n+\t}\n+\tp = strings.TrimSuffix(p, \".git\")\n+\tp = strings.TrimSuffix(p, \".hg\")\n+\treturn p, nil\n+}"}, {"sha": "18ab57814deb595e49714a6448de64d8b0ca1a71", "filename": "libgo/go/cmd/go/internal/modconv/glide.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -15,8 +15,7 @@ func ParseGlideLock(file string, data []byte) (*modfile.File, error) {\n \tmf := new(modfile.File)\n \timports := false\n \tname := \"\"\n-\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n-\t\tlineno++\n+\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tif line == \"\" {\n \t\t\tcontinue\n \t\t}"}, {"sha": "164a8e70d995541c83c616946a01ec2ba7f9a377", "filename": "libgo/go/cmd/go/internal/modconv/glock.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -13,8 +13,7 @@ import (\n \n func ParseGLOCKFILE(file string, data []byte) (*modfile.File, error) {\n \tmf := new(modfile.File)\n-\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n-\t\tlineno++\n+\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tf := strings.Fields(line)\n \t\tif len(f) >= 2 && f[0] != \"cmd\" {\n \t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: f[0], Version: f[1]}})"}, {"sha": "ccc4f3d576f6c591ab9db5f1f92a53e566e8bfb9", "filename": "libgo/go/cmd/go/internal/modconv/modconv_test.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -58,6 +58,9 @@ func Test(t *testing.T) {\n \t\t\tfor _, r := range out.Require {\n \t\t\t\tfmt.Fprintf(&buf, \"%s %s\\n\", r.Mod.Path, r.Mod.Version)\n \t\t\t}\n+\t\t\tfor _, r := range out.Replace {\n+\t\t\t\tfmt.Fprintf(&buf, \"replace: %s %s %s %s\\n\", r.Old.Path, r.Old.Version, r.New.Path, r.New.Version)\n+\t\t\t}\n \t\t\tif !bytes.Equal(buf.Bytes(), want) {\n \t\t\t\tt.Errorf(\"have:\\n%s\\nwant:\\n%s\", buf.Bytes(), want)\n \t\t\t}"}, {"sha": "106cddedd395760e3a061dbedf96ba81b2304abf", "filename": "libgo/go/cmd/go/internal/modconv/tsv.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -13,8 +13,7 @@ import (\n \n func ParseDependenciesTSV(file string, data []byte) (*modfile.File, error) {\n \tmf := new(modfile.File)\n-\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n-\t\tlineno++\n+\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tf := strings.Split(line, \"\\t\")\n \t\tif len(f) >= 3 {\n \t\t\tmf.Require = append(mf.Require, &modfile.Require{Mod: module.Version{Path: f[0], Version: f[2]}})"}, {"sha": "f62eba77621d20c215b8ff267c23bb4fc39929dd", "filename": "libgo/go/cmd/go/internal/modconv/vconf.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -13,8 +13,7 @@ import (\n \n func ParseVendorConf(file string, data []byte) (*modfile.File, error) {\n \tmf := new(modfile.File)\n-\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n-\t\tlineno++\n+\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tif i := strings.Index(line, \"#\"); i >= 0 {\n \t\t\tline = line[:i]\n \t\t}"}, {"sha": "8a06519932c294deaa0f4bbf6a9189fc1ec3824f", "filename": "libgo/go/cmd/go/internal/modconv/vyml.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -15,8 +15,7 @@ func ParseVendorYML(file string, data []byte) (*modfile.File, error) {\n \tmf := new(modfile.File)\n \tvendors := false\n \tpath := \"\"\n-\tfor lineno, line := range strings.Split(string(data), \"\\n\") {\n-\t\tlineno++\n+\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tif line == \"\" {\n \t\t\tcontinue\n \t\t}"}, {"sha": "8f31589ebfcbb8adca662af4cf1af9a2c77d0c62", "filename": "libgo/go/cmd/go/internal/modfetch/bootstrap.go", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build cmd_go_bootstrap\n+\n+package modfetch\n+\n+import \"cmd/go/internal/module\"\n+\n+func useSumDB(mod module.Version) bool {\n+\treturn false\n+}\n+\n+func lookupSumDB(mod module.Version) (string, []string, error) {\n+\tpanic(\"bootstrap\")\n+}"}, {"sha": "c0062809d172de0008125120bd7ffbd05da8abf3", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 89, "deletions": 34, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/module\"\n@@ -215,29 +216,21 @@ func (r *cachingRepo) Latest() (*RevInfo, error) {\n \treturn &info, nil\n }\n \n-func (r *cachingRepo) GoMod(rev string) ([]byte, error) {\n+func (r *cachingRepo) GoMod(version string) ([]byte, error) {\n \ttype cached struct {\n \t\ttext []byte\n \t\terr  error\n \t}\n-\tc := r.cache.Do(\"gomod:\"+rev, func() interface{} {\n-\t\tfile, text, err := readDiskGoMod(r.path, rev)\n+\tc := r.cache.Do(\"gomod:\"+version, func() interface{} {\n+\t\tfile, text, err := readDiskGoMod(r.path, version)\n \t\tif err == nil {\n \t\t\t// Note: readDiskGoMod already called checkGoMod.\n \t\t\treturn cached{text, nil}\n \t\t}\n \n-\t\t// Convert rev to canonical version\n-\t\t// so that we use the right identifier in the go.sum check.\n-\t\tinfo, err := r.Stat(rev)\n-\t\tif err != nil {\n-\t\t\treturn cached{nil, err}\n-\t\t}\n-\t\trev = info.Version\n-\n-\t\ttext, err = r.r.GoMod(rev)\n+\t\ttext, err = r.r.GoMod(version)\n \t\tif err == nil {\n-\t\t\tcheckGoMod(r.path, rev, text)\n+\t\t\tcheckGoMod(r.path, version, text)\n \t\t\tif err := writeDiskGoMod(file, text); err != nil {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: writing go.mod cache: %v\\n\", err)\n \t\t\t}\n@@ -258,12 +251,12 @@ func (r *cachingRepo) Zip(dst io.Writer, version string) error {\n // Stat is like Lookup(path).Stat(rev) but avoids the\n // repository path resolution in Lookup if the result is\n // already cached on local disk.\n-func Stat(path, rev string) (*RevInfo, error) {\n+func Stat(proxy, path, rev string) (*RevInfo, error) {\n \t_, info, err := readDiskStat(path, rev)\n \tif err == nil {\n \t\treturn info, nil\n \t}\n-\trepo, err := Lookup(path)\n+\trepo, err := Lookup(proxy, path)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -276,9 +269,22 @@ func InfoFile(path, version string) (string, error) {\n \tif !semver.IsValid(version) {\n \t\treturn \"\", fmt.Errorf(\"invalid version %q\", version)\n \t}\n-\tif _, err := Stat(path, version); err != nil {\n+\n+\tif file, _, err := readDiskStat(path, version); err == nil {\n+\t\treturn file, nil\n+\t}\n+\n+\terr := TryProxies(func(proxy string) error {\n+\t\trepo, err := Lookup(proxy, path)\n+\t\tif err == nil {\n+\t\t\t_, err = repo.Stat(version)\n+\t\t}\n+\t\treturn err\n+\t})\n+\tif err != nil {\n \t\treturn \"\", err\n \t}\n+\n \t// Stat should have populated the disk cache for us.\n \tfile, _, err := readDiskStat(path, version)\n \tif err != nil {\n@@ -294,21 +300,39 @@ func GoMod(path, rev string) ([]byte, error) {\n \t// Convert commit hash to pseudo-version\n \t// to increase cache hit rate.\n \tif !semver.IsValid(rev) {\n-\t\tinfo, err := Stat(path, rev)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tif _, info, err := readDiskStat(path, rev); err == nil {\n+\t\t\trev = info.Version\n+\t\t} else {\n+\t\t\terr := TryProxies(func(proxy string) error {\n+\t\t\t\trepo, err := Lookup(proxy, path)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tinfo, err := repo.Stat(rev)\n+\t\t\t\tif err == nil {\n+\t\t\t\t\trev = info.Version\n+\t\t\t\t}\n+\t\t\t\treturn err\n+\t\t\t})\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n \t\t}\n-\t\trev = info.Version\n \t}\n+\n \t_, data, err := readDiskGoMod(path, rev)\n \tif err == nil {\n \t\treturn data, nil\n \t}\n-\trepo, err := Lookup(path)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn repo.GoMod(rev)\n+\n+\terr = TryProxies(func(proxy string) error {\n+\t\trepo, err := Lookup(proxy, path)\n+\t\tif err == nil {\n+\t\t\tdata, err = repo.GoMod(rev)\n+\t\t}\n+\t\treturn err\n+\t})\n+\treturn data, err\n }\n \n // GoModFile is like GoMod but returns the name of the file containing\n@@ -354,8 +378,29 @@ var errNotCached = fmt.Errorf(\"not in cache\")\n func readDiskStat(path, rev string) (file string, info *RevInfo, err error) {\n \tfile, data, err := readDiskCache(path, rev, \"info\")\n \tif err != nil {\n-\t\tif file, info, err := readDiskStatByHash(path, rev); err == nil {\n-\t\t\treturn file, info, nil\n+\t\t// If the cache already contains a pseudo-version with the given hash, we\n+\t\t// would previously return that pseudo-version without checking upstream.\n+\t\t// However, that produced an unfortunate side-effect: if the author added a\n+\t\t// tag to the repository, 'go get' would not pick up the effect of that new\n+\t\t// tag on the existing commits, and 'go' commands that referred to those\n+\t\t// commits would use the previous name instead of the new one.\n+\t\t//\n+\t\t// That's especially problematic if the original pseudo-version starts with\n+\t\t// v0.0.0-, as was the case for all pseudo-versions during vgo development,\n+\t\t// since a v0.0.0- pseudo-version has lower precedence than pretty much any\n+\t\t// tagged version.\n+\t\t//\n+\t\t// In practice, we're only looking up by hash during initial conversion of a\n+\t\t// legacy config and during an explicit 'go get', and a little extra latency\n+\t\t// for those operations seems worth the benefit of picking up more accurate\n+\t\t// versions.\n+\t\t//\n+\t\t// Fall back to this resolution scheme only if the GOPROXY setting prohibits\n+\t\t// us from resolving upstream tags.\n+\t\tif cfg.GOPROXY == \"off\" {\n+\t\t\tif file, info, err := readDiskStatByHash(path, rev); err == nil {\n+\t\t\t\treturn file, info, nil\n+\t\t\t}\n \t\t}\n \t\treturn file, nil, err\n \t}\n@@ -405,13 +450,23 @@ func readDiskStatByHash(path, rev string) (file string, info *RevInfo, err error\n \tif err != nil {\n \t\treturn \"\", nil, errNotCached\n \t}\n+\n+\t// A given commit hash may map to more than one pseudo-version,\n+\t// depending on which tags are present on the repository.\n+\t// Take the highest such version.\n+\tvar maxVersion string\n \tsuffix := \"-\" + rev + \".info\"\n+\terr = errNotCached\n \tfor _, name := range names {\n-\t\tif strings.HasSuffix(name, suffix) && IsPseudoVersion(strings.TrimSuffix(name, \".info\")) {\n-\t\t\treturn readDiskStat(path, strings.TrimSuffix(name, \".info\"))\n+\t\tif strings.HasSuffix(name, suffix) {\n+\t\t\tv := strings.TrimSuffix(name, \".info\")\n+\t\t\tif IsPseudoVersion(v) && semver.Max(maxVersion, v) == v {\n+\t\t\t\tmaxVersion = v\n+\t\t\t\tfile, info, err = readDiskStat(path, strings.TrimSuffix(name, \".info\"))\n+\t\t\t}\n \t\t}\n \t}\n-\treturn \"\", nil, errNotCached\n+\treturn file, info, err\n }\n \n // oldVgoPrefix is the prefix in the old auto-generated cached go.mod files.\n@@ -451,7 +506,7 @@ func readDiskCache(path, rev, suffix string) (file string, data []byte, err erro\n \tif err != nil {\n \t\treturn \"\", nil, errNotCached\n \t}\n-\tdata, err = ioutil.ReadFile(file)\n+\tdata, err = renameio.ReadFile(file)\n \tif err != nil {\n \t\treturn file, nil, errNotCached\n \t}\n@@ -488,7 +543,7 @@ func writeDiskCache(file string, data []byte) error {\n \t\treturn err\n \t}\n \n-\tif err := renameio.WriteFile(file, data); err != nil {\n+\tif err := renameio.WriteFile(file, data, 0666); err != nil {\n \t\treturn err\n \t}\n \n@@ -545,12 +600,12 @@ func rewriteVersionList(dir string) {\n \t\tbuf.WriteString(v)\n \t\tbuf.WriteString(\"\\n\")\n \t}\n-\told, _ := ioutil.ReadFile(listFile)\n+\told, _ := renameio.ReadFile(listFile)\n \tif bytes.Equal(buf.Bytes(), old) {\n \t\treturn\n \t}\n \n-\tif err := renameio.WriteFile(listFile, buf.Bytes()); err != nil {\n+\tif err := renameio.WriteFile(listFile, buf.Bytes(), 0666); err != nil {\n \t\tbase.Fatalf(\"go: failed to write version list: %v\", err)\n \t}\n }"}, {"sha": "a4e50d692a329c8ada084dd93b30af9993b59f3b", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -79,14 +79,16 @@ type Repo interface {\n \t// nested in a single top-level directory, whose name is not specified.\n \tReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error)\n \n-\t// RecentTag returns the most recent tag at or before the given rev\n-\t// with the given prefix. It should make a best-effort attempt to\n-\t// find a tag that is a valid semantic version (following the prefix),\n-\t// or else the result is not useful to the caller, but it need not\n-\t// incur great expense in doing so. For example, the git implementation\n-\t// of RecentTag limits git's search to tags matching the glob expression\n-\t// \"v[0-9]*.[0-9]*.[0-9]*\" (after the prefix).\n-\tRecentTag(rev, prefix string) (tag string, err error)\n+\t// RecentTag returns the most recent tag on rev or one of its predecessors\n+\t// with the given prefix and major version.\n+\t// An empty major string matches any major version.\n+\tRecentTag(rev, prefix, major string) (tag string, err error)\n+\n+\t// DescendsFrom reports whether rev or any of its ancestors has the given tag.\n+\t//\n+\t// DescendsFrom must return true for any tag returned by RecentTag for the\n+\t// same revision.\n+\tDescendsFrom(rev, tag string) (bool, error)\n }\n \n // A Rev describes a single revision in a source code repository.\n@@ -105,6 +107,32 @@ type FileRev struct {\n \tErr  error  // error if any; os.IsNotExist(Err)==true if rev exists but file does not exist in that rev\n }\n \n+// UnknownRevisionError is an error equivalent to os.ErrNotExist, but for a\n+// revision rather than a file.\n+type UnknownRevisionError struct {\n+\tRev string\n+}\n+\n+func (e *UnknownRevisionError) Error() string {\n+\treturn \"unknown revision \" + e.Rev\n+}\n+func (UnknownRevisionError) Is(err error) bool {\n+\treturn err == os.ErrNotExist\n+}\n+\n+// ErrNoCommits is an error equivalent to os.ErrNotExist indicating that a given\n+// repository or module contains no commits.\n+var ErrNoCommits error = noCommitsError{}\n+\n+type noCommitsError struct{}\n+\n+func (noCommitsError) Error() string {\n+\treturn \"no commits\"\n+}\n+func (noCommitsError) Is(err error) bool {\n+\treturn err == os.ErrNotExist\n+}\n+\n // AllHex reports whether the revision rev is entirely lower-case hexadecimal digits.\n func AllHex(rev string) bool {\n \tfor i := 0; i < len(rev); i++ {"}, {"sha": "d382e8ac9a9232c7ff5f7ac006eb39918ccabf66", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 134, "deletions": 29, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"os/exec\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strconv\"\n@@ -19,6 +20,7 @@ import (\n \n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/semver\"\n )\n \n // GitRepo returns the code repository at the given Git remote reference.\n@@ -32,7 +34,7 @@ func LocalGitRepo(remote string) (Repo, error) {\n \treturn newGitRepoCached(remote, true)\n }\n \n-const gitWorkDirType = \"git2\"\n+const gitWorkDirType = \"git3\"\n \n var gitRepoCache par.Cache\n \n@@ -79,7 +81,7 @@ func newGitRepo(remote string, localOK bool) (Repo, error) {\n \t\t\t// but this lets us say git fetch origin instead, which\n \t\t\t// is a little nicer. More importantly, using a named remote\n \t\t\t// avoids a problem with Git LFS. See golang.org/issue/25605.\n-\t\t\tif _, err := Run(r.dir, \"git\", \"remote\", \"add\", \"origin\", r.remote); err != nil {\n+\t\t\tif _, err := Run(r.dir, \"git\", \"remote\", \"add\", \"origin\", \"--\", r.remote); err != nil {\n \t\t\t\tos.RemoveAll(r.dir)\n \t\t\t\treturn nil, err\n \t\t\t}\n@@ -122,8 +124,10 @@ type gitRepo struct {\n \tstatCache par.Cache\n \n \trefsOnce sync.Once\n-\trefs     map[string]string\n-\trefsErr  error\n+\t// refs maps branch and tag refs (e.g., \"HEAD\", \"refs/heads/master\")\n+\t// to commits (e.g., \"37ffd2e798afde829a34e8955b716ab730b2a6d6\")\n+\trefs    map[string]string\n+\trefsErr error\n \n \tlocalTagsOnce sync.Once\n \tlocalTags     map[string]bool\n@@ -166,7 +170,7 @@ func (r *gitRepo) loadRefs() {\n \tif err != nil {\n \t\tif rerr, ok := err.(*RunError); ok {\n \t\t\tif bytes.Contains(rerr.Stderr, []byte(\"fatal: could not read Username\")) {\n-\t\t\t\trerr.HelpText = \"If this is a private repository, see https://golang.org/doc/faq#git_https for additional information.\"\n+\t\t\t\trerr.HelpText = \"Confirm the import path was entered correctly.\\nIf this is a private repository, see https://golang.org/doc/faq#git_https for additional information.\"\n \t\t\t}\n \t\t}\n \t\tr.refsErr = err\n@@ -218,7 +222,7 @@ func (r *gitRepo) Latest() (*RevInfo, error) {\n \t\treturn nil, r.refsErr\n \t}\n \tif r.refs[\"HEAD\"] == \"\" {\n-\t\treturn nil, fmt.Errorf(\"no commits\")\n+\t\treturn nil, ErrNoCommits\n \t}\n \treturn r.Stat(r.refs[\"HEAD\"])\n }\n@@ -315,7 +319,7 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t\t\thash = rev\n \t\t}\n \t} else {\n-\t\treturn nil, fmt.Errorf(\"unknown revision %s\", rev)\n+\t\treturn nil, &UnknownRevisionError{Rev: rev}\n \t}\n \n \t// Protect r.fetchLevel and the \"fetch more and more\" sequence.\n@@ -339,8 +343,14 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \t\t}\n \t}\n \n-\t// If we know a specific commit we need, fetch it.\n-\tif r.fetchLevel <= fetchSome && hash != \"\" && !r.local {\n+\t// If we know a specific commit we need and its ref, fetch it.\n+\t// We do NOT fetch arbitrary hashes (when we don't know the ref)\n+\t// because we want to avoid ever importing a commit that isn't\n+\t// reachable from refs/tags/* or refs/heads/* or HEAD.\n+\t// Both Gerrit and GitHub expose every CL/PR as a named ref,\n+\t// and we don't want those commits masquerading as being real\n+\t// pseudo-versions in the main repo.\n+\tif r.fetchLevel <= fetchSome && ref != \"\" && hash != \"\" && !r.local {\n \t\tr.fetchLevel = fetchSome\n \t\tvar refspec string\n \t\tif ref != \"\" && ref != \"HEAD\" {\n@@ -369,17 +379,30 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n \n \t// Last resort.\n \t// Fetch all heads and tags and hope the hash we want is in the history.\n+\tif err := r.fetchRefsLocked(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn r.statLocal(rev, rev)\n+}\n+\n+// fetchRefsLocked fetches all heads and tags from the origin, along with the\n+// ancestors of those commits.\n+//\n+// We only fetch heads and tags, not arbitrary other commits: we don't want to\n+// pull in off-branch commits (such as rejected GitHub pull requests) that the\n+// server may be willing to provide. (See the comments within the stat method\n+// for more detail.)\n+//\n+// fetchRefsLocked requires that r.mu remain locked for the duration of the call.\n+func (r *gitRepo) fetchRefsLocked() error {\n \tif r.fetchLevel < fetchAll {\n-\t\t// TODO(bcmills): should we wait to upgrade fetchLevel until after we check\n-\t\t// err? If there is a temporary server error, we want subsequent fetches to\n-\t\t// try again instead of proceeding with an incomplete repo.\n-\t\tr.fetchLevel = fetchAll\n \t\tif err := r.fetchUnshallow(\"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n-\t\t\treturn nil, err\n+\t\t\treturn err\n \t\t}\n+\t\tr.fetchLevel = fetchAll\n \t}\n-\n-\treturn r.statLocal(rev, rev)\n+\treturn nil\n }\n \n func (r *gitRepo) fetchUnshallow(refSpecs ...string) error {\n@@ -400,9 +423,9 @@ func (r *gitRepo) fetchUnshallow(refSpecs ...string) error {\n // statLocal returns a RevInfo describing rev in the local git repository.\n // It uses version as info.Version.\n func (r *gitRepo) statLocal(version, rev string) (*RevInfo, error) {\n-\tout, err := Run(r.dir, \"git\", \"-c\", \"log.showsignature=false\", \"log\", \"-n1\", \"--format=format:%H %ct %D\", rev)\n+\tout, err := Run(r.dir, \"git\", \"-c\", \"log.showsignature=false\", \"log\", \"-n1\", \"--format=format:%H %ct %D\", rev, \"--\")\n \tif err != nil {\n-\t\treturn nil, fmt.Errorf(\"unknown revision %s\", rev)\n+\t\treturn nil, &UnknownRevisionError{Rev: rev}\n \t}\n \tf := strings.Fields(string(out))\n \tif len(f) < 2 {\n@@ -639,23 +662,48 @@ func (r *gitRepo) readFileRevs(tags []string, file string, fileMap map[string]*F\n \treturn missing, nil\n }\n \n-func (r *gitRepo) RecentTag(rev, prefix string) (tag string, err error) {\n+func (r *gitRepo) RecentTag(rev, prefix, major string) (tag string, err error) {\n \tinfo, err := r.Stat(rev)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n \trev = info.Name // expand hash prefixes\n \n-\t// describe sets tag and err using 'git describe' and reports whether the\n+\t// describe sets tag and err using 'git for-each-ref' and reports whether the\n \t// result is definitive.\n \tdescribe := func() (definitive bool) {\n \t\tvar out []byte\n-\t\tout, err = Run(r.dir, \"git\", \"describe\", \"--first-parent\", \"--always\", \"--abbrev=0\", \"--match\", prefix+\"v[0-9]*.[0-9]*.[0-9]*\", \"--tags\", rev)\n+\t\tout, err = Run(r.dir, \"git\", \"for-each-ref\", \"--format\", \"%(refname)\", \"refs/tags\", \"--merged\", rev)\n \t\tif err != nil {\n-\t\t\treturn true // Because we use \"--always\", describe should never fail.\n+\t\t\treturn true\n+\t\t}\n+\n+\t\t// prefixed tags aren't valid semver tags so compare without prefix, but only tags with correct prefix\n+\t\tvar highest string\n+\t\tfor _, line := range strings.Split(string(out), \"\\n\") {\n+\t\t\tline = strings.TrimSpace(line)\n+\t\t\t// git do support lstrip in for-each-ref format, but it was added in v2.13.0. Stripping here\n+\t\t\t// instead gives support for git v2.7.0.\n+\t\t\tif !strings.HasPrefix(line, \"refs/tags/\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tline = line[len(\"refs/tags/\"):]\n+\n+\t\t\tif !strings.HasPrefix(line, prefix) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tsemtag := line[len(prefix):]\n+\t\t\t// Consider only tags that are valid and complete (not just major.minor prefixes).\n+\t\t\tif c := semver.Canonical(semtag); c != \"\" && strings.HasPrefix(semtag, c) && (major == \"\" || semver.Major(c) == major) {\n+\t\t\t\thighest = semver.Max(highest, semtag)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif highest != \"\" {\n+\t\t\ttag = prefix + highest\n \t\t}\n \n-\t\ttag = string(bytes.TrimSpace(out))\n \t\treturn tag != \"\" && !AllHex(tag)\n \t}\n \n@@ -682,12 +730,8 @@ func (r *gitRepo) RecentTag(rev, prefix string) (tag string, err error) {\n \t}\n \tdefer unlock()\n \n-\tif r.fetchLevel < fetchAll {\n-\t\t// Fetch all heads and tags and see if that gives us enough history.\n-\t\tif err := r.fetchUnshallow(\"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t\tr.fetchLevel = fetchAll\n+\tif err := r.fetchRefsLocked(); err != nil {\n+\t\treturn \"\", err\n \t}\n \n \t// If we've reached this point, we have all of the commits that are reachable\n@@ -704,6 +748,67 @@ func (r *gitRepo) RecentTag(rev, prefix string) (tag string, err error) {\n \treturn tag, err\n }\n \n+func (r *gitRepo) DescendsFrom(rev, tag string) (bool, error) {\n+\t// The \"--is-ancestor\" flag was added to \"git merge-base\" in version 1.8.0, so\n+\t// this won't work with Git 1.7.1. According to golang.org/issue/28550, cmd/go\n+\t// already doesn't work with Git 1.7.1, so at least it's not a regression.\n+\t//\n+\t// git merge-base --is-ancestor exits with status 0 if rev is an ancestor, or\n+\t// 1 if not.\n+\t_, err := Run(r.dir, \"git\", \"merge-base\", \"--is-ancestor\", \"--\", tag, rev)\n+\n+\t// Git reports \"is an ancestor\" with exit code 0 and \"not an ancestor\" with\n+\t// exit code 1.\n+\t// Unfortunately, if we've already fetched rev with a shallow history, git\n+\t// merge-base has been observed to report a false-negative, so don't stop yet\n+\t// even if the exit code is 1!\n+\tif err == nil {\n+\t\treturn true, nil\n+\t}\n+\n+\t// See whether the tag and rev even exist.\n+\ttags, err := r.Tags(tag)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tif len(tags) == 0 {\n+\t\treturn false, nil\n+\t}\n+\n+\t// NOTE: r.stat is very careful not to fetch commits that we shouldn't know\n+\t// about, like rejected GitHub pull requests, so don't try to short-circuit\n+\t// that here.\n+\tif _, err = r.stat(rev); err != nil {\n+\t\treturn false, err\n+\t}\n+\n+\t// Now fetch history so that git can search for a path.\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tdefer unlock()\n+\n+\tif r.fetchLevel < fetchAll {\n+\t\t// Fetch the complete history for all refs and heads. It would be more\n+\t\t// efficient to only fetch the history from rev to tag, but that's much more\n+\t\t// complicated, and any kind of shallow fetch is fairly likely to trigger\n+\t\t// bugs in JGit servers and/or the go command anyway.\n+\t\tif err := r.fetchRefsLocked(); err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t}\n+\n+\t_, err = Run(r.dir, \"git\", \"merge-base\", \"--is-ancestor\", \"--\", tag, rev)\n+\tif err == nil {\n+\t\treturn true, nil\n+\t}\n+\tif ee, ok := err.(*RunError).Err.(*exec.ExitError); ok && ee.ExitCode() == 1 {\n+\t\treturn false, nil\n+\t}\n+\treturn false, err\n+}\n+\n func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n \t// TODO: Use maxSize or drop it.\n \targs := []string{}"}, {"sha": "b1845f5c65067691ee6edc3bcd2f107c7c3e420e", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -7,11 +7,11 @@ package codehost\n import (\n \t\"encoding/xml\"\n \t\"fmt\"\n+\t\"internal/lazyregexp\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n-\t\"regexp\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n@@ -29,8 +29,9 @@ import (\n // The caller should report this error instead of continuing to probe\n // other possible module paths.\n //\n-// TODO(bcmills): See if we can invert this. (Return a distinguished error for\n-// \u201crepo not found\u201d and treat everything else as terminal.)\n+// TODO(golang.org/issue/31730): See if we can invert this. (Return a\n+// distinguished error for \u201crepo not found\u201d and treat everything else\n+// as terminal.)\n type VCSError struct {\n \tErr error\n }\n@@ -124,10 +125,10 @@ type vcsCmd struct {\n \tvcs           string                                            // vcs name \"hg\"\n \tinit          func(remote string) []string                      // cmd to init repo to track remote\n \ttags          func(remote string) []string                      // cmd to list local tags\n-\ttagRE         *regexp.Regexp                                    // regexp to extract tag names from output of tags cmd\n+\ttagRE         *lazyregexp.Regexp                                // regexp to extract tag names from output of tags cmd\n \tbranches      func(remote string) []string                      // cmd to list local branches\n-\tbranchRE      *regexp.Regexp                                    // regexp to extract branch names from output of tags cmd\n-\tbadLocalRevRE *regexp.Regexp                                    // regexp of names that must not be served out of local cache without doing fetch first\n+\tbranchRE      *lazyregexp.Regexp                                // regexp to extract branch names from output of tags cmd\n+\tbadLocalRevRE *lazyregexp.Regexp                                // regexp of names that must not be served out of local cache without doing fetch first\n \tstatLocal     func(rev, remote string) []string                 // cmd to stat local rev\n \tparseStat     func(rev, out string) (*RevInfo, error)           // cmd to parse output of statLocal\n \tfetch         []string                                          // cmd to fetch everything from remote\n@@ -136,13 +137,13 @@ type vcsCmd struct {\n \treadZip       func(rev, subdir, remote, target string) []string // cmd to read rev's subdir as zip file\n }\n \n-var re = regexp.MustCompile\n+var re = lazyregexp.New\n \n var vcsCmds = map[string]*vcsCmd{\n \t\"hg\": {\n \t\tvcs: \"hg\",\n \t\tinit: func(remote string) []string {\n-\t\t\treturn []string{\"hg\", \"clone\", \"-U\", remote, \".\"}\n+\t\t\treturn []string{\"hg\", \"clone\", \"-U\", \"--\", remote, \".\"}\n \t\t},\n \t\ttags: func(remote string) []string {\n \t\t\treturn []string{\"hg\", \"tags\", \"-q\"}\n@@ -167,36 +168,36 @@ var vcsCmds = map[string]*vcsCmd{\n \t\t\tif subdir != \"\" {\n \t\t\t\tpattern = []string{\"-I\", subdir + \"/**\"}\n \t\t\t}\n-\t\t\treturn str.StringList(\"hg\", \"archive\", \"-t\", \"zip\", \"--no-decode\", \"-r\", rev, \"--prefix=prefix/\", pattern, target)\n+\t\t\treturn str.StringList(\"hg\", \"archive\", \"-t\", \"zip\", \"--no-decode\", \"-r\", rev, \"--prefix=prefix/\", pattern, \"--\", target)\n \t\t},\n \t},\n \n \t\"svn\": {\n \t\tvcs:  \"svn\",\n \t\tinit: nil, // no local checkout\n \t\ttags: func(remote string) []string {\n-\t\t\treturn []string{\"svn\", \"list\", strings.TrimSuffix(remote, \"/trunk\") + \"/tags\"}\n+\t\t\treturn []string{\"svn\", \"list\", \"--\", strings.TrimSuffix(remote, \"/trunk\") + \"/tags\"}\n \t\t},\n \t\ttagRE: re(`(?m)^(.*?)/?$`),\n \t\tstatLocal: func(rev, remote string) []string {\n \t\t\tsuffix := \"@\" + rev\n \t\t\tif rev == \"latest\" {\n \t\t\t\tsuffix = \"\"\n \t\t\t}\n-\t\t\treturn []string{\"svn\", \"log\", \"-l1\", \"--xml\", remote + suffix}\n+\t\t\treturn []string{\"svn\", \"log\", \"-l1\", \"--xml\", \"--\", remote + suffix}\n \t\t},\n \t\tparseStat: svnParseStat,\n \t\tlatest:    \"latest\",\n \t\treadFile: func(rev, file, remote string) []string {\n-\t\t\treturn []string{\"svn\", \"cat\", remote + \"/\" + file + \"@\" + rev}\n+\t\t\treturn []string{\"svn\", \"cat\", \"--\", remote + \"/\" + file + \"@\" + rev}\n \t\t},\n \t\t// TODO: zip\n \t},\n \n \t\"bzr\": {\n \t\tvcs: \"bzr\",\n \t\tinit: func(remote string) []string {\n-\t\t\treturn []string{\"bzr\", \"branch\", \"--use-existing-dir\", remote, \".\"}\n+\t\t\treturn []string{\"bzr\", \"branch\", \"--use-existing-dir\", \"--\", remote, \".\"}\n \t\t},\n \t\tfetch: []string{\n \t\t\t\"bzr\", \"pull\", \"--overwrite-tags\",\n@@ -219,14 +220,14 @@ var vcsCmds = map[string]*vcsCmd{\n \t\t\tif subdir != \"\" {\n \t\t\t\textra = []string{\"./\" + subdir}\n \t\t\t}\n-\t\t\treturn str.StringList(\"bzr\", \"export\", \"--format=zip\", \"-r\", rev, \"--root=prefix/\", target, extra)\n+\t\t\treturn str.StringList(\"bzr\", \"export\", \"--format=zip\", \"-r\", rev, \"--root=prefix/\", \"--\", target, extra)\n \t\t},\n \t},\n \n \t\"fossil\": {\n \t\tvcs: \"fossil\",\n \t\tinit: func(remote string) []string {\n-\t\t\treturn []string{\"fossil\", \"clone\", remote, \".fossil\"}\n+\t\t\treturn []string{\"fossil\", \"clone\", \"--\", remote, \".fossil\"}\n \t\t},\n \t\tfetch: []string{\"fossil\", \"pull\", \"-R\", \".fossil\"},\n \t\ttags: func(remote string) []string {\n@@ -248,7 +249,7 @@ var vcsCmds = map[string]*vcsCmd{\n \t\t\t}\n \t\t\t// Note that vcsRepo.ReadZip below rewrites this command\n \t\t\t// to run in a different directory, to work around a fossil bug.\n-\t\t\treturn str.StringList(\"fossil\", \"zip\", \"-R\", \".fossil\", \"--name\", \"prefix\", extra, rev, target)\n+\t\t\treturn str.StringList(\"fossil\", \"zip\", \"-R\", \".fossil\", \"--name\", \"prefix\", extra, \"--\", rev, target)\n \t\t},\n \t},\n }\n@@ -346,7 +347,7 @@ func (r *vcsRepo) fetch() {\n func (r *vcsRepo) statLocal(rev string) (*RevInfo, error) {\n \tout, err := Run(r.dir, r.cmd.statLocal(rev, r.remote))\n \tif err != nil {\n-\t\treturn nil, vcsErrorf(\"unknown revision %s\", rev)\n+\t\treturn nil, &UnknownRevisionError{Rev: rev}\n \t}\n \treturn r.cmd.parseStat(rev, string(out))\n }\n@@ -391,7 +392,7 @@ func (r *vcsRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[s\n \treturn nil, vcsErrorf(\"ReadFileRevs not implemented\")\n }\n \n-func (r *vcsRepo) RecentTag(rev, prefix string) (tag string, err error) {\n+func (r *vcsRepo) RecentTag(rev, prefix, major string) (tag string, err error) {\n \t// We don't technically need to lock here since we're returning an error\n \t// uncondititonally, but doing so anyway will help to avoid baking in\n \t// lock-inversion bugs.\n@@ -404,6 +405,16 @@ func (r *vcsRepo) RecentTag(rev, prefix string) (tag string, err error) {\n \treturn \"\", vcsErrorf(\"RecentTag not implemented\")\n }\n \n+func (r *vcsRepo) DescendsFrom(rev, tag string) (bool, error) {\n+\tunlock, err := r.mu.Lock()\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tdefer unlock()\n+\n+\treturn false, vcsErrorf(\"DescendsFrom not implemented\")\n+}\n+\n func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n \tif r.cmd.readZip == nil {\n \t\treturn nil, \"\", vcsErrorf(\"ReadZip not implemented for %s\", r.cmd.vcs)"}, {"sha": "267b76349dd49b2590a140fe4843adecc4ec5326", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 365, "deletions": 62, "changes": 427, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,12 +6,14 @@ package modfetch\n \n import (\n \t\"archive/zip\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/modfile\"\n@@ -42,12 +44,10 @@ type codeRepo struct {\n \t// It is used only for logging.\n \tpathPrefix string\n \n-\t// pseudoMajor is the major version prefix to use when generating\n-\t// pseudo-versions for this module, derived from the module path.\n-\t//\n-\t// TODO(golang.org/issue/29262): We can't distinguish v0 from v1 using the\n-\t// path alone: we have to compute it by examining the tags at a particular\n-\t// revision.\n+\t// pseudoMajor is the major version prefix to require when generating\n+\t// pseudo-versions for this module, derived from the module path. pseudoMajor\n+\t// is empty if the module path does not include a version suffix (that is,\n+\t// accepts either v0 or v1).\n \tpseudoMajor string\n }\n \n@@ -65,10 +65,7 @@ func newCodeRepo(code codehost.Repo, codeRoot, path string) (Repo, error) {\n \tif codeRoot == path {\n \t\tpathPrefix = path\n \t}\n-\tpseudoMajor := \"v0\"\n-\tif pathMajor != \"\" {\n-\t\tpseudoMajor = pathMajor[1:]\n-\t}\n+\tpseudoMajor := module.PathMajorPrefix(pathMajor)\n \n \t// Compute codeDir = bar, the subdirectory within the repo\n \t// corresponding to the module root.\n@@ -159,7 +156,7 @@ func (r *codeRepo) Versions(prefix string) ([]string, error) {\n \t\tif v == \"\" || v != module.CanonicalVersion(v) || IsPseudoVersion(v) {\n \t\t\tcontinue\n \t\t}\n-\t\tif !module.MatchPathMajor(v, r.pathMajor) {\n+\t\tif err := module.MatchPathMajor(v, r.pathMajor); err != nil {\n \t\t\tif r.codeDir == \"\" && r.pathMajor == \"\" && semver.Major(v) > \"v1\" {\n \t\t\t\tincompatible = append(incompatible, v)\n \t\t\t}\n@@ -208,86 +205,340 @@ func (r *codeRepo) Latest() (*RevInfo, error) {\n \treturn r.convert(info, \"\")\n }\n \n+// convert converts a version as reported by the code host to a version as\n+// interpreted by the module system.\n+//\n+// If statVers is a valid module version, it is used for the Version field.\n+// Otherwise, the Version is derived from the passed-in info and recent tags.\n func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, error) {\n \tinfo2 := &RevInfo{\n \t\tName:  info.Name,\n \t\tShort: info.Short,\n \t\tTime:  info.Time,\n \t}\n \n-\t// Determine version.\n-\tif module.CanonicalVersion(statVers) == statVers && module.MatchPathMajor(statVers, r.pathMajor) {\n-\t\t// The original call was repo.Stat(statVers), and requestedVersion is OK, so use it.\n-\t\tinfo2.Version = statVers\n-\t} else {\n-\t\t// Otherwise derive a version from a code repo tag.\n-\t\t// Tag must have a prefix matching codeDir.\n-\t\tp := \"\"\n-\t\tif r.codeDir != \"\" {\n-\t\t\tp = r.codeDir + \"/\"\n-\t\t}\n-\n-\t\t// If this is a plain tag (no dir/ prefix)\n-\t\t// and the module path is unversioned,\n-\t\t// and if the underlying file tree has no go.mod,\n-\t\t// then allow using the tag with a +incompatible suffix.\n-\t\tcanUseIncompatible := false\n+\t// If this is a plain tag (no dir/ prefix)\n+\t// and the module path is unversioned,\n+\t// and if the underlying file tree has no go.mod,\n+\t// then allow using the tag with a +incompatible suffix.\n+\tvar canUseIncompatible func() bool\n+\tcanUseIncompatible = func() bool {\n+\t\tvar ok bool\n \t\tif r.codeDir == \"\" && r.pathMajor == \"\" {\n \t\t\t_, errGoMod := r.code.ReadFile(info.Name, \"go.mod\", codehost.MaxGoMod)\n \t\t\tif errGoMod != nil {\n-\t\t\t\tcanUseIncompatible = true\n+\t\t\t\tok = true\n+\t\t\t}\n+\t\t}\n+\t\tcanUseIncompatible = func() bool { return ok }\n+\t\treturn ok\n+\t}\n+\n+\tinvalidf := func(format string, args ...interface{}) error {\n+\t\treturn &module.ModuleError{\n+\t\t\tPath: r.modPath,\n+\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\tVersion: info2.Version,\n+\t\t\t\tErr:     fmt.Errorf(format, args...),\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\t// checkGoMod verifies that the go.mod file for the module exists or does not\n+\t// exist as required by info2.Version and the module path represented by r.\n+\tcheckGoMod := func() (*RevInfo, error) {\n+\t\t// If r.codeDir is non-empty, then the go.mod file must exist: the module\n+\t\t// author, not the module consumer, gets to decide how to carve up the repo\n+\t\t// into modules.\n+\t\tif r.codeDir != \"\" {\n+\t\t\t_, _, _, err := r.findDir(info2.Version)\n+\t\t\tif err != nil {\n+\t\t\t\t// TODO: It would be nice to return an error like \"not a module\".\n+\t\t\t\t// Right now we return \"missing go.mod\", which is a little confusing.\n+\t\t\t\treturn nil, &module.ModuleError{\n+\t\t\t\t\tPath: r.modPath,\n+\t\t\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\t\t\tVersion: info2.Version,\n+\t\t\t\t\t\tErr:     notExistError(err.Error()),\n+\t\t\t\t\t},\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n-\t\ttagToVersion := func(v string) string {\n-\t\t\tif !strings.HasPrefix(v, p) {\n-\t\t\t\treturn \"\"\n+\t\t// If the version is +incompatible, then the go.mod file must not exist:\n+\t\t// +incompatible is not an ongoing opt-out from semantic import versioning.\n+\t\tif strings.HasSuffix(info2.Version, \"+incompatible\") {\n+\t\t\tif !canUseIncompatible() {\n+\t\t\t\tif r.pathMajor != \"\" {\n+\t\t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: module path includes a major version suffix, so major version must match\")\n+\t\t\t\t} else {\n+\t\t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: module contains a go.mod file, so semantic import versioning is required\")\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tv = v[len(p):]\n-\t\t\tif module.CanonicalVersion(v) != v || IsPseudoVersion(v) {\n-\t\t\t\treturn \"\"\n+\n+\t\t\tif err := module.MatchPathMajor(strings.TrimSuffix(info2.Version, \"+incompatible\"), r.pathMajor); err == nil {\n+\t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: major version %s is compatible\", semver.Major(info2.Version))\n \t\t\t}\n-\t\t\tif module.MatchPathMajor(v, r.pathMajor) {\n-\t\t\t\treturn v\n+\t\t}\n+\n+\t\treturn info2, nil\n+\t}\n+\n+\t// Determine version.\n+\t//\n+\t// If statVers is canonical, then the original call was repo.Stat(statVers).\n+\t// Since the version is canonical, we must not resolve it to anything but\n+\t// itself, possibly with a '+incompatible' annotation: we do not need to do\n+\t// the work required to look for an arbitrary pseudo-version.\n+\tif statVers != \"\" && statVers == module.CanonicalVersion(statVers) {\n+\t\tinfo2.Version = statVers\n+\n+\t\tif IsPseudoVersion(info2.Version) {\n+\t\t\tif err := r.validatePseudoVersion(info, info2.Version); err != nil {\n+\t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\tif canUseIncompatible {\n-\t\t\t\treturn v + \"+incompatible\"\n+\t\t\treturn checkGoMod()\n+\t\t}\n+\n+\t\tif err := module.MatchPathMajor(info2.Version, r.pathMajor); err != nil {\n+\t\t\tif canUseIncompatible() {\n+\t\t\t\tinfo2.Version += \"+incompatible\"\n+\t\t\t\treturn checkGoMod()\n+\t\t\t} else {\n+\t\t\t\tif vErr, ok := err.(*module.InvalidVersionError); ok {\n+\t\t\t\t\t// We're going to describe why the version is invalid in more detail,\n+\t\t\t\t\t// so strip out the existing \u201cinvalid version\u201d wrapper.\n+\t\t\t\t\terr = vErr.Err\n+\t\t\t\t}\n+\t\t\t\treturn nil, invalidf(\"module contains a go.mod file, so major version must be compatible: %v\", err)\n \t\t\t}\n-\t\t\treturn \"\"\n \t\t}\n \n-\t\t// If info.Version is OK, use it.\n-\t\tif v := tagToVersion(info.Version); v != \"\" {\n-\t\t\tinfo2.Version = v\n-\t\t} else {\n-\t\t\t// Otherwise look through all known tags for latest in semver ordering.\n-\t\t\tfor _, tag := range info.Tags {\n-\t\t\t\tif v := tagToVersion(tag); v != \"\" && semver.Compare(info2.Version, v) < 0 {\n+\t\treturn checkGoMod()\n+\t}\n+\n+\t// statVers is empty or non-canonical, so we need to resolve it to a canonical\n+\t// version or pseudo-version.\n+\n+\t// Derive or verify a version from a code repo tag.\n+\t// Tag must have a prefix matching codeDir.\n+\ttagPrefix := \"\"\n+\tif r.codeDir != \"\" {\n+\t\ttagPrefix = r.codeDir + \"/\"\n+\t}\n+\n+\t// tagToVersion returns the version obtained by trimming tagPrefix from tag.\n+\t// If the tag is invalid or a pseudo-version, tagToVersion returns an empty\n+\t// version.\n+\ttagToVersion := func(tag string) (v string, tagIsCanonical bool) {\n+\t\tif !strings.HasPrefix(tag, tagPrefix) {\n+\t\t\treturn \"\", false\n+\t\t}\n+\t\ttrimmed := tag[len(tagPrefix):]\n+\t\t// Tags that look like pseudo-versions would be confusing. Ignore them.\n+\t\tif IsPseudoVersion(tag) {\n+\t\t\treturn \"\", false\n+\t\t}\n+\n+\t\tv = semver.Canonical(trimmed) // Not module.Canonical: we don't want to pick up an explicit \"+incompatible\" suffix from the tag.\n+\t\tif v == \"\" || !strings.HasPrefix(trimmed, v) {\n+\t\t\treturn \"\", false // Invalid or incomplete version (just vX or vX.Y).\n+\t\t}\n+\t\tif v == trimmed {\n+\t\t\ttagIsCanonical = true\n+\t\t}\n+\n+\t\tif err := module.MatchPathMajor(v, r.pathMajor); err != nil {\n+\t\t\tif canUseIncompatible() {\n+\t\t\t\treturn v + \"+incompatible\", tagIsCanonical\n+\t\t\t}\n+\t\t\treturn \"\", false\n+\t\t}\n+\n+\t\treturn v, tagIsCanonical\n+\t}\n+\n+\t// If the VCS gave us a valid version, use that.\n+\tif v, tagIsCanonical := tagToVersion(info.Version); tagIsCanonical {\n+\t\tinfo2.Version = v\n+\t\treturn checkGoMod()\n+\t}\n+\n+\t// Look through the tags on the revision for either a usable canonical version\n+\t// or an appropriate base for a pseudo-version.\n+\tvar pseudoBase string\n+\tfor _, pathTag := range info.Tags {\n+\t\tv, tagIsCanonical := tagToVersion(pathTag)\n+\t\tif tagIsCanonical {\n+\t\t\tif statVers != \"\" && semver.Compare(v, statVers) == 0 {\n+\t\t\t\t// The user requested a non-canonical version, but the tag for the\n+\t\t\t\t// canonical equivalent refers to the same revision. Use it.\n+\t\t\t\tinfo2.Version = v\n+\t\t\t\treturn checkGoMod()\n+\t\t\t} else {\n+\t\t\t\t// Save the highest canonical tag for the revision. If we don't find a\n+\t\t\t\t// better match, we'll use it as the canonical version.\n+\t\t\t\t//\n+\t\t\t\t// NOTE: Do not replace this with semver.Max. Despite the name,\n+\t\t\t\t// semver.Max *also* canonicalizes its arguments, which uses\n+\t\t\t\t// semver.Canonical instead of module.CanonicalVersion and thereby\n+\t\t\t\t// strips our \"+incompatible\" suffix.\n+\t\t\t\tif semver.Compare(info2.Version, v) < 0 {\n \t\t\t\t\tinfo2.Version = v\n \t\t\t\t}\n \t\t\t}\n-\t\t\t// Otherwise make a pseudo-version.\n-\t\t\tif info2.Version == \"\" {\n-\t\t\t\ttag, _ := r.code.RecentTag(statVers, p)\n-\t\t\t\tv = tagToVersion(tag)\n-\t\t\t\t// TODO: Check that v is OK for r.pseudoMajor or else is OK for incompatible.\n-\t\t\t\tinfo2.Version = PseudoVersion(r.pseudoMajor, v, info.Time, info.Short)\n+\t\t} else if v != \"\" && semver.Compare(v, statVers) == 0 {\n+\t\t\t// The user explicitly requested something equivalent to this tag. We\n+\t\t\t// can't use the version from the tag directly: since the tag is not\n+\t\t\t// canonical, it could be ambiguous. For example, tags v0.0.1+a and\n+\t\t\t// v0.0.1+b might both exist and refer to different revisions.\n+\t\t\t//\n+\t\t\t// The tag is otherwise valid for the module, so we can at least use it as\n+\t\t\t// the base of an unambiguous pseudo-version.\n+\t\t\t//\n+\t\t\t// If multiple tags match, tagToVersion will canonicalize them to the same\n+\t\t\t// base version.\n+\t\t\tpseudoBase = v\n+\t\t}\n+\t}\n+\n+\t// If we found any canonical tag for the revision, return it.\n+\t// Even if we found a good pseudo-version base, a canonical version is better.\n+\tif info2.Version != \"\" {\n+\t\treturn checkGoMod()\n+\t}\n+\n+\tif pseudoBase == \"\" {\n+\t\tvar tag string\n+\t\tif r.pseudoMajor != \"\" || canUseIncompatible() {\n+\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, r.pseudoMajor)\n+\t\t} else {\n+\t\t\t// Allow either v1 or v0, but not incompatible higher versions.\n+\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, \"v1\")\n+\t\t\tif tag == \"\" {\n+\t\t\t\ttag, _ = r.code.RecentTag(info.Name, tagPrefix, \"v0\")\n \t\t\t}\n \t\t}\n+\t\tpseudoBase, _ = tagToVersion(tag) // empty if the tag is invalid\n \t}\n \n-\t// Do not allow a successful stat of a pseudo-version for a subdirectory\n-\t// unless the subdirectory actually does have a go.mod.\n-\tif IsPseudoVersion(info2.Version) && r.codeDir != \"\" {\n-\t\t_, _, _, err := r.findDir(info2.Version)\n+\tinfo2.Version = PseudoVersion(r.pseudoMajor, pseudoBase, info.Time, info.Short)\n+\treturn checkGoMod()\n+}\n+\n+// validatePseudoVersion checks that version has a major version compatible with\n+// r.modPath and encodes a base version and commit metadata that agrees with\n+// info.\n+//\n+// Note that verifying a nontrivial base version in particular may be somewhat\n+// expensive: in order to do so, r.code.DescendsFrom will need to fetch at least\n+// enough of the commit history to find a path between version and its base.\n+// Fortunately, many pseudo-versions \u2014 such as those for untagged repositories \u2014\n+// have trivial bases!\n+func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string) (err error) {\n+\tdefer func() {\n \t\tif err != nil {\n-\t\t\t// TODO: It would be nice to return an error like \"not a module\".\n-\t\t\t// Right now we return \"missing go.mod\", which is a little confusing.\n-\t\t\treturn nil, err\n+\t\t\tif _, ok := err.(*module.ModuleError); !ok {\n+\t\t\t\tif _, ok := err.(*module.InvalidVersionError); !ok {\n+\t\t\t\t\terr = &module.InvalidVersionError{Version: version, Pseudo: true, Err: err}\n+\t\t\t\t}\n+\t\t\t\terr = &module.ModuleError{Path: r.modPath, Err: err}\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tif err := module.MatchPathMajor(version, r.pathMajor); err != nil {\n+\t\treturn err\n+\t}\n+\n+\trev, err := PseudoVersionRev(version)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif rev != info.Short {\n+\t\tswitch {\n+\t\tcase strings.HasPrefix(rev, info.Short):\n+\t\t\treturn fmt.Errorf(\"revision is longer than canonical (%s)\", info.Short)\n+\t\tcase strings.HasPrefix(info.Short, rev):\n+\t\t\treturn fmt.Errorf(\"revision is shorter than canonical (%s)\", info.Short)\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"does not match short name of revision (%s)\", info.Short)\n+\t\t}\n+\t}\n+\n+\tt, err := PseudoVersionTime(version)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif !t.Equal(info.Time.Truncate(time.Second)) {\n+\t\treturn fmt.Errorf(\"does not match version-control timestamp (%s)\", info.Time.UTC().Format(time.RFC3339))\n+\t}\n+\n+\t// A pseudo-version should have a precedence just above its parent revisions,\n+\t// and no higher. Otherwise, it would be possible for library authors to \"pin\"\n+\t// dependency versions (and bypass the usual minimum version selection) by\n+\t// naming an extremely high pseudo-version rather than an accurate one.\n+\t//\n+\t// Moreover, if we allow a pseudo-version to use any arbitrary pre-release\n+\t// tag, we end up with infinitely many possible names for each commit. Each\n+\t// name consumes resources in the module cache and proxies, so we want to\n+\t// restrict them to a finite set under control of the module author.\n+\t//\n+\t// We address both of these issues by requiring the tag upon which the\n+\t// pseudo-version is based to refer to some ancestor of the revision. We\n+\t// prefer the highest such tag when constructing a new pseudo-version, but do\n+\t// not enforce that property when resolving existing pseudo-versions: we don't\n+\t// know when the parent tags were added, and the highest-tagged parent may not\n+\t// have existed when the pseudo-version was first resolved.\n+\tbase, err := PseudoVersionBase(strings.TrimSuffix(version, \"+incompatible\"))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif base == \"\" {\n+\t\tif r.pseudoMajor == \"\" && semver.Major(version) == \"v1\" {\n+\t\t\treturn fmt.Errorf(\"major version without preceding tag must be v0, not v1\")\n \t\t}\n+\t\treturn nil\n+\t}\n+\n+\ttagPrefix := \"\"\n+\tif r.codeDir != \"\" {\n+\t\ttagPrefix = r.codeDir + \"/\"\n+\t}\n+\n+\ttags, err := r.code.Tags(tagPrefix + base)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tvar lastTag string // Prefer to log some real tag rather than a canonically-equivalent base.\n+\tancestorFound := false\n+\tfor _, tag := range tags {\n+\t\tversionOnly := strings.TrimPrefix(tag, tagPrefix)\n+\t\tif semver.Compare(versionOnly, base) == 0 {\n+\t\t\tlastTag = tag\n+\t\t\tancestorFound, err = r.code.DescendsFrom(info.Name, tag)\n+\t\t\tif ancestorFound {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif lastTag == \"\" {\n+\t\treturn fmt.Errorf(\"preceding tag (%s) not found\", base)\n \t}\n \n-\treturn info2, nil\n+\tif !ancestorFound {\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\trev, err := PseudoVersionRev(version)\n+\t\tif err != nil {\n+\t\t\treturn fmt.Errorf(\"not a descendent of preceding tag (%s)\", lastTag)\n+\t\t}\n+\t\treturn fmt.Errorf(\"revision %s is not a descendent of preceding tag (%s)\", rev, lastTag)\n+\t}\n+\treturn nil\n }\n \n func (r *codeRepo) revToRev(rev string) string {\n@@ -309,7 +560,13 @@ func (r *codeRepo) revToRev(rev string) string {\n \n func (r *codeRepo) versionToRev(version string) (rev string, err error) {\n \tif !semver.IsValid(version) {\n-\t\treturn \"\", fmt.Errorf(\"malformed semantic version %q\", version)\n+\t\treturn \"\", &module.ModuleError{\n+\t\t\tPath: r.modPath,\n+\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\tVersion: version,\n+\t\t\t\tErr:     errors.New(\"syntax error\"),\n+\t\t\t},\n+\t\t}\n \t}\n \treturn r.revToRev(version), nil\n }\n@@ -419,6 +676,21 @@ func isMajor(mpath, pathMajor string) bool {\n }\n \n func (r *codeRepo) GoMod(version string) (data []byte, err error) {\n+\tif version != module.CanonicalVersion(version) {\n+\t\treturn nil, fmt.Errorf(\"version %s is not canonical\", version)\n+\t}\n+\n+\tif IsPseudoVersion(version) {\n+\t\t// findDir ignores the metadata encoded in a pseudo-version,\n+\t\t// only using the revision at the end.\n+\t\t// Invoke Stat to verify the metadata explicitly so we don't return\n+\t\t// a bogus file for an invalid version.\n+\t\t_, err := r.Stat(version)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n \trev, dir, gomod, err := r.findDir(version)\n \tif err != nil {\n \t\treturn nil, err\n@@ -452,6 +724,21 @@ func (r *codeRepo) modPrefix(rev string) string {\n }\n \n func (r *codeRepo) Zip(dst io.Writer, version string) error {\n+\tif version != module.CanonicalVersion(version) {\n+\t\treturn fmt.Errorf(\"version %s is not canonical\", version)\n+\t}\n+\n+\tif IsPseudoVersion(version) {\n+\t\t// findDir ignores the metadata encoded in a pseudo-version,\n+\t\t// only using the revision at the end.\n+\t\t// Invoke Stat to verify the metadata explicitly so we don't return\n+\t\t// a bogus file for an invalid version.\n+\t\t_, err := r.Stat(version)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n \trev, dir, _, err := r.findDir(version)\n \tif err != nil {\n \t\treturn err\n@@ -585,6 +872,9 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \t\t\treturn err\n \t\t}\n \t\tw, err := zw.Create(r.modPrefix(version) + \"/\" + name)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\tlr := &io.LimitedReader{R: rc, N: size + 1}\n \t\tif _, err := io.Copy(w, lr); err != nil {\n \t\t\treturn err\n@@ -631,6 +921,19 @@ func isVendoredPackage(name string) bool {\n \tif strings.HasPrefix(name, \"vendor/\") {\n \t\ti += len(\"vendor/\")\n \t} else if j := strings.Index(name, \"/vendor/\"); j >= 0 {\n+\t\t// This offset looks incorrect; this should probably be\n+\t\t//\n+\t\t// \ti = j + len(\"/vendor/\")\n+\t\t//\n+\t\t// (See https://golang.org/issue/31562.)\n+\t\t//\n+\t\t// Unfortunately, we can't fix it without invalidating checksums.\n+\t\t// Fortunately, the error appears to be strictly conservative: we'll retain\n+\t\t// vendored packages that we should have pruned, but we won't prune\n+\t\t// non-vendored packages that we should have retained.\n+\t\t//\n+\t\t// Since this defect doesn't seem to break anything, it's not worth fixing\n+\t\t// for now.\n \t\ti += len(\"/vendor/\")\n \t} else {\n \t\treturn false"}, {"sha": "5fc9bc3439722abf9db56a4236c659462a959398", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 247, "deletions": 178, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -7,7 +7,6 @@ package modfetch\n import (\n \t\"archive/zip\"\n \t\"internal/testenv\"\n-\t\"io\"\n \t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n@@ -16,6 +15,7 @@ import (\n \t\"testing\"\n \t\"time\"\n \n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch/codehost\"\n )\n \n@@ -24,6 +24,14 @@ func TestMain(m *testing.M) {\n }\n \n func testMain(m *testing.M) int {\n+\tcfg.GOPROXY = \"direct\"\n+\n+\t// The sum database is populated using a released version of the go command,\n+\t// but this test may include fixes for additional modules that previously\n+\t// could not be fetched. Since this test isn't executing any of the resolved\n+\t// code, bypass the sum database.\n+\tcfg.GOSUMDB = \"off\"\n+\n \tdir, err := ioutil.TempDir(\"\", \"gitrepo-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n@@ -39,11 +47,12 @@ const (\n \tvgotest1hg  = \"vcs-test.golang.org/hg/vgotest1.hg\"\n )\n \n-var altVgotests = []string{\n-\tvgotest1hg,\n+var altVgotests = map[string]string{\n+\t\"hg\": vgotest1hg,\n }\n \n-var codeRepoTests = []struct {\n+type codeRepoTest struct {\n+\tvcs      string\n \tpath     string\n \tlookerr  string\n \tmpath    string\n@@ -57,8 +66,11 @@ var codeRepoTests = []struct {\n \tgomoderr string\n \tzip      []string\n \tziperr   string\n-}{\n+}\n+\n+var codeRepoTests = []codeRepoTest{\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n \t\trev:     \"v0.0.0\",\n \t\tversion: \"v0.0.0\",\n@@ -72,6 +84,7 @@ var codeRepoTests = []struct {\n \t\t},\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n \t\trev:     \"v1.0.0\",\n \t\tversion: \"v1.0.0\",\n@@ -85,6 +98,7 @@ var codeRepoTests = []struct {\n \t\t},\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1/v2\",\n \t\trev:     \"v2.0.0\",\n \t\tversion: \"v2.0.0\",\n@@ -94,6 +108,7 @@ var codeRepoTests = []struct {\n \t\tziperr:  \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n \t\trev:     \"80d85c5\",\n \t\tversion: \"v1.0.0\",\n@@ -107,6 +122,7 @@ var codeRepoTests = []struct {\n \t\t},\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n \t\trev:     \"mytag\",\n \t\tversion: \"v1.0.0\",\n@@ -120,6 +136,7 @@ var codeRepoTests = []struct {\n \t\t},\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1/v2\",\n \t\trev:      \"45f53230a\",\n \t\tversion:  \"v2.0.0\",\n@@ -130,6 +147,7 @@ var codeRepoTests = []struct {\n \t\tziperr:   \"missing github.com/rsc/vgotest1/go.mod and .../v2/go.mod at revision v2.0.0\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1/v54321\",\n \t\trev:     \"80d85c5\",\n \t\tversion: \"v54321.0.0-20180219231006-80d85c5d4d17\",\n@@ -139,16 +157,19 @@ var codeRepoTests = []struct {\n \t\tziperr:  \"missing github.com/rsc/vgotest1/go.mod and .../v54321/go.mod at revision 80d85c5d4d17\",\n \t},\n \t{\n+\t\tvcs:  \"git\",\n \t\tpath: \"github.com/rsc/vgotest1/submod\",\n \t\trev:  \"v1.0.0\",\n \t\terr:  \"unknown revision submod/v1.0.0\",\n \t},\n \t{\n+\t\tvcs:  \"git\",\n \t\tpath: \"github.com/rsc/vgotest1/submod\",\n \t\trev:  \"v1.0.3\",\n \t\terr:  \"unknown revision submod/v1.0.3\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1/submod\",\n \t\trev:     \"v1.0.4\",\n \t\tversion: \"v1.0.4\",\n@@ -163,6 +184,7 @@ var codeRepoTests = []struct {\n \t\t},\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n \t\trev:     \"v1.1.0\",\n \t\tversion: \"v1.1.0\",\n@@ -178,6 +200,7 @@ var codeRepoTests = []struct {\n \t\t},\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1/v2\",\n \t\trev:     \"v2.0.1\",\n \t\tversion: \"v2.0.1\",\n@@ -187,6 +210,7 @@ var codeRepoTests = []struct {\n \t\tgomod:   \"module \\\"github.com/rsc/vgotest1/v2\\\" // root go.mod\\n\",\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1/v2\",\n \t\trev:      \"v2.0.3\",\n \t\tversion:  \"v2.0.3\",\n@@ -196,6 +220,7 @@ var codeRepoTests = []struct {\n \t\tgomoderr: \"github.com/rsc/vgotest1/v2/go.mod has non-.../v2 module path \\\"github.com/rsc/vgotest\\\" at revision v2.0.3\",\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1/v2\",\n \t\trev:      \"v2.0.4\",\n \t\tversion:  \"v2.0.4\",\n@@ -205,6 +230,7 @@ var codeRepoTests = []struct {\n \t\tgomoderr: \"github.com/rsc/vgotest1/go.mod and .../v2/go.mod both have .../v2 module paths at revision v2.0.4\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1/v2\",\n \t\trev:     \"v2.0.5\",\n \t\tversion: \"v2.0.5\",\n@@ -215,6 +241,7 @@ var codeRepoTests = []struct {\n \t},\n \t{\n \t\t// redirect to github\n+\t\tvcs:     \"git\",\n \t\tpath:    \"rsc.io/quote\",\n \t\trev:     \"v1.0.0\",\n \t\tversion: \"v1.0.0\",\n@@ -225,6 +252,7 @@ var codeRepoTests = []struct {\n \t},\n \t{\n \t\t// redirect to static hosting proxy\n+\t\tvcs:     \"mod\",\n \t\tpath:    \"swtch.com/testmod\",\n \t\trev:     \"v1.0.0\",\n \t\tversion: \"v1.0.0\",\n@@ -234,6 +262,7 @@ var codeRepoTests = []struct {\n \t},\n \t{\n \t\t// redirect to googlesource\n+\t\tvcs:     \"git\",\n \t\tpath:    \"golang.org/x/text\",\n \t\trev:     \"4e4a3210bb\",\n \t\tversion: \"v0.3.1-0.20180208041248-4e4a3210bb54\",\n@@ -242,6 +271,7 @@ var codeRepoTests = []struct {\n \t\ttime:    time.Date(2018, 2, 8, 4, 12, 48, 0, time.UTC),\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/pkg/errors\",\n \t\trev:     \"v0.8.0\",\n \t\tversion: \"v0.8.0\",\n@@ -253,17 +283,20 @@ var codeRepoTests = []struct {\n \t\t// package in subdirectory - custom domain\n \t\t// In general we can't reject these definitively in Lookup,\n \t\t// but gopkg.in is special.\n+\t\tvcs:     \"git\",\n \t\tpath:    \"gopkg.in/yaml.v2/abc\",\n \t\tlookerr: \"invalid module path \\\"gopkg.in/yaml.v2/abc\\\"\",\n \t},\n \t{\n \t\t// package in subdirectory - github\n \t\t// Because it's a package, Stat should fail entirely.\n+\t\tvcs:  \"git\",\n \t\tpath: \"github.com/rsc/quote/buggy\",\n \t\trev:  \"c4d4236f\",\n \t\terr:  \"missing github.com/rsc/quote/buggy/go.mod at revision c4d4236f9242\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"gopkg.in/yaml.v2\",\n \t\trev:     \"d670f940\",\n \t\tversion: \"v2.0.0\",\n@@ -273,6 +306,7 @@ var codeRepoTests = []struct {\n \t\tgomod:   \"module gopkg.in/yaml.v2\\n\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"gopkg.in/check.v1\",\n \t\trev:     \"20d25e280405\",\n \t\tversion: \"v1.0.0-20161208181325-20d25e280405\",\n@@ -282,15 +316,17 @@ var codeRepoTests = []struct {\n \t\tgomod:   \"module gopkg.in/check.v1\\n\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"gopkg.in/yaml.v2\",\n \t\trev:     \"v2\",\n-\t\tversion: \"v2.2.2\",\n-\t\tname:    \"51d6538a90f86fe93ac480b35f37b2be17fef232\",\n-\t\tshort:   \"51d6538a90f8\",\n-\t\ttime:    time.Date(2018, 11, 15, 11, 05, 04, 0, time.UTC),\n+\t\tversion: \"v2.2.3-0.20190319135612-7b8349ac747c\",\n+\t\tname:    \"7b8349ac747c6a24702b762d2c4fd9266cf4f1d6\",\n+\t\tshort:   \"7b8349ac747c\",\n+\t\ttime:    time.Date(2019, 03, 19, 13, 56, 12, 0, time.UTC),\n \t\tgomod:   \"module \\\"gopkg.in/yaml.v2\\\"\\n\\nrequire (\\n\\t\\\"gopkg.in/check.v1\\\" v0.0.0-20161208181325-20d25e280405\\n)\\n\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"vcs-test.golang.org/go/mod/gitrepo1\",\n \t\trev:     \"master\",\n \t\tversion: \"v1.2.4-annotated\",\n@@ -300,6 +336,7 @@ var codeRepoTests = []struct {\n \t\tgomod:   \"module vcs-test.golang.org/go/mod/gitrepo1\\n\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"gopkg.in/natefinch/lumberjack.v2\",\n \t\trev:     \"latest\",\n \t\tversion: \"v2.0.0-20170531160350-a96e63847dc3\",\n@@ -309,6 +346,7 @@ var codeRepoTests = []struct {\n \t\tgomod:   \"module gopkg.in/natefinch/lumberjack.v2\\n\",\n \t},\n \t{\n+\t\tvcs:  \"git\",\n \t\tpath: \"gopkg.in/natefinch/lumberjack.v2\",\n \t\t// This repo has a v2.1 tag.\n \t\t// We only allow semver references to tags that are fully qualified, as in v2.1.0.\n@@ -324,144 +362,156 @@ var codeRepoTests = []struct {\n \t\tgomod:   \"module gopkg.in/natefinch/lumberjack.v2\\n\",\n \t},\n \t{\n-\t\tpath:    \"nanomsg.org/go/mangos/v2\",\n-\t\trev:     \"v2.0.2\",\n-\t\tversion: \"v2.0.2\",\n-\t\tname:    \"63f66a65137b9a648ac9f7bf0160b4a4d17d7999\",\n-\t\tshort:   \"63f66a65137b\",\n-\t\ttime:    time.Date(2018, 12, 1, 15, 7, 40, 0, time.UTC),\n-\t\tgomod:   \"module nanomsg.org/go/mangos/v2\\n\\nrequire (\\n\\tgithub.com/Microsoft/go-winio v0.4.11\\n\\tgithub.com/droundy/goopt v0.0.0-20170604162106-0b8effe182da\\n\\tgithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e // indirect\\n\\tgithub.com/gorilla/websocket v1.4.0\\n\\tgithub.com/jtolds/gls v4.2.1+incompatible // indirect\\n\\tgithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d // indirect\\n\\tgithub.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c\\n\\tgolang.org/x/sys v0.0.0-20181128092732-4ed8d59d0b35 // indirect\\n)\\n\",\n+\t\tvcs:     \"git\",\n+\t\tpath:    \"vcs-test.golang.org/go/v2module/v2\",\n+\t\trev:     \"v2.0.0\",\n+\t\tversion: \"v2.0.0\",\n+\t\tname:    \"203b91c896acd173aa719e4cdcb7d463c4b090fa\",\n+\t\tshort:   \"203b91c896ac\",\n+\t\ttime:    time.Date(2019, 4, 3, 15, 52, 15, 0, time.UTC),\n+\t\tgomod:   \"module vcs-test.golang.org/go/v2module/v2\\n\\ngo 1.12\\n\",\n \t},\n }\n \n func TestCodeRepo(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \n-\ttmpdir, err := ioutil.TempDir(\"\", \"vgo-modfetch-test-\")\n+\ttmpdir, err := ioutil.TempDir(\"\", \"modfetch-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \tdefer os.RemoveAll(tmpdir)\n-\tfor _, tt := range codeRepoTests {\n-\t\tf := func(t *testing.T) {\n-\t\t\trepo, err := Lookup(tt.path)\n-\t\t\tif tt.lookerr != \"\" {\n-\t\t\t\tif err != nil && err.Error() == tt.lookerr {\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tt.Errorf(\"Lookup(%q): %v, want error %q\", tt.path, err, tt.lookerr)\n-\t\t\t}\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n-\t\t\t}\n-\t\t\tif tt.mpath == \"\" {\n-\t\t\t\ttt.mpath = tt.path\n-\t\t\t}\n-\t\t\tif mpath := repo.ModulePath(); mpath != tt.mpath {\n-\t\t\t\tt.Errorf(\"repo.ModulePath() = %q, want %q\", mpath, tt.mpath)\n-\t\t\t}\n-\t\t\tinfo, err := repo.Stat(tt.rev)\n-\t\t\tif err != nil {\n-\t\t\t\tif tt.err != \"\" {\n-\t\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n-\t\t\t\t\t\tt.Fatalf(\"repoStat(%q): %v, wanted %q\", tt.rev, err, tt.err)\n+\n+\tt.Run(\"parallel\", func(t *testing.T) {\n+\t\tfor _, tt := range codeRepoTests {\n+\t\t\tf := func(tt codeRepoTest) func(t *testing.T) {\n+\t\t\t\treturn func(t *testing.T) {\n+\t\t\t\t\tt.Parallel()\n+\t\t\t\t\tif tt.vcs != \"mod\" {\n+\t\t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n \t\t\t\t\t}\n-\t\t\t\t\treturn\n-\t\t\t\t}\n-\t\t\t\tt.Fatalf(\"repo.Stat(%q): %v\", tt.rev, err)\n-\t\t\t}\n-\t\t\tif tt.err != \"\" {\n-\t\t\t\tt.Errorf(\"repo.Stat(%q): success, wanted error\", tt.rev)\n-\t\t\t}\n-\t\t\tif info.Version != tt.version {\n-\t\t\t\tt.Errorf(\"info.Version = %q, want %q\", info.Version, tt.version)\n-\t\t\t}\n-\t\t\tif info.Name != tt.name {\n-\t\t\t\tt.Errorf(\"info.Name = %q, want %q\", info.Name, tt.name)\n-\t\t\t}\n-\t\t\tif info.Short != tt.short {\n-\t\t\t\tt.Errorf(\"info.Short = %q, want %q\", info.Short, tt.short)\n-\t\t\t}\n-\t\t\tif !info.Time.Equal(tt.time) {\n-\t\t\t\tt.Errorf(\"info.Time = %v, want %v\", info.Time, tt.time)\n-\t\t\t}\n-\t\t\tif tt.gomod != \"\" || tt.gomoderr != \"\" {\n-\t\t\t\tdata, err := repo.GoMod(tt.version)\n-\t\t\t\tif err != nil && tt.gomoderr == \"\" {\n-\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v\", tt.version, err)\n-\t\t\t\t} else if err != nil && tt.gomoderr != \"\" {\n-\t\t\t\t\tif err.Error() != tt.gomoderr {\n-\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v, want %q\", tt.version, err, tt.gomoderr)\n+\n+\t\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n+\t\t\t\t\tif tt.lookerr != \"\" {\n+\t\t\t\t\t\tif err != nil && err.Error() == tt.lookerr {\n+\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tt.Errorf(\"Lookup(%q): %v, want error %q\", tt.path, err, tt.lookerr)\n \t\t\t\t\t}\n-\t\t\t\t} else if tt.gomoderr != \"\" {\n-\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want error %q\", tt.version, data, tt.gomoderr)\n-\t\t\t\t} else if string(data) != tt.gomod {\n-\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want %q\", tt.version, data, tt.gomod)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif tt.zip != nil || tt.ziperr != \"\" {\n-\t\t\t\tf, err := ioutil.TempFile(tmpdir, tt.version+\".zip.\")\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"ioutil.TempFile: %v\", err)\n-\t\t\t\t}\n-\t\t\t\tzipfile := f.Name()\n-\t\t\t\terr = repo.Zip(f, tt.version)\n-\t\t\t\tf.Close()\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tif tt.ziperr != \"\" {\n-\t\t\t\t\t\tif err.Error() == tt.ziperr {\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n+\t\t\t\t\t}\n+\t\t\t\t\tif tt.mpath == \"\" {\n+\t\t\t\t\t\ttt.mpath = tt.path\n+\t\t\t\t\t}\n+\t\t\t\t\tif mpath := repo.ModulePath(); mpath != tt.mpath {\n+\t\t\t\t\t\tt.Errorf(\"repo.ModulePath() = %q, want %q\", mpath, tt.mpath)\n+\t\t\t\t\t}\n+\t\t\t\t\tinfo, err := repo.Stat(tt.rev)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tif tt.err != \"\" {\n+\t\t\t\t\t\t\tif !strings.Contains(err.Error(), tt.err) {\n+\t\t\t\t\t\t\t\tt.Fatalf(\"repoStat(%q): %v, wanted %q\", tt.rev, err, tt.err)\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\treturn\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v, want error %q\", tt.version, err, tt.ziperr)\n+\t\t\t\t\t\tt.Fatalf(\"repo.Stat(%q): %v\", tt.rev, err)\n \t\t\t\t\t}\n-\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v\", tt.version, err)\n-\t\t\t\t}\n-\t\t\t\tif tt.ziperr != \"\" {\n-\t\t\t\t\tt.Errorf(\"repo.Zip(%q): success, want error %q\", tt.version, tt.ziperr)\n-\t\t\t\t}\n-\t\t\t\tprefix := tt.path + \"@\" + tt.version + \"/\"\n-\t\t\t\tz, err := zip.OpenReader(zipfile)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatalf(\"open zip %s: %v\", zipfile, err)\n-\t\t\t\t}\n-\t\t\t\tvar names []string\n-\t\t\t\tfor _, file := range z.File {\n-\t\t\t\t\tif !strings.HasPrefix(file.Name, prefix) {\n-\t\t\t\t\t\tt.Errorf(\"zip entry %v does not start with prefix %v\", file.Name, prefix)\n-\t\t\t\t\t\tcontinue\n+\t\t\t\t\tif tt.err != \"\" {\n+\t\t\t\t\t\tt.Errorf(\"repo.Stat(%q): success, wanted error\", tt.rev)\n+\t\t\t\t\t}\n+\t\t\t\t\tif info.Version != tt.version {\n+\t\t\t\t\t\tt.Errorf(\"info.Version = %q, want %q\", info.Version, tt.version)\n+\t\t\t\t\t}\n+\t\t\t\t\tif info.Name != tt.name {\n+\t\t\t\t\t\tt.Errorf(\"info.Name = %q, want %q\", info.Name, tt.name)\n+\t\t\t\t\t}\n+\t\t\t\t\tif info.Short != tt.short {\n+\t\t\t\t\t\tt.Errorf(\"info.Short = %q, want %q\", info.Short, tt.short)\n+\t\t\t\t\t}\n+\t\t\t\t\tif !info.Time.Equal(tt.time) {\n+\t\t\t\t\t\tt.Errorf(\"info.Time = %v, want %v\", info.Time, tt.time)\n+\t\t\t\t\t}\n+\t\t\t\t\tif tt.gomod != \"\" || tt.gomoderr != \"\" {\n+\t\t\t\t\t\tdata, err := repo.GoMod(tt.version)\n+\t\t\t\t\t\tif err != nil && tt.gomoderr == \"\" {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v\", tt.version, err)\n+\t\t\t\t\t\t} else if err != nil && tt.gomoderr != \"\" {\n+\t\t\t\t\t\t\tif err.Error() != tt.gomoderr {\n+\t\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v, want %q\", tt.version, err, tt.gomoderr)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else if tt.gomoderr != \"\" {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want error %q\", tt.version, data, tt.gomoderr)\n+\t\t\t\t\t\t} else if string(data) != tt.gomod {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want %q\", tt.version, data, tt.gomod)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif tt.zip != nil || tt.ziperr != \"\" {\n+\t\t\t\t\t\tf, err := ioutil.TempFile(tmpdir, tt.version+\".zip.\")\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\tt.Fatalf(\"ioutil.TempFile: %v\", err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tzipfile := f.Name()\n+\t\t\t\t\t\terr = repo.Zip(f, tt.version)\n+\t\t\t\t\t\tf.Close()\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\tif tt.ziperr != \"\" {\n+\t\t\t\t\t\t\t\tif err.Error() == tt.ziperr {\n+\t\t\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v, want error %q\", tt.version, err, tt.ziperr)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v\", tt.version, err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif tt.ziperr != \"\" {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): success, want error %q\", tt.version, tt.ziperr)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tprefix := tt.path + \"@\" + tt.version + \"/\"\n+\t\t\t\t\t\tz, err := zip.OpenReader(zipfile)\n+\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\tt.Fatalf(\"open zip %s: %v\", zipfile, err)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tvar names []string\n+\t\t\t\t\t\tfor _, file := range z.File {\n+\t\t\t\t\t\t\tif !strings.HasPrefix(file.Name, prefix) {\n+\t\t\t\t\t\t\t\tt.Errorf(\"zip entry %v does not start with prefix %v\", file.Name, prefix)\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tnames = append(names, file.Name[len(prefix):])\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tz.Close()\n+\t\t\t\t\t\tif !reflect.DeepEqual(names, tt.zip) {\n+\t\t\t\t\t\t\tt.Fatalf(\"zip = %v\\nwant %v\\n\", names, tt.zip)\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tnames = append(names, file.Name[len(prefix):])\n-\t\t\t\t}\n-\t\t\t\tz.Close()\n-\t\t\t\tif !reflect.DeepEqual(names, tt.zip) {\n-\t\t\t\t\tt.Fatalf(\"zip = %v\\nwant %v\\n\", names, tt.zip)\n \t\t\t\t}\n \t\t\t}\n-\t\t}\n-\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f)\n-\t\tif strings.HasPrefix(tt.path, vgotest1git) {\n-\t\t\tfor _, alt := range altVgotests {\n-\t\t\t\t// Note: Communicating with f through tt; should be cleaned up.\n-\t\t\t\told := tt\n-\t\t\t\ttt.path = alt + strings.TrimPrefix(tt.path, vgotest1git)\n-\t\t\t\tif strings.HasPrefix(tt.mpath, vgotest1git) {\n-\t\t\t\t\ttt.mpath = alt + strings.TrimPrefix(tt.mpath, vgotest1git)\n-\t\t\t\t}\n-\t\t\t\tvar m map[string]string\n-\t\t\t\tif alt == vgotest1hg {\n-\t\t\t\t\tm = hgmap\n+\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n+\t\t\tif strings.HasPrefix(tt.path, vgotest1git) {\n+\t\t\t\tfor vcs, alt := range altVgotests {\n+\t\t\t\t\t// Note: Communicating with f through tt; should be cleaned up.\n+\t\t\t\t\told := tt\n+\t\t\t\t\ttt.vcs = vcs\n+\t\t\t\t\ttt.path = alt + strings.TrimPrefix(tt.path, vgotest1git)\n+\t\t\t\t\tif strings.HasPrefix(tt.mpath, vgotest1git) {\n+\t\t\t\t\t\ttt.mpath = alt + strings.TrimPrefix(tt.mpath, vgotest1git)\n+\t\t\t\t\t}\n+\t\t\t\t\tvar m map[string]string\n+\t\t\t\t\tif alt == vgotest1hg {\n+\t\t\t\t\t\tm = hgmap\n+\t\t\t\t\t}\n+\t\t\t\t\ttt.version = remap(tt.version, m)\n+\t\t\t\t\ttt.name = remap(tt.name, m)\n+\t\t\t\t\ttt.short = remap(tt.short, m)\n+\t\t\t\t\ttt.rev = remap(tt.rev, m)\n+\t\t\t\t\ttt.gomoderr = remap(tt.gomoderr, m)\n+\t\t\t\t\ttt.ziperr = remap(tt.ziperr, m)\n+\t\t\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n+\t\t\t\t\ttt = old\n \t\t\t\t}\n-\t\t\t\ttt.version = remap(tt.version, m)\n-\t\t\t\ttt.name = remap(tt.name, m)\n-\t\t\t\ttt.short = remap(tt.short, m)\n-\t\t\t\ttt.rev = remap(tt.rev, m)\n-\t\t\t\ttt.gomoderr = remap(tt.gomoderr, m)\n-\t\t\t\ttt.ziperr = remap(tt.ziperr, m)\n-\t\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f)\n-\t\t\t\ttt = old\n \t\t\t}\n \t\t}\n-\t}\n+\t})\n }\n \n var hgmap = map[string]string{\n@@ -497,32 +547,39 @@ func remap(name string, m map[string]string) string {\n }\n \n var codeRepoVersionsTests = []struct {\n+\tvcs      string\n \tpath     string\n \tprefix   string\n \tversions []string\n }{\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1\",\n \t\tversions: []string{\"v0.0.0\", \"v0.0.1\", \"v1.0.0\", \"v1.0.1\", \"v1.0.2\", \"v1.0.3\", \"v1.1.0\", \"v2.0.0+incompatible\"},\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1\",\n \t\tprefix:   \"v1.0\",\n \t\tversions: []string{\"v1.0.0\", \"v1.0.1\", \"v1.0.2\", \"v1.0.3\"},\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1/v2\",\n \t\tversions: []string{\"v2.0.0\", \"v2.0.1\", \"v2.0.2\", \"v2.0.3\", \"v2.0.4\", \"v2.0.5\", \"v2.0.6\"},\n \t},\n \t{\n+\t\tvcs:      \"mod\",\n \t\tpath:     \"swtch.com/testmod\",\n \t\tversions: []string{\"v1.0.0\", \"v1.1.1\"},\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"gopkg.in/russross/blackfriday.v2\",\n \t\tversions: []string{\"v2.0.0\", \"v2.0.1\"},\n \t},\n \t{\n+\t\tvcs:      \"git\",\n \t\tpath:     \"gopkg.in/natefinch/lumberjack.v2\",\n \t\tversions: []string{\"v2.0.0\"},\n \t},\n@@ -536,41 +593,55 @@ func TestCodeRepoVersions(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \tdefer os.RemoveAll(tmpdir)\n-\tfor _, tt := range codeRepoVersionsTests {\n-\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {\n-\t\t\trepo, err := Lookup(tt.path)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n-\t\t\t}\n-\t\t\tlist, err := repo.Versions(tt.prefix)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Versions(%q): %v\", tt.prefix, err)\n-\t\t\t}\n-\t\t\tif !reflect.DeepEqual(list, tt.versions) {\n-\t\t\t\tt.Fatalf(\"Versions(%q):\\nhave %v\\nwant %v\", tt.prefix, list, tt.versions)\n-\t\t\t}\n-\t\t})\n-\t}\n+\n+\tt.Run(\"parallel\", func(t *testing.T) {\n+\t\tfor _, tt := range codeRepoVersionsTests {\n+\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {\n+\t\t\t\ttt := tt\n+\t\t\t\tt.Parallel()\n+\t\t\t\tif tt.vcs != \"mod\" {\n+\t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n+\t\t\t\t}\n+\n+\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n+\t\t\t\t}\n+\t\t\t\tlist, err := repo.Versions(tt.prefix)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"Versions(%q): %v\", tt.prefix, err)\n+\t\t\t\t}\n+\t\t\t\tif !reflect.DeepEqual(list, tt.versions) {\n+\t\t\t\t\tt.Fatalf(\"Versions(%q):\\nhave %v\\nwant %v\", tt.prefix, list, tt.versions)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n }\n \n var latestTests = []struct {\n+\tvcs     string\n \tpath    string\n \tversion string\n \terr     string\n }{\n \t{\n+\t\tvcs:  \"git\",\n \t\tpath: \"github.com/rsc/empty\",\n \t\terr:  \"no commits\",\n \t},\n \t{\n+\t\tvcs:     \"git\",\n \t\tpath:    \"github.com/rsc/vgotest1\",\n \t\tversion: \"v0.0.0-20180219223237-a08abb797a67\",\n \t},\n \t{\n+\t\tvcs:  \"git\",\n \t\tpath: \"github.com/rsc/vgotest1/subdir\",\n-\t\terr:  \"missing github.com/rsc/vgotest1/subdir/go.mod at revision a08abb797a67\",\n+\t\terr:  \"github.com/rsc/vgotest1/subdir@v0.0.0-20180219223237-a08abb797a67: invalid version: missing github.com/rsc/vgotest1/subdir/go.mod at revision a08abb797a67\",\n \t},\n \t{\n+\t\tvcs:     \"mod\",\n \t\tpath:    \"swtch.com/testmod\",\n \t\tversion: \"v1.1.1\",\n \t},\n@@ -584,51 +655,49 @@ func TestLatest(t *testing.T) {\n \t\tt.Fatal(err)\n \t}\n \tdefer os.RemoveAll(tmpdir)\n-\tfor _, tt := range latestTests {\n-\t\tname := strings.ReplaceAll(tt.path, \"/\", \"_\")\n-\t\tt.Run(name, func(t *testing.T) {\n-\t\t\trepo, err := Lookup(tt.path)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n-\t\t\t}\n-\t\t\tinfo, err := repo.Latest()\n-\t\t\tif err != nil {\n-\t\t\t\tif tt.err != \"\" {\n-\t\t\t\t\tif err.Error() == tt.err {\n-\t\t\t\t\t\treturn\n+\n+\tt.Run(\"parallel\", func(t *testing.T) {\n+\t\tfor _, tt := range latestTests {\n+\t\t\tname := strings.ReplaceAll(tt.path, \"/\", \"_\")\n+\t\t\tt.Run(name, func(t *testing.T) {\n+\t\t\t\ttt := tt\n+\t\t\t\tt.Parallel()\n+\t\t\t\tif tt.vcs != \"mod\" {\n+\t\t\t\t\ttestenv.MustHaveExecPath(t, tt.vcs)\n+\t\t\t\t}\n+\n+\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n+\t\t\t\t}\n+\t\t\t\tinfo, err := repo.Latest()\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tif tt.err != \"\" {\n+\t\t\t\t\t\tif err.Error() == tt.err {\n+\t\t\t\t\t\t\treturn\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tt.Fatalf(\"Latest(): %v, want %q\", err, tt.err)\n \t\t\t\t\t}\n-\t\t\t\t\tt.Fatalf(\"Latest(): %v, want %q\", err, tt.err)\n+\t\t\t\t\tt.Fatalf(\"Latest(): %v\", err)\n \t\t\t\t}\n-\t\t\t\tt.Fatalf(\"Latest(): %v\", err)\n-\t\t\t}\n-\t\t\tif tt.err != \"\" {\n-\t\t\t\tt.Fatalf(\"Latest() = %v, want error %q\", info.Version, tt.err)\n-\t\t\t}\n-\t\t\tif info.Version != tt.version {\n-\t\t\t\tt.Fatalf(\"Latest() = %v, want %v\", info.Version, tt.version)\n-\t\t\t}\n-\t\t})\n-\t}\n+\t\t\t\tif tt.err != \"\" {\n+\t\t\t\t\tt.Fatalf(\"Latest() = %v, want error %q\", info.Version, tt.err)\n+\t\t\t\t}\n+\t\t\t\tif info.Version != tt.version {\n+\t\t\t\t\tt.Fatalf(\"Latest() = %v, want %v\", info.Version, tt.version)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n }\n \n // fixedTagsRepo is a fake codehost.Repo that returns a fixed list of tags\n type fixedTagsRepo struct {\n \ttags []string\n+\tcodehost.Repo\n }\n \n-func (ch *fixedTagsRepo) Tags(string) ([]string, error)                  { return ch.tags, nil }\n-func (ch *fixedTagsRepo) Latest() (*codehost.RevInfo, error)             { panic(\"not impl\") }\n-func (ch *fixedTagsRepo) ReadFile(string, string, int64) ([]byte, error) { panic(\"not impl\") }\n-func (ch *fixedTagsRepo) ReadFileRevs([]string, string, int64) (map[string]*codehost.FileRev, error) {\n-\tpanic(\"not impl\")\n-}\n-func (ch *fixedTagsRepo) ReadZip(string, string, int64) (io.ReadCloser, string, error) {\n-\tpanic(\"not impl\")\n-}\n-func (ch *fixedTagsRepo) RecentTag(string, string) (string, error) {\n-\tpanic(\"not impl\")\n-}\n-func (ch *fixedTagsRepo) Stat(string) (*codehost.RevInfo, error) { panic(\"not impl\") }\n+func (ch *fixedTagsRepo) Tags(string) ([]string, error) { return ch.tags, nil }\n \n func TestNonCanonicalSemver(t *testing.T) {\n \troot := \"golang.org/x/issue24476\""}, {"sha": "74e36cc6fc1579cb2d3f2cf49a81abd0eedef72c", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 257, "deletions": 29, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -48,7 +48,7 @@ func Download(mod module.Version) (dir string, err error) {\n \t\tif err := download(mod, dir); err != nil {\n \t\t\treturn cached{\"\", err}\n \t\t}\n-\t\tcheckSum(mod)\n+\t\tcheckMod(mod)\n \t\treturn cached{dir, nil}\n \t}).(cached)\n \treturn c.dir, c.err\n@@ -205,13 +205,16 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n \t\t}\n \t}()\n \n-\trepo, err := Lookup(mod.Path)\n+\terr = TryProxies(func(proxy string) error {\n+\t\trepo, err := Lookup(proxy, mod.Path)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\treturn repo.Zip(f, mod.Version)\n+\t})\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif err := repo.Zip(f, mod.Version); err != nil {\n-\t\treturn err\n-\t}\n \n \t// Double-check that the paths within the zip file are well-formed.\n \t//\n@@ -246,9 +249,9 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tcheckOneSum(mod, hash)\n+\tcheckModSum(mod, hash)\n \n-\tif err := renameio.WriteFile(zipfile+\"hash\", []byte(hash)); err != nil {\n+\tif err := renameio.WriteFile(zipfile+\"hash\", []byte(hash), 0666); err != nil {\n \t\treturn err\n \t}\n \tif err := os.Rename(f.Name(), zipfile); err != nil {\n@@ -290,7 +293,7 @@ func initGoSum() bool {\n \n \tgoSum.m = make(map[module.Version][]string)\n \tgoSum.checked = make(map[modSum]bool)\n-\tdata, err := ioutil.ReadFile(GoSumFile)\n+\tdata, err := renameio.ReadFile(GoSumFile)\n \tif err != nil && !os.IsNotExist(err) {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n@@ -300,12 +303,12 @@ func initGoSum() bool {\n \t// Add old go.modverify file.\n \t// We'll delete go.modverify in WriteGoSum.\n \talt := strings.TrimSuffix(GoSumFile, \".sum\") + \".modverify\"\n-\tif data, err := ioutil.ReadFile(alt); err == nil {\n+\tif data, err := renameio.ReadFile(alt); err == nil {\n \t\tmigrate := make(map[module.Version][]string)\n \t\treadGoSum(migrate, alt, data)\n \t\tfor mod, sums := range migrate {\n \t\t\tfor _, sum := range sums {\n-\t\t\t\tcheckOneSumLocked(mod, sum)\n+\t\t\t\taddModSumLocked(mod, sum)\n \t\t\t}\n \t\t}\n \t\tgoSum.modverify = alt\n@@ -348,8 +351,8 @@ func readGoSum(dst map[module.Version][]string, file string, data []byte) {\n \t}\n }\n \n-// checkSum checks the given module's checksum.\n-func checkSum(mod module.Version) {\n+// checkMod checks the given module's checksum.\n+func checkMod(mod module.Version) {\n \tif PkgMod == \"\" {\n \t\t// Do not use current directory.\n \t\treturn\n@@ -360,7 +363,7 @@ func checkSum(mod module.Version) {\n \tif err != nil {\n \t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n \t}\n-\tdata, err := ioutil.ReadFile(ziphash)\n+\tdata, err := renameio.ReadFile(ziphash)\n \tif err != nil {\n \t\tif os.IsNotExist(err) {\n \t\t\t// This can happen if someone does rm -rf GOPATH/src/cache/download. So it goes.\n@@ -373,7 +376,7 @@ func checkSum(mod module.Version) {\n \t\tbase.Fatalf(\"verifying %s@%s: unexpected ziphash: %q\", mod.Path, mod.Version, h)\n \t}\n \n-\tcheckOneSum(mod, h)\n+\tcheckModSum(mod, h)\n }\n \n // goModSum returns the checksum for the go.mod contents.\n@@ -391,36 +394,90 @@ func checkGoMod(path, version string, data []byte) {\n \t\tbase.Fatalf(\"verifying %s %s go.mod: %v\", path, version, err)\n \t}\n \n-\tcheckOneSum(module.Version{Path: path, Version: version + \"/go.mod\"}, h)\n+\tcheckModSum(module.Version{Path: path, Version: version + \"/go.mod\"}, h)\n }\n \n-// checkOneSum checks that the recorded hash for mod is h.\n-func checkOneSum(mod module.Version, h string) {\n+// checkModSum checks that the recorded checksum for mod is h.\n+func checkModSum(mod module.Version, h string) {\n+\t// We lock goSum when manipulating it,\n+\t// but we arrange to release the lock when calling checkSumDB,\n+\t// so that parallel calls to checkModHash can execute parallel calls\n+\t// to checkSumDB.\n+\n+\t// Check whether mod+h is listed in go.sum already. If so, we're done.\n \tgoSum.mu.Lock()\n-\tdefer goSum.mu.Unlock()\n-\tif initGoSum() {\n-\t\tcheckOneSumLocked(mod, h)\n+\tinited := initGoSum()\n+\tdone := inited && haveModSumLocked(mod, h)\n+\tgoSum.mu.Unlock()\n+\n+\tif done {\n+\t\treturn\n+\t}\n+\n+\t// Not listed, so we want to add them.\n+\t// Consult checksum database if appropriate.\n+\tif useSumDB(mod) {\n+\t\t// Calls base.Fatalf if mismatch detected.\n+\t\tcheckSumDB(mod, h)\n+\t}\n+\n+\t// Add mod+h to go.sum, if it hasn't appeared already.\n+\tif inited {\n+\t\tgoSum.mu.Lock()\n+\t\taddModSumLocked(mod, h)\n+\t\tgoSum.mu.Unlock()\n \t}\n }\n \n-func checkOneSumLocked(mod module.Version, h string) {\n+// haveModSumLocked reports whether the pair mod,h is already listed in go.sum.\n+// If it finds a conflicting pair instead, it calls base.Fatalf.\n+// goSum.mu must be locked.\n+func haveModSumLocked(mod module.Version, h string) bool {\n \tgoSum.checked[modSum{mod, h}] = true\n-\n \tfor _, vh := range goSum.m[mod] {\n \t\tif h == vh {\n-\t\t\treturn\n+\t\t\treturn true\n \t\t}\n \t\tif strings.HasPrefix(vh, \"h1:\") {\n-\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\tgo.sum:     %v\", mod.Path, mod.Version, h, vh)\n+\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\tgo.sum:     %v\"+goSumMismatch, mod.Path, mod.Version, h, vh)\n \t\t}\n \t}\n+\treturn false\n+}\n+\n+// addModSumLocked adds the pair mod,h to go.sum.\n+// goSum.mu must be locked.\n+func addModSumLocked(mod module.Version, h string) {\n+\tif haveModSumLocked(mod, h) {\n+\t\treturn\n+\t}\n \tif len(goSum.m[mod]) > 0 {\n-\t\tfmt.Fprintf(os.Stderr, \"warning: verifying %s@%s: unknown hashes in go.sum: %v; adding %v\", mod.Path, mod.Version, strings.Join(goSum.m[mod], \", \"), h)\n+\t\tfmt.Fprintf(os.Stderr, \"warning: verifying %s@%s: unknown hashes in go.sum: %v; adding %v\"+hashVersionMismatch, mod.Path, mod.Version, strings.Join(goSum.m[mod], \", \"), h)\n \t}\n \tgoSum.m[mod] = append(goSum.m[mod], h)\n \tgoSum.dirty = true\n }\n \n+// checkSumDB checks the mod, h pair against the Go checksum database.\n+// It calls base.Fatalf if the hash is to be rejected.\n+func checkSumDB(mod module.Version, h string) {\n+\tdb, lines, err := lookupSumDB(mod)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n+\t}\n+\n+\thave := mod.Path + \" \" + mod.Version + \" \" + h\n+\tprefix := mod.Path + \" \" + mod.Version + \" h1:\"\n+\tfor _, line := range lines {\n+\t\tif line == have {\n+\t\t\treturn\n+\t\t}\n+\t\tif strings.HasPrefix(line, prefix) {\n+\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s: %v\"+sumdbMismatch, mod.Path, mod.Version, h, db, line[len(prefix)-len(\"h1:\"):])\n+\t\t}\n+\t}\n+}\n+\n // Sum returns the checksum for the downloaded copy of the given module,\n // if present in the download cache.\n func Sum(mod module.Version) string {\n@@ -433,7 +490,7 @@ func Sum(mod module.Version) string {\n \tif err != nil {\n \t\treturn \"\"\n \t}\n-\tdata, err := ioutil.ReadFile(ziphash)\n+\tdata, err := renameio.ReadFile(ziphash)\n \tif err != nil {\n \t\treturn \"\"\n \t}\n@@ -455,6 +512,9 @@ func WriteGoSum() {\n \t\t// Don't bother opening the go.sum file if we don't have anything to add.\n \t\treturn\n \t}\n+\tif cfg.BuildMod == \"readonly\" {\n+\t\tbase.Fatalf(\"go: updates to go.sum needed, disabled by -mod=readonly\")\n+\t}\n \n \t// We want to avoid races between creating the lockfile and deleting it, but\n \t// we also don't want to leave a permanent lockfile in the user's repository.\n@@ -478,7 +538,7 @@ func WriteGoSum() {\n \tif !goSum.overwrite {\n \t\t// Re-read the go.sum file to incorporate any sums added by other processes\n \t\t// in the meantime.\n-\t\tdata, err := ioutil.ReadFile(GoSumFile)\n+\t\tdata, err := renameio.ReadFile(GoSumFile)\n \t\tif err != nil && !os.IsNotExist(err) {\n \t\t\tbase.Fatalf(\"go: re-reading go.sum: %v\", err)\n \t\t}\n@@ -489,7 +549,8 @@ func WriteGoSum() {\n \t\tgoSum.m = make(map[module.Version][]string, len(goSum.m))\n \t\treadGoSum(goSum.m, GoSumFile, data)\n \t\tfor ms := range goSum.checked {\n-\t\t\tcheckOneSumLocked(ms.mod, ms.sum)\n+\t\t\taddModSumLocked(ms.mod, ms.sum)\n+\t\t\tgoSum.dirty = true\n \t\t}\n \t}\n \n@@ -507,7 +568,7 @@ func WriteGoSum() {\n \t\t}\n \t}\n \n-\tif err := renameio.WriteFile(GoSumFile, buf.Bytes()); err != nil {\n+\tif err := renameio.WriteFile(GoSumFile, buf.Bytes(), 0666); err != nil {\n \t\tbase.Fatalf(\"go: writing go.sum: %v\", err)\n \t}\n \n@@ -539,3 +600,170 @@ func TrimGoSum(keep map[module.Version]bool) {\n \t\t}\n \t}\n }\n+\n+const goSumMismatch = `\n+\n+SECURITY ERROR\n+This download does NOT match an earlier download recorded in go.sum.\n+The bits may have been replaced on the origin server, or an attacker may\n+have intercepted the download attempt.\n+\n+For more information, see 'go help module-auth'.\n+`\n+\n+const sumdbMismatch = `\n+\n+SECURITY ERROR\n+This download does NOT match the one reported by the checksum server.\n+The bits may have been replaced on the origin server, or an attacker may\n+have intercepted the download attempt.\n+\n+For more information, see 'go help module-auth'.\n+`\n+\n+const hashVersionMismatch = `\n+\n+SECURITY WARNING\n+This download is listed in go.sum, but using an unknown hash algorithm.\n+The download cannot be verified.\n+\n+For more information, see 'go help module-auth'.\n+\n+`\n+\n+var HelpModuleAuth = &base.Command{\n+\tUsageLine: \"module-auth\",\n+\tShort:     \"module authentication using go.sum\",\n+\tLong: `\n+The go command tries to authenticate every downloaded module,\n+checking that the bits downloaded for a specific module version today\n+match bits downloaded yesterday. This ensures repeatable builds\n+and detects introduction of unexpected changes, malicious or not.\n+\n+In each module's root, alongside go.mod, the go command maintains\n+a file named go.sum containing the cryptographic checksums of the\n+module's dependencies.\n+\n+The form of each line in go.sum is three fields:\n+\n+\t<module> <version>[/go.mod] <hash>\n+\n+Each known module version results in two lines in the go.sum file.\n+The first line gives the hash of the module version's file tree.\n+The second line appends \"/go.mod\" to the version and gives the hash\n+of only the module version's (possibly synthesized) go.mod file.\n+The go.mod-only hash allows downloading and authenticating a\n+module version's go.mod file, which is needed to compute the\n+dependency graph, without also downloading all the module's source code.\n+\n+The hash begins with an algorithm prefix of the form \"h<N>:\".\n+The only defined algorithm prefix is \"h1:\", which uses SHA-256.\n+\n+Module authentication failures\n+\n+The go command maintains a cache of downloaded packages and computes\n+and records the cryptographic checksum of each package at download time.\n+In normal operation, the go command checks the main module's go.sum file\n+against these precomputed checksums instead of recomputing them on\n+each command invocation. The 'go mod verify' command checks that\n+the cached copies of module downloads still match both their recorded\n+checksums and the entries in go.sum.\n+\n+In day-to-day development, the checksum of a given module version\n+should never change. Each time a dependency is used by a given main\n+module, the go command checks its local cached copy, freshly\n+downloaded or not, against the main module's go.sum. If the checksums\n+don't match, the go command reports the mismatch as a security error\n+and refuses to run the build. When this happens, proceed with caution:\n+code changing unexpectedly means today's build will not match\n+yesterday's, and the unexpected change may not be beneficial.\n+\n+If the go command reports a mismatch in go.sum, the downloaded code\n+for the reported module version does not match the one used in a\n+previous build of the main module. It is important at that point\n+to find out what the right checksum should be, to decide whether\n+go.sum is wrong or the downloaded code is wrong. Usually go.sum is right:\n+you want to use the same code you used yesterday.\n+\n+If a downloaded module is not yet included in go.sum and it is a publicly\n+available module, the go command consults the Go checksum database to fetch\n+the expected go.sum lines. If the downloaded code does not match those\n+lines, the go command reports the mismatch and exits. Note that the\n+database is not consulted for module versions already listed in go.sum.\n+\n+If a go.sum mismatch is reported, it is always worth investigating why\n+the code downloaded today differs from what was downloaded yesterday.\n+\n+The GOSUMDB environment variable identifies the name of checksum database\n+to use and optionally its public key and URL, as in:\n+\n+\tGOSUMDB=\"sum.golang.org\"\n+\tGOSUMDB=\"sum.golang.org+<publickey>\"\n+\tGOSUMDB=\"sum.golang.org+<publickey> https://sum.golang.org\"\n+\n+The go command knows the public key of sum.golang.org; use of any other\n+database requires giving the public key explicitly. The URL defaults to\n+\"https://\" followed by the database name.\n+\n+GOSUMDB defaults to \"sum.golang.org\", the Go checksum database run by Google.\n+See https://sum.golang.org/privacy for the service's privacy policy.\n+\n+If GOSUMDB is set to \"off\", or if \"go get\" is invoked with the -insecure flag,\n+the checksum database is not consulted, and all unrecognized modules are\n+accepted, at the cost of giving up the security guarantee of verified repeatable\n+downloads for all modules. A better way to bypass the checksum database\n+for specific modules is to use the GOPRIVATE or GONOSUMDB environment\n+variables. See 'go help module-private' for details.\n+\n+The 'go env -w' command (see 'go help env') can be used to set these variables\n+for future go command invocations.\n+`,\n+}\n+\n+var HelpModulePrivate = &base.Command{\n+\tUsageLine: \"module-private\",\n+\tShort:     \"module configuration for non-public modules\",\n+\tLong: `\n+The go command defaults to downloading modules from the public Go module\n+mirror at proxy.golang.org. It also defaults to validating downloaded modules,\n+regardless of source, against the public Go checksum database at sum.golang.org.\n+These defaults work well for publicly available source code.\n+\n+The GOPRIVATE environment variable controls which modules the go command\n+considers to be private (not available publicly) and should therefore not use the\n+proxy or checksum database. The variable is a comma-separated list of\n+glob patterns (in the syntax of Go's path.Match) of module path prefixes.\n+For example,\n+\n+\tGOPRIVATE=*.corp.example.com,rsc.io/private\n+\n+causes the go command to treat as private any module with a path prefix\n+matching either pattern, including git.corp.example.com/xyzzy, rsc.io/private,\n+and rsc.io/private/quux.\n+\n+The GOPRIVATE environment variable may be used by other tools as well to\n+identify non-public modules. For example, an editor could use GOPRIVATE\n+to decide whether to hyperlink a package import to a godoc.org page.\n+\n+For fine-grained control over module download and validation, the GONOPROXY\n+and GONOSUMDB environment variables accept the same kind of glob list\n+and override GOPRIVATE for the specific decision of whether to use the proxy\n+and checksum database, respectively.\n+\n+For example, if a company ran a module proxy serving private modules,\n+users would configure go using:\n+\n+\tGOPRIVATE=*.corp.example.com\n+\tGOPROXY=proxy.example.com\n+\tGONOPROXY=none\n+\n+This would tell the go command and other tools that modules beginning with\n+a corp.example.com subdomain are private but that the company proxy should\n+be used for downloading both public and private modules, because\n+GONOPROXY has been set to a pattern that won't match any modules,\n+overriding GOPRIVATE.\n+\n+The 'go env -w' command (see 'go help env') can be used to set these variables\n+for future go command invocations.\n+`,\n+}"}, {"sha": "06f9989b9d4373c6ae8e477d8eb864ffece1677d", "filename": "libgo/go/cmd/go/internal/modfetch/key.go", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fkey.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fkey.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fkey.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,9 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modfetch\n+\n+var knownGOSUMDB = map[string]string{\n+\t\"sum.golang.org\": \"sum.golang.org+033de0ae+Ac4zctda0e5eza+HJyk9SxEdh+s3Ux18htTTAD8OuAn8\",\n+}"}, {"sha": "9d713dcc6696877224011eceec547a2f4e5068db", "filename": "libgo/go/cmd/go/internal/modfetch/noweb.go", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fnoweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fnoweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fnoweb.go?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build cmd_go_bootstrap\n-\n-package modfetch\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-)\n-\n-func webGetGoGet(url string, body *io.ReadCloser) error {\n-\treturn fmt.Errorf(\"no network in go_bootstrap\")\n-}\n-\n-func webGetBytes(url string, body *[]byte) error {\n-\treturn fmt.Errorf(\"no network in go_bootstrap\")\n-}\n-\n-func webGetBody(url string, body *io.ReadCloser) error {\n-\treturn fmt.Errorf(\"no network in go_bootstrap\")\n-}"}, {"sha": "6049ccfd30a5bc26abf6140173e71aabbeb84d09", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 224, "deletions": 58, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,33 +6,31 @@ package modfetch\n \n import (\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"net/url\"\n \t\"os\"\n+\t\"path\"\n+\tpathpkg \"path\"\n+\t\"path/filepath\"\n \t\"strings\"\n+\t\"sync\"\n \t\"time\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/semver\"\n+\t\"cmd/go/internal/web\"\n )\n \n var HelpGoproxy = &base.Command{\n \tUsageLine: \"goproxy\",\n \tShort:     \"module proxy protocol\",\n \tLong: `\n-The go command by default downloads modules from version control systems\n-directly, just as 'go get' always has. The GOPROXY environment variable allows\n-further control over the download source. If GOPROXY is unset, is the empty string,\n-or is the string \"direct\", downloads use the default direct connection to version\n-control systems. Setting GOPROXY to \"off\" disallows downloading modules from\n-any source. Otherwise, GOPROXY is expected to be the URL of a module proxy,\n-in which case the go command will fetch all modules from that proxy.\n-No matter the source of the modules, downloaded modules must match existing\n-entries in go.sum (see 'go help modules' for discussion of verification).\n-\n A Go module proxy is any web server that can respond to GET requests for\n URLs of a specified form. The requests have no query parameters, so even\n a site serving from a fixed file system (including a file:/// URL)\n@@ -85,47 +83,175 @@ cached module versions with GOPROXY=https://example.com/proxy.\n `,\n }\n \n-var proxyURL = os.Getenv(\"GOPROXY\")\n+var proxyOnce struct {\n+\tsync.Once\n+\tlist []string\n+\terr  error\n+}\n+\n+func proxyURLs() ([]string, error) {\n+\tproxyOnce.Do(func() {\n+\t\tif cfg.GONOPROXY != \"\" && cfg.GOPROXY != \"direct\" {\n+\t\t\tproxyOnce.list = append(proxyOnce.list, \"noproxy\")\n+\t\t}\n+\t\tfor _, proxyURL := range strings.Split(cfg.GOPROXY, \",\") {\n+\t\t\tproxyURL = strings.TrimSpace(proxyURL)\n+\t\t\tif proxyURL == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif proxyURL == \"off\" {\n+\t\t\t\t// \"off\" always fails hard, so can stop walking list.\n+\t\t\t\tproxyOnce.list = append(proxyOnce.list, \"off\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif proxyURL == \"direct\" {\n+\t\t\t\tproxyOnce.list = append(proxyOnce.list, \"direct\")\n+\t\t\t\t// For now, \"direct\" is the end of the line. We may decide to add some\n+\t\t\t\t// sort of fallback behavior for them in the future, so ignore\n+\t\t\t\t// subsequent entries for forward-compatibility.\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\t// Single-word tokens are reserved for built-in behaviors, and anything\n+\t\t\t// containing the string \":/\" or matching an absolute file path must be a\n+\t\t\t// complete URL. For all other paths, implicitly add \"https://\".\n+\t\t\tif strings.ContainsAny(proxyURL, \".:/\") && !strings.Contains(proxyURL, \":/\") && !filepath.IsAbs(proxyURL) && !path.IsAbs(proxyURL) {\n+\t\t\t\tproxyURL = \"https://\" + proxyURL\n+\t\t\t}\n+\n+\t\t\t// Check that newProxyRepo accepts the URL.\n+\t\t\t// It won't do anything with the path.\n+\t\t\t_, err := newProxyRepo(proxyURL, \"golang.org/x/text\")\n+\t\t\tif err != nil {\n+\t\t\t\tproxyOnce.err = err\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tproxyOnce.list = append(proxyOnce.list, proxyURL)\n+\t\t}\n+\t})\n+\n+\treturn proxyOnce.list, proxyOnce.err\n+}\n \n-func lookupProxy(path string) (Repo, error) {\n-\tif strings.Contains(proxyURL, \",\") {\n-\t\treturn nil, fmt.Errorf(\"invalid $GOPROXY setting: cannot have comma\")\n+// TryProxies iterates f over each configured proxy (including \"noproxy\" and\n+// \"direct\" if applicable) until f returns an error that is not\n+// equivalent to os.ErrNotExist.\n+//\n+// TryProxies then returns that final error.\n+//\n+// If GOPROXY is set to \"off\", TryProxies invokes f once with the argument\n+// \"off\".\n+func TryProxies(f func(proxy string) error) error {\n+\tproxies, err := proxyURLs()\n+\tif err != nil {\n+\t\treturn err\n \t}\n-\tu, err := url.Parse(proxyURL)\n-\tif err != nil || u.Scheme != \"http\" && u.Scheme != \"https\" && u.Scheme != \"file\" {\n-\t\t// Don't echo $GOPROXY back in case it has user:password in it (sigh).\n-\t\treturn nil, fmt.Errorf(\"invalid $GOPROXY setting: malformed URL or invalid scheme (must be http, https, file)\")\n+\tif len(proxies) == 0 {\n+\t\treturn f(\"off\")\n+\t}\n+\n+\tfor _, proxy := range proxies {\n+\t\terr = f(proxy)\n+\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\tbreak\n+\t\t}\n \t}\n-\treturn newProxyRepo(u.String(), path)\n+\treturn err\n }\n \n type proxyRepo struct {\n-\turl  string\n+\turl  *url.URL\n \tpath string\n }\n \n func newProxyRepo(baseURL, path string) (Repo, error) {\n+\tbase, err := url.Parse(baseURL)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tswitch base.Scheme {\n+\tcase \"http\", \"https\":\n+\t\t// ok\n+\tcase \"file\":\n+\t\tif *base != (url.URL{Scheme: base.Scheme, Path: base.Path, RawPath: base.RawPath}) {\n+\t\t\treturn nil, fmt.Errorf(\"invalid file:// proxy URL with non-path elements: %s\", web.Redacted(base))\n+\t\t}\n+\tcase \"\":\n+\t\treturn nil, fmt.Errorf(\"invalid proxy URL missing scheme: %s\", web.Redacted(base))\n+\tdefault:\n+\t\treturn nil, fmt.Errorf(\"invalid proxy URL scheme (must be https, http, file): %s\", web.Redacted(base))\n+\t}\n+\n \tenc, err := module.EncodePath(path)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\treturn &proxyRepo{strings.TrimSuffix(baseURL, \"/\") + \"/\" + pathEscape(enc), path}, nil\n+\n+\tbase.Path = strings.TrimSuffix(base.Path, \"/\") + \"/\" + enc\n+\tbase.RawPath = strings.TrimSuffix(base.RawPath, \"/\") + \"/\" + pathEscape(enc)\n+\treturn &proxyRepo{base, path}, nil\n }\n \n func (p *proxyRepo) ModulePath() string {\n \treturn p.path\n }\n \n-func (p *proxyRepo) Versions(prefix string) ([]string, error) {\n-\tvar data []byte\n-\terr := webGetBytes(p.url+\"/@v/list\", &data)\n+// versionError returns err wrapped in a ModuleError for p.path.\n+func (p *proxyRepo) versionError(version string, err error) error {\n+\tif version != \"\" && version != module.CanonicalVersion(version) {\n+\t\treturn &module.ModuleError{\n+\t\t\tPath: p.path,\n+\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\tVersion: version,\n+\t\t\t\tPseudo:  IsPseudoVersion(version),\n+\t\t\t\tErr:     err,\n+\t\t\t},\n+\t\t}\n+\t}\n+\n+\treturn &module.ModuleError{\n+\t\tPath:    p.path,\n+\t\tVersion: version,\n+\t\tErr:     err,\n+\t}\n+}\n+\n+func (p *proxyRepo) getBytes(path string) ([]byte, error) {\n+\tbody, err := p.getBody(path)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\tdefer body.Close()\n+\treturn ioutil.ReadAll(body)\n+}\n+\n+func (p *proxyRepo) getBody(path string) (io.ReadCloser, error) {\n+\tfullPath := pathpkg.Join(p.url.Path, path)\n+\n+\ttarget := *p.url\n+\ttarget.Path = fullPath\n+\ttarget.RawPath = pathpkg.Join(target.RawPath, pathEscape(path))\n+\n+\tresp, err := web.Get(web.DefaultSecurity, &target)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif err := resp.Err(); err != nil {\n+\t\tresp.Body.Close()\n+\t\treturn nil, err\n+\t}\n+\treturn resp.Body, nil\n+}\n+\n+func (p *proxyRepo) Versions(prefix string) ([]string, error) {\n+\tdata, err := p.getBytes(\"@v/list\")\n+\tif err != nil {\n+\t\treturn nil, p.versionError(\"\", err)\n+\t}\n \tvar list []string\n \tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tf := strings.Fields(line)\n-\t\tif len(f) >= 1 && semver.IsValid(f[0]) && strings.HasPrefix(f[0], prefix) {\n+\t\tif len(f) >= 1 && semver.IsValid(f[0]) && strings.HasPrefix(f[0], prefix) && !IsPseudoVersion(f[0]) {\n \t\t\tlist = append(list, f[0])\n \t\t}\n \t}\n@@ -134,98 +260,138 @@ func (p *proxyRepo) Versions(prefix string) ([]string, error) {\n }\n \n func (p *proxyRepo) latest() (*RevInfo, error) {\n-\tvar data []byte\n-\terr := webGetBytes(p.url+\"/@v/list\", &data)\n+\tdata, err := p.getBytes(\"@v/list\")\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(\"\", err)\n \t}\n-\tvar best time.Time\n-\tvar bestVersion string\n+\n+\tvar (\n+\t\tbestTime             time.Time\n+\t\tbestTimeIsFromPseudo bool\n+\t\tbestVersion          string\n+\t)\n+\n \tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\tf := strings.Fields(line)\n-\t\tif len(f) >= 2 && semver.IsValid(f[0]) {\n-\t\t\tft, err := time.Parse(time.RFC3339, f[1])\n-\t\t\tif err == nil && best.Before(ft) {\n-\t\t\t\tbest = ft\n+\t\tif len(f) >= 1 && semver.IsValid(f[0]) {\n+\t\t\t// If the proxy includes timestamps, prefer the timestamp it reports.\n+\t\t\t// Otherwise, derive the timestamp from the pseudo-version.\n+\t\t\tvar (\n+\t\t\t\tft             time.Time\n+\t\t\t\tftIsFromPseudo = false\n+\t\t\t)\n+\t\t\tif len(f) >= 2 {\n+\t\t\t\tft, _ = time.Parse(time.RFC3339, f[1])\n+\t\t\t} else if IsPseudoVersion(f[0]) {\n+\t\t\t\tft, _ = PseudoVersionTime(f[0])\n+\t\t\t\tftIsFromPseudo = true\n+\t\t\t} else {\n+\t\t\t\t// Repo.Latest promises that this method is only called where there are\n+\t\t\t\t// no tagged versions. Ignore any tagged versions that were added in the\n+\t\t\t\t// meantime.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif bestTime.Before(ft) {\n+\t\t\t\tbestTime = ft\n+\t\t\t\tbestTimeIsFromPseudo = ftIsFromPseudo\n \t\t\t\tbestVersion = f[0]\n \t\t\t}\n \t\t}\n \t}\n \tif bestVersion == \"\" {\n-\t\treturn nil, fmt.Errorf(\"no commits\")\n+\t\treturn nil, p.versionError(\"\", codehost.ErrNoCommits)\n+\t}\n+\n+\tif bestTimeIsFromPseudo {\n+\t\t// We parsed bestTime from the pseudo-version, but that's in UTC and we're\n+\t\t// supposed to report the timestamp as reported by the VCS.\n+\t\t// Stat the selected version to canonicalize the timestamp.\n+\t\t//\n+\t\t// TODO(bcmills): Should we also stat other versions to ensure that we\n+\t\t// report the correct Name and Short for the revision?\n+\t\treturn p.Stat(bestVersion)\n \t}\n-\tinfo := &RevInfo{\n+\n+\treturn &RevInfo{\n \t\tVersion: bestVersion,\n \t\tName:    bestVersion,\n \t\tShort:   bestVersion,\n-\t\tTime:    best,\n-\t}\n-\treturn info, nil\n+\t\tTime:    bestTime,\n+\t}, nil\n }\n \n func (p *proxyRepo) Stat(rev string) (*RevInfo, error) {\n-\tvar data []byte\n \tencRev, err := module.EncodeVersion(rev)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(rev, err)\n \t}\n-\terr = webGetBytes(p.url+\"/@v/\"+pathEscape(encRev)+\".info\", &data)\n+\tdata, err := p.getBytes(\"@v/\" + encRev + \".info\")\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(rev, err)\n \t}\n \tinfo := new(RevInfo)\n \tif err := json.Unmarshal(data, info); err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(rev, err)\n+\t}\n+\tif info.Version != rev && rev == module.CanonicalVersion(rev) && module.Check(p.path, rev) == nil {\n+\t\t// If we request a correct, appropriate version for the module path, the\n+\t\t// proxy must return either exactly that version or an error \u2014 not some\n+\t\t// arbitrary other version.\n+\t\treturn nil, p.versionError(rev, fmt.Errorf(\"proxy returned info for version %s instead of requested version\", info.Version))\n \t}\n \treturn info, nil\n }\n \n func (p *proxyRepo) Latest() (*RevInfo, error) {\n-\tvar data []byte\n-\tu := p.url + \"/@latest\"\n-\terr := webGetBytes(u, &data)\n+\tdata, err := p.getBytes(\"@latest\")\n \tif err != nil {\n \t\t// TODO return err if not 404\n \t\treturn p.latest()\n \t}\n \tinfo := new(RevInfo)\n \tif err := json.Unmarshal(data, info); err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(\"\", err)\n \t}\n \treturn info, nil\n }\n \n func (p *proxyRepo) GoMod(version string) ([]byte, error) {\n-\tvar data []byte\n+\tif version != module.CanonicalVersion(version) {\n+\t\treturn nil, p.versionError(version, fmt.Errorf(\"internal error: version passed to GoMod is not canonical\"))\n+\t}\n+\n \tencVer, err := module.EncodeVersion(version)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(version, err)\n \t}\n-\terr = webGetBytes(p.url+\"/@v/\"+pathEscape(encVer)+\".mod\", &data)\n+\tdata, err := p.getBytes(\"@v/\" + encVer + \".mod\")\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, p.versionError(version, err)\n \t}\n \treturn data, nil\n }\n \n func (p *proxyRepo) Zip(dst io.Writer, version string) error {\n-\tvar body io.ReadCloser\n+\tif version != module.CanonicalVersion(version) {\n+\t\treturn p.versionError(version, fmt.Errorf(\"internal error: version passed to Zip is not canonical\"))\n+\t}\n+\n \tencVer, err := module.EncodeVersion(version)\n \tif err != nil {\n-\t\treturn err\n+\t\treturn p.versionError(version, err)\n \t}\n-\terr = webGetBody(p.url+\"/@v/\"+pathEscape(encVer)+\".zip\", &body)\n+\tbody, err := p.getBody(\"@v/\" + encVer + \".zip\")\n \tif err != nil {\n-\t\treturn err\n+\t\treturn p.versionError(version, err)\n \t}\n \tdefer body.Close()\n \n \tlr := &io.LimitedReader{R: body, N: codehost.MaxZipFile + 1}\n \tif _, err := io.Copy(dst, lr); err != nil {\n-\t\treturn err\n+\t\treturn p.versionError(version, err)\n \t}\n \tif lr.N <= 0 {\n-\t\treturn fmt.Errorf(\"downloaded zip file too large\")\n+\t\treturn p.versionError(version, fmt.Errorf(\"downloaded zip file too large\"))\n \t}\n \treturn nil\n }"}, {"sha": "8c063b9107f968c7f1f121c4add2356454a0ce9f", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo.go", "status": "modified", "additions": 132, "deletions": 24, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -35,21 +35,25 @@\n package modfetch\n \n import (\n-\t\"cmd/go/internal/semver\"\n+\t\"errors\"\n \t\"fmt\"\n-\t\"regexp\"\n \t\"strings\"\n \t\"time\"\n+\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/semver\"\n+\t\"internal/lazyregexp\"\n )\n \n+var pseudoVersionRE = lazyregexp.New(`^v[0-9]+\\.(0\\.0-|\\d+\\.\\d+-([^+]*\\.)?0\\.)\\d{14}-[A-Za-z0-9]+(\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?$`)\n+\n // PseudoVersion returns a pseudo-version for the given major version (\"v1\")\n // preexisting older tagged version (\"\" or \"v1.2.3\" or \"v1.2.3-pre\"), revision time,\n // and revision identifier (usually a 12-byte commit hash prefix).\n func PseudoVersion(major, older string, t time.Time, rev string) string {\n \tif major == \"\" {\n \t\tmajor = \"v0\"\n \t}\n-\tmajor = strings.TrimSuffix(major, \"-unstable\") // make gopkg.in/macaroon-bakery.v2-unstable use \"v2\"\n \tsegment := fmt.Sprintf(\"%s-%s\", t.UTC().Format(\"20060102150405\"), rev)\n \tbuild := semver.Build(older)\n \tolder = semver.Canonical(older)\n@@ -62,15 +66,19 @@ func PseudoVersion(major, older string, t time.Time, rev string) string {\n \n \t// Form (2), (3).\n \t// Extract patch from vMAJOR.MINOR.PATCH\n-\tv := older[:len(older)]\n-\ti := strings.LastIndex(v, \".\") + 1\n-\tv, patch := v[:i], v[i:]\n-\n-\t// Increment PATCH by adding 1 to decimal:\n-\t// scan right to left turning 9s to 0s until you find a digit to increment.\n-\t// (Number might exceed int64, but math/big is overkill.)\n-\tdigits := []byte(patch)\n-\tfor i = len(digits) - 1; i >= 0 && digits[i] == '9'; i-- {\n+\ti := strings.LastIndex(older, \".\") + 1\n+\tv, patch := older[:i], older[i:]\n+\n+\t// Reassemble.\n+\treturn v + incDecimal(patch) + \"-0.\" + segment + build\n+}\n+\n+// incDecimal returns the decimal string incremented by 1.\n+func incDecimal(decimal string) string {\n+\t// Scan right to left turning 9s to 0s until you find a digit to increment.\n+\tdigits := []byte(decimal)\n+\ti := len(digits) - 1\n+\tfor ; i >= 0 && digits[i] == '9'; i-- {\n \t\tdigits[i] = '0'\n \t}\n \tif i >= 0 {\n@@ -80,13 +88,29 @@ func PseudoVersion(major, older string, t time.Time, rev string) string {\n \t\tdigits[0] = '1'\n \t\tdigits = append(digits, '0')\n \t}\n-\tpatch = string(digits)\n-\n-\t// Reassemble.\n-\treturn v + patch + \"-0.\" + segment + build\n+\treturn string(digits)\n }\n \n-var pseudoVersionRE = regexp.MustCompile(`^v[0-9]+\\.(0\\.0-|\\d+\\.\\d+-([^+]*\\.)?0\\.)\\d{14}-[A-Za-z0-9]+(\\+incompatible)?$`)\n+// decDecimal returns the decimal string decremented by 1, or the empty string\n+// if the decimal is all zeroes.\n+func decDecimal(decimal string) string {\n+\t// Scan right to left turning 0s to 9s until you find a digit to decrement.\n+\tdigits := []byte(decimal)\n+\ti := len(digits) - 1\n+\tfor ; i >= 0 && digits[i] == '0'; i-- {\n+\t\tdigits[i] = '9'\n+\t}\n+\tif i < 0 {\n+\t\t// decimal is all zeros\n+\t\treturn \"\"\n+\t}\n+\tif i == 0 && digits[i] == '1' && len(digits) > 1 {\n+\t\tdigits = digits[1:]\n+\t} else {\n+\t\tdigits[i]--\n+\t}\n+\treturn string(digits)\n+}\n \n // IsPseudoVersion reports whether v is a pseudo-version.\n func IsPseudoVersion(v string) bool {\n@@ -97,33 +121,117 @@ func IsPseudoVersion(v string) bool {\n // It returns an error if v is not a pseudo-version or if the time stamp\n // embedded in the pseudo-version is not a valid time.\n func PseudoVersionTime(v string) (time.Time, error) {\n-\ttimestamp, _, err := parsePseudoVersion(v)\n+\t_, timestamp, _, _, err := parsePseudoVersion(v)\n+\tif err != nil {\n+\t\treturn time.Time{}, err\n+\t}\n \tt, err := time.Parse(\"20060102150405\", timestamp)\n \tif err != nil {\n-\t\treturn time.Time{}, fmt.Errorf(\"pseudo-version with malformed time %s: %q\", timestamp, v)\n+\t\treturn time.Time{}, &module.InvalidVersionError{\n+\t\t\tVersion: v,\n+\t\t\tPseudo:  true,\n+\t\t\tErr:     fmt.Errorf(\"malformed time %q\", timestamp),\n+\t\t}\n \t}\n \treturn t, nil\n }\n \n // PseudoVersionRev returns the revision identifier of the pseudo-version v.\n // It returns an error if v is not a pseudo-version.\n func PseudoVersionRev(v string) (rev string, err error) {\n-\t_, rev, err = parsePseudoVersion(v)\n+\t_, _, rev, _, err = parsePseudoVersion(v)\n \treturn\n }\n \n-func parsePseudoVersion(v string) (timestamp, rev string, err error) {\n+// PseudoVersionBase returns the canonical parent version, if any, upon which\n+// the pseudo-version v is based.\n+//\n+// If v has no parent version (that is, if it is \"vX.0.0-[\u2026]\"),\n+// PseudoVersionBase returns the empty string and a nil error.\n+func PseudoVersionBase(v string) (string, error) {\n+\tbase, _, _, build, err := parsePseudoVersion(v)\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\n+\tswitch pre := semver.Prerelease(base); pre {\n+\tcase \"\":\n+\t\t// vX.0.0-yyyymmddhhmmss-abcdef123456 \u2192 \"\"\n+\t\tif build != \"\" {\n+\t\t\t// Pseudo-versions of the form vX.0.0-yyyymmddhhmmss-abcdef123456+incompatible\n+\t\t\t// are nonsensical: the \"vX.0.0-\" prefix implies that there is no parent tag,\n+\t\t\t// but the \"+incompatible\" suffix implies that the major version of\n+\t\t\t// the parent tag is not compatible with the module's import path.\n+\t\t\t//\n+\t\t\t// There are a few such entries in the index generated by proxy.golang.org,\n+\t\t\t// but we believe those entries were generated by the proxy itself.\n+\t\t\treturn \"\", &module.InvalidVersionError{\n+\t\t\t\tVersion: v,\n+\t\t\t\tPseudo:  true,\n+\t\t\t\tErr:     fmt.Errorf(\"lacks base version, but has build metadata %q\", build),\n+\t\t\t}\n+\t\t}\n+\t\treturn \"\", nil\n+\n+\tcase \"-0\":\n+\t\t// vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdef123456 \u2192 vX.Y.Z\n+\t\t// vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdef123456+incompatible \u2192 vX.Y.Z+incompatible\n+\t\tbase = strings.TrimSuffix(base, pre)\n+\t\ti := strings.LastIndexByte(base, '.')\n+\t\tif i < 0 {\n+\t\t\tpanic(\"base from parsePseudoVersion missing patch number: \" + base)\n+\t\t}\n+\t\tpatch := decDecimal(base[i+1:])\n+\t\tif patch == \"\" {\n+\t\t\t// vX.0.0-0 is invalid, but has been observed in the wild in the index\n+\t\t\t// generated by requests to proxy.golang.org.\n+\t\t\t//\n+\t\t\t// NOTE(bcmills): I cannot find a historical bug that accounts for\n+\t\t\t// pseudo-versions of this form, nor have I seen such versions in any\n+\t\t\t// actual go.mod files. If we find actual examples of this form and a\n+\t\t\t// reasonable theory of how they came into existence, it seems fine to\n+\t\t\t// treat them as equivalent to vX.0.0 (especially since the invalid\n+\t\t\t// pseudo-versions have lower precedence than the real ones). For now, we\n+\t\t\t// reject them.\n+\t\t\treturn \"\", &module.InvalidVersionError{\n+\t\t\t\tVersion: v,\n+\t\t\t\tPseudo:  true,\n+\t\t\t\tErr:     fmt.Errorf(\"version before %s would have negative patch number\", base),\n+\t\t\t}\n+\t\t}\n+\t\treturn base[:i+1] + patch + build, nil\n+\n+\tdefault:\n+\t\t// vX.Y.Z-pre.0.yyyymmddhhmmss-abcdef123456 \u2192 vX.Y.Z-pre\n+\t\t// vX.Y.Z-pre.0.yyyymmddhhmmss-abcdef123456+incompatible \u2192 vX.Y.Z-pre+incompatible\n+\t\tif !strings.HasSuffix(base, \".0\") {\n+\t\t\tpanic(`base from parsePseudoVersion missing \".0\" before date: ` + base)\n+\t\t}\n+\t\treturn strings.TrimSuffix(base, \".0\") + build, nil\n+\t}\n+}\n+\n+var errPseudoSyntax = errors.New(\"syntax error\")\n+\n+func parsePseudoVersion(v string) (base, timestamp, rev, build string, err error) {\n \tif !IsPseudoVersion(v) {\n-\t\treturn \"\", \"\", fmt.Errorf(\"malformed pseudo-version %q\", v)\n+\t\treturn \"\", \"\", \"\", \"\", &module.InvalidVersionError{\n+\t\t\tVersion: v,\n+\t\t\tPseudo:  true,\n+\t\t\tErr:     errPseudoSyntax,\n+\t\t}\n \t}\n-\tv = strings.TrimSuffix(v, \"+incompatible\")\n+\tbuild = semver.Build(v)\n+\tv = strings.TrimSuffix(v, build)\n \tj := strings.LastIndex(v, \"-\")\n \tv, rev = v[:j], v[j+1:]\n \ti := strings.LastIndex(v, \"-\")\n \tif j := strings.LastIndex(v, \".\"); j > i {\n+\t\tbase = v[:j] // \"vX.Y.Z-pre.0\" or \"vX.Y.(Z+1)-0\"\n \t\ttimestamp = v[j+1:]\n \t} else {\n+\t\tbase = v[:i] // \"vX.0.0\"\n \t\ttimestamp = v[i+1:]\n \t}\n-\treturn timestamp, rev, nil\n+\treturn base, timestamp, rev, build, nil\n }"}, {"sha": "4483f8e962fa5212ea2ae65e1eac66e5117a15ed", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo_test.go", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -23,6 +23,10 @@ var pseudoTests = []struct {\n \t{\"unused\", \"v1.2.99999999999999999\", \"v1.2.100000000000000000-0.20060102150405-hash\"},\n \t{\"unused\", \"v1.2.3-pre\", \"v1.2.3-pre.0.20060102150405-hash\"},\n \t{\"unused\", \"v1.3.0-pre\", \"v1.3.0-pre.0.20060102150405-hash\"},\n+\t{\"unused\", \"v0.0.0--\", \"v0.0.0--.0.20060102150405-hash\"},\n+\t{\"unused\", \"v1.0.0+metadata\", \"v1.0.1-0.20060102150405-hash+metadata\"},\n+\t{\"unused\", \"v2.0.0+incompatible\", \"v2.0.1-0.20060102150405-hash+incompatible\"},\n+\t{\"unused\", \"v2.3.0-pre+incompatible\", \"v2.3.0-pre.0.20060102150405-hash+incompatible\"},\n }\n \n var pseudoTime = time.Date(2006, 1, 2, 15, 4, 5, 0, time.UTC)\n@@ -60,6 +64,13 @@ func TestPseudoVersionTime(t *testing.T) {\n \t}\n }\n \n+func TestInvalidPseudoVersionTime(t *testing.T) {\n+\tconst v = \"---\"\n+\tif _, err := PseudoVersionTime(v); err == nil {\n+\t\tt.Error(\"expected error, got nil instead\")\n+\t}\n+}\n+\n func TestPseudoVersionRev(t *testing.T) {\n \tfor _, tt := range pseudoTests {\n \t\trev, err := PseudoVersionRev(tt.version)\n@@ -72,3 +83,72 @@ func TestPseudoVersionRev(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestPseudoVersionBase(t *testing.T) {\n+\tfor _, tt := range pseudoTests {\n+\t\tbase, err := PseudoVersionBase(tt.version)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"PseudoVersionBase(%q): %v\", tt.version, err)\n+\t\t} else if base != tt.older {\n+\t\t\tt.Errorf(\"PseudoVersionBase(%q) = %q; want %q\", tt.version, base, tt.older)\n+\t\t}\n+\t}\n+}\n+\n+func TestInvalidPseudoVersionBase(t *testing.T) {\n+\tfor _, in := range []string{\n+\t\t\"v0.0.0\",\n+\t\t\"v0.0.0-\",                                 // malformed: empty prerelease\n+\t\t\"v0.0.0-0.20060102150405-hash\",            // Z+1 == 0\n+\t\t\"v0.1.0-0.20060102150405-hash\",            // Z+1 == 0\n+\t\t\"v1.0.0-0.20060102150405-hash\",            // Z+1 == 0\n+\t\t\"v0.0.0-20060102150405-hash+incompatible\", // \"+incompatible without base version\n+\t\t\"v0.0.0-20060102150405-hash+metadata\",     // other metadata without base version\n+\t} {\n+\t\tbase, err := PseudoVersionBase(in)\n+\t\tif err == nil || base != \"\" {\n+\t\t\tt.Errorf(`PseudoVersionBase(%q) = %q, %v; want \"\", error`, in, base, err)\n+\t\t}\n+\t}\n+}\n+\n+func TestIncDecimal(t *testing.T) {\n+\tcases := []struct {\n+\t\tin, want string\n+\t}{\n+\t\t{\"0\", \"1\"},\n+\t\t{\"1\", \"2\"},\n+\t\t{\"99\", \"100\"},\n+\t\t{\"100\", \"101\"},\n+\t\t{\"101\", \"102\"},\n+\t}\n+\n+\tfor _, tc := range cases {\n+\t\tgot := incDecimal(tc.in)\n+\t\tif got != tc.want {\n+\t\t\tt.Fatalf(\"incDecimal(%q) = %q; want %q\", tc.in, tc.want, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestDecDecimal(t *testing.T) {\n+\tcases := []struct {\n+\t\tin, want string\n+\t}{\n+\t\t{\"\", \"\"},\n+\t\t{\"0\", \"\"},\n+\t\t{\"00\", \"\"},\n+\t\t{\"1\", \"0\"},\n+\t\t{\"2\", \"1\"},\n+\t\t{\"99\", \"98\"},\n+\t\t{\"100\", \"99\"},\n+\t\t{\"101\", \"100\"},\n+\t}\n+\n+\tfor _, tc := range cases {\n+\t\tgot := decDecimal(tc.in)\n+\t\tif got != tc.want {\n+\t\t\tt.Fatalf(\"decDecimal(%q) = %q; want %q\", tc.in, tc.want, got)\n+\t\t}\n+\t}\n+}"}, {"sha": "95351269dbec8c79b82e8e0c12a7249740b5f01a", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,6 +5,7 @@\n package modfetch\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -17,6 +18,7 @@ import (\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/semver\"\n+\t\"cmd/go/internal/str\"\n \tweb \"cmd/go/internal/web\"\n )\n \n@@ -160,12 +162,6 @@ type RevInfo struct {\n // To avoid version control access except when absolutely necessary,\n // Lookup does not attempt to connect to the repository itself.\n //\n-// The Import function takes an import path found in source code and\n-// determines which module to add to the requirement list to satisfy\n-// that import. It checks successive truncations of the import path\n-// to determine possible modules and stops when it finds a module\n-// in which the latest version satisfies the import path.\n-//\n // The ImportRepoRev function is a variant of Import which is limited\n // to code in a source code repository at a particular revision identifier\n // (usually a commit hash or source code repository tag, not necessarily\n@@ -177,20 +173,32 @@ type RevInfo struct {\n \n var lookupCache par.Cache\n \n-// Lookup returns the module with the given module path.\n+type lookupCacheKey struct {\n+\tproxy, path string\n+}\n+\n+// Lookup returns the module with the given module path,\n+// fetched through the given proxy.\n+//\n+// The distinguished proxy \"direct\" indicates that the path should be fetched\n+// from its origin, and \"noproxy\" indicates that the patch should be fetched\n+// directly only if GONOPROXY matches the given path.\n+//\n+// For the distinguished proxy \"off\", Lookup always returns a non-nil error.\n+//\n // A successful return does not guarantee that the module\n // has any defined versions.\n-func Lookup(path string) (Repo, error) {\n+func Lookup(proxy, path string) (Repo, error) {\n \tif traceRepo {\n-\t\tdefer logCall(\"Lookup(%q)\", path)()\n+\t\tdefer logCall(\"Lookup(%q, %q)\", proxy, path)()\n \t}\n \n \ttype cached struct {\n \t\tr   Repo\n \t\terr error\n \t}\n-\tc := lookupCache.Do(path, func() interface{} {\n-\t\tr, err := lookup(path)\n+\tc := lookupCache.Do(lookupCacheKey{proxy, path}, func() interface{} {\n+\t\tr, err := lookup(proxy, path)\n \t\tif err == nil {\n \t\t\tif traceRepo {\n \t\t\t\tr = newLoggingRepo(r)\n@@ -204,25 +212,48 @@ func Lookup(path string) (Repo, error) {\n }\n \n // lookup returns the module with the given module path.\n-func lookup(path string) (r Repo, err error) {\n+func lookup(proxy, path string) (r Repo, err error) {\n \tif cfg.BuildMod == \"vendor\" {\n-\t\treturn nil, fmt.Errorf(\"module lookup disabled by -mod=%s\", cfg.BuildMod)\n+\t\treturn nil, errModVendor\n \t}\n-\tif proxyURL == \"off\" {\n-\t\treturn nil, fmt.Errorf(\"module lookup disabled by GOPROXY=%s\", proxyURL)\n+\n+\tif str.GlobsMatchPath(cfg.GONOPROXY, path) {\n+\t\tswitch proxy {\n+\t\tcase \"noproxy\", \"direct\":\n+\t\t\treturn lookupDirect(path)\n+\t\tdefault:\n+\t\t\treturn nil, errNoproxy\n+\t\t}\n \t}\n-\tif proxyURL != \"\" && proxyURL != \"direct\" {\n-\t\treturn lookupProxy(path)\n+\n+\tswitch proxy {\n+\tcase \"off\":\n+\t\treturn nil, errProxyOff\n+\tcase \"direct\":\n+\t\treturn lookupDirect(path)\n+\tcase \"noproxy\":\n+\t\treturn nil, errUseProxy\n+\tdefault:\n+\t\treturn newProxyRepo(proxy, path)\n \t}\n+}\n+\n+var (\n+\terrModVendor       = errors.New(\"module lookup disabled by -mod=vendor\")\n+\terrProxyOff        = errors.New(\"module lookup disabled by GOPROXY=off\")\n+\terrNoproxy   error = notExistError(\"disabled by GOPRIVATE/GONOPROXY\")\n+\terrUseProxy  error = notExistError(\"path does not match GOPRIVATE/GONOPROXY\")\n+)\n \n-\tsecurity := web.Secure\n+func lookupDirect(path string) (Repo, error) {\n+\tsecurity := web.SecureOnly\n \tif get.Insecure {\n \t\tsecurity = web.Insecure\n \t}\n \trr, err := get.RepoRootForImportPath(path, get.PreferMod, security)\n \tif err != nil {\n \t\t// We don't know where to find code for a module with this path.\n-\t\treturn nil, err\n+\t\treturn nil, notExistError(err.Error())\n \t}\n \n \tif rr.VCS == \"mod\" {\n@@ -260,7 +291,7 @@ func ImportRepoRev(path, rev string) (Repo, *RevInfo, error) {\n \t// Note: Because we are converting a code reference from a legacy\n \t// version control system, we ignore meta tags about modules\n \t// and use only direct source control entries (get.IgnoreMod).\n-\tsecurity := web.Secure\n+\tsecurity := web.SecureOnly\n \tif get.Insecure {\n \t\tsecurity = web.Insecure\n \t}\n@@ -288,7 +319,7 @@ func ImportRepoRev(path, rev string) (Repo, *RevInfo, error) {\n \t\treturn nil, nil, err\n \t}\n \n-\tinfo, err := repo.(*codeRepo).convert(revInfo, \"\")\n+\tinfo, err := repo.(*codeRepo).convert(revInfo, rev)\n \tif err != nil {\n \t\treturn nil, nil, err\n \t}\n@@ -364,3 +395,13 @@ func (l *loggingRepo) Zip(dst io.Writer, version string) error {\n \tdefer logCall(\"Repo[%s]: Zip(%s, %q)\", l.r.ModulePath(), dstName, version)()\n \treturn l.r.Zip(dst, version)\n }\n+\n+// A notExistError is like os.ErrNotExist, but with a custom message\n+type notExistError string\n+\n+func (e notExistError) Error() string {\n+\treturn string(e)\n+}\n+func (notExistError) Is(target error) bool {\n+\treturn target == os.ErrNotExist\n+}"}, {"sha": "66a09d32c273dba6952ce2d3ec2e61df9abc377e", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,263 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Go checksum database lookup\n+\n+// +build !cmd_go_bootstrap\n+\n+package modfetch\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"net/url\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/get\"\n+\t\"cmd/go/internal/lockedfile\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/note\"\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/sumweb\"\n+\t\"cmd/go/internal/web\"\n+)\n+\n+// useSumDB reports whether to use the Go checksum database for the given module.\n+func useSumDB(mod module.Version) bool {\n+\treturn cfg.GOSUMDB != \"off\" && !get.Insecure && !str.GlobsMatchPath(cfg.GONOSUMDB, mod.Path)\n+}\n+\n+// lookupSumDB returns the Go checksum database's go.sum lines for the given module,\n+// along with the name of the database.\n+func lookupSumDB(mod module.Version) (dbname string, lines []string, err error) {\n+\tdbOnce.Do(func() {\n+\t\tdbName, db, dbErr = dbDial()\n+\t})\n+\tif dbErr != nil {\n+\t\treturn \"\", nil, dbErr\n+\t}\n+\tlines, err = db.Lookup(mod.Path, mod.Version)\n+\treturn dbName, lines, err\n+}\n+\n+var (\n+\tdbOnce sync.Once\n+\tdbName string\n+\tdb     *sumweb.Conn\n+\tdbErr  error\n+)\n+\n+func dbDial() (dbName string, db *sumweb.Conn, err error) {\n+\t// $GOSUMDB can be \"key\" or \"key url\",\n+\t// and the key can be a full verifier key\n+\t// or a host on our list of known keys.\n+\tkey := strings.Fields(cfg.GOSUMDB)\n+\tif len(key) >= 1 {\n+\t\tif k := knownGOSUMDB[key[0]]; k != \"\" {\n+\t\t\tkey[0] = k\n+\t\t}\n+\t}\n+\tif len(key) == 0 {\n+\t\treturn \"\", nil, fmt.Errorf(\"missing GOSUMDB\")\n+\t}\n+\tif len(key) > 2 {\n+\t\treturn \"\", nil, fmt.Errorf(\"invalid GOSUMDB: too many fields\")\n+\t}\n+\tvkey, err := note.NewVerifier(key[0])\n+\tif err != nil {\n+\t\treturn \"\", nil, fmt.Errorf(\"invalid GOSUMDB: %v\", err)\n+\t}\n+\tname := vkey.Name()\n+\n+\t// No funny business in the database name.\n+\tdirect, err := url.Parse(\"https://\" + name)\n+\tif err != nil || strings.HasSuffix(name, \"/\") || *direct != (url.URL{Scheme: \"https\", Host: direct.Host, Path: direct.Path, RawPath: direct.RawPath}) || direct.RawPath != \"\" || direct.Host == \"\" {\n+\t\treturn \"\", nil, fmt.Errorf(\"invalid sumdb name (must be host[/path]): %s %+v\", name, *direct)\n+\t}\n+\n+\t// Determine how to get to database.\n+\tvar base *url.URL\n+\tif len(key) >= 2 {\n+\t\t// Use explicit alternate URL listed in $GOSUMDB,\n+\t\t// bypassing both the default URL derivation and any proxies.\n+\t\tu, err := url.Parse(key[1])\n+\t\tif err != nil {\n+\t\t\treturn \"\", nil, fmt.Errorf(\"invalid GOSUMDB URL: %v\", err)\n+\t\t}\n+\t\tbase = u\n+\t}\n+\n+\treturn name, sumweb.NewConn(&dbClient{key: key[0], name: name, direct: direct, base: base}), nil\n+}\n+\n+type dbClient struct {\n+\tkey    string\n+\tname   string\n+\tdirect *url.URL\n+\n+\tonce    sync.Once\n+\tbase    *url.URL\n+\tbaseErr error\n+}\n+\n+func (c *dbClient) ReadRemote(path string) ([]byte, error) {\n+\tc.once.Do(c.initBase)\n+\tif c.baseErr != nil {\n+\t\treturn nil, c.baseErr\n+\t}\n+\n+\tvar data []byte\n+\tstart := time.Now()\n+\ttarg := web.Join(c.base, path)\n+\tdata, err := web.GetBytes(targ)\n+\tif false {\n+\t\tfmt.Fprintf(os.Stderr, \"%.3fs %s\\n\", time.Since(start).Seconds(), web.Redacted(targ))\n+\t}\n+\treturn data, err\n+}\n+\n+// initBase determines the base URL for connecting to the database.\n+// Determining the URL requires sending network traffic to proxies,\n+// so this work is delayed until we need to download something from\n+// the database. If everything we need is in the local cache and\n+// c.ReadRemote is never called, we will never do this work.\n+func (c *dbClient) initBase() {\n+\tif c.base != nil {\n+\t\treturn\n+\t}\n+\n+\t// Try proxies in turn until we find out how to connect to this database.\n+\turls, err := proxyURLs()\n+\tif err != nil {\n+\t\tc.baseErr = err\n+\t\treturn\n+\t}\n+\tfor _, proxyURL := range urls {\n+\t\tif proxyURL == \"noproxy\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif proxyURL == \"direct\" || proxyURL == \"off\" {\n+\t\t\tbreak\n+\t\t}\n+\t\tproxy, err := url.Parse(proxyURL)\n+\t\tif err != nil {\n+\t\t\tc.baseErr = err\n+\t\t\treturn\n+\t\t}\n+\t\t// Quoting https://golang.org/design/25530-sumdb#proxying-a-checksum-database:\n+\t\t//\n+\t\t// Before accessing any checksum database URL using a proxy,\n+\t\t// the proxy client should first fetch <proxyURL>/sumdb/<sumdb-name>/supported.\n+\t\t// If that request returns a successful (HTTP 200) response, then the proxy supports\n+\t\t// proxying checksum database requests. In that case, the client should use\n+\t\t// the proxied access method only, never falling back to a direct connection to the database.\n+\t\t// If the /sumdb/<sumdb-name>/supported check fails with a \u201cnot found\u201d (HTTP 404)\n+\t\t// or \u201cgone\u201d (HTTP 410) response, the proxy is unwilling to proxy the checksum database,\n+\t\t// and the client should connect directly to the database.\n+\t\t// Any other response is treated as the database being unavailable.\n+\t\t_, err = web.GetBytes(web.Join(proxy, \"sumdb/\"+c.name+\"/supported\"))\n+\t\tif err == nil {\n+\t\t\t// Success! This proxy will help us.\n+\t\t\tc.base = web.Join(proxy, \"sumdb/\"+c.name)\n+\t\t\treturn\n+\t\t}\n+\t\t// If the proxy serves a non-404/410, give up.\n+\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\tc.baseErr = err\n+\t\t\treturn\n+\t\t}\n+\t}\n+\n+\t// No proxies, or all proxies said 404, or we reached an explicit \"direct\".\n+\tc.base = c.direct\n+}\n+\n+// ReadConfig reads the key from c.key\n+// and otherwise reads the config (a latest tree head) from GOPATH/pkg/sumdb/<file>.\n+func (c *dbClient) ReadConfig(file string) (data []byte, err error) {\n+\tif file == \"key\" {\n+\t\treturn []byte(c.key), nil\n+\t}\n+\n+\t// GOPATH/pkg is PkgMod/..\n+\ttarg := filepath.Join(PkgMod, \"../sumdb/\"+file)\n+\tdata, err = lockedfile.Read(targ)\n+\tif errors.Is(err, os.ErrNotExist) {\n+\t\t// Treat non-existent as empty, to bootstrap the \"latest\" file\n+\t\t// the first time we connect to a given database.\n+\t\treturn []byte{}, nil\n+\t}\n+\treturn data, err\n+}\n+\n+// WriteConfig rewrites the latest tree head.\n+func (*dbClient) WriteConfig(file string, old, new []byte) error {\n+\tif file == \"key\" {\n+\t\t// Should not happen.\n+\t\treturn fmt.Errorf(\"cannot write key\")\n+\t}\n+\ttarg := filepath.Join(PkgMod, \"../sumdb/\"+file)\n+\tos.MkdirAll(filepath.Dir(targ), 0777)\n+\tf, err := lockedfile.Edit(targ)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\tdata, err := ioutil.ReadAll(f)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif len(data) > 0 && !bytes.Equal(data, old) {\n+\t\treturn sumweb.ErrWriteConflict\n+\t}\n+\tif _, err := f.Seek(0, 0); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := f.Truncate(0); err != nil {\n+\t\treturn err\n+\t}\n+\tif _, err := f.Write(new); err != nil {\n+\t\treturn err\n+\t}\n+\treturn f.Close()\n+}\n+\n+// ReadCache reads cached lookups or tiles from\n+// GOPATH/pkg/mod/download/cache/sumdb,\n+// which will be deleted by \"go clean -modcache\".\n+func (*dbClient) ReadCache(file string) ([]byte, error) {\n+\ttarg := filepath.Join(PkgMod, \"download/cache/sumdb\", file)\n+\tdata, err := lockedfile.Read(targ)\n+\t// lockedfile.Write does not atomically create the file with contents.\n+\t// There is a moment between file creation and locking the file for writing,\n+\t// during which the empty file can be locked for reading.\n+\t// Treat observing an empty file as file not found.\n+\tif err == nil && len(data) == 0 {\n+\t\terr = &os.PathError{Op: \"read\", Path: targ, Err: os.ErrNotExist}\n+\t}\n+\treturn data, err\n+}\n+\n+// WriteCache updates cached lookups or tiles.\n+func (*dbClient) WriteCache(file string, data []byte) {\n+\ttarg := filepath.Join(PkgMod, \"download/cache/sumdb\", file)\n+\tos.MkdirAll(filepath.Dir(targ), 0777)\n+\tlockedfile.Write(targ, bytes.NewReader(data), 0666)\n+}\n+\n+func (*dbClient) Log(msg string) {\n+\t// nothing for now\n+}\n+\n+func (*dbClient) SecurityError(msg string) {\n+\tbase.Fatalf(\"%s\", msg)\n+}"}, {"sha": "b327bf293d1de604040d8be3b69dd3ac2fbf3418", "filename": "libgo/go/cmd/go/internal/modfetch/web.go", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fweb.go?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build !cmd_go_bootstrap\n-\n-package modfetch\n-\n-import (\n-\t\"io\"\n-\n-\tweb \"cmd/go/internal/web2\"\n-)\n-\n-// webGetGoGet fetches a go-get=1 URL and returns the body in *body.\n-// It allows non-200 responses, as usual for these URLs.\n-func webGetGoGet(url string, body *io.ReadCloser) error {\n-\treturn web.Get(url, web.Non200OK(), web.Body(body))\n-}\n-\n-// webGetBytes returns the body returned by an HTTP GET, as a []byte.\n-// It insists on a 200 response.\n-func webGetBytes(url string, body *[]byte) error {\n-\treturn web.Get(url, web.ReadAllBody(body))\n-}\n-\n-// webGetBody returns the body returned by an HTTP GET, as a io.ReadCloser.\n-// It insists on a 200 response.\n-func webGetBody(url string, body *io.ReadCloser) error {\n-\treturn web.Get(url, web.Body(body))\n-}"}, {"sha": "6e1a22f3caa821ac2bc050d8c7054cd48357aac1", "filename": "libgo/go/cmd/go/internal/modfile/rule.go", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,15 +8,14 @@ import (\n \t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n+\t\"internal/lazyregexp\"\n \t\"path/filepath\"\n-\t\"regexp\"\n \t\"sort\"\n \t\"strconv\"\n \t\"strings\"\n \t\"unicode\"\n \n \t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/semver\"\n )\n \n // A File is the parsed, interpreted form of a go.mod file.\n@@ -154,7 +153,7 @@ func parseToFile(file string, data []byte, fix VersionFixer, strict bool) (*File\n \treturn f, nil\n }\n \n-var GoVersionRE = regexp.MustCompile(`([1-9][0-9]*)\\.(0|[1-9][0-9]*)`)\n+var GoVersionRE = lazyregexp.New(`([1-9][0-9]*)\\.(0|[1-9][0-9]*)`)\n \n func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, fix VersionFixer, strict bool) {\n \t// If strict is false, this module is a dependency.\n@@ -195,7 +194,7 @@ func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, f\n \t\tf.Module = &Module{Syntax: line}\n \t\tif len(args) != 1 {\n \n-\t\t\tfmt.Fprintf(errs, \"%s:%d: usage: module module/path [version]\\n\", f.Syntax.Name, line.Start.Line)\n+\t\t\tfmt.Fprintf(errs, \"%s:%d: usage: module module/path\\n\", f.Syntax.Name, line.Start.Line)\n \t\t\treturn\n \t\t}\n \t\ts, err := parseString(&args[0])\n@@ -214,22 +213,18 @@ func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, f\n \t\t\tfmt.Fprintf(errs, \"%s:%d: invalid quoted string: %v\\n\", f.Syntax.Name, line.Start.Line, err)\n \t\t\treturn\n \t\t}\n-\t\told := args[1]\n-\t\tv, err := parseVersion(s, &args[1], fix)\n+\t\tv, err := parseVersion(verb, s, &args[1], fix)\n \t\tif err != nil {\n-\t\t\tfmt.Fprintf(errs, \"%s:%d: invalid module version %q: %v\\n\", f.Syntax.Name, line.Start.Line, old, err)\n+\t\t\tfmt.Fprintf(errs, \"%s:%d: %v\\n\", f.Syntax.Name, line.Start.Line, err)\n \t\t\treturn\n \t\t}\n \t\tpathMajor, err := modulePathMajor(s)\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(errs, \"%s:%d: %v\\n\", f.Syntax.Name, line.Start.Line, err)\n \t\t\treturn\n \t\t}\n-\t\tif !module.MatchPathMajor(v, pathMajor) {\n-\t\t\tif pathMajor == \"\" {\n-\t\t\t\tpathMajor = \"v0 or v1\"\n-\t\t\t}\n-\t\t\tfmt.Fprintf(errs, \"%s:%d: invalid module: %s should be %s, not %s (%s)\\n\", f.Syntax.Name, line.Start.Line, s, pathMajor, semver.Major(v), v)\n+\t\tif err := module.MatchPathMajor(v, pathMajor); err != nil {\n+\t\t\tfmt.Fprintf(errs, \"%s:%d: %v\\n\", f.Syntax.Name, line.Start.Line, &Error{Verb: verb, ModPath: s, Err: err})\n \t\t\treturn\n \t\t}\n \t\tif verb == \"require\" {\n@@ -265,17 +260,13 @@ func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, f\n \t\t}\n \t\tvar v string\n \t\tif arrow == 2 {\n-\t\t\told := args[1]\n-\t\t\tv, err = parseVersion(s, &args[1], fix)\n+\t\t\tv, err = parseVersion(verb, s, &args[1], fix)\n \t\t\tif err != nil {\n-\t\t\t\tfmt.Fprintf(errs, \"%s:%d: invalid module version %v: %v\\n\", f.Syntax.Name, line.Start.Line, old, err)\n+\t\t\t\tfmt.Fprintf(errs, \"%s:%d: %v\\n\", f.Syntax.Name, line.Start.Line, err)\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tif !module.MatchPathMajor(v, pathMajor) {\n-\t\t\t\tif pathMajor == \"\" {\n-\t\t\t\t\tpathMajor = \"v0 or v1\"\n-\t\t\t\t}\n-\t\t\t\tfmt.Fprintf(errs, \"%s:%d: invalid module: %s should be %s, not %s (%s)\\n\", f.Syntax.Name, line.Start.Line, s, pathMajor, semver.Major(v), v)\n+\t\t\tif err := module.MatchPathMajor(v, pathMajor); err != nil {\n+\t\t\t\tfmt.Fprintf(errs, \"%s:%d: %v\\n\", f.Syntax.Name, line.Start.Line, &Error{Verb: verb, ModPath: s, Err: err})\n \t\t\t\treturn\n \t\t\t}\n \t\t}\n@@ -296,10 +287,9 @@ func (f *File) add(errs *bytes.Buffer, line *Line, verb string, args []string, f\n \t\t\t}\n \t\t}\n \t\tif len(args) == arrow+3 {\n-\t\t\told := args[arrow+1]\n-\t\t\tnv, err = parseVersion(ns, &args[arrow+2], fix)\n+\t\t\tnv, err = parseVersion(verb, ns, &args[arrow+2], fix)\n \t\t\tif err != nil {\n-\t\t\t\tfmt.Fprintf(errs, \"%s:%d: invalid module version %v: %v\\n\", f.Syntax.Name, line.Start.Line, old, err)\n+\t\t\t\tfmt.Fprintf(errs, \"%s:%d: %v\\n\", f.Syntax.Name, line.Start.Line, err)\n \t\t\t\treturn\n \t\t\t}\n \t\t\tif IsDirectoryPath(ns) {\n@@ -411,23 +401,56 @@ func parseString(s *string) (string, error) {\n \treturn t, nil\n }\n \n-func parseVersion(path string, s *string, fix VersionFixer) (string, error) {\n+type Error struct {\n+\tVerb    string\n+\tModPath string\n+\tErr     error\n+}\n+\n+func (e *Error) Error() string {\n+\treturn fmt.Sprintf(\"%s %s: %v\", e.Verb, e.ModPath, e.Err)\n+}\n+\n+func (e *Error) Unwrap() error { return e.Err }\n+\n+func parseVersion(verb string, path string, s *string, fix VersionFixer) (string, error) {\n \tt, err := parseString(s)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn \"\", &Error{\n+\t\t\tVerb:    verb,\n+\t\t\tModPath: path,\n+\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\tVersion: *s,\n+\t\t\t\tErr:     err,\n+\t\t\t},\n+\t\t}\n \t}\n \tif fix != nil {\n \t\tvar err error\n \t\tt, err = fix(path, t)\n \t\tif err != nil {\n+\t\t\tif err, ok := err.(*module.ModuleError); ok {\n+\t\t\t\treturn \"\", &Error{\n+\t\t\t\t\tVerb:    verb,\n+\t\t\t\t\tModPath: path,\n+\t\t\t\t\tErr:     err.Err,\n+\t\t\t\t}\n+\t\t\t}\n \t\t\treturn \"\", err\n \t\t}\n \t}\n \tif v := module.CanonicalVersion(t); v != \"\" {\n \t\t*s = v\n \t\treturn *s, nil\n \t}\n-\treturn \"\", fmt.Errorf(\"version must be of the form v1.2.3\")\n+\treturn \"\", &Error{\n+\t\tVerb:    verb,\n+\t\tModPath: path,\n+\t\tErr: &module.InvalidVersionError{\n+\t\t\tVersion: t,\n+\t\t\tErr:     errors.New(\"must be of the form v1.2.3\"),\n+\t\t},\n+\t}\n }\n \n func modulePathMajor(path string) (string, error) {"}, {"sha": "491d2891c7ea0fb8eb5846e74e766f12da03bbce", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 605, "deletions": 323, "changes": 928, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -9,27 +9,28 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/get\"\n+\t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/load\"\n-\t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n \t\"cmd/go/internal/semver\"\n-\t\"cmd/go/internal/str\"\n \t\"cmd/go/internal/work\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"os\"\n-\tpathpkg \"path\"\n \t\"path/filepath\"\n+\t\"sort\"\n \t\"strings\"\n+\t\"sync\"\n )\n \n var CmdGet = &base.Command{\n-\t// Note: -d -m -u are listed explicitly because they are the most common get flags.\n+\t// Note: -d -u are listed explicitly because they are the most common get flags.\n \t// Do not send CLs removing them because they're covered by [get flags].\n-\tUsageLine: \"go get [-d] [-m] [-u] [-v] [-insecure] [build flags] [packages]\",\n+\tUsageLine: \"go get [-d] [-t] [-u] [-v] [-insecure] [build flags] [packages]\",\n \tShort:     \"add dependencies to current module and install them\",\n \tLong: `\n Get resolves and adds dependencies to the current development module\n@@ -40,7 +41,7 @@ The first step is to resolve which dependencies to add.\n For each named package or package pattern, get must decide which version of\n the corresponding module to use. By default, get chooses the latest tagged\n release version, such as v0.4.5 or v1.2.3. If there are no tagged release\n-versions, get chooses the latest tagged prerelease version, such as\n+versions, get chooses the latest tagged pre-release version, such as\n v0.0.1-pre1. If there are no tagged versions at all, get chooses the latest\n known commit.\n \n@@ -49,8 +50,6 @@ suffix to the package argument, as in 'go get golang.org/x/text@v0.3.0'.\n For modules stored in source control repositories, the version suffix can\n also be a commit hash, branch identifier, or other syntax known to the\n source control system, as in 'go get golang.org/x/text@master'.\n-The version suffix @latest explicitly requests the default behavior\n-described above.\n \n If a module under consideration is already a dependency of the current\n development module, then get will update the required version.\n@@ -59,6 +58,14 @@ downgrades the dependency. The version suffix @none indicates that the\n dependency should be removed entirely, downgrading or removing modules\n depending on it as needed.\n \n+The version suffix @latest explicitly requests the latest minor release of the\n+given path. The suffix @patch requests the latest patch release: if the path\n+is already in the build list, the selected version will have the same minor\n+version. If the path is not already in the build list, @patch is equivalent\n+to @latest. Neither @latest nor @patch will cause 'go get' to downgrade a module\n+in the build list if it is required at a newer pre-release version that is\n+newer than the latest released version.\n+\n Although get defaults to using the latest version of the module containing\n a named package, it does not use the latest version of that module's\n dependencies. Instead it prefers to use the specific dependency versions\n@@ -68,25 +75,31 @@ will use the latest A but then use B v1.2.3, as requested by A. (If there\n are competing requirements for a particular module, then 'go get' resolves\n those requirements by taking the maximum requested version.)\n \n-The -u flag instructs get to update dependencies to use newer minor or\n-patch releases when available. Continuing the previous example,\n-'go get -u A' will use the latest A with B v1.3.1 (not B v1.2.3).\n+The -t flag instructs get to consider modules needed to build tests of\n+packages specified on the command line.\n+\n+The -u flag instructs get to update modules providing dependencies\n+of packages named on the command line to use newer minor or patch\n+releases when available. Continuing the previous example, 'go get -u A'\n+will use the latest A with B v1.3.1 (not B v1.2.3). If B requires module C,\n+but C does not provide any packages needed to build packages in A\n+(not including tests), then C will not be updated.\n+\n+The -u=patch flag (not -u patch) also instructs get to update dependencies,\n+but changes the default to select patch releases.\n+Continuing the previous example,\n+'go get -u=patch A@latest' will use the latest A with B v1.2.4 (not B v1.2.3),\n+while 'go get -u=patch A' will use a patch release of A instead.\n \n-The -u=patch flag (not -u patch) instructs get to update dependencies\n-to use newer patch releases when available. Continuing the previous example,\n-'go get -u=patch A' will use the latest A with B v1.2.4 (not B v1.2.3).\n+When the -t and -u flags are used together, get will update\n+test dependencies as well.\n \n In general, adding a new dependency may require upgrading\n existing dependencies to keep a working build, and 'go get' does\n this automatically. Similarly, downgrading one dependency may\n require downgrading other dependencies, and 'go get' does\n this automatically as well.\n \n-The -m flag instructs get to stop here, after resolving, upgrading,\n-and downgrading modules and updating go.mod. When using -m,\n-each specified package path must be a module path as well,\n-not the import path of a package below the module root.\n-\n The -insecure flag permits fetching from repositories and resolving\n custom domains using insecure schemes such as HTTP. Use with caution.\n \n@@ -108,12 +121,11 @@ The -d flag instructs get to download the source code needed to build\n the named packages, including downloading necessary dependencies,\n but not to build and install them.\n \n-With no package arguments, 'go get' applies to the main module,\n-and to the Go package in the current directory, if any. In particular,\n-'go get -u' and 'go get -u=patch' update all the dependencies of the\n-main module. With no package arguments and also without -u,\n-'go get' is not much more than 'go install', and 'go get -d' not much\n-more than 'go list'.\n+With no package arguments, 'go get' applies to Go package in the\n+current directory, if any. In particular, 'go get -u' and\n+'go get -u=patch' update all the dependencies of that package.\n+With no package arguments and also without -u, 'go get' is not much more\n+than 'go install', and 'go get -d' not much more than 'go list'.\n \n For more about modules, see 'go help modules'.\n \n@@ -165,6 +177,9 @@ func (v *upgradeFlag) Set(s string) error {\n \tif s == \"false\" {\n \t\ts = \"\"\n \t}\n+\tif s == \"true\" {\n+\t\ts = \"latest\"\n+\t}\n \t*v = upgradeFlag(s)\n \treturn nil\n }\n@@ -178,15 +193,53 @@ func init() {\n \tCmdGet.Flag.Var(&getU, \"u\", \"\")\n }\n \n-// A task holds the state for processing a single get argument (path@vers).\n-type task struct {\n-\targ             string // original argument\n-\tindex           int\n-\tpath            string           // package path part of arg\n-\tforceModulePath bool             // path must be interpreted as a module path\n-\tvers            string           // version part of arg\n-\tm               module.Version   // module version indicated by argument\n-\treq             []module.Version // m's requirement list (not upgraded)\n+// A getArg holds a parsed positional argument for go get (path@vers).\n+type getArg struct {\n+\t// raw is the original argument, to be printed in error messages.\n+\traw string\n+\n+\t// path is the part of the argument before \"@\" (or the whole argument\n+\t// if there is no \"@\"). path specifies the modules or packages to get.\n+\tpath string\n+\n+\t// vers is the part of the argument after \"@\" (or \"\" if there is no \"@\").\n+\t// vers specifies the module version to get.\n+\tvers string\n+}\n+\n+// querySpec describes a query for a specific module. path may be a\n+// module path, package path, or package pattern. vers is a version\n+// query string from a command line argument.\n+type querySpec struct {\n+\t// path is a module path, package path, or package pattern that\n+\t// specifies which module to query.\n+\tpath string\n+\n+\t// vers specifies what version of the module to get.\n+\tvers string\n+\n+\t// forceModulePath is true if path should be interpreted as a module path.\n+\t// If forceModulePath is true, prevM must be set.\n+\tforceModulePath bool\n+\n+\t// prevM is the previous version of the module. prevM is needed\n+\t// to determine the minor version number if vers is \"patch\". It's also\n+\t// used to avoid downgrades from prerelease versions newer than\n+\t// \"latest\" and \"patch\". If prevM is set, forceModulePath must be true.\n+\tprevM module.Version\n+}\n+\n+// query holds the state for a query made for a specific module.\n+// After a query is performed, we know the actual module path and\n+// version and whether any packages were matched by the query path.\n+type query struct {\n+\tquerySpec\n+\n+\t// arg is the command line argument that matched the specified module.\n+\targ string\n+\n+\t// m is the module path and version found by the query.\n+\tm module.Version\n }\n \n func runGet(cmd *base.Command, args []string) {\n@@ -196,7 +249,7 @@ func runGet(cmd *base.Command, args []string) {\n \t}\n \n \tswitch getU {\n-\tcase \"\", \"patch\", \"true\":\n+\tcase \"\", \"latest\", \"patch\":\n \t\t// ok\n \tdefault:\n \t\tbase.Fatalf(\"go get: unknown upgrade flag -u=%s\", getU)\n@@ -207,29 +260,32 @@ func runGet(cmd *base.Command, args []string) {\n \tif *getFix {\n \t\tfmt.Fprintf(os.Stderr, \"go get: -fix flag is a no-op when using modules\\n\")\n \t}\n-\tif *getT {\n-\t\tfmt.Fprintf(os.Stderr, \"go get: -t flag is a no-op when using modules\\n\")\n+\tif *getM {\n+\t\tbase.Fatalf(\"go get: -m flag is no longer supported; consider -d to skip building packages\")\n \t}\n+\tmodload.LoadTests = *getT\n \n \tif cfg.BuildMod == \"vendor\" {\n \t\tbase.Fatalf(\"go get: disabled by -mod=%s\", cfg.BuildMod)\n \t}\n \n-\tmodload.LoadBuildList()\n+\tbuildList := modload.LoadBuildList()\n+\tbuildList = buildList[:len(buildList):len(buildList)] // copy on append\n+\tversionByPath := make(map[string]string)\n+\tfor _, m := range buildList {\n+\t\tversionByPath[m.Path] = m.Version\n+\t}\n \n \t// Do not allow any updating of go.mod until we've applied\n \t// all the requested changes and checked that the result matches\n \t// what was requested.\n \tmodload.DisallowWriteGoMod()\n \n-\t// Build task and install lists.\n-\t// The command-line arguments are of the form path@version\n-\t// or simply path, with implicit @latest. path@none is \"downgrade away\".\n-\t// At the end of the loop, we've resolved the list of arguments into\n-\t// a list of tasks (a path@vers that needs further processing)\n-\t// and a list of install targets (for the \"go install\" at the end).\n-\tvar tasks []*task\n-\tvar install []string\n+\t// Parse command-line arguments and report errors. The command-line\n+\t// arguments are of the form path@version or simply path, with implicit\n+\t// @latest. path@none is \"downgrade away\".\n+\tvar gets []getArg\n+\tvar queries []*query\n \tfor _, arg := range search.CleanPatterns(args) {\n \t\t// Argument is module query path@vers, or else path with implicit @latest.\n \t\tpath := arg\n@@ -241,226 +297,306 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\tbase.Errorf(\"go get %s: invalid module version syntax\", arg)\n \t\t\tcontinue\n \t\t}\n-\t\tif vers != \"none\" {\n-\t\t\tinstall = append(install, path)\n-\t\t}\n-\n-\t\t// Deciding which module to upgrade/downgrade for a particular argument is difficult.\n-\t\t// Patterns only make it more difficult.\n-\t\t// We impose restrictions to avoid needing to interlace pattern expansion,\n-\t\t// like in modload.ImportPaths.\n-\t\t// Specifically, these patterns are supported:\n-\t\t//\n-\t\t//\t- Relative paths like ../../foo or ../../foo... are restricted to matching directories\n-\t\t//\t  in the current module and therefore map to the current module.\n-\t\t//\t  It's possible that the pattern matches no packages, but we will still treat it\n-\t\t//\t  as mapping to the current module.\n-\t\t//\t  TODO: In followup, could just expand the full list and remove the discrepancy.\n-\t\t//\t- The pattern \"all\" has its usual package meaning and maps to the list of modules\n-\t\t//\t  from which the matched packages are drawn. This is potentially a subset of the\n-\t\t//\t  module pattern \"all\". If module A requires B requires C but A does not import\n-\t\t//\t  the parts of B that import C, the packages matched by \"all\" are only from A and B,\n-\t\t//\t  so only A and B end up on the tasks list.\n-\t\t//\t  TODO: Even in -m mode?\n-\t\t//\t- The patterns \"std\" and \"cmd\" expand to packages in the standard library,\n-\t\t//\t  which aren't upgradable, so we skip over those.\n-\t\t//\t  In -m mode they expand to non-module-paths, so they are disallowed.\n-\t\t//\t- Import path patterns like foo/bar... are matched against the module list,\n-\t\t//\t  assuming any package match would imply a module pattern match.\n-\t\t//\t  TODO: What about -m mode?\n-\t\t//\t- Import paths without patterns are left as is, for resolution by getQuery (eventually modload.Import).\n-\t\t//\n-\t\tif search.IsRelativePath(path) {\n-\t\t\t// Check that this relative pattern only matches directories in the current module,\n-\t\t\t// and then record the current module as the target.\n-\t\t\tdir := path\n-\t\t\tif i := strings.Index(path, \"...\"); i >= 0 {\n-\t\t\t\tdir, _ = pathpkg.Split(path[:i])\n-\t\t\t}\n-\t\t\tabs, err := filepath.Abs(dir)\n-\t\t\tif err != nil {\n-\t\t\t\tbase.Errorf(\"go get %s: %v\", arg, err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif !str.HasFilePathPrefix(abs, modload.ModRoot()) {\n-\t\t\t\tbase.Errorf(\"go get %s: directory %s is outside module root %s\", arg, abs, modload.ModRoot())\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t// TODO: Check if abs is inside a nested module.\n-\t\t\ttasks = append(tasks, &task{arg: arg, path: modload.Target.Path, vers: \"\"})\n-\t\t\tcontinue\n+\n+\t\t// If the user runs 'go get -u=patch some/module', update some/module to a\n+\t\t// patch release, not a minor version.\n+\t\tif vers == \"\" && getU != \"\" {\n+\t\t\tvers = string(getU)\n \t\t}\n-\t\tif path == \"all\" {\n-\t\t\t// TODO: If *getM, should this be the module pattern \"all\"?\n-\n-\t\t\t// This is the package pattern \"all\" not the module pattern \"all\":\n-\t\t\t// enumerate all the modules actually needed by builds of the packages\n-\t\t\t// in the main module, not incidental modules that happen to be\n-\t\t\t// in the package graph (and therefore build list).\n-\t\t\t// Note that LoadALL may add new modules to the build list to\n-\t\t\t// satisfy new imports, but vers == \"latest\" implicitly anyway,\n-\t\t\t// so we'll assume that's OK.\n-\t\t\tseen := make(map[module.Version]bool)\n-\t\t\tpkgs := modload.LoadALL()\n-\t\t\tfor _, pkg := range pkgs {\n-\t\t\t\tm := modload.PackageModule(pkg)\n-\t\t\t\tif m.Path != \"\" && !seen[m] {\n-\t\t\t\t\tseen[m] = true\n-\t\t\t\t\ttasks = append(tasks, &task{arg: arg, path: m.Path, vers: \"latest\", forceModulePath: true})\n+\n+\t\tgets = append(gets, getArg{raw: arg, path: path, vers: vers})\n+\n+\t\t// Determine the modules that path refers to, and create queries\n+\t\t// to lookup modules at target versions before loading packages.\n+\t\t// This is an imprecise process, but it helps reduce unnecessary\n+\t\t// queries and package loading. It's also necessary for handling\n+\t\t// patterns like golang.org/x/tools/..., which can't be expanded\n+\t\t// during package loading until they're in the build list.\n+\t\tswitch {\n+\t\tcase search.IsRelativePath(path):\n+\t\t\t// Relative paths like ../../foo or ../../foo... are restricted to\n+\t\t\t// matching packages in the main module. If the path is explicit and\n+\t\t\t// contains no wildcards (...), check that it is a package in\n+\t\t\t// the main module. If the path contains wildcards but matches no\n+\t\t\t// packages, we'll warn after package loading.\n+\t\t\tif !strings.Contains(path, \"...\") {\n+\t\t\t\tpkgPath := modload.DirImportPath(filepath.FromSlash(path))\n+\t\t\t\tif pkgs := modload.TargetPackages(pkgPath); len(pkgs) == 0 {\n+\t\t\t\t\tabs, err := filepath.Abs(path)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\tabs = path\n+\t\t\t\t\t}\n+\t\t\t\t\tbase.Errorf(\"go get %s: path %s is not a package in module rooted at %s\", arg, abs, modload.ModRoot())\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif search.IsMetaPackage(path) {\n-\t\t\t// Already handled \"all\", so this must be \"std\" or \"cmd\",\n-\t\t\t// which are entirely in the standard library.\n+\n \t\t\tif path != arg {\n-\t\t\t\tbase.Errorf(\"go get %s: cannot use pattern %q with explicit version\", arg, arg)\n-\t\t\t}\n-\t\t\tif *getM {\n-\t\t\t\tbase.Errorf(\"go get %s: cannot use pattern %q with -m\", arg, arg)\n+\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n \t\t\t\tcontinue\n \t\t\t}\n+\n+\t\tcase strings.Contains(path, \"...\"):\n+\t\t\t// Wait until we load packages to look up modules.\n+\t\t\t// We don't know yet whether any modules in the build list provide\n+\t\t\t// packages matching the pattern. For example, suppose\n+\t\t\t// golang.org/x/tools and golang.org/x/tools/playground are separate\n+\t\t\t// modules, and only golang.org/x/tools is in the build list. If the\n+\t\t\t// user runs 'go get golang.org/x/tools/playground/...', we should\n+\t\t\t// add a requirement for golang.org/x/tools/playground. We should not\n+\t\t\t// upgrade golang.org/x/tools.\n+\n+\t\tcase path == \"all\":\n+\t\t\t// Don't query modules until we load packages. We'll automatically\n+\t\t\t// look up any missing modules.\n+\n+\t\tcase search.IsMetaPackage(path):\n+\t\t\tbase.Errorf(\"go get %s: explicit requirement on standard-library module %s not allowed\", path, path)\n \t\t\tcontinue\n-\t\t}\n-\t\tif strings.Contains(path, \"...\") {\n-\t\t\t// Apply to modules in build list matched by pattern (golang.org/x/...), if any.\n-\t\t\tmatch := search.MatchPattern(path)\n-\t\t\tmatched := false\n-\t\t\tfor _, m := range modload.BuildList() {\n-\t\t\t\tif match(m.Path) || str.HasPathPrefix(path, m.Path) {\n-\t\t\t\t\ttasks = append(tasks, &task{arg: arg, path: m.Path, vers: vers, forceModulePath: true})\n-\t\t\t\t\tmatched = true\n+\n+\t\tdefault:\n+\t\t\t// The argument is a package path.\n+\t\t\tif pkgs := modload.TargetPackages(path); len(pkgs) != 0 {\n+\t\t\t\t// The path is in the main module. Nothing to query.\n+\t\t\t\tif vers != \"\" && vers != \"latest\" && vers != \"patch\" {\n+\t\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n \t\t\t\t}\n-\t\t\t}\n-\t\t\t// If matched, we're done.\n-\t\t\t// Otherwise assume pattern is inside a single module\n-\t\t\t// (golang.org/x/text/unicode/...) and leave for usual lookup.\n-\t\t\t// Unless we're using -m.\n-\t\t\tif matched {\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tif *getM {\n-\t\t\t\tbase.Errorf(\"go get %s: pattern matches no modules in build list\", arg)\n+\n+\t\t\tfirst := path\n+\t\t\tif i := strings.IndexByte(first, '/'); i >= 0 {\n+\t\t\t\tfirst = path\n+\t\t\t}\n+\t\t\tif !strings.Contains(first, \".\") {\n+\t\t\t\t// The path doesn't have a dot in the first component and cannot be\n+\t\t\t\t// queried as a module. It may be a package in the standard library,\n+\t\t\t\t// which is fine, so don't report an error unless we encounter\n+\t\t\t\t// a problem loading packages below.\n \t\t\t\tcontinue\n \t\t\t}\n+\n+\t\t\t// If we're querying \"latest\" or \"patch\", we need to know the current\n+\t\t\t// version of the module. For \"latest\", we want to avoid accidentally\n+\t\t\t// downgrading from a newer prerelease. For \"patch\", we need to query\n+\t\t\t// the correct minor version.\n+\t\t\t// Here, we check if \"path\" is the name of a module in the build list\n+\t\t\t// (other than the main module) and set prevM if so. If \"path\" isn't\n+\t\t\t// a module in the build list, the current version doesn't matter\n+\t\t\t// since it's either an unknown module or a package within a module\n+\t\t\t// that we'll discover later.\n+\t\t\tq := &query{querySpec: querySpec{path: path, vers: vers}, arg: arg}\n+\t\t\tif v, ok := versionByPath[path]; ok && path != modload.Target.Path {\n+\t\t\t\tq.prevM = module.Version{Path: path, Version: v}\n+\t\t\t\tq.forceModulePath = true\n+\t\t\t}\n+\t\t\tqueries = append(queries, q)\n \t\t}\n-\t\ttasks = append(tasks, &task{arg: arg, path: path, vers: vers})\n \t}\n \tbase.ExitIfErrors()\n \n-\t// Now we've reduced the upgrade/downgrade work to a list of path@vers pairs (tasks).\n-\t// Resolve each one in parallel.\n-\treqs := modload.Reqs()\n-\tvar lookup par.Work\n-\tfor _, t := range tasks {\n-\t\tlookup.Add(t)\n-\t}\n-\tlookup.Do(10, func(item interface{}) {\n-\t\tt := item.(*task)\n-\t\tif t.vers == \"none\" {\n-\t\t\t// Wait for downgrade step.\n-\t\t\tt.m = module.Version{Path: t.path, Version: \"none\"}\n-\t\t\treturn\n+\t// Query modules referenced by command line arguments at requested versions.\n+\t// We need to do this before loading packages since patterns that refer to\n+\t// packages in unknown modules can't be expanded. This also avoids looking\n+\t// up new modules while loading packages, only to downgrade later.\n+\tqueryCache := make(map[querySpec]*query)\n+\tbyPath := runQueries(queryCache, queries, nil)\n+\n+\t// Add missing modules to the build list.\n+\t// We call SetBuildList here and elsewhere, since newUpgrader,\n+\t// ImportPathsQuiet, and other functions read the global build list.\n+\tfor _, q := range queries {\n+\t\tif _, ok := versionByPath[q.m.Path]; !ok && q.m.Version != \"none\" {\n+\t\t\tbuildList = append(buildList, q.m)\n \t\t}\n-\t\tm, err := getQuery(t.path, t.vers, t.forceModulePath)\n-\t\tif err != nil {\n-\t\t\tbase.Errorf(\"go get %v: %v\", t.arg, err)\n-\t\t\treturn\n+\t}\n+\tversionByPath = nil // out of date now; rebuilt later when needed\n+\tmodload.SetBuildList(buildList)\n+\n+\t// Upgrade modules specifically named on the command line. This is our only\n+\t// chance to upgrade modules without root packages (modOnly below).\n+\t// This also skips loading packages at an old version, only to upgrade\n+\t// and reload at a new version.\n+\tupgrade := make(map[string]*query)\n+\tfor path, q := range byPath {\n+\t\tif q.path == q.m.Path && q.m.Version != \"none\" {\n+\t\t\tupgrade[path] = q\n \t\t}\n-\t\tt.m = m\n-\t})\n+\t}\n+\tbuildList, err := mvs.UpgradeAll(modload.Target, newUpgrader(upgrade, nil))\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go get: %v\", err)\n+\t}\n+\tmodload.SetBuildList(buildList)\n \tbase.ExitIfErrors()\n-\n-\t// Now we know the specific version of each path@vers.\n-\t// The final build list will be the union of three build lists:\n-\t//\t1. the original build list\n-\t//\t2. the modules named on the command line (other than @none)\n-\t//\t3. the upgraded requirements of those modules (if upgrading)\n-\t// Start building those lists.\n-\t// This loop collects (2).\n-\t// Also, because the list of paths might have named multiple packages in a single module\n-\t// (or even the same package multiple times), now that we know the module for each\n-\t// package, this loop deduplicates multiple references to a given module.\n-\t// (If a module is mentioned multiple times, the listed target version must be the same each time.)\n-\tvar named []module.Version\n-\tbyPath := make(map[string]*task)\n-\tfor _, t := range tasks {\n-\t\tprev, ok := byPath[t.m.Path]\n-\t\tif prev != nil && prev.m != t.m {\n-\t\t\tbase.Errorf(\"go get: conflicting versions for module %s: %s and %s\", t.m.Path, prev.m.Version, t.m.Version)\n-\t\t\tbyPath[t.m.Path] = nil // sentinel to stop errors\n+\tprevBuildList := buildList\n+\n+\t// Build a set of module paths that we don't plan to load packages from.\n+\t// This includes explicitly requested modules that don't have a root package\n+\t// and modules with a target version of \"none\".\n+\tvar wg sync.WaitGroup\n+\tmodOnly := make(map[string]*query)\n+\tfor _, q := range queries {\n+\t\tif q.m.Version == \"none\" {\n+\t\t\tmodOnly[q.m.Path] = q\n \t\t\tcontinue\n \t\t}\n-\t\tif ok {\n-\t\t\tcontinue // already added\n-\t\t}\n-\t\tbyPath[t.m.Path] = t\n-\t\tif t.m.Version != \"none\" {\n-\t\t\tnamed = append(named, t.m)\n+\t\tif q.path == q.m.Path {\n+\t\t\twg.Add(1)\n+\t\t\tgo func(q *query) {\n+\t\t\t\tif hasPkg, err := modload.ModuleHasRootPackage(q.m); err != nil {\n+\t\t\t\t\tbase.Errorf(\"go get: %v\", err)\n+\t\t\t\t} else if !hasPkg {\n+\t\t\t\t\tmodOnly[q.m.Path] = q\n+\t\t\t\t}\n+\t\t\t\twg.Done()\n+\t\t\t}(q)\n \t\t}\n \t}\n+\twg.Wait()\n \tbase.ExitIfErrors()\n \n-\t// If the modules named on the command line have any dependencies\n-\t// and we're supposed to upgrade dependencies,\n-\t// chase down the full list of upgraded dependencies.\n-\t// This turns required from a not-yet-upgraded (3) to the final (3).\n-\t// (See list above.)\n-\tvar required []module.Version\n-\tif getU != \"\" {\n-\t\tupgraded, err := mvs.UpgradeAll(upgradeTarget, &upgrader{\n-\t\t\tReqs:    modload.Reqs(),\n-\t\t\ttargets: named,\n-\t\t\tpatch:   getU == \"patch\",\n-\t\t\ttasks:   byPath,\n-\t\t})\n+\t// Build a list of arguments that may refer to packages.\n+\tvar pkgPatterns []string\n+\tvar pkgGets []getArg\n+\tfor _, arg := range gets {\n+\t\tif modOnly[arg.path] == nil && arg.vers != \"none\" {\n+\t\t\tpkgPatterns = append(pkgPatterns, arg.path)\n+\t\t\tpkgGets = append(pkgGets, arg)\n+\t\t}\n+\t}\n+\n+\t// Load packages and upgrade the modules that provide them. We do this until\n+\t// we reach a fixed point, since modules providing packages may change as we\n+\t// change versions. This must terminate because the module graph is finite,\n+\t// and the load and upgrade operations may only add and upgrade modules\n+\t// in the build list.\n+\tvar matches []*search.Match\n+\tfor {\n+\t\tvar seenPkgs map[string]bool\n+\t\tseenQuery := make(map[querySpec]bool)\n+\t\tvar queries []*query\n+\t\taddQuery := func(q *query) {\n+\t\t\tif !seenQuery[q.querySpec] {\n+\t\t\t\tseenQuery[q.querySpec] = true\n+\t\t\t\tqueries = append(queries, q)\n+\t\t\t}\n+\t\t}\n+\n+\t\tif len(pkgPatterns) > 0 {\n+\t\t\t// Don't load packages if pkgPatterns is empty. Both\n+\t\t\t// modload.ImportPathsQuiet and ModulePackages convert an empty list\n+\t\t\t// of patterns to []string{\".\"}, which is not what we want.\n+\t\t\tmatches = modload.ImportPathsQuiet(pkgPatterns, imports.AnyTags())\n+\t\t\tseenPkgs = make(map[string]bool)\n+\t\t\tfor i, match := range matches {\n+\t\t\t\targ := pkgGets[i]\n+\n+\t\t\t\tif len(match.Pkgs) == 0 {\n+\t\t\t\t\t// If the pattern did not match any packages, look up a new module.\n+\t\t\t\t\t// If the pattern doesn't match anything on the last iteration,\n+\t\t\t\t\t// we'll print a warning after the outer loop.\n+\t\t\t\t\tif !search.IsRelativePath(arg.path) && !match.Literal && arg.path != \"all\" {\n+\t\t\t\t\t\taddQuery(&query{querySpec: querySpec{path: arg.path, vers: arg.vers}, arg: arg.raw})\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tallStd := true\n+\t\t\t\tfor _, pkg := range match.Pkgs {\n+\t\t\t\t\tif !seenPkgs[pkg] {\n+\t\t\t\t\t\tseenPkgs[pkg] = true\n+\t\t\t\t\t\tif _, _, err := modload.Lookup(\"\", false, pkg); err != nil {\n+\t\t\t\t\t\t\tallStd = false\n+\t\t\t\t\t\t\tbase.Errorf(\"go get %s: %v\", arg.raw, err)\n+\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tm := modload.PackageModule(pkg)\n+\t\t\t\t\tif m.Path == \"\" {\n+\t\t\t\t\t\t// pkg is in the standard library.\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tallStd = false\n+\t\t\t\t\tif m.Path == modload.Target.Path {\n+\t\t\t\t\t\t// pkg is in the main module.\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\taddQuery(&query{querySpec: querySpec{path: m.Path, vers: arg.vers, forceModulePath: true, prevM: m}, arg: arg.raw})\n+\t\t\t\t}\n+\t\t\t\tif allStd && arg.path != arg.raw {\n+\t\t\t\t\tbase.Errorf(\"go get %s: cannot use pattern %q with explicit version\", arg.raw, arg.raw)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tbase.ExitIfErrors()\n+\n+\t\t// Query target versions for modules providing packages matched by\n+\t\t// command line arguments.\n+\t\tbyPath = runQueries(queryCache, queries, modOnly)\n+\n+\t\t// Handle upgrades. This is needed for arguments that didn't match\n+\t\t// modules or matched different modules from a previous iteration. It\n+\t\t// also upgrades modules providing package dependencies if -u is set.\n+\t\tbuildList, err := mvs.UpgradeAll(modload.Target, newUpgrader(byPath, seenPkgs))\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go get: %v\", err)\n \t\t}\n-\t\trequired = upgraded[1:] // slice off upgradeTarget\n+\t\tmodload.SetBuildList(buildList)\n \t\tbase.ExitIfErrors()\n-\t}\n \n-\t// Put together the final build list as described above (1) (2) (3).\n-\t// If we're not using -u, then len(required) == 0 and ReloadBuildList\n-\t// chases down the dependencies of all the named module versions\n-\t// in one operation.\n-\tvar list []module.Version\n-\tlist = append(list, modload.BuildList()...)\n-\tlist = append(list, named...)\n-\tlist = append(list, required...)\n-\tmodload.SetBuildList(list)\n-\tmodload.ReloadBuildList() // note: does not update go.mod\n-\tbase.ExitIfErrors()\n+\t\t// Stop if no changes have been made to the build list.\n+\t\tbuildList = modload.BuildList()\n+\t\teq := len(buildList) == len(prevBuildList)\n+\t\tfor i := 0; eq && i < len(buildList); i++ {\n+\t\t\teq = buildList[i] == prevBuildList[i]\n+\t\t}\n+\t\tif eq {\n+\t\t\tbreak\n+\t\t}\n+\t\tprevBuildList = buildList\n+\t}\n+\tif !*getD {\n+\t\t// Only print warnings after the last iteration,\n+\t\t// and only if we aren't going to build.\n+\t\tsearch.WarnUnmatched(matches)\n+\t}\n \n-\t// Scan for and apply any needed downgrades.\n+\t// Handle downgrades.\n \tvar down []module.Version\n \tfor _, m := range modload.BuildList() {\n-\t\tt := byPath[m.Path]\n-\t\tif t != nil && semver.Compare(m.Version, t.m.Version) > 0 {\n-\t\t\tdown = append(down, module.Version{Path: m.Path, Version: t.m.Version})\n+\t\tq := byPath[m.Path]\n+\t\tif q != nil && semver.Compare(m.Version, q.m.Version) > 0 {\n+\t\t\tdown = append(down, module.Version{Path: m.Path, Version: q.m.Version})\n \t\t}\n \t}\n \tif len(down) > 0 {\n-\t\tlist, err := mvs.Downgrade(modload.Target, modload.Reqs(), down...)\n+\t\tbuildList, err := mvs.Downgrade(modload.Target, modload.Reqs(), down...)\n \t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go get: %v\", err)\n+\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n-\t\tmodload.SetBuildList(list)\n+\t\tmodload.SetBuildList(buildList)\n \t\tmodload.ReloadBuildList() // note: does not update go.mod\n+\t\tbase.ExitIfErrors()\n \t}\n-\tbase.ExitIfErrors()\n \n \t// Scan for any upgrades lost by the downgrades.\n-\tlost := make(map[string]string)\n-\tfor _, m := range modload.BuildList() {\n-\t\tt := byPath[m.Path]\n-\t\tif t != nil && semver.Compare(m.Version, t.m.Version) != 0 {\n-\t\t\tlost[m.Path] = m.Version\n+\tvar lostUpgrades []*query\n+\tif len(down) > 0 {\n+\t\tversionByPath = make(map[string]string)\n+\t\tfor _, m := range modload.BuildList() {\n+\t\t\tversionByPath[m.Path] = m.Version\n+\t\t}\n+\t\tfor _, q := range byPath {\n+\t\t\tif v, ok := versionByPath[q.m.Path]; q.m.Version != \"none\" && (!ok || semver.Compare(v, q.m.Version) != 0) {\n+\t\t\t\tlostUpgrades = append(lostUpgrades, q)\n+\t\t\t}\n \t\t}\n+\t\tsort.Slice(lostUpgrades, func(i, j int) bool {\n+\t\t\treturn lostUpgrades[i].m.Path < lostUpgrades[j].m.Path\n+\t\t})\n \t}\n-\tif len(lost) > 0 {\n+\tif len(lostUpgrades) > 0 {\n \t\tdesc := func(m module.Version) string {\n \t\t\ts := m.Path + \"@\" + m.Version\n \t\t\tt := byPath[m.Path]\n@@ -473,23 +609,22 @@ func runGet(cmd *base.Command, args []string) {\n \t\tfor _, d := range down {\n \t\t\tdownByPath[d.Path] = d\n \t\t}\n+\n \t\tvar buf strings.Builder\n \t\tfmt.Fprintf(&buf, \"go get: inconsistent versions:\")\n-\t\tfor _, t := range tasks {\n-\t\t\tif lost[t.m.Path] == \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t// We lost t because its build list requires a newer version of something in down.\n+\t\treqs := modload.Reqs()\n+\t\tfor _, q := range lostUpgrades {\n+\t\t\t// We lost q because its build list requires a newer version of something in down.\n \t\t\t// Figure out exactly what.\n \t\t\t// Repeatedly constructing the build list is inefficient\n \t\t\t// if there are MANY command-line arguments,\n \t\t\t// but at least all the necessary requirement lists are cached at this point.\n-\t\t\tlist, err := mvs.BuildList(t.m, reqs)\n+\t\t\tlist, err := buildListForLostUpgrade(q.m, reqs)\n \t\t\tif err != nil {\n-\t\t\t\tbase.Fatalf(\"go get: %v\", err)\n+\t\t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t\t}\n \n-\t\t\tfmt.Fprintf(&buf, \"\\n\\t%s\", desc(t.m))\n+\t\t\tfmt.Fprintf(&buf, \"\\n\\t%s\", desc(q.m))\n \t\t\tsep := \" requires\"\n \t\t\tfor _, m := range list {\n \t\t\t\tif down, ok := downByPath[m.Path]; ok && semver.Compare(down.Version, m.Version) < 0 {\n@@ -500,7 +635,12 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\tif sep != \",\" {\n \t\t\t\t// We have no idea why this happened.\n \t\t\t\t// At least report the problem.\n-\t\t\t\tfmt.Fprintf(&buf, \" ended up at %v unexpectedly (please report at golang.org/issue/new)\", lost[t.m.Path])\n+\t\t\t\tif v := versionByPath[q.m.Path]; v == \"\" {\n+\t\t\t\t\tfmt.Fprintf(&buf, \" removed unexpectedly\")\n+\t\t\t\t} else {\n+\t\t\t\t\tfmt.Fprintf(&buf, \" ended up at %s unexpectedly\", v)\n+\t\t\t\t}\n+\t\t\t\tfmt.Fprintf(&buf, \" (please report at golang.org/issue/new)\")\n \t\t\t}\n \t\t}\n \t\tbase.Fatalf(\"%v\", buf.String())\n@@ -510,150 +650,292 @@ func runGet(cmd *base.Command, args []string) {\n \tmodload.AllowWriteGoMod()\n \tmodload.WriteGoMod()\n \n-\t// If -m was specified, we're done after the module work. No download, no build.\n-\tif *getM {\n+\t// If -d was specified, we're done after the module work.\n+\t// We've already downloaded modules by loading packages above.\n+\t// Otherwise, we need to build and install the packages matched by\n+\t// command line arguments. This may be a different set of packages,\n+\t// since we only build packages for the target platform.\n+\t// Note that 'go get -u' without arguments is equivalent to\n+\t// 'go get -u .', so we'll typically build the package in the current\n+\t// directory.\n+\tif *getD || len(pkgPatterns) == 0 {\n \t\treturn\n \t}\n+\twork.BuildInit()\n+\tpkgs := load.PackagesForBuild(pkgPatterns)\n+\twork.InstallPackages(pkgPatterns, pkgs)\n+}\n \n-\tif len(install) > 0 {\n-\t\t// All requested versions were explicitly @none.\n-\t\t// Note that 'go get -u' without any arguments results in len(install) == 1:\n-\t\t// search.CleanImportPaths returns \".\" for empty args.\n-\t\twork.BuildInit()\n-\t\tpkgs := load.PackagesAndErrors(install)\n-\t\tvar todo []*load.Package\n-\t\tfor _, p := range pkgs {\n-\t\t\t// Ignore \"no Go source files\" errors for 'go get' operations on modules.\n-\t\t\tif p.Error != nil {\n-\t\t\t\tif len(args) == 0 && getU != \"\" && strings.HasPrefix(p.Error.Err, \"no Go files\") {\n-\t\t\t\t\t// Upgrading modules: skip the implicitly-requested package at the\n-\t\t\t\t\t// current directory, even if it is not tho module root.\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tif strings.Contains(p.Error.Err, \"cannot find module providing\") && modload.ModuleInfo(p.ImportPath) != nil {\n-\t\t\t\t\t// Explicitly-requested module, but it doesn't contain a package at the\n-\t\t\t\t\t// module root.\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t\tbase.Errorf(\"%s\", p.Error)\n-\t\t\t}\n-\t\t\ttodo = append(todo, p)\n+// runQueries looks up modules at target versions in parallel. Results will be\n+// cached. If the same module is referenced by multiple queries at different\n+// versions (including earlier queries in the modOnly map), an error will be\n+// reported. A map from module paths to queries is returned, which includes\n+// queries and modOnly.\n+func runQueries(cache map[querySpec]*query, queries []*query, modOnly map[string]*query) map[string]*query {\n+\tvar lookup par.Work\n+\tfor _, q := range queries {\n+\t\tif cached := cache[q.querySpec]; cached != nil {\n+\t\t\t*q = *cached\n+\t\t} else {\n+\t\t\tcache[q.querySpec] = q\n+\t\t\tlookup.Add(q)\n \t\t}\n-\t\tbase.ExitIfErrors()\n+\t}\n+\n+\tlookup.Do(10, func(item interface{}) {\n+\t\tq := item.(*query)\n+\t\tif q.vers == \"none\" {\n+\t\t\t// Wait for downgrade step.\n+\t\t\tq.m = module.Version{Path: q.path, Version: \"none\"}\n+\t\t\treturn\n+\t\t}\n+\t\tm, err := getQuery(q.path, q.vers, q.prevM, q.forceModulePath)\n+\t\tif err != nil {\n+\t\t\tbase.Errorf(\"go get %s: %v\", q.arg, err)\n+\t\t}\n+\t\tq.m = m\n+\t})\n+\tbase.ExitIfErrors()\n \n-\t\t// If -d was specified, we're done after the download: no build.\n-\t\t// (The load.PackagesAndErrors is what did the download\n-\t\t// of the named packages and their dependencies.)\n-\t\tif len(todo) > 0 && !*getD {\n-\t\t\twork.InstallPackages(install, todo)\n+\tbyPath := make(map[string]*query)\n+\tcheck := func(q *query) {\n+\t\tif prev, ok := byPath[q.m.Path]; prev != nil && prev.m != q.m {\n+\t\t\tbase.Errorf(\"go get: conflicting versions for module %s: %s and %s\", q.m.Path, prev.m.Version, q.m.Version)\n+\t\t\tbyPath[q.m.Path] = nil // sentinel to stop errors\n+\t\t\treturn\n+\t\t} else if !ok {\n+\t\t\tbyPath[q.m.Path] = q\n \t\t}\n \t}\n+\tfor _, q := range queries {\n+\t\tcheck(q)\n+\t}\n+\tfor _, q := range modOnly {\n+\t\tcheck(q)\n+\t}\n+\tbase.ExitIfErrors()\n+\n+\treturn byPath\n }\n \n // getQuery evaluates the given package path, version pair\n // to determine the underlying module version being requested.\n // If forceModulePath is set, getQuery must interpret path\n // as a module path.\n-func getQuery(path, vers string, forceModulePath bool) (module.Version, error) {\n-\tif vers == \"\" {\n+func getQuery(path, vers string, prevM module.Version, forceModulePath bool) (module.Version, error) {\n+\tif (prevM.Version != \"\") != forceModulePath {\n+\t\t// We resolve package patterns by calling QueryPattern, which does not\n+\t\t// accept a previous version and therefore cannot take it into account for\n+\t\t// the \"latest\" or \"patch\" queries.\n+\t\t// If we are resolving a package path or pattern, the caller has already\n+\t\t// resolved any existing packages to their containing module(s), and\n+\t\t// will set both prevM.Version and forceModulePath for those modules.\n+\t\t// The only remaining package patterns are those that are not already\n+\t\t// provided by the build list, which are indicated by\n+\t\t// an empty prevM.Version.\n+\t\tbase.Fatalf(\"go get: internal error: prevM may be set if and only if forceModulePath is set\")\n+\t}\n+\n+\tif vers == \"\" || vers == \"patch\" && prevM.Version == \"\" {\n \t\tvers = \"latest\"\n \t}\n \n-\t// First choice is always to assume path is a module path.\n-\t// If that works out, we're done.\n-\tinfo, err := modload.Query(path, vers, modload.Allowed)\n-\tif err == nil {\n-\t\treturn module.Version{Path: path, Version: info.Version}, nil\n+\tif forceModulePath || !strings.Contains(path, \"...\") {\n+\t\tif path == modload.Target.Path {\n+\t\t\tif vers != \"latest\" {\n+\t\t\t\treturn module.Version{}, fmt.Errorf(\"can't get a specific version of the main module\")\n+\t\t\t}\n+\t\t}\n+\n+\t\t// If the path doesn't contain a wildcard, try interpreting it as a module path.\n+\t\tinfo, err := modload.Query(path, vers, prevM.Version, modload.Allowed)\n+\t\tif err == nil {\n+\t\t\treturn module.Version{Path: path, Version: info.Version}, nil\n+\t\t}\n+\n+\t\t// If the query fails, and the path must be a real module, report the query error.\n+\t\tif forceModulePath {\n+\t\t\treturn module.Version{}, err\n+\t\t}\n \t}\n \n-\t// Even if the query fails, if the path must be a real module, then report the query error.\n-\tif forceModulePath || *getM {\n+\t// Otherwise, try a package path or pattern.\n+\tresults, err := modload.QueryPattern(path, vers, modload.Allowed)\n+\tif err != nil {\n \t\treturn module.Version{}, err\n \t}\n-\n-\t// Otherwise, try a package path.\n-\tm, _, err := modload.QueryPackage(path, vers, modload.Allowed)\n-\treturn m, err\n+\treturn results[0].Mod, nil\n }\n \n // An upgrader adapts an underlying mvs.Reqs to apply an\n // upgrade policy to a list of targets and their dependencies.\n-// If patch=false, the upgrader implements \"get -u\".\n-// If patch=true, the upgrader implements \"get -u=patch\".\n type upgrader struct {\n \tmvs.Reqs\n-\ttargets []module.Version\n-\tpatch   bool\n-\ttasks   map[string]*task\n+\n+\t// cmdline maps a module path to a query made for that module at a\n+\t// specific target version. Each query corresponds to a module\n+\t// matched by a command line argument.\n+\tcmdline map[string]*query\n+\n+\t// upgrade is a set of modules providing dependencies of packages\n+\t// matched by command line arguments. If -u or -u=patch is set,\n+\t// these modules are upgraded accordingly.\n+\tupgrade map[string]bool\n }\n \n-// upgradeTarget is a fake \"target\" requiring all the modules to be upgraded.\n-var upgradeTarget = module.Version{Path: \"upgrade target\", Version: \"\"}\n+// newUpgrader creates an upgrader. cmdline contains queries made at\n+// specific versions for modules matched by command line arguments. pkgs\n+// is the set of packages matched by command line arguments. If -u or -u=patch\n+// is set, modules providing dependencies of pkgs are upgraded accordingly.\n+func newUpgrader(cmdline map[string]*query, pkgs map[string]bool) *upgrader {\n+\tu := &upgrader{\n+\t\tReqs:    modload.Reqs(),\n+\t\tcmdline: cmdline,\n+\t}\n+\tif getU != \"\" {\n+\t\tu.upgrade = make(map[string]bool)\n+\n+\t\t// Traverse package import graph.\n+\t\t// Initialize work queue with root packages.\n+\t\tseen := make(map[string]bool)\n+\t\tvar work []string\n+\t\tadd := func(path string) {\n+\t\t\tif !seen[path] {\n+\t\t\t\tseen[path] = true\n+\t\t\t\twork = append(work, path)\n+\t\t\t}\n+\t\t}\n+\t\tfor pkg := range pkgs {\n+\t\t\tadd(pkg)\n+\t\t}\n+\t\tfor len(work) > 0 {\n+\t\t\tpkg := work[0]\n+\t\t\twork = work[1:]\n+\t\t\tm := modload.PackageModule(pkg)\n+\t\t\tu.upgrade[m.Path] = true\n+\n+\t\t\t// testImports is empty unless test imports were actually loaded,\n+\t\t\t// i.e., -t was set or \"all\" was one of the arguments.\n+\t\t\timports, testImports := modload.PackageImports(pkg)\n+\t\t\tfor _, imp := range imports {\n+\t\t\t\tadd(imp)\n+\t\t\t}\n+\t\t\tfor _, imp := range testImports {\n+\t\t\t\tadd(imp)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn u\n+}\n \n // Required returns the requirement list for m.\n-// Other than the upgradeTarget, we defer to u.Reqs.\n+// For the main module, we override requirements with the modules named\n+// one the command line, and we include new requirements. Otherwise,\n+// we defer to u.Reqs.\n func (u *upgrader) Required(m module.Version) ([]module.Version, error) {\n-\tif m == upgradeTarget {\n-\t\treturn u.targets, nil\n+\trs, err := u.Reqs.Required(m)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tif m != modload.Target {\n+\t\treturn rs, nil\n+\t}\n+\n+\toverridden := make(map[string]bool)\n+\tfor i, m := range rs {\n+\t\tif q := u.cmdline[m.Path]; q != nil && q.m.Version != \"none\" {\n+\t\t\trs[i] = q.m\n+\t\t\toverridden[q.m.Path] = true\n+\t\t}\n+\t}\n+\tfor _, q := range u.cmdline {\n+\t\tif !overridden[q.m.Path] && q.m.Path != modload.Target.Path && q.m.Version != \"none\" {\n+\t\t\trs = append(rs, q.m)\n+\t\t}\n \t}\n-\treturn u.Reqs.Required(m)\n+\treturn rs, nil\n }\n \n // Upgrade returns the desired upgrade for m.\n-// If m is a tagged version, then Upgrade returns the latest tagged version.\n+//\n+// If m was requested at a specific version on the command line, then\n+// Upgrade returns that version.\n+//\n+// If -u is set and m provides a dependency of a package matched by\n+// command line arguments, then Upgrade may provider a newer tagged version.\n+// If m is a tagged version, then Upgrade will return the latest tagged\n+// version (with the same minor version number if -u=patch).\n // If m is a pseudo-version, then Upgrade returns the latest tagged version\n-// when that version has a time-stamp newer than m.\n-// Otherwise Upgrade returns m (preserving the pseudo-version).\n-// This special case prevents accidental downgrades\n-// when already using a pseudo-version newer than the latest tagged version.\n+// only if that version has a time-stamp newer than m. This special case\n+// prevents accidental downgrades when already using a pseudo-version\n+// newer than the latest tagged version.\n+//\n+// If none of the above cases apply, then Upgrade returns m.\n func (u *upgrader) Upgrade(m module.Version) (module.Version, error) {\n \t// Allow pkg@vers on the command line to override the upgrade choice v.\n-\t// If t's version is < v, then we're going to downgrade anyway,\n+\t// If q's version is < m.Version, then we're going to downgrade anyway,\n \t// and it's cleaner to avoid moving back and forth and picking up\n \t// extraneous other newer dependencies.\n-\t// If t's version is > v, then we're going to upgrade past v anyway,\n-\t// and again it's cleaner to avoid moving back and forth picking up\n-\t// extraneous other newer dependencies.\n-\tif t := u.tasks[m.Path]; t != nil {\n-\t\treturn t.m, nil\n-\t}\n-\n-\t// Note that query \"latest\" is not the same as\n-\t// using repo.Latest.\n-\t// The query only falls back to untagged versions\n-\t// if nothing is tagged. The Latest method\n-\t// only ever returns untagged versions,\n-\t// which is not what we want.\n-\tquery := \"latest\"\n-\tif u.patch {\n-\t\t// For patch upgrade, query \"v1.2\".\n-\t\tquery = semver.MajorMinor(m.Version)\n-\t}\n-\tinfo, err := modload.Query(m.Path, query, modload.Allowed)\n+\t// If q's version is > m.Version, then we're going to upgrade past\n+\t// m.Version anyway, and again it's cleaner to avoid moving back and forth\n+\t// picking up extraneous other newer dependencies.\n+\tif q := u.cmdline[m.Path]; q != nil {\n+\t\treturn q.m, nil\n+\t}\n+\n+\tif !u.upgrade[m.Path] {\n+\t\t// Not involved in upgrade. Leave alone.\n+\t\treturn m, nil\n+\t}\n+\n+\t// Run query required by upgrade semantics.\n+\t// Note that Query \"latest\" is not the same as using repo.Latest,\n+\t// which may return a pseudoversion for the latest commit.\n+\t// Query \"latest\" returns the newest tagged version or the newest\n+\t// prerelease version if there are no non-prereleases, or repo.Latest\n+\t// if there aren't any tagged versions. Since we're providing the previous\n+\t// version, Query will confirm the latest version is actually newer\n+\t// and will return the current version if not.\n+\tinfo, err := modload.Query(m.Path, string(getU), m.Version, modload.Allowed)\n \tif err != nil {\n \t\t// Report error but return m, to let version selection continue.\n \t\t// (Reporting the error will fail the command at the next base.ExitIfErrors.)\n \t\t// Special case: if the error is \"no matching versions\" then don't\n \t\t// even report the error. Because Query does not consider pseudo-versions,\n \t\t// it may happen that we have a pseudo-version but during -u=patch\n \t\t// the query v0.0 matches no versions (not even the one we're using).\n-\t\tif !strings.Contains(err.Error(), \"no matching versions\") {\n+\t\tvar noMatch *modload.NoMatchingVersionError\n+\t\tif !errors.As(err, &noMatch) {\n \t\t\tbase.Errorf(\"go get: upgrading %s@%s: %v\", m.Path, m.Version, err)\n \t\t}\n \t\treturn m, nil\n \t}\n \n-\t// If we're on a later prerelease, keep using it,\n-\t// even though normally an Upgrade will ignore prereleases.\n-\tif semver.Compare(info.Version, m.Version) < 0 {\n-\t\treturn m, nil\n-\t}\n+\treturn module.Version{Path: m.Path, Version: info.Version}, nil\n+}\n \n-\t// If we're on a pseudo-version chronologically after the latest tagged version, keep using it.\n-\t// This avoids some accidental downgrades.\n-\tif mTime, err := modfetch.PseudoVersionTime(m.Version); err == nil && info.Time.Before(mTime) {\n-\t\treturn m, nil\n-\t}\n+// buildListForLostUpgrade returns the build list for the module graph\n+// rooted at lost. Unlike mvs.BuildList, the target module (lost) is not\n+// treated specially. The returned build list may contain a newer version\n+// of lost.\n+//\n+// buildListForLostUpgrade is used after a downgrade has removed a module\n+// requested at a specific version. This helps us understand the requirements\n+// implied by each downgrade.\n+func buildListForLostUpgrade(lost module.Version, reqs mvs.Reqs) ([]module.Version, error) {\n+\treturn mvs.BuildList(lostUpgradeRoot, &lostUpgradeReqs{Reqs: reqs, lost: lost})\n+}\n \n-\treturn module.Version{Path: m.Path, Version: info.Version}, nil\n+var lostUpgradeRoot = module.Version{Path: \"lost-upgrade-root\", Version: \"\"}\n+\n+type lostUpgradeReqs struct {\n+\tmvs.Reqs\n+\tlost module.Version\n+}\n+\n+func (r *lostUpgradeReqs) Required(mod module.Version) ([]module.Version, error) {\n+\tif mod == lostUpgradeRoot {\n+\t\treturn []module.Version{r.lost}, nil\n+\t}\n+\treturn r.Reqs.Required(mod)\n }"}, {"sha": "07248d1a61cb837be4d1cc7e6574407f6eb651a1", "filename": "libgo/go/cmd/go/internal/modinfo/info.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodinfo%2Finfo.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -20,8 +20,8 @@ type ModulePublic struct {\n \tIndirect  bool          `json:\",omitempty\"` // module is only indirectly needed by main module\n \tDir       string        `json:\",omitempty\"` // directory holding local copy of files, if any\n \tGoMod     string        `json:\",omitempty\"` // path to go.mod file describing module, if any\n-\tError     *ModuleError  `json:\",omitempty\"` // error loading module\n \tGoVersion string        `json:\",omitempty\"` // go version used in module\n+\tError     *ModuleError  `json:\",omitempty\"` // error loading module\n }\n \n type ModuleError struct {"}, {"sha": "17a65216c2a21c9302a090c06cf3888697ea2e80", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"cmd/go/internal/modinfo\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/semver\"\n \t\"encoding/hex\"\n \t\"fmt\"\n \t\"internal/goroot\"\n@@ -38,9 +39,6 @@ func findStandardImportPath(path string) string {\n \t\tif goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n \t\t\treturn filepath.Join(cfg.GOROOT, \"src\", path)\n \t\t}\n-\t\tif goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, \"vendor/\"+path) {\n-\t\t\treturn filepath.Join(cfg.GOROOT, \"src/vendor\", path)\n-\t\t}\n \t}\n \treturn \"\"\n }\n@@ -77,13 +75,15 @@ func ModuleInfo(path string) *modinfo.ModulePublic {\n \n // addUpdate fills in m.Update if an updated version is available.\n func addUpdate(m *modinfo.ModulePublic) {\n-\tif m.Version != \"\" {\n-\t\tif info, err := Query(m.Path, \"latest\", Allowed); err == nil && info.Version != m.Version {\n-\t\t\tm.Update = &modinfo.ModulePublic{\n-\t\t\t\tPath:    m.Path,\n-\t\t\t\tVersion: info.Version,\n-\t\t\t\tTime:    &info.Time,\n-\t\t\t}\n+\tif m.Version == \"\" {\n+\t\treturn\n+\t}\n+\n+\tif info, err := Query(m.Path, \"latest\", m.Version, Allowed); err == nil && semver.Compare(info.Version, m.Version) > 0 {\n+\t\tm.Update = &modinfo.ModulePublic{\n+\t\t\tPath:    m.Path,\n+\t\t\tVersion: info.Version,\n+\t\t\tTime:    &info.Time,\n \t\t}\n \t}\n }\n@@ -127,7 +127,7 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t// complete fills in the extra fields in m.\n \tcomplete := func(m *modinfo.ModulePublic) {\n \t\tif m.Version != \"\" {\n-\t\t\tif q, err := Query(m.Path, m.Version, nil); err != nil {\n+\t\t\tif q, err := Query(m.Path, m.Version, \"\", nil); err != nil {\n \t\t\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n \t\t\t} else {\n \t\t\t\tm.Version = q.Version\n@@ -219,7 +219,7 @@ func PackageBuildInfo(path string, deps []string) string {\n \t\tif r.Path == \"\" {\n \t\t\th = \"\\t\" + modfetch.Sum(mod)\n \t\t}\n-\t\tfmt.Fprintf(&buf, \"dep\\t%s\\t%s%s\\n\", mod.Path, mod.Version, h)\n+\t\tfmt.Fprintf(&buf, \"dep\\t%s\\t%s%s\\n\", mod.Path, mv, h)\n \t\tif r.Path != \"\" {\n \t\t\tfmt.Fprintf(&buf, \"=>\\t%s\\t%s\\t%s\\n\", r.Path, r.Version, modfetch.Sum(r))\n \t\t}\n@@ -250,20 +250,16 @@ func findModule(target, path string) module.Version {\n }\n \n func ModInfoProg(info string) []byte {\n-\t// Inject a variable with the debug information as runtime/debug.modinfo,\n+\t// Inject a variable with the debug information as runtime.modinfo,\n \t// but compile it in package main so that it is specific to the binary.\n-\t//\n \t// The variable must be a literal so that it will have the correct value\n \t// before the initializer for package main runs.\n \t//\n-\t// We also want the value to be present even if runtime/debug.modinfo is\n-\t// otherwise unused in the rest of the program. Reading it in an init function\n-\t// suffices for now.\n-\n+\t// The runtime startup code refers to the variable, which keeps it live in all binaries.\n \treturn []byte(fmt.Sprintf(`package main\n import _ \"unsafe\"\n-//go:linkname __set_debug_modinfo__ runtime..z2fdebug.setmodinfo\n-func __set_debug_modinfo__(string)\n-func init() { __set_debug_modinfo__(%q) }\n+//go:linkname __set_modinfo__ runtime.setmodinfo\n+func __set_modinfo__(string)\n+func init() { __set_modinfo__(%q) }\n \t`, string(infoStart)+info+string(infoEnd)))\n }"}, {"sha": "788544c2c85177ca10ff36240c1da424e22323ae", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -19,34 +19,28 @@ including recording and resolving dependencies on other modules.\n Modules replace the old GOPATH-based approach to specifying\n which source files are used in a given build.\n \n-Preliminary module support\n-\n-Go 1.11 includes preliminary support for Go modules,\n-including a new module-aware 'go get' command.\n-We intend to keep revising this support, while preserving compatibility,\n-until it can be declared official (no longer preliminary),\n-and then at a later point we may remove support for work\n-in GOPATH and the old 'go get' command.\n-\n-The quickest way to take advantage of the new Go 1.11 module support\n-is to check out your repository into a directory outside GOPATH/src,\n-create a go.mod file (described in the next section) there, and run\n+Module support\n+\n+Go 1.13 includes support for Go modules. Module-aware mode is active by default\n+whenever a go.mod file is found in, or in a parent of, the current directory.\n+\n+The quickest way to take advantage of module support is to check out your\n+repository, create a go.mod file (described in the next section) there, and run\n go commands from within that file tree.\n \n-For more fine-grained control, the module support in Go 1.11 respects\n+For more fine-grained control, Go 1.13 continues to respect\n a temporary environment variable, GO111MODULE, which can be set to one\n of three string values: off, on, or auto (the default).\n-If GO111MODULE=off, then the go command never uses the\n-new module support. Instead it looks in vendor directories and GOPATH\n-to find dependencies; we now refer to this as \"GOPATH mode.\"\n If GO111MODULE=on, then the go command requires the use of modules,\n-never consulting GOPATH. We refer to this as the command being\n-module-aware or running in \"module-aware mode\".\n-If GO111MODULE=auto or is unset, then the go command enables or\n-disables module support based on the current directory.\n-Module support is enabled only when the current directory is outside\n-GOPATH/src and itself contains a go.mod file or is below a directory\n-containing a go.mod file.\n+never consulting GOPATH. We refer to this as the command\n+being module-aware or running in \"module-aware mode\".\n+If GO111MODULE=off, then the go command never uses\n+module support. Instead it looks in vendor directories and GOPATH\n+to find dependencies; we now refer to this as \"GOPATH mode.\"\n+If GO111MODULE=auto or is unset, then the go command enables or disables\n+module support based on the current directory.\n+Module support is enabled only when the current directory contains a\n+go.mod file or is below a directory containing a go.mod file.\n \n In module-aware mode, GOPATH no longer defines the meaning of imports\n during a build, but it still stores downloaded dependencies (in GOPATH/pkg/mod)\n@@ -337,26 +331,35 @@ module file trees.\n \n Module downloading and verification\n \n-The go command maintains, in the main module's root directory alongside\n-go.mod, a file named go.sum containing the expected cryptographic checksums\n-of the content of specific module versions. Each time a dependency is\n-used, its checksum is added to go.sum if missing or else required to match\n-the existing entry in go.sum.\n-\n-The go command maintains a cache of downloaded packages and computes\n-and records the cryptographic checksum of each package at download time.\n-In normal operation, the go command checks these pre-computed checksums\n-against the main module's go.sum file, instead of recomputing them on\n-each command invocation. The 'go mod verify' command checks that\n-the cached copies of module downloads still match both their recorded\n-checksums and the entries in go.sum.\n-\n-The go command can fetch modules from a proxy instead of connecting\n-to source control systems directly, according to the setting of the GOPROXY\n-environment variable.\n-\n-See 'go help goproxy' for details about the proxy and also the format of\n-the cached downloaded packages.\n+The go command can fetch modules from a proxy or connect to source control\n+servers directly, according to the setting of the GOPROXY environment\n+variable (see 'go help env'). The default setting for GOPROXY is\n+\"https://proxy.golang.org,direct\", which means to try the\n+Go module mirror run by Google and fall back to a direct connection\n+if the proxy reports that it does not have the module (HTTP error 404 or 410).\n+See https://proxy.golang.org/privacy for the service's privacy policy.\n+If GOPROXY is set to the string \"direct\", downloads use a direct connection\n+to source control servers. Setting GOPROXY to \"off\" disallows downloading\n+modules from any source. Otherwise, GOPROXY is expected to be a comma-separated\n+list of the URLs of module proxies, in which case the go command will fetch\n+modules from those proxies. For each request, the go command tries each proxy\n+in sequence, only moving to the next if the current proxy returns a 404 or 410\n+HTTP response. The string \"direct\" may appear in the proxy list,\n+to cause a direct connection to be attempted at that point in the search.\n+Any proxies listed after \"direct\" are never consulted.\n+\n+The GOPRIVATE and GONOPROXY environment variables allow bypassing\n+the proxy for selected modules. See 'go help module-private' for details.\n+\n+No matter the source of the modules, the go command checks downloads against\n+known checksums, to detect unexpected changes in the content of any specific\n+module version from one day to the next. This check first consults the current\n+module's go.sum file but falls back to the Go checksum database, controlled by\n+the GOSUMDB and GONOSUMDB environment variables. See 'go help module-auth'\n+for details.\n+\n+See 'go help goproxy' for details about the proxy protocol and also\n+the format of the cached downloaded packages.\n \n Modules and vendoring\n \n@@ -461,5 +464,12 @@ Because the module graph defines the meaning of import statements, any\n commands that load packages also use and therefore update go.mod,\n including go build, go get, go install, go list, go test, go mod graph,\n go mod tidy, and go mod why.\n+\n+The expected language version, set by the go directive, determines\n+which language features are available when compiling the module.\n+Language features available in that version will be available for use.\n+Language features removed in earlier versions, or added in later versions,\n+will not be available. Note that the language version does not affect\n+build tags, which are determined by the Go release being used.\n \t`,\n }"}, {"sha": "dacc876701a0cad75c44d5ce386f63c9add98e99", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -18,7 +18,6 @@ import (\n \n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n@@ -28,6 +27,10 @@ import (\n type ImportMissingError struct {\n \tImportPath string\n \tModule     module.Version\n+\n+\t// newMissingVersion is set to a newer version of Module if one is present\n+\t// in the build list. When set, we can't automatically upgrade.\n+\tnewMissingVersion string\n }\n \n func (e *ImportMissingError) Error() string {\n@@ -61,17 +64,21 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t}\n \n \t// Is the package in the standard library?\n-\tif search.IsStandardImportPath(path) {\n-\t\tif goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n-\t\t\tdir := filepath.Join(cfg.GOROOT, \"src\", path)\n-\t\t\treturn module.Version{}, dir, nil\n+\tif search.IsStandardImportPath(path) &&\n+\t\tgoroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n+\t\tif targetInGorootSrc {\n+\t\t\tif dir, ok := dirInModule(path, targetPrefix, ModRoot(), true); ok {\n+\t\t\t\treturn Target, dir, nil\n+\t\t\t}\n \t\t}\n+\t\tdir := filepath.Join(cfg.GOROOT, \"src\", path)\n+\t\treturn module.Version{}, dir, nil\n \t}\n \n \t// -mod=vendor is special.\n \t// Everything must be in the main module or the main module's vendor directory.\n \tif cfg.BuildMod == \"vendor\" {\n-\t\tmainDir, mainOK := dirInModule(path, Target.Path, ModRoot(), true)\n+\t\tmainDir, mainOK := dirInModule(path, targetPrefix, ModRoot(), true)\n \t\tvendorDir, vendorOK := dirInModule(path, \"\", filepath.Join(ModRoot(), \"vendor\"), false)\n \t\tif mainOK && vendorOK {\n \t\t\treturn module.Version{}, \"\", fmt.Errorf(\"ambiguous import: found %s in multiple directories:\\n\\t%s\\n\\t%s\", path, mainDir, vendorDir)\n@@ -178,14 +185,37 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t}\n \t}\n \n-\tm, _, err = QueryPackage(path, \"latest\", Allowed)\n+\tcandidates, err := QueryPackage(path, \"latest\", Allowed)\n \tif err != nil {\n-\t\tif _, ok := err.(*codehost.VCSError); ok {\n+\t\tif errors.Is(err, os.ErrNotExist) {\n+\t\t\t// Return \"cannot find module providing package [\u2026]\" instead of whatever\n+\t\t\t// low-level error QueryPackage produced.\n+\t\t\treturn module.Version{}, \"\", &ImportMissingError{ImportPath: path}\n+\t\t} else {\n \t\t\treturn module.Version{}, \"\", err\n \t\t}\n-\t\treturn module.Version{}, \"\", &ImportMissingError{ImportPath: path}\n \t}\n-\treturn m, \"\", &ImportMissingError{ImportPath: path, Module: m}\n+\tm = candidates[0].Mod\n+\tnewMissingVersion := \"\"\n+\tfor _, c := range candidates {\n+\t\tcm := c.Mod\n+\t\tfor _, bm := range buildList {\n+\t\t\tif bm.Path == cm.Path && semver.Compare(bm.Version, cm.Version) > 0 {\n+\t\t\t\t// QueryPackage proposed that we add module cm to provide the package,\n+\t\t\t\t// but we already depend on a newer version of that module (and we don't\n+\t\t\t\t// have the package).\n+\t\t\t\t//\n+\t\t\t\t// This typically happens when a package is present at the \"@latest\"\n+\t\t\t\t// version (e.g., v1.0.0) of a module, but we have a newer version\n+\t\t\t\t// of the same module in the build list (e.g., v1.0.1-beta), and\n+\t\t\t\t// the package is not present there.\n+\t\t\t\tm = cm\n+\t\t\t\tnewMissingVersion = bm.Version\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn m, \"\", &ImportMissingError{ImportPath: path, Module: m, newMissingVersion: newMissingVersion}\n }\n \n // maybeInModule reports whether, syntactically,\n@@ -229,8 +259,8 @@ func dirInModule(path, mpath, mdir string, isLocal bool) (dir string, haveGoFile\n \tif isLocal {\n \t\tfor d := dir; d != mdir && len(d) > len(mdir); {\n \t\t\thaveGoMod := haveGoModCache.Do(d, func() interface{} {\n-\t\t\t\t_, err := os.Stat(filepath.Join(d, \"go.mod\"))\n-\t\t\t\treturn err == nil\n+\t\t\t\tfi, err := os.Stat(filepath.Join(d, \"go.mod\"))\n+\t\t\t\treturn err == nil && !fi.IsDir()\n \t\t\t}).(bool)\n \n \t\t\tif haveGoMod {"}, {"sha": "c6ade5d17f4e00a38a3b78d1bceb8a3a46d79fee", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -21,7 +21,7 @@ var importTests = []struct {\n \t},\n \t{\n \t\tpath: \"golang.org/x/net\",\n-\t\terr:  \"cannot find module providing package golang.org/x/net\",\n+\t\terr:  \"module golang.org/x/net@.* found, but does not contain package golang.org/x/net\",\n \t},\n \t{\n \t\tpath: \"golang.org/x/text\",\n@@ -43,6 +43,7 @@ var importTests = []struct {\n \n func TestImport(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \tfor _, tt := range importTests {\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {"}, {"sha": "807ce8d5dc5fe290d6ee66f2a17d0e03ca0a3488", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 163, "deletions": 124, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -6,6 +6,18 @@ package modload\n \n import (\n \t\"bytes\"\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"go/build\"\n+\t\"internal/lazyregexp\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"runtime/debug\"\n+\t\"strconv\"\n+\t\"strings\"\n+\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n@@ -18,22 +30,11 @@ import (\n \t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/renameio\"\n \t\"cmd/go/internal/search\"\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"go/build\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"path\"\n-\t\"path/filepath\"\n-\t\"regexp\"\n-\t\"runtime/debug\"\n-\t\"strconv\"\n-\t\"strings\"\n )\n \n var (\n \tcwd            string // TODO(bcmills): Is this redundant with base.Cwd?\n-\tMustUseModules = mustUseModules()\n+\tmustUseModules = false\n \tinitialized    bool\n \n \tmodRoot     string\n@@ -42,6 +43,15 @@ var (\n \texcluded    map[module.Version]bool\n \tTarget      module.Version\n \n+\t// targetPrefix is the path prefix for packages in Target, without a trailing\n+\t// slash. For most modules, targetPrefix is just Target.Path, but the\n+\t// standard-library module \"std\" has an empty prefix.\n+\ttargetPrefix string\n+\n+\t// targetInGorootSrc caches whether modRoot is within GOROOT/src.\n+\t// The \"std\" module is special within GOROOT/src, but not otherwise.\n+\ttargetInGorootSrc bool\n+\n \tgopath string\n \n \tCmdModInit   bool   // running 'go mod init'\n@@ -69,18 +79,6 @@ func BinDir() string {\n \treturn filepath.Join(gopath, \"bin\")\n }\n \n-// mustUseModules reports whether we are invoked as vgo\n-// (as opposed to go).\n-// If so, we only support builds with go.mod files.\n-func mustUseModules() bool {\n-\tname := os.Args[0]\n-\tname = name[strings.LastIndex(name, \"/\")+1:]\n-\tname = name[strings.LastIndex(name, `\\`)+1:]\n-\treturn strings.HasPrefix(name, \"vgo\")\n-}\n-\n-var inGOPATH bool // running in GOPATH/src\n-\n // Init determines whether module mode is enabled, locates the root of the\n // current module (if any), sets environment variables for Git subprocesses, and\n // configures the cfg, codehost, load, modfetch, and search packages for use\n@@ -91,18 +89,17 @@ func Init() {\n \t}\n \tinitialized = true\n \n-\tenv := os.Getenv(\"GO111MODULE\")\n+\tenv := cfg.Getenv(\"GO111MODULE\")\n \tswitch env {\n \tdefault:\n \t\tbase.Fatalf(\"go: unknown environment setting GO111MODULE=%s\", env)\n-\tcase \"\", \"auto\":\n-\t\t// leave MustUseModules alone\n+\tcase \"auto\", \"\":\n+\t\tmustUseModules = false\n \tcase \"on\":\n-\t\tMustUseModules = true\n+\t\tmustUseModules = true\n \tcase \"off\":\n-\t\tif !MustUseModules {\n-\t\t\treturn\n-\t\t}\n+\t\tmustUseModules = false\n+\t\treturn\n \t}\n \n \t// Disable any prompting for passwords by Git.\n@@ -138,36 +135,14 @@ func Init() {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tinGOPATH = false\n-\tfor _, gopath := range filepath.SplitList(cfg.BuildContext.GOPATH) {\n-\t\tif gopath == \"\" {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif search.InDir(cwd, filepath.Join(gopath, \"src\")) != \"\" {\n-\t\t\tinGOPATH = true\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\tif inGOPATH && !MustUseModules {\n-\t\tif CmdModInit {\n-\t\t\tdie() // Don't init a module that we're just going to ignore.\n-\t\t}\n-\t\t// No automatic enabling in GOPATH.\n-\t\tif root, _ := FindModuleRoot(cwd, \"\", false); root != \"\" {\n-\t\t\tcfg.GoModInGOPATH = filepath.Join(root, \"go.mod\")\n-\t\t}\n-\t\treturn\n-\t}\n-\n \tif CmdModInit {\n \t\t// Running 'go mod init': go.mod will be created in current directory.\n \t\tmodRoot = cwd\n \t} else {\n-\t\tmodRoot, _ = FindModuleRoot(cwd, \"\", MustUseModules)\n+\t\tmodRoot = findModuleRoot(cwd)\n \t\tif modRoot == \"\" {\n-\t\t\tif !MustUseModules {\n-\t\t\t\t// GO111MODULE is 'auto' (or unset), and we can't find a module root.\n+\t\t\tif !mustUseModules {\n+\t\t\t\t// GO111MODULE is 'auto', and we can't find a module root.\n \t\t\t\t// Stay in GOPATH mode.\n \t\t\t\treturn\n \t\t\t}\n@@ -254,9 +229,11 @@ func Init() {\n func init() {\n \tload.ModInit = Init\n \n-\t// Set modfetch.PkgMod unconditionally, so that go clean -modcache can run even without modules enabled.\n+\t// Set modfetch.PkgMod and codehost.WorkRoot unconditionally,\n+\t// so that go clean -modcache and go mod download can run even without modules enabled.\n \tif list := filepath.SplitList(cfg.BuildContext.GOPATH); len(list) > 0 && list[0] != \"\" {\n \t\tmodfetch.PkgMod = filepath.Join(list[0], \"pkg/mod\")\n+\t\tcodehost.WorkRoot = filepath.Join(list[0], \"pkg/mod/cache/vcs\")\n \t}\n }\n \n@@ -266,7 +243,7 @@ func init() {\n // (usually through MustModRoot).\n func Enabled() bool {\n \tInit()\n-\treturn modRoot != \"\" || MustUseModules\n+\treturn modRoot != \"\" || mustUseModules\n }\n \n // ModRoot returns the root of the main module.\n@@ -296,11 +273,21 @@ func die() {\n \tif printStackInDie {\n \t\tdebug.PrintStack()\n \t}\n-\tif os.Getenv(\"GO111MODULE\") == \"off\" {\n+\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n-\tif inGOPATH && !MustUseModules {\n-\t\tbase.Fatalf(\"go: modules disabled inside GOPATH/src by GO111MODULE=auto; see 'go help modules'\")\n+\tif cwd != \"\" {\n+\t\tif dir, name := findAltConfig(cwd); dir != \"\" {\n+\t\t\trel, err := filepath.Rel(cwd, dir)\n+\t\t\tif err != nil {\n+\t\t\t\trel = dir\n+\t\t\t}\n+\t\t\tcdCmd := \"\"\n+\t\t\tif rel != \".\" {\n+\t\t\t\tcdCmd = fmt.Sprintf(\"cd %s && \", rel)\n+\t\t\t}\n+\t\t\tbase.Fatalf(\"go: cannot find main module, but found %s in %s\\n\\tto create a module there, run:\\n\\t%sgo mod init\", name, dir, cdCmd)\n+\t\t}\n \t}\n \tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n }\n@@ -315,6 +302,7 @@ func InitMod() {\n \tInit()\n \tif modRoot == \"\" {\n \t\tTarget = module.Version{Path: \"command-line-arguments\"}\n+\t\ttargetPrefix = \"command-line-arguments\"\n \t\tbuildList = []module.Version{Target}\n \t\treturn\n \t}\n@@ -328,14 +316,8 @@ func InitMod() {\n \t}\n \n \tgomod := filepath.Join(modRoot, \"go.mod\")\n-\tdata, err := ioutil.ReadFile(gomod)\n+\tdata, err := renameio.ReadFile(gomod)\n \tif err != nil {\n-\t\tif os.IsNotExist(err) {\n-\t\t\tlegacyModInit()\n-\t\t\tmodFileToBuildList()\n-\t\t\tWriteGoMod()\n-\t\t\treturn\n-\t\t}\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n@@ -349,7 +331,7 @@ func InitMod() {\n \n \tif len(f.Syntax.Stmt) == 0 || f.Module == nil {\n \t\t// Empty mod file. Must add module path.\n-\t\tpath, err := FindModulePath(modRoot)\n+\t\tpath, err := findModulePath(modRoot)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n@@ -367,37 +349,81 @@ func InitMod() {\n \t\texcluded[x.Mod] = true\n \t}\n \tmodFileToBuildList()\n+\tstdVendorMode()\n \tWriteGoMod()\n }\n \n // modFileToBuildList initializes buildList from the modFile.\n func modFileToBuildList() {\n \tTarget = modFile.Module.Mod\n+\ttargetPrefix = Target.Path\n+\tif rel := search.InDir(cwd, cfg.GOROOTsrc); rel != \"\" {\n+\t\ttargetInGorootSrc = true\n+\t\tif Target.Path == \"std\" {\n+\t\t\ttargetPrefix = \"\"\n+\t\t}\n+\t}\n+\n \tlist := []module.Version{Target}\n \tfor _, r := range modFile.Require {\n \t\tlist = append(list, r.Mod)\n \t}\n \tbuildList = list\n }\n \n+// stdVendorMode applies inside $GOROOT/src.\n+// It checks that the go.mod matches vendor/modules.txt\n+// and then sets -mod=vendor unless this is a command\n+// that has to do explicitly with modules.\n+func stdVendorMode() {\n+\tif !targetInGorootSrc {\n+\t\treturn\n+\t}\n+\tif cfg.CmdName == \"get\" || strings.HasPrefix(cfg.CmdName, \"mod \") {\n+\t\treturn\n+\t}\n+\n+\treadVendorList()\n+BuildList:\n+\tfor _, m := range buildList {\n+\t\tif m.Path == \"cmd\" || m.Path == \"std\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor _, v := range vendorList {\n+\t\t\tif m.Path == v.Path {\n+\t\t\t\tif m.Version != v.Version {\n+\t\t\t\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:\\n\"+\n+\t\t\t\t\t\t\"\\tgo.mod requires %s %s but vendor/modules.txt has %s.\\n\"+\n+\t\t\t\t\t\t\"\\trun 'go mod tidy; go mod vendor' to sync\",\n+\t\t\t\t\t\tmodRoot, m.Path, m.Version, v.Version)\n+\t\t\t\t}\n+\t\t\t\tcontinue BuildList\n+\t\t\t}\n+\t\t}\n+\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:\\n\"+\n+\t\t\t\"\\tgo.mod requires %s %s but vendor/modules.txt does not include it.\\n\"+\n+\t\t\t\"\\trun 'go mod tidy; go mod vendor' to sync\", modRoot, m.Path, m.Version)\n+\t}\n+\tcfg.BuildMod = \"vendor\"\n+}\n+\n // Allowed reports whether module m is allowed (not excluded) by the main module's go.mod.\n func Allowed(m module.Version) bool {\n \treturn !excluded[m]\n }\n \n func legacyModInit() {\n \tif modFile == nil {\n-\t\tpath, err := FindModulePath(modRoot)\n+\t\tpath, err := findModulePath(modRoot)\n \t\tif err != nil {\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t\tfmt.Fprintf(os.Stderr, \"go: creating new go.mod: module %s\\n\", path)\n \t\tmodFile = new(modfile.File)\n \t\tmodFile.AddModuleStmt(path)\n+\t\taddGoStmt() // Add the go directive before converted module requirements.\n \t}\n \n-\taddGoStmt()\n-\n \tfor _, name := range altConfigs {\n \t\tcfg := filepath.Join(modRoot, name)\n \t\tdata, err := ioutil.ReadFile(cfg)\n@@ -420,15 +446,12 @@ func legacyModInit() {\n \t}\n }\n \n-// InitGoStmt adds a go statement, unless there already is one.\n-func InitGoStmt() {\n-\tif modFile.Go == nil {\n-\t\taddGoStmt()\n-\t}\n-}\n-\n-// addGoStmt adds a go statement referring to the current version.\n+// addGoStmt adds a go directive to the go.mod file if it does not already include one.\n+// The 'go' version added, if any, is the latest version supported by this toolchain.\n func addGoStmt() {\n+\tif modFile.Go != nil && modFile.Go.Version != \"\" {\n+\t\treturn\n+\t}\n \ttags := build.Default.ReleaseTags\n \tversion := tags[len(tags)-1]\n \tif !strings.HasPrefix(version, \"go\") || !modfile.GoVersionRE.MatchString(version[2:]) {\n@@ -454,57 +477,59 @@ var altConfigs = []string{\n \t\".git/config\",\n }\n \n-// Exported only for testing.\n-func FindModuleRoot(dir, limit string, legacyConfigOK bool) (root, file string) {\n+func findModuleRoot(dir string) (root string) {\n \tdir = filepath.Clean(dir)\n-\tdir1 := dir\n-\tlimit = filepath.Clean(limit)\n \n \t// Look for enclosing go.mod.\n \tfor {\n \t\tif fi, err := os.Stat(filepath.Join(dir, \"go.mod\")); err == nil && !fi.IsDir() {\n-\t\t\treturn dir, \"go.mod\"\n-\t\t}\n-\t\tif dir == limit {\n-\t\t\tbreak\n+\t\t\treturn dir\n \t\t}\n \t\td := filepath.Dir(dir)\n \t\tif d == dir {\n \t\t\tbreak\n \t\t}\n \t\tdir = d\n \t}\n+\treturn \"\"\n+}\n \n-\t// Failing that, look for enclosing alternate version config.\n-\tif legacyConfigOK {\n-\t\tdir = dir1\n-\t\tfor {\n-\t\t\tfor _, name := range altConfigs {\n-\t\t\t\tif fi, err := os.Stat(filepath.Join(dir, name)); err == nil && !fi.IsDir() {\n-\t\t\t\t\treturn dir, name\n+func findAltConfig(dir string) (root, name string) {\n+\tdir = filepath.Clean(dir)\n+\tfor {\n+\t\tfor _, name := range altConfigs {\n+\t\t\tif fi, err := os.Stat(filepath.Join(dir, name)); err == nil && !fi.IsDir() {\n+\t\t\t\tif rel := search.InDir(dir, cfg.BuildContext.GOROOT); rel == \".\" {\n+\t\t\t\t\t// Don't suggest creating a module from $GOROOT/.git/config.\n+\t\t\t\t\treturn \"\", \"\"\n \t\t\t\t}\n+\t\t\t\treturn dir, name\n \t\t\t}\n-\t\t\tif dir == limit {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\td := filepath.Dir(dir)\n-\t\t\tif d == dir {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tdir = d\n \t\t}\n+\t\td := filepath.Dir(dir)\n+\t\tif d == dir {\n+\t\t\tbreak\n+\t\t}\n+\t\tdir = d\n \t}\n-\n \treturn \"\", \"\"\n }\n \n-// Exported only for testing.\n-func FindModulePath(dir string) (string, error) {\n+func findModulePath(dir string) (string, error) {\n \tif CmdModModule != \"\" {\n \t\t// Running go mod init x/y/z; return x/y/z.\n+\t\tif err := module.CheckImportPath(CmdModModule); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n \t\treturn CmdModModule, nil\n \t}\n \n+\t// TODO(bcmills): once we have located a plausible module path, we should\n+\t// query version control (if available) to verify that it matches the major\n+\t// version of the most recent tag.\n+\t// See https://golang.org/issue/29433, https://golang.org/issue/27009, and\n+\t// https://golang.org/issue/31549.\n+\n \t// Cast about for import comments,\n \t// first in top-level directory, then in subdirectories.\n \tlist, _ := ioutil.ReadDir(dir)\n@@ -554,18 +579,19 @@ func FindModulePath(dir string) (string, error) {\n \t\t}\n \t}\n \n-\t// Look for .git/config with github origin as last resort.\n-\tdata, _ = ioutil.ReadFile(filepath.Join(dir, \".git/config\"))\n-\tif m := gitOriginRE.FindSubmatch(data); m != nil {\n-\t\treturn \"github.com/\" + string(m[1]), nil\n-\t}\n+\tmsg := `cannot determine module path for source directory %s (outside GOPATH, module path must be specified)\n+\n+Example usage:\n+\t'go mod init example.com/m' to initialize a v0 or v1 module\n+\t'go mod init example.com/m/v2' to initialize a v2 module\n \n-\treturn \"\", fmt.Errorf(\"cannot determine module path for source directory %s (outside GOPATH, no import comments)\", dir)\n+Run 'go help mod init' for more information.\n+`\n+\treturn \"\", fmt.Errorf(msg, dir)\n }\n \n var (\n-\tgitOriginRE     = regexp.MustCompile(`(?m)^\\[remote \"origin\"\\]\\r?\\n\\turl = (?:https://github.com/|git@github.com:|gh:)([^/]+/[^/]+?)(\\.git)?\\r?\\n`)\n-\timportCommentRE = regexp.MustCompile(`(?m)^package[ \\t]+[^ \\t\\r\\n/]+[ \\t]+//[ \\t]+import[ \\t]+(\\\"[^\"]+\\\")[ \\t]*\\r?\\n`)\n+\timportCommentRE = lazyregexp.New(`(?m)^package[ \\t]+[^ \\t\\r\\n/]+[ \\t]+//[ \\t]+import[ \\t]+(\\\"[^\"]+\\\")[ \\t]*\\r?\\n`)\n )\n \n func findImportComment(file string) string {\n@@ -629,6 +655,8 @@ func WriteGoMod() {\n \t\treturn\n \t}\n \n+\taddGoStmt()\n+\n \tif loaded != nil {\n \t\treqs := MinReqs()\n \t\tmin, err := reqs.Required(Target)\n@@ -651,24 +679,27 @@ func WriteGoMod() {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n+\tdirty := !bytes.Equal(new, modFileData)\n+\tif dirty && cfg.BuildMod == \"readonly\" {\n+\t\t// If we're about to fail due to -mod=readonly,\n+\t\t// prefer to report a dirty go.mod over a dirty go.sum\n+\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\t}\n \t// Always update go.sum, even if we didn't change go.mod: we may have\n \t// downloaded modules that we didn't have before.\n \tmodfetch.WriteGoSum()\n \n-\tif bytes.Equal(new, modFileData) {\n+\tif !dirty {\n \t\t// We don't need to modify go.mod from what we read previously.\n \t\t// Ignore any intervening edits.\n \t\treturn\n \t}\n-\tif cfg.BuildMod == \"readonly\" {\n-\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n-\t}\n \n \tunlock := modfetch.SideLock()\n \tdefer unlock()\n \n \tfile := filepath.Join(modRoot, \"go.mod\")\n-\told, err := ioutil.ReadFile(file)\n+\told, err := renameio.ReadFile(file)\n \tif !bytes.Equal(old, modFileData) {\n \t\tif bytes.Equal(old, new) {\n \t\t\t// Some other process wrote the same go.mod file that we were about to write.\n@@ -688,7 +719,7 @@ func WriteGoMod() {\n \n \t}\n \n-\tif err := renameio.WriteFile(file, new); err != nil {\n+\tif err := renameio.WriteFile(file, new, 0666); err != nil {\n \t\tbase.Fatalf(\"error writing go.mod: %v\", err)\n \t}\n \tmodFileData = new\n@@ -705,13 +736,21 @@ func fixVersion(path, vers string) (string, error) {\n \t// Avoid the query if it looks OK.\n \t_, pathMajor, ok := module.SplitPathVersion(path)\n \tif !ok {\n-\t\treturn \"\", fmt.Errorf(\"malformed module path: %s\", path)\n+\t\treturn \"\", &module.ModuleError{\n+\t\t\tPath: path,\n+\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\tVersion: vers,\n+\t\t\t\tErr:     fmt.Errorf(\"malformed module path %q\", path),\n+\t\t\t},\n+\t\t}\n \t}\n-\tif vers != \"\" && module.CanonicalVersion(vers) == vers && module.MatchPathMajor(vers, pathMajor) {\n-\t\treturn vers, nil\n+\tif vers != \"\" && module.CanonicalVersion(vers) == vers {\n+\t\tif err := module.MatchPathMajor(vers, pathMajor); err == nil {\n+\t\t\treturn vers, nil\n+\t\t}\n \t}\n \n-\tinfo, err := Query(path, vers, nil)\n+\tinfo, err := Query(path, vers, \"\", nil)\n \tif err != nil {\n \t\treturn \"\", err\n \t}"}, {"sha": "2df9d8af7df1b6a9d68c40154b1cce53f44e13f7", "filename": "libgo/go/cmd/go/internal/modload/init_test.go", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit_test.go?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd", "patch": "@@ -1,42 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modload\n-\n-import (\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"testing\"\n-)\n-\n-func TestFindModuleRootIgnoreDir(t *testing.T) {\n-\t// In Plan 9, directories are automatically created in /n.\n-\t// For example, /n/go.mod always exist, but it's a directory.\n-\t// Test that we ignore directories when trying to find go.mod and other config files.\n-\n-\tdir, err := ioutil.TempDir(\"\", \"gotest\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"failed to create temporary directory: %v\", err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\tif err := os.Mkdir(filepath.Join(dir, \"go.mod\"), os.ModeDir|0755); err != nil {\n-\t\tt.Fatalf(\"Mkdir failed: %v\", err)\n-\t}\n-\tfor _, name := range altConfigs {\n-\t\tif err := os.MkdirAll(filepath.Join(dir, name), os.ModeDir|0755); err != nil {\n-\t\t\tt.Fatalf(\"MkdirAll failed: %v\", err)\n-\t\t}\n-\t}\n-\tp := filepath.Join(dir, \"example\")\n-\tif err := os.Mkdir(p, os.ModeDir|0755); err != nil {\n-\t\tt.Fatalf(\"Mkdir failed: %v\", err)\n-\t}\n-\tif root, _ := FindModuleRoot(p, \"\", false); root != \"\" {\n-\t\tt.Errorf(\"FindModuleRoot(%q, \\\"\\\", false): %q, want empty string\", p, root)\n-\t}\n-\tif root, _ := FindModuleRoot(p, \"\", true); root != \"\" {\n-\t\tt.Errorf(\"FindModuleRoot(%q, \\\"\\\", true): %q, want empty string\", p, root)\n-\t}\n-}"}, {"sha": "c571ddc5f5423cc40b2308d396b8b6e1de7291a1", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -55,18 +55,28 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\tbase.Fatalf(\"go: cannot use relative path %s to specify module\", arg)\n \t\t}\n \t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n-\t\t\tinfo, err := Query(arg[:i], arg[i+1:], nil)\n+\t\t\tpath := arg[:i]\n+\t\t\tvers := arg[i+1:]\n+\t\t\tvar current string\n+\t\t\tfor _, m := range buildList {\n+\t\t\t\tif m.Path == path {\n+\t\t\t\t\tcurrent = m.Version\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tinfo, err := Query(path, vers, current, nil)\n \t\t\tif err != nil {\n \t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\tPath:    arg[:i],\n-\t\t\t\t\tVersion: arg[i+1:],\n+\t\t\t\t\tPath:    path,\n+\t\t\t\t\tVersion: vers,\n \t\t\t\t\tError: &modinfo.ModuleError{\n \t\t\t\t\t\tErr: err.Error(),\n \t\t\t\t\t},\n \t\t\t\t})\n \t\t\t\tcontinue\n \t\t\t}\n-\t\t\tmods = append(mods, moduleInfo(module.Version{Path: arg[:i], Version: info.Version}, false))\n+\t\t\tmods = append(mods, moduleInfo(module.Version{Path: path, Version: info.Version}, false))\n \t\t\tcontinue\n \t\t}\n \n@@ -101,11 +111,18 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\t\t// Don't make the user provide an explicit '@latest' when they're\n \t\t\t\t\t// explicitly asking what the available versions are.\n \t\t\t\t\t// Instead, resolve the module, even if it isn't an existing dependency.\n-\t\t\t\t\tinfo, err := Query(arg, \"latest\", nil)\n+\t\t\t\t\tinfo, err := Query(arg, \"latest\", \"\", nil)\n \t\t\t\t\tif err == nil {\n \t\t\t\t\t\tmods = append(mods, moduleInfo(module.Version{Path: arg, Version: info.Version}, false))\n-\t\t\t\t\t\tcontinue\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n+\t\t\t\t\t\t\tPath: arg,\n+\t\t\t\t\t\t\tError: &modinfo.ModuleError{\n+\t\t\t\t\t\t\t\tErr: err.Error(),\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t})\n \t\t\t\t\t}\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n \t\t\t\t\tPath: arg,"}, {"sha": "a9d6c21b0e3d63bd36506b0eaf626a932f1e0dca", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 207, "deletions": 89, "changes": 296, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n+\tpathpkg \"path\"\n \t\"path/filepath\"\n \t\"sort\"\n \t\"strings\"\n@@ -50,29 +51,28 @@ var buildList []module.Version\n var loaded *loader\n \n // ImportPaths returns the set of packages matching the args (patterns),\n-// adding modules to the build list as needed to satisfy new imports.\n+// on the target platform. Modules may be added to the build list\n+// to satisfy new imports.\n func ImportPaths(patterns []string) []*search.Match {\n-\tInitMod()\n-\n-\tvar matches []*search.Match\n-\tfor _, pattern := range search.CleanPatterns(patterns) {\n-\t\tm := &search.Match{\n-\t\t\tPattern: pattern,\n-\t\t\tLiteral: !strings.Contains(pattern, \"...\") && !search.IsMetaPackage(pattern),\n-\t\t}\n-\t\tif m.Literal {\n-\t\t\tm.Pkgs = []string{pattern}\n-\t\t}\n-\t\tmatches = append(matches, m)\n-\t}\n+\tmatches := ImportPathsQuiet(patterns, imports.Tags())\n+\tsearch.WarnUnmatched(matches)\n+\treturn matches\n+}\n \n-\tfsDirs := make([][]string, len(matches))\n-\tloaded = newLoader()\n-\tupdateMatches := func(iterating bool) {\n+// ImportPathsQuiet is like ImportPaths but does not warn about patterns with\n+// no matches. It also lets the caller specify a set of build tags to match\n+// packages. The build tags should typically be imports.Tags() or\n+// imports.AnyTags(); a nil map has no special meaning.\n+func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n+\tvar fsDirs [][]string\n+\tupdateMatches := func(matches []*search.Match, iterating bool) {\n \t\tfor i, m := range matches {\n \t\t\tswitch {\n \t\t\tcase build.IsLocalImport(m.Pattern) || filepath.IsAbs(m.Pattern):\n \t\t\t\t// Evaluate list of file system directories on first iteration.\n+\t\t\t\tif fsDirs == nil {\n+\t\t\t\t\tfsDirs = make([][]string, len(matches))\n+\t\t\t\t}\n \t\t\t\tif fsDirs[i] == nil {\n \t\t\t\t\tvar dirs []string\n \t\t\t\t\tif m.Literal {\n@@ -90,7 +90,9 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\t// the exact version of a particular module increases during\n \t\t\t\t// the loader iterations.\n \t\t\t\tm.Pkgs = str.StringList(fsDirs[i])\n-\t\t\t\tfor j, pkg := range m.Pkgs {\n+\t\t\t\tpkgs := m.Pkgs\n+\t\t\t\tm.Pkgs = m.Pkgs[:0]\n+\t\t\t\tfor _, pkg := range pkgs {\n \t\t\t\t\tdir := pkg\n \t\t\t\t\tif !filepath.IsAbs(dir) {\n \t\t\t\t\t\tdir = filepath.Join(cwd, pkg)\n@@ -108,10 +110,20 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\t\t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n \t\t\t\t\t\t\t// TODO getmode vendor check\n \t\t\t\t\t\t\tpkg = strings.TrimPrefix(suffix, \"/vendor/\")\n+\t\t\t\t\t\t} else if targetInGorootSrc && Target.Path == \"std\" {\n+\t\t\t\t\t\t\t// Don't add the prefix \"std/\" to packages in the \"std\" module.\n+\t\t\t\t\t\t\t// It's the one module path that isn't a prefix of its packages.\n+\t\t\t\t\t\t\tpkg = strings.TrimPrefix(suffix, \"/\")\n+\t\t\t\t\t\t\tif pkg == \"builtin\" {\n+\t\t\t\t\t\t\t\t// \"builtin\" is a pseudo-package with a real source file.\n+\t\t\t\t\t\t\t\t// It's not included in \"std\", so it shouldn't be included in\n+\t\t\t\t\t\t\t\t// \"./...\" within module \"std\" either.\n+\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tpkg = Target.Path + suffix\n \t\t\t\t\t\t}\n-\t\t\t\t\t} else if sub := search.InDir(dir, cfg.GOROOTsrc); sub != \"\" && !strings.Contains(sub, \"@\") {\n+\t\t\t\t\t} else if sub := search.InDir(dir, cfg.GOROOTsrc); sub != \"\" && sub != \".\" && !strings.Contains(sub, \"@\") {\n \t\t\t\t\t\tpkg = filepath.ToSlash(sub)\n \t\t\t\t\t} else if path := pathInModuleCache(dir); path != \"\" {\n \t\t\t\t\t\tpkg = path\n@@ -129,10 +141,10 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\t\t\t// After loader is done iterating, we still need to return the\n \t\t\t\t\t\t// path, so that \"go list -e\" produces valid output.\n \t\t\t\t\t\tif iterating {\n-\t\t\t\t\t\t\tpkg = \"\"\n+\t\t\t\t\t\t\tcontinue\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tm.Pkgs[j] = pkg\n+\t\t\t\t\tm.Pkgs = append(m.Pkgs, pkg)\n \t\t\t\t}\n \n \t\t\tcase strings.Contains(m.Pattern, \"...\"):\n@@ -154,25 +166,35 @@ func ImportPaths(patterns []string) []*search.Match {\n \t\t\t\tif len(m.Pkgs) == 0 {\n \t\t\t\t\tm.Pkgs = search.MatchPackages(m.Pattern).Pkgs\n \t\t\t\t}\n+\n+\t\t\tdefault:\n+\t\t\t\tm.Pkgs = []string{m.Pattern}\n \t\t\t}\n \t\t}\n \t}\n \n+\tInitMod()\n+\n+\tvar matches []*search.Match\n+\tfor _, pattern := range search.CleanPatterns(patterns) {\n+\t\tmatches = append(matches, &search.Match{\n+\t\t\tPattern: pattern,\n+\t\t\tLiteral: !strings.Contains(pattern, \"...\") && !search.IsMetaPackage(pattern),\n+\t\t})\n+\t}\n+\n+\tloaded = newLoader(tags)\n \tloaded.load(func() []string {\n \t\tvar roots []string\n-\t\tupdateMatches(true)\n+\t\tupdateMatches(matches, true)\n \t\tfor _, m := range matches {\n-\t\t\tfor _, pkg := range m.Pkgs {\n-\t\t\t\tif pkg != \"\" {\n-\t\t\t\t\troots = append(roots, pkg)\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\troots = append(roots, m.Pkgs...)\n \t\t}\n \t\treturn roots\n \t})\n \n \t// One last pass to finalize wildcards.\n-\tupdateMatches(false)\n+\tupdateMatches(matches, false)\n \n \t// A given module path may be used as itself or as a replacement for another\n \t// module, but not both at the same time. Otherwise, the aliasing behavior is\n@@ -193,15 +215,25 @@ func ImportPaths(patterns []string) []*search.Match {\n \tbase.ExitIfErrors()\n \tWriteGoMod()\n \n-\tsearch.WarnUnmatched(matches)\n \treturn matches\n }\n \n // pathInModuleCache returns the import path of the directory dir,\n // if dir is in the module cache copy of a module in our build list.\n func pathInModuleCache(dir string) string {\n \tfor _, m := range buildList[1:] {\n-\t\troot, err := modfetch.DownloadDir(m)\n+\t\tvar root string\n+\t\tvar err error\n+\t\tif repl := Replacement(m); repl.Path != \"\" && repl.Version == \"\" {\n+\t\t\troot = repl.Path\n+\t\t\tif !filepath.IsAbs(root) {\n+\t\t\t\troot = filepath.Join(ModRoot(), root)\n+\t\t\t}\n+\t\t} else if repl.Path != \"\" {\n+\t\t\troot, err = modfetch.DownloadDir(repl)\n+\t\t} else {\n+\t\t\troot, err = modfetch.DownloadDir(m)\n+\t\t}\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n@@ -230,12 +262,13 @@ func warnPattern(pattern string, list []string) []string {\n func ImportFromFiles(gofiles []string) {\n \tInitMod()\n \n-\timports, testImports, err := imports.ScanFiles(gofiles, imports.Tags())\n+\ttags := imports.Tags()\n+\timports, testImports, err := imports.ScanFiles(gofiles, tags)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tloaded = newLoader()\n+\tloaded = newLoader(tags)\n \tloaded.load(func() []string {\n \t\tvar roots []string\n \t\troots = append(roots, imports...)\n@@ -259,14 +292,14 @@ func DirImportPath(dir string) string {\n \t}\n \n \tif dir == modRoot {\n-\t\treturn Target.Path\n+\t\treturn targetPrefix\n \t}\n \tif strings.HasPrefix(dir, modRoot+string(filepath.Separator)) {\n \t\tsuffix := filepath.ToSlash(dir[len(modRoot):])\n \t\tif strings.HasPrefix(suffix, \"/vendor/\") {\n \t\t\treturn strings.TrimPrefix(suffix, \"/vendor/\")\n \t\t}\n-\t\treturn Target.Path + suffix\n+\t\treturn targetPrefix + suffix\n \t}\n \treturn \".\"\n }\n@@ -284,7 +317,7 @@ func LoadBuildList() []module.Version {\n }\n \n func ReloadBuildList() []module.Version {\n-\tloaded = newLoader()\n+\tloaded = newLoader(imports.Tags())\n \tloaded.load(func() []string { return nil })\n \treturn buildList\n }\n@@ -310,14 +343,13 @@ func LoadVendor() []string {\n func loadAll(testAll bool) []string {\n \tInitMod()\n \n-\tloaded = newLoader()\n+\tloaded = newLoader(imports.AnyTags())\n \tloaded.isALL = true\n-\tloaded.tags = anyTags\n \tloaded.testAll = testAll\n \tif !testAll {\n \t\tloaded.testRoots = true\n \t}\n-\tall := TargetPackages()\n+\tall := TargetPackages(\"...\")\n \tloaded.load(func() []string { return all })\n \tWriteGoMod()\n \n@@ -331,14 +363,11 @@ func loadAll(testAll bool) []string {\n \treturn paths\n }\n \n-// anyTags is a special tags map that satisfies nearly all build tag expressions.\n-// Only \"ignore\" and malformed build tag requirements are considered false.\n-var anyTags = map[string]bool{\"*\": true}\n-\n-// TargetPackages returns the list of packages in the target (top-level) module,\n-// under all build tag settings.\n-func TargetPackages() []string {\n-\treturn matchPackages(\"...\", anyTags, false, []module.Version{Target})\n+// TargetPackages returns the list of packages in the target (top-level) module\n+// matching pattern, which may be relative to the working directory, under all\n+// build tag settings.\n+func TargetPackages(pattern string) []string {\n+\treturn matchPackages(pattern, imports.AnyTags(), false, []module.Version{Target})\n }\n \n // BuildList returns the module build list,\n@@ -387,20 +416,47 @@ func PackageModule(path string) module.Version {\n \treturn pkg.mod\n }\n \n+// PackageImports returns the imports for the package named by the import path.\n+// Test imports will be returned as well if tests were loaded for the package\n+// (i.e., if \"all\" was loaded or if LoadTests was set and the path was matched\n+// by a command line argument). PackageImports will return nil for\n+// unknown package paths.\n+func PackageImports(path string) (imports, testImports []string) {\n+\tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n+\tif !ok {\n+\t\treturn nil, nil\n+\t}\n+\timports = make([]string, len(pkg.imports))\n+\tfor i, p := range pkg.imports {\n+\t\timports[i] = p.path\n+\t}\n+\tif pkg.test != nil {\n+\t\ttestImports = make([]string, len(pkg.test.imports))\n+\t\tfor i, p := range pkg.test.imports {\n+\t\t\ttestImports[i] = p.path\n+\t\t}\n+\t}\n+\treturn imports, testImports\n+}\n+\n // ModuleUsedDirectly reports whether the main module directly imports\n // some package in the module with the given path.\n func ModuleUsedDirectly(path string) bool {\n \treturn loaded.direct[path]\n }\n \n // Lookup returns the source directory, import path, and any loading error for\n-// the package at path.\n+// the package at path as imported from the package in parentDir.\n // Lookup requires that one of the Load functions in this package has already\n // been called.\n-func Lookup(path string) (dir, realPath string, err error) {\n+func Lookup(parentPath string, parentIsStd bool, path string) (dir, realPath string, err error) {\n \tif path == \"\" {\n \t\tpanic(\"Lookup called with empty package path\")\n \t}\n+\n+\tif parentIsStd {\n+\t\tpath = loaded.stdVendor(parentPath, path)\n+\t}\n \tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n \tif !ok {\n \t\t// The loader should have found all the relevant paths.\n@@ -434,10 +490,11 @@ func Lookup(path string) (dir, realPath string, err error) {\n // TODO(rsc): It might be nice to make the loader take and return\n // a buildList rather than hard-coding use of the global.\n type loader struct {\n-\ttags      map[string]bool // tags for scanDir\n-\ttestRoots bool            // include tests for roots\n-\tisALL     bool            // created with LoadALL\n-\ttestAll   bool            // include tests for all packages\n+\ttags           map[string]bool // tags for scanDir\n+\ttestRoots      bool            // include tests for roots\n+\tisALL          bool            // created with LoadALL\n+\ttestAll        bool            // include tests for all packages\n+\tforceStdVendor bool            // if true, load standard-library dependencies from the vendor subtree\n \n \t// reset on each iteration\n \troots    []*loadPkg\n@@ -453,10 +510,17 @@ type loader struct {\n // LoadTests controls whether the loaders load tests of the root packages.\n var LoadTests bool\n \n-func newLoader() *loader {\n+func newLoader(tags map[string]bool) *loader {\n \tld := new(loader)\n-\tld.tags = imports.Tags()\n+\tld.tags = tags\n \tld.testRoots = LoadTests\n+\n+\t// Inside the \"std\" and \"cmd\" modules, we prefer to use the vendor directory\n+\t// unless the command explicitly changes the module graph.\n+\tif !targetInGorootSrc || (cfg.CmdName != \"get\" && !strings.HasPrefix(cfg.CmdName, \"mod \")) {\n+\t\tld.forceStdVendor = true\n+\t}\n+\n \treturn ld\n }\n \n@@ -511,15 +575,20 @@ func (ld *loader) load(roots func() []string) {\n \t\tfor _, m := range buildList {\n \t\t\thaveMod[m] = true\n \t\t}\n+\t\tmodAddedBy := make(map[module.Version]*loadPkg)\n \t\tfor _, pkg := range ld.pkgs {\n \t\t\tif err, ok := pkg.err.(*ImportMissingError); ok && err.Module.Path != \"\" {\n+\t\t\t\tif err.newMissingVersion != \"\" {\n+\t\t\t\t\tbase.Fatalf(\"go: %s: package provided by %s at latest version %s but not at required version %s\", pkg.stackText(), err.Module.Path, err.Module.Version, err.newMissingVersion)\n+\t\t\t\t}\n \t\t\t\tif added[pkg.path] {\n \t\t\t\t\tbase.Fatalf(\"go: %s: looping trying to add package\", pkg.stackText())\n \t\t\t\t}\n \t\t\t\tadded[pkg.path] = true\n \t\t\t\tnumAdded++\n \t\t\t\tif !haveMod[err.Module] {\n \t\t\t\t\thaveMod[err.Module] = true\n+\t\t\t\t\tmodAddedBy[err.Module] = pkg\n \t\t\t\t\tbuildList = append(buildList, err.Module)\n \t\t\t\t}\n \t\t\t\tcontinue\n@@ -535,6 +604,14 @@ func (ld *loader) load(roots func() []string) {\n \t\treqs = Reqs()\n \t\tbuildList, err = mvs.BuildList(Target, reqs)\n \t\tif err != nil {\n+\t\t\t// If an error was found in a newly added module, report the package\n+\t\t\t// import stack instead of the module requirement stack. Packages\n+\t\t\t// are more descriptive.\n+\t\t\tif err, ok := err.(*mvs.BuildListError); ok {\n+\t\t\t\tif pkg := modAddedBy[err.Module()]; pkg != nil {\n+\t\t\t\t\tbase.Fatalf(\"go: %s: %v\", pkg.stackText(), err.Err)\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tbase.Fatalf(\"go: %v\", err)\n \t\t}\n \t}\n@@ -635,7 +712,11 @@ func (ld *loader) doPkg(item interface{}) {\n \t\t}\n \t}\n \n+\tinStd := (search.IsStandardImportPath(pkg.path) && search.InDir(pkg.dir, cfg.GOROOTsrc) != \"\")\n \tfor _, path := range imports {\n+\t\tif inStd {\n+\t\t\tpath = ld.stdVendor(pkg.path, path)\n+\t\t}\n \t\tpkg.imports = append(pkg.imports, ld.pkg(path, false))\n \t}\n \n@@ -646,6 +727,31 @@ func (ld *loader) doPkg(item interface{}) {\n \t}\n }\n \n+// stdVendor returns the canonical import path for the package with the given\n+// path when imported from the standard-library package at parentPath.\n+func (ld *loader) stdVendor(parentPath, path string) string {\n+\tif search.IsStandardImportPath(path) {\n+\t\treturn path\n+\t}\n+\n+\tif str.HasPathPrefix(parentPath, \"cmd\") {\n+\t\tif ld.forceStdVendor || Target.Path != \"cmd\" {\n+\t\t\tvendorPath := pathpkg.Join(\"cmd\", \"vendor\", path)\n+\t\t\tif _, err := os.Stat(filepath.Join(cfg.GOROOTsrc, filepath.FromSlash(vendorPath))); err == nil {\n+\t\t\t\treturn vendorPath\n+\t\t\t}\n+\t\t}\n+\t} else if ld.forceStdVendor || Target.Path != \"std\" {\n+\t\tvendorPath := pathpkg.Join(\"vendor\", path)\n+\t\tif _, err := os.Stat(filepath.Join(cfg.GOROOTsrc, filepath.FromSlash(vendorPath))); err == nil {\n+\t\t\treturn vendorPath\n+\t\t}\n+\t}\n+\n+\t// Not vendored: resolve from modules.\n+\treturn path\n+}\n+\n // computePatternAll returns the list of packages matching pattern \"all\",\n // starting with a list of the import paths for the packages in the main module.\n func (ld *loader) computePatternAll(paths []string) []string {\n@@ -741,27 +847,33 @@ func (ld *loader) buildStacks() {\n // stackText builds the import stack text to use when\n // reporting an error in pkg. It has the general form\n //\n-//\timport root ->\n-//\t\timport other ->\n-//\t\timport other2 ->\n-//\t\timport pkg\n+//\troot imports\n+//\t\tother imports\n+//\t\tother2 tested by\n+//\t\tother2.test imports\n+//\t\tpkg\n //\n func (pkg *loadPkg) stackText() string {\n \tvar stack []*loadPkg\n-\tfor p := pkg.stack; p != nil; p = p.stack {\n+\tfor p := pkg; p != nil; p = p.stack {\n \t\tstack = append(stack, p)\n \t}\n \n \tvar buf bytes.Buffer\n \tfor i := len(stack) - 1; i >= 0; i-- {\n \t\tp := stack[i]\n+\t\tfmt.Fprint(&buf, p.path)\n \t\tif p.testOf != nil {\n-\t\t\tfmt.Fprintf(&buf, \"test ->\\n\\t\")\n-\t\t} else {\n-\t\t\tfmt.Fprintf(&buf, \"import %q ->\\n\\t\", p.path)\n+\t\t\tfmt.Fprint(&buf, \".test\")\n+\t\t}\n+\t\tif i > 0 {\n+\t\t\tif stack[i-1].testOf == p {\n+\t\t\t\tfmt.Fprint(&buf, \" tested by\\n\\t\")\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprint(&buf, \" imports\\n\\t\")\n+\t\t\t}\n \t\t}\n \t}\n-\tfmt.Fprintf(&buf, \"import %q\", pkg.path)\n \treturn buf.String()\n }\n \n@@ -913,27 +1025,40 @@ func readVendorList() {\n }\n \n func (r *mvsReqs) modFileToList(f *modfile.File) []module.Version {\n-\tvar list []module.Version\n+\tlist := make([]module.Version, 0, len(f.Require))\n \tfor _, r := range f.Require {\n \t\tlist = append(list, r.Mod)\n \t}\n \treturn list\n }\n \n+// required returns a unique copy of the requirements of mod.\n func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \tif mod == Target {\n \t\tif modFile != nil && modFile.Go != nil {\n \t\t\tr.versions.LoadOrStore(mod, modFile.Go.Version)\n \t\t}\n-\t\tvar list []module.Version\n-\t\treturn append(list, r.buildList[1:]...), nil\n+\t\treturn append([]module.Version(nil), r.buildList[1:]...), nil\n \t}\n \n \tif cfg.BuildMod == \"vendor\" {\n \t\t// For every module other than the target,\n \t\t// return the full list of modules from modules.txt.\n \t\treadVendorList()\n-\t\treturn vendorList, nil\n+\t\treturn append([]module.Version(nil), vendorList...), nil\n+\t}\n+\n+\tif targetInGorootSrc {\n+\t\t// When inside \"std\" or \"cmd\", only fetch and read go.mod files if we're\n+\t\t// explicitly running a command that can change the module graph. If we have\n+\t\t// to resolve a new dependency, we might pick the wrong version, but 'go mod\n+\t\t// tidy' will fix it \u2014 and new standard-library dependencies should be rare\n+\t\t// anyway.\n+\t\t//\n+\t\t// TODO(golang.org/issue/30240): Drop this special-case.\n+\t\tif cfg.CmdName != \"get\" && !strings.HasPrefix(cfg.CmdName, \"mod \") {\n+\t\t\treturn nil, nil\n+\t\t}\n \t}\n \n \torigPath := mod.Path\n@@ -947,13 +1072,11 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \t\t\tgomod := filepath.Join(dir, \"go.mod\")\n \t\t\tdata, err := ioutil.ReadFile(gomod)\n \t\t\tif err != nil {\n-\t\t\t\tbase.Errorf(\"go: parsing %s: %v\", base.ShortPath(gomod), err)\n-\t\t\t\treturn nil, ErrRequire\n+\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n \t\t\t}\n \t\t\tf, err := modfile.ParseLax(gomod, data, nil)\n \t\t\tif err != nil {\n-\t\t\t\tbase.Errorf(\"go: parsing %s: %v\", base.ShortPath(gomod), err)\n-\t\t\t\treturn nil, ErrRequire\n+\t\t\t\treturn nil, fmt.Errorf(\"parsing %s: %v\", base.ShortPath(gomod), err)\n \t\t\t}\n \t\t\tif f.Go != nil {\n \t\t\t\tr.versions.LoadOrStore(mod, f.Go.Version)\n@@ -974,22 +1097,18 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \n \tdata, err := modfetch.GoMod(mod.Path, mod.Version)\n \tif err != nil {\n-\t\tbase.Errorf(\"go: %s@%s: %v\\n\", mod.Path, mod.Version, err)\n-\t\treturn nil, ErrRequire\n+\t\treturn nil, err\n \t}\n \tf, err := modfile.ParseLax(\"go.mod\", data, nil)\n \tif err != nil {\n-\t\tbase.Errorf(\"go: %s@%s: parsing go.mod: %v\", mod.Path, mod.Version, err)\n-\t\treturn nil, ErrRequire\n+\t\treturn nil, module.VersionError(mod, fmt.Errorf(\"parsing go.mod: %v\", err))\n \t}\n \n \tif f.Module == nil {\n-\t\tbase.Errorf(\"go: %s@%s: parsing go.mod: missing module line\", mod.Path, mod.Version)\n-\t\treturn nil, ErrRequire\n+\t\treturn nil, module.VersionError(mod, errors.New(\"parsing go.mod: missing module line\"))\n \t}\n \tif mpath := f.Module.Mod.Path; mpath != origPath && mpath != mod.Path {\n-\t\tbase.Errorf(\"go: %s@%s: parsing go.mod: unexpected module path %q\", mod.Path, mod.Version, mpath)\n-\t\treturn nil, ErrRequire\n+\t\treturn nil, module.VersionError(mod, fmt.Errorf(\"parsing go.mod: unexpected module path %q\", mpath))\n \t}\n \tif f.Go != nil {\n \t\tr.versions.LoadOrStore(mod, f.Go.Version)\n@@ -998,11 +1117,6 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \treturn r.modFileToList(f), nil\n }\n \n-// ErrRequire is the sentinel error returned when Require encounters problems.\n-// It prints the problems directly to standard error, so that multiple errors\n-// can be displayed easily.\n-var ErrRequire = errors.New(\"error loading module requirements\")\n-\n func (*mvsReqs) Max(v1, v2 string) string {\n \tif v1 != \"\" && semver.Compare(v1, v2) == -1 {\n \t\treturn v2\n@@ -1019,11 +1133,15 @@ func (*mvsReqs) Upgrade(m module.Version) (module.Version, error) {\n func versions(path string) ([]string, error) {\n \t// Note: modfetch.Lookup and repo.Versions are cached,\n \t// so there's no need for us to add extra caching here.\n-\trepo, err := modfetch.Lookup(path)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\treturn repo.Versions(\"\")\n+\tvar versions []string\n+\terr := modfetch.TryProxies(func(proxy string) error {\n+\t\trepo, err := modfetch.Lookup(proxy, path)\n+\t\tif err == nil {\n+\t\t\tversions, err = repo.Versions(\"\")\n+\t\t}\n+\t\treturn err\n+\t})\n+\treturn versions, err\n }\n \n // Previous returns the tagged version of m.Path immediately prior to"}, {"sha": "8ce61c0a1d6657e525e2989a5160cd2dfda4ffb2", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 361, "deletions": 65, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,35 +5,64 @@\n package modload\n \n import (\n-\t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/semver\"\n+\t\"errors\"\n \t\"fmt\"\n+\t\"os\"\n \tpathpkg \"path\"\n \t\"strings\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/imports\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/search\"\n+\t\"cmd/go/internal/semver\"\n+\t\"cmd/go/internal/str\"\n )\n \n // Query looks up a revision of a given module given a version query string.\n // The module must be a complete module path.\n // The version must take one of the following forms:\n //\n-//\t- the literal string \"latest\", denoting the latest available, allowed tagged version,\n-//\t  with non-prereleases preferred over prereleases.\n-//\t  If there are no tagged versions in the repo, latest returns the most recent commit.\n-//\t- v1, denoting the latest available tagged version v1.x.x.\n-//\t- v1.2, denoting the latest available tagged version v1.2.x.\n-//\t- v1.2.3, a semantic version string denoting that tagged version.\n-//\t- <v1.2.3, <=v1.2.3, >v1.2.3, >=v1.2.3,\n-//\t   denoting the version closest to the target and satisfying the given operator,\n-//\t   with non-prereleases preferred over prereleases.\n-//\t- a repository commit identifier, denoting that commit.\n+// - the literal string \"latest\", denoting the latest available, allowed\n+//   tagged version, with non-prereleases preferred over prereleases.\n+//   If there are no tagged versions in the repo, latest returns the most\n+//   recent commit.\n+// - the literal string \"patch\", denoting the latest available tagged version\n+//   with the same major and minor number as current. If current is \"\",\n+//   \"patch\" is equivalent to \"latest\".\n+// - v1, denoting the latest available tagged version v1.x.x.\n+// - v1.2, denoting the latest available tagged version v1.2.x.\n+// - v1.2.3, a semantic version string denoting that tagged version.\n+// - <v1.2.3, <=v1.2.3, >v1.2.3, >=v1.2.3,\n+//   denoting the version closest to the target and satisfying the given operator,\n+//   with non-prereleases preferred over prereleases.\n+// - a repository commit identifier or tag, denoting that commit.\n+//\n+// current is optional, denoting the current version of the module.\n+// If query is \"latest\" or \"patch\", current will be returned if it is a newer\n+// semantic version or if it is a chronologically later pseudoversion. This\n+// prevents accidental downgrades from newer prerelease or development\n+// versions.\n //\n-// If the allowed function is non-nil, Query excludes any versions for which allowed returns false.\n+// If the allowed function is non-nil, Query excludes any versions for which\n+// allowed returns false.\n //\n // If path is the path of the main module and the query is \"latest\",\n // Query returns Target.Version as the version.\n-func Query(path, query string, allowed func(module.Version) bool) (*modfetch.RevInfo, error) {\n+func Query(path, query, current string, allowed func(module.Version) bool) (*modfetch.RevInfo, error) {\n+\tvar info *modfetch.RevInfo\n+\terr := modfetch.TryProxies(func(proxy string) (err error) {\n+\t\tinfo, err = queryProxy(proxy, path, query, current, allowed)\n+\t\treturn err\n+\t})\n+\treturn info, err\n+}\n+\n+func queryProxy(proxy, path, query, current string, allowed func(module.Version) bool) (*modfetch.RevInfo, error) {\n+\tif current != \"\" && !semver.IsValid(current) {\n+\t\treturn nil, fmt.Errorf(\"invalid previous version %q\", current)\n+\t}\n \tif allowed == nil {\n \t\tallowed = func(module.Version) bool { return true }\n \t}\n@@ -46,9 +75,22 @@ func Query(path, query string, allowed func(module.Version) bool) (*modfetch.Rev\n \tvar ok func(module.Version) bool\n \tvar prefix string\n \tvar preferOlder bool\n+\tvar mayUseLatest bool\n \tswitch {\n \tcase query == \"latest\":\n \t\tok = allowed\n+\t\tmayUseLatest = true\n+\n+\tcase query == \"patch\":\n+\t\tif current == \"\" {\n+\t\t\tok = allowed\n+\t\t\tmayUseLatest = true\n+\t\t} else {\n+\t\t\tprefix = semver.MajorMinor(current)\n+\t\t\tok = func(m module.Version) bool {\n+\t\t\t\treturn matchSemverPrefix(prefix, m.Version) && allowed(m)\n+\t\t\t}\n+\t\t}\n \n \tcase strings.HasPrefix(query, \"<=\"):\n \t\tv := query[len(\"<=\"):]\n@@ -102,18 +144,27 @@ func Query(path, query string, allowed func(module.Version) bool) (*modfetch.Rev\n \t\t}\n \t\tprefix = query + \".\"\n \n-\tcase semver.IsValid(query):\n-\t\tvers := module.CanonicalVersion(query)\n-\t\tif !allowed(module.Version{Path: path, Version: vers}) {\n-\t\t\treturn nil, fmt.Errorf(\"%s@%s excluded\", path, vers)\n-\t\t}\n-\t\treturn modfetch.Stat(path, vers)\n-\n \tdefault:\n \t\t// Direct lookup of semantic version or commit identifier.\n-\t\tinfo, err := modfetch.Stat(path, query)\n+\t\t//\n+\t\t// If the identifier is not a canonical semver tag \u2014 including if it's a\n+\t\t// semver tag with a +metadata suffix \u2014 then modfetch.Stat will populate\n+\t\t// info.Version with a suitable pseudo-version.\n+\t\tinfo, err := modfetch.Stat(proxy, path, query)\n \t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\t\tqueryErr := err\n+\t\t\t// The full query doesn't correspond to a tag. If it is a semantic version\n+\t\t\t// with a +metadata suffix, see if there is a tag without that suffix:\n+\t\t\t// semantic versioning defines them to be equivalent.\n+\t\t\tif vers := module.CanonicalVersion(query); vers != \"\" && vers != query {\n+\t\t\t\tinfo, err = modfetch.Stat(proxy, path, vers)\n+\t\t\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\t\t\treturn info, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, queryErr\n+\t\t\t}\n \t\t}\n \t\tif !allowed(module.Version{Path: path, Version: info.Version}) {\n \t\t\treturn nil, fmt.Errorf(\"%s@%s excluded\", path, info.Version)\n@@ -131,8 +182,12 @@ func Query(path, query string, allowed func(module.Version) bool) (*modfetch.Rev\n \t\treturn &modfetch.RevInfo{Version: Target.Version}, nil\n \t}\n \n+\tif str.HasPathPrefix(path, \"std\") || str.HasPathPrefix(path, \"cmd\") {\n+\t\treturn nil, fmt.Errorf(\"explicit requirement on standard-library module %s not allowed\", path)\n+\t}\n+\n \t// Load versions and execute query.\n-\trepo, err := modfetch.Lookup(path)\n+\trepo, err := modfetch.Lookup(proxy, path)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -141,44 +196,67 @@ func Query(path, query string, allowed func(module.Version) bool) (*modfetch.Rev\n \t\treturn nil, err\n \t}\n \n+\tlookup := func(v string) (*modfetch.RevInfo, error) {\n+\t\trev, err := repo.Stat(v)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// For \"latest\" and \"patch\", make sure we don't accidentally downgrade\n+\t\t// from a newer prerelease or from a chronologically newer pseudoversion.\n+\t\tif current != \"\" && (query == \"latest\" || query == \"patch\") {\n+\t\t\tcurrentTime, err := modfetch.PseudoVersionTime(current)\n+\t\t\tif semver.Compare(rev.Version, current) < 0 || (err == nil && rev.Time.Before(currentTime)) {\n+\t\t\t\treturn repo.Stat(current)\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn rev, nil\n+\t}\n+\n \tif preferOlder {\n \t\tfor _, v := range versions {\n \t\t\tif semver.Prerelease(v) == \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn repo.Stat(v)\n+\t\t\t\treturn lookup(v)\n \t\t\t}\n \t\t}\n \t\tfor _, v := range versions {\n \t\t\tif semver.Prerelease(v) != \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn repo.Stat(v)\n+\t\t\t\treturn lookup(v)\n \t\t\t}\n \t\t}\n \t} else {\n \t\tfor i := len(versions) - 1; i >= 0; i-- {\n \t\t\tv := versions[i]\n \t\t\tif semver.Prerelease(v) == \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn repo.Stat(v)\n+\t\t\t\treturn lookup(v)\n \t\t\t}\n \t\t}\n \t\tfor i := len(versions) - 1; i >= 0; i-- {\n \t\t\tv := versions[i]\n \t\t\tif semver.Prerelease(v) != \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn repo.Stat(v)\n+\t\t\t\treturn lookup(v)\n \t\t\t}\n \t\t}\n \t}\n \n-\tif query == \"latest\" {\n+\tif mayUseLatest {\n \t\t// Special case for \"latest\": if no tags match, use latest commit in repo,\n \t\t// provided it is not excluded.\n-\t\tif info, err := repo.Latest(); err == nil && allowed(module.Version{Path: path, Version: info.Version}) {\n-\t\t\treturn info, nil\n+\t\tlatest, err := repo.Latest()\n+\t\tif err == nil {\n+\t\t\tif allowed(module.Version{Path: path, Version: latest.Version}) {\n+\t\t\t\treturn lookup(latest.Version)\n+\t\t\t}\n+\t\t} else if !errors.Is(err, os.ErrNotExist) {\n+\t\t\treturn nil, err\n \t\t}\n \t}\n \n-\treturn nil, fmt.Errorf(\"no matching versions for query %q\", query)\n+\treturn nil, &NoMatchingVersionError{query: query, current: current}\n }\n \n-// isSemverPrefix reports whether v is a semantic version prefix: v1 or  v1.2 (not v1.2.3).\n+// isSemverPrefix reports whether v is a semantic version prefix: v1 or v1.2 (not v1.2.3).\n // The caller is assumed to have checked that semver.IsValid(v) is true.\n func isSemverPrefix(v string) bool {\n \tdots := 0\n@@ -199,53 +277,271 @@ func isSemverPrefix(v string) bool {\n // matchSemverPrefix reports whether the shortened semantic version p\n // matches the full-width (non-shortened) semantic version v.\n func matchSemverPrefix(p, v string) bool {\n-\treturn len(v) > len(p) && v[len(p)] == '.' && v[:len(p)] == p\n+\treturn len(v) > len(p) && v[len(p)] == '.' && v[:len(p)] == p && semver.Prerelease(v) == \"\"\n+}\n+\n+type QueryResult struct {\n+\tMod      module.Version\n+\tRev      *modfetch.RevInfo\n+\tPackages []string\n+}\n+\n+// QueryPackage looks up the module(s) containing path at a revision matching\n+// query. The results are sorted by module path length in descending order.\n+//\n+// If the package is in the main module, QueryPackage considers only the main\n+// module and only the version \"latest\", without checking for other possible\n+// modules.\n+func QueryPackage(path, query string, allowed func(module.Version) bool) ([]QueryResult, error) {\n+\tif search.IsMetaPackage(path) || strings.Contains(path, \"...\") {\n+\t\treturn nil, fmt.Errorf(\"pattern %s is not an importable package\", path)\n+\t}\n+\treturn QueryPattern(path, query, allowed)\n }\n \n-// QueryPackage looks up a revision of a module containing path.\n+// QueryPattern looks up the module(s) containing at least one package matching\n+// the given pattern at the given version. The results are sorted by module path\n+// length in descending order.\n //\n-// If multiple modules with revisions matching the query provide the requested\n-// package, QueryPackage picks the one with the longest module path.\n+// QueryPattern queries modules with package paths up to the first \"...\"\n+// in the pattern. For the pattern \"example.com/a/b.../c\", QueryPattern would\n+// consider prefixes of \"example.com/a\". If multiple modules have versions\n+// that match the query and packages that match the pattern, QueryPattern\n+// picks the one with the longest module path.\n //\n-// If the path is in the main module and the query is \"latest\",\n-// QueryPackage returns Target as the version.\n-func QueryPackage(path, query string, allowed func(module.Version) bool) (module.Version, *modfetch.RevInfo, error) {\n+// If any matching package is in the main module, QueryPattern considers only\n+// the main module and only the version \"latest\", without checking for other\n+// possible modules.\n+func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]QueryResult, error) {\n+\tbase := pattern\n+\tvar match func(m module.Version, root string, isLocal bool) (pkgs []string)\n+\n+\tif i := strings.Index(pattern, \"...\"); i >= 0 {\n+\t\tbase = pathpkg.Dir(pattern[:i+3])\n+\t\tmatch = func(m module.Version, root string, isLocal bool) []string {\n+\t\t\treturn matchPackages(pattern, imports.AnyTags(), false, []module.Version{m})\n+\t\t}\n+\t} else {\n+\t\tmatch = func(m module.Version, root string, isLocal bool) []string {\n+\t\t\tprefix := m.Path\n+\t\t\tif m == Target {\n+\t\t\t\tprefix = targetPrefix\n+\t\t\t}\n+\t\t\tif _, ok := dirInModule(pattern, prefix, root, isLocal); ok {\n+\t\t\t\treturn []string{pattern}\n+\t\t\t} else {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tif HasModRoot() {\n-\t\tif _, ok := dirInModule(path, Target.Path, modRoot, true); ok {\n+\t\tpkgs := match(Target, modRoot, true)\n+\t\tif len(pkgs) > 0 {\n \t\t\tif query != \"latest\" {\n-\t\t\t\treturn module.Version{}, nil, fmt.Errorf(\"can't query specific version (%q) for package %s in the main module (%s)\", query, path, Target.Path)\n+\t\t\t\treturn nil, fmt.Errorf(\"can't query specific version for package %s in the main module (%s)\", pattern, Target.Path)\n \t\t\t}\n \t\t\tif !allowed(Target) {\n-\t\t\t\treturn module.Version{}, nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed\", path, Target.Path)\n+\t\t\t\treturn nil, fmt.Errorf(\"internal error: package %s is in the main module (%s), but version is not allowed\", pattern, Target.Path)\n \t\t\t}\n-\t\t\treturn Target, &modfetch.RevInfo{Version: Target.Version}, nil\n+\t\t\treturn []QueryResult{{\n+\t\t\t\tMod:      Target,\n+\t\t\t\tRev:      &modfetch.RevInfo{Version: Target.Version},\n+\t\t\t\tPackages: pkgs,\n+\t\t\t}}, nil\n \t\t}\n \t}\n \n-\tfinalErr := errMissing\n-\tfor p := path; p != \".\" && p != \"/\"; p = pathpkg.Dir(p) {\n-\t\tinfo, err := Query(p, query, allowed)\n-\t\tif err != nil {\n-\t\t\tif _, ok := err.(*codehost.VCSError); ok {\n-\t\t\t\t// A VCSError means we know where to find the code,\n-\t\t\t\t// we just can't. Abort search.\n-\t\t\t\treturn module.Version{}, nil, err\n+\tvar (\n+\t\tresults          []QueryResult\n+\t\tcandidateModules = modulePrefixesExcludingTarget(base)\n+\t)\n+\tif len(candidateModules) == 0 {\n+\t\treturn nil, fmt.Errorf(\"package %s is not in the main module (%s)\", pattern, Target.Path)\n+\t}\n+\n+\terr := modfetch.TryProxies(func(proxy string) error {\n+\t\tqueryModule := func(path string) (r QueryResult, err error) {\n+\t\t\tr.Mod.Path = path\n+\t\t\tr.Rev, err = queryProxy(proxy, path, query, \"\", allowed)\n+\t\t\tif err != nil {\n+\t\t\t\treturn r, err\n+\t\t\t}\n+\t\t\tr.Mod.Version = r.Rev.Version\n+\t\t\troot, isLocal, err := fetch(r.Mod)\n+\t\t\tif err != nil {\n+\t\t\t\treturn r, err\n \t\t\t}\n-\t\t\tif finalErr == errMissing {\n-\t\t\t\tfinalErr = err\n+\t\t\tr.Packages = match(r.Mod, root, isLocal)\n+\t\t\tif len(r.Packages) == 0 {\n+\t\t\t\treturn r, &packageNotInModuleError{\n+\t\t\t\t\tmod:     r.Mod,\n+\t\t\t\t\tquery:   query,\n+\t\t\t\t\tpattern: pattern,\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tcontinue\n+\t\t\treturn r, nil\n \t\t}\n-\t\tm := module.Version{Path: p, Version: info.Version}\n-\t\troot, isLocal, err := fetch(m)\n-\t\tif err != nil {\n-\t\t\treturn module.Version{}, nil, err\n+\n+\t\tvar err error\n+\t\tresults, err = queryPrefixModules(candidateModules, queryModule)\n+\t\treturn err\n+\t})\n+\n+\treturn results, err\n+}\n+\n+// modulePrefixesExcludingTarget returns all prefixes of path that may plausibly\n+// exist as a module, excluding targetPrefix but otherwise including path\n+// itself, sorted by descending length.\n+func modulePrefixesExcludingTarget(path string) []string {\n+\tprefixes := make([]string, 0, strings.Count(path, \"/\")+1)\n+\n+\tfor {\n+\t\tif path != targetPrefix {\n+\t\t\tif _, _, ok := module.SplitPathVersion(path); ok {\n+\t\t\t\tprefixes = append(prefixes, path)\n+\t\t\t}\n \t\t}\n-\t\t_, ok := dirInModule(path, m.Path, root, isLocal)\n-\t\tif ok {\n-\t\t\treturn m, info, nil\n+\n+\t\tj := strings.LastIndexByte(path, '/')\n+\t\tif j < 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tpath = path[:j]\n+\t}\n+\n+\treturn prefixes\n+}\n+\n+type prefixResult struct {\n+\tQueryResult\n+\terr error\n+}\n+\n+func queryPrefixModules(candidateModules []string, queryModule func(path string) (QueryResult, error)) (found []QueryResult, err error) {\n+\t// If the path we're attempting is not in the module cache and we don't have a\n+\t// fetch result cached either, we'll end up making a (potentially slow)\n+\t// request to the proxy or (often even slower) the origin server.\n+\t// To minimize latency, execute all of those requests in parallel.\n+\ttype result struct {\n+\t\tQueryResult\n+\t\terr error\n+\t}\n+\tresults := make([]result, len(candidateModules))\n+\tvar wg sync.WaitGroup\n+\twg.Add(len(candidateModules))\n+\tfor i, p := range candidateModules {\n+\t\tgo func(p string, r *result) {\n+\t\t\tr.QueryResult, r.err = queryModule(p)\n+\t\t\twg.Done()\n+\t\t}(p, &results[i])\n+\t}\n+\twg.Wait()\n+\n+\t// Classify the results. In case of failure, identify the error that the user\n+\t// is most likely to find helpful.\n+\tvar (\n+\t\tnoVersion   *NoMatchingVersionError\n+\t\tnoPackage   *packageNotInModuleError\n+\t\tnotExistErr error\n+\t)\n+\tfor _, r := range results {\n+\t\tswitch rErr := r.err.(type) {\n+\t\tcase nil:\n+\t\t\tfound = append(found, r.QueryResult)\n+\t\tcase *NoMatchingVersionError:\n+\t\t\tif noVersion == nil {\n+\t\t\t\tnoVersion = rErr\n+\t\t\t}\n+\t\tcase *packageNotInModuleError:\n+\t\t\tif noPackage == nil {\n+\t\t\t\tnoPackage = rErr\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tif errors.Is(rErr, os.ErrNotExist) {\n+\t\t\t\tif notExistErr == nil {\n+\t\t\t\t\tnotExistErr = rErr\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\terr = r.err\n+\t\t\t}\n \t\t}\n \t}\n \n-\treturn module.Version{}, nil, finalErr\n+\t// TODO(#26232): If len(found) == 0 and some of the errors are 4xx HTTP\n+\t// codes, have the auth package recheck the failed paths.\n+\t// If we obtain new credentials for any of them, re-run the above loop.\n+\n+\tif len(found) == 0 && err == nil {\n+\t\tswitch {\n+\t\tcase noPackage != nil:\n+\t\t\terr = noPackage\n+\t\tcase noVersion != nil:\n+\t\t\terr = noVersion\n+\t\tcase notExistErr != nil:\n+\t\t\terr = notExistErr\n+\t\tdefault:\n+\t\t\tpanic(\"queryPrefixModules: no modules found, but no error detected\")\n+\t\t}\n+\t}\n+\n+\treturn found, err\n+}\n+\n+// A NoMatchingVersionError indicates that Query found a module at the requested\n+// path, but not at any versions satisfying the query string and allow-function.\n+//\n+// NOTE: NoMatchingVersionError MUST NOT implement Is(os.ErrNotExist).\n+//\n+// If the module came from a proxy, that proxy had to return a successful status\n+// code for the versions it knows about, and thus did not have the opportunity\n+// to return a non-400 status code to suppress fallback.\n+type NoMatchingVersionError struct {\n+\tquery, current string\n+}\n+\n+func (e *NoMatchingVersionError) Error() string {\n+\tcurrentSuffix := \"\"\n+\tif (e.query == \"latest\" || e.query == \"patch\") && e.current != \"\" {\n+\t\tcurrentSuffix = fmt.Sprintf(\" (current version is %s)\", e.current)\n+\t}\n+\treturn fmt.Sprintf(\"no matching versions for query %q\", e.query) + currentSuffix\n+}\n+\n+// A packageNotInModuleError indicates that QueryPattern found a candidate\n+// module at the requested version, but that module did not contain any packages\n+// matching the requested pattern.\n+//\n+// NOTE: packageNotInModuleError MUST NOT implement Is(os.ErrNotExist).\n+//\n+// If the module came from a proxy, that proxy had to return a successful status\n+// code for the versions it knows about, and thus did not have the opportunity\n+// to return a non-400 status code to suppress fallback.\n+type packageNotInModuleError struct {\n+\tmod     module.Version\n+\tquery   string\n+\tpattern string\n+}\n+\n+func (e *packageNotInModuleError) Error() string {\n+\tfound := \"\"\n+\tif e.query != e.mod.Version {\n+\t\tfound = fmt.Sprintf(\" (%s)\", e.mod.Version)\n+\t}\n+\n+\tif strings.Contains(e.pattern, \"...\") {\n+\t\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain packages matching %s\", e.mod.Path, e.query, found, e.pattern)\n+\t}\n+\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain package %s\", e.mod.Path, e.query, found, e.pattern)\n+}\n+\n+// ModuleHasRootPackage returns whether module m contains a package m.Path.\n+func ModuleHasRootPackage(m module.Version) (bool, error) {\n+\troot, isLocal, err := fetch(m)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\t_, ok := dirInModule(m.Path, m.Path, root, isLocal)\n+\treturn ok, nil\n }"}, {"sha": "5c0527d40c947bef096c2ea7c373e0d25eda3cde", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 63, "deletions": 13, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"strings\"\n \t\"testing\"\n \n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/module\"\n@@ -24,11 +25,16 @@ func TestMain(m *testing.M) {\n }\n \n func testMain(m *testing.M) int {\n+\tcfg.GOPROXY = \"direct\"\n+\n \tdir, err := ioutil.TempDir(\"\", \"modload-test-\")\n \tif err != nil {\n \t\tlog.Fatal(err)\n \t}\n \tdefer os.RemoveAll(dir)\n+\n+\tos.Setenv(\"GOPATH\", dir)\n+\tcfg.BuildContext.GOPATH = dir\n \tmodfetch.PkgMod = filepath.Join(dir, \"pkg/mod\")\n \tcodehost.WorkRoot = filepath.Join(dir, \"codework\")\n \treturn m.Run()\n@@ -44,19 +50,20 @@ var (\n )\n \n var queryTests = []struct {\n-\tpath  string\n-\tquery string\n-\tallow string\n-\tvers  string\n-\terr   string\n+\tpath    string\n+\tquery   string\n+\tcurrent string\n+\tallow   string\n+\tvers    string\n+\terr     string\n }{\n \t/*\n \t\tgit init\n \t\techo module vcs-test.golang.org/git/querytest.git >go.mod\n \t\tgit add go.mod\n \t\tgit commit -m v1 go.mod\n \t\tgit tag start\n-\t\tfor i in v0.0.0-pre1 v0.0.0 v0.0.1 v0.0.2 v0.0.3 v0.1.0 v0.1.1 v0.1.2 v0.3.0 v1.0.0 v1.1.0 v1.9.0 v1.9.9 v1.9.10-pre1; do\n+\t\tfor i in v0.0.0-pre1 v0.0.0 v0.0.1 v0.0.2 v0.0.3 v0.1.0 v0.1.1 v0.1.2 v0.3.0 v1.0.0 v1.1.0 v1.9.0 v1.9.9 v1.9.10-pre1 v1.9.10-pre2+metadata; do\n \t\t\techo before $i >status\n \t\t\tgit add status\n \t\t\tgit commit -m \"before $i\" status\n@@ -70,14 +77,15 @@ var queryTests = []struct {\n \t\tgit checkout v2\n \t\techo module vcs-test.golang.org/git/querytest.git/v2 >go.mod\n \t\tgit commit -m v2 go.mod\n-\t\tfor i in v2.0.0 v2.1.0 v2.2.0 v2.5.5; do\n+\t\tfor i in v2.0.0 v2.1.0 v2.2.0 v2.5.5 v2.6.0-pre1; do\n \t\t\techo before $i >status\n \t\t\tgit add status\n \t\t\tgit commit -m \"before $i\" status\n \t\t\techo at $i >status\n \t\t\tgit commit -m \"at $i\" status\n \t\t\tgit tag $i\n \t\tdone\n+\t\tgit checkout v2.5.5\n \t\techo after v2.5.5 >status\n \t\tgit commit -m 'after v2.5.5' status\n \t\tgit checkout master\n@@ -97,22 +105,61 @@ var queryTests = []struct {\n \t{path: queryRepo, query: \"v0.1\", vers: \"v0.1.2\"},\n \t{path: queryRepo, query: \"v0.2\", err: `no matching versions for query \"v0.2\"`},\n \t{path: queryRepo, query: \"v0.0\", vers: \"v0.0.3\"},\n+\t{path: queryRepo, query: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n+\n+\t// golang.org/issue/29262: The major version for for a module without a suffix\n+\t// should be based on the most recent tag (v1 as appropriate, not v0\n+\t// unconditionally).\n+\t{path: queryRepo, query: \"42abcb6df8ee\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n+\n+\t{path: queryRepo, query: \"v1.9.10-pre2+wrongmetadata\", err: `unknown revision v1.9.10-pre2+wrongmetadata`},\n+\t{path: queryRepo, query: \"v1.9.10-pre2\", err: `unknown revision v1.9.10-pre2`},\n \t{path: queryRepo, query: \"latest\", vers: \"v1.9.9\"},\n+\t{path: queryRepo, query: \"latest\", current: \"v1.9.10-pre1\", vers: \"v1.9.10-pre1\"},\n+\t{path: queryRepo, query: \"latest\", current: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n+\t{path: queryRepo, query: \"latest\", current: \"v0.0.0-20190513201126-42abcb6df8ee\", vers: \"v0.0.0-20190513201126-42abcb6df8ee\"},\n \t{path: queryRepo, query: \"latest\", allow: \"NOMATCH\", err: `no matching versions for query \"latest\"`},\n+\t{path: queryRepo, query: \"latest\", current: \"v1.9.9\", allow: \"NOMATCH\", err: `no matching versions for query \"latest\" (current version is v1.9.9)`},\n+\t{path: queryRepo, query: \"latest\", current: \"v1.99.99\", err: `unknown revision v1.99.99`},\n+\t{path: queryRepo, query: \"patch\", current: \"\", vers: \"v1.9.9\"},\n+\t{path: queryRepo, query: \"patch\", current: \"v0.1.0\", vers: \"v0.1.2\"},\n+\t{path: queryRepo, query: \"patch\", current: \"v1.9.0\", vers: \"v1.9.9\"},\n+\t{path: queryRepo, query: \"patch\", current: \"v1.9.10-pre1\", vers: \"v1.9.10-pre1\"},\n+\t{path: queryRepo, query: \"patch\", current: \"v1.9.10-pre2+metadata\", vers: \"v1.9.10-pre2.0.20190513201126-42abcb6df8ee\"},\n+\t{path: queryRepo, query: \"patch\", current: \"v1.99.99\", err: `no matching versions for query \"patch\" (current version is v1.99.99)`},\n \t{path: queryRepo, query: \">v1.9.9\", vers: \"v1.9.10-pre1\"},\n \t{path: queryRepo, query: \">v1.10.0\", err: `no matching versions for query \">v1.10.0\"`},\n \t{path: queryRepo, query: \">=v1.10.0\", err: `no matching versions for query \">=v1.10.0\"`},\n \t{path: queryRepo, query: \"6cf84eb\", vers: \"v0.0.2-0.20180704023347-6cf84ebaea54\"},\n+\n+\t// golang.org/issue/27173: A pseudo-version may be based on the highest tag on\n+\t// any parent commit, or any existing semantically-lower tag: a given commit\n+\t// could have been a pre-release for a backport tag at any point.\n+\t{path: queryRepo, query: \"3ef0cec634e0\", vers: \"v0.1.2-0.20180704023347-3ef0cec634e0\"},\n+\t{path: queryRepo, query: \"v0.1.2-0.20180704023347-3ef0cec634e0\", vers: \"v0.1.2-0.20180704023347-3ef0cec634e0\"},\n+\t{path: queryRepo, query: \"v0.1.1-0.20180704023347-3ef0cec634e0\", vers: \"v0.1.1-0.20180704023347-3ef0cec634e0\"},\n+\t{path: queryRepo, query: \"v0.0.4-0.20180704023347-3ef0cec634e0\", vers: \"v0.0.4-0.20180704023347-3ef0cec634e0\"},\n+\n+\t// Invalid tags are tested in cmd/go/testdata/script/mod_pseudo_invalid.txt.\n+\n \t{path: queryRepo, query: \"start\", vers: \"v0.0.0-20180704023101-5e9e31667ddf\"},\n+\t{path: queryRepo, query: \"5e9e31667ddf\", vers: \"v0.0.0-20180704023101-5e9e31667ddf\"},\n+\t{path: queryRepo, query: \"v0.0.0-20180704023101-5e9e31667ddf\", vers: \"v0.0.0-20180704023101-5e9e31667ddf\"},\n+\n \t{path: queryRepo, query: \"7a1b6bf\", vers: \"v0.1.0\"},\n \n \t{path: queryRepoV2, query: \"<v0.0.0\", err: `no matching versions for query \"<v0.0.0\"`},\n \t{path: queryRepoV2, query: \"<=v0.0.0\", err: `no matching versions for query \"<=v0.0.0\"`},\n \t{path: queryRepoV2, query: \">v0.0.0\", vers: \"v2.0.0\"},\n \t{path: queryRepoV2, query: \">=v0.0.0\", vers: \"v2.0.0\"},\n-\t{path: queryRepoV2, query: \"v0.0.1+foo\", vers: \"v2.0.0-20180704023347-179bc86b1be3\"},\n+\n+\t{path: queryRepoV2, query: \"v2\", vers: \"v2.5.5\"},\n+\t{path: queryRepoV2, query: \"v2.5\", vers: \"v2.5.5\"},\n+\t{path: queryRepoV2, query: \"v2.6\", err: `no matching versions for query \"v2.6\"`},\n+\t{path: queryRepoV2, query: \"v2.6.0-pre1\", vers: \"v2.6.0-pre1\"},\n \t{path: queryRepoV2, query: \"latest\", vers: \"v2.5.5\"},\n \n+\t{path: queryRepoV3, query: \"e0cf3de987e6\", vers: \"v3.0.0-20180704024501-e0cf3de987e6\"},\n \t{path: queryRepoV3, query: \"latest\", vers: \"v3.0.0-20180704024501-e0cf3de987e6\"},\n \n \t{path: emptyRepo, query: \"latest\", vers: \"v0.0.0-20180704023549-7bb914627242\"},\n@@ -122,6 +169,7 @@ var queryTests = []struct {\n \n func TestQuery(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"git\")\n \n \tfor _, tt := range queryTests {\n \t\tallow := tt.allow\n@@ -132,13 +180,15 @@ func TestQuery(t *testing.T) {\n \t\t\tok, _ := path.Match(allow, m.Version)\n \t\t\treturn ok\n \t\t}\n-\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.query+\"/\"+allow, func(t *testing.T) {\n-\t\t\tinfo, err := Query(tt.path, tt.query, allowed)\n+\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.query+\"/\"+tt.current+\"/\"+allow, func(t *testing.T) {\n+\t\t\tinfo, err := Query(tt.path, tt.query, tt.current, allowed)\n \t\t\tif tt.err != \"\" {\n-\t\t\t\tif err != nil && err.Error() == tt.err {\n-\t\t\t\t\treturn\n+\t\t\t\tif err == nil {\n+\t\t\t\t\tt.Errorf(\"Query(%q, %q, %v) = %v, want error %q\", tt.path, tt.query, allow, info.Version, tt.err)\n+\t\t\t\t} else if err.Error() != tt.err {\n+\t\t\t\t\tt.Errorf(\"Query(%q, %q, %v): %v, want error %q\", tt.path, tt.query, allow, err, tt.err)\n \t\t\t\t}\n-\t\t\t\tt.Fatalf(\"Query(%q, %q, %v): %v, want error %q\", tt.path, tt.query, allow, err, tt.err)\n+\t\t\t\treturn\n \t\t\t}\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"Query(%q, %q, %v): %v\", tt.path, tt.query, allow, err)"}, {"sha": "d82386eca30538511800a4cd408a0004cdd4665e", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -35,12 +35,14 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t}\n \tvar pkgs []string\n \n-\twalkPkgs := func(root, importPathRoot string) {\n+\ttype pruning int8\n+\tconst (\n+\t\tpruneVendor = pruning(1 << iota)\n+\t\tpruneGoMod\n+\t)\n+\n+\twalkPkgs := func(root, importPathRoot string, prune pruning) {\n \t\troot = filepath.Clean(root)\n-\t\tvar cmd string\n-\t\tif root == cfg.GOROOTsrc {\n-\t\t\tcmd = filepath.Join(root, \"cmd\")\n-\t\t}\n \t\tfilepath.Walk(root, func(path string, fi os.FileInfo, err error) error {\n \t\t\tif err != nil {\n \t\t\t\treturn nil\n@@ -51,14 +53,6 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\t\treturn nil\n \t\t\t}\n \n-\t\t\t// GOROOT/src/cmd makes use of GOROOT/src/cmd/vendor,\n-\t\t\t// which module mode can't deal with. Eventually we'll stop using\n-\t\t\t// that vendor directory, and then we can remove this exclusion.\n-\t\t\t// golang.org/issue/26924.\n-\t\t\tif path == cmd {\n-\t\t\t\treturn filepath.SkipDir\n-\t\t\t}\n-\n \t\t\twant := true\n \t\t\t// Avoid .foo, _foo, and testdata directory trees.\n \t\t\t_, elem := filepath.Split(path)\n@@ -86,8 +80,9 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\tif !want {\n \t\t\t\treturn filepath.SkipDir\n \t\t\t}\n-\t\t\tif path != root {\n-\t\t\t\tif _, err := os.Stat(filepath.Join(path, \"go.mod\")); err == nil {\n+\t\t\t// Stop at module boundaries.\n+\t\t\tif (prune&pruneGoMod != 0) && path != root {\n+\t\t\t\tif fi, err := os.Stat(filepath.Join(path, \"go.mod\")); err == nil && !fi.IsDir() {\n \t\t\t\t\treturn filepath.SkipDir\n \t\t\t\t}\n \t\t\t}\n@@ -101,36 +96,59 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif elem == \"vendor\" {\n+\t\t\tif elem == \"vendor\" && (prune&pruneVendor != 0) {\n \t\t\t\treturn filepath.SkipDir\n \t\t\t}\n \t\t\treturn nil\n \t\t})\n \t}\n \n \tif useStd {\n-\t\twalkPkgs(cfg.GOROOTsrc, \"\")\n+\t\twalkPkgs(cfg.GOROOTsrc, \"\", pruneGoMod)\n+\t\tif treeCanMatch(\"cmd\") {\n+\t\t\twalkPkgs(filepath.Join(cfg.GOROOTsrc, \"cmd\"), \"cmd\", pruneGoMod)\n+\t\t}\n+\t}\n+\n+\tif cfg.BuildMod == \"vendor\" {\n+\t\tif HasModRoot() {\n+\t\t\twalkPkgs(ModRoot(), targetPrefix, pruneGoMod|pruneVendor)\n+\t\t\twalkPkgs(filepath.Join(ModRoot(), \"vendor\"), \"\", pruneVendor)\n+\t\t}\n+\t\treturn pkgs\n \t}\n \n \tfor _, mod := range modules {\n \t\tif !treeCanMatch(mod.Path) {\n \t\t\tcontinue\n \t\t}\n-\t\tvar root string\n-\t\tif mod.Version == \"\" {\n+\n+\t\tvar (\n+\t\t\troot, modPrefix string\n+\t\t\tisLocal         bool\n+\t\t)\n+\t\tif mod == Target {\n \t\t\tif !HasModRoot() {\n \t\t\t\tcontinue // If there is no main module, we can't search in it.\n \t\t\t}\n \t\t\troot = ModRoot()\n+\t\t\tmodPrefix = targetPrefix\n+\t\t\tisLocal = true\n \t\t} else {\n \t\t\tvar err error\n-\t\t\troot, _, err = fetch(mod)\n+\t\t\troot, isLocal, err = fetch(mod)\n \t\t\tif err != nil {\n \t\t\t\tbase.Errorf(\"go: %v\", err)\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tmodPrefix = mod.Path\n+\t\t}\n+\n+\t\tprune := pruneVendor\n+\t\tif isLocal {\n+\t\t\tprune |= pruneGoMod\n \t\t}\n-\t\twalkPkgs(root, mod.Path)\n+\t\twalkPkgs(root, modPrefix, prune)\n \t}\n \n \treturn pkgs"}, {"sha": "3e0baba15b3ec81a2ed681a4daf35aa5ed3f9dce", "filename": "libgo/go/cmd/go/internal/module/module.go", "status": "modified", "additions": 108, "deletions": 16, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -18,6 +18,7 @@ package module\n // Changes to the semantics in this file require approval from rsc.\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"sort\"\n \t\"strings\"\n@@ -40,6 +41,60 @@ type Version struct {\n \tVersion string `json:\",omitempty\"`\n }\n \n+// A ModuleError indicates an error specific to a module.\n+type ModuleError struct {\n+\tPath    string\n+\tVersion string\n+\tErr     error\n+}\n+\n+// VersionError returns a ModuleError derived from a Version and error.\n+func VersionError(v Version, err error) error {\n+\treturn &ModuleError{\n+\t\tPath:    v.Path,\n+\t\tVersion: v.Version,\n+\t\tErr:     err,\n+\t}\n+}\n+\n+func (e *ModuleError) Error() string {\n+\tif v, ok := e.Err.(*InvalidVersionError); ok {\n+\t\treturn fmt.Sprintf(\"%s@%s: invalid %s: %v\", e.Path, v.Version, v.noun(), v.Err)\n+\t}\n+\tif e.Version != \"\" {\n+\t\treturn fmt.Sprintf(\"%s@%s: %v\", e.Path, e.Version, e.Err)\n+\t}\n+\treturn fmt.Sprintf(\"module %s: %v\", e.Path, e.Err)\n+}\n+\n+func (e *ModuleError) Unwrap() error { return e.Err }\n+\n+// An InvalidVersionError indicates an error specific to a version, with the\n+// module path unknown or specified externally.\n+//\n+// A ModuleError may wrap an InvalidVersionError, but an InvalidVersionError\n+// must not wrap a ModuleError.\n+type InvalidVersionError struct {\n+\tVersion string\n+\tPseudo  bool\n+\tErr     error\n+}\n+\n+// noun returns either \"version\" or \"pseudo-version\", depending on whether\n+// e.Version is a pseudo-version.\n+func (e *InvalidVersionError) noun() string {\n+\tif e.Pseudo {\n+\t\treturn \"pseudo-version\"\n+\t}\n+\treturn \"version\"\n+}\n+\n+func (e *InvalidVersionError) Error() string {\n+\treturn fmt.Sprintf(\"%s %q invalid: %s\", e.noun(), e.Version, e.Err)\n+}\n+\n+func (e *InvalidVersionError) Unwrap() error { return e.Err }\n+\n // Check checks that a given module path, version pair is valid.\n // In addition to the path being a valid module path\n // and the version being a valid semantic version,\n@@ -51,17 +106,14 @@ func Check(path, version string) error {\n \t\treturn err\n \t}\n \tif !semver.IsValid(version) {\n-\t\treturn fmt.Errorf(\"malformed semantic version %v\", version)\n+\t\treturn &ModuleError{\n+\t\t\tPath: path,\n+\t\t\tErr:  &InvalidVersionError{Version: version, Err: errors.New(\"not a semantic version\")},\n+\t\t}\n \t}\n \t_, pathMajor, _ := SplitPathVersion(path)\n-\tif !MatchPathMajor(version, pathMajor) {\n-\t\tif pathMajor == \"\" {\n-\t\t\tpathMajor = \"v0 or v1\"\n-\t\t}\n-\t\tif pathMajor[0] == '.' { // .v1\n-\t\t\tpathMajor = pathMajor[1:]\n-\t\t}\n-\t\treturn fmt.Errorf(\"mismatched module path %v and version %v (want %v)\", path, version, pathMajor)\n+\tif err := MatchPathMajor(version, pathMajor); err != nil {\n+\t\treturn &ModuleError{Path: path, Err: err}\n \t}\n \treturn nil\n }\n@@ -169,6 +221,9 @@ func checkPath(path string, fileName bool) error {\n \tif path == \"\" {\n \t\treturn fmt.Errorf(\"empty string\")\n \t}\n+\tif path[0] == '-' {\n+\t\treturn fmt.Errorf(\"leading dash\")\n+\t}\n \tif strings.Contains(path, \"..\") {\n \t\treturn fmt.Errorf(\"double dot\")\n \t}\n@@ -317,22 +372,56 @@ func splitGopkgIn(path string) (prefix, pathMajor string, ok bool) {\n \treturn prefix, pathMajor, true\n }\n \n-// MatchPathMajor reports whether the semantic version v\n-// matches the path major version pathMajor.\n-func MatchPathMajor(v, pathMajor string) bool {\n+// MatchPathMajor returns a non-nil error if the semantic version v\n+// does not match the path major version pathMajor.\n+func MatchPathMajor(v, pathMajor string) error {\n \tif strings.HasPrefix(pathMajor, \".v\") && strings.HasSuffix(pathMajor, \"-unstable\") {\n \t\tpathMajor = strings.TrimSuffix(pathMajor, \"-unstable\")\n \t}\n \tif strings.HasPrefix(v, \"v0.0.0-\") && pathMajor == \".v1\" {\n \t\t// Allow old bug in pseudo-versions that generated v0.0.0- pseudoversion for gopkg .v1.\n \t\t// For example, gopkg.in/yaml.v2@v2.2.1's go.mod requires gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405.\n-\t\treturn true\n+\t\treturn nil\n \t}\n \tm := semver.Major(v)\n \tif pathMajor == \"\" {\n-\t\treturn m == \"v0\" || m == \"v1\" || semver.Build(v) == \"+incompatible\"\n+\t\tif m == \"v0\" || m == \"v1\" || semver.Build(v) == \"+incompatible\" {\n+\t\t\treturn nil\n+\t\t}\n+\t\tpathMajor = \"v0 or v1\"\n+\t} else if pathMajor[0] == '/' || pathMajor[0] == '.' {\n+\t\tif m == pathMajor[1:] {\n+\t\t\treturn nil\n+\t\t}\n+\t\tpathMajor = pathMajor[1:]\n+\t}\n+\treturn &InvalidVersionError{\n+\t\tVersion: v,\n+\t\tErr:     fmt.Errorf(\"should be %s, not %s\", pathMajor, semver.Major(v)),\n \t}\n-\treturn (pathMajor[0] == '/' || pathMajor[0] == '.') && m == pathMajor[1:]\n+}\n+\n+// PathMajorPrefix returns the major-version tag prefix implied by pathMajor.\n+// An empty PathMajorPrefix allows either v0 or v1.\n+//\n+// Note that MatchPathMajor may accept some versions that do not actually begin\n+// with this prefix: namely, it accepts a 'v0.0.0-' prefix for a '.v1'\n+// pathMajor, even though that pathMajor implies 'v1' tagging.\n+func PathMajorPrefix(pathMajor string) string {\n+\tif pathMajor == \"\" {\n+\t\treturn \"\"\n+\t}\n+\tif pathMajor[0] != '/' && pathMajor[0] != '.' {\n+\t\tpanic(\"pathMajor suffix \" + pathMajor + \" passed to PathMajorPrefix lacks separator\")\n+\t}\n+\tif strings.HasPrefix(pathMajor, \".v\") && strings.HasSuffix(pathMajor, \"-unstable\") {\n+\t\tpathMajor = strings.TrimSuffix(pathMajor, \"-unstable\")\n+\t}\n+\tm := pathMajor[1:]\n+\tif m != semver.Major(m) {\n+\t\tpanic(\"pathMajor suffix \" + pathMajor + \"passed to PathMajorPrefix is not a valid major version\")\n+\t}\n+\treturn m\n }\n \n // CanonicalVersion returns the canonical form of the version string v.\n@@ -447,7 +536,10 @@ func EncodePath(path string) (encoding string, err error) {\n // and not contain exclamation marks.\n func EncodeVersion(v string) (encoding string, err error) {\n \tif err := checkElem(v, true); err != nil || strings.Contains(v, \"!\") {\n-\t\treturn \"\", fmt.Errorf(\"disallowed version string %q\", v)\n+\t\treturn \"\", &InvalidVersionError{\n+\t\t\tVersion: v,\n+\t\t\tErr:     fmt.Errorf(\"disallowed version string\"),\n+\t\t}\n \t}\n \treturn encodeString(v)\n }"}, {"sha": "b9f07bf57d549c6509d29d601c7f8d2fb33a41f6", "filename": "libgo/go/cmd/go/internal/module/module_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -79,7 +79,7 @@ var checkPathTests = []struct {\n \t{\"/x.y/z\", false, false, false},\n \t{\"x./z\", false, false, false},\n \t{\".x/z\", false, false, true},\n-\t{\"-x/z\", false, true, true},\n+\t{\"-x/z\", false, false, false},\n \t{\"x..y/z\", false, false, false},\n \t{\"x.y/z/../../w\", false, false, false},\n \t{\"x.y//z\", false, false, false},"}, {"sha": "568efbd8b2663a5c0ea0893c546882c8d05befa6", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 156, "deletions": 47, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -9,9 +9,10 @@ package mvs\n import (\n \t\"fmt\"\n \t\"sort\"\n+\t\"strings\"\n \t\"sync\"\n+\t\"sync/atomic\"\n \n-\t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n )\n@@ -34,7 +35,7 @@ type Reqs interface {\n \t// Max returns the maximum of v1 and v2 (it returns either v1 or v2).\n \t//\n \t// For all versions v, Max(v, \"none\") must be v,\n-\t// and for the tanget passed as the first argument to MVS functions,\n+\t// and for the target passed as the first argument to MVS functions,\n \t// Max(target, v) must be target.\n \t//\n \t// Note that v1 < v2 can be written Max(v1, v2) != v1\n@@ -59,12 +60,57 @@ type Reqs interface {\n \tPrevious(m module.Version) (module.Version, error)\n }\n \n-type MissingModuleError struct {\n-\tModule module.Version\n+// BuildListError decorates an error that occurred gathering requirements\n+// while constructing a build list. BuildListError prints the chain\n+// of requirements to the module where the error occurred.\n+type BuildListError struct {\n+\tErr   error\n+\tstack []buildListErrorElem\n }\n \n-func (e *MissingModuleError) Error() string {\n-\treturn fmt.Sprintf(\"missing module: %v\", e.Module)\n+type buildListErrorElem struct {\n+\tm module.Version\n+\n+\t// nextReason is the reason this module depends on the next module in the\n+\t// stack. Typically either \"requires\", or \"upgraded to\".\n+\tnextReason string\n+}\n+\n+// Module returns the module where the error occurred. If the module stack\n+// is empty, this returns a zero value.\n+func (e *BuildListError) Module() module.Version {\n+\tif len(e.stack) == 0 {\n+\t\treturn module.Version{}\n+\t}\n+\treturn e.stack[0].m\n+}\n+\n+func (e *BuildListError) Error() string {\n+\tb := &strings.Builder{}\n+\tstack := e.stack\n+\n+\t// Don't print modules at the beginning of the chain without a\n+\t// version. These always seem to be the main module or a\n+\t// synthetic module (\"target@\").\n+\tfor len(stack) > 0 && stack[len(stack)-1].m.Version == \"\" {\n+\t\tstack = stack[:len(stack)-1]\n+\t}\n+\n+\tfor i := len(stack) - 1; i >= 1; i-- {\n+\t\tfmt.Fprintf(b, \"%s@%s %s\\n\\t\", stack[i].m.Path, stack[i].m.Version, stack[i].nextReason)\n+\t}\n+\tif len(stack) == 0 {\n+\t\tb.WriteString(e.Err.Error())\n+\t} else {\n+\t\t// Ensure that the final module path and version are included as part of the\n+\t\t// error message.\n+\t\tif _, ok := e.Err.(*module.ModuleError); ok {\n+\t\t\tfmt.Fprintf(b, \"%v\", e.Err)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(b, \"%v\", module.VersionError(stack[0].m, e.Err))\n+\t\t}\n+\t}\n+\treturn b.String()\n }\n \n // BuildList returns the build list for the target module.\n@@ -73,66 +119,119 @@ func BuildList(target module.Version, reqs Reqs) ([]module.Version, error) {\n \treturn buildList(target, reqs, nil)\n }\n \n-func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) module.Version) ([]module.Version, error) {\n+func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (module.Version, error)) ([]module.Version, error) {\n \t// Explore work graph in parallel in case reqs.Required\n \t// does high-latency network operations.\n-\tvar work par.Work\n-\twork.Add(target)\n+\ttype modGraphNode struct {\n+\t\tm        module.Version\n+\t\trequired []module.Version\n+\t\tupgrade  module.Version\n+\t\terr      error\n+\t}\n \tvar (\n \t\tmu       sync.Mutex\n-\t\tmin      = map[string]string{target.Path: target.Version}\n-\t\tfirstErr error\n+\t\tmodGraph = map[module.Version]*modGraphNode{}\n+\t\tmin      = map[string]string{} // maps module path to minimum required version\n+\t\thaveErr  int32\n \t)\n+\tsetErr := func(n *modGraphNode, err error) {\n+\t\tn.err = err\n+\t\tatomic.StoreInt32(&haveErr, 1)\n+\t}\n+\n+\tvar work par.Work\n+\twork.Add(target)\n \twork.Do(10, func(item interface{}) {\n \t\tm := item.(module.Version)\n-\t\trequired, err := reqs.Required(m)\n \n+\t\tnode := &modGraphNode{m: m}\n \t\tmu.Lock()\n-\t\tif err != nil && firstErr == nil {\n-\t\t\tfirstErr = err\n-\t\t}\n-\t\tif firstErr != nil {\n-\t\t\tmu.Unlock()\n-\t\t\treturn\n-\t\t}\n+\t\tmodGraph[m] = node\n \t\tif v, ok := min[m.Path]; !ok || reqs.Max(v, m.Version) != v {\n \t\t\tmin[m.Path] = m.Version\n \t\t}\n \t\tmu.Unlock()\n \n-\t\tfor _, r := range required {\n-\t\t\tif r.Path == \"\" {\n-\t\t\t\tbase.Errorf(\"Required(%v) returned zero module in list\", m)\n-\t\t\t\tcontinue\n-\t\t\t}\n+\t\trequired, err := reqs.Required(m)\n+\t\tif err != nil {\n+\t\t\tsetErr(node, err)\n+\t\t\treturn\n+\t\t}\n+\t\tnode.required = required\n+\t\tfor _, r := range node.required {\n \t\t\twork.Add(r)\n \t\t}\n \n \t\tif upgrade != nil {\n-\t\t\tu := upgrade(m)\n-\t\t\tif u.Path == \"\" {\n-\t\t\t\tbase.Errorf(\"Upgrade(%v) returned zero module\", m)\n+\t\t\tu, err := upgrade(m)\n+\t\t\tif err != nil {\n+\t\t\t\tsetErr(node, err)\n \t\t\t\treturn\n \t\t\t}\n-\t\t\twork.Add(u)\n+\t\t\tif u != m {\n+\t\t\t\tnode.upgrade = u\n+\t\t\t\twork.Add(u)\n+\t\t\t}\n \t\t}\n \t})\n \n-\tif firstErr != nil {\n-\t\treturn nil, firstErr\n+\t// If there was an error, find the shortest path from the target to the\n+\t// node where the error occurred so we can report a useful error message.\n+\tif haveErr != 0 {\n+\t\t// neededBy[a] = b means a was added to the module graph by b.\n+\t\tneededBy := make(map[*modGraphNode]*modGraphNode)\n+\t\tq := make([]*modGraphNode, 0, len(modGraph))\n+\t\tq = append(q, modGraph[target])\n+\t\tfor len(q) > 0 {\n+\t\t\tnode := q[0]\n+\t\t\tq = q[1:]\n+\n+\t\t\tif node.err != nil {\n+\t\t\t\terr := &BuildListError{\n+\t\t\t\t\tErr:   node.err,\n+\t\t\t\t\tstack: []buildListErrorElem{{m: node.m}},\n+\t\t\t\t}\n+\t\t\t\tfor n, prev := neededBy[node], node; n != nil; n, prev = neededBy[n], n {\n+\t\t\t\t\treason := \"requires\"\n+\t\t\t\t\tif n.upgrade == prev.m {\n+\t\t\t\t\t\treason = \"updating to\"\n+\t\t\t\t\t}\n+\t\t\t\t\terr.stack = append(err.stack, buildListErrorElem{m: n.m, nextReason: reason})\n+\t\t\t\t}\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tneighbors := node.required\n+\t\t\tif node.upgrade.Path != \"\" {\n+\t\t\t\tneighbors = append(neighbors, node.upgrade)\n+\t\t\t}\n+\t\t\tfor _, neighbor := range neighbors {\n+\t\t\t\tnn := modGraph[neighbor]\n+\t\t\t\tif neededBy[nn] != nil {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tneededBy[nn] = node\n+\t\t\t\tq = append(q, nn)\n+\t\t\t}\n+\t\t}\n \t}\n+\n+\t// Construct the list by traversing the graph again, replacing older\n+\t// modules with required minimum versions.\n \tif v := min[target.Path]; v != target.Version {\n+\t\t// TODO(jayconrod): there is a special case in modload.mvsReqs.Max\n+\t\t// that prevents us from selecting a newer version of a module\n+\t\t// when the module has no version. This may only be the case for target.\n+\t\t// Should we always panic when target has a version?\n+\t\t// See golang.org/issue/31491, golang.org/issue/29773.\n \t\tpanic(fmt.Sprintf(\"mistake: chose version %q instead of target %+v\", v, target)) // TODO: Don't panic.\n \t}\n \n \tlist := []module.Version{target}\n \tlisted := map[string]bool{target.Path: true}\n \tfor i := 0; i < len(list); i++ {\n-\t\tm := list[i]\n-\t\trequired, err := reqs.Required(m)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n+\t\tn := modGraph[list[i]]\n+\t\trequired := n.required\n \t\tfor _, r := range required {\n \t\t\tv := min[r.Path]\n \t\t\tif r.Path != target.Path && reqs.Max(v, r.Version) != v {\n@@ -237,17 +336,12 @@ func Req(target module.Version, list []module.Version, base []string, reqs Reqs)\n // UpgradeAll returns a build list for the target module\n // in which every module is upgraded to its latest version.\n func UpgradeAll(target module.Version, reqs Reqs) ([]module.Version, error) {\n-\treturn buildList(target, reqs, func(m module.Version) module.Version {\n+\treturn buildList(target, reqs, func(m module.Version) (module.Version, error) {\n \t\tif m.Path == target.Path {\n-\t\t\treturn target\n+\t\t\treturn target, nil\n \t\t}\n \n-\t\tlatest, err := reqs.Upgrade(m)\n-\t\tif err != nil {\n-\t\t\tpanic(err) // TODO\n-\t\t}\n-\t\tm.Version = latest.Version\n-\t\treturn m\n+\t\treturn reqs.Upgrade(m)\n \t})\n }\n \n@@ -256,7 +350,7 @@ func UpgradeAll(target module.Version, reqs Reqs) ([]module.Version, error) {\n func Upgrade(target module.Version, reqs Reqs, upgrade ...module.Version) ([]module.Version, error) {\n \tlist, err := reqs.Required(target)\n \tif err != nil {\n-\t\tpanic(err) // TODO\n+\t\treturn nil, err\n \t}\n \t// TODO: Maybe if an error is given,\n \t// rerun with BuildList(upgrade[0], reqs) etc\n@@ -275,7 +369,7 @@ func Upgrade(target module.Version, reqs Reqs, upgrade ...module.Version) ([]mod\n func Downgrade(target module.Version, reqs Reqs, downgrade ...module.Version) ([]module.Version, error) {\n \tlist, err := reqs.Required(target)\n \tif err != nil {\n-\t\tpanic(err) // TODO\n+\t\treturn nil, err\n \t}\n \tmax := make(map[string]string)\n \tfor _, r := range list {\n@@ -314,7 +408,17 @@ func Downgrade(target module.Version, reqs Reqs, downgrade ...module.Version) ([\n \t\t}\n \t\tlist, err := reqs.Required(m)\n \t\tif err != nil {\n-\t\t\tpanic(err) // TODO\n+\t\t\t// If we can't load the requirements, we couldn't load the go.mod file.\n+\t\t\t// There are a number of reasons this can happen, but this usually\n+\t\t\t// means an older version of the module had a missing or invalid\n+\t\t\t// go.mod file. For example, if example.com/mod released v2.0.0 before\n+\t\t\t// migrating to modules (v2.0.0+incompatible), then added a valid go.mod\n+\t\t\t// in v2.0.1, downgrading from v2.0.1 would cause this error.\n+\t\t\t//\n+\t\t\t// TODO(golang.org/issue/31730, golang.org/issue/30134): if the error\n+\t\t\t// is transient (we couldn't download go.mod), return the error from\n+\t\t\t// Downgrade. Currently, we can't tell what kind of error it is.\n+\t\t\texclude(m)\n \t\t}\n \t\tfor _, r := range list {\n \t\t\tadd(r)\n@@ -334,7 +438,12 @@ List:\n \t\tfor excluded[r] {\n \t\t\tp, err := reqs.Previous(r)\n \t\t\tif err != nil {\n-\t\t\t\treturn nil, err // TODO\n+\t\t\t\t// This is likely a transient error reaching the repository,\n+\t\t\t\t// rather than a permanent error with the retrieved version.\n+\t\t\t\t//\n+\t\t\t\t// TODO(golang.org/issue/31730, golang.org/issue/30134):\n+\t\t\t\t// decode what to do based on the actual error.\n+\t\t\t\treturn nil, err\n \t\t\t}\n \t\t\t// If the target version is a pseudo-version, it may not be\n \t\t\t// included when iterating over prior versions using reqs.Previous."}, {"sha": "cab4bb241bc701fcee70af4712e4285db2eef1e8", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,6 +5,7 @@\n package mvs\n \n import (\n+\t\"fmt\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -446,7 +447,7 @@ func (r reqsMap) Upgrade(m module.Version) (module.Version, error) {\n \t\t}\n \t}\n \tif u.Path == \"\" {\n-\t\treturn module.Version{}, &MissingModuleError{module.Version{Path: m.Path, Version: \"\"}}\n+\t\treturn module.Version{}, fmt.Errorf(\"missing module: %v\", module.Version{Path: m.Path})\n \t}\n \treturn u, nil\n }\n@@ -467,7 +468,7 @@ func (r reqsMap) Previous(m module.Version) (module.Version, error) {\n func (r reqsMap) Required(m module.Version) ([]module.Version, error) {\n \trr, ok := r[m]\n \tif !ok {\n-\t\treturn nil, &MissingModuleError{m}\n+\t\treturn nil, fmt.Errorf(\"missing module: %v\", m)\n \t}\n \treturn rr, nil\n }"}, {"sha": "53554b4c23fb041f2ee252412fb36df057214763", "filename": "libgo/go/cmd/go/internal/note/example_test.go", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fexample_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,128 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package note_test\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\n+\t\"cmd/go/internal/note\"\n+)\n+\n+func ExampleSign() {\n+\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n+\ttext := \"If you think cryptography is the answer to your problem,\\n\" +\n+\t\t\"then you don't know what your problem is.\\n\"\n+\n+\tsigner, err := note.NewSigner(skey)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\n+\tmsg, err := note.Sign(&note.Note{Text: text}, signer)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\tos.Stdout.Write(msg)\n+\n+\t// Output:\n+\t// If you think cryptography is the answer to your problem,\n+\t// then you don't know what your problem is.\n+\t//\n+\t// \u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n+}\n+\n+func ExampleOpen() {\n+\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n+\t\t\"then you don't know what your problem is.\\n\" +\n+\t\t\"\\n\" +\n+\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n+\n+\tverifier, err := note.NewVerifier(vkey)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\tverifiers := note.VerifierList(verifier)\n+\n+\tn, err := note.Open(msg, verifiers)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\tfmt.Printf(\"%s (%08x):\\n%s\", n.Sigs[0].Name, n.Sigs[0].Hash, n.Text)\n+\n+\t// Output:\n+\t// PeterNeumann (c74f20a3):\n+\t// If you think cryptography is the answer to your problem,\n+\t// then you don't know what your problem is.\n+}\n+\n+var rand = struct {\n+\tReader io.Reader\n+}{\n+\tzeroReader{},\n+}\n+\n+type zeroReader struct{}\n+\n+func (zeroReader) Read(buf []byte) (int, error) {\n+\tfor i := range buf {\n+\t\tbuf[i] = 0\n+\t}\n+\treturn len(buf), nil\n+}\n+\n+func ExampleSign_add_signatures() {\n+\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n+\t\t\"then you don't know what your problem is.\\n\" +\n+\t\t\"\\n\" +\n+\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n+\n+\tverifier, err := note.NewVerifier(vkey)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\tverifiers := note.VerifierList(verifier)\n+\n+\tn, err := note.Open([]byte(msg), verifiers)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\n+\tskey, vkey, err := note.GenerateKey(rand.Reader, \"EnochRoot\")\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\t_ = vkey // give to verifiers\n+\n+\tme, err := note.NewSigner(skey)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\n+\tmsg, err = note.Sign(n, me)\n+\tif err != nil {\n+\t\tfmt.Println(err)\n+\t\treturn\n+\t}\n+\tos.Stdout.Write(msg)\n+\n+\t// Output:\n+\t// If you think cryptography is the answer to your problem,\n+\t// then you don't know what your problem is.\n+\t//\n+\t// \u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n+\t// \u2014 EnochRoot rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\n+}"}, {"sha": "f770da24b3761aa66bbdd93c622a5e764b9a245d", "filename": "libgo/go/cmd/go/internal/note/note.go", "status": "added", "additions": 683, "deletions": 0, "changes": 683, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,683 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package note defines the notes signed by the Go module database server.\n+//\n+// This package is part of a DRAFT of what the Go module database server will look like.\n+// Do not assume the details here are final!\n+//\n+// A note is text signed by one or more server keys.\n+// The text should be ignored unless the note is signed by\n+// a trusted server key and the signature has been verified\n+// using the server's public key.\n+//\n+// A server's public key is identified by a name, typically the \"host[/path]\"\n+// giving the base URL of the server's transparency log.\n+// The syntactic restrictions on a name are that it be non-empty,\n+// well-formed UTF-8 containing neither Unicode spaces nor plus (U+002B).\n+//\n+// A Go module database server signs texts using public key cryptography.\n+// A given server may have multiple public keys, each\n+// identified by the first 32 bits of the SHA-256 hash of\n+// the concatenation of the server name, a newline, and\n+// the encoded public key.\n+//\n+// Verifying Notes\n+//\n+// A Verifier allows verification of signatures by one server public key.\n+// It can report the name of the server and the uint32 hash of the key,\n+// and it can verify a purported signature by that key.\n+//\n+// The standard implementation of a Verifier is constructed\n+// by NewVerifier starting from a verifier key, which is a\n+// plain text string of the form \"<name>+<hash>+<keydata>\".\n+//\n+// A Verifiers allows looking up a Verifier by the combination\n+// of server name and key hash.\n+//\n+// The standard implementation of a Verifiers is constructed\n+// by VerifierList from a list of known verifiers.\n+//\n+// A Note represents a text with one or more signatures.\n+// An implementation can reject a note with too many signatures\n+// (for example, more than 100 signatures).\n+//\n+// A Signature represents a signature on a note, verified or not.\n+//\n+// The Open function takes as input a signed message\n+// and a set of known verifiers. It decodes and verifies\n+// the message signatures and returns a Note structure\n+// containing the message text and (verified or unverified) signatures.\n+//\n+// Signing Notes\n+//\n+// A Signer allows signing a text with a given key.\n+// It can report the name of the server and the hash of the key\n+// and can sign a raw text using that key.\n+//\n+// The standard implementation of a Signer is constructed\n+// by NewSigner starting from an encoded signer key, which is a\n+// plain text string of the form \"PRIVATE+KEY+<name>+<hash>+<keydata>\".\n+// Anyone with an encoded signer key can sign messages using that key,\n+// so it must be kept secret. The encoding begins with the literal text\n+// \"PRIVATE+KEY\" to avoid confusion with the public server key.\n+//\n+// The Sign function takes as input a Note and a list of Signers\n+// and returns an encoded, signed message.\n+//\n+// Signed Note Format\n+//\n+// A signed note consists of a text ending in newline (U+000A),\n+// followed by a blank line (only a newline),\n+// followed by one or more signature lines of this form:\n+// em dash (U+2014), space (U+0020),\n+// server name, space, base64-encoded signature, newline.\n+//\n+// Signed notes must be valid UTF-8 and must not contain any\n+// ASCII control characters (those below U+0020) other than newline.\n+//\n+// A signature is a base64 encoding of 4+n bytes.\n+//\n+// The first four bytes in the signature are the uint32 key hash\n+// stored in big-endian order, which is to say they are the first\n+// four bytes of the truncated SHA-256 used to derive the key hash\n+// in the first place.\n+//\n+// The remaining n bytes are the result of using the specified key\n+// to sign the note text (including the final newline but not the\n+// separating blank line).\n+//\n+// Generating Keys\n+//\n+// There is only one key type, Ed25519 with algorithm identifier 1.\n+// New key types may be introduced in the future as needed,\n+// although doing so will require deploying the new algorithms to all clients\n+// before starting to depend on them for signatures.\n+//\n+// The GenerateKey function generates and returns a new signer\n+// and corresponding verifier.\n+//\n+// Example\n+//\n+// Here is a well-formed signed note:\n+//\n+//\tIf you think cryptography is the answer to your problem,\n+//\tthen you don't know what your problem is.\n+//\n+//\t\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n+//\n+// It can be constructed and displayed using:\n+//\n+//\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n+//\ttext := \"If you think cryptography is the answer to your problem,\\n\" +\n+//\t\t\"then you don't know what your problem is.\\n\"\n+//\n+//\tsigner, err := note.NewSigner(skey)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\n+//\tmsg, err := note.Sign(&note.Note{Text: text}, signer)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\tos.Stdout.Write(msg)\n+//\n+// The note's text is two lines, including the final newline,\n+// and the text is purportedly signed by a server named\n+// \"PeterNeumann\". (Although server names are canonically\n+// base URLs, the only syntactic requirement is that they\n+// not contain spaces or newlines).\n+//\n+// If Open is given access to a Verifiers including the\n+// Verifier for this key, then it will succeed at verifiying\n+// the encoded message and returning the parsed Note:\n+//\n+//\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+//\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n+//\t\t\"then you don't know what your problem is.\\n\" +\n+//\t\t\"\\n\" +\n+//\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n+//\n+//\tverifier, err := note.NewVerifier(vkey)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\tverifiers := note.VerifierList(verifier)\n+//\n+//\tn, err := note.Open([]byte(msg), verifiers)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\tfmt.Printf(\"%s (%08x):\\n%s\", n.Sigs[0].Name, n.Sigs[0].Hash, n.Text)\n+//\n+// You can add your own signature to this message by re-signing the note:\n+//\n+//\tskey, vkey, err := note.GenerateKey(rand.Reader, \"EnochRoot\")\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\t_ = vkey // give to verifiers\n+//\n+//\tme, err := note.NewSigner(skey)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\n+//\tmsg, err := note.Sign(n, me)\n+//\tif err != nil {\n+//\t\tlog.Fatal(err)\n+//\t}\n+//\tos.Stdout.Write(msg)\n+//\n+// This will print a doubly-signed message, like:\n+//\n+//\tIf you think cryptography is the answer to your problem,\n+//\tthen you don't know what your problem is.\n+//\n+//\t\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n+//\t\u2014 EnochRoot rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\n+//\n+package note\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/ed25519\"\n+\t\"crypto/sha256\"\n+\t\"encoding/base64\"\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n+)\n+\n+// A Verifier verifies messages signed with a specific key.\n+type Verifier interface {\n+\t// Name returns the server name associated with the key.\n+\tName() string\n+\n+\t// KeyHash returns the key hash.\n+\tKeyHash() uint32\n+\n+\t// Verify reports whether sig is a valid signature of msg.\n+\tVerify(msg, sig []byte) bool\n+}\n+\n+// A Signer signs messages using a specific key.\n+type Signer interface {\n+\t// Name returns the server name associated with the key.\n+\tName() string\n+\n+\t// KeyHash returns the key hash.\n+\tKeyHash() uint32\n+\n+\t// Sign returns a signature for the given message.\n+\tSign(msg []byte) ([]byte, error)\n+}\n+\n+// keyHash computes the key hash for the given server name and encoded public key.\n+func keyHash(name string, key []byte) uint32 {\n+\th := sha256.New()\n+\th.Write([]byte(name))\n+\th.Write([]byte(\"\\n\"))\n+\th.Write(key)\n+\tsum := h.Sum(nil)\n+\treturn binary.BigEndian.Uint32(sum)\n+}\n+\n+var (\n+\terrVerifierID   = errors.New(\"malformed verifier id\")\n+\terrVerifierAlg  = errors.New(\"unknown verifier algorithm\")\n+\terrVerifierHash = errors.New(\"invalid verifier hash\")\n+)\n+\n+const (\n+\talgEd25519 = 1\n+)\n+\n+// isValidName reports whether name is valid.\n+// It must be non-empty and not have any Unicode spaces or pluses.\n+func isValidName(name string) bool {\n+\treturn name != \"\" && utf8.ValidString(name) && strings.IndexFunc(name, unicode.IsSpace) < 0 && !strings.Contains(name, \"+\")\n+}\n+\n+// NewVerifier construct a new Verifier from an encoded verifier key.\n+func NewVerifier(vkey string) (Verifier, error) {\n+\tname, vkey := chop(vkey, \"+\")\n+\thash16, key64 := chop(vkey, \"+\")\n+\thash, err1 := strconv.ParseUint(hash16, 16, 32)\n+\tkey, err2 := base64.StdEncoding.DecodeString(key64)\n+\tif len(hash16) != 8 || err1 != nil || err2 != nil || !isValidName(name) || len(key) == 0 {\n+\t\treturn nil, errVerifierID\n+\t}\n+\tif uint32(hash) != keyHash(name, key) {\n+\t\treturn nil, errVerifierHash\n+\t}\n+\n+\tv := &verifier{\n+\t\tname: name,\n+\t\thash: uint32(hash),\n+\t}\n+\n+\talg, key := key[0], key[1:]\n+\tswitch alg {\n+\tdefault:\n+\t\treturn nil, errVerifierAlg\n+\n+\tcase algEd25519:\n+\t\tif len(key) != 32 {\n+\t\t\treturn nil, errVerifierID\n+\t\t}\n+\t\tv.verify = func(msg, sig []byte) bool {\n+\t\t\treturn ed25519.Verify(key, msg, sig)\n+\t\t}\n+\t}\n+\n+\treturn v, nil\n+}\n+\n+// chop chops s at the first instance of sep, if any,\n+// and returns the text before and after sep.\n+// If sep is not present, chop returns before is s and after is empty.\n+func chop(s, sep string) (before, after string) {\n+\ti := strings.Index(s, sep)\n+\tif i < 0 {\n+\t\treturn s, \"\"\n+\t}\n+\treturn s[:i], s[i+len(sep):]\n+}\n+\n+// verifier is a trivial Verifier implementation.\n+type verifier struct {\n+\tname   string\n+\thash   uint32\n+\tverify func([]byte, []byte) bool\n+}\n+\n+func (v *verifier) Name() string                { return v.name }\n+func (v *verifier) KeyHash() uint32             { return v.hash }\n+func (v *verifier) Verify(msg, sig []byte) bool { return v.verify(msg, sig) }\n+\n+// NewSigner constructs a new Signer from an encoded signer key.\n+func NewSigner(skey string) (Signer, error) {\n+\tpriv1, skey := chop(skey, \"+\")\n+\tpriv2, skey := chop(skey, \"+\")\n+\tname, skey := chop(skey, \"+\")\n+\thash16, key64 := chop(skey, \"+\")\n+\thash, err1 := strconv.ParseUint(hash16, 16, 32)\n+\tkey, err2 := base64.StdEncoding.DecodeString(key64)\n+\tif priv1 != \"PRIVATE\" || priv2 != \"KEY\" || len(hash16) != 8 || err1 != nil || err2 != nil || !isValidName(name) || len(key) == 0 {\n+\t\treturn nil, errSignerID\n+\t}\n+\n+\t// Note: hash is the hash of the public key and we have the private key.\n+\t// Must verify hash after deriving public key.\n+\n+\ts := &signer{\n+\t\tname: name,\n+\t\thash: uint32(hash),\n+\t}\n+\n+\tvar pubkey []byte\n+\n+\talg, key := key[0], key[1:]\n+\tswitch alg {\n+\tdefault:\n+\t\treturn nil, errSignerAlg\n+\n+\tcase algEd25519:\n+\t\tif len(key) != 32 {\n+\t\t\treturn nil, errSignerID\n+\t\t}\n+\t\tkey = ed25519.NewKeyFromSeed(key)\n+\t\tpubkey = append([]byte{algEd25519}, key[32:]...)\n+\t\ts.sign = func(msg []byte) ([]byte, error) {\n+\t\t\treturn ed25519.Sign(key, msg), nil\n+\t\t}\n+\t}\n+\n+\tif uint32(hash) != keyHash(name, pubkey) {\n+\t\treturn nil, errSignerHash\n+\t}\n+\n+\treturn s, nil\n+}\n+\n+var (\n+\terrSignerID   = errors.New(\"malformed verifier id\")\n+\terrSignerAlg  = errors.New(\"unknown verifier algorithm\")\n+\terrSignerHash = errors.New(\"invalid verifier hash\")\n+)\n+\n+// signer is a trivial Signer implementation.\n+type signer struct {\n+\tname string\n+\thash uint32\n+\tsign func([]byte) ([]byte, error)\n+}\n+\n+func (s *signer) Name() string                    { return s.name }\n+func (s *signer) KeyHash() uint32                 { return s.hash }\n+func (s *signer) Sign(msg []byte) ([]byte, error) { return s.sign(msg) }\n+\n+// GenerateKey generates a signer and verifier key pair for a named server.\n+// The signer key skey is private and must be kept secret.\n+func GenerateKey(rand io.Reader, name string) (skey, vkey string, err error) {\n+\tpub, priv, err := ed25519.GenerateKey(rand)\n+\tif err != nil {\n+\t\treturn \"\", \"\", err\n+\t}\n+\tpubkey := append([]byte{algEd25519}, pub...)\n+\tprivkey := append([]byte{algEd25519}, priv.Seed()...)\n+\th := keyHash(name, pubkey)\n+\n+\tskey = fmt.Sprintf(\"PRIVATE+KEY+%s+%08x+%s\", name, h, base64.StdEncoding.EncodeToString(privkey))\n+\tvkey = fmt.Sprintf(\"%s+%08x+%s\", name, h, base64.StdEncoding.EncodeToString(pubkey))\n+\treturn skey, vkey, nil\n+}\n+\n+// NewEd25519VerifierKey returns an encoded verifier key using the given name\n+// and Ed25519 public key.\n+func NewEd25519VerifierKey(name string, key ed25519.PublicKey) (string, error) {\n+\tif len(key) != ed25519.PublicKeySize {\n+\t\treturn \"\", fmt.Errorf(\"invalid public key size %d, expected %d\", len(key), ed25519.PublicKeySize)\n+\t}\n+\n+\tpubkey := append([]byte{algEd25519}, key...)\n+\thash := keyHash(name, pubkey)\n+\n+\tb64Key := base64.StdEncoding.EncodeToString(pubkey)\n+\treturn fmt.Sprintf(\"%s+%08x+%s\", name, hash, b64Key), nil\n+}\n+\n+// A Verifiers is a collection of known verifier keys.\n+type Verifiers interface {\n+\t// Verifier returns the Verifier associated with the key\n+\t// identified by the name and hash.\n+\t// If the name, hash pair is unknown, Verifier should return\n+\t// an UnknownVerifierError.\n+\tVerifier(name string, hash uint32) (Verifier, error)\n+}\n+\n+// An UnknownVerifierError indicates that the given key is not known.\n+// The Open function records signatures without associated verifiers as\n+// unverified signatures.\n+type UnknownVerifierError struct {\n+\tName    string\n+\tKeyHash uint32\n+}\n+\n+func (e *UnknownVerifierError) Error() string {\n+\treturn fmt.Sprintf(\"unknown key %s+%08x\", e.Name, e.KeyHash)\n+}\n+\n+// An ambiguousVerifierError indicates that the given name and hash\n+// match multiple keys passed to VerifierList.\n+// (If this happens, some malicious actor has taken control of the\n+// verifier list, at which point we may as well give up entirely,\n+// but we diagnose the problem instead.)\n+type ambiguousVerifierError struct {\n+\tname string\n+\thash uint32\n+}\n+\n+func (e *ambiguousVerifierError) Error() string {\n+\treturn fmt.Sprintf(\"ambiguous key %s+%08x\", e.name, e.hash)\n+}\n+\n+// VerifierList returns a Verifiers implementation that uses the given list of verifiers.\n+func VerifierList(list ...Verifier) Verifiers {\n+\tm := make(verifierMap)\n+\tfor _, v := range list {\n+\t\tk := nameHash{v.Name(), v.KeyHash()}\n+\t\tm[k] = append(m[k], v)\n+\t}\n+\treturn m\n+}\n+\n+type nameHash struct {\n+\tname string\n+\thash uint32\n+}\n+\n+type verifierMap map[nameHash][]Verifier\n+\n+func (m verifierMap) Verifier(name string, hash uint32) (Verifier, error) {\n+\tv, ok := m[nameHash{name, hash}]\n+\tif !ok {\n+\t\treturn nil, &UnknownVerifierError{name, hash}\n+\t}\n+\tif len(v) > 1 {\n+\t\treturn nil, &ambiguousVerifierError{name, hash}\n+\t}\n+\treturn v[0], nil\n+}\n+\n+// A Note is a text and signatures.\n+type Note struct {\n+\tText           string      // text of note\n+\tSigs           []Signature // verified signatures\n+\tUnverifiedSigs []Signature // unverified signatures\n+}\n+\n+// A Signature is a single signature found in a note.\n+type Signature struct {\n+\t// Name and Hash give the name and key hash\n+\t// for the key that generated the signature.\n+\tName string\n+\tHash uint32\n+\n+\t// Base64 records the base64-encoded signature bytes.\n+\tBase64 string\n+}\n+\n+// An UnverifiedNoteError indicates that the note\n+// successfully parsed but had no verifiable signatures.\n+type UnverifiedNoteError struct {\n+\tNote *Note\n+}\n+\n+func (e *UnverifiedNoteError) Error() string {\n+\treturn \"note has no verifiable signatures\"\n+}\n+\n+// An InvalidSignatureError indicates that the given key was known\n+// and the associated Verifier rejected the signature.\n+type InvalidSignatureError struct {\n+\tName string\n+\tHash uint32\n+}\n+\n+func (e *InvalidSignatureError) Error() string {\n+\treturn fmt.Sprintf(\"invalid signature for key %s+%08x\", e.Name, e.Hash)\n+}\n+\n+var (\n+\terrMalformedNote = errors.New(\"malformed note\")\n+\terrInvalidSigner = errors.New(\"invalid signer\")\n+\n+\tsigSplit  = []byte(\"\\n\\n\")\n+\tsigPrefix = []byte(\"\u2014 \")\n+)\n+\n+// Open opens and parses the message msg, checking signatures from the known verifiers.\n+//\n+// For each signature in the message, Open calls known.Verifier to find a verifier.\n+// If known.Verifier returns a verifier and the verifier accepts the signature,\n+// Open records the signature in the returned note's Sigs field.\n+// If known.Verifier returns a verifier but the verifier rejects the signature,\n+// Open returns an InvalidSignatureError.\n+// If known.Verifier returns an UnknownVerifierError,\n+// Open records the signature in the returned note's UnverifiedSigs field.\n+// If known.Verifier returns any other error, Open returns that error.\n+//\n+// If no known verifier has signed an otherwise valid note,\n+// Open returns an UnverifiedNoteError.\n+// In this case, the unverified note can be fetched from inside the error.\n+func Open(msg []byte, known Verifiers) (*Note, error) {\n+\tif known == nil {\n+\t\t// Treat nil Verifiers as empty list, to produce useful error instead of crash.\n+\t\tknown = VerifierList()\n+\t}\n+\n+\t// Must have valid UTF-8 with no non-newline ASCII control characters.\n+\tfor i := 0; i < len(msg); {\n+\t\tr, size := utf8.DecodeRune(msg[i:])\n+\t\tif r < 0x20 && r != '\\n' || r == utf8.RuneError && size == 1 {\n+\t\t\treturn nil, errMalformedNote\n+\t\t}\n+\t\ti += size\n+\t}\n+\n+\t// Must end with signature block preceded by blank line.\n+\tsplit := bytes.LastIndex(msg, sigSplit)\n+\tif split < 0 {\n+\t\treturn nil, errMalformedNote\n+\t}\n+\ttext, sigs := msg[:split+1], msg[split+2:]\n+\tif len(sigs) == 0 || sigs[len(sigs)-1] != '\\n' {\n+\t\treturn nil, errMalformedNote\n+\t}\n+\n+\tn := &Note{\n+\t\tText: string(text),\n+\t}\n+\n+\tvar buf bytes.Buffer\n+\tbuf.Write(text)\n+\n+\t// Parse and verify signatures.\n+\t// Ignore duplicate signatures.\n+\tseen := make(map[nameHash]bool)\n+\tseenUnverified := make(map[string]bool)\n+\tnumSig := 0\n+\tfor len(sigs) > 0 {\n+\t\t// Pull out next signature line.\n+\t\t// We know sigs[len(sigs)-1] == '\\n', so IndexByte always finds one.\n+\t\ti := bytes.IndexByte(sigs, '\\n')\n+\t\tline := sigs[:i]\n+\t\tsigs = sigs[i+1:]\n+\n+\t\tif !bytes.HasPrefix(line, sigPrefix) {\n+\t\t\treturn nil, errMalformedNote\n+\t\t}\n+\t\tline = line[len(sigPrefix):]\n+\t\tname, b64 := chop(string(line), \" \")\n+\t\tsig, err := base64.StdEncoding.DecodeString(b64)\n+\t\tif err != nil || !isValidName(name) || b64 == \"\" || len(sig) < 5 {\n+\t\t\treturn nil, errMalformedNote\n+\t\t}\n+\t\thash := binary.BigEndian.Uint32(sig[0:4])\n+\t\tsig = sig[4:]\n+\n+\t\tif numSig++; numSig > 100 {\n+\t\t\t// Avoid spending forever parsing a note with many signatures.\n+\t\t\treturn nil, errMalformedNote\n+\t\t}\n+\n+\t\tv, err := known.Verifier(name, hash)\n+\t\tif _, ok := err.(*UnknownVerifierError); ok {\n+\t\t\t// Drop repeated identical unverified signatures.\n+\t\t\tif seenUnverified[string(line)] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tseenUnverified[string(line)] = true\n+\t\t\tn.UnverifiedSigs = append(n.UnverifiedSigs, Signature{Name: name, Hash: hash, Base64: b64})\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\t// Drop repeated signatures by a single verifier.\n+\t\tif seen[nameHash{name, hash}] {\n+\t\t\tcontinue\n+\t\t}\n+\t\tseen[nameHash{name, hash}] = true\n+\n+\t\tok := v.Verify(text, sig)\n+\t\tif !ok {\n+\t\t\treturn nil, &InvalidSignatureError{name, hash}\n+\t\t}\n+\n+\t\tn.Sigs = append(n.Sigs, Signature{Name: name, Hash: hash, Base64: b64})\n+\t}\n+\n+\t// Parsed and verified all the signatures.\n+\tif len(n.Sigs) == 0 {\n+\t\treturn nil, &UnverifiedNoteError{n}\n+\t}\n+\treturn n, nil\n+}\n+\n+// Sign signs the note with the given signers and returns the encoded message.\n+// The new signatures from signers are listed in the encoded message after\n+// the existing signatures already present in n.Sigs.\n+// If any signer uses the same key as an existing signature,\n+// the existing signature is elided from the output.\n+func Sign(n *Note, signers ...Signer) ([]byte, error) {\n+\tvar buf bytes.Buffer\n+\tif !strings.HasSuffix(n.Text, \"\\n\") {\n+\t\treturn nil, errMalformedNote\n+\t}\n+\tbuf.WriteString(n.Text)\n+\n+\t// Prepare signatures.\n+\tvar sigs bytes.Buffer\n+\thave := make(map[nameHash]bool)\n+\tfor _, s := range signers {\n+\t\tname := s.Name()\n+\t\thash := s.KeyHash()\n+\t\thave[nameHash{name, hash}] = true\n+\t\tif !isValidName(name) {\n+\t\t\treturn nil, errInvalidSigner\n+\t\t}\n+\n+\t\tsig, err := s.Sign(buf.Bytes()) // buf holds n.Text\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tvar hbuf [4]byte\n+\t\tbinary.BigEndian.PutUint32(hbuf[:], hash)\n+\t\tb64 := base64.StdEncoding.EncodeToString(append(hbuf[:], sig...))\n+\t\tsigs.WriteString(\"\u2014 \")\n+\t\tsigs.WriteString(name)\n+\t\tsigs.WriteString(\" \")\n+\t\tsigs.WriteString(b64)\n+\t\tsigs.WriteString(\"\\n\")\n+\t}\n+\n+\tbuf.WriteString(\"\\n\")\n+\n+\t// Emit existing signatures not replaced by new ones.\n+\tfor _, list := range [][]Signature{n.Sigs, n.UnverifiedSigs} {\n+\t\tfor _, sig := range list {\n+\t\t\tname, hash := sig.Name, sig.Hash\n+\t\t\tif !isValidName(name) {\n+\t\t\t\treturn nil, errMalformedNote\n+\t\t\t}\n+\t\t\tif have[nameHash{name, hash}] {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// Double-check hash against base64.\n+\t\t\traw, err := base64.StdEncoding.DecodeString(sig.Base64)\n+\t\t\tif err != nil || len(raw) < 4 || binary.BigEndian.Uint32(raw) != hash {\n+\t\t\t\treturn nil, errMalformedNote\n+\t\t\t}\n+\t\t\tbuf.WriteString(\"\u2014 \")\n+\t\t\tbuf.WriteString(sig.Name)\n+\t\t\tbuf.WriteString(\" \")\n+\t\t\tbuf.WriteString(sig.Base64)\n+\t\t\tbuf.WriteString(\"\\n\")\n+\t\t}\n+\t}\n+\tbuf.Write(sigs.Bytes())\n+\n+\treturn buf.Bytes(), nil\n+}"}, {"sha": "729324647e747680e9eff985e4278f793d7c7633", "filename": "libgo/go/cmd/go/internal/note/note_test.go", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,472 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package note\n+\n+import (\n+\t\"crypto/ed25519\"\n+\t\"crypto/rand\"\n+\t\"errors\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"testing/iotest\"\n+)\n+\n+func TestNewVerifier(t *testing.T) {\n+\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+\t_, err := NewVerifier(vkey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Check various manglings are not accepted.\n+\tbadKey := func(k string) {\n+\t\t_, err := NewVerifier(k)\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"NewVerifier(%q) succeeded, should have failed\", k)\n+\t\t}\n+\t}\n+\n+\tb := []byte(vkey)\n+\tfor i := 0; i <= len(b); i++ {\n+\t\tfor j := i + 1; j <= len(b); j++ {\n+\t\t\tif i != 0 || j != len(b) {\n+\t\t\t\tbadKey(string(b[i:j]))\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor i := 0; i < len(b); i++ {\n+\t\tb[i]++\n+\t\tbadKey(string(b))\n+\t\tb[i]--\n+\t}\n+\n+\tbadKey(\"PeterNeumann+cc469956+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TWBADKEY==\") // wrong length key, with adjusted key hash\n+\tbadKey(\"PeterNeumann+173116ae+ZRpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\")         // unknown algorithm, with adjusted key hash\n+}\n+\n+func TestNewSigner(t *testing.T) {\n+\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n+\t_, err := NewSigner(skey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Check various manglings are not accepted.\n+\tb := []byte(skey)\n+\tfor i := 0; i <= len(b); i++ {\n+\t\tfor j := i + 1; j <= len(b); j++ {\n+\t\t\tif i == 0 && j == len(b) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t_, err := NewSigner(string(b[i:j]))\n+\t\t\tif err == nil {\n+\t\t\t\tt.Errorf(\"NewSigner(%q) succeeded, should have failed\", b[i:j])\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor i := 0; i < len(b); i++ {\n+\t\tb[i]++\n+\t\t_, err := NewSigner(string(b))\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"NewSigner(%q) succeeded, should have failed\", b)\n+\t\t}\n+\t\tb[i]--\n+\t}\n+}\n+\n+func testSignerAndVerifier(t *testing.T, Name string, signer Signer, verifier Verifier) {\n+\tif name := signer.Name(); name != Name {\n+\t\tt.Errorf(\"signer.Name() = %q, want %q\", name, Name)\n+\t}\n+\tif name := verifier.Name(); name != Name {\n+\t\tt.Errorf(\"verifier.Name() = %q, want %q\", name, Name)\n+\t}\n+\tshash := signer.KeyHash()\n+\tvhash := verifier.KeyHash()\n+\tif shash != vhash {\n+\t\tt.Errorf(\"signer.KeyHash() = %#08x != verifier.KeyHash() = %#08x\", shash, vhash)\n+\t}\n+\n+\tmsg := []byte(\"hi\")\n+\tsig, err := signer.Sign(msg)\n+\tif err != nil {\n+\t\tt.Fatalf(\"signer.Sign: %v\", err)\n+\t}\n+\tif !verifier.Verify(msg, sig) {\n+\t\tt.Fatalf(\"verifier.Verify failed on signature returned by signer.Sign\")\n+\t}\n+\tsig[0]++\n+\tif verifier.Verify(msg, sig) {\n+\t\tt.Fatalf(\"verifier.Verify succceeded on corrupt signature\")\n+\t}\n+\tsig[0]--\n+\tmsg[0]++\n+\tif verifier.Verify(msg, sig) {\n+\t\tt.Fatalf(\"verifier.Verify succceeded on corrupt message\")\n+\t}\n+}\n+\n+func TestGenerateKey(t *testing.T) {\n+\t// Generate key pair, make sure it is all self-consistent.\n+\tconst Name = \"EnochRoot\"\n+\n+\tskey, vkey, err := GenerateKey(rand.Reader, Name)\n+\tif err != nil {\n+\t\tt.Fatalf(\"GenerateKey: %v\", err)\n+\t}\n+\tsigner, err := NewSigner(skey)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewSigner: %v\", err)\n+\t}\n+\tverifier, err := NewVerifier(vkey)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewVerifier: %v\", err)\n+\t}\n+\n+\ttestSignerAndVerifier(t, Name, signer, verifier)\n+\n+\t// Check that GenerateKey returns error from rand reader.\n+\t_, _, err = GenerateKey(iotest.TimeoutReader(iotest.OneByteReader(rand.Reader)), Name)\n+\tif err == nil {\n+\t\tt.Fatalf(\"GenerateKey succeeded with error-returning rand reader\")\n+\t}\n+}\n+\n+func TestFromEd25519(t *testing.T) {\n+\tconst Name = \"EnochRoot\"\n+\n+\tpub, priv, err := ed25519.GenerateKey(rand.Reader)\n+\tif err != nil {\n+\t\tt.Fatalf(\"GenerateKey: %v\", err)\n+\t}\n+\tsigner, err := newSignerFromEd25519Seed(Name, priv.Seed())\n+\tif err != nil {\n+\t\tt.Fatalf(\"newSignerFromEd25519Seed: %v\", err)\n+\t}\n+\tvkey, err := NewEd25519VerifierKey(Name, pub)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewEd25519VerifierKey: %v\", err)\n+\t}\n+\tverifier, err := NewVerifier(vkey)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewVerifier: %v\", err)\n+\t}\n+\n+\ttestSignerAndVerifier(t, Name, signer, verifier)\n+\n+\t// Check that wrong key sizes return errors.\n+\t_, err = NewEd25519VerifierKey(Name, pub[:len(pub)-1])\n+\tif err == nil {\n+\t\tt.Errorf(\"NewEd25519VerifierKey succeeded with a seed of the wrong size\")\n+\t}\n+}\n+\n+// newSignerFromEd25519Seed constructs a new signer from a verifier name and a\n+// crypto/ed25519 private key seed.\n+func newSignerFromEd25519Seed(name string, seed []byte) (Signer, error) {\n+\tif len(seed) != ed25519.SeedSize {\n+\t\treturn nil, errors.New(\"invalid seed size\")\n+\t}\n+\tpriv := ed25519.NewKeyFromSeed(seed)\n+\tpub := priv[32:]\n+\n+\tpubkey := append([]byte{algEd25519}, pub...)\n+\thash := keyHash(name, pubkey)\n+\n+\ts := &signer{\n+\t\tname: name,\n+\t\thash: uint32(hash),\n+\t\tsign: func(msg []byte) ([]byte, error) {\n+\t\t\treturn ed25519.Sign(priv, msg), nil\n+\t\t},\n+\t}\n+\treturn s, nil\n+}\n+\n+func TestSign(t *testing.T) {\n+\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n+\ttext := \"If you think cryptography is the answer to your problem,\\n\" +\n+\t\t\"then you don't know what your problem is.\\n\"\n+\n+\tsigner, err := NewSigner(skey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tmsg, err := Sign(&Note{Text: text}, signer)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\twant := `If you think cryptography is the answer to your problem,\n+then you don't know what your problem is.\n+\n+\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n+`\n+\tif string(msg) != want {\n+\t\tt.Errorf(\"Sign: wrong output\\nhave:\\n%s\\nwant:\\n%s\", msg, want)\n+\t}\n+\n+\t// Check that existing signature is replaced by new one.\n+\tmsg, err = Sign(&Note{Text: text, Sigs: []Signature{{Name: \"PeterNeumann\", Hash: 0xc74f20a3, Base64: \"BADSIGN=\"}}}, signer)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif string(msg) != want {\n+\t\tt.Errorf(\"Sign replacing signature: wrong output\\nhave:\\n%s\\nwant:\\n%s\", msg, want)\n+\t}\n+\n+\t// Check various bad inputs.\n+\t_, err = Sign(&Note{Text: \"abc\"}, signer)\n+\tif err == nil || err.Error() != \"malformed note\" {\n+\t\tt.Fatalf(\"Sign with short text: %v, want malformed note error\", err)\n+\t}\n+\n+\t_, err = Sign(&Note{Text: text, Sigs: []Signature{{Name: \"a+b\", Base64: \"ABCD\"}}})\n+\tif err == nil || err.Error() != \"malformed note\" {\n+\t\tt.Fatalf(\"Sign with bad name: %v, want malformed note error\", err)\n+\t}\n+\n+\t_, err = Sign(&Note{Text: text, Sigs: []Signature{{Name: \"PeterNeumann\", Hash: 0xc74f20a3, Base64: \"BADHASH=\"}}})\n+\tif err == nil || err.Error() != \"malformed note\" {\n+\t\tt.Fatalf(\"Sign with bad pre-filled signature: %v, want malformed note error\", err)\n+\t}\n+\n+\t_, err = Sign(&Note{Text: text}, &badSigner{signer})\n+\tif err == nil || err.Error() != \"invalid signer\" {\n+\t\tt.Fatalf(\"Sign with bad signer: %v, want invalid signer error\", err)\n+\t}\n+\n+\t_, err = Sign(&Note{Text: text}, &errSigner{signer})\n+\tif err != errSurprise {\n+\t\tt.Fatalf(\"Sign with failing signer: %v, want errSurprise\", err)\n+\t}\n+}\n+\n+func TestVerifierList(t *testing.T) {\n+\tpeterKey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+\tpeterVerifier, err := NewVerifier(peterKey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tenochKey := \"EnochRoot+af0cfe78+ATtqJ7zOtqQtYqOo0CpvDXNlMhV3HeJDpjrASKGLWdop\"\n+\tenochVerifier, err := NewVerifier(enochKey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tlist := VerifierList(peterVerifier, enochVerifier, enochVerifier)\n+\tv, err := list.Verifier(\"PeterNeumann\", 0xc74f20a3)\n+\tif v != peterVerifier || err != nil {\n+\t\tt.Fatalf(\"list.Verifier(peter) = %v, %v, want %v, nil\", v, err, peterVerifier)\n+\t}\n+\tv, err = list.Verifier(\"PeterNeumann\", 0xc74f20a4)\n+\tif v != nil || err == nil || err.Error() != \"unknown key PeterNeumann+c74f20a4\" {\n+\t\tt.Fatalf(\"list.Verifier(peter bad hash) = %v, %v, want nil, unknown key error\", v, err)\n+\t}\n+\n+\tv, err = list.Verifier(\"PeterNeuman\", 0xc74f20a3)\n+\tif v != nil || err == nil || err.Error() != \"unknown key PeterNeuman+c74f20a3\" {\n+\t\tt.Fatalf(\"list.Verifier(peter bad name) = %v, %v, want nil, unknown key error\", v, err)\n+\t}\n+\tv, err = list.Verifier(\"EnochRoot\", 0xaf0cfe78)\n+\tif v != nil || err == nil || err.Error() != \"ambiguous key EnochRoot+af0cfe78\" {\n+\t\tt.Fatalf(\"list.Verifier(enoch) = %v, %v, want nil, ambiguous key error\", v, err)\n+\t}\n+}\n+\n+type badSigner struct {\n+\tSigner\n+}\n+\n+func (b *badSigner) Name() string {\n+\treturn \"bad name\"\n+}\n+\n+var errSurprise = errors.New(\"surprise!\")\n+\n+type errSigner struct {\n+\tSigner\n+}\n+\n+func (e *errSigner) Sign([]byte) ([]byte, error) {\n+\treturn nil, errSurprise\n+}\n+\n+func TestOpen(t *testing.T) {\n+\tpeterKey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+\tpeterVerifier, err := NewVerifier(peterKey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tenochKey := \"EnochRoot+af0cfe78+ATtqJ7zOtqQtYqOo0CpvDXNlMhV3HeJDpjrASKGLWdop\"\n+\tenochVerifier, err := NewVerifier(enochKey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\ttext := `If you think cryptography is the answer to your problem,\n+then you don't know what your problem is.\n+`\n+\tpeterSig := \"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\"\n+\tenochSig := \"\u2014 EnochRoot rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\\n\"\n+\n+\tpeter := Signature{\"PeterNeumann\", 0xc74f20a3, \"x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\"}\n+\tenoch := Signature{\"EnochRoot\", 0xaf0cfe78, \"rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\"}\n+\n+\t// Check one signature verified, one not.\n+\tn, err := Open([]byte(text+\"\\n\"+peterSig+enochSig), VerifierList(peterVerifier))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif n.Text != text {\n+\t\tt.Errorf(\"n.Text = %q, want %q\", n.Text, text)\n+\t}\n+\tif len(n.Sigs) != 1 || n.Sigs[0] != peter {\n+\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter})\n+\t}\n+\tif len(n.UnverifiedSigs) != 1 || n.UnverifiedSigs[0] != enoch {\n+\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter})\n+\t}\n+\n+\t// Check both verified.\n+\tn, err = Open([]byte(text+\"\\n\"+peterSig+enochSig), VerifierList(peterVerifier, enochVerifier))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif len(n.Sigs) != 2 || n.Sigs[0] != peter || n.Sigs[1] != enoch {\n+\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter, enoch})\n+\t}\n+\tif len(n.UnverifiedSigs) != 0 {\n+\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{})\n+\t}\n+\n+\t// Check both unverified.\n+\tn, err = Open([]byte(text+\"\\n\"+peterSig+enochSig), VerifierList())\n+\tif n != nil || err == nil {\n+\t\tt.Fatalf(\"Open unverified = %v, %v, want nil, error\", n, err)\n+\t}\n+\te, ok := err.(*UnverifiedNoteError)\n+\tif !ok {\n+\t\tt.Fatalf(\"Open unverified: err is %T, want *UnverifiedNoteError\", err)\n+\t}\n+\tif err.Error() != \"note has no verifiable signatures\" {\n+\t\tt.Fatalf(\"Open unverified: err.Error() = %q, want %q\", err.Error(), \"note has no verifiable signatures\")\n+\t}\n+\n+\tn = e.Note\n+\tif n == nil {\n+\t\tt.Fatalf(\"Open unverified: missing note in UnverifiedNoteError\")\n+\t}\n+\tif len(n.Sigs) != 0 {\n+\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{})\n+\t}\n+\tif len(n.UnverifiedSigs) != 2 || n.UnverifiedSigs[0] != peter || n.UnverifiedSigs[1] != enoch {\n+\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter, enoch})\n+\t}\n+\n+\t// Check duplicated verifier.\n+\t_, err = Open([]byte(text+\"\\n\"+enochSig), VerifierList(enochVerifier, peterVerifier, enochVerifier))\n+\tif err == nil || err.Error() != \"ambiguous key EnochRoot+af0cfe78\" {\n+\t\tt.Fatalf(\"Open with duplicated verifier: err=%v, want ambiguous key\", err)\n+\t}\n+\n+\t// Check unused duplicated verifier.\n+\t_, err = Open([]byte(text+\"\\n\"+peterSig), VerifierList(enochVerifier, peterVerifier, enochVerifier))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\t// Check too many signatures.\n+\tn, err = Open([]byte(text+\"\\n\"+strings.Repeat(peterSig, 101)), VerifierList(peterVerifier))\n+\tif n != nil || err == nil || err.Error() != \"malformed note\" {\n+\t\tt.Fatalf(\"Open too many verified signatures = %v, %v, want nil, malformed note error\", n, err)\n+\t}\n+\tn, err = Open([]byte(text+\"\\n\"+strings.Repeat(peterSig, 101)), VerifierList())\n+\tif n != nil || err == nil || err.Error() != \"malformed note\" {\n+\t\tt.Fatalf(\"Open too many verified signatures = %v, %v, want nil, malformed note error\", n, err)\n+\t}\n+\n+\t// Invalid signature.\n+\tn, err = Open([]byte(text+\"\\n\"+peterSig[:60]+\"ABCD\"+peterSig[60:]), VerifierList(peterVerifier))\n+\tif n != nil || err == nil || err.Error() != \"invalid signature for key PeterNeumann+c74f20a3\" {\n+\t\tt.Fatalf(\"Open too many verified signatures = %v, %v, want nil, invalid signature error\", n, err)\n+\t}\n+\n+\t// Duplicated verified and unverified signatures.\n+\tenochABCD := Signature{\"EnochRoot\", 0xaf0cfe78, \"rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n\" + \"ABCD\" + \"2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\"}\n+\tn, err = Open([]byte(text+\"\\n\"+peterSig+peterSig+enochSig+enochSig+enochSig[:60]+\"ABCD\"+enochSig[60:]), VerifierList(peterVerifier))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif len(n.Sigs) != 1 || n.Sigs[0] != peter {\n+\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter})\n+\t}\n+\tif len(n.UnverifiedSigs) != 2 || n.UnverifiedSigs[0] != enoch || n.UnverifiedSigs[1] != enochABCD {\n+\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.UnverifiedSigs, []Signature{enoch, enochABCD})\n+\t}\n+\n+\t// Invalid encoded message syntax.\n+\tbadMsgs := []string{\n+\t\ttext,\n+\t\ttext + \"\\n\",\n+\t\ttext + \"\\n\" + peterSig[:len(peterSig)-1],\n+\t\t\"\\x01\" + text + \"\\n\" + peterSig,\n+\t\t\"\\xff\" + text + \"\\n\" + peterSig,\n+\t\ttext + \"\\n\" + \"\u2014 Bad Name x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\",\n+\t\ttext + \"\\n\" + peterSig + \"Unexpected line.\\n\",\n+\t}\n+\tfor _, msg := range badMsgs {\n+\t\tn, err := Open([]byte(msg), VerifierList(peterVerifier))\n+\t\tif n != nil || err == nil || err.Error() != \"malformed note\" {\n+\t\t\tt.Fatalf(\"Open bad msg = %v, %v, want nil, malformed note error\\nmsg:\\n%s\", n, err, msg)\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkOpen(b *testing.B) {\n+\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n+\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n+\t\t\"then you don't know what your problem is.\\n\" +\n+\t\t\"\\n\" +\n+\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n+\n+\tverifier, err := NewVerifier(vkey)\n+\tif err != nil {\n+\t\tb.Fatal(err)\n+\t}\n+\tverifiers := VerifierList(verifier)\n+\tverifiers0 := VerifierList()\n+\n+\t// Try with 0 signatures and 1 signature so we can tell how much each signature adds.\n+\n+\tb.Run(\"Sig0\", func(b *testing.B) {\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\t_, err := Open(msg, verifiers0)\n+\t\t\te, ok := err.(*UnverifiedNoteError)\n+\t\t\tif !ok {\n+\t\t\t\tb.Fatal(\"expected UnverifiedNoteError\")\n+\t\t\t}\n+\t\t\tn := e.Note\n+\t\t\tif len(n.Sigs) != 0 || len(n.UnverifiedSigs) != 1 {\n+\t\t\t\tb.Fatal(\"wrong signature count\")\n+\t\t\t}\n+\t\t}\n+\t})\n+\n+\tb.Run(\"Sig1\", func(b *testing.B) {\n+\t\tfor i := 0; i < b.N; i++ {\n+\t\t\tn, err := Open(msg, verifiers)\n+\t\t\tif err != nil {\n+\t\t\t\tb.Fatal(err)\n+\t\t\t}\n+\t\t\tif len(n.Sigs) != 1 || len(n.UnverifiedSigs) != 0 {\n+\t\t\t\tb.Fatal(\"wrong signature count\")\n+\t\t\t}\n+\t\t}\n+\t})\n+}"}, {"sha": "960cec6fb16994ea9ef028b9e1b9d2b797f35a19", "filename": "libgo/go/cmd/go/internal/par/work.go", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fpar%2Fwork.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -147,3 +147,44 @@ func (c *Cache) Get(key interface{}) interface{} {\n \t}\n \treturn e.result\n }\n+\n+// Clear removes all entries in the cache.\n+//\n+// Concurrent calls to Get may return old values. Concurrent calls to Do\n+// may return old values or store results in entries that have been deleted.\n+//\n+// TODO(jayconrod): Delete this after the package cache clearing functions\n+// in internal/load have been removed.\n+func (c *Cache) Clear() {\n+\tc.m.Range(func(key, value interface{}) bool {\n+\t\tc.m.Delete(key)\n+\t\treturn true\n+\t})\n+}\n+\n+// Delete removes an entry from the map. It is safe to call Delete for an\n+// entry that does not exist. Delete will return quickly, even if the result\n+// for a key is still being computed; the computation will finish, but the\n+// result won't be accessible through the cache.\n+//\n+// TODO(jayconrod): Delete this after the package cache clearing functions\n+// in internal/load have been removed.\n+func (c *Cache) Delete(key interface{}) {\n+\tc.m.Delete(key)\n+}\n+\n+// DeleteIf calls pred for each key in the map. If pred returns true for a key,\n+// DeleteIf removes the corresponding entry. If the result for a key is\n+// still being computed, DeleteIf will remove the entry without waiting for\n+// the computation to finish. The result won't be accessible through the cache.\n+//\n+// TODO(jayconrod): Delete this after the package cache clearing functions\n+// in internal/load have been removed.\n+func (c *Cache) DeleteIf(pred func(key interface{}) bool) {\n+\tc.m.Range(func(key, _ interface{}) bool {\n+\t\tif pred(key) {\n+\t\t\tc.Delete(key)\n+\t\t}\n+\t\treturn true\n+\t})\n+}"}, {"sha": "d573cc690d2397627c69e055f5a4b4c55e7de9b2", "filename": "libgo/go/cmd/go/internal/renameio/renameio.go", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,12 +8,15 @@ package renameio\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"io/ioutil\"\n+\t\"math/rand\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strconv\"\n+\n+\t\"cmd/go/internal/robustio\"\n )\n \n-const patternSuffix = \"*.tmp\"\n+const patternSuffix = \".tmp\"\n \n // Pattern returns a glob pattern that matches the unrenamed temporary files\n // created when writing to filename.\n@@ -26,14 +29,14 @@ func Pattern(filename string) string {\n // final name.\n //\n // That ensures that the final location, if it exists, is always a complete file.\n-func WriteFile(filename string, data []byte) (err error) {\n-\treturn WriteToFile(filename, bytes.NewReader(data))\n+func WriteFile(filename string, data []byte, perm os.FileMode) (err error) {\n+\treturn WriteToFile(filename, bytes.NewReader(data), perm)\n }\n \n // WriteToFile is a variant of WriteFile that accepts the data as an io.Reader\n // instead of a slice.\n-func WriteToFile(filename string, data io.Reader) (err error) {\n-\tf, err := ioutil.TempFile(filepath.Dir(filename), filepath.Base(filename)+patternSuffix)\n+func WriteToFile(filename string, data io.Reader, perm os.FileMode) (err error) {\n+\tf, err := tempFile(filepath.Dir(filename), filepath.Base(filename), perm)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -59,5 +62,32 @@ func WriteToFile(filename string, data io.Reader) (err error) {\n \tif err := f.Close(); err != nil {\n \t\treturn err\n \t}\n-\treturn os.Rename(f.Name(), filename)\n+\n+\treturn robustio.Rename(f.Name(), filename)\n+}\n+\n+// ReadFile is like ioutil.ReadFile, but on Windows retries spurious errors that\n+// may occur if the file is concurrently replaced.\n+//\n+// Errors are classified heuristically and retries are bounded, so even this\n+// function may occasionally return a spurious error on Windows.\n+// If so, the error will likely wrap one of:\n+// \t- syscall.ERROR_ACCESS_DENIED\n+// \t- syscall.ERROR_FILE_NOT_FOUND\n+// \t- internal/syscall/windows.ERROR_SHARING_VIOLATION\n+func ReadFile(filename string) ([]byte, error) {\n+\treturn robustio.ReadFile(filename)\n+}\n+\n+// tempFile creates a new temporary file with given permission bits.\n+func tempFile(dir, prefix string, perm os.FileMode) (f *os.File, err error) {\n+\tfor i := 0; i < 10000; i++ {\n+\t\tname := filepath.Join(dir, prefix+strconv.Itoa(rand.Intn(1000000000))+patternSuffix)\n+\t\tf, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, perm)\n+\t\tif os.IsExist(err) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\treturn\n }"}, {"sha": "81dba6d5451d086a0cbdf39d94a0cec4f535f794", "filename": "libgo/go/cmd/go/internal/renameio/renameio_test.go", "status": "added", "additions": 145, "deletions": 0, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,145 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build !plan9\n+\n+package renameio\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"errors\"\n+\t\"io/ioutil\"\n+\t\"math/rand\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\t\"syscall\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/robustio\"\n+)\n+\n+func TestConcurrentReadsAndWrites(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"renameio\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\tpath := filepath.Join(dir, \"blob.bin\")\n+\n+\tconst chunkWords = 8 << 10\n+\tbuf := make([]byte, 2*chunkWords*8)\n+\tfor i := uint64(0); i < 2*chunkWords; i++ {\n+\t\tbinary.LittleEndian.PutUint64(buf[i*8:], i)\n+\t}\n+\n+\tvar attempts int64 = 128\n+\tif !testing.Short() {\n+\t\tattempts *= 16\n+\t}\n+\tconst parallel = 32\n+\n+\tvar sem = make(chan bool, parallel)\n+\n+\tvar (\n+\t\twriteSuccesses, readSuccesses int64 // atomic\n+\t\twriteErrnoSeen, readErrnoSeen sync.Map\n+\t)\n+\n+\tfor n := attempts; n > 0; n-- {\n+\t\tsem <- true\n+\t\tgo func() {\n+\t\t\tdefer func() { <-sem }()\n+\n+\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Microsecond)\n+\t\t\toffset := rand.Intn(chunkWords)\n+\t\t\tchunk := buf[offset*8 : (offset+chunkWords)*8]\n+\t\t\tif err := WriteFile(path, chunk, 0666); err == nil {\n+\t\t\t\tatomic.AddInt64(&writeSuccesses, 1)\n+\t\t\t} else if robustio.IsEphemeralError(err) {\n+\t\t\t\tvar (\n+\t\t\t\t\terrno syscall.Errno\n+\t\t\t\t\tdup   bool\n+\t\t\t\t)\n+\t\t\t\tif errors.As(err, &errno) {\n+\t\t\t\t\t_, dup = writeErrnoSeen.LoadOrStore(errno, true)\n+\t\t\t\t}\n+\t\t\t\tif !dup {\n+\t\t\t\t\tt.Logf(\"ephemeral error: %v\", err)\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n+\t\t\t}\n+\n+\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Microsecond)\n+\t\t\tdata, err := ReadFile(path)\n+\t\t\tif err == nil {\n+\t\t\t\tatomic.AddInt64(&readSuccesses, 1)\n+\t\t\t} else if robustio.IsEphemeralError(err) {\n+\t\t\t\tvar (\n+\t\t\t\t\terrno syscall.Errno\n+\t\t\t\t\tdup   bool\n+\t\t\t\t)\n+\t\t\t\tif errors.As(err, &errno) {\n+\t\t\t\t\t_, dup = readErrnoSeen.LoadOrStore(errno, true)\n+\t\t\t\t}\n+\t\t\t\tif !dup {\n+\t\t\t\t\tt.Logf(\"ephemeral error: %v\", err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t} else {\n+\t\t\t\tt.Errorf(\"unexpected error: %v\", err)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tif len(data) != 8*chunkWords {\n+\t\t\t\tt.Errorf(\"read %d bytes, but each write is a %d-byte file\", len(data), 8*chunkWords)\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tu := binary.LittleEndian.Uint64(data)\n+\t\t\tfor i := 1; i < chunkWords; i++ {\n+\t\t\t\tnext := binary.LittleEndian.Uint64(data[i*8:])\n+\t\t\t\tif next != u+1 {\n+\t\t\t\t\tt.Errorf(\"wrote sequential integers, but read integer out of sequence at offset %d\", i)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\tu = next\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\tfor n := parallel; n > 0; n-- {\n+\t\tsem <- true\n+\t}\n+\n+\tvar minWriteSuccesses int64 = attempts\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Windows produces frequent \"Access is denied\" errors under heavy rename load.\n+\t\t// As long as those are the only errors and *some* of the writes succeed, we're happy.\n+\t\tminWriteSuccesses = attempts / 4\n+\t}\n+\n+\tif writeSuccesses < minWriteSuccesses {\n+\t\tt.Errorf(\"%d (of %d) writes succeeded; want \u2265 %d\", writeSuccesses, attempts, minWriteSuccesses)\n+\t} else {\n+\t\tt.Logf(\"%d (of %d) writes succeeded (ok: \u2265 %d)\", writeSuccesses, attempts, minWriteSuccesses)\n+\t}\n+\n+\tvar minReadSuccesses int64 = attempts\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// Windows produces frequent \"Access is denied\" errors under heavy rename load.\n+\t\t// As long as those are the only errors and *some* of the writes succeed, we're happy.\n+\t\tminReadSuccesses = attempts / 4\n+\t}\n+\n+\tif readSuccesses < minReadSuccesses {\n+\t\tt.Errorf(\"%d (of %d) reads succeeded; want \u2265 %d\", readSuccesses, attempts, minReadSuccesses)\n+\t} else {\n+\t\tt.Logf(\"%d (of %d) reads succeeded (ok: \u2265 %d)\", readSuccesses, attempts, minReadSuccesses)\n+\t}\n+}"}, {"sha": "1a471c9e4e644865f3b06cdf21b87448182462bd", "filename": "libgo/go/cmd/go/internal/renameio/umask_test.go", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build !nacl,!plan9,!windows,!js\n+\n+package renameio\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"syscall\"\n+\t\"testing\"\n+)\n+\n+func TestWriteFileModeAppliesUmask(t *testing.T) {\n+\tdir, err := ioutil.TempDir(\"\", \"renameio\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n+\t}\n+\n+\tconst mode = 0644\n+\tconst umask = 0007\n+\tdefer syscall.Umask(syscall.Umask(umask))\n+\n+\tfile := filepath.Join(dir, \"testWrite\")\n+\terr = WriteFile(file, []byte(\"go-build\"), mode)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to write file: %v\", err)\n+\t}\n+\tdefer os.RemoveAll(dir)\n+\n+\tfi, err := os.Stat(file)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Stat %q (looking for mode %#o): %s\", file, mode, err)\n+\t}\n+\n+\tif fi.Mode()&os.ModePerm != 0640 {\n+\t\tt.Errorf(\"Stat %q: mode %#o want %#o\", file, fi.Mode()&os.ModePerm, 0640)\n+\t}\n+}"}, {"sha": "76e47ad1ffad76850a1e4752fe2b217593c59dcf", "filename": "libgo/go/cmd/go/internal/robustio/robustio.go", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package robustio wraps I/O functions that are prone to failure on Windows,\n+// transparently retrying errors up to an arbitrary timeout.\n+//\n+// Errors are classified heuristically and retries are bounded, so the functions\n+// in this package do not completely eliminate spurious errors. However, they do\n+// significantly reduce the rate of failure in practice.\n+//\n+// If so, the error will likely wrap one of:\n+// The functions in this package do not completely eliminate spurious errors,\n+// but substantially reduce their rate of occurrence in practice.\n+package robustio\n+\n+// Rename is like os.Rename, but on Windows retries errors that may occur if the\n+// file is concurrently read or overwritten.\n+//\n+// (See golang.org/issue/31247 and golang.org/issue/32188.)\n+func Rename(oldpath, newpath string) error {\n+\treturn rename(oldpath, newpath)\n+}\n+\n+// ReadFile is like ioutil.ReadFile, but on Windows retries errors that may\n+// occur if the file is concurrently replaced.\n+//\n+// (See golang.org/issue/31247 and golang.org/issue/32188.)\n+func ReadFile(filename string) ([]byte, error) {\n+\treturn readFile(filename)\n+}\n+\n+// RemoveAll is like os.RemoveAll, but on Windows retries errors that may occur\n+// if an executable file in the directory has recently been executed.\n+//\n+// (See golang.org/issue/19491.)\n+func RemoveAll(path string) error {\n+\treturn removeAll(path)\n+}\n+\n+// IsEphemeralError reports whether err is one of the errors that the functions\n+// in this package attempt to mitigate.\n+//\n+// Errors considered ephemeral include:\n+// \t- syscall.ERROR_ACCESS_DENIED\n+// \t- syscall.ERROR_FILE_NOT_FOUND\n+// \t- internal/syscall/windows.ERROR_SHARING_VIOLATION\n+//\n+// This set may be expanded in the future; programs must not rely on the\n+// non-ephemerality of any given error.\n+func IsEphemeralError(err error) bool {\n+\treturn isEphemeralError(err)\n+}"}, {"sha": "91ca56cb82cae11f8a79404e78b3ae7757f2afe1", "filename": "libgo/go/cmd/go/internal/robustio/robustio_other.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+//+build !windows\n+\n+package robustio\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+)\n+\n+func rename(oldpath, newpath string) error {\n+\treturn os.Rename(oldpath, newpath)\n+}\n+\n+func readFile(filename string) ([]byte, error) {\n+\treturn ioutil.ReadFile(filename)\n+}\n+\n+func removeAll(path string) error {\n+\treturn os.RemoveAll(path)\n+}\n+\n+func isEphemeralError(err error) bool {\n+\treturn false\n+}"}, {"sha": "a3d94e566fe420340f93aa1d4d3da5c544e1c051", "filename": "libgo/go/cmd/go/internal/robustio/robustio_windows.go", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_windows.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package robustio\n+\n+import (\n+\t\"errors\"\n+\t\"internal/syscall/windows\"\n+\t\"io/ioutil\"\n+\t\"math/rand\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+const arbitraryTimeout = 500 * time.Millisecond\n+\n+// retry retries ephemeral errors from f up to an arbitrary timeout\n+// to work around spurious filesystem errors on Windows\n+func retry(f func() (err error, mayRetry bool)) error {\n+\tvar (\n+\t\tbestErr     error\n+\t\tlowestErrno syscall.Errno\n+\t\tstart       time.Time\n+\t\tnextSleep   time.Duration = 1 * time.Millisecond\n+\t)\n+\tfor {\n+\t\terr, mayRetry := f()\n+\t\tif err == nil || !mayRetry {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tvar errno syscall.Errno\n+\t\tif errors.As(err, &errno) && (lowestErrno == 0 || errno < lowestErrno) {\n+\t\t\tbestErr = err\n+\t\t\tlowestErrno = errno\n+\t\t} else if bestErr == nil {\n+\t\t\tbestErr = err\n+\t\t}\n+\n+\t\tif start.IsZero() {\n+\t\t\tstart = time.Now()\n+\t\t} else if d := time.Since(start) + nextSleep; d >= arbitraryTimeout {\n+\t\t\tbreak\n+\t\t}\n+\t\ttime.Sleep(nextSleep)\n+\t\tnextSleep += time.Duration(rand.Int63n(int64(nextSleep)))\n+\t}\n+\n+\treturn bestErr\n+}\n+\n+// rename is like os.Rename, but retries ephemeral errors.\n+//\n+// It wraps os.Rename, which (as of 2019-06-04) uses MoveFileEx with\n+// MOVEFILE_REPLACE_EXISTING.\n+//\n+// Windows also provides a different system call, ReplaceFile,\n+// that provides similar semantics, but perhaps preserves more metadata. (The\n+// documentation on the differences between the two is very sparse.)\n+//\n+// Empirical error rates with MoveFileEx are lower under modest concurrency, so\n+// for now we're sticking with what the os package already provides.\n+func rename(oldpath, newpath string) (err error) {\n+\treturn retry(func() (err error, mayRetry bool) {\n+\t\terr = os.Rename(oldpath, newpath)\n+\t\treturn err, isEphemeralError(err)\n+\t})\n+}\n+\n+// readFile is like ioutil.ReadFile, but retries ephemeral errors.\n+func readFile(filename string) ([]byte, error) {\n+\tvar b []byte\n+\terr := retry(func() (err error, mayRetry bool) {\n+\t\tb, err = ioutil.ReadFile(filename)\n+\n+\t\t// Unlike in rename, we do not retry ERROR_FILE_NOT_FOUND here: it can occur\n+\t\t// as a spurious error, but the file may also genuinely not exist, so the\n+\t\t// increase in robustness is probably not worth the extra latency.\n+\t\treturn err, isEphemeralError(err) && !errors.Is(err, syscall.ERROR_FILE_NOT_FOUND)\n+\t})\n+\treturn b, err\n+}\n+\n+func removeAll(path string) error {\n+\treturn retry(func() (err error, mayRetry bool) {\n+\t\terr = os.RemoveAll(path)\n+\t\treturn err, isEphemeralError(err)\n+\t})\n+}\n+\n+// isEphemeralError returns true if err may be resolved by waiting.\n+func isEphemeralError(err error) bool {\n+\tvar errno syscall.Errno\n+\tif errors.As(err, &errno) {\n+\t\tswitch errno {\n+\t\tcase syscall.ERROR_ACCESS_DENIED,\n+\t\t\tsyscall.ERROR_FILE_NOT_FOUND,\n+\t\t\twindows.ERROR_SHARING_VIOLATION:\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "71da5adc934cdaf23c042a97d5f0c186b7b32dfa", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -8,6 +8,7 @@ package run\n import (\n \t\"fmt\"\n \t\"os\"\n+\t\"path\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n@@ -22,7 +23,7 @@ var CmdRun = &base.Command{\n \tShort:     \"compile and run Go program\",\n \tLong: `\n Run compiles and runs the named main Go package.\n-Typically the package is specified as a list of .go source files,\n+Typically the package is specified as a list of .go source files from a single directory,\n but it may also be an import path, file system path, or pattern\n matching a single known package, as in 'go run .' or 'go run my/cmd'.\n \n@@ -94,10 +95,10 @@ func runRun(cmd *base.Command, args []string) {\n \t\tbase.Fatalf(\"go run: no go files listed\")\n \t}\n \tcmdArgs := args[i:]\n-\n \tif p.Error != nil {\n \t\tbase.Fatalf(\"%s\", p.Error)\n \t}\n+\n \tp.Internal.OmitDebug = true\n \tif len(p.DepsErrors) > 0 {\n \t\t// Since these are errors in dependencies,\n@@ -117,21 +118,26 @@ func runRun(cmd *base.Command, args []string) {\n \t\tbase.Fatalf(\"go run: cannot run non-main package\")\n \t}\n \tp.Target = \"\" // must build - not up to date\n-\tvar src string\n-\tif len(p.GoFiles) > 0 {\n-\t\tsrc = p.GoFiles[0]\n-\t} else if len(p.CgoFiles) > 0 {\n-\t\tsrc = p.CgoFiles[0]\n-\t} else {\n-\t\t// this case could only happen if the provided source uses cgo\n-\t\t// while cgo is disabled.\n-\t\thint := \"\"\n-\t\tif !cfg.BuildContext.CgoEnabled {\n-\t\t\thint = \" (cgo is disabled)\"\n+\tif p.Internal.CmdlineFiles {\n+\t\t//set executable name if go file is given as cmd-argument\n+\t\tvar src string\n+\t\tif len(p.GoFiles) > 0 {\n+\t\t\tsrc = p.GoFiles[0]\n+\t\t} else if len(p.CgoFiles) > 0 {\n+\t\t\tsrc = p.CgoFiles[0]\n+\t\t} else {\n+\t\t\t// this case could only happen if the provided source uses cgo\n+\t\t\t// while cgo is disabled.\n+\t\t\thint := \"\"\n+\t\t\tif !cfg.BuildContext.CgoEnabled {\n+\t\t\t\thint = \" (cgo is disabled)\"\n+\t\t\t}\n+\t\t\tbase.Fatalf(\"go run: no suitable source files%s\", hint)\n \t\t}\n-\t\tbase.Fatalf(\"go run: no suitable source files%s\", hint)\n+\t\tp.Internal.ExeName = src[:len(src)-len(\".go\")]\n+\t} else {\n+\t\tp.Internal.ExeName = path.Base(p.ImportPath)\n \t}\n-\tp.Internal.ExeName = src[:len(src)-len(\".go\")] // name temporary executable for first go file\n \ta1 := b.LinkAction(work.ModeBuild, work.ModeBuild, p)\n \ta := &work.Action{Mode: \"go run\", Func: buildRunProgram, Args: cmdArgs, Deps: []*work.Action{a1}}\n \tb.Do(a)"}, {"sha": "0167c8d7550838f0b84ee8c03f60269c1167baf6", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -190,7 +190,7 @@ func MatchPackagesInFS(pattern string) *Match {\n \n \t\tif !top && cfg.ModulesEnabled {\n \t\t\t// Ignore other modules found in subdirectories.\n-\t\t\tif _, err := os.Stat(filepath.Join(path, \"go.mod\")); err == nil {\n+\t\t\tif fi, err := os.Stat(filepath.Join(path, \"go.mod\")); err == nil && !fi.IsDir() {\n \t\t\t\treturn filepath.SkipDir\n \t\t\t}\n \t\t}\n@@ -327,14 +327,35 @@ func ImportPathsQuiet(patterns []string) []*Match {\n \t\t\tout = append(out, MatchPackages(a))\n \t\t\tcontinue\n \t\t}\n-\t\tif strings.Contains(a, \"...\") {\n-\t\t\tif build.IsLocalImport(a) {\n-\t\t\t\tout = append(out, MatchPackagesInFS(a))\n+\n+\t\tif build.IsLocalImport(a) || filepath.IsAbs(a) {\n+\t\t\tvar m *Match\n+\t\t\tif strings.Contains(a, \"...\") {\n+\t\t\t\tm = MatchPackagesInFS(a)\n \t\t\t} else {\n-\t\t\t\tout = append(out, MatchPackages(a))\n+\t\t\t\tm = &Match{Pattern: a, Literal: true, Pkgs: []string{a}}\n+\t\t\t}\n+\n+\t\t\t// Change the file import path to a regular import path if the package\n+\t\t\t// is in GOPATH or GOROOT. We don't report errors here; LoadImport\n+\t\t\t// (or something similar) will report them later.\n+\t\t\tfor i, dir := range m.Pkgs {\n+\t\t\t\tif !filepath.IsAbs(dir) {\n+\t\t\t\t\tdir = filepath.Join(base.Cwd, dir)\n+\t\t\t\t}\n+\t\t\t\tif bp, _ := cfg.BuildContext.ImportDir(dir, build.FindOnly); bp.ImportPath != \"\" && bp.ImportPath != \".\" {\n+\t\t\t\t\tm.Pkgs[i] = bp.ImportPath\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tout = append(out, m)\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif strings.Contains(a, \"...\") {\n+\t\t\tout = append(out, MatchPackages(a))\n+\t\t\tcontinue\n+\t\t}\n+\n \t\tout = append(out, &Match{Pattern: a, Literal: true, Pkgs: []string{a}})\n \t}\n \treturn out"}, {"sha": "a4ffc5f131241bc1165a495df56f4ffa3e79c007", "filename": "libgo/go/cmd/go/internal/str/path.go", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fstr%2Fpath.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -5,6 +5,7 @@\n package str\n \n import (\n+\t\"path\"\n \t\"path/filepath\"\n \t\"strings\"\n )\n@@ -49,3 +50,47 @@ func HasFilePathPrefix(s, prefix string) bool {\n \t\treturn s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix\n \t}\n }\n+\n+// GlobsMatchPath reports whether any path prefix of target\n+// matches one of the glob patterns (as defined by path.Match)\n+// in the comma-separated globs list.\n+// It ignores any empty or malformed patterns in the list.\n+func GlobsMatchPath(globs, target string) bool {\n+\tfor globs != \"\" {\n+\t\t// Extract next non-empty glob in comma-separated list.\n+\t\tvar glob string\n+\t\tif i := strings.Index(globs, \",\"); i >= 0 {\n+\t\t\tglob, globs = globs[:i], globs[i+1:]\n+\t\t} else {\n+\t\t\tglob, globs = globs, \"\"\n+\t\t}\n+\t\tif glob == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// A glob with N+1 path elements (N slashes) needs to be matched\n+\t\t// against the first N+1 path elements of target,\n+\t\t// which end just before the N+1'th slash.\n+\t\tn := strings.Count(glob, \"/\")\n+\t\tprefix := target\n+\t\t// Walk target, counting slashes, truncating at the N+1'th slash.\n+\t\tfor i := 0; i < len(target); i++ {\n+\t\t\tif target[i] == '/' {\n+\t\t\t\tif n == 0 {\n+\t\t\t\t\tprefix = target[:i]\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tn--\n+\t\t\t}\n+\t\t}\n+\t\tif n > 0 {\n+\t\t\t// Not enough prefix elements.\n+\t\t\tcontinue\n+\t\t}\n+\t\tmatched, _ := path.Match(glob, prefix)\n+\t\tif matched {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}"}, {"sha": "a8117a71b783051eaec39191eff3e02020f82ada", "filename": "libgo/go/cmd/go/internal/sumweb/cache.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fcache.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Parallel cache.\n+// This file is copied from cmd/go/internal/par.\n+\n+package sumweb\n+\n+import (\n+\t\"sync\"\n+\t\"sync/atomic\"\n+)\n+\n+// parCache runs an action once per key and caches the result.\n+type parCache struct {\n+\tm sync.Map\n+}\n+\n+type cacheEntry struct {\n+\tdone   uint32\n+\tmu     sync.Mutex\n+\tresult interface{}\n+}\n+\n+// Do calls the function f if and only if Do is being called for the first time with this key.\n+// No call to Do with a given key returns until the one call to f returns.\n+// Do returns the value returned by the one call to f.\n+func (c *parCache) Do(key interface{}, f func() interface{}) interface{} {\n+\tentryIface, ok := c.m.Load(key)\n+\tif !ok {\n+\t\tentryIface, _ = c.m.LoadOrStore(key, new(cacheEntry))\n+\t}\n+\te := entryIface.(*cacheEntry)\n+\tif atomic.LoadUint32(&e.done) == 0 {\n+\t\te.mu.Lock()\n+\t\tif atomic.LoadUint32(&e.done) == 0 {\n+\t\t\te.result = f()\n+\t\t\tatomic.StoreUint32(&e.done, 1)\n+\t\t}\n+\t\te.mu.Unlock()\n+\t}\n+\treturn e.result\n+}\n+\n+// Get returns the cached result associated with key.\n+// It returns nil if there is no such result.\n+// If the result for key is being computed, Get does not wait for the computation to finish.\n+func (c *parCache) Get(key interface{}) interface{} {\n+\tentryIface, ok := c.m.Load(key)\n+\tif !ok {\n+\t\treturn nil\n+\t}\n+\te := entryIface.(*cacheEntry)\n+\tif atomic.LoadUint32(&e.done) == 0 {\n+\t\treturn nil\n+\t}\n+\treturn e.result\n+}"}, {"sha": "6973e5ac1799081ca54d3f2a657989a3d944c295", "filename": "libgo/go/cmd/go/internal/sumweb/client.go", "status": "added", "additions": 619, "deletions": 0, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,619 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sumweb\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n+\n+\t\"cmd/go/internal/note\"\n+\t\"cmd/go/internal/str\"\n+\t\"cmd/go/internal/tlog\"\n+)\n+\n+// A Client provides the external operations\n+// (file caching, HTTP fetches, and so on)\n+// needed to implement the HTTP client Conn.\n+// The methods must be safe for concurrent use by multiple goroutines.\n+type Client interface {\n+\t// ReadRemote reads and returns the content served at the given path\n+\t// on the remote database server. The path begins with \"/lookup\" or \"/tile/\".\n+\t// It is the implementation's responsibility to turn that path into a full URL\n+\t// and make the HTTP request. ReadRemote should return an error for\n+\t// any non-200 HTTP response status.\n+\tReadRemote(path string) ([]byte, error)\n+\n+\t// ReadConfig reads and returns the content of the named configuration file.\n+\t// There are only a fixed set of configuration files.\n+\t//\n+\t// \"key\" returns a file containing the verifier key for the server.\n+\t//\n+\t// serverName + \"/latest\" returns a file containing the latest known\n+\t// signed tree from the server. It is read and written (using WriteConfig).\n+\t// To signal that the client wishes to start with an \"empty\" signed tree,\n+\t// ReadConfig can return a successful empty result (0 bytes of data).\n+\tReadConfig(file string) ([]byte, error)\n+\n+\t// WriteConfig updates the content of the named configuration file,\n+\t// changing it from the old []byte to the new []byte.\n+\t// If the old []byte does not match the stored configuration,\n+\t// WriteConfig must return ErrWriteConflict.\n+\t// Otherwise, WriteConfig should atomically replace old with new.\n+\tWriteConfig(file string, old, new []byte) error\n+\n+\t// ReadCache reads and returns the content of the named cache file.\n+\t// Any returned error will be treated as equivalent to the file not existing.\n+\t// There can be arbitrarily many cache files, such as:\n+\t//\tserverName/lookup/pkg@version\n+\t//\tserverName/tile/8/1/x123/456\n+\tReadCache(file string) ([]byte, error)\n+\n+\t// WriteCache writes the named cache file.\n+\tWriteCache(file string, data []byte)\n+\n+\t// Log prints the given log message (such as with log.Print)\n+\tLog(msg string)\n+\n+\t// SecurityError prints the given security error log message.\n+\t// The Conn returns ErrSecurity from any operation that invokes SecurityError,\n+\t// but the return value is mainly for testing. In a real program,\n+\t// SecurityError should typically print the message and call log.Fatal or os.Exit.\n+\tSecurityError(msg string)\n+}\n+\n+// ErrWriteConflict signals a write conflict during Client.WriteConfig.\n+var ErrWriteConflict = errors.New(\"write conflict\")\n+\n+// ErrSecurity is returned by Conn operations that invoke Client.SecurityError.\n+var ErrSecurity = errors.New(\"security error: misbehaving server\")\n+\n+// A Conn is a client connection to a go.sum database.\n+// All the methods are safe for simultaneous use by multiple goroutines.\n+type Conn struct {\n+\tclient Client // client-provided external world\n+\n+\tdidLookup uint32\n+\n+\t// one-time initialized data\n+\tinitOnce   sync.Once\n+\tinitErr    error          // init error, if any\n+\tname       string         // name of accepted verifier\n+\tverifiers  note.Verifiers // accepted verifiers (just one, but Verifiers for note.Open)\n+\ttileReader tileReader\n+\ttileHeight int\n+\tnosumdb    string\n+\n+\trecord    parCache // cache of record lookup, keyed by path@vers\n+\ttileCache parCache // cache of c.readTile, keyed by tile\n+\n+\tlatestMu  sync.Mutex\n+\tlatest    tlog.Tree // latest known tree head\n+\tlatestMsg []byte    // encoded signed note for latest\n+\n+\ttileSavedMu sync.Mutex\n+\ttileSaved   map[tlog.Tile]bool // which tiles have been saved using c.client.WriteCache already\n+}\n+\n+// NewConn returns a new Conn using the given Client.\n+func NewConn(client Client) *Conn {\n+\treturn &Conn{\n+\t\tclient: client,\n+\t}\n+}\n+\n+// init initiailzes the conn (if not already initialized)\n+// and returns any initialization error.\n+func (c *Conn) init() error {\n+\tc.initOnce.Do(c.initWork)\n+\treturn c.initErr\n+}\n+\n+// initWork does the actual initialization work.\n+func (c *Conn) initWork() {\n+\tdefer func() {\n+\t\tif c.initErr != nil {\n+\t\t\tc.initErr = fmt.Errorf(\"initializing sumweb.Conn: %v\", c.initErr)\n+\t\t}\n+\t}()\n+\n+\tc.tileReader.c = c\n+\tif c.tileHeight == 0 {\n+\t\tc.tileHeight = 8\n+\t}\n+\tc.tileSaved = make(map[tlog.Tile]bool)\n+\n+\tvkey, err := c.client.ReadConfig(\"key\")\n+\tif err != nil {\n+\t\tc.initErr = err\n+\t\treturn\n+\t}\n+\tverifier, err := note.NewVerifier(strings.TrimSpace(string(vkey)))\n+\tif err != nil {\n+\t\tc.initErr = err\n+\t\treturn\n+\t}\n+\tc.verifiers = note.VerifierList(verifier)\n+\tc.name = verifier.Name()\n+\n+\tdata, err := c.client.ReadConfig(c.name + \"/latest\")\n+\tif err != nil {\n+\t\tc.initErr = err\n+\t\treturn\n+\t}\n+\tif err := c.mergeLatest(data); err != nil {\n+\t\tc.initErr = err\n+\t\treturn\n+\t}\n+}\n+\n+// SetTileHeight sets the tile height for the Conn.\n+// Any call to SetTileHeight must happen before the first call to Lookup.\n+// If SetTileHeight is not called, the Conn defaults to tile height 8.\n+func (c *Conn) SetTileHeight(height int) {\n+\tif atomic.LoadUint32(&c.didLookup) != 0 {\n+\t\tpanic(\"SetTileHeight used after Lookup\")\n+\t}\n+\tif c.tileHeight != 0 {\n+\t\tpanic(\"multiple calls to SetTileHeight\")\n+\t}\n+\tc.tileHeight = height\n+}\n+\n+// SetGONOSUMDB sets the list of comma-separated GONOSUMDB patterns for the Conn.\n+// For any module path matching one of the patterns,\n+// Lookup will return ErrGONOSUMDB.\n+// Any call to SetGONOSUMDB must happen before the first call to Lookup.\n+func (c *Conn) SetGONOSUMDB(list string) {\n+\tif atomic.LoadUint32(&c.didLookup) != 0 {\n+\t\tpanic(\"SetGONOSUMDB used after Lookup\")\n+\t}\n+\tif c.nosumdb != \"\" {\n+\t\tpanic(\"multiple calls to SetGONOSUMDB\")\n+\t}\n+\tc.nosumdb = list\n+}\n+\n+// ErrGONOSUMDB is returned by Lookup for paths that match\n+// a pattern listed in the GONOSUMDB list (set by SetGONOSUMDB,\n+// usually from the environment variable).\n+var ErrGONOSUMDB = errors.New(\"skipped (listed in GONOSUMDB)\")\n+\n+func (c *Conn) skip(target string) bool {\n+\treturn str.GlobsMatchPath(c.nosumdb, target)\n+}\n+\n+// Lookup returns the go.sum lines for the given module path and version.\n+// The version may end in a /go.mod suffix, in which case Lookup returns\n+// the go.sum lines for the module's go.mod-only hash.\n+func (c *Conn) Lookup(path, vers string) (lines []string, err error) {\n+\tatomic.StoreUint32(&c.didLookup, 1)\n+\n+\tif c.skip(path) {\n+\t\treturn nil, ErrGONOSUMDB\n+\t}\n+\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\terr = fmt.Errorf(\"%s@%s: %v\", path, vers, err)\n+\t\t}\n+\t}()\n+\n+\tif err := c.init(); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Prepare encoded cache filename / URL.\n+\tepath, err := encodePath(path)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tevers, err := encodeVersion(strings.TrimSuffix(vers, \"/go.mod\"))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfile := c.name + \"/lookup/\" + epath + \"@\" + evers\n+\tremotePath := \"/lookup/\" + epath + \"@\" + evers\n+\n+\t// Fetch the data.\n+\t// The lookupCache avoids redundant ReadCache/GetURL operations\n+\t// (especially since go.sum lines tend to come in pairs for a given\n+\t// path and version) and also avoids having multiple of the same\n+\t// request in flight at once.\n+\ttype cached struct {\n+\t\tdata []byte\n+\t\terr  error\n+\t}\n+\tresult := c.record.Do(file, func() interface{} {\n+\t\t// Try the on-disk cache, or else get from web.\n+\t\twriteCache := false\n+\t\tdata, err := c.client.ReadCache(file)\n+\t\tif err != nil {\n+\t\t\tdata, err = c.client.ReadRemote(remotePath)\n+\t\t\tif err != nil {\n+\t\t\t\treturn cached{nil, err}\n+\t\t\t}\n+\t\t\twriteCache = true\n+\t\t}\n+\n+\t\t// Validate the record before using it for anything.\n+\t\tid, text, treeMsg, err := tlog.ParseRecord(data)\n+\t\tif err != nil {\n+\t\t\treturn cached{nil, err}\n+\t\t}\n+\t\tif err := c.mergeLatest(treeMsg); err != nil {\n+\t\t\treturn cached{nil, err}\n+\t\t}\n+\t\tif err := c.checkRecord(id, text); err != nil {\n+\t\t\treturn cached{nil, err}\n+\t\t}\n+\n+\t\t// Now that we've validated the record,\n+\t\t// save it to the on-disk cache (unless that's where it came from).\n+\t\tif writeCache {\n+\t\t\tc.client.WriteCache(file, data)\n+\t\t}\n+\n+\t\treturn cached{data, nil}\n+\t}).(cached)\n+\tif result.err != nil {\n+\t\treturn nil, result.err\n+\t}\n+\n+\t// Extract the lines for the specific version we want\n+\t// (with or without /go.mod).\n+\tprefix := path + \" \" + vers + \" \"\n+\tvar hashes []string\n+\tfor _, line := range strings.Split(string(result.data), \"\\n\") {\n+\t\tif strings.HasPrefix(line, prefix) {\n+\t\t\thashes = append(hashes, line)\n+\t\t}\n+\t}\n+\treturn hashes, nil\n+}\n+\n+// mergeLatest merges the tree head in msg\n+// with the Conn's current latest tree head,\n+// ensuring the result is a consistent timeline.\n+// If the result is inconsistent, mergeLatest calls c.client.SecurityError\n+// with a detailed security error message and then\n+// (only if c.client.SecurityError does not exit the program) returns ErrSecurity.\n+// If the Conn's current latest tree head moves forward,\n+// mergeLatest updates the underlying configuration file as well,\n+// taking care to merge any independent updates to that configuration.\n+func (c *Conn) mergeLatest(msg []byte) error {\n+\t// Merge msg into our in-memory copy of the latest tree head.\n+\twhen, err := c.mergeLatestMem(msg)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif when != msgFuture {\n+\t\t// msg matched our present or was in the past.\n+\t\t// No change to our present, so no update of config file.\n+\t\treturn nil\n+\t}\n+\n+\t// Flush our extended timeline back out to the configuration file.\n+\t// If the configuration file has been updated in the interim,\n+\t// we need to merge any updates made there as well.\n+\t// Note that writeConfig is an atomic compare-and-swap.\n+\tfor {\n+\t\tmsg, err := c.client.ReadConfig(c.name + \"/latest\")\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\twhen, err := c.mergeLatestMem(msg)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif when != msgPast {\n+\t\t\t// msg matched our present or was from the future,\n+\t\t\t// and now our in-memory copy matches.\n+\t\t\treturn nil\n+\t\t}\n+\n+\t\t// msg (== config) is in the past, so we need to update it.\n+\t\tc.latestMu.Lock()\n+\t\tlatestMsg := c.latestMsg\n+\t\tc.latestMu.Unlock()\n+\t\tif err := c.client.WriteConfig(c.name+\"/latest\", msg, latestMsg); err != ErrWriteConflict {\n+\t\t\t// Success or a non-write-conflict error.\n+\t\t\treturn err\n+\t\t}\n+\t}\n+}\n+\n+const (\n+\tmsgPast = 1 + iota\n+\tmsgNow\n+\tmsgFuture\n+)\n+\n+// mergeLatestMem is like mergeLatest but is only concerned with\n+// updating the in-memory copy of the latest tree head (c.latest)\n+// not the configuration file.\n+// The when result explains when msg happened relative to our\n+// previous idea of c.latest:\n+// msgPast means msg was from before c.latest,\n+// msgNow means msg was exactly c.latest, and\n+// msgFuture means msg was from after c.latest, which has now been updated.\n+func (c *Conn) mergeLatestMem(msg []byte) (when int, err error) {\n+\tif len(msg) == 0 {\n+\t\t// Accept empty msg as the unsigned, empty timeline.\n+\t\tc.latestMu.Lock()\n+\t\tlatest := c.latest\n+\t\tc.latestMu.Unlock()\n+\t\tif latest.N == 0 {\n+\t\t\treturn msgNow, nil\n+\t\t}\n+\t\treturn msgPast, nil\n+\t}\n+\n+\tnote, err := note.Open(msg, c.verifiers)\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"reading tree note: %v\\nnote:\\n%s\", err, msg)\n+\t}\n+\ttree, err := tlog.ParseTree([]byte(note.Text))\n+\tif err != nil {\n+\t\treturn 0, fmt.Errorf(\"reading tree: %v\\ntree:\\n%s\", err, note.Text)\n+\t}\n+\n+\t// Other lookups may be calling mergeLatest with other heads,\n+\t// so c.latest is changing underfoot. We don't want to hold the\n+\t// c.mu lock during tile fetches, so loop trying to update c.latest.\n+\tc.latestMu.Lock()\n+\tlatest := c.latest\n+\tlatestMsg := c.latestMsg\n+\tc.latestMu.Unlock()\n+\n+\tfor {\n+\t\t// If the tree head looks old, check that it is on our timeline.\n+\t\tif tree.N <= latest.N {\n+\t\t\tif err := c.checkTrees(tree, msg, latest, latestMsg); err != nil {\n+\t\t\t\treturn 0, err\n+\t\t\t}\n+\t\t\tif tree.N < latest.N {\n+\t\t\t\treturn msgPast, nil\n+\t\t\t}\n+\t\t\treturn msgNow, nil\n+\t\t}\n+\n+\t\t// The tree head looks new. Check that we are on its timeline and try to move our timeline forward.\n+\t\tif err := c.checkTrees(latest, latestMsg, tree, msg); err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\n+\t\t// Install our msg if possible.\n+\t\t// Otherwise we will go around again.\n+\t\tc.latestMu.Lock()\n+\t\tinstalled := false\n+\t\tif c.latest == latest {\n+\t\t\tinstalled = true\n+\t\t\tc.latest = tree\n+\t\t\tc.latestMsg = msg\n+\t\t} else {\n+\t\t\tlatest = c.latest\n+\t\t\tlatestMsg = c.latestMsg\n+\t\t}\n+\t\tc.latestMu.Unlock()\n+\n+\t\tif installed {\n+\t\t\treturn msgFuture, nil\n+\t\t}\n+\t}\n+}\n+\n+// checkTrees checks that older (from olderNote) is contained in newer (from newerNote).\n+// If an error occurs, such as malformed data or a network problem, checkTrees returns that error.\n+// If on the other hand checkTrees finds evidence of misbehavior, it prepares a detailed\n+// message and calls log.Fatal.\n+func (c *Conn) checkTrees(older tlog.Tree, olderNote []byte, newer tlog.Tree, newerNote []byte) error {\n+\tthr := tlog.TileHashReader(newer, &c.tileReader)\n+\th, err := tlog.TreeHash(older.N, thr)\n+\tif err != nil {\n+\t\tif older.N == newer.N {\n+\t\t\treturn fmt.Errorf(\"checking tree#%d: %v\", older.N, err)\n+\t\t}\n+\t\treturn fmt.Errorf(\"checking tree#%d against tree#%d: %v\", older.N, newer.N, err)\n+\t}\n+\tif h == older.Hash {\n+\t\treturn nil\n+\t}\n+\n+\t// Detected a fork in the tree timeline.\n+\t// Start by reporting the inconsistent signed tree notes.\n+\tvar buf bytes.Buffer\n+\tfmt.Fprintf(&buf, \"SECURITY ERROR\\n\")\n+\tfmt.Fprintf(&buf, \"go.sum database server misbehavior detected!\\n\\n\")\n+\tindent := func(b []byte) []byte {\n+\t\treturn bytes.Replace(b, []byte(\"\\n\"), []byte(\"\\n\\t\"), -1)\n+\t}\n+\tfmt.Fprintf(&buf, \"old database:\\n\\t%s\\n\", indent(olderNote))\n+\tfmt.Fprintf(&buf, \"new database:\\n\\t%s\\n\", indent(newerNote))\n+\n+\t// The notes alone are not enough to prove the inconsistency.\n+\t// We also need to show that the newer note's tree hash for older.N\n+\t// does not match older.Hash. The consumer of this report could\n+\t// of course consult the server to try to verify the inconsistency,\n+\t// but we are holding all the bits we need to prove it right now,\n+\t// so we might as well print them and make the report not depend\n+\t// on the continued availability of the misbehaving server.\n+\t// Preparing this data only reuses the tiled hashes needed for\n+\t// tlog.TreeHash(older.N, thr) above, so assuming thr is caching tiles,\n+\t// there are no new access to the server here, and these operations cannot fail.\n+\tfmt.Fprintf(&buf, \"proof of misbehavior:\\n\\t%v\", h)\n+\tif p, err := tlog.ProveTree(newer.N, older.N, thr); err != nil {\n+\t\tfmt.Fprintf(&buf, \"\\tinternal error: %v\\n\", err)\n+\t} else if err := tlog.CheckTree(p, newer.N, newer.Hash, older.N, h); err != nil {\n+\t\tfmt.Fprintf(&buf, \"\\tinternal error: generated inconsistent proof\\n\")\n+\t} else {\n+\t\tfor _, h := range p {\n+\t\t\tfmt.Fprintf(&buf, \"\\n\\t%v\", h)\n+\t\t}\n+\t}\n+\tc.client.SecurityError(buf.String())\n+\treturn ErrSecurity\n+}\n+\n+// checkRecord checks that record #id's hash matches data.\n+func (c *Conn) checkRecord(id int64, data []byte) error {\n+\tc.latestMu.Lock()\n+\tlatest := c.latest\n+\tc.latestMu.Unlock()\n+\n+\tif id >= latest.N {\n+\t\treturn fmt.Errorf(\"cannot validate record %d in tree of size %d\", id, latest.N)\n+\t}\n+\thashes, err := tlog.TileHashReader(latest, &c.tileReader).ReadHashes([]int64{tlog.StoredHashIndex(0, id)})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif hashes[0] == tlog.RecordHash(data) {\n+\t\treturn nil\n+\t}\n+\treturn fmt.Errorf(\"cannot authenticate record data in server response\")\n+}\n+\n+// tileReader is a *Conn wrapper that implements tlog.TileReader.\n+// The separate type avoids exposing the ReadTiles and SaveTiles\n+// methods on Conn itself.\n+type tileReader struct {\n+\tc *Conn\n+}\n+\n+func (r *tileReader) Height() int {\n+\treturn r.c.tileHeight\n+}\n+\n+// ReadTiles reads and returns the requested tiles,\n+// either from the on-disk cache or the server.\n+func (r *tileReader) ReadTiles(tiles []tlog.Tile) ([][]byte, error) {\n+\t// Read all the tiles in parallel.\n+\tdata := make([][]byte, len(tiles))\n+\terrs := make([]error, len(tiles))\n+\tvar wg sync.WaitGroup\n+\tfor i, tile := range tiles {\n+\t\twg.Add(1)\n+\t\tgo func(i int, tile tlog.Tile) {\n+\t\t\tdefer wg.Done()\n+\t\t\tdata[i], errs[i] = r.c.readTile(tile)\n+\t\t}(i, tile)\n+\t}\n+\twg.Wait()\n+\n+\tfor _, err := range errs {\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t}\n+\n+\treturn data, nil\n+}\n+\n+// tileCacheKey returns the cache key for the tile.\n+func (c *Conn) tileCacheKey(tile tlog.Tile) string {\n+\treturn c.name + \"/\" + tile.Path()\n+}\n+\n+// tileRemotePath returns the remote path for the tile.\n+func (c *Conn) tileRemotePath(tile tlog.Tile) string {\n+\treturn \"/\" + tile.Path()\n+}\n+\n+// readTile reads a single tile, either from the on-disk cache or the server.\n+func (c *Conn) readTile(tile tlog.Tile) ([]byte, error) {\n+\ttype cached struct {\n+\t\tdata []byte\n+\t\terr  error\n+\t}\n+\n+\tresult := c.tileCache.Do(tile, func() interface{} {\n+\t\t// Try the requested tile in on-disk cache.\n+\t\tdata, err := c.client.ReadCache(c.tileCacheKey(tile))\n+\t\tif err == nil {\n+\t\t\tc.markTileSaved(tile)\n+\t\t\treturn cached{data, nil}\n+\t\t}\n+\n+\t\t// Try the full tile in on-disk cache (if requested tile not already full).\n+\t\t// We only save authenticated tiles to the on-disk cache,\n+\t\t// so the recreated prefix is equally authenticated.\n+\t\tfull := tile\n+\t\tfull.W = 1 << tile.H\n+\t\tif tile != full {\n+\t\t\tdata, err := c.client.ReadCache(c.tileCacheKey(full))\n+\t\t\tif err == nil {\n+\t\t\t\tc.markTileSaved(tile) // don't save tile later; we already have full\n+\t\t\t\treturn cached{data[:len(data)/full.W*tile.W], nil}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Try requested tile from server.\n+\t\tdata, err = c.client.ReadRemote(c.tileRemotePath(tile))\n+\t\tif err == nil {\n+\t\t\treturn cached{data, nil}\n+\t\t}\n+\n+\t\t// Try full tile on server.\n+\t\t// If the partial tile does not exist, it should be because\n+\t\t// the tile has been completed and only the complete one\n+\t\t// is available.\n+\t\tif tile != full {\n+\t\t\tdata, err := c.client.ReadRemote(c.tileRemotePath(full))\n+\t\t\tif err == nil {\n+\t\t\t\t// Note: We could save the full tile in the on-disk cache here,\n+\t\t\t\t// but we don't know if it is valid yet, and we will only find out\n+\t\t\t\t// about the partial data, not the full data. So let SaveTiles\n+\t\t\t\t// save the partial tile, and we'll just refetch the full tile later\n+\t\t\t\t// once we can validate more (or all) of it.\n+\t\t\t\treturn cached{data[:len(data)/full.W*tile.W], nil}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Nothing worked.\n+\t\t// Return the error from the server fetch for the requested (not full) tile.\n+\t\treturn cached{nil, err}\n+\t}).(cached)\n+\n+\treturn result.data, result.err\n+}\n+\n+// markTileSaved records that tile is already present in the on-disk cache,\n+// so that a future SaveTiles for that tile can be ignored.\n+func (c *Conn) markTileSaved(tile tlog.Tile) {\n+\tc.tileSavedMu.Lock()\n+\tc.tileSaved[tile] = true\n+\tc.tileSavedMu.Unlock()\n+}\n+\n+// SaveTiles saves the now validated tiles.\n+func (r *tileReader) SaveTiles(tiles []tlog.Tile, data [][]byte) {\n+\tc := r.c\n+\n+\t// Determine which tiles need saving.\n+\t// (Tiles that came from the cache need not be saved back.)\n+\tsave := make([]bool, len(tiles))\n+\tc.tileSavedMu.Lock()\n+\tfor i, tile := range tiles {\n+\t\tif !c.tileSaved[tile] {\n+\t\t\tsave[i] = true\n+\t\t\tc.tileSaved[tile] = true\n+\t\t}\n+\t}\n+\tc.tileSavedMu.Unlock()\n+\n+\tfor i, tile := range tiles {\n+\t\tif save[i] {\n+\t\t\t// If WriteCache fails here (out of disk space? i/o error?),\n+\t\t\t// c.tileSaved[tile] is still true and we will not try to write it again.\n+\t\t\t// Next time we run maybe we'll redownload it again and be\n+\t\t\t// more successful.\n+\t\t\tc.client.WriteCache(c.name+\"/\"+tile.Path(), data[i])\n+\t\t}\n+\t}\n+}"}, {"sha": "83a182adc559764c0c6e1868a0f6e7650e3bb44c", "filename": "libgo/go/cmd/go/internal/sumweb/client_test.go", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,460 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sumweb\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"strings\"\n+\t\"sync\"\n+\t\"testing\"\n+\n+\t\"cmd/go/internal/note\"\n+\t\"cmd/go/internal/tlog\"\n+)\n+\n+const (\n+\ttestName        = \"localhost.localdev/sumdb\"\n+\ttestVerifierKey = \"localhost.localdev/sumdb+00000c67+AcTrnkbUA+TU4heY3hkjiSES/DSQniBqIeQ/YppAUtK6\"\n+\ttestSignerKey   = \"PRIVATE+KEY+localhost.localdev/sumdb+00000c67+AXu6+oaVaOYuQOFrf1V59JK1owcFlJcHwwXHDfDGxSPk\"\n+)\n+\n+func TestConnLookup(t *testing.T) {\n+\ttc := newTestClient(t)\n+\ttc.mustHaveLatest(1)\n+\n+\t// Basic lookup.\n+\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0\", \"rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\")\n+\ttc.mustHaveLatest(3)\n+\n+\t// Everything should now be cached, both for the original package and its /go.mod.\n+\ttc.getOK = false\n+\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0\", \"rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\")\n+\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0/go.mod\", \"rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\")\n+\ttc.mustHaveLatest(3)\n+\ttc.getOK = true\n+\ttc.getTileOK = false // the cache has what we need\n+\n+\t// Lookup with multiple returned lines.\n+\ttc.mustLookup(\"rsc.io/quote\", \"v1.5.2\", \"rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=\\nrsc.io/quote v1.5.2 h2:xyzzy\")\n+\ttc.mustHaveLatest(3)\n+\n+\t// Lookup with need for !-encoding.\n+\t// rsc.io/Quote is the only record written after rsc.io/samper,\n+\t// so it is the only one that should need more tiles.\n+\ttc.getTileOK = true\n+\ttc.mustLookup(\"rsc.io/Quote\", \"v1.5.2\", \"rsc.io/Quote v1.5.2 h1:uppercase!=\")\n+\ttc.mustHaveLatest(4)\n+}\n+\n+func TestConnBadTiles(t *testing.T) {\n+\ttc := newTestClient(t)\n+\n+\tflipBits := func() {\n+\t\tfor url, data := range tc.remote {\n+\t\t\tif strings.Contains(url, \"/tile/\") {\n+\t\t\t\tfor i := range data {\n+\t\t\t\t\tdata[i] ^= 0x80\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Bad tiles in initial download.\n+\ttc.mustHaveLatest(1)\n+\tflipBits()\n+\t_, err := tc.conn.Lookup(\"rsc.io/sampler\", \"v1.3.0\")\n+\ttc.mustError(err, \"rsc.io/sampler@v1.3.0: initializing sumweb.Conn: checking tree#1: downloaded inconsistent tile\")\n+\tflipBits()\n+\ttc.newConn()\n+\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0\", \"rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\")\n+\n+\t// Bad tiles after initial download.\n+\tflipBits()\n+\t_, err = tc.conn.Lookup(\"rsc.io/Quote\", \"v1.5.2\")\n+\ttc.mustError(err, \"rsc.io/Quote@v1.5.2: checking tree#3 against tree#4: downloaded inconsistent tile\")\n+\tflipBits()\n+\ttc.newConn()\n+\ttc.mustLookup(\"rsc.io/Quote\", \"v1.5.2\", \"rsc.io/Quote v1.5.2 h1:uppercase!=\")\n+\n+\t// Bad starting tree hash looks like bad tiles.\n+\ttc.newConn()\n+\ttext := tlog.FormatTree(tlog.Tree{N: 1, Hash: tlog.Hash{}})\n+\tdata, err := note.Sign(&note.Note{Text: string(text)}, tc.signer)\n+\tif err != nil {\n+\t\ttc.t.Fatal(err)\n+\t}\n+\ttc.config[testName+\"/latest\"] = data\n+\t_, err = tc.conn.Lookup(\"rsc.io/sampler\", \"v1.3.0\")\n+\ttc.mustError(err, \"rsc.io/sampler@v1.3.0: initializing sumweb.Conn: checking tree#1: downloaded inconsistent tile\")\n+}\n+\n+func TestConnFork(t *testing.T) {\n+\ttc := newTestClient(t)\n+\ttc2 := tc.fork()\n+\n+\ttc.addRecord(\"rsc.io/pkg1@v1.5.2\", `rsc.io/pkg1 v1.5.2 h1:hash!=\n+`)\n+\ttc.addRecord(\"rsc.io/pkg1@v1.5.4\", `rsc.io/pkg1 v1.5.4 h1:hash!=\n+`)\n+\ttc.mustLookup(\"rsc.io/pkg1\", \"v1.5.2\", \"rsc.io/pkg1 v1.5.2 h1:hash!=\")\n+\n+\ttc2.addRecord(\"rsc.io/pkg1@v1.5.3\", `rsc.io/pkg1 v1.5.3 h1:hash!=\n+`)\n+\ttc2.addRecord(\"rsc.io/pkg1@v1.5.4\", `rsc.io/pkg1 v1.5.4 h1:hash!=\n+`)\n+\ttc2.mustLookup(\"rsc.io/pkg1\", \"v1.5.4\", \"rsc.io/pkg1 v1.5.4 h1:hash!=\")\n+\n+\tkey := \"/lookup/rsc.io/pkg1@v1.5.2\"\n+\ttc2.remote[key] = tc.remote[key]\n+\t_, err := tc2.conn.Lookup(\"rsc.io/pkg1\", \"v1.5.2\")\n+\ttc2.mustError(err, ErrSecurity.Error())\n+\n+\t/*\n+\t   SECURITY ERROR\n+\t   go.sum database server misbehavior detected!\n+\n+\t   old database:\n+\t   \tgo.sum database tree!\n+\t   \t5\n+\t   \tnWzN20+pwMt62p7jbv1/NlN95ePTlHijabv5zO/s36w=\n+\n+\t   \t\u2014 localhost.localdev/sumdb AAAMZ5/2FVAdMH58kmnz/0h299pwyskEbzDzoa2/YaPdhvLya4YWDFQQxu2TQb5GpwAH4NdWnTwuhILafisyf3CNbgg=\n+\n+\t   new database:\n+\t   \tgo.sum database tree\n+\t   \t6\n+\t   \twc4SkQt52o5W2nQ8To2ARs+mWuUJjss+sdleoiqxMmM=\n+\n+\t   \t\u2014 localhost.localdev/sumdb AAAMZ6oRNswlEZ6ZZhxrCvgl1MBy+nusq4JU+TG6Fe2NihWLqOzb+y2c2kzRLoCr4tvw9o36ucQEnhc20e4nA4Qc/wc=\n+\n+\t   proof of misbehavior:\n+\t   \tT7i+H/8ER4nXOiw4Bj0koZOkGjkxoNvlI34GpvhHhQg=\n+\t   \tNsuejv72de9hYNM5bqFv8rv3gm3zJQwv/DT/WNbLDLA=\n+\t   \tmOmqqZ1aI/lzS94oq/JSbj7pD8Rv9S+xDyi12BtVSHo=\n+\t   \t/7Aw5jVSMM9sFjQhaMg+iiDYPMk6decH7QLOGrL9Lx0=\n+\t*/\n+\n+\twants := []string{\n+\t\t\"SECURITY ERROR\",\n+\t\t\"go.sum database server misbehavior detected!\",\n+\t\t\"old database:\\n\\tgo.sum database tree\\n\\t5\\n\",\n+\t\t\"\u2014 localhost.localdev/sumdb AAAMZ5/2FVAd\",\n+\t\t\"new database:\\n\\tgo.sum database tree\\n\\t6\\n\",\n+\t\t\"\u2014 localhost.localdev/sumdb AAAMZ6oRNswl\",\n+\t\t\"proof of misbehavior:\\n\\tT7i+H/8ER4nXOiw4Bj0k\",\n+\t}\n+\ttext := tc2.security.String()\n+\tfor _, want := range wants {\n+\t\tif !strings.Contains(text, want) {\n+\t\t\tt.Fatalf(\"cannot find %q in security text:\\n%s\", want, text)\n+\t\t}\n+\t}\n+}\n+\n+func TestConnGONOSUMDB(t *testing.T) {\n+\ttc := newTestClient(t)\n+\ttc.conn.SetGONOSUMDB(\"p,*/q\")\n+\ttc.conn.Lookup(\"rsc.io/sampler\", \"v1.3.0\") // initialize before we turn off network\n+\ttc.getOK = false\n+\n+\tok := []string{\n+\t\t\"abc\",\n+\t\t\"a/p\",\n+\t\t\"pq\",\n+\t\t\"q\",\n+\t\t\"n/o/p/q\",\n+\t}\n+\tskip := []string{\n+\t\t\"p\",\n+\t\t\"p/x\",\n+\t\t\"x/q\",\n+\t\t\"x/q/z\",\n+\t}\n+\n+\tfor _, path := range ok {\n+\t\t_, err := tc.conn.Lookup(path, \"v1.0.0\")\n+\t\tif err == ErrGONOSUMDB {\n+\t\t\tt.Errorf(\"Lookup(%q): ErrGONOSUMDB, wanted failed actual lookup\", path)\n+\t\t}\n+\t}\n+\tfor _, path := range skip {\n+\t\t_, err := tc.conn.Lookup(path, \"v1.0.0\")\n+\t\tif err != ErrGONOSUMDB {\n+\t\t\tt.Errorf(\"Lookup(%q): %v, wanted ErrGONOSUMDB\", path, err)\n+\t\t}\n+\t}\n+}\n+\n+// A testClient is a self-contained client-side testing environment.\n+type testClient struct {\n+\tt          *testing.T // active test\n+\tconn       *Conn      // conn being tested\n+\ttileHeight int        // tile height to use (default 2)\n+\tgetOK      bool       // should tc.GetURL succeed?\n+\tgetTileOK  bool       // should tc.GetURL of tiles succeed?\n+\ttreeSize   int64\n+\thashes     []tlog.Hash\n+\tremote     map[string][]byte\n+\tsigner     note.Signer\n+\n+\t// mu protects config, cache, log, security\n+\t// during concurrent use of the exported methods\n+\t// by the conn itself (testClient is the Conn's Client,\n+\t// and the Client methods can both read and write these fields).\n+\t// Unexported methods invoked directly by the test\n+\t// (for example, addRecord) need not hold the mutex:\n+\t// for proper test execution those methods should only\n+\t// be called when the Conn is idle and not using its Client.\n+\t// Not holding the mutex in those methods ensures\n+\t// that if a mistake is made, go test -race will report it.\n+\t// (Holding the mutex would eliminate the race report but\n+\t// not the underlying problem.)\n+\t// Similarly, the get map is not protected by the mutex,\n+\t// because the Client methods only read it.\n+\tmu       sync.Mutex // prot\n+\tconfig   map[string][]byte\n+\tcache    map[string][]byte\n+\tsecurity bytes.Buffer\n+}\n+\n+// newTestClient returns a new testClient that will call t.Fatal on error\n+// and has a few records already available on the remote server.\n+func newTestClient(t *testing.T) *testClient {\n+\ttc := &testClient{\n+\t\tt:          t,\n+\t\ttileHeight: 2,\n+\t\tgetOK:      true,\n+\t\tgetTileOK:  true,\n+\t\tconfig:     make(map[string][]byte),\n+\t\tcache:      make(map[string][]byte),\n+\t\tremote:     make(map[string][]byte),\n+\t}\n+\n+\ttc.config[\"key\"] = []byte(testVerifierKey + \"\\n\")\n+\tvar err error\n+\ttc.signer, err = note.NewSigner(testSignerKey)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\ttc.newConn()\n+\n+\ttc.addRecord(\"rsc.io/quote@v1.5.2\", `rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=\n+rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=\n+rsc.io/quote v1.5.2 h2:xyzzy\n+`)\n+\n+\ttc.addRecord(\"golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c\", `golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=\n+golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+`)\n+\ttc.addRecord(\"rsc.io/sampler@v1.3.0\", `rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\n+rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n+`)\n+\ttc.config[testName+\"/latest\"] = tc.signTree(1)\n+\n+\ttc.addRecord(\"rsc.io/!quote@v1.5.2\", `rsc.io/Quote v1.5.2 h1:uppercase!=\n+`)\n+\treturn tc\n+}\n+\n+// newConn resets the Conn associated with tc.\n+// This clears any in-memory cache from the Conn\n+// but not tc's on-disk cache.\n+func (tc *testClient) newConn() {\n+\ttc.conn = NewConn(tc)\n+\ttc.conn.SetTileHeight(tc.tileHeight)\n+}\n+\n+// mustLookup does a lookup for path@vers and checks that the lines that come back match want.\n+func (tc *testClient) mustLookup(path, vers, want string) {\n+\ttc.t.Helper()\n+\tlines, err := tc.conn.Lookup(path, vers)\n+\tif err != nil {\n+\t\ttc.t.Fatal(err)\n+\t}\n+\tif strings.Join(lines, \"\\n\") != want {\n+\t\ttc.t.Fatalf(\"Lookup(%q, %q):\\n\\t%s\\nwant:\\n\\t%s\", path, vers, strings.Join(lines, \"\\n\\t\"), strings.Replace(want, \"\\n\", \"\\n\\t\", -1))\n+\t}\n+}\n+\n+// mustHaveLatest checks that the on-disk configuration\n+// for latest is a tree of size n.\n+func (tc *testClient) mustHaveLatest(n int64) {\n+\ttc.t.Helper()\n+\n+\tlatest := tc.config[testName+\"/latest\"]\n+\tlines := strings.Split(string(latest), \"\\n\")\n+\tif len(lines) < 2 || lines[1] != fmt.Sprint(n) {\n+\t\ttc.t.Fatalf(\"/latest should have tree %d, but has:\\n%s\", n, latest)\n+\t}\n+}\n+\n+// mustError checks that err's error string contains the text.\n+func (tc *testClient) mustError(err error, text string) {\n+\ttc.t.Helper()\n+\tif err == nil || !strings.Contains(err.Error(), text) {\n+\t\ttc.t.Fatalf(\"err = %v, want %q\", err, text)\n+\t}\n+}\n+\n+// fork returns a copy of tc.\n+// Changes made to the new copy or to tc are not reflected in the other.\n+func (tc *testClient) fork() *testClient {\n+\ttc2 := &testClient{\n+\t\tt:          tc.t,\n+\t\tgetOK:      tc.getOK,\n+\t\tgetTileOK:  tc.getTileOK,\n+\t\ttileHeight: tc.tileHeight,\n+\t\ttreeSize:   tc.treeSize,\n+\t\thashes:     append([]tlog.Hash{}, tc.hashes...),\n+\t\tsigner:     tc.signer,\n+\t\tconfig:     copyMap(tc.config),\n+\t\tcache:      copyMap(tc.cache),\n+\t\tremote:     copyMap(tc.remote),\n+\t}\n+\ttc2.newConn()\n+\treturn tc2\n+}\n+\n+func copyMap(m map[string][]byte) map[string][]byte {\n+\tm2 := make(map[string][]byte)\n+\tfor k, v := range m {\n+\t\tm2[k] = v\n+\t}\n+\treturn m2\n+}\n+\n+// ReadHashes is tc's implementation of tlog.HashReader, for use with\n+// tlog.TreeHash and so on.\n+func (tc *testClient) ReadHashes(indexes []int64) ([]tlog.Hash, error) {\n+\tvar list []tlog.Hash\n+\tfor _, id := range indexes {\n+\t\tlist = append(list, tc.hashes[id])\n+\t}\n+\treturn list, nil\n+}\n+\n+// addRecord adds a log record using the given (!-encoded) key and data.\n+func (tc *testClient) addRecord(key, data string) {\n+\ttc.t.Helper()\n+\n+\t// Create record, add hashes to log tree.\n+\tid := tc.treeSize\n+\ttc.treeSize++\n+\trec, err := tlog.FormatRecord(id, []byte(data))\n+\tif err != nil {\n+\t\ttc.t.Fatal(err)\n+\t}\n+\thashes, err := tlog.StoredHashesForRecordHash(id, tlog.RecordHash([]byte(data)), tc)\n+\tif err != nil {\n+\t\ttc.t.Fatal(err)\n+\t}\n+\ttc.hashes = append(tc.hashes, hashes...)\n+\n+\t// Create lookup result.\n+\ttc.remote[\"/lookup/\"+key] = append(rec, tc.signTree(tc.treeSize)...)\n+\n+\t// Create new tiles.\n+\ttiles := tlog.NewTiles(tc.tileHeight, id, tc.treeSize)\n+\tfor _, tile := range tiles {\n+\t\tdata, err := tlog.ReadTileData(tile, tc)\n+\t\tif err != nil {\n+\t\t\ttc.t.Fatal(err)\n+\t\t}\n+\t\ttc.remote[\"/\"+tile.Path()] = data\n+\t\t// TODO delete old partial tiles\n+\t}\n+}\n+\n+// signTree returns the signed head for the tree of the given size.\n+func (tc *testClient) signTree(size int64) []byte {\n+\th, err := tlog.TreeHash(size, tc)\n+\tif err != nil {\n+\t\ttc.t.Fatal(err)\n+\t}\n+\ttext := tlog.FormatTree(tlog.Tree{N: size, Hash: h})\n+\tdata, err := note.Sign(&note.Note{Text: string(text)}, tc.signer)\n+\tif err != nil {\n+\t\ttc.t.Fatal(err)\n+\t}\n+\treturn data\n+}\n+\n+// ReadRemote is for tc's implementation of Client.\n+func (tc *testClient) ReadRemote(path string) ([]byte, error) {\n+\t// No mutex here because only the Client should be running\n+\t// and the Client cannot change tc.get.\n+\tif !tc.getOK {\n+\t\treturn nil, fmt.Errorf(\"disallowed remote read %s\", path)\n+\t}\n+\tif strings.Contains(path, \"/tile/\") && !tc.getTileOK {\n+\t\treturn nil, fmt.Errorf(\"disallowed remote tile read %s\", path)\n+\t}\n+\n+\tdata, ok := tc.remote[path]\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"no remote path %s\", path)\n+\t}\n+\treturn data, nil\n+}\n+\n+// ReadConfig is for tc's implementation of Client.\n+func (tc *testClient) ReadConfig(file string) ([]byte, error) {\n+\ttc.mu.Lock()\n+\tdefer tc.mu.Unlock()\n+\n+\tdata, ok := tc.config[file]\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"no config %s\", file)\n+\t}\n+\treturn data, nil\n+}\n+\n+// WriteConfig is for tc's implementation of Client.\n+func (tc *testClient) WriteConfig(file string, old, new []byte) error {\n+\ttc.mu.Lock()\n+\tdefer tc.mu.Unlock()\n+\n+\tdata := tc.config[file]\n+\tif !bytes.Equal(old, data) {\n+\t\treturn ErrWriteConflict\n+\t}\n+\ttc.config[file] = new\n+\treturn nil\n+}\n+\n+// ReadCache is for tc's implementation of Client.\n+func (tc *testClient) ReadCache(file string) ([]byte, error) {\n+\ttc.mu.Lock()\n+\tdefer tc.mu.Unlock()\n+\n+\tdata, ok := tc.cache[file]\n+\tif !ok {\n+\t\treturn nil, fmt.Errorf(\"no cache %s\", file)\n+\t}\n+\treturn data, nil\n+}\n+\n+// WriteCache is for tc's implementation of Client.\n+func (tc *testClient) WriteCache(file string, data []byte) {\n+\ttc.mu.Lock()\n+\tdefer tc.mu.Unlock()\n+\n+\ttc.cache[file] = data\n+}\n+\n+// Log is for tc's implementation of Client.\n+func (tc *testClient) Log(msg string) {\n+\ttc.t.Log(msg)\n+}\n+\n+// SecurityError is for tc's implementation of Client.\n+func (tc *testClient) SecurityError(msg string) {\n+\ttc.mu.Lock()\n+\tdefer tc.mu.Unlock()\n+\n+\tfmt.Fprintf(&tc.security, \"%s\\n\", strings.TrimRight(msg, \"\\n\"))\n+}"}, {"sha": "d044a84f3a818425a173adc85cc4815db7881330", "filename": "libgo/go/cmd/go/internal/sumweb/encode.go", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// FS-safe encoding of module paths and versions.\n+// Copied from cmd/go/internal/module and unexported.\n+\n+package sumweb\n+\n+import (\n+\t\"fmt\"\n+\t\"unicode/utf8\"\n+)\n+\n+// Safe encodings\n+//\n+// Module paths appear as substrings of file system paths\n+// (in the download cache) and of web server URLs in the proxy protocol.\n+// In general we cannot rely on file systems to be case-sensitive,\n+// nor can we rely on web servers, since they read from file systems.\n+// That is, we cannot rely on the file system to keep rsc.io/QUOTE\n+// and rsc.io/quote separate. Windows and macOS don't.\n+// Instead, we must never require two different casings of a file path.\n+// Because we want the download cache to match the proxy protocol,\n+// and because we want the proxy protocol to be possible to serve\n+// from a tree of static files (which might be stored on a case-insensitive\n+// file system), the proxy protocol must never require two different casings\n+// of a URL path either.\n+//\n+// One possibility would be to make the safe encoding be the lowercase\n+// hexadecimal encoding of the actual path bytes. This would avoid ever\n+// needing different casings of a file path, but it would be fairly illegible\n+// to most programmers when those paths appeared in the file system\n+// (including in file paths in compiler errors and stack traces)\n+// in web server logs, and so on. Instead, we want a safe encoding that\n+// leaves most paths unaltered.\n+//\n+// The safe encoding is this:\n+// replace every uppercase letter with an exclamation mark\n+// followed by the letter's lowercase equivalent.\n+//\n+// For example,\n+// github.com/Azure/azure-sdk-for-go ->  github.com/!azure/azure-sdk-for-go.\n+// github.com/GoogleCloudPlatform/cloudsql-proxy -> github.com/!google!cloud!platform/cloudsql-proxy\n+// github.com/Sirupsen/logrus -> github.com/!sirupsen/logrus.\n+//\n+// Import paths that avoid upper-case letters are left unchanged.\n+// Note that because import paths are ASCII-only and avoid various\n+// problematic punctuation (like : < and >), the safe encoding is also ASCII-only\n+// and avoids the same problematic punctuation.\n+//\n+// Import paths have never allowed exclamation marks, so there is no\n+// need to define how to encode a literal !.\n+//\n+// Although paths are disallowed from using Unicode (see pathOK above),\n+// the eventual plan is to allow Unicode letters as well, to assume that\n+// file systems and URLs are Unicode-safe (storing UTF-8), and apply\n+// the !-for-uppercase convention. Note however that not all runes that\n+// are different but case-fold equivalent are an upper/lower pair.\n+// For example, U+004B ('K'), U+006B ('k'), and U+212A ('\u212a' for Kelvin)\n+// are considered to case-fold to each other. When we do add Unicode\n+// letters, we must not assume that upper/lower are the only case-equivalent pairs.\n+// Perhaps the Kelvin symbol would be disallowed entirely, for example.\n+// Or perhaps it would encode as \"!!k\", or perhaps as \"(212A)\".\n+//\n+// Also, it would be nice to allow Unicode marks as well as letters,\n+// but marks include combining marks, and then we must deal not\n+// only with case folding but also normalization: both U+00E9 ('\u00e9')\n+// and U+0065 U+0301 ('e' followed by combining acute accent)\n+// look the same on the page and are treated by some file systems\n+// as the same path. If we do allow Unicode marks in paths, there\n+// must be some kind of normalization to allow only one canonical\n+// encoding of any character used in an import path.\n+\n+// encodePath returns the safe encoding of the given module path.\n+// It fails if the module path is invalid.\n+func encodePath(path string) (encoding string, err error) {\n+\treturn encodeString(path)\n+}\n+\n+// encodeVersion returns the safe encoding of the given module version.\n+// Versions are allowed to be in non-semver form but must be valid file names\n+// and not contain exclamation marks.\n+func encodeVersion(v string) (encoding string, err error) {\n+\treturn encodeString(v)\n+}\n+\n+func encodeString(s string) (encoding string, err error) {\n+\thaveUpper := false\n+\tfor _, r := range s {\n+\t\tif r == '!' || r >= utf8.RuneSelf {\n+\t\t\t// This should be disallowed by CheckPath, but diagnose anyway.\n+\t\t\t// The correctness of the encoding loop below depends on it.\n+\t\t\treturn \"\", fmt.Errorf(\"internal error: inconsistency in EncodePath\")\n+\t\t}\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\thaveUpper = true\n+\t\t}\n+\t}\n+\n+\tif !haveUpper {\n+\t\treturn s, nil\n+\t}\n+\n+\tvar buf []byte\n+\tfor _, r := range s {\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\tbuf = append(buf, '!', byte(r+'a'-'A'))\n+\t\t} else {\n+\t\t\tbuf = append(buf, byte(r))\n+\t\t}\n+\t}\n+\treturn string(buf), nil\n+}\n+\n+// decodePath returns the module path of the given safe encoding.\n+// It fails if the encoding is invalid or encodes an invalid path.\n+func decodePath(encoding string) (path string, err error) {\n+\tpath, ok := decodeString(encoding)\n+\tif !ok {\n+\t\treturn \"\", fmt.Errorf(\"invalid module path encoding %q\", encoding)\n+\t}\n+\treturn path, nil\n+}\n+\n+// decodeVersion returns the version string for the given safe encoding.\n+// It fails if the encoding is invalid or encodes an invalid version.\n+// Versions are allowed to be in non-semver form but must be valid file names\n+// and not contain exclamation marks.\n+func decodeVersion(encoding string) (v string, err error) {\n+\tv, ok := decodeString(encoding)\n+\tif !ok {\n+\t\treturn \"\", fmt.Errorf(\"invalid version encoding %q\", encoding)\n+\t}\n+\treturn v, nil\n+}\n+\n+func decodeString(encoding string) (string, bool) {\n+\tvar buf []byte\n+\n+\tbang := false\n+\tfor _, r := range encoding {\n+\t\tif r >= utf8.RuneSelf {\n+\t\t\treturn \"\", false\n+\t\t}\n+\t\tif bang {\n+\t\t\tbang = false\n+\t\t\tif r < 'a' || 'z' < r {\n+\t\t\t\treturn \"\", false\n+\t\t\t}\n+\t\t\tbuf = append(buf, byte(r+'A'-'a'))\n+\t\t\tcontinue\n+\t\t}\n+\t\tif r == '!' {\n+\t\t\tbang = true\n+\t\t\tcontinue\n+\t\t}\n+\t\tif 'A' <= r && r <= 'Z' {\n+\t\t\treturn \"\", false\n+\t\t}\n+\t\tbuf = append(buf, byte(r))\n+\t}\n+\tif bang {\n+\t\treturn \"\", false\n+\t}\n+\treturn string(buf), true\n+}"}, {"sha": "9ed5e4a9a04bfb5dbc77b534c24c7e26e406bca7", "filename": "libgo/go/cmd/go/internal/sumweb/encode_test.go", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sumweb\n+\n+import \"testing\"\n+\n+var encodeTests = []struct {\n+\tpath string\n+\tenc  string // empty means same as path\n+}{\n+\t{path: \"ascii.com/abcdefghijklmnopqrstuvwxyz.-+/~_0123456789\"},\n+\t{path: \"github.com/GoogleCloudPlatform/omega\", enc: \"github.com/!google!cloud!platform/omega\"},\n+}\n+\n+func TestEncodePath(t *testing.T) {\n+\t// Check encodings.\n+\tfor _, tt := range encodeTests {\n+\t\tenc, err := encodePath(tt.path)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"encodePath(%q): unexpected error: %v\", tt.path, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\twant := tt.enc\n+\t\tif want == \"\" {\n+\t\t\twant = tt.path\n+\t\t}\n+\t\tif enc != want {\n+\t\t\tt.Errorf(\"encodePath(%q) = %q, want %q\", tt.path, enc, want)\n+\t\t}\n+\t}\n+}\n+\n+var badDecode = []string{\n+\t\"github.com/GoogleCloudPlatform/omega\",\n+\t\"github.com/!google!cloud!platform!/omega\",\n+\t\"github.com/!0google!cloud!platform/omega\",\n+\t\"github.com/!_google!cloud!platform/omega\",\n+\t\"github.com/!!google!cloud!platform/omega\",\n+}\n+\n+func TestDecodePath(t *testing.T) {\n+\t// Check invalid decodings.\n+\tfor _, bad := range badDecode {\n+\t\t_, err := decodePath(bad)\n+\t\tif err == nil {\n+\t\t\tt.Errorf(\"DecodePath(%q): succeeded, want error (invalid decoding)\", bad)\n+\t\t}\n+\t}\n+\n+\t// Check encodings.\n+\tfor _, tt := range encodeTests {\n+\t\tenc := tt.enc\n+\t\tif enc == \"\" {\n+\t\t\tenc = tt.path\n+\t\t}\n+\t\tpath, err := decodePath(enc)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"decodePath(%q): unexpected error: %v\", enc, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif path != tt.path {\n+\t\t\tt.Errorf(\"decodePath(%q) = %q, want %q\", enc, path, tt.path)\n+\t\t}\n+\t}\n+}"}, {"sha": "5050805f873b8462562fe704ee472466828051de", "filename": "libgo/go/cmd/go/internal/sumweb/server.go", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fserver.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,183 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package sumweb implements the HTTP protocols for serving or accessing a go.sum database.\n+package sumweb\n+\n+import (\n+\t\"context\"\n+\t\"internal/lazyregexp\"\n+\t\"net/http\"\n+\t\"os\"\n+\t\"strings\"\n+\n+\t\"cmd/go/internal/tlog\"\n+)\n+\n+// A Server provides the external operations\n+// (underlying database access and so on)\n+// needed to implement the HTTP server Handler.\n+type Server interface {\n+\t// NewContext returns the context to use for the request r.\n+\tNewContext(r *http.Request) (context.Context, error)\n+\n+\t// Signed returns the signed hash of the latest tree.\n+\tSigned(ctx context.Context) ([]byte, error)\n+\n+\t// ReadRecords returns the content for the n records id through id+n-1.\n+\tReadRecords(ctx context.Context, id, n int64) ([][]byte, error)\n+\n+\t// Lookup looks up a record by its associated key (\"module@version\"),\n+\t// returning the record ID.\n+\tLookup(ctx context.Context, key string) (int64, error)\n+\n+\t// ReadTileData reads the content of tile t.\n+\t// It is only invoked for hash tiles (t.L \u2265 0).\n+\tReadTileData(ctx context.Context, t tlog.Tile) ([]byte, error)\n+}\n+\n+// A Handler is the go.sum database server handler,\n+// which should be invoked to serve the paths listed in Paths.\n+// The calling code is responsible for initializing Server.\n+type Handler struct {\n+\tServer Server\n+}\n+\n+// Paths are the URL paths for which Handler should be invoked.\n+//\n+// Typically a server will do:\n+//\n+//\thandler := &sumweb.Handler{Server: srv}\n+//\tfor _, path := range sumweb.Paths {\n+//\t\thttp.HandleFunc(path, handler)\n+//\t}\n+//\n+var Paths = []string{\n+\t\"/lookup/\",\n+\t\"/latest\",\n+\t\"/tile/\",\n+}\n+\n+var modVerRE = lazyregexp.New(`^[^@]+@v[0-9]+\\.[0-9]+\\.[0-9]+(-[^@]*)?(\\+incompatible)?$`)\n+\n+func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n+\tctx, err := h.Server.NewContext(r)\n+\tif err != nil {\n+\t\thttp.Error(w, err.Error(), 500)\n+\t\treturn\n+\t}\n+\n+\tswitch {\n+\tdefault:\n+\t\thttp.NotFound(w, r)\n+\n+\tcase strings.HasPrefix(r.URL.Path, \"/lookup/\"):\n+\t\tmod := strings.TrimPrefix(r.URL.Path, \"/lookup/\")\n+\t\tif !modVerRE.MatchString(mod) {\n+\t\t\thttp.Error(w, \"invalid module@version syntax\", http.StatusBadRequest)\n+\t\t\treturn\n+\t\t}\n+\t\ti := strings.Index(mod, \"@\")\n+\t\tencPath, encVers := mod[:i], mod[i+1:]\n+\t\tpath, err := decodePath(encPath)\n+\t\tif err != nil {\n+\t\t\treportError(w, r, err)\n+\t\t\treturn\n+\t\t}\n+\t\tvers, err := decodeVersion(encVers)\n+\t\tif err != nil {\n+\t\t\treportError(w, r, err)\n+\t\t\treturn\n+\t\t}\n+\t\tid, err := h.Server.Lookup(ctx, path+\"@\"+vers)\n+\t\tif err != nil {\n+\t\t\treportError(w, r, err)\n+\t\t\treturn\n+\t\t}\n+\t\trecords, err := h.Server.ReadRecords(ctx, id, 1)\n+\t\tif err != nil {\n+\t\t\t// This should never happen - the lookup says the record exists.\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tif len(records) != 1 {\n+\t\t\thttp.Error(w, \"invalid record count returned by ReadRecords\", http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tmsg, err := tlog.FormatRecord(id, records[0])\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tsigned, err := h.Server.Signed(ctx)\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=UTF-8\")\n+\t\tw.Write(msg)\n+\t\tw.Write(signed)\n+\n+\tcase r.URL.Path == \"/latest\":\n+\t\tdata, err := h.Server.Signed(ctx)\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t\treturn\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=UTF-8\")\n+\t\tw.Write(data)\n+\n+\tcase strings.HasPrefix(r.URL.Path, \"/tile/\"):\n+\t\tt, err := tlog.ParseTilePath(r.URL.Path[1:])\n+\t\tif err != nil {\n+\t\t\thttp.Error(w, \"invalid tile syntax\", http.StatusBadRequest)\n+\t\t\treturn\n+\t\t}\n+\t\tif t.L == -1 {\n+\t\t\t// Record data.\n+\t\t\tstart := t.N << uint(t.H)\n+\t\t\trecords, err := h.Server.ReadRecords(ctx, start, int64(t.W))\n+\t\t\tif err != nil {\n+\t\t\t\treportError(w, r, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif len(records) != t.W {\n+\t\t\t\thttp.Error(w, \"invalid record count returned by ReadRecords\", http.StatusInternalServerError)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tvar data []byte\n+\t\t\tfor i, text := range records {\n+\t\t\t\tmsg, err := tlog.FormatRecord(start+int64(i), text)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+\t\t\t\t}\n+\t\t\t\tdata = append(data, msg...)\n+\t\t\t}\n+\t\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=UTF-8\")\n+\t\t\tw.Write(data)\n+\t\t\treturn\n+\t\t}\n+\n+\t\tdata, err := h.Server.ReadTileData(ctx, t)\n+\t\tif err != nil {\n+\t\t\treportError(w, r, err)\n+\t\t\treturn\n+\t\t}\n+\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n+\t\tw.Write(data)\n+\t}\n+}\n+\n+// reportError reports err to w.\n+// If it's a not-found, the reported error is 404.\n+// Otherwise it is an internal server error.\n+// The caller must only call reportError in contexts where\n+// a not-found err should be reported as 404.\n+func reportError(w http.ResponseWriter, r *http.Request, err error) {\n+\tif os.IsNotExist(err) {\n+\t\thttp.Error(w, err.Error(), http.StatusNotFound)\n+\t\treturn\n+\t}\n+\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n+}"}, {"sha": "cce86e7e9afc1117493c5c7a8e733cf70eeed411", "filename": "libgo/go/cmd/go/internal/sumweb/test.go", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Ftest.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package sumweb\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"net/http\"\n+\t\"strings\"\n+\t\"sync\"\n+\n+\t\"cmd/go/internal/note\"\n+\t\"cmd/go/internal/tlog\"\n+)\n+\n+// NewTestServer constructs a new TestServer\n+// that will sign its tree with the given signer key\n+// (see cmd/go/internal/note)\n+// and fetch new records as needed by calling gosum.\n+func NewTestServer(signer string, gosum func(path, vers string) ([]byte, error)) *TestServer {\n+\treturn &TestServer{signer: signer, gosum: gosum}\n+}\n+\n+// A TestServer is an in-memory implementation of Server for testing.\n+type TestServer struct {\n+\tsigner string\n+\tgosum  func(path, vers string) ([]byte, error)\n+\n+\tmu      sync.Mutex\n+\thashes  testHashes\n+\trecords [][]byte\n+\tlookup  map[string]int64\n+}\n+\n+// testHashes implements tlog.HashReader, reading from a slice.\n+type testHashes []tlog.Hash\n+\n+func (h testHashes) ReadHashes(indexes []int64) ([]tlog.Hash, error) {\n+\tvar list []tlog.Hash\n+\tfor _, id := range indexes {\n+\t\tlist = append(list, h[id])\n+\t}\n+\treturn list, nil\n+}\n+\n+func (s *TestServer) NewContext(r *http.Request) (context.Context, error) {\n+\treturn nil, nil\n+}\n+\n+func (s *TestServer) Signed(ctx context.Context) ([]byte, error) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tsize := int64(len(s.records))\n+\th, err := tlog.TreeHash(size, s.hashes)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\ttext := tlog.FormatTree(tlog.Tree{N: size, Hash: h})\n+\tsigner, err := note.NewSigner(s.signer)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn note.Sign(&note.Note{Text: string(text)}, signer)\n+}\n+\n+func (s *TestServer) ReadRecords(ctx context.Context, id, n int64) ([][]byte, error) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\tvar list [][]byte\n+\tfor i := int64(0); i < n; i++ {\n+\t\tif id+i >= int64(len(s.records)) {\n+\t\t\treturn nil, fmt.Errorf(\"missing records\")\n+\t\t}\n+\t\tlist = append(list, s.records[id+i])\n+\t}\n+\treturn list, nil\n+}\n+\n+func (s *TestServer) Lookup(ctx context.Context, key string) (int64, error) {\n+\ts.mu.Lock()\n+\tid, ok := s.lookup[key]\n+\ts.mu.Unlock()\n+\tif ok {\n+\t\treturn id, nil\n+\t}\n+\n+\t// Look up module and compute go.sum lines.\n+\ti := strings.Index(key, \"@\")\n+\tif i < 0 {\n+\t\treturn 0, fmt.Errorf(\"invalid lookup key %q\", key)\n+\t}\n+\tpath, vers := key[:i], key[i+1:]\n+\tdata, err := s.gosum(path, vers)\n+\tif err != nil {\n+\t\treturn 0, err\n+\t}\n+\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\t// We ran the fetch without the lock.\n+\t// If another fetch happened and committed, use it instead.\n+\tid, ok = s.lookup[key]\n+\tif ok {\n+\t\treturn id, nil\n+\t}\n+\n+\t// Add record.\n+\tid = int64(len(s.records))\n+\ts.records = append(s.records, data)\n+\tif s.lookup == nil {\n+\t\ts.lookup = make(map[string]int64)\n+\t}\n+\ts.lookup[key] = id\n+\thashes, err := tlog.StoredHashesForRecordHash(id, tlog.RecordHash([]byte(data)), s.hashes)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\ts.hashes = append(s.hashes, hashes...)\n+\n+\treturn id, nil\n+}\n+\n+func (s *TestServer) ReadTileData(ctx context.Context, t tlog.Tile) ([]byte, error) {\n+\ts.mu.Lock()\n+\tdefer s.mu.Unlock()\n+\n+\treturn tlog.ReadTileData(t, s.hashes)\n+}"}, {"sha": "eed2d437c99efd15b0396ce17151dcf920d6e097", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -102,7 +102,10 @@ package test passes, go test prints only the final 'ok' summary\n line. If a package test fails, go test prints the full test output.\n If invoked with the -bench or -v flag, go test prints the full\n output even for passing package tests, in order to display the\n-requested benchmark results or verbose logging.\n+requested benchmark results or verbose logging. After the package\n+tests for all of the listed packages finish, and their output is\n+printed, go test prints a final 'FAIL' status if any package test\n+has failed.\n \n In package list mode only, go test caches successful package test\n results to avoid unnecessary repeated running of tests. When the\n@@ -484,10 +487,14 @@ var (\n \tpkgArgs          []string\n \tpkgs             []*load.Package\n \n-\ttestKillTimeout = 10 * time.Minute\n-\ttestCacheExpire time.Time // ignore cached test results before this time\n+\ttestActualTimeout = 10 * time.Minute                  // actual timeout which is passed to tests\n+\ttestKillTimeout   = testActualTimeout + 1*time.Minute // backup alarm\n+\ttestCacheExpire   time.Time                           // ignore cached test results before this time\n )\n \n+// testVetExplicit records whether testVetFlags were set by an explicit -vet.\n+var testVetExplicit = false\n+\n // testVetFlags is the list of flags to pass to vet when invoked automatically during go test.\n var testVetFlags = []string{\n \t// TODO(rsc): Decide which tests are enabled by default.\n@@ -500,6 +507,7 @@ var testVetFlags = []string{\n \t// \"-cgocall\",\n \t// \"-composites\",\n \t// \"-copylocks\",\n+\t\"-errorsas\",\n \t// \"-httpresponse\",\n \t// \"-lostcancel\",\n \t// \"-methods\",\n@@ -514,15 +522,22 @@ var testVetFlags = []string{\n \t// \"-unusedresult\",\n }\n \n+func testCmdUsage() {\n+\tfmt.Fprintf(os.Stderr, \"usage: %s\\n\", CmdTest.UsageLine)\n+\tfmt.Fprintf(os.Stderr, \"Run 'go help %s' and 'go help %s' for details.\\n\", CmdTest.LongName(), HelpTestflag.LongName())\n+\tos.Exit(2)\n+}\n+\n func runTest(cmd *base.Command, args []string) {\n \tmodload.LoadTests = true\n \n-\tpkgArgs, testArgs = testFlags(cmd.Usage, args)\n+\tpkgArgs, testArgs = testFlags(testCmdUsage, args)\n \n \twork.FindExecCmd() // initialize cached result\n \n \twork.BuildInit()\n \twork.VetFlags = testVetFlags\n+\twork.VetExplicit = testVetExplicit\n \n \tpkgs = load.PackagesForBuild(pkgArgs)\n \tif len(pkgs) == 0 {\n@@ -546,13 +561,21 @@ func runTest(cmd *base.Command, args []string) {\n \t// the test wedges with a goroutine spinning and its background\n \t// timer does not get a chance to fire.\n \tif dt, err := time.ParseDuration(testTimeout); err == nil && dt > 0 {\n-\t\ttestKillTimeout = dt + 1*time.Minute\n+\t\ttestActualTimeout = dt\n+\t\ttestKillTimeout = testActualTimeout + 1*time.Minute\n \t} else if err == nil && dt == 0 {\n \t\t// An explicit zero disables the test timeout.\n+\t\t// No timeout is passed to tests.\n \t\t// Let it have one century (almost) before we kill it.\n+\t\ttestActualTimeout = -1\n \t\ttestKillTimeout = 100 * 365 * 24 * time.Hour\n \t}\n \n+\t// Pass timeout to tests if it exists.\n+\tif testActualTimeout > 0 {\n+\t\ttestArgs = append(testArgs, \"-test.timeout=\"+testActualTimeout.String())\n+\t}\n+\n \t// show passing test output (after buffering) with -v flag.\n \t// must buffer because tests are running in parallel, and\n \t// otherwise the output will get mixed.\n@@ -640,7 +663,7 @@ func runTest(cmd *base.Command, args []string) {\n \t\t}\n \n \t\t// Select for coverage all dependencies matching the testCoverPaths patterns.\n-\t\tfor _, p := range load.GetTestPackageList(pkgs) {\n+\t\tfor _, p := range load.TestPackageList(pkgs) {\n \t\t\thaveMatch := false\n \t\t\tfor i := range testCoverPaths {\n \t\t\t\tif match[i](p) {\n@@ -720,7 +743,7 @@ func runTest(cmd *base.Command, args []string) {\n \t}\n \n \t// Ultimately the goal is to print the output.\n-\troot := &work.Action{Mode: \"go test\", Deps: prints}\n+\troot := &work.Action{Mode: \"go test\", Func: printExitStatus, Deps: prints}\n \n \t// Force the printing of results to happen in order,\n \t// one at a time.\n@@ -754,7 +777,7 @@ func ensureImport(p *load.Package, pkg string) {\n \t\t}\n \t}\n \n-\tp1 := load.LoadPackage(pkg, &load.ImportStack{})\n+\tp1 := load.LoadImportWithFlags(pkg, p.Dir, p, &load.ImportStack{}, nil, 0)\n \tif p1.Error != nil {\n \t\tbase.Fatalf(\"load %s: %v\", pkg, p1.Error)\n \t}\n@@ -792,7 +815,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \t\t\tDeclVars: declareCoverVars,\n \t\t}\n \t}\n-\tpmain, ptest, pxtest, err := load.GetTestPackagesFor(p, cover)\n+\tpmain, ptest, pxtest, err := load.TestPackagesFor(p, cover)\n \tif err != nil {\n \t\treturn nil, nil, nil, err\n \t}\n@@ -820,7 +843,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \tif !cfg.BuildN {\n \t\t// writeTestmain writes _testmain.go,\n \t\t// using the test description gathered in t.\n-\t\tif err := ioutil.WriteFile(testDir+\"_testmain.go\", *pmain.Internal.TestmainGo, 0666); err != nil {\n+\t\tif err := ioutil.WriteFile(testDir+\"_testmain.go\", pmain.Internal.TestmainGo, 0666); err != nil {\n \t\t\treturn nil, nil, nil, err\n \t\t}\n \t}\n@@ -1617,3 +1640,14 @@ func builderNoTest(b *work.Builder, a *work.Action) error {\n \tfmt.Fprintf(stdout, \"?   \\t%s\\t[no test files]\\n\", a.Package.ImportPath)\n \treturn nil\n }\n+\n+// printExitStatus is the action for printing the exit status\n+func printExitStatus(b *work.Builder, a *work.Action) error {\n+\tif !testJSON && len(pkgArgs) != 0 {\n+\t\tif base.GetExitStatus() != 0 {\n+\t\t\tfmt.Println(\"FAIL\")\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\treturn nil\n+}"}, {"sha": "138e1f9d2a25f435917166700c76c87a79e92755", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13", "patch": "@@ -202,6 +202,7 @@ func testFlags(usage func(), args []string) (packageNames, passToTest []string)\n \t\t}\n \t}\n \n+\ttestVetExplicit = testVetList != \"\"\n \tif testVetList != \"\" && testVetList != \"off\" {\n \t\tif strings.Contains(testVetList, \"=\") {\n \t\t\tbase.Fatalf(\"-vet argument cannot contain equal signs\")"}, {"sha": "c2d9aebe79a0975baec6c4224b4dae1f72cc4394", "filename": "libgo/go/cmd/go/internal/tlog/ct_test.go", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fct_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fct_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fct_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "65c71644baf6ad7d2bff69f1da6ce0a7f7b77383", "filename": "libgo/go/cmd/go/internal/tlog/note.go", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a32d6d214362c91874b2474c036514c4ccebb51e", "filename": "libgo/go/cmd/go/internal/tlog/note_test.go", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "694d89cdf261fdd37b95c6815e04787ce4b25a2a", "filename": "libgo/go/cmd/go/internal/tlog/tile.go", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftile.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "6703656b19fa92460af377f10b86f26044918ff2", "filename": "libgo/go/cmd/go/internal/tlog/tlog.go", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "584e728c1bb558c8252300277daae0ce1a1c0c8d", "filename": "libgo/go/cmd/go/internal/tlog/tlog_test.go", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "930eecb63f1c4955c842e6e7d10a936e77783254", "filename": "libgo/go/cmd/go/internal/tool/tool.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftool%2Ftool.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "55da960c025e6168af111c44c09444ce2fbec413", "filename": "libgo/go/cmd/go/internal/version/exe.go", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fexe.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "857548c7ed8d41ddde7399242487527064723613", "filename": "libgo/go/cmd/go/internal/version/version.go", "status": "modified", "additions": 179, "deletions": 6, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fversion%2Fversion.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "327b761c3cd6bf68858804b3c17a409acf24c95b", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "cd0e19d3ffd1990226a3d41d3bfe66d8bbd18c61", "filename": "libgo/go/cmd/go/internal/web/api.go", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "781702100a09e8b596ce9d3a9095e7dc88ada578", "filename": "libgo/go/cmd/go/internal/web/bootstrap.go", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fbootstrap.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "e31ad71d4d982eee2e35baad162cb98007c16a1f", "filename": "libgo/go/cmd/go/internal/web/file_test.go", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b790fe9916e8c64772e73d5d62a5e06519fb09f1", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "modified", "additions": 157, "deletions": 62, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "1dc6f1b076fb46be26b3b3d2c6dea5915f1cebe2", "filename": "libgo/go/cmd/go/internal/web/security.go", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fsecurity.go?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd"}, {"sha": "146c51f0aecfca50ab5f2fdfd26087e27146864c", "filename": "libgo/go/cmd/go/internal/web/url.go", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "bd243e591a9c796e60df2e61e6fd6dcecffc8716", "filename": "libgo/go/cmd/go/internal/web/url_other.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b4a74d94b93e0508ff8c134121e9e027fde84c15", "filename": "libgo/go/cmd/go/internal/web/url_other_test.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "8f462f53259b5c50ce27e828312ee41dbe32d4b2", "filename": "libgo/go/cmd/go/internal/web/url_test.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "2a65ec83f60e8e40ef2a19d75ef871e7a6856b52", "filename": "libgo/go/cmd/go/internal/web/url_windows.go", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_windows.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "06386a038988ca9a3bc34dcf5b7b072e1bdaf9ca", "filename": "libgo/go/cmd/go/internal/web/url_windows_test.go", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_windows_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_windows_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_windows_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "64934f1d506dbfa4142550a57656a8816dec75c4", "filename": "libgo/go/cmd/go/internal/web2/web.go", "status": "removed", "additions": 0, "deletions": 299, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb2%2Fweb.go?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd"}, {"sha": "94b20a33ffc7d5813abe1b21e2df7575e30b33d5", "filename": "libgo/go/cmd/go/internal/webtest/test.go", "status": "removed", "additions": 0, "deletions": 314, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwebtest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwebtest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwebtest%2Ftest.go?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd"}, {"sha": "eabac6bd14e1412210decc8a50e5b2110bdb92ea", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 104, "deletions": 44, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "ed5a149da355f82fb4e0d6219b8b3c11f19ca255", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 78, "deletions": 11, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "55e1eea25ba08aaccc0df7b95d962010c65543d4", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "1f6d1e8e779a3160165796e2adc9e43962cae690", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "8e92f9461cf19d84f03b3a8034a7d6bfefdeb3b7", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 184, "deletions": 130, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "86322946a6113484ce2a61c3b00b9eacd0d4121b", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "87b3f5facd95c0099357fcc303df168121416d2c", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "35d3a505cc7d362607932d3c9decff4e51cb8479", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "0d8da21ae388793379568c4b510fee06baeb372f", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "fd8caeab4ecf7dd0286ba26df65fb15dc05cc440", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "16bdb6209f1b8580c9b620008e1db04aa9f0362d", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "e94e82bd5bd9909d935e5df67302c5444a40e63b", "filename": "libgo/go/cmd/go/note_test.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fnote_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "6919d32184720df84b9b2c1ea97e43976aae2c14", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 211, "deletions": 21, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "4dcb4b4e0d5dc0a8f0d19bbdaa51224abe529b81", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 163, "deletions": 74, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d9c3aab9c49630306a61607398f21b451283b39c", "filename": "libgo/go/cmd/go/testdata/addmod.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Faddmod.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a4e5507f2cd92ca6aba8cb9cde5769654f068665", "filename": "libgo/go/cmd/go/testdata/flag_test.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fflag_test.go?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d7bf6471b7cdeb6bac3dca177dcb5ffef57901ef", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_a_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_a_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_a_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_a_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "92190d8ac177a11226b09c435bae3a182727453d", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_a_v1.1.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_a_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_a_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_a_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d42b8aab164536e3e5a157dd605f8bfc4d097662", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_b_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_b_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_b_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_b_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "664818474ce815cb4bc882914c8c5d1e2ffa2263", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_b_v1.1.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_b_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_b_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_b_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "9c717cb0e6efcf0fba2b30642a02aa54dee67b89", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_c_v1.0.0.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "da19ebd9ec9060cb16d1062699232979b7dd9ed1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_badchain_c_v1.1.0.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_badchain_c_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "88d50e5bbab8d6578a693e6865674b20b0936f1d", "filename": "libgo/go/cmd/go/testdata/mod/example.com_downgrade_v2.0.0.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_downgrade_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_downgrade_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_downgrade_v2.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a4d665ff1be4f0dab02b1bf4d340538a4d3216e9", "filename": "libgo/go/cmd/go/testdata/mod/example.com_downgrade_v2_v2.0.1.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_downgrade_v2_v2.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_downgrade_v2_v2.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_downgrade_v2_v2.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "7d9d1303a9043c2a9c7cf6015e2fc66d8da3f226", "filename": "libgo/go/cmd/go/testdata/mod/example.com_invalidpath_v1_v1.0.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_invalidpath_v1_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_invalidpath_v1_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_invalidpath_v1_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "25bd3d9d8fa2e802965bb851d45453dc2cbf4be5", "filename": "libgo/go/cmd/go/testdata/mod/example.com_latemigrate_v2_v2.0.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_latemigrate_v2_v2.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_latemigrate_v2_v2.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_latemigrate_v2_v2.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "be427a3185d693b901302fc0405ebfb4f0079dfb", "filename": "libgo/go/cmd/go/testdata/mod/example.com_latemigrate_v2_v2.0.1.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_latemigrate_v2_v2.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_latemigrate_v2_v2.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_latemigrate_v2_v2.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "15f3f69557d1ddf54ae15c86d6fc88e3832f10e1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_missingpkg_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_missingpkg_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_missingpkg_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_missingpkg_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "44580fe4cbe3900ba21de34bc9562950b3cc1e08", "filename": "libgo/go/cmd/go/testdata/mod/example.com_missingpkg_v1.0.1-beta.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_missingpkg_v1.0.1-beta.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_missingpkg_v1.0.1-beta.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_missingpkg_v1.0.1-beta.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "90f1459803944054313dec639e713e95f9316773", "filename": "libgo/go/cmd/go/testdata/mod/example.com_nest_sub_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_sub_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_sub_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_sub_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "593caf1d90abe48bd1d9476644ac0bab517971af", "filename": "libgo/go/cmd/go/testdata/mod/example.com_nest_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "5a01550fd5d075167d7bfce1413bcf2dad1a090b", "filename": "libgo/go/cmd/go/testdata/mod/example.com_nest_v1.1.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_nest_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "829065df9fb96989d2f9aa70e220f1fb75750396", "filename": "libgo/go/cmd/go/testdata/mod/example.com_newcycle_a_v1.0.0.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_a_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_a_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_a_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a03f4b49fd5ec51f0c5196f2390163f0d90840ca", "filename": "libgo/go/cmd/go/testdata/mod/example.com_newcycle_a_v1.0.1.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_a_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_a_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_a_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "ff9e1f5ea5fa6e769071f37a022f7797cc817253", "filename": "libgo/go/cmd/go/testdata/mod/example.com_newcycle_b_v1.0.0.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_b_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_b_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_newcycle_b_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "aa5febf71056fd75dd32f9c05ade375026e36cb0", "filename": "libgo/go/cmd/go/testdata/mod/example.com_noroot_v1.0.0.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_noroot_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_noroot_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_noroot_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "9b93717c84f48e36a7b812c6f5c7d3b9b20db1a1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_noroot_v1.0.1.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_noroot_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_noroot_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_noroot_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "259774d542554c675a3c83f056d0be544a1f2b94", "filename": "libgo/go/cmd/go/testdata/mod/example.com_notags_v0.0.0-20190507143103-cc8cbe209b64.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_notags_v0.0.0-20190507143103-cc8cbe209b64.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_notags_v0.0.0-20190507143103-cc8cbe209b64.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_notags_v0.0.0-20190507143103-cc8cbe209b64.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "bae8b13d470e24ae28b88f93dd3b489f2a287f13", "filename": "libgo/go/cmd/go/testdata/mod/example.com_printversion_v0.1.0.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v0.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "246741821aff1be4ecc82d789a0f61c5f0947cfb", "filename": "libgo/go/cmd/go/testdata/mod/example.com_printversion_v1.0.0.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_printversion_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "047ceb68c5b55caa73e98695cdb48a22754b1bcf", "filename": "libgo/go/cmd/go/testdata/mod/example.com_pseudoupgrade_v0.0.0-20190430073000-30950c05d534.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.0.0-20190430073000-30950c05d534.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.0.0-20190430073000-30950c05d534.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.0.0-20190430073000-30950c05d534.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "7ddb0dc724d5ba0ceb1695cab5b10dff222fc173", "filename": "libgo/go/cmd/go/testdata/mod/example.com_pseudoupgrade_v0.1.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b3f48bbdab6cec1112aed97240b9e5aa879bd566", "filename": "libgo/go/cmd/go/testdata/mod/example.com_pseudoupgrade_v0.1.1-0.20190429073117-b5426c86b553.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.1.1-0.20190429073117-b5426c86b553.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.1.1-0.20190429073117-b5426c86b553.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_pseudoupgrade_v0.1.1-0.20190429073117-b5426c86b553.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "22e36b993affb711fb3dec2d25eb8fed287305eb", "filename": "libgo/go/cmd/go/testdata/mod/example.com_tools_v1.0.0.txt", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_tools_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_tools_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_tools_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "5e1c5c815ed73a30f35200301f86c0040d27b40e", "filename": "libgo/go/cmd/go/testdata/mod/example.com_usemissingpre_v1.0.0.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_usemissingpre_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_usemissingpre_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_usemissingpre_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d8c45b527e9d504591ef9ec2881ac7472620cf66", "filename": "libgo/go/cmd/go/testdata/mod/example.com_version_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "3bfdb0e4cdcc2fad4895b0d05aac7b312810c85d", "filename": "libgo/go/cmd/go/testdata/mod/example.com_version_v1.0.1.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "8109a9acc9e53e84d9ce5714a6a3d013b4e37449", "filename": "libgo/go/cmd/go/testdata/mod/example.com_version_v1.1.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_version_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "c2709c161e169124637b6e20687ebad339582ddd", "filename": "libgo/go/cmd/go/testdata/mod/github.com_dmitshur-test_modtest5_v0.0.0-20190619020302-197a620e0c9a.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.0.0-20190619020302-197a620e0c9a.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.0.0-20190619020302-197a620e0c9a.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.0.0-20190619020302-197a620e0c9a.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "22e47f378ef91398d5c903453bd199c8de54209d", "filename": "libgo/go/cmd/go/testdata/mod/github.com_dmitshur-test_modtest5_v0.5.0-alpha.0.20190619023908-3da23a9deb9e.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.5.0-alpha.0.20190619023908-3da23a9deb9e.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.5.0-alpha.0.20190619023908-3da23a9deb9e.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.5.0-alpha.0.20190619023908-3da23a9deb9e.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "4f088ccd2ca3f6063196e54ef4bcc810a1ac8bb5", "filename": "libgo/go/cmd/go/testdata/mod/github.com_dmitshur-test_modtest5_v0.5.0-alpha.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.5.0-alpha.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.5.0-alpha.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fgithub.com_dmitshur-test_modtest5_v0.5.0-alpha.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "40616c668a8a74ce6bdcb1102a66e4d6a3c0493d", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_depofdirectpatch_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_depofdirectpatch_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_depofdirectpatch_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_depofdirectpatch_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "e075028656e2691feccc438337b67de71d875a00", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_depofdirectpatch_v1.0.1.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_depofdirectpatch_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_depofdirectpatch_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_depofdirectpatch_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "1e775fb89bc9ac1664a7cd980ea0abaf099ffe71", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_direct_v1.0.0.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "64912b7b439b6868a480395ffc923c4dd3a14d1f", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_direct_v1.0.1.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "406e3b9f628a76d6ea4c10568cfdc3d11095b82d", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_direct_v1.1.0.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_direct_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "ea7f5e2d8d0c8fa841f716c06604de327ce3b65f", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_indirect_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "8c6cf8e7bf94732bfe178d118c4ac4ce0ce0e022", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_indirect_v1.0.1.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "f7229d417aa8c209f9bc00942891caaa5635441a", "filename": "libgo/go/cmd/go/testdata/mod/patch.example.com_indirect_v1.1.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.1.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.1.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fpatch.example.com_indirect_v1.1.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d62db2627a0510da485bedf9826c919989d13c2c", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badsum_v1.0.0.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badsum_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badsum_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badsum_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "5fea50a01d73c53444616b2e856c6c36acf82dfc", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badsum_v1.0.1.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badsum_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badsum_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badsum_v1.0.1.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "07a38fa6d7d7492fd365c426c43ae2877a7dd544", "filename": "libgo/go/cmd/go/testdata/mod/rsc.io_badzip_v1.0.0.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badzip_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badzip_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Frsc.io_badzip_v1.0.0.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "66ab8515c33e7838b31f4c4a3b63260a967ad67a", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "397904efaa8ab0fc9ebc826d32e8001b985ffb9f", "filename": "libgo/go/cmd/go/testdata/script/binary_only.txt", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbinary_only.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920ea3b8ba3164b61ac9490dfdfceb6936eda6dd/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbinary_only.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbinary_only.txt?ref=920ea3b8ba3164b61ac9490dfdfceb6936eda6dd"}, {"sha": "db3ac253672bff0880bb32f2e2a64651e9ed1f58", "filename": "libgo/go/cmd/go/testdata/script/bug.txt", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "c93ca932cab5064aac1626df7f80d6fd4f1991f8", "filename": "libgo/go/cmd/go/testdata/script/build_GOTMPDIR.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_GOTMPDIR.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "13a3ba226aa851bdbaefc76f25b05fc2e4b38368", "filename": "libgo/go/cmd/go/testdata/script/build_acl_windows.txt", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_acl_windows.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_acl_windows.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_acl_windows.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "64b391f9aa4651dcac1826be4a74f95f7bc9d2f7", "filename": "libgo/go/cmd/go/testdata/script/build_cache_compile.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_compile.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_compile.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_compile.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "0cbf16a923b8b2c129a9a7149afc761755e1f207", "filename": "libgo/go/cmd/go/testdata/script/build_cache_gomips.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_gomips.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_gomips.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_gomips.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b9c740ac10ea23acdb23901b3d9a113081e5d169", "filename": "libgo/go/cmd/go/testdata/script/build_cache_link.txt", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_link.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_link.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_link.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "89e3ff0f1ec377116f1b1010783587a9240d1fbe", "filename": "libgo/go/cmd/go/testdata/script/build_cache_output.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_output.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "39367ae3809e3656db6e4e1d0e4648d7c58e80ea", "filename": "libgo/go/cmd/go/testdata/script/build_cache_trimpath.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "1d4926d979095b8b370bfb76a27895f6f63b8537", "filename": "libgo/go/cmd/go/testdata/script/build_multi_main.txt", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_multi_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_multi_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_multi_main.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "1059cad45c7a2bbfeef28a56c69d70fc1a78bbfc", "filename": "libgo/go/cmd/go/testdata/script/build_nocache.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_nocache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_nocache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_nocache.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "0716bcd56a591e9c161ff04052ac75fddb4f6f8d", "filename": "libgo/go/cmd/go/testdata/script/build_relative_pkgdir.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_relative_pkgdir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_relative_pkgdir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_relative_pkgdir.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "3e98a67b813e1174924678765f80336c1c1f0eea", "filename": "libgo/go/cmd/go/testdata/script/build_relative_tmpdir.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_relative_tmpdir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_relative_tmpdir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_relative_tmpdir.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "da1b65f06c849788fbf7b7b73a50ee0f40979892", "filename": "libgo/go/cmd/go/testdata/script/build_runtime_gcflags.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_runtime_gcflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_runtime_gcflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_runtime_gcflags.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "f785b0cb9ec9d112937db49dff6d540694ff333e", "filename": "libgo/go/cmd/go/testdata/script/build_trimpath.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "0e07ba63823e52b12502e2ffcf3a0969ee8b207b", "filename": "libgo/go/cmd/go/testdata/script/cache_unix.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcache_unix.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcache_unix.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcache_unix.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "4fb5ccab04e1813617bd8c6b0c5980f3a96c2843", "filename": "libgo/go/cmd/go/testdata/script/cgo_syso_issue29253.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_syso_issue29253.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_syso_issue29253.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcgo_syso_issue29253.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "dd7846462e153a98b9c9d0f2c120ec40a0cbfc3a", "filename": "libgo/go/cmd/go/testdata/script/clean_testcache.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_testcache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_testcache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fclean_testcache.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "c3bc67df534687b7823a4244e8b9a612e976d70e", "filename": "libgo/go/cmd/go/testdata/script/cover_atomic_pkgall.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_atomic_pkgall.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_atomic_pkgall.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_atomic_pkgall.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "9927c3069070fdeed6712717bc0c222039b07e06", "filename": "libgo/go/cmd/go/testdata/script/cover_pkgall_runtime.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_runtime.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_runtime.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_runtime.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "38d6439fb1717eb06abf022ec71ed6a8d9d3a0e6", "filename": "libgo/go/cmd/go/testdata/script/cpu_profile_twice.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcpu_profile_twice.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcpu_profile_twice.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcpu_profile_twice.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "695cc83f3d7f9b027880028690106ea6349e3d91", "filename": "libgo/go/cmd/go/testdata/script/env_write.txt", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "5cb35f0dac35f92851ecc768d39e7e5aea55fb36", "filename": "libgo/go/cmd/go/testdata/script/fileline.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffileline.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffileline.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffileline.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "dce8e39715d81e2fbfad6ee782ec673fda5594e1", "filename": "libgo/go/cmd/go/testdata/script/gcflags_patterns.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgcflags_patterns.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b71cc7fe010a1e182342d70ed003aced170fee88", "filename": "libgo/go/cmd/go/testdata/script/get_404_meta.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_404_meta.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "3449a0c2c82995fc54786f672fb2caf1f4a3b8f9", "filename": "libgo/go/cmd/go/testdata/script/get_brace.txt", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_brace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_brace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_brace.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "6757f9dce344f502cc532563ee2b0c954fd653f6", "filename": "libgo/go/cmd/go/testdata/script/get_dotfiles.txt", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dotfiles.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dotfiles.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_dotfiles.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a83b17672d4c1ded8935e5ad1acfa7c6062c9785", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_redirect.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "e520957359ca124caf8c5f6327a9e2133ed6c5ad", "filename": "libgo/go/cmd/go/testdata/script/get_tilde.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_tilde.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_tilde.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_tilde.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d3b82bdf250dd0b39f8e14d5dcd46a680a7ea016", "filename": "libgo/go/cmd/go/testdata/script/get_unicode.txt", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_unicode.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_unicode.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_unicode.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "98854c72ad262b3d360760429415000ee2053520", "filename": "libgo/go/cmd/go/testdata/script/get_with_git_trace.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_with_git_trace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_with_git_trace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_with_git_trace.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "fac6d807202285e365ff343b2b18bfd62105c5d9", "filename": "libgo/go/cmd/go/testdata/script/goflags.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a0a41a50de328db92f7d6985cf476a120eb49666", "filename": "libgo/go/cmd/go/testdata/script/gopath_std_vendor.txt", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_std_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_std_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_std_vendor.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "9752ede2e372830eabca429fdbc1ae67fa16d0d9", "filename": "libgo/go/cmd/go/testdata/script/help.txt", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fhelp.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "dc85eb8ceffaf0d343488291c9768c54226c400f", "filename": "libgo/go/cmd/go/testdata/script/install_cleans_build.txt", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cleans_build.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cleans_build.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cleans_build.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "81649e234ff38b21cb92353830fe2cd404188e1d", "filename": "libgo/go/cmd/go/testdata/script/install_cmd_gobin.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cmd_gobin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cmd_gobin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cmd_gobin.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "60aeed689f30dcc9f3d4c155e10d514688873434", "filename": "libgo/go/cmd/go/testdata/script/install_cross_gobin.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "14a6c8611e32d5421276b71c2a2bb975e80eb8db", "filename": "libgo/go/cmd/go/testdata/script/install_rebuild_gopath.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_gopath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_gopath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_gopath.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "5db3778d8eb8b929997e623e8036e01f82a95500", "filename": "libgo/go/cmd/go/testdata/script/install_rebuild_removed.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_removed.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_removed.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_rebuild_removed.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "11336594d3596ba8a203bdc1099d90d63bc054b1", "filename": "libgo/go/cmd/go/testdata/script/linkname.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flinkname.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flinkname.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flinkname.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b8f9d586f303566ad1c84ca0c680e8deb69c7175", "filename": "libgo/go/cmd/go/testdata/script/list_bad_import.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_bad_import.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "bb4faa366f823c6bb929430930898fea8de23b41", "filename": "libgo/go/cmd/go/testdata/script/list_compiled_imports.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_compiled_imports.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_compiled_imports.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_compiled_imports.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d450fc95549fa999cf6b21fece61ecc97f3a83ee", "filename": "libgo/go/cmd/go/testdata/script/list_find.txt", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_find.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_find.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_find.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "52ee6028f5bd2a25dc259e24f4647c3afd39ce2a", "filename": "libgo/go/cmd/go/testdata/script/list_importmap.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_importmap.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_importmap.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_importmap.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "6ab1bd1674c99433106d200602c0cb5a897b5722", "filename": "libgo/go/cmd/go/testdata/script/list_std.txt", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_std.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "49069bd2135eae367b6f4b5f50b707c92a7c9c0b", "filename": "libgo/go/cmd/go/testdata/script/list_tags.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_tags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_tags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_tags.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "263892ba63f901b559ac5c4088956763243c6397", "filename": "libgo/go/cmd/go/testdata/script/list_test_e.txt", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_e.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_e.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_e.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "a174b5e9ad282c5e6f3145d1a611588113765609", "filename": "libgo/go/cmd/go/testdata/script/list_test_err.txt", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_err.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "b2a6bc45f9ef0f55cc5996144b63b606991e1d97", "filename": "libgo/go/cmd/go/testdata/script/list_test_imports.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_imports.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_imports.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_imports.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "16b98f4a37509cb3962928ca98846ef513f5c3fc", "filename": "libgo/go/cmd/go/testdata/script/list_test_non_go_files.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_non_go_files.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_non_go_files.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_test_non_go_files.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "32f94c53038084994e351fa5f157c16955ddbf65", "filename": "libgo/go/cmd/go/testdata/script/mod_alt_goroot.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_alt_goroot.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_alt_goroot.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_alt_goroot.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "fe1d65794afb7205cbd23bfd048bb8d377ecf7a6", "filename": "libgo/go/cmd/go/testdata/script/mod_auth.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "ae1d605e1f2f1227bbdea8c70c55f69941b6074f", "filename": "libgo/go/cmd/go/testdata/script/mod_build_tags.txt", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_tags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_tags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_tags.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "d1d74de10c22b1b75cd79a237b8e6c3b36db519c", "filename": "libgo/go/cmd/go/testdata/script/mod_build_versioned.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_versioned.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_versioned.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_versioned.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "01fbc381e043b2ae6e543eb50d64f7d5e533d752", "filename": "libgo/go/cmd/go/testdata/script/mod_clean_cache.txt", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_clean_cache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_clean_cache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_clean_cache.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}, {"sha": "e03e5e5edbeda9a5245e2b9b6beccc1850eb9900", "filename": "libgo/go/cmd/go/testdata/script/mod_concurrent.txt", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_concurrent.txt?ref=aa8901e9bb0399d2c16f988ba2fe46eb0c0c5d13"}]}