{"sha": "75118c2eadecda75a2b9573fb6985fe841505ad0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUxMThjMmVhZGVjZGE3NWEyYjk1NzNmYjY5ODVmZTg0MTUwNWFkMA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:45:48Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-04T00:45:48Z"}, "message": "re PR fortran/43829 (Scalarization of reductions)\n\n\tPR fortran/43829\n\t* gfortran.dg/function_optimize_7.f90: Disable sum inlining.\n\t* gfortran.dg/inline_sum_1.f90: New.\n\t* gfortran.dg/inline_sum_2.f90: New.\n\t* gfortran.dg/inline_sum_bounds_check_1.f90: New.\n\t* gfortran.dg/inline_sum_bounds_check_2.f90: New.\n\t* gfortran.dg/inline_product_1.f90: New.\n\nFrom-SVN: r180922", "tree": {"sha": "f5cd1357e69abe603fc4d625b36dbead6c7fcf9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5cd1357e69abe603fc4d625b36dbead6c7fcf9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75118c2eadecda75a2b9573fb6985fe841505ad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75118c2eadecda75a2b9573fb6985fe841505ad0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75118c2eadecda75a2b9573fb6985fe841505ad0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75118c2eadecda75a2b9573fb6985fe841505ad0/comments", "author": null, "committer": null, "parents": [{"sha": "02750c15b628ef6a426a08ca06b7ea5754bdca18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02750c15b628ef6a426a08ca06b7ea5754bdca18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02750c15b628ef6a426a08ca06b7ea5754bdca18"}], "stats": {"total": 296, "additions": 295, "deletions": 1}, "files": [{"sha": "24366e971d08f4783d5383d9c3e04e908171b4fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -1,3 +1,13 @@\n+2011-11-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/43829\n+\t* gfortran.dg/function_optimize_7.f90: Disable sum inlining.\n+\t* gfortran.dg/inline_sum_1.f90: New.\n+\t* gfortran.dg/inline_sum_2.f90: New.\n+\t* gfortran.dg/inline_sum_bounds_check_1.f90: New.\n+\t* gfortran.dg/inline_sum_bounds_check_2.f90: New.\n+\t* gfortran.dg/inline_product_1.f90: New.\n+\n 2011-11-03  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/50933"}, {"sha": "e0c404b6a2a9fd79ceebf66c92044f02d624ef79", "filename": "gcc/testsuite/gfortran.dg/function_optimize_7.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_optimize_7.f90?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -12,6 +12,7 @@ subroutine xx(n, m, a, b, c, d, x, z, i, s_in, s_out)\n   real, intent(out) :: z\n   character(60) :: line\n   real, external :: ext_func\n+  integer :: one = 1\n   interface\n      elemental function element(x)\n        real, intent(in) :: x\n@@ -33,7 +34,7 @@ end function elem_impure\n   z = element(x) + element(x)\n   i = mypure(x) - mypure(x)\n   z = elem_impure(x) - elem_impure(x)\n-  s_out = sum(s_in,1) + 3.14 / sum(s_in,1) ! { dg-warning \"Creating array temporary\" }\n+  s_out = sum(s_in,one) + 3.14 / sum(s_in,one) ! { dg-warning \"Creating array temporary\" }\n end subroutine xx\n ! { dg-final { scan-tree-dump-times \"matmul_r4\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"__builtin_sinf\" 1 \"original\" } }"}, {"sha": "72c096bff4abc6924ebd8858220d746a37a99eed", "filename": "gcc/testsuite/gfortran.dg/inline_product_1.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_product_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_product_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_product_1.f90?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+! { dg-options \"-Warray-temporaries -O -fdump-tree-original\" }\n+!\n+! PR fortran/43829\n+! Scalarization of reductions.\n+! Test that product is properly inlined.\n+\n+! For more extended tests, see inline_sum_1.f90\n+\n+  implicit none\n+\n+\n+  integer :: i\n+\n+  integer, parameter :: q = 2\n+  integer, parameter :: nx=3, ny=2*q, nz=5\n+  integer, parameter, dimension(nx,ny,nz) :: p  = &\n+        & reshape ((/ (i, i=1,size(p)) /), shape(p))\n+\n+\n+  integer, dimension(nx,ny,nz) :: a\n+  integer, dimension(nx,   nz) :: ay\n+\n+  a  = p\n+\n+  ay = product(a,2)\n+\n+end\n+! { dg-final { scan-tree-dump-times \"struct array._integer\\\\(kind=4\\\\) atmp\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"struct array\\[^\\\\n\\]*atmp\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_product_\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "4538e5e117f6195170d1277e6553c1ee9fe5c676", "filename": "gcc/testsuite/gfortran.dg/inline_sum_1.f90", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_1.f90?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -0,0 +1,194 @@\n+! { dg-do compile }\n+! { dg-options \"-Warray-temporaries -O -fdump-tree-original\" }\n+!\n+! PR fortran/43829\n+! Scalarization of reductions.\n+! Test that sum is properly inlined.\n+\n+! This is the compile time test only; for the runtime test see inline_sum_2.f90\n+! We can't test for temporaries on the run time test directly, as it tries\n+! several optimization options among which -Os, and sum inlining is disabled\n+! at -Os.\n+\n+\n+  implicit none\n+\n+\n+  integer :: i, j, k\n+\n+  integer, parameter :: q = 2\n+  integer, parameter :: nx=3, ny=2*q, nz=5\n+  integer, parameter, dimension(nx,ny,nz) :: p  = &\n+        & reshape ((/ (i**2, i=1,size(p)) /), shape(p))\n+\n+  integer, parameter, dimension(   ny,nz) :: px = &\n+        & reshape ((/ (( &\n+        &        nx*(  nx*j+nx*ny*k+1)*(  nx*j+nx*ny*k+1+      (nx-1)) &\n+        &       +      nx*(nx-1)*(2*nx-1)/6, &\n+        &       j=0,ny-1), k=0,nz-1) /), shape(px))\n+\n+  integer, parameter, dimension(nx,   nz) :: py = &\n+        & reshape ((/ (( &\n+        &        ny*(i     +nx*ny*k+1)*(i     +nx*ny*k+1+nx   *(ny-1)) &\n+        &       +(nx   )**2*ny*(ny-1)*(2*ny-1)/6, &\n+        &       i=0,nx-1), k=0,nz-1) /), shape(py))\n+\n+  integer, parameter, dimension(nx,ny   ) :: pz = &\n+        & reshape ((/ (( &\n+        &        nz*(i+nx*j        +1)*(i+nx*j        +1+nx*ny*(nz-1)) &\n+        &       +(nx*ny)**2*nz*(nz-1)*(2*nz-1)/6, &\n+        &       i=0,nx-1), j=0,ny-1) /), shape(pz))\n+\n+\n+  integer, dimension(nx,ny,nz) :: a\n+  integer, dimension(   ny,nz) :: ax\n+  integer, dimension(nx,   nz) :: ay\n+  integer, dimension(nx,ny   ) :: az\n+\n+  logical, dimension(nx,ny,nz) :: m, true\n+\n+\n+  integer, dimension(nx,ny) :: b\n+\n+  integer, dimension(nx,nx) :: onesx\n+  integer, dimension(ny,ny) :: onesy\n+  integer, dimension(nz,nz) :: onesz\n+\n+\n+  a    = p\n+  m    = reshape((/ ((/ .true., .false. /), i=1,size(m)/2) /), shape(m))\n+  true = reshape((/ (.true., i=1,size(true)) /), shape(true))\n+\n+  onesx = reshape((/ ((1, j=1,i),(0,j=1,nx-i),i=1,size(onesx,2)) /), shape(onesx))\n+  onesy = reshape((/ ((1, j=1,i),(0,j=1,ny-i),i=1,size(onesy,2)) /), shape(onesy))\n+  onesz = reshape((/ ((1, j=1,i),(0,j=1,nz-i),i=1,size(onesz,2)) /), shape(onesz))\n+\n+  ! Correct results in simple cases\n+  ax = sum(a,1)\n+  if (any(ax /= px)) call abort\n+\n+  ay = sum(a,2)\n+  if (any(ay /= py)) call abort\n+\n+  az = sum(a,3)\n+  if (any(az /= pz)) call abort\n+\n+\n+  ! Masks work\n+  if (any(sum(a,1,.false.) /= 0))                    call abort\n+  if (any(sum(a,2,.true.)  /= py))                   call abort\n+  if (any(sum(a,3,m)       /= merge(pz,0,m(:,:,1)))) call abort\n+  if (any(sum(a,2,m)       /= merge(sum(a(:, ::2,:),2),&\n+                                    sum(a(:,2::2,:),2),&\n+                                    m(:,1,:))))      call abort\n+\n+\n+  ! It works too with array constructors ...\n+  if (any(sum(                                      &\n+        reshape((/ (i*i,i=1,size(a)) /), shape(a)), &\n+        1,                                          &\n+        true) /= ax)) call abort\n+\n+  ! ... and with vector subscripts\n+  if (any(sum(               &\n+        a((/ (i,i=1,nx) /),  &\n+          (/ (i,i=1,ny) /),  &\n+          (/ (i,i=1,nz) /)), &\n+        1) /= ax)) call abort\n+\n+  if (any(sum(                &\n+        a(sum(onesx(:,:),1),  & ! unnecessary { dg-warning \"Creating array temporary\" }\n+          sum(onesy(:,:),1),  & ! unnecessary { dg-warning \"Creating array temporary\" }\n+          sum(onesz(:,:),1)), & ! unnecessary { dg-warning \"Creating array temporary\" }\n+        1) /= ax)) call abort\n+\n+\n+  ! Nested sums work\n+  if (sum(sum(sum(a,1),1),1) /= sum(a)) call abort\n+  if (sum(sum(sum(a,1),2),1) /= sum(a)) call abort\n+  if (sum(sum(sum(a,3),1),1) /= sum(a)) call abort\n+  if (sum(sum(sum(a,3),2),1) /= sum(a)) call abort\n+\n+  if (any(sum(sum(a,1),1) /= sum(sum(a,2),1))) call abort\n+  if (any(sum(sum(a,1),2) /= sum(sum(a,3),1))) call abort\n+  if (any(sum(sum(a,2),2) /= sum(sum(a,3),2))) call abort\n+\n+\n+  ! Temps are unavoidable here (function call's argument or result)\n+  ax = sum(neid3(a),1)          ! { dg-warning \"Creating array temporary\" }\n+  ! Sums as part of a bigger expr work\n+  if (any(1+sum(eid(a),1)+ax+sum( &\n+        neid3(a), &            ! { dg-warning \"Creating array temporary\" }\n+        1)+1  /= 3*ax+2))        call abort\n+  if (any(1+eid(sum(a,2))+ay+ &\n+        neid2( &               ! { dg-warning \"Creating array temporary\" }\n+        sum(a,2) &             ! { dg-warning \"Creating array temporary\" }\n+        )+1  /= 3*ay+2))        call abort\n+  if (any(sum(eid(sum(a,3))+az+2* &\n+        neid2(az) &            ! { dg-warning \"Creating array temporary\" }\n+        ,1)+1 /= 4*sum(az,1)+1)) call abort\n+\n+  if (any(sum(transpose(sum(a,1)),1)+sum(az,1) /= sum(ax,2)+sum(sum(a,3),1))) call abort\n+\n+\n+  ! Creates a temp when needed. \n+  a(1,:,:) = sum(a,1)                   ! unnecessary { dg-warning \"Creating array temporary\" }\n+  if (any(a(1,:,:) /= ax)) call abort\n+\n+  b = p(:,:,1)\n+  call set(b(2:,1), sum(b(:nx-1,:),2))  ! { dg-warning \"Creating array temporary\" }\n+  if (any(b(2:,1) /= ay(1:nx-1,1))) call abort\n+\n+  b = p(:,:,1)\n+  call set(b(:,1), sum(b,2))            ! unnecessary { dg-warning \"Creating array temporary\" }\n+  if (any(b(:,1) /= ay(:,1))) call abort\n+\n+  b = p(:,:,1)\n+  call tes(sum(eid(b(:nx-1,:)),2), b(2:,1))  ! { dg-warning \"Creating array temporary\" }\n+  if (any(b(2:,1) /= ay(1:nx-1,1))) call abort\n+\n+  b = p(:,:,1)\n+  call tes(eid(sum(b,2)), b(:,1))            ! unnecessary { dg-warning \"Creating array temporary\" }\n+  if (any(b(:,1) /= ay(:,1))) call abort\n+\n+contains\n+\n+  elemental function eid (x)\n+    integer, intent(in) :: x\n+    integer             :: eid\n+\n+    eid = x\n+  end function eid\n+\n+  function neid2 (x)\n+    integer, intent(in) :: x(:,:)\n+    integer             :: neid2(size(x,1),size(x,2))\n+\n+    neid2 = x\n+  end function neid2\n+\n+  function neid3 (x)\n+    integer, intent(in) :: x(:,:,:)\n+    integer             :: neid3(size(x,1),size(x,2),size(x,3))\n+\n+    neid3 = x\n+  end function neid3\n+\n+  elemental subroutine set (o, i)\n+    integer, intent(in)  :: i\n+    integer, intent(out) :: o\n+\n+    o = i\n+  end subroutine set\n+\n+  elemental subroutine tes (i, o)\n+    integer, intent(in)  :: i\n+    integer, intent(out) :: o\n+\n+    o = i\n+  end subroutine tes\n+end\n+! { dg-final { scan-tree-dump-times \"struct array._integer\\\\(kind=4\\\\) atmp\" 13 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"struct array\\[^\\\\n\\]*atmp\" 13 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_sum_\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "0b7c60ad9e91ff4fa2d20e27fb29d30d8e7ab7dc", "filename": "gcc/testsuite/gfortran.dg/inline_sum_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_2.f90?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+\n+! PR fortran/43829 \n+! Scalarization of reductions.\n+! Test that inlined sum is correct.\n+\n+! We can't check for the absence of temporary arrays generated on the run-time\n+! testcase, as inlining is disabled at -Os, so it will fail in that case.\n+! Thus, the test is splitted into two independant files, one checking for\n+! the absence of temporaries, and one (this one) checking that the code\n+! generated remains valid at all optimization levels.\n+include 'inline_sum_1.f90'"}, {"sha": "39984683d4bf23d94ab69dfb7e0b58fd6c584c07", "filename": "gcc/testsuite/gfortran.dg/inline_sum_bounds_check_1.f90", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_bounds_check_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_bounds_check_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_bounds_check_1.f90?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -0,0 +1,22 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+\n+      integer, parameter :: nx = 3, ny = 4\n+\n+      integer :: i, j, too_big\n+\n+      integer, parameter, dimension(nx,ny) :: p = &\n+        reshape((/ (i*i, i=1,size(p)) /), shape(p))\n+\n+      integer, dimension(nx,ny) :: a\n+\n+      integer, dimension(:), allocatable :: b\n+\n+      allocate(b(nx))\n+\n+      a = p\n+      too_big = ny + 1\n+\n+      b = sum(a(:,1:too_big),2)\n+      end\n+! { dg-shouldfail \"outside of expected range\" }"}, {"sha": "8de80fdc9f6471a8ebb44e5a1030578ff25cb3a9", "filename": "gcc/testsuite/gfortran.dg/inline_sum_bounds_check_2.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_bounds_check_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75118c2eadecda75a2b9573fb6985fe841505ad0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_bounds_check_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_sum_bounds_check_2.f90?ref=75118c2eadecda75a2b9573fb6985fe841505ad0", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+\n+      integer, parameter :: nx = 3, ny = 4\n+\n+      integer :: i, j, too_big\n+\n+      integer, parameter, dimension(nx,ny) :: p = &\n+        reshape((/ (i*i, i=1,size(p)) /), shape(p))\n+\n+      integer, dimension(nx,ny) :: a\n+\n+      integer, dimension(:), allocatable :: c\n+\n+\n+      allocate(c(ny))\n+\n+      a = p\n+      too_big = nx + 1\n+\n+      c = sum(a(1:too_big,:),2)\n+      end\n+! { dg-shouldfail \"outside of expected range\" }"}]}