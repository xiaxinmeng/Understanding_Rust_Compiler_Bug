{"sha": "d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE0YzYwYWQyNmY1N2VkNmQzMjE4MGE5NmNjMjdjN2JmMWQ3ZjViMg==", "commit": {"author": {"name": "Will Schmidt", "email": "will_schmidt@vnet.ibm.com", "date": "2017-09-19T13:42:48Z"}, "committer": {"name": "Will Schmidt", "email": "willschm@gcc.gnu.org", "date": "2017-09-19T13:42:48Z"}, "message": "rs6000.c (rs6000_gimple_fold_builtin): Add handling for early folding of vector loads (ALTIVEC_BUILTIN_LVX_*).\n\n[gcc]\n\n2017-09-19  Will Schmidt  <will_schmidt@vnet.ibm.com>\n\n    * config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Add handling\n    for early folding of vector loads (ALTIVEC_BUILTIN_LVX_*).\n    * config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n    Remove obsoleted code for handling ALTIVEC_BUILTIN_VEC_LD.\n\nFrom-SVN: r252975", "tree": {"sha": "2231680c5bbeace8f32ac41319b46a171a02bb17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2231680c5bbeace8f32ac41319b46a171a02bb17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/comments", "author": {"login": "willschm", "id": 44359, "node_id": "MDQ6VXNlcjQ0MzU5", "avatar_url": "https://avatars.githubusercontent.com/u/44359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willschm", "html_url": "https://github.com/willschm", "followers_url": "https://api.github.com/users/willschm/followers", "following_url": "https://api.github.com/users/willschm/following{/other_user}", "gists_url": "https://api.github.com/users/willschm/gists{/gist_id}", "starred_url": "https://api.github.com/users/willschm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willschm/subscriptions", "organizations_url": "https://api.github.com/users/willschm/orgs", "repos_url": "https://api.github.com/users/willschm/repos", "events_url": "https://api.github.com/users/willschm/events{/privacy}", "received_events_url": "https://api.github.com/users/willschm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "81b29ad80a7fb41b5534c1ae45565e1c353dbf0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81b29ad80a7fb41b5534c1ae45565e1c353dbf0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81b29ad80a7fb41b5534c1ae45565e1c353dbf0e"}], "stats": {"total": 123, "additions": 51, "deletions": 72}, "files": [{"sha": "d2a7c14a8731fbb620080827c62ca8af94937bae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "patch": "@@ -1,3 +1,10 @@\n+2017-09-19  Will Schmidt  <will_schmidt@vnet.ibm.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_gimple_fold_builtin): Add handling\n+\tfor early folding of vector loads (ALTIVEC_BUILTIN_LVX_*).\n+\t* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):\n+\tRemove obsoleted code for handling ALTIVEC_BUILTIN_VEC_LD.\n+\n 2017-09-19  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/82244"}, {"sha": "a49db972e912935735f78e40734d2f8f751caa07", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 2, "deletions": 72, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "patch": "@@ -6472,85 +6472,15 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       return stmt;\n     }\n \n-  /* Expand vec_ld into an expression that masks the address and\n-     performs the load.  We need to expand this early to allow\n+  /* Expand vec_st into an expression that masks the address and\n+     performs the store.  We need to expand this early to allow\n      the best aliasing, as by the time we get into RTL we no longer\n      are able to honor __restrict__, for example.  We may want to\n      consider this for all memory access built-ins.\n \n      When -maltivec=be is specified, or the wrong number of arguments\n      is provided, simply punt to existing built-in processing.  */\n-  if (fcode == ALTIVEC_BUILTIN_VEC_LD\n-      && (BYTES_BIG_ENDIAN || !VECTOR_ELT_ORDER_BIG)\n-      && nargs == 2)\n-    {\n-      tree arg0 = (*arglist)[0];\n-      tree arg1 = (*arglist)[1];\n-\n-      /* Strip qualifiers like \"const\" from the pointer arg.  */\n-      tree arg1_type = TREE_TYPE (arg1);\n-      if (TREE_CODE (arg1_type) == ARRAY_TYPE && c_dialect_cxx ())\n-\t{\n-\t  /* Force array-to-pointer decay for C++.  */\n-\t  arg1 = default_conversion (arg1);\n-\t  arg1_type = TREE_TYPE (arg1);\n-\t}\n-      if (!POINTER_TYPE_P (arg1_type))\n-\tgoto bad;\n-\n-      tree inner_type = TREE_TYPE (arg1_type);\n-      if (TYPE_QUALS (TREE_TYPE (arg1_type)) != 0)\n-\t{\n-\t  arg1_type = build_pointer_type (build_qualified_type (inner_type,\n-\t\t\t\t\t\t\t\t0));\n-\t  arg1 = fold_convert (arg1_type, arg1);\n-\t}\n-\n-      /* Construct the masked address.  Let existing error handling take\n-\t over if we don't have a constant offset.  */\n-      arg0 = fold (arg0);\n-\n-      if (TREE_CODE (arg0) == INTEGER_CST)\n-\t{\n-\t  if (!ptrofftype_p (TREE_TYPE (arg0)))\n-\t    arg0 = build1 (NOP_EXPR, sizetype, arg0);\n-\n-\t  tree addr = fold_build2_loc (loc, POINTER_PLUS_EXPR, arg1_type,\n-\t\t\t\t       arg1, arg0);\n-\t  tree aligned = fold_build2_loc (loc, BIT_AND_EXPR, arg1_type, addr,\n-\t\t\t\t\t  build_int_cst (arg1_type, -16));\n-\n-\t  /* Find the built-in to get the return type so we can convert\n-\t     the result properly (or fall back to default handling if the\n-\t     arguments aren't compatible).  */\n-\t  for (desc = altivec_overloaded_builtins;\n-\t       desc->code && desc->code != fcode; desc++)\n-\t    continue;\n-\n-\t  for (; desc->code == fcode; desc++)\n-\t    if (rs6000_builtin_type_compatible (TREE_TYPE (arg0), desc->op1)\n-\t\t&& (rs6000_builtin_type_compatible (TREE_TYPE (arg1),\n-\t\t\t\t\t\t    desc->op2)))\n-\t      {\n-\t\ttree ret_type = rs6000_builtin_type (desc->ret_type);\n-\t\tif (TYPE_MODE (ret_type) == V2DImode)\n-\t\t  /* Type-based aliasing analysis thinks vector long\n-\t\t     and vector long long are different and will put them\n-\t\t     in distinct alias classes.  Force our return type\n-\t\t     to be a may-alias type to avoid this.  */\n-\t\t  ret_type\n-\t\t    = build_pointer_type_for_mode (ret_type, Pmode,\n-\t\t\t\t\t\t   true/*can_alias_all*/);\n-\t\telse\n-\t\t  ret_type = build_pointer_type (ret_type);\n-\t\taligned = build1 (NOP_EXPR, ret_type, aligned);\n-\t\ttree ret_val = build_indirect_ref (loc, aligned, RO_NULL);\n-\t\treturn ret_val;\n-\t      }\n-\t}\n-    }\n \n-  /* Similarly for stvx.  */\n   if (fcode == ALTIVEC_BUILTIN_VEC_ST\n       && (BYTES_BIG_ENDIAN || !VECTOR_ELT_ORDER_BIG)\n       && nargs == 3)"}, {"sha": "1978634f02e55668bff9d4672e7d45ced3272284", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d14c60ad26f57ed6d32180a96cc27c7bf1d7f5b2", "patch": "@@ -16546,6 +16546,48 @@ rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \tupdate_call_from_tree (gsi, res);\n \treturn true;\n       }\n+    /* Vector loads.  */\n+    case ALTIVEC_BUILTIN_LVX_V16QI:\n+    case ALTIVEC_BUILTIN_LVX_V8HI:\n+    case ALTIVEC_BUILTIN_LVX_V4SI:\n+    case ALTIVEC_BUILTIN_LVX_V4SF:\n+    case ALTIVEC_BUILTIN_LVX_V2DI:\n+    case ALTIVEC_BUILTIN_LVX_V2DF:\n+      {\n+\t arg0 = gimple_call_arg (stmt, 0);  // offset\n+\t arg1 = gimple_call_arg (stmt, 1);  // address\n+\t /* Do not fold for -maltivec=be on LE targets.  */\n+\t if (VECTOR_ELT_ORDER_BIG && !BYTES_BIG_ENDIAN)\n+\t    return false;\n+\t lhs = gimple_call_lhs (stmt);\n+\t location_t loc = gimple_location (stmt);\n+\t /* Since arg1 may be cast to a different type, just use ptr_type_node\n+\t    here instead of trying to enforce TBAA on pointer types.  */\n+\t tree arg1_type = ptr_type_node;\n+\t tree lhs_type = TREE_TYPE (lhs);\n+\t /* POINTER_PLUS_EXPR wants the offset to be of type 'sizetype'.  Create\n+\t    the tree using the value from arg0.  The resulting type will match\n+\t    the type of arg1.  */\n+\t gimple_seq stmts = NULL;\n+\t tree temp_offset = gimple_convert (&stmts, loc, sizetype, arg0);\n+\t tree temp_addr = gimple_build (&stmts, loc, POINTER_PLUS_EXPR,\n+\t\t\t\t       arg1_type, arg1, temp_offset);\n+\t /* Mask off any lower bits from the address.  */\n+\t tree aligned_addr = gimple_build (&stmts, loc, BIT_AND_EXPR,\n+\t\t\t\t\t  arg1_type, temp_addr,\n+\t\t\t\t\t  build_int_cst (arg1_type, -16));\n+\t gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);\n+\t /* Use the build2 helper to set up the mem_ref.  The MEM_REF could also\n+\t    take an offset, but since we've already incorporated the offset\n+\t    above, here we just pass in a zero.  */\n+\t gimple *g;\n+\t g = gimple_build_assign (lhs, build2 (MEM_REF, lhs_type, aligned_addr,\n+\t\t\t\t\t\tbuild_int_cst (arg1_type, 0)));\n+\t gimple_set_location (g, loc);\n+\t gsi_replace (gsi, g, true);\n+\t return true;\n+      }\n+\n     default:\n \tif (TARGET_DEBUG_BUILTIN)\n \t   fprintf (stderr, \"gimple builtin intrinsic not matched:%d %s %s\\n\","}]}