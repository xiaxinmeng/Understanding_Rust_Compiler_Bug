{"sha": "8b9a1428e501cc54419cba1da888d6f98e69464e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5YTE0MjhlNTAxY2M1NDQxOWNiYTFkYTg4OGQ2Zjk4ZTY5NDY0ZQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-05-12T20:36:31Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-05-12T20:36:31Z"}, "message": "sparc.h (REG_OK_FOR_INDEX_P, [...]): Remove.\n\n\t* config/sparc/sparc.h (REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P,\n\tSYMBOLIC_CONST, RTX_OK_FOR_BASE_P, RTX_OK_FOR_INDEX_P): Remove.\n\t(RTX_OK_FOR_OFFSET_P, RTX_OK_FOR_OLO10_P): Move to...\n\t* config/sparc/sparc.c (RTX_OK_FOR_OFFSET_P,\n\tRTX_OK_FOR_OLO10_P): ...here.\n\t(sparc_mode_dependent_address_p): Use symbolic_operand instead of\n\tSYMBOLIC_CONST.\n\nFrom-SVN: r173714", "tree": {"sha": "4d6123108261e16aefced35ddb0ebf30d0e0332d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d6123108261e16aefced35ddb0ebf30d0e0332d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b9a1428e501cc54419cba1da888d6f98e69464e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b9a1428e501cc54419cba1da888d6f98e69464e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b9a1428e501cc54419cba1da888d6f98e69464e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b9a1428e501cc54419cba1da888d6f98e69464e/comments", "author": null, "committer": null, "parents": [{"sha": "acf98146054a121b1da2d76d76bc2c77e03dd301", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acf98146054a121b1da2d76d76bc2c77e03dd301", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acf98146054a121b1da2d76d76bc2c77e03dd301"}], "stats": {"total": 84, "additions": 21, "deletions": 63}, "files": [{"sha": "58f25a7b686d3ebe95bf4d3b70df24ff780ffdc4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9a1428e501cc54419cba1da888d6f98e69464e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9a1428e501cc54419cba1da888d6f98e69464e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b9a1428e501cc54419cba1da888d6f98e69464e", "patch": "@@ -1,3 +1,13 @@\n+2011-05-12  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/sparc/sparc.h (REG_OK_FOR_INDEX_P, REG_OK_FOR_BASE_P,\n+\tSYMBOLIC_CONST, RTX_OK_FOR_BASE_P, RTX_OK_FOR_INDEX_P): Remove.\n+\t(RTX_OK_FOR_OFFSET_P, RTX_OK_FOR_OLO10_P): Move to...\n+\t* config/sparc/sparc.c (RTX_OK_FOR_OFFSET_P,\n+\tRTX_OK_FOR_OLO10_P): ...here.\n+\t(sparc_mode_dependent_address_p): Use symbolic_operand instead of\n+\tSYMBOLIC_CONST.\n+\n 2011-05-12  Kai Tietz  <ktietz@redhat.com>\n \n \t* gimplify.c (gimple_boolify): Re-boolify expression"}, {"sha": "e2443d7c4ed94ea21aebddb0d812cac55c102848", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9a1428e501cc54419cba1da888d6f98e69464e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9a1428e501cc54419cba1da888d6f98e69464e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8b9a1428e501cc54419cba1da888d6f98e69464e", "patch": "@@ -3110,8 +3110,16 @@ legitimate_pic_operand_p (rtx x)\n   return true;\n }\n \n-/* Return nonzero if ADDR is a valid memory address.\n-   STRICT specifies whether strict register checking applies.  */\n+#define RTX_OK_FOR_OFFSET_P(X)                                          \\\n+  (CONST_INT_P (X) && INTVAL (X) >= -0x1000 && INTVAL (X) < 0x1000 - 8)\n+\n+#define RTX_OK_FOR_OLO10_P(X)                                           \\\n+  (CONST_INT_P (X) && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)\n+\n+/* Handle the TARGET_LEGITIMATE_ADDRESS_P target hook.\n+\n+   On SPARC, the actual legitimate addresses must be REG+REG or REG+SMALLINT\n+   ordinarily.  This changes a bit when generating PIC.  */\n \n static bool\n sparc_legitimate_address_p (enum machine_mode mode, rtx addr, bool strict)\n@@ -3706,7 +3714,7 @@ sparc_mode_dependent_address_p (const_rtx addr)\n       rtx op0 = XEXP (addr, 0);\n       rtx op1 = XEXP (addr, 1);\n       if (op0 == pic_offset_table_rtx\n-\t  && SYMBOLIC_CONST (op1))\n+\t  && symbolic_operand (op1, VOIDmode))\n \treturn true;\n     }\n "}, {"sha": "ad354e89ecaa2296297a9901ef344e36040dd5e5", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b9a1428e501cc54419cba1da888d6f98e69464e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b9a1428e501cc54419cba1da888d6f98e69464e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=8b9a1428e501cc54419cba1da888d6f98e69464e", "patch": "@@ -1538,41 +1538,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    addresses which require two reload registers.  */\n \n #define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-  (REGNO (X) < 32\t\t\t\t\\\n-   || REGNO (X) == FRAME_POINTER_REGNUM\t\t\\\n-   || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X)  REG_OK_FOR_INDEX_P (X)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n \f\n /* Should gcc use [%reg+%lo(xx)+offset] addresses?  */\n \n@@ -1581,31 +1546,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n #else\n #define USE_AS_OFFSETABLE_LO10 0\n #endif\n-\f\n-/* On SPARC, the actual legitimate addresses must be REG+REG or REG+SMALLINT\n-   ordinarily.  This changes a bit when generating PIC.  The details are\n-   in sparc.c's implementation of TARGET_LEGITIMATE_ADDRESS_P.  */\n-\n-#define SYMBOLIC_CONST(X) symbolic_operand (X, VOIDmode)\n-\n-#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-  || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-      && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-      && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n-\n-#define RTX_OK_FOR_INDEX_P(X)\t\t\t\t\t\t\\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\t\t\\\n-  || (GET_CODE (X) == SUBREG\t\t\t\t\t\t\\\n-      && GET_CODE (SUBREG_REG (X)) == REG\t\t\t\t\\\n-      && REG_OK_FOR_INDEX_P (SUBREG_REG (X))))\n-\n-#define RTX_OK_FOR_OFFSET_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0x1000 - 8)\n-\n-#define RTX_OK_FOR_OLO10_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)\n-\n \f\n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This"}]}