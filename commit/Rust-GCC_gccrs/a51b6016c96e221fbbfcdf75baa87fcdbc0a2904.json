{"sha": "a51b6016c96e221fbbfcdf75baa87fcdbc0a2904", "node_id": "C_kwDOANBUbNoAKGE1MWI2MDE2Yzk2ZTIyMWZiYmZjZGY3NWJhYTg3ZmNkYmMwYTI5MDQ", "commit": {"author": {"name": "Ghjuvan Lacambre", "email": "lacambre@adacore.com", "date": "2022-03-28T14:40:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-17T08:25:49Z"}, "message": "[Ada] CUDA: remove code performing kernel registration\n\nA previous commit implemented a new kernel registration scheme, using\nthe binder to generate registration code rather than inserting\nregistration code in packages.  Now that this new approach has had time\nto be thoroughly tested, it is time to remove the old approach.\n\ngcc/ada/\n\n\t* gnat_cuda.ads: Update package-level comments.\n\t(Build_And_Insert_CUDA_Initialization): Remove function.\n\t* gnat_cuda.adb (Build_And_Insert_CUDA_Initialization): Remove\n\tfunction.\n\t(Expand_CUDA_Package): Remove call to\n\tBuild_And_Insert_CUDA_Initialization.", "tree": {"sha": "8fda3b668f1d08d7adcc6f03c23e8ceb6c91ba32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8fda3b668f1d08d7adcc6f03c23e8ceb6c91ba32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904/comments", "author": {"login": "glacambre", "id": 11534587, "node_id": "MDQ6VXNlcjExNTM0NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/11534587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glacambre", "html_url": "https://github.com/glacambre", "followers_url": "https://api.github.com/users/glacambre/followers", "following_url": "https://api.github.com/users/glacambre/following{/other_user}", "gists_url": "https://api.github.com/users/glacambre/gists{/gist_id}", "starred_url": "https://api.github.com/users/glacambre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glacambre/subscriptions", "organizations_url": "https://api.github.com/users/glacambre/orgs", "repos_url": "https://api.github.com/users/glacambre/repos", "events_url": "https://api.github.com/users/glacambre/events{/privacy}", "received_events_url": "https://api.github.com/users/glacambre/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ab656c5e90219ce2d11a9c88d06ff927b275297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ab656c5e90219ce2d11a9c88d06ff927b275297", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ab656c5e90219ce2d11a9c88d06ff927b275297"}], "stats": {"total": 511, "additions": 8, "deletions": 503}, "files": [{"sha": "44394b731630a17e013e016fb44c92262725b2cf", "filename": "gcc/ada/gnat_cuda.adb", "status": "modified", "additions": 0, "deletions": 490, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904/gcc%2Fada%2Fgnat_cuda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904/gcc%2Fada%2Fgnat_cuda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_cuda.adb?ref=a51b6016c96e221fbbfcdf75baa87fcdbc0a2904", "patch": "@@ -31,19 +31,12 @@ with Einfo.Entities; use Einfo.Entities;\n with Einfo.Utils;    use Einfo.Utils;\n with Elists;         use Elists;\n with Errout;         use Errout;\n-with Namet;          use Namet;\n with Nlists;         use Nlists;\n with Nmake;          use Nmake;\n-with Rtsfind;        use Rtsfind;\n-with Sem;            use Sem;\n with Sem_Aux;        use Sem_Aux;\n with Sem_Util;       use Sem_Util;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Sinfo;          use Sinfo;\n-with Snames;         use Snames;\n-with Stringt;        use Stringt;\n-with Tbuild;         use Tbuild;\n-with Uintp;          use Uintp;\n \n with GNAT.HTable;\n \n@@ -83,25 +76,6 @@ package body GNAT_CUDA is\n    --  least one procedure marked with aspect CUDA_Global. The values are\n    --  Elists of the marked procedures.\n \n-   procedure Build_And_Insert_CUDA_Initialization (N : Node_Id);\n-   --  Builds declarations necessary for CUDA initialization and inserts them\n-   --  in N, the package body that contains CUDA_Global nodes. These\n-   --  declarations are:\n-   --\n-   --    * A symbol to hold the pointer P to the CUDA fat binary.\n-   --\n-   --    * A type definition T for a wrapper that contains the pointer to the\n-   --      CUDA fat binary.\n-   --\n-   --    * An object of the aforementioned type to hold the aforementioned\n-   --      pointer.\n-   --\n-   --    * For each CUDA_Global procedure in the package, a declaration of a C\n-   --      string containing the function's name.\n-   --\n-   --    * A procedure that takes care of calling CUDA functions that register\n-   --      CUDA_Global procedures with the runtime.\n-\n    procedure Empty_CUDA_Global_Subprograms (Pack_Id : Entity_Id);\n    --  For all subprograms marked CUDA_Global in Pack_Id, remove declarations\n    --  and replace statements with a single null statement.\n@@ -234,13 +208,6 @@ package body GNAT_CUDA is\n \n       Remove_CUDA_Device_Entities\n         (Package_Specification (Corresponding_Spec (N)));\n-\n-      --  If procedures marked with CUDA_Global have been defined within N,\n-      --  we need to register them with the CUDA runtime at program startup.\n-      --  This requires multiple declarations and function calls which need\n-      --  to be appended to N's declarations.\n-\n-      Build_And_Insert_CUDA_Initialization (N);\n    end Expand_CUDA_Package;\n \n    ----------\n@@ -270,463 +237,6 @@ package body GNAT_CUDA is\n       return CUDA_Kernels_Table.Get (Pack_Id);\n    end Get_CUDA_Kernels;\n \n-   ------------------------------------------\n-   -- Build_And_Insert_CUDA_Initialization --\n-   ------------------------------------------\n-\n-   procedure Build_And_Insert_CUDA_Initialization (N : Node_Id) is\n-\n-      --  For the following kernel declaration:\n-      --\n-      --  package body <Package_Name> is\n-      --     procedure <Proc_Name> (X : Integer) with CUDA_Global;\n-      --  end package;\n-      --\n-      --  Insert the following declarations:\n-      --\n-      --     Fat_Binary : System.Address;\n-      --     pragma Import\n-      --        (Convention    => C,\n-      --         Entity        => Fat_Binary,\n-      --         External_Name => \"_binary_<Package_Name>_fatbin_start\");\n-      --\n-      --     Wrapper : Fatbin_Wrapper :=\n-      --       (16#466243b1#, 1, Fat_Binary'Address, System.Null_Address);\n-      --\n-      --     Proc_Symbol_Name : Interfaces.C.Strings.Chars_Ptr :=\n-      --       Interfaces.C.Strings.New_Char_Array(\"<Proc_Name>\");\n-      --\n-      --     Fat_Binary_Handle : System.Address :=\n-      --       CUDA.Internal.Register_Fat_Binary (Wrapper'Address);\n-      --\n-      --     procedure Initialize_CUDA_Kernel is\n-      --     begin\n-      --        CUDA.Internal.Register_Function\n-      --           (Fat_Binary_Handle,\n-      --            <Proc_Name>'Address,\n-      --            Proc_Symbol_Name,\n-      --            Proc_Symbol_Name,\n-      --            -1,\n-      --            System.Null_Address,\n-      --            System.Null_Address,\n-      --            System.Null_Address,\n-      --            System.Null_Address,\n-      --            System.Null_Address);\n-      --        CUDA.Internal.Register_Fat_Binary_End (Fat_Binary_Handle);\n-      --     end Initialize_CUDA_Kernel;\n-      --\n-      --  Proc_Symbol_Name is the name of the procedure marked with\n-      --  CUDA_Global. The CUDA runtime uses this in order to be able to find\n-      --  kernels in the fat binary, so it has to match the name of the\n-      --  procedure symbol compiled by GNAT_LLVM. When looking at the code\n-      --  generated by NVCC, it seems that the CUDA runtime also needs the name\n-      --  of the procedure symbol of the host. Fortuantely, the procedures are\n-      --  named the same way whether they are compiled for the host or the\n-      --  device, so we use Vector_Add_Name to specify the name of the symbol\n-      --  for both the host and the device. The meaning of the rest of the\n-      --  arguments is unknown.\n-\n-      function Build_CUDA_Init_Proc\n-        (Init_Id      : Entity_Id;\n-         CUDA_Kernels : Elist_Id;\n-         Handle_Id    : Entity_Id;\n-         Pack_Decls   : List_Id) return Node_Id;\n-      --  Create the declaration of Init_Id, the function that binds each\n-      --  kernel present in CUDA_Kernels with the fat binary Handle_Id and then\n-      --  tells the CUDA runtime that no new function will be bound to the fat\n-      --  binary.\n-\n-      function Build_Fat_Binary_Declaration\n-        (Bin_Id : Entity_Id) return Node_Id;\n-      --  Create a declaration for Bin_Id, the entity that represents the fat\n-      --  binary, i.e.:\n-      --\n-      --    Bin_Id : System.Address;\n-\n-      function Build_Fat_Binary_Handle_Declaration\n-        (Handle_Id  : Entity_Id;\n-         Wrapper_Id : Entity_Id) return Node_Id;\n-      --  Create the declaration of Handle_Id, a System.Address that will\n-      --  receive the results of passing the address of Wrapper_Id to\n-      --  CUDA.Register_Fat_Binary, i.e.:\n-      --\n-      --    Handle_Id : System.Address :=\n-      --      CUDA.Register_Fat_Binary (Wrapper_Id'Address)\n-\n-      function Build_Fat_Binary_Wrapper_Declaration\n-        (Wrapper_Id : Entity_Id;\n-         Bin_Id     : Entity_Id) return Node_Id;\n-      --  Create the declaration of the fat binary wrapper Wrapper_Id, which\n-      --  holds magic numbers and Bin_Id'Address, i.e.:\n-      --\n-      --     Wrapper_Id : System.Address :=\n-      --       (16#466243b1#, 1, Bin_Id'Address, System.Null_Address);\n-\n-      function Build_Import_Pragma\n-        (Bin_Id    : Entity_Id;\n-         Pack_Body : Node_Id) return Node_Id;\n-      --  Create a pragma that will bind the fat binary Bin_Id to its external\n-      --  symbol. N is the package body Bin_Id belongs to, i.e.:\n-      --\n-      --     pragma Import\n-      --        (Convention    => C,\n-      --         Entity        => Bin_Id,\n-      --         External_Name => \"_binary_<Pack_Body's name>_fatbin_start\");\n-\n-      function Build_Kernel_Name_Declaration\n-        (Kernel : Entity_Id) return Node_Id;\n-      --  Create the declaration of a C string that contains the name of\n-      --  Kernel's symbol, i.e.:\n-      --\n-      --     Kernel : Interfaces.C.Strings.Chars_Ptr :=\n-      --       Interfaces.C.Strings.New_Char_Array(\"<Kernel's name>\");\n-\n-      function Build_Register_Procedure_Call\n-        (Loc         : Source_Ptr;\n-         Bin         : Entity_Id;\n-         Kernel      : Entity_Id;\n-         Kernel_Name : Entity_Id) return Node_Id;\n-      --  Return a call to CUDA.Internal.Register_Function that binds Kernel\n-      --  (the entity of a procedure) to the symbol described by the C string\n-      --  Kernel_Name in the fat binary Bin, using Loc as location.\n-\n-      --------------------------\n-      -- Build_CUDA_Init_Proc --\n-      --------------------------\n-\n-      function Build_CUDA_Init_Proc\n-        (Init_Id      : Entity_Id;\n-         CUDA_Kernels : Elist_Id;\n-         Handle_Id    : Entity_Id;\n-         Pack_Decls   : List_Id) return Node_Id\n-      is\n-         Loc : constant Source_Ptr := Sloc (Init_Id);\n-\n-         Stmts : constant List_Id := New_List;\n-         --  List of statements that will be used by the cuda initialization\n-         --  function.\n-\n-         New_Stmt : Node_Id;\n-         --  Temporary variable to hold the various newly-created nodes\n-\n-         Kernel_Elmt : Elmt_Id;\n-         Kernel_Id   : Entity_Id;\n-\n-      begin\n-         --  For each CUDA_Global function, declare a C string that holds\n-         --  its symbol's name (i.e. packagename __ functionname).\n-\n-         --  Also create a function call to CUDA.Internal.Register_Function\n-         --  that takes the declared C string, a pointer to the function and\n-         --  the fat binary handle.\n-\n-         Kernel_Elmt := First_Elmt (CUDA_Kernels);\n-         while Present (Kernel_Elmt) loop\n-            Kernel_Id := Node (Kernel_Elmt);\n-\n-            New_Stmt := Build_Kernel_Name_Declaration (Kernel_Id);\n-            Append (New_Stmt, Pack_Decls);\n-            Analyze (New_Stmt);\n-\n-            Append_To (Stmts,\n-              Build_Register_Procedure_Call (Loc,\n-                Bin         => Handle_Id,\n-                Kernel      => Kernel_Id,\n-                Kernel_Name => Defining_Entity (New_Stmt)));\n-\n-            Next_Elmt (Kernel_Elmt);\n-         end loop;\n-\n-         --  Finish the CUDA initialization function: add a call to\n-         --  register_fat_binary_end, to let the CUDA runtime know that we\n-         --  won't be registering any other symbol with the current fat binary.\n-\n-         Append_To (Stmts,\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Register_Fat_Binary_End), Loc),\n-             Parameter_Associations =>\n-               New_List (New_Occurrence_Of (Handle_Id, Loc))));\n-\n-         --  Now that we have all the declarations and calls we need, we can\n-         --  build and and return the initialization procedure.\n-\n-         return\n-           Make_Subprogram_Body (Loc,\n-             Specification              =>\n-               Make_Procedure_Specification (Loc, Init_Id),\n-             Declarations               => New_List,\n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n-      end Build_CUDA_Init_Proc;\n-\n-      ----------------------------------\n-      -- Build_Fat_Binary_Declaration --\n-      ----------------------------------\n-\n-      function Build_Fat_Binary_Declaration\n-        (Bin_Id : Entity_Id) return Node_Id\n-      is\n-      begin\n-         return\n-           Make_Object_Declaration (Sloc (Bin_Id),\n-             Defining_Identifier => Bin_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Address), Sloc (Bin_Id)));\n-      end Build_Fat_Binary_Declaration;\n-\n-      -----------------------------------------\n-      -- Build_Fat_Binary_Handle_Declaration --\n-      -----------------------------------------\n-\n-      function Build_Fat_Binary_Handle_Declaration\n-        (Handle_Id  : Entity_Id;\n-         Wrapper_Id : Entity_Id) return Node_Id\n-      is\n-         Loc : constant Source_Ptr := Sloc (Handle_Id);\n-      begin\n-         --  Generate:\n-         --    Handle_Id : System.Address :=\n-         --      CUDA.Register_Fat_Binary (Wrapper_Id'Address);\n-\n-         return\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Handle_Id,\n-             Object_Definition   => New_Occurrence_Of (RTE (RE_Address), Loc),\n-             Expression          =>\n-               Make_Function_Call (Loc,\n-                 Name                   =>\n-                   New_Occurrence_Of (RTE (RE_Register_Fat_Binary), Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         =>\n-                       New_Occurrence_Of (Wrapper_Id, Loc),\n-                     Attribute_Name => Name_Address))));\n-      end Build_Fat_Binary_Handle_Declaration;\n-\n-      ------------------------------------------\n-      -- Build_Fat_Binary_Wrapper_Declaration --\n-      ------------------------------------------\n-\n-      function Build_Fat_Binary_Wrapper_Declaration\n-        (Wrapper_Id : Entity_Id;\n-         Bin_Id     : Entity_Id) return Node_Id\n-      is\n-         Loc : constant Source_Ptr := Sloc (Wrapper_Id);\n-      begin\n-         return\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Wrapper_Id,\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Fatbin_Wrapper), Loc),\n-             Expression          =>\n-               Make_Aggregate (Loc,\n-                 Expressions => New_List (\n-                   Make_Integer_Literal (Loc, UI_From_Int (16#466243b1#)),\n-                   Make_Integer_Literal (Loc, Uint_1),\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Occurrence_Of (Bin_Id, Loc),\n-                     Attribute_Name => Name_Address),\n-                   New_Occurrence_Of (RTE (RE_Null_Address), Loc))));\n-      end Build_Fat_Binary_Wrapper_Declaration;\n-\n-      -------------------------\n-      -- Build_Import_Pragma --\n-      -------------------------\n-\n-      function Build_Import_Pragma\n-        (Bin_Id    : Entity_Id;\n-         Pack_Body : Node_Id) return Node_Id\n-      is\n-         Loc             : constant Source_Ptr := Sloc (Bin_Id);\n-         External_Symbol : String_Id;\n-      begin\n-         Start_String;\n-         Store_String_Chars\n-           (\"_binary_\"\n-            & Get_Name_String (Chars (Defining_Unit_Name (Pack_Body)))\n-            & \"_fatbin_start\");\n-         External_Symbol := End_String;\n-\n-         return\n-           Make_Pragma (Loc,\n-             Pragma_Identifier            =>\n-               Make_Identifier (Loc, Name_Import),\n-             Pragma_Argument_Associations => New_List (\n-               Make_Pragma_Argument_Association (Loc,\n-                 Chars      => Name_Convention,\n-                 Expression => Make_Identifier (Loc, Name_C)),\n-               Make_Pragma_Argument_Association (Loc,\n-                 Chars      => Name_Entity,\n-                 Expression => New_Occurrence_Of (Bin_Id, Loc)),\n-               Make_Pragma_Argument_Association (Loc,\n-                 Chars      => Name_External_Name,\n-                 Expression => Make_String_Literal (Loc, External_Symbol))));\n-      end Build_Import_Pragma;\n-\n-      -------------------------------------\n-      -- Build_Kernel_Name_Declaration --\n-      -------------------------------------\n-\n-      function Build_Kernel_Name_Declaration\n-        (Kernel : Entity_Id) return Node_Id\n-      is\n-         Loc : constant Source_Ptr := Sloc (Kernel);\n-\n-         Package_Name : constant String :=\n-           Get_Name_String (Chars (Scope (Kernel)));\n-\n-         Symbol_Name : constant String := Get_Name_String (Chars (Kernel));\n-\n-         Kernel_Name : String_Id;\n-      begin\n-         Start_String;\n-         Store_String_Chars (Package_Name & \"__\" & Symbol_Name);\n-         Kernel_Name := End_String;\n-\n-         return\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Make_Temporary (Loc, 'C'),\n-             Object_Definition   =>\n-               New_Occurrence_Of (RTE (RE_Chars_Ptr), Loc),\n-             Expression          =>\n-               Make_Function_Call (Loc,\n-                 Name                   =>\n-                   New_Occurrence_Of (RTE (RE_New_Char_Array), Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_String_Literal (Loc, Kernel_Name))));\n-      end Build_Kernel_Name_Declaration;\n-\n-      -----------------------------------\n-      -- Build_Register_Procedure_Call --\n-      -----------------------------------\n-\n-      function Build_Register_Procedure_Call\n-        (Loc         : Source_Ptr;\n-         Bin         : Entity_Id;\n-         Kernel      : Entity_Id;\n-         Kernel_Name : Entity_Id) return Node_Id\n-      is\n-         Args : constant List_Id := New_List;\n-      begin\n-         --  First argument: the handle of the fat binary\n-\n-         Append (New_Occurrence_Of (Bin, Loc), Args);\n-\n-         --  Second argument: the host address of the function that is marked\n-         --  with CUDA_Global.\n-\n-         Append_To (Args,\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Kernel, Loc),\n-             Attribute_Name => Name_Address));\n-\n-         --  Third argument, the name of the function on the host\n-\n-         Append (New_Occurrence_Of (Kernel_Name, Loc), Args);\n-\n-         --  Fourth argument, the name of the function on the device\n-\n-         Append (New_Occurrence_Of (Kernel_Name, Loc), Args);\n-\n-         --  Fith argument: -1. Meaning unknown - this has been copied from\n-         --  LLVM.\n-\n-         Append (Make_Integer_Literal (Loc, Uint_Minus_1), Args);\n-\n-         --  Args 6, 7, 8, 9, 10: Null pointers. Again, meaning unknown\n-\n-         for Arg_Count in 6 .. 10 loop\n-            Append_To (Args, New_Occurrence_Of (RTE (RE_Null_Address), Loc));\n-         end loop;\n-\n-         --  Build the call to CUDARegisterFunction, passing the argument list\n-         --  we just built.\n-\n-         return\n-           Make_Procedure_Call_Statement (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_Register_Function), Loc),\n-             Parameter_Associations => Args);\n-      end Build_Register_Procedure_Call;\n-\n-      --  Local declarations\n-\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      Spec_Id : constant Node_Id := Corresponding_Spec (N);\n-      --  The specification of the package we're adding a cuda init func to\n-\n-      Pack_Decls : constant List_Id := Declarations (N);\n-\n-      CUDA_Node_List : constant Elist_Id := Get_CUDA_Kernels (Spec_Id);\n-      --  CUDA nodes that belong to the package\n-\n-      CUDA_Init_Func : Entity_Id;\n-      --  Entity of the cuda init func\n-\n-      Fat_Binary : Entity_Id;\n-      --  Entity of the fat binary of N. Bound to said fat binary by a pragma\n-\n-      Fat_Binary_Handle : Entity_Id;\n-      --  Entity of the result of passing the fat binary wrapper to\n-      --  CUDA.Register_Fat_Binary.\n-\n-      Fat_Binary_Wrapper : Entity_Id;\n-      --  Entity of a record that holds a bunch of magic numbers and a\n-      --  reference to Fat_Binary.\n-\n-      New_Stmt : Node_Id;\n-      --  Node to store newly-created declarations\n-\n-   --  Start of processing for Build_And_Insert_CUDA_Initialization\n-\n-   begin\n-      if No (CUDA_Node_List) then\n-         return;\n-      end if;\n-\n-      Fat_Binary := Make_Temporary (Loc, 'C');\n-      New_Stmt := Build_Fat_Binary_Declaration (Fat_Binary);\n-      Append_To (Pack_Decls, New_Stmt);\n-      Analyze (New_Stmt);\n-\n-      New_Stmt := Build_Import_Pragma (Fat_Binary, N);\n-      Append_To (Pack_Decls, New_Stmt);\n-      Analyze (New_Stmt);\n-\n-      Fat_Binary_Wrapper := Make_Temporary (Loc, 'C');\n-      New_Stmt :=\n-        Build_Fat_Binary_Wrapper_Declaration\n-          (Wrapper_Id => Fat_Binary_Wrapper,\n-           Bin_Id     => Fat_Binary);\n-      Append_To (Pack_Decls, New_Stmt);\n-      Analyze (New_Stmt);\n-\n-      Fat_Binary_Handle := Make_Temporary (Loc, 'C');\n-      New_Stmt :=\n-        Build_Fat_Binary_Handle_Declaration\n-          (Fat_Binary_Handle, Fat_Binary_Wrapper);\n-      Append_To (Pack_Decls, New_Stmt);\n-      Analyze (New_Stmt);\n-\n-      CUDA_Init_Func := Make_Temporary (Loc, 'C');\n-      New_Stmt :=\n-        Build_CUDA_Init_Proc\n-          (Init_Id      => CUDA_Init_Func,\n-           CUDA_Kernels => CUDA_Node_List,\n-           Handle_Id    => Fat_Binary_Handle,\n-           Pack_Decls   => Pack_Decls);\n-      Append_To (Pack_Decls, New_Stmt);\n-      Analyze (New_Stmt);\n-\n-      New_Stmt :=\n-        Make_Procedure_Call_Statement (Loc,\n-          Name => New_Occurrence_Of (CUDA_Init_Func, Loc));\n-      Append_To (Pack_Decls, New_Stmt);\n-      Analyze (New_Stmt);\n-   end Build_And_Insert_CUDA_Initialization;\n-\n    ---------------------------------\n    -- Remove_CUDA_Device_Entities --\n    ---------------------------------"}, {"sha": "1333a6570ecd6dbaf83050f5e5f16c4cb539e7f8", "filename": "gcc/ada/gnat_cuda.ads", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904/gcc%2Fada%2Fgnat_cuda.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a51b6016c96e221fbbfcdf75baa87fcdbc0a2904/gcc%2Fada%2Fgnat_cuda.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_cuda.ads?ref=a51b6016c96e221fbbfcdf75baa87fcdbc0a2904", "patch": "@@ -43,24 +43,21 @@\n --  compiling for the host, the frontend stores procedures marked with\n --  CUDA_Global in a hash table the key of which is the Node_Id of the package\n --  body that contains the CUDA_Global procedure. This is done in sem_prag.adb.\n---  Once the declarations of a package body have been analyzed, variable, type\n---  and procedure declarations necessary for the initialization of the CUDA\n---  runtime are appended to the package that contains the CUDA_Global\n---  procedure.\n---\n---  These declarations are used to register the CUDA kernel with the CUDA\n---  runtime when the program is launched. Registering a CUDA kernel with the\n---  CUDA runtime requires multiple function calls:\n+--  When emitting an ALI file for a compilation unit, the frontend emits 'K'\n+--  lines for each visible CUDA kernel (see Output_CUDA_Symbols in\n+--  lib-writ.adb). This allows the binder to see all kernels in a program and\n+--  emit code to register the kernels with the CUDA runtime.\n+\n+--  Registering a CUDA kernel with the CUDA runtime requires multiple function\n+--  calls:\n --  - The first one registers the fat binary which corresponds to the package\n --    with the CUDA runtime.\n --  - Then, as many function calls as there are kernels in order to bind them\n --    with the fat binary.\n --    fat binary.\n --  - The last call lets the CUDA runtime know that we are done initializing\n --    CUDA.\n---  Expansion of the CUDA_Global aspect is triggered in sem_ch7.adb, during\n---  analysis of the package. All of this expansion is performed in the\n---  Insert_CUDA_Initialization procedure defined in GNAT_CUDA.\n+--  All of that is performed by the code emitted by bindgen.adb.\n --\n --  Once a CUDA package is initialized, its kernels are ready to be used.\n --  Launching CUDA kernels is done by using the CUDA_Execute pragma. When\n@@ -87,8 +84,6 @@ package GNAT_CUDA is\n \n    procedure Expand_CUDA_Package (N : Node_Id);\n    --  When compiling for the host:\n-   --  - Generate code to register kernels with the CUDA runtime and\n-   --    post-process kernels.\n    --  - Empty content of CUDA_Global procedures.\n    --  - Remove declarations of CUDA_Device entities.\n "}]}