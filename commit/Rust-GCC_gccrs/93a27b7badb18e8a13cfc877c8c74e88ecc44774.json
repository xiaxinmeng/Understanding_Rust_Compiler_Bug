{"sha": "93a27b7badb18e8a13cfc877c8c74e88ecc44774", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTNhMjdiN2JhZGIxOGU4YTEzY2ZjODc3YzhjNzRlODhlY2M0NDc3NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-10-27T01:29:42Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-10-27T01:29:42Z"}, "message": "dbxout.c: Include obstack.h.\n\n\t* dbxout.c: Include obstack.h.\n\t(ASM_STABS_OP): Take XCOFF_DEBUGGING_INFO into account in\n\tdefault definition.\n\t(ASM_STABD_OP, NO_DBX_MAIN_SOURCE_DIRECTORY, DBX_CONTIN_CHAR):\n\tDefault-define here.\n\t(DBX_CONTIN_LENGTH): Move definition with others.\n\t(DBX_FINISH_STABS): New target macro.\n\t(current_sym_code, current_sym_value, current_sym_addr)\n\t(current_sym_nchars, CHARS, dbxout_continue)\n\t(print_int_cst_octal, print_octal, print_wide_int)\n\t(dbxout_prepare_symbol, dbxout_finish_symbol): Delete.\n\t(stabstr_ob, stabstr_last_contin_point): New variables.\n\t(NUMBER_FMT_LOOP): New improper macro.\n\t(dbxout_int, dbxout_stab_value_zero, dbxout_stab_value_label)\n\t(dbxout_stab_value_label_diff, dbxout_stab_value_internal_label)\n\t(dbxout_stab_value_internal_label_diff, dbxout_stabd)\n\t(dbxout_begin_stabn, dbxout_begin_stabn_sline)\n\t(dbxout_begin_simple_stabs, dbxout_begin_simple_stabs_desc)\n\t(dbxout_begin_complex_stabs, dbxout_finish_complex_stabs)\n\t(stabstr_C, stabstr_S, stabstr_I, stabstr_D, stabstr_U, stabstr_O)\n\t(stabstr_continue, DECL_ACCESSIBILITY_CHAR)\n\tNew functions and/or proper function-like macros.\n\t(CONTIN): Use stabstr_continue, unconditionally.\n\t(get_lang_number): Define unconditionally, with ATTRIBUTE_UNUSED.\n\t(dbxout_init): Initialize stabstr_ob.  Check\n\tNO_DBX_MAIN_SOURCE_DIRECTORY.  Only write out the Ltext label\n\tif it was used.  Use the new interfaces.\n\t(dbxout_source_file): Remove file argument; always write to\n\tasm_out_file.  Use the new interfaces.\n\t(dbxout_type_method_1): Remove second argument which is always\n\tDECL_ASSEMBLER_NAME of the first argument.  Use the new interfaces.\n\t(dbxout_type_methods): Remove write-only variables.  Use the\n\tnew interfaces.\n\t(dbxout_parms): Refactor to remove code duplicated in each of\n\tseveral successive if-else-if blocks.  Use the new interfaces.\n\t(dbxout_function_end, emit_bincl_stab, dbxout_end_source_file)\n\t(dbxout_source_line, dbxout_finish, dbxout_type_index)\n\t(dbxout_type_fields, dbxout_range_type, dbxout_type, dbxout_type_name)\n\t(dbxout_class_name_qualifiers, dbxout_symbol, dbxout_symbol_location)\n\t(dbxout_symbol_name, dbxout_reg_parms, dbxout_args)\n\t(dbx_output_lbrac, dbx_output_rbrac, dbxout_block):\n\tUse the new interfaces.\n\t* Makefile.in (dbxout.o): Update dependencies.\n\n\t* defaults.h: Don't define ASM_STABD_OP.\n\t* output.h: Prototype new dbxout_* interfaces.\n\t* system.h: Poison DBX_OUTPUT_GCC_MARKER and DBX_FINISH_SYMBOL.\n\t* varasm.c: Don't define ASM_STABS_OP.\n\t(default_stabs_asm_out_constructor, default_stabs_asm_out_destructor):\n\tUse the new dbxout.c interfaces.  Call sorry if neither\n\tDBX_DEBUGGING_INFO nor XCOFF_DEBUGGING_INFO is defined.\n\n\t* xcoffout.h: Don't define ASM_STABS_OP.\n\t(DBX_FINISH_SYMBOL): Rewrite and rename DBX_FINISH_STABS.\n\t(DBX_OUTPUT_MAIN_SOURCE_DIRECTORY, DBX_OUTPUT_GCC_MARKER): Delete.\n\t(NO_DBX_MAIN_SOURCE_DIRECTORY, NO_DBX_GCC_MARKER): Define.\n\t(DBX_OUTPUT_MAIN_SOURCE_FILE_END): Change bare block to\n\tdo { ... } while (0) idiom.\n\n\t* config/alpha/alpha.c (num_source_filenames): Export.\n\t* config/alpha/alpha.h (num_source_filenames): Declare.\n\t(DBX_OUTPUT_SOURCE_LINE): Use new interfaces.\n\t(SDB_OUTPUT_SOURCE_LINE): Add missing newline.\n\t* config/m32r/m32r.h (DBX_OUTPUT_SOURCE_LINE): Use new interfaces.\n\tAlways use .debugsym.  Update commentary.\n\t* config/mips/mips.h (DBX_OUTPUT_SOURCE_LINE): Use new interfaces.\n\t(SDB_OUTPUT_SOURCE_LINE): Add missing newline.\n\t* config/rs6000/linux64.h (DBX_OUTPUT_SOURCE_LINE, DBX_OUTPUT_BRAC):\n\tUse new interfaces.\n\t* config/rs6000/rs6000.c: If TARGET_MACHO, include gstab.h.\n\t(macho_branch_islands): Use new interfaces.\n\n\t* doc/tm.texi: Update.\n\nFrom-SVN: r89623", "tree": {"sha": "0c96f65f534d94db49923bd04453180f46fc5a5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c96f65f534d94db49923bd04453180f46fc5a5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93a27b7badb18e8a13cfc877c8c74e88ecc44774", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a27b7badb18e8a13cfc877c8c74e88ecc44774", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93a27b7badb18e8a13cfc877c8c74e88ecc44774", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93a27b7badb18e8a13cfc877c8c74e88ecc44774/comments", "author": null, "committer": null, "parents": [{"sha": "ab4375af84fb7780d3a4c7f7a25521341931cf0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab4375af84fb7780d3a4c7f7a25521341931cf0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab4375af84fb7780d3a4c7f7a25521341931cf0c"}], "stats": {"total": 2103, "additions": 1155, "deletions": 948}, "files": [{"sha": "45edb1739a66cbe04b55786b222e0b89ea35b767", "filename": "gcc/ChangeLog", "status": "modified", "additions": 86, "deletions": 10, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -1,3 +1,79 @@\n+2004-10-26  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* dbxout.c: Include obstack.h.\n+\t(ASM_STABS_OP): Take XCOFF_DEBUGGING_INFO into account in\n+\tdefault definition.\n+\t(ASM_STABD_OP, NO_DBX_MAIN_SOURCE_DIRECTORY, DBX_CONTIN_CHAR):\n+\tDefault-define here.\n+\t(DBX_CONTIN_LENGTH): Move definition with others.\n+\t(DBX_FINISH_STABS): New target macro.\n+\t(current_sym_code, current_sym_value, current_sym_addr)\n+\t(current_sym_nchars, CHARS, dbxout_continue)\n+\t(print_int_cst_octal, print_octal, print_wide_int)\n+\t(dbxout_prepare_symbol, dbxout_finish_symbol): Delete.\n+\t(stabstr_ob, stabstr_last_contin_point): New variables.\n+\t(NUMBER_FMT_LOOP): New improper macro.\n+\t(dbxout_int, dbxout_stab_value_zero, dbxout_stab_value_label)\n+\t(dbxout_stab_value_label_diff, dbxout_stab_value_internal_label)\n+\t(dbxout_stab_value_internal_label_diff, dbxout_stabd)\n+\t(dbxout_begin_stabn, dbxout_begin_stabn_sline)\n+\t(dbxout_begin_simple_stabs, dbxout_begin_simple_stabs_desc)\n+\t(dbxout_begin_complex_stabs, dbxout_finish_complex_stabs)\n+\t(stabstr_C, stabstr_S, stabstr_I, stabstr_D, stabstr_U, stabstr_O)\n+\t(stabstr_continue, DECL_ACCESSIBILITY_CHAR)\n+\tNew functions and/or proper function-like macros.\n+\t(CONTIN): Use stabstr_continue, unconditionally.\n+\t(get_lang_number): Define unconditionally, with ATTRIBUTE_UNUSED.\n+\t(dbxout_init): Initialize stabstr_ob.  Check\n+\tNO_DBX_MAIN_SOURCE_DIRECTORY.  Only write out the Ltext label\n+\tif it was used.  Use the new interfaces.\n+\t(dbxout_source_file): Remove file argument; always write to\n+\tasm_out_file.  Use the new interfaces.\n+\t(dbxout_type_method_1): Remove second argument which is always\n+\tDECL_ASSEMBLER_NAME of the first argument.  Use the new interfaces.\n+\t(dbxout_type_methods): Remove write-only variables.  Use the\n+\tnew interfaces.\n+\t(dbxout_parms): Refactor to remove code duplicated in each of\n+\tseveral successive if-else-if blocks.  Use the new interfaces.\n+\t(dbxout_function_end, emit_bincl_stab, dbxout_end_source_file)\n+\t(dbxout_source_line, dbxout_finish, dbxout_type_index)\n+\t(dbxout_type_fields, dbxout_range_type, dbxout_type, dbxout_type_name)\n+\t(dbxout_class_name_qualifiers, dbxout_symbol, dbxout_symbol_location)\n+\t(dbxout_symbol_name, dbxout_reg_parms, dbxout_args)\n+\t(dbx_output_lbrac, dbx_output_rbrac, dbxout_block):\n+\tUse the new interfaces.\n+\t* Makefile.in (dbxout.o): Update dependencies.\n+\n+\t* defaults.h: Don't define ASM_STABD_OP.\n+\t* output.h: Prototype new dbxout_* interfaces.\n+\t* system.h: Poison DBX_OUTPUT_GCC_MARKER and DBX_FINISH_SYMBOL.\n+\t* varasm.c: Don't define ASM_STABS_OP.\n+\t(default_stabs_asm_out_constructor, default_stabs_asm_out_destructor):\n+\tUse the new dbxout.c interfaces.  Call sorry if neither\n+\tDBX_DEBUGGING_INFO nor XCOFF_DEBUGGING_INFO is defined.\n+\n+\t* xcoffout.h: Don't define ASM_STABS_OP.\n+\t(DBX_FINISH_SYMBOL): Rewrite and rename DBX_FINISH_STABS.\n+\t(DBX_OUTPUT_MAIN_SOURCE_DIRECTORY, DBX_OUTPUT_GCC_MARKER): Delete.\n+\t(NO_DBX_MAIN_SOURCE_DIRECTORY, NO_DBX_GCC_MARKER): Define.\n+\t(DBX_OUTPUT_MAIN_SOURCE_FILE_END): Change bare block to\n+\tdo { ... } while (0) idiom.\n+\n+\t* config/alpha/alpha.c (num_source_filenames): Export.\n+\t* config/alpha/alpha.h (num_source_filenames): Declare.\n+\t(DBX_OUTPUT_SOURCE_LINE): Use new interfaces.\n+\t(SDB_OUTPUT_SOURCE_LINE): Add missing newline.\n+\t* config/m32r/m32r.h (DBX_OUTPUT_SOURCE_LINE): Use new interfaces.\n+\tAlways use .debugsym.  Update commentary.\n+\t* config/mips/mips.h (DBX_OUTPUT_SOURCE_LINE): Use new interfaces.\n+\t(SDB_OUTPUT_SOURCE_LINE): Add missing newline.\n+\t* config/rs6000/linux64.h (DBX_OUTPUT_SOURCE_LINE, DBX_OUTPUT_BRAC):\n+\tUse new interfaces.\n+\t* config/rs6000/rs6000.c: If TARGET_MACHO, include gstab.h.\n+\t(macho_branch_islands): Use new interfaces.\n+\n+\t* doc/tm.texi: Update.\n+\n 2004-10-26  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* expr.c (emit_group_store): Do not treat floats as BLKmode.\n@@ -37,8 +113,8 @@\n \n 2004-10-26  Fariborz Jahanian <fjahanian@apple.com>\n \n-        * config/rs6000/rs6000.md (andsi3_internal8): Set CR when splitting \n-        into rotlsi3.\n+\t* config/rs6000/rs6000.md (andsi3_internal8): Set CR when splitting\n+\tinto rotlsi3.\n \n 2004-10-26  Kazu Hirata  <kazu@cs.umass.edu>\n \n@@ -64,8 +140,8 @@\n \n 2004-10-26  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * expr.c (emit_group_load): Handle floats.\n-        (emit_group_store): Same.\n+\t* expr.c (emit_group_load): Handle floats.\n+\t(emit_group_store): Same.\n \n 2004-10-26  Nathan Sidwell  <nathan@codesourcery.com>\n \n@@ -147,8 +223,8 @@\n \t* gcc/Makefile.in: removed ggc for cgraphunit.\n \t* gcc/cgraph.c.dump_cgraph_node: removed static var analysis.\n \t* gcc/cgraph.h: removed static var analysis data structures and calls.\n-\t* gcc/cgraphunit.c: \n-\tcgraph_mark_local_and_external_functions:changed name to \n+\t* gcc/cgraphunit.c:\n+\tcgraph_mark_local_and_external_functions:changed name to\n \t\tcgraph_mark_local_functions\n \t(print_order,convert_UIDs_in_bitmap,new_static_vars_info,\n \tcgraph_reset_static_var_maps,get_global_static_vars_info,\n@@ -160,8 +236,8 @@\n \tremoved.\n \t(cgraph_optimize,init_cgraph): removed calls to static vars analysis\n \t* gcc/tree-dfa.c find_referenced_vars: removed call to static vars\n-\tanalysis \n-\t* gcc/tree-flow.h static_vars_info: removed \n+\tanalysis\n+\t* gcc/tree-flow.h static_vars_info: removed\n \t* gcc/tree-ssa-operands.c (add_call_clobber_ops,add_call_read_ops):\n \tremoved calls to static vars analysis.\n \tget_call_expr_operands: removed callee variable.\n@@ -228,7 +304,7 @@\n \n 2004-10-25  David Billinghurst <David.Billinghurst@riotinto.com>\n \n-\t* config/mips/mips.c(mips_output_filename): Remove unused \n+\t* config/mips/mips.c(mips_output_filename): Remove unused\n \tarray ltext_label_name\n \n 2004-10-24  Geoffrey Keating  <geoffk@geoffk.org>\n@@ -294,7 +370,7 @@\n \n 2004-10-22  Eric Christopher  <echristo@redhat.com>\n \n-        * config/rs6000/rs6000.c (setup_incoming_varargs): Align DFmode\n+\t* config/rs6000/rs6000.c (setup_incoming_varargs): Align DFmode\n \tsaves.\n \n 2004-10-22  Aldy Hernandez  <aldyh@redhat.com>"}, {"sha": "4720aaa3c5c41e0c8d20530a01ed055f1b415c0b", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -1883,7 +1883,7 @@ optabs.o : optabs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_\n dbxout.o : dbxout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n    $(FLAGS_H) $(REGS_H) debug.h $(TM_P_H) $(TARGET_H) function.h langhooks.h \\\n    insn-config.h reload.h gstab.h xcoffout.h output.h dbxout.h toplev.h \\\n-   $(GGC_H) gt-dbxout.h\n+   $(GGC_H) $(OBSTACK_H) gt-dbxout.h\n debug.o : debug.c debug.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\n sdbout.o : sdbout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) debug.h \\\n    $(TREE_H) $(GGC_H) varray.h $(RTL_H) $(REGS_H) $(FLAGS_H) insn-config.h \\"}, {"sha": "cefe86d355c531ae87aac123d82a9cfb22a83f72", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -6548,7 +6548,7 @@ alpha_expand_prologue (void)\n }\n \n /* Count the number of .file directives, so that .loc is up to date.  */\n-static int num_source_filenames = 0;\n+int num_source_filenames = 0;\n \n /* Output the textual info surrounding the prologue.  */\n "}, {"sha": "2cd07d3c2ba49d9e8a78adf8cd784634136c8158", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -1662,13 +1662,15 @@ extern long alpha_auto_offset;\n #define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET + alpha_arg_offset)\n \n /* mips-tfile doesn't understand .stabd directives.  */\n-#define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER)\t\t\t\\\n-  fprintf (STREAM, \"$LM%d:\\n%s%d,0,%d,$LM%d\\n\", COUNTER, ASM_STABN_OP,\t\\\n-           N_SLINE, LINE, COUNTER)\n+#define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER) do {\t\\\n+  dbxout_begin_stabn_sline (LINE);\t\t\t\t\\\n+  dbxout_stab_value_internal_label (\"LM\", &COUNTER);\t\t\\\n+} while (0)\n \n /* We want to use MIPS-style .loc directives for SDB line numbers.  */\n+extern int num_source_filenames;\n #define SDB_OUTPUT_SOURCE_LINE(STREAM, LINE)\t\\\n-  fprintf (STREAM, \"\\t.loc\\t%d %d\", num_source_filenames, LINE)\n+  fprintf (STREAM, \"\\t.loc\\t%d %d\\n\", num_source_filenames, LINE)\n \n #define ASM_OUTPUT_SOURCE_FILENAME(STREAM, NAME)\t\t\t\\\n   alpha_output_filename (STREAM, NAME)"}, {"sha": "b2a00a95b331c7a16ed010115fea9547bedf82e9", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -1517,25 +1517,23 @@ L2:     .word STATIC\n /* Globalizing directive for a label.  */\n #define GLOBAL_ASM_OP \"\\t.global\\t\"\n \n-/* If -Os, don't force line number labels to begin at the beginning of\n-   the word; we still want the assembler to try to put things in parallel,\n-   should that be possible.\n-   For m32r/d, instructions are never in parallel (other than with a nop)\n-   and the simulator and stub both handle a breakpoint in the middle of\n-   a word so don't ever force line number labels to begin at the beginning\n-   of a word.  */\n+/* We do not use DBX_LINES_FUNCTION_RELATIVE or\n+   dbxout_stab_value_internal_label_diff here because\n+   we need to use .debugsym for the line label.  */\n \n #define DBX_OUTPUT_SOURCE_LINE(file, line, counter)\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (file, \".stabn 68,0,%d,.LM%d-\",\t\t\t\t\\\n-\t       line, counter);\t\t\t\t\t\t\\\n-      assemble_name\t\t\t\t\t\t\t\\\n-\t(file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\t\\\n-      fprintf (file, (optimize_size || TARGET_M32R)\t\t\t\\\n-\t       ? \"\\n\\t.debugsym .LM%d\\n\"\t\t\t\t\\\n-\t       : \"\\n.LM%d:\\n\",\t\t\t\t\t\t\\\n-\t       counter);\t\t\t\t\t\t\\\n+      char label[64];\t\t\t\t\t\t\t\\\n+      ASM_GENERATE_INTERNAL_LABEL (label, \"LM\", counter);\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      dbxout_begin_stabn_sline (line);\t\t\t\t\t\\\n+      assemble_name (file, label);\t\t\t\t\t\\\n+      putc ('-', file);\t\t\t\t\t\t\t\\\n+      assemble_name (file, begin_label);\t\t\t\t\\\n+      fputs (\"\\n\\t.debugsym \", file);\t\t\t\t\t\\\n+      assemble_name (file, label);\t\t\t\t\t\\\n+      putc ('\\n', file);\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n "}, {"sha": "974817f8518886dbd9604a2099d77dcdf2817fbd", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -2791,14 +2791,14 @@ while (0)\n   mips_output_filename (STREAM, NAME)\n \n /* mips-tfile does not understand .stabd directives.  */\n-#define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER)\t\t\\\n-  fprintf (STREAM, \"%sLM%d:\\n\\t.stabn\\t%d,0,%d,%sLM%d\\n\",\t\\\n-\t   LOCAL_LABEL_PREFIX, COUNTER, N_SLINE, LINE,\t\t\\\n-\t   LOCAL_LABEL_PREFIX, COUNTER)\n+#define DBX_OUTPUT_SOURCE_LINE(STREAM, LINE, COUNTER) do {\t\\\n+  dbxout_begin_stabn_sline (LINE);\t\t\t\t\\\n+  dbxout_stab_value_internal_label (\"LM\", &COUNTER);\t\t\\\n+} while (0)\n \n /* Use .loc directives for SDB line numbers.  */\n #define SDB_OUTPUT_SOURCE_LINE(STREAM, LINE)\t\t\t\\\n-  fprintf (STREAM, \"\\t.loc\\t%d %d\", num_source_filenames, LINE)\n+  fprintf (STREAM, \"\\t.loc\\t%d %d\\n\", num_source_filenames, LINE)\n \n /* The MIPS implementation uses some labels for its own purpose.  The\n    following lists what labels are created, and are all formed by the"}, {"sha": "8168cd3413b1b963fff54f011d7ee3f6c469a2e7", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -482,30 +482,34 @@ extern int dot_symbols;\n \t\t   && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT\t\\\n \t\t   && BITS_PER_WORD == HOST_BITS_PER_INT)))))\n \n-/* This ABI cannot use DBX_LINES_FUNCTION_RELATIVE, because we must\n-   use the function code label, not the function descriptor.  */\n+/* This ABI cannot use DBX_LINES_FUNCTION_RELATIVE, nor can it use\n+   dbxout_stab_value_internal_label_diff, because we must\n+   use the function code label, not the function descriptor label.  */\n #define\tDBX_OUTPUT_SOURCE_LINE(FILE, LINE, COUNTER)\t\t\t\\\n do\t\t\t\t\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     char temp[256];\t\t\t\t\t\t\t\\\n     const char *s;\t\t\t\t\t\t\t\\\n     ASM_GENERATE_INTERNAL_LABEL (temp, \"LM\", COUNTER);\t\t\t\\\n-    fprintf (FILE, \"\\t.stabn 68,0,%d,\", LINE);\t\t\t\t\\\n+    dbxout_begin_stabn_sline (LINE);\t\t\t\t\t\\\n     assemble_name (FILE, temp);\t\t\t\t\t\t\\\n     putc ('-', FILE);\t\t\t\t\t\t\t\\\n     s = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\t\t\\\n     rs6000_output_function_entry (FILE, s);\t\t\t\t\\\n     putc ('\\n', FILE);\t\t\t\t\t\t\t\\\n-    (*targetm.asm_out.internal_label) (FILE, \"LM\", COUNTER);\t\t\\\n+    targetm.asm_out.internal_label (FILE, \"LM\", COUNTER);\t\t\\\n+    COUNTER += 1;\t\t\t\t\t\t\t\\\n   }\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n-/* Similarly, we want the function code label here.  */\n-#define DBX_OUTPUT_BRAC(FILE, NAME, BRAC) \\\n+/* Similarly, we want the function code label here.  Cannot use\n+   dbxout_stab_value_label_diff, as we have to use\n+   rs6000_output_function_entry.  FIXME.  */\n+#define DBX_OUTPUT_BRAC(FILE, NAME, BRAC)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       const char *s;\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s%d,0,0,\", ASM_STABN_OP, BRAC);\t\t\t\\\n+      dbxout_begin_stabn (BRAC);\t\t\t\t\t\\\n       assemble_name (FILE, NAME);\t\t\t\t\t\\\n       putc ('-', FILE);\t\t\t\t\t\t\t\\\n       s = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\t\t\\\n@@ -522,7 +526,7 @@ while (0)\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       const char *s;\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_FUN);\t\t\\\n+      dbxout_begin_empty_stabs (N_FUN);\t\t\t\t\t\\\n       assemble_name (FILE, LSCOPE);\t\t\t\t\t\\\n       putc ('-', FILE);\t\t\t\t\t\t\t\\\n       s = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\t\t\\"}, {"sha": "267796901ce21e7caf710a697821931991c4fa1a", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -56,6 +56,9 @@\n #if TARGET_XCOFF\n #include \"xcoffout.h\"  /* get declarations of xcoff_*_section_name */\n #endif\n+#if TARGET_MACHO\n+#include \"gstab.h\"  /* for N_SLINE */\n+#endif\n \n #ifndef TARGET_NO_PROTOTYPE\n #define TARGET_NO_PROTOTYPE 0\n@@ -17033,8 +17036,7 @@ macho_branch_islands (void)\n       strcat (tmp_buf, label);\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n       if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-\tfprintf (asm_out_file, \"\\t.stabd 68,0,\" HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n-\t\t BRANCH_ISLAND_LINE_NUMBER(branch_island));\n+\tdbxout_stabd (N_SLINE, BRANCH_ISLAND_LINE_NUMBER (branch_island));\n #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n       if (flag_pic)\n \t{\n@@ -17071,8 +17073,7 @@ macho_branch_islands (void)\n       output_asm_insn (tmp_buf, 0);\n #if defined (DBX_DEBUGGING_INFO) || defined (XCOFF_DEBUGGING_INFO)\n       if (write_symbols == DBX_DEBUG || write_symbols == XCOFF_DEBUG)\n-\tfprintf(asm_out_file, \"\\t.stabd 68,0,\" HOST_WIDE_INT_PRINT_UNSIGNED \"\\n\",\n-\t\tBRANCH_ISLAND_LINE_NUMBER (branch_island));\n+\tdbxout_stabd (N_SLINE, BRANCH_ISLAND_LINE_NUMBER (branch_island));\n #endif /* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */\n     }\n "}, {"sha": "e67008f9ef5346b778178c2dbd118237a6a99d93", "filename": "gcc/dbxout.c", "status": "modified", "additions": 944, "deletions": 842, "changes": 1786, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -88,6 +88,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"function.h\"\n #include \"target.h\"\n #include \"langhooks.h\"\n+#include \"obstack.h\"\n \n #ifdef XCOFF_DEBUGGING_INFO\n #include \"xcoffout.h\"\n@@ -101,13 +102,21 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   do {--debug_nesting; return (x);} while (0)\n \n #ifndef ASM_STABS_OP\n-#define ASM_STABS_OP \"\\t.stabs\\t\"\n+# ifdef XCOFF_DEBUGGING_INFO\n+#  define ASM_STABS_OP \"\\t.stabx\\t\"\n+# else\n+#  define ASM_STABS_OP \"\\t.stabs\\t\"\n+# endif\n #endif\n \n #ifndef ASM_STABN_OP\n #define ASM_STABN_OP \"\\t.stabn\\t\"\n #endif\n \n+#ifndef ASM_STABD_OP\n+#define ASM_STABD_OP \"\\t.stabd\\t\"\n+#endif\n+\n #ifndef DBX_TYPE_DECL_STABS_CODE\n #define DBX_TYPE_DECL_STABS_CODE N_LSYM\n #endif\n@@ -132,6 +141,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define NO_DBX_BNSYM_ENSYM 0\n #endif\n \n+#ifndef NO_DBX_MAIN_SOURCE_DIRECTORY\n+#define NO_DBX_MAIN_SOURCE_DIRECTORY 0\n+#endif\n+\n #ifndef DBX_BLOCKS_FUNCTION_RELATIVE\n #define DBX_BLOCKS_FUNCTION_RELATIVE 0\n #endif\n@@ -140,6 +153,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define DBX_LINES_FUNCTION_RELATIVE 0\n #endif\n \n+#ifndef DBX_CONTIN_LENGTH\n+#define DBX_CONTIN_LENGTH 80\n+#endif\n+\n+#ifndef DBX_CONTIN_CHAR\n+#define DBX_CONTIN_CHAR '\\\\'\n+#endif\n+\n enum typestatus {TYPE_UNSEEN, TYPE_XREF, TYPE_DEFINED};\n \n /* Structure recording information about a C data type.\n@@ -281,42 +302,11 @@ static const char *base_input_file;\n #define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n #endif\n \n-/* These variables are for dbxout_symbol to communicate to\n-   dbxout_finish_symbol.\n-   current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.\n-   current_sym_value and current_sym_addr are two ways to address the\n-   value to store in the symtab entry.\n-   current_sym_addr if nonzero represents the value as an rtx.\n-   If that is zero, current_sym_value is used.  This is used\n-   when the value is an offset (such as for auto variables,\n-   register variables and parms).  */\n-\n-static STAB_CODE_TYPE current_sym_code;\n-static int current_sym_value;\n-static rtx current_sym_addr;\n-\n-/* Number of chars of symbol-description generated so far for the\n-   current symbol.  Used by CHARS and CONTIN.  */\n-\n-static int current_sym_nchars;\n-\n-/* Report having output N chars of the current symbol-description.  */\n-\n-#define CHARS(N) (current_sym_nchars += (N))\n-\n-/* Break the current symbol-description, generating a continuation,\n-   if it has become long.  */\n-\n-#ifndef DBX_CONTIN_LENGTH\n-#define DBX_CONTIN_LENGTH 80\n-#endif\n-\n-#if DBX_CONTIN_LENGTH > 0\n-#define CONTIN  \\\n-  do {if (current_sym_nchars > DBX_CONTIN_LENGTH) dbxout_continue ();} while (0)\n-#else\n-#define CONTIN do { } while (0)\n-#endif\n+/* This obstack holds the stab string currently being constructed.  We\n+   build it up here, then write it out, so we can split long lines up\n+   properly (see dbxout_finish_complex_stabs).  */\n+static struct obstack stabstr_ob;\n+static size_t stabstr_last_contin_point;\n \n #ifdef DBX_USE_BINCL\n static void emit_bincl_stab             (const char *c);\n@@ -325,33 +315,23 @@ static void emit_pending_bincls         (void);\n static inline void emit_pending_bincls_if_required (void);\n \n static void dbxout_init (const char *);\n-#ifndef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n-static unsigned int get_lang_number (void);\n-#endif\n+ \n static void dbxout_finish (const char *);\n static void dbxout_start_source_file (unsigned, const char *);\n static void dbxout_end_source_file (unsigned);\n static void dbxout_typedefs (tree);\n static void dbxout_type_index (tree);\n-#if DBX_CONTIN_LENGTH > 0\n-static void dbxout_continue (void);\n-#endif\n static void dbxout_args (tree);\n static void dbxout_type_fields (tree);\n-static void dbxout_type_method_1 (tree, const char *);\n+static void dbxout_type_method_1 (tree);\n static void dbxout_type_methods (tree);\n static void dbxout_range_type (tree);\n static void dbxout_type (tree, int);\n static bool print_int_cst_bounds_in_octal_p (tree);\n-static void print_int_cst_octal (tree);\n-static void print_octal (unsigned HOST_WIDE_INT, int);\n-static void print_wide_int (HOST_WIDE_INT);\n static void dbxout_type_name (tree);\n static void dbxout_class_name_qualifiers (tree);\n static int dbxout_symbol_location (tree, tree, const char *, rtx);\n static void dbxout_symbol_name (tree, const char *, int);\n-static void dbxout_prepare_symbol (tree);\n-static void dbxout_finish_symbol (tree);\n static void dbxout_block (tree, int, tree);\n static void dbxout_global_decl (tree);\n static void dbxout_type_decl (tree, int);\n@@ -362,7 +342,7 @@ static void dbxout_handle_pch (unsigned);\n \n static void dbxout_source_line (unsigned int, const char *);\n static void dbxout_begin_prologue (unsigned int, const char *);\n-static void dbxout_source_file (FILE *, const char *);\n+static void dbxout_source_file (const char *);\n static void dbxout_function_end (void);\n static void dbxout_begin_function (tree);\n static void dbxout_begin_block (unsigned, unsigned);\n@@ -432,7 +412,483 @@ const struct gcc_debug_hooks xcoff_debug_hooks =\n };\n #endif /* XCOFF_DEBUGGING_INFO  */\n \f\n+/* Numeric formatting helper macro.  Note that this does not handle\n+   hexadecimal.  */\n+#define NUMBER_FMT_LOOP(P, NUM, BASE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      int digit = NUM % BASE;\t\t\t\\\n+      NUM /= BASE;\t\t\t\t\\\n+      *--P = digit + '0';\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (NUM > 0)\n+\n+/* Utility: write a decimal integer NUM to asm_out_file.  */\n+void\n+dbxout_int (int num)\n+{\n+  char buf[64];\n+  char *p = buf + sizeof buf;\n+  unsigned int unum;\n+\n+  if (num == 0)\n+    {\n+      putc ('0', asm_out_file);\n+      return;\n+    }\n+  if (num < 0)\n+    {\n+      putc ('-', asm_out_file);\n+      unum = -num;\n+    }\n+  else\n+    unum = num;\n+\n+  NUMBER_FMT_LOOP (p, unum, 10);\n+\n+  while (p < buf + sizeof buf)\n+    {\n+      putc (*p, asm_out_file);\n+      p++;\n+    }\n+}\n+\n+\f\n+/* Primitives for emitting simple stabs directives.  All other stabs\n+   routines should use these functions instead of directly emitting\n+   stabs.  They are exported because machine-dependent code may need\n+   to invoke them, e.g. in a DBX_OUTPUT_* macro whose definition\n+   forwards to code in CPU.c.  */\n+\n+/* The following functions should all be called immediately after one\n+   of the dbxout_begin_stab* functions (below).  They write out\n+   various things as the value of a stab.  */\n+\n+/* Write out a literal zero as the value of a stab.  */\n+void\n+dbxout_stab_value_zero (void)\n+{\n+  fputs (\"0\\n\", asm_out_file);\n+}\n+\n+/* Write out the label LABEL as the value of a stab.  */\n+void\n+dbxout_stab_value_label (const char *label)\n+{\n+  assemble_name (asm_out_file, label);\n+  putc ('\\n', asm_out_file);\n+}\n+\n+/* Write out the difference of two labels, LABEL - BASE, as the value\n+   of a stab.  */\n+void\n+dbxout_stab_value_label_diff (const char *label, const char *base)\n+{\n+  assemble_name (asm_out_file, label);\n+  putc ('-', asm_out_file);\n+  assemble_name (asm_out_file, base);\n+  putc ('\\n', asm_out_file);\n+}\n+\n+/* Write out an internal label as the value of a stab, and immediately\n+   emit that internal label.  This should be used only when\n+   dbxout_stabd will not work.  STEM is the name stem of the label,\n+   COUNTERP is a pointer to a counter variable which will be used to\n+   guarantee label uniqueness.  */\n+void\n+dbxout_stab_value_internal_label (const char *stem, int *counterp)\n+{\n+  char label[100];\n+  int counter = counterp ? (*counterp)++ : 0;\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, stem, counter);\n+  dbxout_stab_value_label (label);\n+  targetm.asm_out.internal_label (asm_out_file, stem, counter);\n+}\n+\n+/* Write out the difference between BASE and an internal label as the\n+   value of a stab, and immediately emit that internal label.  STEM and\n+   COUNTERP are as for dbxout_stab_value_internal_label.  */\n+void\n+dbxout_stab_value_internal_label_diff (const char *stem, int *counterp,\n+\t\t\t\t       const char *base)\n+{\n+  char label[100];\n+  int counter = counterp ? (*counterp)++ : 0;\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, stem, counter);\n+  dbxout_stab_value_label_diff (label, base);\n+  targetm.asm_out.internal_label (asm_out_file, stem, counter);\n+}\n+\n+/* The following functions produce specific kinds of stab directives.  */\n+\n+/* Write a .stabd directive with type STYPE and desc SDESC to asm_out_file.  */\n+void\n+dbxout_stabd (int stype, int sdesc)\n+{\n+  fputs (ASM_STABD_OP, asm_out_file);\n+  dbxout_int (stype);\n+  fputs (\",0,\", asm_out_file);\n+  dbxout_int (sdesc);\n+  putc ('\\n', asm_out_file);\n+}\n+\n+/* Write a .stabn directive with type STYPE.  This function stops\n+   short of emitting the value field, which is the responsibility of\n+   the caller (normally it will be either a symbol or the difference\n+   of two symbols).  */\n+\n+void\n+dbxout_begin_stabn (int stype)\n+{\n+  fputs (ASM_STABN_OP, asm_out_file);\n+  dbxout_int (stype);\n+  fputs (\",0,0,\", asm_out_file);\n+}\n+\n+/* Write a .stabn directive with type N_SLINE and desc LINE.  As above,\n+   the value field is the responsibility of the caller.  */\n+void\n+dbxout_begin_stabn_sline (int lineno)\n+{\n+  fputs (ASM_STABN_OP, asm_out_file);\n+  dbxout_int (N_SLINE);\n+  fputs (\",0,\", asm_out_file);\n+  dbxout_int (lineno);\n+  putc (',', asm_out_file);\n+}\n+\n+/* Begin a .stabs directive with string \"\", type STYPE, and desc and\n+   other fields 0.  The value field is the responsibility of the\n+   caller.  This function cannot be used for .stabx directives.  */\n+void\n+dbxout_begin_empty_stabs (int stype)\n+{\n+  fputs (ASM_STABS_OP, asm_out_file);\n+  fputs (\"\\\"\\\",\", asm_out_file);\n+  dbxout_int (stype);\n+  fputs (\",0,0,\", asm_out_file);\n+}\n+\n+/* Begin a .stabs directive with string STR, type STYPE, and desc 0.\n+   The value field is the responsibility of the caller.  */\n+void\n+dbxout_begin_simple_stabs (const char *str, int stype)\n+{\n+  fputs (ASM_STABS_OP, asm_out_file);\n+  output_quoted_string (asm_out_file, str);\n+  putc (',', asm_out_file);\n+  dbxout_int (stype);\n+  fputs (\",0,0,\", asm_out_file);\n+}\n+\n+/* As above but use SDESC for the desc field.  */\n+void\n+dbxout_begin_simple_stabs_desc (const char *str, int stype, int sdesc)\n+{\n+  fputs (ASM_STABS_OP, asm_out_file);\n+  output_quoted_string (asm_out_file, str);\n+  putc (',', asm_out_file);\n+  dbxout_int (stype);\n+  fputs (\",0,\", asm_out_file);\n+  dbxout_int (sdesc);\n+  putc (',', asm_out_file);\n+}\n+\n+/* The next set of functions are entirely concerned with production of\n+   \"complex\" .stabs directives: that is, .stabs directives whose\n+   strings have to be constructed piecemeal.  dbxout_type,\n+   dbxout_symbol, etc. use these routines heavily.  The string is queued\n+   up in an obstack, then written out by dbxout_finish_complex_stabs, which\n+   is also responsible for splitting it up if it exceeds DBX_CONTIN_LENGTH.\n+   (You might think it would be more efficient to go straight to stdio\n+   when DBX_CONTIN_LENGTH is 0 (i.e. no length limit) but that turns\n+   out not to be the case, and anyway this needs fewer #ifdefs.)  */\n+\n+/* Begin a complex .stabs directive.  If we can, write the initial\n+   ASM_STABS_OP to the asm_out_file.  */\n+\n+static void\n+dbxout_begin_complex_stabs (void)\n+{\n+  emit_pending_bincls_if_required ();\n+  FORCE_TEXT;\n+  fputs (ASM_STABS_OP, asm_out_file);\n+  putc ('\"', asm_out_file);\n+  gcc_assert (stabstr_last_contin_point == 0);\n+}\n+\n+/* Add CHR, a single character, to the string being built.  */\n+#define stabstr_C(chr) obstack_1grow (&stabstr_ob, chr)\n+\n+/* Add STR, a normal C string, to the string being built.  */\n+#define stabstr_S(str) obstack_grow (&stabstr_ob, str, strlen(str))\n+\n+/* Add the text of ID, an IDENTIFIER_NODE, to the string being built.  */\n+#define stabstr_I(id) obstack_grow (&stabstr_ob, \\\n+                                    IDENTIFIER_POINTER (id), \\\n+                                    IDENTIFIER_LENGTH (id))\n+\n+/* Add NUM, a signed decimal number, to the string being built.  */\n+static void\n+stabstr_D (HOST_WIDE_INT num)\n+{\n+  char buf[64];\n+  char *p = buf + sizeof buf;\n+  unsigned int unum;\n+\n+  if (num == 0)\n+    {\n+      stabstr_C ('0');\n+      return;\n+    }\n+  if (num < 0)\n+    {\n+      stabstr_C ('-');\n+      unum = -num;\n+    }\n+  else\n+    unum = num;\n+\n+  NUMBER_FMT_LOOP (p, unum, 10);\n+\n+  obstack_grow (&stabstr_ob, p, (buf + sizeof buf) - p);\n+}\n+\n+/* Add NUM, an unsigned decimal number, to the string being built.  */\n+static void\n+stabstr_U (unsigned HOST_WIDE_INT num)\n+{\n+  char buf[64];\n+  char *p = buf + sizeof buf;\n+  if (num == 0)\n+    {\n+      stabstr_C ('0');\n+      return;\n+    }\n+  NUMBER_FMT_LOOP (p, num, 10);\n+  obstack_grow (&stabstr_ob, p, (buf + sizeof buf) - p);\n+}\n+\n+/* Add CST, an INTEGER_CST tree, to the string being built as an\n+   unsigned octal number.  This routine handles values which are\n+   larger than a single HOST_WIDE_INT.  */\n+static void\n+stabstr_O (tree cst)\n+{\n+  unsigned HOST_WIDE_INT high = TREE_INT_CST_HIGH (cst);\n+  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (cst);\n+\n+  char buf[128];\n+  char *p = buf + sizeof buf;\n+\n+  /* GDB wants constants with no extra leading \"1\" bits, so\n+     we need to remove any sign-extension that might be\n+     present.  */\n+  {\n+    const unsigned int width = TYPE_PRECISION (TREE_TYPE (cst));\n+    if (width == HOST_BITS_PER_WIDE_INT * 2)\n+      ;\n+    else if (width > HOST_BITS_PER_WIDE_INT)\n+      high &= (((HOST_WIDE_INT) 1 << (width - HOST_BITS_PER_WIDE_INT)) - 1);\n+    else if (width == HOST_BITS_PER_WIDE_INT)\n+      high = 0;\n+    else\n+      high = 0, low &= (((HOST_WIDE_INT) 1 << width) - 1);\n+  }\n+\n+  /* Leading zero for base indicator.  */\n+  stabstr_C ('0');\n+\n+  /* If the value is zero, the base indicator will serve as the value\n+     all by itself.  */\n+  if (high == 0 && low == 0)\n+    return;\n+\n+  /* If the high half is zero, we need only print the low half normally.  */\n+  if (high == 0)\n+    NUMBER_FMT_LOOP (p, low, 8);\n+  else\n+    {\n+      /* When high != 0, we need to print enough zeroes from low to\n+\t give the digits from high their proper place-values.  Hence\n+\t NUMBER_FMT_LOOP cannot be used.  */\n+      const int n_digits = HOST_BITS_PER_WIDE_INT / 3;\n+      int i;\n+\n+      for (i = 1; i <= n_digits; i++)\n+\t{\n+\t  unsigned int digit = low % 8;\n+\t  low /= 8;\n+\t  *--p = '0' + digit;\n+\t}\n+\n+      /* Octal digits carry exactly three bits of information.  The\n+\t width of a HOST_WIDE_INT is not normally a multiple of three.\n+\t Therefore, the next digit printed probably needs to carry\n+\t information from both low and high.  */\n+      if (HOST_BITS_PER_WIDE_INT % 3 != 0)\n+\t{\n+\t  const int n_leftover_bits = HOST_BITS_PER_WIDE_INT % 3;\n+\t  const int n_bits_from_high = 3 - n_leftover_bits;\n+\n+\t  const unsigned HOST_WIDE_INT\n+\t    low_mask = (((unsigned HOST_WIDE_INT)1) << n_leftover_bits) - 1;\n+\t  const unsigned HOST_WIDE_INT\n+\t    high_mask = (((unsigned HOST_WIDE_INT)1) << n_bits_from_high) - 1;\n+\n+\t  unsigned int digit;\n+\n+\t  /* At this point, only the bottom n_leftover_bits bits of low\n+\t     should be set.  */\n+\t  gcc_assert (!(low & ~low_mask));\n+\n+\t  digit = (low | ((high & high_mask) << n_leftover_bits));\n+\t  high >>= n_bits_from_high;\n+\n+\t  *--p = '0' + digit;\n+\t}\n+\n+      /* Now we can format high in the normal manner.  However, if\n+\t the only bits of high that were set were handled by the\n+\t digit split between low and high, high will now be zero, and\n+\t we don't want to print extra digits in that case.  */\n+      if (high)\n+\tNUMBER_FMT_LOOP (p, high, 8);\n+    }\n+\n+  obstack_grow (&stabstr_ob, p, (buf + sizeof buf) - p);\n+}\n+\n+/* Called whenever it is safe to break a stabs string into multiple\n+   .stabs directives.  If the current string has exceeded the limit\n+   set by DBX_CONTIN_LENGTH, mark the current position in the buffer\n+   as a continuation point by inserting DBX_CONTIN_CHAR (doubled if\n+   it is a backslash) and a null character.  */\n+static inline void\n+stabstr_continue (void)\n+{\n+  if (DBX_CONTIN_LENGTH > 0\n+      && obstack_object_size (&stabstr_ob) - stabstr_last_contin_point\n+\t > DBX_CONTIN_LENGTH)\n+    {\n+      if (DBX_CONTIN_CHAR == '\\\\')\n+\tobstack_1grow (&stabstr_ob, '\\\\');\n+      obstack_1grow (&stabstr_ob, DBX_CONTIN_CHAR);\n+      obstack_1grow (&stabstr_ob, '\\0');\n+      stabstr_last_contin_point = obstack_object_size (&stabstr_ob);\n+    }\n+}\n+#define CONTIN stabstr_continue ()\n+\n+/* Macro subroutine of dbxout_finish_complex_stabs, which emits\n+   all of the arguments to the .stabs directive after the string.\n+   Overridden by xcoffout.h.  CODE is the stabs code for this symbol;\n+   LINE is the source line to write into the desc field (in extended\n+   mode).\n+\n+   ADDR, LABEL, and NUMBER are three different ways to represent the\n+   stabs value field.  At most one of these should be nonzero.\n+\n+     ADDR is used most of the time; it represents the value as an\n+     RTL address constant.\n+\n+     LABEL is used (currently) only for N_CATCH stabs; it represents\n+     the value as a string suitable for assemble_name.\n+\n+     NUMBER is used when the value is an offset from an implicit base\n+     pointer (e.g. for a stack variable), or an index (e.g. for a\n+     register variable).  It represents the value as a decimal integer.  */\n+\n+#ifndef DBX_FINISH_STABS\n+#define DBX_FINISH_STABS(CODE, LINE, ADDR, LABEL, NUMBER) do {\t\\\n+  int line_ = use_gnu_debug_info_extensions ? LINE : 0;\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  dbxout_int (CODE);\t\t\t\t\t\t\\\n+  fputs (\",0,\", asm_out_file);\t\t\t\t\t\\\n+  dbxout_int (line_);\t\t\t\t\t\t\\\n+  putc (',', asm_out_file);\t\t\t\t\t\\\n+  if (ADDR)\t\t\t\t\t\t\t\\\n+    output_addr_const (asm_out_file, ADDR);\t\t\t\\\n+  else if (LABEL)\t\t\t\t\t\t\\\n+    assemble_name (asm_out_file, LABEL);\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\\\n+    dbxout_int (NUMBER);\t\t\t\t\t\\\n+  putc ('\\n', asm_out_file);\t\t\t\t\t\\\n+} while (0)\n+#endif\n+\n+/* Finish the emission of a complex .stabs directive.  When DBX_CONTIN_LENGTH\n+   is zero, this has only to emit the close quote and the remainder of\n+   the arguments.  When it is nonzero, the string has been marshalled in\n+   stabstr_ob, and this routine is responsible for breaking it up into\n+   DBX_CONTIN_LENGTH-sized chunks.\n+\n+   SYM is the DECL of the symbol under consideration; it is used only\n+   for its DECL_SOURCE_LINE.  The other arguments are all passed directly\n+   to DBX_FINISH_STABS; see above for details.  */\n+   \n+static void\n+dbxout_finish_complex_stabs (tree sym, STAB_CODE_TYPE code,\n+\t\t\t     rtx addr, const char *label, int number)\n+{\n+  int line = sym ? DECL_SOURCE_LINE (sym) : 0;\n+  char *str;\n+  size_t len;\n+\n+  if (DBX_CONTIN_LENGTH > 0)\n+    {\n+      char *chunk;\n+      size_t chunklen;\n+\n+      /* Nul-terminate the growing string, then get its size and\n+\t address.  */\n+      obstack_1grow (&stabstr_ob, '\\0');\n+\n+      len = obstack_object_size (&stabstr_ob);\n+      chunk = str = obstack_finish (&stabstr_ob);\n+\n+      /* Within the buffer are a sequence of NUL-separated strings,\n+\t each of which is to be written out as a separate stab\n+\t directive.  */\n+      for (;;)\n+\t{\n+\t  chunklen = strlen (chunk);\n+\t  fwrite (chunk, 1, chunklen, asm_out_file);\n+\t  fputs (\"\\\",\", asm_out_file);\n+\n+\t  /* Must add an extra byte to account for the NUL separator.  */\n+\t  chunk += chunklen + 1;\n+\t  len   -= chunklen + 1;\n+\n+\t  /* Only put a line number on the last stab in the sequence.  */\n+\t  DBX_FINISH_STABS (code, len == 0 ? line : 0, addr, label, number);\n+\t  if (len == 0)\n+\t    break;\n+\n+\t  fputs (ASM_STABS_OP, asm_out_file);\n+\t  putc ('\"', asm_out_file);\n+\t}\n+      stabstr_last_contin_point = 0;\n+    }\n+  else\n+    {\n+      /* No continuations - we can put the whole string out at once.\n+\t It is faster to augment the string with the close quote and\n+\t comma than to do a two-character fputs.  */\n+      obstack_grow (&stabstr_ob, \"\\\",\", 2);\n+      len = obstack_object_size (&stabstr_ob);\n+      str = obstack_finish (&stabstr_ob);\n+      \n+      fwrite (str, 1, len, asm_out_file);\n+      DBX_FINISH_STABS (code, line, addr, label, number);\n+    }\n+  obstack_free (&stabstr_ob, str);\n+}\n+\n #if defined (DBX_DEBUGGING_INFO)\n+\n static void\n dbxout_function_end (void)\n {\n@@ -442,7 +898,7 @@ dbxout_function_end (void)\n      else; dbxout_block needs it.  */\n   function_section (current_function_decl);\n   \n-  /* Convert Ltext into the appropriate format for local labels in case\n+  /* Convert Lscope into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n      labels.  */\n   ASM_GENERATE_INTERNAL_LABEL (lscope_label_name, \"Lscope\", scope_labelno);\n@@ -462,22 +918,19 @@ dbxout_function_end (void)\n #ifdef DBX_OUTPUT_NFUN\n   DBX_OUTPUT_NFUN (asm_out_file, lscope_label_name, current_function_decl);\n #else\n-  fprintf (asm_out_file, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_FUN);\n-  assemble_name (asm_out_file, lscope_label_name);\n-  putc ('-', asm_out_file);\n-  assemble_name (asm_out_file, XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n-  fprintf (asm_out_file, \"\\n\");\n+  dbxout_begin_empty_stabs (N_FUN);\n+  dbxout_stab_value_label_diff (lscope_label_name,\n+\t\t\t\tXSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n+\t\t\t\t\n #endif\n \n   if (!NO_DBX_BNSYM_ENSYM && !flag_debug_only_used_symbols)\n-    fprintf (asm_out_file, \"%s%d,0,0\\n\", ASM_STABD_OP, N_ENSYM);\n+    dbxout_stabd (N_ENSYM, 0);\n }\n #endif /* DBX_DEBUGGING_INFO */\n \n-#ifndef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n /* Get lang description for N_SO stab.  */\n-\n-static unsigned int\n+static unsigned int ATTRIBUTE_UNUSED\n get_lang_number (void)\n {\n   const char *language_string = lang_hooks.name;\n@@ -498,7 +951,6 @@ get_lang_number (void)\n     return 0;\n \n }\n-#endif\n \n /* At the beginning of compilation, start writing the symbol table.\n    Initialize `typevec' and output the standard data types of C.  */\n@@ -507,18 +959,23 @@ static void\n dbxout_init (const char *input_file_name)\n {\n   char ltext_label_name[100];\n+  bool used_ltext_label_name = false;\n   tree syms = lang_hooks.decls.getdecls ();\n \n   typevec_len = 100;\n   typevec = ggc_calloc (typevec_len, sizeof typevec[0]);\n \n+  /* stabstr_ob contains one string, which will be just fine with\n+     1-byte alignment.  */\n+  obstack_specify_allocation (&stabstr_ob, 0, 1, xmalloc, free);\n+\n   /* Convert Ltext into the appropriate format for local labels in case\n      the system doesn't insert underscores in front of user generated\n      labels.  */\n   ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\", 0);\n \n   /* Put the current working directory in an N_SO symbol.  */\n-  if (use_gnu_debug_info_extensions)\n+  if (use_gnu_debug_info_extensions && !NO_DBX_MAIN_SOURCE_DIRECTORY)\n     {\n       static const char *cwd;\n \n@@ -530,40 +987,34 @@ dbxout_init (const char *input_file_name)\n \t  else if (!IS_DIR_SEPARATOR (cwd[strlen (cwd) - 1]))\n \t    cwd = concat (cwd, \"/\", NULL);\n \t}\n-\n #ifdef DBX_OUTPUT_MAIN_SOURCE_DIRECTORY\n       DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (asm_out_file, cwd);\n #else /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n-      fprintf (asm_out_file, \"%s\", ASM_STABS_OP);\n-      output_quoted_string (asm_out_file, cwd);\n-      fprintf (asm_out_file, \",%d,0,%d,\", N_SO, get_lang_number ());\n-      assemble_name (asm_out_file, ltext_label_name);\n-      fputc ('\\n', asm_out_file);\n+      dbxout_begin_simple_stabs_desc (cwd, N_SO, get_lang_number ());\n+      dbxout_stab_value_label (ltext_label_name);\n+      used_ltext_label_name = true;\n #endif /* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */\n     }\n \n #ifdef DBX_OUTPUT_MAIN_SOURCE_FILENAME\n   DBX_OUTPUT_MAIN_SOURCE_FILENAME (asm_out_file, input_file_name);\n-#else /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n-  /* We include outputting `Ltext:' here,\n-     because that gives you a way to override it.  */\n-  /* Used to put `Ltext:' before the reference, but that loses on sun 4.  */\n-  fprintf (asm_out_file, \"%s\", ASM_STABS_OP);\n-  output_quoted_string (asm_out_file, input_file_name);\n-  fprintf (asm_out_file, \",%d,0,%d,\", N_SO, get_lang_number ());\n-  assemble_name (asm_out_file, ltext_label_name);\n-  fputc ('\\n', asm_out_file);\n-  text_section ();\n-  targetm.asm_out.internal_label (asm_out_file, \"Ltext\", 0);\n-#endif /* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */\n-\n-#ifdef DBX_OUTPUT_GCC_MARKER\n-  DBX_OUTPUT_GCC_MARKER (asm_out_file);\n #else\n+  dbxout_begin_simple_stabs_desc (input_file_name, N_SO, get_lang_number ());\n+  dbxout_stab_value_label (ltext_label_name);\n+  used_ltext_label_name = true;\n+#endif\n+\n+  if (used_ltext_label_name)\n+    {\n+      text_section ();\n+      targetm.asm_out.internal_label (asm_out_file, \"Ltext\", 0);\n+    }\n+\n   /* Emit an N_OPT stab to indicate that this file was compiled by GCC.\n      The string used is historical.  */\n-  fprintf (asm_out_file, \"%s\\\"gcc2_compiled.\\\",%d,0,0,0\\n\",\n-\t   ASM_STABS_OP, N_OPT);\n+#ifndef NO_DBX_GCC_MARKER\n+  dbxout_begin_simple_stabs (\"gcc2_compiled.\", N_OPT);\n+  dbxout_stab_value_zero ();\n #endif\n \n   base_input_file = lastfile = input_file_name;\n@@ -621,9 +1072,8 @@ dbxout_typedefs (tree syms)\n static void\n emit_bincl_stab (const char *name)\n {\n-  fprintf (asm_out_file, \"%s\", ASM_STABS_OP);\n-  output_quoted_string (asm_out_file, name);\n-  fprintf (asm_out_file, \",%d,0,0,0\\n\", N_BINCL);\n+  dbxout_begin_simple_stabs (name, N_BINCL);\n+  dbxout_stab_value_zero ();\n }\n \n /* If there are pending bincls then it is time to emit all of them.  */\n@@ -705,7 +1155,10 @@ dbxout_end_source_file (unsigned int line ATTRIBUTE_UNUSED)\n #ifdef DBX_USE_BINCL\n   /* Emit EINCL stab only if BINCL is not pending.  */\n   if (current_file->bincl_status == BINCL_PROCESSED)\n-    fprintf (asm_out_file, \"%s%d,0,0,0\\n\", ASM_STABN_OP, N_EINCL);\n+    {\n+      dbxout_begin_stabn (N_EINCL);\n+      dbxout_stab_value_zero ();\n+    }\n   current_file->bincl_status = BINCL_NOT_REQUIRED;\n   current_file = current_file->next;\n #endif\n@@ -740,7 +1193,7 @@ dbxout_handle_pch (unsigned at_end)\n /* Output debugging info to FILE to switch to sourcefile FILENAME.  */\n \n static void\n-dbxout_source_file (FILE *file, const char *filename)\n+dbxout_source_file (const char *filename)\n {\n   if (lastfile == 0 && lastfile_is_base)\n     {\n@@ -750,21 +1203,12 @@ dbxout_source_file (FILE *file, const char *filename)\n \n   if (filename && (lastfile == 0 || strcmp (filename, lastfile)))\n     {\n-      char ltext_label_name[100];\n-\n-      ASM_GENERATE_INTERNAL_LABEL (ltext_label_name, \"Ltext\",\n-\t\t\t\t   source_label_number);\n-      fprintf (file, \"%s\", ASM_STABS_OP);\n-      output_quoted_string (file, filename);\n-      fprintf (asm_out_file, \",%d,0,0,\", N_SOL);\n-      assemble_name (asm_out_file, ltext_label_name);\n-      fputc ('\\n', asm_out_file);\n-      if (current_function_decl != NULL_TREE)\n-\t; /* Don't change section amid function.  */\n-      else\n+      /* Don't change section amid function.  */\n+      if (current_function_decl == NULL_TREE)\n \ttext_section ();\n-      targetm.asm_out.internal_label (file, \"Ltext\", source_label_number);\n-      source_label_number++;\n+\n+      dbxout_begin_simple_stabs (filename, N_SOL);\n+      dbxout_stab_value_internal_label (\"Ltext\", &source_label_number);\n       lastfile = filename;\n     }\n }\n@@ -778,7 +1222,7 @@ dbxout_begin_prologue (unsigned int lineno, const char *filename)\n       && !NO_DBX_FUNCTION_END\n       && !NO_DBX_BNSYM_ENSYM\n       && !flag_debug_only_used_symbols)\n-    fprintf (asm_out_file, \"%s%d,0,0\\n\", ASM_STABD_OP, N_BNSYM);\n+    dbxout_stabd (N_BNSYM, 0);\n \n   dbxout_source_line (lineno, filename);\n }\n@@ -789,29 +1233,22 @@ dbxout_begin_prologue (unsigned int lineno, const char *filename)\n static void\n dbxout_source_line (unsigned int lineno, const char *filename)\n {\n-  dbxout_source_file (asm_out_file, filename);\n+  const char *begin_label = XSTR(XEXP(DECL_RTL(current_function_decl), 0), 0);\n+\n+  dbxout_source_file (filename);\n \n #ifdef DBX_OUTPUT_SOURCE_LINE\n-  dbxout_source_line_counter += 1;\n   DBX_OUTPUT_SOURCE_LINE (asm_out_file, lineno, dbxout_source_line_counter);\n #else\n   if (DBX_LINES_FUNCTION_RELATIVE)\n     {\n-      char label[100];\n-      dbxout_source_line_counter += 1;\n+      dbxout_begin_stabn_sline (lineno);\n+      dbxout_stab_value_internal_label_diff (\"LM\", &dbxout_source_line_counter,\n+\t\t\t\t\t     begin_label);\n \n-      ASM_GENERATE_INTERNAL_LABEL (label, \"LM\", dbxout_source_line_counter);\n-      fprintf (asm_out_file, \"%s%d,0,%d,\", ASM_STABN_OP, N_SLINE, lineno);\n-      assemble_name (asm_out_file, label);\n-      putc ('-', asm_out_file);\n-      assemble_name (asm_out_file,\n-\t\t     XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0));\n-      putc ('\\n', asm_out_file);\n-      targetm.asm_out.internal_label (asm_out_file, \"LM\",\n-\t\t\t\t      dbxout_source_line_counter);\n     }\n   else\n-    fprintf (asm_out_file, \"%s%d,0,%d\\n\", ASM_STABD_OP, N_SLINE, lineno);\n+    dbxout_stabd (N_SLINE, lineno);\n #endif\n }\n \n@@ -886,12 +1323,9 @@ dbxout_finish (const char *filename ATTRIBUTE_UNUSED)\n   DBX_OUTPUT_MAIN_SOURCE_FILE_END (asm_out_file, filename);\n #elif defined DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END\n  {\n-   char letext_label[100];\n-   ASM_GENERATE_INTERNAL_LABEL (letext_label, \"Letext\", 0);\n-   fprintf (asm_out_file, \"%s\\\"\\\",%d,0,0,\", ASM_STABS_OP, N_SO);\n-   assemble_name (asm_out_file, letext_label);\n-   putc ('\\n', asm_out_file);\n-   targetm.asm_out.internal_label (asm_out_file, \"Letext\", 0);\n+   text_section ();\n+   dbxout_begin_empty_stabs (N_SO);\n+   dbxout_stab_value_internal_label (\"Letext\", 0);\n  }\n #endif\n   debug_free_queue ();\n@@ -903,37 +1337,24 @@ static void\n dbxout_type_index (tree type)\n {\n #ifndef DBX_USE_BINCL\n-  fprintf (asm_out_file, \"%d\", TYPE_SYMTAB_ADDRESS (type));\n-  CHARS (3);\n+  stabstr_D (TYPE_SYMTAB_ADDRESS (type));\n #else\n   struct typeinfo *t = &typevec[TYPE_SYMTAB_ADDRESS (type)];\n-  fprintf (asm_out_file, \"(%d,%d)\", t->file_number, t->type_number);\n-  CHARS (9);\n+  stabstr_C ('(');\n+  stabstr_D (t->file_number);\n+  stabstr_C (',');\n+  stabstr_D (t->type_number);\n+  stabstr_C (')');\n #endif\n }\n \n-#if DBX_CONTIN_LENGTH > 0\n-/* Continue a symbol-description that gets too big.\n-   End one symbol table entry with a double-backslash\n-   and start a new one, eventually producing something like\n-   .stabs \"start......\\\\\",code,0,value\n-   .stabs \"...rest\",code,0,value   */\n-\n-static void\n-dbxout_continue (void)\n-{\n-  emit_pending_bincls_if_required ();\n-#ifdef DBX_CONTIN_CHAR\n-  fprintf (asm_out_file, \"%c\", DBX_CONTIN_CHAR);\n-#else\n-  fprintf (asm_out_file, \"\\\\\\\\\");\n-#endif\n-  dbxout_finish_symbol (NULL_TREE);\n-  fprintf (asm_out_file, \"%s\\\"\", ASM_STABS_OP);\n-  current_sym_nchars = 0;\n-}\n-#endif /* DBX_CONTIN_LENGTH > 0 */\n \f\n+\n+/* Used in several places: evaluates to '0' for a private decl,\n+   '1' for a protected decl, '2' for a public decl.  */\n+#define DECL_ACCESSIBILITY_CHAR(DECL) \\\n+(TREE_PRIVATE (DECL) ? '0' : TREE_PROTECTED (DECL) ? '1' : '2')\n+\n /* Subroutine of `dbxout_type'.  Output the type fields of TYPE.\n    This must be a separate function because anonymous unions require\n    recursive calls.  */\n@@ -972,26 +1393,16 @@ dbxout_type_fields (tree type)\n \t    CONTIN;\n \n \t  if (DECL_NAME (tem))\n-\t    {\n-\t      fprintf (asm_out_file, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (tem)));\n-\t      CHARS (2 + IDENTIFIER_LENGTH (DECL_NAME (tem)));\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf (asm_out_file, \":\");\n-\t      CHARS (1);\n-\t    }\n+\t    stabstr_I (DECL_NAME (tem));\n+\t  stabstr_C (':');\n \n \t  if (use_gnu_debug_info_extensions\n \t      && (TREE_PRIVATE (tem) || TREE_PROTECTED (tem)\n \t\t  || TREE_CODE (tem) != FIELD_DECL))\n \t    {\n \t      have_used_extensions = 1;\n-\t      putc ('/', asm_out_file);\n-\t      putc ((TREE_PRIVATE (tem) ? '0'\n-\t\t     : TREE_PROTECTED (tem) ? '1' : '2'),\n-\t\t    asm_out_file);\n-\t      CHARS (2);\n+\t      stabstr_C ('/');\n+\t      stabstr_C (DECL_ACCESSIBILITY_CHAR (tem));\n \t    }\n \n \t  dbxout_type ((TREE_CODE (tem) == FIELD_DECL\n@@ -1005,36 +1416,31 @@ dbxout_type_fields (tree type)\n \t\t  tree name = DECL_ASSEMBLER_NAME (tem);\n \n \t\t  have_used_extensions = 1;\n-\t\t  fprintf (asm_out_file, \":%s;\", IDENTIFIER_POINTER (name));\n-\t\t  CHARS (IDENTIFIER_LENGTH (name) + 2);\n+\t\t  stabstr_C (':');\n+\t\t  stabstr_I (name);\n+\t\t  stabstr_C (';');\n \t\t}\n \t      else\n-\t\t{\n-\t\t  /* If TEM is non-static, GDB won't understand it.  */\n-\t\t  fprintf (asm_out_file, \",0,0;\");\n-\t\t  CHARS (5);\n-\t\t}\n+\t\t/* If TEM is non-static, GDB won't understand it.  */\n+\t\tstabstr_S (\",0,0;\");\n \t    }\n \t  else\n \t    {\n-\t      putc (',', asm_out_file);\n-\t      print_wide_int (int_bit_position (tem));\n-\t      putc (',', asm_out_file);\n-\t      print_wide_int (tree_low_cst (DECL_SIZE (tem), 1));\n-\t      putc (';', asm_out_file);\n-\t      CHARS (3);\n+\t      stabstr_C (',');\n+\t      stabstr_D (int_bit_position (tem));\n+\t      stabstr_C (',');\n+\t      stabstr_D (tree_low_cst (DECL_SIZE (tem), 1));\n+\t      stabstr_C (';');\n \t    }\n \t}\n     }\n }\n \f\n /* Subroutine of `dbxout_type_methods'.  Output debug info about the\n-   method described DECL.  DEBUG_NAME is an encoding of the method's\n-   type signature.  ??? We may be able to do without DEBUG_NAME altogether\n-   now.  */\n+   method described DECL.  */\n \n static void\n-dbxout_type_method_1 (tree decl, const char *debug_name)\n+dbxout_type_method_1 (tree decl)\n {\n   char c1 = 'A', c2;\n \n@@ -1058,20 +1464,21 @@ dbxout_type_method_1 (tree decl, const char *debug_name)\n \tc2 = '.';\n     }\n \n-  fprintf (asm_out_file, \":%s;%c%c%c\", debug_name,\n-\t   TREE_PRIVATE (decl) ? '0'\n-\t   : TREE_PROTECTED (decl) ? '1' : '2', c1, c2);\n-  CHARS (IDENTIFIER_LENGTH (DECL_ASSEMBLER_NAME (decl)) + 6\n-\t - (debug_name - IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl))));\n+  /* ??? Output the mangled name, which contains an encoding of the\n+     method's type signature.  May not be necessary anymore.  */\n+  stabstr_C (':');\n+  stabstr_I (DECL_ASSEMBLER_NAME (decl));\n+  stabstr_C (';');\n+  stabstr_C (DECL_ACCESSIBILITY_CHAR (decl));\n+  stabstr_C (c1);\n+  stabstr_C (c2);\n \n   if (DECL_VINDEX (decl) && host_integerp (DECL_VINDEX (decl), 0))\n     {\n-      print_wide_int (tree_low_cst (DECL_VINDEX (decl), 0));\n-      putc (';', asm_out_file);\n-      CHARS (1);\n+      stabstr_D (tree_low_cst (DECL_VINDEX (decl), 0));\n+      stabstr_C (';');\n       dbxout_type (DECL_CONTEXT (decl), 0);\n-      fprintf (asm_out_file, \";\");\n-      CHARS (1);\n+      stabstr_C (';');\n     }\n }\n \f\n@@ -1083,21 +1490,12 @@ dbxout_type_methods (tree type)\n {\n   /* C++: put out the method names and their parameter lists */\n   tree methods = TYPE_METHODS (type);\n-  tree type_encoding;\n   tree fndecl;\n   tree last;\n-  char formatted_type_identifier_length[16];\n-  int type_identifier_length;\n \n   if (methods == NULL_TREE)\n     return;\n \n-  type_encoding = DECL_NAME (TYPE_NAME (type));\n-\n-  type_identifier_length = IDENTIFIER_LENGTH (type_encoding);\n-\n-  sprintf (formatted_type_identifier_length, \"%d\", type_identifier_length);\n-\n   if (TREE_CODE (methods) != TREE_VEC)\n     fndecl = methods;\n   else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)\n@@ -1118,18 +1516,12 @@ dbxout_type_methods (tree type)\n \t   well as the name of the field before overloading, along\n \t   with its parameter list */\n \t{\n-\t  /* This is the \"mangled\" name of the method.\n-\t     It encodes the argument types.  */\n-\t  const char *debug_name;\n-\n \t  /* Skip methods that aren't FUNCTION_DECLs.  (In C++, these\n \t     include TEMPLATE_DECLs.)  The debugger doesn't know what\n \t     to do with such entities anyhow.  */\n \t  if (TREE_CODE (fndecl) != FUNCTION_DECL)\n \t    continue;\n \n-\t  debug_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl));\n-\n \t  CONTIN;\n \n \t  last = fndecl;\n@@ -1143,21 +1535,16 @@ dbxout_type_methods (tree type)\n \t     expects.  */\n \t  if (need_prefix)\n \t    {\n-\t      tree name = DECL_NAME (fndecl);\n-\t      fprintf (asm_out_file, \"%s::\", IDENTIFIER_POINTER (name));\n-\t      CHARS (IDENTIFIER_LENGTH (name) + 2);\n+\t      stabstr_I (DECL_NAME (fndecl));\n+\t      stabstr_S (\"::\");\n \t      need_prefix = 0;\n \t    }\n \n \t  dbxout_type (TREE_TYPE (fndecl), 0);\n-\n-\t  dbxout_type_method_1 (fndecl, debug_name);\n+\t  dbxout_type_method_1 (fndecl);\n \t}\n       if (!need_prefix)\n-\t{\n-\t  putc (';', asm_out_file);\n-\t  CHARS (1);\n-\t}\n+\tstabstr_C (';');\n     }\n }\n \n@@ -1168,7 +1555,7 @@ dbxout_type_methods (tree type)\n static void\n dbxout_range_type (tree type)\n {\n-  fprintf (asm_out_file, \"r\");\n+  stabstr_C ('r');\n   if (TREE_TYPE (type))\n     dbxout_type (TREE_TYPE (type), 0);\n   else if (TREE_CODE (type) != INTEGER_TYPE)\n@@ -1193,39 +1580,30 @@ dbxout_range_type (tree type)\n \tdbxout_type_index (integer_type_node);\n     }\n \n+  stabstr_C (';');\n   if (TYPE_MIN_VALUE (type) != 0\n       && host_integerp (TYPE_MIN_VALUE (type), 0))\n     {\n-      putc (';', asm_out_file);\n-      CHARS (1);\n       if (print_int_cst_bounds_in_octal_p (type))\n-        print_int_cst_octal (TYPE_MIN_VALUE (type));\n+        stabstr_O (TYPE_MIN_VALUE (type));\n       else\n-        print_wide_int (tree_low_cst (TYPE_MIN_VALUE (type), 0));\n+        stabstr_D (tree_low_cst (TYPE_MIN_VALUE (type), 0));\n     }\n   else\n-    {\n-      fprintf (asm_out_file, \";0\");\n-      CHARS (2);\n-    }\n+    stabstr_C ('0');\n \n+  stabstr_C (';');\n   if (TYPE_MAX_VALUE (type) != 0\n       && host_integerp (TYPE_MAX_VALUE (type), 0))\n     {\n-      putc (';', asm_out_file);\n-      CHARS (1);\n       if (print_int_cst_bounds_in_octal_p (type))\n-        print_int_cst_octal (TYPE_MAX_VALUE (type));\n+        stabstr_O (TYPE_MAX_VALUE (type));\n       else\n-        print_wide_int (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n-      putc (';', asm_out_file);\n-      CHARS (1);\n+        stabstr_D (tree_low_cst (TYPE_MAX_VALUE (type), 0));\n+      stabstr_C (';');\n     }\n   else\n-    {\n-      fprintf (asm_out_file, \";-1;\");\n-      CHARS (4);\n-    }\n+    stabstr_S (\"-1;\");\n }\n \f\n \n@@ -1370,9 +1748,7 @@ dbxout_type (tree type, int full)\n #endif\n \n   /* Output a definition now.  */\n-\n-  fprintf (asm_out_file, \"=\");\n-  CHARS (1);\n+  stabstr_C ('=');\n \n   /* Mark it as defined, so that if it is self-referent\n      we will not get into an infinite recursion of definitions.  */\n@@ -1384,15 +1760,13 @@ dbxout_type (tree type, int full)\n      cv-qualified types if we're using extensions.  */\n   if (TYPE_READONLY (type) > TYPE_READONLY (main_variant))\n     {\n-      putc ('k', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('k');\n       dbxout_type (build_type_variant (type, 0, TYPE_VOLATILE (type)), 0);\n       return;\n     }\n   else if (TYPE_VOLATILE (type) > TYPE_VOLATILE (main_variant))\n     {\n-      putc ('B', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('B');\n       dbxout_type (build_type_variant (type, TYPE_READONLY (type), 0), 0);\n       return;\n     }\n@@ -1436,11 +1810,9 @@ dbxout_type (tree type, int full)\n \t     from the output of pcc.\n \t     This used to use `r2' explicitly and we used to\n \t     take care to make sure that `char' was type number 2.  */\n-\t  fprintf (asm_out_file, \"r\");\n-\t  CHARS (1);\n+\t  stabstr_C ('r');\n \t  dbxout_type_index (type);\n-\t  fprintf (asm_out_file, \";0;127;\");\n-\t  CHARS (7);\n+\t  stabstr_S (\";0;127;\");\n \t}\n \n       /* If this is a subtype of another integer type, always prefer to\n@@ -1455,8 +1827,9 @@ dbxout_type (tree type, int full)\n \t      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n \t    {\n \t      have_used_extensions = 1;\n-\t      fprintf (asm_out_file, \"@s%d;\", TYPE_PRECISION (type));\n-\t      CHARS (5);\n+\t      stabstr_S (\"@s\");\n+\t      stabstr_D (TYPE_PRECISION (type));\n+\t      stabstr_C (';');\n \t    }\n \n \t  dbxout_range_type (type);\n@@ -1471,14 +1844,14 @@ dbxout_type (tree type, int full)\n \t      && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n \t    {\n \t      have_used_extensions = 1;\n-\t      fprintf (asm_out_file, \"@s%d;\", TYPE_PRECISION (type));\n-\t      CHARS (5);\n+\t      stabstr_S (\"@s\");\n+\t      stabstr_D (TYPE_PRECISION (type));\n+\t      stabstr_C (';');\n \t    }\n \n \t  if (print_int_cst_bounds_in_octal_p (type))\n \t    {\n-\t      fprintf (asm_out_file, \"r\");\n-\t      CHARS (1);\n+\t      stabstr_C ('r');\n \n               /* If this type derives from another type, output type index of\n \t\t parent type. This is particularly important when parent type\n@@ -1490,14 +1863,11 @@ dbxout_type (tree type, int full)\n               else\n                 dbxout_type_index (type);\n \n-\t      fprintf (asm_out_file, \";\");\n-\t      CHARS (1);\n-\t      print_int_cst_octal (TYPE_MIN_VALUE (type));\n-\t      fprintf (asm_out_file, \";\");\n-\t      CHARS (1);\n-\t      print_int_cst_octal (TYPE_MAX_VALUE (type));\n-\t      fprintf (asm_out_file, \";\");\n-\t      CHARS (1);\n+\t      stabstr_C (';');\n+\t      stabstr_O (TYPE_MIN_VALUE (type));\n+\t      stabstr_C (';');\n+\t      stabstr_O (TYPE_MAX_VALUE (type));\n+\t      stabstr_C (';');\n \t    }\n \n \t  else\n@@ -1510,58 +1880,45 @@ dbxout_type (tree type, int full)\n     case REAL_TYPE:\n       /* This used to say `r1' and we used to take care\n \t to make sure that `int' was type number 1.  */\n-      fprintf (asm_out_file, \"r\");\n-      CHARS (1);\n+      stabstr_C ('r');\n       dbxout_type_index (integer_type_node);\n-      putc (';', asm_out_file);\n-      CHARS (1);\n-      print_wide_int (int_size_in_bytes (type));\n-      fputs (\";0;\", asm_out_file);\n-      CHARS (3);\n+      stabstr_C (';');\n+      stabstr_D (int_size_in_bytes (type));\n+      stabstr_S (\";0;\");\n       break;\n \n     case CHAR_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asm_out_file);\n-\t  CHARS (2);\n-\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fputs (\";-20;\", asm_out_file);\n-\t  CHARS (4);\n+\t  stabstr_S (\"@s\");\n+\t  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  stabstr_S (\";-20;\");\n \t}\n       else\n \t{\n \t  /* Output the type `char' as a subrange of itself.\n \t     That is what pcc seems to do.  */\n-\t  fprintf (asm_out_file, \"r\");\n-\t  CHARS (1);\n+\t  stabstr_C ('r');\n \t  dbxout_type_index (char_type_node);\n-\t  fprintf (asm_out_file, \";0;%d;\", TYPE_UNSIGNED (type) ? 255 : 127);\n-\t  CHARS (7);\n+\t  stabstr_S (TYPE_UNSIGNED (type) ? \";0;255;\" : \";0;127;\");\n \t}\n       break;\n \n     case BOOLEAN_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asm_out_file);\n-\t  CHARS (2);\n-\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fputs (\";-16;\", asm_out_file);\n-\t  CHARS (4);\n+\t  stabstr_S (\"@s\");\n+\t  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  stabstr_S (\";-16;\");\n \t}\n       else /* Define as enumeral type (False, True) */\n-\t{\n-\t  fprintf (asm_out_file, \"eFalse:0,True:1,;\");\n-\t  CHARS (17);\n-\t}\n+\tstabstr_S (\"eFalse:0,True:1,;\");\n       break;\n \n     case FILE_TYPE:\n-      putc ('d', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('d');\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n@@ -1572,54 +1929,46 @@ dbxout_type (tree type, int full)\n \n       if (TREE_CODE (TREE_TYPE (type)) == REAL_TYPE)\n \t{\n-\t  fputs (\"R3;\", asm_out_file);\n-\t  CHARS (3);\n-\t  print_wide_int (2 * int_size_in_bytes (TREE_TYPE (type)));\n-\t  fputs (\";0;\", asm_out_file);\n-\t  CHARS (3);\n+\t  stabstr_S (\"R3;\");\n+\t  stabstr_D (2 * int_size_in_bytes (TREE_TYPE (type)));\n+\t  stabstr_S (\";0;\");\n \t}\n       else\n \t{\n \t  /* Output a complex integer type as a structure,\n \t     pending some other way to do it.  */\n-\t  putc ('s', asm_out_file);\n-\t  CHARS (1);\n-\t  print_wide_int (int_size_in_bytes (type));\n-\t  fprintf (asm_out_file, \"real:\");\n-\t  CHARS (5);\n+\t  stabstr_C ('s');\n+\t  stabstr_D (int_size_in_bytes (type));\n \n+\t  stabstr_S (\"real:\");\n \t  dbxout_type (TREE_TYPE (type), 0);\n-\t  fprintf (asm_out_file, \",0,%d;\", TYPE_PRECISION (TREE_TYPE (type)));\n-\t  CHARS (7);\n-\t  fprintf (asm_out_file, \"imag:\");\n-\t  CHARS (5);\n+\t  stabstr_S (\",0,\");\n+\t  stabstr_D (TYPE_PRECISION (TREE_TYPE (type)));\n+\n+\t  stabstr_S (\";imag:\");\n \t  dbxout_type (TREE_TYPE (type), 0);\n-\t  fprintf (asm_out_file, \",%d,%d;;\", TYPE_PRECISION (TREE_TYPE (type)),\n-\t\t   TYPE_PRECISION (TREE_TYPE (type)));\n-\t  CHARS (10);\n+\t  stabstr_C (',');\n+\t  stabstr_D (TYPE_PRECISION (TREE_TYPE (type)));\n+\t  stabstr_C (',');\n+\t  stabstr_D (TYPE_PRECISION (TREE_TYPE (type)));\n+\t  stabstr_S (\";;\");\n \t}\n       break;\n \n     case SET_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asm_out_file);\n-\t  CHARS (2);\n-\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  putc (';', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_S (\"@s\");\n+\t  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  stabstr_C (';');\n \n \t  /* Check if a bitstring type, which in Chill is\n \t     different from a [power]set.  */\n \t  if (TYPE_STRING_FLAG (type))\n-\t    {\n-\t      fprintf (asm_out_file, \"@S;\");\n-\t      CHARS (3);\n-\t    }\n+\t    stabstr_S (\"@S;\");\n \t}\n-      putc ('S', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('S');\n       dbxout_type (TYPE_DOMAIN (type), 0);\n       break;\n \n@@ -1628,11 +1977,9 @@ dbxout_type (tree type, int full)\n       if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fputs (\"@s\", asm_out_file);\n-\t  CHARS (2);\n-\t  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));\n-\t  fprintf (asm_out_file, \";@S;S\");\n-\t  CHARS (5);\n+\t  stabstr_S (\"@s\");\n+\t  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));\n+\t  stabstr_S (\";@S;S\");\n \t  dbxout_type (TYPE_DOMAIN (type), 0);\n \t  break;\n \t}\n@@ -1646,22 +1993,18 @@ dbxout_type (tree type, int full)\n       if (TYPE_STRING_FLAG (type) && use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  fprintf (asm_out_file, \"@S;\");\n-\t  CHARS (3);\n+\t  stabstr_S (\"@S;\");\n \t}\n       tem = TYPE_DOMAIN (type);\n       if (tem == NULL)\n \t{\n-\t  fprintf (asm_out_file, \"ar\");\n-\t  CHARS (2);\n+\t  stabstr_S (\"ar\");\n \t  dbxout_type_index (integer_type_node);\n-\t  fprintf (asm_out_file, \";0;-1;\");\n-\t  CHARS (6);\n+\t  stabstr_S (\";0;-1;\");\n \t}\n       else\n \t{\n-\t  fprintf (asm_out_file, \"a\");\n-\t  CHARS (1);\n+\t  stabstr_C ('a');\n \t  dbxout_range_type (tem);\n \t}\n \n@@ -1691,26 +2034,23 @@ dbxout_type (tree type, int full)\n \t       If the type has a name, don't nest its definition within\n \t       another type's definition; instead, output an xref\n \t       and let the definition come when the name is defined.  */\n-\t    fputs ((TREE_CODE (type) == RECORD_TYPE) ? \"xs\" : \"xu\", asm_out_file);\n-\t    CHARS (2);\n+\t    stabstr_S ((TREE_CODE (type) == RECORD_TYPE) ? \"xs\" : \"xu\");\n \t    if (TYPE_NAME (type) != 0)\n \t      dbxout_type_name (type);\n \t    else\n \t      {\n-\t\tfprintf (asm_out_file, \"$$%d\", anonymous_type_number++);\n-\t\tCHARS (5);\n+\t\tstabstr_S (\"$$\");\n+\t\tstabstr_D (anonymous_type_number++);\n \t      }\n \n-\t    fprintf (asm_out_file, \":\");\n-\t    CHARS (1);\n+\t    stabstr_C (':');\n \t    typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n \t    break;\n \t  }\n \n \t/* Identify record or union, and print its size.  */\n-\tputc (((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u'), asm_out_file);\n-\tCHARS (1);\n-\tprint_wide_int (int_size_in_bytes (type));\n+\tstabstr_C ((TREE_CODE (type) == RECORD_TYPE) ? 's' : 'u');\n+\tstabstr_D (int_size_in_bytes (type));\n \n \tif (binfo)\n \t  {\n@@ -1723,8 +2063,9 @@ dbxout_type (tree type, int full)\n \t\tif (BINFO_N_BASE_BINFOS (binfo))\n \t\t  {\n \t\t    have_used_extensions = 1;\n-\t\t    fprintf (asm_out_file, \"!%u,\", BINFO_N_BASE_BINFOS (binfo));\n-\t\t    CHARS (8);\n+\t\t    stabstr_C ('!');\n+\t\t    stabstr_U (BINFO_N_BASE_BINFOS (binfo));\n+\t\t    stabstr_C (',');\n \t\t  }\n \t      }\n \t    for (i = 0; BINFO_BASE_ITERATE (binfo, i, child); i++)\n@@ -1735,48 +2076,41 @@ dbxout_type (tree type, int full)\n \t\tif (use_gnu_debug_info_extensions)\n \t\t  {\n \t\t    have_used_extensions = 1;\n-\t\t    putc (BINFO_VIRTUAL_P (child) ? '1' : '0', asm_out_file);\n-\t\t    putc (access == access_public_node ? '2' :\n-\t\t\t  (access == access_protected_node ? '1' :'0'),\n-\t\t\t  asm_out_file);\n-\t\t    CHARS (2);\n+\t\t    stabstr_C (BINFO_VIRTUAL_P (child) ? '1' : '0');\n+\t\t    stabstr_C (access == access_public_node ? '2' :\n+\t\t\t\t   access == access_protected_node\n+\t\t\t\t   ? '1' :'0');\n \t\t    if (BINFO_VIRTUAL_P (child)\n \t\t\t&& strcmp (lang_hooks.name, \"GNU C++\") == 0)\n \t\t      /* For a virtual base, print the (negative)\n \t\t     \t offset within the vtable where we must look\n \t\t     \t to find the necessary adjustment.  */\n-\t\t      print_wide_int\n+\t\t      stabstr_D\n \t\t\t(tree_low_cst (BINFO_VPTR_FIELD (child), 0)\n \t\t\t * BITS_PER_UNIT);\n \t\t    else\n-\t\t      print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n-\t\t\t\t      * BITS_PER_UNIT);\n-\t\t    putc (',', asm_out_file);\n-\t\t    CHARS (1);\n+\t\t      stabstr_D (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t\t       * BITS_PER_UNIT);\n+\t\t    stabstr_C (',');\n \t\t    dbxout_type (BINFO_TYPE (child), 0);\n-\t\t    putc (';', asm_out_file);\n-\t\t    CHARS (1);\n+\t\t    stabstr_C (';');\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    /* Print out the base class information with\n \t\t       fields which have the same names at the types\n \t\t       they hold.  */\n \t\t    dbxout_type_name (BINFO_TYPE (child));\n-\t\t    putc (':', asm_out_file);\n-\t\t    CHARS (1);\n+\t\t    stabstr_C (':');\n \t\t    dbxout_type (BINFO_TYPE (child), full);\n-\t\t    putc (',', asm_out_file);\n-\t\t    CHARS (1);\n-\t\t    print_wide_int (tree_low_cst (BINFO_OFFSET (child), 0)\n-\t\t\t\t    * BITS_PER_UNIT);\n-\t\t    putc (',', asm_out_file);\n-\t\t    CHARS (1);\n-\t\t    print_wide_int\n+\t\t    stabstr_C (',');\n+\t\t    stabstr_D (tree_low_cst (BINFO_OFFSET (child), 0)\n+\t\t\t\t     * BITS_PER_UNIT);\n+\t\t    stabstr_C (',');\n+\t\t    stabstr_D\n \t\t      (tree_low_cst (TYPE_SIZE (BINFO_TYPE (child)), 0)\n \t\t       * BITS_PER_UNIT);\n-\t\t    putc (';', asm_out_file);\n-\t\t    CHARS (1);\n+\t\t    stabstr_C (';');\n \t\t  }\n \t      }\n \t  }\n@@ -1790,32 +2124,21 @@ dbxout_type (tree type, int full)\n \t  dbxout_type_methods (type);\n \t}\n \n-      putc (';', asm_out_file);\n-      CHARS (1);\n+      stabstr_C (';');\n \n       if (use_gnu_debug_info_extensions && TREE_CODE (type) == RECORD_TYPE\n \t  /* Avoid the ~ if we don't really need it--it confuses dbx.  */\n \t  && TYPE_VFIELD (type))\n \t{\n \t  have_used_extensions = 1;\n \n-\t  /* Tell GDB+ that it may keep reading.  */\n-\t  putc ('~', asm_out_file);\n-\t  CHARS (1);\n-\n \t  /* We need to write out info about what field this class\n \t     uses as its \"main\" vtable pointer field, because if this\n \t     field is inherited from a base class, GDB cannot necessarily\n \t     figure out which field it's using in time.  */\n-\t  if (TYPE_VFIELD (type))\n-\t    {\n-\t      putc ('%', asm_out_file);\n-\t      CHARS (1);\n-\t      dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n-\t    }\n-\n-\t  putc (';', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_S (\"~%\");\n+\t  dbxout_type (DECL_FCONTEXT (TYPE_VFIELD (type)), 0);\n+\t  stabstr_C (';');\n \t}\n       break;\n \n@@ -1829,66 +2152,60 @@ dbxout_type (tree type, int full)\n \t   && !full)\n \t  || !COMPLETE_TYPE_P (type))\n \t{\n-\t  fprintf (asm_out_file, \"xe\");\n-\t  CHARS (2);\n+\t  stabstr_S (\"xe\");\n \t  dbxout_type_name (type);\n \t  typevec[TYPE_SYMTAB_ADDRESS (type)].status = TYPE_XREF;\n-\t  putc (':', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C (':');\n \t  return;\n \t}\n       if (use_gnu_debug_info_extensions\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (integer_type_node))\n \t{\n-\t  fprintf (asm_out_file, \"@s%d;\", TYPE_PRECISION (type));\n-\t  CHARS (5);\n+\t  have_used_extensions = 1;\n+\t  stabstr_S (\"@s\");\n+\t  stabstr_D (TYPE_PRECISION (type));\n+\t  stabstr_C (';');\n \t}\n \n-      putc ('e', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('e');\n       for (tem = TYPE_VALUES (type); tem; tem = TREE_CHAIN (tem))\n \t{\n-\t  fprintf (asm_out_file, \"%s:\", IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n-\t  CHARS (IDENTIFIER_LENGTH (TREE_PURPOSE (tem)) + 1);\n+\t  stabstr_I (TREE_PURPOSE (tem));\n+\t  stabstr_C (':');\n+\n \t  if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == 0)\n-\t    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+\t    stabstr_D (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n \t  else if (TREE_INT_CST_HIGH (TREE_VALUE (tem)) == -1\n \t\t   && (HOST_WIDE_INT) TREE_INT_CST_LOW (TREE_VALUE (tem)) < 0)\n-\t    print_wide_int (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+\t    stabstr_D (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n \t  else\n-\t    print_int_cst_octal (TREE_VALUE (tem));\n+\t    stabstr_O (TREE_VALUE (tem));\n \n-\t  putc (',', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C (',');\n \t  if (TREE_CHAIN (tem) != 0)\n \t    CONTIN;\n \t}\n \n-      putc (';', asm_out_file);\n-      CHARS (1);\n+      stabstr_C (';');\n       break;\n \n     case POINTER_TYPE:\n-      putc ('*', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('*');\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case METHOD_TYPE:\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  putc ('#', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C ('#');\n \n \t  /* Write the argument types out longhand.  */\n \t  dbxout_type (TYPE_METHOD_BASETYPE (type), 0);\n-\t  putc (',', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C (',');\n \t  dbxout_type (TREE_TYPE (type), 0);\n \t  dbxout_args (TYPE_ARG_TYPES (type));\n-\t  putc (';', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C (';');\n \t}\n       else\n \t/* Treat it as a function type.  */\n@@ -1899,11 +2216,9 @@ dbxout_type (tree type, int full)\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  have_used_extensions = 1;\n-\t  putc ('@', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C ('@');\n \t  dbxout_type (TYPE_OFFSET_BASETYPE (type), 0);\n-\t  putc (',', asm_out_file);\n-\t  CHARS (1);\n+\t  stabstr_C (',');\n \t  dbxout_type (TREE_TYPE (type), 0);\n \t}\n       else\n@@ -1913,15 +2228,17 @@ dbxout_type (tree type, int full)\n \n     case REFERENCE_TYPE:\n       if (use_gnu_debug_info_extensions)\n-\thave_used_extensions = 1;\n-      putc (use_gnu_debug_info_extensions ? '&' : '*', asm_out_file);\n-      CHARS (1);\n+\t{\n+\t  have_used_extensions = 1;\n+\t  stabstr_C ('&');\n+\t}\n+      else\n+\tstabstr_C ('*');\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n     case FUNCTION_TYPE:\n-      putc ('f', asm_out_file);\n-      CHARS (1);\n+      stabstr_C ('f');\n       dbxout_type (TREE_TYPE (type), 0);\n       break;\n \n@@ -1963,83 +2280,6 @@ print_int_cst_bounds_in_octal_p (tree type)\n     return FALSE;\n }\n \n-/* Print the value of integer constant C, in octal,\n-   handling double precision.  */\n-\n-static void\n-print_int_cst_octal (tree c)\n-{\n-  unsigned HOST_WIDE_INT high = TREE_INT_CST_HIGH (c);\n-  unsigned HOST_WIDE_INT low = TREE_INT_CST_LOW (c);\n-  int excess = (3 - (HOST_BITS_PER_WIDE_INT % 3));\n-  unsigned int width = TYPE_PRECISION (TREE_TYPE (c));\n-\n-  /* GDB wants constants with no extra leading \"1\" bits, so\n-     we need to remove any sign-extension that might be\n-     present.  */\n-  if (width == HOST_BITS_PER_WIDE_INT * 2)\n-    ;\n-  else if (width > HOST_BITS_PER_WIDE_INT)\n-    high &= (((HOST_WIDE_INT) 1 << (width - HOST_BITS_PER_WIDE_INT)) - 1);\n-  else if (width == HOST_BITS_PER_WIDE_INT)\n-    high = 0;\n-  else\n-    high = 0, low &= (((HOST_WIDE_INT) 1 << width) - 1);\n-\n-  fprintf (asm_out_file, \"0\");\n-  CHARS (1);\n-\n-  if (excess == 3)\n-    {\n-      print_octal (high, HOST_BITS_PER_WIDE_INT / 3);\n-      print_octal (low, HOST_BITS_PER_WIDE_INT / 3);\n-    }\n-  else\n-    {\n-      unsigned HOST_WIDE_INT beg = high >> excess;\n-      unsigned HOST_WIDE_INT middle\n-\t= ((high & (((HOST_WIDE_INT) 1 << excess) - 1)) << (3 - excess)\n-\t   | (low >> (HOST_BITS_PER_WIDE_INT / 3 * 3)));\n-      unsigned HOST_WIDE_INT end\n-\t= low & (((unsigned HOST_WIDE_INT) 1\n-\t\t  << (HOST_BITS_PER_WIDE_INT / 3 * 3))\n-\t\t - 1);\n-\n-      fprintf (asm_out_file, \"%o%01o\", (int) beg, (int) middle);\n-      CHARS (2);\n-      print_octal (end, HOST_BITS_PER_WIDE_INT / 3);\n-    }\n-}\n-\n-static void\n-print_octal (unsigned HOST_WIDE_INT value, int digits)\n-{\n-  int i;\n-\n-  for (i = digits - 1; i >= 0; i--)\n-    fprintf (asm_out_file, \"%01o\", (int) ((value >> (3 * i)) & 7));\n-\n-  CHARS (digits);\n-}\n-\n-/* Output C in decimal while adjusting the number of digits written.  */\n-\n-static void\n-print_wide_int (HOST_WIDE_INT c)\n-{\n-  int digs = 0;\n-\n-  fprintf (asm_out_file, HOST_WIDE_INT_PRINT_DEC, c);\n-\n-  if (c < 0)\n-    digs++, c = -c;\n-\n-  while (c > 0)\n-    c /= 10; digs++;\n-\n-  CHARS (digs);\n-}\n-\n /* Output the name of type TYPE, with no punctuation.\n    Such names can be set up either by typedef declarations\n    or by struct, enum and union tags.  */\n@@ -2061,8 +2301,7 @@ dbxout_type_name (tree type)\n       gcc_unreachable ();\n     }\n \n-  fprintf (asm_out_file, \"%s\", IDENTIFIER_POINTER (t));\n-  CHARS (IDENTIFIER_LENGTH (t));\n+  stabstr_I (t);\n }\n \n /* Output leading leading struct or class names needed for qualifying\n@@ -2081,15 +2320,13 @@ dbxout_class_name_qualifiers (tree decl)\n     {\n       tree name = TYPE_NAME (context);\n \n-      emit_pending_bincls_if_required ();\n-\n       if (TREE_CODE (name) == TYPE_DECL)\n \t{\n \t  dbxout_class_name_qualifiers (name);\n \t  name = DECL_NAME (name);\n \t}\n-      fprintf (asm_out_file, \"%s::\", IDENTIFIER_POINTER (name));\n-      CHARS (IDENTIFIER_LENGTH (name) + 2);\n+      stabstr_I (name);\n+      stabstr_S (\"::\");\n     }\n }\n \f\n@@ -2138,8 +2375,8 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n       /* We now have a used symbol.  We need to generate the info for\n          the symbol's type in addition to the symbol itself.  These\n          type symbols are queued to be generated after were done with\n-         the symbol itself (done because the symbol's info is generated\n-         with fprintf's, etc. as it determines what's needed).\n+         the symbol itself (otherwise they would fight over the\n+         stabstr obstack).\n \n          Note, because the TREE_TYPE(type) might be something like a\n          pointer to a named type we need to look for the first name\n@@ -2182,14 +2419,6 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \n   emit_pending_bincls_if_required ();\n \n-  dbxout_prepare_symbol (decl);\n-\n-  /* The output will always start with the symbol name,\n-     so always count that in the length-output-so-far.  */\n-\n-  if (DECL_NAME (decl) != 0)\n-    current_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (decl));\n-\n   switch (TREE_CODE (decl))\n     {\n     case CONST_DECL:\n@@ -2208,16 +2437,12 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n       if (!MEM_P (DECL_RTL (decl))\n \t  || GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n \tbreak;\n-      FORCE_TEXT;\n \n-      fprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n-\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n-\t       TREE_PUBLIC (decl) ? 'F' : 'f');\n+      dbxout_begin_complex_stabs ();\n+      stabstr_I (DECL_ASSEMBLER_NAME (decl));\n+      stabstr_S (TREE_PUBLIC (decl) ? \":F\" : \":f\");\n       result = 1;\n \n-      current_sym_code = N_FUN;\n-      current_sym_addr = XEXP (DECL_RTL (decl), 0);\n-\n       if (TREE_TYPE (type))\n \tdbxout_type (TREE_TYPE (type), 0);\n       else\n@@ -2227,11 +2452,15 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t mention the containing function name\n \t as well as (since dbx wants it) our own assembler-name.  */\n       if (context != 0)\n-\tfprintf (asm_out_file, \",%s,%s\",\n-\t\t IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n-\t\t IDENTIFIER_POINTER (DECL_NAME (context)));\n+\t{\n+\t  stabstr_C (',');\n+\t  stabstr_I (DECL_ASSEMBLER_NAME (decl));\n+\t  stabstr_C (',');\n+\t  stabstr_I (DECL_NAME (context));\n+\t}\n \n-      dbxout_finish_symbol (decl);\n+      dbxout_finish_complex_stabs (decl, N_FUN, XEXP (DECL_RTL (decl), 0),\n+\t\t\t\t   0, 0);\n       break;\n \n     case TYPE_DECL:\n@@ -2289,28 +2518,27 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t\tif (TREE_CODE (name) == TYPE_DECL)\n \t\t  name = DECL_NAME (name);\n \n-\t\tcurrent_sym_code = DBX_TYPE_DECL_STABS_CODE;\n-\t\tcurrent_sym_value = 0;\n-\t\tcurrent_sym_addr = 0;\n-\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n-\n-\t\tfprintf (asm_out_file, \"%s\\\"%s:T\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (name));\n+\t\tdbxout_begin_complex_stabs ();\n+\t\tstabstr_I (name);\n+\t\tstabstr_S (\":T\");\n \t\tdbxout_type (type, 1);\n-\t\tdbxout_finish_symbol (NULL_TREE);\n+\t\tdbxout_finish_complex_stabs (0, DBX_TYPE_DECL_STABS_CODE,\n+\t\t\t\t\t     0, 0, 0);\n \t      }\n \n-\t    /* Output .stabs (or whatever) and leading double quote.  */\n-\t    fprintf (asm_out_file, \"%s\\\"\", ASM_STABS_OP);\n+\t    dbxout_begin_complex_stabs ();\n \n+\t    /* Output leading class/struct qualifiers.\n+\t       ??? why not set have_used_extensions here ... because\n+\t       then the test of it below would always be true, I\n+\t       guess.  But it's not clear to me why we shouldn't do\n+\t       that always in extended mode.  */\n \t    if (use_gnu_debug_info_extensions)\n-\t      {\n-\t\t/* Output leading class/struct qualifiers.  */\n-\t\tdbxout_class_name_qualifiers (decl);\n-\t      }\n+\t      dbxout_class_name_qualifiers (decl);\n \n \t    /* Output typedef name.  */\n-\t    fprintf (asm_out_file, \"%s:\", IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t    stabstr_I (DECL_NAME (decl));\n+\t    stabstr_C (':');\n \n \t    /* Short cut way to output a tag also.  */\n \t    if ((TREE_CODE (type) == RECORD_TYPE\n@@ -2323,16 +2551,15 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t      {\n \t\tif (use_gnu_debug_info_extensions && have_used_extensions)\n \t\t  {\n-\t\t    putc ('T', asm_out_file);\n+\t\t    stabstr_C ('T');\n \t\t    TREE_ASM_WRITTEN (TYPE_NAME (type)) = 1;\n \t\t  }\n \t      }\n \n-\t    putc ('t', asm_out_file);\n-\t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n-\n+\t    stabstr_C ('t');\n \t    dbxout_type (type, 1);\n-\t    dbxout_finish_symbol (decl);\n+\t    dbxout_finish_complex_stabs (decl, DBX_TYPE_DECL_STABS_CODE,\n+\t\t\t\t\t 0, 0, 0);\n \t    did_output = 1;\n \t  }\n \n@@ -2354,33 +2581,26 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \t    if (TREE_CODE (name) == TYPE_DECL)\n \t      name = DECL_NAME (name);\n \n-\t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n-\t    current_sym_value = 0;\n-\t    current_sym_addr = 0;\n-\t    current_sym_nchars = 2 + IDENTIFIER_LENGTH (name);\n-\n-\t    fprintf (asm_out_file, \"%s\\\"%s:T\", ASM_STABS_OP,\n-\t\t     IDENTIFIER_POINTER (name));\n+\t    dbxout_begin_complex_stabs ();\n+\t    stabstr_I (name);\n+\t    stabstr_S (\":T\");\n \t    dbxout_type (type, 1);\n-\t    dbxout_finish_symbol (NULL_TREE);\n+\t    dbxout_finish_complex_stabs (0, DBX_TYPE_DECL_STABS_CODE, 0, 0, 0);\n \t    did_output = 1;\n \t  }\n \n-\t/* If an enum type has no name, it cannot be referred to,\n-\t   but we must output it anyway, since the enumeration constants\n-\t   can be referred to.  */\n+\t/* If an enum type has no name, it cannot be referred to, but\n+\t   we must output it anyway, to record the enumeration\n+\t   constants.  */\n+\n \tif (!did_output && TREE_CODE (type) == ENUMERAL_TYPE)\n \t  {\n-\t    current_sym_code = DBX_TYPE_DECL_STABS_CODE;\n-\t    current_sym_value = 0;\n-\t    current_sym_addr = 0;\n-\t    current_sym_nchars = 2;\n-\n+\t    dbxout_begin_complex_stabs ();\n \t    /* Some debuggers fail when given NULL names, so give this a\n-\t       harmless name of ` '.  */\n-\t    fprintf (asm_out_file, \"%s\\\" :T\", ASM_STABS_OP);\n+\t       harmless name of \" \" (Why not \"(anon)\"?).  */\n+\t    stabstr_S (\" :T\");\n \t    dbxout_type (type, 1);\n-\t    dbxout_finish_symbol (NULL_TREE);\n+\t    dbxout_finish_complex_stabs (0, DBX_TYPE_DECL_STABS_CODE, 0, 0, 0);\n \t  }\n \n \t/* Prevent duplicate output of a typedef.  */\n@@ -2404,37 +2624,36 @@ dbxout_symbol (tree decl, int local ATTRIBUTE_UNUSED)\n \tbreak;\n \n       /* If the variable is really a constant\n-\t and not written in memory, inform the debugger.  */\n+\t and not written in memory, inform the debugger.\n+\n+\t ??? Why do we skip emitting the type and location in this case?  */\n       if (TREE_STATIC (decl) && TREE_READONLY (decl)\n \t  && DECL_INITIAL (decl) != 0\n \t  && host_integerp (DECL_INITIAL (decl), 0)\n \t  && ! TREE_ASM_WRITTEN (decl)\n \t  && (DECL_CONTEXT (decl) == NULL_TREE\n-\t      || TREE_CODE (DECL_CONTEXT (decl)) == BLOCK))\n+\t      || TREE_CODE (DECL_CONTEXT (decl)) == BLOCK)\n+\t  && TREE_PUBLIC (decl) == 0)\n \t{\n-\t  if (TREE_PUBLIC (decl) == 0)\n-\t    {\n-\t      /* The sun4 assembler does not grok this.  */\n-\t      const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+\t  /* The sun4 assembler does not grok this.  */\n \n-\t      if (TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n-\t\t{\n-\t\t  HOST_WIDE_INT ival = tree_low_cst (DECL_INITIAL (decl), 0);\n-\t\t  fprintf (asm_out_file, \"%s\\\"%s:c=i\" HOST_WIDE_INT_PRINT_DEC\n-\t\t\t   \"\\\",0x%x,0,0,0\\n\",\n-\t\t\t   ASM_STABS_OP, name, ival, N_LSYM);\n-\t\t  DBXOUT_DECR_NESTING;\n-\t\t  return 1;\n-\t\t}\n-\t      else if (TREE_CODE (TREE_TYPE (decl)) == REAL_TYPE)\n-\t\t{\n-\t\t  /* Don't know how to do this yet.  */\n-\t\t}\n-\t      break;\n+\t  if (TREE_CODE (TREE_TYPE (decl)) == INTEGER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (decl)) == ENUMERAL_TYPE)\n+\t    {\n+\t      HOST_WIDE_INT ival = TREE_INT_CST_LOW (DECL_INITIAL (decl));\n+\n+\t      dbxout_begin_complex_stabs ();\n+\t      stabstr_I (DECL_NAME (decl));\n+\t      stabstr_S (\":c=i\");\n+\t      stabstr_D (ival);\n+\t      dbxout_finish_complex_stabs (0, N_LSYM, 0, 0, 0);\n+\t      DBXOUT_DECR_NESTING;\n+\t      return 1;\n \t    }\n-\t  /* else it is something we handle like a normal variable.  */\n+\t  else\n+\t    break;\n \t}\n+      /* else it is something we handle like a normal variable.  */\n \n       SET_DECL_RTL (decl, eliminate_regs (DECL_RTL (decl), 0, NULL_RTX));\n #ifdef LEAF_REG_REMAP\n@@ -2462,10 +2681,11 @@ static int\n dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n {\n   int letter = 0;\n+  STAB_CODE_TYPE code;\n+  rtx addr = 0;\n+  int number = 0;\n   int regno = -1;\n \n-  emit_pending_bincls_if_required ();\n-\n   /* Don't mention a variable at all\n      if it was completely optimized into nothingness.\n \n@@ -2505,17 +2725,16 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n      no letter at all, and N_LSYM, for auto variable,\n      r and N_RSYM for register variable.  */\n \n-  if (MEM_P (home)\n-      && GET_CODE (XEXP (home, 0)) == SYMBOL_REF)\n+  if (MEM_P (home) && GET_CODE (XEXP (home, 0)) == SYMBOL_REF)\n     {\n       if (TREE_PUBLIC (decl))\n \t{\n \t  letter = 'G';\n-\t  current_sym_code = N_GSYM;\n+\t  code = N_GSYM;\n \t}\n       else\n \t{\n-\t  current_sym_addr = XEXP (home, 0);\n+\t  addr = XEXP (home, 0);\n \n \t  letter = decl_function_context (decl) ? 'V' : 'S';\n \n@@ -2526,35 +2745,35 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \t  if (DECL_INITIAL (decl) == 0\n \t      || (!strcmp (lang_hooks.name, \"GNU C++\")\n \t\t  && DECL_INITIAL (decl) == error_mark_node))\n-\t    current_sym_code = N_LCSYM;\n+\t    code = N_LCSYM;\n \t  else if (DECL_IN_TEXT_SECTION (decl))\n \t    /* This is not quite right, but it's the closest\n \t       of all the codes that Unix defines.  */\n-\t    current_sym_code = DBX_STATIC_CONST_VAR_CODE;\n+\t    code = DBX_STATIC_CONST_VAR_CODE;\n \t  else\n \t    {\n \t      /* Some ports can transform a symbol ref into a label ref,\n \t\t because the symbol ref is too far away and has to be\n \t\t dumped into a constant pool.  Alternatively, the symbol\n \t\t in the constant pool might be referenced by a different\n \t\t symbol.  */\n-\t      if (GET_CODE (current_sym_addr) == SYMBOL_REF\n-\t\t  && CONSTANT_POOL_ADDRESS_P (current_sym_addr))\n+\t      if (GET_CODE (addr) == SYMBOL_REF\n+\t\t  && CONSTANT_POOL_ADDRESS_P (addr))\n \t\t{\n \t\t  bool marked;\n-\t\t  rtx tmp = get_pool_constant_mark (current_sym_addr, &marked);\n+\t\t  rtx tmp = get_pool_constant_mark (addr, &marked);\n \n \t\t  if (GET_CODE (tmp) == SYMBOL_REF)\n \t\t    {\n-\t\t      current_sym_addr = tmp;\n-\t\t      if (CONSTANT_POOL_ADDRESS_P (current_sym_addr))\n-\t\t        get_pool_constant_mark (current_sym_addr, &marked);\n+\t\t      addr = tmp;\n+\t\t      if (CONSTANT_POOL_ADDRESS_P (addr))\n+\t\t        get_pool_constant_mark (addr, &marked);\n \t\t      else\n \t\t\tmarked = true;\n \t\t    }\n \t\t  else if (GET_CODE (tmp) == LABEL_REF)\n \t\t    {\n-\t\t      current_sym_addr = tmp;\n+\t\t      addr = tmp;\n \t\t      marked = true;\n \t\t    }\n \n@@ -2568,15 +2787,15 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n #ifdef DBX_STATIC_STAB_DATA_SECTION\n \t      data_section ();\n #endif\n-\t      current_sym_code = N_STSYM;\n+\t      code = N_STSYM;\n \t    }\n \t}\n     }\n   else if (regno >= 0)\n     {\n       letter = 'r';\n-      current_sym_code = N_RSYM;\n-      current_sym_value = DBX_REGISTER_NUMBER (regno);\n+      code = N_RSYM;\n+      number = DBX_REGISTER_NUMBER (regno);\n     }\n   else if (MEM_P (home)\n \t   && (MEM_P (XEXP (home, 0))\n@@ -2597,18 +2816,17 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n       if (REG_P (XEXP (home, 0)))\n \t{\n \t  letter = 'r';\n-\t  current_sym_code = N_RSYM;\n+\t  code = N_RSYM;\n \t  if (REGNO (XEXP (home, 0)) >= FIRST_PSEUDO_REGISTER)\n \t    return 0;\n-\t  current_sym_value = DBX_REGISTER_NUMBER (REGNO (XEXP (home, 0)));\n+\t  number = DBX_REGISTER_NUMBER (REGNO (XEXP (home, 0)));\n \t}\n       else\n \t{\n-\t  current_sym_code = N_LSYM;\n+\t  code = N_LSYM;\n \t  /* RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))).\n \t     We want the value of that CONST_INT.  */\n-\t  current_sym_value\n-\t    = DEBUGGER_AUTO_OFFSET (XEXP (XEXP (home, 0), 0));\n+\t  number = DEBUGGER_AUTO_OFFSET (XEXP (XEXP (home, 0), 0));\n \t}\n \n       /* Effectively do build_pointer_type, but don't cache this type,\n@@ -2621,17 +2839,17 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n   else if (MEM_P (home)\n \t   && REG_P (XEXP (home, 0)))\n     {\n-      current_sym_code = N_LSYM;\n-      current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n+      code = N_LSYM;\n+      number = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n     }\n   else if (MEM_P (home)\n \t   && GET_CODE (XEXP (home, 0)) == PLUS\n \t   && GET_CODE (XEXP (XEXP (home, 0), 1)) == CONST_INT)\n     {\n-      current_sym_code = N_LSYM;\n+      code = N_LSYM;\n       /* RTL looks like (MEM (PLUS (REG...) (CONST_INT...)))\n \t We want the value of that CONST_INT.  */\n-      current_sym_value = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n+      number = DEBUGGER_AUTO_OFFSET (XEXP (home, 0));\n     }\n   else if (MEM_P (home)\n \t   && GET_CODE (XEXP (home, 0)) == CONST)\n@@ -2647,9 +2865,9 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n \t variable, thereby avoiding the need for a register.  In such\n \t cases we're forced to lie to debuggers and tell them that\n \t this variable was itself `static'.  */\n-      current_sym_code = N_LCSYM;\n+      code = N_LCSYM;\n       letter = 'V';\n-      current_sym_addr = XEXP (XEXP (home, 0), 0);\n+      addr = XEXP (XEXP (home, 0), 0);\n     }\n   else if (GET_CODE (home) == CONCAT)\n     {\n@@ -2670,8 +2888,6 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n       else\n \tdbxout_symbol_location (decl, subtype, \"$real\", XEXP (home, 0));\n \n-      dbxout_prepare_symbol (decl);\n-\n       if (WORDS_BIG_ENDIAN)\n \tdbxout_symbol_location (decl, subtype, \"$real\", XEXP (home, 1));\n       else\n@@ -2685,18 +2901,18 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n     return 0;\n \n   /* Ok, start a symtab entry and output the variable name.  */\n-  FORCE_TEXT;\n \n #ifdef DBX_STATIC_BLOCK_START\n-  DBX_STATIC_BLOCK_START (asm_out_file, current_sym_code);\n+  DBX_STATIC_BLOCK_START (asm_out_file, code);\n #endif\n \n+  dbxout_begin_complex_stabs ();\n   dbxout_symbol_name (decl, suffix, letter);\n   dbxout_type (type, 0);\n-  dbxout_finish_symbol (decl);\n+  dbxout_finish_complex_stabs (decl, code, addr, 0, number);\n \n #ifdef DBX_STATIC_BLOCK_END\n-  DBX_STATIC_BLOCK_END (asm_out_file, current_sym_code);\n+  DBX_STATIC_BLOCK_END (asm_out_file, code);\n #endif\n   return 1;\n }\n@@ -2707,7 +2923,7 @@ dbxout_symbol_location (tree decl, tree type, const char *suffix, rtx home)\n static void\n dbxout_symbol_name (tree decl, const char *suffix, int letter)\n {\n-  const char *name;\n+  tree name;\n \n   if (DECL_CONTEXT (decl) \n       && (TYPE_P (DECL_CONTEXT (decl))\n@@ -2716,50 +2932,22 @@ dbxout_symbol_name (tree decl, const char *suffix, int letter)\n        or a namespace member, we must put out the mangled name instead of the\n        DECL_NAME.  Note also that static member (variable) names DO NOT begin\n        with underscores in .stabs directives.  */\n-    name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+    name = DECL_ASSEMBLER_NAME (decl);\n   else\n     /* ...but if we're function-local, we don't want to include the junk\n        added by ASM_FORMAT_PRIVATE_NAME.  */\n-    name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+    name = DECL_NAME (decl);\n \n-  if (name == 0)\n-    name = \"(anon)\";\n-  fprintf (asm_out_file, \"%s\\\"%s%s:\", ASM_STABS_OP, name,\n-\t   (suffix ? suffix : \"\"));\n+  if (name)\n+    stabstr_I (name);\n+  else\n+    stabstr_S (\"(anon)\");\n \n+  if (suffix)\n+    stabstr_S (suffix);\n+  stabstr_C (':');\n   if (letter)\n-    putc (letter, asm_out_file);\n-}\n-\n-static void\n-dbxout_prepare_symbol (tree decl ATTRIBUTE_UNUSED)\n-{\n-  /* Initialize variables used to communicate each symbol's debug\n-     information to dbxout_finish_symbol with zeroes.  */\n-\n-  /* Cast avoids warning in old compilers.  */\n-  current_sym_code = (STAB_CODE_TYPE) 0;\n-  current_sym_value = 0;\n-  current_sym_addr = 0;\n-}\n-\n-static void\n-dbxout_finish_symbol (tree sym)\n-{\n-#ifdef DBX_FINISH_SYMBOL\n-  DBX_FINISH_SYMBOL (asm_out_file, sym);\n-#else\n-  int line = 0;\n-  if (use_gnu_debug_info_extensions && sym != 0)\n-    line = DECL_SOURCE_LINE (sym);\n-\n-  fprintf (asm_out_file, \"\\\",%d,0,%d,\", current_sym_code, line);\n-  if (current_sym_addr)\n-    output_addr_const (asm_out_file, current_sym_addr);\n-  else\n-    fprintf (asm_out_file, \"%d\", current_sym_value);\n-  putc ('\\n', asm_out_file);\n-#endif\n+    stabstr_C (letter);\n }\n \n /* Output definitions of all the decls in a chain. Return nonzero if\n@@ -2793,7 +2981,6 @@ void\n dbxout_parms (tree parms)\n {\n   ++debug_nesting;\n-\n   emit_pending_bincls_if_required ();\n \n   for (; parms; parms = TREE_CHAIN (parms))\n@@ -2802,7 +2989,10 @@ dbxout_parms (tree parms)\n \t&& DECL_RTL_SET_P (parms)\n \t&& DECL_INCOMING_RTL (parms))\n       {\n-\tdbxout_prepare_symbol (parms);\n+\ttree eff_type;\n+\tchar letter;\n+\tSTAB_CODE_TYPE code;\n+\tint number;\n \n \t/* Perform any necessary register eliminations on the parameter's rtl,\n \t   so that the debugging output will be accurate.  */\n@@ -2819,101 +3009,60 @@ dbxout_parms (tree parms)\n \n \tif (PARM_PASSED_IN_MEMORY (parms))\n \t  {\n-\t    rtx addr = XEXP (DECL_INCOMING_RTL (parms), 0);\n+\t    rtx inrtl = XEXP (DECL_INCOMING_RTL (parms), 0);\n \n \t    /* ??? Here we assume that the parm address is indexed\n \t       off the frame pointer or arg pointer.\n \t       If that is not true, we produce meaningless results,\n \t       but do not crash.  */\n-\t    if (GET_CODE (addr) == PLUS\n-\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-\t      current_sym_value = INTVAL (XEXP (addr, 1));\n-\t    else\n-\t      current_sym_value = 0;\n-\n-\t    current_sym_code = N_PSYM;\n-\t    current_sym_addr = 0;\n-\n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n-\t\tfprintf (asm_out_file, \"%s\\\"%s:p\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\t      }\n+\t    if (GET_CODE (inrtl) == PLUS\n+\t\t&& GET_CODE (XEXP (inrtl, 1)) == CONST_INT)\n+\t      number = INTVAL (XEXP (inrtl, 1));\n \t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asm_out_file, \"%s\\\"(anon):p\", ASM_STABS_OP);\n-\t      }\n-\n-\t    /* It is quite tempting to use:\n-\n-\t           dbxout_type (TREE_TYPE (parms), 0);\n-\n-\t       as the next statement, rather than using DECL_ARG_TYPE(), so\n-\t       that gcc reports the actual type of the parameter, rather\n-\t       than the promoted type.  This certainly makes GDB's life\n-\t       easier, at least for some ports.  The change is a bad idea\n-\t       however, since GDB expects to be able access the type without\n-\t       performing any conversions.  So for example, if we were\n-\t       passing a float to an unprototyped function, gcc will store a\n-\t       double on the stack, but if we emit a stab saying the type is a\n-\t       float, then gdb will only read in a single value, and this will\n-\t       produce an erroneous value.  */\n-\t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n-\t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n-\t    dbxout_finish_symbol (parms);\n+\t      number = 0;\n+\n+\t    code = N_PSYM;\n+\t    number = DEBUGGER_ARG_OFFSET (number, inrtl);\n+\t    letter = 'p';\n+\n+\t    /* It is quite tempting to use TREE_TYPE (parms) instead\n+\t       of DECL_ARG_TYPE (parms) for the eff_type, so that gcc\n+\t       reports the actual type of the parameter, rather than\n+\t       the promoted type.  This certainly makes GDB's life\n+\t       easier, at least for some ports.  The change is a bad\n+\t       idea however, since GDB expects to be able access the\n+\t       type without performing any conversions.  So for\n+\t       example, if we were passing a float to an unprototyped\n+\t       function, gcc will store a double on the stack, but if\n+\t       we emit a stab saying the type is a float, then gdb\n+\t       will only read in a single value, and this will produce\n+\t       an erroneous value.  */\n+\t    eff_type = DECL_ARG_TYPE (parms);\n \t  }\n \telse if (REG_P (DECL_RTL (parms)))\n \t  {\n \t    rtx best_rtl;\n-\t    char regparm_letter;\n-\t    tree parm_type;\n-\t    /* Parm passed in registers and lives in registers or nowhere.  */\n-\n-\t    current_sym_code = DBX_REGPARM_STABS_CODE;\n-\t    regparm_letter = DBX_REGPARM_STABS_LETTER;\n-\t    current_sym_addr = 0;\n-\n-\t    /* If parm lives in a register, use that register;\n-\t       pretend the parm was passed there.  It would be more consistent\n-\t       to describe the register where the parm was passed,\n-\t       but in practice that register usually holds something else.\n \n-\t       If we use DECL_RTL, then we must use the declared type of\n-\t       the variable, not the type that it arrived in.  */\n+\t    /* Parm passed in registers and lives in registers or nowhere.  */\n+\t    code = DBX_REGPARM_STABS_CODE;\n+\t    letter = DBX_REGPARM_STABS_LETTER;\n+\n+\t    /* For parms passed in registers, it is better to use the\n+\t       declared type of the variable, not the type it arrived in.  */\n+\t    eff_type = TREE_TYPE (parms);\n+\n+\t    /* If parm lives in a register, use that register; pretend\n+\t       the parm was passed there.  It would be more consistent\n+\t       to describe the register where the parm was passed, but\n+\t       in practice that register usually holds something else.\n+\t       If the parm lives nowhere, use the register where it\n+\t       was passed.  */\n \t    if (REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n-\t      {\n-\t\tbest_rtl = DECL_RTL (parms);\n-\t\tparm_type = TREE_TYPE (parms);\n-\t      }\n-\t    /* If the parm lives nowhere, use the register where it was\n-\t       passed.  It is also better to use the declared type here.  */\n+\t      best_rtl = DECL_RTL (parms);\n \t    else\n-\t      {\n-\t\tbest_rtl = DECL_INCOMING_RTL (parms);\n-\t\tparm_type = TREE_TYPE (parms);\n-\t      }\n-\t    current_sym_value = DBX_REGISTER_NUMBER (REGNO (best_rtl));\n+\t      best_rtl = DECL_INCOMING_RTL (parms);\n \n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars = 2 + IDENTIFIER_LENGTH (DECL_NAME (parms));\n-\t\tfprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n-\t\t\t regparm_letter);\n-\t      }\n-\t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asm_out_file, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n-\t\t\t regparm_letter);\n-\t      }\n-\n-\t    dbxout_type (parm_type, 0);\n-\t    dbxout_finish_symbol (parms);\n+\t    number = DBX_REGISTER_NUMBER (REGNO (best_rtl));\n \t  }\n \telse if (MEM_P (DECL_RTL (parms))\n \t\t && REG_P (XEXP (DECL_RTL (parms), 0))\n@@ -2928,48 +3077,24 @@ dbxout_parms (tree parms)\n \t       That is, its address was passed in a register.\n \t       Output it as if it lived in that register.\n \t       The debugger will know from the type\n-\t       that it was actually passed by invisible reference.  */\n-\n-\t    char regparm_letter;\n-\t    /* Parm passed in registers and lives in registers or nowhere.  */\n-\n-\t    current_sym_code = DBX_REGPARM_STABS_CODE;\n+\t       that it was actually passed by invisible reference. */\n \n-\t    if (use_gnu_debug_info_extensions)\n-\t      /* GDB likes this marked with a special letter.  */\n-\t      regparm_letter = 'a';\n-\t    else\n-\t      regparm_letter = DBX_REGPARM_STABS_LETTER;\n+\t    code = DBX_REGPARM_STABS_CODE;\n+ \n+\t    /* GDB likes this marked with a special letter.  */\n+\t    letter = (use_gnu_debug_info_extensions\n+\t\t      ? 'a' : DBX_REGPARM_STABS_LETTER);\n+\t    eff_type = TREE_TYPE (parms);\n \n \t    /* DECL_RTL looks like (MEM (REG...).  Get the register number.\n \t       If it is an unallocated pseudo-reg, then use the register where\n-\t       it was passed instead.  */\n-\t    if (REGNO (XEXP (DECL_RTL (parms), 0)) < FIRST_PSEUDO_REGISTER)\n-\t      current_sym_value = REGNO (XEXP (DECL_RTL (parms), 0));\n-\t    else\n-\t      current_sym_value = REGNO (DECL_INCOMING_RTL (parms));\n+\t       it was passed instead.\n+\t       ??? Why is DBX_REGISTER_NUMBER not used here?  */\n \n-\t    current_sym_addr = 0;\n-\n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars\n-\t\t  = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\n-\t\tfprintf (asm_out_file, \"%s\\\"%s:%c\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)),\n-\t\t\t regparm_letter);\n-\t      }\n+\t    if (REGNO (XEXP (DECL_RTL (parms), 0)) < FIRST_PSEUDO_REGISTER)\n+\t      number = REGNO (XEXP (DECL_RTL (parms), 0));\n \t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asm_out_file, \"%s\\\"(anon):%c\", ASM_STABS_OP,\n-\t\t\t regparm_letter);\n-\t      }\n-\n-\t    dbxout_type (TREE_TYPE (parms), 0);\n-\t    dbxout_finish_symbol (parms);\n+\t      number = REGNO (DECL_INCOMING_RTL (parms));\n \t  }\n \telse if (MEM_P (DECL_RTL (parms))\n \t\t && MEM_P (XEXP (DECL_RTL (parms), 0)))\n@@ -2978,25 +3103,18 @@ dbxout_parms (tree parms)\n \t       living on the stack.  DECL_RTL looks like\n \t       (MEM (MEM (PLUS (REG ...) (CONST_INT ...)))) or it\n \t       could look like (MEM (MEM (REG))).  */\n-\t    const char *const decl_name = (DECL_NAME (parms)\n-\t\t\t\t     ? IDENTIFIER_POINTER (DECL_NAME (parms))\n-\t\t\t\t     : \"(anon)\");\n-\t    if (REG_P (XEXP (XEXP (DECL_RTL (parms), 0), 0)))\n-\t      current_sym_value = 0;\n+\n+\t    code = N_PSYM;\n+\t    letter = 'v';\n+\t    eff_type = TREE_TYPE (parms);\n+\n+\t    if (!REG_P (XEXP (XEXP (DECL_RTL (parms), 0), 0)))\n+\t      number = INTVAL (XEXP (XEXP (XEXP (DECL_RTL (parms), 0), 0), 1));\n \t    else\n-\t      current_sym_value\n-\t        = INTVAL (XEXP (XEXP (XEXP (DECL_RTL (parms), 0), 0), 1));\n-\t    current_sym_addr = 0;\n-\t    current_sym_code = N_PSYM;\n-\n-\t    FORCE_TEXT;\n-\t    fprintf (asm_out_file, \"%s\\\"%s:v\", ASM_STABS_OP, decl_name);\n-\n-\t    current_sym_value\n-\t      = DEBUGGER_ARG_OFFSET (current_sym_value,\n-\t\t\t\t     XEXP (XEXP (DECL_RTL (parms), 0), 0));\n-\t    dbxout_type (TREE_TYPE (parms), 0);\n-\t    dbxout_finish_symbol (parms);\n+\t      number = 0;\n+\n+\t    number = DEBUGGER_ARG_OFFSET (number,\n+\t\t\t\t\t  XEXP (XEXP (DECL_RTL (parms), 0), 0));\n \t  }\n \telse if (MEM_P (DECL_RTL (parms))\n \t\t && XEXP (DECL_RTL (parms), 0) != const0_rtx\n@@ -3007,51 +3125,43 @@ dbxout_parms (tree parms)\n \t  {\n \t    /* Parm was passed in registers but lives on the stack.  */\n \n-\t    current_sym_code = N_PSYM;\n+\t    code = N_PSYM;\n+\t    letter = 'p';\n+\t    eff_type = TREE_TYPE (parms);\n+\n \t    /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))),\n \t       in which case we want the value of that CONST_INT,\n \t       or (MEM (REG ...)),\n \t       in which case we use a value of zero.  */\n-\t    if (REG_P (XEXP (DECL_RTL (parms), 0)))\n-\t      current_sym_value = 0;\n+\t    if (!REG_P (XEXP (DECL_RTL (parms), 0)))\n+\t      number = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n \t    else\n-\t\tcurrent_sym_value\n-\t\t  = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n-\n-\t    current_sym_addr = 0;\n+\t      number = 0;\n \n \t    /* Make a big endian correction if the mode of the type of the\n \t       parameter is not the same as the mode of the rtl.  */\n \t    if (BYTES_BIG_ENDIAN\n \t\t&& TYPE_MODE (TREE_TYPE (parms)) != GET_MODE (DECL_RTL (parms))\n \t\t&& GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))) < UNITS_PER_WORD)\n-\t      {\n-\t\tcurrent_sym_value +=\n-\t\t    GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))\n-\t\t    - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms)));\n-\t      }\n-\n-\t    FORCE_TEXT;\n-\t    if (DECL_NAME (parms))\n-\t      {\n-\t\tcurrent_sym_nchars\n-\t\t  = 2 + strlen (IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\n-\t\tfprintf (asm_out_file, \"%s\\\"%s:p\", ASM_STABS_OP,\n-\t\t\t IDENTIFIER_POINTER (DECL_NAME (parms)));\n-\t      }\n-\t    else\n-\t      {\n-\t\tcurrent_sym_nchars = 8;\n-\t\tfprintf (asm_out_file, \"%s\\\"(anon):p\", ASM_STABS_OP);\n-\t      }\n+\t      number += (GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))\n+\t\t\t - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))));\n+\t  }\n+\telse\n+\t  /* ??? We don't know how to represent this argument.  */\n+\t  continue;\n \n-\t    current_sym_value\n-\t      = DEBUGGER_ARG_OFFSET (current_sym_value,\n-\t\t\t\t     XEXP (DECL_RTL (parms), 0));\n-\t    dbxout_type (TREE_TYPE (parms), 0);\n-\t    dbxout_finish_symbol (parms);\n+\tdbxout_begin_complex_stabs ();\n+\t    \n+\tif (DECL_NAME (parms))\n+\t  {\n+\t    stabstr_I (DECL_NAME (parms));\n+\t    stabstr_C (':');\n \t  }\n+\telse\n+\t  stabstr_S (\"(anon):\");\n+\tstabstr_C (letter);\n+\tdbxout_type (eff_type, 0);\n+\tdbxout_finish_complex_stabs (parms, code, 0, 0, number);\n       }\n   DBXOUT_DECR_NESTING;\n }\n@@ -3075,8 +3185,6 @@ dbxout_reg_parms (tree parms)\n   for (; parms; parms = TREE_CHAIN (parms))\n     if (DECL_NAME (parms) && PARM_PASSED_IN_MEMORY (parms))\n       {\n-\tdbxout_prepare_symbol (parms);\n-\n \t/* Report parms that live in registers during the function\n \t   but were passed in memory.  */\n \tif (REG_P (DECL_RTL (parms))\n@@ -3103,9 +3211,8 @@ dbxout_args (tree args)\n {\n   while (args)\n     {\n-      putc (',', asm_out_file);\n+      stabstr_C (',');\n       dbxout_type (TREE_VALUE (args), 0);\n-      CHARS (1);\n       args = TREE_CHAIN (args);\n     }\n }\n@@ -3120,14 +3227,11 @@ dbx_output_lbrac (const char *label,\n #ifdef DBX_OUTPUT_LBRAC\n   DBX_OUTPUT_LBRAC (asm_out_file, label);\n #else\n-  fprintf (asm_out_file, \"%s%d,0,0,\", ASM_STABN_OP, N_LBRAC);\n-  assemble_name (asm_out_file, label);\n+  dbxout_begin_stabn (N_LBRAC);\n   if (DBX_BLOCKS_FUNCTION_RELATIVE)\n-    {\n-      putc ('-', asm_out_file);\n-      assemble_name (asm_out_file, begin_label);\n-    }\n-  fprintf (asm_out_file, \"\\n\");\n+    dbxout_stab_value_label_diff (label, begin_label);\n+  else\n+    dbxout_stab_value_label (label);\n #endif\n }\n \n@@ -3141,14 +3245,11 @@ dbx_output_rbrac (const char *label,\n #ifdef DBX_OUTPUT_RBRAC\n   DBX_OUTPUT_RBRAC (asm_out_file, label);\n #else\n-  fprintf (asm_out_file, \"%s%d,0,0,\", ASM_STABN_OP, N_RBRAC);\n-  assemble_name (asm_out_file, label);\n+  dbxout_begin_stabn (N_RBRAC);\n   if (DBX_BLOCKS_FUNCTION_RELATIVE)\n-    {\n-      putc ('-', asm_out_file);\n-      assemble_name (asm_out_file, begin_label);\n-    }\n-  fprintf (asm_out_file, \"\\n\");\n+    dbxout_stab_value_label_diff (label, begin_label);\n+  else\n+    dbxout_stab_value_label (label);\n #endif\n }\n \n@@ -3172,8 +3273,8 @@ dbx_output_rbrac (const char *label,\n static void\n dbxout_block (tree block, int depth, tree args)\n {\n-  const char *begin_label;\n-  begin_label = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n+  const char *begin_label\n+    = XSTR (XEXP (DECL_RTL (current_function_decl), 0), 0);\n \n   while (block)\n     {\n@@ -3216,10 +3317,11 @@ dbxout_block (tree block, int depth, tree args)\n \t\t  tree decl = BLOCK_VARS (block);\n \t\t  while (decl)\n \t\t    {\n-\t\t      fprintf (asm_out_file, \"%s\\\"%s:C1\\\",%d,0,0,\", ASM_STABS_OP,\n-\t\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)), N_CATCH);\n-\t\t      assemble_name (asm_out_file, scope_start);\n-\t\t      fprintf (asm_out_file, \"\\n\");\n+\t\t      dbxout_begin_complex_stabs ();\n+\t\t      stabstr_I (DECL_NAME (decl));\n+\t\t      stabstr_S (\":C1\");\n+\t\t      dbxout_finish_complex_stabs (0, N_CATCH, 0,\n+\t\t\t\t\t\t   scope_start, 0);\n \t\t      decl = TREE_CHAIN (decl);\n \t\t    }\n \t\t}"}, {"sha": "b69ae13f3320d73f419c3b1cf86780c55b17f086", "filename": "gcc/defaults.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -73,10 +73,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n   } while (0)\n #endif\n \n-#ifndef ASM_STABD_OP\n-#define ASM_STABD_OP \"\\t.stabd\\t\"\n-#endif\n-\n /* This is how to output an element of a case-vector that is absolute.\n    Some targets don't use this, but we have to define it anyway.  */\n "}, {"sha": "061df95f1cbd7b9fa507cadb421a3537d0a7983a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -8049,26 +8049,36 @@ This describes file names in DBX format.\n \n @defmac DBX_OUTPUT_MAIN_SOURCE_FILENAME (@var{stream}, @var{name})\n A C statement to output DBX debugging information to the stdio stream\n-@var{stream} which indicates that file @var{name} is the main source\n+@var{stream}, which indicates that file @var{name} is the main source\n file---the file specified as the input file for compilation.\n This macro is called only once, at the beginning of compilation.\n \n This macro need not be defined if the standard form of output\n for DBX debugging information is appropriate.\n+\n+It may be necessary to refer to a label equal to the beginning of the\n+text section.  You can use @samp{assemble_name (stream, ltext_label_name)}\n+to do so.  If you do this, you must also set the variable\n+@var{used_ltext_label_name} to @code{true}.\n @end defmac\n \n-@defmac DBX_OUTPUT_MAIN_SOURCE_DIRECTORY (@var{stream}, @var{name})\n-A C statement to output DBX debugging information to the stdio stream\n-@var{stream} which indicates that the current directory during\n-compilation is named @var{name}.\n+@defmac NO_DBX_MAIN_SOURCE_DIRECTORY\n+Define this macro, with value 1, if GCC should not emit an indication\n+of the current directory for compilation and current source language at\n+the beginning of the file.\n+@end defmac\n \n-This macro need not be defined if the standard form of output\n-for DBX debugging information is appropriate.\n+@defmac NO_DBX_GCC_MARKER\n+Define this macro, with value 1, if GCC should not emit an indication\n+that this object file was compiled by GCC@.  The default is to emit\n+an @code{N_OPT} stab at the beginning of every source file, with\n+@samp{gcc2_compiled.} for the string and value 0.\n @end defmac\n \n @defmac DBX_OUTPUT_MAIN_SOURCE_FILE_END (@var{stream}, @var{name})\n A C statement to output DBX debugging information at the end of\n-compilation of the main source file @var{name}.\n+compilation of the main source file @var{name}.  Output should be\n+written to the stdio stream @var{stream}.\n \n If you don't define this macro, nothing special is output at the end\n of compilation, which is correct for most machines."}, {"sha": "5148b5e5c6012fbe1ccc5dbb4ec000588a98bd6f", "filename": "gcc/output.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -522,4 +522,24 @@ extern bool default_valid_pointer_mode (enum machine_mode);\n \n extern int default_address_cost (rtx);\n \n+/* dbxout helper functions */\n+#if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO\n+\n+extern void dbxout_int (int);\n+extern void dbxout_stabd (int, int);\n+extern void dbxout_begin_stabn (int);\n+extern void dbxout_begin_stabn_sline (int);\n+extern void dbxout_begin_empty_stabs (int);\n+extern void dbxout_begin_simple_stabs (const char *, int);\n+extern void dbxout_begin_simple_stabs_desc (const char *, int, int);\n+\n+extern void dbxout_stab_value_zero (void);\n+extern void dbxout_stab_value_label (const char *);\n+extern void dbxout_stab_value_label_diff (const char *, const char *);\n+extern void dbxout_stab_value_internal_label (const char *, int *);\n+extern void dbxout_stab_value_internal_label_diff (const char *, int *,\n+\t\t\t\t\t\t   const char *);\n+\n+#endif\n+\n #endif /* ! GCC_OUTPUT_H */"}, {"sha": "20b8c2b02d4927e026b81885cb7bd8c4eaf228c9", "filename": "gcc/system.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -656,7 +656,8 @@ extern void fancy_abort (const char *, int, const char *) ATTRIBUTE_NORETURN;\n \tCOLLECT_PARSE_FLAG DWARF2_GENERATE_TEXT_SECTION_LABEL WINNING_GDB  \\\n \tASM_OUTPUT_FILENAME ASM_OUTPUT_SOURCE_LINE FILE_NAME_JOINER\t   \\\n \tGDB_INV_REF_REGPARM_STABS_LETTER DBX_MEMPARM_STABS_LETTER\t   \\\n-\tPUT_SDB_SRC_FILE STABS_GCC_MARKER DBX_OUTPUT_FUNCTION_END\n+\tPUT_SDB_SRC_FILE STABS_GCC_MARKER DBX_OUTPUT_FUNCTION_END\t   \\\n+\tDBX_OUTPUT_GCC_MARKER DBX_FINISH_SYMBOL\n \n /* Hooks that are no longer used.  */\n  #pragma GCC poison LANG_HOOKS_FUNCTION_MARK LANG_HOOKS_FUNCTION_FREE\t\\"}, {"sha": "acc5e186101498dfbeb6d474e40ee9bf2d2e9d64", "filename": "gcc/varasm.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -57,10 +57,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t\t\t\t   declarations for e.g. AIX 4.x.  */\n #endif\n \n-#ifndef ASM_STABS_OP\n-#define ASM_STABS_OP \"\\t.stabs\\t\"\n-#endif\n-\n /* The (assembler) name of the first globally-visible object output.  */\n const char *first_global_object_name;\n const char *weak_global_object_name;\n@@ -1023,12 +1019,15 @@ assemble_asm (tree string)\n void\n default_stabs_asm_out_destructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n+#if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO\n   /* Tell GNU LD that this is part of the static destructor set.\n      This will work for any system that uses stabs, most usefully\n      aout systems.  */\n-  fprintf (asm_out_file, \"%s\\\"___DTOR_LIST__\\\",22,0,0,\", ASM_STABS_OP);\n-  assemble_name (asm_out_file, XSTR (symbol, 0));\n-  fputc ('\\n', asm_out_file);\n+  dbxout_begin_simple_stabs (\"___DTOR_LIST__\", 22 /* N_SETT */);\n+  dbxout_stab_value_label (XSTR (symbol, 0));\n+#else\n+  sorry (\"global destructors not supported on this target\");\n+#endif\n }\n \n void\n@@ -1080,12 +1079,15 @@ default_dtor_section_asm_out_destructor (rtx symbol,\n void\n default_stabs_asm_out_constructor (rtx symbol, int priority ATTRIBUTE_UNUSED)\n {\n+#if defined DBX_DEBUGGING_INFO || defined XCOFF_DEBUGGING_INFO\n   /* Tell GNU LD that this is part of the static destructor set.\n      This will work for any system that uses stabs, most usefully\n      aout systems.  */\n-  fprintf (asm_out_file, \"%s\\\"___CTOR_LIST__\\\",22,0,0,\", ASM_STABS_OP);\n-  assemble_name (asm_out_file, XSTR (symbol, 0));\n-  fputc ('\\n', asm_out_file);\n+  dbxout_begin_simple_stabs (\"___CTOR_LIST__\", 22 /* N_SETT */);\n+  dbxout_stab_value_label (XSTR (symbol, 0));\n+#else\n+  sorry (\"global constructors not supported on this target\");\n+#endif\n }\n \n void"}, {"sha": "59a0d3a010642ccaf387425196aa000bdd5e7095", "filename": "gcc/xcoffout.h", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fxcoffout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93a27b7badb18e8a13cfc877c8c74e88ecc44774/gcc%2Fxcoffout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.h?ref=93a27b7badb18e8a13cfc877c8c74e88ecc44774", "patch": "@@ -21,8 +21,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n \n-#define ASM_STABS_OP \"\\t.stabx\\t\"\n-\n /* Tags and typedefs are C_DECL in XCOFF, not C_LSYM.  */\n \n #define DBX_TYPE_DECL_STABS_CODE N_DECL\n@@ -70,32 +68,35 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Define our own finish symbol function, since xcoff stabs have their\n    own different format.  */\n \n-#define DBX_FINISH_SYMBOL(ASMFILE,SYM)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (current_sym_addr && current_sym_code == N_FUN)\t\t\\\n-    fprintf ((ASMFILE), \"\\\",.\");\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    fprintf ((ASMFILE), \"\\\",\");\t\t\t\t\t\\\n-  /* If we are writing a function name, we must ensure that\t\\\n-     there is no storage-class suffix on the name.  */\t\t\\\n-  if (current_sym_addr && current_sym_code == N_FUN\t\t\\\n-      && GET_CODE (current_sym_addr) == SYMBOL_REF)\t\t\\\n+#define DBX_FINISH_STABS(CODE, LINE, ADDR, LABEL, NUMBER) do {\t\\\n+  if (ADDR)\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      const char *_p = XSTR (current_sym_addr, 0);\t\t\\\n-      if (*_p == '*')\t\t\t\t\t\t\\\n-\tfprintf ((ASMFILE), \"%s\", _p+1);\t\t\t\\\n+      /* If we are writing a function name, we must ensure that\t\\\n+\t there is no storage-class suffix on the name.  */\t\\\n+      if (CODE == N_FUN && GET_CODE (ADDR) == SYMBOL_REF)\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  const char *_p = XSTR (ADDR, 0);\t\t\t\\\n+\t  if (*_p == '*')\t\t\t\t\t\\\n+\t    fputs (_p+1, asm_out_file);\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\\\n+\t    for (; *_p != '[' && *_p; _p++)\t\t\t\\\n+\t      putc (*_p, asm_out_file);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-\tfor (; *_p != '[' && *_p; _p++)\t\t\t\t\\\n-\t  fprintf ((ASMFILE), \"%c\", *_p);\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (CODE == N_FUN)\t\t\t\t\t\\\n+\t    putc ('.', asm_out_file);\t\t\t\t\\\n+\t  output_addr_const (asm_out_file, ADDR);\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n-  else if (current_sym_addr)\t\t\t\t\t\\\n-    output_addr_const ((ASMFILE), current_sym_addr);\t\t\\\n-  else if (current_sym_code == N_GSYM)\t\t\t\t\\\n-    assemble_name ((ASMFILE), XSTR (XEXP (DECL_RTL (SYM), 0), 0)); \\\n+  else if (LABEL)\t\t\t\t\t\t\\\n+    assemble_name (asm_out_file, LABEL);\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n-    fprintf ((ASMFILE), \"%d\", current_sym_value);\t\t\\\n-  fprintf ((ASMFILE), \",%d,0\\n\", stab_to_sclass (current_sym_code)); \\\n-}\n+    dbxout_int (NUMBER);\t\t\t\t\t\\\n+  putc (',', asm_out_file);\t\t\t\t\t\\\n+  dbxout_int (stab_to_sclass (CODE));\t\t\t\t\\\n+  fputs (\",0\\n\", asm_out_file);\t\t\t\t\t\\\n+} while (0)\n \n /* These are IBM XCOFF extensions we need to reference in dbxout.c\n    and xcoffout.c.  */\n@@ -128,7 +129,7 @@ extern char *xcoff_read_only_section_name;\n extern const char *xcoff_lastfile;\n \n /* Don't write out path name for main source file.  */\n-#define DBX_OUTPUT_MAIN_SOURCE_DIRECTORY(FILE,FILENAME)\n+#define NO_DBX_MAIN_SOURCE_DIRECTORY 1\n \n /* Write out main source file name using \".file\" rather than \".stabs\".\n    We don't actually do this here, because the assembler gets confused if there\n@@ -140,24 +141,18 @@ extern const char *xcoff_lastfile;\n \n /* If we are still in an include file, its end must be marked.  */\n #define DBX_OUTPUT_MAIN_SOURCE_FILE_END(FILE, FILENAME)\t\\\n-{\t\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\\\n   if (xcoff_current_include_file)\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       fputs (\"\\t.ei\\t\", (FILE));\t\t\t\\\n       output_quoted_string ((FILE), xcoff_current_include_file);\t\\\n       putc ('\\n', (FILE));\t\t\t\t\\\n       xcoff_current_include_file = NULL;\t\t\\\n     }\t\t\t\t\t\t\t\\\n-}\n+} while (0)\n \n-/* .stabx has the type in a different place.  */\n-#if 0  /* Do not emit any marker for XCOFF until assembler allows XFT_CV.  */\n-#define DBX_OUTPUT_GCC_MARKER(FILE) \\\n-  fprintf ((FILE), \"%s\\\"gcc2_compiled.\\\",0,%d,0\\n\", ASM_STABS_OP, \\\n-\t   stab_to_sclass (N_GSYM))\n-#else\n-#define DBX_OUTPUT_GCC_MARKER(FILE)\n-#endif\n+/* Do not emit any marker for XCOFF until assembler allows XFT_CV.  */\n+#define NO_DBX_GCC_MARKER\n \n /* Do not break .stabs pseudos into continuations.  */\n #define DBX_CONTIN_LENGTH 0"}]}