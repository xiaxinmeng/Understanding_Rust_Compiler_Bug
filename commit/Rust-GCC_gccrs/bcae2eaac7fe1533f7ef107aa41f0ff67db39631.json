{"sha": "bcae2eaac7fe1533f7ef107aa41f0ff67db39631", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNhZTJlYWFjN2ZlMTUzM2Y3ZWYxMDdhYTQxZjBmZjY3ZGIzOTYzMQ==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2010-10-08T12:30:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-08T12:30:52Z"}, "message": "sem_prag.adb (Analyze_Pragma): Add missing checks on wrong use of pragmas CIL_Constructor and Java_Constructor.\n\n\t* sem_prag.adb (Analyze_Pragma): Add missing checks on wrong use of\n\tpragmas CIL_Constructor and Java_Constructor.\n\nFrom-SVN: r165167", "tree": {"sha": "a787824c49c6efe6c809bca6246d384e168a4f92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a787824c49c6efe6c809bca6246d384e168a4f92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcae2eaac7fe1533f7ef107aa41f0ff67db39631", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcae2eaac7fe1533f7ef107aa41f0ff67db39631", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcae2eaac7fe1533f7ef107aa41f0ff67db39631", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcae2eaac7fe1533f7ef107aa41f0ff67db39631/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "394860586c4ea568a64497652df7dc318a0d734d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/394860586c4ea568a64497652df7dc318a0d734d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/394860586c4ea568a64497652df7dc318a0d734d"}], "stats": {"total": 194, "additions": 164, "deletions": 30}, "files": [{"sha": "30a0a3f0dde73c7c51643f40a38578ef2d5c6887", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 164, "deletions": 30, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcae2eaac7fe1533f7ef107aa41f0ff67db39631/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcae2eaac7fe1533f7ef107aa41f0ff67db39631/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=bcae2eaac7fe1533f7ef107aa41f0ff67db39631", "patch": "@@ -8903,10 +8903,10 @@ package body Sem_Prag is\n \n          when Pragma_CIL_Constructor | Pragma_Java_Constructor =>\n          Java_Constructor : declare\n-            Id         : Entity_Id;\n+            Convention : Convention_Id;\n             Def_Id     : Entity_Id;\n             Hom_Id     : Entity_Id;\n-            Convention : Convention_Id;\n+            Id         : Entity_Id;\n \n          begin\n             GNAT_Pragma;\n@@ -8923,6 +8923,22 @@ package body Sem_Prag is\n                return;\n             end if;\n \n+            --  Check wrong use of pragma in wrong VM target\n+\n+            if VM_Target = No_VM then\n+               return;\n+\n+            elsif VM_Target = CLI_Target\n+              and then Prag_Id = Pragma_Java_Constructor\n+            then\n+               Error_Pragma (\"must use pragma 'C'I'L_'Constructor\");\n+\n+            elsif VM_Target = JVM_Target\n+              and then Prag_Id = Pragma_CIL_Constructor\n+            then\n+               Error_Pragma (\"must use pragma 'Java_'Constructor\");\n+            end if;\n+\n             case Prag_Id is\n                when Pragma_CIL_Constructor  => Convention := Convention_CIL;\n                when Pragma_Java_Constructor => Convention := Convention_Java;\n@@ -8936,43 +8952,161 @@ package body Sem_Prag is\n             loop\n                Def_Id := Get_Base_Subprogram (Hom_Id);\n \n-               --  The constructor is required to be a function returning an\n-               --  access type whose designated type has convention Java/CIL.\n+               --  The constructor is required to be a function\n \n-               if Ekind (Def_Id) = E_Function\n-                 and then\n-                   (Is_Value_Type (Etype (Def_Id))\n-                     or else\n-                       (Ekind (Etype (Def_Id)) = E_Access_Subprogram_Type\n-                         and then\n-                          Atree.Convention (Etype (Def_Id)) = Convention)\n-                     or else\n-                       (Ekind (Etype (Def_Id)) in Access_Kind\n-                         and then\n-                          (Atree.Convention\n-                             (Designated_Type (Etype (Def_Id))) = Convention\n-                            or else\n-                              Atree.Convention\n-                               (Root_Type (Designated_Type (Etype (Def_Id)))) =\n-                                                                 Convention)))\n-               then\n-                  Set_Is_Constructor (Def_Id);\n-                  Set_Convention     (Def_Id, Convention);\n-                  Set_Is_Imported    (Def_Id);\n-\n-               else\n-                  if Convention = Convention_Java then\n+               if Ekind (Def_Id) /= E_Function then\n+                  if VM_Target = JVM_Target then\n                      Error_Pragma_Arg\n                        (\"pragma% requires function returning a \" &\n-                        \"'Java access type\", Arg1);\n+                        \"'Java access type\", Def_Id);\n                   else\n-                     pragma Assert (Convention = Convention_CIL);\n                      Error_Pragma_Arg\n                        (\"pragma% requires function returning a \" &\n-                        \"'C'I'L access type\", Arg1);\n+                        \"'C'I'L access type\", Def_Id);\n+                  end if;\n+               end if;\n+\n+               --  Check arguments: For tagged type the first formal must be\n+               --  named \"this\" and its type must be a named access type\n+               --  designating a class-wide tagged type that has convention\n+               --  CIL/Java. The first formal must also have a null default\n+               --  value. For example:\n+\n+               --      type Typ is tagged ...\n+               --      type Ref is access all Typ;\n+               --      pragma Convention (CIL, Typ);\n+\n+               --      function New_Typ (This : Ref) return Ref;\n+               --      function New_Typ (This : Ref; I : Integer) return Ref;\n+               --      pragma Cil_Constructor (New_Typ);\n+\n+               --  Reason: The first formal must NOT be a primitive of the\n+               --  tagged type.\n+\n+               --  This rule also applies to constructors of delegates used\n+               --  to interface with standard target libraries. For example:\n+\n+               --      type Delegate is access procedure ...\n+               --      pragma Import (CIL, Delegate, ...);\n+\n+               --      function new_Delegate\n+               --        (This : Delegate := null; ... ) return Delegate;\n+\n+               --  For value-types this rule does not apply.\n+\n+               if not Is_Value_Type (Etype (Def_Id)) then\n+                  if No (First_Formal (Def_Id)) then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_N\n+                       (\"first formal of % function must be named `this`\",\n+                        Def_Id);\n+\n+                  elsif Get_Name_String (Chars (First_Formal (Def_Id)))\n+                          /= \"this\"\n+                  then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_N\n+                       (\"first formal of % function must be named `this`\",\n+                        Parent (First_Formal (Def_Id)));\n+\n+                  --  Warning: We should reject anonymous access types because\n+                  --  the constructor must not be handled as a primitive of the\n+                  --  tagged type. We temporarily allow it because this profile\n+                  --  is currently generated by cil2ada???\n+\n+                  elsif not Is_Access_Type (Etype (First_Formal (Def_Id)))\n+                    or else not Ekind_In (Etype (First_Formal (Def_Id)),\n+                                  E_Access_Type,\n+                                  E_General_Access_Type,\n+                                  E_Anonymous_Access_Type) --  ???\n+                  then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_N\n+                       (\"first formal of % function must be a named access\" &\n+                        \" type\",\n+                        Parameter_Type (Parent (First_Formal (Def_Id))));\n+\n+                  elsif Atree.Convention\n+                         (Designated_Type (Etype (First_Formal (Def_Id))))\n+                           /= Convention\n+                  then\n+                     Error_Msg_Name_1 := Pname;\n+\n+                     if Convention = Convention_Java then\n+                        Error_Msg_N\n+                          (\"pragma% requires convention 'Cil in designated\" &\n+                           \" type\",\n+                           Parameter_Type (Parent (First_Formal (Def_Id))));\n+                     else\n+                        Error_Msg_N\n+                          (\"pragma% requires convention 'Java in designated\" &\n+                           \" type\",\n+                           Parameter_Type (Parent (First_Formal (Def_Id))));\n+                     end if;\n+\n+                  elsif No (Expression (Parent (First_Formal (Def_Id))))\n+                    or else\n+                      Nkind (Expression (Parent (First_Formal (Def_Id)))) /=\n+                        N_Null\n+                  then\n+                     Error_Msg_Name_1 := Pname;\n+                     Error_Msg_N\n+                       (\"pragma% requires first formal with default `null`\",\n+                        Parameter_Type (Parent (First_Formal (Def_Id))));\n                   end if;\n                end if;\n \n+               --  Check result type: the constructor must be a function\n+               --  returning:\n+               --   * a value type (only allowed in the CIL compiler)\n+               --   * an access-to-subprogram type with convention Java/CIL\n+               --   * an access-type designating a type that has convention\n+               --     Java/CIL.\n+\n+               if Is_Value_Type (Etype (Def_Id)) then\n+                  null;\n+\n+               --  Access-to-subprogram type with convention Java/CIL\n+\n+               elsif Ekind (Etype (Def_Id)) = E_Access_Subprogram_Type then\n+                  if Atree.Convention (Etype (Def_Id)) /= Convention then\n+                     if Convention = Convention_Java then\n+                        Error_Pragma_Arg\n+                          (\"pragma% requires function returning a \" &\n+                           \"'Java access type\", Arg1);\n+                     else\n+                        pragma Assert (Convention = Convention_CIL);\n+                        Error_Pragma_Arg\n+                          (\"pragma% requires function returning a \" &\n+                           \"'C'I'L access type\", Arg1);\n+                     end if;\n+                  end if;\n+\n+               elsif Ekind (Etype (Def_Id)) in Access_Kind then\n+                  if not Ekind_In (Etype (Def_Id), E_Access_Type,\n+                                                   E_General_Access_Type)\n+                    or else\n+                      Atree.Convention\n+                        (Designated_Type (Etype (Def_Id))) /= Convention\n+                  then\n+                     Error_Msg_Name_1 := Pname;\n+\n+                     if Convention = Convention_Java then\n+                        Error_Pragma_Arg\n+                          (\"pragma% requires function returning a named\" &\n+                           \"'Java access type\", Arg1);\n+                     else\n+                        Error_Pragma_Arg\n+                          (\"pragma% requires function returning a named\" &\n+                           \"'C'I'L access type\", Arg1);\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               Set_Is_Constructor (Def_Id);\n+               Set_Convention     (Def_Id, Convention);\n+               Set_Is_Imported    (Def_Id);\n+\n                Hom_Id := Homonym (Hom_Id);\n \n                exit when No (Hom_Id) or else Scope (Hom_Id) /= Current_Scope;"}]}