{"sha": "34a39466b2adb9684a1737c6ea4915e0194c26bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRhMzk0NjZiMmFkYjk2ODRhMTczN2M2ZWE0OTE1ZTAxOTRjMjZiZg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-02-03T16:45:27Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-02-06T15:45:51Z"}, "message": "Add in support to compile Methods and MethodCallExpr\n\nThere is more work to be done here with adjustments to the self argument\nsuch as borrows and mutability checking.\n\nMethod resolution is basic, for now there is code to scan for all possible\nmatches but traits are not supported at the moment so this resolves quite\nsimply for now.\n\nFixes #191 #112", "tree": {"sha": "df65323e28a0b4507431969d62ac932fc2efb2d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df65323e28a0b4507431969d62ac932fc2efb2d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34a39466b2adb9684a1737c6ea4915e0194c26bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a39466b2adb9684a1737c6ea4915e0194c26bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34a39466b2adb9684a1737c6ea4915e0194c26bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34a39466b2adb9684a1737c6ea4915e0194c26bf/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59a8fa1a80c3b2c6520c627a6bf200274732d395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a8fa1a80c3b2c6520c627a6bf200274732d395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a8fa1a80c3b2c6520c627a6bf200274732d395"}], "stats": {"total": 1393, "additions": 1170, "deletions": 223}, "files": [{"sha": "50006d16476ba1ade4648f25675e152dc62dfcb0", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -2355,9 +2355,9 @@ class CallExpr : public ExprWithoutBlock\n \n   void iterate_params (std::function<bool (Expr *)> cb)\n   {\n-    for (auto it = params.begin (); it != params.end (); it++)\n+    for (auto &param : params)\n       {\n-\tif (!cb (it->get ()))\n+\tif (!cb (param.get ()))\n \t  return;\n       }\n   }\n@@ -2456,6 +2456,15 @@ class MethodCallExpr : public ExprWithoutBlock\n   void mark_for_strip () override { receiver = nullptr; }\n   bool is_marked_for_strip () const override { return receiver == nullptr; }\n \n+  void iterate_params (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto &param : params)\n+      {\n+\tif (!cb (param.get ()))\n+\t  return;\n+      }\n+  }\n+\n   // TODO: this mutable getter seems really dodgy. Think up better way.\n   const std::vector<std::unique_ptr<Expr> > &get_params () const\n   {"}, {"sha": "352fabc564af812330549cdf5f7db516fc60b311", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -366,12 +366,14 @@ struct SelfParam\n   // bool has_type; // only possible if not ref\n   std::unique_ptr<Type> type;\n \n+  NodeId node_id;\n+\n   Location locus;\n \n   // Unrestricted constructor used for error state\n   SelfParam (Lifetime lifetime, bool has_ref, bool is_mut, Type *type)\n     : has_ref (has_ref), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      type (type)\n+      type (type), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n   // this is ok as no outside classes can ever call this\n \n@@ -401,20 +403,23 @@ struct SelfParam\n   // Type-based self parameter (not ref, no lifetime)\n   SelfParam (std::unique_ptr<Type> type, bool is_mut, Location locus)\n     : has_ref (false), is_mut (is_mut), lifetime (Lifetime::error ()),\n-      type (std::move (type)), locus (locus)\n+      type (std::move (type)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()), locus (locus)\n   {}\n \n   // Lifetime-based self parameter (is ref, no type)\n   SelfParam (Lifetime lifetime, bool is_mut, Location locus)\n     : has_ref (true), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      locus (locus)\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()), locus (locus)\n   {}\n \n   // Copy constructor requires clone\n   SelfParam (SelfParam const &other)\n     : has_ref (other.has_ref), is_mut (other.is_mut), lifetime (other.lifetime),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()),\n       locus (other.locus)\n   {\n+    node_id = other.node_id;\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n   }\n@@ -426,6 +431,7 @@ struct SelfParam\n     has_ref = other.has_ref;\n     lifetime = other.lifetime;\n     locus = other.locus;\n+    node_id = other.node_id;\n \n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n@@ -443,6 +449,13 @@ struct SelfParam\n \n   Location get_locus () const { return locus; }\n \n+  bool get_has_ref () const { return has_ref; };\n+  bool get_is_mut () const { return is_mut; }\n+\n+  Lifetime get_lifetime () const { return lifetime; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type ()\n   {"}, {"sha": "049aaf0044811b19fbfb5b226f81581c638248ae", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -78,7 +78,7 @@ class IdentifierPattern : public Pattern\n   Location locus;\n \n public:\n-  std::string as_string () const;\n+  std::string as_string () const override;\n \n   // Returns whether the IdentifierPattern has a pattern to bind.\n   bool has_pattern_to_bind () const { return to_bind != nullptr; }\n@@ -91,6 +91,15 @@ class IdentifierPattern : public Pattern\n       is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n   {}\n \n+  IdentifierPattern (NodeId node_id, Identifier ident, Location locus,\n+\t\t     bool is_ref = false, bool is_mut = false,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus)\n+  {\n+    this->node_id = node_id;\n+  }\n+\n   // Copy constructor with clone\n   IdentifierPattern (IdentifierPattern const &other)\n     : variable_ident (other.variable_ident), is_ref (other.is_ref),"}, {"sha": "3ba837c14ea83d3c2402f78395c27064b6579eb0", "filename": "gcc/rust/backend/cscope.h", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59a8fa1a80c3b2c6520c627a6bf200274732d395/gcc%2Frust%2Fbackend%2Fcscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59a8fa1a80c3b2c6520c627a6bf200274732d395/gcc%2Frust%2Fbackend%2Fcscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Fcscope.h?ref=59a8fa1a80c3b2c6520c627a6bf200274732d395", "patch": "@@ -1,160 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#pragma once\n-\n-#include \"rust-system.h\"\n-#include \"rust-backend.h\"\n-#include \"scope.h\"\n-\n-namespace Rust {\n-namespace Compile {\n-\n-class Scope\n-{\n-public:\n-  Scope (Backend *backend) : backend (backend) {}\n-\n-  ~Scope () {}\n-\n-  void Push ()\n-  {\n-    fndecls.Push ();\n-    vars.Push ();\n-    types.Push ();\n-    structDecls.Push ();\n-  }\n-\n-  void Pop ()\n-  {\n-    fndecls.Pop ();\n-    vars.Pop ();\n-    types.Pop ();\n-    structDecls.Pop ();\n-  }\n-\n-  void PushCurrentFunction (std::string name, Bfunction *fn, Btype *retType,\n-\t\t\t    Bvariable *retDecl)\n-  {\n-    fns.push_back (fn);\n-    fnRetType.push_back (retType);\n-    fnRetDecl.push_back (retDecl);\n-  }\n-\n-  Bfunction *PopCurrentFunction ()\n-  {\n-    auto ret = fns.back ();\n-    fns.pop_back ();\n-    fnRetType.pop_back ();\n-    fnRetDecl.pop_back ();\n-    return ret;\n-  }\n-\n-  Bfunction *GetCurrentFndecl () { return fns.back (); }\n-\n-  Btype *GetCurrentFnRetType () { return fnRetType.back (); }\n-\n-  Bvariable *GetCurrentFnRetDecl () { return fnRetDecl.back (); }\n-\n-  Btype *GetFnRetType (Bfunction *fn)\n-  {\n-    auto it = fnRetTypeMapping.find (fn);\n-    if (it == fnRetTypeMapping.end ())\n-      {\n-\treturn NULL;\n-      }\n-    return it->second;\n-  }\n-\n-  void PushBlock (Bblock *block)\n-  {\n-    blocks.push_back (block);\n-    std::vector<Bstatement *> empty;\n-    context.push_back (empty);\n-  }\n-\n-  Bblock *PopBlock ()\n-  {\n-    auto ret = blocks.back ();\n-    blocks.pop_back ();\n-\n-    auto stmts = context.back ();\n-    context.pop_back ();\n-\n-    backend->block_add_statements (ret, stmts);\n-\n-    return ret;\n-  }\n-\n-  Bblock *CurBlock () { return blocks.back (); }\n-\n-  void AddStatement (Bstatement *stmt) { context.back ().push_back (stmt); }\n-\n-  void InsertStructDecl (std::string name, AST::StructStruct *decl)\n-  {\n-    structDecls.Insert (name, decl);\n-  }\n-\n-  bool LookupStructDecl (std::string name, AST::StructStruct **decl)\n-  {\n-    return structDecls.Lookup (name, decl);\n-  }\n-\n-  void InsertFunction (std::string name, Bfunction *fn, Btype *retType)\n-  {\n-    fndecls.Insert (name, fn);\n-    fnRetTypeMapping[fn] = retType;\n-  }\n-\n-  bool LookupFunction (std::string name, Bfunction **fn)\n-  {\n-    return fndecls.Lookup (name, fn);\n-  }\n-\n-  void InsertType (std::string name, Btype *type) { types.Insert (name, type); }\n-\n-  bool LookupType (std::string name, Btype **type)\n-  {\n-    return types.Lookup (name, type);\n-  }\n-\n-  void InsertVar (std::string name, Bvariable *var) { vars.Insert (name, var); }\n-\n-  bool LookupVar (std::string name, Bvariable **var)\n-  {\n-    return vars.Lookup (name, var);\n-  }\n-\n-private:\n-  Backend *backend;\n-\n-  ::std::vector<Bfunction *> fns;\n-  ::std::vector<Bblock *> blocks;\n-  ::std::vector< ::std::vector<Bstatement *> > context;\n-  ::std::vector< ::Btype *> fnRetType;\n-  ::std::vector< ::Bvariable *> fnRetDecl;\n-  ::std::map<Bfunction *, Btype *> fnRetTypeMapping;\n-\n-  Analysis::Scope<Bfunction *> fndecls;\n-  Analysis::Scope<Bvariable *> vars;\n-  Analysis::Scope<Btype *> types;\n-  Analysis::Scope<AST::StructStruct *> structDecls;\n-};\n-\n-} // namespace Compile\n-} // namespace Rust"}, {"sha": "b823d299260c83792481bb6e4c957156350bcd1e", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -99,6 +99,8 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::CallExpr &expr);\n \n+  void visit (HIR::MethodCallExpr &expr);\n+\n   void visit (HIR::IdentifierExpr &expr)\n   {\n     // need to look up the reference for this identifier"}, {"sha": "1ea0c9fe85848f181d6e4a4283c48e42e714aff8", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -61,6 +61,22 @@ class CompileFnParam : public HIRCompileBase\n   ::Bvariable *translated;\n };\n \n+class CompileSelfParam : public HIRCompileBase\n+{\n+public:\n+  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n+\t\t\t     HIR::SelfParam &self, Btype *decl_type,\n+\t\t\t     Location locus)\n+  {\n+    if (!self.get_is_mut ())\n+      decl_type = ctx->get_backend ()->immutable_type (decl_type);\n+\n+    return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n+\t\t\t\t\t\t    false /* address_taken */,\n+\t\t\t\t\t\t    locus);\n+  }\n+};\n+\n } // namespace Compile\n } // namespace Rust\n "}, {"sha": "6d180c87891a2a9451b6b3a2008fc130ef1648b1", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 215, "deletions": 17, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -32,10 +32,10 @@ namespace Compile {\n class CompileInherentImplItem : public HIRCompileBase\n {\n public:\n-  static void Compile (HIR::Type *base, HIR::InherentImplItem *item,\n+  static void Compile (TyTy::TyBase *self, HIR::InherentImplItem *item,\n \t\t       Context *ctx, bool compile_fns)\n   {\n-    CompileInherentImplItem compiler (base, ctx, compile_fns);\n+    CompileInherentImplItem compiler (self, ctx, compile_fns);\n     item->accept_vis (compiler);\n   }\n \n@@ -50,7 +50,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n     Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n-    std::string ident = base->as_string () + \"::\" + constant.get_identifier ();\n+    std::string ident = self->as_string () + \"::\" + constant.get_identifier ();\n     Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n@@ -78,7 +78,8 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n       {\n-\trust_fatal_error (function.locus, \"failed to lookup function type\");\n+\trust_fatal_error (function.get_locus (),\n+\t\t\t  \"failed to lookup function type\");\n \treturn;\n       }\n \n@@ -93,23 +94,15 @@ class CompileInherentImplItem : public HIRCompileBase\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n-    bool is_main_fn = function.function_name.compare (\"main\") == 0;\n-\n     std::string fn_identifier\n-      = base->as_string () + \"::\" + function.function_name;\n+      = self->as_string () + \"::\" + function.function_name;\n \n     // if its the main fn or pub visibility mark its as DECL_PUBLIC\n     // please see https://github.com/Rust-GCC/gccrs/pull/137\n-    if (is_main_fn || function.has_visibility ())\n+    if (function.has_visibility ())\n       flags |= Backend::function_is_visible;\n \n     std::string asm_name = fn_identifier;\n-    if (!is_main_fn)\n-      {\n-\t// FIXME need name mangling\n-\tasm_name = \"__\" + function.function_name;\n-      }\n-\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n@@ -229,12 +222,217 @@ class CompileInherentImplItem : public HIRCompileBase\n     ctx->push_function (fndecl);\n   }\n \n+  void visit (HIR::Method &method)\n+  {\n+    if (!compile_fns)\n+      return;\n+\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (method.get_mappings ().get_hirid (),\n+\t\t\t\t   &lookup))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  return;\n+      }\n+\n+    TyTy::TyBase *fntype_tyty;\n+    if (!ctx->get_tyctx ()->lookup_type (method.get_mappings ().get_hirid (),\n+\t\t\t\t\t &fntype_tyty))\n+      {\n+\trust_fatal_error (method.get_locus (),\n+\t\t\t  \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (method.get_locus (), \"invalid TyTy for function item\");\n+\treturn;\n+      }\n+\n+    TyTy::FnType *fntype = (TyTy::FnType *) fntype_tyty;\n+    // convert to the actual function type\n+    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+\n+    unsigned int flags = 0;\n+    std::string fn_identifier\n+      = self->as_string () + \"::\" + method.get_method_name ();\n+\n+    // if its the main fn or pub visibility mark its as DECL_PUBLIC\n+    // please see https://github.com/Rust-GCC/gccrs/pull/137\n+    if (method.has_visibility ())\n+      flags |= Backend::function_is_visible;\n+\n+    std::string asm_name = fn_identifier;\n+    Bfunction *fndecl\n+      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n+\t\t\t\t       asm_name, flags, method.get_locus ());\n+    ctx->insert_function_decl (method.get_mappings ().get_hirid (), fndecl);\n+\n+    // setup the params\n+    TyTy::TyBase *tyret = fntype->return_type ();\n+    std::vector<Bvariable *> param_vars;\n+\n+    // insert self\n+    TyTy::TyBase *self_tyty_lookup = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  method.get_self_param ().get_mappings ().get_hirid (),\n+\t  &self_tyty_lookup))\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to lookup self param type\");\n+\treturn;\n+      }\n+\n+    Btype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+    if (self_type == nullptr)\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to compile self param type\");\n+\treturn;\n+      }\n+\n+    Bvariable *compiled_self_param\n+      = CompileSelfParam::compile (ctx, fndecl, method.get_self_param (),\n+\t\t\t\t   self_type,\n+\t\t\t\t   method.get_self_param ().get_locus ());\n+    if (compiled_self_param == nullptr)\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to compile self param variable\");\n+\treturn;\n+      }\n+\n+    param_vars.push_back (compiled_self_param);\n+    ctx->insert_var_decl (method.get_self_param ().get_mappings ().get_hirid (),\n+\t\t\t  compiled_self_param);\n+\n+    // offset from + 1 for the TyTy::FnType being used\n+    size_t i = 1;\n+    for (auto referenced_param : method.get_function_params ())\n+      {\n+\tauto tyty_param = fntype->param_at (i);\n+\tauto param_tyty = tyty_param.second;\n+\n+\tauto compiled_param_type\n+\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n+\tif (compiled_param_type == nullptr)\n+\t  {\n+\t    rust_error_at (referenced_param.get_locus (),\n+\t\t\t   \"failed to compile parameter type\");\n+\t    return;\n+\t  }\n+\n+\tLocation param_locus\n+\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n+\tBvariable *compiled_param_var\n+\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t     compiled_param_type, param_locus);\n+\tif (compiled_param_var == nullptr)\n+\t  {\n+\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n+\t    return;\n+\t  }\n+\n+\tparam_vars.push_back (compiled_param_var);\n+\n+\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t      compiled_param_var);\n+\ti++;\n+      }\n+\n+    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+      {\n+\trust_fatal_error (method.get_locus (),\n+\t\t\t  \"failed to setup parameter variables\");\n+\treturn;\n+      }\n+\n+    // lookup locals\n+    auto block_expr = method.get_function_body ().get ();\n+    auto body_mappings = block_expr->get_mappings ();\n+\n+    Resolver::Rib *rib = nullptr;\n+    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n+\t\t\t\t\t      &rib))\n+      {\n+\trust_fatal_error (method.get_locus (),\n+\t\t\t  \"failed to setup locals per block\");\n+\treturn;\n+      }\n+\n+    std::vector<Bvariable *> locals;\n+    rib->iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n+      Resolver::Definition d;\n+      bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      locals.push_back (compiled);\n+\n+      return true;\n+    });\n+\n+    bool toplevel_item\n+      = method.get_mappings ().get_local_defid () != UNKNOWN_LOCAL_DEFID;\n+    Bblock *enclosing_scope\n+      = toplevel_item ? NULL : ctx->peek_enclosing_scope ();\n+\n+    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n+    Location start_location = function_body->get_locus ();\n+    Location end_location = function_body->get_closing_locus ();\n+\n+    Bblock *code_block\n+      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t    start_location, end_location);\n+    ctx->push_block (code_block);\n+\n+    Bvariable *return_address = nullptr;\n+    if (method.has_function_return_type ())\n+      {\n+\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+\tbool address_is_taken = false;\n+\tBstatement *ret_var_stmt = nullptr;\n+\n+\treturn_address = ctx->get_backend ()->temporary_variable (\n+\t  fndecl, code_block, return_type, NULL, address_is_taken,\n+\t  method.get_locus (), &ret_var_stmt);\n+\n+\tctx->add_statement (ret_var_stmt);\n+      }\n+\n+    ctx->push_fn (fndecl, return_address);\n+\n+    compile_function_body (fndecl, method.get_function_body (),\n+\t\t\t   method.has_function_return_type ());\n+\n+    ctx->pop_block ();\n+    auto body = ctx->get_backend ()->block_statement (code_block);\n+    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n+      {\n+\trust_error_at (method.get_locus (), \"failed to set body to function\");\n+\treturn;\n+      }\n+\n+    ctx->pop_fn ();\n+\n+    ctx->push_function (fndecl);\n+  }\n+\n private:\n-  CompileInherentImplItem (HIR::Type *base, Context *ctx, bool compile_fns)\n-    : HIRCompileBase (ctx), base (base), compile_fns (compile_fns)\n+  CompileInherentImplItem (TyTy::TyBase *self, Context *ctx, bool compile_fns)\n+    : HIRCompileBase (ctx), self (self), compile_fns (compile_fns)\n   {}\n \n-  HIR::Type *base;\n+  TyTy::TyBase *self;\n   bool compile_fns;\n };\n "}, {"sha": "7f93af9fefbc475291cff68253570bee0c835d8d", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -282,9 +282,18 @@ class CompileItem : public HIRCompileBase\n \n   void visit (HIR::InherentImpl &impl_block)\n   {\n+    TyTy::TyBase *self_lookup = nullptr;\n+    if (!ctx->get_tyctx ()->lookup_type (\n+\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n+      {\n+\trust_error_at (impl_block.get_locus (),\n+\t\t       \"failed to resolve type of impl\");\n+\treturn;\n+      }\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (impl_block.get_type ().get (),\n-\t\t\t\t\timpl_item.get (), ctx, compile_fns);\n+      CompileInherentImplItem::Compile (self_lookup, impl_item.get (), ctx,\n+\t\t\t\t\tcompile_fns);\n   }\n \n private:"}, {"sha": "0b83c720da17bd9513890172e620bdd467eb26ef", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -95,6 +95,83 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     }\n }\n \n+void\n+CompileExpr::visit (HIR::MethodCallExpr &expr)\n+{\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  if (!ctx->get_resolver ()->lookup_resolved_name (\n+\texpr.get_mappings ().get_nodeid (), &resolved_node_id))\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to lookup resolved MethodCall\");\n+      return;\n+    }\n+\n+  // reverse lookup\n+  HirId ref;\n+  if (!ctx->get_mappings ()->lookup_node_to_hir (\n+\texpr.get_mappings ().get_crate_num (), resolved_node_id, &ref))\n+    {\n+      rust_fatal_error (expr.get_locus (), \"reverse lookup failure\");\n+      return;\n+    }\n+\n+  // lookup compiled functions\n+  Bfunction *fn = nullptr;\n+  if (!ctx->lookup_function_decl (ref, &fn))\n+    {\n+      // this might fail because its a forward decl so we can attempt to\n+      // resolve it now\n+      HIR::InherentImplItem *resolved_item\n+\t= ctx->get_mappings ()->lookup_hir_implitem (\n+\t  expr.get_mappings ().get_crate_num (), ref);\n+      if (resolved_item == nullptr)\n+\t{\n+\t  rust_error_at (expr.get_locus (), \"failed to lookup forward decl\");\n+\t  return;\n+\t}\n+\n+      TyTy::TyBase *self_type = nullptr;\n+      if (!ctx->get_tyctx ()->lookup_type (\n+\t    expr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n+\t{\n+\t  rust_error_at (expr.get_locus (),\n+\t\t\t \"failed to resolve type for self param\");\n+\t  return;\n+\t}\n+\n+      CompileInherentImplItem::Compile (self_type, resolved_item, ctx, true);\n+      if (!ctx->lookup_function_decl (ref, &fn))\n+\t{\n+\t  rust_error_at (expr.get_locus (), \"forward decl was not compiled\");\n+\t  return;\n+\t}\n+    }\n+\n+  Bexpression *fn_expr\n+    = ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+\n+  std::vector<Bexpression *> args;\n+\n+  // method receiver\n+  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+  rust_assert (self != nullptr);\n+  args.push_back (self);\n+\n+  // normal args\n+  expr.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+    Bexpression *compiled_expr = CompileExpr::Compile (p, ctx);\n+    rust_assert (compiled_expr != nullptr);\n+    args.push_back (compiled_expr);\n+    return true;\n+  });\n+\n+  auto fncontext = ctx->peek_fn ();\n+  translated\n+    = ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t    nullptr, expr.get_locus ());\n+}\n+\n // rust-compile-block.h\n \n void"}, {"sha": "cd1863f8cdb772988e52ca8c464e1548f33cddc2", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -238,6 +238,35 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t   expr.get_locus ());\n   }\n \n+  void visit (AST::MethodCallExpr &expr)\n+  {\n+    std::vector<HIR::Attribute> outer_attribs;\n+\n+    HIR::PathExprSegment method_path (\n+      expr.get_method_name ().get_ident_segment ().as_string (),\n+      expr.get_method_name ().get_locus ());\n+\n+    HIR::Expr *receiver\n+      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+    std::vector<std::unique_ptr<HIR::Expr> > params;\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      auto trans = ASTLoweringExpr::translate (p);\n+      params.push_back (std::unique_ptr<HIR::Expr> (trans));\n+      return true;\n+    });\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (\n+      crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n+      mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::MethodCallExpr (mapping, std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t\t method_path, std::move (params),\n+\t\t\t\t std::move (outer_attribs), expr.get_locus ());\n+  }\n+\n   void visit (AST::AssignmentExpr &expr)\n   {\n     HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());"}, {"sha": "de4d55d19c89fffabe0c4ce03c213b5c8549d608", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -40,6 +40,21 @@ class ASTLowerImplItem : public ASTLoweringBase\n     return resolver.translated;\n   }\n \n+  HIR::SelfParam lower_self (AST::SelfParam &self)\n+  {\n+    HIR::Type *type = self.has_type ()\n+\t\t\t? ASTLoweringType::translate (self.get_type ().get ())\n+\t\t\t: nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, self.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t   self.get_is_mut (), self.get_locus ());\n+  }\n+\n   void visit (AST::ConstantItem &constant)\n   {\n     std::vector<HIR::Attribute> outer_attrs;\n@@ -143,6 +158,91 @@ class ASTLowerImplItem : public ASTLoweringBase\n     translated = fn;\n   }\n \n+  void visit (AST::Method &method)\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    std::vector<HIR::Attribute> outer_attrs;\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers (\n+      HIR::FunctionQualifiers::AsyncConstStatus::NONE, false);\n+    HIR::Visibility vis = HIR::Visibility::create_public ();\n+\n+    // need\n+    Identifier method_name = method.get_method_name ();\n+    Location locus = method.get_locus ();\n+\n+    HIR::SelfParam self_param = lower_self (method.get_self_param ());\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = method.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (method.get_return_type ().get ()))\n+\t\t\t\t  : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : method.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> method_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (method.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, method.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+    auto mth\n+      = new HIR::Method (mapping, std::move (method_name),\n+\t\t\t std::move (qualifiers), std::move (generic_params),\n+\t\t\t std::move (self_param), std::move (function_params),\n+\t\t\t std::move (return_type), std::move (where_clause),\n+\t\t\t std::move (method_body), std::move (vis),\n+\t\t\t std::move (outer_attrs), locus);\n+\n+    mappings->insert_hir_implitem (mapping.get_crate_num (),\n+\t\t\t\t   mapping.get_hirid (), mth);\n+    mappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t       method.get_locus ());\n+\n+    // insert mappings for self\n+    mappings->insert_hir_self_param (crate_num,\n+\t\t\t\t     self_param.get_mappings ().get_hirid (),\n+\t\t\t\t     &self_param);\n+    mappings->insert_location (crate_num,\n+\t\t\t       self_param.get_mappings ().get_hirid (),\n+\t\t\t       self_param.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : mth->get_function_params ())\n+      {\n+\tmappings->insert_hir_param (mapping.get_crate_num (),\n+\t\t\t\t    param.get_mappings ().get_hirid (), &param);\n+\tmappings->insert_location (crate_num, mapping.get_hirid (),\n+\t\t\t\t   param.get_locus ());\n+      }\n+\n+    translated = mth;\n+  }\n+\n private:\n   ASTLowerImplItem () : translated (nullptr) {}\n "}, {"sha": "d4af3c215653480f73245dfd726323f3a323d5f3", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -2177,9 +2177,9 @@ class CallExpr : public ExprWithoutBlock\n \n   void iterate_params (std::function<bool (Expr *)> cb)\n   {\n-    for (auto it = params.begin (); it != params.end (); it++)\n+    for (auto &param : params)\n       {\n-\tif (!cb (it->get ()))\n+\tif (!cb (param.get ()))\n \t  return;\n       }\n   }\n@@ -2261,6 +2261,27 @@ class MethodCallExpr : public ExprWithoutBlock\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::unique_ptr<Expr> &get_receiver () { return receiver; }\n+\n+  PathExprSegment get_method_name () const { return method_name; };\n+\n+  std::vector<std::unique_ptr<Expr> > &get_params () { return params; }\n+  const std::vector<std::unique_ptr<Expr> > &get_params () const\n+  {\n+    return params;\n+  }\n+\n+  size_t num_params () const { return params.size (); }\n+\n+  void iterate_params (std::function<bool (Expr *)> cb)\n+  {\n+    for (auto &param : params)\n+      {\n+\tif (!cb (param.get ()))\n+\t  return;\n+      }\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "e4fa39a0f2a7962f393d10901a9b24f678d643cc", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -676,7 +676,7 @@ Method::as_string () const\n     }\n \n   str += \"\\n Block expr (body): \\n  \";\n-  str += expr->as_string ();\n+  str += function_body->as_string ();\n \n   return str;\n }"}, {"sha": "4ab23e155f5598bb3a3a7fc4b59a98f6f2d4c638", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 85, "deletions": 14, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -297,10 +297,13 @@ struct SelfParam\n \n   Location locus;\n \n+  Analysis::NodeMapping mappings;\n+\n   // Unrestricted constructor used for error state\n-  SelfParam (Lifetime lifetime, bool has_ref, bool is_mut, Type *type)\n+  SelfParam (Analysis::NodeMapping mappings, Lifetime lifetime, bool has_ref,\n+\t     bool is_mut, Type *type)\n     : has_ref (has_ref), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      type (type)\n+      type (type), mappings (mappings)\n   {}\n   // this is ok as no outside classes can ever call this\n \n@@ -319,21 +322,23 @@ struct SelfParam\n   }\n \n   // Type-based self parameter (not ref, no lifetime)\n-  SelfParam (std::unique_ptr<Type> type, bool is_mut, Location locus)\n+  SelfParam (Analysis::NodeMapping mappings, std::unique_ptr<Type> type,\n+\t     bool is_mut, Location locus)\n     : has_ref (false), is_mut (is_mut), lifetime (Lifetime::error ()),\n-      type (std::move (type)), locus (locus)\n+      type (std::move (type)), locus (locus), mappings (mappings)\n   {}\n \n   // Lifetime-based self parameter (is ref, no type)\n-  SelfParam (Lifetime lifetime, bool is_mut, Location locus)\n+  SelfParam (Analysis::NodeMapping mappings, Lifetime lifetime, bool is_mut,\n+\t     Location locus)\n     : has_ref (true), is_mut (is_mut), lifetime (std::move (lifetime)),\n-      locus (locus)\n+      locus (locus), mappings (mappings)\n   {}\n \n   // Copy constructor requires clone\n   SelfParam (SelfParam const &other)\n     : has_ref (other.has_ref), is_mut (other.is_mut), lifetime (other.lifetime),\n-      locus (other.locus)\n+      locus (other.locus), mappings (other.mappings)\n   {\n     if (other.type != nullptr)\n       type = other.type->clone_type ();\n@@ -348,6 +353,7 @@ struct SelfParam\n     has_ref = other.has_ref;\n     lifetime = other.lifetime;\n     locus = other.locus;\n+    mappings = other.mappings;\n \n     return *this;\n   }\n@@ -359,6 +365,18 @@ struct SelfParam\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  bool get_has_ref () const { return has_ref; };\n+  bool get_is_mut () const { return is_mut; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n+\n+  Analysis::NodeMapping get_mappings () { return mappings; }\n };\n \n // Qualifiers for function, i.e. const, unsafe, extern etc.\n@@ -542,6 +560,8 @@ struct Visibility\n // A method (function belonging to a type)\n class Method : public InherentImplItem, public TraitImplItem\n {\n+  Analysis::NodeMapping mappings;\n+\n   // moved from impl items for consistency\n   std::vector<Attribute> outer_attrs;\n   Visibility vis;\n@@ -566,9 +586,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   // bool has_where_clause;\n   WhereClause where_clause;\n \n-  std::unique_ptr<BlockExpr> expr;\n-\n-  Analysis::NodeMapping mappings;\n+  std::unique_ptr<BlockExpr> function_body;\n \n   Location locus;\n \n@@ -603,8 +621,8 @@ class Method : public InherentImplItem, public TraitImplItem\n       self_param (std::move (self_param)),\n       function_params (std::move (function_params)),\n       return_type (std::move (return_type)),\n-      where_clause (std::move (where_clause)), expr (std::move (function_body)),\n-      locus (locus)\n+      where_clause (std::move (where_clause)),\n+      function_body (std::move (function_body)), locus (locus)\n   {}\n \n   // TODO: add constructor with less fields\n@@ -616,7 +634,8 @@ class Method : public InherentImplItem, public TraitImplItem\n       method_name (other.method_name), self_param (other.self_param),\n       function_params (other.function_params),\n       return_type (other.return_type->clone_type ()),\n-      where_clause (other.where_clause), expr (other.expr->clone_block_expr ()),\n+      where_clause (other.where_clause),\n+      function_body (other.function_body->clone_block_expr ()),\n       locus (other.locus)\n   {\n     generic_params.reserve (other.generic_params.size ());\n@@ -636,7 +655,7 @@ class Method : public InherentImplItem, public TraitImplItem\n     function_params = other.function_params;\n     return_type = other.return_type->clone_type ();\n     where_clause = other.where_clause;\n-    expr = other.expr->clone_block_expr ();\n+    function_body = other.function_body->clone_block_expr ();\n     locus = other.locus;\n \n     generic_params.reserve (other.generic_params.size ());\n@@ -661,6 +680,58 @@ class Method : public InherentImplItem, public TraitImplItem\n     return get_mappings ();\n   };\n \n+  // Returns whether function has return type - if not, it is void.\n+  bool has_function_return_type () const { return return_type != nullptr; }\n+\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n+  const std::vector<FunctionParam> &get_function_params () const\n+  {\n+    return function_params;\n+  }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+  const std::vector<std::unique_ptr<GenericParam> > &get_generic_params () const\n+  {\n+    return generic_params;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<BlockExpr> &get_definition ()\n+  {\n+    rust_assert (function_body != nullptr);\n+    return function_body;\n+  }\n+\n+  SelfParam &get_self_param () { return self_param; }\n+  const SelfParam &get_self_param () const { return self_param; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  WhereClause &get_where_clause ()\n+  {\n+    rust_assert (has_where_clause ());\n+    return where_clause;\n+  }\n+\n+  Identifier get_method_name () const { return method_name; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::unique_ptr<BlockExpr> &get_function_body () { return function_body; }\n+  const std::unique_ptr<BlockExpr> &get_function_body () const\n+  {\n+    return function_body;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */"}, {"sha": "9a772f0d8599a168aa284550cbcad950c1e37d27", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -228,6 +228,8 @@ class PathExprSegment\n   std::string as_string () const;\n \n   Location get_locus () const { return locus; }\n+\n+  PathIdentSegment get_segment () const { return segment_name; }\n };\n \n // HIR node representing a pattern that involves a \"path\" - abstract base class"}, {"sha": "d563f934d9d672321105214bb40c0d1da1d6671a", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -91,6 +91,15 @@ class ResolveExpr : public ResolverBase\n     });\n   }\n \n+  void visit (AST::MethodCallExpr &expr)\n+  {\n+    ResolveExpr::go (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+    expr.iterate_params ([&] (AST::Expr *p) mutable -> bool {\n+      ResolveExpr::go (p, expr.get_node_id ());\n+      return true;\n+    });\n+  }\n+\n   void visit (AST::AssignmentExpr &expr)\n   {\n     ResolveExpr::go (expr.get_left_expr ().get (), expr.get_node_id ());"}, {"sha": "8b6227e73ca5616500183bef8769c6e58d8bc44e", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -129,6 +129,58 @@ class ResolveItem : public ResolverBase\n     resolver->get_type_scope ().peek ()->clear_name (\"Self\", resolved_node);\n   }\n \n+  void visit (AST::Method &method)\n+  {\n+    if (method.has_return_type ())\n+      ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n+\n+    NodeId scope_node_id = method.get_node_id ();\n+    resolver->get_name_scope ().push (scope_node_id);\n+    resolver->get_type_scope ().push (scope_node_id);\n+    resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+    resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+\n+    // self turns into self: Self as a function param\n+    AST::SelfParam &self_param = method.get_self_param ();\n+    AST::IdentifierPattern self_pattern (\n+      self_param.get_node_id (), \"self\", self_param.get_locus (),\n+      self_param.get_has_ref (), self_param.get_is_mut (),\n+      std::unique_ptr<AST::Pattern> (nullptr));\n+\n+    std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+    segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n+      new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n+\n+    AST::TypePath self_type_path (std::move (segments),\n+\t\t\t\t  self_param.get_locus ());\n+\n+    ResolveType::go (&self_type_path, self_param.get_node_id ());\n+    PatternDeclaration::go (&self_pattern, self_param.get_node_id ());\n+\n+    resolver->mark_assignment_to_decl (self_pattern.get_node_id (),\n+\t\t\t\t       self_pattern.get_node_id ());\n+\n+    // we make a new scope so the names of parameters are resolved and shadowed\n+    // correctly\n+    for (auto &param : method.get_function_params ())\n+      {\n+\tResolveType::go (param.get_type ().get (), param.get_node_id ());\n+\tPatternDeclaration::go (param.get_pattern ().get (),\n+\t\t\t\tparam.get_node_id ());\n+\n+\t// the mutability checker needs to verify for immutable decls the number\n+\t// of assignments are <1. This marks an implicit assignment\n+\tresolver->mark_assignment_to_decl (param.get_pattern ()->get_node_id (),\n+\t\t\t\t\t   param.get_node_id ());\n+      }\n+\n+    // resolve the function body\n+    ResolveExpr::go (method.get_definition ().get (), method.get_node_id ());\n+\n+    resolver->get_name_scope ().pop ();\n+    resolver->get_type_scope ().pop ();\n+  }\n+\n private:\n   ResolveItem () : ResolverBase (UNKNOWN_NODEID) {}\n };"}, {"sha": "9a6c76fc85e81184071c85cdb36d86d28f66d4d5", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_METHOD_RESOLVE_H\n+#define RUST_HIR_METHOD_RESOLVE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class MethodResolution : public TypeCheckBase\n+{\n+public:\n+  static std::vector<HIR::Method *> Probe (TyTy::TyBase *receiver,\n+\t\t\t\t\t   HIR::PathExprSegment method_name)\n+  {\n+    MethodResolution probe (receiver, method_name);\n+\n+    // lookup impl items for this crate and find all methods that can resolve to\n+    // this receiver\n+    probe.mappings->iterate_impl_items (\n+      [&] (HirId id, HIR::InherentImplItem *item) mutable -> bool {\n+\titem->accept_vis (probe);\n+\treturn true;\n+      });\n+\n+    return probe.probed;\n+  }\n+\n+  void visit (HIR::Method &method)\n+  {\n+    TyTy::TyBase *self_lookup = nullptr;\n+    if (!context->lookup_type (\n+\t  method.get_self_param ().get_mappings ().get_hirid (), &self_lookup))\n+      {\n+\trust_error_at (method.get_self_param ().get_locus (),\n+\t\t       \"failed to lookup lookup self type in MethodProbe\");\n+\treturn;\n+      }\n+\n+    // are the names the same\n+    HIR::PathIdentSegment seg = method_name.get_segment ();\n+    if (seg.as_string ().compare (method.get_method_name ()) != 0)\n+      {\n+\t// if the method name does not match then this is not a valid match\n+\treturn;\n+      }\n+\n+    // FIXME this can be simplified with\n+    // https://github.com/Rust-GCC/gccrs/issues/187\n+    auto combined = receiver->combine (self_lookup);\n+    if (combined == nullptr)\n+      {\n+\t// incompatible self argument then this is not a valid method for this\n+\t// receiver\n+\treturn;\n+      }\n+    delete combined;\n+\n+    probed.push_back (&method);\n+  }\n+\n+private:\n+  MethodResolution (TyTy::TyBase *receiver, HIR::PathExprSegment method_name)\n+    : TypeCheckBase (), receiver (receiver), method_name (method_name)\n+  {}\n+\n+  TyTy::TyBase *receiver;\n+  HIR::PathExprSegment method_name;\n+\n+  std::vector<HIR::Method *> probed;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_METHOD_RESOLVE_H"}, {"sha": "e6cca19afc188629fa5366891fe7d2ec9d4b8a18", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n+#include \"rust-hir-method-resolve.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -37,7 +38,10 @@ class TypeCheckExpr : public TypeCheckBase\n     expr->accept_vis (resolver);\n \n     if (resolver.infered == nullptr)\n-      return new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n+      {\n+\trust_error_at (expr->get_locus_slow (), \"failed to resolve expression\");\n+\treturn new TyTy::ErrorType (expr->get_mappings ().get_hirid ());\n+      }\n \n     auto ref = expr->get_mappings ().get_hirid ();\n     resolver.infered->set_ref (ref);\n@@ -196,9 +200,8 @@ class TypeCheckExpr : public TypeCheckBase\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (ref, &lookup))\n       {\n-\t// FIXME we need to be able to lookup the location info for the\n-\t// reference here\n-\trust_error_at (expr.get_locus (), \"consider giving this a type: %s\",\n+\trust_error_at (mappings->lookup_location (ref),\n+\t\t       \"failed to lookup type for CallExpr: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -213,6 +216,65 @@ class TypeCheckExpr : public TypeCheckBase\n     infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n+  void visit (HIR::MethodCallExpr &expr)\n+  {\n+    auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n+    if (receiver_tyty == nullptr)\n+      {\n+\trust_error_at (expr.get_receiver ()->get_locus_slow (),\n+\t\t       \"failed to resolve receiver in MethodCallExpr\");\n+\treturn;\n+      }\n+\n+    // https://doc.rust-lang.org/reference/expressions/method-call-expr.html\n+    // method resolution is complex in rust once we start handling generics and\n+    // traits. For now we only support looking up the valid name in impl blocks\n+    // which is simple. There will need to be adjustments to ensure we can turn\n+    // the receiver into borrowed references etc\n+\n+    auto probes\n+      = MethodResolution::Probe (receiver_tyty, expr.get_method_name ());\n+    if (probes.size () == 0)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to resolve the PathExprSegment to any Method\");\n+\treturn;\n+      }\n+    else if (probes.size () > 1)\n+      {\n+\trust_error_at (\n+\t  expr.get_locus (),\n+\t  \"Generics and Traits are not implemented yet for MethodCall\");\n+\treturn;\n+      }\n+\n+    auto resolved_method = probes.at (0);\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (resolved_method->get_mappings ().get_hirid (),\n+\t\t\t       &lookup))\n+      {\n+\trust_error_at (resolved_method->get_locus (),\n+\t\t       \"failed to lookup type for CallExpr: %s\",\n+\t\t       expr.as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    infered = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to lookup type to MethodCallExpr\");\n+\treturn;\n+      }\n+\n+    infered->set_ref (expr.get_mappings ().get_hirid ());\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (\n+      expr.get_mappings ().get_nodeid (),\n+      resolved_method->get_mappings ().get_nodeid ());\n+  }\n+\n   void visit (HIR::AssignmentExpr &expr)\n   {\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n@@ -313,7 +375,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!context->lookup_type (ref, &lookup))\n       {\n \trust_error_at (mappings->lookup_location (ref),\n-\t\t       \"consider giving this a type: %s\",\n+\t\t       \"Failed to resolve IdentifierExpr type: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;\n       }\n@@ -703,7 +765,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (!is_valid_type)\n       {\n \trust_error_at (expr.get_locus (),\n-\t\t       \"expected ADT or Tuple Type got: [%s]\",\n+\t\t       \"expected algebraic data type got: [%s]\",\n \t\t       struct_base->as_string ().c_str ());\n \treturn;\n       }\n@@ -747,7 +809,11 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    context->lookup_type (ref, &infered);\n+    if (!context->lookup_type (ref, &infered))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to resolve PathInExpression type\");\n+      }\n   }\n \n private:\n@@ -799,6 +865,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t   && (((TyTy::InferType *) type)->get_infer_kind ()\n \t\t       == TyTy::InferType::INTEGRAL));\n       }\n+    gcc_unreachable ();\n   }\n \n   TyTy::TyBase *infered;"}, {"sha": "c8d161a30c0c803fb7579959fe7cc32e6f257179", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -31,9 +31,9 @@ namespace Resolver {\n class TypeCheckTopLevelImplItem : public TypeCheckBase\n {\n public:\n-  static void Resolve (HIR::InherentImplItem *item)\n+  static void Resolve (HIR::InherentImplItem *item, TyTy::TyBase *self)\n   {\n-    TypeCheckTopLevelImplItem resolver;\n+    TypeCheckTopLevelImplItem resolver (self);\n     item->accept_vis (resolver);\n   }\n \n@@ -81,8 +81,62 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n+  void visit (HIR::Method &method)\n+  {\n+    TyTy::TyBase *ret_type = nullptr;\n+    if (!method.has_function_return_type ())\n+      ret_type = new TyTy::UnitType (method.get_mappings ().get_hirid ());\n+    else\n+      {\n+\tauto resolved\n+\t  = TypeCheckType::Resolve (method.get_return_type ().get ());\n+\tif (resolved == nullptr)\n+\t  {\n+\t    rust_error_at (method.get_locus (),\n+\t\t\t   \"failed to resolve return type\");\n+\t    return;\n+\t  }\n+\n+\tret_type = resolved->clone ();\n+\tret_type->set_ref (\n+\t  method.get_return_type ()->get_mappings ().get_hirid ());\n+      }\n+\n+    // hold all the params to the fndef\n+    std::vector<std::pair<HIR::Pattern *, TyTy::TyBase *> > params;\n+\n+    // add the self param at the front\n+    HIR::SelfParam &self_param = method.get_self_param ();\n+    HIR::IdentifierPattern *self_pattern\n+      = new HIR::IdentifierPattern (\"self\", self_param.get_locus (),\n+\t\t\t\t    self_param.get_has_ref (),\n+\t\t\t\t    self_param.get_is_mut (),\n+\t\t\t\t    std::unique_ptr<HIR::Pattern> (nullptr));\n+    context->insert_type (self_param.get_mappings (), self->clone ());\n+    params.push_back (\n+      std::pair<HIR::Pattern *, TyTy::TyBase *> (self_pattern, self->clone ()));\n+\n+    for (auto &param : method.get_function_params ())\n+      {\n+\t// get the name as well required for later on\n+\tauto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\tparams.push_back (\n+\t  std::pair<HIR::Pattern *, TyTy::TyBase *> (param.get_param_name (),\n+\t\t\t\t\t\t     param_tyty));\n+\n+\tcontext->insert_type (param.get_mappings (), param_tyty);\n+      }\n+\n+    auto fnType = new TyTy::FnType (method.get_mappings ().get_hirid (), params,\n+\t\t\t\t    ret_type);\n+    context->insert_type (method.get_mappings (), fnType);\n+  }\n+\n private:\n-  TypeCheckTopLevelImplItem () : TypeCheckBase () {}\n+  TypeCheckTopLevelImplItem (TyTy::TyBase *self) : TypeCheckBase (), self (self)\n+  {}\n+\n+  TyTy::TyBase *self;\n };\n \n class TypeCheckImplItem : public TypeCheckBase\n@@ -99,7 +153,7 @@ class TypeCheckImplItem : public TypeCheckBase\n     TyTy::TyBase *lookup;\n     if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n       {\n-\trust_error_at (function.locus, \"failed to lookup function type\");\n+\trust_error_at (function.get_locus (), \"failed to lookup function type\");\n \treturn;\n       }\n \n@@ -137,6 +191,49 @@ class TypeCheckImplItem : public TypeCheckBase\n     context->pop_return_type ();\n   }\n \n+  void visit (HIR::Method &method)\n+  {\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (method.get_mappings ().get_hirid (), &lookup))\n+      {\n+\trust_error_at (method.get_locus (), \"failed to lookup function type\");\n+\treturn;\n+      }\n+\n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (method.get_locus (),\n+\t\t       \"found invalid type for function [%s]\",\n+\t\t       lookup->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // need to get the return type from this\n+    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n+    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    context->push_return_type (expected_ret_tyty);\n+\n+    TypeCheckExpr::Resolve (method.get_function_body ().get ());\n+    if (method.get_function_body ()->has_expr ())\n+      {\n+\tauto resolved\n+\t  = TypeCheckExpr::Resolve (method.get_function_body ()->expr.get ());\n+\n+\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n+\tif (ret_resolved == nullptr)\n+\t  {\n+\t    rust_error_at (method.get_function_body ()->expr->get_locus_slow (),\n+\t\t\t   \"failed to resolve final expression\");\n+\t    return;\n+\t  }\n+\n+\tcontext->peek_return_type ()->append_reference (\n+\t  ret_resolved->get_ref ());\n+      }\n+\n+    context->pop_return_type ();\n+  }\n+\n private:\n   TypeCheckImplItem (TyTy::TyBase *self) : TypeCheckBase (), self (self) {}\n "}, {"sha": "61823bf0381ba5854160c7ca45217f7c947889c3", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -137,11 +137,15 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n   void visit (HIR::InherentImpl &impl_block)\n   {\n-    TypeCheckType::Resolve (impl_block.get_type ().get ());\n-    for (auto &impl_item : impl_block.get_impl_items ())\n+    auto self = TypeCheckType::Resolve (impl_block.get_type ().get ());\n+    if (self == nullptr)\n       {\n-\tTypeCheckTopLevelImplItem::Resolve (impl_item.get ());\n+\trust_error_at (impl_block.get_locus (), \"failed to resolve impl type\");\n+\treturn;\n       }\n+\n+    for (auto &impl_item : impl_block.get_impl_items ())\n+      TypeCheckTopLevelImplItem::Resolve (impl_item.get (), self);\n   }\n \n private:"}, {"sha": "2f872a6263f76ddc5798a68041438e8e3ec6a43c", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -73,6 +73,18 @@ class TypeResolverDump : public TypeCheckBase\n     dump += indent () + \"}\\n\";\n   }\n \n+  void visit (HIR::Method &method)\n+  {\n+    dump += indent () + \"fn \" + method.get_method_name () + \" \"\n+\t    + type_string (method.get_mappings ()) + \"\\n\";\n+    dump += indent () + \"{\\n\";\n+\n+    HIR::BlockExpr *function_body = method.get_function_body ().get ();\n+    function_body->accept_vis (*this);\n+\n+    dump += indent () + \"}\\n\";\n+  }\n+\n   void visit (HIR::BlockExpr &expr)\n   {\n     indentation_level++;"}, {"sha": "82b070f1f7aa82a9802f7cbb15e2fb2bd3d3c989", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -38,7 +38,6 @@ class TypeCheckCallExpr : private TyVisitor\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n-  ~TypeCheckCallExpr () {}\n \n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n@@ -71,6 +70,47 @@ class TypeCheckCallExpr : private TyVisitor\n   Analysis::Mappings *mappings;\n };\n \n+class TypeCheckMethodCallExpr : private TyVisitor\n+{\n+public:\n+  static TyBase *go (TyBase *ref, HIR::MethodCallExpr &call,\n+\t\t     Resolver::TypeCheckContext *context)\n+  {\n+    TypeCheckMethodCallExpr checker (call, context);\n+    ref->accept_vis (checker);\n+    return checker.resolved;\n+  }\n+\n+  void visit (UnitType &type) override { gcc_unreachable (); }\n+  void visit (InferType &type) override { gcc_unreachable (); }\n+  void visit (TupleType &type) override { gcc_unreachable (); }\n+  void visit (StructFieldType &type) override { gcc_unreachable (); }\n+  void visit (ArrayType &type) override { gcc_unreachable (); }\n+  void visit (BoolType &type) override { gcc_unreachable (); }\n+  void visit (IntType &type) override { gcc_unreachable (); }\n+  void visit (UintType &type) override { gcc_unreachable (); }\n+  void visit (FloatType &type) override { gcc_unreachable (); }\n+  void visit (USizeType &type) override { gcc_unreachable (); }\n+  void visit (ISizeType &type) override { gcc_unreachable (); }\n+  void visit (ErrorType &type) override { gcc_unreachable (); }\n+  void visit (ADTType &type) override { gcc_unreachable (); };\n+\n+  // call fns\n+  void visit (FnType &type) override;\n+\n+private:\n+  TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+\t\t\t   Resolver::TypeCheckContext *context)\n+    : resolved (nullptr), call (c), context (context),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n+\n+  TyBase *resolved;\n+  HIR::MethodCallExpr &call;\n+  Resolver::TypeCheckContext *context;\n+  Analysis::Mappings *mappings;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "8b04209291b7ae24c1f266719590194a58f9fc03", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -147,14 +147,15 @@ ADTType::accept_vis (TyVisitor &vis)\n std::string\n ADTType::as_string () const\n {\n-  if (num_fields () == 0)\n-    return identifier;\n+  // if (num_fields () == 0)\n+  //   return identifier;\n \n-  std::string fields_buffer;\n-  for (auto &field : fields)\n-    fields_buffer += field->as_string () + \", \";\n+  // std::string fields_buffer;\n+  // for (auto &field : fields)\n+  //   fields_buffer += field->as_string () + \", \";\n \n-  return identifier + \"{\" + fields_buffer + \"}\";\n+  // return identifier + \"{\" + fields_buffer + \"}\";\n+  return identifier;\n }\n \n TyBase *\n@@ -574,5 +575,56 @@ TypeCheckCallExpr::visit (FnType &type)\n   resolved = type.get_return_type ()->clone ();\n }\n \n+// method call checker\n+\n+void\n+TypeCheckMethodCallExpr::visit (FnType &type)\n+{\n+  // +1 for the receiver self\n+  size_t num_args_to_call = call.num_params () + 1;\n+  if (num_args_to_call != type.num_params ())\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\",\n+\t\t     call.num_params (), type.num_params ());\n+      return;\n+    }\n+\n+  size_t i = 1;\n+  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n+    auto fnparam = type.param_at (i);\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param);\n+    if (argument_expr_tyty == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"failed to resolve type for argument expr in CallExpr\");\n+\treturn false;\n+      }\n+\n+    auto resolved_argument_type = fnparam.second->combine (argument_expr_tyty);\n+    if (resolved_argument_type == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"Type Resolution failure on parameter\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (param->get_mappings (), resolved_argument_type);\n+\n+    i++;\n+    return true;\n+  });\n+\n+  if (i != num_args_to_call)\n+    {\n+      rust_error_at (call.get_locus (),\n+\t\t     \"unexpected number of arguments %lu expected %lu\", i,\n+\t\t     call.num_params ());\n+      return;\n+    }\n+\n+  resolved = type.get_return_type ()->clone ();\n+}\n+\n } // namespace TyTy\n } // namespace Rust"}, {"sha": "8a15631406a6a7998d733858dcc43ee09f0d25e9", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -374,6 +374,30 @@ Mappings::lookup_hir_param (CrateNum crateNum, HirId id)\n   return iy->second;\n }\n \n+void\n+Mappings::insert_hir_self_param (CrateNum crateNum, HirId id,\n+\t\t\t\t HIR::SelfParam *param)\n+{\n+  rust_assert (lookup_hir_stmt (crateNum, id) == nullptr);\n+\n+  hirSelfParamMappings[crateNum][id] = param;\n+  nodeIdToHirMappings[crateNum][param->get_mappings ().get_nodeid ()] = id;\n+}\n+\n+HIR::SelfParam *\n+Mappings::lookup_hir_self_param (CrateNum crateNum, HirId id)\n+{\n+  auto it = hirSelfParamMappings.find (crateNum);\n+  if (it == hirSelfParamMappings.end ())\n+    return nullptr;\n+\n+  auto iy = it->second.find (id);\n+  if (iy == it->second.end ())\n+    return nullptr;\n+\n+  return iy->second;\n+}\n+\n void\n Mappings::insert_hir_struct_field (CrateNum crateNum, HirId id,\n \t\t\t\t   HIR::StructExprField *field)"}, {"sha": "0d625f6b67ec8b1f1aa6345bb89d723b00feaa81", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -125,6 +125,10 @@ class Mappings\n   void insert_hir_param (CrateNum crateNum, HirId id, HIR::FunctionParam *type);\n   HIR::FunctionParam *lookup_hir_param (CrateNum crateNum, HirId id);\n \n+  void insert_hir_self_param (CrateNum crateNum, HirId id,\n+\t\t\t      HIR::SelfParam *type);\n+  HIR::SelfParam *lookup_hir_self_param (CrateNum crateNum, HirId id);\n+\n   void insert_hir_struct_field (CrateNum crateNum, HirId id,\n \t\t\t\tHIR::StructExprField *type);\n   HIR::StructExprField *lookup_hir_struct_field (CrateNum crateNum, HirId id);\n@@ -152,6 +156,20 @@ class Mappings\n     return hirNodesWithinCrate[crate];\n   }\n \n+  void\n+  iterate_impl_items (std::function<bool (HirId, HIR::InherentImplItem *)> cb)\n+  {\n+    for (auto it = hirImplItemMappings.begin ();\n+\t it != hirImplItemMappings.end (); it++)\n+      {\n+\tfor (auto iy = it->second.begin (); iy != it->second.end (); iy++)\n+\t  {\n+\t    if (!cb (iy->first, iy->second))\n+\t      return;\n+\t  }\n+      }\n+  }\n+\n private:\n   Mappings ();\n \n@@ -176,6 +194,7 @@ class Mappings\n     hirStructFieldMappings;\n   std::map<CrateNum, std::map<HirId, HIR::InherentImplItem *> >\n     hirImplItemMappings;\n+  std::map<CrateNum, std::map<HirId, HIR::SelfParam *> > hirSelfParamMappings;\n \n   // location info\n   std::map<CrateNum, std::map<NodeId, Location> > locations;"}, {"sha": "cffa02e630b84b1e2a87706d48bd2b6649b93fa6", "filename": "gcc/testsuite/rust.test/compilable/methods1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods1.rs?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -0,0 +1,39 @@\n+struct Point {\n+    x: f64,\n+    y: f64,\n+}\n+\n+impl Point {\n+    fn origin() -> Point {\n+        Point { x: 0.0, y: 0.0 }\n+    }\n+\n+    fn new(x: f64, y: f64) -> Point {\n+        Point { x: x, y: y }\n+    }\n+}\n+\n+struct Rectangle {\n+    p1: Point,\n+    p2: Point,\n+}\n+\n+impl Rectangle {\n+    fn from(p1: Point, p2: Point) -> Self {\n+        Self { p1, p2 }\n+    }\n+\n+    fn sum_x(self) -> f64 {\n+        let p1 = self.p1;\n+        let p2 = self.p2;\n+        p1.x + p2.x\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point::origin();\n+    let p2 = Point::new(3.0, 4.0);\n+    let rect = Rectangle::from(p1, p2);\n+\n+    let sum = rect.sum_x();\n+}"}, {"sha": "96a3211f797fada6fbd6cdb5df655fe87b891417", "filename": "gcc/testsuite/rust.test/compilable/methods2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34a39466b2adb9684a1737c6ea4915e0194c26bf/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fmethods2.rs?ref=34a39466b2adb9684a1737c6ea4915e0194c26bf", "patch": "@@ -0,0 +1,41 @@\n+struct Point {\n+    x: f64,\n+    y: f64,\n+}\n+\n+impl Point {\n+    fn origin() -> Point {\n+        Point { x: 0.0, y: 0.0 }\n+    }\n+\n+    fn new(x: f64, y: f64) -> Point {\n+        Point { x: x, y: y }\n+    }\n+}\n+\n+struct Rectangle {\n+    p1: Point,\n+    p2: Point,\n+}\n+\n+impl Rectangle {\n+    fn from(p1: Point, p2: Point) -> Self {\n+        Self { p1, p2 }\n+    }\n+}\n+\n+fn main() {\n+    let p1 = Point::origin();\n+    let p2 = Point::new(3.0, 4.0);\n+    let rect = Rectangle::from(p1, p2);\n+\n+    let sum = rect.sum_x();\n+}\n+\n+impl Rectangle {\n+    fn sum_x(self) -> f64 {\n+        let p1 = self.p1;\n+        let p2 = self.p2;\n+        p1.x + p2.x\n+    }\n+}"}]}