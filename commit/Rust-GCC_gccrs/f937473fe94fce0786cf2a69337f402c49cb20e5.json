{"sha": "f937473fe94fce0786cf2a69337f402c49cb20e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkzNzQ3M2ZlOTRmY2UwNzg2Y2YyYTY5MzM3ZjQwMmM0OWNiMjBlNQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-04-06T09:19:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-04-06T09:19:10Z"}, "message": "einfo.ads, einfo.adb: (First_Component_Or_Discriminant): New function\n\n2007-04-06  Robert Dewar  <dewar@adacore.com>\n\t    Thomas Quinot  <quinot@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\n\t* einfo.ads, einfo.adb: (First_Component_Or_Discriminant): New function\n\t(Next_Component_Or_Discriminant): New function and procedure\n\t(First_Index, First_Literal, Master_Id,\n\tSet_First_Index, Set_First_Literal, Set_Master_Id):\n\tAdd missing Ekind assertions.\n\t(Is_Access_Protected_Subprogram_Type): New predicate.\n\t(Has_RACW): New entity flag, set on package entities to indicate that\n\tthe package contains the declaration of a remote accecss-to-classwide\n\ttype.\n\t(E_Return_Statement): This node type has the Finalization_Chain_Entity\n\tattribute, in case the result type has controlled parts.\n\t(Requires_Overriding): Add this new flag, because \"requires\n\toverriding\" is subtly different from \"is abstract\" (see AI-228).\n\t(Is_Abstract): Split Is_Abstract flag into Is_Abstract_Subprogram and\n\tIs_Abstract_Type. Make sure these are called only when appropriate.\n\t(Has_Pragma_Unreferenced_Objects): New flag\n\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): If the left-hand side is\n\tclass-wide, the tag of the right-hand side must be an exact match, not\n\tan ancestor of that of the object on left-hand side.\n\t(Move_Activation_Chain): New procedure to create the call to\n\tSystem.Tasking.Stages.Move_Activation_Chain.\n\t(Expand_N_Extended_Return_Statement): Generate code to call\n\tSystem.Finalization_Implementation.Move_Final_List at the end of a\n\treturn statement if the function's result type has controlled parts.\n\tMove asserts to Build_In_Place_Formal.\n\t(Move_Final_List): New function to create the call statement.\n\t(Expand_N_Assignment_Statement): In case of assignment to a class-wide\n\ttagged type, replace generation of call to the run-time subprogram\n\tCW_Membership by call to Build_CW_Membership.\n\t(Expand_N_Return_Statement): Replace generation of call to the run-time\n\tsubprogram Get_Access_Level by call to Build_Get_Access_Level.\n\t(Expand_N_Simple_Function_Return): Replace generation of call to the\n\trun-time subprogram Get_Access_Level by call to Build_Get_Access_Level.\n\n\t* exp_ch6.ads, exp_ch6.adb (Expand_Call): Use new predicate\n\tIs_Access_Protected_Subprogram_Type, to handle both named and anonymous\n\taccess to protected operations.\n\t(Add_Task_Actuals_To_Build_In_Place_Call): New procedure to add the\n\tmaster and chain actual parameters to a build-in-place function call\n\tinvolving tasks.\n\t(BIP_Formal_Suffix): Add new enumeration literals to complete the case\n\tstatement.\n\t(Make_Build_In_Place_Call_In_Allocator,\n\tMake_Build_In_Place_Call_In_Anonymous_Context,\n\tMake_Build_In_Place_Call_In_Assignment,\n\tMake_Build_In_Place_Call_In_Object_Declaration): Call\n\tAdd_Task_Actuals_To_Build_In_Place_Call with the appropriate master.\n\t(Expand_Inlined_Call): If the subprogram is a null procedure, or a\n\tstubbed procedure with a null body, replace the call with a null\n\tstatement without using the full inlining machinery, for efficiency\n\tand to avoid invalid values in source file table entries.\n\n\t* exp_ch8.adb (Expand_N_Object_Renaming_Declaration): Add support for\n\trenamings of calls to build-in-place functions.\n\n\t* rtsfind.adb (RTE_Record_Component_Available): New subprogram that\n\tprovides the functionality of RTE_Available to record components.\n\t(RTU_Entity): The function Entity has been renamed to RTU_Entity\n\tto avoid undesired overloading.\n\t(Entity): New subprogram that returns the entity for the referened\n\tunit. If this unit has not been loaded, it returns Empty.\n\t(RE_Activation_Chain_Access, RE_Move_Activation_Chain): New entities.\n\tRemove no longer used entities.\n\t(RE_Finalizable_Ptr_Ptr, RE_Move_Final_List): New entities.\n\t(RE_Type_Specific_Data): New entity.\n\t(RE_Move_Any_Value): New entity.\n\t(RE_TA_A, RE_Get_Any_Type): New entities.\n\t(RE_Access_Level, RE_Dispatch_Table, E_Default_Prim_Op_Count,\n\t RE_Prims_Ptr, RE_RC_Offset, RE_Remotely_Callable,\n\t RE_DT_Typeinfo_Ptr_Size, RE_Cstring_Ptr, RE_DT_Expanded_Name): Added.\n\t(Entity): New subprogram that returns the entity for the referened\n\tunit. If this unit has not been loaded, it returns Empty.\n\t(RTE): Addition of a new formal that extends the search to the scopes\n\tof the record types found in the chain of the package.\n\n\t* sem_ch6.ads, sem_ch6.adb (Check_Overriding_Indicator): Print\n\t\"abstract subprograms must be visible\" message, whether or not the type\n\tis an interface; that is, remove the special case for interface types.\n\t(Analyze_Function_Return): Remove error message \"return of task objects\n\tis not yet implemented\" because this is now implemented.\n\t(Create_Extra_Formals): Add the extra master and activation chain\n\tformals in case the result type has tasks.\n\tRemove error message \"return of limited controlled objects is not yet\n\timplemented\".\n\t(Create_Extra_Formals): Add the extra caller's finalization list formal\n\tin case the result type has controlled parts.\n\t(Process_Formals): In case of access formal types there is no need\n\tto continue with the analysis of the formals if we already notified\n\terrors.\n\t(Check_Overriding_Indicator): Add code to check overriding of predefined\n\toperators.\n\t(Create_Extra_Formals): Prevent creation of useless Extra_Constrained\n\tflags for formals that do not require them,.\n\t(Enter_Overloaded_Entity): Do not give -gnatwh warning message unless\n\thidden entity is use visible or directly visible.\n\t(Analyze_Abstract_Subprogram_Declaration,Analyze_Subprogram_Body,\n\tAnalyze_Subprogram_Declaration,Analyze_Subprogram_Specification,\n\tCheck_Conventions,Check_Delayed_Subprogram,Make_Inequality_Operator,\n\tNew_Overloaded_Entity): Split Is_Abstract flag into\n\tIs_Abstract_Subprogram and Is_Abstract_Type.\n\n\t* s-finimp.ads, s-finimp.adb (Move_Final_List): New procedure to move\n\ta return statement's finalization list to the caller's list, used for\n\tbuild-in-place functions with result type with controlled parts.\n\tRemove no longer used entities.\n\n\t* s-taskin.ads (Activation_Chain): Remove pragma Volatile. It is no\n\tlonger needed, because the full type is now limited, and therefore a\n\tpass-by-reference type.\n\t(Foreign_Task_Level): New constant.\n\n\t* s-tassta.ads, s-tassta.adb (Move_Activation_Chain): New procedure to\n\tmove tasks from the activation chain belonging to a return statement to\n\tthe one passed in by the caller, and update the master to the one\n\tpassed in by the caller.\n\t(Vulnerable_Complete_Master, Check_Unactivated_Tasks): Check the master\n\tof unactivated tasks, so we don't kill the ones that are being returned\n\tby a build-in-place function.\n\t(Create_Task): Ignore AI-280 for foreign threads.\n\nFrom-SVN: r123558", "tree": {"sha": "12ed0014102d78ce0433f132d50d7cdaeaa18628", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12ed0014102d78ce0433f132d50d7cdaeaa18628"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f937473fe94fce0786cf2a69337f402c49cb20e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f937473fe94fce0786cf2a69337f402c49cb20e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f937473fe94fce0786cf2a69337f402c49cb20e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f937473fe94fce0786cf2a69337f402c49cb20e5/comments", "author": null, "committer": null, "parents": [{"sha": "9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dac0a42ea1bb2816ceac970652ddba6c88cd0cf"}], "stats": {"total": 8247, "additions": 4576, "deletions": 3671}, "files": [{"sha": "8707301143a58404bf53cde6845dfdce2e56afab", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 892, "deletions": 789, "changes": 1681, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5"}, {"sha": "f606d4f5ecf3c13340cff5a4b1c3dc4f9007ff8d", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 1705, "deletions": 1621, "changes": 3326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=f937473fe94fce0786cf2a69337f402c49cb20e5"}, {"sha": "d3db4afceb38601d2c91579428216be24dc08eb8", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 540, "deletions": 614, "changes": 1154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -29,6 +29,7 @@ with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -127,10 +128,6 @@ package body Exp_Ch5 is\n    --  pointers which are not 'part of the value' and must not be changed\n    --  upon assignment. N is the original Assignment node.\n \n-   procedure No_Secondary_Stack_Case (N : Node_Id);\n-   --  Obsolete code to deal with functions for which\n-   --  Function_Returns_With_DSP is True.\n-\n    function Possible_Bit_Aligned_Component (N : Node_Id) return Boolean;\n    --  This function is used in processing the assignment of a record or\n    --  indexed component. The argument N is either the left hand or right\n@@ -1401,7 +1398,7 @@ package body Exp_Ch5 is\n    begin\n       --  Ada 2005 (AI-327): Handle assignment to priority of protected object\n \n-      --  Rewrite an assignment to X'Priority into a run-time call.\n+      --  Rewrite an assignment to X'Priority into a run-time call\n \n       --   For example:         X'Priority := New_Prio_Expr;\n       --   ...is expanded into  Set_Ceiling (X._Object, New_Prio_Expr);\n@@ -1759,7 +1756,7 @@ package body Exp_Ch5 is\n \n       --  Build-in-place function call case. Note that we're not yet doing\n       --  build-in-place for user-written assignment statements; the\n-      --  assignment here came from can aggregate.\n+      --  assignment here came from an aggregate.\n \n       elsif Ada_Version >= Ada_05\n         and then Is_Build_In_Place_Function_Call (Rhs)\n@@ -1830,7 +1827,7 @@ package body Exp_Ch5 is\n \n                   --  In case of assignment to a class-wide tagged type, before\n                   --  the assignment we generate run-time check to ensure that\n-                  --  the tag of the Target is covered by the tag of the source\n+                  --  the tags of source and target match.\n \n                   if Is_Class_Wide_Type (Typ)\n                     and then Is_Tagged_Type (Typ)\n@@ -1839,29 +1836,28 @@ package body Exp_Ch5 is\n                      Append_To (L,\n                        Make_Raise_Constraint_Error (Loc,\n                          Condition =>\n-                           Make_Op_Not (Loc,\n-                             Make_Function_Call (Loc,\n-                               Name => New_Reference_To\n-                                         (RTE (RE_CW_Membership), Loc),\n-                               Parameter_Associations => New_List (\n+                             Make_Op_Ne (Loc,\n+                               Left_Opnd =>\n                                  Make_Selected_Component (Loc,\n-                                   Prefix =>\n-                                     Duplicate_Subexpr (Lhs),\n+                                   Prefix        => Duplicate_Subexpr (Lhs),\n                                    Selector_Name =>\n-                                     Make_Identifier (Loc, Name_uTag)),\n+                                     Make_Identifier (Loc,\n+                                       Chars => Name_uTag)),\n+                               Right_Opnd =>\n                                  Make_Selected_Component (Loc,\n-                                   Prefix =>\n-                                     Duplicate_Subexpr (Rhs),\n+                                   Prefix        => Duplicate_Subexpr (Rhs),\n                                    Selector_Name =>\n-                                     Make_Identifier (Loc, Name_uTag))))),\n+                                     Make_Identifier (Loc,\n+                                       Chars => Name_uTag))),\n                          Reason => CE_Tag_Check_Failed));\n                   end if;\n \n                   Append_To (L,\n                     Make_Procedure_Call_Statement (Loc,\n                       Name => New_Reference_To (Op, Loc),\n                       Parameter_Associations => New_List (\n-                        Unchecked_Convert_To (F_Typ, Duplicate_Subexpr (Lhs)),\n+                        Unchecked_Convert_To (F_Typ,\n+                          Duplicate_Subexpr (Lhs)),\n                         Unchecked_Convert_To (F_Typ,\n                           Duplicate_Subexpr (Rhs)))));\n                end;\n@@ -1872,8 +1868,8 @@ package body Exp_Ch5 is\n                --  We can't afford to have destructive Finalization Actions\n                --  in the Self assignment case, so if the target and the\n                --  source are not obviously different, code is generated to\n-               --  avoid the self assignment case\n-               --\n+               --  avoid the self assignment case:\n+\n                --    if lhs'address /= rhs'address then\n                --       <code for controlled and/or tagged assignment>\n                --    end if;\n@@ -1901,7 +1897,7 @@ package body Exp_Ch5 is\n                --  We need to set up an exception handler for implementing\n                --  7.6.1 (18). The remaining adjustments are tackled by the\n                --  implementation of adjust for record_controllers (see\n-               --  s-finimp.adb)\n+               --  s-finimp.adb).\n \n                --  This is skipped if we have no finalization\n \n@@ -1914,7 +1910,7 @@ package body Exp_Ch5 is\n                         Make_Handled_Sequence_Of_Statements (Loc,\n                           Statements => L,\n                           Exception_Handlers => New_List (\n-                            Make_Exception_Handler (Loc,\n+                            Make_Implicit_Exception_Handler (Loc,\n                               Exception_Choices =>\n                                 New_List (Make_Others_Choice (Loc)),\n                               Statements        => New_List (\n@@ -1931,7 +1927,7 @@ package body Exp_Ch5 is\n                   Make_Handled_Sequence_Of_Statements (Loc, Statements => L)));\n \n             --  If no restrictions on aborts, protect the whole assignement\n-            --  for controlled objects as per 9.8(11)\n+            --  for controlled objects as per 9.8(11).\n \n             if Controlled_Type (Typ)\n               and then Expand_Ctrl_Actions\n@@ -2366,61 +2362,6 @@ package body Exp_Ch5 is\n    --  initial values might need to be set).\n \n    procedure Expand_N_Extended_Return_Statement (N : Node_Id) is\n-\n-      function Is_Build_In_Place_Function (Fun : Entity_Id) return Boolean;\n-      --  F must be of type E_Function or E_Generic_Function. Return True if it\n-      --  uses build-in-place for the result object. In Ada 95, this must be\n-      --  False for inherently limited result type. In Ada 2005, this must be\n-      --  True for inherently limited result type. For other types, we have a\n-      --  choice -- build-in-place is usually more efficient for large things,\n-      --  and less efficient for small things. However, we had better not use\n-      --  build-in-place if the Convention is other than Ada, because that\n-      --  would disturb mixed-language programs.\n-      --\n-      --  Note that for the non-inherently-limited cases, we must make the same\n-      --  decision for Ada 95 and 2005, so that mixed-dialect programs work.\n-      --\n-      --  ???This function will be needed when compiling the call sites;\n-      --  we will have to move it to a more global place.\n-\n-      --------------------------------\n-      -- Is_Build_In_Place_Function --\n-      --------------------------------\n-\n-      function Is_Build_In_Place_Function (Fun : Entity_Id) return Boolean is\n-         R_Type : constant Entity_Id := Underlying_Type (Etype (Fun));\n-\n-      begin\n-         --  First, the cases that matter for correctness\n-\n-         if Is_Inherently_Limited_Type (R_Type) then\n-            return Ada_Version >= Ada_05 and then not Debug_Flag_Dot_L;\n-\n-            --  Note: If you have Convention (C) on an inherently limited\n-            --  type, you're on your own. That is, the C code will have to be\n-            --  carefully written to know about the Ada conventions.\n-\n-         elsif\n-           Has_Foreign_Convention (R_Type)\n-             or else\n-           Has_Foreign_Convention (Fun)\n-         then\n-            return False;\n-\n-         --  Second, the efficiency-related decisions. It would be obnoxiously\n-         --  inefficient to use build-in-place for elementary types. For\n-         --  composites, we could return False if the subtype is known to be\n-         --  small (<= one or two words?) but we don't bother with that yet.\n-\n-         else\n-            return Is_Composite_Type (R_Type);\n-         end if;\n-      end Is_Build_In_Place_Function;\n-\n-      ------------------------\n-      -- Local Declarations --\n-      ------------------------\n-\n       Loc : constant Source_Ptr := Sloc (N);\n \n       Return_Object_Entity : constant Entity_Id :=\n@@ -2433,10 +2374,83 @@ package body Exp_Ch5 is\n                                Is_Build_In_Place_Function (Parent_Function);\n \n       Return_Stm      : Node_Id;\n+      Statements      : List_Id;\n       Handled_Stm_Seq : Node_Id;\n       Result          : Node_Id;\n       Exp             : Node_Id;\n \n+      function Move_Activation_Chain return Node_Id;\n+      --  Construct a call to System.Tasking.Stages.Move_Activation_Chain\n+      --  with parameters:\n+      --    From         current activation chain\n+      --    To           activation chain passed in by the caller\n+      --    New_Master   master passed in by the caller\n+\n+      function Move_Final_List return Node_Id;\n+      --  Construct call to System.Finalization_Implementation.Move_Final_List\n+      --  with parameters:\n+      --  From           finalization list of the return statement\n+      --  To             finalization list passed in by the caller\n+\n+      ---------------------\n+      -- Move_Activation_Chain --\n+      ---------------------\n+\n+      function Move_Activation_Chain return Node_Id is\n+         Activation_Chain_Formal : constant Entity_Id :=\n+           Build_In_Place_Formal (Parent_Function, BIP_Activation_Chain);\n+         To                      : constant Node_Id :=\n+           New_Reference_To (Activation_Chain_Formal, Loc);\n+         Master_Formal           : constant Entity_Id :=\n+           Build_In_Place_Formal (Parent_Function, BIP_Master);\n+         New_Master              : constant Node_Id :=\n+           New_Reference_To (Master_Formal, Loc);\n+\n+         Chain_Entity : Entity_Id;\n+         From         : Node_Id;\n+      begin\n+         Chain_Entity := First_Entity (Return_Statement_Entity (N));\n+         while Chars (Chain_Entity) /= Name_uChain loop\n+            Chain_Entity := Next_Entity (Chain_Entity);\n+         end loop;\n+\n+         From :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => New_Reference_To (Chain_Entity, Loc),\n+             Attribute_Name => Name_Unrestricted_Access);\n+         --  ??? I'm not sure why \"Make_Identifier (Loc, Name_uChain)\" doesn't\n+         --  work, instead of \"New_Reference_To (Chain_Entity, Loc)\" above.\n+\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Move_Activation_Chain), Loc),\n+             Parameter_Associations => New_List (From, To, New_Master));\n+      end Move_Activation_Chain;\n+\n+      ---------------------\n+      -- Move_Final_List --\n+      ---------------------\n+\n+      function Move_Final_List return Node_Id is\n+         Flist : constant Entity_Id  :=\n+                   Finalization_Chain_Entity (Return_Statement_Entity (N));\n+\n+         From  : constant Node_Id := New_Reference_To (Flist, Loc);\n+\n+         Caller_Final_List : constant Entity_Id :=\n+                               Build_In_Place_Formal\n+                                 (Parent_Function, BIP_Final_List);\n+\n+         To    : constant Node_Id :=\n+                   New_Reference_To (Caller_Final_List, Loc);\n+\n+      begin\n+         return\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Move_Final_List), Loc),\n+             Parameter_Associations => New_List (From, To));\n+      end Move_Final_List;\n+\n    --  Start of processing for Expand_N_Extended_Return_Statement\n \n    begin\n@@ -2448,27 +2462,63 @@ package body Exp_Ch5 is\n \n       Handled_Stm_Seq := Handled_Statement_Sequence (N);\n \n+      --  Build a simple_return_statement that returns the return object when\n+      --  there is a statement sequence, or no expression, or the result will\n+      --  be built in place. Note however that we currently do this for all\n+      --  composite cases, even though nonlimited composite results are not yet\n+      --  built in place (though we plan to do so eventually).\n+\n       if Present (Handled_Stm_Seq)\n-        or else Is_Build_In_Place\n+        or else Is_Composite_Type (Etype (Parent_Function))\n         or else No (Exp)\n       then\n-         --  Build simple_return_statement that returns the return object\n+         Statements := New_List;\n+\n+         if Present (Handled_Stm_Seq) then\n+            Append_To (Statements, Handled_Stm_Seq);\n+         end if;\n+\n+         --  If control gets past the above Statements, we have successfully\n+         --  completed the return statement. If the result type has controlled\n+         --  parts, we call Move_Final_List to transfer responsibility for\n+         --  finalization of the return object to the caller. An alternative\n+         --  would be to declare a Success flag in the function, initialize it\n+         --  to False, and set it to True here. Then move the Move_Final_List\n+         --  call into the cleanup code, and check Success. If Success then\n+         --  Move_Final_List else do finalization. Then we can remove the\n+         --  abort-deferral and the nulling-out of the From parameter from\n+         --  Move_Final_List. Note that the current method is not quite\n+         --  correct in the rather obscure case of a select-then-abort\n+         --  statement whose abortable part contains the return statement.\n+\n+         if Is_Controlled (Etype (Parent_Function))\n+           or else Has_Controlled_Component (Etype (Parent_Function))\n+         then\n+            Append_To (Statements, Move_Final_List);\n+         end if;\n+\n+         --  Similarly to the above Move_Final_List, if the result type\n+         --  contains tasks, we call Move_Activation_Chain. Later, the cleanup\n+         --  code will call Complete_Master, which will terminate any\n+         --  unactivated tasks belonging to the return statement master. But\n+         --  Move_Activation_Chain updates their master to be that of the\n+         --  caller, so they will not be terminated unless the return\n+         --  statement completes unsuccessfully due to exception, abort, goto,\n+         --  or exit.\n+\n+         if Has_Task (Etype (Parent_Function)) then\n+            Append_To (Statements, Move_Activation_Chain);\n+         end if;\n+\n+         --  Build a simple_return_statement that returns the return object\n \n          Return_Stm :=\n            Make_Return_Statement (Loc,\n              Expression => New_Occurrence_Of (Return_Object_Entity, Loc));\n+         Append_To (Statements, Return_Stm);\n \n-         if Present (Handled_Stm_Seq) then\n-            Handled_Stm_Seq :=\n-              Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => New_List (Handled_Stm_Seq, Return_Stm));\n-         else\n-            Handled_Stm_Seq :=\n-              Make_Handled_Sequence_Of_Statements (Loc,\n-                Statements => New_List (Return_Stm));\n-         end if;\n-\n-         pragma Assert (Present (Handled_Stm_Seq));\n+         Handled_Stm_Seq :=\n+           Make_Handled_Sequence_Of_Statements (Loc, Statements);\n       end if;\n \n       --  Case where we build a block\n@@ -2479,7 +2529,29 @@ package body Exp_Ch5 is\n              Declarations => Return_Object_Declarations (N),\n              Handled_Statement_Sequence => Handled_Stm_Seq);\n \n-         if Is_Build_In_Place then\n+         --  We set the entity of the new block statement to be that of the\n+         --  return statement. This is necessary so that various fields, such\n+         --  as Finalization_Chain_Entity carry over from the return statement\n+         --  to the block. Note that this block is unusual, in that its entity\n+         --  is an E_Return_Statement rather than an E_Block.\n+\n+         Set_Identifier\n+           (Result, New_Occurrence_Of (Return_Statement_Entity (N), Loc));\n+\n+         --  If the object decl was already rewritten as a renaming, then\n+         --  we don't want to do the object allocation and transformation of\n+         --  of the return object declaration to a renaming. This case occurs\n+         --  when the return object is initialized by a call to another\n+         --  build-in-place function, and that function is responsible for the\n+         --  allocation of the return object.\n+\n+         if Is_Build_In_Place\n+           and then\n+             Nkind (Return_Object_Decl) = N_Object_Renaming_Declaration\n+         then\n+            Set_By_Ref (Return_Stm);  -- Return build-in-place results by ref\n+\n+         elsif Is_Build_In_Place then\n \n             --  Locate the implicit access parameter associated with the\n             --  the caller-supplied return object and convert the return\n@@ -2503,84 +2575,282 @@ package body Exp_Ch5 is\n             --     ...\n \n             declare\n-               Return_Obj_Id   : constant Entity_Id :=\n-                                   Defining_Identifier (Return_Object_Decl);\n-               Return_Obj_Typ  : constant Entity_Id := Etype (Return_Obj_Id);\n-               Return_Obj_Expr : constant Node_Id :=\n-                                   Expression (Return_Object_Decl);\n-               Obj_Acc_Formal  : Entity_Id := Extra_Formals (Parent_Function);\n-               Obj_Acc_Deref   : Node_Id;\n-               Init_Assignment : Node_Id;\n+               Return_Obj_Id    : constant Entity_Id :=\n+                                    Defining_Identifier (Return_Object_Decl);\n+               Return_Obj_Typ   : constant Entity_Id := Etype (Return_Obj_Id);\n+               Return_Obj_Expr  : constant Node_Id :=\n+                                    Expression (Return_Object_Decl);\n+               Result_Subt      : constant Entity_Id :=\n+                                    Etype (Parent_Function);\n+               Constr_Result    : constant Boolean :=\n+                                    Is_Constrained (Result_Subt);\n+               Obj_Alloc_Formal : Entity_Id;\n+               Object_Access    : Entity_Id;\n+               Obj_Acc_Deref    : Node_Id;\n+               Init_Assignment  : Node_Id := Empty;\n \n             begin\n                --  Build-in-place results must be returned by reference\n \n                Set_By_Ref (Return_Stm);\n \n-               --  Locate the implicit access parameter passed by the caller.\n-               --  It might be better to search for that with a symbol table\n-               --  lookup, but for now we traverse the extra actuals to find\n-               --  the access parameter (currently there can only be one).\n+               --  Retrieve the implicit access parameter passed by the caller\n \n-               while Present (Obj_Acc_Formal) loop\n-                  exit when\n-                    Ekind (Etype (Obj_Acc_Formal)) = E_Anonymous_Access_Type;\n-                  Next_Formal_With_Extras (Obj_Acc_Formal);\n-               end loop;\n+               Object_Access :=\n+                 Build_In_Place_Formal (Parent_Function, BIP_Object_Access);\n \n-               --  ??? pragma Assert (Present (Obj_Acc_Formal));\n+               --  If the return object's declaration includes an expression\n+               --  and the declaration isn't marked as No_Initialization, then\n+               --  we need to generate an assignment to the object and insert\n+               --  it after the declaration before rewriting it as a renaming\n+               --  (otherwise we'll lose the initialization).\n \n-               --  For now we only rewrite the object if we can locate the\n-               --  implicit access parameter. Normally there should be one\n-               --  if Build_In_Place is true, but at the moment it's only\n-               --  created in the more restrictive case of constrained\n-               --  inherently limited result subtypes. ???\n+               if Present (Return_Obj_Expr)\n+                 and then not No_Initialization (Return_Object_Decl)\n+               then\n+                  Init_Assignment :=\n+                    Make_Assignment_Statement (Loc,\n+                      Name       => New_Reference_To (Return_Obj_Id, Loc),\n+                      Expression => Relocate_Node (Return_Obj_Expr));\n+                  Set_Assignment_OK (Name (Init_Assignment));\n+                  Set_No_Ctrl_Actions (Init_Assignment);\n \n-               if Present (Obj_Acc_Formal) then\n+                  Set_Parent (Expression (Init_Assignment), Init_Assignment);\n \n-                  --  If the return object's declaration includes an expression\n-                  --  and the declaration isn't marked as No_Initialization,\n-                  --  then we need to generate an assignment to the object and\n-                  --  insert it after the declaration before rewriting it as\n-                  --  a renaming (otherwise we'll lose the initialization).\n+                  Set_Expression (Return_Object_Decl, Empty);\n \n-                  if Present (Return_Obj_Expr)\n-                    and then not No_Initialization (Return_Object_Decl)\n+                  if Is_Class_Wide_Type (Etype (Return_Obj_Id))\n+                    and then not Is_Class_Wide_Type\n+                                   (Etype (Expression (Init_Assignment)))\n                   then\n-                     Init_Assignment :=\n-                       Make_Assignment_Statement (Loc,\n-                         Name       => New_Reference_To (Return_Obj_Id, Loc),\n-                         Expression => Relocate_Node (Return_Obj_Expr));\n-                     Set_Assignment_OK (Name (Init_Assignment));\n-                     Set_No_Ctrl_Actions (Init_Assignment);\n-\n-                     --  ??? Should we be setting the parent of the expression\n-                     --  here?\n-                     --  Set_Parent\n-                     --    (Expression (Init_Assignment), Init_Assignment);\n-\n-                     Set_Expression (Return_Object_Decl, Empty);\n+                     Rewrite (Expression (Init_Assignment),\n+                       Make_Type_Conversion (Loc,\n+                         Subtype_Mark =>\n+                           New_Occurrence_Of\n+                             (Etype (Return_Obj_Id), Loc),\n+                         Expression =>\n+                           Relocate_Node (Expression (Init_Assignment))));\n+                  end if;\n \n+                  if Constr_Result then\n                      Insert_After (Return_Object_Decl, Init_Assignment);\n                   end if;\n+               end if;\n \n-                  --  Replace the return object declaration with a renaming\n-                  --  of a dereference of the implicit access formal.\n+               --  When the function's subtype is unconstrained, a run-time\n+               --  test is needed to determine the form of allocation to use\n+               --  for the return object. The function has an implicit formal\n+               --  parameter that indicates this. If the BIP_Alloc_Form formal\n+               --  has the value one, then the caller has passed access to an\n+               --  existing object for use as the return object. If the value\n+               --  is two, then the return object must be allocated on the\n+               --  secondary stack. Otherwise, the object must be allocated in\n+               --  a storage pool. Currently the last case is only supported\n+               --  for the global heap (user-defined storage pools TBD ???). We\n+               --  generate an if statement to test the implicit allocation\n+               --  formal and initialize a local access value appropriately,\n+               --  creating allocators in the secondary stack and global heap\n+               --  cases.\n+\n+               if not Constr_Result then\n+                  Obj_Alloc_Formal :=\n+                    Build_In_Place_Formal (Parent_Function, BIP_Alloc_Form);\n+\n+                  declare\n+                     Ref_Type       : Entity_Id;\n+                     Ptr_Type_Decl  : Node_Id;\n+                     Alloc_Obj_Id   : Entity_Id;\n+                     Alloc_Obj_Decl : Node_Id;\n+                     Alloc_If_Stmt  : Node_Id;\n+                     SS_Allocator   : Node_Id;\n+                     Heap_Allocator : Node_Id;\n+\n+                  begin\n+                     --  Reuse the itype created for the function's implicit\n+                     --  access formal. This avoids the need to create a new\n+                     --  access type here, plus it allows assigning the access\n+                     --  formal directly without applying a conversion.\n+\n+                     --  Ref_Type := Etype (Object_Access);\n+\n+                     --  Create an access type designating the function's\n+                     --  result subtype.\n+\n+                     Ref_Type :=\n+                       Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n+\n+                     Ptr_Type_Decl :=\n+                       Make_Full_Type_Declaration (Loc,\n+                         Defining_Identifier => Ref_Type,\n+                         Type_Definition =>\n+                           Make_Access_To_Object_Definition (Loc,\n+                             All_Present => True,\n+                             Subtype_Indication =>\n+                               New_Reference_To (Return_Obj_Typ, Loc)));\n+\n+                     Insert_Before_And_Analyze\n+                       (Return_Object_Decl, Ptr_Type_Decl);\n+\n+                     --  Create an access object that will be initialized to an\n+                     --  access value denoting the return object, either coming\n+                     --  from an implicit access value passed in by the caller\n+                     --  or from the result of an allocator.\n+\n+                     Alloc_Obj_Id :=\n+                       Make_Defining_Identifier (Loc,\n+                         Chars => New_Internal_Name ('R'));\n+                     Set_Etype (Alloc_Obj_Id, Ref_Type);\n+\n+                     Alloc_Obj_Decl :=\n+                       Make_Object_Declaration (Loc,\n+                         Defining_Identifier => Alloc_Obj_Id,\n+                         Object_Definition   => New_Reference_To\n+                                                  (Ref_Type, Loc));\n+\n+                     Insert_Before_And_Analyze\n+                       (Return_Object_Decl, Alloc_Obj_Decl);\n+\n+                     --  Create allocators for both the secondary stack and\n+                     --  global heap. If there's an initialization expression,\n+                     --  then create these as initialized allocators.\n+\n+                     if Present (Return_Obj_Expr)\n+                       and then not No_Initialization (Return_Object_Decl)\n+                     then\n+                        Heap_Allocator :=\n+                          Make_Allocator (Loc,\n+                            Expression =>\n+                              Make_Qualified_Expression (Loc,\n+                                Subtype_Mark =>\n+                                  New_Reference_To (Return_Obj_Typ, Loc),\n+                                Expression =>\n+                                  New_Copy_Tree (Return_Obj_Expr)));\n+\n+                        SS_Allocator := New_Copy_Tree (Heap_Allocator);\n+\n+                     else\n+                        Heap_Allocator :=\n+                          Make_Allocator (Loc,\n+                            New_Reference_To (Return_Obj_Typ, Loc));\n \n-                  Obj_Acc_Deref :=\n-                    Make_Explicit_Dereference (Loc,\n-                      Prefix => New_Reference_To (Obj_Acc_Formal, Loc));\n+                        --  If the object requires default initialization then\n+                        --  that will happen later following the elaboration of\n+                        --  the object renaming. If we don't turn it off here\n+                        --  then the object will be default initialized twice.\n \n-                  Rewrite (Return_Object_Decl,\n-                    Make_Object_Renaming_Declaration (Loc,\n-                      Defining_Identifier => Return_Obj_Id,\n-                      Access_Definition   => Empty,\n-                      Subtype_Mark        => New_Occurrence_Of\n-                                               (Return_Obj_Typ, Loc),\n-                      Name                => Obj_Acc_Deref));\n+                        Set_No_Initialization (Heap_Allocator);\n \n-                  Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n+                        SS_Allocator := New_Copy_Tree (Heap_Allocator);\n+                     end if;\n+\n+                     Set_Storage_Pool\n+                       (SS_Allocator, RTE (RE_SS_Pool));\n+                     Set_Procedure_To_Call\n+                       (SS_Allocator, RTE (RE_SS_Allocate));\n+\n+                     --  Create an if statement to test the BIP_Alloc_Form\n+                     --  formal and initialize the access object to either the\n+                     --  BIP_Object_Access formal (BIP_Alloc_Form = 0), the\n+                     --  result of allocaing the object in the secondary stack\n+                     --  (BIP_Alloc_Form = 1), or else an allocator to create\n+                     --  the return object in the heap (BIP_Alloc_Form = 2).\n+\n+                     --  ??? An unchecked type conversion must be made in the\n+                     --  case of assigning the access object formal to the\n+                     --  local access object, because a normal conversion would\n+                     --  be illegal in some cases (such as converting access-\n+                     --  to-unconstrained to access-to-constrained), but the\n+                     --  the unchecked conversion will presumably fail to work\n+                     --  right in just such cases. It's not clear at all how to\n+                     --  handle this. ???\n+\n+                     Alloc_If_Stmt :=\n+                       Make_If_Statement (Loc,\n+                         Condition       =>\n+                           Make_Op_Eq (Loc,\n+                             Left_Opnd =>\n+                               New_Reference_To (Obj_Alloc_Formal, Loc),\n+                             Right_Opnd =>\n+                               Make_Integer_Literal (Loc,\n+                                 UI_From_Int (BIP_Allocation_Form'Pos\n+                                                (Caller_Allocation)))),\n+                         Then_Statements =>\n+                           New_List (Make_Assignment_Statement (Loc,\n+                                       Name       =>\n+                                         New_Reference_To\n+                                           (Alloc_Obj_Id, Loc),\n+                                       Expression =>\n+                                         Make_Unchecked_Type_Conversion (Loc,\n+                                           Subtype_Mark =>\n+                                             New_Reference_To (Ref_Type, Loc),\n+                                           Expression =>\n+                                             New_Reference_To\n+                                               (Object_Access, Loc)))),\n+                         Elsif_Parts     =>\n+                           New_List (Make_Elsif_Part (Loc,\n+                                       Condition       =>\n+                                         Make_Op_Eq (Loc,\n+                                           Left_Opnd =>\n+                                             New_Reference_To\n+                                               (Obj_Alloc_Formal, Loc),\n+                                           Right_Opnd =>\n+                                             Make_Integer_Literal (Loc,\n+                                               UI_From_Int (\n+                                                 BIP_Allocation_Form'Pos\n+                                                    (Secondary_Stack)))),\n+                                       Then_Statements =>\n+                                          New_List\n+                                            (Make_Assignment_Statement (Loc,\n+                                               Name       =>\n+                                                 New_Reference_To\n+                                                   (Alloc_Obj_Id, Loc),\n+                                               Expression =>\n+                                                 SS_Allocator)))),\n+                         Else_Statements =>\n+                           New_List (Make_Assignment_Statement (Loc,\n+                                        Name       =>\n+                                          New_Reference_To\n+                                            (Alloc_Obj_Id, Loc),\n+                                        Expression =>\n+                                          Heap_Allocator)));\n+\n+                     --  If a separate initialization assignment was created\n+                     --  earlier, append that following the assignment of the\n+                     --  implicit access formal to the access object, to ensure\n+                     --  that the return object is initialized in that case.\n+\n+                     if Present (Init_Assignment) then\n+                        Append_To\n+                          (Then_Statements (Alloc_If_Stmt),\n+                           Init_Assignment);\n+                     end if;\n+\n+                     Insert_After_And_Analyze (Alloc_Obj_Decl, Alloc_If_Stmt);\n+\n+                     --  Remember the local access object for use in the\n+                     --  dereference of the renaming created below.\n+\n+                     Object_Access := Alloc_Obj_Id;\n+                  end;\n                end if;\n+\n+               --  Replace the return object declaration with a renaming of a\n+               --  dereference of the access value designating the return\n+               --  object.\n+\n+               Obj_Acc_Deref :=\n+                 Make_Explicit_Dereference (Loc,\n+                   Prefix => New_Reference_To (Object_Access, Loc));\n+\n+               Rewrite (Return_Object_Decl,\n+                 Make_Object_Renaming_Declaration (Loc,\n+                   Defining_Identifier => Return_Obj_Id,\n+                   Access_Definition   => Empty,\n+                   Subtype_Mark        => New_Occurrence_Of\n+                                            (Return_Obj_Typ, Loc),\n+                   Name                => Obj_Acc_Deref));\n+\n+               Set_Renamed_Object (Return_Obj_Id, Obj_Acc_Deref);\n             end;\n          end if;\n \n@@ -2622,8 +2892,8 @@ package body Exp_Ch5 is\n    -- Expand_N_If_Statement --\n    ---------------------------\n \n-   --  First we deal with the case of C and Fortran convention boolean\n-   --  values, with zero/non-zero semantics.\n+   --  First we deal with the case of C and Fortran convention boolean values,\n+   --  with zero/non-zero semantics.\n \n    --  Second, we deal with the obvious rewriting for the cases where the\n    --  condition of the IF is known at compile time to be True or False.\n@@ -2647,8 +2917,8 @@ package body Exp_Ch5 is\n    --     end if;\n \n    --  This rewriting is needed if at least one elsif part has a non-empty\n-   --  Condition_Actions list. We also do the same processing if there is\n-   --  a constant condition in an elsif part (in conjunction with the first\n+   --  Condition_Actions list. We also do the same processing if there is a\n+   --  constant condition in an elsif part (in conjunction with the first\n    --  processing step mentioned above, for the recursive call made to deal\n    --  with the created inner if, this deals with properly optimizing the\n    --  cases of constant elsif conditions).\n@@ -2668,8 +2938,8 @@ package body Exp_Ch5 is\n \n       while Compile_Time_Known_Value (Condition (N)) loop\n \n-         --  If condition is True, we can simply rewrite the if statement\n-         --  now by replacing it by the series of then statements.\n+         --  If condition is True, we can simply rewrite the if statement now\n+         --  by replacing it by the series of then statements.\n \n          if Is_True (Expr_Value (Condition (N))) then\n \n@@ -2687,19 +2957,19 @@ package body Exp_Ch5 is\n          --  the Then statements\n \n          else\n-            --  We do not delete the condition if constant condition\n-            --  warnings are enabled, since otherwise we end up deleting\n-            --  the desired warning. Of course the backend will get rid\n-            --  of this True/False test anyway, so nothing is lost here.\n+            --  We do not delete the condition if constant condition warnings\n+            --  are enabled, since otherwise we end up deleting the desired\n+            --  warning. Of course the backend will get rid of this True/False\n+            --  test anyway, so nothing is lost here.\n \n             if not Constant_Condition_Warnings then\n                Kill_Dead_Code (Condition (N));\n             end if;\n \n             Kill_Dead_Code (Then_Statements (N), Warn_On_Deleted_Code);\n \n-            --  If there are no elsif statements, then we simply replace\n-            --  the entire if statement by the sequence of else statements.\n+            --  If there are no elsif statements, then we simply replace the\n+            --  entire if statement by the sequence of else statements.\n \n             if No (Elsif_Parts (N)) then\n                if No (Else_Statements (N))\n@@ -2715,9 +2985,9 @@ package body Exp_Ch5 is\n \n                return;\n \n-            --  If there are elsif statements, the first of them becomes\n-            --  the if/then section of the rebuilt if statement This is\n-            --  the case where we loop to reprocess this copied condition.\n+            --  If there are elsif statements, the first of them becomes the\n+            --  if/then section of the rebuilt if statement This is the case\n+            --  where we loop to reprocess this copied condition.\n \n             else\n                Hed := Remove_Head (Elsif_Parts (N));\n@@ -2747,18 +3017,18 @@ package body Exp_Ch5 is\n          while Present (E) loop\n             Adjust_Condition (Condition (E));\n \n-            --  If there are condition actions, then we rewrite the if\n-            --  statement as indicated above. We also do the same rewrite\n-            --  if the condition is True or False. The further processing\n-            --  of this constant condition is then done by the recursive\n-            --  call to expand the newly created if statement\n+            --  If there are condition actions, then rewrite the if statement\n+            --  as indicated above. We also do the same rewrite for a True or\n+            --  False condition. The further processing of this constant\n+            --  condition is then done by the recursive call to expand the\n+            --  newly created if statement\n \n             if Present (Condition_Actions (E))\n               or else Compile_Time_Known_Value (Condition (E))\n             then\n-               --  Note this is not an implicit if statement, since it is\n-               --  part of an explicit if statement in the source (or of an\n-               --  implicit if statement that has already been tested).\n+               --  Note this is not an implicit if statement, since it is part\n+               --  of an explicit if statement in the source (or of an implicit\n+               --  if statement that has already been tested).\n \n                New_If :=\n                  Make_If_Statement (Sloc (E),\n@@ -2913,9 +3183,9 @@ package body Exp_Ch5 is\n       --  range bounds here, since they were frozen with constant declarations\n       --  and it is during that process that the validity checking is done.\n \n-      --  Handle the case where we have a for loop with the range type being\n-      --  an enumeration type with non-standard representation. In this case\n-      --  we expand:\n+      --  Handle the case where we have a for loop with the range type being an\n+      --  enumeration type with non-standard representation. In this case we\n+      --  expand:\n \n       --    for x in [reverse] a .. b loop\n       --       ...\n@@ -2952,8 +3222,8 @@ package body Exp_Ch5 is\n               Make_Defining_Identifier (Loc,\n                 Chars => New_External_Name (Chars (Loop_Id), 'P'));\n \n-            --  If the type has a contiguous representation, successive\n-            --  values can be generated as offsets from the first literal.\n+            --  If the type has a contiguous representation, successive values\n+            --  can be generated as offsets from the first literal.\n \n             if Has_Contiguous_Rep (Btype) then\n                Expr :=\n@@ -3033,8 +3303,8 @@ package body Exp_Ch5 is\n             Analyze (N);\n          end;\n \n-      --  Second case, if we have a while loop with Condition_Actions set,\n-      --  then we change it into a plain loop:\n+      --  Second case, if we have a while loop with Condition_Actions set, then\n+      --  we change it into a plain loop:\n \n       --    while C loop\n       --       ...\n@@ -3064,10 +3334,10 @@ package body Exp_Ch5 is\n             Prepend (ES, Statements (N));\n             Insert_List_Before (ES, Condition_Actions (Isc));\n \n-            --  This is not an implicit loop, since it is generated in\n-            --  response to the loop statement being processed. If this\n-            --  is itself implicit, the restriction has already been\n-            --  checked. If not, it is an explicit loop.\n+            --  This is not an implicit loop, since it is generated in response\n+            --  to the loop statement being processed. If this is itself\n+            --  implicit, the restriction has already been checked. If not,\n+            --  it is an explicit loop.\n \n             Rewrite (N,\n               Make_Loop_Statement (Sloc (N),\n@@ -3167,8 +3437,8 @@ package body Exp_Ch5 is\n \n          pragma Assert (Is_Entry (Scope_Id));\n \n-         --  Look at the enclosing block to see whether the return is from\n-         --  an accept statement or an entry body.\n+         --  Look at the enclosing block to see whether the return is from an\n+         --  accept statement or an entry body.\n \n          for J in reverse 0 .. Cur_Idx loop\n             Scope_Id := Scope_Stack.Table (J).Entity;\n@@ -3249,9 +3519,9 @@ package body Exp_Ch5 is\n \n       --  Deal with returning variable length objects and controlled types\n \n-      --  Nothing to do if we are returning by reference, or this is not a\n-      --  type that requires special processing (indicated by the fact that\n-      --  it requires a cleanup scope for the secondary stack case).\n+      --  Nothing to do if we are returning by reference, or this is not type\n+      --  that requires special processing (indicated by the fact that it\n+      --  requires a cleanup scope for the secondary stack case).\n \n       if Is_Inherently_Limited_Type (T) then\n          null;\n@@ -3282,158 +3552,6 @@ package body Exp_Ch5 is\n             end if;\n          end;\n \n-      --  Case of secondary stack not used\n-\n-      elsif Function_Returns_With_DSP (Scope_Id) then\n-\n-         --  The DSP method is no longer in use. We would like to ignore DSP\n-         --  while implementing AI-318; hence the raise below.\n-\n-         if True then\n-            raise Program_Error;\n-         end if;\n-\n-         --  Here what we need to do is to always return by reference, since\n-         --  we will return with the stack pointer depressed. We may need to\n-         --  do a copy to a local temporary before doing this return.\n-\n-         No_Secondary_Stack_Case : declare\n-            Local_Copy_Required : Boolean := False;\n-            --  Set to True if a local copy is required\n-\n-            Copy_Ent : Entity_Id;\n-            --  Used for the target entity if a copy is required\n-\n-            Decl : Node_Id;\n-            --  Declaration used to create copy if needed\n-\n-            procedure Test_Copy_Required (Expr : Node_Id);\n-            --  Determines if Expr represents a return value for which a\n-            --  copy is required. More specifically, a copy is not required\n-            --  if Expr represents an object or component of an object that\n-            --  is either in the local subprogram frame, or is constant.\n-            --  If a copy is required, then Local_Copy_Required is set True.\n-\n-            ------------------------\n-            -- Test_Copy_Required --\n-            ------------------------\n-\n-            procedure Test_Copy_Required (Expr : Node_Id) is\n-               Ent : Entity_Id;\n-\n-            begin\n-               --  If component, test prefix (object containing component)\n-\n-               if Nkind (Expr) = N_Indexed_Component\n-                    or else\n-                  Nkind (Expr) = N_Selected_Component\n-               then\n-                  Test_Copy_Required (Prefix (Expr));\n-                  return;\n-\n-               --  See if we have an entity name\n-\n-               elsif Is_Entity_Name (Expr) then\n-                  Ent := Entity (Expr);\n-\n-                  --  Constant entity is always OK, no copy required\n-\n-                  if Ekind (Ent) = E_Constant then\n-                     return;\n-\n-                  --  No copy required for local variable\n-\n-                  elsif Ekind (Ent) = E_Variable\n-                    and then Scope (Ent) = Current_Subprogram\n-                  then\n-                     return;\n-                  end if;\n-               end if;\n-\n-               --  All other cases require a copy\n-\n-               Local_Copy_Required := True;\n-            end Test_Copy_Required;\n-\n-         --  Start of processing for No_Secondary_Stack_Case\n-\n-         begin\n-            --  No copy needed if result is from a function call.\n-            --  In this case the result is already being returned by\n-            --  reference with the stack pointer depressed.\n-\n-            --  To make up for a gcc 2.8.1 deficiency (???), we perform\n-            --  the copy for array types if the constrained status of the\n-            --  target type is different from that of the expression.\n-\n-            if Requires_Transient_Scope (T)\n-              and then\n-                (not Is_Array_Type (T)\n-                   or else Is_Constrained (T) = Is_Constrained (Return_Type)\n-                   or else Controlled_Type (T))\n-              and then Nkind (Exp) = N_Function_Call\n-            then\n-               Set_By_Ref (N);\n-\n-            --  We always need a local copy for a controlled type, since\n-            --  we are required to finalize the local value before return.\n-            --  The copy will automatically include the required finalize.\n-            --  Moreover, gigi cannot make this copy, since we need special\n-            --  processing to ensure proper behavior for finalization.\n-\n-            --  Note: the reason we are returning with a depressed stack\n-            --  pointer in the controlled case (even if the type involved\n-            --  is constrained) is that we must make a local copy to deal\n-            --  properly with the requirement that the local result be\n-            --  finalized.\n-\n-            elsif Controlled_Type (Utyp) then\n-               Copy_Ent :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_Internal_Name ('R'));\n-\n-               --  Build declaration to do the copy, and insert it, setting\n-               --  Assignment_OK, because we may be copying a limited type.\n-               --  In addition we set the special flag to inhibit finalize\n-               --  attachment if this is a controlled type (since this attach\n-               --  must be done by the caller, otherwise if we attach it here\n-               --  we will finalize the returned result prematurely).\n-\n-               Decl :=\n-                 Make_Object_Declaration (Loc,\n-                   Defining_Identifier => Copy_Ent,\n-                   Object_Definition   => New_Occurrence_Of (Return_Type, Loc),\n-                   Expression          => Relocate_Node (Exp));\n-\n-               Set_Assignment_OK (Decl);\n-               Set_Delay_Finalize_Attach (Decl);\n-               Insert_Action (N, Decl);\n-\n-               --  Now the actual return uses the copied value\n-\n-               Rewrite (Exp, New_Occurrence_Of (Copy_Ent, Loc));\n-               Analyze_And_Resolve (Exp, Return_Type);\n-\n-               --  Since we have made the copy, gigi does not have to, so\n-               --  we set the By_Ref flag to prevent another copy being made.\n-\n-               Set_By_Ref (N);\n-\n-            --  Non-controlled cases\n-\n-            else\n-               Test_Copy_Required (Exp);\n-\n-               --  If a local copy is required, then gigi will make the\n-               --  copy, otherwise, we can return the result directly,\n-               --  so set By_Ref to suppress the gigi copy.\n-\n-               if not Local_Copy_Required then\n-                  Set_By_Ref (N);\n-               end if;\n-            end if;\n-         end No_Secondary_Stack_Case;\n-\n       --  Here if secondary stack is used\n \n       else\n@@ -3457,12 +3575,12 @@ package body Exp_Ch5 is\n          --  case either the result is already on the secondary stack, or is\n          --  already being returned with the stack pointer depressed and no\n          --  further processing is required except to set the By_Ref flag to\n-         --  ensure that gigi does not attempt an extra unnecessary copy.\n-         --  (actually not just unnecessary but harmfully wrong in the case\n-         --  of a controlled type, where gigi does not know how to do a copy).\n-         --  To make up for a gcc 2.8.1 deficiency (???), we perform\n-         --  the copy for array types if the constrained status of the\n-         --  target type is different from that of the expression.\n+         --  ensure that gigi does not attempt an extra unnecessary copy\n+         --  (actually not just unnecessary but harmfully wrong in the case of\n+         --  a controlled type, where gigi does not know how to do a copy). To\n+         --  make up for a gcc 2.8.1 deficiency (???), we perform the copy for\n+         --  array types if the constrained status of the target type is\n+         --  different from that of the expression.\n \n          if Requires_Transient_Scope (T)\n            and then\n@@ -3474,25 +3592,25 @@ package body Exp_Ch5 is\n          then\n             Set_By_Ref (N);\n \n-            --  Remove side effects from the expression now so that\n-            --  other part of the expander do not have to reanalyze\n-            --  this node without this optimization\n+            --  Remove side effects from the expression now so that other parts\n+            --  of the expander do not have to reanalyze the node without this\n+            --  optimization.\n \n             Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n \n          --  For controlled types, do the allocation on the secondary stack\n          --  manually in order to call adjust at the right time:\n+\n          --    type Anon1 is access Return_Type;\n          --    for Anon1'Storage_pool use ss_pool;\n          --    Anon2 : anon1 := new Return_Type'(expr);\n          --    return Anon2.all;\n+\n          --  We do the same for classwide types that are not potentially\n          --  controlled (by the virtue of restriction No_Finalization) because\n          --  gigi is not able to properly allocate class-wide types.\n \n-         elsif Is_Class_Wide_Type (Utyp)\n-           or else Controlled_Type (Utyp)\n-         then\n+         elsif CW_Or_Controlled_Type (Utyp) then\n             declare\n                Loc        : constant Source_Ptr := Sloc (N);\n                Temp       : constant Entity_Id :=\n@@ -3550,13 +3668,12 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n-      --  Implement the rules of 6.5(8-10), which require a tag check in\n-      --  the case of a limited tagged return type, and tag reassignment\n-      --  for nonlimited tagged results. These actions are needed when\n-      --  the return type is a specific tagged type and the result\n-      --  expression is a conversion or a formal parameter, because in\n-      --  that case the tag of the expression might differ from the tag\n-      --  of the specific result type.\n+      --  Implement the rules of 6.5(8-10), which require a tag check in the\n+      --  case of a limited tagged return type, and tag reassignment for\n+      --  nonlimited tagged results. These actions are needed when the return\n+      --  type is a specific tagged type and the result expression is a\n+      --  conversion or a formal parameter, because in that case the tag of the\n+      --  expression might differ from the tag of the specific result type.\n \n       if Is_Tagged_Type (Utyp)\n         and then not Is_Class_Wide_Type (Utyp)\n@@ -3565,8 +3682,8 @@ package body Exp_Ch5 is\n                     or else (Is_Entity_Name (Exp)\n                                and then Ekind (Entity (Exp)) in Formal_Kind))\n       then\n-         --  When the return type is limited, perform a check that the\n-         --  tag of the result is the same as the tag of the return type.\n+         --  When the return type is limited, perform a check that the tag of\n+         --  the result is the same as the tag of the return type.\n \n          if Is_Limited_Type (Return_Type) then\n             Insert_Action (Exp,\n@@ -3586,14 +3703,13 @@ package body Exp_Ch5 is\n                            Loc))),\n                 Reason => CE_Tag_Check_Failed));\n \n-         --  If the result type is a specific nonlimited tagged type,\n-         --  then we have to ensure that the tag of the result is that\n-         --  of the result type. This is handled by making a copy of the\n-         --  expression in the case where it might have a different tag,\n-         --  namely when the expression is a conversion or a formal\n-         --  parameter. We create a new object of the result type and\n-         --  initialize it from the expression, which will implicitly\n-         --  force the tag to be set appropriately.\n+         --  If the result type is a specific nonlimited tagged type, then we\n+         --  have to ensure that the tag of the result is that of the result\n+         --  type. This is handled by making a copy of the expression in the\n+         --  case where it might have a different tag, namely when the\n+         --  expression is a conversion or a formal parameter. We create a new\n+         --  object of the result type and initialize it from the expression,\n+         --  which will implicitly force the tag to be set appropriately.\n \n          else\n             Result_Id :=\n@@ -3640,16 +3756,10 @@ package body Exp_Ch5 is\n              Condition =>\n                Make_Op_Gt (Loc,\n                  Left_Opnd =>\n-                   Make_Function_Call (Loc,\n-                     Name =>\n-                       New_Reference_To\n-                         (RTE (RE_Get_Access_Level), Loc),\n-                     Parameter_Associations =>\n-                       New_List (Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                      Duplicate_Subexpr (Exp),\n-                                   Attribute_Name =>\n-                                      Name_Tag))),\n+                   Build_Get_Access_Level (Loc,\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => Duplicate_Subexpr (Exp),\n+                       Attribute_Name => Name_Tag)),\n                  Right_Opnd =>\n                    Make_Integer_Literal (Loc,\n                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n@@ -3683,8 +3793,8 @@ package body Exp_Ch5 is\n       if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n          return;\n \n-      --  If it is a nested return within an extended one, replace it\n-      --  with a return of the previously declared return object.\n+      --  If it is a nested return within an extended one, replace it with a\n+      --  return of the previously declared return object.\n \n       elsif Kind = E_Return_Statement then\n          Rewrite (N,\n@@ -3699,8 +3809,8 @@ package body Exp_Ch5 is\n \n       pragma Assert (Is_Entry (Scope_Id));\n \n-      --  Look at the enclosing block to see whether the return is from\n-      --  an accept statement or an entry body.\n+      --  Look at the enclosing block to see whether the return is from an\n+      --  accept statement or an entry body.\n \n       for J in reverse 0 .. Scope_Stack.Last loop\n          Scope_Id := Scope_Stack.Table (J).Entity;\n@@ -3740,8 +3850,8 @@ package body Exp_Ch5 is\n          Rewrite (N, Goto_Stat);\n          Analyze (N);\n \n-      --  If it is a return from an entry body, put a Complete_Entry_Body\n-      --  call in front of the return.\n+      --  If it is a return from an entry body, put a Complete_Entry_Body call\n+      --  in front of the return.\n \n       elsif Is_Protected_Type (Scope_Id) then\n          Call :=\n@@ -3818,25 +3928,20 @@ package body Exp_Ch5 is\n       --  The type of the expression (not necessarily the same as R_Type)\n \n    begin\n-      --  The DSP method is no longer in use\n-\n-      pragma Assert (not Function_Returns_With_DSP (Scope_Id));\n-\n       --  We rewrite \"return <expression>;\" to be:\n \n       --    return _anon_ : <return_subtype> := <expression>\n \n       --  The expansion produced by Expand_N_Extended_Return_Statement will\n-      --  contain simple return statements (for example, a block containing a\n+      --  contain simple return statements (for example, a block containing\n       --  simple return of the return object), which brings us back here with\n       --  Comes_From_Extended_Return_Statement set. To avoid infinite\n       --  recursion, we do not transform into an extended return if\n       --  Comes_From_Extended_Return_Statement is True.\n \n       --  The reason for this design is that for Ada 2005 limited returns, we\n-      --  need to reify the return object, so we can build it \"in place\",\n-      --  and we need a block statement to hang finalization and tasking stuff\n-      --  off of.\n+      --  need to reify the return object, so we can build it \"in place\", and\n+      --  we need a block statement to hang finalization and tasking stuff.\n \n       --  ??? In order to avoid disruption, we avoid translating to extended\n       --  return except in the cases where we really need to (Ada 2005\n@@ -3878,11 +3983,11 @@ package body Exp_Ch5 is\n       --  of an extended return statement (either written by the user, or\n       --  generated by the above code).\n \n-      --  Always normalize C/Fortran boolean result. This is not always\n-      --  necessary, but it seems a good idea to minimize the passing\n-      --  around of non-normalized values, and in any case this handles\n-      --  the processing of barrier functions for protected types, which\n-      --  turn the condition into a return statement.\n+      --  Always normalize C/Fortran boolean result. This is not always needed,\n+      --  but it seems a good idea to minimize the passing around of non-\n+      --  normalized values, and in any case this handles the processing of\n+      --  barrier functions for protected types, which turn the condition into\n+      --  a return statement.\n \n       if Is_Boolean_Type (Exptyp)\n         and then Nonzero_Is_True (Exptyp)\n@@ -3943,18 +4048,6 @@ package body Exp_Ch5 is\n             end if;\n          end;\n \n-      --  Case of secondary stack not used\n-\n-      elsif Function_Returns_With_DSP (Scope_Id) then\n-\n-         --  The DSP method is no longer in use. We would like to ignore DSP\n-         --  while implementing AI-318; hence the following assertion. Keep the\n-         --  old code around in case DSP is revived someday.\n-\n-         pragma Assert (False);\n-\n-         No_Secondary_Stack_Case (N);\n-\n       --  Here if secondary stack is used\n \n       else\n@@ -3989,15 +4082,14 @@ package body Exp_Ch5 is\n            and then\n               (not Is_Array_Type (Exptyp)\n                 or else Is_Constrained (Exptyp) = Is_Constrained (R_Type)\n-                or else Is_Class_Wide_Type (Utyp)\n-                or else Controlled_Type (Exptyp))\n+                or else CW_Or_Controlled_Type (Utyp))\n            and then Nkind (Exp) = N_Function_Call\n          then\n             Set_By_Ref (N);\n \n-            --  Remove side effects from the expression now so that\n-            --  other part of the expander do not have to reanalyze\n-            --  this node without this optimization\n+            --  Remove side effects from the expression now so that other parts\n+            --  of the expander do not have to reanalyze this node without this\n+            --  optimization\n \n             Rewrite (Exp, Duplicate_Subexpr_No_Checks (Exp));\n \n@@ -4013,9 +4105,7 @@ package body Exp_Ch5 is\n          --  controlled (by the virtue of restriction No_Finalization) because\n          --  gigi is not able to properly allocate class-wide types.\n \n-         elsif Is_Class_Wide_Type (Utyp)\n-           or else Controlled_Type (Utyp)\n-         then\n+         elsif CW_Or_Controlled_Type (Utyp) then\n             declare\n                Loc        : constant Source_Ptr := Sloc (N);\n                Temp       : constant Entity_Id :=\n@@ -4073,13 +4163,12 @@ package body Exp_Ch5 is\n          end if;\n       end if;\n \n-      --  Implement the rules of 6.5(8-10), which require a tag check in\n-      --  the case of a limited tagged return type, and tag reassignment\n-      --  for nonlimited tagged results. These actions are needed when\n-      --  the return type is a specific tagged type and the result\n-      --  expression is a conversion or a formal parameter, because in\n-      --  that case the tag of the expression might differ from the tag\n-      --  of the specific result type.\n+      --  Implement the rules of 6.5(8-10), which require a tag check in the\n+      --  case of a limited tagged return type, and tag reassignment for\n+      --  nonlimited tagged results. These actions are needed when the return\n+      --  type is a specific tagged type and the result expression is a\n+      --  conversion or a formal parameter, because in that case the tag of the\n+      --  expression might differ from the tag of the specific result type.\n \n       if Is_Tagged_Type (Utyp)\n         and then not Is_Class_Wide_Type (Utyp)\n@@ -4109,14 +4198,13 @@ package body Exp_Ch5 is\n                            Loc))),\n                 Reason => CE_Tag_Check_Failed));\n \n-         --  If the result type is a specific nonlimited tagged type,\n-         --  then we have to ensure that the tag of the result is that\n-         --  of the result type. This is handled by making a copy of the\n-         --  expression in the case where it might have a different tag,\n-         --  namely when the expression is a conversion or a formal\n-         --  parameter. We create a new object of the result type and\n-         --  initialize it from the expression, which will implicitly\n-         --  force the tag to be set appropriately.\n+         --  If the result type is a specific nonlimited tagged type, then we\n+         --  have to ensure that the tag of the result is that of the result\n+         --  type. This is handled by making a copy of the expression in the\n+         --  case where it might have a different tag, namely when the\n+         --  expression is a conversion or a formal parameter. We create a new\n+         --  object of the result type and initialize it from the expression,\n+         --  which will implicitly force the tag to be set appropriately.\n \n          else\n             declare\n@@ -4168,16 +4256,10 @@ package body Exp_Ch5 is\n              Condition =>\n                Make_Op_Gt (Loc,\n                  Left_Opnd =>\n-                   Make_Function_Call (Loc,\n-                     Name =>\n-                       New_Reference_To\n-                         (RTE (RE_Get_Access_Level), Loc),\n-                     Parameter_Associations =>\n-                       New_List (Make_Attribute_Reference (Loc,\n-                                   Prefix         =>\n-                                      Duplicate_Subexpr (Exp),\n-                                   Attribute_Name =>\n-                                      Name_Tag))),\n+                   Build_Get_Access_Level (Loc,\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => Duplicate_Subexpr (Exp),\n+                     Attribute_Name => Name_Tag)),\n                  Right_Opnd =>\n                    Make_Integer_Literal (Loc,\n                      Scope_Depth (Enclosing_Dynamic_Scope (Scope_Id)))),\n@@ -4200,8 +4282,8 @@ package body Exp_Ch5 is\n       Save_Tag : constant Boolean := Is_Tagged_Type (T)\n                                        and then not No_Ctrl_Actions (N)\n                                        and then not Java_VM;\n-      --  Tags are not saved and restored when Java_VM because JVM tags\n-      --  are represented implicitly in objects.\n+      --  Tags are not saved and restored when Java_VM because JVM tags are\n+      --  represented implicitly in objects.\n \n       Res       : List_Id;\n       Tag_Tmp   : Entity_Id;\n@@ -4271,8 +4353,8 @@ package body Exp_Ch5 is\n       --  specific to each object of the type, not to the value being assigned.\n       --  Thus they need to be left intact during the assignment. We achieve\n       --  this by constructing a Storage_Array subtype, and by overlaying\n-      --  objects of this type on the source and target of the assignment.\n-      --  The assignment is then rewritten to assignments of slices of these\n+      --  objects of this type on the source and target of the assignment. The\n+      --  assignment is then rewritten to assignments of slices of these\n       --  arrays, copying the user data, and leaving the pointers untouched.\n \n       if Ctrl_Act then\n@@ -4306,10 +4388,9 @@ package body Exp_Ch5 is\n               (Rec : Entity_Id;\n                Lo  : Node_Id;\n                Hi  : Node_Id) return Node_Id;\n-            --  Build and return a slice of an array of type S overlaid\n-            --  on object Rec, with bounds specified by Lo and Hi. If either\n-            --  bound is empty, a default of S'First (respectively S'Last)\n-            --  is used.\n+            --  Build and return a slice of an array of type S overlaid on\n+            --  object Rec, with bounds specified by Lo and Hi. If either bound\n+            --  is empty, a default of S'First (respectively S'Last) is used.\n \n             -----------------\n             -- Build_Slice --\n@@ -4328,12 +4409,12 @@ package body Exp_Ch5 is\n                             Make_Attribute_Reference (Loc,\n                               Prefix         => Rec,\n                               Attribute_Name => Name_Address));\n-               --  Access value designating an opaque storage array of\n-               --  type S overlaid on record Rec.\n+               --  Access value designating an opaque storage array of type S\n+               --  overlaid on record Rec.\n \n             begin\n-               --  Compute slice bounds using S'First (1) and S'Last\n-               --  as default values when not specified by the caller.\n+               --  Compute slice bounds using S'First (1) and S'Last as default\n+               --  values when not specified by the caller.\n \n                if No (Lo) then\n                   Lo_Bound := Make_Integer_Literal (Loc, 1);\n@@ -4613,161 +4694,6 @@ package body Exp_Ch5 is\n          return Empty_List;\n    end Make_Tag_Ctrl_Assignment;\n \n-   -----------------------------\n-   -- No_Secondary_Stack_Case --\n-   -----------------------------\n-\n-   procedure No_Secondary_Stack_Case (N : Node_Id) is\n-      pragma Assert (False); --  DSP method no longer in use\n-\n-      Loc         : constant Source_Ptr := Sloc (N);\n-      Exp         : constant Node_Id    := Expression (N);\n-      T           : constant Entity_Id  := Etype (Exp);\n-      Scope_Id    : constant Entity_Id  :=\n-                      Return_Applies_To (Return_Statement_Entity (N));\n-      Return_Type : constant Entity_Id  := Etype (Scope_Id);\n-      Utyp        : constant Entity_Id  := Underlying_Type (Return_Type);\n-\n-      --  Here what we need to do is to always return by reference, since\n-      --  we will return with the stack pointer depressed. We may need to\n-      --  do a copy to a local temporary before doing this return.\n-\n-      Local_Copy_Required : Boolean := False;\n-      --  Set to True if a local copy is required\n-\n-      Copy_Ent : Entity_Id;\n-      --  Used for the target entity if a copy is required\n-\n-      Decl : Node_Id;\n-      --  Declaration used to create copy if needed\n-\n-      procedure Test_Copy_Required (Expr : Node_Id);\n-      --  Determines if Expr represents a return value for which a\n-      --  copy is required. More specifically, a copy is not required\n-      --  if Expr represents an object or component of an object that\n-      --  is either in the local subprogram frame, or is constant.\n-      --  If a copy is required, then Local_Copy_Required is set True.\n-\n-      ------------------------\n-      -- Test_Copy_Required --\n-      ------------------------\n-\n-      procedure Test_Copy_Required (Expr : Node_Id) is\n-         Ent : Entity_Id;\n-\n-      begin\n-         --  If component, test prefix (object containing component)\n-\n-         if Nkind (Expr) = N_Indexed_Component\n-              or else\n-            Nkind (Expr) = N_Selected_Component\n-         then\n-            Test_Copy_Required (Prefix (Expr));\n-            return;\n-\n-         --  See if we have an entity name\n-\n-         elsif Is_Entity_Name (Expr) then\n-            Ent := Entity (Expr);\n-\n-            --  Constant entity is always OK, no copy required\n-\n-            if Ekind (Ent) = E_Constant then\n-               return;\n-\n-            --  No copy required for local variable\n-\n-            elsif Ekind (Ent) = E_Variable\n-              and then Scope (Ent) = Current_Subprogram\n-            then\n-               return;\n-            end if;\n-         end if;\n-\n-         --  All other cases require a copy\n-\n-         Local_Copy_Required := True;\n-      end Test_Copy_Required;\n-\n-   --  Start of processing for No_Secondary_Stack_Case\n-\n-   begin\n-      --  No copy needed if result is from a function call.\n-      --  In this case the result is already being returned by\n-      --  reference with the stack pointer depressed.\n-\n-      --  To make up for a gcc 2.8.1 deficiency (???), we perform\n-      --  the copy for array types if the constrained status of the\n-      --  target type is different from that of the expression.\n-\n-      if Requires_Transient_Scope (T)\n-        and then\n-          (not Is_Array_Type (T)\n-             or else Is_Constrained (T) = Is_Constrained (Return_Type)\n-             or else Controlled_Type (T))\n-        and then Nkind (Exp) = N_Function_Call\n-      then\n-         Set_By_Ref (N);\n-\n-      --  We always need a local copy for a controlled type, since\n-      --  we are required to finalize the local value before return.\n-      --  The copy will automatically include the required finalize.\n-      --  Moreover, gigi cannot make this copy, since we need special\n-      --  processing to ensure proper behavior for finalization.\n-\n-      --  Note: the reason we are returning with a depressed stack\n-      --  pointer in the controlled case (even if the type involved\n-      --  is constrained) is that we must make a local copy to deal\n-      --  properly with the requirement that the local result be\n-      --  finalized.\n-\n-      elsif Controlled_Type (Utyp) then\n-         Copy_Ent :=\n-           Make_Defining_Identifier (Loc,\n-             Chars => New_Internal_Name ('R'));\n-\n-         --  Build declaration to do the copy, and insert it, setting\n-         --  Assignment_OK, because we may be copying a limited type.\n-         --  In addition we set the special flag to inhibit finalize\n-         --  attachment if this is a controlled type (since this attach\n-         --  must be done by the caller, otherwise if we attach it here\n-         --  we will finalize the returned result prematurely).\n-\n-         Decl :=\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => Copy_Ent,\n-             Object_Definition   => New_Occurrence_Of (Return_Type, Loc),\n-             Expression          => Relocate_Node (Exp));\n-\n-         Set_Assignment_OK (Decl);\n-         Set_Delay_Finalize_Attach (Decl);\n-         Insert_Action (N, Decl);\n-\n-         --  Now the actual return uses the copied value\n-\n-         Rewrite (Exp, New_Occurrence_Of (Copy_Ent, Loc));\n-         Analyze_And_Resolve (Exp, Return_Type);\n-\n-         --  Since we have made the copy, gigi does not have to, so\n-         --  we set the By_Ref flag to prevent another copy being made.\n-\n-         Set_By_Ref (N);\n-\n-      --  Non-controlled cases\n-\n-      else\n-         Test_Copy_Required (Exp);\n-\n-         --  If a local copy is required, then gigi will make the\n-         --  copy, otherwise, we can return the result directly,\n-         --  so set By_Ref to suppress the gigi copy.\n-\n-         if not Local_Copy_Required then\n-            Set_By_Ref (N);\n-         end if;\n-      end if;\n-   end No_Secondary_Stack_Case;\n-\n    ------------------------------------\n    -- Possible_Bit_Aligned_Component --\n    ------------------------------------\n@@ -4821,9 +4747,9 @@ package body Exp_Ch5 is\n                end if;\n             end;\n \n-         --  If we have neither a record nor array component, it means that\n-         --  we have fallen off the top testing prefixes recursively, and\n-         --  we now have a stand alone object, where we don't have a problem\n+         --  If we have neither a record nor array component, it means that we\n+         --  have fallen off the top testing prefixes recursively, and we now\n+         --  have a stand alone object, where we don't have a problem.\n \n          when others =>\n             return False;"}, {"sha": "e1d245b7108bb36e0c0afa05f12702865ea84d61", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 734, "deletions": 184, "changes": 918, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -30,6 +30,7 @@ with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n with Elists;   use Elists;\n+with Exp_Atag; use Exp_Atag;\n with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -62,7 +63,6 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Mech; use Sem_Mech;\n with Sem_Res;  use Sem_Res;\n-with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n@@ -81,11 +81,53 @@ package body Exp_Ch6 is\n    procedure Add_Access_Actual_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n-      Return_Object : Node_Id);\n+      Return_Object : Node_Id;\n+      Is_Access     : Boolean := False);\n    --  Ada 2005 (AI-318-02): Apply the Unrestricted_Access attribute to the\n    --  object name given by Return_Object and add the attribute to the end of\n    --  the actual parameter list associated with the build-in-place function\n-   --  call denoted by Function_Call.\n+   --  call denoted by Function_Call. However, if Is_Access is True, then\n+   --  Return_Object is already an access expression, in which case it's passed\n+   --  along directly to the build-in-place function. Finally, if Return_Object\n+   --  is empty, then pass a null literal as the actual.\n+\n+   procedure Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+     (Function_Call  : Node_Id;\n+      Function_Id    : Entity_Id;\n+      Alloc_Form     : BIP_Allocation_Form := Unspecified;\n+      Alloc_Form_Exp : Node_Id             := Empty);\n+   --  Ada 2005 (AI-318-02): Add an actual indicating the form of allocation,\n+   --  if any, to be done by a build-in-place function. If Alloc_Form_Exp is\n+   --  present, then use it, otherwise pass a literal corresponding to the\n+   --  Alloc_Form parameter (which must not be Unspecified in that case).\n+\n+   procedure Add_Extra_Actual_To_Call\n+     (Subprogram_Call : Node_Id;\n+      Extra_Formal    : Entity_Id;\n+      Extra_Actual    : Node_Id);\n+   --  Adds Extra_Actual as a named parameter association for the formal\n+   --  Extra_Formal in Subprogram_Call.\n+\n+   procedure Add_Final_List_Actual_To_Build_In_Place_Call\n+     (Function_Call : Node_Id;\n+      Function_Id   : Entity_Id);\n+   --  Ada 2005 (AI-318-02): For a build-in-place call, if the result type has\n+   --  controlled parts, add an actual parameter that is a pointer to caller's\n+   --  finalization list.\n+\n+   procedure Add_Task_Actuals_To_Build_In_Place_Call\n+     (Function_Call : Node_Id;\n+      Function_Id   : Entity_Id;\n+      Master_Actual : Node_Id);\n+   --  Ada 2005 (AI-318-02): For a build-in-place call, if the result type\n+   --  contains tasks, add two actual parameters: the master, and a pointer to\n+   --  the caller's activation chain. Master_Actual is the actual parameter\n+   --  expression to pass for the master. In most cases, this is the current\n+   --  master (_master). The two exceptions are: If the function call is the\n+   --  initialization expression for an allocator, we pass the master of the\n+   --  access type. If the function call is the initialization expression for\n+   --  a return object, we pass along the master passed in by the caller. The\n+   --  activation chain to pass is always the local one.\n \n    procedure Check_Overriding_Operation (Subp : Entity_Id);\n    --  Subp is a dispatching operation. Check whether it may override an\n@@ -172,66 +214,296 @@ package body Exp_Ch6 is\n    procedure Add_Access_Actual_To_Build_In_Place_Call\n      (Function_Call : Node_Id;\n       Function_Id   : Entity_Id;\n-      Return_Object : Node_Id)\n+      Return_Object : Node_Id;\n+      Is_Access     : Boolean := False)\n    is\n       Loc            : constant Source_Ptr := Sloc (Function_Call);\n       Obj_Address    : Node_Id;\n-      Obj_Acc_Formal : Node_Id;\n-      Param_Assoc    : Node_Id;\n+      Obj_Acc_Formal : Entity_Id;\n \n    begin\n-      --  Locate the implicit access parameter in the called function. Maybe\n-      --  we should be testing for the name of the access parameter (or perhaps\n-      --  better, each implicit formal for build-in-place could have an\n-      --  identifying flag, or a Uint attribute to identify it). ???\n+      --  Locate the implicit access parameter in the called function\n \n-      Obj_Acc_Formal := Extra_Formals (Function_Id);\n+      Obj_Acc_Formal := Build_In_Place_Formal (Function_Id, BIP_Object_Access);\n \n-      while Present (Obj_Acc_Formal) loop\n-         exit when Ekind (Etype (Obj_Acc_Formal)) = E_Anonymous_Access_Type;\n-         Next_Formal_With_Extras (Obj_Acc_Formal);\n-      end loop;\n+      --  If no return object is provided, then pass null\n+\n+      if not Present (Return_Object) then\n+         Obj_Address := Make_Null (Loc);\n \n-      pragma Assert (Present (Obj_Acc_Formal));\n+      --  If Return_Object is already an expression of an access type, then use\n+      --  it directly, since it must be an access value denoting the return\n+      --  object, and couldn't possibly be the return object itself.\n+\n+      elsif Is_Access then\n+         Obj_Address := Return_Object;\n \n       --  Apply Unrestricted_Access to caller's return object\n \n-      Obj_Address :=\n-         Make_Attribute_Reference (Loc,\n-           Prefix         => Return_Object,\n-           Attribute_Name => Name_Unrestricted_Access);\n+      else\n+         Obj_Address :=\n+            Make_Attribute_Reference (Loc,\n+              Prefix         => Return_Object,\n+              Attribute_Name => Name_Unrestricted_Access);\n+      end if;\n \n       Analyze_And_Resolve (Obj_Address, Etype (Obj_Acc_Formal));\n \n       --  Build the parameter association for the new actual and add it to the\n       --  end of the function's actuals.\n \n+      Add_Extra_Actual_To_Call (Function_Call, Obj_Acc_Formal, Obj_Address);\n+   end Add_Access_Actual_To_Build_In_Place_Call;\n+\n+   --------------------------------------------------\n+   -- Add_Alloc_Form_Actual_To_Build_In_Place_Call --\n+   --------------------------------------------------\n+\n+   procedure Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+     (Function_Call  : Node_Id;\n+      Function_Id    : Entity_Id;\n+      Alloc_Form     : BIP_Allocation_Form := Unspecified;\n+      Alloc_Form_Exp : Node_Id             := Empty)\n+   is\n+      Loc               : constant Source_Ptr := Sloc (Function_Call);\n+      Alloc_Form_Actual : Node_Id;\n+      Alloc_Form_Formal : Node_Id;\n+\n+   begin\n+      --  Locate the implicit allocation form parameter in the called function.\n+      --  Maybe it would be better for each implicit formal of a build-in-place\n+      --  function to have a flag or a Uint attribute to identify it. ???\n+\n+      Alloc_Form_Formal := Build_In_Place_Formal (Function_Id, BIP_Alloc_Form);\n+\n+      if Present (Alloc_Form_Exp) then\n+         pragma Assert (Alloc_Form = Unspecified);\n+\n+         Alloc_Form_Actual := Alloc_Form_Exp;\n+\n+      else\n+         pragma Assert (Alloc_Form /= Unspecified);\n+\n+         Alloc_Form_Actual :=\n+           Make_Integer_Literal (Loc,\n+             Intval => UI_From_Int (BIP_Allocation_Form'Pos (Alloc_Form)));\n+      end if;\n+\n+      Analyze_And_Resolve (Alloc_Form_Actual, Etype (Alloc_Form_Formal));\n+\n+      --  Build the parameter association for the new actual and add it to the\n+      --  end of the function's actuals.\n+\n+      Add_Extra_Actual_To_Call\n+        (Function_Call, Alloc_Form_Formal, Alloc_Form_Actual);\n+   end Add_Alloc_Form_Actual_To_Build_In_Place_Call;\n+\n+   ------------------------------\n+   -- Add_Extra_Actual_To_Call --\n+   ------------------------------\n+\n+   procedure Add_Extra_Actual_To_Call\n+     (Subprogram_Call : Node_Id;\n+      Extra_Formal    : Entity_Id;\n+      Extra_Actual    : Node_Id)\n+   is\n+      Loc         : constant Source_Ptr := Sloc (Subprogram_Call);\n+      Param_Assoc : Node_Id;\n+\n+   begin\n       Param_Assoc :=\n         Make_Parameter_Association (Loc,\n-          Selector_Name             => New_Occurrence_Of (Obj_Acc_Formal, Loc),\n-          Explicit_Actual_Parameter => Obj_Address);\n+          Selector_Name             => New_Occurrence_Of (Extra_Formal, Loc),\n+          Explicit_Actual_Parameter => Extra_Actual);\n \n-      Set_Parent (Param_Assoc, Function_Call);\n-      Set_Parent (Obj_Address, Param_Assoc);\n+      Set_Parent (Param_Assoc, Subprogram_Call);\n+      Set_Parent (Extra_Actual, Param_Assoc);\n \n-      if Present (Parameter_Associations (Function_Call)) then\n-         if Nkind (Last (Parameter_Associations (Function_Call))) =\n+      if Present (Parameter_Associations (Subprogram_Call)) then\n+         if Nkind (Last (Parameter_Associations (Subprogram_Call))) =\n               N_Parameter_Association\n          then\n-            Set_Next_Named_Actual\n-              (Last (Parameter_Associations (Function_Call)),\n-               Obj_Address);\n+\n+            --  Find last named actual, and append\n+\n+            declare\n+               L : Node_Id;\n+            begin\n+               L := First_Actual (Subprogram_Call);\n+               while Present (L) loop\n+                  if No (Next_Actual (L)) then\n+                     Set_Next_Named_Actual (Parent (L), Extra_Actual);\n+                     exit;\n+                  end if;\n+                  Next_Actual (L);\n+               end loop;\n+            end;\n+\n          else\n-            Set_First_Named_Actual (Function_Call, Obj_Address);\n+            Set_First_Named_Actual (Subprogram_Call, Extra_Actual);\n          end if;\n \n-         Append (Param_Assoc, To => Parameter_Associations (Function_Call));\n+         Append (Param_Assoc, To => Parameter_Associations (Subprogram_Call));\n \n       else\n-         Set_Parameter_Associations (Function_Call, New_List (Param_Assoc));\n-         Set_First_Named_Actual (Function_Call, Obj_Address);\n+         Set_Parameter_Associations (Subprogram_Call, New_List (Param_Assoc));\n+         Set_First_Named_Actual (Subprogram_Call, Extra_Actual);\n       end if;\n-   end Add_Access_Actual_To_Build_In_Place_Call;\n+   end Add_Extra_Actual_To_Call;\n+\n+   --------------------------------------------------\n+   -- Add_Final_List_Actual_To_Build_In_Place_Call --\n+   --------------------------------------------------\n+\n+   procedure Add_Final_List_Actual_To_Build_In_Place_Call\n+     (Function_Call : Node_Id;\n+      Function_Id   : Entity_Id)\n+   is\n+      Loc               : constant Source_Ptr := Sloc (Function_Call);\n+      Final_List        : Node_Id;\n+      Final_List_Actual : Node_Id;\n+      Final_List_Formal : Node_Id;\n+\n+   begin\n+      --  No such extra parameter is needed if there are no controlled parts\n+\n+      if not (Is_Controlled (Etype (Function_Id))\n+              or else Has_Controlled_Component (Etype (Function_Id))) then\n+         return;\n+      end if;\n+\n+      --  Locate implicit finalization list parameter in the called function\n+\n+      Final_List_Formal := Build_In_Place_Formal (Function_Id, BIP_Final_List);\n+\n+      --  Create the actual which is a pointer to the current finalization list\n+\n+      Final_List := Find_Final_List (Current_Scope);\n+      Final_List_Actual :=\n+        Make_Attribute_Reference (Loc,\n+          Prefix         => Final_List,\n+          Attribute_Name => Name_Unrestricted_Access);\n+\n+      Analyze_And_Resolve (Final_List_Actual, Etype (Final_List_Formal));\n+\n+      --  Build the parameter association for the new actual and add it to the\n+      --  end of the function's actuals.\n+\n+      Add_Extra_Actual_To_Call\n+        (Function_Call, Final_List_Formal, Final_List_Actual);\n+   end Add_Final_List_Actual_To_Build_In_Place_Call;\n+\n+   ---------------------------------------------\n+   -- Add_Task_Actuals_To_Build_In_Place_Call --\n+   ---------------------------------------------\n+\n+   procedure Add_Task_Actuals_To_Build_In_Place_Call\n+     (Function_Call : Node_Id;\n+      Function_Id   : Entity_Id;\n+      Master_Actual : Node_Id)\n+      --  Note: Master_Actual can be Empty, but only if there are no tasks\n+   is\n+      Loc               : constant Source_Ptr := Sloc (Function_Call);\n+\n+   begin\n+      --  No such extra parameters are needed if there are no tasks\n+\n+      if not Has_Task (Etype (Function_Id)) then\n+         return;\n+      end if;\n+\n+      --  The master\n+\n+      declare\n+         Master_Formal : Node_Id;\n+      begin\n+         --  Locate implicit master parameter in the called function\n+\n+         Master_Formal := Build_In_Place_Formal (Function_Id, BIP_Master);\n+\n+         Analyze_And_Resolve (Master_Actual, Etype (Master_Formal));\n+\n+         --  Build the parameter association for the new actual and add it to\n+         --  the end of the function's actuals.\n+\n+         Add_Extra_Actual_To_Call\n+           (Function_Call, Master_Formal, Master_Actual);\n+      end;\n+\n+      --  The activation chain\n+\n+      declare\n+         Activation_Chain_Actual : Node_Id;\n+         Activation_Chain_Formal : Node_Id;\n+      begin\n+         --  Locate implicit activation chain parameter in the called function\n+\n+         Activation_Chain_Formal := Build_In_Place_Formal\n+           (Function_Id, BIP_Activation_Chain);\n+\n+         --  Create the actual which is a pointer to the current activation\n+         --  chain\n+\n+         Activation_Chain_Actual :=\n+           Make_Attribute_Reference (Loc,\n+             Prefix         => Make_Identifier (Loc, Name_uChain),\n+             Attribute_Name => Name_Unrestricted_Access);\n+\n+         Analyze_And_Resolve\n+           (Activation_Chain_Actual, Etype (Activation_Chain_Formal));\n+\n+         --  Build the parameter association for the new actual and add it to\n+         --  the end of the function's actuals.\n+\n+         Add_Extra_Actual_To_Call\n+           (Function_Call, Activation_Chain_Formal, Activation_Chain_Actual);\n+      end;\n+   end Add_Task_Actuals_To_Build_In_Place_Call;\n+\n+   -----------------------\n+   -- BIP_Formal_Suffix --\n+   -----------------------\n+\n+   function BIP_Formal_Suffix (Kind : BIP_Formal_Kind) return String is\n+   begin\n+      case Kind is\n+         when BIP_Alloc_Form       =>\n+            return \"BIPalloc\";\n+         when BIP_Final_List       =>\n+            return \"BIPfinallist\";\n+         when BIP_Master           =>\n+            return \"BIPmaster\";\n+         when BIP_Activation_Chain =>\n+            return \"BIPactivationchain\";\n+         when BIP_Object_Access    =>\n+            return \"BIPaccess\";\n+      end case;\n+   end BIP_Formal_Suffix;\n+\n+   ---------------------------\n+   -- Build_In_Place_Formal --\n+   ---------------------------\n+\n+   function Build_In_Place_Formal\n+     (Func : Entity_Id;\n+      Kind : BIP_Formal_Kind) return Entity_Id\n+   is\n+      Extra_Formal : Entity_Id := Extra_Formals (Func);\n+\n+   begin\n+      --  Maybe it would be better for each implicit formal of a build-in-place\n+      --  function to have a flag or a Uint attribute to identify it. ???\n+\n+      loop\n+         exit when\n+           Chars (Extra_Formal) =\n+             New_External_Name (Chars (Func), BIP_Formal_Suffix (Kind));\n+         Next_Formal_With_Extras (Extra_Formal);\n+      end loop;\n+\n+      pragma Assert (Present (Extra_Formal));\n+      return Extra_Formal;\n+   end Build_In_Place_Formal;\n \n    --------------------------------\n    -- Check_Overriding_Operation --\n@@ -1088,10 +1360,10 @@ package body Exp_Ch6 is\n             --  Ada 2005 (AI-318-02): If the actual parameter is a call to a\n             --  build-in-place function, then a temporary return object needs\n             --  to be created and access to it must be passed to the function.\n-            --  Currently we limit such functions to those with constrained\n-            --  inherently limited result subtypes, but eventually we plan to\n-            --  expand the allowed forms of funtions that are treated as\n-            --  build-in-place.\n+            --  Currently we limit such functions to those with inherently\n+            --  limited result subtypes, but eventually we plan to expand the\n+            --  functions that are treated as build-in-place to include other\n+            --  composite result types.\n \n             if Ada_Version >= Ada_05\n               and then Is_Build_In_Place_Function_Call (Actual)\n@@ -2001,8 +2273,11 @@ package body Exp_Ch6 is\n               Make_Implicit_If_Statement (N,\n                 Condition       =>\n                   Make_Op_Not (Loc,\n-                    Get_Remotely_Callable\n-                      (Duplicate_Subexpr_Move_Checks (Actual))),\n+                    Build_Get_Remotely_Callable (Loc,\n+                      Make_Selected_Component (Loc,\n+                        Prefix => Duplicate_Subexpr_Move_Checks (Actual),\n+                        Selector_Name =>\n+                          Make_Identifier (Loc, Name_uTag)))),\n                 Then_Statements => New_List (\n                   Make_Raise_Program_Error (Loc,\n                     Reason => PE_Illegal_RACW_E_4_18))));\n@@ -2161,7 +2436,7 @@ package body Exp_Ch6 is\n \n          Set_Entity (Name (N), Parent_Subp);\n \n-         if Is_Abstract (Parent_Subp)\n+         if Is_Abstract_Subprogram (Parent_Subp)\n            and then not In_Instance\n          then\n             Error_Msg_NE\n@@ -2270,8 +2545,8 @@ package body Exp_Ch6 is\n \n       --  Handle case of access to protected subprogram type\n \n-         if Ekind (Base_Type (Etype (Prefix (Name (N))))) =\n-                               E_Access_Protected_Subprogram_Type\n+         if Is_Access_Protected_Subprogram_Type\n+            (Base_Type (Etype (Prefix (Name (N)))))\n          then\n             --  If this is a call through an access to protected operation,\n             --  the prefix has the form (object'address, operation'access).\n@@ -2717,6 +2992,10 @@ package body Exp_Ch6 is\n       --  If the type returned by the function is unconstrained and the\n       --  call can be inlined, special processing is required.\n \n+      function Is_Null_Procedure return Boolean;\n+      --  Predicate to recognize stubbed procedures and null procedures, for\n+      --  which there is no need for the full inlining mechanism.\n+\n       procedure Make_Exit_Label;\n       --  Build declaration for exit label to be used in Return statements\n \n@@ -2743,6 +3022,50 @@ package body Exp_Ch6 is\n       function Formal_Is_Used_Once (Formal : Entity_Id) return Boolean;\n       --  Determine whether a formal parameter is used only once in Orig_Bod\n \n+      -----------------------\n+      -- Is_Null_Procedure --\n+      -----------------------\n+\n+      function Is_Null_Procedure return Boolean is\n+         Decl : constant Node_Id := Unit_Declaration_Node (Subp);\n+\n+      begin\n+         if Ekind (Subp) /= E_Procedure then\n+            return False;\n+\n+         elsif Nkind (Orig_Bod) /= N_Subprogram_Body then\n+            return False;\n+\n+         --  Check if this is an ada 2005 null procedure\n+\n+         elsif Nkind (Decl) = N_Subprogram_Declaration\n+           and then Null_Present (Specification (Decl))\n+         then\n+            return True;\n+\n+         --  Check if the body contains only a null statement, followed by the\n+         --  return statement added during expansion.\n+\n+         else\n+            declare\n+               Stat : constant Node_Id :=\n+                        First\n+                          (Statements (Handled_Statement_Sequence (Orig_Bod)));\n+\n+               Stat2 : constant Node_Id := Next (Stat);\n+\n+            begin\n+               return\n+                 Nkind (Stat) = N_Null_Statement\n+                   and then\n+                     (No (Stat2)\n+                       or else\n+                         (Nkind (Stat2) = N_Return_Statement\n+                           and then No (Next (Stat2))));\n+            end;\n+         end if;\n+      end Is_Null_Procedure;\n+\n       ---------------------\n       -- Make_Exit_Label --\n       ---------------------\n@@ -3076,6 +3399,10 @@ package body Exp_Ch6 is\n             (RTE (RE_Address),\n              Relocate_Node (First_Actual (N))));\n          return;\n+\n+      elsif Is_Null_Procedure  then\n+         Rewrite (N, Make_Null_Statement (Loc));\n+         return;\n       end if;\n \n       --  Check for an illegal attempt to inline a recursive procedure. If the\n@@ -3786,7 +4113,7 @@ package body Exp_Ch6 is\n                 Chars => Name_uE);\n \n             Excep_Handlers := New_List (\n-              Make_Exception_Handler (Loc,\n+              Make_Implicit_Exception_Handler (Loc,\n                 Choice_Parameter => Ent_EO,\n                 Exception_Choices => New_List (\n                   Make_Others_Choice (Loc)),\n@@ -4003,9 +4330,7 @@ package body Exp_Ch6 is\n          elsif Is_Inherently_Limited_Type (Typ) then\n             Set_Returns_By_Ref (Spec_Id);\n \n-         elsif Present (Utyp)\n-           and then (Is_Class_Wide_Type (Utyp) or else Controlled_Type (Utyp))\n-         then\n+         elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n             Set_Returns_By_Ref (Spec_Id);\n          end if;\n       end;\n@@ -4403,24 +4728,29 @@ package body Exp_Ch6 is\n    function Is_Build_In_Place_Function (E : Entity_Id) return Boolean is\n    begin\n       --  For now we test whether E denotes a function or access-to-function\n-      --  type whose result subtype is constrained and inherently limited.\n-      --  Later this test will be revised to include unconstrained limited\n-      --  types and composite nonlimited types in general. Functions with\n-      --  a foreign convention or whose result type has a foreign convention\n+      --  type whose result subtype is inherently limited. Later this test may\n+      --  be revised to allow composite nonlimited types. Functions with a\n+      --  foreign convention or whose result type has a foreign convention\n       --  never qualify.\n \n       if Ekind (E) = E_Function\n+        or else Ekind (E) = E_Generic_Function\n         or else (Ekind (E) = E_Subprogram_Type\n                   and then Etype (E) /= Standard_Void_Type)\n       then\n+         --  Note: If you have Convention (C) on an inherently limited type,\n+         --  you're on your own. That is, the C code will have to be carefully\n+         --  written to know about the Ada conventions.\n+\n          if Has_Foreign_Convention (E)\n            or else Has_Foreign_Convention (Etype (E))\n          then\n             return False;\n \n          else\n             return Is_Inherently_Limited_Type (Etype (E))\n-              and then Is_Constrained (Etype (E));\n+              and then Ada_Version >= Ada_05\n+              and then not Debug_Flag_Dot_L;\n          end if;\n \n       else\n@@ -4456,6 +4786,22 @@ package body Exp_Ch6 is\n       end if;\n    end Is_Build_In_Place_Function_Call;\n \n+   ---------------------------------------\n+   -- Is_Build_In_Place_Function_Return --\n+   ---------------------------------------\n+\n+   function Is_Build_In_Place_Function_Return (N : Node_Id) return Boolean is\n+   begin\n+      if Nkind (N) = N_Return_Statement\n+        or else Nkind (N) = N_Extended_Return_Statement\n+      then\n+         return Is_Build_In_Place_Function\n+                  (Return_Applies_To (Return_Statement_Entity (N)));\n+      else\n+         return False;\n+      end if;\n+   end Is_Build_In_Place_Function_Return;\n+\n    -----------------------\n    -- Freeze_Subprogram --\n    -----------------------\n@@ -4474,17 +4820,16 @@ package body Exp_Ch6 is\n \n       procedure Register_Predefined_DT_Entry (Prim : Entity_Id) is\n          Iface_DT_Ptr : Elmt_Id;\n-         Iface_Typ    : Entity_Id;\n-         Iface_Elmt   : Elmt_Id;\n          Tagged_Typ   : Entity_Id;\n          Thunk_Id     : Entity_Id;\n \n       begin\n          Tagged_Typ := Find_Dispatching_Type (Prim);\n \n          if No (Access_Disp_Table (Tagged_Typ))\n-           or else No (Abstract_Interfaces (Tagged_Typ))\n+           or else not Has_Abstract_Interfaces (Tagged_Typ)\n            or else not RTE_Available (RE_Interface_Tag)\n+           or else Restriction_Active (No_Dispatching_Calls)\n          then\n             return;\n          end if;\n@@ -4497,36 +4842,29 @@ package body Exp_Ch6 is\n \n          Iface_DT_Ptr :=\n            Next_Elmt (First_Elmt (Access_Disp_Table (Tagged_Typ)));\n-         Iface_Elmt := First_Elmt (Abstract_Interfaces (Tagged_Typ));\n-         while Present (Iface_DT_Ptr) and then Present (Iface_Elmt) loop\n-            Iface_Typ := Node (Iface_Elmt);\n-\n-            if not Is_Ancestor (Iface_Typ, Tagged_Typ) then\n-               Thunk_Id :=\n-                 Make_Defining_Identifier (Loc,\n-                   Chars => New_Internal_Name ('T'));\n-\n-               Insert_Actions (N, New_List (\n-                 Expand_Interface_Thunk\n-                  (N           => Prim,\n-                   Thunk_Alias => Prim,\n-                   Thunk_Id    => Thunk_Id),\n-\n-                 Make_DT_Access_Action (Iface_Typ,\n-                   Action => Set_Predefined_Prim_Op_Address,\n-                   Args   => New_List (\n-                     Unchecked_Convert_To (RTE (RE_Tag),\n-                       New_Reference_To (Node (Iface_DT_Ptr), Loc)),\n-\n-                     Make_Integer_Literal (Loc, DT_Position (Prim)),\n-\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => New_Reference_To (Thunk_Id, Loc),\n-                       Attribute_Name => Name_Address)))));\n-            end if;\n+\n+         while Present (Iface_DT_Ptr) loop\n+            Thunk_Id :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_Internal_Name ('T'));\n+\n+            Insert_Actions (N, New_List (\n+              Expand_Interface_Thunk\n+               (N           => Prim,\n+                Thunk_Alias => Prim,\n+                Thunk_Id    => Thunk_Id),\n+\n+              Build_Set_Predefined_Prim_Op_Address (Loc,\n+                Tag_Node =>\n+                  New_Reference_To (Node (Iface_DT_Ptr), Loc),\n+                Position_Node =>\n+                  Make_Integer_Literal (Loc, DT_Position (Prim)),\n+                Address_Node =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => New_Reference_To (Thunk_Id, Loc),\n+                    Attribute_Name => Name_Address))));\n \n             Next_Elmt (Iface_DT_Ptr);\n-            Next_Elmt (Iface_Elmt);\n          end loop;\n       end Register_Predefined_DT_Entry;\n \n@@ -4537,8 +4875,7 @@ package body Exp_Ch6 is\n       --  whose constructor is in the CPP side (and therefore we don't need\n       --  to generate code to register them in the dispatch table).\n \n-      if not Debug_Flag_QQ\n-        and then Is_Imported (E)\n+      if Is_Imported (E)\n         and then Convention (E) = Convention_CPP\n       then\n          return;\n@@ -4551,7 +4888,7 @@ package body Exp_Ch6 is\n       --  the dispatching mechanism is handled internally by the JVM.\n \n       if Is_Dispatching_Operation (E)\n-        and then not Is_Abstract (E)\n+        and then not Is_Abstract_Subprogram (E)\n         and then Present (DTC_Entity (E))\n         and then not Java_VM\n         and then not Is_CPP_Class (Scope (DTC_Entity (E)))\n@@ -4560,43 +4897,48 @@ package body Exp_Ch6 is\n \n          --  Ada 95 case: Register the subprogram in the primary dispatch table\n \n-         if Ada_Version < Ada_05 then\n+         --  Do not register the subprogram in the dispatch table if we are\n+         --  compiling under No_Dispatching_Calls restriction.\n \n-            --  Do not register the subprogram in the dispatch table if we\n-            --  are compiling with the No_Dispatching_Calls restriction.\n+         if not Restriction_Active (No_Dispatching_Calls) then\n \n-            if not Restriction_Active (No_Dispatching_Calls) then\n+            if Ada_Version < Ada_05 then\n                Insert_After (N,\n                  Fill_DT_Entry (Sloc (N), Prim => E));\n-            end if;\n \n-         --  Ada 2005 case: Register the subprogram in the secondary dispatch\n-         --  tables associated with abstract interfaces.\n+            --  Ada 2005 case: Register the subprogram in all the dispatch\n+            --  tables associated with the type\n \n-         else\n-            declare\n-               Typ : constant Entity_Id := Scope (DTC_Entity (E));\n+            else\n+               declare\n+                  Typ : constant Entity_Id := Scope (DTC_Entity (E));\n \n-            begin\n-               --  There is no dispatch table associated with abstract\n-               --  interface types. Each type implementing interfaces will\n-               --  fill the associated secondary DT entries.\n+               begin\n+                  if not Is_Interface (Typ)\n+                    and then Is_Predefined_Dispatching_Operation (E)\n+                  then\n+                     Register_Predefined_DT_Entry (E);\n+                     Insert_After (N, Fill_DT_Entry (Sloc (N), Prim => E));\n \n-               if not Is_Interface (Typ)\n-                 or else Present (Alias (E))\n-               then\n-                  --  Ada 2005 (AI-251): Check if this entry corresponds with\n-                  --  a subprogram that covers an abstract interface type.\n+                  --  There is no dispatch table associated with abstract\n+                  --  interface types. Each type implementing interfaces will\n+                  --  fill the associated secondary DT entries.\n \n-                  if Present (Abstract_Interface_Alias (E)) then\n-                     Register_Interface_DT_Entry (N, E);\n+                  elsif not Is_Interface (Typ)\n+                    or else Present (Alias (E))\n+                  then\n+                     --  Ada 2005 (AI-251): Check if this entry corresponds\n+                     --  with a subprogram that covers an abstract interface\n+                     --  type.\n \n-                  --  Common case: Primitive subprogram\n+                     if Present (Abstract_Interface_Alias (E)) then\n+                        Register_Interface_DT_Entry (N, E);\n \n-                  else\n-                     --  Generate thunks for all the predefined operations\n+                     --  Common case: Primitive subprogram\n+\n+                     else\n+                        --  Generate thunks for all the predefined operations\n \n-                     if not Restriction_Active (No_Dispatching_Calls) then\n                         if Is_Predefined_Dispatching_Operation (E) then\n                            Register_Predefined_DT_Entry (E);\n                         end if;\n@@ -4605,8 +4947,8 @@ package body Exp_Ch6 is\n                           Fill_DT_Entry (Sloc (N), Prim => E));\n                      end if;\n                   end if;\n-               end if;\n-            end;\n+               end;\n+            end if;\n          end if;\n       end if;\n \n@@ -4622,9 +4964,7 @@ package body Exp_Ch6 is\n          if Is_Inherently_Limited_Type (Typ) then\n             Set_Returns_By_Ref (E);\n \n-         elsif Present (Utyp)\n-           and then (Is_Class_Wide_Type (Utyp) or else Controlled_Type (Utyp))\n-         then\n+         elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n             Set_Returns_By_Ref (E);\n          end if;\n       end;\n@@ -4665,43 +5005,79 @@ package body Exp_Ch6 is\n \n       Result_Subt := Etype (Function_Id);\n \n-      --  Replace the initialized allocator of form \"new T'(Func (...))\" with\n-      --  an uninitialized allocator of form \"new T\", where T is the result\n-      --  subtype of the called function. The call to the function is handled\n-      --  separately further below.\n+      --  When the result subtype is constrained, the return object must be\n+      --  allocated on the caller side, and access to it is passed to the\n+      --  function.\n \n-      New_Allocator :=\n-        Make_Allocator (Loc, New_Reference_To (Result_Subt, Loc));\n-      Set_No_Initialization (New_Allocator);\n+      if Is_Constrained (Result_Subt) then\n \n-      Rewrite (Allocator, New_Allocator);\n+         --  Replace the initialized allocator of form \"new T'(Func (...))\"\n+         --  with an uninitialized allocator of form \"new T\", where T is the\n+         --  result subtype of the called function. The call to the function\n+         --  is handled separately further below.\n \n-      --  Create a new access object and initialize it to the result of the new\n-      --  uninitialized allocator.\n+         New_Allocator :=\n+           Make_Allocator (Loc, New_Reference_To (Result_Subt, Loc));\n \n-      Return_Obj_Access :=\n-        Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n-      Set_Etype (Return_Obj_Access, Acc_Type);\n+         Set_Storage_Pool      (New_Allocator, Storage_Pool (Allocator));\n+         Set_Procedure_To_Call (New_Allocator, Procedure_To_Call (Allocator));\n+         Set_No_Initialization (New_Allocator);\n \n-      Insert_Action (Allocator,\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Return_Obj_Access,\n-          Object_Definition   => New_Reference_To (Acc_Type, Loc),\n-          Expression          => Relocate_Node (Allocator)));\n+         Rewrite (Allocator, New_Allocator);\n \n-      --  Add an implicit actual to the function call that provides access to\n-      --  the allocated object. An unchecked conversion to the (specific)\n-      --  result subtype of the function is inserted to handle the case where\n-      --  the access type of the allocator has a class-wide designated type.\n+         --  Create a new access object and initialize it to the result of the\n+         --  new uninitialized allocator.\n \n-      Add_Access_Actual_To_Build_In_Place_Call\n-        (Func_Call,\n-         Function_Id,\n-         Make_Unchecked_Type_Conversion (Loc,\n-           Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n-           Expression   =>\n-             Make_Explicit_Dereference (Loc,\n-               Prefix => New_Reference_To (Return_Obj_Access, Loc))));\n+         Return_Obj_Access :=\n+           Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n+         Set_Etype (Return_Obj_Access, Acc_Type);\n+\n+         Insert_Action (Allocator,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Return_Obj_Access,\n+             Object_Definition   => New_Reference_To (Acc_Type, Loc),\n+             Expression          => Relocate_Node (Allocator)));\n+\n+         --  Add an implicit actual to the function call that provides access\n+         --  to the allocated object. An unchecked conversion to the (specific)\n+         --  result subtype of the function is inserted to handle cases where\n+         --  the access type of the allocator has a class-wide designated type.\n+\n+         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n+         Add_Access_Actual_To_Build_In_Place_Call\n+           (Func_Call,\n+            Function_Id,\n+            Make_Unchecked_Type_Conversion (Loc,\n+              Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n+              Expression   =>\n+                Make_Explicit_Dereference (Loc,\n+                  Prefix => New_Reference_To (Return_Obj_Access, Loc))));\n+\n+      --  When the result subtype is unconstrained, the function itself must\n+      --  perform the allocation of the return object, so we pass parameters\n+      --  indicating that. We don't yet handle the case where the allocation\n+      --  must be done in a user-defined storage pool, which will require\n+      --  passing another actual or two to provide allocation/deallocation\n+      --  operations. ???\n+\n+      else\n+         --  Pass an allocation parameter indicating that the function should\n+         --  allocate its result on the heap.\n+\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Global_Heap);\n+\n+         --  The caller does not provide the return object in this case, so we\n+         --  have to pass null for the object access actual.\n+\n+         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Master_Actual => Master_Id (Acc_Type));\n+         Add_Access_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Return_Object => Empty);\n+      end if;\n \n       --  Finally, replace the allocator node with a reference to the result\n       --  of the function call itself (which will effectively be an access\n@@ -4744,28 +5120,60 @@ package body Exp_Ch6 is\n \n       Result_Subt := Etype (Function_Id);\n \n-      --  Create a temporary object to hold the function result\n+      --  When the result subtype is constrained, an object of the subtype is\n+      --  declared and an access value designating it is passed as an actual.\n \n-      Return_Obj_Id :=\n-        Make_Defining_Identifier (Loc,\n-          Chars => New_Internal_Name ('R'));\n-      Set_Etype (Return_Obj_Id, Result_Subt);\n+      if Is_Constrained (Result_Subt) then\n \n-      Return_Obj_Decl :=\n-        Make_Object_Declaration (Loc,\n-          Defining_Identifier => Return_Obj_Id,\n-          Aliased_Present     => True,\n-          Object_Definition   => New_Reference_To (Result_Subt, Loc));\n+         --  Create a temporary object to hold the function result\n+\n+         Return_Obj_Id :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_Internal_Name ('R'));\n+         Set_Etype (Return_Obj_Id, Result_Subt);\n \n-      Set_No_Initialization (Return_Obj_Decl);\n+         Return_Obj_Decl :=\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Return_Obj_Id,\n+             Aliased_Present     => True,\n+             Object_Definition   => New_Reference_To (Result_Subt, Loc));\n \n-      Insert_Action (Func_Call, Return_Obj_Decl);\n+         Set_No_Initialization (Return_Obj_Decl);\n \n-      --  Add an implicit actual to the function call that provides access to\n-      --  the caller's return object.\n+         Insert_Action (Func_Call, Return_Obj_Decl);\n \n-      Add_Access_Actual_To_Build_In_Place_Call\n-        (Func_Call, Function_Id, New_Reference_To (Return_Obj_Id, Loc));\n+         --  Add an implicit actual to the function call that provides access\n+         --  to the caller's return object.\n+\n+         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+         Add_Access_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, New_Reference_To (Return_Obj_Id, Loc));\n+\n+      --  When the result subtype is unconstrained, the function must allocate\n+      --  the return object in the secondary stack, so appropriate implicit\n+      --  parameters are added to the call to indicate that. A transient\n+      --  scope is established to ensure eventual cleanup of the result.\n+\n+      else\n+         --  Pass an allocation parameter indicating that the function should\n+         --  allocate its result on the secondary stack.\n+\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Secondary_Stack);\n+\n+         --  Pass a null value to the function since no return object is\n+         --  available on the caller side.\n+\n+         Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+         Add_Access_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Empty);\n+\n+         Establish_Transient_Scope (Func_Call, Sec_Stack => True);\n+      end if;\n    end Make_Build_In_Place_Call_In_Anonymous_Context;\n \n    ---------------------------------------------------\n@@ -4805,9 +5213,20 @@ package body Exp_Ch6 is\n \n       Result_Subt := Etype (Function_Id);\n \n+      --  When the result subtype is unconstrained, an additional actual must\n+      --  be passed to indicate that the caller is providing the return object.\n+\n+      if not Is_Constrained (Result_Subt) then\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+      end if;\n+\n       --  Add an implicit actual to the function call that provides access to\n       --  the caller's return object.\n \n+      Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+      Add_Task_Actuals_To_Build_In_Place_Call\n+        (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n       Add_Access_Actual_To_Build_In_Place_Call\n         (Func_Call,\n          Function_Id,\n@@ -4860,14 +5279,20 @@ package body Exp_Ch6 is\n      (Object_Decl   : Node_Id;\n       Function_Call : Node_Id)\n    is\n-      Loc          : Source_Ptr;\n-      Func_Call    : Node_Id := Function_Call;\n-      Function_Id  : Entity_Id;\n-      Result_Subt  : Entity_Id;\n-      Ref_Type     : Entity_Id;\n-      Ptr_Typ_Decl : Node_Id;\n-      Def_Id       : Entity_Id;\n-      New_Expr     : Node_Id;\n+      Loc             : Source_Ptr;\n+      Obj_Def_Id      : constant Entity_Id :=\n+                          Defining_Identifier (Object_Decl);\n+      Func_Call       : Node_Id := Function_Call;\n+      Function_Id     : Entity_Id;\n+      Result_Subt     : Entity_Id;\n+      Caller_Object   : Node_Id;\n+      Call_Deref      : Node_Id;\n+      Ref_Type        : Entity_Id;\n+      Ptr_Typ_Decl    : Node_Id;\n+      Def_Id          : Entity_Id;\n+      New_Expr        : Node_Id;\n+      Enclosing_Func  : Entity_Id;\n+      Pass_Caller_Acc : Boolean := False;\n \n    begin\n       if Nkind (Func_Call) = N_Qualified_Expression then\n@@ -4888,18 +5313,96 @@ package body Exp_Ch6 is\n \n       Result_Subt := Etype (Function_Id);\n \n-      --  Add an implicit actual to the function call that provides access to\n-      --  the declared object. An unchecked conversion to the (specific) result\n-      --  type of the function is inserted to handle the case where the object\n-      --  is declared with a class-wide type.\n+      --  In the constrained case, add an implicit actual to the function call\n+      --  that provides access to the declared object. An unchecked conversion\n+      --  to the (specific) result type of the function is inserted to handle\n+      --  the case where the object is declared with a class-wide type.\n+\n+      if Is_Constrained (Result_Subt) then\n+         Caller_Object :=\n+            Make_Unchecked_Type_Conversion (Loc,\n+              Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n+              Expression   => New_Reference_To (Obj_Def_Id, Loc));\n \n+      --  If the function's result subtype is unconstrained and the object is\n+      --  a return object of an enclosing build-in-place function, then the\n+      --  implicit build-in-place parameters of the enclosing function must be\n+      --  passed along to the called function.\n+\n+      elsif Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement then\n+         Pass_Caller_Acc := True;\n+\n+         Enclosing_Func := Enclosing_Subprogram (Obj_Def_Id);\n+\n+         --  If the enclosing function has a constrained result type, then\n+         --  caller allocation will be used.\n+\n+         if Is_Constrained (Etype (Enclosing_Func)) then\n+            Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+              (Func_Call, Function_Id, Alloc_Form => Caller_Allocation);\n+\n+         --  Otherwise, when the enclosing function has an unconstrained result\n+         --  type, the BIP_Alloc_Form formal of the enclosing function must be\n+         --  passed long to the callee.\n+\n+         else\n+            Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+              (Func_Call,\n+               Function_Id,\n+               Alloc_Form_Exp =>\n+                 New_Reference_To\n+                   (Build_In_Place_Formal (Enclosing_Func, BIP_Alloc_Form),\n+                    Loc));\n+         end if;\n+\n+         --  Retrieve the BIPacc formal from the enclosing function and convert\n+         --  it to the access type of the callee's BIP_Object_Access formal.\n+\n+         Caller_Object :=\n+            Make_Unchecked_Type_Conversion (Loc,\n+              Subtype_Mark =>\n+                New_Reference_To\n+                  (Etype\n+                     (Build_In_Place_Formal (Function_Id, BIP_Object_Access)),\n+                   Loc),\n+              Expression   =>\n+                New_Reference_To\n+                  (Build_In_Place_Formal (Enclosing_Func, BIP_Object_Access),\n+                   Loc));\n+\n+      --  In other unconstrained cases, pass an indication to do the allocation\n+      --  on the secondary stack and set Caller_Object to Empty so that a null\n+      --  value will be passed for the caller's object address. A transient\n+      --  scope is established to ensure eventual cleanup of the result.\n+\n+      else\n+         Add_Alloc_Form_Actual_To_Build_In_Place_Call\n+           (Func_Call,\n+            Function_Id,\n+            Alloc_Form => Secondary_Stack);\n+         Caller_Object := Empty;\n+\n+         Establish_Transient_Scope (Object_Decl, Sec_Stack => True);\n+      end if;\n+\n+      Add_Final_List_Actual_To_Build_In_Place_Call (Func_Call, Function_Id);\n+      if Nkind (Parent (Object_Decl)) = N_Extended_Return_Statement\n+        and then Has_Task (Result_Subt)\n+      then\n+         Enclosing_Func := Enclosing_Subprogram (Obj_Def_Id);\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id,\n+            Master_Actual =>\n+              New_Reference_To\n+                (Build_In_Place_Formal (Enclosing_Func, BIP_Master), Loc));\n+         --  Here we're passing along the master that was passed in to this\n+         --  function.\n+      else\n+         Add_Task_Actuals_To_Build_In_Place_Call\n+           (Func_Call, Function_Id, Make_Identifier (Loc, Name_uMaster));\n+      end if;\n       Add_Access_Actual_To_Build_In_Place_Call\n-        (Func_Call,\n-         Function_Id,\n-         Make_Unchecked_Type_Conversion (Loc,\n-           Subtype_Mark => New_Reference_To (Result_Subt, Loc),\n-           Expression   => New_Reference_To\n-                             (Defining_Identifier (Object_Decl), Loc)));\n+        (Func_Call, Function_Id, Caller_Object, Is_Access => Pass_Caller_Acc);\n \n       --  Create an access type designating the function's result subtype\n \n@@ -4915,7 +5418,18 @@ package body Exp_Ch6 is\n               Subtype_Indication =>\n                 New_Reference_To (Result_Subt, Loc)));\n \n-      Insert_After_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n+      --  The access type and its accompanying object must be inserted after\n+      --  the object declaration in the constrained case, so that the function\n+      --  call can be passed access to the object. In the unconstrained case,\n+      --  the access type and object must be inserted before the object, since\n+      --  the object declaration is rewritten to be a renaming of a dereference\n+      --  of the access object.\n+\n+      if Is_Constrained (Result_Subt) then\n+         Insert_After_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n+      else\n+         Insert_Before_And_Analyze (Object_Decl, Ptr_Typ_Decl);\n+      end if;\n \n       --  Finally, create an access object initialized to a reference to the\n       --  function call.\n@@ -4935,8 +5449,44 @@ package body Exp_Ch6 is\n           Object_Definition   => New_Reference_To (Ref_Type, Loc),\n           Expression          => New_Expr));\n \n-      Set_Expression (Object_Decl, Empty);\n-      Set_No_Initialization (Object_Decl);\n+      if Is_Constrained (Result_Subt) then\n+         Set_Expression (Object_Decl, Empty);\n+         Set_No_Initialization (Object_Decl);\n+\n+      --  In case of an unconstrained result subtype, rewrite the object\n+      --  declaration as an object renaming where the renamed object is a\n+      --  dereference of <function_Call>'reference:\n+      --\n+      --      Obj : Subt renames <function_call>'Ref.all;\n+\n+      else\n+         Call_Deref :=\n+           Make_Explicit_Dereference (Loc,\n+             Prefix => New_Reference_To (Def_Id, Loc));\n+\n+         Rewrite (Object_Decl,\n+           Make_Object_Renaming_Declaration (Loc,\n+             Defining_Identifier => Make_Defining_Identifier (Loc,\n+                                      New_Internal_Name ('D')),\n+             Access_Definition   => Empty,\n+             Subtype_Mark        => New_Occurrence_Of (Result_Subt, Loc),\n+             Name                => Call_Deref));\n+\n+         Set_Renamed_Object (Defining_Identifier (Object_Decl), Call_Deref);\n+\n+         Analyze (Object_Decl);\n+\n+         --  Replace the internal identifier of the renaming declaration's\n+         --  entity with identifier of the original object entity. We also have\n+         --  to exchange the entities containing their defining identifiers to\n+         --  ensure the correct replacement of the object declaration by the\n+         --  object renaming declaration to avoid homograph conflicts (since\n+         --  the object declaration's defining identifier was already entered\n+         --  in current scope).\n+\n+         Set_Chars (Defining_Identifier (Object_Decl), Chars (Obj_Def_Id));\n+         Exchange_Entities (Defining_Identifier (Object_Decl), Obj_Def_Id);\n+      end if;\n \n       --  If the object entity has a class-wide Etype, then we need to change\n       --  it to the result subtype of the function call, because otherwise the\n@@ -4980,7 +5530,7 @@ package body Exp_Ch6 is\n \n       pragma Assert (Is_Interface (Iface_Typ));\n \n-      if not Is_Ancestor (Iface_Typ, Tagged_Typ) then\n+      if not Is_Parent (Iface_Typ, Tagged_Typ) then\n          Thunk_Id  :=\n            Make_Defining_Identifier (Loc,\n              Chars => New_Internal_Name ('T'));"}, {"sha": "436654c4c1b2f2fd0e561d203fea2d8b4b705cff", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 71, "deletions": 9, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -40,21 +40,83 @@ package Exp_Ch6 is\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call.\n \n+   procedure Freeze_Subprogram (N : Node_Id);\n+   --  generate the appropriate expansions related to Subprogram freeze\n+   --  nodes (e. g. the filling of the corresponding Dispatch Table for\n+   --  Primitive Operations)\n+\n+   --  The following type defines the various forms of allocation used for the\n+   --  results of build-in-place function calls.\n+\n+   type BIP_Allocation_Form is\n+     (Unspecified,\n+      Caller_Allocation,\n+      Secondary_Stack,\n+      Global_Heap,\n+      User_Storage_Pool);\n+\n+   type BIP_Formal_Kind is\n+   --  Ada 2005 (AI-318-02): This type defines the kinds of implicit extra\n+   --  formals created for build-in-place functions. The order of the above\n+   --  enumeration literals matches the order in which the formals are\n+   --  declared. See Sem_Ch6.Create_Extra_Formals.\n+     (BIP_Alloc_Form,\n+      --  Present if result subtype is unconstrained. Indicates whether the\n+      --  return object is allocated by the caller or callee, and if the\n+      --  callee, whether to use the secondary stack or the heap. See\n+      --  Create_Extra_Formals.\n+      BIP_Final_List,\n+      --  Present if result type has controlled parts. Pointer to caller's\n+      --  finalization list.\n+      BIP_Master,\n+      --  Present if result type contains tasks. Master associated with\n+      --  calling context.\n+      BIP_Activation_Chain,\n+      --  Present if result type contains tasks. Caller's activation chain.\n+      BIP_Object_Access);\n+      --  Present for all build-in-place functions. Address at which to place\n+      --  the return object, or null if BIP_Alloc_Form indicates\n+      --  allocated by callee.\n+      --  ??? We also need to be able to pass in some way to access a\n+      --  user-defined storage pool at some point. And perhaps a constrained\n+      --  flag.\n+\n+   function BIP_Formal_Suffix (Kind : BIP_Formal_Kind) return String;\n+   --  Ada 2005 (AI-318-02): Returns a string to be used as the suffix of names\n+   --  for build-in-place formal parameters of the given kind.\n+\n+   function Build_In_Place_Formal\n+     (Func : Entity_Id;\n+      Kind : BIP_Formal_Kind) return Entity_Id;\n+   --  Ada 2005 (AI-318-02): Locates and returns the entity for the implicit\n+   --  build-in-place formal parameter of the given kind associated with the\n+   --  function Func, and returns its Entity_Id. It is a bug if not found; the\n+   --  caller should ensure this is called only when the extra formal exists.\n+\n    function Is_Build_In_Place_Function (E : Entity_Id) return Boolean;\n-   --  Ada 2005 (AI-318-02): Returns True if E denotes a function or an\n-   --  access-to-function type whose result must be built in place; otherwise\n-   --  returns False. Currently this is restricted to the subset of functions\n-   --  whose result subtype is a constrained inherently limited type.\n+   --  Ada 2005 (AI-318-02): Returns True if E denotes a function, generic\n+   --  function, or access-to-function type whose result must be built in\n+   --  place; otherwise returns False. For Ada 2005, this is currently\n+   --  restricted to the set of functions whose result subtype is an inherently\n+   --  limited type. In Ada 95, this must be False for inherently limited\n+   --  result types (but currently returns False for all Ada 95 functions).\n+   --  Eventually we plan to support build-in-place for nonlimited types.\n+   --  Build-in-place is usually more efficient for large things, and less\n+   --  efficient for small things. However, we never use build-in-place if the\n+   --  convention is other than Ada, because that would disturb mixed-language\n+   --  programs. Note that for the non-inherently-limited cases, we must make\n+   --  the same decision for Ada 95 and 2005, so that mixed-dialect programs\n+   --  will work.\n \n    function Is_Build_In_Place_Function_Call (N : Node_Id) return Boolean;\n    --  Ada 2005 (AI-318-02): Returns True if N denotes a call to a function\n    --  that requires handling as a build-in-place call or is a qualified\n    --  expression applied to such a call; otherwise returns False.\n \n-   procedure Freeze_Subprogram (N : Node_Id);\n-   --  generate the appropriate expansions related to Subprogram freeze\n-   --  nodes (e. g. the filling of the corresponding Dispatch Table for\n-   --  Primitive Operations)\n+   function Is_Build_In_Place_Function_Return (N : Node_Id) return Boolean;\n+   --  Ada 2005 (AI-318-02): Returns True if N is an N_Return_Statement or\n+   --  N_Extended_Return_Statement and it applies to a build-in-place function\n+   --  or generic function.\n \n    procedure Make_Build_In_Place_Call_In_Allocator\n      (Allocator     : Node_Id;\n@@ -84,7 +146,7 @@ package Exp_Ch6 is\n       Function_Call : Node_Id);\n    --  Ada 2005 (AI-318-02): Handle a call to a build-in-place function that\n    --  occurs as the right-hand side of an assignment statement by passing\n-   --  access to the left-hand sid as an additional parameter of the function\n+   --  access to the left-hand side as an additional parameter of the function\n    --  call. Assign must denote a N_Assignment_Statement. Function_Call must\n    --  denote either an N_Function_Call node for which Is_Build_In_Place_Call\n    --  is True, or an N_Qualified_Expression node applied to such a function"}, {"sha": "03408a77c075946513349f92a37f7fe4a571f622", "filename": "gcc/ada/exp_ch8.adb", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fexp_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch8.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,10 +26,12 @@\n \n with Atree;    use Atree;\n with Einfo;    use Einfo;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Dbug; use Exp_Dbug;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Nlists;   use Nlists;\n+with Opt;      use Opt;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sinfo;    use Sinfo;\n@@ -268,6 +270,19 @@ package body Exp_Ch8 is\n          end if;\n       end if;\n \n+      --  Ada 2005 (AI-318-02): If the renamed object is a call to a build-in-\n+      --  place function, then a temporary return object needs to be created\n+      --  and access to it must be passed to the function. Currently we limit\n+      --  such functions to those with inherently limited result subtypes, but\n+      --  eventually we plan to expand the functions that are treated as\n+      --  build-in-place to include other composite result types.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function_Call (Nam)\n+      then\n+         Make_Build_In_Place_Call_In_Anonymous_Context (Nam);\n+      end if;\n+\n       --  Create renaming entry for debug information\n \n       Decl := Debug_Renaming_Declaration (N);"}, {"sha": "9f8993b2961170c7eddd9ba3e7a41dbffa8205d6", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 242, "deletions": 88, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -54,8 +54,10 @@ with Uname;    use Uname;\n package body Rtsfind is\n \n    RTE_Available_Call : Boolean := False;\n-   --  Set True during call to RTE from RTE_Available. Tells RTE to set\n-   --  RTE_Is_Available to False rather than generating an error message.\n+   --  Set True during call to RTE from RTE_Available (or from call to\n+   --  RTE_Record_Component from RTE_Record_Component_Available). Tells\n+   --  the called subprogram to set RTE_Is_Available to False rather than\n+   --  generating an error message.\n \n    RTE_Is_Available : Boolean;\n    --  Set True by RTE_Available on entry. When RTE_Available_Call is set\n@@ -97,6 +99,11 @@ package body Rtsfind is\n    --  first time, its ID is stored in this array, so that subsequent calls\n    --  for the same entity can be satisfied immediately.\n \n+   --  NOTE: In order to avoid conflicts between record components and subprgs\n+   --        that have the same name (ie. subprogram External_Tag and component\n+   --        External_Tag of package Ada.Tags) this table is not used with\n+   --        Record_Components.\n+\n    RE_Table : array (RE_Id) of Entity_Id;\n \n    --------------------------\n@@ -123,11 +130,20 @@ package body Rtsfind is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Check_CRT (E : RE_Id; Eid : Entity_Id) return Entity_Id;\n+   --  Check entity Eid to ensure that configurable run-time restrictions\n+   --  are met. May generate an error message and raise RE_Not_Available\n+   --  if the entity E does not exist (i.e. Eid is Empty)\n+\n    procedure Entity_Not_Defined (Id : RE_Id);\n    --  Outputs error messages for an entity that is not defined in the\n    --  run-time library (the form of the error message is tailored for\n    --  no run time/configurable run time mode as required).\n \n+   function Get_Unit_Name (U_Id : RTU_Id) return Unit_Name_Type;\n+   --  Retrieves the Unit Name given a unit id represented by its\n+   --  enumeration value in RTU_Id.\n+\n    procedure Load_Fail (S : String; U_Id : RTU_Id; Id : RE_Id);\n    --  Internal procedure called if we can't sucessfully locate or\n    --  process a run-time unit. The parameters give information about\n@@ -144,10 +160,6 @@ package body Rtsfind is\n    --  a normal situation in configurable run-time mode (and the message in\n    --  this case is suppressed unless we are operating in All_Errors_Mode).\n \n-   function Get_Unit_Name (U_Id : RTU_Id) return Unit_Name_Type;\n-   --  Retrieves the Unit Name given a unit id represented by its\n-   --  enumeration value in RTU_Id.\n-\n    procedure Load_RTU\n      (U_Id        : RTU_Id;\n       Id          : RE_Id   := RE_Null;\n@@ -165,6 +177,10 @@ package body Rtsfind is\n    --  Id is used only for error message detail, and if it is RE_Null, then\n    --  the attempt to output the entity name is ignored.\n \n+   function Make_Unit_Name (E : RE_Id; N : Node_Id) return Node_Id;\n+   --  If the unit is a child unit, build fully qualified name for use in\n+   --  With_Clause.\n+\n    procedure Output_Entity_Name (Id : RE_Id; Msg : String);\n    --  Output continuation error message giving qualified name of entity\n    --  corresponding to Id, appending the string given by Msg. This call\n@@ -181,6 +197,37 @@ package body Rtsfind is\n    --  used if you are sure that the message comes directly or indirectly from\n    --  a call to the RTE function.\n \n+   ---------------\n+   -- Check_CRT --\n+   ---------------\n+\n+   function Check_CRT (E : RE_Id; Eid : Entity_Id) return Entity_Id is\n+      U_Id : constant RTU_Id := RE_Unit_Table (E);\n+\n+   begin\n+      if No (Eid) then\n+         Entity_Not_Defined (E);\n+         raise RE_Not_Available;\n+\n+      --  Entity is available\n+\n+      else\n+         --  If in No_Run_Time mode and entity is not in one of the\n+         --  specially permitted units, raise the exception.\n+\n+         if No_Run_Time_Mode\n+           and then not OK_No_Run_Time_Unit (U_Id)\n+         then\n+            Entity_Not_Defined (E);\n+            raise RE_Not_Available;\n+         end if;\n+\n+         --  Otherwise entity is accessible\n+\n+         return Eid;\n+      end if;\n+   end Check_CRT;\n+\n    ------------------------\n    -- Entity_Not_Defined --\n    ------------------------\n@@ -658,6 +705,36 @@ package body Rtsfind is\n       end if;\n    end Load_RTU;\n \n+   --------------------\n+   -- Make_Unit_Name --\n+   --------------------\n+\n+   function Make_Unit_Name (E : RE_Id; N : Node_Id) return Node_Id is\n+      U_Id : constant RTU_Id := RE_Unit_Table (E);\n+      U    : RT_Unit_Table_Record renames RT_Unit_Table (U_Id);\n+      Nam  : Node_Id;\n+      Scop : Entity_Id;\n+\n+   begin\n+      Nam  := New_Reference_To (U.Entity, Standard_Location);\n+      Scop := Scope (U.Entity);\n+\n+      if Nkind (N) = N_Defining_Program_Unit_Name then\n+         while Scop /= Standard_Standard loop\n+            Nam :=\n+              Make_Expanded_Name (Standard_Location,\n+                Chars  => Chars (U.Entity),\n+                Prefix => New_Reference_To (Scop, Standard_Location),\n+                Selector_Name => Nam);\n+            Set_Entity (Nam, U.Entity);\n+\n+            Scop := Scope (Scop);\n+         end loop;\n+      end if;\n+\n+      return Nam;\n+   end Make_Unit_Name;\n+\n    -----------------------\n    -- Output_Entity_Name --\n    ------------------------\n@@ -763,11 +840,6 @@ package body Rtsfind is\n \n       Save_Front_End_Inlining : Boolean;\n \n-      function Check_CRT (Eid : Entity_Id) return Entity_Id;\n-      --  Check entity Eid to ensure that configurable run-time restrictions\n-      --  are met. May generate an error message and raise RE_Not_Available\n-      --  if the entity E does not exist (i.e. Eid is Empty)\n-\n       procedure Check_RPC;\n       --  Reject programs that make use of distribution features not supported\n       --  on the current target. On such targets (VMS, Vxworks, others?) we\n@@ -778,39 +850,6 @@ package body Rtsfind is\n       --  This function is used when entity E is in this compilation's main\n       --  unit. It gets the value from the already compiled declaration.\n \n-      function Make_Unit_Name (N : Node_Id) return Node_Id;\n-      --  If the unit is a child unit, build fully qualified name for use\n-      --  in With_Clause.\n-\n-      ---------------\n-      -- Check_CRT --\n-      ---------------\n-\n-      function Check_CRT (Eid : Entity_Id) return Entity_Id is\n-      begin\n-         if No (Eid) then\n-            Entity_Not_Defined (E);\n-            raise RE_Not_Available;\n-\n-         --  Entity is available\n-\n-         else\n-            --  If in No_Run_Time mode and entity is not in one of the\n-            --  specially permitted units, raise the exception.\n-\n-            if No_Run_Time_Mode\n-              and then not OK_No_Run_Time_Unit (U_Id)\n-            then\n-               Entity_Not_Defined (E);\n-               raise RE_Not_Available;\n-            end if;\n-\n-            --  Otherwise entity is accessible\n-\n-            return Eid;\n-         end if;\n-      end Check_CRT;\n-\n       ---------------\n       -- Check_RPC --\n       ---------------\n@@ -847,9 +886,9 @@ package body Rtsfind is\n          end if;\n       end Check_RPC;\n \n-      ------------------------\n-      -- Find_System_Entity --\n-      ------------------------\n+      -----------------------\n+      -- Find_Local_Entity --\n+      -----------------------\n \n       function Find_Local_Entity (E : RE_Id) return Entity_Id is\n          RE_Str : String renames RE_Id'Image (E);\n@@ -871,34 +910,6 @@ package body Rtsfind is\n          return Ent;\n       end Find_Local_Entity;\n \n-      --------------------\n-      -- Make_Unit_Name --\n-      --------------------\n-\n-      function Make_Unit_Name (N : Node_Id) return Node_Id is\n-         Nam  : Node_Id;\n-         Scop : Entity_Id;\n-\n-      begin\n-         Nam  := New_Reference_To (U.Entity, Standard_Location);\n-         Scop := Scope (U.Entity);\n-\n-         if Nkind (N) = N_Defining_Program_Unit_Name then\n-            while Scop /= Standard_Standard loop\n-               Nam :=\n-                 Make_Expanded_Name (Standard_Location,\n-                   Chars  => Chars (U.Entity),\n-                   Prefix => New_Reference_To (Scop, Standard_Location),\n-                   Selector_Name => Nam);\n-               Set_Entity (Nam, U.Entity);\n-\n-               Scop := Scope (Scop);\n-            end loop;\n-         end if;\n-\n-         return Nam;\n-      end Make_Unit_Name;\n-\n    --  Start of processing for RTE\n \n    begin\n@@ -917,7 +928,7 @@ package body Rtsfind is\n         and then Analyzed (Main_Unit_Entity)\n         and then not Is_Child_Unit (Main_Unit_Entity)\n       then\n-         return Check_CRT (Find_Local_Entity (E));\n+         return Check_CRT (E, Find_Local_Entity (E));\n       end if;\n \n       Save_Front_End_Inlining := Front_End_Inlining;\n@@ -947,16 +958,16 @@ package body Rtsfind is\n \n             --  First we search the package entity chain\n \n-               Pkg_Ent := First_Entity (U.Entity);\n-               while Present (Pkg_Ent) loop\n-                  if Ename = Chars (Pkg_Ent) then\n-                     RE_Table (E) := Pkg_Ent;\n-                     Check_RPC;\n-                     goto Found;\n-                  end if;\n+            Pkg_Ent := First_Entity (U.Entity);\n+            while Present (Pkg_Ent) loop\n+               if Ename = Chars (Pkg_Ent) then\n+                  RE_Table (E) := Pkg_Ent;\n+                  Check_RPC;\n+                  goto Found;\n+               end if;\n \n-                  Next_Entity (Pkg_Ent);\n-               end loop;\n+               Next_Entity (Pkg_Ent);\n+            end loop;\n \n             --  If we did not find the entity in the package entity chain,\n             --  then check if the package entity itself matches. Note that\n@@ -979,7 +990,7 @@ package body Rtsfind is\n       --  a WITH if the current unit is part of the extended main code\n       --  unit, and if we have not already added the with. The WITH is\n       --  added to the appropriate unit (the current one). We do not need\n-      --  to generate a WITH for an ????\n+      --  to generate a WITH for a call issued from RTE_Available.\n \n    <<Found>>\n       if (not U.Withed)\n@@ -999,7 +1010,7 @@ package body Rtsfind is\n               Make_With_Clause (Standard_Location,\n                 Name =>\n                   Make_Unit_Name\n-                    (Defining_Unit_Name (Specification (Lib_Unit))));\n+                    (E, Defining_Unit_Name (Specification (Lib_Unit))));\n             Set_Library_Unit          (Withn, Cunit (U.Unum));\n             Set_Corresponding_Spec    (Withn, U.Entity);\n             Set_First_Name            (Withn, True);\n@@ -1012,7 +1023,7 @@ package body Rtsfind is\n       end if;\n \n       Front_End_Inlining := Save_Front_End_Inlining;\n-      return Check_CRT (RE_Table (E));\n+      return Check_CRT (E, RE_Table (E));\n    end RTE;\n \n    -------------------\n@@ -1047,6 +1058,140 @@ package body Rtsfind is\n          return False;\n    end RTE_Available;\n \n+   --------------------------\n+   -- RTE_Record_Component --\n+   --------------------------\n+\n+   function RTE_Record_Component (E : RE_Id) return Entity_Id is\n+      U_Id     : constant RTU_Id := RE_Unit_Table (E);\n+      U        : RT_Unit_Table_Record renames RT_Unit_Table (U_Id);\n+      E1       : Entity_Id;\n+      Ename    : Name_Id;\n+      Lib_Unit : Node_Id;\n+      Pkg_Ent  : Entity_Id;\n+\n+      --  The following flag is used to disable front-end inlining when\n+      --  RTE_Record_Component is invoked. This prevents the analysis of other\n+      --  runtime bodies when a particular spec is loaded through Rtsfind. This\n+      --  is both efficient, and it prevents spurious visibility conflicts\n+      --  between use-visible user entities, and entities in run-time packages.\n+\n+      --  In configurable run-time mode, subprograms marked Inlined_Always must\n+      --  be inlined, so in the case we retain the Front_End_Inlining mode.\n+\n+      Save_Front_End_Inlining : Boolean;\n+\n+   begin\n+      --  Note: Contrary to subprogram RTE, there is no need to do any special\n+      --  management with package system.ads because it has no record type\n+      --  declarations.\n+\n+      Save_Front_End_Inlining := Front_End_Inlining;\n+      Front_End_Inlining      := Configurable_Run_Time_Mode;\n+\n+      --  Load unit if unit not previously loaded\n+\n+      if not Present (U.Entity) then\n+         Load_RTU (U_Id, Id => E);\n+      end if;\n+\n+      Lib_Unit := Unit (Cunit (U.Unum));\n+\n+      pragma Assert (Nkind (Lib_Unit) = N_Package_Declaration);\n+      Ename := RE_Chars (E);\n+\n+      --  Search the entity in the components of record type declarations\n+      --  found in the package entity chain.\n+\n+      Pkg_Ent := First_Entity (U.Entity);\n+      Search : while Present (Pkg_Ent) loop\n+         if Is_Record_Type (Pkg_Ent) then\n+            E1 := First_Entity (Pkg_Ent);\n+            while Present (E1) loop\n+               if Ename = Chars (E1) then\n+                  exit Search;\n+               end if;\n+\n+               Next_Entity (E1);\n+            end loop;\n+         end if;\n+\n+         Next_Entity (Pkg_Ent);\n+      end loop Search;\n+\n+      --  If we didn't find the entity we want, something is wrong. The\n+      --  appropriate action will be taken by Check_CRT when we exit.\n+\n+      --  Cenerate a with-clause if the current unit is part of the extended\n+      --  main code unit, and if we have not already added the with. The clause\n+      --  is added to the appropriate unit (the current one). We do not need to\n+      --  generate it for a call issued from RTE_Component_Available.\n+\n+      if (not U.Withed)\n+        and then\n+          In_Extended_Main_Code_Unit (Cunit_Entity (Current_Sem_Unit))\n+        and then not RTE_Available_Call\n+      then\n+         U.Withed := True;\n+\n+         declare\n+            Withn    : Node_Id;\n+            Lib_Unit : Node_Id;\n+\n+         begin\n+            Lib_Unit := Unit (Cunit (U.Unum));\n+            Withn :=\n+              Make_With_Clause (Standard_Location,\n+                Name =>\n+                  Make_Unit_Name\n+                    (E, Defining_Unit_Name (Specification (Lib_Unit))));\n+            Set_Library_Unit          (Withn, Cunit (U.Unum));\n+            Set_Corresponding_Spec    (Withn, U.Entity);\n+            Set_First_Name            (Withn, True);\n+            Set_Implicit_With         (Withn, True);\n+\n+            Mark_Rewrite_Insertion (Withn);\n+            Append (Withn, Context_Items (Cunit (Current_Sem_Unit)));\n+            Check_Restriction_No_Dependence (Name (Withn), Current_Error_Node);\n+         end;\n+      end if;\n+\n+      Front_End_Inlining := Save_Front_End_Inlining;\n+      return Check_CRT (E, E1);\n+   end RTE_Record_Component;\n+\n+   ------------------------------------\n+   -- RTE_Record_Component_Available --\n+   ------------------------------------\n+\n+   function RTE_Record_Component_Available (E : RE_Id) return Boolean is\n+      Dummy : Entity_Id;\n+      pragma Warnings (Off, Dummy);\n+\n+      Result : Boolean;\n+\n+      Save_RTE_Available_Call : constant Boolean := RTE_Available_Call;\n+      Save_RTE_Is_Available   : constant Boolean := RTE_Is_Available;\n+      --  These are saved recursively because the call to load a unit\n+      --  caused by an upper level call may perform a recursive call\n+      --  to this routine during analysis of the corresponding unit.\n+\n+   begin\n+      RTE_Available_Call := True;\n+      RTE_Is_Available := True;\n+      Dummy := RTE_Record_Component (E);\n+      Result := RTE_Is_Available;\n+      RTE_Available_Call := Save_RTE_Available_Call;\n+      RTE_Is_Available   := Save_RTE_Is_Available;\n+      return Result;\n+\n+   exception\n+      when RE_Not_Available =>\n+         RTE_Available_Call := Save_RTE_Available_Call;\n+         RTE_Is_Available   := Save_RTE_Is_Available;\n+         return False;\n+   end RTE_Record_Component_Available;\n+\n    -------------------\n    -- RTE_Error_Msg --\n    -------------------\n@@ -1068,6 +1213,15 @@ package body Rtsfind is\n       end if;\n    end RTE_Error_Msg;\n \n+   ----------------\n+   -- RTU_Entity --\n+   ----------------\n+\n+   function RTU_Entity (U : RTU_Id) return Entity_Id is\n+   begin\n+      return RT_Unit_Table (U).Entity;\n+   end RTU_Entity;\n+\n    ----------------\n    -- RTU_Loaded --\n    ----------------"}, {"sha": "4047436e89b973cc4d5230f1a9016de47366cf28", "filename": "gcc/ada/s-finimp.adb", "status": "modified", "additions": 32, "deletions": 98, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-finimp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-finimp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -168,15 +168,15 @@ package body System.Finalization_Implementation is\n       Nb_Link : Short_Short_Integer)\n    is\n    begin\n-      --  Simple case: attachement to a one way list\n+      --  Simple case: attachment to a one way list\n \n       if Nb_Link = 1 then\n          Obj.Next := L;\n          L        := Obj'Unchecked_Access;\n \n       --  Dynamically allocated objects: they are attached to a doubly linked\n       --  list, so that an element can be finalized at any moment by means of\n-      --  an unchecked deallocation. Attachement is protected against\n+      --  an unchecked deallocation. Attachment is protected against\n       --  multi-threaded access.\n \n       elsif Nb_Link = 2 then\n@@ -203,7 +203,7 @@ package body System.Finalization_Implementation is\n                raise;\n          end Locked_Processing;\n \n-      --  Attachement of arrays to the final list (used only for objects\n+      --  Attachment of arrays to the final list (used only for objects\n       --  returned by function). Obj, in this case is the last element,\n       --  but all other elements are already threaded after it. We just\n       --  attach the rest of the final list at the end of the array list.\n@@ -230,32 +230,6 @@ package body System.Finalization_Implementation is\n       end if;\n    end Attach_To_Final_List;\n \n-   ---------------------\n-   -- Deep_Tag_Adjust --\n-   ---------------------\n-\n-   procedure Deep_Tag_Adjust\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Short_Short_Integer)\n-   is\n-      V          : constant SFR.Finalizable_Ptr := To_Finalizable_Ptr (A);\n-      Controller : constant RC_Ptr := Get_Deep_Controller (A);\n-\n-   begin\n-      if Controller /= null then\n-         Adjust (Controller.all);\n-         Attach_To_Final_List (L, Controller.all, B);\n-      end if;\n-\n-      --  Is controlled\n-\n-      if V.all in Finalizable then\n-         Adjust (V.all);\n-         Attach_To_Final_List (L, Finalizable (V.all), 1);\n-      end if;\n-   end Deep_Tag_Adjust;\n-\n    ---------------------\n    -- Deep_Tag_Attach --\n    ----------------------\n@@ -280,74 +254,6 @@ package body System.Finalization_Implementation is\n       end if;\n    end Deep_Tag_Attach;\n \n-   -----------------------\n-   -- Deep_Tag_Finalize --\n-   -----------------------\n-\n-   procedure Deep_Tag_Finalize\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Boolean)\n-   is\n-      pragma Warnings (Off, L);\n-\n-      V          : constant SFR.Finalizable_Ptr := To_Finalizable_Ptr (A);\n-      Controller : constant RC_Ptr := Get_Deep_Controller (A);\n-\n-   begin\n-      if Controller /= null then\n-         if B then\n-            Finalize_One (Controller.all);\n-         else\n-            Finalize (Controller.all);\n-         end if;\n-      end if;\n-\n-      --  Is controlled\n-\n-      if V.all in Finalizable then\n-         if B then\n-            Finalize_One (V.all);\n-         else\n-            Finalize (V.all);\n-         end if;\n-      end if;\n-   end Deep_Tag_Finalize;\n-\n-   -------------------------\n-   -- Deep_Tag_Initialize --\n-   -------------------------\n-\n-   procedure Deep_Tag_Initialize\n-     (L : in out SFR.Finalizable_Ptr;\n-      A :        System.Address;\n-      B :        Short_Short_Integer)\n-   is\n-      V          : constant SFR.Finalizable_Ptr := To_Finalizable_Ptr (A);\n-      Controller : constant RC_Ptr := Get_Deep_Controller (A);\n-\n-   begin\n-      --  This procedure should not be called if the object has no\n-      --  controlled components\n-\n-      if Controller = null then\n-         raise Program_Error;\n-\n-      --  Has controlled components\n-\n-      else\n-         Initialize (Controller.all);\n-         Attach_To_Final_List (L, Controller.all, B);\n-      end if;\n-\n-      --  Is controlled\n-\n-      if V.all in Finalizable then\n-         Initialize (V.all);\n-         Attach_To_Final_List (Controller.F, Finalizable (Controller.all), 1);\n-      end if;\n-   end Deep_Tag_Initialize;\n-\n    -----------------------------\n    -- Detach_From_Final_List --\n    -----------------------------\n@@ -441,7 +347,7 @@ package body System.Finalization_Implementation is\n       --  programs using controlled types heavily.\n \n       if System.Restrictions.Abort_Allowed then\n-         X := To_Ptr (System.Soft_Links.Get_Current_Excep.all).Id;\n+         X := To_Ptr (SSL.Get_Current_Excep.all).Id;\n       end if;\n \n       while P /= null loop\n@@ -554,6 +460,34 @@ package body System.Finalization_Implementation is\n       Object.My_Address := Object'Address;\n    end Initialize;\n \n+   ---------------------\n+   -- Move_Final_List --\n+   ---------------------\n+\n+   procedure Move_Final_List\n+     (From : in out SFR.Finalizable_Ptr;\n+      To   : Finalizable_Ptr_Ptr)\n+   is\n+   begin\n+      --  This is currently called at the end of the return statement, and the\n+      --  caller does NOT defer aborts. We need to defer aborts to prevent\n+      --  mangling the finalization lists.\n+\n+      SSL.Abort_Defer.all;\n+\n+      --  Put the return statement's finalization list onto the caller's one,\n+      --  thus transferring responsibility for finalization of the return\n+      --  object to the caller.\n+\n+      Attach_To_Final_List (To.all, From.all, Nb_Link => 3);\n+\n+      --  Empty the return statement's finalization list, so that when the\n+      --  cleanup code executes, there will be nothing to finalize.\n+      From := null;\n+\n+      SSL.Abort_Undefer.all;\n+   end Move_Final_List;\n+\n    -------------------------\n    -- Raise_From_Finalize --\n    -------------------------"}, {"sha": "f5bb1d27d322c1621c62d53d3087d962a72a00d6", "filename": "gcc/ada/s-finimp.ads", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-finimp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-finimp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-finimp.ads?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,15 +51,15 @@ package System.Finalization_Implementation is\n \n    Collection_Finalization_Started : constant SFR.Finalizable_Ptr :=\n                                        To_Finalizable_Ptr (SSE.To_Address (1));\n-   --  This is used to implement the rule in RM-4.8(10.2/2) that requires an\n+   --  This is used to implement the rule in RM 4.8(10.2/2) that requires an\n    --  allocator to raise Program_Error if the collection finalization has\n    --  already started. See also Ada.Finalization.List_Controller. Finalize on\n    --  List_Controller first sets the list to Collection_Finalization_Started,\n    --  to indicate that finalization has started. An allocator will call\n    --  Attach_To_Final_List, which checks for the special value and raises\n-   --  Program_Error if appropriate. The value of\n-   --  Collection_Finalization_Started must be different from 'Access of any\n-   --  finalizable object, and different from null. See AI-280.\n+   --  Program_Error if appropriate. The Collection_Finalization_Started value\n+   --  must be different from 'Access of any finalizable object, and different\n+   --  from null. See AI-280.\n \n    Global_Final_List : SFR.Finalizable_Ptr;\n    --  This list stores the controlled objects defined in library-level\n@@ -72,60 +72,52 @@ package System.Finalization_Implementation is\n      (L       : in out SFR.Finalizable_Ptr;\n       Obj     : in out SFR.Finalizable;\n       Nb_Link : Short_Short_Integer);\n-   --  Attach finalizable object Obj to the linked list L. Nb_Link controls\n-   --  the number of link of the linked_list, and can be either 0 for no\n-   --  attachement, 1 for simple linked lists or 2 for doubly linked lists\n-   --  or even 3 for a simple attachement of a whole array of elements.\n-   --  Attachement to a simply linked list is not protected against\n-   --  concurrent access and should only be used in contexts where it\n-   --  doesn't matter, such as for objects allocated on the stack. In the\n-   --  case of an attachment on a doubly linked list, L must not be null\n-   --  and Obj will be inserted AFTER the first element and the attachment\n-   --  is protected against concurrent call. Typically used to attach to\n-   --  a dynamically allocated object to a List_Controller (whose first\n-   --  element is always a dummy element)\n+   --  Attach finalizable object Obj to the linked list L. Nb_Link controls the\n+   --  number of link of the linked_list, and is one of: 0 for no attachment, 1\n+   --  for simple linked lists or 2 for doubly linked lists or even 3 for a\n+   --  simple attachment of a whole array of elements. Attachment to a simply\n+   --  linked list is not protected against concurrent access and should only\n+   --  be used in contexts where it doesn't matter, such as for objects\n+   --  allocated on the stack. In the case of an attachment on a doubly linked\n+   --  list, L must not be null and Obj will be inserted AFTER the first\n+   --  element and the attachment is protected against concurrent call.\n+   --  Typically used to attach to a dynamically allocated object to a\n+   --  List_Controller (whose first element is always a dummy element)\n+\n+   type Finalizable_Ptr_Ptr is access all SFR.Finalizable_Ptr;\n+   --  A pointer to a finalization list. This is used as the type of the extra\n+   --  implicit formal which are passed to build-in-place functions that return\n+   --  controlled types (see Sem_Ch6). That extra formal is then passed on to\n+   --  Move_Final_List (below).\n+\n+   procedure Move_Final_List\n+     (From : in out SFR.Finalizable_Ptr;\n+      To   : Finalizable_Ptr_Ptr);\n+   --  Move all objects on From list to To list. This is used to implement\n+   --  build-in-place function returns. The return object is initially placed\n+   --  on a finalization list local to the return statement, in case the\n+   --  return statement is left prematurely (due to raising an exception,\n+   --  being aborted, or a goto or exit statement). Once the return statement\n+   --  has completed successfully, Move_Final_List is called to move the\n+   --  return object to the caller's finalization list.\n \n    procedure Finalize_List (L : SFR.Finalizable_Ptr);\n    --  Call Finalize on each element of the list L;\n \n    procedure Finalize_One (Obj  : in out SFR.Finalizable);\n-   --  Call Finalize on Obj and remove its final list.\n+   --  Call Finalize on Obj and remove its final list\n \n    ---------------------\n    -- Deep Procedures --\n    ---------------------\n \n-   procedure Deep_Tag_Initialize\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Short_Short_Integer);\n-   --  Generic initialize for tagged objects with controlled components.\n-   --  A is the address of the object, L the finalization list when it needs\n-   --  to be attached and B the attachement level (see Attach_To_Final_List).\n-\n-   procedure Deep_Tag_Adjust\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Short_Short_Integer);\n-   --  Generic adjust for tagged objects with controlled components.\n-   --  A is the address of the object, L the finalization list when it needs\n-   --  to be attached and B the attachement level (see Attach_To_Final_List).\n-\n-   procedure Deep_Tag_Finalize\n-     (L : in out SFR.Finalizable_Ptr;\n-      A : System.Address;\n-      B : Boolean);\n-   --  Generic finalize for tagged objects with controlled components.\n-   --  A is the address of the object, L the finalization list when it needs\n-   --  to be attached and B the attachement level (see Attach_To_Final_List).\n-\n    procedure Deep_Tag_Attach\n      (L : in out SFR.Finalizable_Ptr;\n       A : System.Address;\n       B : Short_Short_Integer);\n-   --  Generic attachement for tagged objects with controlled components.\n+   --  Generic attachment for tagged objects with controlled components.\n    --  A is the address of the object, L the finalization list when it needs\n-   --  to be attached and B the attachement level (see Attach_To_Final_List).\n+   --  to be attached and B the attachment level (see Attach_To_Final_List).\n \n    -----------------------------\n    -- Record Controller Types --\n@@ -141,11 +133,11 @@ package System.Finalization_Implementation is\n    end record;\n \n    procedure Initialize (Object : in out Limited_Record_Controller);\n-   --  Does nothing.\n+   --  Does nothing currently.\n \n    procedure Finalize (Object : in out Limited_Record_Controller);\n-   --  Finalize the controlled components of the enclosing record by\n-   --  following the list starting at Object.F.\n+   --  Finalize the controlled components of the enclosing record by following\n+   --  the list starting at Object.F.\n \n    type Record_Controller is\n       new Limited_Record_Controller with record\n@@ -156,13 +148,13 @@ package System.Finalization_Implementation is\n    --  Initialize the field My_Address to the Object'Address\n \n    procedure Adjust (Object : in out Record_Controller);\n-   --  Adjust the components and their finalization pointers by subtracting\n-   --  by the offset of the target and the source addresses of the assignment.\n+   --  Adjust the components and their finalization pointers by subtracting by\n+   --  the offset of the target and the source addresses of the assignment.\n \n    --  Inherit Finalize from Limited_Record_Controller\n \n    procedure Detach_From_Final_List (Obj : in out SFR.Finalizable);\n-   --  Remove the specified object from its Final list, which must be a\n-   --  doubly linked list.\n+   --  Remove the specified object from its Final list, which must be a doubly\n+   --  linked list.\n \n end System.Finalization_Implementation;"}, {"sha": "ae6908dac491051b3cb63502c66b68fc75a2deca", "filename": "gcc/ada/s-taskin.ads", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-taskin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-taskin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taskin.ads?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -364,10 +364,12 @@ package System.Tasking is\n    ------------------------------------\n \n    type Activation_Chain is limited private;\n-   --  Comment required ???\n+   --  Linked list of to-be-activated tasks, linked through\n+   --  Activation_Link. The order of tasks on the list is irrelevant, because\n+   --  the priority rules will ensure that they actually start activating in\n+   --  priority order.\n \n    type Activation_Chain_Access is access all Activation_Chain;\n-   --  Comment required ???\n \n    type Task_Procedure_Access is access procedure (Arg : System.Address);\n \n@@ -651,11 +653,14 @@ package System.Tasking is\n    --  Normally, a task starts out with internal master nesting level one\n    --  larger than external master nesting level. It is incremented to one by\n    --  Enter_Master, which is called in the task body only if the compiler\n-   --  thinks the task may have dependent tasks. It is set to for the\n+   --  thinks the task may have dependent tasks. It is set to 1 for the\n    --  environment task, the level 2 is reserved for server tasks of the\n    --  run-time system (the so called \"independent tasks\"), and the level 3 is\n-   --  for the library level tasks.\n+   --  for the library level tasks. Foreign threads which are detected by\n+   --  the run-time have a level of 0, allowing these tasks to be easily\n+   --  distinguished if needed.\n \n+   Foreign_Task_Level     : constant Master_Level := 0;\n    Environment_Task_Level : constant Master_Level := 1;\n    Independent_Task_Level : constant Master_Level := 2;\n    Library_Task_Level     : constant Master_Level := 3;\n@@ -1062,14 +1067,14 @@ package System.Tasking is\n private\n    Null_Task : constant Task_Id := null;\n \n-   type Activation_Chain is record\n+   type Activation_Chain is limited record\n       T_ID : Task_Id;\n    end record;\n-   pragma Volatile (Activation_Chain);\n \n-   --  Activation_chain is an in-out parameter of initialization procedures\n-   --  and it must be passed by reference because the init proc may terminate\n+   --  Activation_Chain is an in-out parameter of initialization procedures and\n+   --  it must be passed by reference because the init proc may terminate\n    --  abnormally after creating task components, and these must be properly\n-   --  registered for removal (Expunge_Unactivated_Tasks).\n+   --  registered for removal (Expunge_Unactivated_Tasks). The \"limited\" forces\n+   --  Activation_Chain to be a by-reference type; see RM-6.2(4).\n \n end System.Tasking;"}, {"sha": "d6fe66c1f4e98a953eac6315d6021f4ec191d2b6", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -149,6 +149,9 @@ package body System.Tasking.Stages is\n    --  trigger an automatic stack alignment suitable for GCC's assumptions if\n    --  need be.\n \n+   --  \"Vulnerable_...\" in the procedure names below means they must be called\n+   --  with abort deferred.\n+\n    procedure Vulnerable_Complete_Task (Self_ID : Task_Id);\n    --  Complete the calling task. This procedure must be called with\n    --  abort deferred. It should only be called by Complete_Task and\n@@ -520,9 +523,11 @@ package body System.Tasking.Stages is\n    begin\n       --  If Master is greater than the current master, it means that Master\n       --  has already awaited its dependent tasks. This raises Program_Error,\n-      --  by 4.8(10.3/2). See AI-280.\n+      --  by 4.8(10.3/2). See AI-280. Ignore this check for foreign threads.\n \n-      if Master > Self_ID.Master_Within then\n+      if Self_ID.Master_of_Task /= Foreign_Task_Level\n+        and then Master > Self_ID.Master_Within\n+      then\n          raise Program_Error with\n            \"create task after awaiting termination\";\n       end if;\n@@ -877,6 +882,53 @@ package body System.Tasking.Stages is\n       end if;\n    end Free_Task;\n \n+   ---------------------------\n+   -- Move_Activation_Chain --\n+   ---------------------------\n+\n+   procedure Move_Activation_Chain\n+     (From, To   : Activation_Chain_Access;\n+      New_Master : Master_ID)\n+   is\n+      Self_ID : constant Task_Id := STPO.Self;\n+      C       : Task_Id;\n+\n+   begin\n+      pragma Debug\n+        (Debug.Trace (Self_ID, \"Move_Activation_Chain\", 'C'));\n+\n+      --  Nothing to do if From is empty, and we can check that without\n+      --  deferring aborts.\n+\n+      C := From.all.T_ID;\n+\n+      if C = null then\n+         return;\n+      end if;\n+\n+      Initialization.Defer_Abort (Self_ID);\n+\n+      --  Loop through the From chain, changing their Master_of_Task\n+      --  fields, and to find the end of the chain.\n+\n+      loop\n+         C.Master_of_Task := New_Master;\n+         exit when C.Common.Activation_Link = null;\n+         C := C.Common.Activation_Link;\n+      end loop;\n+\n+      --  Hook From in at the start of To\n+\n+      C.Common.Activation_Link := To.all.T_ID;\n+      To.all.T_ID := From.all.T_ID;\n+\n+      --  Set From to empty\n+\n+      From.all.T_ID := null;\n+\n+      Initialization.Undefer_Abort (Self_ID);\n+   end Move_Activation_Chain;\n+\n    ------------------\n    -- Task_Wrapper --\n    ------------------\n@@ -1407,7 +1459,7 @@ package body System.Tasking.Stages is\n \n          C := All_Tasks_List;\n          while C /= null loop\n-            if C.Common.Activator = Self_ID then\n+            if C.Common.Activator = Self_ID and then C.Master_of_Task = CM then\n                return False;\n             end if;\n \n@@ -1449,13 +1501,24 @@ package body System.Tasking.Stages is\n       --  zero for new tasks, and the task should not exit the\n       --  sleep-loops that use this count until the count reaches zero.\n \n+      --  While we're counting, if we run across any unactivated tasks that\n+      --  belong to this master, we summarily terminate them as required by\n+      --  RM-9.2(6).\n+\n       Lock_RTS;\n       Write_Lock (Self_ID);\n \n       C := All_Tasks_List;\n       while C /= null loop\n-         if C.Common.Activator = Self_ID then\n+\n+         --  Terminate unactivated (never-to-be activated) tasks\n+\n+         if C.Common.Activator = Self_ID and then C.Master_of_Task = CM then\n             pragma Assert (C.Common.State = Unactivated);\n+            --  Usually, C.Common.Activator = Self_ID implies C.Master_of_Task\n+            --  = CM. The only case where C is pending activation by this\n+            --  task, but the master of C is not CM is in Ada 2005, when C is\n+            --  part of a return object of a build-in-place function.\n \n             Write_Lock (C);\n             C.Common.Activator := null;\n@@ -1465,6 +1528,8 @@ package body System.Tasking.Stages is\n             Unlock (C);\n          end if;\n \n+         --  Count it if dependent on this master\n+\n          if C.Common.Parent = Self_ID and then C.Master_of_Task = CM then\n             Write_Lock (C);\n \n@@ -1733,9 +1798,9 @@ package body System.Tasking.Stages is\n \n    --  Complete the calling task\n \n-   --  This procedure must be called with abort deferred. (That's why the\n-   --  name has \"Vulnerable\" in it.) It should only be called by Complete_Task\n-   --  and Finalize_Global_Tasks (for the environment task).\n+   --  This procedure must be called with abort deferred. It should only be\n+   --  called by Complete_Task and Finalize_Global_Tasks (for the environment\n+   --  task).\n \n    --  The effect is similar to that of Complete_Master. Differences include\n    --  the closing of entries here, and computation of the number of active"}, {"sha": "03abca42d8bcce65e4d21935c540b46039c89add", "filename": "gcc/ada/s-tassta.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-tassta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fs-tassta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.ads?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                  S p e c                                 --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -143,6 +143,8 @@ package System.Tasking.Stages is\n    --  it is not needed if priority-based scheduling is supported, since all\n    --  the activated tasks synchronize on the activators lock before they\n    --  start activating and so they should start activating in priority order.\n+   --  ??? Actually, the body of this package DOES reverse the chain, so I\n+   --  don't understand the above comment.\n \n    procedure Complete_Activation;\n    --  Compiler interface only. Do not call from within the RTS.\n@@ -255,6 +257,22 @@ package System.Tasking.Stages is\n    --  if T has terminated. Do nothing in the other case. It is called from\n    --  Unchecked_Deallocation, for objects that are or contain tasks.\n \n+   procedure Move_Activation_Chain\n+     (From, To   : Activation_Chain_Access;\n+      New_Master : Master_ID);\n+   --  Compiler interface only. Do not call from within the RTS.\n+   --  Move all tasks on From list to To list, and change their Master_of_Task\n+   --  to be New_Master. This is used to implement build-in-place function\n+   --  returns. Tasks that are part of the return object are initially placed\n+   --  on an activation chain local to the return statement, and their master\n+   --  is the return statement, in case the return statement is left\n+   --  prematurely (due to raising an exception, being aborted, or a goto or\n+   --  exit statement). Once the return statement has completed successfully,\n+   --  Move_Activation_Chain is called to move them to the caller's activation\n+   --  chain, and change their master to the one passed in by the caller. If\n+   --  that doesn't happen, they will never be activated, and will become\n+   --  terminated on leaving the return statement.\n+\n    function Terminated (T : Task_Id) return Boolean;\n    --  This is called by the compiler to implement the 'Terminated attribute.\n    --  Though is not required to be so by the ARM, we choose to synchronize"}, {"sha": "8fc23c2b3e1a285928337ad60c88f5642b1bd69f", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 176, "deletions": 196, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -124,11 +124,6 @@ package body Sem_Ch6 is\n    --  If proper warnings are enabled and the subprogram contains a construct\n    --  that cannot be inlined, the offending construct is flagged accordingly.\n \n-   type Conformance_Type is\n-     (Type_Conformant, Mode_Conformant, Subtype_Conformant, Fully_Conformant);\n-   --  Conformance type used for following call, meaning matches the\n-   --  RM definitions of the corresponding terms.\n-\n    procedure Check_Conformance\n      (New_Id                   : Entity_Id;\n       Old_Id                   : Entity_Id;\n@@ -177,15 +172,6 @@ package body Sem_Ch6 is\n    --  True otherwise. Proc is the entity for the procedure case and is used\n    --  in posting the warning message.\n \n-   function Conforming_Types\n-     (T1       : Entity_Id;\n-      T2       : Entity_Id;\n-      Ctype    : Conformance_Type;\n-      Get_Inst : Boolean := False) return Boolean;\n-   --  Check that two formal parameter types conform, checking both for\n-   --  equality of base types, and where required statically matching\n-   --  subtypes, depending on the setting of Ctype.\n-\n    procedure Enter_Overloaded_Entity (S : Entity_Id);\n    --  This procedure makes S, a new overloaded entity, into the first visible\n    --  entity with that name.\n@@ -367,7 +353,7 @@ package body Sem_Ch6 is\n \n    begin\n       Generate_Definition (Designator);\n-      Set_Is_Abstract (Designator);\n+      Set_Is_Abstract_Subprogram (Designator);\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n \n@@ -638,41 +624,6 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n-      --  ???Check for not-yet-implemented cases of AI-318.  Currently we\n-      --  warn, because that's convenient for our own use.  We might want to\n-      --  change these warnings to errors at some point.  This will go away\n-      --  once AI-318 is fully implemented.\n-      --\n-      --  In the first version, we plan not to implement limited function\n-      --  returns when the result type contains tasks or protected objects,\n-      --  and when the result subtype is unconstrained.\n-\n-      if Ada_Version >= Ada_05\n-        and then not Debug_Flag_Dot_L\n-        and then Is_Inherently_Limited_Type (R_Type)\n-      then\n-         if Has_Task (R_Type) then\n-            Error_Msg_N (\"(Ada 2005) return of task objects\" &\n-                         \" is not yet implemented\", N);\n-         end if;\n-\n-         if Is_Controlled (R_Type)\n-           or else Has_Controlled_Component (R_Type)\n-         then\n-            Error_Msg_N\n-              (\"(Ada 2005) return of limited controlled objects\" &\n-               \" is not yet implemented\", N);\n-         end if;\n-\n-         if\n-           Is_Composite_Type (R_Type) and then not Is_Constrained (R_Type)\n-         then\n-            Error_Msg_N\n-              (\"(Ada 2005) return of unconstrained limited composite objects\" &\n-               \" is not yet implemented\", N);\n-         end if;\n-      end if;\n-\n       if Present (Expr)\n         and then Present (Etype (Expr)) --  Could be False in case of errors.\n       then\n@@ -1373,7 +1324,9 @@ package body Sem_Ch6 is\n       --  subprogram declaration for it, in order to attach the body to inline.\n \n       procedure Copy_Parameter_List (Plist : List_Id);\n-      --  Comment required ???\n+      --  Utility to create a parameter profile for a new subprogram spec,\n+      --  when the subprogram has a body that acts as spec. This is done for\n+      --  some cases of inlining, and for private protected ops.\n \n       procedure Verify_Overriding_Indicator;\n       --  If there was a previous spec, the entity has been entered in the\n@@ -1767,7 +1720,7 @@ package body Sem_Ch6 is\n          Set_Is_Compilation_Unit (Body_Id, Is_Compilation_Unit (Spec_Id));\n          Set_Is_Child_Unit       (Body_Id, Is_Child_Unit       (Spec_Id));\n \n-         if Is_Abstract (Spec_Id) then\n+         if Is_Abstract_Subprogram (Spec_Id) then\n             Error_Msg_N (\"an abstract subprogram cannot have a body\", N);\n             return;\n          else\n@@ -1843,36 +1796,6 @@ package body Sem_Ch6 is\n                    (Etype (First_Entity (Spec_Id))));\n             end if;\n \n-            --  Ada 2005: A formal that is an access parameter may have a\n-            --  designated type imported through a limited_with clause, while\n-            --  the body has a regular with clause. Update the types of the\n-            --  formals accordingly, so that the non-limited view of each type\n-            --  is available in the body. We have already verified that the\n-            --  declarations are type-conformant.\n-\n-            if Ada_Version >= Ada_05 then\n-               declare\n-                  F_Spec : Entity_Id;\n-                  F_Body : Entity_Id;\n-\n-               begin\n-                  F_Spec := First_Formal (Spec_Id);\n-                  F_Body := First_Formal (Body_Id);\n-\n-                  while Present (F_Spec) loop\n-                     if Ekind (Etype (F_Spec)) = E_Anonymous_Access_Type\n-                       and then\n-                         From_With_Type (Designated_Type (Etype (F_Spec)))\n-                     then\n-                        Set_Etype (F_Spec, Etype (F_Body));\n-                     end if;\n-\n-                     Next_Formal (F_Spec);\n-                     Next_Formal (F_Body);\n-                  end loop;\n-               end;\n-            end if;\n-\n             --  Now make the formals visible, and place subprogram\n             --  on scope stack.\n \n@@ -2296,7 +2219,7 @@ package body Sem_Ch6 is\n             end if;\n \n             if Is_Interface (Etyp)\n-              and then not Is_Abstract (Designator)\n+              and then not Is_Abstract_Subprogram (Designator)\n               and then not (Ekind (Designator) = E_Procedure\n                               and then Null_Present (Specification (N)))\n             then\n@@ -2441,15 +2364,16 @@ package body Sem_Ch6 is\n          --  interface types the following error message will be reported later\n          --  (see Analyze_Subprogram_Declaration).\n \n-         if Is_Abstract (Etype (Designator))\n+         if Is_Abstract_Type (Etype (Designator))\n            and then not Is_Interface (Etype (Designator))\n            and then Nkind (Parent (N))\n                       /= N_Abstract_Subprogram_Declaration\n            and then (Nkind (Parent (N)))\n                       /= N_Formal_Abstract_Subprogram_Declaration\n            and then (Nkind (Parent (N)) /= N_Subprogram_Renaming_Declaration\n                       or else not Is_Entity_Name (Name (Parent (N)))\n-                      or else not Is_Abstract (Entity (Name (Parent (N)))))\n+                      or else not Is_Abstract_Subprogram\n+                                    (Entity (Name (Parent (N)))))\n          then\n             Error_Msg_N\n               (\"function that returns abstract type must be abstract\", N);\n@@ -2464,7 +2388,7 @@ package body Sem_Ch6 is\n    --------------------------\n \n    procedure Build_Body_To_Inline (N : Node_Id; Subp : Entity_Id) is\n-      Decl : constant Node_Id := Unit_Declaration_Node (Subp);\n+      Decl            : constant Node_Id := Unit_Declaration_Node (Subp);\n       Original_Body   : Node_Id;\n       Body_To_Analyze : Node_Id;\n       Max_Size        : constant := 10;\n@@ -2479,24 +2403,24 @@ package body Sem_Ch6 is\n       --  elementary statements, as a measure of acceptable size.\n \n       function Has_Pending_Instantiation return Boolean;\n-      --  If some enclosing body contains instantiations that appear before\n-      --  the corresponding generic body, the enclosing body has a freeze node\n-      --  so that it can be elaborated after the generic itself. This might\n+      --  If some enclosing body contains instantiations that appear before the\n+      --  corresponding generic body, the enclosing body has a freeze node so\n+      --  that it can be elaborated after the generic itself. This might\n       --  conflict with subsequent inlinings, so that it is unsafe to try to\n       --  inline in such a case.\n \n       function Has_Single_Return return Boolean;\n-      --  In general we cannot inline functions that return unconstrained\n-      --  type. However, we can handle such functions if all return statements\n-      --  return a local variable that is the only declaration in the body\n-      --  of the function. In that case the call can be replaced by that\n-      --  local variable as is done for other inlined calls.\n+      --  In general we cannot inline functions that return unconstrained type.\n+      --  However, we can handle such functions if all return statements return\n+      --  a local variable that is the only declaration in the body of the\n+      --  function. In that case the call can be replaced by that local\n+      --  variable as is done for other inlined calls.\n \n       procedure Remove_Pragmas;\n-      --  A pragma Unreferenced that mentions a formal parameter has no\n-      --  meaning when the body is inlined and the formals are rewritten.\n-      --  Remove it from body to inline. The analysis of the non-inlined body\n-      --  will handle the pragma properly.\n+      --  A pragma Unreferenced that mentions a formal parameter has no meaning\n+      --  when the body is inlined and the formals are rewritten. Remove it\n+      --  from body to inline. The analysis of the non-inlined body will handle\n+      --  the pragma properly.\n \n       function Uses_Secondary_Stack (Bod : Node_Id) return Boolean;\n       --  If the body of the subprogram includes a call that returns an\n@@ -3462,7 +3386,7 @@ package body Sem_Ch6 is\n             --  are left by an erroneous overriding.\n \n             if not Is_Predefined_Dispatching_Operation (Prim_Op)\n-              and then not Is_Abstract (Prim_Op)\n+              and then not Is_Abstract_Subprogram (Prim_Op)\n               and then Chars (Prim_Op) = Chars (Op)\n               and then Type_Conformant (Prim_Op, Op)\n               and then Convention (Prim_Op) /= Convention (Op)\n@@ -3503,7 +3427,7 @@ package body Sem_Ch6 is\n          --  of abstract primitives left from an erroneous overriding.\n \n          if not Is_Predefined_Dispatching_Operation (Prim_Op)\n-           and then not Is_Abstract (Prim_Op)\n+           and then not Is_Abstract_Subprogram (Prim_Op)\n          then\n             Check_Convention\n               (Op          => Prim_Op,\n@@ -3550,7 +3474,9 @@ package body Sem_Ch6 is\n    begin\n       --  Never need to freeze abstract subprogram\n \n-      if Is_Abstract (Designator) then\n+      if Ekind (Designator) /= E_Subprogram_Type\n+        and then Is_Abstract_Subprogram (Designator)\n+      then\n          null;\n       else\n          --  Need delayed freeze if return type itself needs a delayed\n@@ -3585,7 +3511,7 @@ package body Sem_Ch6 is\n             if Is_Inherently_Limited_Type (Typ) then\n                Set_Returns_By_Ref (Designator);\n \n-            elsif Present (Utyp) and then Controlled_Type (Utyp) then\n+            elsif Present (Utyp) and then CW_Or_Controlled_Type (Utyp) then\n                Set_Returns_By_Ref (Designator);\n             end if;\n          end;\n@@ -3801,6 +3727,7 @@ package body Sem_Ch6 is\n       if Nkind (Decl) = N_Subprogram_Body\n         or else Nkind (Decl) = N_Subprogram_Body_Stub\n         or else Nkind (Decl) = N_Subprogram_Declaration\n+        or else Nkind (Decl) = N_Abstract_Subprogram_Declaration\n         or else Nkind (Decl) = N_Subprogram_Renaming_Declaration\n       then\n          Spec := Specification (Decl);\n@@ -3819,15 +3746,41 @@ package body Sem_Ch6 is\n             if Ekind (Subp) = E_Entry then\n                Error_Msg_NE (\"entry & overrides inherited operation #\",\n                              Spec, Subp);\n+\n             else\n                Error_Msg_NE (\"subprogram & overrides inherited operation #\",\n                              Spec, Subp);\n             end if;\n          end if;\n+\n+      --  If Subp is an operator, it may override a predefined operation.\n+      --  In that case overridden_subp is empty because of our implicit\n+      --  representation for predefined operators. We have to check whether\n+      --  the signature of Subp matches that of a predefined operator.\n+      --  Note that first argument provides the name of the operator, and\n+      --  the second argument the signature that may match that of a standard\n+      --  operation.\n+\n+      elsif Nkind (Subp) = N_Defining_Operator_Symbol\n+        and then  Must_Not_Override (Spec)\n+      then\n+         if Operator_Matches_Spec (Subp, Subp) then\n+            Error_Msg_NE\n+              (\"subprogram & overrides predefined operation \",\n+                 Spec, Subp);\n+         end if;\n+\n       else\n          if Must_Override (Spec) then\n             if Ekind (Subp) = E_Entry then\n                Error_Msg_NE (\"entry & is not overriding\", Spec, Subp);\n+\n+            elsif Nkind (Subp) = N_Defining_Operator_Symbol then\n+               if not Operator_Matches_Spec (Subp, Subp) then\n+                  Error_Msg_NE\n+                    (\"subprogram & is not overriding\", Spec, Subp);\n+               end if;\n+\n             else\n                Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n             end if;\n@@ -3936,7 +3889,6 @@ package body Sem_Ch6 is\n                declare\n                   Arg : constant Node_Id :=\n                           Original_Node (First_Actual (Last_Stm));\n-\n                begin\n                   if Nkind (Arg) = N_Attribute_Reference\n                     and then Attribute_Name (Arg) = Name_Identity\n@@ -4379,28 +4331,11 @@ package body Sem_Ch6 is\n       --  treated recursively because they carry a signature.\n \n       Are_Anonymous_Access_To_Subprogram_Types :=\n-\n-         --  Case 1: Anonymous access to subprogram types\n-\n-        (Ekind (Type_1) = E_Anonymous_Access_Subprogram_Type\n-           and then Ekind (Type_2) = E_Anonymous_Access_Subprogram_Type)\n-\n-         --  Case 2: Anonymous access to PROTECTED subprogram types. In this\n-         --  case the anonymous type_declaration has been replaced by an\n-         --  occurrence of an internal access to subprogram type declaration\n-         --  available through the Original_Access_Type attribute\n-\n-        or else\n-          (Ekind (Type_1) = E_Access_Protected_Subprogram_Type\n-            and then Ekind (Type_2) = E_Access_Protected_Subprogram_Type\n-            and then not Comes_From_Source (Type_1)\n-            and then not Comes_From_Source (Type_2)\n-            and then Present (Original_Access_Type (Type_1))\n-            and then Present (Original_Access_Type (Type_2))\n-            and then Ekind (Original_Access_Type (Type_1)) =\n-                       E_Anonymous_Access_Protected_Subprogram_Type\n-            and then Ekind (Original_Access_Type (Type_2)) =\n-                       E_Anonymous_Access_Protected_Subprogram_Type);\n+        Ekind (Type_1) = Ekind (Type_2)\n+          and then\n+            (Ekind (Type_1) =  E_Anonymous_Access_Subprogram_Type\n+             or else\n+               Ekind (Type_1) = E_Anonymous_Access_Protected_Subprogram_Type);\n \n       --  Test anonymous access type case. For this case, static subtype\n       --  matching is required for mode conformance (RM 6.3.1(15))\n@@ -4544,16 +4479,9 @@ package body Sem_Ch6 is\n          EF : constant Entity_Id :=\n                 Make_Defining_Identifier (Sloc (Assoc_Entity),\n                   Chars  => New_External_Name (Chars (Assoc_Entity),\n-                  Suffix => Suffix));\n+                                               Suffix => Suffix));\n \n       begin\n-         --  We never generate extra formals if expansion is not active\n-         --  because we don't need them unless we are generating code.\n-\n-         if not Expander_Active then\n-            return Empty;\n-         end if;\n-\n          --  A little optimization. Never generate an extra formal for the\n          --  _init operand of an initialization procedure, since it could\n          --  never be used.\n@@ -4586,6 +4514,13 @@ package body Sem_Ch6 is\n    --  Start of processing for Create_Extra_Formals\n \n    begin\n+      --  We never generate extra formals if expansion is not active\n+      --  because we don't need them unless we are generating code.\n+\n+      if not Expander_Active then\n+         return;\n+      end if;\n+\n       --  If this is a derived subprogram then the subtypes of the parent\n       --  subprogram's formal parameters will be used to to determine the need\n       --  for extra formals.\n@@ -4601,7 +4536,7 @@ package body Sem_Ch6 is\n          Next_Formal (Formal);\n       end loop;\n \n-      --  If Extra_formals where already created, don't do it again. This\n+      --  If Extra_formals were already created, don't do it again. This\n       --  situation may arise for subprogram types created as part of\n       --  dispatching calls (see Expand_Dispatching_Call)\n \n@@ -4642,10 +4577,8 @@ package body Sem_Ch6 is\n             end if;\n \n             if Has_Discriminants (Formal_Type)\n-              and then\n-                ((not Is_Constrained (Formal_Type)\n-                    and then not Is_Indefinite_Subtype (Formal_Type))\n-                  or else Present (Extra_Formal (Formal)))\n+              and then not Is_Constrained (Formal_Type)\n+              and then not Is_Indefinite_Subtype (Formal_Type)\n             then\n                Set_Extra_Constrained\n                  (Formal,\n@@ -4657,7 +4590,7 @@ package body Sem_Ch6 is\n          --  Create extra formal for supporting accessibility checking\n \n          --  This is suppressed if we specifically suppress accessibility\n-         --  checks at the pacage level for either the subprogram, or the\n+         --  checks at the package level for either the subprogram, or the\n          --  package in which it resides. However, we do not suppress it\n          --  simply if the scope has accessibility checks suppressed, since\n          --  this could cause trouble when clients are compiled with a\n@@ -4687,63 +4620,110 @@ package body Sem_Ch6 is\n             end if;\n          end if;\n \n-         if Present (P_Formal) then\n-            Next_Formal (P_Formal);\n-         end if;\n-\n          --  This label is required when skipping extra formal generation for\n          --  Unchecked_Union parameters.\n \n          <<Skip_Extra_Formal_Generation>>\n \n+         if Present (P_Formal) then\n+            Next_Formal (P_Formal);\n+         end if;\n+\n          Next_Formal (Formal);\n       end loop;\n \n       --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n-      --  an extra formal that will be passed the address of the return object\n-      --  within the caller. This is added as the last extra formal, but\n-      --  eventually will be accompanied by other implicit formals related to\n-      --  build-in-place functions (such as allocate/deallocate subprograms,\n-      --  finalization list, constrained flag, task master, task activation\n-      --  list, etc.).\n-\n-      if Expander_Active\n-        and then Ada_Version >= Ada_05\n-        and then Is_Build_In_Place_Function (E)\n-      then\n+      --  appropriate extra formals. See type Exp_Ch6.BIP_Formal_Kind.\n+\n+      if Ada_Version >= Ada_05 and then Is_Build_In_Place_Function (E) then\n          declare\n-            Formal_Type        : constant Entity_Id :=\n-                                   Create_Itype\n-                                     (E_Anonymous_Access_Type,\n-                                      E, Scope_Id => Scope (E));\n-            Result_Subt        : constant Entity_Id := Etype (E);\n-            Result_Addr_Formal : Entity_Id;\n+            Result_Subt : constant Entity_Id := Etype (E);\n+\n+            Discard : Entity_Id;\n+            pragma Warnings (Off, Discard);\n \n          begin\n-            Set_Directly_Designated_Type (Formal_Type, Result_Subt);\n-            Set_Etype (Formal_Type, Formal_Type);\n-            Init_Size_Align (Formal_Type);\n-            Set_Depends_On_Private\n-              (Formal_Type, Has_Private_Component (Formal_Type));\n-            Set_Is_Public (Formal_Type, Is_Public (Scope (Formal_Type)));\n-            Set_Is_Access_Constant (Formal_Type, False);\n-            Set_Can_Never_Be_Null (Formal_Type);\n+            --  In the case of functions with unconstrained result subtypes,\n+            --  add a 3-state formal indicating whether the return object is\n+            --  allocated by the caller (0), or should be allocated by the\n+            --  callee on the secondary stack (1) or in the global heap (2).\n+            --  For the moment we just use Natural for the type of this formal.\n+            --  Note that this formal isn't needed in the case where the\n+            --  result subtype is constrained.\n+\n+            if not Is_Constrained (Result_Subt) then\n+               Discard :=\n+                 Add_Extra_Formal\n+                   (E, Standard_Natural,\n+                    E, BIP_Formal_Suffix (BIP_Alloc_Form));\n+            end if;\n \n-            --  Ada 2005 (AI-50217): Propagate the attribute that indicates\n-            --  the designated type comes from the limited view (for back-end\n-            --  purposes).\n+            --  In the case of functions whose result type has controlled\n+            --  parts, we have an extra formal of type\n+            --  System.Finalization_Implementation.Finalizable_Ptr_Ptr. That\n+            --  is, we are passing a pointer to a finalization list (which is\n+            --  itself a pointer). This extra formal is then passed along to\n+            --  Move_Final_List in case of successful completion of a return\n+            --  statement. We cannot pass an 'in out' parameter, because we\n+            --  need to update the finalization list during an abort-deferred\n+            --  region, rather than using copy-back after the function\n+            --  returns. This is true even if we are able to get away with\n+            --  having 'in out' parameters, which are normally illegal for\n+            --  functions.\n+\n+            if Is_Controlled (Result_Subt)\n+              or else Has_Controlled_Component (Result_Subt)\n+            then\n+               Discard :=\n+                 Add_Extra_Formal\n+                   (E, RTE (RE_Finalizable_Ptr_Ptr),\n+                    E, BIP_Formal_Suffix (BIP_Final_List));\n+            end if;\n+\n+            --  If the result type contains tasks, we have two extra formals:\n+            --  the master of the tasks to be created, and the caller's\n+            --  activation chain.\n+\n+            if Has_Task (Result_Subt) then\n+               Discard :=\n+                 Add_Extra_Formal\n+                   (E, RTE (RE_Master_Id),\n+                    E, BIP_Formal_Suffix (BIP_Master));\n+               Discard :=\n+                 Add_Extra_Formal\n+                   (E, RTE (RE_Activation_Chain_Access),\n+                    E, BIP_Formal_Suffix (BIP_Activation_Chain));\n+            end if;\n \n-            Set_From_With_Type (Formal_Type, From_With_Type (Result_Subt));\n+            --  All build-in-place functions get an extra formal that will be\n+            --  passed the address of the return object within the caller.\n \n-            Layout_Type (Formal_Type);\n+            declare\n+               Formal_Type : constant Entity_Id :=\n+                               Create_Itype\n+                                 (E_Anonymous_Access_Type, E,\n+                                  Scope_Id => Scope (E));\n+            begin\n+               Set_Directly_Designated_Type (Formal_Type, Result_Subt);\n+               Set_Etype (Formal_Type, Formal_Type);\n+               Init_Size_Align (Formal_Type);\n+               Set_Depends_On_Private\n+                 (Formal_Type, Has_Private_Component (Formal_Type));\n+               Set_Is_Public (Formal_Type, Is_Public (Scope (Formal_Type)));\n+               Set_Is_Access_Constant (Formal_Type, False);\n \n-            Result_Addr_Formal := Add_Extra_Formal (E, Formal_Type, E, \"RA\");\n+               --  Ada 2005 (AI-50217): Propagate the attribute that indicates\n+               --  the designated type comes from the limited view (for\n+               --  back-end purposes).\n \n-            --  For some reason the following is not effective and the\n-            --  dereference of the formal within the function still gets\n-            --  a check. ???\n+               Set_From_With_Type (Formal_Type, From_With_Type (Result_Subt));\n \n-            Set_Can_Never_Be_Null (Result_Addr_Formal);\n+               Layout_Type (Formal_Type);\n+\n+               Discard :=\n+                 Add_Extra_Formal\n+                   (E, Formal_Type, E, BIP_Formal_Suffix (BIP_Object_Access));\n+            end;\n          end;\n       end if;\n    end Create_Extra_Formals;\n@@ -4813,8 +4793,10 @@ package body Sem_Ch6 is\n \n             --  Warn unless genuine overloading\n \n-            if (not Is_Overloadable (E))\n-              or else Subtype_Conformant (E, S)\n+            if (not Is_Overloadable (E) or else Subtype_Conformant (E, S))\n+                  and then (Is_Immediately_Visible (E)\n+                              or else\n+                            Is_Potentially_Use_Visible (S))\n             then\n                Error_Msg_Sloc := Sloc (E);\n                Error_Msg_N (\"declaration of & hides one#?\", S);\n@@ -5698,7 +5680,7 @@ package body Sem_Ch6 is\n          Remove (Decl);\n          Set_Has_Completion (Op_Name);\n          Set_Corresponding_Equality (Op_Name, S);\n-         Set_Is_Abstract (Op_Name, Is_Abstract (S));\n+         Set_Is_Abstract_Subprogram (Op_Name, Is_Abstract_Subprogram (S));\n       end;\n    end Make_Inequality_Operator;\n \n@@ -5827,7 +5809,7 @@ package body Sem_Ch6 is\n          --  declarations because they don't have interface lists.\n \n          if Nkind (Parent (Typ)) /= N_Full_Type_Declaration then\n-            Collect_Synchronized_Interfaces (Typ, Ifaces_List);\n+            Collect_Abstract_Interfaces (Typ, Ifaces_List);\n \n             if not Is_Empty_Elmt_List (Ifaces_List) then\n                Overridden_Subp :=\n@@ -5900,22 +5882,14 @@ package body Sem_Ch6 is\n               and then Visible_Part_Type (T)\n               and then not In_Instance\n             then\n-               if Is_Abstract (T)\n-                 and then Is_Abstract (S)\n-                 and then (not Is_Overriding or else not Is_Abstract (E))\n+               if Is_Abstract_Type (T)\n+                 and then Is_Abstract_Subprogram (S)\n+                 and then (not Is_Overriding\n+                           or else not Is_Abstract_Subprogram (E))\n                then\n-                  if not Is_Interface (T) then\n-                     Error_Msg_N (\"abstract subprograms must be visible \"\n+                  Error_Msg_N (\"abstract subprograms must be visible \"\n                                    & \"('R'M 3.9.3(10))!\", S);\n \n-                  --  Ada 2005 (AI-251)\n-\n-                  else\n-                     Error_Msg_N (\"primitive subprograms of interface types \"\n-                       & \"declared in a visible part, must be declared in \"\n-                       & \"the visible part ('R'M 3.9.4)!\", S);\n-                  end if;\n-\n                elsif Ekind (S) = E_Function\n                  and then Is_Tagged_Type (T)\n                  and then T = Base_Type (Etype (S))\n@@ -6609,6 +6583,12 @@ package body Sem_Ch6 is\n             Formal_Type :=\n               Access_Definition (Related_Nod, Parameter_Type (Param_Spec));\n \n+            --  No need to continue if we already notified errors\n+\n+            if not Present (Formal_Type) then\n+               return;\n+            end if;\n+\n             --  Ada 2005 (AI-254)\n \n             declare\n@@ -6619,7 +6599,7 @@ package body Sem_Ch6 is\n                if Present (AD) and then Protected_Present (AD) then\n                   Formal_Type :=\n                     Replace_Anonymous_Access_To_Protected_Subprogram\n-                      (Param_Spec, Formal_Type);\n+                      (Param_Spec);\n                end if;\n             end;\n          end if;"}, {"sha": "f465c80debfc6fd679a4d5ae20a306a36bcb19bc", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f937473fe94fce0786cf2a69337f402c49cb20e5/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=f937473fe94fce0786cf2a69337f402c49cb20e5", "patch": "@@ -27,6 +27,12 @@\n with Types; use Types;\n package Sem_Ch6 is\n \n+   type Conformance_Type is\n+     (Type_Conformant, Mode_Conformant, Subtype_Conformant, Fully_Conformant);\n+   --  Conformance type used in conformance checks between specs and bodies,\n+   --  and for overriding. The literals match the RM definitions of the\n+   --  corresponding terms.\n+\n    procedure Analyze_Abstract_Subprogram_Declaration (N : Node_Id);\n    procedure Analyze_Extended_Return_Statement       (N : Node_Id);\n    procedure Analyze_Function_Call                   (N : Node_Id);\n@@ -39,7 +45,8 @@ package Sem_Ch6 is\n \n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id;\n    --  Analyze subprogram specification in both subprogram declarations\n-   --  and body declarations. Returns the defining entity for the spec.\n+   --  and body declarations. Returns the defining entity for the\n+   --  specification N.\n \n    procedure Cannot_Inline (Msg : String; N : Node_Id; Subp : Entity_Id);\n    --  This procedure is called if the node N, an instance of a call to\n@@ -55,9 +62,9 @@ package Sem_Ch6 is\n    --  their respective counterparts.\n \n    procedure Check_Delayed_Subprogram (Designator : Entity_Id);\n-   --  Designator can be a E_Subrpgram_Type, E_Procedure or E_Function. If a\n+   --  Designator can be a E_Subprogram_Type, E_Procedure or E_Function. If a\n    --  type in its profile depends on a private type without a full\n-   --  declaration, indicate that the subprogram is delayed.\n+   --  declaration, indicate that the subprogram or type is delayed.\n \n    procedure Check_Discriminant_Conformance\n      (N        : Node_Id;\n@@ -112,6 +119,16 @@ package Sem_Ch6 is\n    --  the flag being placed on the Err_Loc node if it is specified, and\n    --  on the appropriate component of the New_Id construct if not.\n \n+   function Conforming_Types\n+     (T1       : Entity_Id;\n+      T2       : Entity_Id;\n+      Ctype    : Conformance_Type;\n+      Get_Inst : Boolean := False) return Boolean;\n+   --  Check that the types of two formal parameters are conforming. In most\n+   --  cases this is just a name comparison, but within an instance it involves\n+   --  generic actual types, and in the presence of anonymous access types\n+   --  it must examine the designated types.\n+\n    procedure Create_Extra_Formals (E : Entity_Id);\n    --  For each parameter of a subprogram or entry that requires an additional\n    --  formal (such as for access parameters and indefinite discriminated"}]}