{"sha": "e9bd9cf340129729a451df77baee39f5b2978226", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTliZDljZjM0MDEyOTcyOWE0NTFkZjc3YmFlZTM5ZjViMjk3ODIyNg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2007-07-07T03:25:29Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2007-07-07T03:25:29Z"}, "message": "re PR middle-end/23488 (GCSE load PRE does not work with non sets (or missing load PRE with plain decls))\n\n2007-07-06  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/23488\n\n\t* tree-ssa-sccvn.c (expr_has_constants): Handle tcc_declaration.\n\t(try_to_simplify): Ditto.\n\t(visit_use): Ditto.\n\t* tree-vn.c (set_value_handle): Use decl_vh_map for decl value\n\thandles.\n\t* tree-flow-inline.h (get_value_handle): Ditto.\n\t* tree-ssa-pre.c (decl_vh_map): New.\n\t(decl_node_pool): New.\n\t(can_value_number_operation): Support DECL_P.\n\t(can_PRE_operation): Ditto.\n\t(create_expression_by_pieces): Ditto.\n\t(find_existing_value_expr): Modify to differnetiate between\n\taddressing and top level.\n\t(create_value_handle_for_expr): Handle DECL's.\n\t(poolify_tree): Ditto.\n\t(make_values_for_phi): Don't insert into PHI_GEN during FRE.\n\t(make_values_for_stmt): Handle DECL's properly.\n\t(init_pre): Reorg to not init useless things during FRE.\n\t(fini_pre): Ditto.\n\t* tree-flow.h: Include pointer-set.h.\n\t(decl_vh_map): Declare.\n\t* Makefile.in (TREE_FLOW_H): Add pointer-set.h\n\nFrom-SVN: r126434", "tree": {"sha": "24aed28d0f9be6fc1f86cf8db9b21c0fc8d53291", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24aed28d0f9be6fc1f86cf8db9b21c0fc8d53291"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9bd9cf340129729a451df77baee39f5b2978226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9bd9cf340129729a451df77baee39f5b2978226", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9bd9cf340129729a451df77baee39f5b2978226", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9bd9cf340129729a451df77baee39f5b2978226/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3673b8ca2b37955838b1c238ba9f70c2a30ac298", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3673b8ca2b37955838b1c238ba9f70c2a30ac298", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3673b8ca2b37955838b1c238ba9f70c2a30ac298"}], "stats": {"total": 312, "additions": 211, "deletions": 101}, "files": [{"sha": "5f9ffcd87dcfb6cab9cf025795b24457ed669efc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -1,3 +1,30 @@\n+2007-07-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\tFix PR tree-optimization/23488\n+\n+\t* tree-ssa-sccvn.c (expr_has_constants): Handle tcc_declaration.\n+\t(try_to_simplify): Ditto.\n+\t(visit_use): Ditto.\n+\t* tree-vn.c (set_value_handle): Use decl_vh_map for decl value\n+\thandles.\n+\t* tree-flow-inline.h (get_value_handle): Ditto.\n+\t* tree-ssa-pre.c (decl_vh_map): New.\n+\t(decl_node_pool): New.\n+\t(can_value_number_operation): Support DECL_P.\n+\t(can_PRE_operation): Ditto.\n+\t(create_expression_by_pieces): Ditto.\n+\t(find_existing_value_expr): Modify to differnetiate between\n+\taddressing and top level.\n+\t(create_value_handle_for_expr): Handle DECL's.\n+\t(poolify_tree): Ditto.\n+\t(make_values_for_phi): Don't insert into PHI_GEN during FRE.\n+\t(make_values_for_stmt): Handle DECL's properly.\n+\t(init_pre): Reorg to not init useless things during FRE.\n+\t(fini_pre): Ditto.\n+\t* tree-flow.h: Include pointer-set.h.\n+\t(decl_vh_map): Declare.\n+\t* Makefile.in (TREE_FLOW_H): Add pointer-set.h\n+\t\t\n 2007-07-06  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* c-opts.c (c_common_handle_option): Make DOLLARS_IN_IDENTIFIERS"}, {"sha": "045bfee732d62098a1704c992292d37b8d9d7cf5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -805,7 +805,7 @@ TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)\n TREE_GIMPLE_H = tree-gimple.h tree-iterator.h\n TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n \t\tbitmap.h $(BASIC_BLOCK_H) hard-reg-set.h $(TREE_GIMPLE_H) \\\n-\t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H)\n+\t\t$(HASHTAB_H) $(CGRAPH_H) $(IPA_REFERENCE_H) pointer-set.h\n TREE_SSA_LIVE_H = tree-ssa-live.h $(PARTITION_H) vecprim.h\n PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H) options.h"}, {"sha": "20b4f95b06e96cbd6de8ba6fbe24d42d1a7a5486", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -1,3 +1,8 @@\n+2007-07-06  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* gcc.dg/tree-ssa/ssa-pre-17.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-fre-7.c: New test.\n+\n 2007-07-06  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gcc.dg/20001012-1.c: Run on all fpic-capable targets."}, {"sha": "6963c1ce483c08bdde88fd982ab5c9a744f1d1a4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-6.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-6.c?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre-details\" } */\n+\n+ int i; int foo(void) { i = 2; int j = i * 2; int k = i + 2; return j == k; }\n+/* { dg-final { scan-tree-dump-times \"Replaced \" 5 \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "8fbfced3d5edf78c67b96dddc58c3f7996effb58", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-17.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-17.c?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-pre-details\" } */\n+\n+ int i; \n+ int foo(int q) { \n+     int j;\n+     int p;\n+     for (j = 0; j < 9; j++)\n+       {\n+\t p = i + q;\n+       }\n+     return p;\n+ }\n+/* We should replace p = a load from i that will pop into the loop, with a hoisted version.\n+   We should also replace i + q with a hoisted version.  */\n+/* { dg-final { scan-tree-dump-times \"Replaced \" 2 \"pre\" } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "2ab4a5ec1c8f3327770773e955e92acfff185711", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -1792,12 +1792,20 @@ get_value_handle (tree expr)\n {\n   if (TREE_CODE (expr) == SSA_NAME)\n     return SSA_NAME_VALUE (expr);\n-  else if (DECL_P (expr) || TREE_CODE (expr) == TREE_LIST\n+  else if (TREE_CODE (expr) == TREE_LIST\n \t   || TREE_CODE (expr) == CONSTRUCTOR)\n     {\n       tree_ann_common_t ann = tree_common_ann (expr);\n       return ((ann) ? ann->value_handle : NULL_TREE);\n     }\n+  else if (DECL_P (expr))\n+    {\n+      tree *result = (tree *)pointer_map_contains (decl_vh_map,\n+\t\t\t\t\t\t   expr);\n+      if (result)\n+\treturn *result;\n+      return NULL_TREE;\n+    }\n   else if (is_gimple_min_invariant (expr))\n     return expr;\n   else if (EXPR_P (expr))"}, {"sha": "d521a16b933f3870c3320ddb13d1a3cdcc282527", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -31,6 +31,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"tree-ssa-operands.h\"\n #include \"cgraph.h\"\n #include \"ipa-reference.h\"\n+#include \"pointer-set.h\"\n \n /* Forward declare structures for the garbage collector GTY markers.  */\n #ifndef GCC_BASIC_BLOCK_H\n@@ -1081,7 +1082,7 @@ extern bool maybe_clean_or_replace_eh_stmt (tree, tree);\n void add_to_value (tree, tree);\n void debug_value_expressions (tree);\n void print_value_expressions (FILE *, tree);\n-\n+extern struct pointer_map_t *decl_vh_map;\n \n /* In tree-vn.c  */\n tree make_value_handle (tree);"}, {"sha": "9ea3057e9ef88dae17cb92b416ead0c0d13ae7c2", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 131, "deletions": 95, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -46,6 +46,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"langhooks.h\"\n #include \"cfgloop.h\"\n #include \"tree-ssa-sccvn.h\"\n+#include \"pointer-set.h\"\n \n /* TODO:\n \n@@ -182,6 +183,14 @@ Boston, MA 02110-1301, USA.  */\n    useful only for debugging, since we don't do identity lookups.  */\n \n \n+/* Mapping from decl's to value handles, by pointer equality.  We\n+   \"unshare\" decls so we can give the same decl in different places\n+   different value handles.  */\n+struct pointer_map_t *decl_vh_map;\n+\n+/* Mapping from expressions to ids.  */\n+struct pointer_map_t *expression_id_map;\n+\n /* Next global expression id number.  */\n static unsigned int next_expression_id;\n \n@@ -193,15 +202,14 @@ static VEC(tree, heap) *expressions;\n static inline unsigned int\n alloc_expression_id (tree expr)\n {\n-  tree_ann_common_t ann;\n-\n-  ann = get_tree_common_ann (expr);\n+  unsigned int *slot;\n \n+  slot = (unsigned int *) pointer_map_insert (expression_id_map,\n+\t\t\t\t\t      expr);\n   /* Make sure we won't overflow. */\n   gcc_assert (next_expression_id + 1 > next_expression_id);\n \n-  ann->aux = XNEW (unsigned int);\n-  * ((unsigned int *)ann->aux) = next_expression_id++;\n+  *slot = next_expression_id++;\n   VEC_safe_push (tree, heap, expressions, expr);\n   return next_expression_id - 1;\n }\n@@ -211,11 +219,10 @@ alloc_expression_id (tree expr)\n static inline unsigned int\n get_expression_id (tree expr)\n {\n-  tree_ann_common_t ann = tree_common_ann (expr);\n-  gcc_assert (ann);\n-  gcc_assert (ann->aux);\n-\n-  return  *((unsigned int *)ann->aux);\n+  unsigned int *slot;\n+  slot = (unsigned int *) pointer_map_contains (expression_id_map,\n+\t\t\t\t\t\texpr);\n+  return *slot;\n }\n \n /* Return the existing expression id for EXPR, or create one if one\n@@ -224,12 +231,13 @@ get_expression_id (tree expr)\n static inline unsigned int\n get_or_alloc_expression_id (tree expr)\n {\n-  tree_ann_common_t ann = tree_common_ann (expr);\n-\n-  if (ann == NULL || !ann->aux)\n+  unsigned int *slot;\n+  slot = (unsigned int *) pointer_map_contains (expression_id_map,\n+\t\t\t\t\t\texpr);\n+  if (slot)\n+    return *slot;\n+  else\n     return alloc_expression_id (expr);\n-\n-  return get_expression_id (expr);\n }\n \n /* Return the expression that has expression id ID */\n@@ -240,23 +248,6 @@ expression_for_id (unsigned int id)\n   return VEC_index (tree, expressions, id);\n }\n \n-/* Free the expression id field in all of our expressions,\n-   and then destroy the expressions array.  */\n-\n-static void\n-clear_expression_ids (void)\n-{\n-  int i;\n-  tree expr;\n-\n-  for (i = 0; VEC_iterate (tree, expressions, i, expr); i++)\n-    {\n-      free (tree_common_ann (expr)->aux);\n-      tree_common_ann (expr)->aux = NULL;\n-    }\n-  VEC_free (tree, heap, expressions);\n-}\n-\n static bool in_fre = false;\n \n /* An unordered bitmap set.  One bitmap tracks values, the other,\n@@ -369,6 +360,7 @@ static alloc_pool unary_node_pool;\n static alloc_pool reference_node_pool;\n static alloc_pool comparison_node_pool;\n static alloc_pool modify_expr_node_pool;\n+static alloc_pool decl_node_pool;\n static bitmap_obstack grand_bitmap_obstack;\n \n /* We can't use allocation pools to hold temporary CALL_EXPR objects, since\n@@ -954,7 +946,8 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n     return expr;\n \n   /* Phi translations of a given expression don't change.  */\n-  if (EXPR_P (expr) || GIMPLE_STMT_P (expr))\n+  if (EXPR_P (expr) || GIMPLE_STMT_P (expr) || REFERENCE_CLASS_P (expr)\n+      || DECL_P (expr))\n     {\n       tree vh;\n \n@@ -1101,7 +1094,13 @@ phi_translate_1 (tree expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\t\t\t\t\t    pred);\n \n \tif (oldvuses != newvuses)\n-\t  vn_lookup_or_add_with_vuses (expr, newvuses);\n+\t  {\n+\t    tree newexpr = (tree) pool_alloc (decl_node_pool);\n+\t    memcpy (newexpr, expr, tree_size (expr));\n+\t    vn_lookup_or_add_with_vuses (newexpr, newvuses);\n+\t    expr = newexpr;\n+\t    phi_trans_add (expr, expr, pred, newvuses);\n+\t  }\n \n \tphi_trans_add (oldexpr, expr, pred, newvuses);\n       }\n@@ -2065,6 +2064,7 @@ can_value_number_operation (tree op)\n     || BINARY_CLASS_P (op)\n     || COMPARISON_CLASS_P (op)\n     || REFERENCE_CLASS_P (op)\n+    || DECL_P (op)\n     || (TREE_CODE (op) == CALL_EXPR\n \t&& can_value_number_call (op));\n }\n@@ -2080,6 +2080,7 @@ can_PRE_operation (tree op)\n   return UNARY_CLASS_P (op)\n     || BINARY_CLASS_P (op)\n     || COMPARISON_CLASS_P (op)\n+    || DECL_P (op)\n     || TREE_CODE (op) == INDIRECT_REF\n     || TREE_CODE (op) == COMPONENT_REF\n     || TREE_CODE (op) == CALL_EXPR\n@@ -2316,7 +2317,14 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \t\t\t      genop1, genop2);\n \tbreak;\n       }\n-\n+    case tcc_declaration:\n+      {\n+\t/* Get the \"shared\" version of the DECL, that we didn't create\n+\t   using a pool.  */\n+\tfolded = referenced_var_lookup (DECL_UID (expr));\n+      }\n+      break;\n+      \n     case tcc_unary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n@@ -2957,10 +2965,15 @@ find_existing_value_expr (tree t, tree stmt)\n    replaced with the value handles of each of the operands of EXPR.\n \n    VUSES represent the virtual use operands associated with EXPR (if\n-   any). Insert EXPR's operands into the EXP_GEN set for BLOCK. */\n+   any). Insert EXPR's operands into the EXP_GEN set for BLOCK.\n+\n+   TOP_LEVEL is true if we are at the top of the original\n+   expression.  This is used to differentiate between addressing and\n+   actual loads of globals.  IE a = t vs a = t[0].  */\n \n static inline tree\n-create_value_expr_from (tree expr, basic_block block, tree stmt)\n+create_value_expr_from (tree expr, basic_block block, tree stmt,\n+\t\t\tbool top_level)\n {\n   int i;\n   enum tree_code code = TREE_CODE (expr);\n@@ -2985,6 +2998,8 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n     pool = binary_node_pool;\n   else if (TREE_CODE_CLASS (code) == tcc_comparison)\n     pool = comparison_node_pool;\n+  else if (TREE_CODE_CLASS (code) == tcc_declaration)\n+    pool = decl_node_pool;\n   else\n     gcc_assert (code == CALL_EXPR);\n \n@@ -2995,20 +3010,23 @@ create_value_expr_from (tree expr, basic_block block, tree stmt)\n       vexpr = (tree) pool_alloc (pool);\n       memcpy (vexpr, expr, tree_size (expr));\n     }\n-\n+  \n   for (i = 0; i < TREE_OPERAND_LENGTH (expr); i++)\n     {\n       tree val = NULL_TREE;\n       tree op;\n-\n+      \n+      if (i != 0)\n+\ttop_level = false;\n+      \n       op = TREE_OPERAND (expr, i);\n       if (op == NULL_TREE)\n \tcontinue;\n \n       /* Recursively value-numberize reference ops and tree lists.  */\n       if (REFERENCE_CLASS_P (op))\n \t{\n-\t  tree tempop = create_value_expr_from (op, block, stmt);\n+\t  tree tempop = create_value_expr_from (op, block, stmt, false);\n \t  op = tempop ? tempop : op;\n \t  val = vn_lookup_or_add_with_stmt (op, stmt);\n \t}\n@@ -3059,13 +3077,15 @@ poolify_tree (tree node)\n \treturn temp;\n       }\n       break;\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+    case VAR_DECL:\n+    case CONST_DECL:\n+    case FUNCTION_DECL:\n     case SSA_NAME:\n     case INTEGER_CST:\n     case STRING_CST:\n     case REAL_CST:\n-    case PARM_DECL:\n-    case VAR_DECL:\n-    case RESULT_DECL:\n       return node;\n     default:\n       gcc_unreachable ();\n@@ -3280,7 +3300,8 @@ make_values_for_phi (tree phi, basic_block block)\n       if (sccvnval)\n \t{\n \t  vn_add (result, sccvnval);\n-\t  bitmap_insert_into_set (PHI_GEN (block), result);\n+\t  if (!in_fre)\n+\t    bitmap_insert_into_set (PHI_GEN (block), result);\n \t  bitmap_value_insert_into_set (AVAIL_OUT (block), result);\n \t}\n       else\n@@ -3348,7 +3369,7 @@ make_values_for_stmt (tree stmt, basic_block block)\n       /* For value numberable operation, create a\n \t duplicate expression with the operands replaced\n \t with the value handles of the original RHS.  */\n-      tree newt = create_value_expr_from (rhs, block, stmt);\n+      tree newt = create_value_expr_from (rhs, block, stmt, true);\n       if (newt)\n \t{\n \t  /* If we already have a value number for the LHS, reuse\n@@ -3376,8 +3397,7 @@ make_values_for_stmt (tree stmt, basic_block block)\n \t    && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs))\n \t   || is_gimple_min_invariant (rhs)\n \t   || TREE_CODE (rhs) == ADDR_EXPR\n-\t   || TREE_INVARIANT (rhs)\n-\t   || DECL_P (rhs))\n+\t   || TREE_INVARIANT (rhs))\n     {\n       \n       if (lhsval)\n@@ -3785,7 +3805,8 @@ static void\n init_pre (bool do_fre)\n {\n   basic_block bb;\n-  \n+  unsigned int max_decl_size;\n+\n   next_expression_id = 0;\n   expressions = NULL;\n   in_fre = do_fre;\n@@ -3796,52 +3817,63 @@ init_pre (bool do_fre)\n   storetemp = NULL_TREE;\n   prephitemp = NULL_TREE;\n \n-  if (!do_fre)\n-    loop_optimizer_init (LOOPS_NORMAL);\n-\n-  connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n-\n-\n-  postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n-  post_order_compute (postorder, false, false);\n-\n+  bitmap_obstack_initialize (&grand_bitmap_obstack);\n+  \n+  if (!do_fre)\n+    {\n+      loop_optimizer_init (LOOPS_NORMAL);\n+      connect_infinite_loops_to_exit ();\n+      postorder = XNEWVEC (int, n_basic_blocks - NUM_FIXED_BLOCKS);\n+      post_order_compute (postorder, false, false);\n+      calculate_dominance_info (CDI_POST_DOMINATORS);\n+      phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n+\t\t\t\t\t expr_pred_trans_eq, free);\n+      seen_during_translate = BITMAP_ALLOC (&grand_bitmap_obstack);\n+      binary_node_pool = create_alloc_pool (\"Binary tree nodes\",\n+\t\t\t\t\t    tree_code_size (PLUS_EXPR), 30);\n+      unary_node_pool = create_alloc_pool (\"Unary tree nodes\",\n+\t\t\t\t\t   tree_code_size (NEGATE_EXPR), 30);\n+      reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n+\t\t\t\t\t       tree_code_size (ARRAY_REF), 30);\n+      comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n+\t\t\t\t\t\ttree_code_size (EQ_EXPR), 30);\n+      modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n+\t\t\t\t\t\t tree_code_size (GIMPLE_MODIFY_STMT),\n+\t\t\t\t\t\t 30);  \n+      max_decl_size = MAX (tree_code_size (VAR_DECL), tree_code_size (PARM_DECL));\n+      max_decl_size = MAX (max_decl_size, tree_code_size (RESULT_DECL));\n+      max_decl_size = MAX (max_decl_size, tree_code_size (CONST_DECL));\n+      max_decl_size = MAX (max_decl_size, tree_code_size (FUNCTION_DECL));\n+      decl_node_pool = create_alloc_pool (\"_DECL nodes\", max_decl_size, 30);\n+      \n+      obstack_init (&temp_call_expr_obstack);\n+      modify_expr_template = NULL;\n+    }\n+ \n   FOR_ALL_BB (bb)\n     bb->aux = xcalloc (1, sizeof (struct bb_bitmap_sets));\n \n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  bitmap_obstack_initialize (&grand_bitmap_obstack);\n-  phi_translate_table = htab_create (5110, expr_pred_trans_hash,\n-\t\t\t\t     expr_pred_trans_eq, free);\n-  seen_during_translate = BITMAP_ALLOC (&grand_bitmap_obstack);\n   bitmap_set_pool = create_alloc_pool (\"Bitmap sets\",\n \t\t\t\t       sizeof (struct bitmap_set), 30);\n-  binary_node_pool = create_alloc_pool (\"Binary tree nodes\",\n-\t\t\t\t\ttree_code_size (PLUS_EXPR), 30);\n-  unary_node_pool = create_alloc_pool (\"Unary tree nodes\",\n-\t\t\t\t       tree_code_size (NEGATE_EXPR), 30);\n-  reference_node_pool = create_alloc_pool (\"Reference tree nodes\",\n-\t\t\t\t\t   tree_code_size (ARRAY_REF), 30);\n-  comparison_node_pool = create_alloc_pool (\"Comparison tree nodes\",\n-\t\t\t\t\t    tree_code_size (EQ_EXPR), 30);\n-  modify_expr_node_pool = create_alloc_pool (\"GIMPLE_MODIFY_STMT nodes\",\n-\t\t\t\t\t     tree_code_size (GIMPLE_MODIFY_STMT),\n-\t\t\t\t\t     30);\n-  obstack_init (&temp_call_expr_obstack);\n-  modify_expr_template = NULL;\n \n   FOR_ALL_BB (bb)\n     {\n-      EXP_GEN (bb) = bitmap_set_new ();\n-      PHI_GEN (bb) = bitmap_set_new ();\n-      TMP_GEN (bb) = bitmap_set_new ();\n+      if (!do_fre)\n+\t{\n+\t  EXP_GEN (bb) = bitmap_set_new ();\n+\t  PHI_GEN (bb) = bitmap_set_new ();\n+\t  TMP_GEN (bb) = bitmap_set_new ();\n+\t}\n       AVAIL_OUT (bb) = bitmap_set_new ();\n     }\n-  maximal_set = in_fre ? NULL : bitmap_set_new ();\n+  maximal_set = do_fre ? NULL : bitmap_set_new ();\n \n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n+  decl_vh_map = pointer_map_create ();\n+  expression_id_map = pointer_map_create ();\n }\n \n \n@@ -3852,36 +3884,41 @@ fini_pre (void)\n {\n   basic_block bb;\n   unsigned int i;\n-\n-  free (postorder);\n-  VEC_free (tree, heap, inserted_exprs);\n-  VEC_free (tree, heap, need_creation);\n+  \n+  if (!in_fre)\n+    {\n+      free (postorder);\n+      VEC_free (tree, heap, inserted_exprs);\n+      VEC_free (tree, heap, need_creation);\n+      free_alloc_pool (binary_node_pool);\n+      free_alloc_pool (reference_node_pool);\n+      free_alloc_pool (unary_node_pool);\n+      free_alloc_pool (comparison_node_pool);\n+      free_alloc_pool (modify_expr_node_pool);\n+      free_alloc_pool (decl_node_pool);\n+      htab_delete (phi_translate_table);\n+      remove_fake_exit_edges ();\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+    }\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (bitmap_set_pool);\n-  free_alloc_pool (binary_node_pool);\n-  free_alloc_pool (reference_node_pool);\n-  free_alloc_pool (unary_node_pool);\n-  free_alloc_pool (comparison_node_pool);\n-  free_alloc_pool (modify_expr_node_pool);\n-  htab_delete (phi_translate_table);\n-  remove_fake_exit_edges ();\n \n   FOR_ALL_BB (bb)\n     {\n       free (bb->aux);\n       bb->aux = NULL;\n     }\n \n-  free_dominance_info (CDI_POST_DOMINATORS);\n-\n   if (!bitmap_empty_p (need_eh_cleanup))\n     {\n       tree_purge_all_dead_eh_edges (need_eh_cleanup);\n       cleanup_tree_cfg ();\n     }\n \n   BITMAP_FREE (need_eh_cleanup);\n-\n+  pointer_map_destroy (decl_vh_map);\n+  pointer_map_destroy (expression_id_map);\n+  \n   /* Wipe out pointers to VALUE_HANDLEs.  In the not terribly distant\n      future we will want them to be persistent though.  */\n   for (i = 0; i < num_ssa_names; i++)\n@@ -3895,7 +3932,7 @@ fini_pre (void)\n \t  && TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n \tSSA_NAME_VALUE (name) = NULL;\n     }\n-  if (current_loops != NULL)\n+  if (current_loops != NULL && !in_fre)\n     loop_optimizer_finalize ();\n }\n \n@@ -3956,7 +3993,6 @@ execute_pre (bool do_fre)\n   bsi_commit_edge_inserts ();\n \n   free_scc_vn ();\n-  clear_expression_ids ();\n   if (!do_fre)\n     {\n       remove_dead_inserted_code ();"}, {"sha": "651f747e479a30ad77b8381bea01e25de2e96626", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -1332,6 +1332,7 @@ expr_has_constants (tree expr)\n       /* Constants inside reference ops are rarely interesting, but\n \t it can take a lot of looking to find them.  */\n     case tcc_reference:\n+    case tcc_declaration:\n       return false;\n     default:\n       return is_gimple_min_invariant (expr);\n@@ -1453,7 +1454,7 @@ try_to_simplify (tree stmt, tree rhs)\n \t{\n \t  /* For references, see if we find a result for the lookup,\n \t     and use it if we do.  */\n-\n+\tcase tcc_declaration:\n \tcase tcc_reference:\n \t  {\n \t    tree result = vn_reference_lookup (rhs,\n@@ -1613,7 +1614,7 @@ visit_use (tree use)\n \t  if (TREE_CODE (lhs) == SSA_NAME\n \t      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n \t    changed = defs_to_varying (stmt);\n-\t  else if (REFERENCE_CLASS_P (lhs))\n+\t  else if (REFERENCE_CLASS_P (lhs) || DECL_P (lhs))\n \t    {\n \t      changed = visit_reference_op_store (lhs, rhs, stmt);\n \t    }"}, {"sha": "1afd0fedef4d65f67de6cc7c71ab4f089c092756", "filename": "gcc/tree-vn.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-vn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9bd9cf340129729a451df77baee39f5b2978226/gcc%2Ftree-vn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vn.c?ref=e9bd9cf340129729a451df77baee39f5b2978226", "patch": "@@ -83,6 +83,10 @@ expressions_equal_p (tree e1, tree e2)\n       return true;\n \n     }\n+  else if (TREE_CODE (e1) == TREE_CODE (e2)\n+\t   && DECL_P (e1)\n+\t   && te1 == te2)\n+    return DECL_UID (e1) == DECL_UID (e2);\n   else if (TREE_CODE (e1) == TREE_CODE (e2) \n \t   && (te1 == te2\n \t       || types_compatible_p (te1, te2))\n@@ -99,7 +103,12 @@ set_value_handle (tree e, tree v)\n {\n   if (TREE_CODE (e) == SSA_NAME)\n     SSA_NAME_VALUE (e) = v;\n-  else if (EXPR_P (e) || DECL_P (e) || TREE_CODE (e) == TREE_LIST\n+  else if (DECL_P (e))\n+    {\n+      tree *slot = (tree *)pointer_map_insert (decl_vh_map, e);\n+      *slot = v;\n+    }\n+  else if (EXPR_P (e) || TREE_CODE (e) == TREE_LIST\n \t   || GIMPLE_STMT_P (e)\n \t   || TREE_CODE (e) == CONSTRUCTOR)\n     get_tree_common_ann (e)->value_handle = v;"}]}