{"sha": "ba3aa0e6c7552cceaefe7cb23db2daf40a32de00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzYWEwZTZjNzU1MmNjZWFlZmU3Y2IyM2RiMmRhZjQwYTMyZGUwMA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-11-06T17:16:00Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2011-11-06T17:16:00Z"}, "message": "41975.cc: Add tests to check performance with or without cache of hash code and with...\n\n2011-11-06  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n\n\t* testsuite/performance/23_containers/insert_erase/41975.cc: Add\n\ttests to check performance with or without cache of hash code and with\n\tstring type that has a costlier hash functor than int type.\n\nFrom-SVN: r181037", "tree": {"sha": "483dbed39e4a71e8aace8c3acdf89b1f00d0ad4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/483dbed39e4a71e8aace8c3acdf89b1f00d0ad4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00/comments", "author": null, "committer": null, "parents": [{"sha": "86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86951993f8a4cae2fb26bf8705e2f248a8d6f21e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86951993f8a4cae2fb26bf8705e2f248a8d6f21e"}], "stats": {"total": 181, "additions": 149, "deletions": 32}, "files": [{"sha": "b04f1a9c1ac156ac80be92240cee4cb331a4a05f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ba3aa0e6c7552cceaefe7cb23db2daf40a32de00", "patch": "@@ -1,3 +1,9 @@\n+2011-11-06  Fran\u00e7ois Dumont <fdumont@gcc.gnu.org>\n+\n+\t* testsuite/performance/23_containers/insert_erase/41975.cc: Add\n+\ttests to check performance with or without cache of hash code and with\n+\tstring type that has a costlier hash functor than int type.\n+\n 2011-11-06  Benjamin Kosnik  <bkoz@redhat.com>\n \t    Andrew MacLeod  <amacleod@redhat.com>\n "}, {"sha": "a5dae41dc60ab5d8f49a75c457a92118726d4494", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert_erase/41975.cc", "status": "modified", "additions": 143, "deletions": 32, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3aa0e6c7552cceaefe7cb23db2daf40a32de00/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc?ref=ba3aa0e6c7552cceaefe7cb23db2daf40a32de00", "patch": "@@ -17,56 +17,167 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include <cassert>\n+#include <sstream>\n #include <unordered_set>\n #include <testsuite_performance.h>\n \n-int main()\n+namespace\n {\n-  using namespace __gnu_test;\n+  // Bench using an unordered_set<int>. Hash functor for int is quite\n+  // predictable so it helps bench very specific use cases.\n+  template<bool use_cache>\n+    void bench()\n+    {\n+      using namespace __gnu_test;\n+      std::ostringstream ostr;\n+      ostr << \"unordered_set<int> \" << (use_cache ? \"with\" : \"without\")\n+\t   << \" cache\";\n+      const std::string desc = ostr.str();\n+\n+      time_counter time;\n+      resource_counter resource;\n+\n+      const int nb = 200000;\n+      start_counters(time, resource);\n+\n+      std::__unordered_set<int, std::hash<int>, std::equal_to<int>,\n+\t\t\t   std::allocator<int>, use_cache> us;\n+      for (int i = 0; i != nb; ++i)\n+\tus.insert(i);\n+\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": first insert\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+      start_counters(time, resource);\n+\n+      // Here is the worst erase use case when hashtable implementation was\n+      // something like vector<forward_list<>>. Erasing from the end was very\n+      // costly because we need to return the iterator following the erased\n+      // one, as the hashtable is getting emptier at each step there are\n+      // more and more empty bucket to loop through to reach the end of the\n+      // container and find out that it was in fact the last element.\n+      for (int j = nb - 1; j >= 0; --j)\n+\t{\n+\t  auto it = us.find(j);\n+\t  if (it != us.end())\n+\t    us.erase(it);\n+\t}\n \n-  time_counter time;\n-  resource_counter resource;\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": erase from iterator\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n \n-  start_counters(time, resource);\n+      start_counters(time, resource);\n \n-  std::unordered_set<int> us;\n-  for (int i = 0; i != 5000000; ++i)\n-    us.insert(i);\n+      // This is a worst insertion use case for the current implementation as\n+      // we insert an element at the begining of the hashtable and then we\n+      // insert starting at the end so that each time we need to seek up to the\n+      // first bucket to find the first non-empty one.\n+      us.insert(0);\n+      for (int i = nb - 1; i >= 0; --i)\n+\tus.insert(i);\n \n-  stop_counters(time, resource);\n-  report_performance(__FILE__, \"Container generation\", time, resource);\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": second insert\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n \n-  start_counters(time, resource);\n+      start_counters(time, resource);\n \n-  for (int j = 100; j != 0; --j)\n+      for (int j = nb - 1; j >= 0; --j)\n+\tus.erase(j);\n+\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": erase from key\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+    }\n+\n+  // Bench using unordered_set<string> that show how important it is to cache\n+  // hash code as computing string hash code is quite expensive compared to\n+  // computing it for int.\n+  template<bool use_cache>\n+    void bench_str()\n     {\n-      auto it = us.begin();\n-      while (it != us.end())\n+      using namespace __gnu_test;\n+      std::ostringstream ostr;\n+      ostr << \"unordered_set<string> \" << (use_cache ? \"with\" : \"without\")\n+\t   << \" cache\";\n+      const std::string desc = ostr.str();\n+\n+      time_counter time;\n+      resource_counter resource;\n+\n+      const int nb = 200000;\n+      // First generate once strings that are going to be used throughout the\n+      // bench:\n+      std::vector<std::string> strs;\n+      strs.reserve(nb);\n+      for (int i = 0; i != nb; ++i)\n+      {\n+\tostr.str(\"\");\n+\tostr << \"string #\" << i;\n+\tstrs.push_back(ostr.str());\n+      }\n+\n+      start_counters(time, resource);\n+\n+      std::__unordered_set<std::string, std::hash<std::string>,\n+\t\t\t   std::equal_to<std::string>,\n+\t\t\t   std::allocator<std::string>, use_cache> us;\n+      for (int i = 0; i != nb; ++i)\n+\tus.insert(strs[i]);\n+\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": first insert\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+      start_counters(time, resource);\n+\n+      for (int j = nb - 1; j >= 0; --j)\n \t{\n-\t  if ((*it % j) == 0)\n-\t    it = us.erase(it);\n-\t  else\n-\t    ++it;\n+\t  auto it = us.find(strs[j]);\n+\t  if (it != us.end())\n+\t    us.erase(it);\n \t}\n-    }\n \n-  stop_counters(time, resource);\n-  report_performance(__FILE__, \"Container erase\", time, resource);\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": erase from iterator\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n \n-  start_counters(time, resource);\n+      start_counters(time, resource);\n \n-  us.insert(0);\n+      us.insert(strs[0]);\n+      for (int i = nb - 1; i >= 0; --i)\n+\tus.insert(strs[i]);\n \n-  for (int i = 0; i != 500; ++i)\n-    {\n-      auto it = us.begin();\n-      ++it;\n-      assert( it == us.end() );\n-    }\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": second insert\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+\n+      start_counters(time, resource);\n+\n+      for (int j = nb - 1; j >= 0; --j)\n+\tus.erase(strs[j]);\n \n-  stop_counters(time, resource);\n-  report_performance(__FILE__, \"Container iteration\", time, resource);\n+      stop_counters(time, resource);\n+      ostr.str(\"\");\n+      ostr << desc << \": erase from key\";\n+      report_performance(__FILE__, ostr.str().c_str(), time, resource);\n+    }\n+}\n \n+int main()\n+{\n+  bench<false>();\n+  bench<true>();\n+  bench_str<false>();\n+  bench_str<true>();\n   return 0;\n }"}]}