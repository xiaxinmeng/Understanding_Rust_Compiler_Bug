{"sha": "54269f054f818c6bc958242809b5f766dc758cf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQyNjlmMDU0ZjgxOGM2YmM5NTgyNDI4MDliNWY3NjZkYzc1OGNmNA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2008-06-16T10:39:07Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2008-06-16T10:39:07Z"}, "message": "re PR tree-optimization/36493 (vectorizer aliasing bug)\n\n\tPR tree-optimization/36493\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Remove TYPE from\n\tthe arguments list. Use VECTYPE to create vector pointer.\n\t(vectorizable_store): Fail if accesses through a pointer to vectype\n\tdo not alias the original memory reference operands.\n\tCall vect_create_data_ref_ptr without the removed argument.\n\t(vectorizable_load): Likewise.\n\t(vect_setup_realignment): Call vect_create_data_ref_ptr without the\n\tremoved argument.\n\nFrom-SVN: r136843", "tree": {"sha": "f7ada106868dc6feee115753eee2066ceab6839d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7ada106868dc6feee115753eee2066ceab6839d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54269f054f818c6bc958242809b5f766dc758cf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54269f054f818c6bc958242809b5f766dc758cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54269f054f818c6bc958242809b5f766dc758cf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54269f054f818c6bc958242809b5f766dc758cf4/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7364f2868c8ac21e519725d716bc13f02b19684f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7364f2868c8ac21e519725d716bc13f02b19684f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7364f2868c8ac21e519725d716bc13f02b19684f"}], "stats": {"total": 89, "additions": 78, "deletions": 11}, "files": [{"sha": "6b6a931e948719dd8619e6c42aa95a145a456b43", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=54269f054f818c6bc958242809b5f766dc758cf4", "patch": "@@ -1,3 +1,15 @@\n+2008-06-16  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/36493\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Remove TYPE from\n+\tthe arguments list. Use VECTYPE to create vector pointer.\n+\t(vectorizable_store): Fail if accesses through a pointer to vectype\n+\tdo not alias the original memory reference operands.\n+\tCall vect_create_data_ref_ptr without the removed argument.\n+\t(vectorizable_load): Likewise.\n+\t(vect_setup_realignment): Call vect_create_data_ref_ptr without the\n+\tremoved argument.\n+\n 2008-06-015  Andy Hutchinson  <hutchinsonandy@aim.com>\n \n \tPR target/36336"}, {"sha": "e97e60b6ebf3f948013343e360c2c984bbe4b49e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=54269f054f818c6bc958242809b5f766dc758cf4", "patch": "@@ -1,3 +1,8 @@\n+2008-06-16  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/36493\n+\t* gcc.dg/vect/pr36493.c: New testcase.\n+\n 2008-06-15  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/36515"}, {"sha": "d96e96221d45b7d607dd0f36e8727981e6471e74", "filename": "gcc/testsuite/gcc.dg/vect/pr36493.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr36493.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr36493.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr36493.c?ref=54269f054f818c6bc958242809b5f766dc758cf4", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int\n+main (void)\n+{\n+  int i;\n+  long x[12] __attribute__((aligned(16)));\n+\n+  x[0] = 1;\n+  for (i = 0; i < 12; i++)\n+    x[i] = i;\n+\n+  if (x[0] != 0)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "4110b335d7450c274bc14d8b93505b7c66f1253d", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 38, "deletions": 11, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54269f054f818c6bc958242809b5f766dc758cf4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=54269f054f818c6bc958242809b5f766dc758cf4", "patch": "@@ -49,7 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n static bool vect_transform_stmt (tree, block_stmt_iterator *, bool *, slp_tree);\n static tree vect_create_destination_var (tree, tree);\n static tree vect_create_data_ref_ptr \n-  (tree, struct loop*, tree, tree *, tree *, bool, tree, bool *); \n+  (tree, struct loop*, tree, tree *, tree *, bool, bool *); \n static tree vect_create_addr_base_for_vector_ref \n   (tree, tree *, tree, struct loop *);\n static tree vect_get_new_vect_var (tree, enum vect_var_kind, const char *);\n@@ -951,7 +951,6 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n         by the data-ref in STMT.\n    4. ONLY_INIT: indicate if vp is to be updated in the loop, or remain\n         pointing to the initial address.\n-   5. TYPE: if not NULL indicates the required type of the data-ref\n \n    Output:\n    1. Declare a new ptr to vector_type, and have it point to the base of the\n@@ -981,7 +980,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n static tree\n vect_create_data_ref_ptr (tree stmt, struct loop *at_loop,\n \t\t\t  tree offset, tree *initial_address, tree *ptr_incr,\n-\t\t\t  bool only_init, tree type, bool *inv_p)\n+\t\t\t  bool only_init, bool *inv_p)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -1040,10 +1039,8 @@ vect_create_data_ref_ptr (tree stmt, struct loop *at_loop,\n     }\n \n   /** (1) Create the new vector-pointer variable:  **/\n-  if (type)  \n-    vect_ptr_type = build_pointer_type (type);\n-  else\n-    vect_ptr_type = build_pointer_type (vectype);\n+  vect_ptr_type = build_pointer_type (vectype);\n+\n   vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n                                     get_name (base_name));\n   add_referenced_var (vect_ptr);\n@@ -4756,6 +4753,24 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n       return false;\n     }\n \n+  /* If accesses through a pointer to vectype do not alias the original\n+     memory reference we have a problem.  */\n+  if (get_alias_set (vectype) != get_alias_set (TREE_TYPE (scalar_dest))\n+      && !alias_set_subset_of (get_alias_set (vectype), \n+                               get_alias_set (TREE_TYPE (scalar_dest))))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vector type does not alias scalar type\");\n+      return false;\n+    }\n+\n+  if (!useless_type_conversion_p (TREE_TYPE (op), TREE_TYPE (scalar_dest)))\n+    {      \n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"operands of different types\");\n+      return false;\n+    }\n+\n   vec_mode = TYPE_MODE (vectype);\n   /* FORNOW. In some cases can vectorize even if data-type not supported\n      (e.g. - array initialization with 0).  */\n@@ -4930,9 +4945,10 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n \t\t  next_stmt = DR_GROUP_NEXT_DR (vinfo_for_stmt (next_stmt));\n \t\t}\n \t    }\n+\n \t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, NULL, NULL_TREE, \n-\t\t\t\t\t\t  &dummy, &ptr_incr, false,\n-\t\t\t\t\t\t  TREE_TYPE (vec_oprnd), &inv_p);\n+\t\t\t\t\t\t  &dummy, &ptr_incr, false, \n+\t\t\t\t\t\t  &inv_p);\n \t  gcc_assert (!inv_p);\n \t}\n       else \n@@ -5170,7 +5186,7 @@ vect_setup_realignment (tree stmt, block_stmt_iterator *bsi,\n       pe = loop_preheader_edge (loop_for_initial_load);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       ptr = vect_create_data_ref_ptr (stmt, loop_for_initial_load, NULL_TREE,\n-\t\t\t\t&init_addr, &inc, true, NULL_TREE, &inv_p);\n+\t\t\t\t      &init_addr, &inc, true, &inv_p);\n       data_ref = build1 (ALIGN_INDIRECT_REF, vectype, ptr);\n       new_stmt = build_gimple_modify_stmt (vec_dest, data_ref);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n@@ -5619,6 +5635,17 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n       return false;\n     }\n \n+  /* If accesses through a pointer to vectype do not alias the original\n+     memory reference we have a problem.  */\n+  if (get_alias_set (vectype) != get_alias_set (scalar_type)\n+      && !alias_set_subset_of (get_alias_set (vectype),\n+                               get_alias_set (scalar_type)))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vector type does not alias scalar type\");\n+      return false;\n+    }\n+\n   /* Check if the load is a part of an interleaving chain.  */\n   if (STMT_VINFO_STRIDED_ACCESS (stmt_info))\n     {\n@@ -5811,7 +5838,7 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt,\n         dataref_ptr = vect_create_data_ref_ptr (first_stmt,\n \t\t\t\t\t        at_loop, offset, \n \t\t\t\t\t\t&dummy, &ptr_incr, false, \n-\t\t\t\t\t\tNULL_TREE, &inv_p);\n+\t\t\t\t\t\t&inv_p);\n       else\n         dataref_ptr = \n \t\tbump_vector_ptr (dataref_ptr, ptr_incr, bsi, stmt, NULL_TREE);"}]}