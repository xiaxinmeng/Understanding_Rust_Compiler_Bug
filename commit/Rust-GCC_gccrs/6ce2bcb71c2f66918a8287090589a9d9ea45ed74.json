{"sha": "6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNlMmJjYjcxYzJmNjY5MThhODI4NzA5MDU4OWE5ZDllYTQ1ZWQ3NA==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-06-03T12:07:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-06-03T12:07:47Z"}, "message": "basic-block.c (tail_recursion_label_list): Don't declare.\n\n\t* basic-block.c (tail_recursion_label_list): Don't declare.\n\t(CLEANUP_PRE_SIBCALL): Remove.  Renumber the other CLEANUP_*\n\taccordingly.\n\t* cfgbuild.c (find_label_refs): Remove.\n\t(find_basic_blocks_1): Don't handle CALL_PLACEHOLDER insns.\n\t* cfgcleanup.c (tail_recursion_label_p): Remove.\n\t(merge_blocks_move): Do not check for tail recursion.\n\t(try_optimize_cfg): Likewise.\n\t(cleanup_cfg): Never handle CLEANUP_PRE_SIBCALL.\n\t* cfgrtl.c (tail_recursion_label_list): Remove.\n\t* except.c (remove_unreachable_regions): Don't handle\n\tCALL_PLACEHOLDER insns.\n\t(convert_from_eh_region_ranges_1, can_throw_internal,\n\tcan_throw_external): Likewise.\n\t* function.c (free_after_compilation): Don't clear\n\tx_tail_recursion_label.\n\t(fixup_var_refs_insns): Don't handle CALL_PLACEHOLDER insns.\n\t(identify_blocks_1): Don't recurse for CALL_PLACEHOLDER insns.\n\t(reorder_blocks_1): Likewise.\n\t* function.h (struct function): Remove x_tail_recursion_label\n\tmember.  Don't define tail_recursion_label.\n\t* jump.c (mark_all_labels): Don't handle CALL_PLACEHOLDER insns.\n\t* print-rtl.c (print_rtx): Likewise.\n\t* rtl.def (CALL_PLACEHOLDER): Remove.\n\t* rtl.h (sibcall_use_t): Remove enum.\n\t(optimize_sibling_and_tail_recursive_calls,\n\treplace_call_placeholder): Remove function prototypes.\n\t* stmt.c (tail_recursion_args): Remove.\n\t(optimize_tail_recursion): Remove.\n\t(expand_return): Don't check for possible tail recursion.\n\t* tree.h (optimize_tail_recursion): Remove prototype.\n\nFrom-SVN: r82597", "tree": {"sha": "a5c35a768c30f3209297293fe64b76eab30e93f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5c35a768c30f3209297293fe64b76eab30e93f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/comments", "author": null, "committer": null, "parents": [{"sha": "53ef271f84dcf405c5e58ea7b1ef2211f073d3c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53ef271f84dcf405c5e58ea7b1ef2211f073d3c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53ef271f84dcf405c5e58ea7b1ef2211f073d3c1"}], "stats": {"total": 508, "additions": 50, "deletions": 458}, "files": [{"sha": "12a96aa9e473b8f6a7a5e1b1fc5995c809c29b51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -1,3 +1,37 @@\n+2004-06-03  Steevn Bosscher  <stevenb@suse.de>\n+\n+\t* basic-block.c (tail_recursion_label_list): Don't declare.\n+\t(CLEANUP_PRE_SIBCALL): Remove.  Renumber the other CLEANUP_*\n+\taccordingly.\n+\t* cfgbuild.c (find_label_refs): Remove.\n+\t(find_basic_blocks_1): Don't handle CALL_PLACEHOLDER insns.\n+\t* cfgcleanup.c (tail_recursion_label_p): Remove.\n+\t(merge_blocks_move): Do not check for tail recursion.\n+\t(try_optimize_cfg): Likewise.\n+\t(cleanup_cfg): Never handle CLEANUP_PRE_SIBCALL.\n+\t* cfgrtl.c (tail_recursion_label_list): Remove.\n+\t* except.c (remove_unreachable_regions): Don't handle\n+\tCALL_PLACEHOLDER insns.\n+\t(convert_from_eh_region_ranges_1, can_throw_internal,\n+\tcan_throw_external): Likewise.\n+\t* function.c (free_after_compilation): Don't clear\n+\tx_tail_recursion_label.\n+\t(fixup_var_refs_insns): Don't handle CALL_PLACEHOLDER insns.\n+\t(identify_blocks_1): Don't recurse for CALL_PLACEHOLDER insns.\n+\t(reorder_blocks_1): Likewise.\n+\t* function.h (struct function): Remove x_tail_recursion_label\n+\tmember.  Don't define tail_recursion_label.\n+\t* jump.c (mark_all_labels): Don't handle CALL_PLACEHOLDER insns.\n+\t* print-rtl.c (print_rtx): Likewise.\n+\t* rtl.def (CALL_PLACEHOLDER): Remove.\n+\t* rtl.h (sibcall_use_t): Remove enum.\n+\t(optimize_sibling_and_tail_recursive_calls,\n+\treplace_call_placeholder): Remove function prototypes.\n+\t* stmt.c (tail_recursion_args): Remove.\n+\t(optimize_tail_recursion): Remove.\n+\t(expand_return): Don't check for possible tail recursion.\n+\t* tree.h (optimize_tail_recursion): Remove prototype.\n+\n 2004-06-02  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-cfg.c (tree_find_edge_insert_loc):  Allow inserting before"}, {"sha": "f087f8b5180800d23c2864afdf21cf1d481e7182", "filename": "gcc/basic-block.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -367,7 +367,6 @@ extern regset regs_live_at_setjmp;\n /* Special labels found during CFG build.  */\n \n extern GTY(()) rtx label_value_list;\n-extern GTY(()) rtx tail_recursion_label_list;\n \n extern struct obstack flow_obstack;\n \n@@ -554,16 +553,15 @@ enum update_life_extent\n #define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n #define CLEANUP_POST_REGSTACK\t4\t/* We run after reg-stack and need\n \t\t\t\t\t   to care REG_DEAD notes.  */\n-#define CLEANUP_PRE_SIBCALL\t8\t/* Do not get confused by code hidden\n-\t\t\t\t\t   inside call_placeholders..  */\n-#define CLEANUP_PRE_LOOP\t16\t/* Take care to preserve syntactic loop\n+#define CLEANUP_PRE_LOOP\t8\t/* Take care to preserve syntactic loop\n \t\t\t\t\t   notes.  */\n-#define CLEANUP_UPDATE_LIFE\t32\t/* Keep life information up to date.  */\n-#define CLEANUP_THREADING\t64\t/* Do jump threading.  */\n-#define CLEANUP_NO_INSN_DEL\t128\t/* Do not try to delete trivially dead\n+#define CLEANUP_UPDATE_LIFE\t16\t/* Keep life information up to date.  */\n+#define CLEANUP_THREADING\t32\t/* Do jump threading.  */\n+#define CLEANUP_NO_INSN_DEL\t64\t/* Do not try to delete trivially dead\n \t\t\t\t\t   insns.  */\n-#define CLEANUP_CFGLAYOUT\t256\t/* Do cleanup in cfglayout mode.  */\n-#define CLEANUP_LOG_LINKS\t512\t/* Update log links.  */\n+#define CLEANUP_CFGLAYOUT\t128\t/* Do cleanup in cfglayout mode.  */\n+#define CLEANUP_LOG_LINKS\t256\t/* Update log links.  */\n+\n extern void life_analysis (FILE *, int);\n extern int update_life_info (sbitmap, enum update_life_extent, int);\n extern int update_life_info_in_dirty_blocks (enum update_life_extent, int);"}, {"sha": "0cef94eafd3c8f756a665ac52ce33cb1114cda99", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 61, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -50,7 +50,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static int count_basic_blocks (rtx);\n static void find_basic_blocks_1 (rtx);\n-static rtx find_label_refs (rtx, rtx);\n static void make_edges (rtx, basic_block, basic_block, int);\n static void make_label_edge (sbitmap *, basic_block, rtx, int);\n static void find_bb_boundaries (basic_block);\n@@ -175,51 +174,6 @@ count_basic_blocks (rtx f)\n \n   return count;\n }\n-\n-/* Scan a list of insns for labels referred to other than by jumps.\n-   This is used to scan the alternatives of a call placeholder.  */\n-\n-static rtx\n-find_label_refs (rtx f, rtx lvl)\n-{\n-  rtx insn;\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && GET_CODE (insn) != JUMP_INSN)\n-      {\n-\trtx note;\n-\n-\t/* Make a list of all labels referred to other than by jumps\n-\t   (which just don't have the REG_LABEL notes).\n-\n-\t   Make a special exception for labels followed by an ADDR*VEC,\n-\t   as this would be a part of the tablejump setup code.\n-\n-\t   Make a special exception to registers loaded with label\n-\t   values just before jump insns that use them.  */\n-\n-\tfor (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t  if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t    {\n-\t      rtx lab = XEXP (note, 0), next;\n-\n-\t      if ((next = next_nonnote_insn (lab)) != NULL\n-\t\t  && GET_CODE (next) == JUMP_INSN\n-\t\t  && (GET_CODE (PATTERN (next)) == ADDR_VEC\n-\t\t      || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n-\t\t;\n-\t      else if (GET_CODE (lab) == NOTE)\n-\t\t;\n-\t      else if (GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n-\t\t       && find_reg_note (NEXT_INSN (insn), REG_LABEL, lab))\n-\t\t;\n-\t      else\n-\t\tlvl = alloc_EXPR_LIST (0, XEXP (note, 0), lvl);\n-\t    }\n-      }\n-\n-  return lvl;\n-}\n \f\n /* Create an edge between two basic blocks.  FLAGS are auxiliary information\n    about the edge that is accumulated between calls.  */\n@@ -464,7 +418,6 @@ find_basic_blocks_1 (rtx f)\n   rtx insn, next;\n   rtx bb_note = NULL_RTX;\n   rtx lvl = NULL_RTX;\n-  rtx trll = NULL_RTX;\n   rtx head = NULL_RTX;\n   rtx end = NULL_RTX;\n   basic_block prev = ENTRY_BLOCK_PTR;\n@@ -525,23 +478,11 @@ find_basic_blocks_1 (rtx f)\n \n \tcase CODE_LABEL:\n \tcase JUMP_INSN:\n+\tcase CALL_INSN:\n \tcase INSN:\n \tcase BARRIER:\n \t  break;\n \n-\tcase CALL_INSN:\n-\t  if (GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t    {\n-\t      /* Scan each of the alternatives for label refs.  */\n-\t      lvl = find_label_refs (XEXP (PATTERN (insn), 0), lvl);\n-\t      lvl = find_label_refs (XEXP (PATTERN (insn), 1), lvl);\n-\t      lvl = find_label_refs (XEXP (PATTERN (insn), 2), lvl);\n-\t      /* Record its tail recursion label, if any.  */\n-\t      if (XEXP (PATTERN (insn), 3) != NULL_RTX)\n-\t\ttrll = alloc_EXPR_LIST (0, XEXP (PATTERN (insn), 3), trll);\n-\t    }\n-\t  break;\n-\n \tdefault:\n \t  abort ();\n \t}\n@@ -588,7 +529,6 @@ find_basic_blocks_1 (rtx f)\n     abort ();\n \n   label_value_list = lvl;\n-  tail_recursion_label_list = trll;\n   clear_aux_for_blocks ();\n }\n "}, {"sha": "90c1f9b8f31d864cb1102e5073edfb93abb10fde", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 3, "deletions": 30, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -78,7 +78,6 @@ static bool outgoing_edges_match (int, basic_block, basic_block);\n static int flow_find_cross_jump (int, basic_block, basic_block, rtx *, rtx *);\n static bool insns_match_p (int, rtx, rtx);\n \n-static bool tail_recursion_label_p (rtx);\n static void merge_blocks_move_predecessor_nojumps (basic_block, basic_block);\n static void merge_blocks_move_successor_nojumps (basic_block, basic_block);\n static bool try_optimize_cfg (int);\n@@ -670,19 +669,6 @@ try_forward_edges (int mode, basic_block b)\n   return changed;\n }\n \f\n-/* Return true if LABEL is used for tail recursion.  */\n-\n-static bool\n-tail_recursion_label_p (rtx label)\n-{\n-  rtx x;\n-\n-  for (x = tail_recursion_label_list; x; x = XEXP (x, 1))\n-    if (label == XEXP (x, 0))\n-      return true;\n-\n-  return false;\n-}\n \n /* Blocks A and B are to be merged into a single block.  A has no incoming\n    fallthru edge, so it can be moved before B without adding or modifying\n@@ -809,14 +795,6 @@ static basic_block\n merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n {\n   basic_block next;\n-  /* If C has a tail recursion label, do not merge.  There is no\n-     edge recorded from the call_placeholder back to this label, as\n-     that would make optimize_sibling_and_tail_recursive_calls more\n-     complex for no gain.  */\n-  if ((mode & CLEANUP_PRE_SIBCALL)\n-      && GET_CODE (BB_HEAD (c)) == CODE_LABEL\n-      && tail_recursion_label_p (BB_HEAD (c)))\n-    return NULL;\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n@@ -1852,15 +1830,11 @@ try_optimize_cfg (int mode)\n \t\t  b = c;\n \t\t}\n \n-\t      /* Remove code labels no longer used.  Don't do this\n-\t\t before CALL_PLACEHOLDER is removed, as some branches\n-\t\t may be hidden within.  */\n+\t      /* Remove code labels no longer used.  */\n \t      if (b->pred->pred_next == NULL\n \t\t  && (b->pred->flags & EDGE_FALLTHRU)\n \t\t  && !(b->pred->flags & EDGE_COMPLEX)\n \t\t  && GET_CODE (BB_HEAD (b)) == CODE_LABEL\n-\t\t  && (!(mode & CLEANUP_PRE_SIBCALL)\n-\t\t      || !tail_recursion_label_p (BB_HEAD (b)))\n \t\t  /* If the previous block ends with a branch to this\n \t\t     block, we can't delete the label.  Normally this\n \t\t     is a condjump that is yet to be simplified, but\n@@ -2077,8 +2051,7 @@ cleanup_cfg (int mode)\n       changed = true;\n       /* We've possibly created trivially dead code.  Cleanup it right\n \t now to introduce more opportunities for try_optimize_cfg.  */\n-      if (!(mode & (CLEANUP_NO_INSN_DEL\n-\t\t    | CLEANUP_UPDATE_LIFE | CLEANUP_PRE_SIBCALL))\n+      if (!(mode & (CLEANUP_NO_INSN_DEL | CLEANUP_UPDATE_LIFE))\n \t  && !reload_completed)\n \tdelete_trivially_dead_insns (get_insns(), max_reg_num ());\n     }\n@@ -2101,7 +2074,7 @@ cleanup_cfg (int mode)\n \t\t\t\t\t\t    ? PROP_LOG_LINKS : 0)))\n \t    break;\n \t}\n-      else if (!(mode & (CLEANUP_NO_INSN_DEL | CLEANUP_PRE_SIBCALL))\n+      else if (!(mode & CLEANUP_NO_INSN_DEL)\n \t       && (mode & CLEANUP_EXPENSIVE)\n \t       && !reload_completed)\n \t{"}, {"sha": "e70733ba0d8410d39d4174d403313608fa2d1707", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -62,7 +62,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* ??? Should probably be using LABEL_NUSES instead.  It would take a\n    bit of surgery to be able to use or co-opt the routines in jump.  */\n rtx label_value_list;\n-rtx tail_recursion_label_list;\n \n static int can_delete_note_p (rtx);\n static int can_delete_label_p (rtx);"}, {"sha": "f3bc4ef3f2c4e2af216f6c328eb416ed9ce6f445", "filename": "gcc/except.c", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -1157,18 +1157,7 @@ remove_unreachable_regions (rtx insns)\n     }\n \n   for (insn = insns; insn; insn = NEXT_INSN (insn))\n-    {\n-      reachable[uid_region_num[INSN_UID (insn)]] = true;\n-\n-      if (GET_CODE (insn) == CALL_INSN\n-\t  && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\tfor (i = 0; i < 3; i++)\n-\t  {\n-\t    rtx sub = XEXP (PATTERN (insn), i);\n-\t    for (; sub ; sub = NEXT_INSN (sub))\n-\t      reachable[uid_region_num[INSN_UID (sub)]] = true;\n-\t  }\n-    }\n+    reachable[uid_region_num[INSN_UID (insn)]] = true;\n \n   for (i = cfun->eh->last_region_number; i > 0; --i)\n     {\n@@ -1259,8 +1248,6 @@ convert_from_eh_region_ranges_1 (rtx *pinsns, int *orig_sp, int cur)\n \t      else\n \t\tcur = *--sp;\n \n-\t      /* Removing the first insn of a CALL_PLACEHOLDER sequence\n-\t\t requires extra care to adjust sequence start.  */\n \t      if (insn == *pinsns)\n \t\t*pinsns = next;\n \t      remove_insn (insn);\n@@ -1285,17 +1272,6 @@ convert_from_eh_region_ranges_1 (rtx *pinsns, int *orig_sp, int cur)\n \t      REG_NOTES (insn) = alloc_EXPR_LIST (REG_EH_REGION, GEN_INT (cur),\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t    }\n-\n-\t  if (GET_CODE (insn) == CALL_INSN\n-\t      && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t    {\n-\t      convert_from_eh_region_ranges_1 (&XEXP (PATTERN (insn), 0),\n-\t\t\t\t\t       sp, cur);\n-\t      convert_from_eh_region_ranges_1 (&XEXP (PATTERN (insn), 1),\n-\t\t\t\t\t       sp, cur);\n-\t      convert_from_eh_region_ranges_1 (&XEXP (PATTERN (insn), 2),\n-\t\t\t\t\t       sp, cur);\n-\t    }\n \t}\n     }\n \n@@ -3131,20 +3107,6 @@ can_throw_internal (rtx insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n-  if (GET_CODE (insn) == CALL_INSN\n-      && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-    {\n-      int i;\n-      for (i = 0; i < 3; ++i)\n-\t{\n-\t  rtx sub = XEXP (PATTERN (insn), i);\n-\t  for (; sub ; sub = NEXT_INSN (sub))\n-\t    if (can_throw_internal (sub))\n-\t      return true;\n-\t}\n-      return false;\n-    }\n-\n   /* Every insn that might throw has an EH_REGION note.  */\n   note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n   if (!note || INTVAL (XEXP (note, 0)) <= 0)\n@@ -3192,20 +3154,6 @@ can_throw_external (rtx insn)\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n     insn = XVECEXP (PATTERN (insn), 0, 0);\n \n-  if (GET_CODE (insn) == CALL_INSN\n-      && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-    {\n-      int i;\n-      for (i = 0; i < 3; ++i)\n-\t{\n-\t  rtx sub = XEXP (PATTERN (insn), i);\n-\t  for (; sub ; sub = NEXT_INSN (sub))\n-\t    if (can_throw_external (sub))\n-\t      return true;\n-\t}\n-      return false;\n-    }\n-\n   note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n   if (!note)\n     {"}, {"sha": "69866f9812da987b21af4b8085782b8b810369f2", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 57, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -444,7 +444,6 @@ free_after_compilation (struct function *f)\n   f->x_save_expr_regs = NULL;\n   f->x_stack_slot_list = NULL;\n   f->x_rtl_expr_chain = NULL;\n-  f->x_tail_recursion_label = NULL;\n   f->x_tail_recursion_reentry = NULL;\n   f->x_arg_pointer_save_area = NULL;\n   f->x_parm_birth_insn = NULL;\n@@ -1683,32 +1682,7 @@ fixup_var_refs_insns (rtx insn, rtx var, enum machine_mode promoted_mode,\n          pointer now.  */\n       rtx next = NEXT_INSN (insn);\n \n-      /* CALL_PLACEHOLDERs are special; we have to switch into each of\n-\t the three sequences they (potentially) contain, and process\n-\t them recursively.  The CALL_INSN itself is not interesting.  */\n-\n-      if (GET_CODE (insn) == CALL_INSN\n-\t  && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t{\n-\t  int i;\n-\n-\t  /* Look at the Normal call, sibling call and tail recursion\n-\t     sequences attached to the CALL_PLACEHOLDER.  */\n-\t  for (i = 0; i < 3; i++)\n-\t    {\n-\t      rtx seq = XEXP (PATTERN (insn), i);\n-\t      if (seq)\n-\t\t{\n-\t\t  push_to_sequence (seq);\n-\t\t  fixup_var_refs_insns (seq, var, promoted_mode, unsignedp, 0,\n-\t\t\t\t\tmay_share);\n-\t\t  XEXP (PATTERN (insn), i) = get_insns ();\n-\t\t  end_sequence ();\n-\t\t}\n-\t    }\n-\t}\n-\n-      else if (INSN_P (insn))\n+      if (INSN_P (insn))\n \tfixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel,\n \t\t\t     may_share);\n \n@@ -1717,11 +1691,7 @@ fixup_var_refs_insns (rtx insn, rtx var, enum machine_mode promoted_mode,\n }\n \n /* Look up the insns which reference VAR in HT and fix them up.  Other\n-   arguments are the same as fixup_var_refs_insns.\n-\n-   N.B. No need for special processing of CALL_PLACEHOLDERs here,\n-   because the hash table will point straight to the interesting insn\n-   (inside the CALL_PLACEHOLDER).  */\n+   arguments are the same as fixup_var_refs_insns.  */\n \n static void\n fixup_var_refs_insns_with_hash (htab_t ht, rtx var, enum machine_mode promoted_mode,\n@@ -5903,7 +5873,7 @@ identify_blocks (void)\n }\n \n /* Subroutine of identify_blocks.  Do the block substitution on the\n-   insn chain beginning with INSNS.  Recurse for CALL_PLACEHOLDER chains.\n+   insn chain beginning with INSNS.\n \n    BLOCK_STACK is pushed and popped for each BLOCK_BEGIN/BLOCK_END pair.\n    BLOCK_VECTOR is incremented for each block seen.  */\n@@ -5942,20 +5912,6 @@ identify_blocks_1 (rtx insns, tree *block_vector, tree *end_block_vector,\n \t      NOTE_BLOCK (insn) = *--block_stack;\n \t    }\n \t}\n-      else if (GET_CODE (insn) == CALL_INSN\n-\t       && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t{\n-\t  rtx cp = PATTERN (insn);\n-\n-\t  block_vector = identify_blocks_1 (XEXP (cp, 0), block_vector,\n-\t\t\t\t\t    end_block_vector, block_stack);\n-\t  if (XEXP (cp, 1))\n-\t    block_vector = identify_blocks_1 (XEXP (cp, 1), block_vector,\n-\t\t\t\t\t      end_block_vector, block_stack);\n-\t  if (XEXP (cp, 2))\n-\t    block_vector = identify_blocks_1 (XEXP (cp, 2), block_vector,\n-\t\t\t\t\t      end_block_vector, block_stack);\n-\t}\n     }\n \n   /* If there are more NOTE_INSN_BLOCK_BEGINs than NOTE_INSN_BLOCK_ENDs,\n@@ -6066,16 +6022,6 @@ reorder_blocks_1 (rtx insns, tree current_block, varray_type *p_block_stack)\n \t      current_block = BLOCK_SUPERCONTEXT (current_block);\n \t    }\n \t}\n-      else if (GET_CODE (insn) == CALL_INSN\n-\t       && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t{\n-\t  rtx cp = PATTERN (insn);\n-\t  reorder_blocks_1 (XEXP (cp, 0), current_block, p_block_stack);\n-\t  if (XEXP (cp, 1))\n-\t    reorder_blocks_1 (XEXP (cp, 1), current_block, p_block_stack);\n-\t  if (XEXP (cp, 2))\n-\t    reorder_blocks_1 (XEXP (cp, 2), current_block, p_block_stack);\n-\t}\n     }\n }\n "}, {"sha": "bd19e3d4450d8d434265721ea44d96b57ce63abe", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -278,10 +278,6 @@ struct function GTY(())\n   /* Chain of all RTL_EXPRs that have insns in them.  */\n   tree x_rtl_expr_chain;\n \n-  /* Label to jump back to for tail recursion, or 0 if we have\n-     not yet needed one for this function.  */\n-  rtx x_tail_recursion_label;\n-\n   /* Place after which to insert the tail_recursion_label if we need one.  */\n   rtx x_tail_recursion_reentry;\n \n@@ -560,7 +556,6 @@ extern int trampolines_created;\n #define stack_slot_list (cfun->x_stack_slot_list)\n #define parm_birth_insn (cfun->x_parm_birth_insn)\n #define frame_offset (cfun->x_frame_offset)\n-#define tail_recursion_label (cfun->x_tail_recursion_label)\n #define tail_recursion_reentry (cfun->x_tail_recursion_reentry)\n #define arg_pointer_save_area (cfun->x_arg_pointer_save_area)\n #define rtl_expr_chain (cfun->x_rtl_expr_chain)"}, {"sha": "9ac1a4454b67d61b7bfebaee32c4f4b0d00b68f1", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -192,26 +192,6 @@ mark_all_labels (rtx f)\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     if (INSN_P (insn))\n       {\n-\tif (GET_CODE (insn) == CALL_INSN\n-\t    && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-\t  {\n-\t    mark_all_labels (XEXP (PATTERN (insn), 0));\n-\t    mark_all_labels (XEXP (PATTERN (insn), 1));\n-\t    mark_all_labels (XEXP (PATTERN (insn), 2));\n-\n-\t    /* Canonicalize the tail recursion label attached to the\n-\t       CALL_PLACEHOLDER insn.  */\n-\t    if (XEXP (PATTERN (insn), 3))\n-\t      {\n-\t\trtx label_ref = gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t   XEXP (PATTERN (insn), 3));\n-\t\tmark_jump_label (label_ref, insn, 0);\n-\t\tXEXP (PATTERN (insn), 3) = XEXP (label_ref, 0);\n-\t      }\n-\n-\t    continue;\n-\t  }\n-\n \tmark_jump_label (PATTERN (insn), insn, 0);\n \tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n \t  {"}, {"sha": "51dc65a82ad411010fa500a7ae54dea7196f8792", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -60,9 +60,6 @@ int flag_simple = 0;\n /* Nonzero if we are dumping graphical description.  */\n int dump_for_graph;\n \n-/* Nonzero to dump all call_placeholder alternatives.  */\n-static int debug_call_placeholder_verbose;\n-\n void\n print_mem_expr (FILE *outfile, tree expr)\n {\n@@ -99,7 +96,6 @@ print_rtx (rtx in_rtx)\n   int j;\n   const char *format_ptr;\n   int is_insn;\n-  rtx tem;\n \n   if (sawclose)\n     {\n@@ -573,49 +569,6 @@ print_rtx (rtx in_rtx)\n \t}\n       break;\n \n-    case CALL_PLACEHOLDER:\n-      if (debug_call_placeholder_verbose)\n-\t{\n-\t  fputs (\" (cond [\\n  (const_string \\\"normal\\\") (sequence [\", outfile);\n-\t  for (tem = XEXP (in_rtx, 0); tem != 0; tem = NEXT_INSN (tem))\n-\t    {\n-\t      fputs (\"\\n    \", outfile);\n-\t      print_inline_rtx (outfile, tem, 4);\n-\t    }\n-\n-\t  tem = XEXP (in_rtx, 1);\n-\t  if (tem)\n-\t    fputs (\"\\n    ])\\n  (const_string \\\"tail_call\\\") (sequence [\",\n-\t\t   outfile);\n-\t  for (; tem != 0; tem = NEXT_INSN (tem))\n-\t    {\n-\t      fputs (\"\\n    \", outfile);\n-\t      print_inline_rtx (outfile, tem, 4);\n-\t    }\n-\n-\t  tem = XEXP (in_rtx, 2);\n-\t  if (tem)\n-\t    fputs (\"\\n    ])\\n  (const_string \\\"tail_recursion\\\") (sequence [\",\n-\t\t   outfile);\n-\t  for (; tem != 0; tem = NEXT_INSN (tem))\n-\t    {\n-\t      fputs (\"\\n    \", outfile);\n-\t      print_inline_rtx (outfile, tem, 4);\n-\t    }\n-\n-\t  fputs (\"\\n    ])\\n  ])\", outfile);\n-\t  break;\n-\t}\n-\n-      for (tem = XEXP (in_rtx, 0); tem != 0; tem = NEXT_INSN (tem))\n-\tif (GET_CODE (tem) == CALL_INSN)\n-\t  {\n-\t    fprintf (outfile, \" \");\n-\t    print_rtx (tem);\n-\t    break;\n-\t  }\n-      break;\n-\n     default:\n       break;\n     }"}, {"sha": "350e84feb1a35bb82e4b56926485a3793e8f7875", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -1153,27 +1153,6 @@ DEF_RTL_EXPR(RANGE_VAR, \"range_var\", \"eti\", RTX_EXTRA)\n    0 is the live bitmap.  Operand 1 is the original block number.  */\n DEF_RTL_EXPR(RANGE_LIVE, \"range_live\", \"bi\", RTX_EXTRA)\n \n-/* A placeholder for a CALL_INSN which may be turned into a normal call,\n-   a sibling (tail) call or tail recursion.\n-\n-   Immediately after RTL generation, this placeholder will be replaced\n-   by the insns to perform the call, sibcall or tail recursion.\n-\n-   This RTX has 4 operands.  The first three are lists of instructions to\n-   perform the call as a normal call, sibling call and tail recursion\n-   respectively.  The latter two lists may be NULL, the first may never\n-   be NULL.\n-\n-   The last operand is the tail recursion CODE_LABEL, which may be NULL if no \n-   potential tail recursive calls were found.\n-\n-   The tail recursion label is needed so that we can clear LABEL_PRESERVE_P\n-   after we select a call method.\n-\n-   This method of tail-call elimination is intended to be replaced by\n-   tree-based optimizations once front-end conversions are complete.  */\n-DEF_RTL_EXPR(CALL_PLACEHOLDER, \"call_placeholder\", \"uuuu\", RTX_EXTRA)\n-\n /* Describes a merge operation between two vector values.\n    Operands 0 and 1 are the vectors to be merged, operand 2 is a bitmask\n    that specifies where the parts of the result are taken from.  Set bits"}, {"sha": "06f298fefe72b1127ad40f686818de8fdc71880a", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -2414,16 +2414,6 @@ extern rtx gen_hard_reg_clobber (enum machine_mode, unsigned int);\n extern rtx get_reg_known_value (unsigned int);\n extern bool get_reg_known_equiv_p (unsigned int);\n \n-/* In sibcall.c */\n-typedef enum {\n-  sibcall_use_normal = 1,\n-  sibcall_use_tail_recursion,\n-  sibcall_use_sibcall\n-} sibcall_use_t;\n-\n-extern void optimize_sibling_and_tail_recursive_calls (void);\n-extern void replace_call_placeholder (rtx, sibcall_use_t);\n-\n #ifdef STACK_REGS\n extern int stack_regs_mentioned (rtx insn);\n #endif"}, {"sha": "6e65c7f88f5ab324f0a4eff14666f0f3ca62aec2", "filename": "gcc/stmt.c", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -382,7 +382,6 @@ static void expand_null_return_1 (rtx);\n static enum br_predictor return_prediction (rtx);\n static rtx shift_return_value (rtx);\n static void expand_value_return (rtx);\n-static int tail_recursion_args (tree, tree);\n static void expand_cleanups (tree, int, int);\n static void check_seenlabel (void);\n static void do_jump_if_equal (rtx, rtx, rtx, int);\n@@ -2668,39 +2667,6 @@ expand_return (tree retval)\n \n   last_insn = get_last_insn ();\n \n-  /* Distribute return down conditional expr if either of the sides\n-     may involve tail recursion (see test below).  This enhances the number\n-     of tail recursions we see.  Don't do this always since it can produce\n-     sub-optimal code in some cases and we distribute assignments into\n-     conditional expressions when it would help.  */\n-\n-  if (optimize && retval_rhs != 0\n-      && frame_offset == 0\n-      && TREE_CODE (retval_rhs) == COND_EXPR\n-      && (TREE_CODE (TREE_OPERAND (retval_rhs, 1)) == CALL_EXPR\n-\t  || TREE_CODE (TREE_OPERAND (retval_rhs, 2)) == CALL_EXPR))\n-    {\n-      rtx label = gen_label_rtx ();\n-      tree expr;\n-\n-      do_jump (TREE_OPERAND (retval_rhs, 0), label, NULL_RTX);\n-      start_cleanup_deferral ();\n-      expr = build (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (current_function_decl)),\n-\t\t    DECL_RESULT (current_function_decl),\n-\t\t    TREE_OPERAND (retval_rhs, 1));\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-      expand_return (expr);\n-      emit_label (label);\n-\n-      expr = build (MODIFY_EXPR, TREE_TYPE (TREE_TYPE (current_function_decl)),\n-\t\t    DECL_RESULT (current_function_decl),\n-\t\t    TREE_OPERAND (retval_rhs, 2));\n-      TREE_SIDE_EFFECTS (expr) = 1;\n-      expand_return (expr);\n-      end_cleanup_deferral ();\n-      return;\n-    }\n-\n   result_rtl = DECL_RTL (DECL_RESULT (current_function_decl));\n \n   /* If the result is an aggregate that is being returned in one (or more)\n@@ -2850,114 +2816,6 @@ expand_return (tree retval)\n     }\n }\n \f\n-/* Attempt to optimize a potential tail recursion call into a goto.\n-   ARGUMENTS are the arguments to a CALL_EXPR; LAST_INSN indicates\n-   where to place the jump to the tail recursion label.\n-\n-   Return TRUE if the call was optimized into a goto.  */\n-\n-int\n-optimize_tail_recursion (tree arguments, rtx last_insn)\n-{\n-  /* Finish checking validity, and if valid emit code to set the\n-     argument variables for the new call.  */\n-  if (tail_recursion_args (arguments, DECL_ARGUMENTS (current_function_decl)))\n-    {\n-      if (tail_recursion_label == 0)\n-\t{\n-\t  tail_recursion_label = gen_label_rtx ();\n-\t  emit_label_after (tail_recursion_label,\n-\t\t\t    tail_recursion_reentry);\n-\t}\n-      emit_queue ();\n-      expand_goto_internal (NULL_TREE, tail_recursion_label, last_insn);\n-      emit_barrier ();\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* Emit code to alter this function's formal parms for a tail-recursive call.\n-   ACTUALS is a list of actual parameter expressions (chain of TREE_LISTs).\n-   FORMALS is the chain of decls of formals.\n-   Return 1 if this can be done;\n-   otherwise return 0 and do not emit any code.  */\n-\n-static int\n-tail_recursion_args (tree actuals, tree formals)\n-{\n-  tree a = actuals, f = formals;\n-  int i;\n-  rtx *argvec;\n-\n-  /* Check that number and types of actuals are compatible\n-     with the formals.  This is not always true in valid C code.\n-     Also check that no formal needs to be addressable\n-     and that all formals are scalars.  */\n-\n-  /* Also count the args.  */\n-\n-  for (a = actuals, f = formals, i = 0; a && f; a = TREE_CHAIN (a), f = TREE_CHAIN (f), i++)\n-    {\n-      if (!lang_hooks.types_compatible_p (TREE_TYPE (TREE_VALUE (a)), \n-\t      TREE_TYPE (f)))\n-\treturn 0;\n-      if (GET_CODE (DECL_RTL (f)) != REG || DECL_MODE (f) == BLKmode)\n-\treturn 0;\n-    }\n-  if (a != 0 || f != 0)\n-    return 0;\n-\n-  /* Compute all the actuals.  */\n-\n-  argvec = alloca (i * sizeof (rtx));\n-\n-  for (a = actuals, i = 0; a; a = TREE_CHAIN (a), i++)\n-    argvec[i] = expand_expr (TREE_VALUE (a), NULL_RTX, VOIDmode, 0);\n-\n-  /* Find which actual values refer to current values of previous formals.\n-     Copy each of them now, before any formal is changed.  */\n-\n-  for (a = actuals, i = 0; a; a = TREE_CHAIN (a), i++)\n-    {\n-      int copy = 0;\n-      int j;\n-      for (f = formals, j = 0; j < i; f = TREE_CHAIN (f), j++)\n-\tif (reg_mentioned_p (DECL_RTL (f), argvec[i]))\n-\t  {\n-\t    copy = 1;\n-\t    break;\n-\t  }\n-      if (copy)\n-\targvec[i] = copy_to_reg (argvec[i]);\n-    }\n-\n-  /* Store the values of the actuals into the formals.  */\n-\n-  for (f = formals, a = actuals, i = 0; f;\n-       f = TREE_CHAIN (f), a = TREE_CHAIN (a), i++)\n-    {\n-      if (GET_MODE (DECL_RTL (f)) == GET_MODE (argvec[i]))\n-\temit_move_insn (DECL_RTL (f), argvec[i]);\n-      else\n-\t{\n-\t  rtx tmp = argvec[i];\n-\t  int unsignedp = TYPE_UNSIGNED (TREE_TYPE (TREE_VALUE (a)));\n-\t  promote_mode(TREE_TYPE (TREE_VALUE (a)), GET_MODE (tmp),\n-\t\t       &unsignedp, 0);\n-\t  if (DECL_MODE (f) != GET_MODE (DECL_RTL (f)))\n-\t    {\n-\t      tmp = gen_reg_rtx (DECL_MODE (f));\n-\t      convert_move (tmp, argvec[i], unsignedp);\n-\t    }\n-\t  convert_move (DECL_RTL (f), tmp, unsignedp);\n-\t}\n-    }\n-\n-  free_temp_slots ();\n-  return 1;\n-}\n-\f\n /* Generate the RTL code for entering a binding contour.\n    The variables are declared one by one, by calls to `expand_decl'.\n "}, {"sha": "71c9fc6783056dcb011ca818c4e1963b76fc1d3d", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -72,7 +72,7 @@ Boston, MA 02111-1307, USA.  */\n    omit the accumulator.\n \n    There are three cases how the function may exit.  The first one is\n-   handled in adjust_return_value, the later two in adjust_accumulator_values\n+   handled in adjust_return_value, the other two in adjust_accumulator_values\n    (the second case is actually a special case of the third one and we\n    present it separately just for clarity):\n "}, {"sha": "34b836c7a38f2b664291b696e829eb23a36b7840", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ce2bcb71c2f66918a8287090589a9d9ea45ed74/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6ce2bcb71c2f66918a8287090589a9d9ea45ed74", "patch": "@@ -3399,7 +3399,6 @@ extern void expand_stack_alloc (tree, tree);\n extern rtx expand_stack_save (void);\n extern void expand_stack_restore (tree);\n extern void expand_return (tree);\n-extern int optimize_tail_recursion (tree, rtx);\n extern void expand_start_bindings_and_block (int, tree);\n #define expand_start_bindings(flags) \\\n   expand_start_bindings_and_block(flags, NULL_TREE)"}]}