{"sha": "152f64c2c6c31b6574258312c867e15703add0fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUyZjY0YzJjNmMzMWI2NTc0MjU4MzEyYzg2N2UxNTcwM2FkZDBmZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-03-02T13:43:20Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-10T09:16:19Z"}, "message": "[Ada] Use small limit for aggregates inside subprograms\n\ngcc/ada/\n\n\t* exp_aggr.adb (Max_Aggregate_Size): Use small limit for\n\taggregate inside subprograms.\n\t* sprint.adb (Sprint_Node_Actual [N_Object_Declaration]): Do not\n\tprint the initialization expression if the No_Initialization\n\tflag is set.\n\t* sem_util.ads, sem_util.adb (Predicate_Enabled): New.\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Code cleanup and apply\n\tpredicate check consistently.\n\t* exp_ch6.adb (Expand_Actuals.By_Ref_Predicate_Check): Ditto.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Ditto.\n\t* exp_ch3.adb (Build_Assignment): Revert handling of predicate\n\tcheck for allocators with qualified expressions, now handled in\n\tFreeze_Expression directly.\n\t* sem_aggr.adb: Fix typos.\n\t* checks.adb: Code refactoring: use Predicate_Enabled.\n\t(Apply_Predicate_Check): Code cleanup.\n\t* freeze.adb (Freeze_Expression): Freeze the subtype mark before\n\ta qualified expression on an allocator.\n\t* exp_util.ads, exp_util.adb (Within_Internal_Subprogram):\n\tRenamed Predicate_Check_In_Scope to clarify usage, refine\n\thandling of predicates within init procs which should be enabled\n\twhen the node comes from source.\n\t* sem_ch13.adb (Freeze_Entity_Checks): Update call to\n\tPredicate_Check_In_Scope.", "tree": {"sha": "4ce4b5a10f0d679609e8f09851e3cbcd8c900d2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ce4b5a10f0d679609e8f09851e3cbcd8c900d2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/152f64c2c6c31b6574258312c867e15703add0fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152f64c2c6c31b6574258312c867e15703add0fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/152f64c2c6c31b6574258312c867e15703add0fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/152f64c2c6c31b6574258312c867e15703add0fd/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbe3b8d49d07cf5eee62c3963b843f3ea931b03f"}], "stats": {"total": 370, "additions": 196, "deletions": 174}, "files": [{"sha": "46a878e7e38afb112737bc75e11cc3ccdac878dc", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 114, "deletions": 121, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -2746,153 +2746,146 @@ package body Checks is\n       S   : Entity_Id;\n \n    begin\n-      if Predicate_Checks_Suppressed (Empty) then\n-         return;\n-\n-      elsif Predicates_Ignored (Typ) then\n+      if not Predicate_Enabled (Typ)\n+        or else not Predicate_Check_In_Scope (N)\n+      then\n          return;\n+      end if;\n \n-      elsif Present (Predicate_Function (Typ)) then\n-         S := Current_Scope;\n-         while Present (S) and then not Is_Subprogram (S) loop\n-            S := Scope (S);\n-         end loop;\n-\n-         --  A predicate check does not apply within internally generated\n-         --  subprograms, such as TSS functions.\n+      S := Current_Scope;\n+      while Present (S) and then not Is_Subprogram (S) loop\n+         S := Scope (S);\n+      end loop;\n \n-         if Within_Internal_Subprogram then\n-            return;\n+      --  If the check appears within the predicate function itself, it means\n+      --  that the user specified a check whose formal is the predicated\n+      --  subtype itself, rather than some covering type. This is likely to be\n+      --  a common error, and thus deserves a warning.\n \n-         --  If the check appears within the predicate function itself, it\n-         --  means that the user specified a check whose formal is the\n-         --  predicated subtype itself, rather than some covering type. This\n-         --  is likely to be a common error, and thus deserves a warning.\n+      if Present (S) and then S = Predicate_Function (Typ) then\n+         Error_Msg_NE\n+           (\"predicate check includes a call to& that requires a \"\n+            & \"predicate check??\", Parent (N), Fun);\n+         Error_Msg_N\n+           (\"\\this will result in infinite recursion??\", Parent (N));\n \n-         elsif Present (S) and then S = Predicate_Function (Typ) then\n+         if Is_First_Subtype (Typ) then\n             Error_Msg_NE\n-              (\"predicate check includes a call to& that requires a \"\n-               & \"predicate check??\", Parent (N), Fun);\n-            Error_Msg_N\n-              (\"\\this will result in infinite recursion??\", Parent (N));\n+              (\"\\use an explicit subtype of& to carry the predicate\",\n+               Parent (N), Typ);\n+         end if;\n \n-            if Is_First_Subtype (Typ) then\n-               Error_Msg_NE\n-                 (\"\\use an explicit subtype of& to carry the predicate\",\n-                  Parent (N), Typ);\n-            end if;\n+         Insert_Action (N,\n+           Make_Raise_Storage_Error (Sloc (N),\n+             Reason => SE_Infinite_Recursion));\n+         return;\n+      end if;\n \n-            Insert_Action (N,\n-              Make_Raise_Storage_Error (Sloc (N),\n-                Reason => SE_Infinite_Recursion));\n+      --  Normal case of predicate active\n \n-         --  Here for normal case of predicate active\n+      --  If the expression is an IN parameter, the predicate will have\n+      --  been applied at the point of call. An additional check would\n+      --  be redundant, or will lead to out-of-scope references if the\n+      --  call appears within an aspect specification for a precondition.\n \n-         else\n-            --  If the expression is an IN parameter, the predicate will have\n-            --  been applied at the point of call. An additional check would\n-            --  be redundant, or will lead to out-of-scope references if the\n-            --  call appears within an aspect specification for a precondition.\n-\n-            --  However, if the reference is within the body of the subprogram\n-            --  that declares the formal, the predicate can safely be applied,\n-            --  which may be necessary for a nested call whose formal has a\n-            --  different predicate.\n-\n-            if Is_Entity_Name (N)\n-              and then Ekind (Entity (N)) = E_In_Parameter\n-            then\n-               declare\n-                  In_Body : Boolean := False;\n-                  P       : Node_Id := Parent (N);\n+      --  However, if the reference is within the body of the subprogram\n+      --  that declares the formal, the predicate can safely be applied,\n+      --  which may be necessary for a nested call whose formal has a\n+      --  different predicate.\n \n-               begin\n-                  while Present (P) loop\n-                     if Nkind (P) = N_Subprogram_Body\n-                       and then\n-                         ((Present (Corresponding_Spec (P))\n-                            and then\n-                              Corresponding_Spec (P) = Scope (Entity (N)))\n-                            or else\n-                              Defining_Unit_Name (Specification (P)) =\n-                                Scope (Entity (N)))\n-                     then\n-                        In_Body := True;\n-                        exit;\n-                     end if;\n+      if Is_Entity_Name (N)\n+        and then Ekind (Entity (N)) = E_In_Parameter\n+      then\n+         declare\n+            In_Body : Boolean := False;\n+            P       : Node_Id := Parent (N);\n \n-                     P := Parent (P);\n-                  end loop;\n+         begin\n+            while Present (P) loop\n+               if Nkind (P) = N_Subprogram_Body\n+                 and then\n+                   ((Present (Corresponding_Spec (P))\n+                      and then\n+                        Corresponding_Spec (P) = Scope (Entity (N)))\n+                      or else\n+                        Defining_Unit_Name (Specification (P)) =\n+                          Scope (Entity (N)))\n+               then\n+                  In_Body := True;\n+                  exit;\n+               end if;\n \n-                  if not In_Body then\n-                     return;\n-                  end if;\n-               end;\n+               P := Parent (P);\n+            end loop;\n+\n+            if not In_Body then\n+               return;\n             end if;\n+         end;\n+      end if;\n \n-            --  If the type has a static predicate and the expression is known\n-            --  at compile time, see if the expression satisfies the predicate.\n+      --  If the type has a static predicate and the expression is known\n+      --  at compile time, see if the expression satisfies the predicate.\n \n-            Check_Expression_Against_Static_Predicate (N, Typ);\n+      Check_Expression_Against_Static_Predicate (N, Typ);\n \n-            if not Expander_Active then\n-               return;\n-            end if;\n+      if not Expander_Active then\n+         return;\n+      end if;\n \n-            Par := Parent (N);\n-            if Nkind (Par) = N_Qualified_Expression then\n-               Par := Parent (Par);\n-            end if;\n+      Par := Parent (N);\n+      if Nkind (Par) = N_Qualified_Expression then\n+         Par := Parent (Par);\n+      end if;\n \n-            --  For an entity of the type, generate a call to the predicate\n-            --  function, unless its type is an actual subtype, which is not\n-            --  visible outside of the enclosing subprogram.\n+      --  For an entity of the type, generate a call to the predicate\n+      --  function, unless its type is an actual subtype, which is not\n+      --  visible outside of the enclosing subprogram.\n \n-            if Is_Entity_Name (N)\n-              and then not Is_Actual_Subtype (Typ)\n-            then\n-               Insert_Action (N,\n-                 Make_Predicate_Check\n-                   (Typ, New_Occurrence_Of (Entity (N), Sloc (N))));\n-\n-            --  If the expression is an aggregate in an assignment, apply the\n-            --  check to the LHS after the assignment, rather than create a\n-            --  redundant temporary. This is only necessary in rare cases\n-            --  of array types (including strings) initialized with an\n-            --  aggregate with an \"others\" clause, either coming from source\n-            --  or generated by an Initialize_Scalars pragma.\n-\n-            elsif Nkind_In (N, N_Aggregate, N_Extension_Aggregate)\n-              and then Nkind (Par) = N_Assignment_Statement\n-            then\n-               Insert_Action_After (Par,\n-                 Make_Predicate_Check\n-                   (Typ, Duplicate_Subexpr (Name (Par))));\n+      if Is_Entity_Name (N)\n+        and then not Is_Actual_Subtype (Typ)\n+      then\n+         Insert_Action (N,\n+           Make_Predicate_Check\n+             (Typ, New_Occurrence_Of (Entity (N), Sloc (N))));\n+         return;\n \n-            --  Similarly, if the expression is an aggregate in an object\n-            --  declaration, apply it to the object after the declaration.\n-            --  This is only necessary in rare cases of tagged extensions\n-            --  initialized with an aggregate with an \"others => <>\" clause.\n+      elsif Nkind_In (N, N_Aggregate, N_Extension_Aggregate) then\n \n-            elsif Nkind_In (N, N_Aggregate, N_Extension_Aggregate)\n-              and then Nkind (Par) = N_Object_Declaration\n-            then\n-               Insert_Action_After (Par,\n-                 Make_Predicate_Check (Typ,\n-                   New_Occurrence_Of (Defining_Identifier (Par), Sloc (N))));\n+         --  If the expression is an aggregate in an assignment, apply the\n+         --  check to the LHS after the assignment, rather than create a\n+         --  redundant temporary. This is only necessary in rare cases\n+         --  of array types (including strings) initialized with an\n+         --  aggregate with an \"others\" clause, either coming from source\n+         --  or generated by an Initialize_Scalars pragma.\n \n-            --  If the expression is not an entity it may have side effects,\n-            --  and the following call will create an object declaration for\n-            --  it. We disable checks during its analysis, to prevent an\n-            --  infinite recursion.\n+         if Nkind (Par) = N_Assignment_Statement then\n+            Insert_Action_After (Par,\n+              Make_Predicate_Check\n+                (Typ, Duplicate_Subexpr (Name (Par))));\n+            return;\n \n-            else\n-               Insert_Action (N,\n-                 Make_Predicate_Check\n-                   (Typ, Duplicate_Subexpr (N)), Suppress => All_Checks);\n-            end if;\n+         --  Similarly, if the expression is an aggregate in an object\n+         --  declaration, apply it to the object after the declaration.\n+         --  This is only necessary in rare cases of tagged extensions\n+         --  initialized with an aggregate with an \"others => <>\" clause.\n+\n+         elsif Nkind (Par) = N_Object_Declaration then\n+            Insert_Action_After (Par,\n+              Make_Predicate_Check (Typ,\n+                New_Occurrence_Of (Defining_Identifier (Par), Sloc (N))));\n+            return;\n          end if;\n       end if;\n+\n+      --  If the expression is not an entity it may have side effects,\n+      --  and the following call will create an object declaration for\n+      --  it. We disable checks during its analysis, to prevent an\n+      --  infinite recursion.\n+\n+      Insert_Action (N,\n+        Make_Predicate_Check\n+          (Typ, Duplicate_Subexpr (N)), Suppress => All_Checks);\n    end Apply_Predicate_Check;\n \n    -----------------------"}, {"sha": "7a6b5b9ad167cbee567dc03d2e34d8eb100b28b1", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -8181,6 +8181,10 @@ package body Exp_Aggr is\n       --  if components are static it is much more efficient to construct a\n       --  one-dimensional equivalent array with static components.\n \n+      --  Finally we also use a small limit when we're within a subprogram\n+      --  since we want to favor loops (potentially transformed to memset\n+      --  calls) in this context.\n+\n       if CodePeer_Mode then\n          return 100;\n       elsif Restriction_Active (No_Elaboration_Code)\n@@ -8190,6 +8194,8 @@ package body Exp_Aggr is\n                    and then Static_Elaboration_Desired (Current_Scope))\n       then\n          return 2 ** 24;\n+      elsif Ekind (Current_Scope) in Subprogram_Kind then\n+         return 64;\n       else\n          return Default_Size;\n       end if;"}, {"sha": "3402a087b6c57326e1df13c9a2f8a2fd97effc4c", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -2061,27 +2061,11 @@ package body Exp_Ch3 is\n          --  which provides for a better error message.\n \n          if Comes_From_Source (Exp)\n-           and then Has_Predicates (Typ)\n-           and then not Predicate_Checks_Suppressed (Empty)\n-           and then not Predicates_Ignored (Typ)\n+           and then Predicate_Enabled (Typ)\n          then\n             Append (Make_Predicate_Check (Typ, Exp), Res);\n          end if;\n \n-         if Nkind (Exp) = N_Allocator\n-            and then Nkind (Expression (Exp)) = N_Qualified_Expression\n-         then\n-            declare\n-               Subtype_Entity : constant Entity_Id\n-                  := Entity (Subtype_Mark (Expression (Exp)));\n-            begin\n-               if Has_Predicates (Subtype_Entity) then\n-                  Append (Make_Predicate_Check\n-                     (Subtype_Entity, Expression (Expression (Exp))), Res);\n-               end if;\n-            end;\n-         end if;\n-\n          return Res;\n \n       exception\n@@ -8350,7 +8334,7 @@ package body Exp_Ch3 is\n       --  subtypes to which these checks do not apply.\n \n       elsif Has_Invariants (Def_Id) then\n-         if Within_Internal_Subprogram\n+         if not Predicate_Check_In_Scope (Def_Id)\n            or else (Ekind (Current_Scope) = E_Function\n                      and then Is_Predicate_Function (Current_Scope))\n          then"}, {"sha": "dbf3e3bef6b2b0869df56aa88245a4d3f0e782ab", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -12506,23 +12506,22 @@ package body Exp_Ch4 is\n       --  guard is necessary to prevent infinite recursions when we generate\n       --  internal conversions for the purpose of checking predicates.\n \n-      if Present (Predicate_Function (Target_Type))\n-        and then not Predicates_Ignored (Target_Type)\n+      if Predicate_Enabled (Target_Type)\n         and then Target_Type /= Operand_Type\n         and then Comes_From_Source (N)\n       then\n          declare\n             New_Expr : constant Node_Id := Duplicate_Subexpr (N);\n \n          begin\n-            --  Avoid infinite recursion on the subsequent expansion of\n-            --  of the copy of the original type conversion. When needed,\n-            --  a range check has already been applied to the expression.\n+            --  Avoid infinite recursion on the subsequent expansion of the\n+            --  copy of the original type conversion. When needed, a range\n+            --  check has already been applied to the expression.\n \n             Set_Comes_From_Source (New_Expr, False);\n             Insert_Action (N,\n-               Make_Predicate_Check (Target_Type, New_Expr),\n-               Suppress => Range_Check);\n+              Make_Predicate_Check (Target_Type, New_Expr),\n+              Suppress => Range_Check);\n          end;\n       end if;\n    end Expand_N_Type_Conversion;"}, {"sha": "076bbbae0de074b980b954cce952356096d17f7d", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -2472,8 +2472,7 @@ package body Exp_Ch6 is\n                   Atyp := Aund;\n                end if;\n \n-               if Has_Predicates (Atyp)\n-                 and then Present (Predicate_Function (Atyp))\n+               if Predicate_Enabled (Atyp)\n \n                  --  Skip predicate checks for special cases\n "}, {"sha": "27609c78363e85effeb20e61d843fbb85ab414fc", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -9681,10 +9681,9 @@ package body Exp_Util is\n          return Make_Null_Statement (Loc);\n       end if;\n \n-      --  Do not generate a check within an internal subprogram (stream\n-      --  functions and the like, including predicate functions).\n+      --  Do not generate a check within stream functions and the like.\n \n-      if Within_Internal_Subprogram then\n+      if not Predicate_Check_In_Scope (Expr) then\n          return Make_Null_Statement (Loc);\n       end if;\n \n@@ -13715,11 +13714,11 @@ package body Exp_Util is\n       return False;\n    end Within_Case_Or_If_Expression;\n \n-   --------------------------------\n-   -- Within_Internal_Subprogram --\n-   --------------------------------\n+   ------------------------------\n+   -- Predicate_Check_In_Scope --\n+   ------------------------------\n \n-   function Within_Internal_Subprogram return Boolean is\n+   function Predicate_Check_In_Scope (N : Node_Id) return Boolean is\n       S : Entity_Id;\n \n    begin\n@@ -13728,10 +13727,23 @@ package body Exp_Util is\n          S := Scope (S);\n       end loop;\n \n-      return Present (S)\n-        and then Get_TSS_Name (S) /= TSS_Null\n-        and then not Is_Predicate_Function (S)\n-        and then not Is_Predicate_Function_M (S);\n-   end Within_Internal_Subprogram;\n+      if Present (S) then\n+\n+         --  Predicate checks should only be enabled in init procs for\n+         --  expressions coming from source.\n+\n+         if Is_Init_Proc (S) then\n+            return Comes_From_Source (N);\n+\n+         elsif Get_TSS_Name (S) /= TSS_Null\n+           and then not Is_Predicate_Function (S)\n+           and then not Is_Predicate_Function_M (S)\n+         then\n+            return False;\n+         end if;\n+      end if;\n+\n+      return True;\n+   end Predicate_Check_In_Scope;\n \n end Exp_Util;"}, {"sha": "3f882a6f315b2aa42f3f3f6316a2d77d275a8c73", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -1195,12 +1195,10 @@ package Exp_Util is\n    function Within_Case_Or_If_Expression (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N is within a case or an if expression\n \n-   function Within_Internal_Subprogram return Boolean;\n-   --  Indicates that some expansion is taking place within the body of a\n-   --  predefined primitive operation. Some expansion activity (e.g. predicate\n-   --  checks) is disabled in such. Because we want to detect invalid uses\n-   --  of function calls within predicates (which lead to infinite recursion)\n-   --  predicate functions themselves are not considered internal here.\n+   function Predicate_Check_In_Scope (N : Node_Id) return Boolean;\n+   --  Return True if predicate checks should be generated in the current\n+   --  scope on the given node. Will return False for example when the current\n+   --  scope is a predefined primitive operation.\n \n private\n    pragma Inline (Duplicate_Subexpr);"}, {"sha": "b24e91722601b9e9bbf210fe6417d721fb4d7f8d", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -7182,6 +7182,8 @@ package body Freeze is\n       Parent_P  : Node_Id;\n       Typ       : Entity_Id;\n \n+      Allocator_Typ : Entity_Id := Empty;\n+\n       Freeze_Outside : Boolean := False;\n       --  This flag is set true if the entity must be frozen outside the\n       --  current subprogram. This happens in the case of expander generated\n@@ -7292,6 +7294,10 @@ package body Freeze is\n          when N_Allocator =>\n             Desig_Typ := Designated_Type (Etype (N));\n \n+            if Nkind (Expression (N)) = N_Qualified_Expression then\n+               Allocator_Typ := Entity (Subtype_Mark (Expression (N)));\n+            end if;\n+\n          when N_Aggregate =>\n             if Is_Array_Type (Etype (N))\n               and then Is_Access_Type (Component_Type (Etype (N)))\n@@ -7334,6 +7340,7 @@ package body Freeze is\n       if No (Typ)\n         and then No (Nam)\n         and then No (Desig_Typ)\n+        and then No (Allocator_Typ)\n       then\n          return;\n       end if;\n@@ -7803,6 +7810,14 @@ package body Freeze is\n \n       In_Spec_Expression := False;\n \n+      --  Freeze the subtype mark before a qualified expression on an\n+      --  allocator as per AARM 13.14(4.a). This is needed in particular to\n+      --  generate predicate functions.\n+\n+      if Present (Allocator_Typ) then\n+         Freeze_Before (P, Allocator_Typ);\n+      end if;\n+\n       --  Freeze the designated type of an allocator (RM 13.14(13))\n \n       if Present (Desig_Typ) then"}, {"sha": "2e728464dffc9f2168ad39718004a826bd6b40fd", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -1499,7 +1499,7 @@ package body Sem_Aggr is\n \n          --  If an aggregate component has a type with predicates, an explicit\n          --  predicate check must be applied, as for an assignment statement,\n-         --  because the aggegate might not be expanded into individual\n+         --  because the aggregate might not be expanded into individual\n          --  component assignments. If the expression covers several components\n          --  the analysis and the predicate check take place later.\n \n@@ -4105,7 +4105,7 @@ package body Sem_Aggr is\n \n          --  If an aggregate component has a type with predicates, an explicit\n          --  predicate check must be applied, as for an assignment statement,\n-         --  because the aggegate might not be expanded into individual\n+         --  because the aggregate might not be expanded into individual\n          --  component assignments.\n \n          if Has_Predicates (Expr_Type)"}, {"sha": "0351a0f1427be9dbed23ebc945b8513a32dce47f", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -12308,16 +12308,16 @@ package body Sem_Ch13 is\n       Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n \n       --  If we have a type with predicates, build predicate function. This is\n-      --  not needed in the generic case, nor within TSS subprograms and other\n-      --  predefined primitives. For a derived type, ensure that the parent\n-      --  type is already frozen so that its predicate function has been\n+      --  not needed in the generic case, nor within e.g. TSS subprograms and\n+      --  other predefined primitives. For a derived type, ensure that the\n+      --  parent type is already frozen so that its predicate function has been\n       --  constructed already. This is necessary if the parent is declared\n       --  in a nested package and its own freeze point has not been reached.\n \n       if Is_Type (E)\n         and then Nongeneric_Case\n-        and then not Within_Internal_Subprogram\n         and then Has_Predicates (E)\n+        and then Predicate_Check_In_Scope (N)\n       then\n          declare\n             Atyp : constant Entity_Id := Nearest_Ancestor (E);"}, {"sha": "3907272c31aa4068965a0f32de93c3c1b6593f37", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -4418,8 +4418,7 @@ package body Sem_Ch3 is\n       --  the predicate still applies.\n \n       if not Suppress_Assignment_Checks (N)\n-        and then Present (Predicate_Function (T))\n-        and then not Predicates_Ignored (T)\n+        and then Predicate_Enabled (T)\n         and then\n           (not No_Initialization (N)\n             or else (Present (E) and then Nkind (E) = N_Aggregate))"}, {"sha": "6c2a4992cf6ec70592177ec72ba06598631a2500", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -24807,6 +24807,17 @@ package body Sem_Util is\n       return Kind;\n    end Policy_In_Effect;\n \n+   -----------------------\n+   -- Predicate_Enabled --\n+   -----------------------\n+\n+   function Predicate_Enabled (Typ : Entity_Id) return Boolean is\n+   begin\n+      return Present (Predicate_Function (Typ))\n+        and then not Predicates_Ignored (Typ)\n+        and then not Predicate_Checks_Suppressed (Empty);\n+   end Predicate_Enabled;\n+\n    ----------------------------------\n    -- Predicate_Tests_On_Arguments --\n    ----------------------------------"}, {"sha": "017a42a45e0488b0ff9e755f71a7a8da65ebb34f", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -2601,6 +2601,11 @@ package Sem_Util is\n    --  Given a policy, return the policy identifier associated with it. If no\n    --  such policy is in effect, the value returned is No_Name.\n \n+   function Predicate_Enabled (Typ : Entity_Id) return Boolean;\n+   --  Return True if a predicate check should be emitted for the given type\n+   --  Typ, taking into account Predicates_Ignored and\n+   --  Predicate_Checks_Suppressed.\n+\n    function Predicate_Tests_On_Arguments (Subp : Entity_Id) return Boolean;\n    --  Subp is the entity for a subprogram call. This function returns True if\n    --  predicate tests are required for the arguments in this call (this is the"}, {"sha": "8fc91fdc39f0e55ab455e9c416b7a44328f2c39b", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/152f64c2c6c31b6574258312c867e15703add0fd/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=152f64c2c6c31b6574258312c867e15703add0fd", "patch": "@@ -2391,6 +2391,7 @@ package body Sprint is\n \n                   if Present (Expression (Node))\n                     and then Expression (Node) /= Error\n+                    and then not No_Initialization (Node)\n                   then\n                      Write_Str (\" := \");\n                      Sprint_Node (Expression (Node));"}]}