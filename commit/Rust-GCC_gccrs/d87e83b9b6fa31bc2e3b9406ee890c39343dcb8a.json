{"sha": "d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg3ZTgzYjliNmZhMzFiYzJlM2I5NDA2ZWU4OTBjMzkzNDNkY2I4YQ==", "commit": {"author": {"name": "Stephane Carrez", "email": "stcarrez@nerim.fr", "date": "2004-03-02T22:16:15Z"}, "committer": {"name": "Stephane Carrez", "email": "ciceron@gcc.gnu.org", "date": "2004-03-02T22:16:15Z"}, "message": "m68hc11.md (move peephole2): New peepholes to optimize sequences of moves.\n\n\t* config/m68hc11/m68hc11.md (move peephole2): New peepholes to optimize\n\tsequences of moves.\n\t(add peepholes): New peepholes to optimize sequences adding small\n\tconstants.\n\t(bset peepholes): New peepholes to transform an OR in a bset form\n\t(bclr peepholes): Likewise for bclr form.\n\t(cmp peepholes): New peepholes to avoid register copies when comparing.\n\nFrom-SVN: r78787", "tree": {"sha": "6cd18a7c0bc72a7fdeeae48dfbf58d8620d43ce0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd18a7c0bc72a7fdeeae48dfbf58d8620d43ce0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a/comments", "author": null, "committer": null, "parents": [{"sha": "d5111c9c202ac474da83aa29927454596ebcbbe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5111c9c202ac474da83aa29927454596ebcbbe2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5111c9c202ac474da83aa29927454596ebcbbe2"}], "stats": {"total": 345, "additions": 345, "deletions": 0}, "files": [{"sha": "a1782ba302f0298b2b7b4f0bc1dc80a3d34bd0cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a", "patch": "@@ -1,3 +1,13 @@\n+2004-03-02  Stephane Carrez  <stcarrez@nerim.fr>\n+\n+\t* config/m68hc11/m68hc11.md (move peephole2): New peepholes to optimize\n+\tsequences of moves.\n+\t(add peepholes): New peepholes to optimize sequences adding small\n+\tconstants.\n+\t(bset peepholes): New peepholes to transform an OR in a bset form\n+\t(bclr peepholes): Likewise for bclr form.\n+\t(cmp peepholes): New peepholes to avoid register copies when comparing.\n+\n 2004-03-02  Stephane Carrez  <stcarrez@nerim.fr>\n \n \t* config/m68hc11/m68hc11.md (\"*pushdi_internal\"): New insn and split"}, {"sha": "08d03cbd6ffd2779d24982e750b8872974e43e4c", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=d87e83b9b6fa31bc2e3b9406ee890c39343dcb8a", "patch": "@@ -6907,6 +6907,61 @@\n \t\t\t  gen_rtx_POST_INC (HImode,\n \t\t\t\t   gen_rtx_REG (HImode, HARD_SP_REGNUM)));\")\n \n+;; Replace: \"pshx; tfr d,x; stx 0,sp\" into \"pshd; tfr d,x\"\n+(define_peephole2\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (match_operand:HI 0 \"hard_reg_operand\" \"\"))\n+   (set (match_dup 0)\n+        (match_operand:HI 1 \"hard_reg_operand\" \"\"))\n+   (set (mem:HI (reg:HI SP_REGNUM))\n+        (match_dup 0))]\n+  \"TARGET_M6812\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (match_dup 1))\n+   (set (match_dup 0) (match_dup 1))]\n+  \"\")\n+\n+;;\n+;; Change: \"ldd 0,sp; pulx\" into  \"puld\"\n+;; This sequence usually appears at end a functions.\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+        (mem:HI (reg:HI SP_REGNUM)))\n+   (use (match_dup 0))\n+   (set (match_operand:HI 1 \"hard_reg_operand\" \"\")\n+        (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))]\n+  \"peep2_reg_dead_p (2, operands[1])\"\n+  [(set (match_dup 0) (mem:HI (post_inc:HI (reg:HI SP_REGNUM))))\n+   (use (match_dup 0))]\n+  \"\")\n+\n+;; Replace: \"pshx; clr 0,sp; clr 1,sp\" by \"clr 1,-sp; clr 1,-sp\"\n+;; Appears to allocate local variables.\n+(define_peephole2\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (match_operand:HI 0 \"hard_reg_operand\" \"\"))\n+   (set (mem:QI (plus:HI (reg:HI SP_REGNUM) (const_int 1)))\n+        (const_int 0))\n+   (set (mem:QI (reg:HI SP_REGNUM))\n+        (const_int 0))]\n+  \"TARGET_M6812\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (const_int 0))]\n+  \"\")\n+\n+;; Likewise for HI mode\n+(define_peephole2\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (match_operand:HI 0 \"hard_reg_operand\" \"\"))\n+   (set (mem:HI (reg:HI SP_REGNUM))\n+        (const_int 0))]\n+  \"TARGET_M6812\"\n+  [(set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM)))\n+        (const_int 0))]\n+  \"\")\n+;;--------------------------------------------------------------------\n+;;- \n+;;--------------------------------------------------------------------\n ;;\n ;; Optimize memory<->memory moves when the value is also loaded in\n ;; a register.\n@@ -6970,6 +7025,36 @@\n    (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n   \"\")\n \n+;;\n+;; Replace: \"ldx #N; xgdx; addd <var>; xgdx\" by \"ldab #N; ldx <var>; abx\"\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 2 \"general_operand\" \"\")))\n+   (match_scratch:QI 3 \"d\")]\n+  \"TARGET_M6811 && (INTVAL (operands[1]) >= 0 && INTVAL (operands[1]) <= 0x0ff)\"\n+  [(set (match_dup 3) (match_dup 4))\n+   (set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (plus:HI (zero_extend:HI (match_dup 3)) (match_dup 0)))]\n+  \"operands[4] = m68hc11_gen_lowpart (QImode, operands[1]);\")\n+\n+;;\n+;; Replace: \"ldx #N; xgdx; addd <var>; xgdx\" by \"ldab #N; ldx <var>; abx\"\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"const_int_operand\" \"\"))\n+   (set (match_dup 0)\n+\t(plus:HI (match_dup 0)\n+\t         (match_operand:HI 2 \"general_operand\" \"\")))]\n+  \"TARGET_M6812\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n+  \"\")\n+\n ;;\n ;; Optimize an address register increment and a compare to use\n ;; a PRE_INC or PRE_DEC addressing mode (disabled on the tst insn\n@@ -7061,6 +7146,31 @@\n    (set (match_dup 0) (plus:HI (match_dup 0) (match_dup 1)))]\n   \"\")\n \n+;;\n+;;\n+;;\n+(define_peephole2\n+  [(parallel \n+     [(set (match_operand:SI 0 \"hard_reg_operand\" \"\")\n+\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"\")\n+\t\t   (const_int 1)))\n+      (clobber (match_scratch:HI 2 \"\"))])\n+   (set (match_operand:HI 3 \"nonimmediate_operand\" \"\") (reg:HI D_REGNUM))\n+   (set (match_operand:HI 4 \"nonimmediate_operand\" \"\") (reg:HI X_REGNUM))]\n+  \"!X_REG_P (operands[1])\n+   && peep2_reg_dead_p (2, gen_rtx (REG, HImode, D_REGNUM))\n+   && peep2_reg_dead_p (3, gen_rtx (REG, HImode, X_REGNUM))\"\n+  [(set (reg:HI D_REGNUM) (match_dup 5))\n+   (set (reg:HI D_REGNUM) (ashift:HI (reg:HI D_REGNUM) (const_int 1)))\n+   (set (match_dup 3) (reg:HI D_REGNUM))\n+   (set (reg:HI D_REGNUM) (match_dup 6))\n+   (parallel [(set (reg:HI D_REGNUM)\n+\t\t   (rotate:HI (reg:HI D_REGNUM) (const_int 1)))\n+              (clobber (reg:HI CC_REGNUM))])\n+   (set (match_dup 4) (reg:HI D_REGNUM))]\n+  \"operands[5] = m68hc11_gen_lowpart (HImode, operands[1]);\n+   operands[6] = m68hc11_gen_highpart (HImode, operands[1]);\")\n+\n ;;\n ;; Replace a \"ldd <mem>; psha; pshb\" with a \"ldx <mem>; pshx\".\n ;;\n@@ -7075,6 +7185,25 @@\n    (set (mem:HI (pre_dec:HI (reg:HI SP_REGNUM))) (match_dup 2))]\n   \"\")\n \n+;;\n+;; Remove one load when copying a value to/from memory and also\n+;; to a register.  Take care not cloberring a possible register used\n+;; by operand 2.\n+;; Replace: \"ldd 0,y; std 2,y; ldx 0,y\" into \"ldx 0,y; stx 2,y\"\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+        (match_operand:HI 1 \"general_operand\" \"\"))\n+   (set (match_operand:HI 2 \"nonimmediate_operand\" \"\") (match_dup 0))\n+   (set (match_operand:HI 3 \"hard_reg_operand\" \"\") (match_dup 1))]\n+  \"peep2_reg_dead_p (2, operands[0])\n+   && !side_effects_p (operands[1])\n+   && !side_effects_p (operands[2])\n+   && !reg_mentioned_p (operands[3], operands[2])\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 2) (match_dup 3))]\n+  \"\")\n+\n ;;\n ;; Replace a \"ldd <mem>; addd #N; std <mem>\" into a\n ;; \"ldx <mem>; leax; stx <mem>\" if we have a free X/Y register\n@@ -7098,6 +7227,174 @@\n   \"if (reg_mentioned_p (operands[4], operands[1])) FAIL;\n    if (reg_mentioned_p (operands[4], operands[3])) FAIL;\")\n \n+;;--------------------------------------------------------------------\n+;;- Bset peephole2\n+;;--------------------------------------------------------------------\n+;; These peepholes try to replace some logical sequences by 'bset' and 'bclr'.\n+;;\n+;; Replace 'ldab <mem>; orab #N; stab <mem>' by 'bset <mem> #N'.\n+;; Register D must be dead and there must be no register side effects for mem.\n+;; The <mem> *can* be volatile this is why we must not use 'side_effects_p'.\n+;; The good side effect is that it makes the sequence atomic.\n+;;\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:QI 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_dup 0) (ior:QI (match_dup 0)\n+\t\t\t      (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (set (match_dup 1) (match_dup 0))]\n+  \"(TARGET_M6812 || m68hc11_indirect_p (operands[1], QImode))\n+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))\n+   && peep2_reg_dead_p (3, operands[0])\"\n+  [(set (match_dup 1) (ior:QI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_dup 0) (ior:HI (match_dup 0)\n+\t\t\t      (match_operand:HI 2 \"const_int_operand\" \"\")))\n+   (set (match_dup 1) (match_dup 0))]\n+  \"(TARGET_M6812 || m68hc11_indirect_p (operands[1], HImode))\n+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))\n+   && peep2_reg_dead_p (3, operands[0])\"\n+  [(set (match_dup 1) (ior:HI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+;;--------------------------------------------------------------------\n+;;- Bclr peephole2\n+;;--------------------------------------------------------------------\n+;; Replace 'ldab <mem>; andab #N; stab <mem>' by 'bclr <mem> #N'.\n+;; See Bset peephole2.\n+;;\n+(define_peephole2\n+  [(set (match_operand:QI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:QI 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_dup 0) (and:QI (match_dup 0)\n+\t\t\t      (match_operand:QI 2 \"const_int_operand\" \"\")))\n+   (set (match_dup 1) (match_dup 0))]\n+  \"(TARGET_M6812 || m68hc11_indirect_p (operands[1], QImode))\n+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))\n+   && peep2_reg_dead_p (3, operands[0])\"\n+  [(set (match_dup 1) (and:QI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"nonimmediate_operand\" \"\"))\n+   (set (match_dup 0) (and:HI (match_dup 0)\n+\t\t\t      (match_operand:HI 2 \"const_int_operand\" \"\")))\n+   (set (match_dup 1) (match_dup 0))]\n+  \"(TARGET_M6812 || m68hc11_indirect_p (operands[1], HImode))\n+   && (GET_CODE (operands[1]) != MEM || !auto_inc_p (XEXP (operands[1], 0)))\n+   && peep2_reg_dead_p (3, operands[0])\"\n+  [(set (match_dup 1) (and:HI (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+\n+;;--------------------------------------------------------------------\n+;;- Compare peephole2\n+;;--------------------------------------------------------------------\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"hard_reg_operand\" \"\"))\n+   (set (match_dup 1) (plus:HI (match_dup 1) \n+                               (match_operand:HI 2 \"const_int_operand\" \"\")))\n+   (set (cc0) (match_dup 0))]\n+  \"peep2_reg_dead_p (3, operands[0]) && !Z_REG_P (operands[1])\"\n+  [(set (match_dup 1) (plus:HI (match_dup 1) (match_dup 2)))\n+   (set (cc0) (compare (match_dup 1) (match_dup 2)))]\n+  \"\")\n+\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"hard_reg_operand\" \"\"))\n+   (set (match_operand:HI 2 \"hard_reg_operand\" \"\")\n+        (plus:HI (match_dup 2) \n+                 (match_operand:HI 3 \"const_int_operand\" \"\")))\n+   (set (match_operand:HI 4 \"memory_operand\" \"\") (match_dup 2))\n+   (set (cc0) (match_operand:HI 5 \"hard_reg_operand\" \"\"))]\n+  \"peep2_reg_dead_p (4, operands[5]) && !Z_REG_P (operands[2])\n+   && !reg_mentioned_p (operands[2], operands[4])\n+\n+   && ((rtx_equal_p (operands[5], operands[0])\n+        && rtx_equal_p (operands[2], operands[1]))\n+\n+       || (rtx_equal_p (operands[5], operands[1])\n+           && rtx_equal_p (operands[2], operands[0])))\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 2) (plus:HI (match_dup 2) (match_dup 3)))\n+   (set (match_dup 4) (match_dup 2))\n+   (set (cc0) (compare (match_dup 2) (match_dup 3)))]\n+  \"\")\n+\n+\n+;;--------------------------------------------------------------------\n+;;- Load peephole2\n+;;--------------------------------------------------------------------\n+;;\n+;; Optimize initialization of 2 hard regs from the same memory location\n+;; Since we can't copy easily X, Y and D to each other, load the 2 registers\n+;; from the same memory location.\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:HI 2 \"hard_reg_operand\" \"\") (match_dup 0))]\n+  \"TARGET_M6811\n+   && !side_effects_p (operands[1])\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 2) (match_dup 1))]\n+  \"\")\n+\n+;; Replace \"ldd #N; addd <op>\" with \"ldd <op>; addd #N\".\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (set (match_operand:HI 1 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (set (match_operand:HI 2 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (set (match_operand:HI 3 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (match_scratch:HI 4 \"d\")]\n+  \"\"\n+  [(set (match_dup 4) (const_int 0))\n+   (set (match_dup 0) (match_dup 4))\n+   (set (match_dup 1) (match_dup 4))\n+   (set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 4))]\n+  \"\")\n+\n+;;\n+;; Replace \"ldd #N; addd <op>\" with \"ldd <op>; addd #N\".\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (set (match_operand:HI 1 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (set (match_operand:HI 2 \"nonimmediate_operand\" \"\") (const_int 0))\n+   (match_scratch:HI 3 \"d\")]\n+  \"\"\n+  [(set (match_dup 3) (const_int 0))\n+   (set (match_dup 0) (match_dup 3))\n+   (set (match_dup 1) (match_dup 3))\n+   (set (match_dup 2) (match_dup 3))]\n+  \"\")\n+\n+;;\n+;; Replace \"ldd #N; addd <op>\" with \"ldd <op>; addd #N\".\n+;;\n+(define_peephole2\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\") (const_int 0))\n+   (set (match_operand:HI 1 \"push_operand\" \"\") (match_dup 0))\n+   (set (match_operand:HI 2 \"push_operand\" \"\") (match_dup 0))\n+   (set (match_operand:HI 3 \"push_operand\" \"\") (match_dup 0))\n+   (match_scratch:HI 4 \"x\")]\n+  \"TARGET_M6811 && D_REG_P (operands[0]) && peep2_reg_dead_p (4, operands[0])\"\n+  [(set (match_dup 4) (const_int 0))\n+   (set (match_dup 1) (match_dup 4))\n+   (set (match_dup 2) (match_dup 4))\n+   (set (match_dup 3) (match_dup 4))]\n+  \"\")\n+\n ;;\n ;; This peephole catches the address computations generated by the reload\n ;; pass. \n@@ -7367,3 +7664,41 @@\n   return \\\"sts\\\\t%t0\\\\n\\\\tld%0\\\\t%t0\\\";\n }\n \")\n+\n+(define_peephole\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\")\n+\t(match_operand:HI 1 \"memory_operand\" \"\"))\n+   (set (match_operand:HI 2 \"hard_reg_operand\" \"\") (match_dup 0))]\n+  \"TARGET_M6811\n+   && !side_effects_p (operands[1])\n+   && !reg_mentioned_p (operands[0], operands[1])\"\n+  \"*\n+{\n+  rtx ops[2];\n+\n+  ops[0] = operands[0];\n+  ops[1] = operands[1];\n+  m68hc11_gen_movhi (insn, ops);\n+  ops[0] = operands[2];\n+  m68hc11_gen_movhi (insn, ops);\n+  return \\\"\\\";\n+}\")\n+\n+;; Peephole for Z register replacement.\n+;; Avoid to use _.tmp register when comparing D and X if we can compare\n+;; with soft register\n+(define_peephole\n+  [(set (match_operand:HI 0 \"hard_reg_operand\" \"\") (reg:HI SOFT_XY_REGNUM))\n+   (set (reg:HI SOFT_TMP_REGNUM) (match_dup 0))\n+   (set (cc0) (compare (match_operand:HI 2 \"hard_reg_operand\" \"\")\n+                       (reg:HI SOFT_TMP_REGNUM)))]\n+  \"X_REG_P (operands[0]) || Y_REG_P (operands[0])\"\n+  \"*\n+{\n+  rtx ops[2];\n+\n+  ops[0] = operands[0];\n+  ops[1] = operands[1];\n+  m68hc11_gen_movhi (insn, ops);\n+  return \\\"cp%2\\\\t%1\\\";\n+}\")"}]}