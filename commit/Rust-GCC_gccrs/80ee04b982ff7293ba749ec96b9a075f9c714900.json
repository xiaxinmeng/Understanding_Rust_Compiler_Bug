{"sha": "80ee04b982ff7293ba749ec96b9a075f9c714900", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBlZTA0Yjk4MmZmNzI5M2JhNzQ5ZWM5NmI5YTA3NWY5YzcxNDkwMA==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-12-30T13:16:36Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-12-30T13:16:36Z"}, "message": "re PR fortran/30321 (program crash for SUM applied to zero-size array)\n\n2006-12-30  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30321\n\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code):\n\tCheck for extents < 0 for zero-sized arrays.  If\n\tno retarray has been specified and the size is zero,\n\treturn early.\n\t(`m'name`'rtype_qual`_'atype_code): Likewise.\n\t* generated/all_l16.c: Regenerated.\n\t* generated/all_l4.c: Regenerated.\n\t* generated/all_l8.c: Regenerated.\n\t* generated/any_l16.c: Regenerated.\n\t* generated/any_l4.c: Regenerated.\n\t* generated/any_l8.c: Regenerated.\n\t* generated/count_16_l16.c: Regenerated.\n\t* generated/count_16_l4.c: Regenerated.\n\t* generated/count_16_l8.c: Regenerated.\n\t* generated/count_4_l16.c: Regenerated.\n\t* generated/count_4_l4.c: Regenerated.\n\t* generated/count_4_l8.c: Regenerated.\n\t* generated/count_8_l16.c: Regenerated.\n\t* generated/count_8_l4.c: Regenerated.\n\t* generated/count_8_l8.c: Regenerated.\n\t* generated/cshift1_16.c: Regenerated.\n\t* generated/cshift1_4.c: Regenerated.\n\t* generated/cshift1_8.c: Regenerated.\n\t* generated/maxloc1_16_i16.c: Regenerated.\n\t* generated/maxloc1_16_i4.c: Regenerated.\n\t* generated/maxloc1_16_i8.c: Regenerated.\n\t* generated/maxloc1_16_r10.c: Regenerated.\n\t* generated/maxloc1_16_r16.c: Regenerated.\n\t* generated/maxloc1_16_r4.c: Regenerated.\n\t* generated/maxloc1_16_r8.c: Regenerated.\n\t* generated/maxloc1_4_i16.c: Regenerated.\n\t* generated/maxloc1_4_i4.c: Regenerated.\n\t* generated/maxloc1_4_i8.c: Regenerated.\n\t* generated/maxloc1_4_r10.c: Regenerated.\n\t* generated/maxloc1_4_r16.c: Regenerated.\n\t* generated/maxloc1_4_r4.c: Regenerated.\n\t* generated/maxloc1_4_r8.c: Regenerated.\n\t* generated/maxloc1_8_i16.c: Regenerated.\n\t* generated/maxloc1_8_i4.c: Regenerated.\n\t* generated/maxloc1_8_i8.c: Regenerated.\n\t* generated/maxloc1_8_r10.c: Regenerated.\n\t* generated/maxloc1_8_r16.c: Regenerated.\n\t* generated/maxloc1_8_r4.c: Regenerated.\n\t* generated/maxloc1_8_r8.c: Regenerated.\n\t* generated/maxval_i16.c: Regenerated.\n\t* generated/maxval_i4.c: Regenerated.\n\t* generated/maxval_i8.c: Regenerated.\n\t* generated/maxval_r10.c: Regenerated.\n\t* generated/maxval_r16.c: Regenerated.\n\t* generated/maxval_r4.c: Regenerated.\n\t* generated/maxval_r8.c: Regenerated.\n\t* generated/minloc1_16_i16.c: Regenerated.\n\t* generated/minloc1_16_i4.c: Regenerated.\n\t* generated/minloc1_16_i8.c: Regenerated.\n\t* generated/minloc1_16_r10.c: Regenerated.\n\t* generated/minloc1_16_r16.c: Regenerated.\n\t* generated/minloc1_16_r4.c: Regenerated.\n\t* generated/minloc1_16_r8.c: Regenerated.\n\t* generated/minloc1_4_i16.c: Regenerated.\n\t* generated/minloc1_4_i4.c: Regenerated.\n\t* generated/minloc1_4_i8.c: Regenerated.\n\t* generated/minloc1_4_r10.c: Regenerated.\n\t* generated/minloc1_4_r16.c: Regenerated.\n\t* generated/minloc1_4_r4.c: Regenerated.\n\t* generated/minloc1_4_r8.c: Regenerated.\n\t* generated/minloc1_8_i16.c: Regenerated.\n\t* generated/minloc1_8_i4.c: Regenerated.\n\t* generated/minloc1_8_i8.c: Regenerated.\n\t* generated/minloc1_8_r10.c: Regenerated.\n\t* generated/minloc1_8_r16.c: Regenerated.\n\t* generated/minloc1_8_r4.c: Regenerated.\n\t* generated/minloc1_8_r8.c: Regenerated.\n\t* generated/minval_i16.c: Regenerated.\n\t* generated/minval_i4.c: Regenerated.\n\t* generated/minval_i8.c: Regenerated.\n\t* generated/minval_r10.c: Regenerated.\n\t* generated/minval_r16.c: Regenerated.\n\t* generated/minval_r4.c: Regenerated.\n\t* generated/minval_r8.c: Regenerated.\n\t* generated/product_c10.c: Regenerated.\n\t* generated/product_c16.c: Regenerated.\n\t* generated/product_c4.c: Regenerated.\n\t* generated/product_c8.c: Regenerated.\n\t* generated/product_i16.c: Regenerated.\n\t* generated/product_i4.c: Regenerated.\n\t* generated/product_i8.c: Regenerated.\n\t* generated/product_r10.c: Regenerated.\n\t* generated/product_r16.c: Regenerated.\n\t* generated/product_r4.c: Regenerated.\n\t* generated/product_r8.c: Regenerated.\n\t* generated/sum_c10.c: Regenerated.\n\t* generated/sum_c16.c: Regenerated.\n\t* generated/sum_c4.c: Regenerated.\n\t* generated/sum_c8.c: Regenerated.\n\t* generated/sum_i16.c: Regenerated.\n\t* generated/sum_i4.c: Regenerated.\n\t* generated/sum_i8.c: Regenerated.\n\t* generated/sum_r10.c: Regenerated.\n\t* generated/sum_r16.c: Regenerated.\n\t* generated/sum_r4.c: Regenerated.\n\t* generated/sum_r8.c: Regenerated.\n\n2006-12-30  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR libfortran/30321\n\t* gfortran.dg/sum_zero_array_1.f90:  New test.\n\nFrom-SVN: r120287", "tree": {"sha": "c4d838dbc27d49cca645bfaba8a83f2b0ebddd53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4d838dbc27d49cca645bfaba8a83f2b0ebddd53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80ee04b982ff7293ba749ec96b9a075f9c714900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ee04b982ff7293ba749ec96b9a075f9c714900", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ee04b982ff7293ba749ec96b9a075f9c714900", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ee04b982ff7293ba749ec96b9a075f9c714900/comments", "author": null, "committer": null, "parents": [{"sha": "54e7d067d5f79ec637ca301e69b70665df0d16dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e7d067d5f79ec637ca301e69b70665df0d16dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e7d067d5f79ec637ca301e69b70665df0d16dd"}], "stats": {"total": 4618, "additions": 3920, "deletions": 698}, "files": [{"sha": "4874ec7a39c405b50f148b4d5fddb989c6c16bef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -1,3 +1,8 @@\n+2006-12-30  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30321\n+\t* gfortran.dg/sum_zero_array_1.f90:  New test.\n+\n 2006-12-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/29612"}, {"sha": "b864bbf71a0f6a1dd37f3445777c4c88f33e4186", "filename": "gcc/testsuite/gfortran.dg/sum_zero_array_1.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/gcc%2Ftestsuite%2Fgfortran.dg%2Fsum_zero_array_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/gcc%2Ftestsuite%2Fgfortran.dg%2Fsum_zero_array_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsum_zero_array_1.f90?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR 30321:  This used to segfault.\n+program xzero\n+  implicit none\n+  integer :: ii(1,0)\n+  logical :: ll(1,0)\n+  character (len=80) line\n+  ll = .true.\n+  write (unit=line, fmt=\"(I6)\") sum(ii,dim=1)\n+  if (line /= \" \") call abort\n+  write (unit=line, fmt=\"(I6)\") sum(ii,dim=1,mask=ll)\n+  if (line /= \" \") call abort\n+end program xzero"}, {"sha": "2096806c6bdee773b706e2f0c523c384ea3a9783", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -1,3 +1,108 @@\n+2006-12-30  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR libfortran/30321\n+\t* m4/ifunction.m4 (name`'rtype_qual`_'atype_code):\n+\tCheck for extents < 0 for zero-sized arrays.  If\n+\tno retarray has been specified and the size is zero,\n+\treturn early.\n+\t(`m'name`'rtype_qual`_'atype_code): Likewise.\n+\t* generated/all_l16.c: Regenerated.\n+\t* generated/all_l4.c: Regenerated.\n+\t* generated/all_l8.c: Regenerated.\n+\t* generated/any_l16.c: Regenerated.\n+\t* generated/any_l4.c: Regenerated.\n+\t* generated/any_l8.c: Regenerated.\n+\t* generated/count_16_l16.c: Regenerated.\n+\t* generated/count_16_l4.c: Regenerated.\n+\t* generated/count_16_l8.c: Regenerated.\n+\t* generated/count_4_l16.c: Regenerated.\n+\t* generated/count_4_l4.c: Regenerated.\n+\t* generated/count_4_l8.c: Regenerated.\n+\t* generated/count_8_l16.c: Regenerated.\n+\t* generated/count_8_l4.c: Regenerated.\n+\t* generated/count_8_l8.c: Regenerated.\n+\t* generated/cshift1_16.c: Regenerated.\n+\t* generated/cshift1_4.c: Regenerated.\n+\t* generated/cshift1_8.c: Regenerated.\n+\t* generated/maxloc1_16_i16.c: Regenerated.\n+\t* generated/maxloc1_16_i4.c: Regenerated.\n+\t* generated/maxloc1_16_i8.c: Regenerated.\n+\t* generated/maxloc1_16_r10.c: Regenerated.\n+\t* generated/maxloc1_16_r16.c: Regenerated.\n+\t* generated/maxloc1_16_r4.c: Regenerated.\n+\t* generated/maxloc1_16_r8.c: Regenerated.\n+\t* generated/maxloc1_4_i16.c: Regenerated.\n+\t* generated/maxloc1_4_i4.c: Regenerated.\n+\t* generated/maxloc1_4_i8.c: Regenerated.\n+\t* generated/maxloc1_4_r10.c: Regenerated.\n+\t* generated/maxloc1_4_r16.c: Regenerated.\n+\t* generated/maxloc1_4_r4.c: Regenerated.\n+\t* generated/maxloc1_4_r8.c: Regenerated.\n+\t* generated/maxloc1_8_i16.c: Regenerated.\n+\t* generated/maxloc1_8_i4.c: Regenerated.\n+\t* generated/maxloc1_8_i8.c: Regenerated.\n+\t* generated/maxloc1_8_r10.c: Regenerated.\n+\t* generated/maxloc1_8_r16.c: Regenerated.\n+\t* generated/maxloc1_8_r4.c: Regenerated.\n+\t* generated/maxloc1_8_r8.c: Regenerated.\n+\t* generated/maxval_i16.c: Regenerated.\n+\t* generated/maxval_i4.c: Regenerated.\n+\t* generated/maxval_i8.c: Regenerated.\n+\t* generated/maxval_r10.c: Regenerated.\n+\t* generated/maxval_r16.c: Regenerated.\n+\t* generated/maxval_r4.c: Regenerated.\n+\t* generated/maxval_r8.c: Regenerated.\n+\t* generated/minloc1_16_i16.c: Regenerated.\n+\t* generated/minloc1_16_i4.c: Regenerated.\n+\t* generated/minloc1_16_i8.c: Regenerated.\n+\t* generated/minloc1_16_r10.c: Regenerated.\n+\t* generated/minloc1_16_r16.c: Regenerated.\n+\t* generated/minloc1_16_r4.c: Regenerated.\n+\t* generated/minloc1_16_r8.c: Regenerated.\n+\t* generated/minloc1_4_i16.c: Regenerated.\n+\t* generated/minloc1_4_i4.c: Regenerated.\n+\t* generated/minloc1_4_i8.c: Regenerated.\n+\t* generated/minloc1_4_r10.c: Regenerated.\n+\t* generated/minloc1_4_r16.c: Regenerated.\n+\t* generated/minloc1_4_r4.c: Regenerated.\n+\t* generated/minloc1_4_r8.c: Regenerated.\n+\t* generated/minloc1_8_i16.c: Regenerated.\n+\t* generated/minloc1_8_i4.c: Regenerated.\n+\t* generated/minloc1_8_i8.c: Regenerated.\n+\t* generated/minloc1_8_r10.c: Regenerated.\n+\t* generated/minloc1_8_r16.c: Regenerated.\n+\t* generated/minloc1_8_r4.c: Regenerated.\n+\t* generated/minloc1_8_r8.c: Regenerated.\n+\t* generated/minval_i16.c: Regenerated.\n+\t* generated/minval_i4.c: Regenerated.\n+\t* generated/minval_i8.c: Regenerated.\n+\t* generated/minval_r10.c: Regenerated.\n+\t* generated/minval_r16.c: Regenerated.\n+\t* generated/minval_r4.c: Regenerated.\n+\t* generated/minval_r8.c: Regenerated.\n+\t* generated/product_c10.c: Regenerated.\n+\t* generated/product_c16.c: Regenerated.\n+\t* generated/product_c4.c: Regenerated.\n+\t* generated/product_c8.c: Regenerated.\n+\t* generated/product_i16.c: Regenerated.\n+\t* generated/product_i4.c: Regenerated.\n+\t* generated/product_i8.c: Regenerated.\n+\t* generated/product_r10.c: Regenerated.\n+\t* generated/product_r16.c: Regenerated.\n+\t* generated/product_r4.c: Regenerated.\n+\t* generated/product_r8.c: Regenerated.\n+\t* generated/sum_c10.c: Regenerated.\n+\t* generated/sum_c16.c: Regenerated.\n+\t* generated/sum_c4.c: Regenerated.\n+\t* generated/sum_c8.c: Regenerated.\n+\t* generated/sum_i16.c: Regenerated.\n+\t* generated/sum_i4.c: Regenerated.\n+\t* generated/sum_i8.c: Regenerated.\n+\t* generated/sum_r10.c: Regenerated.\n+\t* generated/sum_r16.c: Regenerated.\n+\t* generated/sum_r4.c: Regenerated.\n+\t* generated/sum_r8.c: Regenerated.\n+\n 2006-12-27  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/30014"}, {"sha": "24aa4d7127870a99e3ea008fef55c0f6892a74b9", "filename": "libgfortran/generated/all_l16.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fall_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fall_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ all_l16 (gfc_array_l16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_LOGICAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "be4fece74e3ced1fbab97d705a235bd6ce4e494e", "filename": "libgfortran/generated/all_l4.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fall_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fall_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ all_l4 (gfc_array_l4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_LOGICAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "684510c5f20d1ef4bb51dcb063b20a60d293fd64", "filename": "libgfortran/generated/all_l8.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fall_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fall_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fall_l8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ all_l8 (gfc_array_l8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_LOGICAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "d351f222717f5ef47f79da77af01a7533fdec69d", "filename": "libgfortran/generated/any_l16.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fany_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fany_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ any_l16 (gfc_array_l16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_LOGICAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "316d9e252319c8ac68bfa3ce608729683d9aa636", "filename": "libgfortran/generated/any_l4.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fany_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fany_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ any_l4 (gfc_array_l4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_LOGICAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "6efe431da4028949a87406fe4f69226931bb66b8", "filename": "libgfortran/generated/any_l8.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fany_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fany_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fany_l8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ any_l8 (gfc_array_l8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_LOGICAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_LOGICAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "c396650eff190448fe23bf9a63d89f94a53b6f63", "filename": "libgfortran/generated/count_16_l16.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_16_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_16_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_16_l16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_16_l16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "0f417ac96f3744a02688995cd1f9e80756fccd9a", "filename": "libgfortran/generated/count_16_l4.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_16_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_16_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_16_l4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_16_l4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "2e4ea41b693f68733627b280b471d37598aef1ef", "filename": "libgfortran/generated/count_16_l8.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_16_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_16_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_16_l8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_16_l8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "0c13dd4822294b1163d4033ea0ee83ea11c02c49", "filename": "libgfortran/generated/count_4_l16.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_4_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_4_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_4_l16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_4_l16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "6a8fde0b4b93aa8cf8e4c827fe7bedb49012d6bb", "filename": "libgfortran/generated/count_4_l4.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_4_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_4_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_4_l4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_4_l4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "f1fd30296b341278179d98dd3b252aeaf54ca63a", "filename": "libgfortran/generated/count_4_l8.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_4_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_4_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_4_l8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_4_l8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "2c75d93e00032866f9cf16248ab2b687bd2120d4", "filename": "libgfortran/generated/count_8_l16.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_8_l16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_8_l16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_8_l16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_8_l16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "9ecddbd10b11eff54fc7de9cc400cdff870209e8", "filename": "libgfortran/generated/count_8_l4.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_8_l4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_8_l4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_8_l4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "8ba9ed41d554e7a4f21c82469d1e2a6eeff3bf93", "filename": "libgfortran/generated/count_8_l8.c", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_8_l8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcount_8_l8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcount_8_l8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ count_8_l8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ count_8_l8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {"}, {"sha": "9bbe482dd7147058ad4ac8961843c663b841206c", "filename": "libgfortran/generated/cshift1_16.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcshift1_16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcshift1_16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -55,7 +55,7 @@ cshift1 (gfc_array_char * const restrict ret,\n   index_type soffset;\n   const char *sptr;\n   const char *src;\n-  /* h.* indicates the  array.  */\n+  /* h.* indicates the shift array.  */\n   index_type hstride[GFC_MAX_DIMENSIONS];\n   index_type hstride0;\n   const GFC_INTEGER_16 *hptr;\n@@ -144,7 +144,7 @@ cshift1 (gfc_array_char * const restrict ret,\n \n   while (rptr)\n     {\n-      /* Do the  for this dimension.  */\n+      /* Do the shift for this dimension.  */\n       sh = *hptr;\n       sh = (div (sh, len)).rem;\n       if (sh < 0)"}, {"sha": "f4a357e6220875a28a76e29711596d519b8f154d", "filename": "libgfortran/generated/cshift1_4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcshift1_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcshift1_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -55,7 +55,7 @@ cshift1 (gfc_array_char * const restrict ret,\n   index_type soffset;\n   const char *sptr;\n   const char *src;\n-  /* h.* indicates the  array.  */\n+  /* h.* indicates the shift array.  */\n   index_type hstride[GFC_MAX_DIMENSIONS];\n   index_type hstride0;\n   const GFC_INTEGER_4 *hptr;\n@@ -144,7 +144,7 @@ cshift1 (gfc_array_char * const restrict ret,\n \n   while (rptr)\n     {\n-      /* Do the  for this dimension.  */\n+      /* Do the shift for this dimension.  */\n       sh = *hptr;\n       sh = (div (sh, len)).rem;\n       if (sh < 0)"}, {"sha": "9e9a8a0c696d389e3e2742dd5a56752d3a496761", "filename": "libgfortran/generated/cshift1_8.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcshift1_8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fcshift1_8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift1_8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -55,7 +55,7 @@ cshift1 (gfc_array_char * const restrict ret,\n   index_type soffset;\n   const char *sptr;\n   const char *src;\n-  /* h.* indicates the  array.  */\n+  /* h.* indicates the shift array.  */\n   index_type hstride[GFC_MAX_DIMENSIONS];\n   index_type hstride0;\n   const GFC_INTEGER_8 *hptr;\n@@ -144,7 +144,7 @@ cshift1 (gfc_array_char * const restrict ret,\n \n   while (rptr)\n     {\n-      /* Do the  for this dimension.  */\n+      /* Do the shift for this dimension.  */\n       sh = *hptr;\n       sh = (div (sh, len)).rem;\n       if (sh < 0)"}, {"sha": "c01a006f8eadfdd116cb74d8d3fbe0145c5f74fa", "filename": "libgfortran/generated/maxloc1_16_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "dd0739c5915c51669cb1ebb1ae6a6f8987b0d816", "filename": "libgfortran/generated/maxloc1_16_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "c18a8e5a7915e8458d7429059d92d3bc266cf518", "filename": "libgfortran/generated/maxloc1_16_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "1d4a4cb8609e23d698675d9c64f2e0aca611384a", "filename": "libgfortran/generated/maxloc1_16_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "18e0a5542e6d3341af62eb738c39369d2b3a8e2a", "filename": "libgfortran/generated/maxloc1_16_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "10715a041b619f848d376dde502a57a7b47f464a", "filename": "libgfortran/generated/maxloc1_16_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "a2b6f310ef69190a6369a524fe615f1664714299", "filename": "libgfortran/generated/maxloc1_16_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_16_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "0c8a0cc33c6f20a7a53a39f07ff046d10bf56b44", "filename": "libgfortran/generated/maxloc1_4_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "83131ffd33b565a93287ca96afb7bd9ffdefd727", "filename": "libgfortran/generated/maxloc1_4_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "bb553eb884ebd3ac7945ce34b21b0fbca8bc71e5", "filename": "libgfortran/generated/maxloc1_4_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "0fb88545c0446712fa4f9b3ee88c5747acb8c41b", "filename": "libgfortran/generated/maxloc1_4_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "140731aa615eabef32d0ec962947af90139af64c", "filename": "libgfortran/generated/maxloc1_4_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "1daf4fee9711743cc4fe71da9ec6bfce2a132261", "filename": "libgfortran/generated/maxloc1_4_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "90c169afabb5428daa9dd7458cc5bf321b36da15", "filename": "libgfortran/generated/maxloc1_4_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_4_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "d4bff32de4ead72d09c8bd321f82e151b40134a0", "filename": "libgfortran/generated/maxloc1_8_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "9225f13c7911656ce3092232c832ad5e21ae499e", "filename": "libgfortran/generated/maxloc1_8_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "c0179cd8b7a677ee777e6decf0f1e0d201f0ffc5", "filename": "libgfortran/generated/maxloc1_8_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "9bf455ad8be2ccaca9552c5042c74d9b592d9c31", "filename": "libgfortran/generated/maxloc1_8_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "13f3c189ec0180160bf83f6d9a8d3c7ca038093b", "filename": "libgfortran/generated/maxloc1_8_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "313951b1dd09c94a6f5f17feff30e419b21e2f2b", "filename": "libgfortran/generated/maxloc1_8_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "bc694c7ebe0b59c0993542573646d586b744c762", "filename": "libgfortran/generated/maxloc1_8_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxloc1_8_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ maxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mmaxloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "8bdab56d54d8f964c3fdd4aeb32174866d284bbe", "filename": "libgfortran/generated/maxval_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "ba5b31068417969020f4a4b590298044d4d3f82a", "filename": "libgfortran/generated/maxval_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "ee6a5d2d87c48e23f6837ddf2afd4f004932522c", "filename": "libgfortran/generated/maxval_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "2dcfbef5add83da9c03aeb994956328844485574", "filename": "libgfortran/generated/maxval_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "bc456f9045db44cf11c3f0c5e725ed0c80abcb5e", "filename": "libgfortran/generated/maxval_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "89c944def99068072ec855ada7843d51bb0c8721", "filename": "libgfortran/generated/maxval_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "b53d7deaac6d2ff2890d23fa292abd51554bdb61", "filename": "libgfortran/generated/maxval_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fmaxval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fmaxval_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ maxval_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mmaxval_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "ebbecec7c112150bd1e962882205ba016b022a5e", "filename": "libgfortran/generated/minloc1_16_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "9b12ab48a8935d05de71af66c8e2dd688bd1c1b2", "filename": "libgfortran/generated/minloc1_16_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_i4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "a0e447f44eacec401458f93e46af2753ae883fea", "filename": "libgfortran/generated/minloc1_16_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_i8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "9cbc80cb53d0c670fc649f550104df10ba4ae2d6", "filename": "libgfortran/generated/minloc1_16_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_r10 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "e3efc0db8ae8bcb71f929d7c608fa50ee3446557", "filename": "libgfortran/generated/minloc1_16_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_r16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "6fb0ef49414f2f25bed905caf16cf14362f5ba72", "filename": "libgfortran/generated/minloc1_16_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_r4 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "0b0e7b98d4c222e0f1be690c40466864e4dea37f", "filename": "libgfortran/generated/minloc1_16_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_16_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_16_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_16_r8 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "e72c8e4f60b0405809412ac46aa6e0874c45c6b7", "filename": "libgfortran/generated/minloc1_4_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_i16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "64e80a30b14596b4aa0012e50daf3ccf8e977124", "filename": "libgfortran/generated/minloc1_4_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "408e8328a462c27081da6af827b3764ede15c41e", "filename": "libgfortran/generated/minloc1_4_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_i8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "64ea02e0602863da2efb4e6565feb4e1e1a11b8c", "filename": "libgfortran/generated/minloc1_4_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_r10 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "34ce250e170595e19113eb9e226abb66fd30e240", "filename": "libgfortran/generated/minloc1_4_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_r16 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "1e22a50aca3b83fe1c990838a70a67bf4543a84f", "filename": "libgfortran/generated/minloc1_4_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_r4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "c46393cff3b464ee12d06612215527c797bdd115", "filename": "libgfortran/generated/minloc1_4_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_4_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_4_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_4_r8 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "d4392f6cc318cd58ad4270b6a859a3c84db87e97", "filename": "libgfortran/generated/minloc1_8_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_i16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "f47b5f7b598c3114316b02250f68d1399465cb51", "filename": "libgfortran/generated/minloc1_8_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_i4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "8de5f03e3d40e431bdecb0c16156889233328c79", "filename": "libgfortran/generated/minloc1_8_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "5285cc22b39a8407a318551183d1a155445cb3ad", "filename": "libgfortran/generated/minloc1_8_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_r10 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "30753ce24f4298f2421c88eeb7098f382bf2be0a", "filename": "libgfortran/generated/minloc1_8_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_r16 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "069e0496f72986e3bd78159a4b32aff1f8320f57", "filename": "libgfortran/generated/minloc1_8_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_r4 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "260898c7a6ebd92871b36537750ba0877998182c", "filename": "libgfortran/generated/minloc1_8_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminloc1_8_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminloc1_8_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -71,16 +71,24 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -91,12 +99,21 @@ minloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -213,17 +230,26 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -234,12 +260,22 @@ mminloc1_8_r8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "cc1066bc82ca6f8ff6c8bab79ba753a2fe1180ee", "filename": "libgfortran/generated/minval_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "9bea78aa57c44eaccb3933956146a6ec4bdd93b3", "filename": "libgfortran/generated/minval_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "023e9e8269eb562f1d445da68435151406aaa3ac", "filename": "libgfortran/generated/minval_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "3a8a5c089ae0cd1a180c87772c457432685be838", "filename": "libgfortran/generated/minval_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "82df48c22e4eaf4ad066298790d208e8ba1d218f", "filename": "libgfortran/generated/minval_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "950449bab9d2e5c2c3367793e25c0d6616825d0c", "filename": "libgfortran/generated/minval_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "ec814815e969eec882ab9d27dd86d25ccea26421", "filename": "libgfortran/generated/minval_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fminval_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fminval_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -70,16 +70,24 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -90,12 +98,21 @@ minval_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -207,17 +224,26 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -228,12 +254,22 @@ mminval_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "0d73a9b799cb23b476fcaedbc0b4fdf3600c7a49", "filename": "libgfortran/generated/product_c10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_c10 (gfc_array_c10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_c10 (gfc_array_c10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "a5c8bd07e741a231a5ea3d0b0e5fbd8a4bc939fb", "filename": "libgfortran/generated/product_c16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_c16 (gfc_array_c16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_c16 (gfc_array_c16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "45a62c9cfb9a14b1e7d6096d969d813372efd428", "filename": "libgfortran/generated/product_c4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_c4 (gfc_array_c4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_c4 (gfc_array_c4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "69bcb87c39971dc2c9e71f33fc37935e32828ae3", "filename": "libgfortran/generated/product_c8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_c8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_c8 (gfc_array_c8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_c8 (gfc_array_c8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "7b73578309406a6c3a37255494e8e45442060f7f", "filename": "libgfortran/generated/product_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "72d0e1afbad1ff9afd1304efa75feff4907794e9", "filename": "libgfortran/generated/product_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "d1ae82e4303188aeae8cf6a0af4d8713e8f00ebf", "filename": "libgfortran/generated/product_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "f19b67ba949106ba7bb033f17367cefc21447147", "filename": "libgfortran/generated/product_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "3d0a76a4ade29cacca3d6ce3a814d4c65139052a", "filename": "libgfortran/generated/product_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "069b0d0c0e790b60b3f6f48a99e9dd3e47511ab1", "filename": "libgfortran/generated/product_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "e9cfae39782ee60ac7eb8bfee706c7d26a0d34a5", "filename": "libgfortran/generated/product_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fproduct_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fproduct_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ product_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ mproduct_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "96b878b7fcd03f9ddb8108ad086d4870478e6918", "filename": "libgfortran/generated/sum_c10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_c10 (gfc_array_c10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_c10 (gfc_array_c10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "a99d4f65b62fb3d8bf6fde4032a2dfa1ce057393", "filename": "libgfortran/generated/sum_c16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_c16 (gfc_array_c16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_c16 (gfc_array_c16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "83979fbdf217f5af1af81e97071223208335cce5", "filename": "libgfortran/generated/sum_c4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_c4 (gfc_array_c4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_c4 (gfc_array_c4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "d82092a1b6b35be7c63121cd03182e80cd9570ed", "filename": "libgfortran/generated/sum_c8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_c8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_c8 (gfc_array_c8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_COMPLEX_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_c8 (gfc_array_c8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_COMPLEX_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_COMPLEX_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "83857734a006e8ce77452571c8b5826f171f5de6", "filename": "libgfortran/generated/sum_i16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_i16 (gfc_array_i16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "e97d15c62bac51040ca63cc120a511a33cd43131", "filename": "libgfortran/generated/sum_i4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_i4 (gfc_array_i4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "da913442b4f6090227ef3d9c3e40a5d3422214c6", "filename": "libgfortran/generated/sum_i8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_i8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_i8 (gfc_array_i8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_INTEGER_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_INTEGER_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "0433c90f90bbd4995cf9cf6c1c330f506339acdd", "filename": "libgfortran/generated/sum_r10.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r10.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_r10 (gfc_array_r10 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_10)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_10) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "2c9fdf5b2218b3a5d0f7ca55ee83913cbbb5042a", "filename": "libgfortran/generated/sum_r16.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r16.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_r16 (gfc_array_r16 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_16)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_16) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "e3c33fbf1d4fa301f28e82ea4c9ccbe159a03ee1", "filename": "libgfortran/generated/sum_r4.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r4.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_r4 (gfc_array_r4 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_4)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_4) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "4d331e277a75f88aa612b962b465bb6e74e7d2ca", "filename": "libgfortran/generated/sum_r8.c", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fgenerated%2Fsum_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fsum_r8.c?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -69,16 +69,24 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -89,12 +97,21 @@ sum_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -205,17 +222,26 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -226,12 +252,22 @@ msum_r8 (gfc_array_r8 * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (GFC_REAL_8)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (GFC_REAL_8) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}, {"sha": "225b89a7562b6aa15ecde85e114e9a1e5e25d4fb", "filename": "libgfortran/m4/ifunction.m4", "status": "modified", "additions": 44, "deletions": 8, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fm4%2Fifunction.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ee04b982ff7293ba749ec96b9a075f9c714900/libgfortran%2Fm4%2Fifunction.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fifunction.m4?ref=80ee04b982ff7293ba749ec96b9a075f9c714900", "patch": "@@ -51,16 +51,24 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n     {\n       sstride[n] = array->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -71,12 +79,21 @@ name`'rtype_qual`_'atype_code (rtype * const restrict retarray,\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (rtype_name)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      alloc_size = sizeof (rtype_name) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n     }\n   else\n     {\n@@ -187,17 +204,26 @@ void\n       sstride[n] = array->dim[n].stride;\n       mstride[n] = mask->dim[n].stride;\n       extent[n] = array->dim[n].ubound + 1 - array->dim[n].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n+\n     }\n   for (n = dim; n < rank; n++)\n     {\n       sstride[n] = array->dim[n + 1].stride;\n       mstride[n] = mask->dim[n + 1].stride;\n       extent[n] =\n         array->dim[n + 1].ubound + 1 - array->dim[n + 1].lbound;\n+\n+      if (extent[n] < 0)\n+\textent[n] = 0;\n     }\n \n   if (retarray->data == NULL)\n     {\n+      size_t alloc_size;\n+\n       for (n = 0; n < rank; n++)\n         {\n           retarray->dim[n].lbound = 0;\n@@ -208,12 +234,22 @@ void\n             retarray->dim[n].stride = retarray->dim[n-1].stride * extent[n-1];\n         }\n \n-      retarray->data\n-\t = internal_malloc_size (sizeof (rtype_name)\n-\t\t \t\t * retarray->dim[rank-1].stride\n-\t\t\t\t * extent[rank-1]);\n+      alloc_size = sizeof (rtype_name) * retarray->dim[rank-1].stride\n+    \t\t   * extent[rank-1];\n+\n       retarray->offset = 0;\n       retarray->dtype = (array->dtype & ~GFC_DTYPE_RANK_MASK) | rank;\n+\n+      if (alloc_size == 0)\n+\t{\n+\t  /* Make sure we have a zero-sized array.  */\n+\t  retarray->dim[0].lbound = 0;\n+\t  retarray->dim[0].ubound = -1;\n+\t  return;\n+\t}\n+      else\n+\tretarray->data = internal_malloc_size (alloc_size);\n+\n     }\n   else\n     {"}]}