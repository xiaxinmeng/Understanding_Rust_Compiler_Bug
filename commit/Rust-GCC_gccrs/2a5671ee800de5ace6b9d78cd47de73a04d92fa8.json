{"sha": "2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE1NjcxZWU4MDBkZTVhY2U2YjlkNzhjZDQ3ZGU3M2EwNGQ5MmZhOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-03-13T08:47:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-03-13T08:47:14Z"}, "message": "re PR ipa/44563 (GCC uses a lot of RAM when compiling a large numbers of functions)\n\n2015-03-10  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/44563\n\t* tree-cfgcleanup.c (split_bb_on_noreturn_calls): Remove.\n\t(cleanup_tree_cfg_1): Do not call it.\n\t(execute_cleanup_cfg_post_optimizing): Fixup the CFG here.\n\t(fixup_noreturn_call): Mark the stmt as control altering.\n\t* tree-cfg.c (execute_fixup_cfg): Do not dump the function\n\there.\n\t(pass_data_fixup_cfg): Produce a dump file.\n\t* tree-ssa-dom.c: Include tree-cfgcleanup.h.\n\t(need_noreturn_fixup): New global.\n\t(pass_dominator::execute): Fixup queued noreturn calls.\n\t(optimize_stmt): Queue calls that became noreturn for fixup.\n\t* tree-ssa-forwprop.c (pass_forwprop::execute): Likewise.\n\t* tree-ssa-pre.c: Include tree-cfgcleanup.h.\n\t(el_to_fixup): New global.\n\t(eliminate_dom_walker::before_dom_childre): Queue calls that\n\tbecame noreturn for fixup.\n\t(eliminate): Fixup queued noreturn calls.\n\t* tree-ssa-propagate.c: Include tree-cfgcleanup.h.\n\t(substitute_and_fold_dom_walker): New member stmts_to_fixup.\n\t(substitute_and_fold_dom_walker::before_dom_children): Queue\n\talls that became noreturn for fixup.\n\t(substitute_and_fold): Fixup queued noreturn calls.\n\nFrom-SVN: r221409", "tree": {"sha": "b652e843afc3a6d9186d29d95bbeae5f778cee40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b652e843afc3a6d9186d29d95bbeae5f778cee40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10ac6596183f0ffa298688791bac6a232f351214", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10ac6596183f0ffa298688791bac6a232f351214", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10ac6596183f0ffa298688791bac6a232f351214"}], "stats": {"total": 182, "additions": 138, "deletions": 44}, "files": [{"sha": "18ada578fd6fd337756aeb3472c857b9625729f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -1,3 +1,29 @@\n+2015-03-13  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/44563\n+\t* tree-cfgcleanup.c (split_bb_on_noreturn_calls): Remove.\n+\t(cleanup_tree_cfg_1): Do not call it.\n+\t(execute_cleanup_cfg_post_optimizing): Fixup the CFG here.\n+\t(fixup_noreturn_call): Mark the stmt as control altering.\n+\t* tree-cfg.c (execute_fixup_cfg): Do not dump the function\n+\there.\n+\t(pass_data_fixup_cfg): Produce a dump file.\n+\t* tree-ssa-dom.c: Include tree-cfgcleanup.h.\n+\t(need_noreturn_fixup): New global.\n+\t(pass_dominator::execute): Fixup queued noreturn calls.\n+\t(optimize_stmt): Queue calls that became noreturn for fixup.\n+\t* tree-ssa-forwprop.c (pass_forwprop::execute): Likewise.\n+\t* tree-ssa-pre.c: Include tree-cfgcleanup.h.\n+\t(el_to_fixup): New global.\n+\t(eliminate_dom_walker::before_dom_childre): Queue calls that\n+\tbecame noreturn for fixup.\n+\t(eliminate): Fixup queued noreturn calls.\n+\t* tree-ssa-propagate.c: Include tree-cfgcleanup.h.\n+\t(substitute_and_fold_dom_walker): New member stmts_to_fixup.\n+\t(substitute_and_fold_dom_walker::before_dom_children): Queue\n+\talls that became noreturn for fixup.\n+\t(substitute_and_fold): Fixup queued noreturn calls.\n+\n 2015-03-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-icf.c (sem_function::equals_wpa): Match CXX_CONSTRUCTOR_P"}, {"sha": "ac12a585c5174ec3ed061bb03664b6578b6a119a", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -8721,10 +8721,6 @@ execute_fixup_cfg (void)\n   if (count_scale != REG_BR_PROB_BASE)\n     compute_function_frequency ();\n \n-  /* Dump a textual representation of the flowgraph.  */\n-  if (dump_file)\n-    gimple_dump_cfg (dump_file, dump_flags);\n-\n   if (current_loops\n       && (todo & TODO_cleanup_cfg))\n     loops_state_set (LOOPS_NEED_FIXUP);\n@@ -8737,7 +8733,7 @@ namespace {\n const pass_data pass_data_fixup_cfg =\n {\n   GIMPLE_PASS, /* type */\n-  \"*free_cfg_annotations\", /* name */\n+  \"fixup_cfg\", /* name */\n   OPTGROUP_NONE, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_cfg, /* properties_required */"}, {"sha": "f5a21a30f85c0975c7bdcded3e12523fb4e38587", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 9, "deletions": 35, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -625,35 +625,13 @@ fixup_noreturn_call (gimple stmt)\n       update_stmt (stmt);\n     }\n \n+  /* Mark the call as altering control flow.  */\n+  gimple_call_set_ctrl_altering (stmt, true);\n+\n   return remove_fallthru_edge (bb->succs);\n }\n \n \n-/* Split basic blocks on calls in the middle of a basic block that are now\n-   known not to return, and remove the unreachable code.  */\n-\n-static bool\n-split_bb_on_noreturn_calls (basic_block bb)\n-{\n-  bool changed = false;\n-  gimple_stmt_iterator gsi;\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-\n-      if (!is_gimple_call (stmt))\n-\tcontinue;\n-\n-      if (gimple_call_noreturn_p (stmt))\n-\tchanged |= fixup_noreturn_call (stmt);\n-    }\n-\n-  if (changed)\n-    bitmap_set_bit (cfgcleanup_altered_bbs, bb->index);\n-  return changed;\n-}\n-\n /* Tries to cleanup cfg in basic block BB.  Returns true if anything\n    changes.  */\n \n@@ -703,10 +681,7 @@ cleanup_tree_cfg_1 (void)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, i);\n       if (bb)\n-\t{\n-\t  retval |= cleanup_tree_cfg_bb (bb);\n-\t  retval |= split_bb_on_noreturn_calls (bb);\n-\t}\n+\tretval |= cleanup_tree_cfg_bb (bb);\n     }\n \n   /* Now process the altered blocks, as long as any are available.  */\n@@ -722,10 +697,6 @@ cleanup_tree_cfg_1 (void)\n \tcontinue;\n \n       retval |= cleanup_tree_cfg_bb (bb);\n-\n-      /* Rerun split_bb_on_noreturn_calls, in case we have altered any noreturn\n-\t calls.  */\n-      retval |= split_bb_on_noreturn_calls (bb);\n     }\n \n   end_recording_case_labels ();\n@@ -1111,9 +1082,12 @@ make_pass_merge_phi (gcc::context *ctxt)\n static unsigned int\n execute_cleanup_cfg_post_optimizing (void)\n {\n-  unsigned int todo = 0;\n+  unsigned int todo = execute_fixup_cfg ();\n   if (cleanup_tree_cfg ())\n-    todo |= TODO_update_ssa;\n+    {\n+      todo &= ~TODO_cleanup_cfg;\n+      todo |= TODO_update_ssa;\n+    }\n   maybe_remove_unreachable_handlers ();\n   cleanup_dead_labels ();\n   group_case_labels ();"}, {"sha": "ea49eb7c3c79a6cf9a4083c78758d71b77c29c6a", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -74,6 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-dom.h\"\n #include \"inchash.h\"\n #include \"gimplify.h\"\n+#include \"tree-cfgcleanup.h\"\n \n /* This file implements optimizations on the dominator tree.  */\n \n@@ -246,6 +247,7 @@ static bool cfg_altered;\n /* Bitmap of blocks that have had EH statements cleaned.  We should\n    remove their dead edges eventually.  */\n static bitmap need_eh_cleanup;\n+static vec<gimple> need_noreturn_fixup;\n \n /* Statistics for dominator optimizations.  */\n struct opt_stats_d\n@@ -885,6 +887,7 @@ pass_dominator::execute (function *fun)\n   avail_exprs_stack.create (20);\n   const_and_copies_stack.create (20);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n+  need_noreturn_fixup.create (0);\n \n   calculate_dominance_info (CDI_DOMINATORS);\n   cfg_altered = false;\n@@ -967,6 +970,23 @@ pass_dominator::execute (function *fun)\n       bitmap_clear (need_eh_cleanup);\n     }\n \n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the dominator walk or before\n+     jump threading finished.  Do this in reverse order so we don't\n+     inadvertedly remove a stmt we want to fixup by visiting a dominating\n+     now noreturn call first.  */\n+  while (!need_noreturn_fixup.is_empty ())\n+    {\n+      gimple stmt = need_noreturn_fixup.pop ();\n+      if (dump_file && dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"Fixing up noreturn call \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      fixup_noreturn_call (stmt);\n+    }\n+\n   statistics_counter_event (fun, \"Redundant expressions eliminated\",\n \t\t\t    opt_stats.num_re);\n   statistics_counter_event (fun, \"Constants propagated\",\n@@ -986,7 +1006,7 @@ pass_dominator::execute (function *fun)\n \n   /* Free asserted bitmaps and stacks.  */\n   BITMAP_FREE (need_eh_cleanup);\n-\n+  need_noreturn_fixup.release ();\n   avail_exprs_stack.release ();\n   const_and_copies_stack.release ();\n \n@@ -2364,8 +2384,10 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n   gimple stmt, old_stmt;\n   bool may_optimize_p;\n   bool modified_p = false;\n+  bool was_noreturn;\n \n   old_stmt = stmt = gsi_stmt (si);\n+  was_noreturn = is_gimple_call (stmt) && gimple_call_noreturn_p (stmt);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -2545,6 +2567,10 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"  Flagged to clear EH edges.\\n\");\n \t}\n+\n+      if (!was_noreturn\n+\t  && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n+\tneed_noreturn_fixup.safe_push (stmt);\n     }\n }\n "}, {"sha": "93f92f33a59a92b3ef71f944f9749bdbba4d12ef", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -2141,6 +2141,7 @@ pass_forwprop::execute (function *fun)\n   lattice.quick_grow_cleared (num_ssa_names);\n   int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (fun));\n   int postorder_num = inverted_post_order_compute (postorder);\n+  auto_vec<gimple, 4> to_fixup;\n   to_purge = BITMAP_ALLOC (NULL);\n   for (int i = 0; i < postorder_num; ++i)\n     {\n@@ -2340,6 +2341,8 @@ pass_forwprop::execute (function *fun)\n \t  gimple stmt = gsi_stmt (gsi);\n \t  gimple orig_stmt = stmt;\n \t  bool changed = false;\n+\t  bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t       && gimple_call_noreturn_p (stmt));\n \n \t  /* Mark stmt as potentially needing revisiting.  */\n \t  gimple_set_plf (stmt, GF_PLF_1, false);\n@@ -2350,6 +2353,9 @@ pass_forwprop::execute (function *fun)\n \t      stmt = gsi_stmt (gsi);\n \t      if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))\n \t\tbitmap_set_bit (to_purge, bb->index);\n+\t      if (!was_noreturn\n+\t\t  && is_gimple_call (stmt) && gimple_call_noreturn_p (stmt))\n+\t\tto_fixup.safe_push (stmt);\n \t      /* Cleanup the CFG if we simplified a condition to\n \t         true or false.  */\n \t      if (gcond *cond = dyn_cast <gcond *> (stmt))\n@@ -2470,6 +2476,22 @@ pass_forwprop::execute (function *fun)\n   free (postorder);\n   lattice.release ();\n \n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the walk.  Do this\n+     in reverse order so we don't inadvertedly remove a stmt we want to\n+     fixup by visiting a dominating now noreturn call first.  */\n+  while (!to_fixup.is_empty ())\n+    {\n+      gimple stmt = to_fixup.pop ();\n+      if (dump_file && dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"Fixing up noreturn call \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      cfg_changed |= fixup_noreturn_call (stmt);\n+    }\n+\n   cfg_changed |= gimple_purge_all_dead_eh_edges (to_purge);\n   BITMAP_FREE (to_purge);\n "}, {"sha": "c985e798696bd5271db6a2e49ee6f5b2b88337fb", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -98,6 +98,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"tree-ssa-propagate.h\"\n #include \"ipa-utils.h\"\n+#include \"tree-cfgcleanup.h\"\n \n /* TODO:\n \n@@ -3922,6 +3923,7 @@ compute_avail (void)\n \n /* Local state for the eliminate domwalk.  */\n static vec<gimple> el_to_remove;\n+static vec<gimple> el_to_fixup;\n static unsigned int el_todo;\n static vec<tree> el_avail;\n static vec<tree> el_avail_stack;\n@@ -4429,7 +4431,7 @@ eliminate_dom_walker::before_dom_children (basic_block b)\n \t      /* When changing a call into a noreturn call, cfg cleanup\n \t\t is needed to fix up the noreturn call.  */\n \t      if (!was_noreturn && gimple_call_noreturn_p (stmt))\n-\t\tel_todo |= TODO_cleanup_cfg;\n+\t\tel_to_fixup.safe_push  (stmt);\n \t    }\n \t  else\n \t    {\n@@ -4529,6 +4531,7 @@ eliminate (bool do_pre)\n   need_ab_cleanup = BITMAP_ALLOC (NULL);\n \n   el_to_remove.create (0);\n+  el_to_fixup.create (0);\n   el_todo = 0;\n   el_avail.create (num_ssa_names);\n   el_avail_stack.create (0);\n@@ -4580,6 +4583,25 @@ eliminate (bool do_pre)\n     }\n   el_to_remove.release ();\n \n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the dominator walk.  Do this\n+     in reverse order so we don't inadvertedly remove a stmt we want to\n+     fixup by visiting a dominating now noreturn call first.  */\n+  while (!el_to_fixup.is_empty ())\n+    {\n+      stmt = el_to_fixup.pop ();\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Fixing up noreturn call \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t}\n+\n+      if (fixup_noreturn_call (stmt))\n+\tel_todo |= TODO_cleanup_cfg;\n+    }\n+  el_to_fixup.release ();\n+\n   return el_todo;\n }\n "}, {"sha": "c3f9d3e1cdaa32afd7c7dc6918dbbee748e506ba", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a5671ee800de5ace6b9d78cd47de73a04d92fa8/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=2a5671ee800de5ace6b9d78cd47de73a04d92fa8", "patch": "@@ -67,6 +67,7 @@\n #include \"value-prof.h\"\n #include \"domwalk.h\"\n #include \"cfgloop.h\"\n+#include \"tree-cfgcleanup.h\"\n \n /* This file implements a generic value propagation engine based on\n    the same propagation used by the SSA-CCP algorithm [1].\n@@ -1071,11 +1072,13 @@ class substitute_and_fold_dom_walker : public dom_walker\n       fold_fn (fold_fn_), do_dce (do_dce_), something_changed (false)\n     {\n       stmts_to_remove.create (0);\n+      stmts_to_fixup.create (0);\n       need_eh_cleanup = BITMAP_ALLOC (NULL);\n     }\n     ~substitute_and_fold_dom_walker ()\n     {\n       stmts_to_remove.release ();\n+      stmts_to_fixup.release ();\n       BITMAP_FREE (need_eh_cleanup);\n     }\n \n@@ -1087,6 +1090,7 @@ class substitute_and_fold_dom_walker : public dom_walker\n     bool do_dce;\n     bool something_changed;\n     vec<gimple> stmts_to_remove;\n+    vec<gimple> stmts_to_fixup;\n     bitmap need_eh_cleanup;\n };\n \n@@ -1125,7 +1129,6 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n     {\n       bool did_replace;\n       gimple stmt = gsi_stmt (i);\n-      gimple old_stmt;\n       enum gimple_code code = gimple_code (stmt);\n \n       /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n@@ -1163,7 +1166,9 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t  print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n \t}\n \n-      old_stmt = stmt;\n+      gimple old_stmt = stmt;\n+      bool was_noreturn = (is_gimple_call (stmt)\n+\t\t\t   && gimple_call_noreturn_p (stmt));\n \n       /* Some statements may be simplified using propagator\n \t specific information.  Do this before propagating\n@@ -1194,6 +1199,13 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t  if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))\n \t    bitmap_set_bit (need_eh_cleanup, bb->index);\n \n+\t  /* If we turned a not noreturn call into a noreturn one\n+\t     schedule it for fixup.  */\n+\t  if (!was_noreturn\n+\t      && is_gimple_call (stmt)\n+\t      && gimple_call_noreturn_p (stmt))\n+\t    stmts_to_fixup.safe_push (stmt);\n+\n \t  if (is_gimple_assign (stmt)\n \t      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n \t\t  == GIMPLE_SINGLE_RHS))\n@@ -1286,6 +1298,22 @@ substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n   if (!bitmap_empty_p (walker.need_eh_cleanup))\n     gimple_purge_all_dead_eh_edges (walker.need_eh_cleanup);\n \n+  /* Fixup stmts that became noreturn calls.  This may require splitting\n+     blocks and thus isn't possible during the dominator walk.  Do this\n+     in reverse order so we don't inadvertedly remove a stmt we want to\n+     fixup by visiting a dominating now noreturn call first.  */\n+  while (!walker.stmts_to_fixup.is_empty ())\n+    {\n+      gimple stmt = walker.stmts_to_fixup.pop ();\n+      if (dump_file && dump_flags & TDF_DETAILS)\n+\t{\n+\t  fprintf (dump_file, \"Fixing up noreturn call \");\n+\t  print_gimple_stmt (dump_file, stmt, 0, 0);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      fixup_noreturn_call (stmt);\n+    }\n+\n   statistics_counter_event (cfun, \"Constants propagated\",\n \t\t\t    prop_stats.num_const_prop);\n   statistics_counter_event (cfun, \"Copies propagated\","}]}