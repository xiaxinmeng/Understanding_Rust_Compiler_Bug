{"sha": "1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE3NjkxNmM3OGM5ODVmMTYyMmRiMWIzMWQ0ZjA1ZTE4YzhhZTllNA==", "commit": {"author": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-11T05:36:17Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-06-11T05:36:17Z"}, "message": "Makefile.in: Update cppmain.o.\n\n\t* Makefile.in: Update cppmain.o.\n\t* cpphash.h (struct cpp_reader): Move some members to a\n\tnested structure.\n\t(trad_line): Rename saved_line.\n\t(_cpp_read_logical_line_trad): Update.\n\t(_cpp_remove_overlay): New.\n\t* cppinit.c (cpp_create_reader): No need to set saved_line.\n\t(cpp_destroy): Update.\n\t(cpp_read_main_file): Only overlay if compiling.\n\t* cpplex.c (continue_after_nul): Return false if in directive.\n\t* cpplib.c (EXPAND): New.\n\t(directive_table, SEEN_EOL): Update.\n\t(end_directive): Remove overlay if traditional; don't skip\n\tline in traditional #define.\n\t(prepare_directive_trad): New.\n\t(_cpp_handle_directive, run_directive): Update for traditional\n\tdirectives.\n\t(lex_macro_node): Simplify, don't use lex_identifier_trad.\n\t* cpplib.h (struct options): Add preprocess_only.\n\t* cppmain.c: Don't include intl.h.\n\t(cpp_preprocess_file): Set options->preprocess_only.\n\t(scan_translation_unit_trad): Fix, and print line numbers.\n\t* cpptrad.c (check_output_buffer, lex_identifier, scan_parameters,\n\tmaybe_start_funlike, scan_out_logical_line, replace_args_and_push,\n\tsave_replacement_text, _cpp_create_trad_definition): Update for\n\tvariable renaming.\n\t(_cpp_overlay_buffer): Save line number.\n\t(_cpp_remove_overlay): Rename from restore_buff, restore line.\n\t(_cpp_read_logical_line_trad): Don't handle overlays here.\n\t(scan_out_logical_line): Process directives.\n\nFrom-SVN: r54485", "tree": {"sha": "d6fe32dd73c2bbc61df005aeef06e301cea3ff11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6fe32dd73c2bbc61df005aeef06e301cea3ff11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/comments", "author": null, "committer": null, "parents": [{"sha": "b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25bb36a36ac5d73a46f9a910c20ecae5e40dc2f"}], "stats": {"total": 288, "additions": 174, "deletions": 114}, "files": [{"sha": "b3b998bf8c6d85912dabefb9bf818eaf287b1cdd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -2084,7 +2084,7 @@ libcpp.a: $(LIBCPP_OBJS)\n \t$(AR) $(AR_FLAGS) libcpp.a $(LIBCPP_OBJS)\n \t-$(RANLIB) libcpp.a\n \n-cppmain.o:  cppmain.c  $(CONFIG_H) $(CPPLIB_H) intl.h $(SYSTEM_H)\n+cppmain.o:  cppmain.c  $(CONFIG_H) $(LIBCPP_DEPS)\n \n cpperror.o: cpperror.c $(CONFIG_H) $(LIBCPP_DEPS)\n cppexp.o:   cppexp.c   $(CONFIG_H) $(LIBCPP_DEPS)"}, {"sha": "ae6a4f2301da0f1568f93362cfae0b5b7bc0430e", "filename": "gcc/cpphash.h", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -406,10 +406,18 @@ struct cpp_reader\n   /* Whether cpplib owns the hashtable.  */\n   unsigned char our_hashtable;\n \n-  /* Traditional preprocessing output buffer.  */\n-  uchar *trad_out_base, *trad_out_limit;\n-  uchar *trad_out_cur;\n-  unsigned int trad_line;\n+  /* Traditional preprocessing output buffer (a logical line).  */\n+  struct\n+  {\n+    uchar *base;\n+    uchar *limit;\n+    uchar *cur;\n+    unsigned int first_line;\n+  } out;\n+\n+  /* Used to save the original line number during traditional\n+     preprocessing.  */\n+  unsigned int saved_line;\n };\n \n /* Character classes.  Based on the more primitive macros in safe-ctype.h.\n@@ -510,9 +518,10 @@ extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n \n /* In cpptrad.c.  */\n-extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *, int));\n+extern bool _cpp_read_logical_line_trad PARAMS ((cpp_reader *));\n extern void _cpp_overlay_buffer PARAMS ((cpp_reader *pfile, const uchar *,\n \t\t\t\t\t size_t));\n+extern void _cpp_remove_overlay PARAMS ((cpp_reader *));\n extern cpp_hashnode *_cpp_lex_identifier_trad PARAMS ((cpp_reader *));\n extern void _cpp_set_trad_context PARAMS ((cpp_reader *));\n extern bool _cpp_create_trad_definition PARAMS ((cpp_reader *, cpp_macro *));"}, {"sha": "411dbea1d138573d19f8d07201613ad320df4cde", "filename": "gcc/cppinit.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -506,7 +506,7 @@ cpp_create_reader (lang)\n   /* Initialise the line map.  Start at logical line 1, so we can use\n      a line number of zero for special states.  */\n   init_line_maps (&pfile->line_maps);\n-  pfile->trad_line = pfile->line = 1;\n+  pfile->line = 1;\n \n   /* Initialize lexer state.  */\n   pfile->state.save_comments = ! CPP_OPTION (pfile, discard_comments);\n@@ -561,8 +561,8 @@ cpp_destroy (pfile)\n   while (CPP_BUFFER (pfile) != NULL)\n     _cpp_pop_buffer (pfile);\n \n-  if (pfile->trad_out_base)\n-    free (pfile->trad_out_base);\n+  if (pfile->out.base)\n+    free (pfile->out.base);\n \n   if (pfile->macro_buffer)\n     {\n@@ -941,7 +941,8 @@ cpp_read_main_file (pfile, fname, table)\n   if (CPP_OPTION (pfile, preprocessed))\n     read_original_filename (pfile);\n   /* Overlay an empty buffer to seed traditional preprocessing.  */\n-  else if (CPP_OPTION (pfile, traditional))\n+  else if (CPP_OPTION (pfile, traditional)\n+\t   && !CPP_OPTION (pfile, preprocess_only))\n     _cpp_overlay_buffer (pfile, U\"\", 0);\n \n   return pfile->map->to_file;"}, {"sha": "44fbe2c738ed6dcc711a67868acda544de9fa7f0", "filename": "gcc/cpplex.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -891,7 +891,16 @@ continue_after_nul (pfile)\n \n   buffer->saved_flags = BOL;\n   if (CPP_OPTION (pfile, traditional))\n-    more = _cpp_read_logical_line_trad (pfile, true);\n+    {\n+      if (pfile->state.in_directive)\n+\treturn false;\n+\n+      _cpp_remove_overlay (pfile);\n+      more = _cpp_read_logical_line_trad (pfile);\n+      _cpp_overlay_buffer (pfile, pfile->out.base,\n+\t\t\t   pfile->out.cur - pfile->out.base);\n+      pfile->line = pfile->out.first_line;\n+    }\n   else\n     {\n       /* Stop parsing arguments with a CPP_EOF.  When we finally come"}, {"sha": "73e12b7d8d50f3c0033da7b0212a09030f4d6806", "filename": "gcc/cpplib.c", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -70,11 +70,16 @@ struct pragma_entry\n    conditional; IF_COND an opening conditional.  INCL means to treat\n    \"...\" and <...> as q-char and h-char sequences respectively.  IN_I\n    means this directive should be handled even if -fpreprocessed is in\n-   effect (these are the directives with callback hooks).  */\n+   effect (these are the directives with callback hooks).\n+\n+   EXPAND is set on directives that are always macro-expanded.  If\n+   INCL is set, macro expansion is special-cased and EXPAND should not\n+   be set.  */\n #define COND\t\t(1 << 0)\n #define IF_COND\t\t(1 << 1)\n #define INCL\t\t(1 << 2)\n #define IN_I\t\t(1 << 3)\n+#define EXPAND\t\t(1 << 4)\n \n /* Defines one #-directive, including how to handle it.  */\n typedef void (*directive_handler) PARAMS ((cpp_reader *));\n@@ -93,6 +98,7 @@ struct directive\n static void skip_rest_of_line\tPARAMS ((cpp_reader *));\n static void check_eol\t\tPARAMS ((cpp_reader *));\n static void start_directive\tPARAMS ((cpp_reader *));\n+static void prepare_directive_trad PARAMS ((cpp_reader *));\n static void end_directive\tPARAMS ((cpp_reader *, int));\n static void directive_diagnostics\n \tPARAMS ((cpp_reader *, const directive *, int));\n@@ -144,12 +150,12 @@ D(define,\tT_DEFINE = 0,\tKANDR,     IN_I)\t   /* 270554 */ \\\n D(include,\tT_INCLUDE,\tKANDR,     INCL)\t   /*  52262 */ \\\n D(endif,\tT_ENDIF,\tKANDR,     COND)\t   /*  45855 */ \\\n D(ifdef,\tT_IFDEF,\tKANDR,     COND | IF_COND) /*  22000 */ \\\n-D(if,\t\tT_IF,\t\tKANDR,     COND | IF_COND) /*  18162 */ \\\n+D(if,\t\tT_IF,\t\tKANDR, COND | IF_COND | EXPAND) /*  18162 */ \\\n D(else,\t\tT_ELSE,\t\tKANDR,     COND)\t   /*   9863 */ \\\n D(ifndef,\tT_IFNDEF,\tKANDR,     COND | IF_COND) /*   9675 */ \\\n D(undef,\tT_UNDEF,\tKANDR,     IN_I)\t   /*   4837 */ \\\n-D(line,\t\tT_LINE,\t\tKANDR,     0)\t\t   /*   2465 */ \\\n-D(elif,\t\tT_ELIF,\t\tSTDC89,    COND)\t   /*    610 */ \\\n+D(line,\t\tT_LINE,\t\tKANDR,     EXPAND)\t   /*   2465 */ \\\n+D(elif,\t\tT_ELIF,\t\tSTDC89,    COND | EXPAND)  /*    610 */ \\\n D(error,\tT_ERROR,\tSTDC89,    0)\t\t   /*    475 */ \\\n D(pragma,\tT_PRAGMA,\tSTDC89,    IN_I)\t   /*    195 */ \\\n D(warning,\tT_WARNING,\tEXTENSION, 0)\t\t   /*     22 */ \\\n@@ -202,8 +208,7 @@ static const directive linemarker_dir =\n   do_linemarker, U\"#\", 1, KANDR, IN_I\n };\n \n-#define SEEN_EOL() (CPP_OPTION (pfile, traditional) \\\n-\t\t    || pfile->cur_token[-1].type == CPP_EOF)\n+#define SEEN_EOL() (pfile->cur_token[-1].type == CPP_EOF)\n \n /* Skip any remaining tokens in a directive.  */\n static void\n@@ -249,6 +254,14 @@ end_directive (pfile, skip_line)\n      cpp_reader *pfile;\n      int skip_line;\n {\n+  if (CPP_OPTION (pfile, traditional))\n+    {\n+      if (pfile->directive == &dtable[T_DEFINE])\n+\tskip_line = false;\n+      else\n+\t_cpp_remove_overlay (pfile);\n+    }\n+\n   /* We don't skip for an assembler #.  */\n   if (skip_line)\n     {\n@@ -267,6 +280,27 @@ end_directive (pfile, skip_line)\n   pfile->directive = 0;\n }\n \n+/* Prepare to handle the directive in pfile->directive.  */\n+static void\n+prepare_directive_trad (pfile)\n+     cpp_reader *pfile;\n+{\n+  if (pfile->directive == &dtable[T_DEFINE])\n+    CUR (pfile->context) = pfile->buffer->cur;\n+  else\n+    {\n+      bool no_expand = ! (pfile->directive->flags & EXPAND);\n+\n+      if (no_expand)\n+\tpfile->state.prevent_expansion++;\n+      _cpp_read_logical_line_trad (pfile);\n+      if (no_expand)\n+\tpfile->state.prevent_expansion--;\n+      _cpp_overlay_buffer (pfile, pfile->out.base,\n+\t\t\t   pfile->out.cur - pfile->out.base);\n+    }\n+}\n+\n /* Output diagnostics for a directive DIR.  INDENTED is non-zero if\n    the '#' was indented.  */\n static void\n@@ -405,6 +439,8 @@ _cpp_handle_directive (pfile, indented)\n \t  ! CPP_OPTION (pfile, discard_comments_in_macro_exp);\n \n       pfile->directive = dir;\n+      if (CPP_OPTION (pfile, traditional))\n+\tprepare_directive_trad (pfile);\n       (*pfile->directive->handler) (pfile);\n     }\n   else if (skip == 0)\n@@ -436,6 +472,8 @@ run_directive (pfile, dir_no, buf, count)\n   /* We don't want a leading # to be interpreted as a directive.  */\n   pfile->buffer->saved_flags = 0;\n   pfile->directive = &dtable[dir_no];\n+  if (CPP_OPTION (pfile, traditional))\n+    prepare_directive_trad (pfile);\n   (void) (*pfile->directive->handler) (pfile);\n   end_directive (pfile, 1);\n   _cpp_pop_buffer (pfile);\n@@ -447,7 +485,7 @@ static cpp_hashnode *\n lex_macro_node (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_hashnode *node;\n+  const cpp_token *token = _cpp_lex_token (pfile);\n \n   /* The token immediately after #define must be an identifier.  That\n      identifier may not be \"defined\", per C99 6.10.8p4.\n@@ -459,41 +497,31 @@ lex_macro_node (pfile)\n      Note that if we're copying comments into macro expansions, we\n      could encounter comment tokens here, so eat them all up first.  */\n \n-  if (CPP_OPTION (pfile, traditional))\n-    node = _cpp_lex_identifier_trad (pfile);\n-  else\n+  if (! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n     {\n-      const cpp_token *token = _cpp_lex_token (pfile);\n+      while (token->type == CPP_COMMENT)\n+\ttoken = _cpp_lex_token (pfile);\n+    }\n \n-      if (! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n-\t{\n-\t  while (token->type == CPP_COMMENT)\n-\t    token = _cpp_lex_token (pfile);\n-\t}\n+  if (token->type == CPP_NAME)\n+    {\n+      cpp_hashnode *node = token->val.node;\n \n-      if (token->type == CPP_EOF)\n-\t{\n-\t  cpp_error (pfile, DL_ERROR, \"no macro name given in #%s directive\",\n-\t\t     pfile->directive->name);\n-\t  return NULL;\n-\t}\n-\t\n-      if (token->type == CPP_NAME || (token->flags & NAMED_OP))\n-\tnode = token->val.node;\n-      else\n-\tnode = NULL;\n+      if (node == pfile->spec_nodes.n_defined)\n+\tcpp_error (pfile, DL_ERROR,\n+\t\t   \"\\\"defined\\\" cannot be used as a macro name\");\n+      else if (! (node->flags & NODE_POISONED))\n+\treturn node;\n     }\n-\n-  if (!node)\n-    cpp_error (pfile, DL_ERROR, \"macro names must be identifiers\");\n-  else if (node->flags & NODE_OPERATOR)\n+  else if (token->flags & NAMED_OP)\n     cpp_error (pfile, DL_ERROR,\n        \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n-\t       NODE_NAME (node));\n-  else if (node == pfile->spec_nodes.n_defined)\n-    cpp_error (pfile, DL_ERROR, \"\\\"defined\\\" cannot be used as a macro name\");\n-  else if (! (node->flags & NODE_POISONED))\n-    return node;\n+\t       NODE_NAME (token->val.node));\n+  else if (token->type == CPP_EOF)\n+    cpp_error (pfile, DL_ERROR, \"no macro name given in #%s directive\",\n+\t       pfile->directive->name);\n+  else\n+    cpp_error (pfile, DL_ERROR, \"macro names must be identifiers\");\n \n   return NULL;\n }"}, {"sha": "05d29ce547295a2f5d9bf1830e2e07e39dba5e66", "filename": "gcc/cpplib.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -393,6 +393,9 @@ struct cpp_options\n   /* True for traditional preprocessing.  */\n   unsigned char traditional;\n \n+  /* True if only preprocessing and not compiling.  */\n+  unsigned char preprocess_only;\n+\n   /* Target-specific features set by the front end or client.  */\n \n   /* Precision for target CPP arithmetic, target characters, target"}, {"sha": "0edc3d2b25b86387b88d005a71c9ea377e2e6b43", "filename": "gcc/cppmain.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -25,7 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"system.h\"\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n-#include \"intl.h\"\n \n /* Encapsulates state used to convert the stream of tokens coming from\n    cpp_get_token back into a text file.  */\n@@ -73,6 +72,10 @@ cpp_preprocess_file (pfile)\n {\n   options = cpp_get_options (pfile);\n \n+  /* Let preprocessor know if it's only preprocessing.  It would be\n+     nice to lose this somehow.  */\n+  options->preprocess_only = 1;\n+\n   /* Initialize the printer structure.  Setting print.line to -1 here\n      is a trick to guarantee that the first token of the file will\n      cause a linemarker to be output by maybe_print_line.  */\n@@ -221,20 +224,22 @@ check_multiline_token (str)\n       print.line++;\n }\n \n+/* Writes out a traditionally preprocessed file.  */\n static void\n scan_translation_unit_trad (pfile)\n      cpp_reader *pfile;\n {\n-  bool more;\n-  size_t len;\n-\n-  do\n+  for (;;)\n     {\n-      more = _cpp_read_logical_line_trad (pfile, false);\n-      len = pfile->trad_out_cur - pfile->trad_out_base;\n-      fwrite (pfile->trad_out_base, 1, len, print.outf);\n+      size_t len;\n+\n+      if (!_cpp_read_logical_line_trad (pfile))\n+\tbreak;\n+      len = pfile->out.cur - pfile->out.base;\n+      maybe_print_line (print.map, pfile->out.first_line);\n+      fwrite (pfile->out.base, 1, len, print.outf);\n+      print.printed = 1;\n     }\n-  while (more);\n }\n \n /* If the token read on logical line LINE needs to be output on a"}, {"sha": "33e4575cf951fb6bb26fd088ed1f173de77d2690", "filename": "gcc/cpptrad.c", "status": "modified", "additions": 63, "deletions": 58, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpptrad.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a76916c78c985f1622db1b31d4f05e18c8ae9e4/gcc%2Fcpptrad.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpptrad.c?ref=1a76916c78c985f1622db1b31d4f05e18c8ae9e4", "patch": "@@ -80,7 +80,6 @@ static cpp_hashnode *lex_identifier PARAMS ((cpp_reader *, const uchar *));\n static const uchar *skip_comment PARAMS ((cpp_reader *, const uchar *));\n static void scan_out_logical_line PARAMS ((cpp_reader *pfile, cpp_macro *));\n static void check_output_buffer PARAMS ((cpp_reader *, size_t));\n-static void restore_buff PARAMS ((cpp_reader *));\n static void push_replacement_text PARAMS ((cpp_reader *, cpp_hashnode *));\n static bool scan_parameters PARAMS ((cpp_reader *, cpp_macro *));\n static void save_replacement_text PARAMS ((cpp_reader *, cpp_macro *,\n@@ -99,15 +98,15 @@ check_output_buffer (pfile, n)\n      cpp_reader *pfile;\n      size_t n;\n {\n-  if (n > (size_t) (pfile->trad_out_limit - pfile->trad_out_cur))\n+  if (n > (size_t) (pfile->out.limit - pfile->out.cur))\n     {\n-      size_t size = pfile->trad_out_cur - pfile->trad_out_base;\n+      size_t size = pfile->out.cur - pfile->out.base;\n       size_t new_size = (size + n) * 3 / 2;\n \n-      pfile->trad_out_base\n-\t= (uchar *) xrealloc (pfile->trad_out_base, new_size);\n-      pfile->trad_out_limit = pfile->trad_out_base + new_size;\n-      pfile->trad_out_cur = pfile->trad_out_base + size;\n+      pfile->out.base\n+\t= (uchar *) xrealloc (pfile->out.base, new_size);\n+      pfile->out.limit = pfile->out.base + new_size;\n+      pfile->out.cur = pfile->out.base + size;\n     }\n }\n \n@@ -219,14 +218,14 @@ skip_whitespace (pfile, cur)\n \n /* Lexes and outputs an identifier starting at CUR, which is assumed\n    to point to a valid first character of an identifier.  Returns\n-   the hashnode, and updates trad_out_cur.  */\n+   the hashnode, and updates out.cur.  */\n static cpp_hashnode *\n lex_identifier (pfile, cur)\n      cpp_reader *pfile;\n      const uchar *cur;\n {\n   size_t len;\n-  uchar *out = pfile->trad_out_cur;\n+  uchar *out = pfile->out.cur;\n   cpp_hashnode *result;\n \n   do\n@@ -239,10 +238,10 @@ lex_identifier (pfile, cur)\n   while (is_numchar (*cur));\n \n   CUR (pfile->context) = cur;\n-  len = out - pfile->trad_out_cur;\n-  result = (cpp_hashnode *) ht_lookup (pfile->hash_table, pfile->trad_out_cur,\n+  len = out - pfile->out.cur;\n+  result = (cpp_hashnode *) ht_lookup (pfile->hash_table, pfile->out.cur,\n \t\t\t\t       len, HT_ALLOC);\n-  pfile->trad_out_cur = out;\n+  pfile->out.cur = out;\n   return result;\n }\n \n@@ -281,35 +280,31 @@ _cpp_overlay_buffer (pfile, start, len)\n   buffer->cur = start;\n   buffer->line_base = start;\n   buffer->rlimit = start + len;\n+\n+  pfile->saved_line = pfile->line;\n }\n \n /* Restores a buffer overlaid by _cpp_overlay_buffer().  */\n-static void\n-restore_buff (pfile)\n+void\n+_cpp_remove_overlay (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n   buffer->cur = buffer->saved_cur;\n   buffer->rlimit = buffer->saved_rlimit;\n   buffer->line_base = buffer->saved_line_base;\n+\n+  pfile->line = pfile->saved_line;\n }\n \n /* Reads a logical line into the output buffer.  Returns TRUE if there\n    is more text left in the buffer.  */\n bool\n-_cpp_read_logical_line_trad (pfile, overlay)\n+_cpp_read_logical_line_trad (pfile)\n      cpp_reader *pfile;\n-     int overlay;\n {\n   cpp_buffer *buffer;\n-  unsigned int first_line = 0;\n-\n-  if (overlay)\n-    {\n-      restore_buff (pfile);\n-      first_line = pfile->line = pfile->trad_line;\n-    }\n \n   buffer = pfile->buffer;\n   if (buffer->cur == buffer->rlimit)\n@@ -329,18 +324,11 @@ _cpp_read_logical_line_trad (pfile, overlay)\n \n   CUR (pfile->context) = buffer->cur;\n   RLIMIT (pfile->context) = buffer->rlimit;\n-  pfile->trad_out_cur = pfile->trad_out_base;\n+  pfile->out.cur = pfile->out.base;\n+  pfile->out.first_line = pfile->line;\n   scan_out_logical_line (pfile, NULL);\n   buffer->cur = CUR (pfile->context);\n \n-  if (overlay)\n-    {\n-      pfile->trad_line = pfile->line;\n-      pfile->line = first_line;\n-      _cpp_overlay_buffer (pfile, pfile->trad_out_base,\n-\t\t\t   pfile->trad_out_cur - pfile->trad_out_base);\n-    }\n-\n   return true;\n }\n \n@@ -360,7 +348,7 @@ maybe_start_funlike (pfile, node, start, macro)\n   macro->buff = _cpp_get_buff (pfile, n * sizeof (size_t));\n   macro->args = (size_t *) BUFF_FRONT (macro->buff);\n   macro->node = node;\n-  macro->offset = start - pfile->trad_out_base;\n+  macro->offset = start - pfile->out.base;\n   macro->argc = 0;\n \n   pfile->state.parsing_args = 1;\n@@ -400,7 +388,7 @@ scan_out_logical_line (pfile, macro)\n   context = pfile->context;\n   cur = CUR (context);\n   check_output_buffer (pfile, RLIMIT (context) - cur);\n-  out = pfile->trad_out_cur;\n+  out = pfile->out.cur;\n \n   for (;;)\n     {\n@@ -418,7 +406,7 @@ scan_out_logical_line (pfile, macro)\n \t  /* If this is a macro's expansion, pop it.  */\n \t  if (context->prev)\n \t    {\n-\t      pfile->trad_out_cur = out - 1;\n+\t      pfile->out.cur = out - 1;\n \t      _cpp_pop_context (pfile);\n \t      goto new_context;\n \t    }\n@@ -491,7 +479,7 @@ scan_out_logical_line (pfile, macro)\n \t    {\n \t      cpp_hashnode *node;\n \n-\t      pfile->trad_out_cur = --out;\n+\t      pfile->out.cur = --out;\n \t      node = lex_identifier (pfile, cur - 1);\n \n \t      if (node->type == NT_MACRO\n@@ -504,7 +492,7 @@ scan_out_logical_line (pfile, macro)\n \t\t    {\n \t\t      /* Remove the object-like macro's name from the\n \t\t\t output, and push its replacement text.  */\n-\t\t      pfile->trad_out_cur = out;\n+\t\t      pfile->out.cur = out;\n \t\t      push_replacement_text (pfile, node);\n \t\t      goto new_context;\n \t\t    }\n@@ -513,11 +501,11 @@ scan_out_logical_line (pfile, macro)\n \t\t{\n \t\t  /* Found a parameter in the replacement text of a\n \t\t     #define.  Remove its name from the output.  */\n-\t\t  pfile->trad_out_cur = out;\n+\t\t  pfile->out.cur = out;\n \t\t  save_replacement_text (pfile, macro, node->arg_index);\n \t\t}\n \n-\t      out = pfile->trad_out_cur;\n+\t      out = pfile->out.cur;\n \t      cur = CUR (context);\n \t    }\n \t  break;\n@@ -528,7 +516,7 @@ scan_out_logical_line (pfile, macro)\n \t      paren_depth++;\n \t      if (pfile->state.parsing_args == 1)\n \t\t{\n-\t\t  const uchar *p = pfile->trad_out_base + fmacro.offset;\n+\t\t  const uchar *p = pfile->out.base + fmacro.offset;\n \n \t\t  /* Invoke a prior function-like macro if there is only\n \t\t     white space in-between.  */\n@@ -541,7 +529,7 @@ scan_out_logical_line (pfile, macro)\n \t\t    {\n \t\t      pfile->state.parsing_args = 2;\n \t\t      paren_depth = 1;\n-\t\t      out = pfile->trad_out_base + fmacro.offset;\n+\t\t      out = pfile->out.base + fmacro.offset;\n \t\t      fmacro.args[0] = fmacro.offset;\n \t\t    }\n \t\t  else\n@@ -552,7 +540,7 @@ scan_out_logical_line (pfile, macro)\n \n \tcase ',':\n \t  if (quote == 0 && pfile->state.parsing_args == 2 && paren_depth == 1)\n-\t    save_argument (&fmacro, out - pfile->trad_out_base);\n+\t    save_argument (&fmacro, out - pfile->out.base);\n \t  break;\n \n \tcase ')':\n@@ -564,19 +552,19 @@ scan_out_logical_line (pfile, macro)\n \t\t  cpp_macro *m = fmacro.node->value.macro;\n \n \t\t  pfile->state.parsing_args = 0;\n-\t\t  save_argument (&fmacro, out - pfile->trad_out_base);\n+\t\t  save_argument (&fmacro, out - pfile->out.base);\n \n \t\t  /* A single zero-length argument is no argument.  */\n \t\t  if (fmacro.argc == 1\n \t\t      && m->paramc == 0\n-\t\t      && out == pfile->trad_out_base + 1)\n+\t\t      && out == pfile->out.base + 1)\n \t\t    fmacro.argc = 0;\n \n \t\t  if (_cpp_arguments_ok (pfile, m, fmacro.node, fmacro.argc))\n \t\t    {\n \t\t      /* Remove the macro's invocation from the\n \t\t\t output, and push its replacement text.  */\n-\t\t      pfile->trad_out_cur = (pfile->trad_out_base\n+\t\t      pfile->out.cur = (pfile->out.base\n \t\t\t\t\t     + fmacro.offset);\n \t\t      CUR (context) = cur;\n \t\t      replace_args_and_push (pfile, &fmacro);\n@@ -586,6 +574,21 @@ scan_out_logical_line (pfile, macro)\n \t    }\n \t  break;\n \n+\tcase '#':\n+\t  /* At start of a line it's a directive.  */\n+\t  if (out - 1 == pfile->out.base && !pfile->state.in_directive)\n+\t    {\n+\t      /* This is a kludge.  We want to have the ISO\n+\t\t preprocessor lex the next token.  */\n+\t      pfile->buffer->cur = cur;\n+\t      if (_cpp_handle_directive (pfile, false /* indented */))\n+\t\t{\n+\t\t  cur = CUR (context);\n+\t\t  goto done;\n+\t\t}\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  break;\n \t}\n@@ -594,7 +597,7 @@ scan_out_logical_line (pfile, macro)\n  done:\n   out[-1] = '\\0';\n   CUR (context) = cur;\n-  pfile->trad_out_cur = out - 1;\n+  pfile->out.cur = out - 1;\n   if (fmacro.buff)\n     _cpp_release_buff (pfile, fmacro.buff);\n }\n@@ -660,7 +663,7 @@ replace_args_and_push (pfile, fmacro)\n \t    break;\n \t  arglen = (fmacro->args[b->arg_index]\n \t\t    - fmacro->args[b->arg_index - 1] - 1);\n-\t  memcpy (p, pfile->trad_out_base + fmacro->args[b->arg_index - 1],\n+\t  memcpy (p, pfile->out.base + fmacro->args[b->arg_index - 1],\n \t\t  arglen);\n \t  p += arglen;\n \t  exp += BLOCK_LEN (b->text_len);\n@@ -676,7 +679,7 @@ replace_args_and_push (pfile, fmacro)\n }\n \n /* Read and record the parameters, if any, of a function-like macro\n-   definition.  Destroys pfile->trad_out_cur.\n+   definition.  Destroys pfile->out.cur.\n \n    Returns true on success, false on failure (syntax error or a\n    duplicate parameter).  On success, CUR (pfile->context) is just\n@@ -717,7 +720,7 @@ scan_parameters (pfile, macro)\n   return ok;\n }\n \n-/* Save the text from pfile->trad_out_base to pfile->trad_out_cur as\n+/* Save the text from pfile->out.base to pfile->out.cur as\n    the replacement text for the current macro, followed by argument\n    ARG_INDEX, with zero indicating the end of the replacement\n    text.  */\n@@ -727,15 +730,15 @@ save_replacement_text (pfile, macro, arg_index)\n      cpp_macro *macro;\n      unsigned int arg_index;\n {\n-  size_t len = pfile->trad_out_cur - pfile->trad_out_base;\n+  size_t len = pfile->out.cur - pfile->out.base;\n   uchar *exp;\n \n   if (macro->paramc == 0)\n     {\n       /* Object-like and function-like macros without parameters\n \t simply store their NUL-terminated replacement text.  */\n       exp = _cpp_unaligned_alloc (pfile, len + 1);\n-      memcpy (exp, pfile->trad_out_base, len);\n+      memcpy (exp, pfile->out.base, len);\n       exp[len] = '\\0';\n       macro->exp.text = exp;\n       macro->count = len;\n@@ -757,10 +760,10 @@ save_replacement_text (pfile, macro, arg_index)\n       /* Write out the block information.  */\n       block->text_len = len;\n       block->arg_index = arg_index;\n-      memcpy (block->text, pfile->trad_out_base, len);\n+      memcpy (block->text, pfile->out.base, len);\n \n       /* Lex the rest into the start of the output buffer.  */\n-      pfile->trad_out_cur = pfile->trad_out_base;\n+      pfile->out.cur = pfile->out.base;\n \n       macro->count += blen;\n \n@@ -780,6 +783,8 @@ _cpp_create_trad_definition (pfile, macro)\n   const uchar *cur;\n   uchar *limit;\n \n+  CUR (pfile->context) = pfile->buffer->cur;\n+\n   /* Is this a function-like macro?  */\n   if (* CUR (pfile->context) == '(')\n     {\n@@ -799,7 +804,7 @@ _cpp_create_trad_definition (pfile, macro)\n   /* Skip leading whitespace in the replacement text.  */\n   CUR (pfile->context) = skip_whitespace (pfile, CUR (pfile->context));\n \n-  pfile->trad_out_cur = pfile->trad_out_base;\n+  pfile->out.cur = pfile->out.base;\n   pfile->state.prevent_expansion++;\n   scan_out_logical_line (pfile, macro);\n   pfile->state.prevent_expansion--;\n@@ -808,11 +813,11 @@ _cpp_create_trad_definition (pfile, macro)\n     return false;\n \n   /* Skip trailing white space.  */\n-  cur = pfile->trad_out_base;\n-  limit = pfile->trad_out_cur;\n+  cur = pfile->out.base;\n+  limit = pfile->out.cur;\n   while (limit > cur && is_space (limit[-1]))\n     limit--;\n-  pfile->trad_out_cur = limit;\n+  pfile->out.cur = limit;\n   save_replacement_text (pfile, macro, 0);\n \n   return true;\n@@ -918,7 +923,7 @@ _cpp_set_trad_context (pfile)\n   if (pfile->context->prev)\n     abort ();\n \n-  pfile->trad_out_cur = pfile->trad_out_base;\n+  pfile->out.cur = pfile->out.base;\n   CUR (context) = buffer->cur;\n   RLIMIT (context) = buffer->rlimit;\n   check_output_buffer (pfile, RLIMIT (context) - CUR (context));"}]}