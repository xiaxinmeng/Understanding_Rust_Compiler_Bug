{"sha": "5751a10b97f8607b89325cecdac246d9ef758592", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc1MWExMGI5N2Y4NjA3Yjg5MzI1Y2VjZGFjMjQ2ZDllZjc1ODU5Mg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-09-08T06:57:05Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-09-08T06:57:05Z"}, "message": "sparc.c (struct machine_function): New type.\n\n\t* config/sparc/sparc.c (struct machine_function): New type.\n\t(TARGET_HAVE_TLS, TARGET_CANNOT_FORCE_CONST_MEM): Define.\n\t(sparc_override_options): Initialize init_machine_status.\n\t(tls_symbolic_operand, tgd_symbolic_operand, tld_symbolic_operand,\n\ttie_symbolic_operand, tle_symbolic_operand): New functions.\n\t(symbolic_operand): Disallow tls_symbolic_operand.\n\t(symbolic_memory_operand): Likewise.\n\t(tls_call_delay, sparc_cannot_force_const_mem, legitimate_constant_p,\n\tconstant_address_p, legitimate_pic_operand_p, legitimate_address_p):\n\tNew functions.\n\t(sparc_tls_symbol): New variable.\n\t(sparc_tls_get_addr, sparc_tls_got, legitimize_tls_address,\n\tlegitimize_address): New functions.\n\t(print_operand): Handle %&.\n\t(sparc_init_machine_status, get_some_local_dynamic_name,\n\tget_some_local_dynamic_name_1): New functions.\n\t(sparc_output_dwarf_dtprel): New function.\n\t* config/sparc/sparc.h (CONSTANT_ADDRESS_P): Moved into\n\tconstant_address_p.\n\t(LEGITIMATE_PIC_OPERAND_P): Moved into legitimate_pic_operand_p.\n\t(LEGITIMATE_CONSTANT_P): Moved into legitimate_constant_p.\n\t(GO_IF_LEGITIMATE_ADDRESS): Moved into legitimate_address_p.\n\t(LEGITIMIZE_ADDRESS): Moved into legitimize_address.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Add '&'.\n\t(TARGET_TLS, TARGET_SUN_TLS, TARGET_GNU_TLS): Define.\n\t(ASM_OUTPUT_DWARF_DTPREL): Define.\n\t(PREDICATE_CODES): Add tgd_symbolic_operand, tld_symbolic_operand,\n\ttie_symbolic_operand, tle_symbolic_operand.\n\t* config/sparc/sparc.md (UNSPEC_TLSGD, UNSPEC_TLSLDM, UNSPEC_TLSLDO,\n\tUNSPEC_TLSIE, UNSPEC_TLSLE, UNSPEC_TLSLD_BASE): New constants.\n\t(tls_call_delay): New attribute.\n\t(in_call_delay): Use it.\n\t(movqi, movhi, movsi, movdi): Call legitimize_tls_address if needed.\n\t(tgd_hi22, tgd_lo10, tgd_add32, tgd_add64, tgd_call32, tgd_call64,\n\ttldm_hi22, tldm_lo10, tldm_add32, tldm_add64, tldm_call32, tldm_call64,\n\ttldo_hix22, tldo_lox10, tldo_add32, tldo_add64, tie_hi22, tie_lo10,\n\ttie_ld32, tie_ld64, tie_add32, tie_add64, tle_hix22_sp32,\n\ttle_lox10_sp32, tle_hix22_sp64, tle_lox10_sp64): New insns.\n\t(tldo_ldub_sp32, tldo_ldub1_sp32, tldo_ldub2_sp32, tldo_ldsb1_sp32,\n\ttldo_ldsb2_sp32, tldo_ldub_sp64, tldo_ldub1_sp64, tldo_ldub2_sp64,\n\ttldo_ldub3_sp64, tldo_ldsb1_sp64, tldo_ldsb2_sp64, tldo_ldsb3_sp64,\n\ttldo_lduh_sp32, tldo_lduh1_sp32, tldo_ldsh1_sp32, tldo_lduh_sp64,\n\ttldo_lduh1_sp64, tldo_lduh2_sp64, tldo_ldsh1_sp64, tldo_ldsh2_sp64,\n\ttldo_lduw_sp32, tldo_lduw_sp64, tldo_lduw1_sp64, tldo_ldsw1_sp64,\n\ttldo_ldx_sp64, tldo_stb_sp32, tldo_stb_sp64, tldo_sth_sp32,\n\ttldo_sth_sp64, tldo_stw_sp32, tldo_stw_sp64, tldo_stx_sp64): New\n\tinsns.\n\t* config/sparc/sparc-protos.h (legitimate_constant_p,\n\tconstant_address_p, legitimate_pic_operand_p, legitimate_address_p,\n\tlegitimize_tls_address, legitimize_address, tls_symbolic_operand,\n\ttls_call_delay, sparc_output_dwarf_dtprel): New prototypes.\n\t* config/sparc/linux.h (TARGET_GNU_TLS, TARGET_SUN_TLS): Define.\n\t* config/sparc/linux64.h (TARGET_GNU_TLS, TARGET_SUN_TLS): Likewise.\n\t* configure.in (sparc*-*-*): Add TLS check.\n\t* configure: Rebuilt.\n\nFrom-SVN: r71202", "tree": {"sha": "0cb295b1897b72c5d7c1bff4effc7bdf3f0726a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cb295b1897b72c5d7c1bff4effc7bdf3f0726a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5751a10b97f8607b89325cecdac246d9ef758592", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5751a10b97f8607b89325cecdac246d9ef758592", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5751a10b97f8607b89325cecdac246d9ef758592", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5751a10b97f8607b89325cecdac246d9ef758592/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b65ed544822a16bf1786ecab90412bd26cf7f62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b65ed544822a16bf1786ecab90412bd26cf7f62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b65ed544822a16bf1786ecab90412bd26cf7f62"}], "stats": {"total": 1540, "additions": 1394, "deletions": 146}, "files": [{"sha": "f5cb771483e3bee4b1d02c4114f4e9b75c6cac85", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -1,3 +1,61 @@\n+2003-09-08  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/sparc/sparc.c (struct machine_function): New type.\n+\t(TARGET_HAVE_TLS, TARGET_CANNOT_FORCE_CONST_MEM): Define.\n+\t(sparc_override_options): Initialize init_machine_status.\n+\t(tls_symbolic_operand, tgd_symbolic_operand, tld_symbolic_operand,\n+\ttie_symbolic_operand, tle_symbolic_operand): New functions.\n+\t(symbolic_operand): Disallow tls_symbolic_operand.\n+\t(symbolic_memory_operand): Likewise.\n+\t(tls_call_delay, sparc_cannot_force_const_mem, legitimate_constant_p,\n+\tconstant_address_p, legitimate_pic_operand_p, legitimate_address_p):\n+\tNew functions.\n+\t(sparc_tls_symbol): New variable.\n+\t(sparc_tls_get_addr, sparc_tls_got, legitimize_tls_address,\n+\tlegitimize_address): New functions.\n+\t(print_operand): Handle %&.\n+\t(sparc_init_machine_status, get_some_local_dynamic_name,\n+\tget_some_local_dynamic_name_1): New functions.\n+\t(sparc_output_dwarf_dtprel): New function.\n+\t* config/sparc/sparc.h (CONSTANT_ADDRESS_P): Moved into\n+\tconstant_address_p.\n+\t(LEGITIMATE_PIC_OPERAND_P): Moved into legitimate_pic_operand_p.\n+\t(LEGITIMATE_CONSTANT_P): Moved into legitimate_constant_p.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Moved into legitimate_address_p.\n+\t(LEGITIMIZE_ADDRESS): Moved into legitimize_address.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Add '&'.\n+\t(TARGET_TLS, TARGET_SUN_TLS, TARGET_GNU_TLS): Define.\n+\t(ASM_OUTPUT_DWARF_DTPREL): Define.\n+\t(PREDICATE_CODES): Add tgd_symbolic_operand, tld_symbolic_operand,\n+\ttie_symbolic_operand, tle_symbolic_operand.\n+\t* config/sparc/sparc.md (UNSPEC_TLSGD, UNSPEC_TLSLDM, UNSPEC_TLSLDO,\n+\tUNSPEC_TLSIE, UNSPEC_TLSLE, UNSPEC_TLSLD_BASE): New constants.\n+\t(tls_call_delay): New attribute.\n+\t(in_call_delay): Use it.\n+\t(movqi, movhi, movsi, movdi): Call legitimize_tls_address if needed.\n+\t(tgd_hi22, tgd_lo10, tgd_add32, tgd_add64, tgd_call32, tgd_call64,\n+\ttldm_hi22, tldm_lo10, tldm_add32, tldm_add64, tldm_call32, tldm_call64,\n+\ttldo_hix22, tldo_lox10, tldo_add32, tldo_add64, tie_hi22, tie_lo10,\n+\ttie_ld32, tie_ld64, tie_add32, tie_add64, tle_hix22_sp32,\n+\ttle_lox10_sp32, tle_hix22_sp64, tle_lox10_sp64): New insns.\n+\t(tldo_ldub_sp32, tldo_ldub1_sp32, tldo_ldub2_sp32, tldo_ldsb1_sp32,\n+\ttldo_ldsb2_sp32, tldo_ldub_sp64, tldo_ldub1_sp64, tldo_ldub2_sp64,\n+\ttldo_ldub3_sp64, tldo_ldsb1_sp64, tldo_ldsb2_sp64, tldo_ldsb3_sp64,\n+\ttldo_lduh_sp32, tldo_lduh1_sp32, tldo_ldsh1_sp32, tldo_lduh_sp64,\n+\ttldo_lduh1_sp64, tldo_lduh2_sp64, tldo_ldsh1_sp64, tldo_ldsh2_sp64,\n+\ttldo_lduw_sp32, tldo_lduw_sp64, tldo_lduw1_sp64, tldo_ldsw1_sp64,\n+\ttldo_ldx_sp64, tldo_stb_sp32, tldo_stb_sp64, tldo_sth_sp32,\n+\ttldo_sth_sp64, tldo_stw_sp32, tldo_stw_sp64, tldo_stx_sp64): New\n+\tinsns.\n+\t* config/sparc/sparc-protos.h (legitimate_constant_p,\n+\tconstant_address_p, legitimate_pic_operand_p, legitimate_address_p,\n+\tlegitimize_tls_address, legitimize_address, tls_symbolic_operand,\n+\ttls_call_delay, sparc_output_dwarf_dtprel): New prototypes.\n+\t* config/sparc/linux.h (TARGET_GNU_TLS, TARGET_SUN_TLS): Define.\n+\t* config/sparc/linux64.h (TARGET_GNU_TLS, TARGET_SUN_TLS): Likewise.\n+\t* configure.in (sparc*-*-*): Add TLS check.\n+\t* configure: Rebuilt.\n+\n 2003-09-07  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/11689"}, {"sha": "a53e796098d3c19cd63b102ee7baac64d772edf9", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -232,6 +232,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LINK_EH_SPEC \"%{!static:--eh-frame-hdr} \"\n #endif\n \f\n+#ifdef HAVE_AS_TLS\n+#undef TARGET_SUN_TLS\n+#undef TARGET_GNU_TLS\n+#define TARGET_SUN_TLS 0\n+#define TARGET_GNU_TLS 1\n+#endif\n+\f\n /* Don't be different from other Linux platforms in this regard.  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP\n "}, {"sha": "fe7470a3563268a17925736d27111e8d32b1d017", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -315,6 +315,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define LINK_EH_SPEC \"%{!static:--eh-frame-hdr} \"\n #endif\n \f\n+#ifdef HAVE_AS_TLS\n+#undef TARGET_SUN_TLS\n+#undef TARGET_GNU_TLS\n+#define TARGET_SUN_TLS 0\n+#define TARGET_GNU_TLS 1\n+#endif\n+\f\n /* Don't be different from other Linux platforms in this regard.  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP\n "}, {"sha": "4b9582d96b858b52712fab023fdb78d3c19d65b3", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -78,7 +78,13 @@ extern void emit_tfmode_cvt (enum rtx_code, rtx *);\n extern int gen_v9_scc (enum rtx_code, rtx *);\n extern void sparc_initialize_trampoline (rtx, rtx, rtx);\n extern void sparc64_initialize_trampoline (rtx, rtx, rtx);\n+extern bool legitimate_constant_p (rtx);\n+extern bool constant_address_p (rtx);\n+extern bool legitimate_pic_operand_p (rtx);\n+extern int legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern rtx legitimize_tls_address (rtx);\n+extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern void sparc_emit_set_const32 (rtx, rtx);\n extern void sparc_emit_set_const64 (rtx, rtx);\n@@ -96,9 +102,11 @@ extern int arith_4096_operand (rtx, enum machine_mode);\n extern int zero_operand (rtx, enum machine_mode);\n extern int fp_zero_operand (rtx, enum machine_mode);\n extern int reg_or_0_operand (rtx, enum machine_mode);\n+extern int tls_symbolic_operand (rtx);\n extern int empty_delay_slot (rtx);\n extern int eligible_for_epilogue_delay (rtx, int);\n extern int eligible_for_sibcall_delay (rtx);\n+extern int tls_call_delay (rtx);\n extern int emit_move_sequence (rtx, enum machine_mode);\n extern int fp_sethi_p (rtx);\n extern int fp_mov_p (rtx);\n@@ -116,6 +124,7 @@ extern char *sparc_v8plus_shift (rtx *, rtx, const char *);\n extern int sparc_check_64 (rtx, rtx);\n extern rtx gen_df_reg (rtx, int);\n extern int sparc_extra_constraint_check (rtx, int, int);\n+extern void sparc_output_dwarf_dtprel (FILE*, int, rtx);\n #endif /* RTX_CODE */\n \n #endif /* __SPARC_PROTOS_H__ */"}, {"sha": "9e651365632d1adbf326dc46d7e91d02d0fbe3b3", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 628, "deletions": 3, "changes": 631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -120,6 +120,12 @@ char sparc_leaf_regs[] =\n   1, 1, 1, 1, 1, 1, 1, 1,\n   1, 1, 1, 1, 1};\n \n+struct machine_function GTY(())\n+{\n+  /* Some local-dynamic TLS symbol name.  */\n+  const char *some_ld_name;\n+};\n+\n /* Name of where we pretend to think the frame pointer points.\n    Normally, this is \"%fp\", but if we are in a leaf procedure,\n    this is \"%sp+something\".  We record \"something\" separately as it may be\n@@ -176,6 +182,12 @@ static void emit_hard_tfmode_operation (enum rtx_code, rtx *);\n static bool sparc_function_ok_for_sibcall (tree, tree);\n static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t   HOST_WIDE_INT, tree);\n+static struct machine_function * sparc_init_machine_status (void);\n+static bool sparc_cannot_force_const_mem (rtx);\n+static rtx sparc_tls_get_addr (void);\n+static rtx sparc_tls_got (void);\n+static const char *get_some_local_dynamic_name (void);\n+static int get_some_local_dynamic_name_1 (rtx *, void *);\n static bool sparc_rtx_costs (rtx, int, int, int *);\n \f\n /* Option handling.  */\n@@ -240,6 +252,13 @@ enum processor_type sparc_cpu;\n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL sparc_function_ok_for_sibcall\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+#undef TARGET_CANNOT_FORCE_CONST_MEM\n+#define TARGET_CANNOT_FORCE_CONST_MEM sparc_cannot_force_const_mem\n+\n #undef TARGET_ASM_OUTPUT_MI_THUNK\n #define TARGET_ASM_OUTPUT_MI_THUNK sparc_output_mi_thunk\n #undef TARGET_ASM_CAN_OUTPUT_MI_THUNK\n@@ -448,6 +467,9 @@ sparc_override_options (void)\n \n   /* Do various machine dependent initializations.  */\n   sparc_init_modes ();\n+\n+  /* Set up function hooks.  */\n+  init_machine_status = sparc_init_machine_status;\n }\n \f\n /* Miscellaneous utilities.  */\n@@ -687,6 +709,41 @@ call_operand_address (rtx op, enum machine_mode mode)\n   return (symbolic_operand (op, mode) || memory_address_p (Pmode, op));\n }\n \n+/* If OP is a SYMBOL_REF of a thread-local symbol, return its TLS mode,\n+   otherwise return 0.  */\n+\n+int\n+tls_symbolic_operand (rtx op)\n+{\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+  return SYMBOL_REF_TLS_MODEL (op);\n+}\n+\n+int\n+tgd_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return tls_symbolic_operand (op) == TLS_MODEL_GLOBAL_DYNAMIC;\n+}\n+\n+int\n+tld_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return tls_symbolic_operand (op) == TLS_MODEL_LOCAL_DYNAMIC;\n+}\n+\n+int\n+tie_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return tls_symbolic_operand (op) == TLS_MODEL_INITIAL_EXEC;\n+}\n+\n+int\n+tle_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return tls_symbolic_operand (op) == TLS_MODEL_LOCAL_EXEC;\n+}\n+\n /* Returns 1 if OP is either a symbol reference or a sum of a symbol\n    reference and a constant.  */\n \n@@ -701,12 +758,15 @@ symbolic_operand (register rtx op, enum machine_mode mode)\n   switch (GET_CODE (op))\n     {\n     case SYMBOL_REF:\n+      return !SYMBOL_REF_TLS_MODEL (op);\n+\n     case LABEL_REF:\n       return 1;\n \n     case CONST:\n       op = XEXP (op, 0);\n-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+      return (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t\t&& !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))\n \t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n \t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n \n@@ -726,8 +786,9 @@ symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n   if (GET_CODE (op) != MEM)\n     return 0;\n   op = XEXP (op, 0);\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == HIGH || GET_CODE (op) == LABEL_REF);\n+  return ((GET_CODE (op) == SYMBOL_REF && !SYMBOL_REF_TLS_MODEL (op))\n+\t  || GET_CODE (op) == CONST || GET_CODE (op) == HIGH\n+\t  || GET_CODE (op) == LABEL_REF);\n }\n \n /* Return truth value of statement that OP is a LABEL_REF of mode MODE.  */\n@@ -2793,6 +2854,32 @@ eligible_for_epilogue_delay (rtx trial, int slot)\n   return 0;\n }\n \n+/* Return nonzero if TRIAL can go into the call delay slot.  */\n+int\n+tls_call_delay (rtx trial)\n+{\n+  rtx pat, unspec;\n+\n+  /* Binutils allows\n+     call __tls_get_addr, %tgd_call (foo)\n+      add %l7, %o0, %o0, %tgd_add (foo)\n+     while Sun as/ld does not.  */\n+  if (TARGET_GNU_TLS || !TARGET_TLS)\n+    return 1;\n+\n+  pat = PATTERN (trial);\n+  if (GET_CODE (pat) != SET || GET_CODE (SET_DEST (pat)) != PLUS)\n+    return 1;\n+\n+  unspec = XEXP (SET_DEST (pat), 1);\n+  if (GET_CODE (unspec) != UNSPEC\n+      || (XINT (unspec, 1) != UNSPEC_TLSGD\n+\t  && XINT (unspec, 1) != UNSPEC_TLSLDM))\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* Return nonzero if TRIAL can go into the sibling call\n    delay slot.  */\n \n@@ -2965,6 +3052,45 @@ reg_unused_after (rtx reg, rtx insn)\n   return 1;\n }\n \f\n+/* Determine if it's legal to put X into the constant pool.  This\n+   is not possible if X contains the address of a symbol that is\n+   not constant (TLS) or not known at final link time (PIC).  */\n+\n+static bool\n+sparc_cannot_force_const_mem (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+      /* Accept all non-symbolic constants.  */\n+      return false;\n+\n+    case LABEL_REF:\n+      /* Labels are OK iff we are non-PIC.  */\n+      return flag_pic != 0;\n+\n+    case SYMBOL_REF:\n+      /* 'Naked' TLS symbol references are never OK,\n+\t non-TLS symbols are OK iff we are non-PIC.  */\n+      if (SYMBOL_REF_TLS_MODEL (x))\n+\treturn true;\n+      else\n+\treturn flag_pic != 0;\n+\n+    case CONST:\n+      return sparc_cannot_force_const_mem (XEXP (x, 0));\n+    case PLUS:\n+    case MINUS:\n+      return sparc_cannot_force_const_mem (XEXP (x, 0))\n+         || sparc_cannot_force_const_mem (XEXP (x, 1));\n+    case UNSPEC:\n+      return true;\n+    default:\n+      abort ();\n+    }\n+}\n+\f\n /* The table we use to reference PIC data.  */\n static GTY(()) rtx global_offset_table;\n \n@@ -3010,6 +3136,391 @@ pic_address_needs_scratch (rtx x)\n   return 0;\n }\n \n+/* Determine if a given RTX is a valid constant.  We already know this\n+   satisfies CONSTANT_P.  */\n+\n+bool\n+legitimate_constant_p (rtx x)\n+{\n+  rtx inner;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case SYMBOL_REF:\n+      /* TLS symbols are not constant.  */\n+      if (SYMBOL_REF_TLS_MODEL (x))\n+\treturn false;\n+      break;\n+\n+    case CONST:\n+      inner = XEXP (x, 0);\n+\n+      /* Offsets of TLS symbols are never valid.\n+\t Discourage CSE from creating them.  */\n+      if (GET_CODE (inner) == PLUS\n+\t  && tls_symbolic_operand (XEXP (inner, 0)))\n+\treturn false;\n+      break;\n+\n+    case CONST_DOUBLE:\n+      if (GET_MODE (x) == VOIDmode)\n+        return true;\n+\n+      /* Floating point constants are generally not ok.\n+\t The only exception is 0.0 in VIS.  */\n+      if (TARGET_VIS\n+\t  && (GET_MODE (x) == SFmode\n+\t      || GET_MODE (x) == DFmode\n+\t      || GET_MODE (x) == TFmode)\n+\t  && fp_zero_operand (x, GET_MODE (x)))\n+\treturn true;\n+\n+      return false;\n+\n+    default:\n+      break;\n+    }\n+\n+  return true;\n+}\n+\n+/* Determine if a given RTX is a valid constant address.  */\n+\n+bool\n+constant_address_p (rtx x)\n+{\n+  switch (GET_CODE (x))\n+    {\n+    case LABEL_REF:\n+    case CONST_INT:\n+    case HIGH:\n+      return true;\n+\n+    case CONST:\n+      if (flag_pic && pic_address_needs_scratch (x))\n+\treturn false;\n+      return legitimate_constant_p (x);\n+\n+    case SYMBOL_REF:\n+      return !flag_pic && legitimate_constant_p (x);\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Nonzero if the constant value X is a legitimate general operand\n+   when generating PIC code.  It is given that flag_pic is on and\n+   that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+bool\n+legitimate_pic_operand_p (rtx x)\n+{\n+  if (pic_address_needs_scratch (x))\n+    return false;\n+  if (tls_symbolic_operand (x)\n+      || (GET_CODE (x) == CONST\n+\t  && GET_CODE (XEXP (x, 0)) == PLUS\n+\t  && tls_symbolic_operand (XEXP (XEXP (x, 0), 0))))\n+    return false;\n+  return true;\n+}\n+\n+/* Return nonzero if ADDR is a valid memory address.\n+   STRICT specifies whether strict register checking applies.  */\n+   \n+int\n+legitimate_address_p (enum machine_mode mode, rtx addr, int strict)\n+{\n+  rtx rs1 = NULL, rs2 = NULL, imm1 = NULL, imm2;\n+\n+  if (REG_P (addr) || GET_CODE (addr) == SUBREG)\n+    rs1 = addr;\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      rs1 = XEXP (addr, 0);\n+      rs2 = XEXP (addr, 1);\n+\n+      /* Canonicalize.  REG comes first, if there are no regs,\n+\t LO_SUM comes first.  */\n+      if (!REG_P (rs1)\n+\t  && GET_CODE (rs1) != SUBREG\n+\t  && (REG_P (rs2)\n+\t      || GET_CODE (rs2) == SUBREG\n+\t      || (GET_CODE (rs2) == LO_SUM && GET_CODE (rs1) != LO_SUM)))\n+\t{\n+\t  rs1 = XEXP (addr, 1);\n+\t  rs2 = XEXP (addr, 0);\n+\t}\n+\n+      if ((flag_pic == 1\n+\t   && rs1 == pic_offset_table_rtx\n+\t   && !REG_P (rs2)\n+\t   && GET_CODE (rs2) != SUBREG\n+\t   && GET_CODE (rs2) != LO_SUM\n+\t   && GET_CODE (rs2) != MEM\n+\t   && !tls_symbolic_operand (rs2)\n+\t   && (! symbolic_operand (rs2, VOIDmode) || mode == Pmode)\n+\t   && (GET_CODE (rs2) != CONST_INT || SMALL_INT (rs2)))\n+\t  || ((REG_P (rs1)\n+\t       || GET_CODE (rs1) == SUBREG)\n+\t      && RTX_OK_FOR_OFFSET_P (rs2)))\n+\t{\n+\t  imm1 = rs2;\n+\t  rs2 = NULL;\n+\t}\n+      else if ((REG_P (rs1) || GET_CODE (rs1) == SUBREG)\n+\t       && (REG_P (rs2) || GET_CODE (rs2) == SUBREG))\n+\t{\n+\t  /* We prohibit REG + REG for TFmode when there are no instructions\n+\t     which accept REG+REG instructions.  We do this because REG+REG\n+\t     is not an offsetable address.  If we get the situation in reload\n+\t     where source and destination of a movtf pattern are both MEMs with\n+\t     REG+REG address, then only one of them gets converted to an\n+\t     offsetable address.  */\n+\t  if (mode == TFmode\n+\t      && !(TARGET_FPU && TARGET_ARCH64 && TARGET_V9\n+\t\t   && TARGET_HARD_QUAD))\n+\t    return 0;\n+\n+\t  /* We prohibit REG + REG on ARCH32 if not optimizing for\n+\t     DFmode/DImode because then mem_min_alignment is likely to be zero\n+\t     after reload and the  forced split would lack a matching splitter\n+\t     pattern.  */\n+\t  if (TARGET_ARCH32 && !optimize\n+\t      && (mode == DFmode || mode == DImode))\n+\t    return 0;\n+\t}\n+      else if (USE_AS_OFFSETABLE_LO10\n+\t       && GET_CODE (rs1) == LO_SUM\n+\t       && TARGET_ARCH64\n+\t       && ! TARGET_CM_MEDMID\n+\t       && RTX_OK_FOR_OLO10_P (rs2))\n+\t{\n+\t  imm2 = rs2;\n+\t  rs2 = NULL;\n+\t  imm1 = XEXP (rs1, 1);\n+\t  rs1 = XEXP (rs1, 0);\n+\t  if (! CONSTANT_P (imm1) || tls_symbolic_operand (rs1))\n+\t    return 0;\n+\t}\n+    }\n+  else if (GET_CODE (addr) == LO_SUM)\n+    {\n+      rs1 = XEXP (addr, 0);\n+      imm1 = XEXP (addr, 1);\n+\n+      if (! CONSTANT_P (imm1) || tls_symbolic_operand (rs1))\n+\treturn 0;\n+\n+      /* We can't allow TFmode, because an offset greater than or equal to the\n+         alignment (8) may cause the LO_SUM to overflow if !v9.  */\n+      if (mode == TFmode && !TARGET_V9)\n+\treturn 0;\n+    }\n+  else if (GET_CODE (addr) == CONST_INT && SMALL_INT (addr))\n+    return 1;\n+  else\n+    return 0;\n+\n+  if (GET_CODE (rs1) == SUBREG)\n+    rs1 = SUBREG_REG (rs1);\n+  if (!REG_P (rs1))\n+    return 0;\n+\n+  if (rs2)\n+    {\n+      if (GET_CODE (rs2) == SUBREG)\n+\trs2 = SUBREG_REG (rs2);\n+      if (!REG_P (rs2))\n+\treturn 0;\n+    }\n+\n+  if (strict)\n+    {\n+      if (!REGNO_OK_FOR_BASE_P (REGNO (rs1))\n+\t  || (rs2 && !REGNO_OK_FOR_BASE_P (REGNO (rs2))))\n+\treturn 0;\n+    }\n+  else\n+    {\n+      if ((REGNO (rs1) >= 32\n+\t   && REGNO (rs1) != FRAME_POINTER_REGNUM\n+\t   && REGNO (rs1) < FIRST_PSEUDO_REGISTER)\n+\t  || (rs2\n+\t      && (REGNO (rs2) >= 32\n+\t\t  && REGNO (rs2) != FRAME_POINTER_REGNUM\n+\t\t  && REGNO (rs2) < FIRST_PSEUDO_REGISTER)))\n+\treturn 0;\n+    }\n+  return 1;\n+}\n+\n+/* Construct the SYMBOL_REF for the tls_get_offset function.  */\n+\n+static GTY(()) rtx sparc_tls_symbol;\n+static rtx\n+sparc_tls_get_addr (void)\n+{\n+  if (!sparc_tls_symbol)\n+    sparc_tls_symbol = gen_rtx_SYMBOL_REF (Pmode, \"__tls_get_addr\");\n+\n+  return sparc_tls_symbol;\n+}\n+\n+static rtx\n+sparc_tls_got (void)\n+{\n+  rtx temp;\n+  if (flag_pic)\n+    {\n+      current_function_uses_pic_offset_table = 1;\n+      return pic_offset_table_rtx;\n+    }\n+\n+  if (!global_offset_table)\n+    global_offset_table = gen_rtx_SYMBOL_REF (Pmode, \"_GLOBAL_OFFSET_TABLE_\");\n+  temp = gen_reg_rtx (Pmode);\n+  emit_move_insn (temp, global_offset_table);\n+  return temp;\n+}\n+\n+\n+/* ADDR contains a thread-local SYMBOL_REF.  Generate code to compute\n+   this (thread-local) address.  */\n+\n+rtx\n+legitimize_tls_address (rtx addr)\n+{\n+  rtx temp1, temp2, temp3, ret, o0, got, insn;\n+\n+  if (no_new_pseudos)\n+    abort ();\n+\n+  if (GET_CODE (addr) == SYMBOL_REF)\n+    switch (SYMBOL_REF_TLS_MODEL (addr))\n+      {\n+      case TLS_MODEL_GLOBAL_DYNAMIC:\n+\tstart_sequence ();\n+\ttemp1 = gen_reg_rtx (SImode);\n+\ttemp2 = gen_reg_rtx (SImode);\n+\tret = gen_reg_rtx (Pmode);\n+\to0 = gen_rtx_REG (Pmode, 8);\n+\tgot = sparc_tls_got ();\n+\temit_insn (gen_tgd_hi22 (temp1, addr));\n+\temit_insn (gen_tgd_lo10 (temp2, temp1, addr));\n+\tif (TARGET_ARCH32)\n+\t  {\n+\t    emit_insn (gen_tgd_add32 (o0, got, temp2, addr));\n+\t    insn = emit_call_insn (gen_tgd_call32 (o0, sparc_tls_get_addr (),\n+\t\t\t\t\t\t   addr, const1_rtx));\n+\t  }\n+\telse\n+\t  {\n+\t    emit_insn (gen_tgd_add64 (o0, got, temp2, addr));\n+\t    insn = emit_call_insn (gen_tgd_call64 (o0, sparc_tls_get_addr (),\n+\t\t\t\t\t\t   addr, const1_rtx));\n+\t  }\n+        CALL_INSN_FUNCTION_USAGE (insn)\n+\t  = gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, o0),\n+\t\t\t       CALL_INSN_FUNCTION_USAGE (insn));\n+\tinsn = get_insns ();\n+\tend_sequence ();\n+\temit_libcall_block (insn, ret, o0, addr);\n+\tbreak;\n+\n+      case TLS_MODEL_LOCAL_DYNAMIC:\n+\tstart_sequence ();\n+\ttemp1 = gen_reg_rtx (SImode);\n+\ttemp2 = gen_reg_rtx (SImode);\n+\ttemp3 = gen_reg_rtx (Pmode);\n+\tret = gen_reg_rtx (Pmode);\n+\to0 = gen_rtx_REG (Pmode, 8);\n+\tgot = sparc_tls_got ();\n+\temit_insn (gen_tldm_hi22 (temp1));\n+\temit_insn (gen_tldm_lo10 (temp2, temp1));\n+\tif (TARGET_ARCH32)\n+\t  {\n+\t    emit_insn (gen_tldm_add32 (o0, got, temp2));\n+\t    insn = emit_call_insn (gen_tldm_call32 (o0, sparc_tls_get_addr (),\n+\t\t\t\t\t\t    const1_rtx));\n+\t  }\n+\telse\n+\t  {\n+\t    emit_insn (gen_tldm_add64 (o0, got, temp2));\n+\t    insn = emit_call_insn (gen_tldm_call64 (o0, sparc_tls_get_addr (),\n+\t\t\t\t\t\t    const1_rtx));\n+\t  }\n+        CALL_INSN_FUNCTION_USAGE (insn)\n+\t  = gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, o0),\n+\t\t\t       CALL_INSN_FUNCTION_USAGE (insn));\n+\tinsn = get_insns ();\n+\tend_sequence ();\n+\temit_libcall_block (insn, temp3, o0,\n+\t\t\t    gen_rtx_UNSPEC (Pmode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t\t    UNSPEC_TLSLD_BASE));\n+\ttemp1 = gen_reg_rtx (SImode);\n+\ttemp2 = gen_reg_rtx (SImode);\n+\temit_insn (gen_tldo_hix22 (temp1, addr));\n+\temit_insn (gen_tldo_lox10 (temp2, temp1, addr));\n+\tif (TARGET_ARCH32)\n+\t  emit_insn (gen_tldo_add32 (ret, temp3, temp2, addr));\n+\telse\n+\t  emit_insn (gen_tldo_add64 (ret, temp3, temp2, addr));\n+\tbreak;\n+\n+      case TLS_MODEL_INITIAL_EXEC:\n+\ttemp1 = gen_reg_rtx (SImode);\n+\ttemp2 = gen_reg_rtx (SImode);\n+\ttemp3 = gen_reg_rtx (Pmode);\n+\tgot = sparc_tls_got ();\n+\temit_insn (gen_tie_hi22 (temp1, addr));\n+\temit_insn (gen_tie_lo10 (temp2, temp1, addr));\n+\tif (TARGET_ARCH32)\n+\t  emit_insn (gen_tie_ld32 (temp3, got, temp2, addr));\n+\telse\n+\t  emit_insn (gen_tie_ld64 (temp3, got, temp2, addr));\n+        if (TARGET_SUN_TLS)\n+\t  {\n+\t    ret = gen_reg_rtx (Pmode);\n+\t    if (TARGET_ARCH32)\n+\t      emit_insn (gen_tie_add32 (ret, gen_rtx_REG (Pmode, 7),\n+\t\t\t\t\ttemp3, addr));\n+\t    else\n+\t      emit_insn (gen_tie_add64 (ret, gen_rtx_REG (Pmode, 7),\n+\t\t\t\t\ttemp3, addr));\n+\t  }\n+\telse\n+\t  ret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp3);\n+\tbreak;\n+\n+      case TLS_MODEL_LOCAL_EXEC:\n+\ttemp1 = gen_reg_rtx (Pmode);\n+\ttemp2 = gen_reg_rtx (Pmode);\n+\tif (TARGET_ARCH32)\n+\t  {\n+\t    emit_insn (gen_tle_hix22_sp32 (temp1, addr));\n+\t    emit_insn (gen_tle_lox10_sp32 (temp2, temp1, addr));\n+\t  }\n+\telse\n+\t  {\n+\t    emit_insn (gen_tle_hix22_sp64 (temp1, addr));\n+\t    emit_insn (gen_tle_lox10_sp64 (temp2, temp1, addr));\n+\t  }\n+\tret = gen_rtx_PLUS (Pmode, gen_rtx_REG (Pmode, 7), temp2);\n+\tbreak;\n+\n+      default:\n+\tabort ();\n+      }\n+\n+  else\n+    abort ();  /* for now ... */\n+\n+  return ret;\n+}\n+\n+\n /* Legitimize PIC addresses.  If the address is already position-independent,\n    we return ORIG.  Newly generated position-independent addresses go into a\n    reg.  This is REG if nonzero, otherwise we allocate register(s) as\n@@ -3117,6 +3628,52 @@ legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n   return orig;\n }\n \n+/* Try machine-dependent ways of modifying an illegitimate address X\n+   to be legitimate.  If we find one, return the new, valid address.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE is the mode of the operand pointed to by X.  */\n+\n+rtx\n+legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED, enum machine_mode mode)\n+{\n+  rtx orig_x = x;\n+\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == MULT)\n+    x = gen_rtx_PLUS (Pmode, XEXP (x, 1),\n+\t\t      force_operand (XEXP (x, 0), NULL_RTX));\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == MULT)\n+    x = gen_rtx_PLUS (Pmode, XEXP (x, 0),\n+\t\t      force_operand (XEXP (x, 1), NULL_RTX));\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 0)) == PLUS)\n+    x = gen_rtx_PLUS (Pmode, force_operand (XEXP (x, 0), NULL_RTX),\n+\t\t      XEXP (x, 1));\n+  if (GET_CODE (x) == PLUS && GET_CODE (XEXP (x, 1)) == PLUS)\n+    x = gen_rtx_PLUS (Pmode, XEXP (x, 0),\n+\t\t      force_operand (XEXP (x, 1), NULL_RTX));\n+\n+  if (x != orig_x && legitimate_address_p (mode, x, FALSE))\n+    return x;\n+\n+  if (tls_symbolic_operand (x))\n+    x = legitimize_tls_address (x);\n+  else if (flag_pic)\n+    x = legitimize_pic_address (x, mode, 0);\n+  else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 1)))\n+    x = gen_rtx_PLUS (Pmode, XEXP (x, 0),\n+\t\t      copy_to_mode_reg (Pmode, XEXP (x, 1)));\n+  else if (GET_CODE (x) == PLUS && CONSTANT_ADDRESS_P (XEXP (x, 0)))\n+    x = gen_rtx_PLUS (Pmode, XEXP (x, 1),\n+\t\t      copy_to_mode_reg (Pmode, XEXP (x, 0)));\n+  else if (GET_CODE (x) == SYMBOL_REF\n+\t   || GET_CODE (x) == CONST\n+           || GET_CODE (x) == LABEL_REF)\n+    x = copy_to_suggested_reg (x, NULL_RTX, Pmode);\n+  return x;\n+}\n+\n /* Emit special PIC prologues.  */\n \n void\n@@ -6095,6 +6652,10 @@ print_operand (FILE *file, rtx x, int code)\n       /* ??? What if offset is too big? Perhaps the caller knows it isn't? */\n       fprintf (file, \"%s+%d\", frame_base_name, frame_base_offset);\n       return;\n+    case '&':\n+      /* Print some local dynamic TLS name.  */\n+      assemble_name (file, get_some_local_dynamic_name ());\n+      return;\n     case 'Y':\n       /* Adjust the operand to take into account a RESTORE operation.  */\n       if (GET_CODE (x) == CONST_INT)\n@@ -8350,4 +8911,68 @@ sparc_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   no_new_pseudos = 0;\n }\n \n+/* How to allocate a 'struct machine_function'.  */\n+\n+static struct machine_function *\n+sparc_init_machine_status (void)\n+{\n+  return ggc_alloc_cleared (sizeof (struct machine_function));\n+}\n+\n+/* Locate some local-dynamic symbol still in use by this function\n+   so that we can print its name in local-dynamic base patterns.  */\n+\n+static const char *\n+get_some_local_dynamic_name (void)\n+{\n+  rtx insn;\n+\n+  if (cfun->machine->some_ld_name)\n+    return cfun->machine->some_ld_name;\n+\n+  for (insn = get_insns (); insn ; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn)\n+\t&& for_each_rtx (&PATTERN (insn), get_some_local_dynamic_name_1, 0))\n+      return cfun->machine->some_ld_name;\n+\n+  abort ();\n+}\n+\n+static int\n+get_some_local_dynamic_name_1 (rtx *px, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx x = *px;\n+\n+  if (x\n+      && GET_CODE (x) == SYMBOL_REF\n+      && SYMBOL_REF_TLS_MODEL (x) == TLS_MODEL_LOCAL_DYNAMIC)\n+    {\n+      cfun->machine->some_ld_name = XSTR (x, 0);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* This is called from dwarf2out.c via ASM_OUTPUT_DWARF_DTPREL.\n+   We need to emit DTP-relative relocations.  */\n+\n+void\n+sparc_output_dwarf_dtprel (FILE *file, int size, rtx x)\n+{\n+  switch (size)\n+    {\n+    case 4:\n+      fputs (\"\\t.word\\t%r_tls_dtpoff32(\", file);\n+      break;\n+    case 8:\n+      fputs (\"\\t.xword\\t%r_tls_dtpoff64(\", file);\n+      break;\n+    default:\n+      abort ();\n+    }\n+  output_addr_const (file, x);\n+  fputs (\")\", file);\n+}\n+\n #include \"gt-sparc.h\""}, {"sha": "a997602daffe70631d86dab235168710446a1253", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 39, "deletions": 141, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -2099,27 +2099,18 @@ do {\t\t\t\t\t\t\t\t\t\\\n    When PIC, we do not accept an address that would require a scratch reg\n    to load into a register.  */\n \n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\t\\\n-   || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-       && ! (flag_pic && pic_address_needs_scratch (X))))\n+#define CONSTANT_ADDRESS_P(X) constant_address_p (X)\n \n /* Define this, so that when PIC, reload won't try to reload invalid\n    addresses which require two reload registers.  */\n \n-#define LEGITIMATE_PIC_OPERAND_P(X)  (! pic_address_needs_scratch (X))\n+#define LEGITIMATE_PIC_OPERAND_P(X) legitimate_pic_operand_p (X)\n \n /* Nonzero if the constant value X is a legitimate general operand.\n    Anything can be made to work except floating point constants.\n    If TARGET_VIS, 0.0 can be made to work as well.  */\n \n-#define LEGITIMATE_CONSTANT_P(X) \t\t\t\t\t\\\n-  (GET_CODE (X) != CONST_DOUBLE || GET_MODE (X) == VOIDmode || \t\t\\\n-   (TARGET_VIS &&\t\t\t\t\t\t\t\\\n-    (GET_MODE (X) == SFmode || GET_MODE (X) == DFmode ||\t\t\\\n-     GET_MODE (X) == TFmode) &&\t\t\t\t\t\t\\\n-    fp_zero_operand (X, GET_MODE (X))))\n+#define LEGITIMATE_CONSTANT_P(X) legitimate_constant_p (X)\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n@@ -2226,110 +2217,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define RTX_OK_FOR_OLO10_P(X)\t\t\t\t\t\t\\\n   (GET_CODE (X) == CONST_INT && INTVAL (X) >= -0x1000 && INTVAL (X) < 0xc00 - 8)\n \n+#ifdef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (legitimate_address_p (MODE, X, 1))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      register rtx op0 = XEXP (X, 0);\t\t\t\\\n-      register rtx op1 = XEXP (X, 1);\t\t\t\\\n-      if (flag_pic && op0 == pic_offset_table_rtx)\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if (RTX_OK_FOR_BASE_P (op1))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t  else if (flag_pic == 1\t\t\t\\\n-\t\t   && GET_CODE (op1) != REG\t\t\\\n-\t\t   && GET_CODE (op1) != LO_SUM\t\t\\\n-\t\t   && GET_CODE (op1) != MEM\t\t\\\n-\t\t   && (! SYMBOLIC_CONST (op1)\t\t\\\n-\t\t       || MODE == Pmode)\t\t\\\n-\t\t   && (GET_CODE (op1) != CONST_INT\t\\\n-\t\t       || SMALL_INT (op1)))\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else if (RTX_OK_FOR_BASE_P (op0))\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if ((RTX_OK_FOR_INDEX_P (op1)\t\t\t\\\n- \t      /* We prohibit REG + REG for TFmode when\t\\\n-\t\t there are no instructions which accept\t\\\n-\t\t REG+REG instructions.  We do this\t\\\n-\t\t because REG+REG is not an offsetable\t\\\n-\t\t address.  If we get the situation\t\\\n-\t\t in reload where source and destination\t\\\n-\t\t of a movtf pattern are both MEMs with\t\\\n-\t\t REG+REG address, then only one of them\t\\\n-\t\t gets converted to an offsetable\t\\\n-\t\t address.  */\t\t\t\t\\\n- \t       && (MODE != TFmode\t\t\t\\\n-\t\t   || (TARGET_FPU && TARGET_ARCH64\t\\\n-\t\t       && TARGET_V9\t\t\t\\\n-\t\t       && TARGET_HARD_QUAD))\t\t\\\n-\t      /* We prohibit REG + REG on ARCH32 if\t\\\n-\t\t not optimizing for DFmode/DImode\t\\\n-\t\t because then mem_min_alignment is\t\\\n-\t\t likely to be zero after reload and the \\\n-\t\t forced split would lack a matching\t\\\n-\t\t splitter pattern.  */\t\t\t\\\n-\t       && (TARGET_ARCH64 || optimize\t\t\\\n-\t\t   || (MODE != DFmode\t\t\t\\\n-\t\t       && MODE != DImode)))\t\t\\\n-\t      || RTX_OK_FOR_OFFSET_P (op1))\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else if (RTX_OK_FOR_BASE_P (op1))\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  if ((RTX_OK_FOR_INDEX_P (op0)\t\t\t\\\n- \t      /* See the previous comment.  */\t\t\\\n- \t       && (MODE != TFmode\t\t\t\\\n-\t\t  || (TARGET_FPU && TARGET_ARCH64\t\\\n-\t\t      && TARGET_V9\t\t\t\\\n-\t\t      && TARGET_HARD_QUAD))\t\t\\\n-\t       && (TARGET_ARCH64 || optimize\t\t\\\n-\t\t   || (MODE != DFmode\t\t\t\\\n-\t\t       && MODE != DImode)))\t\t\\\n-\t      || RTX_OK_FOR_OFFSET_P (op0))\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else if (USE_AS_OFFSETABLE_LO10\t\t\t\\\n-\t       && GET_CODE (op0) == LO_SUM\t\t\\\n-\t       && TARGET_ARCH64\t\t\t\t\\\n-\t       && ! TARGET_CM_MEDMID\t\t\t\\\n-\t       && RTX_OK_FOR_OLO10_P (op1))\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  register rtx op00 = XEXP (op0, 0);\t\t\\\n-\t  register rtx op01 = XEXP (op0, 1);\t\t\\\n-\t  if (RTX_OK_FOR_BASE_P (op00)\t\t\t\\\n-\t      && CONSTANT_P (op01))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else if (USE_AS_OFFSETABLE_LO10\t\t\t\\\n-\t       && GET_CODE (op1) == LO_SUM\t\t\\\n-\t       && TARGET_ARCH64\t\t\t\t\\\n-\t       && ! TARGET_CM_MEDMID\t\t\t\\\n-\t       && RTX_OK_FOR_OLO10_P (op0))\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  register rtx op10 = XEXP (op1, 0);\t\t\\\n-\t  register rtx op11 = XEXP (op1, 1);\t\t\\\n-\t  if (RTX_OK_FOR_BASE_P (op10)\t\t\t\\\n-\t      && CONSTANT_P (op11))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == LO_SUM)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      register rtx op0 = XEXP (X, 0);\t\t\t\\\n-      register rtx op1 = XEXP (X, 1);\t\t\t\\\n-      if (RTX_OK_FOR_BASE_P (op0)\t\t\t\\\n-\t  && CONSTANT_P (op1)\t\t\t\t\\\n-\t  /* We can't allow TFmode, because an offset\t\\\n-\t     greater than or equal to the alignment (8)\t\\\n-\t     may cause the LO_SUM to overflow if !v9.  */\\\n-\t  && (MODE != TFmode || TARGET_V9))\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_INT && SMALL_INT (X))\t\\\n+}\n+#else\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (legitimate_address_p (MODE, X, 0))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n }\n+#endif\n \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.\n@@ -2374,33 +2274,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* On SPARC, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n-{ rtx sparc_x = (X);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), NULL_RTX));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), NULL_RTX));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == PLUS)\t\\\n-    (X) = gen_rtx_PLUS (Pmode, force_operand (XEXP (X, 0), NULL_RTX),\\\n-\t\t\tXEXP (X, 1));\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == PLUS)\t\\\n-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), NULL_RTX));\t\\\n-  if (sparc_x != (X) && memory_address_p (MODE, X))\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\\\n-  if (flag_pic) (X) = legitimize_pic_address (X, MODE, 0);\t\\\n-  else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (X, 1)));\t\\\n-  else if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx_PLUS (Pmode, XEXP (X, 1),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (X, 0)));\t\\\n-  else if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n-\t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n-    (X) = copy_to_suggested_reg (X, NULL_RTX, Pmode); \t\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\\\n-    goto WIN; }\n+{\t\t\t\t\t\t\\\n+  (X) = legitimize_address (X, OLDX, MODE);\t\\\n+  if (memory_address_p (MODE, X))\t\t\\\n+    goto WIN;\t\t\t\t\t\\\n+}\n \n /* Try a machine-dependent way of reloading an illegitimate address\n    operand.  If we find one, push the reload and jump to WIN.  This\n@@ -2845,8 +2723,16 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_IDENT(FILE, NAME) \\\n   fprintf (FILE, \"%s\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n \n+/* Emit a dtp-relative reference to a TLS variable.  */\n+\n+#ifdef HAVE_AS_TLS\n+#define ASM_OUTPUT_DWARF_DTPREL(FILE, SIZE, X) \\\n+  sparc_output_dwarf_dtprel (FILE, SIZE, X)\n+#endif\n+\n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^' || (CHAR) == '(' || (CHAR) == '_')\n+  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^'\t\t\\\n+   || (CHAR) == '(' || (CHAR) == '_' || (CHAR) == '&')\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n@@ -2933,6 +2819,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n+#ifdef HAVE_AS_TLS\n+#define TARGET_TLS 1\n+#else\n+#define TARGET_TLS 0\n+#endif\n+#define TARGET_SUN_TLS TARGET_TLS\n+#define TARGET_GNU_TLS 0\n+\n /* Define the codes that are matched by predicates in sparc.c.  */\n \n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n@@ -2980,7 +2874,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"clobbered_register\", {REG}},\t\t\t\t\t\t\\\n {\"input_operand\", {SUBREG, REG, CONST_INT, MEM, CONST}},\t\t\\\n {\"const64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\t\\\n-{\"const64_high_operand\", {CONST_INT, CONST_DOUBLE}},\n+{\"const64_high_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n+{\"tgd_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n+{\"tld_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n+{\"tie_symbolic_operand\", {SYMBOL_REF}},\t\t\t\t\t\\\n+{\"tle_symbolic_operand\", {SYMBOL_REF}},\n \n /* The number of Pmode words for the setjmp buffer.  */\n #define JMP_BUF_SIZE 12"}, {"sha": "954e89dc2b6c8ff8404e98dc18d7b0965b9a0179", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 591, "deletions": 1, "changes": 592, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -38,6 +38,13 @@\n    (UNSPEC_EMB_TEXTHI\t\t14)\n    (UNSPEC_EMB_TEXTULO\t\t15)\n    (UNSPEC_EMB_SETHM\t\t18)\n+\n+   (UNSPEC_TLSGD\t\t30)\n+   (UNSPEC_TLSLDM\t\t31)\n+   (UNSPEC_TLSLDO\t\t32)\n+   (UNSPEC_TLSIE\t\t33)\n+   (UNSPEC_TLSLE\t\t34)\n+   (UNSPEC_TLSLD_BASE\t\t35)\n   ])\n \n (define_constants\n@@ -195,14 +202,18 @@\n \n ;; Attributes for instruction and branch scheduling\n \n+(define_attr \"tls_call_delay\" \"false,true\"\n+  (symbol_ref \"tls_call_delay (insn)\"))\n+\n (define_attr \"in_call_delay\" \"false,true\"\n   (cond [(eq_attr \"type\" \"uncond_branch,branch,call,sibcall,call_no_delay_slot,multi\")\n \t \t(const_string \"false\")\n \t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n \t \t(if_then_else (eq_attr \"length\" \"1\")\n \t\t\t      (const_string \"true\")\n \t\t\t      (const_string \"false\"))]\n-\t(if_then_else (eq_attr \"length\" \"1\")\n+\t(if_then_else (and (eq_attr \"length\" \"1\")\n+\t\t\t   (eq_attr \"tls_call_delay\" \"true\"))\n \t\t      (const_string \"true\")\n \t\t      (const_string \"false\"))))\n \n@@ -1681,6 +1692,10 @@\n \t}\n     }\n \n+  /* Fixup TLS cases.  */\n+  if (tls_symbolic_operand (operands [1]))\n+    operands[1] = legitimize_tls_address (operands[1]);\n+\n   /* Fixup PIC cases.  */\n   if (flag_pic)\n     {\n@@ -1740,6 +1755,10 @@\n \t}\n     }\n \n+  /* Fixup TLS cases.  */\n+  if (tls_symbolic_operand (operands [1]))\n+    operands[1] = legitimize_tls_address (operands[1]);\n+\n   /* Fixup PIC cases.  */\n   if (flag_pic)\n     {\n@@ -1822,6 +1841,10 @@\n \t}\n     }\n \n+  /* Fixup TLS cases.  */\n+  if (tls_symbolic_operand (operands [1]))\n+    operands[1] = legitimize_tls_address (operands[1]);\n+\n   /* Fixup PIC cases.  */\n   if (flag_pic)\n     {\n@@ -1998,6 +2021,10 @@\n \t}\n     }\n \n+  /* Fixup TLS cases.  */\n+  if (tls_symbolic_operand (operands [1]))\n+    operands[1] = legitimize_tls_address (operands[1]);\n+\n   if (flag_pic)\n     {\n       if (CONSTANT_P (operands[1])\n@@ -8366,3 +8393,566 @@\n   \"TARGET_V9\"\n   \"t%C0\\t%%xcc, %1\"\n   [(set_attr \"type\" \"trap\")])\n+\n+;; TLS support\n+(define_insn \"tgd_hi22\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (unspec:SI [(match_operand 1 \"tgd_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSGD)))]\n+  \"TARGET_TLS\"\n+  \"sethi\\\\t%%tgd_hi22(%a1), %0\")\n+\n+(define_insn \"tgd_lo10\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (unspec:SI [(match_operand 2 \"tgd_symbolic_operand\" \"\")]\n+\t\t\t      UNSPEC_TLSGD)))]\n+  \"TARGET_TLS\"\n+  \"add\\\\t%1, %%tgd_lo10(%a2), %0\")\n+\n+(define_insn \"tgd_add32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"tgd_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSGD)))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"add\\\\t%1, %2, %0, %%tgd_add(%a3)\")\n+\n+(define_insn \"tgd_add64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"tgd_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSGD)))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"add\\\\t%1, %2, %0, %%tgd_add(%a3)\")\n+\n+(define_insn \"tgd_call32\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (unspec:SI [(match_operand:SI 1 \"symbolic_operand\" \"s\")\n+\t\t\t\t  (match_operand 2 \"tgd_symbolic_operand\" \"\")]\n+\t\t\t\t UNSPEC_TLSGD))\n+\t      (match_operand 3 \"\" \"\")))\n+   (clobber (reg:SI 15))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"call\\t%a1, %%tgd_call(%a2)%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"tgd_call64\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"s\")\n+\t\t\t\t  (match_operand 2 \"tgd_symbolic_operand\" \"\")]\n+\t\t\t\t UNSPEC_TLSGD))\n+\t      (match_operand 3 \"\" \"\")))\n+   (clobber (reg:DI 15))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"call\\t%a1, %%tgd_call(%a2)%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"tldm_hi22\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]\n+  \"TARGET_TLS\"\n+  \"sethi\\\\t%%tldm_hi22(%&), %0\")\n+\n+(define_insn \"tldm_lo10\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (unspec:SI [(const_int 0)] UNSPEC_TLSLDM)))]\n+  \"TARGET_TLS\"\n+  \"add\\\\t%1, %%tldm_lo10(%&), %0\")\n+\n+(define_insn \"tldm_add32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")]\n+\t\t\t    UNSPEC_TLSLDM)))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"add\\\\t%1, %2, %0, %%tldm_add(%&)\")\n+\n+(define_insn \"tldm_add64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")]\n+\t\t\t    UNSPEC_TLSLDM)))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"add\\\\t%1, %2, %0, %%tldm_add(%&)\")\n+\n+(define_insn \"tldm_call32\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:SI (unspec:SI [(match_operand:SI 1 \"symbolic_operand\" \"s\")]\n+\t\t\t\t UNSPEC_TLSLDM))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:SI 15))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"call\\t%a1, %%tldm_call(%&)%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"tldm_call64\"\n+  [(set (match_operand 0 \"register_operand\" \"=r\")\n+\t(call (mem:DI (unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"s\")]\n+\t\t\t\t UNSPEC_TLSLDM))\n+\t      (match_operand 2 \"\" \"\")))\n+   (clobber (reg:DI 15))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"call\\t%a1, %%tldm_call(%&)%#\"\n+  [(set_attr \"type\" \"call\")])\n+\n+(define_insn \"tldo_hix22\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (unspec:SI [(match_operand 1 \"tld_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSLDO)))]\n+  \"TARGET_TLS\"\n+  \"sethi\\\\t%%tldo_hix22(%a1), %0\")\n+\n+(define_insn \"tldo_lox10\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (unspec:SI [(match_operand 2 \"tld_symbolic_operand\" \"\")]\n+\t\t\t      UNSPEC_TLSLDO)))]\n+  \"TARGET_TLS\"\n+  \"xor\\\\t%1, %%tldo_lox10(%a2), %0\")\n+\n+(define_insn \"tldo_add32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSLDO)))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"add\\\\t%1, %2, %0, %%tldo_add(%a3)\")\n+\n+(define_insn \"tldo_add64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSLDO)))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"add\\\\t%1, %2, %0, %%tldo_add(%a3)\")\n+\n+(define_insn \"tie_hi22\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (unspec:SI [(match_operand 1 \"tie_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSIE)))]\n+  \"TARGET_TLS\"\n+  \"sethi\\\\t%%tie_hi22(%a1), %0\")\n+\n+(define_insn \"tie_lo10\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (unspec:SI [(match_operand 2 \"tie_symbolic_operand\" \"\")]\n+\t\t\t      UNSPEC_TLSIE)))]\n+  \"TARGET_TLS\"\n+  \"add\\\\t%1, %%tie_lo10(%a2), %0\")\n+\n+(define_insn \"tie_ld32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t    (match_operand 3 \"tie_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TLSIE))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ld\\\\t[%1 + %2], %0, %%tie_ld(%a3)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"tie_ld64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t    (match_operand 3 \"tie_symbolic_operand\" \"\")]\n+\t\t   UNSPEC_TLSIE))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldx\\\\t[%1 + %2], %0, %%tie_ldx(%a3)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"tie_add32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSIE)))]\n+  \"TARGET_SUN_TLS && TARGET_ARCH32\"\n+  \"add\\\\t%1, %2, %0, %%tie_add(%a3)\")\n+\n+(define_insn \"tie_add64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSIE)))]\n+  \"TARGET_SUN_TLS && TARGET_ARCH64\"\n+  \"add\\\\t%1, %2, %0, %%tie_add(%a3)\")\n+\n+(define_insn \"tle_hix22_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (high:SI (unspec:SI [(match_operand 1 \"tle_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSLE)))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"sethi\\\\t%%tle_hix22(%a1), %0\")\n+\n+(define_insn \"tle_lox10_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:SI (match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t   (unspec:SI [(match_operand 2 \"tle_symbolic_operand\" \"\")]\n+\t\t\t      UNSPEC_TLSLE)))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"xor\\\\t%1, %%tle_lox10(%a2), %0\")\n+\n+(define_insn \"tle_hix22_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (high:DI (unspec:DI [(match_operand 1 \"tle_symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_TLSLE)))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"sethi\\\\t%%tle_hix22(%a1), %0\")\n+\n+(define_insn \"tle_lox10_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t   (unspec:DI [(match_operand 2 \"tle_symbolic_operand\" \"\")]\n+\t\t\t      UNSPEC_TLSLE)))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"xor\\\\t%1, %%tle_lox10(%a2), %0\")\n+\n+;; Now patterns combinding tldo_add{32,64} with some integer loads or stores\n+(define_insn \"*tldo_ldub_sp32\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldub1_sp32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldub2_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsb1_sp32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ldsb\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsb2_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ldsb\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldub_sp64\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldub1_sp64\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldub2_sp64\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldub3_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldub\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsb1_sp64\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldsb\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsb2_sp64\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldsb\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsb3_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldsb\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_lduh_sp32\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_lduh1_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsh1_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ldsh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_lduh_sp64\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_lduh1_sp64\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:SI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_lduh2_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"lduh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsh1_sp64\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:SI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldsh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldsh2_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldsh\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_lduw_sp32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"ld\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*tldo_lduw_sp64\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"lduw\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*tldo_lduw1_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:DI (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"lduw\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*tldo_ldsw1_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:DI (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldsw\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"sload\")\n+   (set_attr \"us3load_type\" \"3cycle\")])\n+\n+(define_insn \"*tldo_ldx_sp64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\"))))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"ldx\\t[%1 + %2], %0, %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*tldo_stb_sp32\"\n+  [(set (mem:QI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))\n+\t(match_operand:QI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"stb\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*tldo_stb_sp64\"\n+  [(set (mem:QI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))\n+\t(match_operand:QI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"stb\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*tldo_sth_sp32\"\n+  [(set (mem:HI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))\n+\t(match_operand:HI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"sth\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*tldo_sth_sp64\"\n+  [(set (mem:HI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))\n+\t(match_operand:HI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"sth\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*tldo_stw_sp32\"\n+  [(set (mem:SI (plus:SI (unspec:SI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:SI 1 \"register_operand\" \"r\")))\n+\t(match_operand:SI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH32\"\n+  \"st\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*tldo_stw_sp64\"\n+  [(set (mem:SI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))\n+\t(match_operand:SI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"stw\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*tldo_stx_sp64\"\n+  [(set (mem:DI (plus:DI (unspec:DI [(match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t\t     (match_operand 3 \"tld_symbolic_operand\" \"\")]\n+\t\t\t\t    UNSPEC_TLSLDO)\n+\t\t\t (match_operand:DI 1 \"register_operand\" \"r\")))\n+\t(match_operand:DI 0 \"register_operand\" \"=r\"))]\n+  \"TARGET_TLS && TARGET_ARCH64\"\n+  \"stx\\t%0, [%1 + %2], %%tldo_add(%3)\"\n+  [(set_attr \"type\" \"store\")])"}, {"sha": "05dec4115a54e7ff80b18d9bd9e3ebbac5931ae4", "filename": "gcc/configure", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -6661,6 +6661,33 @@ foo:\t.long\t25\n \ttls_first_minor=14\n \ttls_as_opt=\"-m64 -Aesame\"\n \t;;\n+  sparc*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tsethi\t%tgd_hi22(foo), %o0\n+\tadd\t%o0, %tgd_lo10(foo), %o1\n+\tadd\t%l7, %o1, %o0, %tgd_add(foo)\n+\tcall\t__tls_get_addr, %tgd_call(foo)\n+\tsethi\t%tldm_hi22(foo), %l1\n+\tadd\t%l1, %tldm_lo10(foo), %l2\n+\tadd\t%l7, %l2, %o0, %tldm_add(foo)\n+\tcall\t__tls_get_addr, %tldm_call(foo)\n+\tsethi\t%tldo_hix22(foo), %l3\n+\txor\t%l3, %tldo_lox10(foo), %l4\n+\tadd\t%o0, %l4, %l5, %tldo_add(foo)\n+\tsethi\t%tie_hi22(foo), %o3\n+\tadd\t%o3, %tie_lo10(foo), %o3\n+\tld\t[%l7 + %o3], %o2, %tie_ld(foo)\n+\tadd\t%g7, %o2, %o4, %tie_add(foo)\n+\tsethi\t%tle_hix22(foo), %l1\n+\txor\t%l1, %tle_lox10(foo), %o5\n+\tld\t[%g7 + %o5], %o1'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\ttls_as_opt=-32\n+\t;;\n esac\n if test -z \"$tls_first_major\"; then\n   : # If we don't have a check, assume no support."}, {"sha": "b0926a7764425cfb117dbed2d013f080e923d7e1", "filename": "gcc/configure.in", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5751a10b97f8607b89325cecdac246d9ef758592/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=5751a10b97f8607b89325cecdac246d9ef758592", "patch": "@@ -2000,7 +2000,6 @@ foo:\t.long\t25\n \ttls_first_minor=13\n \t;;\n   i[34567]86-*-*)\n-changequote([,])dnl\n     conftest_s='\n \t.section \".tdata\",\"awT\",@progbits\n foo:\t.long\t25\n@@ -2147,6 +2146,34 @@ foo:\t.long\t25\n \ttls_first_minor=14\n \ttls_as_opt=\"-m64 -Aesame\"\n \t;;\n+  sparc*-*-*)\n+    conftest_s='\n+\t.section \".tdata\",\"awT\",@progbits\n+foo:\t.long\t25\n+\t.text\n+\tsethi\t%tgd_hi22(foo), %o0\n+\tadd\t%o0, %tgd_lo10(foo), %o1\n+\tadd\t%l7, %o1, %o0, %tgd_add(foo)\n+\tcall\t__tls_get_addr, %tgd_call(foo)\n+\tsethi\t%tldm_hi22(foo), %l1\n+\tadd\t%l1, %tldm_lo10(foo), %l2\n+\tadd\t%l7, %l2, %o0, %tldm_add(foo)\n+\tcall\t__tls_get_addr, %tldm_call(foo)\n+\tsethi\t%tldo_hix22(foo), %l3\n+\txor\t%l3, %tldo_lox10(foo), %l4\n+\tadd\t%o0, %l4, %l5, %tldo_add(foo)\n+\tsethi\t%tie_hi22(foo), %o3\n+\tadd\t%o3, %tie_lo10(foo), %o3\n+\tld\t[%l7 + %o3], %o2, %tie_ld(foo)\n+\tadd\t%g7, %o2, %o4, %tie_add(foo)\n+\tsethi\t%tle_hix22(foo), %l1\n+\txor\t%l1, %tle_lox10(foo), %o5\n+\tld\t[%g7 + %o5], %o1'\n+\ttls_first_major=2\n+\ttls_first_minor=14\n+\ttls_as_opt=-32\n+\t;;\n+changequote([,])dnl\n esac\n if test -z \"$tls_first_major\"; then\n   : # If we don't have a check, assume no support."}]}