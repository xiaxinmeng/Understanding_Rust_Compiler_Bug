{"sha": "2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZmZTBlMDI0MTRjN2RkY2Q0ZjRlZTRjMmU1YmY2NGMyYTVlZjhjNg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-28T18:13:28Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-28T18:13:28Z"}, "message": "ia64.c (ia64_split_tmode, [...]): Rewrite to use POST_INC/POST_DEC/POST_MODIFY instead of a scratch pointer.\n\n2004-01-28  Zack Weinberg  <zack@codesourcery.com>\n\t    Jim Wilson  <wilson@specifixinc.com>\n\n\t* config/ia64/ia64.c (ia64_split_tmode, ia64_split_tmode_move):\n\tRewrite to use POST_INC/POST_DEC/POST_MODIFY instead of a\n\tscratch pointer.\n\t(ia64_secondary_reload_class): Delete case GR_REGS.\n\t* config/ia64/ia64.md (movti, *movti_internal, movtf, *movtf_internal):\n\tDo not allocate a scratch register.\n\t(reload_inti, reload_outti, reload_intf, reload_outtf): Delete.\n\nFrom-SVN: r76798", "tree": {"sha": "644ba2035c9037222b188c3b55de2b75a1f61010", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/644ba2035c9037222b188c3b55de2b75a1f61010"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/comments", "author": null, "committer": null, "parents": [{"sha": "f15f99a14e78da7a517a470e502d5d695dfe4ef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15f99a14e78da7a517a470e502d5d695dfe4ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15f99a14e78da7a517a470e502d5d695dfe4ef3"}], "stats": {"total": 326, "additions": 196, "deletions": 130}, "files": [{"sha": "9238255e2ffda412dff8b6afe4198d63ea185258", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "patch": "@@ -1,3 +1,14 @@\n+2004-01-28  Zack Weinberg  <zack@codesourcery.com>\n+\t    Jim Wilson  <wilson@specifixinc.com>\n+\n+\t* config/ia64/ia64.c (ia64_split_tmode, ia64_split_tmode_move):\n+\tRewrite to use POST_INC/POST_DEC/POST_MODIFY instead of a\n+\tscratch pointer.\n+\t(ia64_secondary_reload_class): Delete case GR_REGS.\n+\t* config/ia64/ia64.md (movti, *movti_internal, movtf, *movtf_internal):\n+\tDo not allocate a scratch register.\n+\t(reload_inti, reload_outti, reload_intf, reload_outtf): Delete.\n+\n 2004-01-28  Jan Hubicka  <jh@suse.cz>\n \n \t* gcse.c (bypass_block): Prevent edges to be unified when we are\n@@ -43,7 +54,7 @@\n \t* config/s390/s390.h (TARGET_DEFAULT): Default to !TARGET_BACKCHAIN.\n \t* config/s390/s390.c (s390_return_addr_rtx): Fail for all but current\n \tframe if !TARGET_BACKCHAIN.\n-\t* config/s390/s390.md (\"allocate_stack\"): Use pattern only if \n+\t* config/s390/s390.md (\"allocate_stack\"): Use pattern only if\n \tTARGET_BACKCHAIN.\n \t* doc/invoke.texi (-mbackchain/-mno-backchain): Document new default.\n "}, {"sha": "12b563faadb23b31a795858ff5b0a28c4476d248", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 174, "deletions": 88, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "patch": "@@ -1395,62 +1395,37 @@ ia64_emit_cond_move (rtx op0, rtx op1, rtx cond)\n }\n \n /* Split a post-reload TImode or TFmode reference into two DImode\n-   components.  */\n+   components.  This is made extra difficult by the fact that we do\n+   not get any scratch registers to work with, because reload cannot\n+   be prevented from giving us a scratch that overlaps the register\n+   pair involved.  So instead, when addressing memory, we tweak the\n+   pointer register up and back down with POST_INCs.  Or up and not\n+   back down when we can get away with it.\n+\n+   REVERSED is true when the loads must be done in reversed order\n+   (high word first) for correctness.  DEAD is true when the pointer\n+   dies with the second insn we generate and therefore the second\n+   address must not carry a postmodify.\n+\n+   May return an insn which is to be emitted after the moves.  */\n \n static rtx\n-ia64_split_tmode (rtx out[2], rtx in, rtx scratch)\n+ia64_split_tmode (rtx out[2], rtx in, bool reversed, bool dead)\n {\n+  rtx fixup = 0;\n+\n   switch (GET_CODE (in))\n     {\n     case REG:\n-      out[0] = gen_rtx_REG (DImode, REGNO (in));\n-      out[1] = gen_rtx_REG (DImode, REGNO (in) + 1);\n-      return NULL_RTX;\n-\n-    case MEM:\n-      {\n-\trtx base = XEXP (in, 0);\n-\n-\tswitch (GET_CODE (base))\n-\t  {\n-\t  case REG:\n-\t    out[0] = adjust_address (in, DImode, 0);\n-\t    break;\n-\t  case POST_MODIFY:\n-\t    base = XEXP (base, 0);\n-\t    out[0] = adjust_address (in, DImode, 0);\n-\t    break;\n-\n-\t  /* Since we're changing the mode, we need to change to POST_MODIFY\n-\t     as well to preserve the size of the increment.  Either that or\n-\t     do the update in two steps, but we've already got this scratch\n-\t     register handy so let's use it.  */\n-\t  case POST_INC:\n-\t    base = XEXP (base, 0);\n-\t    out[0]\n-\t      = change_address (in, DImode,\n-\t\t\t\tgen_rtx_POST_MODIFY\n-\t\t\t\t(Pmode, base, plus_constant (base, 16)));\n-\t    break;\n-\t  case POST_DEC:\n-\t    base = XEXP (base, 0);\n-\t    out[0]\n-\t      = change_address (in, DImode,\n-\t\t\t\tgen_rtx_POST_MODIFY\n-\t\t\t\t(Pmode, base, plus_constant (base, -16)));\n-\t    break;\n-\t  default:\n-\t    abort ();\n-\t  }\n-\n-\tif (scratch == NULL_RTX)\n-\t  abort ();\n-\tout[1] = change_address (in, DImode, scratch);\n-\treturn gen_adddi3 (scratch, base, GEN_INT (8));\n-      }\n+      out[reversed] = gen_rtx_REG (DImode, REGNO (in));\n+      out[!reversed] = gen_rtx_REG (DImode, REGNO (in) + 1);\n+      break;\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n+      /* Cannot occur reversed.  */\n+      if (reversed) abort ();\n+      \n       if (GET_MODE (in) != TFmode)\n \tsplit_double (in, &out[0], &out[1]);\n       else\n@@ -1477,51 +1452,169 @@ ia64_split_tmode (rtx out[2], rtx in, rtx scratch)\n \t  out[0] = GEN_INT (p[0]);\n \t  out[1] = GEN_INT (p[1]);\n \t}\n-      return NULL_RTX;\n+      break;\n+\n+    case MEM:\n+      {\n+\trtx base = XEXP (in, 0);\n+\trtx offset;\n+\n+\tswitch (GET_CODE (base))\n+\t  {\n+\t  case REG:\n+\t    if (!reversed)\n+\t      {\n+\t\tout[0] = adjust_automodify_address\n+\t\t  (in, DImode, gen_rtx_POST_INC (Pmode, base), 0);\n+\t\tout[1] = adjust_automodify_address\n+\t\t  (in, DImode, dead ? 0 : gen_rtx_POST_DEC (Pmode, base), 8);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Reversal requires a pre-increment, which can only\n+\t\t   be done as a separate insn.  */\n+\t\temit_insn (gen_adddi3 (base, base, GEN_INT (8)));\n+\t\tout[0] = adjust_automodify_address\n+\t\t  (in, DImode, gen_rtx_POST_DEC (Pmode, base), 8);\n+\t\tout[1] = adjust_address (in, DImode, 0);\n+\t      }\n+\t    break;\n+\n+\t  case POST_INC:\n+\t    if (reversed || dead) abort ();\n+\t    /* Just do the increment in two steps.  */\n+\t    out[0] = adjust_automodify_address (in, DImode, 0, 0);\n+\t    out[1] = adjust_automodify_address (in, DImode, 0, 8);\n+\t    break;\n+\n+\t  case POST_DEC:\n+\t    if (reversed || dead) abort ();\n+\t    /* Add 8, subtract 24.  */\n+\t    base = XEXP (base, 0);\n+\t    out[0] = adjust_automodify_address\n+\t      (in, DImode, gen_rtx_POST_INC (Pmode, base), 0);\n+\t    out[1] = adjust_automodify_address\n+\t      (in, DImode,\n+\t       gen_rtx_POST_MODIFY (Pmode, base, plus_constant (base, -24)),\n+\t       8);\n+\t    break;\n+\n+\t  case POST_MODIFY:\n+\t    if (reversed || dead) abort ();\n+\t    /* Extract and adjust the modification.  This case is\n+\t       trickier than the others, because we might have an\n+\t       index register, or we might have a combined offset that\n+\t       doesn't fit a signed 9-bit displacement field.  We can\n+\t       assume the incoming expression is already legitimate.  */\n+\t    offset = XEXP (base, 1);\n+\t    base = XEXP (base, 0);\n+\n+\t    out[0] = adjust_automodify_address\n+\t      (in, DImode, gen_rtx_POST_INC (Pmode, base), 0);\n+\n+\t    if (GET_CODE (XEXP (offset, 1)) == REG)\n+\t      {\n+\t\t/* Can't adjust the postmodify to match.  Emit the\n+\t\t   original, then a separate addition insn.  */\n+\t\tout[1] = adjust_automodify_address (in, DImode, 0, 8);\n+\t\tfixup = gen_adddi3 (base, base, GEN_INT (-8));\n+\t      }\n+\t    else if (GET_CODE (XEXP (offset, 1)) != CONST_INT)\n+\t      abort ();\n+\t    else if (INTVAL (XEXP (offset, 1)) < -256 + 8)\n+\t      {\n+\t\t/* Again the postmodify cannot be made to match, but\n+\t\t   in this case it's more efficient to get rid of the\n+\t\t   postmodify entirely and fix up with an add insn. */\n+\t\tout[1] = adjust_automodify_address (in, DImode, base, 8);\n+\t\tfixup = gen_adddi3 (base, base,\n+\t\t\t\t    GEN_INT (INTVAL (XEXP (offset, 1)) - 8));\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Combined offset still fits in the displacement field.\n+\t\t   (We cannot overflow it at the high end.)  */\n+\t\tout[1] = adjust_automodify_address\n+\t\t  (in, DImode,\n+\t\t   gen_rtx_POST_MODIFY (Pmode, base,\n+\t\t     gen_rtx_PLUS (Pmode, base,\n+\t\t\t\t   GEN_INT (INTVAL (XEXP (offset, 1)) - 8))),\n+\t\t   8);\n+\t      }\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+\tbreak;\n+      }\n \n     default:\n       abort ();\n     }\n+\n+  return fixup;\n }\n \n /* Split a TImode or TFmode move instruction after reload.\n    This is used by *movtf_internal and *movti_internal.  */\n void\n ia64_split_tmode_move (rtx operands[])\n {\n-  rtx adj1, adj2, in[2], out[2], insn;\n-  int first;\n-\n-  adj1 = ia64_split_tmode (in, operands[1], operands[2]);\n-  adj2 = ia64_split_tmode (out, operands[0], operands[2]);\n-\n-  first = 0;\n-  if (reg_overlap_mentioned_p (out[0], in[1]))\n-    {\n-      if (reg_overlap_mentioned_p (out[1], in[0]))\n-\tabort ();\n-      first = 1;\n-    }\n-\n-  if (adj1 && adj2)\n-    abort ();\n-  if (adj1)\n-    emit_insn (adj1);\n-  if (adj2)\n-    emit_insn (adj2);\n-  insn = emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));\n-  if (GET_CODE (out[first]) == MEM\n-      && GET_CODE (XEXP (out[first], 0)) == POST_MODIFY)\n-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t  XEXP (XEXP (out[first], 0), 0),\n-\t\t\t\t\t  REG_NOTES (insn));\n-  insn = emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));\n-  if (GET_CODE (out[!first]) == MEM\n-      && GET_CODE (XEXP (out[!first], 0)) == POST_MODIFY)\n-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t  XEXP (XEXP (out[!first], 0), 0),\n-\t\t\t\t\t  REG_NOTES (insn));\n-\n+  rtx in[2], out[2], insn;\n+  rtx fixup[2];\n+  bool dead = false;\n+  bool reversed = false;\n+\n+  /* It is possible for reload to decide to overwrite a pointer with\n+     the value it points to.  In that case we have to do the loads in\n+     the appropriate order so that the pointer is not destroyed too\n+     early.  Also we must not generate a postmodify for that second\n+     load, or rws_access_regno will abort.  */\n+  if (GET_CODE (operands[1]) == MEM\n+      && reg_overlap_mentioned_p (operands[0], operands[1]))\n+    {\n+      rtx base = XEXP (operands[1], 0);\n+      while (GET_CODE (base) != REG)\n+\tbase = XEXP (base, 0);\n+\n+      if (REGNO (base) == REGNO (operands[0]))\n+\treversed = true;\n+      dead = true;\n+    }\n+  /* Another reason to do the moves in reversed order is if the first\n+     element of the target register pair is also the second element of\n+     the source register pair.  */\n+  if (GET_CODE (operands[0]) == REG && GET_CODE (operands[1]) == REG\n+      && REGNO (operands[0]) == REGNO (operands[1]) + 1)\n+    reversed = true;\n+\n+  fixup[0] = ia64_split_tmode (in, operands[1], reversed, dead);\n+  fixup[1] = ia64_split_tmode (out, operands[0], reversed, dead);\n+\n+#define MAYBE_ADD_REG_INC_NOTE(INSN, EXP)\t\t\t\t\\\n+  if (GET_CODE (EXP) == MEM\t\t\t\t\t\t\\\n+      && (GET_CODE (XEXP (EXP, 0)) == POST_MODIFY\t\t\t\\\n+\t  || GET_CODE (XEXP (EXP, 0)) == POST_INC\t\t\t\\\n+\t  || GET_CODE (XEXP (EXP, 0)) == POST_DEC))\t\t\t\\\n+    REG_NOTES (INSN) = gen_rtx_EXPR_LIST (REG_INC,\t\t\t\\\n+\t\t\t\t\t  XEXP (XEXP (EXP, 0), 0),\t\\\n+\t\t\t\t\t  REG_NOTES (INSN))\n+\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, out[0], in[0]));\n+  MAYBE_ADD_REG_INC_NOTE (insn, in[0]);\n+  MAYBE_ADD_REG_INC_NOTE (insn, out[0]);\n+\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, out[1], in[1]));\n+  MAYBE_ADD_REG_INC_NOTE (insn, in[1]);\n+  MAYBE_ADD_REG_INC_NOTE (insn, out[1]);\n+\n+  if (fixup[0])\n+    emit_insn (fixup[0]);\n+  if (fixup[1])\n+    emit_insn (fixup[1]);\n+\n+#undef MAYBE_ADD_REG_INC_NOTE\n }\n \n /* ??? Fixing GR->FR XFmode moves during reload is hard.  You need to go\n@@ -4492,13 +4585,6 @@ ia64_secondary_reload_class (enum reg_class class,\n \treturn GR_REGS;\n       break;\n \n-    case GR_REGS:\n-      /* Since we have no offsettable memory addresses, we need a temporary\n-\t to hold the address of the second word.  */\n-      if (mode == TImode || mode == TFmode)\n-\treturn GR_REGS;\n-      break;\n-\n     default:\n       break;\n     }"}, {"sha": "2713eb624aa6b52548b35c529006cd7947259f8d", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=2ffe0e02414c7ddcd4f4ee4c2e5bf64c2a5ef8c6", "patch": "@@ -584,11 +584,12 @@\n   [(set_attr \"itanium_class\" \"ialu\")])\n \n ;; With no offsettable memory references, we've got to have a scratch\n-;; around to play with the second word.\n+;; around to play with the second word.  However, in order to avoid a\n+;; reload nightmare we lie, claim we don't need one, and fix it up\n+;; in ia64_split_tmode_move.\n (define_expand \"movti\"\n-  [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n-\t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n-\t      (clobber (match_scratch:DI 2 \"\"))])]\n+  [(set (match_operand:TI 0 \"general_operand\" \"\")\n+\t(match_operand:TI 1 \"general_operand\" \"\"))]\n   \"\"\n {\n   rtx op1 = ia64_expand_move (operands[0], operands[1]);\n@@ -599,8 +600,7 @@\n \n (define_insn_and_split \"*movti_internal\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:TI 1 \"general_operand\"      \"ri,m,r\"))\n-   (clobber (match_scratch:DI 2 \"=X,&r,&r\"))]\n+\t(match_operand:TI 1 \"general_operand\"      \"ri,m,r\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n   \"#\"\n   \"reload_completed\"\n@@ -612,20 +612,6 @@\n   [(set_attr \"itanium_class\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_expand \"reload_inti\"\n-  [(parallel [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:TI 1 \"memory_operand\" \"m\"))\n-\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_outti\"\n-  [(parallel [(set (match_operand:TI 0 \"memory_operand\" \"=m\")\n-\t\t   (match_operand:TI 1 \"register_operand\" \"r\"))\n-\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n-  \"\"\n-  \"\")\n-\n ;; Floating Point Moves\n ;;\n ;; Note - Patterns for SF mode moves are compulsory, but\n@@ -764,13 +750,10 @@\n   [(set_attr \"itanium_class\" \"fmisc,fld,stf\")])\n \n ;; Better code generation via insns that deal with TFmode register pairs\n-;; directly.\n-;; With no offsettable memory references, we've got to have a scratch\n-;; around to play with the second word.\n+;; directly.  Same concerns apply as for TImode.\n (define_expand \"movtf\"\n-  [(parallel [(set (match_operand:TF 0 \"general_operand\" \"\")\n-\t\t   (match_operand:TF 1 \"general_operand\" \"\"))\n-\t      (clobber (match_scratch:DI 2 \"\"))])]\n+  [(set (match_operand:TF 0 \"general_operand\" \"\")\n+\t(match_operand:TF 1 \"general_operand\" \"\"))]\n   \"\"\n {\n   rtx op1 = ia64_expand_move (operands[0], operands[1]);\n@@ -781,8 +764,7 @@\n \n (define_insn_and_split \"*movtf_internal\"\n   [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:TF 1 \"general_operand\"      \"ri,m,r\"))\n-   (clobber (match_scratch:DI 2 \"=X,&r,&r\"))]\n+\t(match_operand:TF 1 \"general_operand\"      \"ri,m,r\"))]\n   \"ia64_move_ok (operands[0], operands[1])\"\n   \"#\"\n   \"reload_completed\"\n@@ -794,19 +776,6 @@\n   [(set_attr \"itanium_class\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n-(define_expand \"reload_intf\"\n-  [(parallel [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:TF 1 \"memory_operand\" \"m\"))\n-\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"reload_outtf\"\n-  [(parallel [(set (match_operand:TF 0 \"memory_operand\" \"=m\")\n-\t\t   (match_operand:TF 1 \"register_operand\" \"r\"))\n-\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n-  \"\"\n-  \"\")\n \f\n ;; ::::::::::::::::::::\n ;; ::"}]}