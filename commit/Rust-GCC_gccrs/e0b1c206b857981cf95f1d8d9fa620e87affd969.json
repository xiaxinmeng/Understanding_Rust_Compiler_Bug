{"sha": "e0b1c206b857981cf95f1d8d9fa620e87affd969", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBiMWMyMDZiODU3OTgxY2Y5NWYxZDhkOWZhNjIwZTg3YWZmZDk2OQ==", "commit": {"author": {"name": "Eric Blake", "email": "ebb9@email.byu.edu", "date": "2002-03-12T03:45:57Z"}, "committer": {"name": "Eric Blake", "email": "ericb@gcc.gnu.org", "date": "2002-03-12T03:45:57Z"}, "message": "re PR java/5902 (Gcj fails to parse float)\n\n2002-03-11  Eric Blake  <ebb9@email.byu.edu>\n\n\t* lex.c: Adjust comments to GNU standards.\n\n2002-03-11  Eric Blake  <ebb9@email.byu.edu>\n\n\tFix for PR java/5902:\n\t* lex.c (java_lex): Fix parsing of literals.\n\nFrom-SVN: r50630", "tree": {"sha": "e70c2204bc5e3a11e5cdb57cb347bb4ac82dfce9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e70c2204bc5e3a11e5cdb57cb347bb4ac82dfce9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0b1c206b857981cf95f1d8d9fa620e87affd969", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b1c206b857981cf95f1d8d9fa620e87affd969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b1c206b857981cf95f1d8d9fa620e87affd969", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b1c206b857981cf95f1d8d9fa620e87affd969/comments", "author": null, "committer": null, "parents": [{"sha": "44d3eb5b564683bbbbddbc1fc934ae996f0df2d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44d3eb5b564683bbbbddbc1fc934ae996f0df2d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44d3eb5b564683bbbbddbc1fc934ae996f0df2d6"}], "stats": {"total": 159, "additions": 84, "deletions": 75}, "files": [{"sha": "15b7bb2d864851ddcf70f900592699fac8a9246e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b1c206b857981cf95f1d8d9fa620e87affd969/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b1c206b857981cf95f1d8d9fa620e87affd969/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=e0b1c206b857981cf95f1d8d9fa620e87affd969", "patch": "@@ -1,3 +1,12 @@\n+2002-03-11  Eric Blake  <ebb9@email.byu.edu>\n+\n+\t* lex.c: Adjust comments to GNU standards.\n+\n+2002-03-11  Eric Blake  <ebb9@email.byu.edu>\n+\n+\tFix for PR java/5902:\n+\t* lex.c (java_lex): Fix parsing of literals.\n+\n 2002-03-11  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n \n \t* parse.y (patch_assignment): Wrap the right-hand-side with a save_expr"}, {"sha": "4f7f8f7691670413488fc9c3f627932a9de70319", "filename": "gcc/java/lex.c", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0b1c206b857981cf95f1d8d9fa620e87affd969/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0b1c206b857981cf95f1d8d9fa620e87affd969/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=e0b1c206b857981cf95f1d8d9fa620e87affd969", "patch": "@@ -1,5 +1,5 @@\n /* Language lexer for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n This file is part of GNU CC.\n@@ -38,7 +38,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"flags.h\"\n #include \"chartables.h\"\n \n-/* Function declaration  */\n+/* Function declarations.  */\n static char *java_sprint_unicode PARAMS ((struct java_line *, int));\n static void java_unicode_2_utf8 PARAMS ((unicode_t));\n static void java_lex_error PARAMS ((const char *, int));\n@@ -191,7 +191,7 @@ java_allocate_new_line ()\n \t  free (ctxp->p_line);\n \t}\n       ctxp->p_line = ctxp->c_line;\n-      ctxp->c_line = NULL;\t\t/* Reallocated */\n+      ctxp->c_line = NULL;\t\t/* Reallocated.  */\n     }\n \n   if (!ctxp->c_line)\n@@ -606,7 +606,7 @@ java_read_unicode_collapsing_terminators (lex, unicode_escape_p)\n static int\n java_get_unicode ()\n {\n-  /* It's time to read a line when... */\n+  /* It's time to read a line when...  */\n   if (!ctxp->c_line || ctxp->c_line->current == ctxp->c_line->size)\n     {\n       int c;\n@@ -649,7 +649,7 @@ java_get_unicode ()\n }\n \n /* Parse the end of a C style comment.\n- * C is the first character following the '/' and '*'. */\n+ * C is the first character following the '/' and '*'.  */\n static void\n java_parse_end_comment (c)\n      int c;\n@@ -669,7 +669,7 @@ java_parse_end_comment (c)\n \t      return;\n \t    case '/':\n \t      return;\n-\t    case '*':\t/* reparse only '*' */\n+\t    case '*':\t/* Reparse only '*'.  */\n \t      java_unget_unicode ();\n \t    }\n \t}\n@@ -705,9 +705,9 @@ java_parse_doc_section (c)\n     java_lex_error (\"Comment not terminated at end of input\", 0);\n \n   if (seen_star && (c == '/'))\n-    return 1;\t\t\t/* Goto step1 in caller */\n+    return 1;\t\t\t/* Goto step1 in caller.  */\n \n-  /* We're parsing @deprecated */\n+  /* We're parsing `@deprecated'.  */\n   if (valid_tag && (c == '@'))\n     {\n       char tag [11];\n@@ -910,7 +910,7 @@ java_lex (java_lval)\n   /* Translation of the Unicode escape in the raw stream of Unicode\n      characters. Takes care of line terminator.  */\n  step1:\n-  /* Skip white spaces: SP, TAB and FF or ULT */ \n+  /* Skip white spaces: SP, TAB and FF or ULT.  */ \n   for (c = java_get_unicode ();\n        c == '\\n' || JAVA_WHITE_SPACE_P (c); c = java_get_unicode ())\n     if (c == '\\n')\n@@ -921,15 +921,16 @@ java_lex (java_lval)\n \n   ctxp->elc.col = (ctxp->elc.col < 0 ? 0 : ctxp->elc.col);\n \n-  if (c == 0x1a)\t\t/* CTRL-Z */\n+  if (c == 0x1a)\t\t/* CTRL-Z.  */\n     {\n       if ((c = java_get_unicode ()) == UEOF)\n-\treturn 0;\t\t/* Ok here */\n+\treturn 0;\t\t/* Ok here.  */\n       else\n-\tjava_unget_unicode ();\t/* Caught later, at the end of the function */\n+\tjava_unget_unicode ();\t/* Caught later, at the end of the\n+                                   function.  */\n     }\n-  /* Handle EOF here */\n-  if (c == UEOF)\t/* Should probably do something here... */\n+  /* Handle EOF here.  */\n+  if (c == UEOF)\t/* Should probably do something here...  */\n     return 0;\n \n   /* Take care of eventual comments.  */\n@@ -959,7 +960,7 @@ java_lex (java_lval)\n \t  if ((c = java_get_unicode ()) == '*')\n \t    {\n \t      if ((c = java_get_unicode ()) == '/')\n-\t\tgoto step1;\t/* Empy documentation comment  */\n+\t\tgoto step1;\t/* Empty documentation comment.  */\n \t      else if (java_parse_doc_section (c))\n \t\tgoto step1;\n \t    }\n@@ -980,24 +981,24 @@ java_lex (java_lval)\n   if (ctxp->elc.col < 0)\n     abort ();\n \n-  /* Numeric literals */\n+  /* Numeric literals.  */\n   if (JAVA_ASCII_DIGIT (c) || (c == '.'))\n     {\n-      /* This section of code is borrowed from gcc/c-lex.c  */\n+      /* This section of code is borrowed from gcc/c-lex.c.  */\n #define TOTAL_PARTS ((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)\n       int parts[TOTAL_PARTS];\n       HOST_WIDE_INT high, low;\n-      /* End borrowed section  */\n+      /* End borrowed section.  */\n       char literal_token [256];\n       int  literal_index = 0, radix = 10, long_suffix = 0, overflow = 0, bytes;\n-      int  found_hex_digits = 0;\n+      int  found_hex_digits = 0, found_non_octal_digits = 0;\n       int  i;\n #ifndef JC1_LITE\n       int  number_beginning = ctxp->c_line->current;\n       tree value;\n #endif\n       \n-      /* We might have a . separator instead of a FP like .[0-9]* */\n+      /* We might have a . separator instead of a FP like .[0-9]*.  */\n       if (c == '.')\n \t{\n \t  unicode_t peep = java_sneak_unicode ();\n@@ -1024,13 +1025,13 @@ java_lex (java_lval)\n \t    radix = 8;\n \t  else if (c == '.')\n \t    {\n-\t      /* Push the '.' back and prepare for a FP parsing... */\n+\t      /* Push the '.' back and prepare for a FP parsing...  */\n \t      java_unget_unicode ();\n \t      c = '0';\n \t    }\n \t  else\n \t    {\n-\t      /* We have a zero literal: 0, 0{f,F}, 0{d,D} */\n+\t      /* We have a zero literal: 0, 0{l,L}, 0{f,F}, 0{d,D}.  */\n \t      JAVA_LEX_LIT (\"0\", 10);\n               switch (c)\n \t\t{\t\t\n@@ -1052,21 +1053,23 @@ java_lex (java_lval)\n \t}\n       /* Parse the first part of the literal, until we find something\n \t which is not a number.  */\n-      while ((radix == 10 && JAVA_ASCII_DIGIT (c)) ||\n-\t     (radix == 16 && JAVA_ASCII_HEXDIGIT (c)) ||\n-\t     (radix == 8  && JAVA_ASCII_OCTDIGIT (c)))\n+      while ((radix == 16 && JAVA_ASCII_HEXDIGIT (c)) ||\n+\t     JAVA_ASCII_DIGIT (c))\n \t{\n \t  /* We store in a string (in case it turns out to be a FP) and in\n \t     PARTS if we have to process a integer literal.  */\n \t  int numeric = hex_value (c);\n \t  int count;\n \n-\t  /* Remember when we find a valid hexadecimal digit */\n+\t  /* Remember when we find a valid hexadecimal digit.  */\n \t  if (radix == 16)\n \t    found_hex_digits = 1;\n+          /* Remember when we find an invalid octal digit.  */\n+          else if (radix == 8 && !JAVA_ASCII_OCTDIGIT (c))\n+            found_non_octal_digits = 1;\n \n \t  literal_token [literal_index++] = c;\n-\t  /* This section of code if borrowed from gcc/c-lex.c  */\n+\t  /* This section of code if borrowed from gcc/c-lex.c.  */\n \t  for (count = 0; count < TOTAL_PARTS; count++)\n \t    {\n \t      parts[count] *= radix;\n@@ -1092,7 +1095,7 @@ java_lex (java_lval)\n \t  int seen_digit = (literal_index ? 1 : 0);\n \t  int seen_exponent = 0;\n \t  int fflag = 0;\t/* 1 for {f,F}, 0 for {d,D}. FP literal are\n-\t\t\t\t   double unless specified. */\n+\t\t\t\t   double unless specified.  */\n \n \t  /* It is ok if the radix is 8 because this just means we've\n \t     seen a leading `0'.  However, radix==16 is invalid.  */\n@@ -1118,9 +1121,10 @@ java_lex (java_lval)\n \t\t{\n \t\t  if (stage < 2)\n \t\t    {\n-\t\t      /* {E,e} must have seen at list a digit */\n+\t\t      /* {E,e} must have seen at least a digit.  */\n \t\t      if (!seen_digit)\n-\t\t\tjava_lex_error (\"Invalid FP literal\", 0);\n+\t\t\tjava_lex_error\n+                          (\"Invalid FP literal, mantissa must have digit\", 0);\n \t\t      seen_digit = 0;\n \t\t      seen_exponent = 1;\n \t\t      stage = 2;\n@@ -1133,7 +1137,7 @@ java_lex (java_lval)\n \t      if ( c == 'f' || c == 'F' || c == 'd' || c == 'D')\n \t\t{\n \t\t  fflag = ((c == 'd') || (c == 'D')) ? 0 : 1;\n-\t\t  stage = 4;\t/* So we fall through */\n+\t\t  stage = 4;\t/* So we fall through.  */\n \t\t}\n \n \t      if ((c=='-' || c =='+') && stage == 2)\n@@ -1158,12 +1162,13 @@ java_lex (java_lval)\n #ifndef JC1_LITE\n \t\t  struct jpa_args a;\n #endif\n-\t\t  if (stage != 4) /* Don't push back fF/dD */\n+\t\t  if (stage != 4) /* Don't push back fF/dD.  */\n \t\t    java_unget_unicode ();\n \t\t  \n \t\t  /* An exponent (if any) must have seen a digit.  */\n \t\t  if (seen_exponent && !seen_digit)\n-\t\t    java_lex_error (\"Invalid FP literal\", 0);\n+\t\t    java_lex_error\n+                      (\"Invalid FP literal, exponent must have digit\", 0);\n \n \t\t  literal_token [literal_index] = '\\0';\n \t\t  JAVA_LEX_LIT (literal_token, radix);\n@@ -1182,29 +1187,24 @@ java_lex (java_lval)\n #endif\n \t\t}\n \t    }\n-\t} /* JAVA_ASCCI_FPCHAR (c) */\n+\t} /* JAVA_ASCII_FPCHAR (c) */\n \n+      /* Here we get back to converting the integral literal.  */\n       if (radix == 16 && ! found_hex_digits)\n \tjava_lex_error\n \t  (\"0x must be followed by at least one hexadecimal digit\", 0);\n-\n-      /* Here we get back to converting the integral literal.  */\n-      if (c == 'L' || c == 'l')\n+      else if (radix == 8 && found_non_octal_digits)\n+\tjava_lex_error (\"Octal literal contains digit out of range\", 0);\n+      else if (c == 'L' || c == 'l')\n \tlong_suffix = 1;\n-      else if (radix == 16 && JAVA_ASCII_LETTER (c))\n-\tjava_lex_error (\"Digit out of range in hexadecimal literal\", 0);\n-      else if (radix == 8  && JAVA_ASCII_DIGIT (c))\n-\tjava_lex_error (\"Digit out of range in octal literal\", 0);\n-      else if (radix == 16 && !literal_index)\n-\tjava_lex_error (\"No digit specified for hexadecimal literal\", 0);\n       else\n \tjava_unget_unicode ();\n \n #ifdef JAVA_LEX_DEBUG\n-      literal_token [literal_index] = '\\0'; /* So JAVA_LEX_LIT is safe. */\n+      literal_token [literal_index] = '\\0'; /* So JAVA_LEX_LIT is safe.  */\n       JAVA_LEX_LIT (literal_token, radix);\n #endif\n-      /* This section of code is borrowed from gcc/c-lex.c  */\n+      /* This section of code is borrowed from gcc/c-lex.c.  */\n       if (!overflow)\n \t{\n \t  bytes = GET_TYPE_PRECISION (long_type_node);\n@@ -1225,13 +1225,13 @@ java_lex (java_lval)\n \t}\n       /* End borrowed section.  */\n \n-      /* Range checking */\n+      /* Range checking.  */\n       if (long_suffix)\n \t{\n \t  /* 9223372036854775808L is valid if operand of a '-'. Otherwise\n \t     9223372036854775807L is the biggest `long' literal that can be\n-\t     expressed using a 10 radix. For other radixes, everything that\n-\t     fits withing 64 bits is OK. */\n+\t     expressed using a 10 radix. For other radices, everything that\n+\t     fits withing 64 bits is OK.  */\n \t  int hb = (high >> 31);\n \t  if (overflow || (hb && low && radix == 10)\n \t      || (hb && high & 0x7fffffff && radix == 10))\n@@ -1241,9 +1241,9 @@ java_lex (java_lval)\n \t{\n \t  /* 2147483648 is valid if operand of a '-'. Otherwise,\n \t     2147483647 is the biggest `int' literal that can be\n-\t     expressed using a 10 radix. For other radixes, everything\n+\t     expressed using a 10 radix. For other radices, everything\n \t     that fits within 32 bits is OK.  As all literals are\n-\t     signed, we sign extend here. */\n+\t     signed, we sign extend here.  */\n \t  int hb = (low >> 31) & 0x1;\n \t  if (overflow || high || (hb && low & 0x7fffffff && radix == 10))\n \t    JAVA_INTEGRAL_RANGE_ERROR (\"Numeric overflow for `int' literal\");\n@@ -1260,7 +1260,7 @@ java_lex (java_lval)\n       return INT_LIT_TK;\n     }\n \n-  /* Character literals */\n+  /* Character literals.  */\n   if (c == '\\'')\n     {\n       int char_lit;\n@@ -1281,14 +1281,14 @@ java_lex (java_lval)\n \tjava_lex_error (\"Syntax error in character literal\", 0);\n \n       if (char_lit == JAVA_CHAR_ERROR)\n-        char_lit = 0;\t\t/* We silently convert it to zero */\n+        char_lit = 0;\t\t/* We silently convert it to zero.  */\n \n       JAVA_LEX_CHAR_LIT (char_lit);\n       SET_LVAL_NODE_TYPE (build_int_2 (char_lit, 0), char_type_node);\n       return CHAR_LIT_TK;\n     }\n \n-  /* String literals */\n+  /* String literals.  */\n   if (c == '\"')\n     {\n       int no_error;\n@@ -1306,9 +1306,9 @@ java_lex (java_lval)\n \t    }\n \t  java_unicode_2_utf8 (c);\n \t}\n-      if (c == '\\n' || c == UEOF) /* ULT */\n+      if (c == '\\n' || c == UEOF) /* ULT.  */\n \t{\n-\t  lineno--;\t\t/* Refer to the line the terminator was seen */\n+\t  lineno--;\t/* Refer to the line where the terminator was seen.  */\n \t  java_lex_error (\"String not terminated at end of line\", 0);\n \t  lineno++;\n \t}\n@@ -1317,15 +1317,16 @@ java_lex (java_lval)\n       string = obstack_finish (&temporary_obstack);\n #ifndef JC1_LITE\n       if (!no_error || (c != '\"'))\n-\tjava_lval->node = error_mark_node; /* Requires futher testing FIXME */\n+\tjava_lval->node = error_mark_node; /* FIXME: Requires futher\n+                                              testing.  */\n       else\n \tjava_lval->node = build_string (strlen (string), string);\n #endif\n       obstack_free (&temporary_obstack, string);\n       return STRING_LIT_TK;\n     }\n \n-  /* Separator */\n+  /* Separator.  */\n   switch (c)\n     {\n     case '(':\n@@ -1364,7 +1365,7 @@ java_lex (java_lval)\n       /*      return DOT_TK; */\n     }\n \n-  /* Operators */\n+  /* Operators.  */\n   switch (c)\n     {\n     case '=':\n@@ -1544,7 +1545,7 @@ java_lex (java_lval)\n       BUILD_OPERATOR (NOT_TK);\n     }\n   \n-  /* Keyword, boolean literal or null literal */\n+  /* Keyword, boolean literal or null literal.  */\n   for (first_unicode = c, all_ascii = 1, ascii_index = 0; \n        JAVA_PART_CHAR_P (c); c = java_get_unicode ())\n     {\n@@ -1600,7 +1601,7 @@ java_lex (java_lval)\n \t      SET_LVAL_NODE (char_type_node);\n \t      return INTEGRAL_TK;\n \n-\t      /* Keyword based literals */\n+\t      /* Keyword based literals.  */\n \t    case TRUE_TK:\n \t    case FALSE_TK:\n \t      SET_LVAL_NODE ((kw->token == TRUE_TK ? \n@@ -1611,7 +1612,7 @@ java_lex (java_lval)\n \t      return NULL_TK;\n \n \t      /* Some keyword we want to retain information on the location\n-\t\t they where found */\n+\t\t they where found.  */\n \t    case CASE_TK:\n \t    case DEFAULT_TK:\n \t    case SUPER_TK:\n@@ -1631,15 +1632,15 @@ java_lex (java_lval)\n \t}\n     }\n   \n-  /* We may have an ID here */\n+  /* We may have an ID here.  */\n   if (JAVA_START_CHAR_P (first_unicode))\n     {\n       JAVA_LEX_ID (string);\n       java_lval->node = BUILD_ID_WFL (GET_IDENTIFIER (string));\n       return ID_TK;\n     }\n \n-  /* Everything else is an invalid character in the input */\n+  /* Everything else is an invalid character in the input.  */\n   {\n     char lex_error_buffer [128];\n     sprintf (lex_error_buffer, \"Invalid character `%s' in input\", \n@@ -1693,7 +1694,7 @@ java_unicode_2_utf8 (unicode)\n       obstack_1grow (&temporary_obstack,\n \t\t     (unsigned char)(0x80 | (unicode & 0x3f)));\n     }\n-  else\t\t\t\t/* Range 0x800-0xffff */\n+  else\t\t\t\t/* Range 0x800-0xffff.  */\n     {\n       obstack_1grow (&temporary_obstack,\n \t\t     (unsigned char)(0xe0 | (unicode & 0xf000) >> 12));\n@@ -1710,7 +1711,7 @@ build_wfl_node (node)\n      tree node;\n {\n   node = build_expr_wfl (node, ctxp->filename, ctxp->elc.line, ctxp->elc.col);\n-  /* Prevent java_complete_lhs from short-circuiting node (if constant). */\n+  /* Prevent java_complete_lhs from short-circuiting node (if constant).  */\n   TREE_TYPE (node) = NULL_TREE;\n   return node;\n }\n@@ -1725,7 +1726,7 @@ java_lex_error (msg, forward)\n   ctxp->elc.line = ctxp->c_line->lineno;\n   ctxp->elc.col = ctxp->c_line->char_col-1+forward;\n \n-  /* Might be caught in the middle of some error report */\n+  /* Might be caught in the middle of some error report.  */\n   ctxp->java_error_flag = 0;\n   java_error (NULL);\n   java_error (msg);\n@@ -1762,11 +1763,11 @@ java_get_line_col (filename, line, col)\n #ifdef JC1_LITE\n   return 0;\n #else\n-  /* Dumb implementation. Doesn't try to cache or optimize things. */\n-  /* First line of the file is line 1, first column is 1 */\n+  /* Dumb implementation. Doesn't try to cache or optimize things.  */\n+  /* First line of the file is line 1, first column is 1.  */\n \n-  /* COL == -1 means, at the CR/LF in LINE */\n-  /* COL == -2 means, at the first non space char in LINE */\n+  /* COL == -1 means, at the CR/LF in LINE.  */\n+  /* COL == -2 means, at the first non space char in LINE.  */\n \n   FILE *fp;\n   int c, ccol, cline = 1;\n@@ -1790,7 +1791,7 @@ java_get_line_col (filename, line, col)\n \tcline++;\n     }\n \n-  /* Gather the chars of the current line in a buffer */\n+  /* Gather the chars of the current line in a buffer.  */\n   for (;;)\n     {\n       c = getc (fp);\n@@ -1815,11 +1816,11 @@ java_get_line_col (filename, line, col)\n   else\n     first_non_space = 0;\n \n-  /* Place the '^' a the right position */\n+  /* Place the '^' a the right position.  */\n   base = obstack_base (&temporary_obstack);\n   for (ccol = 1; ccol <= col+3; ccol++)\n     {\n-      /* Compute \\t when reaching first_non_space */\n+      /* Compute \\t when reaching first_non_space.  */\n       char c = (first_non_space ?\n \t\t(base [ccol-1] == '\\t' ? '\\t' : ' ') : ' ');\n       obstack_1grow (&temporary_obstack, c);\n@@ -1984,8 +1985,7 @@ cxx_keyword_p (name, length)\n       if (r == 0)\n \t{\n \t  int i;\n-\t  /* We've found a match if all the remaining characters are\n-\t     `$'.  */\n+\t  /* We've found a match if all the remaining characters are `$'.  */\n \t  for (i = min_length; i < length && name[i] == '$'; ++i)\n \t    ;\n \t  if (i == length)"}]}