{"sha": "37ba33904d12e2988ca34171034d21c8943a9f91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiYTMzOTA0ZDEyZTI5ODhjYTM0MTcxMDM0ZDIxYzg5NDNhOWY5MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-23T22:45:25Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-23T22:45:25Z"}, "message": "Initial revision\n\nFrom-SVN: r129", "tree": {"sha": "8f4213142266ffce03365602f2e8c3b999460e41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f4213142266ffce03365602f2e8c3b999460e41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37ba33904d12e2988ca34171034d21c8943a9f91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ba33904d12e2988ca34171034d21c8943a9f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37ba33904d12e2988ca34171034d21c8943a9f91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37ba33904d12e2988ca34171034d21c8943a9f91/comments", "author": null, "committer": null, "parents": [{"sha": "1d21dbd39b6de887f890215adf3f6f0c242df2d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d21dbd39b6de887f890215adf3f6f0c242df2d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d21dbd39b6de887f890215adf3f6f0c242df2d3"}], "stats": {"total": 1356, "additions": 1356, "deletions": 0}, "files": [{"sha": "77bb95fc1442968bc5471f67100f77170db91f35", "filename": "gcc/sdbout.c", "status": "added", "additions": 1356, "deletions": 0, "changes": 1356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37ba33904d12e2988ca34171034d21c8943a9f91/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37ba33904d12e2988ca34171034d21c8943a9f91/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=37ba33904d12e2988ca34171034d21c8943a9f91", "patch": "@@ -0,0 +1,1356 @@\n+/* Output sdb-format symbol table information from GNU compiler.\n+   Copyright (C) 1988-1990 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/*  mike@tredysvr.Tredydev.Unisys.COM says:\n+I modified the struct.c example and have a nm of a .o resulting from the\n+AT&T C compiler.  From the example below I would conclude the following:\n+\n+1. All .defs from structures are emitted as scanned.  The example below\n+   clearly shows the symbol table entries for BoxRec2 are after the first\n+   function.\n+\n+2. All functions and their locals (including statics) are emitted as scanned.\n+\n+3. All nested unnamed union and structure .defs must be emitted before\n+   the structure in which they are nested.  The AT&T assembler is a\n+   one pass beast as far as symbolics are concerned.\n+\n+4. All structure .defs are emitted before the typedefs that refer to them.\n+\n+5. All top level static and external variable definitions are moved to the\n+   end of file with all top level statics occuring first before externs.\n+\n+6. All undefined references are at the end of the file.\n+*/\n+\n+#include \"config.h\"\n+\n+#ifdef SDB_DEBUGGING_INFO\n+\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include <stdio.h>\n+#include \"regs.h\"\n+#include \"flags.h\"\n+#include \"insn-config.h\"\n+#include \"reload.h\"\n+\n+/* Mips systems use the SDB functions to dump out it's symbols, but\n+   do not supply usable syms.h include files.  */\n+#if defined(USG) && !defined(MIPS)\n+#include <syms.h>\n+/* Use T_INT if we don't have T_VOID.  */\n+#ifndef T_VOID\n+#define T_VOID T_INT\n+#endif\n+#else /* not USG, or MIPS */\n+#include \"gsyms.h\"\n+#endif /* not USG, or MIPS */\n+\n+/* #include <storclass.h>  used to be this instead of syms.h.  */\n+\n+/* 1 if PARM is passed to this function in memory.  */\n+\n+#define PARM_PASSED_IN_MEMORY(PARM) \\\n+ (GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)\n+\n+/* A C expression for the integer offset value of an automatic variable\n+   (C_AUTO) having address X (an RTX).  */\n+#ifndef DEBUGGER_AUTO_OFFSET\n+#define DEBUGGER_AUTO_OFFSET(X) \\\n+  (GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)\n+#endif\n+\n+/* A C expression for the integer offset value of an argument (C_ARG)\n+   having address X (an RTX).  The nominal offset is OFFSET.  */\n+#ifndef DEBUGGER_ARG_OFFSET\n+#define DEBUGGER_ARG_OFFSET(OFFSET, X) (OFFSET)\n+#endif\n+\n+/* Line number of beginning of current function, minus one.\n+   Negative means not in a function or not using sdb.  */\n+\n+int sdb_begin_function_line = -1;\n+\n+/* Counter to generate unique \"names\" for nameless struct members.  */\n+\n+static int unnamed_struct_number = 0;\n+\n+extern FILE *asm_out_file;\n+\n+extern tree current_function_decl;\n+\n+void sdbout_init ();\n+void sdbout_symbol ();\n+void sdbout_types();\n+\n+static void sdbout_typedefs ();\n+static void sdbout_syms ();\n+static void sdbout_one_type ();\n+static void sdbout_queue_anonymous_type ();\n+static void sdbout_dequeue_anonymous_type ();\n+static int plain_type_1 ();\n+\f\n+/* Define the default sizes for various types.  */\n+\n+#ifndef CHAR_TYPE_SIZE\n+#define CHAR_TYPE_SIZE BITS_PER_UNIT\n+#endif\n+\n+#ifndef SHORT_TYPE_SIZE\n+#define SHORT_TYPE_SIZE (BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))\n+#endif\n+\n+#ifndef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef LONG_LONG_TYPE_SIZE\n+#define LONG_LONG_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef FLOAT_TYPE_SIZE\n+#define FLOAT_TYPE_SIZE BITS_PER_WORD\n+#endif\n+\n+#ifndef DOUBLE_TYPE_SIZE\n+#define DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\n+#ifndef LONG_DOUBLE_TYPE_SIZE\n+#define LONG_DOUBLE_TYPE_SIZE (BITS_PER_WORD * 2)\n+#endif\n+\f\n+/* Random macros describing parts of SDB data.  */\n+\n+/* Put something here if lines get too long */\n+#define CONTIN\n+\n+/* Default value of delimiter is \";\".  */\n+#ifndef SDB_DELIM\n+#define SDB_DELIM\t\";\"\n+#endif\n+\n+/* Maximum number of dimensions the assembler will allow.  */\n+#ifndef SDB_MAX_DIM\n+#define SDB_MAX_DIM 4\n+#endif\n+\n+#ifndef PUT_SDB_SCL\n+#define PUT_SDB_SCL(a) fprintf(asm_out_file, \"\\t.scl\\t%d%s\", (a), SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_INT_VAL\n+#define PUT_SDB_INT_VAL(a) fprintf (asm_out_file, \"\\t.val\\t%d%s\", (a), SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_VAL\n+#define PUT_SDB_VAL(a)\t\t\t\t\\\n+( fputs (\"\\t.val\\t\", asm_out_file),\t\t\\\n+  output_addr_const (asm_out_file, (a)),\t\\\n+  fprintf (asm_out_file, SDB_DELIM))\n+#endif\n+\n+#ifndef PUT_SDB_DEF\n+#define PUT_SDB_DEF(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\t.def\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a); \t\\\n+     fprintf (asm_out_file, SDB_DELIM); } while (0)\n+#endif\n+\n+#ifndef PUT_SDB_PLAIN_DEF\n+#define PUT_SDB_PLAIN_DEF(a) fprintf(asm_out_file,\"\\t.def\\t.%s%s\",a, SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_ENDEF\n+#define PUT_SDB_ENDEF fputs(\"\\t.endef\\n\", asm_out_file)\n+#endif\n+\n+#ifndef PUT_SDB_TYPE\n+#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\t.type\\t0%o%s\", a, SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_SIZE\n+#define PUT_SDB_SIZE(a) fprintf(asm_out_file, \"\\t.size\\t%d%s\", a, SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_START_DIM\n+#define PUT_SDB_START_DIM fprintf(asm_out_file, \"\\t.dim\\t\")\n+#endif\n+\n+#ifndef PUT_SDB_NEXT_DIM\n+#define PUT_SDB_NEXT_DIM(a) fprintf(asm_out_file, \"%d,\", a)\n+#endif\n+\n+#ifndef PUT_SDB_LAST_DIM\n+#define PUT_SDB_LAST_DIM(a) fprintf(asm_out_file, \"%d%s\", a, SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_TAG\n+#define PUT_SDB_TAG(a)\t\t\t\t\\\n+do { fprintf (asm_out_file, \"\\t.tag\\t\");\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, a);\t\\\n+     fprintf (asm_out_file, SDB_DELIM); } while (0)\n+#endif\n+\n+#ifndef PUT_SDB_BLOCK_START\n+#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.bb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_BLOCK_END\n+#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.eb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\",  \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_FUNCTION_START\n+#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.bf%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_FUNCTION_END\n+#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n+  fprintf (asm_out_file,\t\t\t\\\n+\t   \"\\t.def\\t.ef%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n+\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n+#endif\n+\n+#ifndef PUT_SDB_EPILOGUE_END\n+#define PUT_SDB_EPILOGUE_END(NAME)\t\t\t\\\n+do { fprintf (asm_out_file, \"\\t.def\\t\");\t\t\\\n+     ASM_OUTPUT_LABELREF (asm_out_file, NAME);\t\t\\\n+     fprintf (asm_out_file,\t\t\t\t\\\n+\t      \"%s\\t.val\\t.%s\\t.scl\\t-1%s\\t.endef\\n\",\t\\\n+\t      SDB_DELIM, SDB_DELIM, SDB_DELIM); } while (0)\n+#endif\n+\n+#ifndef SDB_GENERATE_FAKE\n+#define SDB_GENERATE_FAKE(BUFFER, NUMBER) \\\n+  sprintf ((BUFFER), \".%dfake\", (NUMBER));\n+#endif\n+\n+/* Return the sdb tag identifier string for TYPE\n+   if TYPE has already been defined; otherwise return a null pointer.   */\n+\n+#define KNOWN_TYPE_TAG(type) (char *)(TYPE_SYMTAB_ADDRESS (type))\n+\n+/* Set the sdb tag identifier string for TYPE to NAME.  */\n+\n+#define SET_KNOWN_TYPE_TAG(TYPE, NAME) \\\n+  (TYPE_SYMTAB_ADDRESS (TYPE) = (int)(NAME))\n+\n+/* Return the name (a string) of the struct, union or enum tag\n+   described by the TREE_LIST node LINK.  This is 0 for an anonymous one.  */\n+\n+#define TAG_NAME(link) \\\n+  (((link) && TREE_PURPOSE ((link)) \\\n+    && IDENTIFIER_POINTER (TREE_PURPOSE ((link)))) \\\n+   ? IDENTIFIER_POINTER (TREE_PURPOSE ((link))) : (char *) 0)\n+\n+/* Ensure we don't output a negative line number.  */\n+#define MAKE_LINE_SAFE(line)  \\\n+  if (line <= sdb_begin_function_line) line = sdb_begin_function_line + 1\n+\f\n+/* Set up for SDB output at the start of compilation.  */\n+\n+void\n+sdbout_init (asm_file, input_file_name, syms)\n+     FILE *asm_file;\n+     char *input_file_name;\n+     tree syms;\n+{\n+#if 0 /* Nothing need be output for the predefined types.  */\n+  /* Get all permanent types that have typedef names,\n+     and output them all, except for those already output.  */\n+\n+  sdbout_typedefs (syms);\n+#endif\n+}\n+\n+#if 0\n+\n+/* return the tag identifier for type\n+ */\n+\n+char *\n+tag_of_ru_type (type,link)\n+     tree type,link;\n+{\n+  if (TYPE_SYMTAB_ADDRESS (type))\n+    return (char *)TYPE_SYMTAB_ADDRESS (type);\n+  if (link && TREE_PURPOSE (link)\n+      && IDENTIFIER_POINTER (TREE_PURPOSE (link)))\n+    TYPE_SYMTAB_ADDRESS (type)\n+      = (int)IDENTIFIER_POINTER (TREE_PURPOSE (link));\n+  else\n+    return (char *) TYPE_SYMTAB_ADDRESS (type);\n+}\n+#endif\n+\n+/* Return a unique string to name an anonymous type.  */\n+\n+static char *\n+gen_fake_label ()\n+{\n+  char label[10];\n+  char *labelstr;\n+  SDB_GENERATE_FAKE (label, unnamed_struct_number);\n+  unnamed_struct_number++;\n+  labelstr = (char *) permalloc (strlen (label) + 1);\n+  strcpy (labelstr, label);\n+  return labelstr;\n+}\n+\f\n+/* Return the number which describes TYPE for SDB.\n+   For pointers, etc., this function is recursive.\n+   Each record, union or enumeral type must already have had a\n+   tag number output.  */\n+\n+/* The number is given by d6d5d4d3d2d1bbbb\n+   where bbbb is 4 bit basic type, and di indicate  one of notype,ptr,fn,array.\n+   Thus, char *foo () has bbbb=T_CHAR\n+\t\t\t  d1=D_FCN\n+\t\t\t  d2=D_PTR\n+ N_BTMASK=     017       1111     basic type field.\n+ N_TSHIFT=       2                derived type shift\n+ N_BTSHFT=       4                Basic type shift */\n+\n+/* Produce the number that describes a pointer, function or array type.\n+   PREV is the number describing the target, value or element type.\n+   DT_type describes how to transform that type.  */\n+#define PUSH_DERIVED_LEVEL(DT_type,PREV) \\\n+  ((((PREV)&~N_BTMASK)<<N_TSHIFT)|(DT_type<<N_BTSHFT)|(PREV&N_BTMASK))\n+\n+/* Number of elements used in sdb_dims.  */\n+static int sdb_n_dims = 0;\n+\n+/* Table of array dimensions of current type.  */\n+static int sdb_dims[SDB_MAX_DIM];\n+\n+/* Size of outermost array currently being processed.  */\n+static int sdb_type_size = -1;\n+\n+static int\n+plain_type (type)\n+     tree type;\n+{\n+  int val = plain_type_1 (type);\n+\n+  /* If we have already saved up some array dimensions, print them now.  */\n+  if (sdb_n_dims > 0)\n+    {\n+      int i;\n+      PUT_SDB_START_DIM;\n+      for (i = sdb_n_dims - 1; i > 0; i--)\n+\tPUT_SDB_NEXT_DIM (sdb_dims[i]);\n+      PUT_SDB_LAST_DIM (sdb_dims[0]);\n+      sdb_n_dims = 0;\n+\n+      sdb_type_size = int_size_in_bytes (type);\n+      /* Don't kill sdb if type is not laid out or has variable size.  */\n+      if (sdb_type_size < 0)\n+\tsdb_type_size = 0;\n+    }\n+  /* If we have computed the size of an array containing this type,\n+     print it now.  */\n+  if (sdb_type_size >= 0)\n+    {\n+      PUT_SDB_SIZE (sdb_type_size);\n+      sdb_type_size = -1;\n+    }\n+  return val;\n+}\n+\n+static void\n+sdbout_record_type_name (type)\n+     tree type;\n+{\n+  char *name = 0;\n+  int no_name;\n+\n+  if (KNOWN_TYPE_TAG (type))\n+    return;\n+\n+  if (TYPE_NAME (type) != 0)\n+    {\n+      tree t = 0;\n+      /* Find the IDENTIFIER_NODE for the type name.  */\n+      if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n+\t{\n+\t  t = TYPE_NAME (type);\n+\t}\n+#if 0  /* Don't use typedef names.  */\n+      else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+\t{\n+\t  t = DECL_NAME (TYPE_NAME (type));\n+\t}\n+#endif\n+\n+      /* Now get the name as a string, or invent one.  */\n+      if (t != 0)\n+\tname = IDENTIFIER_POINTER (t);\n+    }\n+\n+  no_name = (name == 0 || *name == 0);\n+  if (no_name)\n+    name = gen_fake_label ();\n+\n+  SET_KNOWN_TYPE_TAG (type, name);\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+  if (no_name)\n+    sdbout_queue_anonymous_type (type);\n+#endif\n+}\n+\n+static int\n+plain_type_1 (type)\n+     tree type;\n+{\n+  if (type == 0)\n+    type = void_type_node;\n+  if (type == error_mark_node)\n+    type = integer_type_node;\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case VOID_TYPE:\n+      return T_VOID;\n+    case INTEGER_TYPE:\n+      {\n+\tint size = int_size_in_bytes (type) * BITS_PER_UNIT;\n+\tif (size == CHAR_TYPE_SIZE)\n+\t  return (TREE_UNSIGNED (type) ? T_UCHAR : T_CHAR);\n+\tif (size == SHORT_TYPE_SIZE)\n+\t  return (TREE_UNSIGNED (type) ? T_USHORT : T_SHORT);\n+\tif (size == INT_TYPE_SIZE)\n+\t  return (TREE_UNSIGNED (type) ? T_UINT : T_INT);\n+\treturn 0;\n+      }\n+\n+    case REAL_TYPE:\n+      {\n+\tint size = int_size_in_bytes (type) * BITS_PER_UNIT;\n+\tif (size == FLOAT_TYPE_SIZE)\n+\t  return T_FLOAT;\n+\tif (size == DOUBLE_TYPE_SIZE)\n+\t  return T_DOUBLE;\n+\treturn 0;\n+      }\n+\n+    case ARRAY_TYPE:\n+      {\n+\tint m;\n+\tm = plain_type_1 (TREE_TYPE (type));\n+\tif (sdb_n_dims < SDB_MAX_DIM)\n+\t  sdb_dims[sdb_n_dims++]\n+\t    = (TYPE_DOMAIN (type)\n+\t       ? TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) + 1\n+\t       : 0);\n+\treturn PUSH_DERIVED_LEVEL (DT_ARY, m);\n+      }\n+\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      {\n+\tchar *tag;\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+\tsdbout_record_type_name (type);\n+#endif\n+#ifndef SDB_ALLOW_UNKNOWN_REFERENCES\n+\tif ((TREE_ASM_WRITTEN (type) && KNOWN_TYPE_TAG (type) != 0)\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+\t    || TYPE_MODE (type) != VOIDmode\n+#endif\n+\t    )\n+#endif\n+\t  {\n+\t    /* Output the referenced structure tag name\n+\t       only if the .def has already been finished.\n+\t       At least on 386, the Unix assembler\n+\t       cannot handle forward references to tags.  */\n+\t    /* But the 88100, it requires them, sigh... */\n+\t    /* And the MIPS requires unknown refs as well... */\n+\t    tag = KNOWN_TYPE_TAG (type);\n+\t    PUT_SDB_TAG (tag);\n+\t    /* These 3 lines used to follow the close brace.\n+\t       However, a size of 0 without a tag implies a tag of 0,\n+\t       so if we don't know a tag, we can't mention the size.  */\n+\t    sdb_type_size = int_size_in_bytes (type);\n+\t    if (sdb_type_size < 0)\n+\t      sdb_type_size = 0;\n+\t  }\n+\treturn ((TREE_CODE (type) == RECORD_TYPE) ? T_STRUCT\n+\t\t: (TREE_CODE (type) == UNION_TYPE) ? T_UNION\n+\t\t: T_ENUM);\n+      }\n+    case POINTER_TYPE:\n+    case REFERENCE_TYPE:\n+      {\n+\tint m = plain_type_1 (TREE_TYPE (type));\n+\treturn PUSH_DERIVED_LEVEL (DT_PTR, m);\n+      }\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      {\n+\tint m = plain_type_1 (TREE_TYPE (type));\n+\treturn PUSH_DERIVED_LEVEL (DT_FCN, m);\n+      }\n+    default:\n+      return 0;\n+    }\n+}\n+\f\n+/* Output the symbols defined in block number DO_BLOCK.\n+   Set NEXT_BLOCK_NUMBER to 0 before calling.\n+\n+   This function works by walking the tree structure of blocks,\n+   counting blocks until it finds the desired block.  */\n+\n+static int do_block = 0;\n+\n+static int next_block_number;\n+\n+static void\n+sdbout_block (block)\n+     register tree block;\n+{\n+  while (block)\n+    {\n+      /* Ignore blocks never expanded or otherwise marked as real.  */\n+      if (TREE_USED (block))\n+\t{\n+\t  /* When we reach the specified block, output its symbols.  */\n+\t  if (next_block_number == do_block)\n+\t    {\n+\t      sdbout_syms (BLOCK_VARS (block));\n+\t    }\n+\n+\t  /* If we are past the specified block, stop the scan.  */\n+\t  if (next_block_number > do_block)\n+\t    return;\n+\n+\t  next_block_number++;\n+\n+\t  /* Scan the blocks within this block.  */\n+\t  sdbout_block (BLOCK_SUBBLOCKS (block));\n+\t}\n+\n+      block = BLOCK_CHAIN (block);\n+    }\n+}\n+\f\n+/* Call sdbout_symbol on each decl in the chain SYMS.  */\n+\n+static void\n+sdbout_syms (syms)\n+     tree syms;\n+{\n+  while (syms)\n+    {\n+      sdbout_symbol (syms, 1);\n+      syms = TREE_CHAIN (syms);\n+    }\n+}\n+\n+/* Output SDB information for a symbol described by DECL.\n+   LOCAL is nonzero if the symbol is not file-scope.  */\n+\n+void\n+sdbout_symbol (decl, local)\n+     tree decl;\n+     int local;\n+{\n+  int letter = 0;\n+  tree type = TREE_TYPE (decl);\n+  tree context = NULL_TREE;\n+  rtx value;\n+  int regno = -1;\n+  char *name;\n+\n+  sdbout_one_type (type);\n+\n+  switch (TREE_CODE (decl))\n+    {\n+    case CONST_DECL:\n+      /* Enum values are defined by defining the enum type.  */\n+      return;\n+\n+    case FUNCTION_DECL:\n+      /* Don't mention a nested function under its parent.  */\n+      context = decl_function_context (decl);\n+      if (context == current_function_decl)\n+\treturn;\n+      if (TREE_EXTERNAL (decl))\n+\treturn;\n+      if (GET_CODE (DECL_RTL (decl)) != MEM\n+\t  || GET_CODE (XEXP (DECL_RTL (decl), 0)) != SYMBOL_REF)\n+\treturn;\n+      PUT_SDB_DEF (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+      PUT_SDB_VAL (XEXP (DECL_RTL (decl), 0));\n+      PUT_SDB_SCL (TREE_PUBLIC (decl) ? C_EXT : C_STAT);\n+      break;\n+\n+    case TYPE_DECL:\n+      /* Done with tagged types.  */\n+      if (DECL_NAME (decl) == 0)\n+\treturn;\n+\n+      /* Output typedef name.  */\n+      PUT_SDB_DEF (IDENTIFIER_POINTER (DECL_NAME (decl)));\n+      PUT_SDB_SCL (C_TPDEF);\n+      break;\n+\n+    case PARM_DECL:\n+      /* Parm decls go in their own separate chains\n+\t and are output by sdbout_reg_parms and sdbout_parms.  */\n+      abort ();\n+\n+    case VAR_DECL:\n+      /* Don't mention a variable that is external.\n+\t Let the file that defines it describe it.  */\n+      if (TREE_EXTERNAL (decl))\n+\treturn;\n+\n+      /* If there was an error in the declaration, don't dump core\n+\t if there is no RTL associated with the variable doesn't\n+\t exist.  */\n+      if (DECL_RTL (decl) == 0)\n+\treturn;\n+\n+      value = eliminate_regs (DECL_RTL (decl), 0, 0);\n+\n+      /* Don't mention a variable at all\n+\t if it was completely optimized into nothingness.\n+\n+\t If DECL was from an inline function, then its rtl\n+\t is not identically the rtl that was used in this\n+\t particular compilation.  */\n+      if (GET_CODE (value) == REG)\n+\t{\n+\t  regno = REGNO (DECL_RTL (decl));\n+\t  if (regno >= FIRST_PSEUDO_REGISTER)\n+\t    regno = reg_renumber[REGNO (DECL_RTL (decl))];\n+\t  if (regno < 0)\n+\t    return;\n+\t}\n+      else if (GET_CODE (DECL_RTL (decl)) == SUBREG)\n+\t{\n+\t  int offset = 0;\n+\t  while (GET_CODE (value) == SUBREG)\n+\t    {\n+\t      offset += SUBREG_WORD (value);\n+\t      value = SUBREG_REG (value);\n+\t    }\n+\t  if (GET_CODE (value) == REG)\n+\t    {\n+\t      regno = REGNO (value);\n+\t      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t\tregno = reg_renumber[REGNO (value)];\n+\t      if (regno >= 0)\n+\t\tregno += offset;\n+\t    }\n+\t}\n+\n+      /* Emit any structure, union, or enum type that has not been output.\n+\t This occurs for tag-less structs (et al) used to declare variables\n+\t within functions.  */\n+      if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t  || TREE_CODE (type) == RECORD_TYPE\n+\t  || TREE_CODE (type) == UNION_TYPE)\n+\t{\n+\t  if (TYPE_SIZE (type) != 0\t\t/* not a forward reference */\n+\t      && KNOWN_TYPE_TAG (type) == 0)\t/* not yet declared */\n+\t    sdbout_one_type (type);\n+\t}\n+\n+      /* Defer SDB information for top-level initialized variables! */\n+      if (! local\n+\t  && GET_CODE (value) == MEM\n+\t  && DECL_INITIAL (decl))\n+\treturn;\n+\n+      /* Record the name for, starting a symtab entry.  */\n+      name = IDENTIFIER_POINTER (DECL_NAME (decl));\n+\n+      if (GET_CODE (value) == MEM\n+\t  && GET_CODE (XEXP (value, 0)) == SYMBOL_REF)\n+\t{\n+\t  PUT_SDB_DEF (name);\n+\t  if (TREE_PUBLIC (decl))\n+\t    {\n+\t      PUT_SDB_VAL (XEXP (value, 0));\n+              PUT_SDB_SCL (C_EXT);\n+\t    }\n+\t  else\n+\t    {\n+\t      PUT_SDB_VAL (XEXP (value, 0));\n+              PUT_SDB_SCL (C_STAT);\n+\t    }\n+\t}\n+      else if (regno >= 0)\n+\t{\n+\t  PUT_SDB_DEF (name);\n+\t  PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (regno));\n+\t  PUT_SDB_SCL (C_REG);\n+\t}\n+      else if (GET_CODE (value) == MEM\n+\t       && (GET_CODE (XEXP (value, 0)) == MEM\n+\t\t   || (GET_CODE (XEXP (value, 0)) == REG\n+\t\t       && REGNO (XEXP (value, 0)) != FRAME_POINTER_REGNUM)))\n+\t/* If the value is indirect by memory or by a register\n+\t   that isn't the frame pointer\n+\t   then it means the object is variable-sized and address through\n+\t   that register or stack slot.  COFF has no way to represent this\n+\t   so all we can do is output the variable as a pointer.  */\n+\t{\n+\t  PUT_SDB_DEF (name);\n+\t  if (GET_CODE (XEXP (value, 0)) == REG)\n+\t    {\n+\t      PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (XEXP (value, 0))));\n+\t      PUT_SDB_SCL (C_REG);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* DECL_RTL looks like (MEM (MEM (PLUS (REG...)\n+\t\t (CONST_INT...)))).\n+\t\t We want the value of that CONST_INT.  */\n+\t      /* Encore compiler hates a newline in a macro arg, it seems.  */\n+\t      PUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET\n+\t\t\t       (XEXP (XEXP (value, 0), 0)));\n+\t      PUT_SDB_SCL (C_AUTO);\n+\t    }\n+\n+\t  type = build_pointer_type (TREE_TYPE (decl));\n+\t}\n+      else if (GET_CODE (value) == MEM\n+\t       && GET_CODE (XEXP (value, 0)) == PLUS\n+\t       && GET_CODE (XEXP (XEXP (value, 0), 0)) == REG\n+\t       && GET_CODE (XEXP (XEXP (value, 0), 1)) == CONST_INT)\n+\t{\n+\t  /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))).\n+\t     We want the value of that CONST_INT.  */\n+\t  PUT_SDB_DEF (name);\n+\t  PUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET (XEXP (value, 0)));\n+\t  PUT_SDB_SCL (C_AUTO);\n+\t}\n+      else\n+\t{\n+\t  /* It is something we don't know how to represent for SDB.  */\n+\t  return;\n+\t}\n+      break;\n+    }\n+  PUT_SDB_TYPE (plain_type (type));\n+  PUT_SDB_ENDEF;\n+}\n+\f\n+/* Output SDB information for a top-level initialized variable\n+   that has been delayed.  */\n+\n+void\n+sdbout_toplevel_data (decl)\n+     tree decl;\n+{\n+  tree type = TREE_TYPE (decl);\n+\n+  if (! (TREE_CODE (decl) == VAR_DECL\n+\t && GET_CODE (DECL_RTL (decl)) == MEM\n+\t && DECL_INITIAL (decl)))\n+    abort ();\n+\n+  PUT_SDB_DEF (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n+  PUT_SDB_VAL (XEXP (DECL_RTL (decl), 0));\n+  if (TREE_PUBLIC (decl))\n+    {\n+      PUT_SDB_SCL (C_EXT);\n+    }\n+  else\n+    {\n+      PUT_SDB_SCL (C_STAT);\n+    }\n+  PUT_SDB_TYPE (plain_type (type));\n+  PUT_SDB_ENDEF;\n+}\n+\f\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+\n+/* Machinery to record and output anonymous types. */\n+\n+static tree anonymous_types;\n+\n+static void\n+sdbout_queue_anonymous_type (type)\n+     tree type;\n+{\n+  anonymous_types = saveable_tree_cons (NULL_TREE, type, anonymous_types);\n+}\n+\n+static void\n+sdbout_dequeue_anonymous_types ()\n+{\n+  register tree types, link;\n+\n+  while (anonymous_types)\n+    {\n+      types = nreverse (anonymous_types);\n+      anonymous_types = NULL_TREE;\n+\n+      for (link = types; link; link = TREE_CHAIN (link))\n+\t{\n+\t  register tree type = TREE_VALUE (link);\n+\n+\t  if (! TREE_ASM_WRITTEN (type))\n+\t    sdbout_one_type (type);\n+\t}\n+    }\n+}\n+\n+#endif\n+\f\n+/* Given a chain of ..._TYPE nodes, all of which have names,\n+   output definitions of those names, as typedefs.  */\n+\n+void\n+sdbout_types (types)\n+     register tree types;\n+{\n+  register tree link;\n+\n+  for (link = types; link; link = TREE_CHAIN (link))\n+    sdbout_one_type (link);\n+\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+  sdbout_dequeue_anonymous_types ();\n+#endif\n+}\n+\n+static void\n+sdbout_type (type)\n+     tree type;\n+{\n+  register tree tem;\n+  if (type == error_mark_node)\n+    type = integer_type_node;\n+  PUT_SDB_TYPE (plain_type (type));\n+}\n+\n+/* Output types of the fields of type TYPE, if they are structs.\n+\n+   Formerly did not chase through pointer types, since that could be circular.\n+   They must come before TYPE, since forward refs are not allowed.\n+   Now james@bigtex.cactus.org says to try them.  */\n+\n+static void\n+sdbout_field_types (type)\n+     tree type;\n+{\n+  tree tail;\n+  for (tail = TYPE_FIELDS (type); tail; tail = TREE_CHAIN (tail))\n+    if (TREE_CODE (TREE_TYPE (tail)) == POINTER_TYPE)\n+      sdbout_one_type (TREE_TYPE (TREE_TYPE (tail)));\n+    else\n+      sdbout_one_type (TREE_TYPE (tail));\n+}\n+\n+/* Use this to put out the top level defined record and union types\n+   for later reference.  If this is a struct with a name, then put that\n+   name out.  Other unnamed structs will have .xxfake labels generated so\n+   that they may be referred to later.\n+   The label will be stored in the KNOWN_TYPE_TAG slot of a type.\n+   It may NOT be called recursively.  */\n+\n+static void\n+sdbout_one_type (type)\n+     tree type;\n+{\n+  text_section ();\n+\n+  switch (TREE_CODE (type))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+    case ENUMERAL_TYPE:\n+      type = TYPE_MAIN_VARIANT (type);\n+      /* Don't output a type twice.  */\n+      if (TREE_ASM_WRITTEN (type))\n+\t/* James said test TREE_ASM_BEING_WRITTEN here.  */\n+\treturn;\n+\n+      /* Output nothing if type is not yet defined.  */\n+      if (TYPE_SIZE (type) == 0)\n+\treturn;\n+\n+      TREE_ASM_WRITTEN (type) = 1;\n+#if 1\n+      /* This is reputed to cause trouble with the following case,\n+\t but perhaps checking TYPE_SIZE above will fix it.\n+\n+      /* Here is a test case:\n+\n+\tstruct foo {\n+\t  struct badstr *bbb;\n+\t} forwardref;\n+\n+\ttypedef struct intermediate {\n+\t  int aaaa;\n+\t} intermediate_ref;\n+\n+\ttypedef struct badstr {\n+\t  int ccccc;\n+\t} badtype;   */\n+\n+#if 0\n+      TREE_ASM_BEING_WRITTEN (type) = 1;\n+#endif\n+      /* This change, which ought to make better output,\n+\t used to make the COFF assembler unhappy.\n+\t Changes involving KNOWN_TYPE_TAG may fix the problem.  */\n+      /* Before really doing anything, output types we want to refer to.  */\n+      /* Note that in version 1 the following two lines\n+\t are not used if forward references are in use.  */\n+      if (TREE_CODE (type) != ENUMERAL_TYPE)\n+\tsdbout_field_types (type);\n+#if 0\n+      TREE_ASM_WRITTEN (type) = 1;\n+#endif\n+#endif\n+\n+      /* Output a structure type.  */\n+      {\n+\tint size = int_size_in_bytes (type);\n+\tint member_scl;\n+\ttree tem;\n+\n+\t/* Record the type tag, but not in its permanent place just yet.  */\n+\tsdbout_record_type_name (type);\n+\n+\tPUT_SDB_DEF (KNOWN_TYPE_TAG (type));\n+\n+\tswitch (TREE_CODE (type))\n+\t  {\n+\t  case UNION_TYPE:\n+\t    PUT_SDB_SCL (C_UNTAG);\n+\t    PUT_SDB_TYPE (T_UNION);\n+\t    member_scl = C_MOU;\n+\t    break;\n+\n+\t  case RECORD_TYPE:\n+\t    PUT_SDB_SCL (C_STRTAG);\n+\t    PUT_SDB_TYPE (T_STRUCT);\n+\t    member_scl = C_MOS;\n+\t    break;\n+\n+\t  case ENUMERAL_TYPE:\n+\t    PUT_SDB_SCL (C_ENTAG);\n+\t    PUT_SDB_TYPE (T_ENUM);\n+\t    member_scl = C_MOE;\n+\t    break;\n+\t  }\n+\n+\tPUT_SDB_SIZE (size);\n+\tPUT_SDB_ENDEF;\n+\n+\t/* output the individual fields */\n+\n+\tif (TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+\t    {\n+\t      PUT_SDB_DEF (IDENTIFIER_POINTER (TREE_PURPOSE (tem)));\n+\t      PUT_SDB_INT_VAL (TREE_INT_CST_LOW (TREE_VALUE (tem)));\n+\t      PUT_SDB_SCL (C_MOE);\n+\t      PUT_SDB_TYPE (T_MOE);\n+\t      PUT_SDB_ENDEF;\n+\t    }\n+\n+\telse\t\t\t/* record or union type */\n+\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n+\t    /* Output the name, type, position (in bits), size (in bits)\n+\t       of each field.  */\n+\n+\t    /* Omit here the nameless fields that are used to skip bits.\n+\t       Also omit fields with variable size or position.\n+\t       Also omit non FIELD_DECL nodes that GNU C++ may put here.  */\n+\t    if (TREE_CODE (tem) == FIELD_DECL\n+\t\t&& DECL_NAME (tem) != 0\n+\t\t&& TREE_CODE (DECL_SIZE (tem)) == INTEGER_CST\n+\t\t&& TREE_CODE (DECL_FIELD_BITPOS (tem)) == INTEGER_CST)\n+\t      {\n+\t\tCONTIN;\n+\t\tPUT_SDB_DEF (IDENTIFIER_POINTER (DECL_NAME (tem)));\n+\t\tif (DECL_BIT_FIELD_TYPE (tem))\n+\t\t  {\n+\t\t    PUT_SDB_INT_VAL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem)));\n+\t\t    PUT_SDB_SCL (C_FIELD);\n+\t\t    sdbout_type (DECL_BIT_FIELD_TYPE (tem));\n+\t\t    PUT_SDB_SIZE (TREE_INT_CST_LOW (DECL_SIZE (tem)));\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    PUT_SDB_INT_VAL (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (tem))\n+\t\t\t\t     / BITS_PER_UNIT);\n+\t\t    PUT_SDB_SCL (member_scl);\n+\t\t    sdbout_type (TREE_TYPE (tem));\n+\t\t  }\n+\t\tPUT_SDB_ENDEF;\n+\t      }\n+\t/* output end of a structure,union, or enumeral definition */\n+\n+\tPUT_SDB_PLAIN_DEF (\"eos\");\n+\tPUT_SDB_INT_VAL (size);\n+\tPUT_SDB_SCL (C_EOS);\n+\tPUT_SDB_TAG (KNOWN_TYPE_TAG (type));\n+\tPUT_SDB_SIZE (size);\n+\tPUT_SDB_ENDEF;\n+\tbreak;\n+      }\n+    }\n+}\n+\f\n+/* The following two functions output definitions of function parameters.\n+   Each parameter gets a definition locating it in the parameter list.\n+   Each parameter that is a register variable gets a second definition\n+   locating it in the register.\n+\n+   Printing or argument lists in gdb uses the definitions that\n+   locate in the parameter list.  But reference to the variable in\n+   expressions uses preferentially the definition as a register.  */\n+\n+/* Output definitions, referring to storage in the parmlist,\n+   of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */\n+\n+static void\n+sdbout_parms (parms)\n+     tree parms;\n+{\n+  for (; parms; parms = TREE_CHAIN (parms))\n+    if (DECL_NAME (parms))\n+      {\n+\tint current_sym_value = 0;\n+\tchar *name = IDENTIFIER_POINTER (DECL_NAME (parms));\n+\n+\tif (name == 0 || *name == 0)\n+\t  name = gen_fake_label ();\n+\n+\t/* Perform any necessary register eliminations on the parameter's rtl,\n+\t   so that the debugging output will be accurate.  */\n+\tDECL_INCOMING_RTL (parms) =\n+\t  eliminate_regs (DECL_INCOMING_RTL (parms), 0, 0);\n+\tDECL_RTL (parms) = eliminate_regs (DECL_RTL (parms), 0, 0);\n+\n+\tif (PARM_PASSED_IN_MEMORY (parms))\n+\t  {\n+\t    rtx addr = XEXP (DECL_INCOMING_RTL (parms), 0);\n+\t    tree type;\n+\n+\t    /* ??? Here we assume that the parm address is indexed\n+\t       off the frame pointer or arg pointer.\n+\t       If that is not true, we produce meaningless results,\n+\t       but do not crash.  */\n+\t    if (GET_CODE (addr) == PLUS\n+\t\t&& GET_CODE (XEXP (addr, 1)) == CONST_INT)\n+\t      current_sym_value = INTVAL (XEXP (addr, 1));\n+\t    else\n+\t      current_sym_value = 0;\n+\n+\t    if (GET_CODE (DECL_RTL (parms)) == REG\n+\t\t&& REGNO (DECL_RTL (parms)) >= 0\n+\t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n+\t      type = DECL_ARG_TYPE (parms);\n+\t    else\n+\t      {\n+\t\tint original_sym_value = current_sym_value;\n+\n+\t\t/* This is the case where the parm is passed as an int or\n+\t\t   double and it is converted to a char, short or float\n+\t\t   and stored back in the parmlist.  In this case, describe\n+\t\t   the parm with the variable's declared type, and adjust\n+\t\t   the address if the least significant bytes (which we are\n+\t\t   using) are not the first ones.  */\n+#if BYTES_BIG_ENDIAN\n+\t\tif (TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t\t  current_sym_value +=\n+\t\t    (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n+\t\t     - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n+#endif\n+\t\tif (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t    && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n+\t\t    && (GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n+\t\t\t== CONST_INT)\n+\t\t    && (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1))\n+\t\t\t== current_sym_value))\n+\t\t  type = TREE_TYPE (parms);\n+\t\telse\n+\t\t  {\n+\t\t    current_sym_value = original_sym_value;\n+\t\t    type = DECL_ARG_TYPE (parms);\n+\t\t  }\n+\t      }\n+\n+\t    PUT_SDB_DEF (name);\n+\t    PUT_SDB_INT_VAL (DEBUGGER_ARG_OFFSET (current_sym_value, addr));\n+\t    PUT_SDB_SCL (C_ARG);\n+\t    PUT_SDB_TYPE (plain_type (type));\n+\t    PUT_SDB_ENDEF;\n+\t  }\n+\telse if (GET_CODE (DECL_RTL (parms)) == REG)\n+\t  {\n+\t    rtx best_rtl;\n+\t    /* Parm passed in registers and lives in registers or nowhere.  */\n+\n+\t    /* If parm lives in a register, use that register;\n+\t       pretend the parm was passed there.  It would be more consistent\n+\t       to describe the register where the parm was passed,\n+\t       but in practice that register usually holds something else.  */\n+\t    if (REGNO (DECL_RTL (parms)) >= 0\n+\t\t&& REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER)\n+\t      best_rtl = DECL_RTL (parms);\n+\t    /* If the parm lives nowhere,\n+\t       use the register where it was passed.  */\n+\t    else\n+\t      best_rtl = DECL_INCOMING_RTL (parms);\n+\n+\t    PUT_SDB_DEF (name);\n+\t    PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (best_rtl)));\n+\t    PUT_SDB_SCL (C_REGPARM);\n+\t    PUT_SDB_TYPE (plain_type (TREE_TYPE (parms), 0));\n+\t    PUT_SDB_ENDEF;\n+\t  }\n+\telse if (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t && XEXP (DECL_RTL (parms), 0) != const0_rtx)\n+\t  {\n+\t    /* Parm was passed in registers but lives on the stack.  */\n+\n+\t    /* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))),\n+\t       in which case we want the value of that CONST_INT,\n+\t       or (MEM (REG ...)) or (MEM (MEM ...)),\n+\t       in which case we use a value of zero.  */\n+\t    if (GET_CODE (XEXP (DECL_RTL (parms), 0)) == REG\n+\t\t|| GET_CODE (XEXP (DECL_RTL (parms), 0)) == MEM)\n+\t      current_sym_value = 0;\n+\t    else\n+\t      current_sym_value = INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1));\n+\n+\t    /* Again, this assumes the offset is based on the arg pointer.  */\n+\t    PUT_SDB_DEF (name);\n+\t    PUT_SDB_INT_VAL (DEBUGGER_ARG_OFFSET (current_sym_value,\n+\t\t\t\t\t\t  XEXP (DECL_RTL (parms), 0)));\n+\t    PUT_SDB_SCL (C_ARG);\n+\t    PUT_SDB_TYPE (plain_type (TREE_TYPE (parms), 0));\n+\t    PUT_SDB_ENDEF;\n+\t  }\n+      }\n+}\n+\n+/* Output definitions for the places where parms live during the function,\n+   when different from where they were passed, when the parms were passed\n+   in memory.\n+\n+   It is not useful to do this for parms passed in registers\n+   that live during the function in different registers, because it is\n+   impossible to look in the passed register for the passed value,\n+   so we use the within-the-function register to begin with.\n+\n+   PARMS is a chain of PARM_DECL nodes.  */\n+\n+static void\n+sdbout_reg_parms (parms)\n+     tree parms;\n+{\n+  for (; parms; parms = TREE_CHAIN (parms))\n+    if (DECL_NAME (parms))\n+      {\n+\tchar *name = IDENTIFIER_POINTER (DECL_NAME (parms));\n+\n+\t/* Report parms that live in registers during the function\n+\t   but were passed in memory.  */\n+\tif (GET_CODE (DECL_RTL (parms)) == REG\n+\t    && REGNO (DECL_RTL (parms)) >= 0\n+\t    && REGNO (DECL_RTL (parms)) < FIRST_PSEUDO_REGISTER\n+\t    && PARM_PASSED_IN_MEMORY (parms))\n+\t  {\n+\t    if (name == 0 || *name == 0)\n+\t      name = gen_fake_label ();\n+\t    PUT_SDB_DEF (name);\n+\t    PUT_SDB_INT_VAL (DBX_REGISTER_NUMBER (REGNO (DECL_RTL (parms))));\n+\t    PUT_SDB_SCL (C_REG);\n+\t    PUT_SDB_TYPE (plain_type (TREE_TYPE (parms), 0));\n+\t    PUT_SDB_ENDEF;\n+\t  }\n+\t/* Report parms that live in memory but not where they were passed.  */\n+\telse if (GET_CODE (DECL_RTL (parms)) == MEM\n+\t\t && GET_CODE (XEXP (DECL_RTL (parms), 0)) == PLUS\n+\t\t && GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 1)) == CONST_INT\n+\t\t && PARM_PASSED_IN_MEMORY (parms)\n+\t\t && ! rtx_equal_p (DECL_RTL (parms), DECL_INCOMING_RTL (parms)))\n+\t  {\n+#if 0 /* ??? It is not clear yet what should replace this.  */\n+\t    int offset = DECL_OFFSET (parms) / BITS_PER_UNIT;\n+\t    /* A parm declared char is really passed as an int,\n+\t       so it occupies the least significant bytes.\n+\t       On a big-endian machine those are not the low-numbered ones.  */\n+#if BYTES_BIG_ENDIAN\n+\t    if (offset != -1 && TREE_TYPE (parms) != DECL_ARG_TYPE (parms))\n+\t      offset += (GET_MODE_SIZE (TYPE_MODE (DECL_ARG_TYPE (parms)))\n+\t\t\t - GET_MODE_SIZE (GET_MODE (DECL_RTL (parms))));\n+#endif\n+\t    if (INTVAL (XEXP (XEXP (DECL_RTL (parms), 0), 1)) != offset) {...}\n+#endif\n+\t      {\n+\t\tif (name == 0 || *name == 0)\n+\t\t  name = gen_fake_label ();\n+\t\tPUT_SDB_DEF (name);\n+\t\tPUT_SDB_INT_VAL (DEBUGGER_AUTO_OFFSET\n+\t\t\t\t (XEXP (DECL_RTL (parms), 0)));\n+\t\tPUT_SDB_SCL (C_AUTO);\n+\t\tPUT_SDB_TYPE (plain_type (TREE_TYPE (parms)));\n+\t\tPUT_SDB_ENDEF;\n+\t      }\n+\t  }\n+      }\n+}\n+\f\n+/* Describe the beginning of an internal block within a function.\n+   Also output descriptions of variables defined in this block.\n+\n+   N is the number of the block, by order of beginning, counting from 1,\n+   and not counting the outermost (function top-level) block.\n+   The blocks match the BLOCKs in DECL_INITIAL (current_function_decl),\n+   if the count starts at 0 for the outermost one.  */\n+\n+void\n+sdbout_begin_block (file, line, n)\n+     FILE *file;\n+     int line;\n+     int n;\n+{\n+  tree decl = current_function_decl;\n+  MAKE_LINE_SAFE (line);\n+  PUT_SDB_BLOCK_START (line - sdb_begin_function_line);\n+  if (n == 1)\n+    {\n+      /* Include the outermost BLOCK's variables in block 1.  */\n+      next_block_number = 0;\n+      do_block = 0;\n+      sdbout_block (DECL_INITIAL (decl));\n+    }\n+  /* If -g1, suppress all the internal symbols of functions\n+     except for arguments.  */\n+  if (debug_info_level != DINFO_LEVEL_TERSE)\n+    {\n+      next_block_number = 0;\n+      do_block = n;\n+      sdbout_block (DECL_INITIAL (decl));\n+    }\n+\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+  sdbout_dequeue_anonymous_types ();\n+#endif\n+}\n+\n+/* Describe the end line-number of an internal block within a function.  */\n+\n+void\n+sdbout_end_block (file, line)\n+     FILE *file;\n+     int line;\n+{\n+  MAKE_LINE_SAFE (line);\n+  PUT_SDB_BLOCK_END (line - sdb_begin_function_line);\n+}\n+\n+/* Output sdb info for the current function name.\n+   Called from assemble_start_function.  */\n+\n+void\n+sdbout_mark_begin_function ()\n+{\n+  sdbout_symbol (current_function_decl, 0);\n+}\n+\n+/* Called at beginning of function body (after prologue).\n+   Record the function's starting line number, so we can output\n+   relative line numbers for the other lines.\n+   Describe beginning of outermost block.\n+   Also describe the parameter list.  */\n+\n+void\n+sdbout_begin_function (line)\n+     int line;\n+{\n+  sdb_begin_function_line = line - 1;\n+  PUT_SDB_FUNCTION_START (line);\n+  sdbout_parms (DECL_ARGUMENTS (current_function_decl));\n+  sdbout_reg_parms (DECL_ARGUMENTS (current_function_decl));\n+}\n+\n+/* Called at end of function (before epilogue).\n+   Describe end of outermost block.  */\n+\n+void\n+sdbout_end_function (line)\n+     int line;\n+{\n+#ifdef SDB_ALLOW_FORWARD_REFERENCES\n+  sdbout_dequeue_anonymous_types ();\n+#endif\n+\n+  MAKE_LINE_SAFE (line);\n+  PUT_SDB_FUNCTION_END (line - sdb_begin_function_line);\n+\n+  /* Indicate we are between functions, for line-number output.  */\n+  sdb_begin_function_line = -1;\n+}\n+\n+/* Output sdb info for the absolute end of a function.\n+   Called after the epilogue is output.  */\n+\n+void\n+sdbout_end_epilogue ()\n+{\n+  char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (current_function_decl));\n+  PUT_SDB_EPILOGUE_END (name);\n+}\n+\n+/* Output sdb info for the given label.  Called only if LABEL_NAME (insn)\n+   is present.  */\n+\n+void\n+sdbout_label (insn)\n+     register rtx insn;\n+{\n+  PUT_SDB_DEF (LABEL_NAME (insn));\n+  PUT_SDB_VAL (insn);\n+  PUT_SDB_SCL (C_LABEL);\n+  PUT_SDB_TYPE (T_NULL);\n+  PUT_SDB_ENDEF;\n+}\n+\n+#endif /* SDB_DEBUGGING_INFO */"}]}