{"sha": "a5cb3b30256cbaa017ed825c6f7778166499a0a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVjYjNiMzAyNTZjYmFhMDE3ZWQ4MjVjNmY3Nzc4MTY2NDk5YTBhNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-13T21:40:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-07-13T21:40:51Z"}, "message": "[multiple changes]\n\n2004-07-13  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* decl.c: (gnat_to_gnu_entity, object case): Convert initializer to\n\tobject type.\n\t(gnat_to_gnu_entity, case E_Record_Subtype): Properly set\n\tTYPE_STUB_DECL.\n\n\t* misc.c (gnat_types_compatible_p): New function.\n\t(LANG_HOOKS_TYPES_COMPATIBLE_P): New hook, to use it.\n\t(LANG_HOOKS_TYPE_MAX_SIZE, gnat_type_max_size): New.\n\n\t* trans.c (gigi): Move processing of main N_Compilation_Unit here.\n\t(gnat_to_gnu, case N_Compilation_Unit): Just handle nested case here.\n\t(add_stmt): Force walking of sizes and DECL_INITIAL for DECL_EXPR.\n\t(mark_visited): Don't mark dummy type.\n\t(tree_transform <N_Procedure_Call_Statement>): Unless this is an In\n\tparameter, we must remove any LJM building from GNU_NAME.\n\t(gnat_to_gnu, case N_String_Literal): Fill in indices in CONSTRUCTOR.\n\t(pos_to_constructor): Use int_const_binop.\n\t(gnat_to_gnu, case N_Identifier): Don't reference DECL_INITIAL of\n\tPARM_DECL.\n\n\t* utils.c (gnat_init_decl_processing): Don't make two \"void\" decls.\n\t(gnat_pushlevel): Set TREE_USE on BLOCK node.\n\t(gnat_install_builtins): Add __builtin_memset.\n\n2004-07-13  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* decl.c (gnat_to_gnu_entity <E_Variable>): If we are making a pointer\n\tfor a renaming, stabilize the initialization expression if we are at a\n\tlocal level.  At the local level, uses of the renaming may be performed\n\tby a direct dereference of the initializing expression, and we don't\n\twant possible variables there to be evaluated for every use.\n\n\t* trans.c (gnat_stabilize_reference, gnat_stabilize_reference_1):\n\tPropagate TREE_SIDE_EFFECTS and TREE_THIS_VOLATILE to avoid loosing\n\tthem on the way.  Account for the fact that we may introduce side\n\teffects in the process.\n\nFrom-SVN: r84647", "tree": {"sha": "ca4e054f37d2b08bfcf30ed0bd62cba30a72b076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca4e054f37d2b08bfcf30ed0bd62cba30a72b076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5cb3b30256cbaa017ed825c6f7778166499a0a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5cb3b30256cbaa017ed825c6f7778166499a0a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5cb3b30256cbaa017ed825c6f7778166499a0a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5cb3b30256cbaa017ed825c6f7778166499a0a6/comments", "author": null, "committer": null, "parents": [{"sha": "1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ff3c0761f1732883f5c1b5bd5c9b6a6f53c4b49"}], "stats": {"total": 426, "additions": 300, "deletions": 126}, "files": [{"sha": "5450f603d8f892c3eb051d6a7473f260b67a8700", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a5cb3b30256cbaa017ed825c6f7778166499a0a6", "patch": "@@ -1,3 +1,42 @@\n+2004-07-13  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* decl.c: (gnat_to_gnu_entity, object case): Convert initializer to\n+\tobject type.\n+\t(gnat_to_gnu_entity, case E_Record_Subtype): Properly set\n+\tTYPE_STUB_DECL.\n+\n+\t* misc.c (gnat_types_compatible_p): New function.\n+\t(LANG_HOOKS_TYPES_COMPATIBLE_P): New hook, to use it.\n+\t(LANG_HOOKS_TYPE_MAX_SIZE, gnat_type_max_size): New.\n+\n+\t* trans.c (gigi): Move processing of main N_Compilation_Unit here.\n+\t(gnat_to_gnu, case N_Compilation_Unit): Just handle nested case here.\n+\t(add_stmt): Force walking of sizes and DECL_INITIAL for DECL_EXPR.\n+\t(mark_visited): Don't mark dummy type.\n+\t(tree_transform <N_Procedure_Call_Statement>): Unless this is an In\t\n+\tparameter, we must remove any LJM building from GNU_NAME.\n+\t(gnat_to_gnu, case N_String_Literal): Fill in indices in CONSTRUCTOR.\n+\t(pos_to_constructor): Use int_const_binop.\n+\t(gnat_to_gnu, case N_Identifier): Don't reference DECL_INITIAL of\n+\tPARM_DECL.\n+\n+\t* utils.c (gnat_init_decl_processing): Don't make two \"void\" decls.\n+\t(gnat_pushlevel): Set TREE_USE on BLOCK node.\n+\t(gnat_install_builtins): Add __builtin_memset.\n+\n+2004-07-13  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* decl.c (gnat_to_gnu_entity <E_Variable>): If we are making a pointer\n+\tfor a renaming, stabilize the initialization expression if we are at a\n+\tlocal level.  At the local level, uses of the renaming may be performed\n+\tby a direct dereference of the initializing expression, and we don't\n+\twant possible variables there to be evaluated for every use.\n+\n+\t* trans.c (gnat_stabilize_reference, gnat_stabilize_reference_1):\n+\tPropagate TREE_SIDE_EFFECTS and TREE_THIS_VOLATILE to avoid loosing\n+\tthem on the way.  Account for the fact that we may introduce side\n+\teffects in the process.\n+\n 2004-07-13  Richard Henderson  <rth@redhat.com>\n \n \t* misc.c (default_pass_by_ref): Use pass_by_reference."}, {"sha": "e719072a4fd10aab667a10b164bf171fbeb38bda", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 43, "deletions": 17, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=a5cb3b30256cbaa017ed825c6f7778166499a0a6", "patch": "@@ -728,15 +728,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      (TYPE_SIZE (TREE_TYPE (TYPE_FIELDS (gnu_type)))))))\n \t  gnu_expr = convert (gnu_type, gnu_expr);\n \n-\t/* See if this is a renaming.  If this is a constant renaming,\n-\t   treat it as a normal variable whose initial value is what\n-\t   is being renamed.  We cannot do this if the type is\n-\t   unconstrained or class-wide.\n+\t/* See if this is a renaming.  If this is a constant renaming, treat\n+\t   it as a normal variable whose initial value is what is being\n+\t   renamed.  We cannot do this if the type is unconstrained or\n+\t   class-wide.\n \n \t   Otherwise, if what we are renaming is a reference, we can simply\n-\t   return a stabilized version of that reference, after forcing\n-\t   any SAVE_EXPRs to be evaluated.  But, if this is at global level,\n-\t   we can only do this if we know no SAVE_EXPRs will be made.\n+\t   return a stabilized version of that reference, after forcing any\n+\t   SAVE_EXPRs to be evaluated.  But, if this is at global level, we\n+\t   can only do this if we know no SAVE_EXPRs will be made.\n+\n \t   Otherwise, make this into a constant pointer to the object we are\n \t   to rename.  */\n \n@@ -761,8 +762,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n                 && !Is_Array_Type (Etype (gnat_entity)))\n \t      ;\n \n-\t    /* If this is a declaration or reference, we can just use that\n-\t       declaration or reference as this entity.  */\n+\t    /* If this is a declaration or reference that we can stabilize,\n+\t       just use that declaration or reference as this entity unless\n+\t       the latter has to be materialized.  */\n \t    else if ((DECL_P (gnu_expr)\n \t\t      || TREE_CODE_CLASS (TREE_CODE (gnu_expr)) == 'r')\n \t\t     && ! Materialize_Entity (gnat_entity)\n@@ -775,12 +777,33 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tsaved = 1;\n \t\tbreak;\n \t      }\n+\t    /* Otherwise, make this into a constant pointer to the object we\n+\t       are to rename.\n+\n+\t       Stabilize it if we are not at the global level since in this\n+\t       case the renaming evaluation may directly dereference the\n+\t       initial value we make here instead of the pointer we will\n+\t       assign it to.  We don't want variables in the expression to be\n+\t       evaluated every time the renaming is used, since the value of\n+\t       these variables may change in between.\n+\n+\t       If we are at the global level and the value is not constant,\n+\t       create_var_decl generates a mere elaboration assignment and\n+\t       does not attach the initial expression to the declaration.\n+\t       There is no possible direct initial-value dereference then.  */\n \t    else\n \t      {\n \t\tinner_const_flag = TREE_READONLY (gnu_expr);\n \t\tconst_flag = 1;\n \t\tgnu_type = build_reference_type (gnu_type);\n \t\tgnu_expr = build_unary_op (ADDR_EXPR, gnu_type, gnu_expr);\n+\n+\t\tif (! global_bindings_p ())\n+\t\t  {\n+\t\t    gnu_expr = gnat_stabilize_reference (gnu_expr, 1);\n+\t\t    add_stmt (gnu_expr);\n+\t\t  }\n+\n \t\tgnu_size = 0;\n \t\tused_by_ref = 1;\n \t      }\n@@ -999,17 +1022,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   with the symbol we need to export in addition.  Don't use the\n \t   Interface_Name if there is an address clause (see CD30005).  */\n \tif (! Is_VMS_Exception (gnat_entity)\n-\t    &&\n-\t    ((Present (Interface_Name (gnat_entity))\n-\t      && No (Address_Clause (gnat_entity)))\n-\t     ||\n-\t     (Is_Public (gnat_entity)\n-\t      && (! Is_Imported (gnat_entity) || Is_Exported (gnat_entity)))))\n+\t    && ((Present (Interface_Name (gnat_entity))\n+\t\t && No (Address_Clause (gnat_entity)))\n+\t\t|| (Is_Public (gnat_entity)\n+\t\t    && (! Is_Imported (gnat_entity)\n+\t\t\t|| Is_Exported (gnat_entity)))))\n \t  gnu_ext_name = create_concat_name (gnat_entity, 0);\n \n \tif (const_flag)\n-\t  gnu_type = build_qualified_type (gnu_type, (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t\t      | TYPE_QUAL_CONST));\n+\t  {\n+\t    gnu_type = build_qualified_type (gnu_type, (TYPE_QUALS (gnu_type)\n+\t\t\t\t\t\t\t| TYPE_QUAL_CONST));\n+\t    if (gnu_expr)\n+\t      gnu_expr = convert (gnu_type, gnu_expr);\n+\t  }\n \n \t/* If this is constant initialized to a static constant and the\n \t   object has an aggregrate type, force it to be statically"}, {"sha": "a22815c79529c88695c078b88e985277bd123396", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=a5cb3b30256cbaa017ed825c6f7778166499a0a6", "patch": "@@ -94,6 +94,7 @@ static bool gnat_post_options\t\t(const char **);\n static HOST_WIDE_INT gnat_get_alias_set\t(tree);\n static void gnat_print_decl\t\t(FILE *, tree, int);\n static void gnat_print_type\t\t(FILE *, tree, int);\n+static int gnat_types_compatible_p\t(tree, tree);\n static const char *gnat_printable_name\t(tree, int);\n static tree gnat_eh_runtime_type\t(tree);\n static int gnat_eh_type_covers\t\t(tree, tree);\n@@ -102,6 +103,7 @@ static rtx gnat_expand_expr\t\t(tree, rtx, enum machine_mode, int,\n \t\t\t\t\t rtx *);\n static void internal_error_function\t(const char *, va_list *);\n static void gnat_adjust_rli\t\t(record_layout_info);\n+static tree gnat_type_max_size\t\t(tree);\n \n /* Definitions for our language-specific hooks.  */\n \n@@ -141,6 +143,10 @@ static void gnat_adjust_rli\t\t(record_layout_info);\n #define LANG_HOOKS_PRINT_DECL\t\tgnat_print_decl\n #undef LANG_HOOKS_PRINT_TYPE\n #define LANG_HOOKS_PRINT_TYPE\t\tgnat_print_type\n+#undef LANG_HOOKS_TYPES_COMPATIBLE_P\n+#define LANG_HOOKS_TYPES_COMPATIBLE_P\tgnat_types_compatible_p\n+#undef LANG_HOOKS_TYPE_MAX_SIZE\n+#define LANG_HOOKS_TYPE_MAX_SIZE\tgnat_type_max_size\n #undef LANG_HOOKS_DECL_PRINTABLE_NAME\n #define LANG_HOOKS_DECL_PRINTABLE_NAME\tgnat_printable_name\n #undef LANG_HOOKS_CALLGRAPH_EXPAND_FUNCTION\n@@ -555,6 +561,27 @@ gnat_print_type (FILE *file, tree node, int indent)\n     }\n }\n \n+/* We consider two types compatible if they have the same main variant,\n+   but we also consider two array types compatible if they have the same\n+   component type and bounds.\n+\n+   ??? We may also want to generalize to considering lots of integer types\n+   compatible, but we need to understand the effects of alias sets first.  */\n+\n+static int\n+gnat_types_compatible_p (tree x, tree y)\n+{\n+  if (TREE_CODE (x) == ARRAY_TYPE && TREE_CODE (y) == ARRAY_TYPE\n+      && gnat_types_compatible_p (TREE_TYPE (x), TREE_TYPE (y))\n+      && operand_equal_p (TYPE_MIN_VALUE (TYPE_DOMAIN (x)),\n+\t\t\t  TYPE_MIN_VALUE (TYPE_DOMAIN (y)), 0)\n+      && operand_equal_p (TYPE_MAX_VALUE (TYPE_DOMAIN (x)),\n+\t\t\t  TYPE_MAX_VALUE (TYPE_DOMAIN (y)), 0))\n+    return 1;\n+  else\n+    return TYPE_MAIN_VARIANT (x) == TYPE_MAIN_VARIANT (y);\n+}\n+\n static const char *\n gnat_printable_name (tree decl, int verbosity)\n {\n@@ -691,6 +718,15 @@ gnat_get_alias_set (tree type)\n   return -1;\n }\n \n+/* GNU_TYPE is a type.  Return its maxium size in bytes, if known.  */\n+\n+static tree\n+gnat_type_max_size (gnu_type)\n+     tree gnu_type;\n+{\n+  return max_size (TYPE_SIZE_UNIT (gnu_type), 1);\n+}\n+\n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n \n@@ -709,7 +745,7 @@ default_pass_by_ref (tree gnu_type)\n \n   if (targetm.calls.return_in_memory (gnu_type, NULL_TREE))\n     return true;\n-  \n+\n   if (AGGREGATE_TYPE_P (gnu_type)\n       && (! host_integerp (TYPE_SIZE (gnu_type), 1)\n \t  || 0 < compare_tree_int (TYPE_SIZE (gnu_type),"}, {"sha": "6635c1df741de9e8bd3d4be51a42884580de5eb0", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 171, "deletions": 86, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=a5cb3b30256cbaa017ed825c6f7778166499a0a6", "patch": "@@ -170,6 +170,8 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       Entity_Id standard_long_long_float, Entity_Id standard_exception_type,\n       Int gigi_operating_mode)\n {\n+  bool body_p;\n+  Entity_Id gnat_unit_entity;\n   tree gnu_standard_long_long_float;\n   tree gnu_standard_exception_type;\n \n@@ -198,9 +200,6 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       TYPE_SIZE_UNIT (void_type_node) = size_zero_node;\n     }\n \n-  if (Nkind (gnat_root) != N_Compilation_Unit)\n-    gigi_abort (301);\n-\n   /* Save the type we made for integer as the type for Standard.Integer.\n      Then make the rest of the standard types.  Note that some of these\n      may be subtypes.  */\n@@ -228,7 +227,74 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   if (Exception_Mechanism == GCC_ZCX)\n     gnat_init_gcc_eh ();\n \n-  gnat_to_gnu (gnat_root);\n+  /* Make the decl for the elaboration procedure.  */\n+  body_p = (Defining_Entity (Unit (gnat_root)),\n+\t    Nkind (Unit (gnat_root)) == N_Package_Body\n+\t    || Nkind (Unit (gnat_root)) == N_Subprogram_Body);\n+  gnat_unit_entity = Defining_Entity (Unit (gnat_root));\n+\n+  gnu_elab_proc_decl\n+    = create_subprog_decl\n+      (create_concat_name (gnat_unit_entity,\n+\t\t\t   body_p ? \"elabb\" : \"elabs\"),\n+       NULL_TREE, void_ftype, NULL_TREE, 0, 1, 0, 0, gnat_unit_entity);\n+\n+  DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n+  allocate_struct_function (gnu_elab_proc_decl);\n+  Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n+  cfun = 0;\n+\n+      /* For a body, first process the spec if there is one. */\n+  if (Nkind (Unit (gnat_root)) == N_Package_Body\n+      || (Nkind (Unit (gnat_root)) == N_Subprogram_Body\n+\t      && ! Acts_As_Spec (gnat_root)))\n+    add_stmt (gnat_to_gnu (Library_Unit (gnat_root)));\n+\n+  process_inlined_subprograms (gnat_root);\n+\n+  if (type_annotate_only)\n+    {\n+      elaborate_all_entities (gnat_root);\n+\n+\t  if (Nkind (Unit (gnat_root)) == N_Subprogram_Declaration\n+\t      || Nkind (Unit (gnat_root)) == N_Generic_Package_Declaration\n+\t      || Nkind (Unit (gnat_root)) == N_Generic_Subprogram_Declaration)\n+\t    return;\n+    }\n+\n+  process_decls (Declarations (Aux_Decls_Node (gnat_root)), Empty, Empty,\n+\t\t 1, 1);\n+  add_stmt (gnat_to_gnu (Unit (gnat_root)));\n+\n+  /* Process any pragmas and actions following the unit.  */\n+  add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_root)));\n+  add_stmt_list (Actions (Aux_Decls_Node (gnat_root)));\n+\n+  /* Generate elaboration code for this unit, if necessary, and say whether\n+     we did or not.  */\n+  Set_Has_No_Elaboration_Code (gnat_root, build_unit_elab ());\n+}\n+\f\n+/* Perform initializations for this module.  */\n+\n+void\n+gnat_init_stmt_group ()\n+{\n+  /* Initialize ourselves.  */\n+  init_code_table ();\n+  start_stmt_group ();\n+\n+  global_stmt_group = current_stmt_group;\n+\n+  /* Enable GNAT stack checking method if needed */\n+  if (!Stack_Check_Probes_On_Target)\n+    set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n+\n+  if (Exception_Mechanism == Front_End_ZCX)\n+    abort ();\n+\n+  REAL_ARITHMETIC (dconstp5, RDIV_EXPR, dconst1, dconst2);\n+  REAL_ARITHMETIC (dconstmp5, RDIV_EXPR, dconstm1, dconst2);\n }\n \f\n /* Perform initializations for this module.  */\n@@ -424,23 +490,38 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  if (TREE_CODE (gnu_result) == PARM_DECL\n \t      && DECL_BY_COMPONENT_PTR_P (gnu_result))\n-\t    gnu_result = convert (build_pointer_type (gnu_result_type),\n-\t\t\t\t  gnu_result);\n+\t    gnu_result\n+\t      = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\tconvert (build_pointer_type (gnu_result_type),\n+\t\t\t\t\t gnu_result));\n \n \t  /* If the object is constant, we try to do the dereference directly\n \t     through the DECL_INITIAL.  This is actually required in order to\n \t     get correct aliasing information for renamed objects that are\n-\t     components of non-aliased aggregates, because the type of\n-\t     the renamed object and that of the aggregate don't alias.  */\n-\t  if (TREE_READONLY (gnu_result)\n-\t      && DECL_INITIAL (gnu_result)\n-\t      /* Strip possible conversion to reference type.  */\n-\t      && (initial = TREE_CODE (DECL_INITIAL (gnu_result)) == NOP_EXPR\n-\t\t\t    ? TREE_OPERAND (DECL_INITIAL (gnu_result), 0)\n-\t\t\t    : DECL_INITIAL (gnu_result), 1)\n-\t      && TREE_CODE (initial) == ADDR_EXPR\n-\t      && (TREE_CODE (TREE_OPERAND (initial, 0)) == ARRAY_REF\n-\t\t  || TREE_CODE (TREE_OPERAND (initial, 0)) == COMPONENT_REF))\n+\t     components of non-aliased aggregates, because the type of the\n+\t     renamed object and that of the aggregate don't alias.\n+\n+\t     Note that we expect the initial value to have been stabilized.\n+\t     If it contains e.g. a variable reference, we certainly don't want\n+\t     to re-evaluate the variable each time the renaming is used.\n+\n+\t     Stabilization is currently not performed at the global level but\n+\t     create_var_decl avoids setting DECL_INITIAL if the value is not\n+\t     constant then, and we get to the pointer dereference below.\n+\n+\t     ??? Couldn't the aliasing issue show up again in this case ?\n+\t     There is no obvious reason why not.  */\n+\t  else if (TREE_READONLY (gnu_result)\n+\t\t   && DECL_INITIAL (gnu_result)\n+\t\t   /* Strip possible conversion to reference type.  */\n+\t\t   && ((initial = TREE_CODE (DECL_INITIAL (gnu_result))\n+\t\t\t== NOP_EXPR\n+\t\t\t? TREE_OPERAND (DECL_INITIAL (gnu_result), 0)\n+\t\t\t: DECL_INITIAL (gnu_result), 1))\n+\t\t   && TREE_CODE (initial) == ADDR_EXPR\n+\t\t   && (TREE_CODE (TREE_OPERAND (initial, 0)) == ARRAY_REF\n+\t\t       || (TREE_CODE (TREE_OPERAND (initial, 0))\n+\t\t\t   == COMPONENT_REF)))\n \t    gnu_result = TREE_OPERAND (initial, 0);\n \t  else\n \t    gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n@@ -629,16 +710,22 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  int length = String_Length (gnat_string);\n \t  int i;\n \t  tree gnu_list = NULL_TREE;\n+\t  tree gnu_idx = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n \n \t  for (i = 0; i < length; i++)\n-\t    gnu_list\n-\t      = tree_cons (NULL_TREE,\n-\t\t\t   convert (TREE_TYPE (gnu_result_type),\n-\t\t\t\t    build_int_2 (Get_String_Char (gnat_string,\n-\t\t\t\t\t\t\t\t  i + 1),\n-\t\t\t\t\t\t 0)),\n+\t    {\n+\t      gnu_list\n+\t\t= tree_cons (gnu_idx,\n+\t\t\t     convert (TREE_TYPE (gnu_result_type),\n+\t\t\t\t      build_int_2\n+\t\t\t\t      (Get_String_Char (gnat_string, i + 1),\n+\t\t\t\t       0)),\n \t\t\t   gnu_list);\n \n+\t      gnu_idx = int_const_binop (PLUS_EXPR, gnu_idx, integer_one_node,\n+\t\t\t\t\t 0);\n+\t    }\n+\n \t  gnu_result\n \t    = gnat_build_constructor (gnu_result_type, nreverse (gnu_list));\n \t}\n@@ -2149,7 +2236,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t      TREE_VALUE (gnu_switch_label_stack)));\n \n \t  }\n-\t\n+\n \t/* Now emit a definition of the label all the cases branched to. */\n \tadd_stmt (build1 (LABEL_EXPR, void_type_node,\n \t\t\t  TREE_VALUE (gnu_switch_label_stack)));\n@@ -2785,6 +2872,16 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      gnu_actual = convert (get_unpadded_type (Etype (gnat_actual)),\n \t\t\t\t    gnu_actual);\n \n+\t    /* Unless this is an In parameter, we must remove any LJM building\n+\t       from GNU_NAME.  */\n+\t    if (Ekind (gnat_formal) != E_In_Parameter\n+\t\t&& TREE_CODE (gnu_name) == CONSTRUCTOR\n+\t\t&& TREE_CODE (TREE_TYPE (gnu_name)) == RECORD_TYPE\n+\t\t&& TYPE_LEFT_JUSTIFIED_MODULAR_P (TREE_TYPE (gnu_name)))\n+\t      gnu_name\n+\t\t= convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_name))),\n+\t\t\t   gnu_name);\n+\n \t    if (Ekind (gnat_formal) != E_Out_Parameter\n \t\t&& ! unchecked_convert_p\n \t\t&& Do_Range_Check (gnat_actual))\n@@ -3149,29 +3246,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Compilation_Unit:\n \n-      /* If this is the main unit, make the decl for the elaboration\n-\t procedure.  Otherwise, push a statement group for this nested\n-\t compilation unit.  */\n-      if (gnat_node == Cunit (Main_Unit))\n-\t{\n-\t  bool body_p = (Defining_Entity (Unit (gnat_node)),\n-\t\t\t Nkind (Unit (gnat_node)) == N_Package_Body\n-\t\t\t || Nkind (Unit (gnat_node)) == N_Subprogram_Body);\n-\t  Entity_Id gnat_unit_entity = Defining_Entity (Unit (gnat_node));\n-\n-\t  gnu_elab_proc_decl\n-\t    = create_subprog_decl\n-\t      (create_concat_name (gnat_unit_entity,\n-\t\t\t\t   body_p ? \"elabb\" : \"elabs\"),\n-\t       NULL_TREE, void_ftype, NULL_TREE, 0, 1, 0, 0, gnat_unit_entity);\n-\n-\t  DECL_ELABORATION_PROC_P (gnu_elab_proc_decl) = 1;\n-\t  allocate_struct_function (gnu_elab_proc_decl);\n-\t  Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n-\t  cfun = 0;\n-\t}\n-      else\n-\tstart_stmt_group ();\n+      /* This is not called for the main unit, which is handled in function\n+\t gigi above.  */\n+      start_stmt_group ();\n \n       /* For a body, first process the spec if there is one. */\n       if (Nkind (Unit (gnat_node)) == N_Package_Body\n@@ -3180,41 +3257,16 @@ gnat_to_gnu (Node_Id gnat_node)\n \tadd_stmt (gnat_to_gnu (Library_Unit (gnat_node)));\n \n       process_inlined_subprograms (gnat_node);\n-\n-      if (type_annotate_only && gnat_node == Cunit (Main_Unit))\n-\t{\n-\t  elaborate_all_entities (gnat_node);\n-\n-\t  if (Nkind (Unit (gnat_node)) == N_Subprogram_Declaration\n-\t      || Nkind (Unit (gnat_node)) == N_Generic_Package_Declaration\n-\t      || Nkind (Unit (gnat_node)) == N_Generic_Subprogram_Declaration)\n-\t    {\n-\t      gnu_result = alloc_stmt_list ();\n-\t      break;\n-\t    }\n-\t}\n-\n       process_decls (Declarations (Aux_Decls_Node (gnat_node)),\n \t\t     Empty, Empty, 1, 1);\n       add_stmt (gnat_to_gnu (Unit (gnat_node)));\n \n       /* Process any pragmas and actions following the unit.  */\n       add_stmt_list (Pragmas_After (Aux_Decls_Node (gnat_node)));\n       add_stmt_list (Actions (Aux_Decls_Node (gnat_node)));\n-      \n-      /* If this is the main unit, generate elaboration code for this\n-\t unit, if necessary, and say whether we did or not.  Otherwise,\n-\t there is no elaboration code and we end our statement group. */\n-      if (gnat_node == Cunit (Main_Unit))\n-\t{\n-\t  Set_Has_No_Elaboration_Code (gnat_node, build_unit_elab ());\n-\t  gnu_result = alloc_stmt_list ();\n-\t}\n-      else\n-\t{\n-\t  Set_Has_No_Elaboration_Code (gnat_node, 1);\n-\t  gnu_result = end_stmt_group ();\n-\t}\n+\n+      Set_Has_No_Elaboration_Code (gnat_node, 1);\n+      gnu_result = end_stmt_group ();\n       break;\n \n     case N_Subprogram_Body_Stub:\n@@ -3317,7 +3369,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t    (set_jmpbuf_decl,\n \t\t     build_unary_op (ADDR_EXPR, NULL_TREE, gnu_jmpbuf_decl)));\n \n-\t\n+\n \tif (Present (First_Real_Statement (gnat_node)))\n \t  process_decls (Statements (gnat_node), Empty,\n \t\t\t First_Real_Statement (gnat_node), 1, 1);\n@@ -3358,7 +3410,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t gnat_temp = Next_Non_Pragma (gnat_temp))\n \t      {\n \t\tgnu_expr = gnat_to_gnu (gnat_temp);\n-\t\t\n+\n \t\t/* If this is the first one, set it as the outer one.\n \t\t   Otherwise, point the \"else\" part of the previous handler\n \t\t   to us. Then point to our \"else\" part.  */\n@@ -3791,7 +3843,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  gnu_result = build_call_alloc_dealloc (gnu_ptr, gnu_obj_size, align,\n \t\t\t\t\t\t Procedure_To_Call (gnat_node),\n-\t\t\t\t\t\t Storage_Pool (gnat_node), \n+\t\t\t\t\t\t Storage_Pool (gnat_node),\n \t\t\t\t\t\t gnat_node);\n \t}\n       break;\n@@ -4047,9 +4099,25 @@ add_stmt (tree gnu_stmt)\n   append_to_statement_list (gnu_stmt, &current_stmt_group->stmt_list);\n \n   /* If we're at top level, show everything in here is in use in case\n-     any of it is shared by a subprogram.  */\n+     any of it is shared by a subprogram.\n+\n+     ??? If this is a DECL_EXPR for a VAR_DECL or CONST_DECL, we must\n+     walk the sizes and DECL_INITIAL since we won't be walking the\n+     BIND_EXPR here.  This whole thing is a mess!  */\n   if (!current_function_decl)\n-    walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n+    {\n+      walk_tree (&gnu_stmt, mark_visited, NULL, NULL);\n+      if (TREE_CODE (gnu_stmt) == DECL_EXPR\n+\t  && (TREE_CODE (DECL_EXPR_DECL (gnu_stmt)) == VAR_DECL\n+\t      || TREE_CODE (DECL_EXPR_DECL (gnu_stmt)) == CONST_DECL))\n+\t{\n+\t  tree gnu_decl = DECL_EXPR_DECL (gnu_stmt);\n+\n+\t  walk_tree (&DECL_SIZE (gnu_decl), mark_visited, NULL, NULL);\n+\t  walk_tree (&DECL_SIZE_UNIT (gnu_decl), mark_visited, NULL, NULL);\n+\t  walk_tree (&DECL_INITIAL (gnu_decl), mark_visited, NULL, NULL);\n+\t}\n+    }\n }\n \n /* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n@@ -4116,7 +4184,7 @@ add_decl_expr (tree gnu_decl, Entity_Id gnat_entity)\n \t  tree gnu_assign_stmt\n \t    = build_binary_op (MODIFY_EXPR, NULL_TREE,\n \t\t\t       gnu_lhs, DECL_INITIAL (gnu_decl));\n-\t  \n+\n \t  DECL_INITIAL (gnu_decl) = 0;\n \t  annotate_with_locus (gnu_assign_stmt,\n \t\t\t       DECL_SOURCE_LOCATION (gnu_decl));\n@@ -4134,7 +4202,10 @@ mark_visited (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n {\n   if (TREE_VISITED (*tp))\n     *walk_subtrees = 0;\n-  else\n+\n+  /* Don't mark a dummy type as visited because we want to mark its sizes\n+     and fields once it's filled in.  */\n+  else if (!TYPE_IS_DUMMY_P (*tp))\n     TREE_VISITED (*tp) = 1;\n \n   return NULL_TREE;\n@@ -4421,7 +4492,7 @@ gnat_expand_body_1 (tree gnu_decl, bool nested_p)\n {\n   if (nested_p)\n     push_function_context ();\n-    \n+\n   tree_rest_of_compilation (gnu_decl, nested_p);\n \n   if (nested_p)\n@@ -5304,9 +5375,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t= tree_cons (gnu_index, convert (TREE_TYPE (gnu_array_type), gnu_expr),\n \t\t     gnu_expr_list);\n \n-      gnu_index = fold (build2 (PLUS_EXPR, TREE_TYPE (gnu_index), gnu_index,\n-\t\t\t\tconvert (TREE_TYPE (gnu_index),\n-\t\t\t\t\t integer_one_node)));\n+      gnu_index = int_const_binop (PLUS_EXPR, gnu_index, integer_one_node, 0);\n     }\n \n   return gnat_build_constructor (gnu_array_type, nreverse (gnu_expr_list));\n@@ -5500,6 +5569,19 @@ gnat_stabilize_reference (tree ref, int force)\n     }\n \n   TREE_READONLY (result) = TREE_READONLY (ref);\n+\n+  /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS attached to the initial\n+     expression may not be sustained across some paths, such as the way via\n+     build1 for INDIRECT_REF.  We re-populate those flags here for the general\n+     case, which is consistent with the GCC version of this routine.\n+\n+     Special care should be taken regarding TREE_SIDE_EFFECTS, because some\n+     paths introduce side effects where there was none initially (e.g. calls\n+     to save_expr), and we also want to keep track of that.  */\n+\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n+  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (ref);\n+\n   return result;\n }\n \n@@ -5569,6 +5651,9 @@ gnat_stabilize_reference_1 (tree e, int force)\n     }\n \n   TREE_READONLY (result) = TREE_READONLY (e);\n+\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n+  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n   return result;\n }\n \f"}, {"sha": "dc8a5b129f8f8120ec9e3cbf9ef6684fb2953bee", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5cb3b30256cbaa017ed825c6f7778166499a0a6/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=a5cb3b30256cbaa017ed825c6f7778166499a0a6", "patch": "@@ -230,6 +230,7 @@ gnat_pushlevel ()\n     BLOCK_SUPERCONTEXT (newlevel->block) = current_binding_level->block;\n \n   BLOCK_VARS (newlevel->block) = BLOCK_SUBBLOCKS (newlevel->block) = NULL_TREE;\n+  TREE_USED (newlevel->block) = 1;\n \n   /* Add this level to the front of the chain (stack) of levels that are\n      active.  */\n@@ -362,7 +363,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t      && DECL_ARTIFICIAL (TYPE_NAME (TREE_TYPE (decl)))\n \t      && ! DECL_ARTIFICIAL (decl))))\n     TYPE_NAME (TREE_TYPE (decl)) = decl;\n-  \n+\n   if (TREE_CODE (decl) != CONST_DECL)\n     rest_of_decl_compilation (decl, NULL, global_bindings_p (), 0);\n }\n@@ -404,9 +405,6 @@ gnat_init_decl_processing (void)\n   gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"long integer\"),\n \t\t\t     long_integer_type_node),\n \t\t Empty);\n-  gnat_pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"),\n-\t\t\t     void_type_node),\n-\t\t Empty);\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n \n@@ -464,6 +462,13 @@ gnat_install_builtins ()\n   gnat_define_builtin (\"__builtin_memcmp\", ftype, BUILT_IN_MEMCMP,\n \t\t       \"memcmp\", false);\n \n+  tmp = tree_cons (NULL_TREE, size_type_node, void_list_node);\n+  tmp = tree_cons (NULL_TREE, integer_type_node, tmp);\n+  tmp = tree_cons (NULL_TREE, ptr_void_type_node, tmp);\n+  ftype = build_function_type (integer_type_node, tmp);\n+  gnat_define_builtin (\"__builtin_memset\", ftype, BUILT_IN_MEMSET,\n+\t\t       \"memset\", false);\n+\n   tmp = tree_cons (NULL_TREE, integer_type_node, void_list_node);\n   ftype = build_function_type (integer_type_node, tmp);\n   gnat_define_builtin (\"__builtin_clz\", ftype, BUILT_IN_CLZ, \"clz\", true);\n@@ -2827,10 +2832,8 @@ convert (tree type, tree expr)\n       return expr;\n \n     case STRING_CST:\n-    case CONSTRUCTOR:\n       /* If we are converting a STRING_CST to another constrained array type,\n-\t just make a new one in the proper type.  Likewise for\n-\t CONSTRUCTOR if the alias sets are the same.  */\n+\t just make a new one in the proper type.  */\n       if (code == ecode && AGGREGATE_TYPE_P (etype)\n \t  && ! (TREE_CODE (TYPE_SIZE (etype)) == INTEGER_CST\n \t\t&& TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n@@ -2843,21 +2846,6 @@ convert (tree type, tree expr)\n \t}\n       break;\n \n-    case COMPONENT_REF:\n-      /* If we are converting between two aggregate types of the same\n-\t kind, size, mode, and alignment, just make a new COMPONENT_REF.\n-\t This avoid unneeded conversions which makes reference computations\n-\t more complex.  */\n-      if (code == ecode && TYPE_MODE (type) == TYPE_MODE (etype)\n-\t  && AGGREGATE_TYPE_P (type) && AGGREGATE_TYPE_P (etype)\n-\t  && TYPE_ALIGN (type) == TYPE_ALIGN (etype)\n-\t  && operand_equal_p (TYPE_SIZE (type), TYPE_SIZE (etype), 0)\n-\t  && get_alias_set (type) == get_alias_set (etype))\n-\treturn build (COMPONENT_REF, type, TREE_OPERAND (expr, 0),\n-\t\t      TREE_OPERAND (expr, 1), NULL_TREE);\n-\n-      break;\n-\n     case UNCONSTRAINED_ARRAY_REF:\n       /* Convert this to the type of the inner array by getting the address of\n \t the array from the template.  */"}]}