{"sha": "65df5b719406d99296f303a3ba4ccef5a3752e19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkZjViNzE5NDA2ZDk5Mjk2ZjMwM2EzYmE0Y2NlZjVhMzc1MmUxOQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2008-04-08T06:50:51Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:50:51Z"}, "message": "exp_ch9.ads, [...] (Build_Protected_Entry, [...]): Generate debug info for declarations related to the handling of private data in...\n\n2008-04-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\n\t* exp_ch9.ads, exp_ch9.adb (Build_Protected_Entry,\n\tBuild_Unprotected_Subprogram_Body): Generate debug info for\n\tdeclarations related to the handling of private data in task and\n\tprotected types.\n\t(Debug_Private_Data_Declarations): New subprogram.\n\t(Install_Private_Data_Declarations): Remove all debug info flagging.\n\tThis is now done by Debug_Private_Data_Declarations at the correct\n\tstage of expansion.\n\t(Build_Simple_Entry_Call): If the task name is a function call, expand\n\tthe prefix into an object declaration, and make the surrounding block a\n\ttask master.\n\t(Build_Master_Entity): An internal block is a master if it wraps a call.\n\tCode reformatting, update comments. Code clean up.\n\t(Make_Task_Create_Call): Use 'Unrestricted_Access instead of 'Address.\n\t(Replicate_Entry_Formals): If the formal is an access parameter or\n\tanonymous access to subprogram, copy the original tree to create new\n\tentities for the formals of the subprogram.\n\t(Expand_N_Task_Type_Declaration): Create a Relative_Deadline variable\n\tfor tasks to store the value passed using pragma Relative_Deadline.\n\t(Make_Task_Create_Call): Add the Relative_Deadline argument to the\n\trun-time call to create a task.\n\t(Build_Wrapper_Spec): If the controlling argument of the interface\n\toperation is an access parameter with a non-null indicator, use the\n\tnon-null indicator on the wrapper.\n\n\t* sem_ch9.adb (Analyze_Protected_Type): Only retrieve the full view when\n\tpresent, which it may not be in the case where the type entity is an\n\tincomplete view brought in by a limited with.\n\t(Analyze_Task_Type): Only retrieve the full view when present, which it\n\tmay not be in the case where the type entity is an incomplete view\n\tbrought in by a limited with.\n\t(Analyze_Protected_Definition): Set Is_Frozen on all itypes generated for\n\tprivate components of a protected type, to prevent the generation of\n\tfreeze nodes for which there is no proper scope of elaboration.\n\n\t* exp_util.ads, exp_util.adb (Remove_Side_Effects): If the expression is\n\ta function call that returns a task, expand into a declaration to invoke\n\tthe build_in_place machinery.\n\t(Find_Protection_Object): New routine.\n\t(Remove_Side_Effects): Also make a copy of the value\n\tfor attributes whose result is of an elementary type.\n\t(Silly_Boolean_Array_Not_Test): New procedure\n\t(Silly_Boolean_Array_Xor_Test): New procedure\n\t(Is_Volatile_Reference): New function\n\t(Remove_Side_Effects): Use Is_Volatile_Reference\n\t(Possible_Bit_Aligned_Component): Handle slice case properly\n\n\t* exp_pakd.adb (Expand_Packed_Not): Move silly true/true or false/false\n\tcase test to Exp_Util\n\t(Expand_Packed_Xor): Move silly true/true case test to Exp_Util\n\nFrom-SVN: r134030", "tree": {"sha": "9188d82c46a135582ea73731887923f5d1dd3edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9188d82c46a135582ea73731887923f5d1dd3edb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65df5b719406d99296f303a3ba4ccef5a3752e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65df5b719406d99296f303a3ba4ccef5a3752e19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65df5b719406d99296f303a3ba4ccef5a3752e19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65df5b719406d99296f303a3ba4ccef5a3752e19/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dcfa065d7cd329cdacd200032668a6480251c7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcfa065d7cd329cdacd200032668a6480251c7cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcfa065d7cd329cdacd200032668a6480251c7cd"}], "stats": {"total": 2712, "additions": 1446, "deletions": 1266}, "files": [{"sha": "b999bfaa6c45ed26c277e6f2988175f065a25234", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1024, "deletions": 1058, "changes": 2082, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=65df5b719406d99296f303a3ba4ccef5a3752e19"}, {"sha": "71c1e830c3cc7ed2d66497c66dd7409507fb9bea", "filename": "gcc/ada/exp_ch9.ads", "status": "modified", "additions": 73, "deletions": 78, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_ch9.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_ch9.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.ads?ref=65df5b719406d99296f303a3ba4ccef5a3752e19", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -25,7 +25,6 @@\n \n --  Expand routines for chapter 9 constructs\n \n-with Namet; use Namet;\n with Types; use Types;\n \n package Exp_Ch9 is\n@@ -37,41 +36,6 @@ package Exp_Ch9 is\n    --  This type is used to distinguish the different protection modes of a\n    --  protected subprogram.\n \n-   procedure Add_Discriminal_Declarations\n-     (Decls : List_Id;\n-      Typ   : Entity_Id;\n-      Name  : Name_Id;\n-      Loc   : Source_Ptr);\n-   --  This routine is used to add discriminal declarations to task and\n-   --  protected operation bodies. The discriminants are available by normal\n-   --  selection from the concurrent object (whose name is passed as the third\n-   --  parameter). Discriminant references inside the body have already\n-   --  been replaced by references to the corresponding discriminals. The\n-   --  declarations constructed by this procedure hook the references up with\n-   --  the objects:\n-   --\n-   --    discriminal_name : discr_type renames name.discriminant_name;\n-   --\n-   --  Obviously we could have expanded the discriminant references in the\n-   --  first place to be the appropriate selection, but this turns out to\n-   --  be hard to do because it would introduce difference in handling of\n-   --  discriminant references depending on their location.\n-\n-   procedure Add_Private_Declarations\n-     (Decls : List_Id;\n-      Typ   : Entity_Id;\n-      Name  : Name_Id;\n-      Loc : Source_Ptr);\n-   --  This routine is used to add private declarations to protected bodies.\n-   --  These are analogous to the discriminal declarations added to tasks\n-   --  and protected operations, and consist of a renaming of each private\n-   --  object to a selection from the concurrent object passed as an extra\n-   --  parameter to each such operation:\n-   --    private_name : private_type renames name.private_name;\n-   --  As with discriminals, private references inside the protected\n-   --  subprogram bodies have already been replaced by references to the\n-   --  corresponding privals.\n-\n    procedure Build_Activation_Chain_Entity (N : Node_Id);\n    --  Given a declaration N of an object that is a task, or contains tasks\n    --  (other than allocators to tasks) this routine ensures that an activation\n@@ -113,12 +77,12 @@ package Exp_Ch9 is\n    --  declarative part.\n \n    function Build_Protected_Sub_Specification\n-     (N       : Node_Id;\n-      Prottyp : Entity_Id;\n-      Mode    : Subprogram_Protection_Mode) return Node_Id;\n-   --  Build specification for protected subprogram. This is called when\n+     (N        : Node_Id;\n+      Prot_Typ : Entity_Id;\n+      Mode     : Subprogram_Protection_Mode) return Node_Id;\n+   --  Build the specification for protected subprogram. This is called when\n    --  expanding a protected type, and also when expanding the declaration for\n-   --  an Access_To_Protected_Subprogram type. In the latter case, Prottyp is\n+   --  an Access_To_Protected_Subprogram type. In the latter case, Prot_Typ is\n    --  empty, and the first parameter of the signature of the protected op is\n    --  of type System.Address.\n \n@@ -242,10 +206,6 @@ package Exp_Ch9 is\n    --  now, within the context of the protected object, to resolve calls to\n    --  other protected functions.\n \n-   procedure Expand_Entry_Body_Declarations (N : Node_Id);\n-   --  Expand declarations required for the expansion of the\n-   --  statements of the body.\n-\n    procedure Expand_N_Abort_Statement            (N : Node_Id);\n    procedure Expand_N_Accept_Statement           (N : Node_Id);\n    procedure Expand_N_Asynchronous_Select        (N : Node_Id);\n@@ -277,11 +237,10 @@ package Exp_Ch9 is\n    procedure Expand_Protected_Body_Declarations\n      (N       : Node_Id;\n       Spec_Id : Entity_Id);\n-   --  Expand declarations required for a protected body. See bodies of\n-   --  both Expand_Protected_Body_Declarations and Expand_N_Protected_Body\n-   --  for full details of the nature and use of these declarations.\n-   --  The second argument is the entity for the corresponding\n-   --  protected type declaration.\n+   --  Expand declarations required for a protected body. See bodies of both\n+   --  Expand_Protected_Body_Declarations and Expand_N_Protected_Body for full\n+   --  details of the nature and use of these declarations. The second argument\n+   --  is the entity for the corresponding protected type declaration.\n \n    function External_Subprogram (E : Entity_Id) return Entity_Id;\n    --  return the external version of a protected operation, which locks\n@@ -291,43 +250,79 @@ package Exp_Ch9 is\n    --  Given the declarations list for a protected body, find the\n    --  first protected operation body.\n \n+   procedure Install_Private_Data_Declarations\n+     (Loc      : Source_Ptr;\n+      Spec_Id  : Entity_Id;\n+      Conc_Typ : Entity_Id;\n+      Body_Nod : Node_Id;\n+      Decls    : List_Id;\n+      Barrier  : Boolean := False;\n+      Family   : Boolean := False);\n+   --  This routines generates several types, objects and object renamings used\n+   --  in the handling of discriminants and private components of protected and\n+   --  task types. It also generates the entry index for entry families. Formal\n+   --  Spec_Id denotes an entry, entry family or a subprogram, Conc_Typ is the\n+   --  concurrent type where Spec_Id resides, Body_Nod is the corresponding\n+   --  body of Spec_Id, Decls are the declarations of the subprogram or entry.\n+   --  Flag Barrier denotes whether the context is an entry barrier function.\n+   --  Flag Family is used in conjunction with Barrier to denote a barrier for\n+   --  an entry family.\n+   --\n+   --  The generated types, entities and renamings are:\n+   --\n+   --  * If flag Barrier is set or Spec_Id denotes a protected entry or an\n+   --    entry family, generate:\n+   --\n+   --      type prot_typVP is access prot_typV;\n+   --      _object : prot_typVP := prot_typV (_O);\n+   --\n+   --    where prot_typV is the corresponding record of a protected type and\n+   --    _O is a formal parameter representing the concurrent object of either\n+   --    the barrier function or the entry (family).\n+   --\n+   --  * If Conc_Typ is a protected type, create a renaming for the Protection\n+   --    field _object:\n+   --\n+   --      conc_typR : protection_typ renames _object._object;\n+   --\n+   --  * If Conc_Typ has discriminants, create renamings of the form:\n+   --\n+   --      discr_nameD : discr_typ renames _object.discr_name;\n+   --        or\n+   --      discr_nameD : discr_typ renames _task.discr_name;\n+   --\n+   --  * If Conc_Typ denotes a protected type and has private components,\n+   --    generate renamings of the form:\n+   --\n+   --      comp_name : comp_typ renames _object.comp_name;\n+   --\n+   --  * Finally, is flag Barrier and Family are set or Spec_Id denotes an\n+   --    entry family, generate the entry index constant:\n+   --\n+   --      subtype Jnn is <Type of Index> range Low .. High;\n+   --      J : constant Jnn :=\n+   --            Jnn'Val (_E - <Index expression> + Jnn'Pos (Jnn'First));\n+   --\n+   --  All the above declarations are inserted in the order shown to the front\n+   --  of Decls.\n+\n    function Make_Task_Create_Call (Task_Rec : Entity_Id) return Node_Id;\n    --  Given the entity of the record type created for a task type, build\n    --  the call to Create_Task\n \n    function Make_Initialize_Protection\n-     (Protect_Rec : Entity_Id)\n-      return        List_Id;\n+     (Protect_Rec : Entity_Id) return List_Id;\n    --  Given the entity of the record type created for a protected type, build\n    --  a list of statements needed for proper initialization of the object.\n \n    function Next_Protected_Operation (N : Node_Id) return Node_Id;\n-   --  Given a protected operation node (a subprogram or entry body),\n-   --  find the following node in the declarations list.\n+   --  Given a protected operation node (a subprogram or entry body), find the\n+   --  following node in the declarations list.\n \n    procedure Set_Discriminals (Dec : Node_Id);\n-   --  Replace discriminals in a protected type for use by the\n-   --  next protected operation on the type. Each operation needs a\n-   --  new set of discriminals, since it needs a unique renaming of\n-   --  the discriminant fields in the record used to implement the\n-   --  protected type.\n-\n-   procedure Set_Privals\n-      (Dec           : Node_Id;\n-       Op            : Node_Id;\n-       Loc           : Source_Ptr;\n-       After_Barrier : Boolean := False);\n-   --  Associates a new set of privals (placeholders for later access to\n-   --  private components of protected objects) with the private object\n-   --  declarations of a protected object. These will be used to expand\n-   --  the references to private objects in the next protected\n-   --  subprogram or entry body to be expanded.\n-   --\n-   --  The flag After_Barrier indicates whether this is called after building\n-   --  the barrier function for an entry body. This flag determines whether\n-   --  the privals should have source names (which simplifies debugging) or\n-   --  internally generated names. Entry barriers contain no debuggable code,\n-   --  and there may be visibility conflicts between an entry index and a\n-   --  a prival, so  privals for barrier function have internal names.\n+   --  Replace discriminals in a protected type for use by the next protected\n+   --  operation on the type. Each operation needs a new set of discirminals,\n+   --  since it needs a unique renaming of the discriminant fields in the\n+   --  record used to implement the protected type.\n \n end Exp_Ch9;"}, {"sha": "8f191be3a367a2acc60f7a323acd69fc39e19a5c", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 8, "deletions": 70, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=65df5b719406d99296f303a3ba4ccef5a3752e19", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1092,7 +1092,7 @@ package body Exp_Pakd is\n          --  discriminants, so we treat it as a default/per-object expression.\n \n          Set_Parent (Len_Expr, Typ);\n-         Analyze_Per_Use_Expression (Len_Expr, Standard_Long_Long_Integer);\n+         Preanalyze_Spec_Expression (Len_Expr, Standard_Long_Long_Integer);\n \n          --  Use a modular type if possible. We can do this if we have\n          --  static bounds, and the length is small enough, and the length\n@@ -1774,47 +1774,11 @@ package body Exp_Pakd is\n       Ltyp := Etype (L);\n       Rtyp := Etype (R);\n \n-      --  First an odd and silly test. We explicitly check for the XOR\n-      --  case where the component type is True .. True, since this will\n-      --  raise constraint error. A special check is required since CE\n-      --  will not be required other wise (cf Expand_Packed_Not).\n-\n-      --  No such check is required for AND and OR, since for both these\n-      --  cases False op False = False, and True op True = True.\n+      --  Deeal with silly case of XOR where the subcomponent has a range\n+      --  True .. True where an exception must be raised.\n \n       if Nkind (N) = N_Op_Xor then\n-         declare\n-            CT : constant Entity_Id := Component_Type (Rtyp);\n-            BT : constant Entity_Id := Base_Type (CT);\n-\n-         begin\n-            Insert_Action (N,\n-              Make_Raise_Constraint_Error (Loc,\n-                Condition =>\n-                  Make_Op_And (Loc,\n-                    Left_Opnd =>\n-                      Make_Op_Eq (Loc,\n-                        Left_Opnd =>\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Occurrence_Of (CT, Loc),\n-                            Attribute_Name => Name_First),\n-\n-                        Right_Opnd =>\n-                          Convert_To (BT,\n-                            New_Occurrence_Of (Standard_True, Loc))),\n-\n-                    Right_Opnd =>\n-                      Make_Op_Eq (Loc,\n-                        Left_Opnd =>\n-                          Make_Attribute_Reference (Loc,\n-                            Prefix         => New_Occurrence_Of (CT, Loc),\n-                            Attribute_Name => Name_Last),\n-\n-                        Right_Opnd =>\n-                          Convert_To (BT,\n-                            New_Occurrence_Of (Standard_True, Loc)))),\n-                Reason => CE_Range_Check_Failed));\n-         end;\n+         Silly_Boolean_Array_Xor_Test (N, Rtyp);\n       end if;\n \n       --  Now that that silliness is taken care of, get packed array type\n@@ -2186,37 +2150,11 @@ package body Exp_Pakd is\n       Convert_To_Actual_Subtype (Opnd);\n       Rtyp := Etype (Opnd);\n \n-      --  First an odd and silly test. We explicitly check for the case\n-      --  where the 'First of the component type is equal to the 'Last of\n-      --  this component type, and if this is the case, we make sure that\n-      --  constraint error is raised. The reason is that the NOT is bound\n-      --  to cause CE in this case, and we will not otherwise catch it.\n+      --  Deal with silly False..False and True..True subtype case\n \n-      --  Believe it or not, this was reported as a bug. Note that nearly\n-      --  always, the test will evaluate statically to False, so the code\n-      --  will be statically removed, and no extra overhead caused.\n+      Silly_Boolean_Array_Not_Test (N, Rtyp);\n \n-      declare\n-         CT : constant Entity_Id := Component_Type (Rtyp);\n-\n-      begin\n-         Insert_Action (N,\n-           Make_Raise_Constraint_Error (Loc,\n-             Condition =>\n-               Make_Op_Eq (Loc,\n-                 Left_Opnd =>\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Occurrence_Of (CT, Loc),\n-                     Attribute_Name => Name_First),\n-\n-                 Right_Opnd =>\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Occurrence_Of (CT, Loc),\n-                     Attribute_Name => Name_Last)),\n-             Reason => CE_Range_Check_Failed));\n-      end;\n-\n-      --  Now that that silliness is taken care of, get packed array type\n+      --  Now that the silliness is taken care of, get packed array type\n \n       Convert_To_PAT_Type (Opnd);\n       PAT := Etype (Opnd);"}, {"sha": "12fea51a197228b5b10bc7f5ef73c3f52668e810", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 222, "deletions": 35, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=65df5b719406d99296f303a3ba4ccef5a3752e19", "patch": "@@ -336,7 +336,7 @@ package body Exp_Util is\n    --  component, whose prefix is the outer variable of the array type.\n    --  The n-dimensional array type has known indices Index, Index2...\n    --  Id_Ref is an indexed component form created by the enclosing init proc.\n-   --  Its successive indices are Val1, Val2,.. which are the loop variables\n+   --  Its successive indices are Val1, Val2, ... which are the loop variables\n    --  in the loops that call the individual task init proc on each component.\n \n    --  The generated function has the following structure:\n@@ -962,9 +962,16 @@ package body Exp_Util is\n          if Has_Entries (Typ)\n            or else Has_Interrupt_Handler (Typ)\n            or else (Has_Attach_Handler (Typ)\n-                     and then not Restricted_Profile)\n-           or else (Ada_Version >= Ada_05\n-                     and then Present (Interface_List (Parent (Typ))))\n+                      and then not Restricted_Profile)\n+\n+            --  A protected type without entries that covers an interface and\n+            --  overrides the abstract routines with protected procedures is\n+            --  considered equivalent to a protected type with entries in the\n+            --  context of dispatching select statements. It is sufficent to\n+            --  check for the presence of an interface list in the declaration\n+            --  node to recognize this case.\n+\n+           or else Present (Interface_List (Parent (Typ)))\n          then\n             if Abort_Allowed\n               or else Restriction_Active (No_Entry_Queue) = False\n@@ -1814,6 +1821,34 @@ package body Exp_Util is\n       return Node (Prim);\n    end Find_Prim_Op;\n \n+   ----------------------------\n+   -- Find_Protection_Object --\n+   ----------------------------\n+\n+   function Find_Protection_Object (Scop : Entity_Id) return Entity_Id is\n+      S : Entity_Id;\n+\n+   begin\n+      S := Scop;\n+      while Present (S) loop\n+         if (Ekind (S) = E_Entry\n+               or else Ekind (S) = E_Entry_Family\n+               or else Ekind (S) = E_Function\n+               or else Ekind (S) = E_Procedure)\n+           and then Present (Protection_Object (S))\n+         then\n+            return Protection_Object (S);\n+         end if;\n+\n+         S := Scope (S);\n+      end loop;\n+\n+      --  If we do not find a Protection object in the scope chain, then\n+      --  something has gone wrong, most likely the object was never created.\n+\n+      raise Program_Error;\n+   end Find_Protection_Object;\n+\n    ----------------------\n    -- Force_Evaluation --\n    ----------------------\n@@ -2292,13 +2327,14 @@ package body Exp_Util is\n          return;\n       end if;\n \n-      --  Ignore insert of actions from inside default expression in the\n-      --  special preliminary analyze mode. Any insertions at this point\n-      --  have no relevance, since we are only doing the analyze to freeze\n-      --  the types of any static expressions. See section \"Handling of\n-      --  Default Expressions\" in the spec of package Sem for further details.\n+      --  Ignore insert of actions from inside default expression (or other\n+      --  similar \"spec expression\") in the special spec-expression analyze\n+      --  mode. Any insertions at this point have no relevance, since we are\n+      --  only doing the analyze to freeze the types of any static expressions.\n+      --  See section \"Handling of Default Expressions\" in the spec of package\n+      --  Sem for further details.\n \n-      if In_Default_Expression then\n+      if In_Spec_Expression then\n          return;\n       end if;\n \n@@ -3028,6 +3064,10 @@ package body Exp_Util is\n \n       Get_Name_String (Chars (E));\n \n+      --  Most predefined primitives have internally generated names. Equality\n+      --  must be treated differently; the predefined operation is recognized\n+      --  as a homgeneous binary operator that returns Boolean.\n+\n       if Name_Len > TSS_Name_Type'Last then\n          TSS_Name := TSS_Name_Type (Name_Buffer (Name_Len - TSS_Name'Length + 1\n                                      .. Name_Len));\n@@ -3441,6 +3481,40 @@ package body Exp_Util is\n                and then Etype (Full_View (T)) /= T);\n    end Is_Untagged_Derivation;\n \n+   ---------------------------\n+   -- Is_Volatile_Reference --\n+   ---------------------------\n+\n+   function Is_Volatile_Reference (N : Node_Id) return Boolean is\n+   begin\n+      if Nkind (N) in N_Has_Etype\n+        and then Present (Etype (N))\n+        and then Treat_As_Volatile (Etype (N))\n+      then\n+         return True;\n+\n+      elsif Is_Entity_Name (N) then\n+         return Treat_As_Volatile (Entity (N));\n+\n+      elsif Nkind (N) = N_Slice then\n+         return Is_Volatile_Reference (Prefix (N));\n+\n+      elsif Nkind_In (N, N_Indexed_Component, N_Selected_Component) then\n+         if (Is_Entity_Name (Prefix (N))\n+               and then Has_Volatile_Components (Entity (Prefix (N))))\n+           or else (Present (Etype (Prefix (N)))\n+                      and then Has_Volatile_Components (Etype (Prefix (N))))\n+         then\n+            return True;\n+         else\n+            return Is_Volatile_Reference (Prefix (N));\n+         end if;\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Volatile_Reference;\n+\n    --------------------\n    -- Kill_Dead_Code --\n    --------------------\n@@ -4257,9 +4331,15 @@ package body Exp_Util is\n                end if;\n             end;\n \n-         --  If we have neither a record nor array component, it means that we\n-         --  have fallen off the top testing prefixes recursively, and we now\n-         --  have a stand alone object, where we don't have a problem.\n+         --  For a slice, test the prefix, if that is possibly misaligned,\n+         --  then for sure the slice is!\n+\n+         when N_Slice =>\n+            return Possible_Bit_Aligned_Component (Prefix (N));\n+\n+         --  If we have none of the above, it means that we have fallen off the\n+         --  top testing prefixes recursively, and we now have a stand alone\n+         --  object, where we don't have a problem.\n \n          when others =>\n             return False;\n@@ -4375,7 +4455,7 @@ package body Exp_Util is\n          --  hand, if we do not consider them to be side effect free, then\n          --  we get some awkward expansions in -gnato mode, resulting in\n          --  code insertions at a point where we do not have a clear model\n-         --  for performing the insertions. See 4908-002/comment for details.\n+         --  for performing the insertions.\n \n          --  Special handling for entity names\n \n@@ -4399,14 +4479,13 @@ package body Exp_Util is\n                return False;\n \n             --  Variables are considered to be a side effect if Variable_Ref\n-            --  is set or if we have a volatile variable and Name_Req is off.\n+            --  is set or if we have a volatile reference and Name_Req is off.\n             --  If Name_Req is True then we can't help returning a name which\n             --  effectively allows multiple references in any case.\n \n             elsif Is_Variable (N) then\n                return not Variable_Ref\n-                 and then (not Treat_As_Volatile (Entity (N))\n-                             or else Name_Req);\n+                 and then (not Is_Volatile_Reference (N) or else Name_Req);\n \n             --  Any other entity (e.g. a subtype name) is definitely side\n             --  effect free.\n@@ -4631,17 +4710,16 @@ package body Exp_Util is\n       Scope_Suppress := (others => True);\n \n       --  If it is a scalar type and we need to capture the value, just make\n-      --  a copy. Likewise for a function or operator call. And if we have a\n-      --  volatile variable and Nam_Req is not set (see comments above for\n-      --  Side_Effect_Free).\n+      --  a copy. Likewise for a function call, an attribute reference or an\n+      --  operator. And if we have a volatile reference and Name_Req is not\n+      --  set (see comments above for Side_Effect_Free).\n \n       if Is_Elementary_Type (Exp_Type)\n         and then (Variable_Ref\n                    or else Nkind (Exp) = N_Function_Call\n+                   or else Nkind (Exp) = N_Attribute_Reference\n                    or else Nkind (Exp) in N_Op\n-                   or else (not Name_Req\n-                             and then Is_Entity_Name (Exp)\n-                             and then Treat_As_Volatile (Entity (Exp))))\n+                   or else (not Name_Req and then Is_Volatile_Reference (Exp)))\n       then\n          Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n          Set_Etype (Def_Id, Exp_Type);\n@@ -4686,9 +4764,9 @@ package body Exp_Util is\n \n       --  If this is a type conversion, leave the type conversion and remove\n       --  the side effects in the expression. This is important in several\n-      --  circumstances: for change of representations, and also when this\n-      --  is a view conversion to a smaller object, where gigi can end up\n-      --  creating its own temporary of the wrong size.\n+      --  circumstances: for change of representations, and also when this is\n+      --  a view conversion to a smaller object, where gigi can end up creating\n+      --  its own temporary of the wrong size.\n \n       elsif Nkind (Exp) = N_Type_Conversion then\n          Remove_Side_Effects (Expression (Exp), Name_Req, Variable_Ref);\n@@ -4732,14 +4810,12 @@ package body Exp_Util is\n          end if;\n \n       --  For expressions that denote objects, we can use a renaming scheme.\n-      --  We skip using this if we have a volatile variable and we do not\n-      --  have Nam_Req set true (see comments above for Side_Effect_Free).\n+      --  We skip using this if we have a volatile reference and we do not\n+      --  have Name_Req set true (see comments above for Side_Effect_Free).\n \n       elsif Is_Object_Reference (Exp)\n         and then Nkind (Exp) /= N_Function_Call\n-        and then (Name_Req\n-                   or else not Is_Entity_Name (Exp)\n-                   or else not Treat_As_Volatile (Entity (Exp)))\n+        and then (Name_Req or else not Is_Volatile_Reference (Exp))\n       then\n          Def_Id := Make_Defining_Identifier (Loc, New_Internal_Name ('R'));\n \n@@ -4778,7 +4854,7 @@ package body Exp_Util is\n          --  If this is a packed reference, or a selected component with a\n          --  non-standard representation, a reference to the temporary will\n          --  be replaced by a copy of the original expression (see\n-         --  exp_ch2.Expand_Renaming). Otherwise the temporary must be\n+         --  Exp_Ch2.Expand_Renaming). Otherwise the temporary must be\n          --  elaborated by gigi, and is of course not to be replaced in-line\n          --  by the expression it renames, which would defeat the purpose of\n          --  removing the side-effect.\n@@ -4795,6 +4871,36 @@ package body Exp_Util is\n       --  Otherwise we generate a reference to the value\n \n       else\n+         --  Special processing for function calls that return a task. We need\n+         --  to build a declaration that will enable build-in-place expansion\n+         --  of the call.\n+\n+         --  This is relevant only in Ada 2005 mode. In Ada 95 programs we have\n+         --  to accommodate functions returning limited objects by reference.\n+\n+         if Nkind (Exp) = N_Function_Call\n+           and then Is_Task_Type (Etype (Exp))\n+           and then Ada_Version >= Ada_05\n+         then\n+            declare\n+               Obj  : constant Entity_Id :=\n+                        Make_Defining_Identifier (Loc,\n+                          Chars => New_Internal_Name ('F'));\n+               Decl : Node_Id;\n+\n+            begin\n+               Decl :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Obj,\n+                   Object_Definition   => New_Occurrence_Of (Exp_Type, Loc),\n+                   Expression          => Relocate_Node (Exp));\n+               Insert_Action (Exp, Decl);\n+               Set_Etype (Obj, Exp_Type);\n+               Rewrite (Exp, New_Occurrence_Of (Obj, Loc));\n+               return;\n+            end;\n+         end if;\n+\n          Ref_Type := Make_Defining_Identifier (Loc, New_Internal_Name ('A'));\n \n          Ptr_Typ_Decl :=\n@@ -5202,9 +5308,9 @@ package body Exp_Util is\n \n             Analyze (Asn);\n \n-            --  Kill current value indication. This is necessary because\n-            --  the tests of this flag are inserted out of sequence and must\n-            --  not pick up bogus indications of the wrong constant value.\n+            --  Kill current value indication. This is necessary because the\n+            --  tests of this flag are inserted out of sequence and must not\n+            --  pick up bogus indications of the wrong constant value.\n \n             Set_Current_Value (Ent, Empty);\n          end if;\n@@ -5237,6 +5343,87 @@ package body Exp_Util is\n       end if;\n    end Set_Renamed_Subprogram;\n \n+   ----------------------------------\n+   -- Silly_Boolean_Array_Not_Test --\n+   ----------------------------------\n+\n+   --  This procedure implements an odd and silly test. We explicitly check\n+   --  for the case where the 'First of the component type is equal to the\n+   --  'Last of this component type, and if this is the case, we make sure\n+   --  that constraint error is raised. The reason is that the NOT is bound\n+   --  to cause CE in this case, and we will not otherwise catch it.\n+\n+   --  Believe it or not, this was reported as a bug. Note that nearly\n+   --  always, the test will evaluate statically to False, so the code will\n+   --  be statically removed, and no extra overhead caused.\n+\n+   procedure Silly_Boolean_Array_Not_Test (N : Node_Id; T : Entity_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      CT  : constant Entity_Id  := Component_Type (T);\n+\n+   begin\n+      Insert_Action (N,\n+        Make_Raise_Constraint_Error (Loc,\n+          Condition =>\n+            Make_Op_Eq (Loc,\n+              Left_Opnd =>\n+                Make_Attribute_Reference (Loc,\n+                  Prefix         => New_Occurrence_Of (CT, Loc),\n+                  Attribute_Name => Name_First),\n+\n+              Right_Opnd =>\n+                Make_Attribute_Reference (Loc,\n+                  Prefix         => New_Occurrence_Of (CT, Loc),\n+                  Attribute_Name => Name_Last)),\n+          Reason => CE_Range_Check_Failed));\n+   end Silly_Boolean_Array_Not_Test;\n+\n+   ----------------------------------\n+   -- Silly_Boolean_Array_Xor_Test --\n+   ----------------------------------\n+\n+   --  This procedure implements an odd and silly test. We explicitly check\n+   --  for the XOR case where the component type is True .. True, since this\n+   --  will raise constraint error. A special check is required since CE\n+   --  will not be required otherwise (cf Expand_Packed_Not).\n+\n+   --  No such check is required for AND and OR, since for both these cases\n+   --  False op False = False, and True op True = True.\n+\n+   procedure Silly_Boolean_Array_Xor_Test (N : Node_Id; T : Entity_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+      CT  : constant Entity_Id  := Component_Type (T);\n+      BT  : constant Entity_Id  := Base_Type (CT);\n+\n+   begin\n+      Insert_Action (N,\n+        Make_Raise_Constraint_Error (Loc,\n+          Condition =>\n+            Make_Op_And (Loc,\n+              Left_Opnd =>\n+                Make_Op_Eq (Loc,\n+                  Left_Opnd =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (CT, Loc),\n+                      Attribute_Name => Name_First),\n+\n+                  Right_Opnd =>\n+                    Convert_To (BT,\n+                      New_Occurrence_Of (Standard_True, Loc))),\n+\n+              Right_Opnd =>\n+                Make_Op_Eq (Loc,\n+                  Left_Opnd =>\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (CT, Loc),\n+                      Attribute_Name => Name_Last),\n+\n+                  Right_Opnd =>\n+                    Convert_To (BT,\n+                      New_Occurrence_Of (Standard_True, Loc)))),\n+          Reason => CE_Range_Check_Failed));\n+   end Silly_Boolean_Array_Xor_Test;\n+\n    --------------------------\n    -- Target_Has_Fixed_Ops --\n    --------------------------"}, {"sha": "73277afe16bc98bfdf24f1f4dab9c1c782596a66", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=65df5b719406d99296f303a3ba4ccef5a3752e19", "patch": "@@ -372,6 +372,13 @@ package Exp_Util is\n    --  operation which is not directly visible. If T is a class wide type,\n    --  then the reference is to an operation of the corresponding root type.\n \n+   function Find_Protection_Object (Scop : Entity_Id) return Entity_Id;\n+   --  Traverse the scope stack starting from Scop and look for an entry,\n+   --  entry family, or a subprogram that has a Protection_Object and return\n+   --  it. Raises Program_Error if no such entity is found since the context\n+   --  in which this routine is invoked should always have a protection\n+   --  object.\n+\n    procedure Force_Evaluation\n      (Exp      : Node_Id;\n       Name_Req : Boolean := False);\n@@ -491,6 +498,13 @@ package Exp_Util is\n    --  Returns true if type T is not tagged and is a derived type,\n    --  or is a private type whose completion is such a type.\n \n+   function Is_Volatile_Reference (N : Node_Id) return Boolean;\n+   --  Checks if the node N represents a volatile reference, which can be\n+   --  either a direct reference to a variable treated as volatile, or an\n+   --  indexed/selected component where the prefix is treated as volatile,\n+   --  or has Volatile_Components set. A slice of a volatile variable is\n+   --  also volatile.\n+\n    procedure Kill_Dead_Code (N : Node_Id; Warn : Boolean := False);\n    --  N represents a node for a section of code that is known to be dead. Any\n    --  exception handler references and warning messages relating to this code\n@@ -613,6 +627,18 @@ package Exp_Util is\n    --  renamed subprogram. The node is rewritten to be an identifier that\n    --  refers directly to the renamed subprogram, given by entity E.\n \n+   procedure Silly_Boolean_Array_Not_Test (N : Node_Id; T : Entity_Id);\n+   --  N is the node for a boolean array NOT operation, and T is the type of\n+   --  the array. This routine deals with the silly case where the subtype of\n+   --  the boolean array is False..False or True..True, where it is required\n+   --  that a Constraint_Error exception be raised (RM 4.5.6(6)).\n+\n+   procedure Silly_Boolean_Array_Xor_Test (N : Node_Id; T : Entity_Id);\n+   --  N is the node for a boolean array XOR operation, and T is the type of\n+   --  the array. This routine deals with the silly case where the subtype of\n+   --  the boolean array is True..True, where a raise of a Constraint_Error\n+   --  exception is required (RM 4.5.6(6)).\n+\n    function Target_Has_Fixed_Ops\n      (Left_Typ   : Entity_Id;\n       Right_Typ  : Entity_Id;"}, {"sha": "86de33e78b7c68348f121bf19b2e6bc008287606", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 93, "deletions": 25, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65df5b719406d99296f303a3ba4ccef5a3752e19/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=65df5b719406d99296f303a3ba4ccef5a3752e19", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -570,9 +570,9 @@ package body Sem_Ch9 is\n          --  expression is only evaluated if the guard is open.\n \n          if Nkind (Delay_Statement (N)) = N_Delay_Relative_Statement then\n-            Pre_Analyze_And_Resolve (Expr, Standard_Duration);\n+            Preanalyze_And_Resolve (Expr, Standard_Duration);\n          else\n-            Pre_Analyze_And_Resolve (Expr);\n+            Preanalyze_And_Resolve (Expr);\n          end if;\n \n          Typ := First_Subtype (Etype (Expr));\n@@ -646,8 +646,8 @@ package body Sem_Ch9 is\n       Stats      : constant Node_Id   := Handled_Statement_Sequence (N);\n       Formals    : constant Node_Id   := Entry_Body_Formal_Part (N);\n       P_Type     : constant Entity_Id := Current_Scope;\n-      Entry_Name : Entity_Id;\n       E          : Entity_Id;\n+      Entry_Name : Entity_Id;\n \n    begin\n       Tasking_Used := True;\n@@ -765,7 +765,6 @@ package body Sem_Ch9 is\n       Exp_Ch9.Expand_Entry_Barrier (N, Entry_Name);\n       Push_Scope (Entry_Name);\n \n-      Exp_Ch9.Expand_Entry_Body_Declarations (N);\n       Install_Declarations (Entry_Name);\n       Set_Actual_Subtypes (N, Current_Scope);\n \n@@ -783,6 +782,17 @@ package body Sem_Ch9 is\n       Set_Entry_Parameters_Type\n         (Id, Entry_Parameters_Type (Entry_Name));\n \n+      --  Add a declaration for the Protection object, renaming declarations\n+      --  for the discriminals and privals and finally a declaration for the\n+      --  entry family index (if applicable).\n+\n+      if Expander_Active\n+        and then Is_Protected_Type (P_Type)\n+      then\n+         Install_Private_Data_Declarations\n+           (Sloc (N), Entry_Name, P_Type, N, Decls);\n+      end if;\n+\n       if Present (Decls) then\n          Analyze_Declarations (Decls);\n       end if;\n@@ -926,40 +936,40 @@ package body Sem_Ch9 is\n    -------------------------------\n \n    procedure Analyze_Entry_Declaration (N : Node_Id) is\n-      Formals : constant List_Id   := Parameter_Specifications (N);\n-      Id      : constant Entity_Id := Defining_Identifier (N);\n       D_Sdef  : constant Node_Id   := Discrete_Subtype_Definition (N);\n+      Def_Id  : constant Entity_Id := Defining_Identifier (N);\n+      Formals : constant List_Id   := Parameter_Specifications (N);\n \n    begin\n-      Generate_Definition (Id);\n+      Generate_Definition (Def_Id);\n       Tasking_Used := True;\n \n       if No (D_Sdef) then\n-         Set_Ekind (Id, E_Entry);\n+         Set_Ekind (Def_Id, E_Entry);\n       else\n-         Enter_Name (Id);\n-         Set_Ekind (Id, E_Entry_Family);\n+         Enter_Name (Def_Id);\n+         Set_Ekind (Def_Id, E_Entry_Family);\n          Analyze (D_Sdef);\n-         Make_Index (D_Sdef, N, Id);\n+         Make_Index (D_Sdef, N, Def_Id);\n       end if;\n \n-      Set_Etype          (Id, Standard_Void_Type);\n-      Set_Convention     (Id, Convention_Entry);\n-      Set_Accept_Address (Id, New_Elmt_List);\n+      Set_Etype          (Def_Id, Standard_Void_Type);\n+      Set_Convention     (Def_Id, Convention_Entry);\n+      Set_Accept_Address (Def_Id, New_Elmt_List);\n \n       if Present (Formals) then\n-         Set_Scope (Id, Current_Scope);\n-         Push_Scope (Id);\n+         Set_Scope (Def_Id, Current_Scope);\n+         Push_Scope (Def_Id);\n          Process_Formals (Formals, N);\n-         Create_Extra_Formals (Id);\n+         Create_Extra_Formals (Def_Id);\n          End_Scope;\n       end if;\n \n-      if Ekind (Id) = E_Entry then\n-         New_Overloaded_Entity (Id);\n+      if Ekind (Def_Id) = E_Entry then\n+         New_Overloaded_Entity (Def_Id);\n       end if;\n \n-      Generate_Reference_To_Formals (Id);\n+      Generate_Reference_To_Formals (Def_Id);\n    end Analyze_Entry_Declaration;\n \n    ---------------------------------------\n@@ -1061,7 +1071,7 @@ package body Sem_Ch9 is\n       Set_Has_Completion (Spec_Id);\n       Install_Declarations (Spec_Id);\n \n-      Exp_Ch9.Expand_Protected_Body_Declarations (N, Spec_Id);\n+      Expand_Protected_Body_Declarations (N, Spec_Id);\n \n       Last_E := Last_Entity (Spec_Id);\n \n@@ -1093,6 +1103,55 @@ package body Sem_Ch9 is\n       E : Entity_Id;\n       L : Entity_Id;\n \n+      procedure Undelay_Itypes (T : Entity_Id);\n+      --  Itypes created for the private components of a protected type\n+      --  do not receive freeze nodes, because there is no scope in which\n+      --  they can be elaborated, and they can depend on discriminants of\n+      --  the enclosed protected type. Given that the components can be\n+      --  composite types with inner components, we traverse recursively\n+      --  the private components of the protected type, and indicate that\n+      --  all itypes within are frozen. This ensures that no freeze nodes\n+      --  will be generated for them.\n+      --\n+      --  On the other hand, components of the correesponding record are\n+      --  frozen (or receive itype references) as for other records.\n+\n+      --------------------\n+      -- Undelay_Itypes --\n+      --------------------\n+\n+      procedure Undelay_Itypes (T : Entity_Id) is\n+         Comp : Entity_Id;\n+\n+      begin\n+         if Is_Protected_Type (T) then\n+            Comp := First_Private_Entity (T);\n+         elsif Is_Record_Type (T) then\n+            Comp := First_Entity (T);\n+         else\n+            return;\n+         end if;\n+\n+         while Present (Comp) loop\n+            if Is_Type (Comp)\n+              and then Is_Itype (Comp)\n+            then\n+               Set_Has_Delayed_Freeze (Comp, False);\n+               Set_Is_Frozen (Comp);\n+\n+               if Is_Record_Type (Comp)\n+                 or else Is_Protected_Type (Comp)\n+               then\n+                  Undelay_Itypes (Comp);\n+               end if;\n+            end if;\n+\n+            Next_Entity (Comp);\n+         end loop;\n+      end Undelay_Itypes;\n+\n+   --  Start of processing for Analyze_Protected_Definition\n+\n    begin\n       Tasking_Used := True;\n       Analyze_Declarations (Visible_Declarations (N));\n@@ -1127,6 +1186,8 @@ package body Sem_Ch9 is\n          Next_Entity (E);\n       end loop;\n \n+      Undelay_Itypes (Current_Scope);\n+\n       Check_Max_Entries (N, Max_Protected_Entries);\n       Process_End_Label (N, 'e', Current_Scope);\n    end Analyze_Protected_Definition;\n@@ -1151,7 +1212,10 @@ package body Sem_Ch9 is\n \n       T := Find_Type_Name (N);\n \n-      if Ekind (T) = E_Incomplete_Type then\n+      --  In the case of an incomplete type, use the full view, unless it's not\n+      --  present (as can occur for an incomplete view from a limited with).\n+\n+      if Ekind (T) = E_Incomplete_Type and then Present (Full_View (T)) then\n          T := Full_View (T);\n          Set_Completion_Referenced (T);\n       end if;\n@@ -1776,6 +1840,7 @@ package body Sem_Ch9 is\n \n    procedure Analyze_Task_Body (N : Node_Id) is\n       Body_Id : constant Entity_Id := Defining_Identifier (N);\n+      Decls   : constant List_Id   := Declarations (N);\n       HSS     : constant Node_Id   := Handled_Statement_Sequence (N);\n       Last_E  : Entity_Id;\n \n@@ -1842,7 +1907,7 @@ package body Sem_Ch9 is\n       Install_Declarations (Spec_Id);\n       Last_E := Last_Entity (Spec_Id);\n \n-      Analyze_Declarations (Declarations (N));\n+      Analyze_Declarations (Decls);\n \n       --  For visibility purposes, all entities in the body are private. Set\n       --  First_Private_Entity accordingly, if there was no private part in the\n@@ -1946,7 +2011,10 @@ package body Sem_Ch9 is\n       T := Find_Type_Name (N);\n       Generate_Definition (T);\n \n-      if Ekind (T) = E_Incomplete_Type then\n+      --  In the case of an incomplete type, use the full view, unless it's not\n+      --  present (as can occur for an incomplete view from a limited with).\n+\n+      if Ekind (T) = E_Incomplete_Type and then Present (Full_View (T)) then\n          T := Full_View (T);\n          Set_Completion_Referenced (T);\n       end if;"}]}