{"sha": "4ed785458b8922a6ff69a85c9f523745864aaefb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVkNzg1NDU4Yjg5MjJhNmZmNjlhODVjOWY1MjM3NDU4NjRhYWVmYg==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-05-09T23:48:37Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2004-05-09T23:48:37Z"}, "message": "rs6000.c (function_arg_boundary): Align for ABI_V4 when size is 8 bytes.\n\n\t* config/rs6000/rs6000.c (function_arg_boundary): Align for ABI_V4\n\twhen size is 8 bytes.\n\t(function_arg_advance): Account for stack space used by AltiVec\n\targs when -mabi=altivec.  Simplify alignment calculations.  For\n\tABI_V4, pass AltiVec vectors by reference when -mabi=no-altivec.\n\t(function_arg): Similarly.\n\t(function_arg_pass_by_reference): True for ABI_V4 AltiVec when\n\tnot AltiVec ABI.\n\t(rs6000_va_arg): Correct fp arg test.  Adjust for AltiVec change.\n\tCorrect alignment, and align before testing reg count.  Remove\n\tTREE_THIS_VOLATILE from reg.  Don't emit unused labels.\n\t(rs6000_complex_function_value): Check TARGET_HARD_FLOAT and\n\tTARGET_FPRS here..\n\t(rs6000_function_value): .. not here before call.\n\nFrom-SVN: r81659", "tree": {"sha": "097d70ef518ae1c7ab32d73d51d4580f211acb84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/097d70ef518ae1c7ab32d73d51d4580f211acb84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ed785458b8922a6ff69a85c9f523745864aaefb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed785458b8922a6ff69a85c9f523745864aaefb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ed785458b8922a6ff69a85c9f523745864aaefb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ed785458b8922a6ff69a85c9f523745864aaefb/comments", "author": null, "committer": null, "parents": [{"sha": "f350ff00330ac7e7d8bf771149574d2d38a69c55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f350ff00330ac7e7d8bf771149574d2d38a69c55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f350ff00330ac7e7d8bf771149574d2d38a69c55"}], "stats": {"total": 182, "additions": 104, "deletions": 78}, "files": [{"sha": "90dce94c7c1f3aad11266a6436680fee1409cf0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed785458b8922a6ff69a85c9f523745864aaefb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed785458b8922a6ff69a85c9f523745864aaefb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ed785458b8922a6ff69a85c9f523745864aaefb", "patch": "@@ -1,3 +1,20 @@\n+2004-05-10  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (function_arg_boundary): Align for ABI_V4\n+\twhen size is 8 bytes.\n+\t(function_arg_advance): Account for stack space used by AltiVec\n+\targs when -mabi=altivec.  Simplify alignment calculations.  For \n+\tABI_V4, pass AltiVec vectors by reference when -mabi=no-altivec.\n+\t(function_arg): Similarly.\n+\t(function_arg_pass_by_reference): True for ABI_V4 AltiVec when\n+\tnot AltiVec ABI.\n+\t(rs6000_va_arg): Correct fp arg test.  Adjust for AltiVec change.\n+\tCorrect alignment, and align before testing reg count.  Remove\n+\tTREE_THIS_VOLATILE from reg.  Don't emit unused labels.\n+\t(rs6000_complex_function_value): Check TARGET_HARD_FLOAT and\n+\tTARGET_FPRS here..\n+\t(rs6000_function_value): .. not here before call.\n+\n 2004-05-09  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/spe.md (\"tstsflt_gpr\"): Fix typo in unspec.\n@@ -15,8 +32,8 @@\n \tanything to current_file_decl.\n \t(pushdecl_top_level): Likewise.\n \t(store_parm_decls_newstyle): Adjust check for nested function.\n-\t(c_write_global_declarations): Update for renamed variable\n-.\n+\t(c_write_global_declarations): Update for renamed variable.\n+\n 2004-05-09  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* config/rs6000/rs6000-protos.h"}, {"sha": "7ee32b11de0031ea932b9859c04f76b531f4b714", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 85, "deletions": 76, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ed785458b8922a6ff69a85c9f523745864aaefb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ed785458b8922a6ff69a85c9f523745864aaefb/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4ed785458b8922a6ff69a85c9f523745864aaefb", "patch": "@@ -4188,10 +4188,10 @@ function_arg_padding (enum machine_mode mode, tree type)\n int\n function_arg_boundary (enum machine_mode mode, tree type ATTRIBUTE_UNUSED)\n {\n-  if (DEFAULT_ABI == ABI_V4 && (mode == DImode || mode == DFmode))\n+  if (DEFAULT_ABI == ABI_V4 && GET_MODE_SIZE (mode) == 8)\n+    return 64;\n+  else if (SPE_VECTOR_MODE (mode))\n     return 64;\n-   else if (SPE_VECTOR_MODE (mode))\n-     return 64;\n   else if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n     return 128;\n   else\n@@ -4228,19 +4228,27 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \n   if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n     {\n+      bool stack = false;\n+\n       if (USE_ALTIVEC_FOR_ARG_P (cum, mode, type, named))\n         {\n \t  cum->vregno++;\n \t  if (!TARGET_ALTIVEC)\n \t    error (\"Cannot pass argument in vector register because\"\n \t\t   \" altivec instructions are disabled, use -maltivec\"\n \t\t   \" to enable them.\");\n+\n+\t  /* PowerPC64 Linux and AIX allocate GPRs for a vector argument\n+\t     even if it is going to be passed in a vector register.  \n+\t     Darwin does the same for variable-argument functions.  */\n+\t  if ((DEFAULT_ABI == ABI_AIX && TARGET_64BIT)\n+\t      || (cum->stdarg && DEFAULT_ABI != ABI_V4))\n+\t    stack = true;\n \t}\n-      /* PowerPC64 Linux and AIX allocates GPRs for a vector argument\n-\t even if it is going to be passed in a vector register.  \n-\t Darwin does the same for variable-argument functions.  */\n-      if ((DEFAULT_ABI == ABI_AIX && TARGET_64BIT)\n-\t\t   || (cum->stdarg && DEFAULT_ABI != ABI_V4))\n+      else\n+\tstack = true;\n+\n+      if (stack)\n         {\n \t  int align;\n \t  \n@@ -4252,7 +4260,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t     aligned.  Space for GPRs is reserved even if the argument\n \t     will be passed in memory.  */\n \t  if (TARGET_32BIT)\n-\t    align = ((6 - (cum->words & 3)) & 3);\n+\t    align = (2 - cum->words) & 3;\n \t  else\n \t    align = cum->words & 1;\n \t  cum->words += align + rs6000_arg_size (mode, type);\n@@ -4290,22 +4298,27 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  int n_words;\n \t  int gregno = cum->sysv_gregno;\n \n-\t  /* Aggregates and IEEE quad get passed by reference.  */\n+\t  /* Aggregates, IEEE quad, and AltiVec vectors get passed by\n+\t     reference.  */\n \t  if ((type && AGGREGATE_TYPE_P (type))\n-\t      || mode == TFmode)\n+\t      || mode == TFmode\n+\t      || ALTIVEC_VECTOR_MODE (mode))\n \t    n_words = 1;\n \t  else \n \t    n_words = rs6000_arg_size (mode, type);\n \n-\t  /* Long long and SPE vectors are put in odd registers.  */\n-\t  if (n_words == 2 && (gregno & 1) == 0)\n-\t    gregno += 1;\n+\t  /* Long long and SPE vectors are put in (r3,r4), (r5,r6),\n+\t     (r7,r8) or (r9,r10).  As does any other 2 word item such\n+\t     as complex int due to a historical mistake.  */\n+\t  if (n_words == 2)\n+\t    gregno += (1 - gregno) & 1;\n \n-\t  /* Long long and SPE vectors are not split between registers\n-\t     and stack.  */\n+\t  /* Multi-reg args are not split between registers and stack.  */\n \t  if (gregno + n_words - 1 > GP_ARG_MAX_REG)\n \t    {\n-\t      /* Long long is aligned on the stack.  */\n+\t      /* Long long and SPE vectors are aligned on the stack.\n+\t\t So are other 2 word items such as complex int due to\n+\t\t a historical mistake.  */\n \t      if (n_words == 2)\n \t\tcum->words += cum->words & 1;\n \t      cum->words += n_words;\n@@ -4607,7 +4620,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t     they just have to start on an even word, since the parameter\n \t     save area is 16-byte aligned.  */\n \t  if (TARGET_32BIT)\n-\t    align = ((6 - (cum->words & 3)) & 3);\n+\t    align = (2 - cum->words) & 3;\n \t  else\n \t    align = cum->words & 1;\n \t  align_words = cum->words + align;\n@@ -4648,18 +4661,22 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  int n_words;\n \t  int gregno = cum->sysv_gregno;\n \n-\t  /* Aggregates and IEEE quad get passed by reference.  */\n+\t  /* Aggregates, IEEE quad, and AltiVec vectors get passed by\n+\t     reference.  */\n \t  if ((type && AGGREGATE_TYPE_P (type))\n-\t      || mode == TFmode)\n+\t      || mode == TFmode\n+\t      || ALTIVEC_VECTOR_MODE (mode))\n \t    n_words = 1;\n \t  else \n \t    n_words = rs6000_arg_size (mode, type);\n \n-\t  /* Long long and SPE vectors are put in odd registers.  */\n-\t  if (n_words == 2 && (gregno & 1) == 0)\n-\t    gregno += 1;\n+\t  /* Long long and SPE vectors are put in (r3,r4), (r5,r6),\n+\t     (r7,r8) or (r9,r10).  As does any other 2 word item such\n+\t     as complex int due to a historical mistake.  */\n+\t  if (n_words == 2)\n+\t    gregno += (1 - gregno) & 1;\n \n-\t  /* Long long does not split between registers and stack.  */\n+\t  /* Multi-reg args are not split between registers and stack.  */\n \t  if (gregno + n_words - 1 <= GP_ARG_MAX_REG)\n \t    return gen_rtx_REG (mode, gregno);\n \t  else\n@@ -4805,7 +4822,8 @@ function_arg_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n {\n   if (DEFAULT_ABI == ABI_V4\n       && ((type && AGGREGATE_TYPE_P (type))\n-\t  || mode == TFmode))\n+\t  || mode == TFmode\n+\t  || (!TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))))\n     {\n       if (TARGET_DEBUG_ARG)\n \tfprintf (stderr, \"function_arg_pass_by_reference: aggregate\\n\");\n@@ -5059,6 +5077,7 @@ rs6000_va_arg (tree valist, tree type)\n   tree gpr, fpr, ovf, sav, reg, t, u;\n   int indirect_p, size, rsize, n_reg, sav_ofs, sav_scale;\n   rtx lab_false, lab_over, addr_rtx, r;\n+  int align;\n \n   if (DEFAULT_ABI != ABI_V4)\n     {\n@@ -5132,10 +5151,14 @@ rs6000_va_arg (tree valist, tree type)\n \n   size = int_size_in_bytes (type);\n   rsize = (size + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+  align = 1;\n \n-  if (AGGREGATE_TYPE_P (type) || TYPE_MODE (type) == TFmode)\n+  if (AGGREGATE_TYPE_P (type)\n+      || TYPE_MODE (type) == TFmode\n+      || (!TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type))))\n     {\n-      /* Aggregates and long doubles are passed by reference.  */\n+      /* Aggregates, long doubles, and AltiVec vectors are passed by\n+\t reference.  */\n       indirect_p = 1;\n       reg = gpr;\n       n_reg = 1;\n@@ -5144,14 +5167,17 @@ rs6000_va_arg (tree valist, tree type)\n       size = UNITS_PER_WORD;\n       rsize = 1;\n     }\n-  else if (FLOAT_TYPE_P (type) && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  else if (TARGET_HARD_FLOAT && TARGET_FPRS\n+\t   && (TYPE_MODE (type) == SFmode || TYPE_MODE (type) == DFmode))\n     {\n       /* FP args go in FP registers, if present.  */\n       indirect_p = 0;\n       reg = fpr;\n       n_reg = 1;\n       sav_ofs = 8*4;\n       sav_scale = 8;\n+      if (TYPE_MODE (type) == DFmode)\n+\talign = 8;\n     }\n   else\n     {\n@@ -5161,38 +5187,43 @@ rs6000_va_arg (tree valist, tree type)\n       n_reg = rsize;\n       sav_ofs = 0;\n       sav_scale = 4;\n+      if (n_reg == 2)\n+\talign = 8;\n     }\n \n   /* Pull the value out of the saved registers....  */\n \n-  lab_false = gen_label_rtx ();\n-  lab_over = gen_label_rtx ();\n+  lab_over = NULL_RTX;\n   addr_rtx = gen_reg_rtx (Pmode);\n \n-  /*  AltiVec vectors never go in registers.  */\n-  if (!TARGET_ALTIVEC || TREE_CODE (type) != VECTOR_TYPE)\n+  /*  AltiVec vectors never go in registers when -mabi=altivec.  */\n+  if (TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (TYPE_MODE (type)))\n+    align = 16;\n+  else\n     {\n-      TREE_THIS_VOLATILE (reg) = 1;\n-      emit_cmp_and_jump_insns\n-\t(expand_expr (reg, NULL_RTX, QImode, EXPAND_NORMAL),\n-\t GEN_INT (8 - n_reg + 1), GE, const1_rtx, QImode, 1,\n-\t lab_false);\n+      lab_false = gen_label_rtx ();\n+      lab_over = gen_label_rtx ();\n \n-      /* Long long is aligned in the registers.  */\n-      if (n_reg > 1)\n+      /* Long long and SPE vectors are aligned in the registers.\n+\t As are any other 2 gpr item such as complex int due to a\n+\t historical mistake.  */\n+      u = reg;\n+      if (n_reg == 2)\n \t{\n \t  u = build (BIT_AND_EXPR, TREE_TYPE (reg), reg,\n \t\t     build_int_2 (n_reg - 1, 0));\n-\t  u = build (PLUS_EXPR, TREE_TYPE (reg), reg, u);\n-\t  u = build (MODIFY_EXPR, TREE_TYPE (reg), reg, u);\n+\t  u = build (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg, u);\n \t  TREE_SIDE_EFFECTS (u) = 1;\n-\t  expand_expr (u, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t}\n \n+      emit_cmp_and_jump_insns\n+\t(expand_expr (u, NULL_RTX, QImode, EXPAND_NORMAL),\n+\t GEN_INT (8 - n_reg + 1), GE, const1_rtx, QImode, 1,\n+\t lab_false);\n+\n+      t = sav;\n       if (sav_ofs)\n \tt = build (PLUS_EXPR, ptr_type_node, sav, build_int_2 (sav_ofs, 0));\n-      else\n-\tt = sav;\n \n       u = build (POSTINCREMENT_EXPR, TREE_TYPE (reg), reg,\n \t\t build_int_2 (n_reg, 0));\n@@ -5213,40 +5244,18 @@ rs6000_va_arg (tree valist, tree type)\n \n       emit_jump_insn (gen_jump (lab_over));\n       emit_barrier ();\n-    }\n \n-  emit_label (lab_false);\n+      emit_label (lab_false);\n+    }\n \n   /* ... otherwise out of the overflow area.  */\n \n-  /* Make sure we don't find reg 7 for the next int arg.\n-\n-     All AltiVec vectors go in the overflow area.  So in the AltiVec\n-     case we need to get the vectors from the overflow area, but\n-     remember where the GPRs and FPRs are.  */\n-  if (n_reg > 1 && (TREE_CODE (type) != VECTOR_TYPE\n-\t\t    || !TARGET_ALTIVEC))\n-    {\n-      t = build (MODIFY_EXPR, TREE_TYPE (reg), reg, build_int_2 (8, 0));\n-      TREE_SIDE_EFFECTS (t) = 1;\n-      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-    }\n-\n   /* Care for on-stack alignment if needed.  */\n-  if (rsize <= 1)\n-    t = ovf;\n-  else\n+  t = ovf;\n+  if (align != 1)\n     {\n-      int align;\n-\n-      /* AltiVec vectors are 16 byte aligned.  */\n-      if (TARGET_ALTIVEC && TREE_CODE (type) == VECTOR_TYPE)\n-\talign = 15;\n-      else\n-\talign = 7;\n-\n-      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf, build_int_2 (align, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align-1, -1));\n+      t = build (PLUS_EXPR, TREE_TYPE (t), t, build_int_2 (align - 1, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n     }\n   t = save_expr (t);\n \n@@ -5259,7 +5268,8 @@ rs6000_va_arg (tree valist, tree type)\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  emit_label (lab_over);\n+  if (lab_over)\n+    emit_label (lab_over);\n \n   if (indirect_p)\n     {\n@@ -16345,7 +16355,7 @@ rs6000_complex_function_value (enum machine_mode mode)\n   enum machine_mode inner = GET_MODE_INNER (mode);\n   unsigned int inner_bytes = GET_MODE_SIZE (inner);\n \n-  if (FLOAT_MODE_P (mode))\n+  if (FLOAT_MODE_P (mode) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else\n     {\n@@ -16403,10 +16413,9 @@ rs6000_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n   else\n     mode = TYPE_MODE (valtype);\n \n-  if (TREE_CODE (valtype) == REAL_TYPE && TARGET_HARD_FLOAT && TARGET_FPRS)\n+  if (SCALAR_FLOAT_TYPE_P (valtype) && TARGET_HARD_FLOAT && TARGET_FPRS)\n     regno = FP_ARG_RETURN;\n   else if (TREE_CODE (valtype) == COMPLEX_TYPE\n-\t   && TARGET_HARD_FLOAT\n \t   && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TREE_CODE (valtype) == VECTOR_TYPE"}]}