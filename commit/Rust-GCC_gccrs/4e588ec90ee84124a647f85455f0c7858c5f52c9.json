{"sha": "4e588ec90ee84124a647f85455f0c7858c5f52c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU1ODhlYzkwZWU4NDEyNGE2NDdmODU0NTVmMGM3ODU4YzVmNTJjOQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@codesourcery.com", "date": "2001-05-25T21:43:42Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2001-05-25T21:43:42Z"}, "message": "std_cmath.h: Tweak.\n\n      * include/c_std/bits/std_cmath.h: Tweak.  #define away abs, cos,\n      fabs, sin, sqrt.  They are now implemented in terms of __builtin_\n      variants.\n\nFrom-SVN: r42595", "tree": {"sha": "3148c7dd43f0f4f2f1c50b516e5dade6414b8558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3148c7dd43f0f4f2f1c50b516e5dade6414b8558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e588ec90ee84124a647f85455f0c7858c5f52c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e588ec90ee84124a647f85455f0c7858c5f52c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e588ec90ee84124a647f85455f0c7858c5f52c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e588ec90ee84124a647f85455f0c7858c5f52c9/comments", "author": null, "committer": null, "parents": [{"sha": "a26c3bb59317a6518c2b9b3854bc664657f36216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a26c3bb59317a6518c2b9b3854bc664657f36216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a26c3bb59317a6518c2b9b3854bc664657f36216"}], "stats": {"total": 613, "additions": 293, "deletions": 320}, "files": [{"sha": "a7619efe6552a64275ac94a1b60c459f9071fb68", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e588ec90ee84124a647f85455f0c7858c5f52c9/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e588ec90ee84124a647f85455f0c7858c5f52c9/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4e588ec90ee84124a647f85455f0c7858c5f52c9", "patch": "@@ -1,3 +1,9 @@\n+2001-05-25  Gabriel Dos Reis  <gdr@codesourcery.com>\n+\n+\t* include/c_std/bits/std_cmath.h: Tweak.  #define away abs, cos,\n+\tfabs, sin, sqrt.  They are now implemented in terms of __builtin_\n+\tvariants. \n+\n 2001-05-24  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tlibstdc++/2830"}, {"sha": "3f6f23db75c2e659a2eb6938391e678812a05098", "filename": "libstdc++-v3/include/c_std/bits/std_cmath.h", "status": "modified", "additions": 287, "deletions": 320, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e588ec90ee84124a647f85455f0c7858c5f52c9/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e588ec90ee84124a647f85455f0c7858c5f52c9/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fbits%2Fstd_cmath.h?ref=4e588ec90ee84124a647f85455f0c7858c5f52c9", "patch": "@@ -40,6 +40,16 @@\n #include <bits/std_cstdlib.h>\n  \n #pragma GCC system_header\n+\n+// Need to mangle these \"C\" functions.  Ideally, we could like to do the\n+// same for the remaining of the \"C\" functions but they do not have\n+// builtin implementations.  So, they are still of nuisance.\n+#define abs __glibcpp_abs\n+#define cos __glibcpp_cos\n+#define fabs __glibcpp_fabs\n+#define sin __glibcpp_sin\n+#define sqrt __glibcpp_sqrt\n+\n #include <math.h>\n \n // Get rid of those macros defined in <math.h> in lieu of real functions.\n@@ -80,17 +90,21 @@ namespace std\n       return __x < _Tp() ? -__x : __x;\n     }\n \n-#if _GLIBCPP_HAVE___BUILTIN_FABSF\n-  inline float \n-  abs(float __x) { return __builtin_fabsf(__x); }\n-#elif _GLIBCPP_HAVE_FABSF\n-  inline float \n-  abs(float __x) { return ::fabsf(__x); }\n-#else\n-  inline float \n-  abs(float __x) { return __cmath_abs(__x); }\n-#endif\n+  // abs.\n+  inline float\n+  abs(float __x)\n+  { return __builtin_fabsf(__x); }\n \n+  inline double\n+  abs(double __x)\n+  { return __builtin_fabs(__x); }\n+\n+  inline long double\n+  abs(long double __x)\n+  { return __builtin_fabsl(__x); }\n+\n+\n+  // acos.\n #if _GLIBCPP_HAVE_ACOSF\n   inline float \n   acos(float __x) { return ::acosf(__x); }\n@@ -99,6 +113,18 @@ namespace std\n   acos(float __x) { return ::acos(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double acos(double __x);\n+  \n+#if _GLIBCPP_HAVE_ACOSL\n+  inline long double \n+  acos(long double __x) { return ::acosl(__x); }\n+#else\n+  inline long double \n+  acos(long double __x) { return ::acos(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // asin.\n #if _GLIBCPP_HAVE_ASINF\n   inline float \n   asin(float __x) { return ::asinf(__x); }\n@@ -107,6 +133,18 @@ namespace std\n   asin(float __x) { return ::asin(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double asin(double __x);\n+\n+#if _GLIBCPP_HAVE_ASINL\n+  inline long double \n+  asin(long double __x) { return ::asinl(__x); }\n+#else\n+  inline long double \n+  asin(long double __x) { return ::asin(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // atan.\n #if _GLIBCPP_HAVE_ATANF\n   inline float \n   atan(float __x) { return ::atanf(__x); }\n@@ -115,6 +153,18 @@ namespace std\n   atan(float __x) { return ::atan(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double atan(double __x);\n+\n+#if _GLIBCPP_HAVE_ATANL\n+  inline long double \n+  atan(long double __x) { return ::atanl(__x); }\n+#else\n+  inline long double \n+  atan(long double __x) { return ::atan(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // atan2.\n #if _GLIBCPP_HAVE_ATAN2F\n   inline float \n   atan2(float __y, float __x) { return ::atan2f(__y, __x); }\n@@ -124,6 +174,19 @@ namespace std\n   { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double atan2(double __y, double __x);\n+\n+#if _GLIBCPP_HAVE_ATAN2L\n+  inline long double \n+  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }\n+#else\n+  inline long double \n+  atan2(long double __y, long double __x) \n+  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // ceil.\n #if _GLIBCPP_HAVE_CEILF\n   inline float \n   ceil(float __x) { return ::ceilf(__x); }\n@@ -132,17 +195,32 @@ namespace std\n   ceil(float __x) { return ::ceil(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE___BUILTIN_COSF\n-  inline float \n-  cos(float __x) { return __builtin_cosf(__x); }\n-#elif _GLIBCPP_HAVE_COSF\n-  inline float \n-  cos(float __x) { return ::cosf(__x); }\n+  extern \"C\" double ceil(double __x);\n+\n+#if _GLIBCPP_HAVE_CEILL\n+  inline long double \n+  ceil(long double __x) { return ::ceill(__x); }\n #else\n-  inline float \n-  cos(float __x) { return ::cos(static_cast<double>(__x)); }\n+  inline long double \n+  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }\n #endif\n \n+\n+  // cos.\n+  inline float\n+  cos(float __x)\n+  { return __builtin_cosf(__x); }\n+\n+  inline double\n+  cos(double __x)\n+  { return __builtin_cos(__x); }\n+\n+  inline long double\n+  cos(long double __x)\n+  { return __builtin_cosl(__x); }\n+\n+\n+  // cosh.\n #if _GLIBCPP_HAVE_COSHF\n   inline float \n   cosh(float __x) { return ::coshf(__x); }\n@@ -151,6 +229,18 @@ namespace std\n   cosh(float __x) { return ::cosh(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double cosh(double __x);\n+\n+#if _GLIBCPP_HAVE_COSHL\n+  inline long double \n+  cosh(long double __x) { return ::coshl(__x); }\n+#else\n+  inline long double \n+  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // exp.\n #if _GLIBCPP_HAVE_EXPF\n   inline float \n   exp(float __x) { return ::expf(__x); }\n@@ -159,17 +249,32 @@ namespace std\n   exp(float __x) { return ::exp(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE___BUILTIN_FABSF\n-  inline float \n-  fabs(float __x) { return __builtin_fabsf(__x); }\n-#elif _GLIBCPP_HAVE_FABSF\n-  inline float \n-  fabs(float __x) { return ::fabsf(__x); }\n+  extern \"C\" double exp(double __x);\n+\n+#if _GLIBCPP_HAVE_EXPL\n+  inline long double \n+  exp(long double __x) { return ::expl(__x); }\n #else\n-  inline float \n-  fabs(float __x) { return __cmath_abs(__x); }\n+  inline long double \n+  exp(long double __x) { return ::exp(static_cast<double>(__x)); }\n #endif\n \n+\n+  // fabs.\n+  inline float\n+  fabs(float __x)\n+  { return __builtin_fabsf(__x); }\n+\n+  inline double\n+  fabs(double __x)\n+  { return __builtin_fabs(__x); }\n+\n+  inline long double\n+  fabs(long double __x)\n+  { return __builtin_fabsl(__x); }\n+\n+\n+  // floor.\n #if _GLIBCPP_HAVE_FLOORF\n   inline float \n   floor(float __x) { return ::floorf(__x); }\n@@ -178,6 +283,18 @@ namespace std\n   floor(float __x) { return ::floor(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double floor(double __x);\n+\n+#if _GLIBCPP_HAVE_FLOORL\n+  inline long double \n+  floor(long double __x) { return ::floorl(__x); }\n+#else\n+  inline long double \n+  floor(long double __x) { return ::floor(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // fmod.\n #if _GLIBCPP_HAVE_FMODF\n   inline float \n   fmod(float __x, float __y) { return ::fmodf(__x, __y); }\n@@ -187,6 +304,19 @@ namespace std\n   { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n+  extern \"C\" double fmod(double __x, double __y);\n+\n+#if _GLIBCPP_HAVE_FMODL\n+  inline long double \n+  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }\n+#else\n+  inline long double \n+  fmod(long double __x, long double __y) \n+  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n+#endif\n+\n+\n+  // frexp.\n #if _GLIBCPP_HAVE_FREXPF\n   inline float \n   frexp(float __x, int* __exp) { return ::frexpf(__x, __exp); }\n@@ -195,6 +325,19 @@ namespace std\n   frexp(float __x, int* __exp) { return ::frexp(__x, __exp); }\n #endif\n \n+  extern \"C\" double frexp(double __x, int* __exp);\n+\n+#if _GLIBCPP_HAVE_FREXPL\n+  inline long double \n+  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }\n+#else\n+  inline long double \n+  frexp(long double __x, int* __exp) \n+  { return ::frexp(static_cast<double>(__x), __exp); }\n+#endif\n+\n+\n+  // ldexp.\n #if _GLIBCPP_HAVE_LDEXPF\n   inline float \n   ldexp(float __x, int __exp) { return ::ldexpf(__x, __exp); }\n@@ -204,6 +347,19 @@ namespace std\n   { return ::ldexp(static_cast<double>(__x), __exp); }\n #endif\n \n+  extern \"C\" double ldexp(double __x, int __exp);\n+\n+#if _GLIBCPP_HAVE_LDEXPL\n+  inline long double \n+  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }\n+#else\n+  inline long double \n+  ldexp(long double __x, int __exp) \n+  { return ::ldexp(static_cast<double>(__x), __exp); }\n+#endif\n+\n+\n+  // log.\n #if _GLIBCPP_HAVE_LOGF\n   inline float \n   log(float __x) { return ::logf(__x); }\n@@ -212,6 +368,18 @@ namespace std\n   { return ::log(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double log(double __x);\n+\n+#if _GLIBCPP_HAVE_LOGL\n+  inline long double \n+  log(long double __x) { return ::logl(__x); }\n+#else\n+  inline long double \n+  log(long double __x) { return ::log(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // log10.\n #if _GLIBCPP_HAVE_LOG10F\n   inline float \n   log10(float __x) { return ::log10f(__x); }\n@@ -220,6 +388,18 @@ namespace std\n   log10(float __x) { return ::log10(static_cast<double>(__x)); }\n #endif\n \n+  extern \"C\" double log10(double __x);\n+\n+#if _GLIBCPP_HAVE_LOG10L\n+  inline long double \n+  log10(long double __x) { return ::log10l(__x); }\n+#else\n+  inline long double \n+  log10(long double __x) { return ::log10(static_cast<double>(__x)); }\n+#endif\n+\n+\n+  // modf.\n #if _GLIBCPP_HAVE_MODFF\n   inline float \n   modf(float __x, float* __iptr) { return ::modff(__x, __iptr); }\n@@ -234,6 +414,24 @@ namespace std\n   }\n #endif\n \n+  extern \"C\" double modf(double __x, double* __iptr);\n+\n+#if _GLIBCPP_HAVE_MODFL\n+  inline long double \n+  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }\n+#else\n+  inline long double \n+  modf(long double __x, long double* __iptr) \n+  { \n+    double __tmp;\n+    double __res = ::modf(static_cast<double>(__x), &__tmp);\n+    * __iptr = static_cast<long double>(__tmp);\n+    return __res;\n+  }\n+#endif\n+\n+\n+  // pow.\n   template<typename _Tp>\n     inline _Tp\n     __pow_helper(_Tp __x, int __n)\n@@ -252,345 +450,114 @@ namespace std\n   { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n-  inline float \n-  pow(float __x, int __n)\n-  {\n-    return __pow_helper(__x, __n);\n-  }\n-\n-#if _GLIBCPP_HAVE___BUILTIN_SINF\n-  inline float \n-  sin(float __x) { return __builtin_sinf(__x); }\n-#elif _GLIBCPP_HAVE_SINF\n-  inline float \n-  sin(float __x) { return ::sinf(__x); }\n-#else\n-  inline float \n-  sin(float __x) { return ::sin(static_cast<double>(__x)); }\n-#endif\n-\n-#if _GLIBCPP_HAVE_SINHF\n-  inline float \n-  sinh(float __x) { return ::sinhf(__x); }\n-#else\n-  inline float \n-  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }\n-#endif\n-\n-#if _GLIBCPP_HAVE___BUILTIN_SQRTF\n-  inline float \n-  sqrt(float __x) { return __builtin_sqrtf(__x); }\n-#elif _GLIBCPP_HAVE_SQRTF\n-  inline float \n-  sqrt(float __x) { return ::sqrtf(__x); }\n-#else\n-  inline float \n-  sqrt(float __x) { return ::sqrt(static_cast<double>(__x)); }\n-#endif\n+  extern \"C\" double pow(double __x, double __y);\n \n-#if _GLIBCPP_HAVE_TANF\n-  inline float \n-  tan(float __x) { return ::tanf(__x); }\n+#if _GLIBCPP_HAVE_POWL\n+  inline long double \n+  pow(long double __x, long double __y) { return ::powl(__x, __y); }\n #else\n-  inline float \n-  tan(float __x) { return ::tan(static_cast<double>(__x)); }\n+  inline long double \n+  pow(long double __x, long double __y) \n+  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n-#if _GLIBCPP_HAVE_TANHF\n-  inline float \n-  tanh(float __x) { return ::tanhf(__x); }\n-#else\n   inline float \n-  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }\n-#endif\n-\n-\n-  extern \"C\" double acos(double __x);\n-\n-  extern \"C\" double asin(double __x);\n-\n-  extern \"C\" double atan(double __x);\n-\n-  extern \"C\" double atan2(double __y, double __x);\n-\n-  extern \"C\" double ceil(double __x);\n-\n-#if _GLIBCPP_HAVE___BUILTIN_COS\n-  inline double \n-  cos(double __x) { return __builtin_cos(__x); }\n-#else\n-  extern \"C\" double cos(double __x);\n-#endif\n-\n-  extern \"C\" double cosh(double __x);\n-\n-  extern \"C\" double exp(double __x);\n-\n-#if _GLIBCPP_HAVE___BUILTIN_FABS\n-  inline double \n-  fabs(double __x) { return __builtin_fabs(__x); }\n-#else\n-  extern \"C\" double fabs(double __x);\n-#endif\n-\n-#if _GLIBCPP_HAVE___BUILTIN_FABS\n-  inline double \n-  abs(double __x) { return __builtin_fabs(__x); }\n-#else\n-  inline double\n-  abs(double __x) { return fabs(__x); }\n-#endif\n-\n-  extern \"C\" double floor(double __x);\n-\n-  extern \"C\" double fmod(double __x, double __y);\n-\n-  extern \"C\" double frexp(double __x, int* __exp);\n-\n-  extern \"C\" double ldexp(double __x, int __exp);\n-\n-  extern \"C\" double log(double __x);\n-\n-  extern \"C\" double log10(double __x);\n-\n-  extern \"C\" double modf(double __x, double* __iptr);\n-\n-  extern \"C\" double pow(double __x, double __y);\n+  pow(float __x, int __n)\n+  {\n+    return __pow_helper(__x, __n);\n+  }\n \n   inline double \n   pow(double __x, int __i)\n   {\n     return __pow_helper(__x, __i);\n   }\n \n-#if _GLIBCPP_HAVE___BUILTIN_SIN\n-  inline double \n-  sin(double __x) { return __builtin_sin(__x); }\n-#else\n-  extern \"C\" double sin(double __x);\n-#endif\n-\n-  extern \"C\" double sinh(double __x);\n-\n-#if _GLIBCPP_HAVE___BUILTIN_SQRT\n-  inline double \n-  sqrt(double __x) { return __builtin_fsqrt(__x); }\n-#else\n-  extern \"C\" double sqrt(double __x);\n-#endif\n-\n-  extern \"C\" double tan(double __x);\n-\n-  extern \"C\" double tanh(double __x);\n-\n-\n-#if _GLIBCPP_HAVE___BUILTIN_FABSL\n-  inline long double \n-  abs(long double __x) { return __builtin_fabsl(__x); }\n-#elif _GLIBCPP_HAVE_FABSL\n-  inline long double \n-  abs(long double __x) { return ::fabsl(__x); }\n-#else\n-  inline long double \n-  abs(long double __x) { return __cmath_abs(__x); }\n-#endif\n-\n-#if _GLIBCPP_HAVE_ACOSL\n-  inline long double \n-  acos(long double __x) { return ::acosl(__x); }\n-#else\n   inline long double \n-  acos(long double __x) { return ::acos(static_cast<double>(__x)); }\n-#endif\n+  pow(long double __x, int __n)\n+  {\n+    return __pow_helper(__x, __n);\n+  }\n \n-#if _GLIBCPP_HAVE_ASINL\n-  inline long double \n-  asin(long double __x) { return ::asinl(__x); }\n-#else\n-  inline long double \n-  asin(long double __x) { return ::asin(static_cast<double>(__x)); }\n-#endif\n \n-#if _GLIBCPP_HAVE_ATANL\n-  inline long double \n-  atan(long double __x) { return ::atanl(__x); }\n-#else\n-  inline long double \n-  atan(long double __x) { return ::atan(static_cast<double>(__x)); }\n-#endif\n+  // sin.\n+  inline float\n+  sin(float __x)\n+  { return __builtin_sinf(__x); }\n \n-#if _GLIBCPP_HAVE_ATAN2L\n-  inline long double \n-  atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }\n-#else\n-  inline long double \n-  atan2(long double __y, long double __x) \n-  { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n-#endif\n-\n-#if _GLIBCPP_HAVE_CEILL\n-  inline long double \n-  ceil(long double __x) { return ::ceill(__x); }\n-#else\n-  inline long double \n-  ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }\n-#endif\n-\n-#if _GLIBCPP_HAVE___BUILTIN_COSL\n-  inline long double \n-  cos(long double __x) { return __builtin_cosl(__x); }\n-#elif _GLIBCPP_HAVE_COSL\n-  inline long double \n-  cos(long double __x) { return ::cosl(__x); }\n-#else\n-  inline long double \n-  cos(long double __x) { return ::cos(static_cast<double>(__x)); }\n-#endif\n+  inline double\n+  sin(double __x)\n+  { return __builtin_sin(__x); }\n \n-#if _GLIBCPP_HAVE_COSHL\n-  inline long double \n-  cosh(long double __x) { return ::coshl(__x); }\n-#else\n-  inline long double \n-  cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }\n-#endif\n+  inline long double\n+  sin(long double __x)\n+  { return __builtin_sinl(__x); }\n \n-#if _GLIBCPP_HAVE_EXPL\n-  inline long double \n-  exp(long double __x) { return ::expl(__x); }\n+  \n+  // sinh.\n+#if _GLIBCPP_HAVE_SINHF\n+  inline float \n+  sinh(float __x) { return ::sinhf(__x); }\n #else\n-  inline long double \n-  exp(long double __x) { return ::exp(static_cast<double>(__x)); }\n+  inline float \n+  sinh(float __x) { return ::sinh(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE___BUILTIN_FABSL\n-  inline long double \n-  fabs(long double __x) { return __builtin_fabsl(__x); }\n-#elif _GLIBCPP_HAVE_FABSL\n-  inline long double \n-  fabs(long double __x) { return ::fabsl(__x); }\n-#else\n-  inline long double \n-  fabs(long double __x) { return __cmath_abs(__x); }\n-#endif\n+  extern \"C\" double sinh(double __x);\n \n-#if _GLIBCPP_HAVE_FLOORL\n+#if _GLIBCPP_HAVE_SINHL\n   inline long double \n-  floor(long double __x) { return ::floorl(__x); }\n+  sinh(long double __x) { return ::sinhl(__x); }\n #else\n   inline long double \n-  floor(long double __x) { return ::floor(static_cast<double>(__x)); }\n+  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE_FMODL\n-  inline long double \n-  fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }\n-#else\n-  inline long double \n-  fmod(long double __x, long double __y) \n-  { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n-#endif\n \n-#if _GLIBCPP_HAVE_FREXPL\n-  inline long double \n-  frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }\n-#else\n-  inline long double \n-  frexp(long double __x, int* __exp) \n-  { return ::frexp(static_cast<double>(__x), __exp); }\n-#endif\n+  // sqrt.\n+  inline float\n+  sqrt(float __x)\n+  { return __builtin_sqrtf(__x); }\n \n-#if _GLIBCPP_HAVE_LDEXPL\n-  inline long double \n-  ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }\n-#else\n-  inline long double \n-  ldexp(long double __x, int __exp) \n-  { return ::ldexp(static_cast<double>(__x), __exp); }\n-#endif\n+  inline double\n+  sqrt(double __x)\n+  { return __builtin_fsqrt(__x); }\n \n-#if _GLIBCPP_HAVE_LOGL\n-  inline long double \n-  log(long double __x) { return ::logl(__x); }\n-#else\n-  inline long double \n-  log(long double __x) { return ::log(static_cast<double>(__x)); }\n-#endif\n+  inline long double\n+  sqrt(long double __x)\n+  { return __builtin_sqrtl(__x); }\n \n-#if _GLIBCPP_HAVE_LOG10L\n-  inline long double \n-  log10(long double __x) { return ::log10l(__x); }\n-#else\n-  inline long double \n-  log10(long double __x) { return ::log10(static_cast<double>(__x)); }\n-#endif\n \n-#if _GLIBCPP_HAVE_MODFL\n-  inline long double \n-  modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }\n-#else\n-  inline long double \n-  modf(long double __x, long double* __iptr) \n-  { \n-    double __tmp;\n-    double __res = ::modf(static_cast<double>(__x), &__tmp);\n-    * __iptr = static_cast<long double>(__tmp);\n-    return __res;\n-  }\n-#endif\n-\n-#if _GLIBCPP_HAVE_POWL\n-  inline long double \n-  pow(long double __x, long double __y) { return ::powl(__x, __y); }\n+  // tan.\n+#if _GLIBCPP_HAVE_TANF\n+  inline float \n+  tan(float __x) { return ::tanf(__x); }\n #else\n-  inline long double \n-  pow(long double __x, long double __y) \n-  { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n+  inline float \n+  tan(float __x) { return ::tan(static_cast<double>(__x)); }\n #endif\n \n-  inline long double \n-  pow(long double __x, int __n)\n-  {\n-    return __pow_helper(__x, __n);\n-  }\n+  extern \"C\" double tan(double __x);\n \n-#if _GLIBCPP_HAVE___BUILTIN_SINL\n-  inline long double \n-  sin(long double __x) { return __builtin_sinl(__x); }\n-#elif _GLIBCPP_HAVE_SINL\n+#if _GLIBCPP_HAVE_TANL\n   inline long double \n-  sin(long double __x) { return ::sinl(__x); }\n+  tan(long double __x) { return ::tanl(__x); }\n #else\n   inline long double \n-  sin(long double __x) { return ::sin(static_cast<double>(__x)); }\n+  tan(long double __x) { return ::tan(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE_SINHL\n-  inline long double \n-  sinh(long double __x) { return ::sinhl(__x); }\n-#else\n-  inline long double \n-  sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }\n-#endif\n \n-#if _GLIBCPP_HAVE___BUILTIN_SQRTL\n-  inline long double \n-  sqrt(long double __x) { return __builtin_sqrtl(__x); }\n-#elif _GLIBCPP_HAVE_SQRTL\n-  inline long double \n-  sqrt(long double __x) { return ::sqrtl(__x); }\n+  // tanh.\n+#if _GLIBCPP_HAVE_TANHF\n+  inline float \n+  tanh(float __x) { return ::tanhf(__x); }\n #else\n-  inline long double \n-  sqrt(long double __x) { return ::sqrt(static_cast<double>(__x)); }\n+  inline float \n+  tanh(float __x) { return ::tanh(static_cast<double>(__x)); }\n #endif\n \n-#if _GLIBCPP_HAVE_TANL\n-  inline long double \n-  tan(long double __x) { return ::tanl(__x); }\n-#else\n-  inline long double \n-  tan(long double __x) { return ::tan(static_cast<double>(__x)); }\n-#endif\n+  extern \"C\" double tanh(double __x);\n \n #if _GLIBCPP_HAVE_TANHL\n   inline long double "}]}