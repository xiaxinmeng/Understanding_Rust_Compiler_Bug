{"sha": "dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwNmFiZWNiYjNhMDM1M2Q1Yzk1YmQ5ZDVhOGFmYjYwODFlNjIzMA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-08-14T08:40:59Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:40:59Z"}, "message": "sem_ch11.adb: Improved warnings for unused variables\n\n2007-08-14  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch11.adb: Improved warnings for unused variables\n\n\t* sem_ch3.ads, sem_ch3.adb (Build_Derived_Record_Type): If the ancestor\n\tis a synchronized interface, the derived type is limited.\n\t(Analyze_Object_Declaration): Mark the potential coextensions in the\n\tdefinition and expression of an object declaration node.\n\t(Build_Derived_Type): For the completion of a private type declaration\n\twith a derived type declaration, chain the parent type's representation\n\titems to the last representation item of the derived type (not the\n\tfirst one) if they are not present already.\n\t(Analyze_Object_Declaration, Constant_Redeclaration): Allow incomplete\n\tobject declaration of forward references to tags.\n\t(Access_Subprogram_Declaration): In Ada2005, anonymous access to\n\tsubprogram types can appear as access discriminants of synchronized\n\ttypes.\n\t(OK_For_Limited_Init_In_05): The initialization is legal is it is a call\n\tgiven in prefixed form as a selected component.\n\t(Process_Discriminants): If not all discriminants have defaults, place\n\terror message on a default that is present.\n\t(Analyze_Private_Extension_Declaration): Diagnose properly an attempt to\n\textend a synchronized tagged type.\n\tImproved warnings for unused variables\n\t(Is_Visible_Component): Fix a visibility hole on a component inherited\n\tby a private extension when parent is itself declared as a private\n\textension, and the derivation is in a child unit.\n\t(Find_Hidden_Interface): Move spec from the package body.\n\nFrom-SVN: r127426", "tree": {"sha": "bf59c4f2cd07a8656d33d6936e5898573c1bc4c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf59c4f2cd07a8656d33d6936e5898573c1bc4c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/comments", "author": null, "committer": null, "parents": [{"sha": "442ade9dfe3e9ddf837174e548c8e248e9312c39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442ade9dfe3e9ddf837174e548c8e248e9312c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442ade9dfe3e9ddf837174e548c8e248e9312c39"}], "stats": {"total": 450, "additions": 261, "deletions": 189}, "files": [{"sha": "a6d937db950a8ffa06798df0d69ec03eee5c247f", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "patch": "@@ -225,9 +225,11 @@ package body Sem_Ch11 is\n \n                Generate_Definition (Choice);\n \n-               --  Set source assigned flag, since in effect this field is\n-               --  always assigned an initial value by the exception.\n+               --  Indicate that choice has an initial value, since in effect\n+               --  this field is assigned an initial value by the exception.\n+               --  We also consider that it is modified in the source.\n \n+               Set_Has_Initial_Value (Choice, True);\n                Set_Never_Set_In_Source (Choice, False);\n             end if;\n \n@@ -269,7 +271,7 @@ package body Sem_Ch11 is\n                            if Warn_On_Obsolescent_Feature then\n                               Error_Msg_N\n                                 (\"Numeric_Error is an \" &\n-                                 \"obsolescent feature ('R'M 'J.6(1))?\", Id);\n+                                 \"obsolescent feature (RM J.6(1))?\", Id);\n                               Error_Msg_N\n                                 (\"\\use Constraint_Error instead?\", Id);\n                            end if;\n@@ -306,7 +308,7 @@ package body Sem_Ch11 is\n                                  \"generic formal package\", Id, Ent);\n                               Error_Msg_N\n                                 (\"\\and therefore cannot appear in \" &\n-                                 \"handler ('R'M 11.2(8))\", Id);\n+                                 \"handler (RM 11.2(8))\", Id);\n                               exit;\n \n                            --  If the exception is declared in an inner\n@@ -462,7 +464,7 @@ package body Sem_Ch11 is\n                       P);\n                   Error_Msg_N\n                     (\"\\?RAISE statement may result in abnormal return\" &\n-                     \" ('R'M 6.4.1(17))\", P);\n+                     \" (RM 6.4.1(17))\", P);\n                end if;\n             end if;\n          end;"}, {"sha": "7779d659eb4c49544e97bcf52692db99caf5d9f3", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 246, "deletions": 183, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "patch": "@@ -208,8 +208,8 @@ package body Sem_Ch3 is\n    --\n    --  the call completes Def_Id to be the appropriate E_*_Subtype.\n    --\n-   --  The Elist is the list of discriminant constraints if any (it is set to\n-   --  No_Elist if T is not a discriminated type, and to an empty list if\n+   --  The Elist is the list of discriminant constraints if any (it is set\n+   --  to No_Elist if T is not a discriminated type, and to an empty list if\n    --  T has discriminants but there are no discriminant constraints). The\n    --  Related_Nod is the same as Decl_Node in Create_Constrained_Components.\n    --  The For_Access says whether or not this subtype is really constraining\n@@ -308,6 +308,11 @@ package body Sem_Ch3 is\n    --  Id is the entity for the redeclaration, N is the N_Object_Declaration,\n    --  node. The caller has not yet set any attributes of this entity.\n \n+   function Contain_Interface\n+     (Iface  : Entity_Id;\n+      Ifaces : Elist_Id) return Boolean;\n+   --  Ada 2005: Determine whether Iface is present in the list Ifaces\n+\n    procedure Convert_Scalar_Bounds\n      (N            : Node_Id;\n       Parent_Type  : Entity_Id;\n@@ -935,6 +940,8 @@ package body Sem_Ch3 is\n          and then Nkind (D_Ityp) /= N_Object_Declaration\n          and then Nkind (D_Ityp) /= N_Object_Renaming_Declaration\n          and then Nkind (D_Ityp) /= N_Formal_Type_Declaration\n+         and then Nkind (D_Ityp) /= N_Task_Type_Declaration\n+         and then Nkind (D_Ityp) /= N_Protected_Type_Declaration\n       loop\n          D_Ityp := Parent (D_Ityp);\n          pragma Assert (D_Ityp /= Empty);\n@@ -1386,7 +1393,7 @@ package body Sem_Ch3 is\n \n       function Contains_POC (Constr : Node_Id) return Boolean is\n       begin\n-         --  Prevent cascaded errors.\n+         --  Prevent cascaded errors\n \n          if Error_Posted (Constr) then\n             return False;\n@@ -1553,8 +1560,7 @@ package body Sem_Ch3 is\n                   E_Class_Wide_Type\n             then\n                Error_Msg_N\n-                 (\"access to specific tagged type required ('R'M 3.9.2(9))\",\n-                  E);\n+                 (\"access to specific tagged type required (RM 3.9.2(9))\", E);\n             end if;\n \n             --  (Ada 2005: AI-230): Accessibility check for anonymous\n@@ -1563,7 +1569,7 @@ package body Sem_Ch3 is\n             if Type_Access_Level (Etype (E)) > Type_Access_Level (T) then\n                Error_Msg_N\n                  (\"expression has deeper access level than component \" &\n-                  \"('R'M 3.10.2 (12.2))\", E);\n+                  \"(RM 3.10.2 (12.2))\", E);\n             end if;\n \n             --  The initialization expression is a reference to an access\n@@ -2211,6 +2217,8 @@ package body Sem_Ch3 is\n          Generate_Definition (Id);\n          Enter_Name (Id);\n \n+         Mark_Coextensions (N, Object_Definition (N));\n+\n          T := Find_Type_Of_Object (Object_Definition (N), N);\n \n          if Nkind (Object_Definition (N)) = N_Access_Definition\n@@ -2265,9 +2273,19 @@ package body Sem_Ch3 is\n       if Constant_Present (N)\n         and then No (E)\n       then\n-         if not Is_Package_Or_Generic_Package (Current_Scope) then\n+         --  We exclude forward references to tags\n+\n+         if Is_Imported (Defining_Identifier (N))\n+           and then\n+            (T = RTE (RE_Tag)\n+              or else (Present (Full_View (T))\n+                        and then Full_View (T) = RTE (RE_Tag)))\n+         then\n+            null;\n+\n+         elsif not Is_Package_Or_Generic_Package (Current_Scope) then\n             Error_Msg_N\n-              (\"invalid context for deferred constant declaration ('R'M 7.4)\",\n+              (\"invalid context for deferred constant declaration (RM 7.4)\",\n                 N);\n             Error_Msg_N\n               (\"\\declaration requires an initialization expression\",\n@@ -2330,7 +2348,7 @@ package body Sem_Ch3 is\n       --  Process initialization expression if present and not in error\n \n       if Present (E) and then E /= Error then\n-         Mark_Static_Coextensions (E);\n+         Mark_Coextensions (N, E);\n          Analyze (E);\n \n          --  In case of errors detected in the analysis of the expression,\n@@ -2370,6 +2388,18 @@ package body Sem_Ch3 is\n             end if;\n          end if;\n \n+         --  Deal with setting of null flags\n+\n+         if Is_Access_Type (T) then\n+            if Known_Non_Null (E) then\n+               Set_Is_Known_Non_Null (Id, True);\n+            elsif Known_Null (E)\n+              and then not Can_Never_Be_Null (Id)\n+            then\n+               Set_Is_Known_Null (Id, True);\n+            end if;\n+         end if;\n+\n          --  Check incorrect use of dynamically tagged expressions. Note\n          --  the use of Is_Tagged_Type (T) which seems redundant but is in\n          --  fact important to avoid spurious errors due to expanded code\n@@ -2572,12 +2602,17 @@ package body Sem_Ch3 is\n          Check_Restriction (No_Wide_Characters, Object_Definition (N));\n       end if;\n \n+      --  Indicate this is not set in source. Certainly true for constants,\n+      --  and true for variables so far (will be reset for a variable if and\n+      --  when we encounter a modification in the source).\n+\n+      Set_Never_Set_In_Source (Id, True);\n+\n       --  Now establish the proper kind and type of the object\n \n       if Constant_Present (N) then\n-         Set_Ekind               (Id, E_Constant);\n-         Set_Never_Set_In_Source (Id, True);\n-         Set_Is_True_Constant    (Id, True);\n+         Set_Ekind            (Id, E_Constant);\n+         Set_Is_True_Constant (Id, True);\n \n       else\n          Set_Ekind (Id, E_Variable);\n@@ -2595,29 +2630,23 @@ package body Sem_Ch3 is\n             Check_Shared_Var (Id, T, N);\n          end if;\n \n-         --  Case of no initializing expression present. If the type is not\n-         --  fully initialized, then we set Never_Set_In_Source, since this\n-         --  is a case of a potentially uninitialized object. Note that we\n-         --  do not consider access variables to be fully initialized for\n-         --  this purpose, since it still seems dubious if someone declares\n-\n-         --  Note that we only do this for source declarations. If the object\n-         --  is declared by a generated declaration, we assume that it is not\n-         --  appropriate to generate warnings in that case.\n+         --  Set Has_Initial_Value if initializing expression present. Note\n+         --  that if there is no initializating expression, we leave the state\n+         --  of this flag unchanged (usually it will be False, but notably in\n+         --  the case of exception choice variables, it will already be true).\n \n-         if No (E) then\n-            if (Is_Access_Type (T)\n-                 or else not Is_Fully_Initialized_Type (T))\n-              and then Comes_From_Source (N)\n-            then\n-               Set_Never_Set_In_Source (Id);\n-            end if;\n+         if Present (E) then\n+            Set_Has_Initial_Value (Id, True);\n          end if;\n       end if;\n \n+      --  Initialize alignment and size\n+\n       Init_Alignment (Id);\n       Init_Esize     (Id);\n \n+      --  Deal with aliased case\n+\n       if Aliased_Present (N) then\n          Set_Is_Aliased (Id);\n \n@@ -2641,8 +2670,12 @@ package body Sem_Ch3 is\n          end if;\n       end if;\n \n+      --  Now we can set the type of the object\n+\n       Set_Etype (Id, Act_T);\n \n+      --  Deal with controlled types\n+\n       if Has_Controlled_Component (Etype (Id))\n         or else Is_Controlled (Etype (Id))\n       then\n@@ -2924,6 +2957,17 @@ package body Sem_Ch3 is\n       then\n          Error_Msg_N (\"premature derivation of incomplete type\", Indic);\n          return;\n+\n+      elsif Is_Concurrent_Type (Parent_Type) then\n+         Error_Msg_N\n+           (\"parent type of a private extension cannot be \"\n+            & \"a synchronized tagged type (RM 3.9.1 (3/1))\", N);\n+\n+         Set_Etype              (T, Any_Type);\n+         Set_Ekind              (T, E_Limited_Private_Type);\n+         Set_Private_Dependents (T, New_Elmt_List);\n+         Set_Error_Posted       (T);\n+         return;\n       end if;\n \n       --  Perhaps the parent type should be changed to the class-wide type's\n@@ -3421,7 +3465,7 @@ package body Sem_Ch3 is\n                                      (Subtype_Mark (Subtype_Indication (N)))));\n                begin\n                   R_Checks :=\n-                    Range_Check\n+                    Get_Range_Checks\n                       (Scalar_Range (Etype (First_Index (Id))),\n                        Target_Typ,\n                        Etype (First_Index (Id)),\n@@ -4096,8 +4140,7 @@ package body Sem_Ch3 is\n \n          declare\n             Indices : constant List_Id :=\n-              New_List (New_Occurrence_Of (Any_Id, Sloc (T)));\n-\n+                        New_List (New_Occurrence_Of (Any_Id, Sloc (T)));\n          begin\n             Set_Discrete_Subtype_Definitions (Def, Indices);\n             Set_First_Index (T, First (Indices));\n@@ -6224,7 +6267,7 @@ package body Sem_Ch3 is\n                then\n                   Error_Msg_NE\n                     (\"parent type of& must not be outside generic body\"\n-                       & \" ('R'M 3.9.1(4))\",\n+                       & \" (RM 3.9.1(4))\",\n                          Indic, Derived_Type);\n                end if;\n             end;\n@@ -6291,13 +6334,20 @@ package body Sem_Ch3 is\n \n       --  AI-419: Limitedness is not inherited from an interface parent, so to\n       --  be limited in that case the type must be explicitly declared as\n-      --  limited.\n+      --  limited. However, task and protected interfaces are always limited.\n \n-      Set_Is_Limited_Record\n-        (Derived_Type,\n-         Limited_Present (Type_Def)\n-           or else (Is_Limited_Record (Parent_Type)\n-                     and then not Is_Interface (Parent_Type)));\n+      if Limited_Present (Type_Def) then\n+         Set_Is_Limited_Record (Derived_Type);\n+\n+      elsif Is_Limited_Record (Parent_Type) then\n+         if not Is_Interface (Parent_Type)\n+           or else Is_Synchronized_Interface (Parent_Type)\n+           or else Is_Protected_Interface (Parent_Type)\n+           or else Is_Task_Interface (Parent_Type)\n+         then\n+            Set_Is_Limited_Record (Derived_Type);\n+         end if;\n+      end if;\n \n       --  STEP 2a: process discriminants of derived type if any\n \n@@ -6796,23 +6846,41 @@ package body Sem_Ch3 is\n          --  from a private extension declaration.\n \n          declare\n-            Rep   : Node_Id;\n+            Rep : Node_Id;\n+            --  Used to iterate over representation items of the derived type\n+\n+            Last_Rep : Node_Id;\n+            --  Last representation item of the (non-empty) representation\n+            --  item list of the derived type.\n+\n             Found : Boolean := False;\n \n          begin\n-            Rep := First_Rep_Item (Derived_Type);\n+            Rep      := First_Rep_Item (Derived_Type);\n+            Last_Rep := Rep;\n             while Present (Rep) loop\n                if Rep = First_Rep_Item (Parent_Type) then\n                   Found := True;\n                   exit;\n+\n                else\n                   Rep := Next_Rep_Item (Rep);\n+\n+                  if Present (Rep) then\n+                     Last_Rep := Rep;\n+                  end if;\n                end if;\n             end loop;\n \n+            --  Here if we either encountered the parent type's first rep\n+            --  item on the derived type's rep item list (in which case\n+            --  Found is True, and we have nothing else to do), or if we\n+            --  reached the last rep item of the derived type, which is\n+            --  Last_Rep, in which case we further chain the parent type's\n+            --  rep items to those of the derived type.\n+\n             if not Found then\n-               Set_Next_Rep_Item\n-                 (First_Rep_Item (Derived_Type), First_Rep_Item (Parent_Type));\n+               Set_Next_Rep_Item (Last_Rep, First_Rep_Item (Parent_Type));\n             end if;\n          end;\n \n@@ -7353,19 +7421,6 @@ package body Sem_Ch3 is\n          elsif not For_Access then\n             Set_Cloned_Subtype (Def_Id, T);\n          end if;\n-\n-         --  Handle subtypes associated with statically allocated dispatch\n-         --  tables.\n-\n-         if Static_Dispatch_Tables\n-           and then VM_Target = No_VM\n-           and then RTU_Loaded (Ada_Tags)\n-           and then (T = RTE (RE_Dispatch_Table_Wrapper)\n-                       or else\n-                     T = RTE (RE_Type_Specific_Data))\n-         then\n-            Set_Size_Known_At_Compile_Time (Def_Id);\n-         end if;\n       end if;\n    end Build_Discriminated_Subtype;\n \n@@ -7701,6 +7756,8 @@ package body Sem_Ch3 is\n          --  overriding in Ada2005, but wrappers need to be built for them\n          --  (see exp_ch3, Build_Controlling_Function_Wrappers).\n \n+         --  Use elseif here and avoid above goto???\n+\n          if Is_Null_Extension (T)\n            and then Has_Controlling_Result (Subp)\n            and then Ada_Version >= Ada_05\n@@ -7798,22 +7855,16 @@ package body Sem_Ch3 is\n                   --  The controlling formal of Subp must be of mode \"out\",\n                   --  \"in out\" or an access-to-variable to be overridden.\n \n+                  --  Error message below needs rewording (remember comma\n+                  --  in -gnatj mode) ???\n+\n                   if Ekind (First_Formal (Subp)) = E_In_Parameter then\n                      Error_Msg_NE\n                        (\"first formal of & must be of mode `OUT`, `IN OUT` \" &\n                         \"or access-to-variable\", T, Subp);\n-\n-                     if Is_Protected_Type\n-                          (Corresponding_Concurrent_Type (T))\n-                     then\n-                        Error_Msg_N\n-                          (\"\\to be overridden by protected procedure or \" &\n-                           \"entry (`R`M 9.4(11))\", T);\n-                     else\n-                        Error_Msg_N\n-                          (\"\\to be overridden by task entry (`R`M 9.4(11))\",\n-                           T);\n-                     end if;\n+                     Error_Msg_N\n+                       (\"\\to be overridden by protected procedure or \" &\n+                        \"entry (RM 9.4(11.9/2))\", T);\n \n                   --  Some other kind of overriding failure\n \n@@ -7896,7 +7947,7 @@ package body Sem_Ch3 is\n                  and then Ada_Version < Ada_05\n                then\n                   Error_Msg_N\n-                    (\"aliased component must be constrained ('R'M 3.6(11))\",\n+                    (\"aliased component must be constrained (RM 3.6(11))\",\n                       C);\n                end if;\n \n@@ -7911,7 +7962,7 @@ package body Sem_Ch3 is\n               and then Ada_Version < Ada_05\n             then\n                Error_Msg_N\n-                 (\"aliased component type must be constrained ('R'M 3.6(11))\",\n+                 (\"aliased component type must be constrained (RM 3.6(11))\",\n                     T);\n             end if;\n          end if;\n@@ -8705,10 +8756,19 @@ package body Sem_Ch3 is\n             Error_Msg_N (\"ALIASED required (see declaration#)\", N);\n          end if;\n \n+         --  Allow incomplete declaration of tags (used to handle forward\n+         --  references to tags). The check on Ada_Tags avoids cicularities\n+         --  when rebuilding the compiler.\n+\n+         if RTU_Loaded (Ada_Tags)\n+           and then T = RTE (RE_Tag)\n+         then\n+            null;\n+\n          --  Check that placement is in private part and that the incomplete\n          --  declaration appeared in the visible part.\n \n-         if Ekind (Current_Scope) = E_Package\n+         elsif Ekind (Current_Scope) = E_Package\n            and then not In_Private_Part (Current_Scope)\n          then\n             Error_Msg_Sloc := Sloc (Prev);\n@@ -9811,7 +9871,7 @@ package body Sem_Ch3 is\n          if Warn_On_Obsolescent_Feature then\n             Error_Msg_N\n               (\"subtype digits constraint is an \" &\n-               \"obsolescent feature ('R'M 'J.3(8))?\", C);\n+               \"obsolescent feature (RM J.3(8))?\", C);\n          end if;\n \n          D := Digits_Expression (C);\n@@ -10014,7 +10074,7 @@ package body Sem_Ch3 is\n          if Warn_On_Obsolescent_Feature then\n             Error_Msg_S\n               (\"subtype delta constraint is an \" &\n-               \"obsolescent feature ('R'M 'J.3(7))?\");\n+               \"obsolescent feature (RM J.3(7))?\");\n          end if;\n \n          D := Delta_Expression (C);\n@@ -10063,6 +10123,31 @@ package body Sem_Ch3 is\n       Set_Has_Delayed_Freeze (Def_Id);\n    end Constrain_Ordinary_Fixed;\n \n+   -----------------------\n+   -- Contain_Interface --\n+   -----------------------\n+\n+   function Contain_Interface\n+     (Iface  : Entity_Id;\n+      Ifaces : Elist_Id) return Boolean\n+   is\n+      Iface_Elmt : Elmt_Id;\n+\n+   begin\n+      if Present (Ifaces) then\n+         Iface_Elmt := First_Elmt (Ifaces);\n+         while Present (Iface_Elmt) loop\n+            if Node (Iface_Elmt) = Iface then\n+               return True;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end if;\n+\n+      return False;\n+   end Contain_Interface;\n+\n    ---------------------------\n    -- Convert_Scalar_Bounds --\n    ---------------------------\n@@ -10501,19 +10586,17 @@ package body Sem_Ch3 is\n             begin\n                Constr    := First_Elmt (Stored_Constraint (Typ));\n                Old_Discr := First_Stored_Discriminant (Typ);\n-\n                while Present (Constr) loop\n                   if Is_Entity_Name (Node (Constr))\n                     and then Ekind (Entity (Node (Constr))) = E_Discriminant\n                   then\n                      New_Discr := Entity (Node (Constr));\n \n-                     if Chars (Corresponding_Discriminant (New_Discr))\n-                         /= Chars (Old_Discr)\n+                     if Chars (Corresponding_Discriminant (New_Discr)) /=\n+                        Chars (Old_Discr)\n                      then\n-\n-                        --  The new discriminant has been used to rename\n-                        --  a subsequent old discriminant. Introduce a shadow\n+                        --  The new discriminant has been used to rename a\n+                        --  subsequent old discriminant. Introduce a shadow\n                         --  component for the current old discriminant.\n \n                         New_C := Create_Component (Old_Discr);\n@@ -11691,8 +11774,8 @@ package body Sem_Ch3 is\n \n       if Interface_Present (Def) then\n          if not Is_Interface (Parent_Type) then\n-            Error_Msg_NE (\"(Ada 2005) & must be an interface\",\n-                          Indic, Parent_Type);\n+            Error_Msg_NE\n+              (\"(Ada 2005) & must be an interface\", Indic, Parent_Type);\n \n          else\n             Parent_Node := Parent (Base_Type (Parent_Type));\n@@ -11706,20 +11789,24 @@ package body Sem_Ch3 is\n                   null;\n \n                elsif Protected_Present (Iface_Def) then\n-                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n-                    \" inherit from protected interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) limited interface cannot \"\n+                     & \"inherit from protected interface\", Indic);\n \n                elsif Synchronized_Present (Iface_Def) then\n-                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n-                    \" inherit from synchronized interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) limited interface cannot \"\n+                     & \"inherit from synchronized interface\", Indic);\n \n                elsif Task_Present (Iface_Def) then\n-                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n-                    \" inherit from task interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) limited interface cannot \"\n+                     & \"inherit from task interface\", Indic);\n \n                else\n-                  Error_Msg_N (\"(Ada 2005) limited interface cannot\" &\n-                    \" inherit from non-limited interface\", Indic);\n+                  Error_Msg_N\n+                    (\"(Ada 2005) limited interface cannot \"\n+                     & \"inherit from non-limited interface\", Indic);\n                end if;\n \n             --  Ada 2005 (AI-345): Non-limited interfaces can only inherit\n@@ -11734,18 +11821,18 @@ package body Sem_Ch3 is\n \n                elsif Protected_Present (Iface_Def) then\n                   Error_Msg_N\n-                    (\"(Ada 2005) non-limited interface cannot \" &\n-                     \"inherit from protected interface\", Indic);\n+                    (\"(Ada 2005) non-limited interface cannot \"\n+                     & \"inherit from protected interface\", Indic);\n \n                elsif Synchronized_Present (Iface_Def) then\n                   Error_Msg_N\n-                    (\"(Ada 2005) non-limited interface cannot \" &\n-                     \"inherit from synchronized interface\", Indic);\n+                    (\"(Ada 2005) non-limited interface cannot \"\n+                     & \"inherit from synchronized interface\", Indic);\n \n                elsif Task_Present (Iface_Def) then\n                   Error_Msg_N\n-                    (\"(Ada 2005) non-limited interface cannot \" &\n-                     \"inherit from task interface\", Indic);\n+                    (\"(Ada 2005) non-limited interface cannot \"\n+                     & \"inherit from task interface\", Indic);\n \n                else\n                   null;\n@@ -11757,10 +11844,11 @@ package body Sem_Ch3 is\n       if Is_Tagged_Type (Parent_Type)\n         and then Is_Concurrent_Type (Parent_Type)\n         and then not Is_Interface (Parent_Type)\n-        and then not Is_Completion\n       then\n-         Error_Msg_N (\"parent type of a record extension cannot be \" &\n-            \"a synchronized tagged type (3.9.1 (3/1)\", N);\n+         Error_Msg_N\n+           (\"parent type of a record extension cannot be \"\n+            & \"a synchronized tagged type (RM 3.9.1 (3/1))\", N);\n+         Set_Etype (T, Any_Type);\n          return;\n       end if;\n \n@@ -12257,6 +12345,36 @@ package body Sem_Ch3 is\n       return Expansion;\n    end Expand_To_Stored_Constraint;\n \n+   ---------------------------\n+   -- Find_Hidden_Interface --\n+   ---------------------------\n+\n+   function Find_Hidden_Interface\n+     (Src  : Elist_Id;\n+      Dest : Elist_Id) return Entity_Id\n+   is\n+      Iface      : Entity_Id;\n+      Iface_Elmt : Elmt_Id;\n+\n+   begin\n+      if Present (Src) and then Present (Dest) then\n+         Iface_Elmt := First_Elmt (Src);\n+         while Present (Iface_Elmt) loop\n+            Iface := Node (Iface_Elmt);\n+\n+            if Is_Interface (Iface)\n+              and then not Contain_Interface (Iface, Dest)\n+            then\n+               return Iface;\n+            end if;\n+\n+            Next_Elmt (Iface_Elmt);\n+         end loop;\n+      end if;\n+\n+      return Empty;\n+   end Find_Hidden_Interface;\n+\n    --------------------\n    -- Find_Type_Name --\n    --------------------\n@@ -12354,8 +12472,9 @@ package body Sem_Ch3 is\n                   end if;\n                end if;\n \n-            --  Ada 2005 (AI-251): Private extension declaration of a\n-            --  task type. This case arises with tasks implementing interfaces\n+            --  Ada 2005 (AI-251): Private extension declaration of a task\n+            --  type or a protected type. This case arises when covering\n+            --  interface types.\n \n             elsif Nkind (N) = N_Task_Type_Declaration\n               or else Nkind (N) = N_Protected_Type_Declaration\n@@ -13471,7 +13590,7 @@ package body Sem_Ch3 is\n       --  If the component has been declared in an ancestor which is currently\n       --  a private type, then it is not visible. The same applies if the\n       --  component's containing type is not in an open scope and the original\n-      --  component's enclosing type is a visible full type of a private type\n+      --  component's enclosing type is a visible full view of a private type\n       --  (which can occur in cases where an attempt is being made to reference\n       --  a component in a sibling package that is inherited from a visible\n       --  component of a type in an ancestor package; the component in the\n@@ -13506,6 +13625,7 @@ package body Sem_Ch3 is\n          else\n             return\n               Is_Child_Unit (Cunit_Entity (Current_Sem_Unit))\n+                and then In_Open_Scopes (Scope (Original_Scope))\n                 and then Is_Local_Type (Type_Scope);\n          end if;\n \n@@ -14003,6 +14123,7 @@ package body Sem_Ch3 is\n \n       Set_Modular_Size (System_Max_Binary_Modulus_Power);\n       Init_Alignment (T);\n+\n    end Modular_Type_Declaration;\n \n    --------------------------\n@@ -14097,7 +14218,7 @@ package body Sem_Ch3 is\n             return OK_For_Limited_Init_In_05\n                      (Expression (Original_Node (Exp)));\n \n-         when N_Indexed_Component =>\n+         when N_Indexed_Component | N_Selected_Component  =>\n             return Nkind (Exp) = N_Function_Call;\n \n          when others =>\n@@ -14284,7 +14405,6 @@ package body Sem_Ch3 is\n \n    begin\n       --  A composite type other than an array type can have discriminants.\n-      --  Discriminants of non-limited types must have a discrete type.\n       --  On entry, the current scope is the composite type.\n \n       --  The discriminants are initially entered into the scope of the type\n@@ -14444,7 +14564,8 @@ package body Sem_Ch3 is\n                  or else Ekind (Current_Scope) = E_Limited_Private_Type\n                then\n                   null;\n-               else\n+\n+               elsif Present (Expression (Discr)) then\n                   Error_Msg_N\n                     (\"(Ada 2005) access discriminants of nonlimited types\",\n                      Expression (Discr));\n@@ -14532,18 +14653,6 @@ package body Sem_Ch3 is\n       --  inherently implements. Duplicate entries are not added to\n       --  the list Ifaces.\n \n-      function Contain_Interface\n-        (Iface  : Entity_Id;\n-         Ifaces : Elist_Id) return Boolean;\n-      --  Ada 2005: Determine whether Iface is present in the list Ifaces\n-\n-      function Find_Hidden_Interface\n-        (Src  : Elist_Id;\n-         Dest : Elist_Id) return Entity_Id;\n-      --  Ada 2005: Determine whether the interfaces in list Src are all\n-      --  present in the list Dest. Return the first differing interface,\n-      --  or Empty otherwise.\n-\n       ------------------------------------\n       -- Collect_Implemented_Interfaces --\n       ------------------------------------\n@@ -14591,10 +14700,8 @@ package body Sem_Ch3 is\n                if Present (Full_View (Typ))\n                  and then Etype (Typ) /= Full_View (Typ)\n                then\n-                  if Is_Interface (Etype (Typ))\n-                    and then not Contain_Interface (Etype (Typ), Ifaces)\n-                  then\n-                     Append_Elmt (Etype (Typ), Ifaces);\n+                  if Is_Interface (Etype (Typ)) then\n+                     Append_Unique_Elmt (Etype (Typ), Ifaces);\n                   end if;\n \n                   Collect_Implemented_Interfaces (Etype (Typ), Ifaces);\n@@ -14603,10 +14710,8 @@ package body Sem_Ch3 is\n             --  Non-private types\n \n             else\n-               if Is_Interface (Etype (Typ))\n-                 and then not Contain_Interface (Etype (Typ), Ifaces)\n-               then\n-                  Append_Elmt (Etype (Typ), Ifaces);\n+               if Is_Interface (Etype (Typ)) then\n+                  Append_Unique_Elmt (Etype (Typ), Ifaces);\n                end if;\n \n                Collect_Implemented_Interfaces (Etype (Typ), Ifaces);\n@@ -14632,59 +14737,6 @@ package body Sem_Ch3 is\n          end if;\n       end Collect_Implemented_Interfaces;\n \n-      -----------------------\n-      -- Contain_Interface --\n-      -----------------------\n-\n-      function Contain_Interface\n-        (Iface  : Entity_Id;\n-         Ifaces : Elist_Id) return Boolean\n-      is\n-         Iface_Elmt : Elmt_Id;\n-\n-      begin\n-         if Present (Ifaces) then\n-            Iface_Elmt := First_Elmt (Ifaces);\n-            while Present (Iface_Elmt) loop\n-               if Node (Iface_Elmt) = Iface then\n-                  return True;\n-               end if;\n-\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-         end if;\n-\n-         return False;\n-      end Contain_Interface;\n-\n-      ---------------------------\n-      -- Find_Hidden_Interface --\n-      ---------------------------\n-\n-      function Find_Hidden_Interface\n-        (Src  : Elist_Id;\n-         Dest : Elist_Id) return Entity_Id\n-      is\n-         Iface      : Entity_Id;\n-         Iface_Elmt : Elmt_Id;\n-\n-      begin\n-         if Present (Src) and then Present (Dest) then\n-            Iface_Elmt := First_Elmt (Src);\n-            while Present (Iface_Elmt) loop\n-               Iface := Node (Iface_Elmt);\n-\n-               if not Contain_Interface (Iface, Dest) then\n-                  return Iface;\n-               end if;\n-\n-               Next_Elmt (Iface_Elmt);\n-            end loop;\n-         end if;\n-\n-         return Empty;\n-      end Find_Hidden_Interface;\n-\n    --  Start of processing for Process_Full_View\n \n    begin\n@@ -14710,11 +14762,17 @@ package body Sem_Ch3 is\n         and then Is_Limited_Type (Priv_T)\n         and then not Is_Limited_Type (Full_T)\n       then\n+         --  If pragma CPP_Class was applied to the private declaration\n+         --  propagate the limitedness to the full-view\n+\n+         if Is_CPP_Class (Priv_T) then\n+            Set_Is_Limited_Record (Full_T);\n+\n          --  GNAT allow its own definition of Limited_Controlled to disobey\n          --  this rule in order in ease the implementation. The next test is\n          --  safe because Root_Controlled is defined in a private system child\n \n-         if Etype (Full_T) = Full_View (RTE (RE_Root_Controlled)) then\n+         elsif Etype (Full_T) = Full_View (RTE (RE_Root_Controlled)) then\n             Set_Is_Limited_Composite (Full_T);\n          else\n             Error_Msg_N\n@@ -14751,14 +14809,14 @@ package body Sem_Ch3 is\n \n             if Present (Iface) then\n                Error_Msg_NE (\"interface & not implemented by full type \" &\n-                             \"('R'M'-2005 7.3 (7.3/2))\", Priv_T, Iface);\n+                             \"(RM-2005 7.3 (7.3/2))\", Priv_T, Iface);\n             end if;\n \n             Iface := Find_Hidden_Interface (Full_T_Ifaces, Priv_T_Ifaces);\n \n             if Present (Iface) then\n                Error_Msg_NE (\"interface & not implemented by partial view \" &\n-                             \"('R'M'-2005 7.3 (7.3/2))\", Full_T, Iface);\n+                             \"(RM-2005 7.3 (7.3/2))\", Full_T, Iface);\n             end if;\n          end;\n       end if;\n@@ -15356,7 +15414,7 @@ package body Sem_Ch3 is\n             --  the place where we put the check.\n \n             if not R_Check_Off then\n-               R_Checks := Range_Check (R, T);\n+               R_Checks := Get_Range_Checks (R, T);\n \n                --  Look up tree to find an appropriate insertion point.\n                --  This seems really junk code, and very brittle, couldn't\n@@ -15924,12 +15982,15 @@ package body Sem_Ch3 is\n          Type_Id : constant Name_Id := Chars (Typ);\n \n          function Names_T (Nam : Node_Id) return Boolean;\n-\n          --  The record type has not been introduced in the current scope\n          --  yet, so we must examine the name of the type itself, either\n          --  an identifier T, or an expanded name of the form P.T, where\n          --  P denotes the current scope.\n \n+         -------------\n+         -- Names_T --\n+         -------------\n+\n          function Names_T (Nam : Node_Id) return Boolean is\n          begin\n             if Nkind (Nam) = N_Identifier then\n@@ -15941,8 +16002,8 @@ package body Sem_Ch3 is\n                      return Chars (Prefix (Nam)) = Chars (Current_Scope);\n \n                   elsif Nkind (Prefix (Nam)) = N_Selected_Component then\n-                     return Chars (Selector_Name (Prefix (Nam)))\n-                       = Chars (Current_Scope);\n+                     return Chars (Selector_Name (Prefix (Nam))) =\n+                            Chars (Current_Scope);\n                   else\n                      return False;\n                   end if;\n@@ -15954,6 +16015,8 @@ package body Sem_Ch3 is\n             end if;\n          end Names_T;\n \n+      --  Start of processing for Mentions_T\n+\n       begin\n          if No (Access_To_Subprogram_Definition (Acc_Def)) then\n             Subt := Subtype_Mark (Acc_Def);"}, {"sha": "5079e7b39e237049eeb76763e2a359d5d44cf00e", "filename": "gcc/ada/sem_ch3.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/gcc%2Fada%2Fsem_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc06abecbb3a0353d5c95bd9d5a8afb6081e6230/gcc%2Fada%2Fsem_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.ads?ref=dc06abecbb3a0353d5c95bd9d5a8afb6081e6230", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -137,6 +137,13 @@ package Sem_Ch3  is\n    --  Note: one might expect this to be private to the package body, but\n    --  there is one rather unusual usage in package Exp_Dist.\n \n+   function Find_Hidden_Interface\n+     (Src  : Elist_Id;\n+      Dest : Elist_Id) return Entity_Id;\n+   --  Ada 2005: Determine whether the interfaces in list Src are all present\n+   --  in the list Dest. Return the first differing interface, or Empty\n+   --  otherwise.\n+\n    function Find_Type_Of_Subtype_Indic (S : Node_Id) return Entity_Id;\n    --  Given a subtype indication S (which is really an N_Subtype_Indication\n    --  node or a plain N_Identifier), find the type of the subtype mark."}]}