{"sha": "07b7dc09b21d1a2f000f2861a87b017b764b38b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdiN2RjMDliMjFkMWEyZjAwMGYyODYxYTg3YjAxN2I3NjRiMzhiNA==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2021-03-01T15:39:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-16T08:43:04Z"}, "message": "[Ada] Fix detection of volatile expressions in restricted contexts\n\ngcc/ada/\n\n\t* sem_res.adb (Flag_Effectively_Volatile_Objects): Detect also\n\tallocators within restricted contexts and not just entity names.\n\t(Resolve_Actuals): Remove duplicated code for detecting\n\trestricted contexts; it is now exclusively done in\n\tIs_OK_Volatile_Context.\n\t(Resolve_Entity_Name): Adapt to new parameter of\n\tIs_OK_Volatile_Context.\n\t* sem_util.ads, sem_util.adb (Is_OK_Volatile_Context): Adapt to\n\thandle contexts both inside and outside of subprogram call\n\tactual parameters.\n\t(Within_Subprogram_Call): Remove; now handled by\n\tIs_OK_Volatile_Context itself and its parameter.", "tree": {"sha": "be959e689cdd3fb00e55cd6adf0b0b0fbc4da815", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be959e689cdd3fb00e55cd6adf0b0b0fbc4da815"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07b7dc09b21d1a2f000f2861a87b017b764b38b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b7dc09b21d1a2f000f2861a87b017b764b38b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07b7dc09b21d1a2f000f2861a87b017b764b38b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07b7dc09b21d1a2f000f2861a87b017b764b38b4/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "207962b929cc771fd560c467f44efe8f9f679ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/207962b929cc771fd560c467f44efe8f9f679ac4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/207962b929cc771fd560c467f44efe8f9f679ac4"}], "stats": {"total": 192, "additions": 91, "deletions": 101}, "files": [{"sha": "4377f91b7b51d7dcec69e611a7ba714b78677b06", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b7dc09b21d1a2f000f2861a87b017b764b38b4/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b7dc09b21d1a2f000f2861a87b017b764b38b4/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=07b7dc09b21d1a2f000f2861a87b017b764b38b4", "patch": "@@ -3755,19 +3755,18 @@ package body Sem_Res is\n \n          begin\n             case Nkind (N) is\n-\n-               --  Do not consider object name appearing in the prefix of\n-               --  attribute Address as a read.\n-\n-               when N_Attribute_Reference =>\n-\n-                  --  Prefix of attribute Address denotes an object, program\n-                  --  unit, or label; none of them needs to be flagged here.\n-\n-                  if Attribute_Name (N) = Name_Address then\n-                     return Skip;\n+               when N_Allocator =>\n+                  if not Is_OK_Volatile_Context (Context       => Parent (N),\n+                                                 Obj_Ref       => N,\n+                                                 Check_Actuals => True)\n+                  then\n+                     Error_Msg_N\n+                       (\"allocator cannot appear in this context\"\n+                        & \" (SPARK RM 7.1.3(10))\", N);\n                   end if;\n \n+                  return Skip;\n+\n                --  Do not consider nested function calls because they have\n                --  already been processed during their own resolution.\n \n@@ -3780,6 +3779,10 @@ package body Sem_Res is\n                   if Present (Id)\n                     and then Is_Object (Id)\n                     and then Is_Effectively_Volatile_For_Reading (Id)\n+                    and then\n+                      not Is_OK_Volatile_Context (Context       => Parent (N),\n+                                                  Obj_Ref       => N,\n+                                                  Check_Actuals => True)\n                   then\n                      Error_Msg_N\n                        (\"volatile object cannot appear in this context\"\n@@ -3789,10 +3792,8 @@ package body Sem_Res is\n                   return Skip;\n \n                when others =>\n-                  null;\n+                  return OK;\n             end case;\n-\n-            return OK;\n          end Flag_Object;\n \n          procedure Flag_Objects is new Traverse_Proc (Flag_Object);\n@@ -4962,40 +4963,14 @@ package body Sem_Res is\n \n             if SPARK_Mode = On and then Comes_From_Source (A) then\n \n-               --  An effectively volatile object for reading may act as an\n-               --  actual when the corresponding formal is of a non-scalar\n-               --  effectively volatile type for reading (SPARK RM 7.1.3(10)).\n+               --  Inspect the expression and flag each effectively volatile\n+               --  object for reading as illegal because it appears within\n+               --  an interfering context. Note that this is usually done\n+               --  in Resolve_Entity_Name, but when the effectively volatile\n+               --  object for reading appears as an actual in a call, the call\n+               --  must be resolved first.\n \n-               if not Is_Scalar_Type (F_Typ)\n-                 and then Is_Effectively_Volatile_For_Reading (F_Typ)\n-               then\n-                  null;\n-\n-               --  An effectively volatile object for reading may act as an\n-               --  actual in a call to an instance of Unchecked_Conversion.\n-               --  (SPARK RM 7.1.3(10)).\n-\n-               elsif Is_Unchecked_Conversion_Instance (Nam) then\n-                  null;\n-\n-               --  The actual denotes an object\n-\n-               elsif Is_Effectively_Volatile_Object_For_Reading (A) then\n-                  Error_Msg_N\n-                    (\"volatile object cannot act as actual in a call (SPARK \"\n-                     & \"RM 7.1.3(10))\", A);\n-\n-               --  Otherwise the actual denotes an expression. Inspect the\n-               --  expression and flag each effectively volatile object\n-               --  for reading as illegal because it apprears within an\n-               --  interfering context. Note that this is usually done in\n-               --  Resolve_Entity_Name, but when the effectively volatile\n-               --  object for reading appears as an actual in a call, the\n-               --  call must be resolved first.\n-\n-               else\n-                  Flag_Effectively_Volatile_Objects (A);\n-               end if;\n+               Flag_Effectively_Volatile_Objects (A);\n \n                --  An effectively volatile variable cannot act as an actual\n                --  parameter in a procedure call when the variable has enabled\n@@ -7890,7 +7865,8 @@ package body Sem_Res is\n \n             if Is_Object (E)\n               and then Is_Effectively_Volatile_For_Reading (E)\n-              and then not Is_OK_Volatile_Context (Par, N)\n+              and then\n+                not Is_OK_Volatile_Context (Par, N, Check_Actuals => False)\n             then\n                SPARK_Msg_N\n                  (\"volatile object cannot appear in this context \""}, {"sha": "68e9a089eaf162e8a0d66a76808b274a8b16dbcb", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b7dc09b21d1a2f000f2861a87b017b764b38b4/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b7dc09b21d1a2f000f2861a87b017b764b38b4/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=07b7dc09b21d1a2f000f2861a87b017b764b38b4", "patch": "@@ -18794,8 +18794,9 @@ package body Sem_Util is\n    ----------------------------\n \n    function Is_OK_Volatile_Context\n-     (Context : Node_Id;\n-      Obj_Ref : Node_Id) return Boolean\n+     (Context       : Node_Id;\n+      Obj_Ref       : Node_Id;\n+      Check_Actuals : Boolean) return Boolean\n    is\n       function Is_Protected_Operation_Call (Nod : Node_Id) return Boolean;\n       --  Determine whether an arbitrary node denotes a call to a protected\n@@ -18878,6 +18879,12 @@ package body Sem_Util is\n          Func_Id := Id;\n          while Present (Func_Id) and then Func_Id /= Standard_Standard loop\n             if Ekind (Func_Id) in E_Function | E_Generic_Function then\n+\n+               --  ??? This routine could just use Return_Applies_To, but it\n+               --  is currently wrongly called by unanalyzed return statements\n+               --  coming from expression functions.\n+               pragma Assert (Func_Id = Return_Applies_To (Id));\n+\n                return Is_Volatile_Function (Func_Id);\n             end if;\n \n@@ -18894,9 +18901,17 @@ package body Sem_Util is\n    --  Start of processing for Is_OK_Volatile_Context\n \n    begin\n+      --  For actual parameters within explicit parameter associations switch\n+      --  the context to the corresponding subprogram call.\n+\n+      if Nkind (Context) = N_Parameter_Association then\n+         return Is_OK_Volatile_Context (Context       => Parent (Context),\n+                                        Obj_Ref       => Obj_Ref,\n+                                        Check_Actuals => Check_Actuals);\n+\n       --  The volatile object appears on either side of an assignment\n \n-      if Nkind (Context) = N_Assignment_Statement then\n+      elsif Nkind (Context) = N_Assignment_Statement then\n          return True;\n \n       --  The volatile object is part of the initialization expression of\n@@ -18914,7 +18929,7 @@ package body Sem_Util is\n          --  function is volatile.\n \n          if Is_Return_Object (Obj_Id) then\n-            return Within_Volatile_Function (Obj_Id);\n+            return Within_Volatile_Function (Scope (Obj_Id));\n \n          --  Otherwise this is a normal object initialization\n \n@@ -18965,8 +18980,9 @@ package body Sem_Util is\n               N_Slice\n         and then Prefix (Context) = Obj_Ref\n         and then Is_OK_Volatile_Context\n-                   (Context => Parent (Context),\n-                    Obj_Ref => Context)\n+                   (Context       => Parent (Context),\n+                    Obj_Ref       => Context,\n+                    Check_Actuals => Check_Actuals)\n       then\n          return True;\n \n@@ -18998,8 +19014,9 @@ package body Sem_Util is\n                              | N_Unchecked_Type_Conversion\n         and then Expression (Context) = Obj_Ref\n         and then Is_OK_Volatile_Context\n-                   (Context => Parent (Context),\n-                    Obj_Ref => Context)\n+                   (Context       => Parent (Context),\n+                    Obj_Ref       => Context,\n+                    Check_Actuals => Check_Actuals)\n       then\n          return True;\n \n@@ -19014,17 +19031,43 @@ package body Sem_Util is\n       elsif Within_Check (Context) then\n          return True;\n \n-      --  Assume that references to effectively volatile objects that appear\n-      --  as actual parameters in a subprogram call are always legal. A full\n-      --  legality check is done when the actuals are resolved (see routine\n-      --  Resolve_Actuals).\n+      --  References to effectively volatile objects that appear as actual\n+      --  parameters in subprogram calls can be examined only after call itself\n+      --  has been resolved. Before that, assume such references to be legal.\n \n-      elsif Within_Subprogram_Call (Context) then\n-         return True;\n+      elsif Nkind (Context) in N_Subprogram_Call | N_Entry_Call_Statement then\n+         if Check_Actuals then\n+            declare\n+               Call   : Node_Id;\n+               Formal : Entity_Id;\n+               Subp   : constant Entity_Id := Get_Called_Entity (Context);\n+            begin\n+               Find_Actual (Obj_Ref, Formal, Call);\n+               pragma Assert (Call = Context);\n+\n+               --  An effectively volatile object may act as an actual when the\n+               --  corresponding formal is of a non-scalar effectively volatile\n+               --  type (SPARK RM 7.1.3(10)).\n+\n+               if not Is_Scalar_Type (Etype (Formal))\n+                 and then Is_Effectively_Volatile_For_Reading (Etype (Formal))\n+               then\n+                  return True;\n+\n+               --  An effectively volatile object may act as an actual in a\n+               --  call to an instance of Unchecked_Conversion. (SPARK RM\n+               --  7.1.3(10)).\n \n-      --  Otherwise the context is not suitable for an effectively volatile\n-      --  object.\n+               elsif Is_Unchecked_Conversion_Instance (Subp) then\n+                  return True;\n \n+               else\n+                  return False;\n+               end if;\n+            end;\n+         else\n+            return True;\n+         end if;\n       else\n          return False;\n       end if;\n@@ -29538,36 +29581,6 @@ package body Sem_Util is\n       return Scope_Within_Or_Same (Scope (E), S);\n    end Within_Scope;\n \n-   ----------------------------\n-   -- Within_Subprogram_Call --\n-   ----------------------------\n-\n-   function Within_Subprogram_Call (N : Node_Id) return Boolean is\n-      Par : Node_Id;\n-\n-   begin\n-      --  Climb the parent chain looking for a function or procedure call\n-\n-      Par := N;\n-      while Present (Par) loop\n-         if Nkind (Par) in N_Entry_Call_Statement\n-                         | N_Function_Call\n-                         | N_Procedure_Call_Statement\n-         then\n-            return True;\n-\n-         --  Prevent the search from going too far\n-\n-         elsif Is_Body_Or_Package_Declaration (Par) then\n-            exit;\n-         end if;\n-\n-         Par := Parent (Par);\n-      end loop;\n-\n-      return False;\n-   end Within_Subprogram_Call;\n-\n    ----------------\n    -- Wrong_Type --\n    ----------------"}, {"sha": "b8ad3820185dcc4a114d457d4e4a0e0bb235dcf7", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07b7dc09b21d1a2f000f2861a87b017b764b38b4/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07b7dc09b21d1a2f000f2861a87b017b764b38b4/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=07b7dc09b21d1a2f000f2861a87b017b764b38b4", "patch": "@@ -2117,11 +2117,16 @@ package Sem_Util is\n    --  conversions and hence variables.\n \n    function Is_OK_Volatile_Context\n-     (Context : Node_Id;\n-      Obj_Ref : Node_Id) return Boolean;\n+     (Context       : Node_Id;\n+      Obj_Ref       : Node_Id;\n+      Check_Actuals : Boolean) return Boolean;\n    --  Determine whether node Context denotes a \"non-interfering context\" (as\n    --  defined in SPARK RM 7.1.3(10)) where volatile reference Obj_Ref can\n-   --  safely reside.\n+   --  safely reside. When examining references that might be located within\n+   --  actual parameters of a subprogram call that has not been resolved yet,\n+   --  Check_Actuals should be False; such references will be assumed to be\n+   --  legal. They will need to be checked again after subprogram call has\n+   --  been resolved.\n \n    function Is_Package_Contract_Annotation (Item : Node_Id) return Boolean;\n    --  Determine whether aspect specification or pragma Item is one of the\n@@ -3285,10 +3290,6 @@ package Sem_Util is\n    function Within_Scope (E : Entity_Id; S : Entity_Id) return Boolean;\n    --  Returns True if entity E is declared within scope S\n \n-   function Within_Subprogram_Call (N : Node_Id) return Boolean;\n-   --  Determine whether arbitrary node N appears in an entry, function, or\n-   --  procedure call.\n-\n    procedure Wrong_Type (Expr : Node_Id; Expected_Type : Entity_Id);\n    --  Output error message for incorrectly typed expression. Expr is the node\n    --  for the incorrectly typed construct (Etype (Expr) is the type found),"}]}