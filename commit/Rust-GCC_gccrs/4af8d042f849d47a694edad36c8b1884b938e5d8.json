{"sha": "4af8d042f849d47a694edad36c8b1884b938e5d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFmOGQwNDJmODQ5ZDQ3YTY5NGVkYWQzNmM4YjE4ODRiOTM4ZTVkOA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-02-04T18:34:30Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2013-02-04T18:34:30Z"}, "message": "re PR fortran/54107 ([F03] Memory hog with abstract interface)\n\nfortran/\n\tPR fortran/54107\n\tPR fortran/54195\n\t* gfortran.h (struct gfc_symbol): New field 'resolved'.\n\t* resolve.c (resolve_fl_var_and_proc): Don't skip result symbols.\n\t(resolve_symbol): Skip duplicate calls.  Don't check the current\n\tnamespace.\n\ntestsuite/\n\tPR fortran/54107\n\t* gfortran.dg/recursive_interface_1.f90: New test.\n\nFrom-SVN: r195729", "tree": {"sha": "99142281f89b91c3918aa3146078166701eb0c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/99142281f89b91c3918aa3146078166701eb0c9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4af8d042f849d47a694edad36c8b1884b938e5d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af8d042f849d47a694edad36c8b1884b938e5d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4af8d042f849d47a694edad36c8b1884b938e5d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4af8d042f849d47a694edad36c8b1884b938e5d8/comments", "author": null, "committer": null, "parents": [{"sha": "7ac3af38365579c83426d3d6ddb6c62884d9f5d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac3af38365579c83426d3d6ddb6c62884d9f5d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac3af38365579c83426d3d6ddb6c62884d9f5d1"}], "stats": {"total": 53, "additions": 44, "deletions": 9}, "files": [{"sha": "bde2d1c6f3b413bef44f04f5fb111dfd8b9bbe0f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4af8d042f849d47a694edad36c8b1884b938e5d8", "patch": "@@ -1,3 +1,12 @@\n+2013-02-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54107\n+\tPR fortran/54195\n+\t* gfortran.h (struct gfc_symbol): New field 'resolved'.\n+\t* resolve.c (resolve_fl_var_and_proc): Don't skip result symbols.\n+\t(resolve_symbol): Skip duplicate calls.  Don't check the current\n+\tnamespace.\n+\n 2013-02-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/50627\n@@ -7,7 +16,7 @@\n \t* parse.c (parse_module):  Do not put namespace into\n \tgsymbol on error.\n \n-2012-01-30  Tobias Burnus  <burnus@net-b.de>\n+2013-01-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/56138\n \t* trans-decl.c (gfc_trans_deferred_vars): Fix deferred-length\n@@ -214,7 +223,7 @@\n \tfinalizer_insert_packed_call, generate_finalization_wrapper):\n \tClean up by using gfc_build_intrinsic_call.\n \n-2012-01-07  Tobias Burnus  <burnus@net-b.de>\n+2013-01-07  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/55763\n \t* resolve.c (resolve_select_type): Reject intrinsic types for"}, {"sha": "3b4b4738f204a980219f9fb9dda612746111ae0a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=4af8d042f849d47a694edad36c8b1884b938e5d8", "patch": "@@ -1248,6 +1248,9 @@ typedef struct gfc_symbol\n   unsigned equiv_built:1;\n   /* Set if this variable is used as an index name in a FORALL.  */\n   unsigned forall_index:1;\n+  /* Used to avoid multiple resolutions of a single symbol.  */\n+  unsigned resolved:1;\n+\n   int refs;\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n "}, {"sha": "5083a5d04ddc401d601ef50e0e0964ddd4a6ab5a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=4af8d042f849d47a694edad36c8b1884b938e5d8", "patch": "@@ -11051,11 +11051,6 @@ resolve_fl_var_and_proc (gfc_symbol *sym, int mp_flag)\n {\n   gfc_array_spec *as;\n \n-  /* Avoid double diagnostics for function result symbols.  */\n-  if ((sym->result || sym->attr.result) && !sym->attr.dummy\n-      && (sym->ns != gfc_current_ns))\n-    return SUCCESS;\n-\n   if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n     as = CLASS_DATA (sym)->as;\n   else\n@@ -13170,6 +13165,10 @@ resolve_symbol (gfc_symbol *sym)\n   gfc_array_spec *as;\n   bool saved_specification_expr;\n \n+  if (sym->resolved)\n+    return;\n+  sym->resolved = 1;\n+\n   if (sym->attr.artificial)\n     return;\n \n@@ -13779,7 +13778,6 @@ resolve_symbol (gfc_symbol *sym)\n      described in 14.7.5, to those variables that have not already\n      been assigned one.  */\n   if (sym->ts.type == BT_DERIVED\n-      && sym->ns == gfc_current_ns\n       && !sym->value\n       && !sym->attr.allocatable\n       && !sym->attr.alloc_comp)"}, {"sha": "8f407555dcbc632beadc4c7f776269cd73bd1519", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4af8d042f849d47a694edad36c8b1884b938e5d8", "patch": "@@ -1,3 +1,8 @@\n+2013-02-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/54107\n+\t* gfortran.dg/recursive_interface_1.f90: New test.\n+\n 2013-02-04  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/56168\n@@ -97,7 +102,7 @@\n \t* lib/target-supports-dg.exp (dg-process-target): Use expr to\n \tevaluate the end index in string range.\n \n-2012-01-30  Tobias Burnus  <burnus@net-b.de>\n+2013-01-30  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/56138\n \t* gfortran.dg/allocatable_function_6.f90: New."}, {"sha": "61db0c110246dc6cc29a0b7e4c41e3ee369c5346", "filename": "gcc/testsuite/gfortran.dg/recursive_interface_1.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_interface_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4af8d042f849d47a694edad36c8b1884b938e5d8/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_interface_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frecursive_interface_1.f90?ref=4af8d042f849d47a694edad36c8b1884b938e5d8", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+!\n+! PR fortran/54107\n+! The compiler used to ICE on recursive interfaces.\n+\n+module m\n+ contains\n+  function foo() result(r1)\n+    procedure(foo), pointer :: r1 \n+  end function foo\n+\n+  function bar() result(r2)\n+    procedure(baz), pointer :: r2\n+  end function bar\n+\n+  function baz() result(r3)\n+    procedure(bar), pointer :: r3\n+  end function baz\n+end module m\n+"}]}