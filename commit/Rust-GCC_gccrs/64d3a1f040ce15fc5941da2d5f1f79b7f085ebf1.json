{"sha": "64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRkM2ExZjA0MGNlMTVmYzU5NDFkYTJkNWYxZjc5YjdmMDg1ZWJmMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-15T08:35:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-15T08:35:15Z"}, "message": "genmatch.c (parser::peek, [...]): Add argument to tell how many tokens to peek ahead (default 1).\n\n2015-07-15  Richard Biener  <rguenther@suse.de>\n\n\t* genmatch.c (parser::peek, parser::peek_ident): Add argument\n\tto tell how many tokens to peek ahead (default 1).\n\t(parser::eat_token, parser::eat_ident): Return token consumed.\n\t(parser::parse_result): Parse new switch statement.\n\t* match.pd: Use case statements where appropriate.\n\nFrom-SVN: r225809", "tree": {"sha": "507b45542db33a685cd0956de8a295ab1a81916a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/507b45542db33a685cd0956de8a295ab1a81916a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a16bca311ae96780b64f3652538e9b22ccee54e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a16bca311ae96780b64f3652538e9b22ccee54e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a16bca311ae96780b64f3652538e9b22ccee54e6"}], "stats": {"total": 452, "additions": 260, "deletions": 192}, "files": [{"sha": "44fa51a36169d913e8c56ec4ae794d40dc4c2989", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "patch": "@@ -1,3 +1,11 @@\n+2015-07-15  Richard Biener  <rguenther@suse.de>\n+\n+\t* genmatch.c (parser::peek, parser::peek_ident): Add argument\n+\tto tell how many tokens to peek ahead (default 1).\n+\t(parser::eat_token, parser::eat_ident): Return token consumed.\n+\t(parser::parse_result): Parse new switch statement.\n+\t* match.pd: Use case statements where appropriate.\n+\n 2015-07-15  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR rtl-optimization/58066"}, {"sha": "1434719a88ed023047e5180d4ce3e60459938081", "filename": "gcc/genmatch.c", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "patch": "@@ -3014,13 +3014,13 @@ class parser\n \n private:\n   const cpp_token *next ();\n-  const cpp_token *peek ();\n-  const cpp_token *peek_ident (const char * = NULL);\n+  const cpp_token *peek (unsigned = 1);\n+  const cpp_token *peek_ident (const char * = NULL, unsigned = 1);\n   const cpp_token *expect (enum cpp_ttype);\n-  void eat_token (enum cpp_ttype);\n+  const cpp_token *eat_token (enum cpp_ttype);\n   const char *get_string ();\n   const char *get_ident ();\n-  void eat_ident (const char *);\n+  const cpp_token *eat_ident (const char *);\n   const char *get_number ();\n \n   id_base *parse_operation ();\n@@ -3078,16 +3078,17 @@ parser::next ()\n /* Peek at the next non-whitespace token from R.  */\n \n const cpp_token *\n-parser::peek ()\n+parser::peek (unsigned num)\n {\n   const cpp_token *token;\n   unsigned i = 0;\n   do\n     {\n       token = cpp_peek_token (r, i++);\n     }\n-  while (token->type == CPP_PADDING\n-\t && token->type != CPP_EOF);\n+  while ((token->type == CPP_PADDING\n+\t  && token->type != CPP_EOF)\n+\t || (--num > 0));\n   /* If we peek at EOF this is a fatal error as it leaves the\n      cpp_reader in unusable state.  Assume we really wanted a\n      token and thus this EOF is unexpected.  */\n@@ -3100,9 +3101,9 @@ parser::peek ()\n    token is not an identifier or equal to ID if supplied).  */\n \n const cpp_token *\n-parser::peek_ident (const char *id)\n+parser::peek_ident (const char *id, unsigned num)\n {\n-  const cpp_token *token = peek ();\n+  const cpp_token *token = peek (num);\n   if (token->type != CPP_NAME)\n     return 0;\n \n@@ -3131,10 +3132,10 @@ parser::expect (enum cpp_ttype tk)\n \n /* Consume the next token from R and assert it is of type TK.  */\n \n-void\n+const cpp_token *\n parser::eat_token (enum cpp_ttype tk)\n {\n-  expect (tk);\n+  return expect (tk);\n }\n \n /* Read the next token from R and assert it is of type CPP_STRING and\n@@ -3159,13 +3160,14 @@ parser::get_ident ()\n \n /* Eat an identifier token with value S from R.  */\n \n-void\n+const cpp_token *\n parser::eat_ident (const char *s)\n {\n   const cpp_token *token = peek ();\n   const char *t = get_ident ();\n   if (strcmp (s, t) != 0)\n     fatal_at (token, \"expected '%s' got '%s'\\n\", s, t);\n+  return token;\n }\n \n /* Read the next token from R and assert it is of type CPP_NUMBER and\n@@ -3557,6 +3559,58 @@ parser::parse_result (operand *result, predicate_id *matcher)\n       eat_token (CPP_CLOSE_PAREN);\n       return withe;\n     }\n+  else if (peek_ident (\"switch\"))\n+    {\n+      token = eat_ident (\"switch\");\n+      eat_token (CPP_OPEN_PAREN);\n+      eat_ident (\"if\");\n+      if_expr *ife = new if_expr ();\n+      operand *res = ife;\n+      ife->cond = parse_c_expr (CPP_OPEN_PAREN);\n+      if (peek ()->type == CPP_OPEN_PAREN)\n+\tife->trueexpr = parse_result (result, matcher);\n+      else\n+\tife->trueexpr = parse_op ();\n+      eat_token (CPP_CLOSE_PAREN);\n+      if (peek ()->type != CPP_OPEN_PAREN\n+\t  || !peek_ident (\"if\", 2))\n+\tfatal_at (token, \"switch can be implemented with a single if\");\n+      while  (peek ()->type != CPP_CLOSE_PAREN)\n+\t{\n+\t  if (peek ()->type == CPP_OPEN_PAREN)\n+\t    {\n+\t      if (peek_ident (\"if\", 2))\n+\t\t{\n+\t\t  eat_token (CPP_OPEN_PAREN);\n+\t\t  eat_ident (\"if\");\n+\t\t  ife->falseexpr = new if_expr ();\n+\t\t  ife = as_a <if_expr *> (ife->falseexpr);\n+\t\t  ife->cond = parse_c_expr (CPP_OPEN_PAREN);\n+\t\t  if (peek ()->type == CPP_OPEN_PAREN)\n+\t\t    ife->trueexpr = parse_result (result, matcher);\n+\t\t  else\n+\t\t    ife->trueexpr = parse_op ();\n+\t\t  eat_token (CPP_CLOSE_PAREN);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* switch default clause */\n+\t\t  ife->falseexpr = parse_result (result, matcher);\n+\t\t  eat_token (CPP_CLOSE_PAREN);\n+\t\t  return res;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* switch default clause */\n+\t      ife->falseexpr = parse_op ();\n+\t      eat_token (CPP_CLOSE_PAREN);\n+\t      return res;\n+\t    }\n+\t}\n+      eat_token (CPP_CLOSE_PAREN);\n+      return res;\n+    }\n   else\n     {\n       operand *op = result;"}, {"sha": "8bedb235788882a11dc8884c759ae548e0e9b7b2", "filename": "gcc/match.pd", "status": "modified", "additions": 186, "deletions": 180, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=64d3a1f040ce15fc5941da2d5f1f79b7f085ebf1", "patch": "@@ -1107,43 +1107,44 @@ along with GCC; see the file COPYING3.  If not see\n       unsigned int final_prec = TYPE_PRECISION (type);\n       int final_unsignedp = TYPE_UNSIGNED (type);\n     }\n-   /* In addition to the cases of two conversions in a row\n-      handled below, if we are converting something to its own\n-      type via an object of identical or wider precision, neither\n-      conversion is needed.  */\n-   (if (((GIMPLE && useless_type_conversion_p (type, inside_type))\n-\t || (GENERIC\n-\t     && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (inside_type)))\n-\t&& (((inter_int || inter_ptr) && final_int)\n-\t    || (inter_float && final_float))\n-\t&& inter_prec >= final_prec)\n-    (ocvt @0)\n-\n-   /* Likewise, if the intermediate and initial types are either both\n-      float or both integer, we don't need the middle conversion if the\n-      former is wider than the latter and doesn't change the signedness\n-      (for integers).  Avoid this if the final type is a pointer since\n-      then we sometimes need the middle conversion.  Likewise if the\n-      final type has a precision not equal to the size of its mode.  */\n-   (if (((inter_int && inside_int) || (inter_float && inside_float))\n-\t&& (final_int || final_float)\n-\t&& inter_prec >= inside_prec\n-\t&& (inter_float || inter_unsignedp == inside_unsignedp)\n-\t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t      && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n-    (ocvt @0)\n-\n-   /* If we have a sign-extension of a zero-extended value, we can\n-      replace that by a single zero-extension.  Likewise if the\n-      final conversion does not change precision we can drop the\n-      intermediate conversion.  */\n-   (if (inside_int && inter_int && final_int\n-\t&& ((inside_prec < inter_prec && inter_prec < final_prec\n-\t     && inside_unsignedp && !inter_unsignedp)\n-\t    || final_prec == inter_prec))\n-    (ocvt @0)\n-\n-   /* Two conversions in a row are not needed unless:\n+   (switch\n+    /* In addition to the cases of two conversions in a row\n+       handled below, if we are converting something to its own\n+       type via an object of identical or wider precision, neither\n+       conversion is needed.  */\n+    (if (((GIMPLE && useless_type_conversion_p (type, inside_type))\n+\t  || (GENERIC\n+\t      && TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (inside_type)))\n+\t && (((inter_int || inter_ptr) && final_int)\n+\t     || (inter_float && final_float))\n+\t && inter_prec >= final_prec)\n+     (ocvt @0))\n+\n+    /* Likewise, if the intermediate and initial types are either both\n+       float or both integer, we don't need the middle conversion if the\n+       former is wider than the latter and doesn't change the signedness\n+       (for integers).  Avoid this if the final type is a pointer since\n+       then we sometimes need the middle conversion.  Likewise if the\n+       final type has a precision not equal to the size of its mode.  */\n+    (if (((inter_int && inside_int) || (inter_float && inside_float))\n+\t && (final_int || final_float)\n+\t && inter_prec >= inside_prec\n+\t && (inter_float || inter_unsignedp == inside_unsignedp)\n+\t && ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n+\t       && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n+     (ocvt @0))\n+\n+    /* If we have a sign-extension of a zero-extended value, we can\n+       replace that by a single zero-extension.  Likewise if the\n+       final conversion does not change precision we can drop the\n+       intermediate conversion.  */\n+    (if (inside_int && inter_int && final_int\n+\t && ((inside_prec < inter_prec && inter_prec < final_prec\n+\t      && inside_unsignedp && !inter_unsignedp)\n+\t     || final_prec == inter_prec))\n+     (ocvt @0))\n+\n+    /* Two conversions in a row are not needed unless:\n \t- some conversion is floating-point (overstrict for now), or\n \t- some conversion is a vector (overstrict for now), or\n \t- the intermediate type is narrower than both initial and\n@@ -1154,39 +1155,39 @@ along with GCC; see the file COPYING3.  If not see\n \t  intermediate and final types differ, or\n \t- the final type is a pointer type and the precisions of the\n \t  initial and intermediate types differ.  */\n-   (if (! inside_float && ! inter_float && ! final_float\n-\t&& ! inside_vec && ! inter_vec && ! final_vec\n-\t&& (inter_prec >= inside_prec || inter_prec >= final_prec)\n-\t&& ! (inside_int && inter_int\n-\t      && inter_unsignedp != inside_unsignedp\n-\t      && inter_prec < final_prec)\n-\t&& ((inter_unsignedp && inter_prec > inside_prec)\n-\t    == (final_unsignedp && final_prec > inter_prec))\n-\t&& ! (inside_ptr && inter_prec != final_prec)\n-\t&& ! (final_ptr && inside_prec != inter_prec)\n-\t&& ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n-\t      && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n-    (ocvt @0)\n-\n-   /* A truncation to an unsigned type (a zero-extension) should be\n-      canonicalized as bitwise and of a mask.  */\n-   (if (final_int && inter_int && inside_int\n-\t&& final_prec == inside_prec\n-\t&& final_prec > inter_prec\n-\t&& inter_unsignedp)\n-    (convert (bit_and @0 { wide_int_to_tree\n-\t                     (inside_type,\n-\t\t\t      wi::mask (inter_prec, false,\n-\t\t\t\t\tTYPE_PRECISION (inside_type))); }))\n-\n-   /* If we are converting an integer to a floating-point that can\n-      represent it exactly and back to an integer, we can skip the\n-      floating-point conversion.  */\n-   (if (GIMPLE /* PR66211 */\n-\t&& inside_int && inter_float && final_int &&\n-\t(unsigned) significand_size (TYPE_MODE (inter_type))\n-\t>= inside_prec - !inside_unsignedp)\n-    (convert @0)))))))))))\n+    (if (! inside_float && ! inter_float && ! final_float\n+\t && ! inside_vec && ! inter_vec && ! final_vec\n+\t && (inter_prec >= inside_prec || inter_prec >= final_prec)\n+\t && ! (inside_int && inter_int\n+\t       && inter_unsignedp != inside_unsignedp\n+\t       && inter_prec < final_prec)\n+\t && ((inter_unsignedp && inter_prec > inside_prec)\n+\t     == (final_unsignedp && final_prec > inter_prec))\n+\t && ! (inside_ptr && inter_prec != final_prec)\n+\t && ! (final_ptr && inside_prec != inter_prec)\n+\t && ! (final_prec != GET_MODE_PRECISION (TYPE_MODE (type))\n+\t       && TYPE_MODE (type) == TYPE_MODE (inter_type)))\n+     (ocvt @0))\n+\n+    /* A truncation to an unsigned type (a zero-extension) should be\n+       canonicalized as bitwise and of a mask.  */\n+    (if (final_int && inter_int && inside_int\n+\t && final_prec == inside_prec\n+\t && final_prec > inter_prec\n+\t && inter_unsignedp)\n+     (convert (bit_and @0 { wide_int_to_tree\n+\t                      (inside_type,\n+\t\t\t       wi::mask (inter_prec, false,\n+\t\t\t\t\t TYPE_PRECISION (inside_type))); })))\n+\n+    /* If we are converting an integer to a floating-point that can\n+       represent it exactly and back to an integer, we can skip the\n+       floating-point conversion.  */\n+    (if (GIMPLE /* PR66211 */\n+\t && inside_int && inter_float && final_int &&\n+\t (unsigned) significand_size (TYPE_MODE (inter_type))\n+\t >= inside_prec - !inside_unsignedp)\n+     (convert @0)))))))\n \n /* If we have a narrowing conversion to an integral type that is fed by a\n    BIT_AND_EXPR, we might be able to remove the BIT_AND_EXPR if it merely\n@@ -1463,58 +1464,60 @@ along with GCC; see the file COPYING3.  If not see\n  (simplify\n   (cmp @0 REAL_CST@1)\n   /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n-  /* a CMP (-0) -> a CMP 0  */\n-  (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@1)))\n-   (cmp @0 { build_real (TREE_TYPE (@1), dconst0); })\n-  /* x != NaN is always true, other ops are always false.  */\n-  (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))\n-       && ! HONOR_SNANS (@1))\n-   { constant_boolean_node (cmp == NE_EXPR, type); }\n-  /* Fold comparisons against infinity.  */\n-  (if (REAL_VALUE_ISINF (TREE_REAL_CST (@1))\n-       && MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (@1))))\n-   (with\n-    {\n-      REAL_VALUE_TYPE max;\n-      enum tree_code code = cmp;\n-      bool neg = REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1));\n-      if (neg)\n-        code = swap_tree_comparison (code);\n-    }\n-    /* x > +Inf is always false, if with ignore sNANs.  */\n-    (if (code == GT_EXPR\n-    \t && ! HONOR_SNANS (@0))\n-     { constant_boolean_node (false, type); }\n-    (if (code == LE_EXPR)\n-     /* x <= +Inf is always true, if we don't case about NaNs.  */\n-     (if (! HONOR_NANS (@0))\n-      { constant_boolean_node (true, type); }\n-      /* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n-      (eq @0 @0))\n-    /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n-    (if (code == EQ_EXPR || code == GE_EXPR)\n-     (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n-      (if (neg)\n-       (lt @0 { build_real (TREE_TYPE (@0), max); })\n-       (gt @0 { build_real (TREE_TYPE (@0), max); })))\n-    /* x < +Inf is always equal to x <= DBL_MAX.  */\n-    (if (code == LT_EXPR)\n-     (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n-      (if (neg)\n-       (ge @0 { build_real (TREE_TYPE (@0), max); })\n-       (le @0 { build_real (TREE_TYPE (@0), max); })))\n-    /* x != +Inf is always equal to !(x > DBL_MAX).  */\n-    (if (code == NE_EXPR)\n-     (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n-      (if (! HONOR_NANS (@0))\n-       (if (neg)\n-        (ge @0 { build_real (TREE_TYPE (@0), max); })\n-\t(le @0 { build_real (TREE_TYPE (@0), max); }))\n-       (if (neg)\n-\t(bit_xor (lt @0 { build_real (TREE_TYPE (@0), max); })\n-\t\t\t{ build_one_cst (type); })\n-\t(bit_xor (gt @0 { build_real (TREE_TYPE (@0), max); })\n-\t\t\t{ build_one_cst (type); }))))))))))))))\n+  (switch\n+   /* a CMP (-0) -> a CMP 0  */\n+   (if (REAL_VALUE_MINUS_ZERO (TREE_REAL_CST (@1)))\n+    (cmp @0 { build_real (TREE_TYPE (@1), dconst0); }))\n+   /* x != NaN is always true, other ops are always false.  */\n+   (if (REAL_VALUE_ISNAN (TREE_REAL_CST (@1))\n+\t&& ! HONOR_SNANS (@1))\n+    { constant_boolean_node (cmp == NE_EXPR, type); })\n+   /* Fold comparisons against infinity.  */\n+   (if (REAL_VALUE_ISINF (TREE_REAL_CST (@1))\n+\t&& MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (@1))))\n+    (with\n+     {\n+       REAL_VALUE_TYPE max;\n+       enum tree_code code = cmp;\n+       bool neg = REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1));\n+       if (neg)\n+         code = swap_tree_comparison (code);\n+     }\n+     (switch\n+      /* x > +Inf is always false, if with ignore sNANs.  */\n+      (if (code == GT_EXPR\n+\t   && ! HONOR_SNANS (@0))\n+       { constant_boolean_node (false, type); })\n+      (if (code == LE_EXPR)\n+       /* x <= +Inf is always true, if we don't case about NaNs.  */\n+       (if (! HONOR_NANS (@0))\n+\t{ constant_boolean_node (true, type); }\n+\t/* x <= +Inf is the same as x == x, i.e. isfinite(x).  */\n+\t(eq @0 @0)))\n+      /* x == +Inf and x >= +Inf are always equal to x > DBL_MAX.  */\n+      (if (code == EQ_EXPR || code == GE_EXPR)\n+       (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n+\t(if (neg)\n+\t (lt @0 { build_real (TREE_TYPE (@0), max); })\n+\t (gt @0 { build_real (TREE_TYPE (@0), max); }))))\n+      /* x < +Inf is always equal to x <= DBL_MAX.  */\n+      (if (code == LT_EXPR)\n+       (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n+\t(if (neg)\n+\t (ge @0 { build_real (TREE_TYPE (@0), max); })\n+\t (le @0 { build_real (TREE_TYPE (@0), max); }))))\n+      /* x != +Inf is always equal to !(x > DBL_MAX).  */\n+      (if (code == NE_EXPR)\n+       (with { real_maxval (&max, neg, TYPE_MODE (TREE_TYPE (@0))); }\n+\t(if (! HONOR_NANS (@0))\n+\t (if (neg)\n+\t  (ge @0 { build_real (TREE_TYPE (@0), max); })\n+\t  (le @0 { build_real (TREE_TYPE (@0), max); }))\n+\t (if (neg)\n+\t  (bit_xor (lt @0 { build_real (TREE_TYPE (@0), max); })\n+\t   { build_one_cst (type); })\n+\t  (bit_xor (gt @0 { build_real (TREE_TYPE (@0), max); })\n+\t   { build_one_cst (type); }))))))))))\n \n  /* If this is a comparison of a real constant with a PLUS_EXPR\n     or a MINUS_EXPR of a real constant, we can convert it into a\n@@ -1549,65 +1552,68 @@ along with GCC; see the file COPYING3.  If not see\n   (for sq (SQRT)\n    (simplify\n     (cmp (sq @0) REAL_CST@1)\n-    (if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1)))\n-     /* sqrt(x) < y is always false, if y is negative.  */\n-     (if (cmp == EQ_EXPR || cmp == LT_EXPR || cmp == LE_EXPR)\n-      { constant_boolean_node (false, type); }\n-     /* sqrt(x) > y is always true, if y is negative and we\n-\tdon't care about NaNs, i.e. negative values of x.  */\n-     (if (cmp == NE_EXPR || !HONOR_NANS (@0))\n-      { constant_boolean_node (true, type); }\n-     /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n-     (ge @0 { build_real (TREE_TYPE (@0), dconst0); })))\n-    (if (cmp == GT_EXPR || cmp == GE_EXPR)\n-     (with\n-      {\n-       \tREAL_VALUE_TYPE c2;\n-\tREAL_ARITHMETIC (c2, MULT_EXPR, TREE_REAL_CST (@1), TREE_REAL_CST (@1));\n-\treal_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n-      }\n-      (if (REAL_VALUE_ISINF (c2))\n-       /* sqrt(x) > y is x == +Inf, when y is very large.  */\n-       (if (HONOR_INFINITIES (@0))\n-        (eq @0 { build_real (TREE_TYPE (@0), c2); })\n+    (switch\n+     (if (REAL_VALUE_NEGATIVE (TREE_REAL_CST (@1)))\n+      (switch\n+       /* sqrt(x) < y is always false, if y is negative.  */\n+       (if (cmp == EQ_EXPR || cmp == LT_EXPR || cmp == LE_EXPR)\n \t{ constant_boolean_node (false, type); })\n-       /* sqrt(x) > c is the same as x > c*c.  */\n-       (cmp @0 { build_real (TREE_TYPE (@0), c2); })))\n-    (if (cmp == LT_EXPR || cmp == LE_EXPR)\n-     (with\n-      {\n-       \tREAL_VALUE_TYPE c2;\n-\tREAL_ARITHMETIC (c2, MULT_EXPR, TREE_REAL_CST (@1), TREE_REAL_CST (@1));\n-\treal_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n-      }\n-      (if (REAL_VALUE_ISINF (c2))\n-       /* sqrt(x) < y is always true, when y is a very large\n-\t  value and we don't care about NaNs or Infinities.  */\n-       (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))\n-        { constant_boolean_node (true, type); }\n-       /* sqrt(x) < y is x != +Inf when y is very large and we\n-\t  don't care about NaNs.  */\n-       (if (! HONOR_NANS (@0))\n-        (ne @0 { build_real (TREE_TYPE (@0), c2); })\n-       /* sqrt(x) < y is x >= 0 when y is very large and we\n-\t  don't care about Infinities.  */\n-       (if (! HONOR_INFINITIES (@0))\n-        (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-       /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n-       (if (GENERIC)\n-        (truth_andif\n-\t (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-\t (ne @0 { build_real (TREE_TYPE (@0), c2); }))))))\n-      /* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n-      (if (! REAL_VALUE_ISINF (c2)\n-           && ! HONOR_NANS (@0))\n-       (cmp @0 { build_real (TREE_TYPE (@0), c2); })\n-      /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n-      (if (! REAL_VALUE_ISINF (c2)\n-           && GENERIC)\n-       (truth_andif\n-        (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n-\t(cmp @0 { build_real (TREE_TYPE (@0), c2); })))))))))))))\n+       /* sqrt(x) > y is always true, if y is negative and we\n+\t  don't care about NaNs, i.e. negative values of x.  */\n+       (if (cmp == NE_EXPR || !HONOR_NANS (@0))\n+\t{ constant_boolean_node (true, type); })\n+       /* sqrt(x) > y is the same as x >= 0, if y is negative.  */\n+       (ge @0 { build_real (TREE_TYPE (@0), dconst0); })))\n+     (if (cmp == GT_EXPR || cmp == GE_EXPR)\n+      (with\n+       {\n+         REAL_VALUE_TYPE c2;\n+\t REAL_ARITHMETIC (c2, MULT_EXPR,\n+\t\t\t  TREE_REAL_CST (@1), TREE_REAL_CST (@1));\n+\t real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n+       }\n+       (if (REAL_VALUE_ISINF (c2))\n+\t/* sqrt(x) > y is x == +Inf, when y is very large.  */\n+\t(if (HONOR_INFINITIES (@0))\n+\t (eq @0 { build_real (TREE_TYPE (@0), c2); })\n+\t { constant_boolean_node (false, type); })\n+\t/* sqrt(x) > c is the same as x > c*c.  */\n+\t(cmp @0 { build_real (TREE_TYPE (@0), c2); }))))\n+     (if (cmp == LT_EXPR || cmp == LE_EXPR)\n+      (with\n+       {\n+       \t REAL_VALUE_TYPE c2;\n+\t REAL_ARITHMETIC (c2, MULT_EXPR,\n+\t\t\t  TREE_REAL_CST (@1), TREE_REAL_CST (@1));\n+\t real_convert (&c2, TYPE_MODE (TREE_TYPE (@0)), &c2);\n+       }\n+       (if (REAL_VALUE_ISINF (c2))\n+        (switch\n+\t /* sqrt(x) < y is always true, when y is a very large\n+\t    value and we don't care about NaNs or Infinities.  */\n+\t (if (! HONOR_NANS (@0) && ! HONOR_INFINITIES (@0))\n+\t  { constant_boolean_node (true, type); })\n+\t /* sqrt(x) < y is x != +Inf when y is very large and we\n+\t    don't care about NaNs.  */\n+\t (if (! HONOR_NANS (@0))\n+\t  (ne @0 { build_real (TREE_TYPE (@0), c2); }))\n+\t /* sqrt(x) < y is x >= 0 when y is very large and we\n+\t    don't care about Infinities.  */\n+\t (if (! HONOR_INFINITIES (@0))\n+\t  (ge @0 { build_real (TREE_TYPE (@0), dconst0); }))\n+\t /* sqrt(x) < y is x >= 0 && x != +Inf, when y is large.  */\n+\t (if (GENERIC)\n+\t  (truth_andif\n+\t   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t   (ne @0 { build_real (TREE_TYPE (@0), c2); }))))\n+\t/* sqrt(x) < c is the same as x < c*c, if we ignore NaNs.  */\n+\t(if (! HONOR_NANS (@0))\n+\t (cmp @0 { build_real (TREE_TYPE (@0), c2); })\n+\t /* sqrt(x) < c is the same as x >= 0 && x < c*c.  */\n+\t (if (GENERIC)\n+\t  (truth_andif\n+\t   (ge @0 { build_real (TREE_TYPE (@0), dconst0); })\n+\t   (cmp @0 { build_real (TREE_TYPE (@0), c2); }))))))))))))\n \n /* Unordered tests if either argument is a NaN.  */\n (simplify"}]}