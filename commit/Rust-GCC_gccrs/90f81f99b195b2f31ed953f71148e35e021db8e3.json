{"sha": "90f81f99b195b2f31ed953f71148e35e021db8e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTBmODFmOTliMTk1YjJmMzFlZDk1M2Y3MTE0OGUzNWUwMjFkYjhlMw==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2004-04-28T23:03:31Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2004-04-28T23:03:31Z"}, "message": "rs6000.c (registers_ok_for_quad_peep): Return false if we do not have fp register.\n\n2004-04-28  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        * config/rs6000/rs6000.c (registers_ok_for_quad_peep):\n        Return false if we do not have fp register.\n        (addrs_ok_for_quad_peep): Rename to ...\n        (mems_ok_for_quad_peep): this.\n        Add check for volatile memory.\n        * config/rs6000/rs6000-protos.h (addrs_ok_for_quad_peep):\n        Rename to ...\n        (mems_ok_for_quad_peep): this.\n        * config/rs6000/rs6000.md: Change peephole's for lfq/stq\n        to peephole2's.\n        (lfq_power2): New instruction.\n        (stfq_power2): Likewise.\n\n2004-04-28  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        * gcc.dg/rs6000-power2-1.c: New test.\n        * gcc.dg/rs6000-power2-2.c: New test.\n\nFrom-SVN: r81262", "tree": {"sha": "333829961ff681e44edfcbcb53b8b69b14a89be3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/333829961ff681e44edfcbcb53b8b69b14a89be3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90f81f99b195b2f31ed953f71148e35e021db8e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90f81f99b195b2f31ed953f71148e35e021db8e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90f81f99b195b2f31ed953f71148e35e021db8e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90f81f99b195b2f31ed953f71148e35e021db8e3/comments", "author": null, "committer": null, "parents": [{"sha": "ea16c81bfa18875f220ca534485c14ebca501c5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea16c81bfa18875f220ca534485c14ebca501c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea16c81bfa18875f220ca534485c14ebca501c5d"}], "stats": {"total": 128, "additions": 110, "deletions": 18}, "files": [{"sha": "176ca3801baa96a27da64fd3374eda6126befa6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -1,3 +1,18 @@\n+2004-04-28  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* config/rs6000/rs6000.c (registers_ok_for_quad_peep):\n+\tReturn false if we do not have fp register.\n+\t(addrs_ok_for_quad_peep): Rename to ...\n+\t(mems_ok_for_quad_peep): this.\n+\tAdd check for volatile memory.\n+\t* config/rs6000/rs6000-protos.h (addrs_ok_for_quad_peep):\n+\tRename to ...\n+\t(mems_ok_for_quad_peep): this.\n+\t* config/rs6000/rs6000.md: Change peephole's for lfq/stq\n+\tto peephole2's.\n+\t(lfq_power2): New instruction.\n+\t(stfq_power2): Likewise.\n+\n 2004-04-28  Jan Hubicka  <jh@suse.cz>\n \n \tPR c/15004"}, {"sha": "d368033d7906dd2af14e148e03f9be93e2d2a2ca", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -102,7 +102,7 @@ extern int includes_rshift_p (rtx, rtx);\n extern int includes_rldic_lshift_p (rtx, rtx);\n extern int includes_rldicr_lshift_p (rtx, rtx);\n extern int registers_ok_for_quad_peep (rtx, rtx);\n-extern int addrs_ok_for_quad_peep (rtx, rtx);\n+extern int mems_ok_for_quad_peep (rtx, rtx);\n extern bool gpr_or_gpr_p (rtx, rtx);\n extern enum reg_class secondary_reload_class (enum reg_class,\n \t\t\t\t\t      enum machine_mode, rtx);"}, {"sha": "7195805b18e4d4a4f734a3f61ca4c150c66ce860", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -8594,17 +8594,19 @@ includes_rldicr_lshift_p (rtx shiftop, rtx andop)\n }\n \n /* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates\n-   for lfq and stfq insns.\n-\n-   Note reg1 and reg2 *must* be hard registers.  To be sure we will\n-   abort if we are passed pseudo registers.  */\n+   for lfq and stfq insns iff the registers are hard registers.   */\n \n int\n registers_ok_for_quad_peep (rtx reg1, rtx reg2)\n {\n   /* We might have been passed a SUBREG.  */\n   if (GET_CODE (reg1) != REG || GET_CODE (reg2) != REG) \n     return 0;\n+    \n+  /* We might have been passed non floating point registers.  */\n+  if (!FP_REGNO_P (REGNO (reg1))\n+      || !FP_REGNO_P (REGNO (reg2)))\n+    return 0;\n \n   return (REGNO (reg1) == REGNO (reg2) - 1);\n }\n@@ -8614,11 +8616,19 @@ registers_ok_for_quad_peep (rtx reg1, rtx reg2)\n    (addr2 == addr1 + 8).  */\n \n int\n-addrs_ok_for_quad_peep (rtx addr1, rtx addr2)\n+mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n {\n+  rtx addr1, addr2;\n   unsigned int reg1;\n   int offset1;\n \n+  /* The mems cannot be volatile.  */\n+  if (MEM_VOLATILE_P (mem1) || MEM_VOLATILE_P (mem2))\n+    return 0;\n+  \n+  addr1 = XEXP (mem1, 0);\n+  addr2 = XEXP (mem2, 0);\n+\n   /* Extract an offset (if used) from the first addr.  */\n   if (GET_CODE (addr1) == PLUS)\n     {"}, {"sha": "d93b80a8456282e0c5b2653305077fbb677b8179", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -9608,29 +9608,48 @@\n \n ;; Peephole to convert two consecutive FP loads or stores into lfq/stfq.\n \n-(define_peephole\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+(define_insn \"*lfq_power2\"\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\" \"=f\")\n+\t(match_operand:TF 1 \"memory_operand\" \"\"))]\n+  \"TARGET_POWER2\n+   && TARGET_HARD_FLOAT && TARGET_FPRS\"\n+   \"lfq%U1%X1 %0,%1\")\n+\n+(define_peephole2\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 1 \"memory_operand\" \"\"))\n-   (set (match_operand:DF 2 \"gpc_reg_operand\" \"=f\")\n+   (set (match_operand:DF 2 \"gpc_reg_operand\" \"\")\n \t(match_operand:DF 3 \"memory_operand\" \"\"))]\n   \"TARGET_POWER2\n    && TARGET_HARD_FLOAT && TARGET_FPRS\n    && registers_ok_for_quad_peep (operands[0], operands[2])\n-   && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n-   && addrs_ok_for_quad_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\"\n-  \"lfq%U1%X1 %0,%1\")\n+   && mems_ok_for_quad_peep (operands[1], operands[3])\"\n+  [(set (match_dup 0)\n+        (match_dup 1))]\n+  \"operands[1] = widen_memory_access (operands[1], TFmode, 0);\n+   operands[0] = gen_rtx_REG (TFmode, REGNO (operands[0]));\")\n \n-(define_peephole\n+(define_insn \"*stfq_power2\"\n+  [(set (match_operand:TF 0 \"memory_operand\" \"\")\n+\t(match_operand:TF 1 \"gpc_reg_operand\" \"f\"))]\n+  \"TARGET_POWER2\n+   && TARGET_HARD_FLOAT && TARGET_FPRS\"\n+  \"stfq%U0%X0 %1,%0\")\n+\n+\n+(define_peephole2\n   [(set (match_operand:DF 0 \"memory_operand\" \"\")\n-\t(match_operand:DF 1 \"gpc_reg_operand\" \"f\"))\n+\t(match_operand:DF 1 \"gpc_reg_operand\" \"\"))\n    (set (match_operand:DF 2 \"memory_operand\" \"\")\n-\t(match_operand:DF 3 \"gpc_reg_operand\" \"f\"))]\n+\t(match_operand:DF 3 \"gpc_reg_operand\" \"\"))]\n   \"TARGET_POWER2\n    && TARGET_HARD_FLOAT && TARGET_FPRS\n    && registers_ok_for_quad_peep (operands[1], operands[3])\n-   && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n-   && addrs_ok_for_quad_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n-  \"stfq%U0%X0 %1,%0\")\n+   && mems_ok_for_quad_peep (operands[0], operands[2])\"\n+  [(set (match_dup 0)\n+\t(match_dup 1))]\n+  \"operands[0] = widen_memory_access (operands[0], TFmode, 0);\n+   operands[1] = gen_rtx_REG (TFmode, REGNO (operands[1]));\")\n \f\n ;; TLS support.\n "}, {"sha": "87f7a59535b7d7ee524f8a17e06eb12ceea6924a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -1,3 +1,8 @@\n+2004-04-28  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* gcc.dg/rs6000-power2-1.c: New test.\n+\t* gcc.dg/rs6000-power2-2.c: New test.\n+\n 2004-04-28  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/unused-6.c: New test."}, {"sha": "7f22b98c64e0e961382cca45d8aebe27da14ea20", "filename": "gcc/testsuite/gcc.dg/rs6000-power2-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Ftestsuite%2Fgcc.dg%2Frs6000-power2-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Ftestsuite%2Fgcc.dg%2Frs6000-power2-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frs6000-power2-1.c?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do assemble { target powerpc-*-* rs6000-*-* }  } */\n+/* { dg-options \"-O -mpower2 -fno-schedule-insns -w\" } */\n+/* This used to ICE as the peephole was not checking to see\n+   if the register is a floating point one (I think this cannot\n+   happen in real life except in this example).  */\n+\n+register double t1 __asm__(\"r14\");\n+register double t2 __asm__(\"r15\");\n+register double t3 __asm__(\"r16\"), t4 __asm__(\"r17\");\n+void t(double *a, double *b)\n+{\n+        t1 = a[-1];\n+        t2 = a[0];\n+        t3 = a[1];\n+        t4 = a[2];\n+        b[-1] = t1;\n+        b[0] = t2;\n+        b[1] = t3;\n+        b[2] = t4;\n+}\n+"}, {"sha": "dda48526c24567417f65d317da43fd55ec08842d", "filename": "gcc/testsuite/gcc.dg/rs6000-power2-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Ftestsuite%2Fgcc.dg%2Frs6000-power2-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90f81f99b195b2f31ed953f71148e35e021db8e3/gcc%2Ftestsuite%2Fgcc.dg%2Frs6000-power2-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Frs6000-power2-2.c?ref=90f81f99b195b2f31ed953f71148e35e021db8e3", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do assemble { target powerpc-*-* rs6000-*-* }  } */\n+/* { dg-options \"-O -mpower2 -fno-schedule-insns\" } */\n+/* { dg-final { scan-assembler-not \"lfd\" } } */\n+/* { dg-final { scan-assembler-not \"sfd\" } } */\n+/* { dg-final { scan-assembler \"lfq\" } } */\n+/* { dg-final { scan-assembler \"sfq\" } } */\n+\n+register double t1 __asm__(\"f0\");\n+register double t2 __asm__(\"f1\");\n+register double t3 __asm__(\"f2\"), t4 __asm__(\"f3\");\n+void t(double *a, double *b)\n+{\n+        t1 = a[-1];\n+        t2 = a[0];\n+        t3 = a[1];\n+        t4 = a[2];\n+        b[-1] = t1;\n+        b[0] = t2;\n+        b[1] = t3;\n+        b[2] = t4;\n+}\n+"}]}