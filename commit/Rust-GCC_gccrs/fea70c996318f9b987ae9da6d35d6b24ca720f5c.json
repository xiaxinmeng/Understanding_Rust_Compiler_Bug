{"sha": "fea70c996318f9b987ae9da6d35d6b24ca720f5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVhNzBjOTk2MzE4ZjliOTg3YWU5ZGE2ZDM1ZDZiMjRjYTcyMGY1Yw==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2015-05-23T23:02:52Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2015-05-23T23:02:52Z"}, "message": "re PR fortran/44054 (Handle -Werror, -Werror=, -fdiagnostics-show-option, !GCC$ diagnostic (pragmas) and color)\n\ngcc/fortran/ChangeLog:\n\n2015-05-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR fortran/44054\n\t* gfortran.h (struct gfc_error_buf): Rename as\n\tgfc_error_buffer. Move closer to push, pop and free\n\tmethods. Reimplement using an output_buffer.\n\t* error.c (errors, warnings, warning_buffer, cur_error_buffer):\n\tDelete everywhere in this file.\n\t(error_char): Delete all contents.\n\t(gfc_increment_error_count): Delete.\n\t(gfc_error_now): Update comment. Set error_buffer.flag.\n\t(gfc_warning_check): Do not handle warning_buffer.\n\t(gfc_error_1): Delete.\n\t(gfc_error_now_1): Delete.\n\t(gfc_error_check): Simplify.\n\t(gfc_move_error_buffer_from_to): Renamed from\n\tgfc_move_output_buffer_from_to.\n\t(gfc_push_error): Handle only gfc_error_buffer.\n\t(gfc_pop_error): Likewise.\n\t(gfc_free_error): Likewise.\n\t(gfc_get_errors): Remove warnings and errors.\n\t(gfc_diagnostics_init): Use static error_buffer.\n\t(gfc_error_1,gfc_error_now_1): Delete declarations.\n\t* symbol.c, decl.c, trans-common.c, data.c, expr.c, expr.c,\n\tfrontend-passes.c, resolve.c, match.c, parse.c: Replace\n\tgfc_error_1 with gfc_error and gfc_error_now_1 with gfc_error_1\n\teverywhere.\n\t* f95-lang.c (gfc_be_parse_file): Do not update errorcount and\n\twarningcount here.\n\t* primary.c (match_complex_constant): Replace gfc_error_buf and\n\toutput_buffer with gfc_error_buffer.\n\nFrom-SVN: r223614", "tree": {"sha": "1b79430e59e975a3a6876ac5c5ead97b2768f624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b79430e59e975a3a6876ac5c5ead97b2768f624"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fea70c996318f9b987ae9da6d35d6b24ca720f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea70c996318f9b987ae9da6d35d6b24ca720f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fea70c996318f9b987ae9da6d35d6b24ca720f5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fea70c996318f9b987ae9da6d35d6b24ca720f5c/comments", "author": null, "committer": null, "parents": [{"sha": "84a3423b97784ba86bcb37efb39fd528de3671cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84a3423b97784ba86bcb37efb39fd528de3671cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84a3423b97784ba86bcb37efb39fd528de3671cb"}], "stats": {"total": 574, "additions": 211, "deletions": 363}, "files": [{"sha": "420a99d77884be595a04daa5ca68295799b80154", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -1,3 +1,35 @@\n+2015-05-24  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR fortran/44054\n+\t* gfortran.h (struct gfc_error_buf): Rename as\n+\tgfc_error_buffer. Move closer to push, pop and free\n+\tmethods. Reimplement using an output_buffer.\n+\t* error.c (errors, warnings, warning_buffer, cur_error_buffer):\n+\tDelete everywhere in this file.\n+\t(error_char): Delete all contents.\n+\t(gfc_increment_error_count): Delete.\n+\t(gfc_error_now): Update comment. Set error_buffer.flag.\n+\t(gfc_warning_check): Do not handle warning_buffer.\n+\t(gfc_error_1): Delete.\n+\t(gfc_error_now_1): Delete.\n+\t(gfc_error_check): Simplify.\n+\t(gfc_move_error_buffer_from_to): Renamed from\n+\tgfc_move_output_buffer_from_to.\n+\t(gfc_push_error): Handle only gfc_error_buffer.\n+\t(gfc_pop_error): Likewise.\n+\t(gfc_free_error): Likewise.\n+\t(gfc_get_errors): Remove warnings and errors.\n+\t(gfc_diagnostics_init): Use static error_buffer.\n+\t(gfc_error_1,gfc_error_now_1): Delete declarations.\n+\t* symbol.c, decl.c, trans-common.c, data.c, expr.c, expr.c,\n+\tfrontend-passes.c, resolve.c, match.c, parse.c: Replace\n+\tgfc_error_1 with gfc_error and gfc_error_now_1 with gfc_error_1\n+\teverywhere.\n+\t* f95-lang.c (gfc_be_parse_file): Do not update errorcount and\n+\twarningcount here.\n+\t* primary.c (match_complex_constant): Replace gfc_error_buf and\n+\toutput_buffer with gfc_error_buffer.\n+\n 2015-05-22  Jim Wilson  <jim.wilson@linaro.org>\n \n \t* Make-lang.in (check_gfortran_parallelize): Update comment."}, {"sha": "3286a58df5cf348152d6f0d72b178fe510e5ec00", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -1031,8 +1031,8 @@ gfc_check_atomic (gfc_expr *atom, int atom_no, gfc_expr *value, int val_no,\n \n   if (atom->ts.type != value->ts.type)\n     {\n-      gfc_error_1 (\"'%s' argument of '%s' intrinsic at %L shall have the same \"\n-\t\t \"type as '%s' at %L\", gfc_current_intrinsic_arg[val_no]->name,\n+      gfc_error (\"%qs argument of %qs intrinsic at %L shall have the same \"\n+\t\t \"type as %qs at %L\", gfc_current_intrinsic_arg[val_no]->name,\n \t\t gfc_current_intrinsic, &value->where,\n \t\t gfc_current_intrinsic_arg[atom_no]->name, &atom->where);\n       return false;\n@@ -1575,7 +1575,7 @@ gfc_check_co_reduce (gfc_expr *a, gfc_expr *op, gfc_expr *result_image,\n \n   if (!gfc_compare_types (&a->ts, &sym->result->ts))\n     {\n-      gfc_error_1 (\"A argument at %L has type %s but the function passed as \"\n+      gfc_error (\"A argument at %L has type %s but the function passed as \"\n \t\t \"OPERATOR at %L returns %s\",\n \t\t &a->where, gfc_typename (&a->ts), &op->where,\n \t\t gfc_typename (&sym->result->ts));\n@@ -1655,16 +1655,16 @@ gfc_check_co_reduce (gfc_expr *a, gfc_expr *op, gfc_expr *result_image,\n \t  && ((formal_size1 && actual_size != formal_size1)\n \t       || (formal_size2 && actual_size != formal_size2)))\n \t{\n-\t  gfc_error_1 (\"The character length of the A argument at %L and of the \"\n-\t\t       \"arguments of the OPERATOR at %L shall be the same\",\n+\t  gfc_error (\"The character length of the A argument at %L and of the \"\n+\t\t     \"arguments of the OPERATOR at %L shall be the same\",\n \t\t     &a->where, &op->where);\n \t  return false;\n \t}\n       if (actual_size && result_size && actual_size != result_size)\n \t{\n-\t  gfc_error_1 (\"The character length of the A argument at %L and of the \"\n-\t\t       \"function result of the OPERATOR at %L shall be the same\",\n-\t\t       &a->where, &op->where);\n+\t  gfc_error (\"The character length of the A argument at %L and of the \"\n+\t\t     \"function result of the OPERATOR at %L shall be the same\",\n+\t\t     &a->where, &op->where);\n \t  return false;\n \t}\n     }\n@@ -1680,10 +1680,10 @@ gfc_check_co_minmax (gfc_expr *a, gfc_expr *result_image, gfc_expr *stat,\n   if (a->ts.type != BT_INTEGER && a->ts.type != BT_REAL\n       && a->ts.type != BT_CHARACTER)\n     {\n-       gfc_error_1 (\"'%s' argument of '%s' intrinsic at %L shall be of type \"\n-\t\t    \"integer, real or character\",\n-\t\t    gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n-\t\t    &a->where);\n+       gfc_error (\"%qs argument of %qs intrinsic at %L shall be of type \"\n+\t\t  \"integer, real or character\",\n+\t\t  gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t  &a->where);\n        return false;\n     }\n   return check_co_collective (a, result_image, stat, errmsg, false);\n@@ -1956,7 +1956,7 @@ gfc_check_dshift (gfc_expr *i, gfc_expr *j, gfc_expr *shift)\n \n   if (i->is_boz && j->is_boz)\n     {\n-      gfc_error_1 (\"'I' at %L and 'J' at %L cannot both be BOZ literal \"\n+      gfc_error (\"%<I%> at %L and %<J%>' at %L cannot both be BOZ literal \"\n \t\t   \"constants\", &i->where, &j->where);\n       return false;\n     }\n@@ -2472,9 +2472,9 @@ gfc_check_ishftc (gfc_expr *i, gfc_expr *shift, gfc_expr *size)\n \n \t      if (i2 > i3)\n \t\t{\n-\t\t  gfc_error_1 (\"The absolute value of SHIFT at %L must be less \"\n-\t\t\t       \"than or equal to SIZE at %L\", &shift->where,\n-\t\t\t       &size->where);\n+\t\t  gfc_error (\"The absolute value of SHIFT at %L must be less \"\n+\t\t\t     \"than or equal to SIZE at %L\", &shift->where,\n+\t\t\t     &size->where);\n \t\t  return false;\n \t\t}\n \t     }"}, {"sha": "ef9101b8d55f9cc0d10369bec631f1ab9b5885fd", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -253,9 +253,9 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index,\n \n \t  if (init && expr->expr_type != EXPR_ARRAY)\n \t    {\n-\t      gfc_error_1 (\"'%s' at %L already is initialized at %L\",\n-\t\t\t   lvalue->symtree->n.sym->name, &lvalue->where,\n-\t\t\t   &init->where);\n+\t      gfc_error (\"%qs at %L already is initialized at %L\",\n+\t\t\t lvalue->symtree->n.sym->name, &lvalue->where,\n+\t\t\t &init->where);\n \t      goto abort;\n \t    }\n "}, {"sha": "e2fd670de3995e954bacc01289282a78a352bb67", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -921,17 +921,17 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n \t  && sym->attr.proc != 0\n \t  && (sym->attr.subroutine || sym->attr.function)\n \t  && sym->attr.if_source != IFSRC_UNKNOWN)\n-\tgfc_error_now_1 (\"Procedure '%s' at %C is already defined at %L\",\n-\t\t\t name, &sym->declared_at);\n+\tgfc_error_now (\"Procedure %qs at %C is already defined at %L\",\n+\t\t       name, &sym->declared_at);\n \n       /* Trap a procedure with a name the same as interface in the\n \t encompassing scope.  */\n       if (sym->attr.generic != 0\n \t  && (sym->attr.subroutine || sym->attr.function)\n \t  && !sym->attr.mod_proc)\n-\tgfc_error_now_1 (\"Name '%s' at %C is already defined\"\n-\t\t\t \" as a generic interface at %L\",\n-\t\t\t name, &sym->declared_at);\n+\tgfc_error_now (\"Name %qs at %C is already defined\"\n+\t\t       \" as a generic interface at %L\",\n+\t\t       name, &sym->declared_at);\n \n       /* Trap declarations of attributes in encompassing scope.  The\n \t signature for this is that ts.kind is set.  Legitimate\n@@ -942,9 +942,9 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n \t  && gfc_current_ns->parent != NULL\n \t  && sym->attr.access == 0\n \t  && !module_fcn_entry)\n-\tgfc_error_now_1 (\"Procedure '%s' at %C has an explicit interface \"\n-\t\t\t \"and must not have attributes declared at %L\",\n-\t\t\t name, &sym->declared_at);\n+\tgfc_error_now (\"Procedure %qs at %C has an explicit interface \"\n+\t\t       \"and must not have attributes declared at %L\",\n+\t\t       name, &sym->declared_at);\n     }\n \n   if (gfc_current_ns->parent == NULL || *result == NULL)\n@@ -2868,9 +2868,9 @@ gfc_match_decl_type_spec (gfc_typespec *ts, int implicit_flag)\n        && !(sym->attr.flavor == FL_PROCEDURE && sym->attr.generic))\n       || sym->attr.subroutine)\n     {\n-      gfc_error_1 (\"Type name '%s' at %C conflicts with previously declared \"\n-\t\t   \"entity at %L, which has the same name\", name,\n-\t\t   &sym->declared_at);\n+      gfc_error (\"Type name %qs at %C conflicts with previously declared \"\n+\t\t \"entity at %L, which has the same name\", name,\n+\t\t &sym->declared_at);\n       return MATCH_ERROR;\n     }\n "}, {"sha": "2512cfc36aa7eeacfa12b87068c5460f00a8a433", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 30, "deletions": 200, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -40,12 +40,12 @@ static int suppress_errors = 0;\n \n static bool warnings_not_errors = false;\n \n-static int terminal_width, errors, warnings;\n-\n-static gfc_error_buf error_buffer, warning_buffer, *cur_error_buffer;\n+static int terminal_width;\n \n /* True if the error/warnings should be buffered.  */\n static bool buffered_p;\n+\n+static gfc_error_buffer error_buffer;\n /* These are always buffered buffers (.flush_p == false) to be used by\n    the pretty-printer.  */\n static output_buffer *pp_error_buffer, *pp_warning_buffer;\n@@ -100,8 +100,6 @@ void\n gfc_error_init_1 (void)\n {\n   terminal_width = gfc_get_terminal_width ();\n-  errors = 0;\n-  warnings = 0;\n   gfc_buffer_error (false);\n }\n \n@@ -119,42 +117,9 @@ gfc_buffer_error (bool flag)\n    buffered_p.  */\n \n static void\n-error_char (char c)\n+error_char (char)\n {\n-  if (buffered_p)\n-    {\n-      if (cur_error_buffer->index >= cur_error_buffer->allocated)\n-\t{\n-\t  cur_error_buffer->allocated = cur_error_buffer->allocated\n-\t\t\t\t      ? cur_error_buffer->allocated * 2 : 1000;\n-\t  cur_error_buffer->message = XRESIZEVEC (char, cur_error_buffer->message,\n-\t\t\t\t\t\t  cur_error_buffer->allocated);\n-\t}\n-      cur_error_buffer->message[cur_error_buffer->index++] = c;\n-    }\n-  else\n-    {\n-      if (c != 0)\n-\t{\n-\t  /* We build up complete lines before handing things\n-\t     over to the library in order to speed up error printing.  */\n-\t  static char *line;\n-\t  static size_t allocated = 0, index = 0;\n-\n-\t  if (index + 1 >= allocated)\n-\t    {\n-\t      allocated = allocated ? allocated * 2 : 1000;\n-\t      line = XRESIZEVEC (char, line, allocated);\n-\t    }\n-\t  line[index++] = c;\n-\t  if (c == '\\n')\n-\t    {\n-\t      line[index] = '\\0';\n-\t      fputs (line, stderr);\n-\t      index = 0;\n-\t    }\n-\t}\n-    }\n+  /* FIXME: Unused function to be removed in a subsequent patch.  */\n }\n \n \n@@ -782,18 +747,6 @@ error_printf (const char *gmsgid, ...)\n }\n \n \n-/* Increment the number of errors, and check whether too many have \n-   been printed.  */\n-\n-static void\n-gfc_increment_error_count (void)\n-{\n-  errors++;\n-  if ((gfc_option.max_errors != 0) && (errors >= gfc_option.max_errors))\n-    gfc_fatal_error (\"Error count reached limit of %d.\", gfc_option.max_errors);\n-}\n-\n-\n /* Clear any output buffered in a pretty-print output_buffer.  */\n \n static void\n@@ -1247,16 +1200,15 @@ gfc_warning_now (int opt, const char *gmsgid, ...)\n \n \n /* Immediate error (i.e. do not buffer).  */\n-/* This function uses the common diagnostics, but does not support\n-   two locations; when being used in scanner.c, ensure that the location\n-   is properly setup. Otherwise, use gfc_error_now_1.   */\n \n void\n gfc_error_now (const char *gmsgid, ...)\n {\n   va_list argp;\n   diagnostic_info diagnostic;\n \n+  error_buffer.flag = true;\n+\n   va_start (argp, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &argp, UNKNOWN_LOCATION, DK_ERROR);\n   report_diagnostic (&diagnostic);\n@@ -1285,8 +1237,6 @@ gfc_fatal_error (const char *gmsgid, ...)\n void\n gfc_clear_warning (void)\n {\n-  warning_buffer.flag = 0;\n-\n   gfc_clear_pp_buffer (pp_warning_buffer);\n   warningcount_buffered = 0;\n   werrorcount_buffered = 0;\n@@ -1299,15 +1249,8 @@ gfc_clear_warning (void)\n void\n gfc_warning_check (void)\n {\n-  if (warning_buffer.flag)\n-    {\n-      warnings++;\n-      if (warning_buffer.message != NULL)\n-\tfputs (warning_buffer.message, stderr);\n-      gfc_clear_warning ();\n-    }\n   /* This is for the new diagnostics machinery.  */\n-  else if (! gfc_output_buffer_empty_p (pp_warning_buffer))\n+  if (! gfc_output_buffer_empty_p (pp_warning_buffer))\n     {\n       pretty_printer *pp = global_dc->printer;\n       output_buffer *tmp_buffer = pp->buffer;\n@@ -1325,62 +1268,6 @@ gfc_warning_check (void)\n \n \n /* Issue an error.  */\n-/* Use gfc_error instead, unless two locations are used in the same\n-   warning or for scanner.c, if the location is not properly set up.  */\n-\n-void\n-gfc_error_1 (const char *gmsgid, ...)\n-{\n-  va_list argp;\n-\n-  if (warnings_not_errors)\n-    goto warning;\n-\n-  if (suppress_errors)\n-    return;\n-\n-  error_buffer.flag = 1;\n-  error_buffer.index = 0;\n-  cur_error_buffer = &error_buffer;\n-\n-  va_start (argp, gmsgid);\n-  error_print (_(\"Error:\"), _(gmsgid), argp);\n-  va_end (argp);\n-\n-  error_char ('\\0');\n-\n-  if (!buffered_p)\n-    gfc_increment_error_count();\n-\n-  return;\n-\n-warning:\n-\n-  if (inhibit_warnings)\n-    return;\n-\n-  warning_buffer.flag = 1;\n-  warning_buffer.index = 0;\n-  cur_error_buffer = &warning_buffer;\n-\n-  va_start (argp, gmsgid);\n-  error_print (_(\"Warning:\"), _(gmsgid), argp);\n-  va_end (argp);\n-\n-  error_char ('\\0');\n-\n-  if (!buffered_p)\n-  {\n-    warnings++;\n-    if (warnings_are_errors)\n-      gfc_increment_error_count();\n-  }\n-}\n-\n-/* Issue an error.  */\n-/* This function uses the common diagnostics, but does not support\n-   two locations; when being used in scanner.c, ensure that the location\n-   is properly setup. Otherwise, use gfc_error_1.   */\n \n static void\n gfc_error (const char *gmsgid, va_list ap)\n@@ -1440,38 +1327,6 @@ gfc_error (const char *gmsgid, ...)\n }\n \n \n-/* Immediate error.  */\n-/* Use gfc_error_now instead, unless two locations are used in the same\n-   warning or for scanner.c, if the location is not properly set up.  */\n-\n-void\n-gfc_error_now_1 (const char *gmsgid, ...)\n-{\n-  va_list argp;\n-  bool buffered_p_saved;\n-\n-  error_buffer.flag = 1;\n-  error_buffer.index = 0;\n-  cur_error_buffer = &error_buffer;\n-\n-  buffered_p_saved = buffered_p;\n-  buffered_p = false;\n-\n-  va_start (argp, gmsgid);\n-  error_print (_(\"Error:\"), _(gmsgid), argp);\n-  va_end (argp);\n-\n-  error_char ('\\0');\n-\n-  gfc_increment_error_count();\n-\n-  buffered_p = buffered_p_saved;\n-\n-  if (flag_fatal_errors)\n-    exit (FATAL_EXIT_CODE);\n-}\n-\n-\n /* This shouldn't happen... but sometimes does.  */\n \n void\n@@ -1516,24 +1371,10 @@ gfc_error_flag_test (void)\n bool\n gfc_error_check (void)\n {\n-  bool error_raised = (bool) error_buffer.flag;\n-\n-  if (error_raised)\n-    {\n-      if (error_buffer.message != NULL)\n-\tfputs (error_buffer.message, stderr);\n-      error_buffer.flag = 0;\n-      gfc_clear_pp_buffer (pp_error_buffer);\n-\n-      gfc_increment_error_count();\n-\n-      if (flag_fatal_errors)\n-\texit (FATAL_EXIT_CODE);\n-    }\n-  /* This is for the new diagnostics machinery.  */\n-  else if (! gfc_output_buffer_empty_p (pp_error_buffer))\n+  if (error_buffer.flag\n+      || ! gfc_output_buffer_empty_p (pp_error_buffer))\n     {\n-      error_raised = true;\n+      error_buffer.flag = false;\n       pretty_printer *pp = global_dc->printer;\n       output_buffer *tmp_buffer = pp->buffer;\n       pp->buffer = pp_error_buffer;\n@@ -1542,18 +1383,26 @@ gfc_error_check (void)\n       gcc_assert (gfc_output_buffer_empty_p (pp_error_buffer));\n       diagnostic_action_after_output (global_dc, DK_ERROR);\n       pp->buffer = tmp_buffer;\n+      return true;\n     }\n \n-  return error_raised;\n+  return false;\n }\n \n /* Move the text buffered from FROM to TO, then clear\n    FROM. Independently if there was text in FROM, TO is also\n    cleared. */\n \n static void\n-gfc_move_output_buffer_from_to (output_buffer *from, output_buffer *to)\n+gfc_move_error_buffer_from_to (gfc_error_buffer * buffer_from,\n+\t\t\t       gfc_error_buffer * buffer_to)\n {\n+  output_buffer * from = &(buffer_from->buffer);\n+  output_buffer * to =  &(buffer_to->buffer);\n+\n+  buffer_to->flag = buffer_from->flag;\n+  buffer_from->flag = false;\n+\n   gfc_clear_pp_buffer (to);\n   /* We make sure this is always buffered.  */\n   to->flush_p = false;\n@@ -1569,46 +1418,27 @@ gfc_move_output_buffer_from_to (output_buffer *from, output_buffer *to)\n /* Save the existing error state.  */\n \n void\n-gfc_push_error (output_buffer *buffer_err, gfc_error_buf *err)\n+gfc_push_error (gfc_error_buffer *err)\n {\n-  err->flag = error_buffer.flag;\n-  if (error_buffer.flag)\n-    err->message = xstrdup (error_buffer.message);\n-\n-  error_buffer.flag = 0;\n-\n-  /* This part uses the common diagnostics.  */\n-  gfc_move_output_buffer_from_to (pp_error_buffer, buffer_err);\n+  gfc_move_error_buffer_from_to (&error_buffer, err);\n }\n \n \n /* Restore a previous pushed error state.  */\n \n void\n-gfc_pop_error (output_buffer *buffer_err, gfc_error_buf *err)\n+gfc_pop_error (gfc_error_buffer *err)\n {\n-  error_buffer.flag = err->flag;\n-  if (error_buffer.flag)\n-    {\n-      size_t len = strlen (err->message) + 1;\n-      gcc_assert (len <= error_buffer.allocated);\n-      memcpy (error_buffer.message, err->message, len);\n-      free (err->message);\n-    }\n-  /* This part uses the common diagnostics.  */\n-  gfc_move_output_buffer_from_to (buffer_err, pp_error_buffer);\n+  gfc_move_error_buffer_from_to (err, &error_buffer);\n }\n \n \n /* Free a pushed error state, but keep the current error state.  */\n \n void\n-gfc_free_error (output_buffer *buffer_err, gfc_error_buf *err)\n+gfc_free_error (gfc_error_buffer *err)\n {\n-  if (err->flag)\n-    free (err->message);\n-\n-  gfc_clear_pp_buffer (buffer_err);\n+  gfc_clear_pp_buffer (&(err->buffer));\n }\n \n \n@@ -1618,9 +1448,9 @@ void\n gfc_get_errors (int *w, int *e)\n {\n   if (w != NULL)\n-    *w = warnings + warningcount + werrorcount;\n+    *w = warningcount + werrorcount;\n   if (e != NULL)\n-    *e = errors + errorcount + sorrycount + werrorcount;\n+    *e = errorcount + sorrycount + werrorcount;\n }\n \n \n@@ -1642,7 +1472,7 @@ gfc_diagnostics_init (void)\n   global_dc->caret_chars[1] = '2';\n   pp_warning_buffer = new (XNEW (output_buffer)) output_buffer ();\n   pp_warning_buffer->flush_p = false;\n-  pp_error_buffer = new (XNEW (output_buffer)) output_buffer ();\n+  pp_error_buffer = &(error_buffer.buffer);\n   pp_error_buffer->flush_p = false;\n }\n "}, {"sha": "b569e0ccb4cd3d24e370cfd46b44d95407729f0e", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -4994,7 +4994,7 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       if (!gfc_check_vardef_context (assoc->target, pointer, false, false, NULL))\n \t{\n \t  if (context)\n-\t    gfc_error_1 (\"Associate-name '%s' can not appear in a variable\"\n+\t    gfc_error (\"Associate-name %qs can not appear in a variable\"\n \t\t       \" definition context (%s) at %L because its target\"\n \t\t       \" at %L can not, either\",\n \t\t       name, context, &e->where,\n@@ -5036,12 +5036,12 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \t\t\t  if (gfc_dep_compare_expr (ec, en) == 0)\n \t\t\t    {\n \t\t\t      if (context)\n-\t\t\t\tgfc_error_now_1 (\"Elements with the same value \"\n-\t\t\t\t\t\t \"at %L and %L in vector \"\n-\t\t\t\t\t\t \"subscript in a variable \"\n-\t\t\t\t\t\t \"definition context (%s)\",\n-\t\t\t\t\t\t &(ec->where), &(en->where),\n-\t\t\t\t\t\t context);\n+\t\t\t\tgfc_error_now (\"Elements with the same value \"\n+\t\t\t\t\t       \"at %L and %L in vector \"\n+\t\t\t\t\t       \"subscript in a variable \"\n+\t\t\t\t\t       \"definition context (%s)\",\n+\t\t\t\t\t       &(ec->where), &(en->where),\n+\t\t\t\t\t       context);\n \t\t\t      return false;\n \t\t\t    }\n \t\t\t}"}, {"sha": "28eaa6aebac96539c5a911db7eca0b51ba3708ef", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -221,18 +221,10 @@ gfc_create_decls (void)\n static void\n gfc_be_parse_file (void)\n {\n-  int errors;\n-  int warnings;\n-\n   gfc_create_decls ();\n   gfc_parse_file ();\n   gfc_generate_constructors ();\n \n-  /* Tell the frontend about any errors.  */\n-  gfc_get_errors (&warnings, &errors);\n-  errorcount += errors;\n-  warningcount += warnings;\n-\n   /* Clear the binding level stack.  */\n   while (!global_bindings_p ())\n     poplevel (0, 0);"}, {"sha": "45b053e665b8f09d678e9f8cfff34bf64f2ba4d8", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -1879,19 +1879,19 @@ doloop_code (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t\t  && a->expr->symtree->n.sym == do_sym)\n \t\t{\n \t\t  if (f->sym->attr.intent == INTENT_OUT)\n-\t\t    gfc_error_now_1 (\"Variable '%s' at %L set to undefined \"\n-\t\t\t\t     \"value inside loop  beginning at %L as \"\n-\t\t\t\t     \"INTENT(OUT) argument to subroutine '%s'\",\n-\t\t\t\t     do_sym->name, &a->expr->where,\n-\t\t\t\t     &doloop_list[i]->loc,\n-\t\t\t\t     co->symtree->n.sym->name);\n+\t\t    gfc_error_now (\"Variable %qs at %L set to undefined \"\n+\t\t\t\t   \"value inside loop  beginning at %L as \"\n+\t\t\t\t   \"INTENT(OUT) argument to subroutine %qs\",\n+\t\t\t\t   do_sym->name, &a->expr->where,\n+\t\t\t\t   &doloop_list[i]->loc,\n+\t\t\t\t   co->symtree->n.sym->name);\n \t\t  else if (f->sym->attr.intent == INTENT_INOUT)\n-\t\t    gfc_error_now_1 (\"Variable '%s' at %L not definable inside \"\n-\t\t\t\t     \"loop beginning at %L as INTENT(INOUT) \"\n-\t\t\t\t     \"argument to subroutine '%s'\",\n-\t\t\t\t     do_sym->name, &a->expr->where,\n-\t\t\t\t     &doloop_list[i]->loc,\n-\t\t\t\t     co->symtree->n.sym->name);\n+\t\t    gfc_error_now (\"Variable %qs at %L not definable inside \"\n+\t\t\t\t   \"loop beginning at %L as INTENT(INOUT) \"\n+\t\t\t\t   \"argument to subroutine %qs\",\n+\t\t\t\t   do_sym->name, &a->expr->where,\n+\t\t\t\t   &doloop_list[i]->loc,\n+\t\t\t\t   co->symtree->n.sym->name);\n \t\t}\n \t    }\n \t  a = a->next;\n@@ -1951,17 +1951,17 @@ do_function (gfc_expr **e, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t      && a->expr->symtree->n.sym == do_sym)\n \t    {\n \t      if (f->sym->attr.intent == INTENT_OUT)\n-\t\tgfc_error_now_1 (\"Variable '%s' at %L set to undefined value \"\n-\t\t\t\t \"inside loop beginning at %L as INTENT(OUT) \"\n-\t\t\t\t \"argument to function '%s'\", do_sym->name,\n-\t\t\t\t &a->expr->where, &doloop_list[i]->loc,\n-\t\t\t\t expr->symtree->n.sym->name);\n+\t\tgfc_error_now (\"Variable %qs at %L set to undefined value \"\n+\t\t\t       \"inside loop beginning at %L as INTENT(OUT) \"\n+\t\t\t       \"argument to function %qs\", do_sym->name,\n+\t\t\t       &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t       expr->symtree->n.sym->name);\n \t      else if (f->sym->attr.intent == INTENT_INOUT)\n-\t\tgfc_error_now_1 (\"Variable '%s' at %L not definable inside loop\"\n-\t\t\t\t \" beginning at %L as INTENT(INOUT) argument to\"\n-\t\t\t\t \" function '%s'\", do_sym->name,\n-\t\t\t\t &a->expr->where, &doloop_list[i]->loc,\n-\t\t\t\t expr->symtree->n.sym->name);\n+\t\tgfc_error_now (\"Variable %qs at %L not definable inside loop\"\n+\t\t\t       \" beginning at %L as INTENT(INOUT) argument to\"\n+\t\t\t       \" function %qs\", do_sym->name,\n+\t\t\t       &a->expr->where, &doloop_list[i]->loc,\n+\t\t\t       expr->symtree->n.sym->name);\n \t    }\n \t}\n       a = a->next;"}, {"sha": "905d47c008670441c70a34998dd97535bda825ac", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -2645,14 +2645,6 @@ const char * gfc_get_string (const char *, ...) ATTRIBUTE_PRINTF_1;\n bool gfc_find_sym_in_expr (gfc_symbol *, gfc_expr *);\n \n /* error.c */\n-\n-typedef struct gfc_error_buf\n-{\n-  int flag;\n-  size_t allocated, index;\n-  char *message;\n-} gfc_error_buf;\n-\n void gfc_error_init_1 (void);\n void gfc_diagnostics_init (void);\n void gfc_diagnostics_finish (void);\n@@ -2668,9 +2660,7 @@ bool gfc_warning_now_at (location_t loc, int opt, const char *gmsgid, ...)\n void gfc_clear_warning (void);\n void gfc_warning_check (void);\n \n-void gfc_error_1 (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_error (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n-void gfc_error_now_1 (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_error_now (const char *, ...) ATTRIBUTE_GCC_GFC(1,2);\n void gfc_fatal_error (const char *, ...) ATTRIBUTE_NORETURN ATTRIBUTE_GCC_GFC(1,2);\n void gfc_internal_error (const char *, ...) ATTRIBUTE_NORETURN ATTRIBUTE_GCC_GFC(1,2);\n@@ -2685,10 +2675,17 @@ bool gfc_notify_std (int, const char *, ...) ATTRIBUTE_GCC_GFC(2,3);\n #define gfc_syntax_error(ST)\t\\\n   gfc_error (\"Syntax error in %s statement at %C\", gfc_ascii_statement (ST));\n \n-#include \"pretty-print.h\" /* For output_buffer.  */\n-void gfc_push_error (output_buffer *, gfc_error_buf *);\n-void gfc_pop_error (output_buffer *, gfc_error_buf *);\n-void gfc_free_error (output_buffer *, gfc_error_buf *);\n+#include \"pretty-print.h\"  /* For output_buffer.  */\n+struct gfc_error_buffer\n+{\n+  bool flag;\n+  output_buffer buffer;\n+  gfc_error_buffer(void) : flag(false), buffer() {}\n+};\n+\n+void gfc_push_error (gfc_error_buffer *);\n+void gfc_pop_error (gfc_error_buffer *);\n+void gfc_free_error (gfc_error_buffer *);\n \n void gfc_get_errors (int *, int *);\n void gfc_errors_to_warnings (bool);"}, {"sha": "2e15af29df6aaf32e81937058fed01b2f4caabe2", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -3599,7 +3599,7 @@ gfc_match_allocate (void)\n \t  /* The next 2 conditionals check C631.  */\n \t  if (ts.type != BT_UNKNOWN)\n \t    {\n-\t      gfc_error_1 (\"SOURCE tag at %L conflicts with the typespec at %L\",\n+\t      gfc_error (\"SOURCE tag at %L conflicts with the typespec at %L\",\n \t\t\t &tmp->where, &old_locus);\n \t      goto cleanup;\n \t    }\n@@ -3636,7 +3636,7 @@ gfc_match_allocate (void)\n \t  /* Check F08:C637.  */\n \t  if (ts.type != BT_UNKNOWN)\n \t    {\n-\t      gfc_error_1 (\"MOLD tag at %L conflicts with the typespec at %L\",\n+\t      gfc_error (\"MOLD tag at %L conflicts with the typespec at %L\",\n \t\t\t &tmp->where, &old_locus);\n \t      goto cleanup;\n \t    }\n@@ -3662,8 +3662,8 @@ gfc_match_allocate (void)\n   /* Check F08:C637.  */\n   if (source && mold)\n     {\n-      gfc_error_1 (\"MOLD tag at %L conflicts with SOURCE tag at %L\",\n-\t\t  &mold->where, &source->where);\n+      gfc_error (\"MOLD tag at %L conflicts with SOURCE tag at %L\",\n+\t\t &mold->where, &source->where);\n       goto cleanup;\n     }\n \n@@ -4350,12 +4350,12 @@ gfc_match_common (void)\n                   /* If we find an error, just print it and continue,\n                      cause it's just semantic, and we can see if there\n                      are more errors.  */\n-                  gfc_error_now_1 (\"Variable '%s' at %L in common block '%s' \"\n-\t\t\t\t   \"at %C must be declared with a C \"\n-\t\t\t\t   \"interoperable kind since common block \"\n-\t\t\t\t   \"'%s' is bind(c)\",\n-\t\t\t\t   sym->name, &(sym->declared_at), t->name,\n-\t\t\t\t   t->name);\n+                  gfc_error_now (\"Variable %qs at %L in common block %qs \"\n+\t\t\t\t \"at %C must be declared with a C \"\n+\t\t\t\t \"interoperable kind since common block \"\n+\t\t\t\t \"%qs is bind(c)\",\n+\t\t\t\t sym->name, &(sym->declared_at), t->name,\n+\t\t\t\t t->name);\n                 }\n \n               if (sym->attr.is_bind_c == 1)\n@@ -4889,8 +4889,7 @@ recursive_stmt_fcn (gfc_expr *e, gfc_symbol *sym)\n match\n gfc_match_st_function (void)\n {\n-  gfc_error_buf old_error_1;\n-  output_buffer old_error;\n+  gfc_error_buffer old_error;\n \n   gfc_symbol *sym;\n   gfc_expr *expr;\n@@ -4900,7 +4899,7 @@ gfc_match_st_function (void)\n   if (m != MATCH_YES)\n     return m;\n \n-  gfc_push_error (&old_error, &old_error_1);\n+  gfc_push_error (&old_error);\n \n   if (!gfc_add_procedure (&sym->attr, PROC_ST_FUNCTION, sym->name, NULL))\n     goto undo_error;\n@@ -4912,7 +4911,7 @@ gfc_match_st_function (void)\n   if (m == MATCH_NO)\n     goto undo_error;\n \n-  gfc_free_error (&old_error, &old_error_1);\n+  gfc_free_error (&old_error);\n \n   if (m == MATCH_ERROR)\n     return m;\n@@ -4931,7 +4930,7 @@ gfc_match_st_function (void)\n   return MATCH_YES;\n \n undo_error:\n-  gfc_pop_error (&old_error, &old_error_1);\n+  gfc_pop_error (&old_error);\n   return MATCH_NO;\n }\n "}, {"sha": "56c67826dbe27033468d4896565cbccfe3bf2782", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -108,14 +108,13 @@ match_word_omp_simd (const char *str, match (*subr) (void), locus *old_locus,\n static void\n use_modules (void)\n {\n-  gfc_error_buf old_error_1;\n-  output_buffer old_error;\n+  gfc_error_buffer old_error;\n \n-  gfc_push_error (&old_error, &old_error_1);\n+  gfc_push_error (&old_error);\n   gfc_buffer_error (false);\n   gfc_use_modules ();\n   gfc_buffer_error (true);\n-  gfc_pop_error (&old_error, &old_error_1);\n+  gfc_pop_error (&old_error);\n   gfc_commit_symbols ();\n   gfc_warning_check ();\n   gfc_current_ns->old_cl_list = gfc_current_ns->cl_list;\n@@ -2435,7 +2434,7 @@ verify_st_order (st_state *p, gfc_statement st, bool silent)\n \n order:\n   if (!silent)\n-    gfc_error_1 (\"%s statement at %C cannot follow %s statement at %L\",\n+    gfc_error (\"%s statement at %C cannot follow %s statement at %L\",\n \t       gfc_ascii_statement (st),\n \t       gfc_ascii_statement (p->last_statement), &p->where);\n \n@@ -2812,7 +2811,7 @@ parse_derived (void)\n \t\t   \"subcomponent exists)\", c->name, &c->loc, sym->name);\n \n       if (sym->attr.lock_comp && coarray && !lock_type)\n-\tgfc_error_1 (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n+\tgfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n \t\t   \"subcomponent of type LOCK_TYPE must have a codimension or \"\n \t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n \t\t   \"not have a codimension as %s at %L has a codimension or a \"\n@@ -3527,7 +3526,7 @@ parse_if_block (void)\n \tcase ST_ELSEIF:\n \t  if (seen_else)\n \t    {\n-\t      gfc_error_1 (\"ELSE IF statement at %C cannot follow ELSE \"\n+\t      gfc_error (\"ELSE IF statement at %C cannot follow ELSE \"\n \t\t\t \"statement at %L\", &else_locus);\n \n \t      reject_statement ();\n@@ -3751,8 +3750,8 @@ gfc_check_do_variable (gfc_symtree *st)\n   for (s=gfc_state_stack; s; s = s->previous)\n     if (s->do_variable == st)\n       {\n-\tgfc_error_now_1 (\"Variable '%s' at %C cannot be redefined inside \"\n-\t\t\t \"loop beginning at %L\", st->name, &s->head->loc);\n+\tgfc_error_now (\"Variable %qs at %C cannot be redefined inside \"\n+\t\t       \"loop beginning at %L\", st->name, &s->head->loc);\n \treturn 1;\n       }\n \n@@ -5070,10 +5069,10 @@ gfc_global_used (gfc_gsymbol *sym, locus *where)\n     }\n \n   if (sym->binding_label)\n-    gfc_error_1 (\"Global binding name '%s' at %L is already being used as a %s \"\n+    gfc_error (\"Global binding name %qs at %L is already being used as a %s \"\n \t       \"at %L\", sym->binding_label, where, name, &sym->where);\n   else\n-    gfc_error_1 (\"Global name '%s' at %L is already being used as a %s at %L\",\n+    gfc_error (\"Global name %qs at %L is already being used as a %s at %L\",\n \t       sym->name, where, name, &sym->where);\n }\n \n@@ -5543,7 +5542,7 @@ gfc_parse_file (void)\n   /* If we see a duplicate main program, shut down.  If the second\n      instance is an implied main program, i.e. data decls or executable\n      statements, we're in for lots of errors.  */\n-  gfc_error_1 (\"Two main PROGRAMs at %L and %C\", &prog_locus);\n+  gfc_error (\"Two main PROGRAMs at %L and %C\", &prog_locus);\n   reject_statement ();\n   gfc_done_2 ();\n   return true;"}, {"sha": "7d2f9c768fe3f91a2697020962a2ac99b7d1473f", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -1274,8 +1274,7 @@ static match\n match_complex_constant (gfc_expr **result)\n {\n   gfc_expr *e, *real, *imag;\n-  gfc_error_buf old_error_1;\n-  output_buffer old_error;\n+  gfc_error_buffer old_error;\n   gfc_typespec target;\n   locus old_loc;\n   int kind;\n@@ -1288,18 +1287,18 @@ match_complex_constant (gfc_expr **result)\n   if (m != MATCH_YES)\n     return m;\n \n-  gfc_push_error (&old_error, &old_error_1);\n+  gfc_push_error (&old_error);\n \n   m = match_complex_part (&real);\n   if (m == MATCH_NO)\n     {\n-      gfc_free_error (&old_error, &old_error_1);\n+      gfc_free_error (&old_error);\n       goto cleanup;\n     }\n \n   if (gfc_match_char (',') == MATCH_NO)\n     {\n-      gfc_pop_error (&old_error, &old_error_1);\n+      gfc_pop_error (&old_error);\n       m = MATCH_NO;\n       goto cleanup;\n     }\n@@ -1311,10 +1310,10 @@ match_complex_constant (gfc_expr **result)\n \n   if (m == MATCH_ERROR)\n     {\n-      gfc_free_error (&old_error, &old_error_1);\n+      gfc_free_error (&old_error);\n       goto cleanup;\n     }\n-  gfc_pop_error (&old_error, &old_error_1);\n+  gfc_pop_error (&old_error);\n \n   m = match_complex_part (&imag);\n   if (m == MATCH_NO)"}, {"sha": "492c016ad9c7eda5990d78d38db950b1ac55c0bd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -418,7 +418,7 @@ resolve_formal_arglist (gfc_symbol *proc)\n \t  /* F08:C1278a.  */\n \t  if (sym->ts.type == BT_CLASS && sym->attr.intent == INTENT_OUT)\n \t    {\n-\t      gfc_error (\"INTENT(OUT) argument '%s' of pure procedure %qs at %L\"\n+\t      gfc_error (\"INTENT(OUT) argument %qs of pure procedure %qs at %L\"\n \t\t\t \" may not be polymorphic\", sym->name, proc->name,\n \t\t\t &sym->declared_at);\n \t      continue;\n@@ -993,7 +993,7 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t      || (!common_root->n.common->binding_label\n \t\t  && gsym->binding_label)))\n \t{\n-\t  gfc_error_1 (\"In Fortran 2003 COMMON '%s' block at %L is a global \"\n+\t  gfc_error (\"In Fortran 2003 COMMON %qs block at %L is a global \"\n \t\t     \"identifier and must thus have the same binding name \"\n \t\t     \"as the same-named COMMON block at %L: %s vs %s\",\n \t\t     common_root->n.common->name, &common_root->n.common->where,\n@@ -1007,15 +1007,15 @@ resolve_common_blocks (gfc_symtree *common_root)\n       if (gsym && gsym->type != GSYM_COMMON\n \t  && !common_root->n.common->binding_label)\n \t{\n-\t  gfc_error_1 (\"COMMON block '%s' at %L uses the same global identifier \"\n+\t  gfc_error (\"COMMON block %qs at %L uses the same global identifier \"\n \t\t     \"as entity at %L\",\n \t\t     common_root->n.common->name, &common_root->n.common->where,\n \t\t     &gsym->where);\n \t  return;\n \t}\n       if (gsym && gsym->type != GSYM_COMMON)\n \t{\n-\t  gfc_error_1 (\"Fortran 2008: COMMON block '%s' with binding label at \"\n+\t  gfc_error (\"Fortran 2008: COMMON block %qs with binding label at \"\n \t\t     \"%L sharing the identifier with global non-COMMON-block \"\n \t\t     \"entity at %L\", common_root->n.common->name,\n \t\t     &common_root->n.common->where, &gsym->where);\n@@ -1037,7 +1037,7 @@ resolve_common_blocks (gfc_symtree *common_root)\n \t\t\t       common_root->n.common->binding_label);\n       if (gsym && gsym->type != GSYM_COMMON)\n \t{\n-\t  gfc_error_1 (\"COMMON block at %L with binding label %s uses the same \"\n+\t  gfc_error (\"COMMON block at %L with binding label %s uses the same \"\n \t\t     \"global identifier as entity at %L\",\n \t\t     &common_root->n.common->where,\n \t\t     common_root->n.common->binding_label, &gsym->where);\n@@ -1058,7 +1058,7 @@ resolve_common_blocks (gfc_symtree *common_root)\n     return;\n \n   if (sym->attr.flavor == FL_PARAMETER)\n-    gfc_error_1 (\"COMMON block '%s' at %L is used as PARAMETER at %L\",\n+    gfc_error (\"COMMON block %qs at %L is used as PARAMETER at %L\",\n \t       sym->name, &common_root->n.common->where, &sym->declared_at);\n \n   if (sym->attr.external)\n@@ -3368,7 +3368,7 @@ resolve_call (gfc_code *c)\n \n   if (csym && csym->ts.type != BT_UNKNOWN)\n     {\n-      gfc_error_1 (\"'%s' at %L has a type, which is not consistent with \"\n+      gfc_error (\"%qs at %L has a type, which is not consistent with \"\n \t\t \"the CALL at %L\", csym->name, &csym->declared_at, &c->loc);\n       return false;\n     }\n@@ -3494,8 +3494,8 @@ compare_shapes (gfc_expr *op1, gfc_expr *op2)\n \t{\n \t  if (mpz_cmp (op1->shape[i], op2->shape[i]) != 0)\n \t   {\n-\t     gfc_error_1 (\"Shapes for operands at %L and %L are not conformable\",\n-\t\t\t &op1->where, &op2->where);\n+\t     gfc_error (\"Shapes for operands at %L and %L are not conformable\",\n+\t\t\t&op1->where, &op2->where);\n \t     t = false;\n \t     break;\n \t   }\n@@ -6785,7 +6785,7 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n \n \t  if (mpz_cmp (e1->shape[i], s) != 0)\n \t    {\n-\t      gfc_error_1 (\"Source-expr at %L and allocate-object at %L must \"\n+\t      gfc_error (\"Source-expr at %L and allocate-object at %L must \"\n \t\t\t \"have the same shape\", &e1->where, &e2->where);\n \t      mpz_clear (s);\n    \t      return false;\n@@ -6943,8 +6943,8 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       /* Check F03:C631.  */\n       if (!gfc_type_compatible (&e->ts, &code->expr3->ts))\n \t{\n-\t  gfc_error_1 (\"Type of entity at %L is type incompatible with \"\n-\t\t       \"source-expr at %L\", &e->where, &code->expr3->where);\n+\t  gfc_error (\"Type of entity at %L is type incompatible with \"\n+\t\t     \"source-expr at %L\", &e->where, &code->expr3->where);\n \t  goto failure;\n \t}\n \n@@ -6955,9 +6955,9 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       /* Check F03:C633.  */\n       if (code->expr3->ts.kind != e->ts.kind && !unlimited)\n \t{\n-\t  gfc_error_1 (\"The allocate-object at %L and the source-expr at %L \"\n-\t\t      \"shall have the same kind type parameter\",\n-\t\t      &e->where, &code->expr3->where);\n+\t  gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n+\t\t     \"shall have the same kind type parameter\",\n+\t\t     &e->where, &code->expr3->where);\n \t  goto failure;\n \t}\n \n@@ -6969,7 +6969,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t\t  && code->expr3->ts.u.derived->intmod_sym_id\n \t\t     == ISOFORTRAN_LOCK_TYPE)))\n \t{\n-\t  gfc_error_1 (\"The source-expr at %L shall neither be of type \"\n+\t  gfc_error (\"The source-expr at %L shall neither be of type \"\n \t\t     \"LOCK_TYPE nor have a LOCK_TYPE component if \"\n \t\t      \"allocate-object at %L is a coarray\",\n \t\t      &code->expr3->where, &e->where);\n@@ -7318,20 +7318,20 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \t\t{\n \t\t  if (pr == NULL && qr == NULL)\n \t\t    {\n-\t\t      gfc_error_1 (\"Allocate-object at %L also appears at %L\",\n-\t\t\t\t   &pe->where, &qe->where);\n+\t\t      gfc_error (\"Allocate-object at %L also appears at %L\",\n+\t\t\t\t &pe->where, &qe->where);\n \t\t      break;\n \t\t    }\n \t\t  else if (pr != NULL && qr == NULL)\n \t\t    {\n-\t\t      gfc_error_1 (\"Allocate-object at %L is subobject of\"\n-\t\t\t\t   \" object at %L\", &pe->where, &qe->where);\n+\t\t      gfc_error (\"Allocate-object at %L is subobject of\"\n+\t\t\t\t \" object at %L\", &pe->where, &qe->where);\n \t\t      break;\n \t\t    }\n \t\t  else if (pr == NULL && qr != NULL)\n \t\t    {\n-\t\t      gfc_error_1 (\"Allocate-object at %L is subobject of\"\n-\t\t\t\t   \" object at %L\", &qe->where, &pe->where);\n+\t\t      gfc_error (\"Allocate-object at %L is subobject of\"\n+\t\t\t\t \" object at %L\", &qe->where, &pe->where);\n \t\t      break;\n \t\t    }\n \t\t  /* Here, pr != NULL && qr != NULL  */\n@@ -7534,7 +7534,7 @@ check_case_overlap (gfc_case *list)\n \t\t\t element in the list.  Either way, we must\n \t\t\t issue an error and get the next case from P.  */\n \t\t      /* FIXME: Sort P and Q by line number.  */\n-\t\t      gfc_error_1 (\"CASE label at %L overlaps with CASE \"\n+\t\t      gfc_error (\"CASE label at %L overlaps with CASE \"\n \t\t\t\t \"label at %L\", &p->where, &q->where);\n \t\t      overlap_seen = 1;\n \t\t      e = p;\n@@ -7772,7 +7772,7 @@ resolve_select (gfc_code *code, bool select_type)\n \t    {\n \t      if (default_case != NULL)\n \t\t{\n-\t\t  gfc_error_1 (\"The DEFAULT CASE at %L cannot be followed \"\n+\t\t  gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n \t\t\t     \"by a second DEFAULT CASE at %L\",\n \t\t\t     &default_case->where, &cp->where);\n \t\t  t = false;\n@@ -8145,7 +8145,7 @@ resolve_select_type (gfc_code *code, gfc_namespace *old_ns)\n \t  /* Check F03:C818.  */\n \t  if (default_case)\n \t    {\n-\t      gfc_error_1 (\"The DEFAULT CASE at %L cannot be followed \"\n+\t      gfc_error (\"The DEFAULT CASE at %L cannot be followed \"\n \t\t\t \"by a second DEFAULT CASE at %L\",\n \t\t\t &default_case->ext.block.case_list->where, &c->where);\n \t      error++;\n@@ -8708,7 +8708,7 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \n   if (label->defined != ST_LABEL_TARGET && label->defined != ST_LABEL_DO_TARGET)\n     {\n-      gfc_error_1 (\"Statement at %L is not a valid branch target statement \"\n+      gfc_error (\"Statement at %L is not a valid branch target statement \"\n \t\t \"for the branch statement at %L\", &label->where, &code->loc);\n       return;\n     }\n@@ -8735,11 +8735,11 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \t{\n \t  if (stack->current->op == EXEC_CRITICAL\n \t      && bitmap_bit_p (stack->reachable_labels, label->value))\n-\t    gfc_error_1 (\"GOTO statement at %L leaves CRITICAL construct for \"\n+\t    gfc_error (\"GOTO statement at %L leaves CRITICAL construct for \"\n \t\t      \"label at %L\", &code->loc, &label->where);\n \t  else if (stack->current->op == EXEC_DO_CONCURRENT\n \t\t   && bitmap_bit_p (stack->reachable_labels, label->value))\n-\t    gfc_error_1 (\"GOTO statement at %L leaves DO CONCURRENT construct \"\n+\t    gfc_error (\"GOTO statement at %L leaves DO CONCURRENT construct \"\n \t\t      \"for label at %L\", &code->loc, &label->where);\n \t}\n \n@@ -8758,13 +8758,13 @@ resolve_branch (gfc_st_label *label, gfc_code *code)\n \t{\n \t  /* Note: A label at END CRITICAL does not leave the CRITICAL\n \t     construct as END CRITICAL is still part of it.  */\n-\t  gfc_error_1 (\"GOTO statement at %L leaves CRITICAL construct for label\"\n+\t  gfc_error (\"GOTO statement at %L leaves CRITICAL construct for label\"\n \t\t      \" at %L\", &code->loc, &label->where);\n \t  return;\n \t}\n       else if (stack->current->op == EXEC_DO_CONCURRENT)\n \t{\n-\t  gfc_error_1 (\"GOTO statement at %L leaves DO CONCURRENT construct for \"\n+\t  gfc_error (\"GOTO statement at %L leaves DO CONCURRENT construct for \"\n \t\t     \"label at %L\", &code->loc, &label->where);\n \t  return;\n \t}\n@@ -10545,7 +10545,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n \n   if (sym->attr.flavor == FL_VARIABLE && gsym->type != GSYM_UNKNOWN)\n     {\n-      gfc_error_1 (\"Variable %s with binding label %s at %L uses the same global \"\n+      gfc_error (\"Variable %s with binding label %s at %L uses the same global \"\n \t\t \"identifier as entity at %L\", sym->name,\n \t\t sym->binding_label, &sym->declared_at, &gsym->where);\n       /* Clear the binding label to prevent checking multiple times.  */\n@@ -10558,7 +10558,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n     {\n       /* This can only happen if the variable is defined in a module - if it\n \t isn't the same module, reject it.  */\n-      gfc_error_1 (\"Variable %s from module %s with binding label %s at %L uses \"\n+      gfc_error (\"Variable %s from module %s with binding label %s at %L uses \"\n \t\t   \"the same global identifier as entity at %L from module %s\",\n \t\t sym->name, module, sym->binding_label,\n \t\t &sym->declared_at, &gsym->where, gsym->mod_name);\n@@ -10575,7 +10575,7 @@ gfc_verify_binding_labels (gfc_symbol *sym)\n       /* Print an error if the procedure is defined multiple times; we have to\n \t exclude references to the same procedure via module association or\n \t multiple checks for the same procedure.  */\n-      gfc_error_1 (\"Procedure %s with binding label %s at %L uses the same \"\n+      gfc_error (\"Procedure %s with binding label %s at %L uses the same \"\n \t\t \"global identifier as entity at %L\", sym->name,\n \t\t sym->binding_label, &sym->declared_at, &gsym->where);\n       sym->binding_label = NULL;\n@@ -11075,7 +11075,7 @@ resolve_fl_variable_derived (gfc_symbol *sym, int no_init_flag)\n \ts = gfc_find_dt_in_generic (s);\n       if (s && s->attr.flavor != FL_DERIVED)\n \t{\n-\t  gfc_error_1 (\"The type '%s' cannot be host associated at %L \"\n+\t  gfc_error (\"The type %qs cannot be host associated at %L \"\n \t\t     \"because it is blocked by an incompatible object \"\n \t\t     \"of the same name declared at %L\",\n \t\t     sym->ts.u.derived->name, &sym->declared_at,\n@@ -11145,7 +11145,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n     {\n       /* The shape of a main program or module array needs to be\n \t constant.  */\n-      gfc_error (\"The module or main program array '%s' at %L must \"\n+      gfc_error (\"The module or main program array %qs at %L must \"\n \t\t \"have constant shape\", sym->name, &sym->declared_at);\n       specification_expr = saved_specification_expr;\n       return false;\n@@ -11194,7 +11194,7 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n \t      && (sym->ns->proc_name->attr.flavor == FL_MODULE\n \t\t  || sym->ns->proc_name->attr.is_main_program))\n \t    {\n-\t      gfc_error (\"'%s' at %L must have constant character length \"\n+\t      gfc_error (\"%qs at %L must have constant character length \"\n \t\t\t\"in this context\", sym->name, &sym->declared_at);\n \t      specification_expr = saved_specification_expr;\n \t      return false;"}, {"sha": "08bdf18b85766c0170903e123dba40aad802145d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -1706,7 +1706,7 @@ gfc_add_type (gfc_symbol *sym, gfc_typespec *ts, locus *where)\n   if (type != BT_UNKNOWN && !(sym->attr.function && sym->attr.implicit_type))\n     {\n       if (sym->attr.use_assoc)\n-\tgfc_error_1 (\"Symbol '%s' at %L conflicts with symbol from module '%s', \"\n+\tgfc_error (\"Symbol %qs at %L conflicts with symbol from module %qs, \"\n \t\t   \"use-associated at %L\", sym->name, where, sym->module,\n \t\t   &sym->declared_at);\n       else\n@@ -1900,7 +1900,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n     {\n       if (strcmp (p->name, name) == 0)\n \t{\n-\t  gfc_error_1 (\"Component '%s' at %C already declared at %L\",\n+\t  gfc_error (\"Component %qs at %C already declared at %L\",\n \t\t     name, &p->loc);\n \t  return false;\n \t}\n@@ -1911,7 +1911,7 @@ gfc_add_component (gfc_symbol *sym, const char *name,\n   if (sym->attr.extension\n \t&& gfc_find_component (sym->components->ts.u.derived, name, true, true))\n     {\n-      gfc_error_1 (\"Component '%s' at %C already in the parent type \"\n+      gfc_error (\"Component %qs at %C already in the parent type \"\n \t\t \"at %L\", name, &sym->components->ts.u.derived->declared_at);\n       return false;\n     }\n@@ -2223,7 +2223,7 @@ gfc_define_st_label (gfc_st_label *lp, gfc_sl_type type, locus *label_locus)\n   labelno = lp->value;\n \n   if (lp->defined != ST_LABEL_UNKNOWN)\n-    gfc_error_1 (\"Duplicate statement label %d at %L and %L\", labelno,\n+    gfc_error (\"Duplicate statement label %d at %L and %L\", labelno,\n \t       &lp->where, label_locus);\n   else\n     {\n@@ -3900,18 +3900,18 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n          J3/04-007, Section 15.2.3, C1505.\t*/\n       if (curr_comp->attr.pointer != 0)\n         {\n-          gfc_error_1 (\"Component '%s' at %L cannot have the \"\n+          gfc_error (\"Component %qs at %L cannot have the \"\n                      \"POINTER attribute because it is a member \"\n-                     \"of the BIND(C) derived type '%s' at %L\",\n+                     \"of the BIND(C) derived type %qs at %L\",\n                      curr_comp->name, &(curr_comp->loc),\n                      derived_sym->name, &(derived_sym->declared_at));\n           retval = false;\n         }\n \n       if (curr_comp->attr.proc_pointer != 0)\n \t{\n-\t  gfc_error_1 (\"Procedure pointer component '%s' at %L cannot be a member\"\n-\t\t     \" of the BIND(C) derived type '%s' at %L\", curr_comp->name,\n+\t  gfc_error (\"Procedure pointer component %qs at %L cannot be a member\"\n+\t\t     \" of the BIND(C) derived type %qs at %L\", curr_comp->name,\n \t\t     &curr_comp->loc, derived_sym->name,\n \t\t     &derived_sym->declared_at);\n           retval = false;\n@@ -3921,9 +3921,9 @@ verify_bind_c_derived_type (gfc_symbol *derived_sym)\n          J3/04-007, Section 15.2.3, C1505.\t*/\n       if (curr_comp->attr.allocatable != 0)\n         {\n-          gfc_error_1 (\"Component '%s' at %L cannot have the \"\n+          gfc_error (\"Component %qs at %L cannot have the \"\n                      \"ALLOCATABLE attribute because it is a member \"\n-                     \"of the BIND(C) derived type '%s' at %L\",\n+                     \"of the BIND(C) derived type %qs at %L\",\n                      curr_comp->name, &(curr_comp->loc),\n                      derived_sym->name, &(derived_sym->declared_at));\n           retval = false;"}, {"sha": "a2bc089cb113fc26890c34cbada4d811a2c9d18f", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fea70c996318f9b987ae9da6d35d6b24ca720f5c/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=fea70c996318f9b987ae9da6d35d6b24ca720f5c", "patch": "@@ -918,8 +918,8 @@ confirm_condition (segment_info *s1, gfc_equiv *eq1, segment_info *s2,\n   offset2 = calculate_offset (eq2->expr);\n \n   if (s1->offset + offset1 != s2->offset + offset2)\n-    gfc_error_1 (\"Inconsistent equivalence rules involving '%s' at %L and \"\n-\t       \"'%s' at %L\", s1->sym->name, &s1->sym->declared_at,\n+    gfc_error (\"Inconsistent equivalence rules involving %qs at %L and \"\n+\t       \"%qs at %L\", s1->sym->name, &s1->sym->declared_at,\n \t       s2->sym->name, &s2->sym->declared_at);\n }\n "}]}