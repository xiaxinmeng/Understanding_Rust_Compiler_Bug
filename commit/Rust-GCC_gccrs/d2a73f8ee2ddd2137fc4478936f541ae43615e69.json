{"sha": "d2a73f8ee2ddd2137fc4478936f541ae43615e69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJhNzNmOGVlMmRkZDIxMzdmYzQ0Nzg5MzZmNTQxYWU0MzYxNWU2OQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1998-09-18T10:27:46Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1998-09-18T10:27:46Z"}, "message": "Fix for PR1654 - implement \"movstrsi\" pattern to copy simple blocks of memory.\n\nFrom-SVN: r22467", "tree": {"sha": "2ba0be0551eaeb5bcbb8b3e569bb2b94b6312275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ba0be0551eaeb5bcbb8b3e569bb2b94b6312275"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2a73f8ee2ddd2137fc4478936f541ae43615e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a73f8ee2ddd2137fc4478936f541ae43615e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a73f8ee2ddd2137fc4478936f541ae43615e69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a73f8ee2ddd2137fc4478936f541ae43615e69/comments", "author": null, "committer": null, "parents": [{"sha": "feaefdd522094b8e2b883ca5bbdd2118dc36d756", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feaefdd522094b8e2b883ca5bbdd2118dc36d756", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feaefdd522094b8e2b883ca5bbdd2118dc36d756"}], "stats": {"total": 325, "additions": 324, "deletions": 1}, "files": [{"sha": "9e844b0e23ab559e5bd8b78aa5803de2864356b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2a73f8ee2ddd2137fc4478936f541ae43615e69", "patch": "@@ -1,3 +1,22 @@\n+Fri Sep 18 09:44:55 1998  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/m32r/m32r.h (m32r_block_immediate_operand): Add to\n+\tPREDICATE_CODES.\n+\n+\t* config/m32r/m32r.md: Add \"movstrsi\" and \"movstrsi_internal\"\n+\tpatterns.\n+\n+\t* config/m32r/m32r.c (m32r_print_operand): Add 's' and 'p'\n+\toperators.\n+\t(block_move_call): New function: Call a library routine to copy a\n+\tblock of memory.\n+\t(m32r_expand_block_move): New function: Expand a \"movstrsi\"\n+\tpattern into a sequence of insns.\n+\t(m32r_output_block_move): New function: Expand a\n+\t\"movstrsi_internal\" pattern into a sequence of assembler opcodes.\n+\t(m32r_block_immediate_operand): New function: Return true if the\n+\tRTL is an integer constant, less than or equal to MAX_MOVE_BYTES.\n+\t\n Thu Sep 17 16:42:16 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* except.c (start_catch_handler): Issue 'fatal' instead of 'error' and"}, {"sha": "41f7ce330ce944ae5bea734a72d3fa03d6faa27b", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 264, "deletions": 1, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=d2a73f8ee2ddd2137fc4478936f541ae43615e69", "patch": "@@ -1783,6 +1783,22 @@ m32r_print_operand (file, x, code)\n \n   switch (code)\n     {\n+      /* The 's' and 'p' codes are used by output_block_move() to\n+\t indicate post-increment 's'tores and 'p're-increment loads.  */\n+    case 's':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"@+%s\", reg_names [REGNO (x)]);\n+      else\n+\toutput_operand_lossage (\"invalid operand to %s code\");\n+      return;\n+      \n+    case 'p':\n+      if (GET_CODE (x) == REG)\n+\tfprintf (file, \"@%s+\", reg_names [REGNO (x)]);\n+      else\n+\toutput_operand_lossage (\"invalid operand to %p code\");\n+      return;\n+\n     case 'R' :\n       /* Write second word of DImode or DFmode reference,\n \t register or memory.  */\n@@ -1822,7 +1838,7 @@ m32r_print_operand (file, x, code)\n \t  rtx first, second;\n \n \t  split_double (x, &first, &second);\n-\t  fprintf (file, \"0x%08lx\",\n+\t  fprintf (file, \"0x%08x\",\n \t\t   code == 'L' ? INTVAL (first) : INTVAL (second));\n \t}\n       else\n@@ -2209,3 +2225,250 @@ emit_cond_move (operands, insn)\n   return buffer;\n }\n \n+\n+\f\n+/* Use a library function to move some bytes.  */\n+static void\n+block_move_call (dest_reg, src_reg, bytes_rtx)\n+     rtx dest_reg;\n+     rtx src_reg;\n+     rtx bytes_rtx;\n+{\n+  /* We want to pass the size as Pmode, which will normally be SImode\n+     but will be DImode if we are using 64 bit longs and pointers.  */\n+  if (GET_MODE (bytes_rtx) != VOIDmode\n+      && GET_MODE (bytes_rtx) != Pmode)\n+    bytes_rtx = convert_to_mode (Pmode, bytes_rtx, 1);\n+\n+#ifdef TARGET_MEM_FUNCTIONS\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"memcpy\"), 0,\n+\t\t     VOIDmode, 3, dest_reg, Pmode, src_reg, Pmode,\n+\t\t     convert_to_mode (TYPE_MODE (sizetype), bytes_rtx,\n+\t\t\t\t      TREE_UNSIGNED (sizetype)),\n+\t\t     TYPE_MODE (sizetype));\n+#else\n+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"bcopy\"), 0,\n+\t\t     VOIDmode, 3, src_reg, Pmode, dest_reg, Pmode,\n+\t\t     convert_to_mode (TYPE_MODE (integer_type_node), bytes_rtx,\n+\t\t\t\t      TREE_UNSIGNED (integer_type_node)),\n+\t\t     TYPE_MODE (integer_type_node));\n+#endif\n+}\n+\n+/* The maximum number of bytes to copy using pairs of load/store instructions.\n+   If a block is larger than this then a loop will be generated to copy\n+   MAX_MOVE_BYTES chunks at a time.  The value of 32 is a semi-arbitary choice.\n+   A customer uses Dhrystome as their benchmark, and Dhrystone has a 31 byte\n+   string copy in it.  */\n+#define MAX_MOVE_BYTES 32\n+\n+/* Expand string/block move operations.\n+\n+   operands[0] is the pointer to the destination.\n+   operands[1] is the pointer to the source.\n+   operands[2] is the number of bytes to move.\n+   operands[3] is the alignment.  */\n+\n+void\n+m32r_expand_block_move (operands)\n+     rtx operands[];\n+{\n+  rtx           orig_dst  = operands[0];\n+  rtx           orig_src  = operands[1];\n+  rtx           bytes_rtx = operands[2];\n+  rtx           align_rtx = operands[3];\n+  int           constp    = GET_CODE (bytes_rtx) == CONST_INT;\n+  HOST_WIDE_INT bytes     = constp ? INTVAL (bytes_rtx) : 0;\n+  int           align     = INTVAL (align_rtx);\n+  int           leftover;\n+  rtx           src_reg;\n+  rtx           dst_reg;\n+\n+  if (constp && bytes <= 0)\n+    return;\n+\n+  /* Move the address into scratch registers.  */\n+  dst_reg = copy_addr_to_reg (XEXP (orig_dst, 0));\n+  src_reg = copy_addr_to_reg (XEXP (orig_src, 0));\n+\n+  if (align > UNITS_PER_WORD)\n+    align = UNITS_PER_WORD;\n+\n+  /* If we prefer size over speed, always use a function call.\n+     If we do not know the size, use a function call.\n+     If the blocks are not word aligned, use a function call.  */\n+  if (optimize_size || ! constp || align != UNITS_PER_WORD)\n+    {\n+      block_move_call (dst_reg, src_reg, bytes_rtx);\n+      return;\n+    }\n+\n+  leftover = bytes % MAX_MOVE_BYTES;\n+  bytes   -= leftover;\n+  \n+  /* If necessary, generate a loop to handle the bulk of the copy.  */\n+  if (bytes)\n+    {\n+      rtx label;\n+      rtx final_src;\n+      \n+      bytes_rtx = GEN_INT (MAX_MOVE_BYTES);\n+\n+      /* If we are going to have to perform this loop more than\n+\t once, then generate a label and compute the address the\n+\t source register will contain upon completion of the final\n+\t itteration.  */\n+      if (bytes > MAX_MOVE_BYTES)\n+\t{\n+\t  final_src = gen_reg_rtx (Pmode);\n+\n+\t  if (INT16_P(bytes))\n+\t    emit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));\n+\t  else\n+\t    {\n+\t      emit_insn (gen_movsi (final_src, bytes_rtx));\n+\t      emit_insn (gen_addsi3 (final_src, final_src, src_reg));\n+\t    }\n+\n+\t  label = gen_label_rtx ();\n+\t  emit_label (label);\n+\t}\n+\n+      /* It is known that output_block_move() will update src_reg to point\n+\t to the word after the end of the source block, and dst_reg to point\n+\t to the last word of the destination block, provided that the block\n+\t is MAX_MOVE_BYTES long.  */\n+      emit_insn (gen_movstrsi_internal (dst_reg, src_reg, bytes_rtx));\n+      emit_insn (gen_addsi3 (dst_reg, dst_reg, GEN_INT (4)));\n+      \n+      if (bytes > MAX_MOVE_BYTES)\n+\t{\n+\t  emit_insn (gen_cmpsi (src_reg, final_src));\n+\t  emit_jump_insn (gen_bne (label));\n+\t}\n+    }\n+\n+  if (leftover)\n+    emit_insn (gen_movstrsi_internal (dst_reg, src_reg, GEN_INT (leftover)));\n+}\n+\n+\f\n+/* Emit load/stores for a small constant word aligned block_move. \n+\n+   operands[0] is the memory address of the destination.\n+   operands[1] is the memory address of the source.\n+   operands[2] is the number of bytes to move.\n+   operands[3] is a temp register.\n+   operands[4] is a temp register.  */\n+\n+char *\n+m32r_output_block_move (insn, operands)\n+     rtx insn;\n+     rtx operands[];\n+{\n+  HOST_WIDE_INT bytes = INTVAL (operands[2]);\n+  int\t\tfirst_time;\n+  int\t\tgot_extra = 0;\n+  \n+  if (bytes < 1 || bytes > MAX_MOVE_BYTES)\n+    abort ();\n+  \n+  /* We do not have a post-increment store available, so the first set of\n+     stores are done without any increment, then the remaining ones can use\n+     the pre-increment addressing mode.\n+     \n+     Note: expand_block_move() also relies upon this behaviour when building\n+     loops to copy large blocks.  */\n+  first_time = 1;\n+  \n+  while (bytes > 0)\n+    {\n+      if (bytes >= 8)\n+\t{\n+\t  if (first_time)\n+\t    {\n+\t      output_asm_insn (\"ld\\t%3, %p1\", operands);\n+\t      output_asm_insn (\"ld\\t%4, %p1\", operands);\n+\t      output_asm_insn (\"st\\t%3, @%0\", operands);\n+\t      output_asm_insn (\"st\\t%4, %s0\", operands);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ld\\t%3, %p1\", operands);\n+\t      output_asm_insn (\"ld\\t%4, %p1\", operands);\n+\t      output_asm_insn (\"st\\t%3, %s0\", operands);\n+\t      output_asm_insn (\"st\\t%4, %s0\", operands);\n+\t    }\n+\n+\t  bytes -= 8;\n+\t}\n+      else if (bytes >= 4)\n+\t{\n+\t  if (bytes > 4)\n+\t    got_extra = 1;\n+\t  \n+\t  output_asm_insn (\"ld\\t%3, %p1\", operands);\n+\t  \n+\t  if (got_extra)\n+\t    output_asm_insn (\"ld\\t%4, %p1\", operands);\n+\t\t\n+\t  if (first_time)\n+\t    output_asm_insn (\"st\\t%3, @%0\", operands);\n+\t  else\n+\t    output_asm_insn (\"st\\t%3, %s0\", operands);\n+\n+\t  bytes -= 4;\n+\t}\n+      else \n+\t{\n+\t  /* Get the entire next word, even though we do not want all of it.\n+\t     The saves us from doing several smaller loads, and we assume that\n+\t     we cannot cause a page fault when at least part of the word is in\n+\t     valid memory.  If got_extra is true then we have already loaded\n+\t     the next word as part of loading and storing the previous word.  */\n+\t  if (! got_extra)\n+\t    output_asm_insn (\"ld\\t%4, @%1\", operands);\n+\n+\t  if (bytes >= 2)\n+\t    {\n+\t      bytes -= 2;\n+\n+\t      output_asm_insn (\"sth\\t%4, @%0\", operands);\n+\t      \n+\t      /* If there is a byte left to store then increment the\n+\t\t destination address and shift the contents of the source\n+\t\t register down by 16 bits.  We could not do the address\n+\t\t increment in the store half word instruction, because it does\n+\t\t not have an auto increment mode.  */\n+\t      if (bytes > 0)  /* assert (bytes == 1) */\n+\t\t{\n+\t\t  output_asm_insn (\"srai\\t%4, #16\", operands);\n+\t\t  output_asm_insn (\"addi\\t%0, #2\", operands);\n+\t\t}\n+\t    }\n+\t  \n+\t  output_asm_insn (\"stb\\t%4, @%0\", operands);\n+\t  \n+\t  bytes = 0;\n+\t}\n+\n+      first_time = 0;\n+    }\n+\n+  return \"\";\n+}\n+\n+/* Return true if op is an integer constant, less than or equal to\n+   MAX_MOVE_BYTES.  */\n+int\n+m32r_block_immediate_operand (op, mode)\n+     rtx op;\n+     int mode;\n+{\n+  if (GET_CODE (op) != CONST_INT\n+      || INTVAL (op) > MAX_MOVE_BYTES\n+      || INTVAL (op) <= 0)\n+    return 0;\n+\n+  return 1;\n+}"}, {"sha": "382f66ef978365301b3171797506e1592d4fda26", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=d2a73f8ee2ddd2137fc4478936f541ae43615e69", "patch": "@@ -1987,6 +1987,7 @@ enum m32r_function_type\n { \"cmp_int16_operand\",\t\t{ CONST_INT }},\t\t\t\t\\\n { \"call_address_operand\",\t{ SYMBOL_REF, LABEL_REF, CONST }},\t\\\n { \"small_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\t\\\n+{ \"m32r_block_immediate_operand\",{ CONST_INT }},\t\t\t\\\n { \"large_insn_p\",\t\t{ INSN, CALL_INSN, JUMP_INSN }},\n \n /* Functions declared in m32r.c */\n@@ -2078,3 +2079,7 @@ extern char *emit_cond_move\t\t\tPROTO((Rtx *, Rtx));\n \n /* Needed by a peephole optimisation.  */\n #define PRESERVE_DEATH_INFO_REGNO_P(regno) (regno < FIRST_PSEUDO_REGISTER)\n+\n+extern char * m32r_output_block_move PROTO((Rtx, Rtx *));\n+extern int    m32r_block_immediate_operand PROTO((Rtx, int));\n+extern void   m32r_expand_block_move PROTO((Rtx *));"}, {"sha": "e1638903ad665eda15c5af76eff0ce10a2faa796", "filename": "gcc/config/m32r/m32r.md", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2Fconfig%2Fm32r%2Fm32r.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2a73f8ee2ddd2137fc4478936f541ae43615e69/gcc%2Fconfig%2Fm32r%2Fm32r.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.md?ref=d2a73f8ee2ddd2137fc4478936f541ae43615e69", "patch": "@@ -1759,3 +1759,39 @@\n    (set_attr \"length\" \"4\")\n   ]\n )\n+\n+;; Block moves, see m32r.c for more details.\n+;; Argument 0 is the destination\n+;; Argument 1 is the source\n+;; Argument 2 is the length\n+;; Argument 3 is the alignment\n+\n+(define_expand \"movstrsi\"\n+  [(parallel [(set (match_operand:BLK 0 \"general_operand\" \"\")\n+\t\t   (match_operand:BLK 1 \"general_operand\" \"\"))\n+\t      (use (match_operand:SI  2 \"immediate_operand\" \"\"))\n+\t      (use (match_operand:SI  3 \"immediate_operand\" \"\"))])]\n+  \"\"\n+  \"\n+{\n+  if (operands[0])\t\t/* avoid unused code messages */\n+    {\n+      m32r_expand_block_move (operands);\n+      DONE;\n+    }\n+}\")\n+\n+;; Insn generated by block moves\n+\n+(define_insn \"movstrsi_internal\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\t;; destination\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\t;; source\n+   (use (match_operand:SI 2 \"m32r_block_immediate_operand\" \"J\"));; # bytes to move\n+   (clobber (match_scratch:SI 3 \"=&r\"))\t\t\t\t;; temp 1\n+   (clobber (match_scratch:SI 4 \"=&r\"))\t\t\t\t;; temp 2\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"* return m32r_output_block_move (insn, operands);\"\n+  [(set_attr \"type\"\t\"store8\")\n+   (set_attr \"length\"\t\"72\")]) ;; Maximum"}]}