{"sha": "a18d0b158091b85fbab45b9fbd6617d919a5a766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTE4ZDBiMTU4MDkxYjg1ZmJhYjQ1YjlmYmQ2NjE3ZDkxOWE1YTc2Ng==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2014-11-20T11:21:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T11:21:41Z"}, "message": "sem_util.adb (Extensions_Visible_Status): Modify the logic to account for non-SPARK code.\n\n2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_util.adb (Extensions_Visible_Status): Modify the logic to account\n\tfor non-SPARK code.\n\t(Object_Access_Level): In ASIS mode, recognize\n\ta selected component with an implicit dereference so that it\n\tyields the same value with and without expansion.\n\nFrom-SVN: r217839", "tree": {"sha": "be1dc98293c1421fa0c2eb23fa6b3522d6b6b43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be1dc98293c1421fa0c2eb23fa6b3522d6b6b43e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a18d0b158091b85fbab45b9fbd6617d919a5a766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a18d0b158091b85fbab45b9fbd6617d919a5a766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a18d0b158091b85fbab45b9fbd6617d919a5a766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a18d0b158091b85fbab45b9fbd6617d919a5a766/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5fde9688e077411aa90e1067b8fb9c1d743e4e7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fde9688e077411aa90e1067b8fb9c1d743e4e7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fde9688e077411aa90e1067b8fb9c1d743e4e7f"}], "stats": {"total": 92, "additions": 52, "deletions": 40}, "files": [{"sha": "7169bf7feb3d746edf907cd33221489ed1101d30", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a18d0b158091b85fbab45b9fbd6617d919a5a766/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a18d0b158091b85fbab45b9fbd6617d919a5a766/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a18d0b158091b85fbab45b9fbd6617d919a5a766", "patch": "@@ -1,3 +1,11 @@\n+2014-11-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_util.adb (Extensions_Visible_Status): Modify the logic to account\n+\tfor non-SPARK code.\n+\t(Object_Access_Level): In ASIS mode, recognize\n+\ta selected component with an implicit dereference so that it\n+\tyields the same value with and without expansion.\n+\n 2014-11-20  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_prag.adb (Analyze_Pragma, case Implemented): In ASIS"}, {"sha": "b2f40e6f1fdb0db8c1359fc563012a32fe715621", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 44, "deletions": 40, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a18d0b158091b85fbab45b9fbd6617d919a5a766/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a18d0b158091b85fbab45b9fbd6617d919a5a766/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a18d0b158091b85fbab45b9fbd6617d919a5a766", "patch": "@@ -5929,68 +5929,62 @@ package body Sem_Util is\n       Subp : Entity_Id;\n \n    begin\n-      if SPARK_Mode = On then\n+      --  When a formal parameter is subject to Extensions_Visible, the pragma\n+      --  is stored in the contract of related subprogram.\n \n-         --  When a formal parameter is subject to Extensions_Visible, the\n-         --  pragma is stored in the contract of related subprogram.\n+      if Is_Formal (Id) then\n+         Subp := Scope (Id);\n \n-         if Is_Formal (Id) then\n-            Subp := Scope (Id);\n+      elsif Is_Subprogram_Or_Generic_Subprogram (Id) then\n+         Subp := Id;\n \n-         elsif Is_Subprogram_Or_Generic_Subprogram (Id) then\n-            Subp := Id;\n+      --  No other construct carries this pragma\n \n-         --  No other construct carries this pragma\n-\n-         else\n-            return Extensions_Visible_None;\n-         end if;\n-\n-         Prag := Get_Pragma (Subp, Pragma_Extensions_Visible);\n-\n-         --  Extract the value from the Boolean expression (if any)\n+      else\n+         return Extensions_Visible_None;\n+      end if;\n \n-         if Present (Prag) then\n-            Arg1 := First (Pragma_Argument_Associations (Prag));\n+      Prag := Get_Pragma (Subp, Pragma_Extensions_Visible);\n \n-            --  The pragma appears with an argument\n+      --  Extract the value from the Boolean expression (if any)\n \n-            if Present (Arg1) then\n-               Expr := Get_Pragma_Arg (Arg1);\n+      if Present (Prag) then\n+         Arg1 := First (Pragma_Argument_Associations (Prag));\n \n-               --  Guarg against cascading errors when the argument of pragma\n-               --  Extensions_Visible is not a valid static Boolean expression.\n+         --  The pragma appears with an argument\n \n-               if Error_Posted (Expr) then\n-                  return Extensions_Visible_None;\n+         if Present (Arg1) then\n+            Expr := Get_Pragma_Arg (Arg1);\n \n-               elsif Is_True (Expr_Value (Expr)) then\n-                  return Extensions_Visible_True;\n+            --  Guard against cascading errors when the argument of pragma\n+            --  Extensions_Visible is not a valid static Boolean expression.\n \n-               else\n-                  return Extensions_Visible_False;\n-               end if;\n+            if Error_Posted (Expr) then\n+               return Extensions_Visible_None;\n \n-            --  Otherwise the pragma defaults to True\n+            elsif Is_True (Expr_Value (Expr)) then\n+               return Extensions_Visible_True;\n \n             else\n-               return Extensions_Visible_True;\n+               return Extensions_Visible_False;\n             end if;\n \n-         --  Otherwise pragma Expresions_Visible is not inherited or directly\n-         --  specified, its value defaults to \"False\".\n+         --  Otherwise the pragma defaults to True\n \n          else\n-            return Extensions_Visible_False;\n+            return Extensions_Visible_True;\n          end if;\n \n-      --  When SPARK_Mode is disabled, all semantic checks related to pragma\n-      --  Extensions_Visible are disabled as well. Instead of saturating the\n-      --  code with \"if SPARK_Mode /= Off then\" checks, the predicate returns\n-      --  a default value.\n+      --  Otherwise pragma Extensions_Visible is not inherited or directly\n+      --  specified. In SPARK code, its value defaults to \"False\".\n+\n+      elsif SPARK_Mode = On then\n+         return Extensions_Visible_False;\n+\n+      --  In non-SPARK code, pragma Extensions_Visible defaults to \"True\"\n \n       else\n-         return Extensions_Visible_None;\n+         return Extensions_Visible_True;\n       end if;\n    end Extensions_Visible_Status;\n \n@@ -15364,10 +15358,20 @@ package body Sem_Util is\n          --  recursive call on the prefix, which will in turn check the level\n          --  of the prefix object of the selected discriminant.\n \n+         --  In Ada 2012, if the discriminant has implicit dereference and\n+         --  the context is a selected component, treat this as an object of\n+         --  unknown scope (see below). This is necessary in compile-only mode;\n+         --  otherwise expansion will already have transformed the prefix into\n+         --  a temporary.\n+\n          if Nkind (Prefix (Obj)) = N_Selected_Component\n            and then Ekind (Etype (Prefix (Obj))) = E_Anonymous_Access_Type\n            and then\n              Ekind (Entity (Selector_Name (Prefix (Obj)))) = E_Discriminant\n+           and then\n+             (not Has_Implicit_Dereference\n+                    (Entity (Selector_Name (Prefix (Obj))))\n+               or else Nkind (Parent (Obj)) /= N_Selected_Component)\n          then\n             return Object_Access_Level (Prefix (Obj));\n "}]}