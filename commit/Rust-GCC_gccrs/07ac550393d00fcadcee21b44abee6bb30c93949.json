{"sha": "07ac550393d00fcadcee21b44abee6bb30c93949", "node_id": "C_kwDOANBUbNoAKDA3YWM1NTAzOTNkMDBmY2FkY2VlMjFiNDRhYmVlNmJiMzBjOTM5NDk", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-06-24T03:14:35Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-07-01T14:49:23Z"}, "message": "c++: dependent generic lambda template-id [PR106024]\n\nWe were wrongly looking up the generic lambda op() in a dependent scope, and\nthen trying to look up its instantiation at substitution time, but lambdas\naren't instantiated, so we crashed.  The fix is to not look into dependent\nclass scopes.\n\nBut this created trouble with wrongly trying to use a template from the\nenclosing scope when we aren't actually looking at a template-argument-list,\nin template/lookup18.C, so let's avoid that.\n\n\tPR c++/106024\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (missing_template_diag): Factor out...\n\t(cp_parser_id_expression): ...from here.\n\t(cp_parser_lookup_name): Don't look in dependent object_type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/lambda-generic10.C: New test.", "tree": {"sha": "7defc84fdface6e8f3b7eddab230e030d3b5418b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7defc84fdface6e8f3b7eddab230e030d3b5418b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07ac550393d00fcadcee21b44abee6bb30c93949", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ac550393d00fcadcee21b44abee6bb30c93949", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ac550393d00fcadcee21b44abee6bb30c93949", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ac550393d00fcadcee21b44abee6bb30c93949/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63abe04999283582b258adf60da6c19d541ebc68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63abe04999283582b258adf60da6c19d541ebc68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63abe04999283582b258adf60da6c19d541ebc68"}], "stats": {"total": 37, "additions": 36, "deletions": 1}, "files": [{"sha": "357fde557c7516ea36799d5c4ce9f7278196cd1e", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ac550393d00fcadcee21b44abee6bb30c93949/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ac550393d00fcadcee21b44abee6bb30c93949/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=07ac550393d00fcadcee21b44abee6bb30c93949", "patch": "@@ -30676,9 +30676,11 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n     }\n   else if (object_type)\n     {\n+      bool dep = dependent_scope_p (object_type);\n+\n       /* Look up the name in the scope of the OBJECT_TYPE, unless the\n \t OBJECT_TYPE is not a class.  */\n-      if (CLASS_TYPE_P (object_type))\n+      if (!dep && CLASS_TYPE_P (object_type))\n \t/* If the OBJECT_TYPE is a template specialization, it may\n \t   be instantiated during name lookup.  In that case, errors\n \t   may be issued.  Even if we rollback the current tentative\n@@ -30702,6 +30704,25 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t\t    : is_template ? LOOK_want::TYPE\n \t\t\t    : prefer_type_arg (tag_type));\n \n+      /* If we did unqualified lookup of a dependent member-qualified name and\n+\t found something, do we want to use it?  P1787 clarified that we need\n+\t to look in the object scope first even if it's dependent, but for now\n+\t let's still use it in some cases.\n+\t FIXME remember unqualified lookup result to use if member lookup fails\n+\t at instantiation time.\t */\n+      if (decl && dep && is_template)\n+\t{\n+\t  saved_token_sentinel toks (parser->lexer, STS_ROLLBACK);\n+\t  /* Only use the unqualified class template lookup if we're actually\n+\t     looking at a template arg list.  */\n+\t  if (!cp_parser_skip_entire_template_parameter_list (parser))\n+\t    decl = NULL_TREE;\n+\t  /* And only use the unqualified lookup if we're looking at ::.  */\n+\t  if (decl\n+\t      && !cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))\n+\t    decl = NULL_TREE;\n+\t}\n+\n       /* If we know we're looking for a type (e.g. A in p->A::x),\n \t mock up a typename.  */\n       if (!decl && object_type && tag_type != none_type"}, {"sha": "47a87bbfbd7599584bae850b440146ce0eb2cbb2", "filename": "gcc/testsuite/g++.dg/cpp2a/lambda-generic10.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ac550393d00fcadcee21b44abee6bb30c93949/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-generic10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ac550393d00fcadcee21b44abee6bb30c93949/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-generic10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Flambda-generic10.C?ref=07ac550393d00fcadcee21b44abee6bb30c93949", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/106024\n+// { dg-do compile { target c++20 } }\n+\n+void sink(...);\n+template <int... args> void f()\n+{\n+  sink ([] <int T> (int...) { return 1; }\n+        .operator()<args>(args...)...); // { dg-warning \"-Wmissing-template-keyword\" }\n+} // { dg-prune-output {expected '\\)'} }\n+\n+int main()\n+{\n+  f<1,2,3>();\n+}"}]}