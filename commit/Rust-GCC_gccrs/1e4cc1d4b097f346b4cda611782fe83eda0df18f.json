{"sha": "1e4cc1d4b097f346b4cda611782fe83eda0df18f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU0Y2MxZDRiMDk3ZjM0NmI0Y2RhNjExNzgyZmU4M2VkYTBkZjE4Zg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-26T21:44:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-26T21:44:20Z"}, "message": "compiler: initial support for exporting function bodies\n    \n    Create a framework for putting function bodies in export data.  At\n    present only empty functions will be put there, and they will be\n    ignored on import.  Later patches will get this to the point of\n    supporting inlining of (some) functions defined in other packages.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/150061\n\nFrom-SVN: r266490", "tree": {"sha": "2d4e3368b005eaf1e957c8b3437f6e03d7026f42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d4e3368b005eaf1e957c8b3437f6e03d7026f42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e4cc1d4b097f346b4cda611782fe83eda0df18f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4cc1d4b097f346b4cda611782fe83eda0df18f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e4cc1d4b097f346b4cda611782fe83eda0df18f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e4cc1d4b097f346b4cda611782fe83eda0df18f/comments", "author": null, "committer": null, "parents": [{"sha": "50e99db39196a0567e844f35ce1cd0f36d066b8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50e99db39196a0567e844f35ce1cd0f36d066b8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50e99db39196a0567e844f35ce1cd0f36d066b8f"}], "stats": {"total": 470, "additions": 454, "deletions": 16}, "files": [{"sha": "89d79def76843e7df73624a6926f1e50e7be06d7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -1,4 +1,4 @@\n-37cb9763cbe8407b8c3a237b05a5272a226f14a0\n+26639de5b48ca895f517b7b5f5720b2613f885ce\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5751488a2a5a96f08778ff7abeadd18bf29ca721", "filename": "gcc/go/gofrontend/export.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fexport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fexport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexport.h?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -286,4 +286,60 @@ class Stream_to_string : public Export::Stream\n   std::string string_;\n };\n \n+// Class to manage exporting a function body.  This is passed around\n+// to Statements and Expressions.  It builds up the export data for\n+// the function.\n+\n+class Export_function_body\n+{\n+ public:\n+  Export_function_body(int indent)\n+    : indent_(indent)\n+  { }\n+\n+  // Write a character to the body.\n+  void\n+  write_char(char c)\n+  { this->body_.append(1, c); }\n+\n+  // Write a NUL terminated string to the body.\n+  void\n+  write_c_string(const char* str)\n+  { this->body_.append(str); }\n+\n+  // Write a string to the body.\n+  void\n+  write_string(const std::string& str)\n+  { this->body_.append(str); }\n+\n+  // Append as many spaces as the current indentation level.\n+  void\n+  indent()\n+  {\n+    for (int i = this->indent_; i > 0; i--)\n+      this->write_char(' ');\n+  }\n+\n+  // Increment the indentation level.\n+  void\n+  increment_indent()\n+  { ++this->indent_; }\n+\n+  // Decrement the indentation level.\n+  void\n+  decrement_indent()\n+  { --this->indent_; }\n+\n+  // Return a reference to the completed body.\n+  const std::string&\n+  body() const\n+  { return this->body_; }\n+\n+ private:\n+  // The body we are building.\n+  std::string body_;\n+  // Current indentation level: the number of spaces before each statement.\n+  int indent_;\n+};\n+\n #endif // !defined(GO_EXPORT_H)"}, {"sha": "33ea9b2db9f7e7aaa3235a8e7e1dc5f86212fb95", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -939,6 +939,11 @@ class Expression\n   copy()\n   { return this->do_copy(); }\n \n+  // Return the cost of this statement for inlining purposes.\n+  int\n+  inlining_cost()\n+  { return this->do_inlining_cost(); }\n+\n   // Return whether the expression is addressable--something which may\n   // be used as the operand of the unary & operator.\n   bool\n@@ -1084,6 +1089,13 @@ class Expression\n   virtual Expression*\n   do_copy() = 0;\n \n+  // Child class implements determining the cost of this statement for\n+  // inlining.  The default cost is high, so we only need to define\n+  // this method for expressions that can be inlined.\n+  virtual int\n+  do_inlining_cost()\n+  { return 0x100000; }\n+\n   // Child class implements whether the expression is addressable.\n   virtual bool\n   do_is_addressable() const"}, {"sha": "354eaba24730489e37d76a0d2cec9c9fa9ec69f6", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 222, "deletions": 7, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -4691,11 +4691,130 @@ Gogo::check_return_statements()\n   this->traverse(&traverse);\n }\n \n+// Traversal class to decide whether a function body is less than the\n+// inlining budget.  This adjusts *available as it goes, and stops the\n+// traversal if it goes negative.\n+\n+class Inline_within_budget : public Traverse\n+{\n+ public:\n+  Inline_within_budget(int* available)\n+    : Traverse(traverse_statements\n+\t       | traverse_expressions),\n+      available_(available)\n+  { }\n+\n+  int\n+  statement(Block*, size_t*, Statement*);\n+\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // Pointer to remaining budget.\n+  int* available_;\n+};\n+\n+// Adjust the budget for the inlining cost of a statement.\n+\n+int\n+Inline_within_budget::statement(Block*, size_t*, Statement* s)\n+{\n+  if (*this->available_ < 0)\n+    return TRAVERSE_EXIT;\n+  *this->available_ -= s->inlining_cost();\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Adjust the budget for the inlining cost of an expression.\n+\n+int\n+Inline_within_budget::expression(Expression** pexpr)\n+{\n+  if (*this->available_ < 0)\n+    return TRAVERSE_EXIT;\n+  *this->available_ -= (*pexpr)->inlining_cost();\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Traversal class to find functions whose body should be exported for\n+// inlining by other packages.\n+\n+class Mark_inline_candidates : public Traverse\n+{\n+ public:\n+  Mark_inline_candidates()\n+    : Traverse(traverse_functions\n+\t       | traverse_types)\n+  { }\n+\n+  int\n+  function(Named_object*);\n+\n+  int\n+  type(Type*);\n+\n+ private:\n+  // We traverse the function body trying to determine how expensive\n+  // it is for inlining.  We start with a budget, and decrease that\n+  // budget for each statement and expression.  If the budget goes\n+  // negative, we do not export the function body.  The value of this\n+  // budget is a heuristic.  In the usual GCC spirit, we could\n+  // consider setting this via a command line option.\n+  const int budget_heuristic = 80;\n+};\n+\n+// Mark a function if it is an inline candidate.\n+\n+int\n+Mark_inline_candidates::function(Named_object* no)\n+{\n+  Function* func = no->func_value();\n+  int budget = budget_heuristic;\n+  Inline_within_budget iwb(&budget);\n+  func->block()->traverse(&iwb);\n+  if (budget >= 0)\n+    func->set_export_for_inlining();\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Mark methods if they are inline candidates.\n+\n+int\n+Mark_inline_candidates::type(Type* t)\n+{\n+  Named_type* nt = t->named_type();\n+  if (nt == NULL || nt->is_alias())\n+    return TRAVERSE_CONTINUE;\n+  const Bindings* methods = nt->local_methods();\n+  if (methods == NULL)\n+    return TRAVERSE_CONTINUE;\n+  for (Bindings::const_definitions_iterator p = methods->begin_definitions();\n+       p != methods->end_definitions();\n+       ++p)\n+    {\n+      Named_object* no = *p;\n+      go_assert(no->is_function());\n+      Function *func = no->func_value();\n+      int budget = budget_heuristic;\n+      Inline_within_budget iwb(&budget);\n+      func->block()->traverse(&iwb);\n+      if (budget >= 0)\n+\tfunc->set_export_for_inlining();\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Export identifiers as requested.\n \n void\n Gogo::do_exports()\n {\n+  // Mark any functions whose body should be exported for inlining by\n+  // other packages.\n+  Mark_inline_candidates mic;\n+  this->traverse(&mic);\n+\n   // For now we always stream to a section.  Later we may want to\n   // support streaming to a separate file.\n   Stream_to_section stream(this->backend());\n@@ -4962,7 +5081,7 @@ Function::Function(Function_type* type, Named_object* enclosing, Block* block,\n     results_are_named_(false), is_unnamed_type_stub_method_(false),\n     calls_recover_(false), is_recover_thunk_(false), has_recover_thunk_(false),\n     calls_defer_retaddr_(false), is_type_specific_function_(false),\n-    in_unique_section_(false)\n+    in_unique_section_(false), export_for_inlining_(false)\n {\n }\n \n@@ -5316,15 +5435,20 @@ Function::defer_stack(Location location)\n void\n Function::export_func(Export* exp, const std::string& name) const\n {\n+  Block* block = NULL;\n+  if (this->export_for_inlining())\n+    block = this->block_;\n   Function::export_func_with_type(exp, name, this->type_,\n-\t\t\t\t  this->is_method() && this->nointerface());\n+\t\t\t\t  this->is_method() && this->nointerface(),\n+\t\t\t\t  block);\n }\n \n // Export a function with a type.\n \n void\n Function::export_func_with_type(Export* exp, const std::string& name,\n-\t\t\t\tconst Function_type* fntype, bool nointerface)\n+\t\t\t\tconst Function_type* fntype, bool nointerface,\n+\t\t\t\tBlock* block)\n {\n   exp->write_c_string(\"func \");\n \n@@ -5404,7 +5528,32 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n \t  exp->write_c_string(\")\");\n \t}\n     }\n-  exp->write_c_string(\"\\n\");\n+\n+  if (block == NULL)\n+    exp->write_c_string(\"\\n\");\n+  else\n+    {\n+      int indent = 1;\n+      if (fntype->is_method())\n+\tindent++;\n+\n+      Export_function_body efb(indent);\n+\n+      efb.indent();\n+      efb.write_c_string(\"// \");\n+      efb.write_string(Linemap::location_to_file(block->start_location()));\n+      efb.write_char('\\n');\n+      block->export_block(&efb);\n+\n+      const std::string& body(efb.body());\n+\n+      char buf[100];\n+      snprintf(buf, sizeof buf, \" <inl:%lu>\\n\",\n+\t       static_cast<unsigned long>(body.length()));\n+      exp->write_c_string(buf);\n+\n+      exp->write_string(body);\n+    }\n }\n \n // Import a function.\n@@ -5480,7 +5629,7 @@ Function::import_func(Import* imp, std::string* pname,\n   *pparameters = parameters;\n \n   Typed_identifier_list* results;\n-  if (imp->peek_char() != ' ')\n+  if (imp->peek_char() != ' ' || imp->match_c_string(\" <inl\"))\n     results = NULL;\n   else\n     {\n@@ -5511,9 +5660,46 @@ Function::import_func(Import* imp, std::string* pname,\n \t  imp->require_c_string(\")\");\n \t}\n     }\n-  imp->require_semicolon_if_old_version();\n-  imp->require_c_string(\"\\n\");\n   *presults = results;\n+\n+  if (!imp->match_c_string(\" <inl:\"))\n+    {\n+      imp->require_semicolon_if_old_version();\n+      imp->require_c_string(\"\\n\");\n+    }\n+  else\n+    {\n+      imp->require_c_string(\" <inl:\");\n+      std::string lenstr;\n+      int c;\n+      while (true)\n+\t{\n+\t  c = imp->peek_char();\n+\t  if (c < '0' || c > '9')\n+\t    break;\n+\t  lenstr += c;\n+\t  imp->get_char();\n+\t}\n+      imp->require_c_string(\">\\n\");\n+\n+      errno = 0;\n+      char* end;\n+      long llen = strtol(lenstr.c_str(), &end, 10);\n+      if (*end != '\\0'\n+\t  || llen < 0\n+\t  || (llen == LONG_MAX && errno == ERANGE))\n+\t{\n+\t  go_error_at(imp->location(), \"invalid inline function length %s\",\n+\t\t      lenstr.c_str());\n+\t  return;\n+\t}\n+\n+      imp->read(static_cast<size_t>(llen));\n+\n+      // Here we should record the body for later parsing if we see a\n+      // call to this function.  This is not yet implemented.  For now\n+      // we just discard the information.\n+    }\n }\n \n // Get the backend representation.\n@@ -6234,6 +6420,35 @@ Block::may_fall_through() const\n   return this->statements_.back()->may_fall_through();\n }\n \n+// Write export data for a block.\n+\n+void\n+Block::export_block(Export_function_body* efb)\n+{\n+  for (Block::iterator p = this->begin();\n+       p != this->end();\n+       ++p)\n+    {\n+      efb->indent();\n+\n+      efb->increment_indent();\n+      (*p)->export_statement(efb);\n+      efb->decrement_indent();\n+\n+      Location loc = (*p)->location();\n+      if ((*p)->is_block_statement())\n+\t{\n+\t  // For a block we put the start location on the first brace\n+\t  // in Block_statement::do_export_statement.  Here we put the\n+\t  // end location on the final brace.\n+\t  loc = (*p)->block_statement()->block()->end_location();\n+\t}\n+      char buf[50];\n+      snprintf(buf, sizeof buf, \" //%d\\n\", Linemap::location_to_line(loc));\n+      efb->write_c_string(buf);\n+    }\n+}\n+\n // Convert a block to the backend representation.\n \n Bblock*"}, {"sha": "1b13e5cd8bde16e8afb827527b9f80b5e23cdf75", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -41,6 +41,7 @@ class Label;\n class Translate_context;\n class Backend;\n class Export;\n+class Export_function_body;\n class Import;\n class Bexpression;\n class Btype;\n@@ -1139,6 +1140,10 @@ class Block\n   bool\n   may_fall_through() const;\n \n+  // Write the export data for the block's statements to the string.\n+  void\n+  export_block(Export_function_body*);\n+\n   // Convert the block to the backend representation.\n   Bblock*\n   get_backend(Translate_context*);\n@@ -1404,6 +1409,16 @@ class Function\n   set_in_unique_section()\n   { this->in_unique_section_ = true; }\n \n+  // Return whether this function should be exported for inlining.\n+  bool\n+  export_for_inlining() const\n+  { return this->export_for_inlining_; }\n+\n+  // Mark the function to be exported for inlining.\n+  void\n+  set_export_for_inlining()\n+  { this->export_for_inlining_ = true; }\n+\n   // Swap with another function.  Used only for the thunk which calls\n   // recover.\n   void\n@@ -1461,7 +1476,7 @@ class Function\n   // Export a function with a type.\n   static void\n   export_func_with_type(Export*, const std::string& name,\n-\t\t\tconst Function_type*, bool nointerface);\n+\t\t\tconst Function_type*, bool nointerface, Block* block);\n \n   // Import a function.\n   static void\n@@ -1539,6 +1554,9 @@ class Function\n   // True if this function should be put in a unique section.  This is\n   // turned on for field tracking.\n   bool in_unique_section_ : 1;\n+  // True if we should export the body of this function for\n+  // cross-package inlining.\n+  bool export_for_inlining_ : 1;\n };\n \n // A snapshot of the current binding state.\n@@ -1654,7 +1672,8 @@ class Function_declaration\n   export_func(Export* exp, const std::string& name) const\n   {\n     Function::export_func_with_type(exp, name, this->fntype_,\n-\t\t\t\t    this->is_method() && this->nointerface());\n+\t\t\t\t    this->is_method() && this->nointerface(),\n+\t\t\t\t    NULL);\n   }\n \n   // Check that the types used in this declaration's signature are defined."}, {"sha": "a0a1f18b49aa921bf41b00a0cb85c7961dd93c69", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -1230,6 +1230,24 @@ Import::read_name()\n   return ret;\n }\n \n+// Read LENGTH bytes from the stream.\n+\n+std::string\n+Import::read(size_t length)\n+{\n+  const char* data;\n+  if (!this->stream_->peek(length, &data))\n+    {\n+      if (!this->stream_->saw_error())\n+\tgo_error_at(this->location_, \"import error at %d: expected %d bytes\",\n+\t\t    this->stream_->pos(), static_cast<int>(length));\n+      this->stream_->set_saw_error();\n+      return \"\";\n+    }\n+  this->advance(length);\n+  return std::string(data, length);\n+}\n+\n // Turn a string into a integer with appropriate error handling.\n \n bool"}, {"sha": "9c6cbfe649fd951466692f453c8e2dae168391f5", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -169,6 +169,11 @@ class Import\n   get_char()\n   { return this->stream_->get_char(); }\n \n+  // Read LENGTH characters into a string and advance past them.  On\n+  // EOF reports an error and returns an empty string.\n+  std::string\n+  read(size_t length);\n+\n   // Return true at the end of the stream.\n   bool\n   at_eof()"}, {"sha": "718139c8cddad93643e7006cbb497725564048ea", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -11,6 +11,7 @@\n #include \"types.h\"\n #include \"expressions.h\"\n #include \"gogo.h\"\n+#include \"export.h\"\n #include \"runtime.h\"\n #include \"backend.h\"\n #include \"statements.h\"\n@@ -1781,6 +1782,27 @@ Statement::make_statement(Expression* expr, bool is_ignored)\n   return new Expression_statement(expr, is_ignored);\n }\n \n+// Export data for a block.\n+\n+void\n+Block_statement::do_export_statement(Export_function_body* efb)\n+{\n+  // We are already indented to the right position.\n+  char buf[50];\n+  snprintf(buf, sizeof buf, \"{ //%d\\n\",\n+\t   Linemap::location_to_line(this->block_->start_location()));\n+  efb->write_c_string(buf);\n+\n+  this->block_->export_block(efb);\n+  // The indentation is correct for the statements in the block, so\n+  // subtract one for the closing curly brace.\n+  efb->decrement_indent();\n+  efb->indent();\n+  efb->write_c_string(\"}\");\n+  // Increment back to the value the caller thinks it has.\n+  efb->increment_indent();\n+}\n+\n // Convert a block to the backend representation of a statement.\n \n Bstatement*"}, {"sha": "ff57a21b6bc18b9333ad821c434a3e2036067341", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -15,6 +15,7 @@ class Statement_inserter;\n class Block;\n class Function;\n class Unnamed_label;\n+class Export_function_body;\n class Assignment_statement;\n class Temporary_statement;\n class Variable_declaration_statement;\n@@ -326,6 +327,17 @@ class Statement\n   check_types(Gogo* gogo)\n   { this->do_check_types(gogo); }\n \n+  // Return the cost of this statement for inlining purposes.\n+  int\n+  inlining_cost()\n+  { return this->do_inlining_cost(); }\n+\n+  // Export data for this statement to BODY.  INDENT is an indentation\n+  // level used if the export data requires multiple lines.\n+  void\n+  export_statement(Export_function_body* efb)\n+  { this->do_export_statement(efb); }\n+\n   // Return whether this is a block statement.\n   bool\n   is_block_statement() const\n@@ -488,6 +500,22 @@ class Statement\n   do_check_types(Gogo*)\n   { }\n \n+  // Implemented by child class: return the cost of this statement for\n+  // inlining.  The default cost is high, so we only need to define\n+  // this method for statements that can be inlined.\n+  virtual int\n+  do_inlining_cost()\n+  { return 0x100000; }\n+\n+  // Implemented by child class: write export data for this statement\n+  // to the string.  The integer is an indentation level used if the\n+  // export data requires multiple lines.  This need only be\n+  // implemented by classes that implement do_inlining_cost with a\n+  // reasonable value.\n+  virtual void\n+  do_export_statement(Export_function_body*)\n+  { go_unreachable(); }\n+\n   // Implemented by child class: return true if this statement may\n   // fall through.\n   virtual bool\n@@ -819,6 +847,11 @@ class Block_statement : public Statement\n       block_(block), is_lowered_for_statement_(false)\n   { }\n \n+  // Return the actual block.\n+  Block*\n+  block() const\n+  { return this->block_; }\n+\n   void\n   set_is_lowered_for_statement()\n   { this->is_lowered_for_statement_ = true; }\n@@ -836,6 +869,13 @@ class Block_statement : public Statement\n   do_determine_types()\n   { this->block_->determine_types(); }\n \n+  int\n+  do_inlining_cost()\n+  { return 0; }\n+\n+  void\n+  do_export_statement(Export_function_body*);\n+\n   bool\n   do_may_fall_through() const\n   { return this->block_->may_fall_through(); }"}, {"sha": "c23002fb52be9b4472a4693b11b478512270f804", "filename": "libgo/go/go/internal/gccgoimporter/parser.go", "status": "modified", "additions": 57, "deletions": 6, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e4cc1d4b097f346b4cda611782fe83eda0df18f/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e4cc1d4b097f346b4cda611782fe83eda0df18f/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Finternal%2Fgccgoimporter%2Fparser.go?ref=1e4cc1d4b097f346b4cda611782fe83eda0df18f", "patch": "@@ -15,6 +15,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"text/scanner\"\n+\t\"unicode/utf8\"\n )\n \n type parser struct {\n@@ -41,7 +42,7 @@ func (p *parser) init(filename string, src io.Reader, imports map[string]*types.\n func (p *parser) initScanner(filename string, src io.Reader) {\n \tp.scanner.Init(src)\n \tp.scanner.Error = func(_ *scanner.Scanner, msg string) { p.error(msg) }\n-\tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings | scanner.ScanComments | scanner.SkipComments\n+\tp.scanner.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats | scanner.ScanStrings\n \tp.scanner.Whitespace = 1<<'\\t' | 1<<' '\n \tp.scanner.Filename = filename // for good error messages\n \tp.next()\n@@ -393,7 +394,7 @@ func (p *parser) parseConst(pkg *types.Package) *types.Const {\n \n // NamedType = TypeName [ \"=\" ] Type { Method } .\n // TypeName  = ExportedName .\n-// Method    = \"func\" \"(\" Param \")\" Name ParamList ResultList \";\" .\n+// Method    = \"func\" \"(\" Param \")\" Name ParamList ResultList [InlineBody] \";\" .\n func (p *parser) parseNamedType(n int) types.Type {\n \tpkg, name := p.parseExportedName()\n \tscope := pkg.Scope()\n@@ -455,6 +456,7 @@ func (p *parser) parseNamedType(n int) types.Type {\n \t\t\tname := p.parseName()\n \t\t\tparams, isVariadic := p.parseParamList(pkg)\n \t\t\tresults := p.parseResultList(pkg)\n+\t\t\tp.skipInlineBody()\n \t\t\tp.expectEOL()\n \n \t\t\tsig := types.NewSignature(receiver, params, results, isVariadic)\n@@ -566,7 +568,11 @@ func (p *parser) parseParamList(pkg *types.Package) (*types.Tuple, bool) {\n func (p *parser) parseResultList(pkg *types.Package) *types.Tuple {\n \tswitch p.tok {\n \tcase '<':\n-\t\treturn types.NewTuple(types.NewParam(token.NoPos, pkg, \"\", p.parseType(pkg)))\n+\t\tp.next()\n+\t\tif p.tok == scanner.Ident && p.lit == \"inl\" {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn types.NewTuple(types.NewParam(token.NoPos, pkg, \"\", p.parseTypeAfterAngle(pkg)))\n \n \tcase '(':\n \t\tparams, _ := p.parseParamList(pkg)\n@@ -584,7 +590,7 @@ func (p *parser) parseFunctionType(pkg *types.Package) *types.Signature {\n \treturn types.NewSignature(nil, params, results, isVariadic)\n }\n \n-// Func = Name FunctionType .\n+// Func = Name FunctionType [InlineBody] .\n func (p *parser) parseFunc(pkg *types.Package) *types.Func {\n \tname := p.parseName()\n \tif strings.ContainsRune(name, '$') {\n@@ -593,7 +599,9 @@ func (p *parser) parseFunc(pkg *types.Package) *types.Func {\n \t\tp.discardDirectiveWhileParsingTypes(pkg)\n \t\treturn nil\n \t}\n-\treturn types.NewFunc(token.NoPos, pkg, name, p.parseFunctionType(pkg))\n+\tf := types.NewFunc(token.NoPos, pkg, name, p.parseFunctionType(pkg))\n+\tp.skipInlineBody()\n+\treturn f\n }\n \n // InterfaceType = \"interface\" \"{\" { (\"?\" Type | Func) \";\" } \"}\" .\n@@ -717,8 +725,13 @@ func lookupBuiltinType(typ int) types.Type {\n }\n \n // Type = \"<\" \"type\" ( \"-\" int | int [ TypeDefinition ] ) \">\" .\n-func (p *parser) parseType(pkg *types.Package) (t types.Type) {\n+func (p *parser) parseType(pkg *types.Package) types.Type {\n \tp.expect('<')\n+\treturn p.parseTypeAfterAngle(pkg)\n+}\n+\n+// (*parser).Type after reading the \"<\".\n+func (p *parser) parseTypeAfterAngle(pkg *types.Package) (t types.Type) {\n \tp.expectKeyword(\"type\")\n \n \tswitch p.tok {\n@@ -748,6 +761,39 @@ func (p *parser) parseType(pkg *types.Package) (t types.Type) {\n \treturn\n }\n \n+// InlineBody = \"<inl:NN>\" .{NN}\n+// Reports whether a body was skipped.\n+func (p *parser) skipInlineBody() {\n+\t// We may or may not have seen the '<' already, depending on\n+\t// whether the function had a result type or not.\n+\tif p.tok == '<' {\n+\t\tp.next()\n+\t\tp.expectKeyword(\"inl\")\n+\t} else if p.tok != scanner.Ident || p.lit != \"inl\" {\n+\t\treturn\n+\t} else {\n+\t\tp.next()\n+\t}\n+\n+\tp.expect(':')\n+\twant := p.parseInt()\n+\tp.expect('>')\n+\n+\tdefer func(w uint64) {\n+\t\tp.scanner.Whitespace = w\n+\t}(p.scanner.Whitespace)\n+\tp.scanner.Whitespace = 0\n+\n+\tgot := int64(0)\n+\tfor got < want {\n+\t\tr := p.scanner.Next()\n+\t\tif r == scanner.EOF {\n+\t\t\tp.error(\"unexpected EOF\")\n+\t\t}\n+\t\tgot += int64(utf8.RuneLen(r))\n+\t}\n+}\n+\n // Types = \"types\" maxp1 exportedp1 (offset length)* .\n func (p *parser) parseTypes(pkg *types.Package) {\n \tmaxp1 := p.parseInt()\n@@ -766,6 +812,11 @@ func (p *parser) parseTypes(pkg *types.Package) {\n \t\ttotal += len\n \t}\n \n+\tdefer func(w uint64) {\n+\t\tp.scanner.Whitespace = w\n+\t}(p.scanner.Whitespace)\n+\tp.scanner.Whitespace = 0\n+\n \t// We should now have p.tok pointing to the final newline.\n \t// The next runes from the scanner should be the type data.\n "}]}