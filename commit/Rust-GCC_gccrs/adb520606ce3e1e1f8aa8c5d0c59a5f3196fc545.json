{"sha": "adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRiNTIwNjA2Y2UzZTFlMWY4YWE4YzVkMGM1OWE1ZjMxOTZmYzU0NQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-15T18:20:29Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-01-15T18:21:58Z"}, "message": "c-family: Improve MEM_REF printing for diagnostics [PR98597]\n\nOk, here is an updated patch which fixes what I found, and implements what\nhas been discussed on the mailing list and on IRC, i.e. if the types\nare compatible as well as alias sets are same, then it prints\nwhat c_fold_indirect_ref_for_warn managed to create, otherwise it uses\nthat info for printing offsets using offsetof (except when it starts\nwith ARRAY_REFs, because one can't have offsetof (struct T[2][2], [1][0].x.y)\n\nThe uninit-38.c test (which was the only one I believe which had tests on the\nexact spelling of MEM_REF printing) contains mainly changes to have space\nbefore * for pointer types (as that is how the C pretty-printers normally\nprint types, int * rather than int*), plus what might be considered a\nregression from what Martin printed, but it is actually a correctness fix.\n\nWhen the arg is a pointer with type pointer to VLA with char element type\n(let's say the pointer is p), which is what happens in several of the\nuninit-38.c tests, omitting the (char *) cast is incorrect, as p + 1\nis not the 1 byte after p, but pointer to the end of the VLA.\nIt only happened to work because of the hacks (which I don't like at all\nand are dangerous, DECL_ARTIFICIAL var names with dot inside can be pretty\nmuch anything, e.g. a lot of passes construct their helper vars from some\nprefix that designates intended use of the var plus numeric suffix), where\nthe a.1 pointer to VLA is printed as a which if one is lucky happens to be\na variable with VLA type (rather than pointer to it), and for such vars\na + 1 is indeed &a[0] + 1 rather than &a + 1.  But if we want to do this\nreliably, we'd need to make sure it comes from VLA (e.g. verify that the\nSSA_NAME is defined to __builtin_alloca_with_align and that there exists\na corresponding VAR_DECL with DECL_VALUE_EXPR that has the a.1 variable\nin it).\n\n2021-01-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR tree-optimization/98597\n\t* c-pretty-print.c: Include options.h.\n\t(c_fold_indirect_ref_for_warn): New function.\n\t(print_mem_ref): Use it.  If it returns something that has compatible\n\ttype and is TBAA compatible with zero offset, print it and return,\n\totherwise print it using offsetof syntax or array ref syntax.  Fix up\n\tprinting if MEM_REFs first operand is ADDR_EXPR, or when the first\n\targument has pointer to array type.  Print pointers using the standard\n\tformatting.\n\n\t* gcc.dg/uninit-38.c: Expect a space in between type name and asterisk.\n\tExpect for now a (char *) cast for VLAs.\n\t* gcc.dg/uninit-40.c: New test.", "tree": {"sha": "ca46d32785edc12fda0caeed41757b29e56f73ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca46d32785edc12fda0caeed41757b29e56f73ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50dbced2f37ba9c4b9756c523a7a06b036151d2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50dbced2f37ba9c4b9756c523a7a06b036151d2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50dbced2f37ba9c4b9756c523a7a06b036151d2d"}], "stats": {"total": 389, "additions": 301, "deletions": 88}, "files": [{"sha": "5a51c05fd754633dd09329a0003d4a516553b7b9", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 211, "deletions": 48, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pretty-print.h\"\n #include \"selftest.h\"\n #include \"langhooks.h\"\n+#include \"options.h\"\n \n /* The pretty-printer code is primarily designed to closely follow\n    (GNU) C and C++ grammars.  That is to be contrasted with spaghetti\n@@ -1809,6 +1810,113 @@ pp_c_call_argument_list (c_pretty_printer *pp, tree t)\n   pp_c_right_paren (pp);\n }\n \n+/* Try to fold *(type *)&op into op.fld.fld2[1] if possible.\n+   Only used for printing expressions.  Should punt if ambiguous\n+   (e.g. in unions).  */\n+\n+static tree\n+c_fold_indirect_ref_for_warn (location_t loc, tree type, tree op,\n+\t\t\t      offset_int &off)\n+{\n+  tree optype = TREE_TYPE (op);\n+  if (off == 0)\n+    {\n+      if (lang_hooks.types_compatible_p (optype, type))\n+\treturn op;\n+      /* *(foo *)&complexfoo => __real__ complexfoo */\n+      else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t       && lang_hooks.types_compatible_p (type, TREE_TYPE (optype)))\n+\treturn build1_loc (loc, REALPART_EXPR, type, op);\n+    }\n+  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */\n+  else if (TREE_CODE (optype) == COMPLEX_TYPE\n+\t   && lang_hooks.types_compatible_p (type, TREE_TYPE (optype))\n+\t   && tree_to_uhwi (TYPE_SIZE_UNIT (type)) == off)\n+    {\n+      off = 0;\n+      return build1_loc (loc, IMAGPART_EXPR, type, op);\n+    }\n+  /* ((foo *)&fooarray)[x] => fooarray[x] */\n+  if (TREE_CODE (optype) == ARRAY_TYPE\n+      && TYPE_SIZE_UNIT (TREE_TYPE (optype))\n+      && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (optype))) == INTEGER_CST\n+      && !integer_zerop (TYPE_SIZE_UNIT (TREE_TYPE (optype))))\n+    {\n+      tree type_domain = TYPE_DOMAIN (optype);\n+      tree min_val = size_zero_node;\n+      if (type_domain && TYPE_MIN_VALUE (type_domain))\n+\tmin_val = TYPE_MIN_VALUE (type_domain);\n+      offset_int el_sz = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (optype)));\n+      offset_int idx = off / el_sz;\n+      offset_int rem = off % el_sz;\n+      if (TREE_CODE (min_val) == INTEGER_CST)\n+\t{\n+\t  tree index\n+\t    = wide_int_to_tree (sizetype, idx + wi::to_offset (min_val));\n+\t  op = build4_loc (loc, ARRAY_REF, TREE_TYPE (optype), op, index,\n+\t\t\t   NULL_TREE, NULL_TREE);\n+\t  off = rem;\n+\t  if (tree ret = c_fold_indirect_ref_for_warn (loc, type, op, off))\n+\t    return ret;\n+\t  return op;\n+\t}\n+    }\n+  /* ((foo *)&struct_with_foo_field)[x] => COMPONENT_REF */\n+  else if (TREE_CODE (optype) == RECORD_TYPE)\n+    {\n+      for (tree field = TYPE_FIELDS (optype);\n+\t   field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && TREE_TYPE (field) != error_mark_node\n+\t    && TYPE_SIZE_UNIT (TREE_TYPE (field))\n+\t    && TREE_CODE (TYPE_SIZE_UNIT (TREE_TYPE (field))) == INTEGER_CST)\n+\t  {\n+\t    tree pos = byte_position (field);\n+\t    if (TREE_CODE (pos) != INTEGER_CST)\n+\t      continue;\n+\t    offset_int upos = wi::to_offset (pos);\n+\t    offset_int el_sz\n+\t      = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (field)));\n+\t    if (upos <= off && off < upos + el_sz)\n+\t      {\n+\t\ttree cop = build3_loc (loc, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t\t       op, field, NULL_TREE);\n+\t\toff = off - upos;\n+\t\tif (tree ret = c_fold_indirect_ref_for_warn (loc, type, cop,\n+\t\t\t\t\t\t\t     off))\n+\t\t  return ret;\n+\t\treturn cop;\n+\t      }\n+\t  }\n+    }\n+  /* Similarly for unions, but in this case try to be very conservative,\n+     only match if some field has type compatible with type and it is the\n+     only such field.  */\n+  else if (TREE_CODE (optype) == UNION_TYPE)\n+    {\n+      tree fld = NULL_TREE;\n+      for (tree field = TYPE_FIELDS (optype);\n+\t   field; field = DECL_CHAIN (field))\n+\tif (TREE_CODE (field) == FIELD_DECL\n+\t    && TREE_TYPE (field) != error_mark_node\n+\t    && lang_hooks.types_compatible_p (TREE_TYPE (field), type))\n+\t  {\n+\t    if (fld)\n+\t      return NULL_TREE;\n+\t    else\n+\t      fld = field;\n+\t  }\n+      if (fld)\n+\t{\n+\t  off = 0;\n+\t  return build3_loc (loc, COMPONENT_REF, TREE_TYPE (fld), op, fld,\n+\t\t\t     NULL_TREE);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Print the MEM_REF expression REF, including its type and offset.\n    Apply casts as necessary if the type of the access is different\n    from the type of the accessed object.  Produce compact output\n@@ -1833,59 +1941,81 @@ print_mem_ref (c_pretty_printer *pp, tree e)\n   offset_int elt_idx = 0;\n   /* True to include a cast to char* (for a nonzero final BYTE_OFF).  */\n   bool char_cast = false;\n-  const bool addr = TREE_CODE (arg) == ADDR_EXPR;\n-  if (addr)\n+  tree op = NULL_TREE;\n+  bool array_ref_only = false;\n+  if (TREE_CODE (arg) == ADDR_EXPR)\n     {\n-      arg = TREE_OPERAND (arg, 0);\n-      if (byte_off == 0)\n+      op = c_fold_indirect_ref_for_warn (EXPR_LOCATION (e), TREE_TYPE (e),\n+\t\t\t\t\t TREE_OPERAND (arg, 0), byte_off);\n+      /* Try to fold it back to component, array ref or their combination,\n+\t but print it only if the types and TBAA types are compatible.  */\n+      if (op\n+\t  && byte_off == 0\n+\t  && lang_hooks.types_compatible_p (TREE_TYPE (e), TREE_TYPE (op))\n+\t  && (!flag_strict_aliasing\n+\t      || (get_deref_alias_set (TREE_OPERAND (e, 1))\n+\t\t  == get_alias_set (op))))\n \t{\n-\t  pp->expression (arg);\n+\t  pp->expression (op);\n \t  return;\n \t}\n+      if (op == NULL_TREE)\n+\top = TREE_OPERAND (arg, 0);\n+      /* If the types or TBAA types are incompatible, undo the\n+\t UNION_TYPE handling from c_fold_indirect_ref_for_warn, and similarly\n+\t undo __real__/__imag__ the code below doesn't try to handle.  */\n+      if (op != TREE_OPERAND (arg, 0)\n+\t  && ((TREE_CODE (op) == COMPONENT_REF\n+\t       && TREE_CODE (TREE_TYPE (TREE_OPERAND (op, 0))) == UNION_TYPE)\n+\t      || TREE_CODE (op) == REALPART_EXPR\n+\t      || TREE_CODE (op) == IMAGPART_EXPR))\n+\top = TREE_OPERAND (op, 0);\n+      if (op != TREE_OPERAND (arg, 0))\n+\t{\n+\t  array_ref_only = true;\n+\t  for (tree ref = op; ref != TREE_OPERAND (arg, 0);\n+\t       ref = TREE_OPERAND (ref, 0))\n+\t    if (TREE_CODE (ref) != ARRAY_REF)\n+\t      {\n+\t\tarray_ref_only = false;\n+\t\tbreak;\n+\t      }\n+\t}\n     }\n \n   tree access_type = TREE_TYPE (e);\n-  if (TREE_CODE (access_type) == ARRAY_TYPE)\n-    access_type = TREE_TYPE (access_type);\n-  tree arg_type = TREE_TYPE (arg);\n-  if (POINTER_TYPE_P (arg_type))\n-    arg_type = TREE_TYPE (arg_type);\n-  if (TREE_CODE (arg_type) == ARRAY_TYPE)\n-    arg_type = TREE_TYPE (arg_type);\n+  tree arg_type = TREE_TYPE (TREE_TYPE (arg));\n   if (tree access_size = TYPE_SIZE_UNIT (access_type))\n-    if (TREE_CODE (access_size) == INTEGER_CST)\n+    if (byte_off != 0\n+\t&& TREE_CODE (access_size) == INTEGER_CST\n+\t&& !integer_zerop (access_size))\n       {\n-\t/* For naturally aligned accesses print the nonzero offset\n-\t   in units of the accessed type, in the form of an index.\n-\t   For unaligned accesses also print the residual byte offset.  */\n \toffset_int asize = wi::to_offset (access_size);\n-\toffset_int szlg2 = wi::floor_log2 (asize);\n-\n-\telt_idx = byte_off >> szlg2;\n-\tbyte_off = byte_off - (elt_idx << szlg2);\n+\telt_idx = byte_off / asize;\n+\tbyte_off = byte_off % asize;\n       }\n \n   /* True to include a cast to the accessed type.  */\n-  const bool access_cast = VOID_TYPE_P (arg_type)\n-    || TYPE_MAIN_VARIANT (access_type) != TYPE_MAIN_VARIANT (arg_type);\n+  const bool access_cast\n+    = ((op && op != TREE_OPERAND (arg, 0))\n+       || VOID_TYPE_P (arg_type)\n+       || !lang_hooks.types_compatible_p (access_type, arg_type));\n+  const bool has_off = byte_off != 0 || (op && op != TREE_OPERAND (arg, 0));\n \n-  if (byte_off != 0)\n+  if (has_off && (byte_off != 0 || !array_ref_only))\n     {\n       /* When printing the byte offset for a pointer to a type of\n \t a different size than char, include a cast to char* first,\n \t before printing the cast to a pointer to the accessed type.  */\n-      offset_int arg_size = 0;\n-      if (tree size = TYPE_SIZE (arg_type))\n-\targ_size = wi::to_offset (size);\n-      if (arg_size != BITS_PER_UNIT)\n+      tree size = TYPE_SIZE (arg_type);\n+      if (size == NULL_TREE\n+\t  || TREE_CODE (size) != INTEGER_CST\n+\t  || wi::to_wide (size) != BITS_PER_UNIT)\n \tchar_cast = true;\n     }\n \n   if (elt_idx == 0)\n-    {\n-      if (!addr)\n-\tpp_c_star (pp);\n-    }\n+    pp_c_star (pp);\n   else if (access_cast || char_cast)\n     pp_c_left_paren (pp);\n \n@@ -1895,51 +2025,84 @@ print_mem_ref (c_pretty_printer *pp, tree e)\n \t with the type of the referenced object (or if the object\n \t is typeless).  */\n       pp_c_left_paren (pp);\n-      pp->type_id (access_type);\n-      pp_c_star (pp);\n+      pp->type_id (build_pointer_type (access_type));\n       pp_c_right_paren (pp);\n     }\n \n-  if (byte_off != 0)\n+  if (has_off)\n     pp_c_left_paren (pp);\n \n   if (char_cast)\n     {\n-      /* Include a cast to char*.  */\n+      /* Include a cast to char *.  */\n       pp_c_left_paren (pp);\n-      pp->type_id (char_type_node);\n-      pp_c_star (pp);\n+      pp->type_id (string_type_node);\n       pp_c_right_paren (pp);\n     }\n \n   pp->unary_expression (arg);\n \n+  if (op && op != TREE_OPERAND (arg, 0))\n+    {\n+      auto_vec<tree, 16> refs;\n+      tree ref;\n+      unsigned i;\n+      bool array_refs = true;\n+      for (ref = op; ref != TREE_OPERAND (arg, 0); ref = TREE_OPERAND (ref, 0))\n+\trefs.safe_push (ref);\n+      FOR_EACH_VEC_ELT_REVERSE (refs, i, ref)\n+\tif (array_refs && TREE_CODE (ref) == ARRAY_REF)\n+\t  {\n+\t    pp_c_left_bracket (pp);\n+\t    pp->expression (TREE_OPERAND (ref, 1));\n+\t    pp_c_right_bracket (pp);\n+\t  }\n+\telse\n+\t  {\n+\t    if (array_refs)\n+\t      {\n+\t\tarray_refs = false;\n+\t\tpp_string (pp, \" + offsetof\");\n+\t\tpp_c_left_paren (pp);\n+\t\tpp->type_id (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+\t\tpp_comma (pp);\n+\t      }\n+\t    else if (TREE_CODE (ref) == COMPONENT_REF)\n+\t      pp_c_dot (pp);\n+\t    if (TREE_CODE (ref) == COMPONENT_REF)\n+\t      pp->expression (TREE_OPERAND (ref, 1));\n+\t    else\n+\t      {\n+\t\tpp_c_left_bracket (pp);\n+\t\tpp->expression (TREE_OPERAND (ref, 1));\n+\t\tpp_c_right_bracket (pp);\n+\t      }\n+\t  }\n+      if (!array_refs)\n+\tpp_c_right_paren (pp);\n+    }\n+\n   if (byte_off != 0)\n     {\n       pp_space (pp);\n       pp_plus (pp);\n       pp_space (pp);\n       tree off = wide_int_to_tree (ssizetype, byte_off);\n       pp->constant (off);\n-      pp_c_right_paren (pp);\n     }\n+\n+  if (has_off)\n+    pp_c_right_paren (pp);\n+\n   if (elt_idx != 0)\n     {\n       if (access_cast || char_cast)\n \tpp_c_right_paren (pp);\n \n-      if (addr)\n-\t{\n-\t  pp_space (pp);\n-\t  pp_plus (pp);\n-\t  pp_space (pp);\n-\t}\n-      else\n-\tpp_c_left_bracket (pp);\n+      pp_c_left_bracket (pp);\n       tree idx = wide_int_to_tree (ssizetype, elt_idx);\n       pp->constant (idx);\n-      if (!addr)\n-\tpp_c_right_bracket (pp);\n+      pp_c_right_bracket (pp);\n     }\n }\n "}, {"sha": "8dacc8c63a6ee32785ede8fc8499f9da3dc70ffd", "filename": "gcc/testsuite/gcc.dg/uninit-38.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-38.c?ref=adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "patch": "@@ -29,28 +29,28 @@ void sink (void*, ...);\n   }\t\t\t\t\t\t\\\n   typedef void dummy_type\n \n-T (int, 0, 0);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)p' is used uninitialized\" }\n-T (int, 0, 1);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)'\" }\n-T (int, 0, 2);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)'\" }\n-T (int, 0, 3);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)'\" }\n-T (int, 0, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[1]'\" }\n-T (int, 0, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 0, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 0, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 0, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[2]'\" }\n-T (int, 0, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 0, 0);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)p' is used uninitialized\" }\n+T (int, 0, 1);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 1\\\\)'\" }\n+T (int, 0, 2);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 2\\\\)'\" }\n+T (int, 0, 3);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 3\\\\)'\" }\n+T (int, 0, 4);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)p\\\\)\\\\\\[1]'\" }\n+T (int, 0, 5);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 6);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 7);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 8);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)p\\\\)\\\\\\[2]'\" }\n+T (int, 0, 9);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n \n \n-T (int, 1, 0);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[1]' is used uninitialized\" }\n-T (int, 1, 1);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 1, 2);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 1, 3);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 1, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[2]'\" }\n-T (int, 1, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n-T (int, 1, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[2]'\" }\n-T (int, 1, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[2]'\" }\n-T (int, 1, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)p\\\\)\\\\\\[3]'\" }\n-T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[3]'\" }\n+T (int, 1, 0);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)p\\\\)\\\\\\[1]' is used uninitialized\" }\n+T (int, 1, 1);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 2);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 3);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 4);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)p\\\\)\\\\\\[2]'\" }\n+T (int, 1, 5);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 6);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 2\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 7);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 3\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 8);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)p\\\\)\\\\\\[3]'\" }\n+T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)p \\\\+ 1\\\\)\\\\)\\\\\\[3]'\" }\n \n #undef T\n #define T(Type, idx, off)\t\t\t\\\n@@ -63,25 +63,25 @@ T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(\\\\(char\\\\*\\\\)p \\\\+ 1\\\\)\\\n   }\t\t\t\t\t\t\\\n   typedef void dummy_type\n \n-T (int, 0, 0);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)a' is used uninitialized\" }\n-T (int, 0, 1);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)'\" }\n-T (int, 0, 2);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)'\" }\n-T (int, 0, 3);      // { dg-warning \"'\\\\*\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)'\" }\n-T (int, 0, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[1]'\" }\n-T (int, 0, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 0, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 0, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 0, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[2]'\" }\n-T (int, 0, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 0, 0);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)a' is used uninitialized\" }\n+T (int, 0, 1);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 1\\\\)'\" }\n+T (int, 0, 2);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 2\\\\)'\" }\n+T (int, 0, 3);      // { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 3\\\\)'\" }\n+T (int, 0, 4);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)a\\\\)\\\\\\[1]'\" }\n+T (int, 0, 5);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 6);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 7);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 0, 8);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)a\\\\)\\\\\\[2]'\" }\n+T (int, 0, 9);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n \n \n-T (int, 1, 0);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[1]' is used uninitialized\" }\n-T (int, 1, 1);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 1, 2);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 1, 3);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n-T (int, 1, 4);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[2]'\" }\n-T (int, 1, 5);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n-T (int, 1, 6);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 2\\\\)\\\\)\\\\\\[2]'\" }\n-T (int, 1, 7);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 3\\\\)\\\\)\\\\\\[2]'\" }\n-T (int, 1, 8);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)a\\\\)\\\\\\[3]'\" }\n-T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int\\\\*\\\\)\\\\(a \\\\+ 1\\\\)\\\\)\\\\\\[3]'\" }\n+T (int, 1, 0);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)a\\\\)\\\\\\[1]' is used uninitialized\" }\n+T (int, 1, 1);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 1\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 2);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 2\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 3);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 3\\\\)\\\\)\\\\\\[1]'\" }\n+T (int, 1, 4);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)a\\\\)\\\\\\[2]'\" }\n+T (int, 1, 5);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 1\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 6);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 2\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 7);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 3\\\\)\\\\)\\\\\\[2]'\" }\n+T (int, 1, 8);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)a\\\\)\\\\\\[3]'\" }\n+T (int, 1, 9);      // { dg-warning \"'\\\\(\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)a \\\\+ 1\\\\)\\\\)\\\\\\[3]'\" }"}, {"sha": "c015191ca32848ce686a79839fdf08b4380f72cd", "filename": "gcc/testsuite/gcc.dg/uninit-40.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-40.c?ref=adb520606ce3e1e1f8aa8c5d0c59a5f3196fc545", "patch": "@@ -0,0 +1,50 @@\n+/* PR tree-optimization/98597 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wuninitialized\" } */\n+\n+union U { double d; int i; float f; };\n+struct S { char a; int b; char c; unsigned d; union U e; int f[3]; unsigned g[3]; };\n+struct T { char t; struct S u; int v; };\n+typedef short V[2][2];\n+void baz (V *);\n+\n+static inline int\n+bar (char *p)\n+{\n+  return *(int *) p;\n+}\n+\n+void\n+foo (int *q)\n+{\n+  struct T t;\n+  t.t = 1;\n+  t.u.c = 2;\n+  char *pt = (char *) &t;\n+  q[0] = bar (pt + __builtin_offsetof (struct T, u.b));\t/* { dg-warning \"'t\\\\.u\\\\.b' is used uninitialized\" } */\n+  q[1] = bar (pt + __builtin_offsetof (struct T, u.e));\t/* { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)&t \\\\+ offsetof\\\\(struct T, u\\\\.e\\\\)\\\\)' is used uninitialized\" } */\n+  q[2] = bar (pt + __builtin_offsetof (struct T, v));\t/* { dg-warning \"'t\\\\.v' is used uninitialized\" } */\n+  q[3] = bar (pt + __builtin_offsetof (struct T, u.d));\t/* { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)&t \\\\+ offsetof\\\\(struct T, u\\\\.d\\\\)\\\\)' is used uninitialized\" } */\n+  q[4] = bar (pt + __builtin_offsetof (struct T, u.f[2])); /* { dg-warning \"'t\\\\.u\\\\.f\\\\\\[2\\\\\\]' is used uninitialized\" } */\n+  q[5] = bar (pt + __builtin_offsetof (struct T, u.g[2])); /* { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)&t \\\\+ offsetof\\\\(struct T, u\\\\.g\\\\\\[2\\\\\\]\\\\)\\\\)' is used uninitialized\" } */\n+  int s[3];\n+  s[0] = 1;\n+  char *ps = (char *) s;\n+  q[6] = bar (ps + sizeof (int));\t\t\t/* { dg-warning \"'s\\\\\\[1\\\\\\]' is used uninitialized\" } */\n+  unsigned w[2][2];\n+  w[0][0] = 1;\n+  char *pw = (char *) w;\n+  q[7] = bar (pw + 3 * sizeof (unsigned));\t\t/* { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(&w\\\\\\[1\\\\\\]\\\\\\[1\\\\\\]\\\\)' is used uninitialized\" } */\n+  struct T x[3][3];\n+  x[0][0].t = 1;\n+  char *px = (char *) x;\n+  q[8] = bar (px + 5 * sizeof (struct T) + __builtin_offsetof (struct T, u.b));\t/* { dg-warning \"'x\\\\\\[1\\\\\\]\\\\\\[2\\\\\\]\\\\.u\\\\.b' is used uninitialized\" } */\n+  q[9] = bar (px + 6 * sizeof (struct T) + __builtin_offsetof (struct T, u.d));\t/* { dg-warning \"'\\\\*\\\\(int \\\\*\\\\)\\\\(\\\\(char \\\\*\\\\)&x\\\\\\[2\\\\\\]\\\\\\[0\\\\\\] \\\\+ offsetof\\\\(struct T, u\\\\.d\\\\)\\\\)' is used uninitialized\" } */\n+#if defined(__i386__) || defined(__x86_64__)\n+  /* memcpy folding is too target dependent to test it everywhere.  */\n+  V u[2], v[2];\n+  u[0][0][0] = 1;\n+  __builtin_memcpy (&v[1], &u[1], sizeof (V));\t\t/* { dg-warning \"'\\\\*\\\\(\\(long \\)?long unsigned int \\\\*\\\\)\\\\(&u\\\\\\[1\\\\\\]\\\\\\[0\\\\\\]\\\\\\[0\\\\\\]\\\\)' is used uninitialized\" \"\" { target i?86-*-* x86_64-*-* } } */\n+  baz (&v[1]);\n+#endif\n+}"}]}