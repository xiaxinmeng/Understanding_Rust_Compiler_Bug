{"sha": "55bd9c35eb4196c89c571ebceff7fba7715d4e79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTViZDljMzVlYjQxOTZjODljNTcxZWJjZWZmN2ZiYTc3MTVkNGU3OQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-10-15T12:42:39Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-10-15T12:42:39Z"}, "message": "re PR fortran/45186 (Gfortran 4.5.0 emits wrong linenumbers)\n\n2010-10-15  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/45186\n        * trans.h (gfc_add_modify_loc, gfc_evaluate_now_loc): New\n        * prototypes.\n        (gfc_trans_runtime_error_vararg): Remove prototype.\n        * trans.c (gfc_add_modify_loc, gfc_evaluate_now_loc): New\n        * functions.\n        (gfc_add_modify, gfc_evaluate_now): Use them.\n        (trans_runtime_error_vararg): Renamed from\n        gfc_trans_runtime_error_vararg, made static and use locus.\n        (gfc_trans_runtime_error): Use it.\n        (gfc_trans_runtime_check): Ditto and make use of locus.\n        * trans-stmt.c (gfc_trans_if_1, gfc_trans_simple_do,\n        gfc_trans_do, gfc_trans_do_while): Improve line number\n        associated with generated expressions.\n\nFrom-SVN: r165507", "tree": {"sha": "029473669b4c05ed25374393705f12f0e907bc7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/029473669b4c05ed25374393705f12f0e907bc7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55bd9c35eb4196c89c571ebceff7fba7715d4e79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55bd9c35eb4196c89c571ebceff7fba7715d4e79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55bd9c35eb4196c89c571ebceff7fba7715d4e79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55bd9c35eb4196c89c571ebceff7fba7715d4e79/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b534dca5618e74e4d22ab43d9c809e05d36795da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b534dca5618e74e4d22ab43d9c809e05d36795da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b534dca5618e74e4d22ab43d9c809e05d36795da"}], "stats": {"total": 231, "additions": 137, "deletions": 94}, "files": [{"sha": "b32454c524a0504979009a9a38d2fbde5c74961b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=55bd9c35eb4196c89c571ebceff7fba7715d4e79", "patch": "@@ -1,3 +1,18 @@\n+2010-10-15  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/45186\n+\t* trans.h (gfc_add_modify_loc, gfc_evaluate_now_loc): New prototypes.\n+\t(gfc_trans_runtime_error_vararg): Remove prototype.\n+\t* trans.c (gfc_add_modify_loc, gfc_evaluate_now_loc): New functions.\n+\t(gfc_add_modify, gfc_evaluate_now): Use them.\n+\t(trans_runtime_error_vararg): Renamed from\n+\tgfc_trans_runtime_error_vararg, made static and use locus.\n+\t(gfc_trans_runtime_error): Use it.\n+\t(gfc_trans_runtime_check): Ditto and make use of locus.\n+\t* trans-stmt.c (gfc_trans_if_1, gfc_trans_simple_do,\n+\tgfc_trans_do, gfc_trans_do_while): Improve line number\n+\tassociated with generated expressions.\n+\n 2010-10-12  Daniel Kraft  <d@domob.eu>\n \n \tPR fortran/38936"}, {"sha": "31b0732844bd7a3aba18ed0221a761c3ef684a3c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 75, "deletions": 69, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=55bd9c35eb4196c89c571ebceff7fba7715d4e79", "patch": "@@ -717,6 +717,7 @@ gfc_trans_if_1 (gfc_code * code)\n {\n   gfc_se if_se;\n   tree stmt, elsestmt;\n+  location_t loc;\n \n   /* Check for an unconditional ELSE clause.  */\n   if (!code->expr1)\n@@ -739,8 +740,9 @@ gfc_trans_if_1 (gfc_code * code)\n     elsestmt = build_empty_stmt (input_location);\n \n   /* Build the condition expression and add it to the condition block.  */\n-  stmt = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t  if_se.expr, stmt, elsestmt);\n+  loc = code->expr1->where.lb ? code->expr1->where.lb->location : input_location;\n+  stmt = fold_build3_loc (loc, COND_EXPR, void_type_node, if_se.expr, stmt,\n+\t\t\t  elsestmt);\n   \n   gfc_add_expr_to_block (&if_se.pre, stmt);\n \n@@ -942,17 +944,20 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   tree saved_dovar = NULL;\n   tree cycle_label;\n   tree exit_label;\n+  location_t loc;\n   \n   type = TREE_TYPE (dovar);\n \n+  loc = code->ext.iterator->start->where.lb->location;\n+\n   /* Initialize the DO variable: dovar = from.  */\n-  gfc_add_modify (pblock, dovar, from);\n+  gfc_add_modify_loc (loc, pblock, dovar, from);\n   \n   /* Save value for do-tinkering checking. */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n       saved_dovar = gfc_create_var (type, \".saved_dovar\");\n-      gfc_add_modify (pblock, saved_dovar, dovar);\n+      gfc_add_modify_loc (loc, pblock, saved_dovar, dovar);\n     }\n \n   /* Cycle and exit statements are implemented with gotos.  */\n@@ -980,7 +985,7 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   /* Check whether someone has modified the loop variable. */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+      tmp = fold_build2_loc (loc, NE_EXPR, boolean_type_node,\n \t\t\t     dovar, saved_dovar);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop variable has been modified\");\n@@ -990,44 +995,44 @@ gfc_trans_simple_do (gfc_code * code, stmtblock_t *pblock, tree dovar,\n   if (exit_cond)\n     {\n       tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n \t\t\t     exit_cond, tmp,\n-\t\t\t     build_empty_stmt (input_location));\n+\t\t\t     build_empty_stmt (loc));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n   /* Evaluate the loop condition.  */\n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, dovar,\n+  cond = fold_build2_loc (loc, EQ_EXPR, boolean_type_node, dovar,\n \t\t\t  to);\n-  cond = gfc_evaluate_now (cond, &body);\n+  cond = gfc_evaluate_now_loc (loc, cond, &body);\n \n   /* Increment the loop variable.  */\n-  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, dovar, step);\n-  gfc_add_modify (&body, dovar, tmp);\n+  tmp = fold_build2_loc (loc, PLUS_EXPR, type, dovar, step);\n+  gfc_add_modify_loc (loc, &body, dovar, tmp);\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n-    gfc_add_modify (&body, saved_dovar, dovar);\n+    gfc_add_modify_loc (loc, &body, saved_dovar, dovar);\n \n   /* The loop exit.  */\n-  tmp = build1_v (GOTO_EXPR, exit_label);\n+  tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t cond, tmp, build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t cond, tmp, build_empty_stmt (loc));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Finish the loop body.  */\n   tmp = gfc_finish_block (&body);\n-  tmp = build1_v (LOOP_EXPR, tmp);\n+  tmp = fold_build1_loc (loc, LOOP_EXPR, void_type_node, tmp);\n \n   /* Only execute the loop if the number of iterations is positive.  */\n   if (tree_int_cst_sgn (step) > 0)\n-    cond = fold_build2_loc (input_location, LE_EXPR, boolean_type_node, dovar,\n+    cond = fold_build2_loc (loc, LE_EXPR, boolean_type_node, dovar,\n \t\t\t    to);\n   else\n-    cond = fold_build2_loc (input_location, GE_EXPR, boolean_type_node, dovar,\n+    cond = fold_build2_loc (loc, GE_EXPR, boolean_type_node, dovar,\n \t\t\t    to);\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond, tmp,\n-\t\t\t build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (loc, COND_EXPR, void_type_node, cond, tmp,\n+\t\t\t build_empty_stmt (loc));\n   gfc_add_expr_to_block (pblock, tmp);\n \n   /* Add the exit label.  */\n@@ -1090,9 +1095,12 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   tree pos_step;\n   stmtblock_t block;\n   stmtblock_t body;\n+  location_t loc;\n \n   gfc_start_block (&block);\n \n+  loc = code->ext.iterator->start->where.lb->location;\n+\n   /* Evaluate all the expressions in the iterator.  */\n   gfc_init_se (&se, NULL);\n   gfc_conv_expr_lhs (&se, code->ext.iterator->var);\n@@ -1129,7 +1137,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \t|| tree_int_cst_equal (step, integer_minus_one_node)))\n     return gfc_trans_simple_do (code, &block, dovar, from, to, step, exit_cond);\n \n-  pos_step = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, step,\n+  pos_step = fold_build2_loc (loc, GT_EXPR, boolean_type_node, step,\n \t\t\t      fold_convert (type, integer_zero_node));\n \n   if (TREE_CODE (type) == INTEGER_TYPE)\n@@ -1154,7 +1162,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n       saved_dovar = gfc_create_var (type, \".saved_dovar\");\n-      gfc_add_modify (&block, saved_dovar, dovar);\n+      gfc_add_modify_loc (loc, &block, saved_dovar, dovar);\n     }\n \n   /* Initialize loop count and jump to exit label if the loop is empty.\n@@ -1180,43 +1188,40 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \n       /* Calculate SIGN (1,step), as (step < 0 ? -1 : 1)  */\n \n-      tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, step,\n+      tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, step,\n \t\t\t     build_int_cst (TREE_TYPE (step), 0));\n-      step_sign = fold_build3_loc (input_location, COND_EXPR, type, tmp, \n+      step_sign = fold_build3_loc (loc, COND_EXPR, type, tmp, \n \t\t\t\t   build_int_cst (type, -1), \n \t\t\t\t   build_int_cst (type, 1));\n \n-      tmp = fold_build2_loc (input_location, LT_EXPR, boolean_type_node, to,\n-\t\t\t     from);\n-      pos = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n-\t\t\t     build1_v (GOTO_EXPR, exit_label),\n-\t\t\t     build_empty_stmt (input_location));\n+      tmp = fold_build2_loc (loc, LT_EXPR, boolean_type_node, to, from);\n+      pos = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp,\n+\t\t\t     fold_build1_loc (loc, GOTO_EXPR, void_type_node,\n+\t\t\t\t\t      exit_label),\n+\t\t\t     build_empty_stmt (loc));\n \n-      tmp = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, to,\n+      tmp = fold_build2_loc (loc, GT_EXPR, boolean_type_node, to,\n \t\t\t     from);\n-      neg = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n-\t\t\t     build1_v (GOTO_EXPR, exit_label),\n-\t\t\t     build_empty_stmt (input_location));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+      neg = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp,\n+\t\t\t     fold_build1_loc (loc, GOTO_EXPR, void_type_node,\n+\t\t\t\t\t      exit_label),\n+\t\t\t     build_empty_stmt (loc));\n+      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n \t\t\t     pos_step, pos, neg);\n \n       gfc_add_expr_to_block (&block, tmp);\n \n       /* Calculate the loop count.  to-from can overflow, so\n \t we cast to unsigned.  */\n \n-      to2 = fold_build2_loc (input_location, MULT_EXPR, type, step_sign, to);\n-      from2 = fold_build2_loc (input_location, MULT_EXPR, type, step_sign,\n-\t\t\t       from);\n-      step2 = fold_build2_loc (input_location, MULT_EXPR, type, step_sign,\n-\t\t\t       step);\n+      to2 = fold_build2_loc (loc, MULT_EXPR, type, step_sign, to);\n+      from2 = fold_build2_loc (loc, MULT_EXPR, type, step_sign, from);\n+      step2 = fold_build2_loc (loc, MULT_EXPR, type, step_sign, step);\n       step2 = fold_convert (utype, step2);\n-      tmp = fold_build2_loc (input_location, MINUS_EXPR, type, to2, from2);\n+      tmp = fold_build2_loc (loc, MINUS_EXPR, type, to2, from2);\n       tmp = fold_convert (utype, tmp);\n-      tmp = fold_build2_loc (input_location, TRUNC_DIV_EXPR, utype, tmp,\n-\t\t\t     step2);\n-      tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t\t     countm1, tmp);\n+      tmp = fold_build2_loc (loc, TRUNC_DIV_EXPR, utype, tmp, step2);\n+      tmp = fold_build2_loc (loc, MODIFY_EXPR, void_type_node, countm1, tmp);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n   else\n@@ -1225,21 +1230,20 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n \t This would probably cause more problems that it solves\n \t when we implement \"long double\" types.  */\n \n-      tmp = fold_build2_loc (input_location, MINUS_EXPR, type, to, from);\n-      tmp = fold_build2_loc (input_location, RDIV_EXPR, type, tmp, step);\n-      tmp = fold_build1_loc (input_location, FIX_TRUNC_EXPR, utype, tmp);\n+      tmp = fold_build2_loc (loc, MINUS_EXPR, type, to, from);\n+      tmp = fold_build2_loc (loc, RDIV_EXPR, type, tmp, step);\n+      tmp = fold_build1_loc (loc, FIX_TRUNC_EXPR, utype, tmp);\n       gfc_add_modify (&block, countm1, tmp);\n \n       /* We need a special check for empty loops:\n \t empty = (step > 0 ? to < from : to > from);  */\n-      tmp = fold_build3_loc (input_location, COND_EXPR, boolean_type_node,\n-\t\t\t     pos_step,\n-\t\t\t     fold_build2_loc (input_location, LT_EXPR,\n+      tmp = fold_build3_loc (loc, COND_EXPR, boolean_type_node, pos_step,\n+\t\t\t     fold_build2_loc (loc, LT_EXPR,\n \t\t\t\t\t      boolean_type_node, to, from),\n-\t\t\t     fold_build2_loc (input_location, GT_EXPR,\n+\t\t\t     fold_build2_loc (loc, GT_EXPR,\n \t\t\t\t\t      boolean_type_node, to, from));\n       /* If the loop is empty, go directly to the exit label.  */\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, tmp,\n+      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node, tmp,\n \t\t\t build1_v (GOTO_EXPR, exit_label),\n \t\t\t build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&block, tmp);\n@@ -1262,7 +1266,7 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   /* Check whether someone has modified the loop variable. */\n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n     {\n-      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, dovar,\n+      tmp = fold_build2_loc (loc, NE_EXPR, boolean_type_node, dovar,\n \t\t\t     saved_dovar);\n       gfc_trans_runtime_check (true, false, tmp, &body, &code->loc,\n \t\t\t       \"Loop variable has been modified\");\n@@ -1272,37 +1276,37 @@ gfc_trans_do (gfc_code * code, tree exit_cond)\n   if (exit_cond)\n     {\n       tmp = build1_v (GOTO_EXPR, exit_label);\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+      tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n \t\t\t     exit_cond, tmp,\n \t\t\t     build_empty_stmt (input_location));\n       gfc_add_expr_to_block (&body, tmp);\n     }\n \n   /* Increment the loop variable.  */\n-  tmp = fold_build2_loc (input_location, PLUS_EXPR, type, dovar, step);\n-  gfc_add_modify (&body, dovar, tmp);\n+  tmp = fold_build2_loc (loc, PLUS_EXPR, type, dovar, step);\n+  gfc_add_modify_loc (loc, &body, dovar, tmp);\n \n   if (gfc_option.rtcheck & GFC_RTCHECK_DO)\n-    gfc_add_modify (&body, saved_dovar, dovar);\n+    gfc_add_modify_loc (loc, &body, saved_dovar, dovar);\n \n   /* End with the loop condition.  Loop until countm1 == 0.  */\n-  cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, countm1,\n+  cond = fold_build2_loc (loc, EQ_EXPR, boolean_type_node, countm1,\n \t\t\t  build_int_cst (utype, 0));\n-  tmp = build1_v (GOTO_EXPR, exit_label);\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t cond, tmp, build_empty_stmt (input_location));\n+  tmp = fold_build1_loc (loc, GOTO_EXPR, void_type_node, exit_label);\n+  tmp = fold_build3_loc (loc, COND_EXPR, void_type_node,\n+\t\t\t cond, tmp, build_empty_stmt (loc));\n   gfc_add_expr_to_block (&body, tmp);\n \n   /* Decrement the loop count.  */\n-  tmp = fold_build2_loc (input_location, MINUS_EXPR, utype, countm1,\n+  tmp = fold_build2_loc (loc, MINUS_EXPR, utype, countm1,\n \t\t\t build_int_cst (utype, 1));\n-  gfc_add_modify (&body, countm1, tmp);\n+  gfc_add_modify_loc (loc, &body, countm1, tmp);\n \n   /* End of loop body.  */\n   tmp = gfc_finish_block (&body);\n \n   /* The for loop itself.  */\n-  tmp = build1_v (LOOP_EXPR, tmp);\n+  tmp = fold_build1_loc (loc, LOOP_EXPR, void_type_node, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Add the exit label.  */\n@@ -1360,14 +1364,15 @@ gfc_trans_do_while (gfc_code * code)\n   gfc_init_se (&cond, NULL);\n   gfc_conv_expr_val (&cond, code->expr1);\n   gfc_add_block_to_block (&block, &cond.pre);\n-  cond.expr = fold_build1_loc (input_location, TRUTH_NOT_EXPR,\n-\t\t\t       boolean_type_node, cond.expr);\n+  cond.expr = fold_build1_loc (code->expr1->where.lb->location,\n+\t\t\t       TRUTH_NOT_EXPR, boolean_type_node, cond.expr);\n \n   /* Build \"IF (! cond) GOTO exit_label\".  */\n   tmp = build1_v (GOTO_EXPR, exit_label);\n   TREE_USED (exit_label) = 1;\n-  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n-\t\t\t cond.expr, tmp, build_empty_stmt (input_location));\n+  tmp = fold_build3_loc (code->expr1->where.lb->location, COND_EXPR,\n+\t\t\t void_type_node, cond.expr, tmp,\n+\t\t\t build_empty_stmt (code->expr1->where.lb->location));\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* The main body of the loop.  */\n@@ -1386,7 +1391,8 @@ gfc_trans_do_while (gfc_code * code)\n \n   gfc_init_block (&block);\n   /* Build the loop.  */\n-  tmp = build1_v (LOOP_EXPR, tmp);\n+  tmp = fold_build1_loc (code->expr1->where.lb->location, LOOP_EXPR,\n+\t\t\t void_type_node, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Add the exit label.  */"}, {"sha": "6050e1a0ab0db6819348f7d279ce2772c6eb12d3", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=55bd9c35eb4196c89c571ebceff7fba7715d4e79", "patch": "@@ -132,26 +132,33 @@ gfc_create_var (tree type, const char *prefix)\n    return a pointer to the VAR_DECL node for this variable.  */\n \n tree\n-gfc_evaluate_now (tree expr, stmtblock_t * pblock)\n+gfc_evaluate_now_loc (location_t loc, tree expr, stmtblock_t * pblock)\n {\n   tree var;\n \n   if (CONSTANT_CLASS_P (expr))\n     return expr;\n \n   var = gfc_create_var (TREE_TYPE (expr), NULL);\n-  gfc_add_modify (pblock, var, expr);\n+  gfc_add_modify_loc (loc, pblock, var, expr);\n \n   return var;\n }\n \n \n+tree\n+gfc_evaluate_now (tree expr, stmtblock_t * pblock)\n+{\n+  return gfc_evaluate_now_loc (input_location, expr, pblock);\n+}\n+\n+\n /* Build a MODIFY_EXPR node and add it to a given statement block PBLOCK.  \n    A MODIFY_EXPR is an assignment:\n    LHS <- RHS.  */\n \n void\n-gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs)\n+gfc_add_modify_loc (location_t loc, stmtblock_t * pblock, tree lhs, tree rhs)\n {\n   tree tmp;\n \n@@ -167,12 +174,19 @@ gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs)\n \t      || AGGREGATE_TYPE_P (TREE_TYPE (lhs)));\n #endif\n \n-  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node, lhs,\n+  tmp = fold_build2_loc (loc, MODIFY_EXPR, void_type_node, lhs,\n \t\t\t rhs);\n   gfc_add_expr_to_block (pblock, tmp);\n }\n \n \n+void\n+gfc_add_modify (stmtblock_t * pblock, tree lhs, tree rhs)\n+{\n+  gfc_add_modify_loc (input_location, pblock, lhs, rhs);\n+}\n+\n+\n /* Create a new scope/binding level and initialize a block.  Care must be\n    taken when translating expressions as any temporaries will be placed in\n    the innermost scope.  */\n@@ -355,18 +369,9 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n /* Generate a call to print a runtime error possibly including multiple\n    arguments and a locus.  */\n \n-tree\n-gfc_trans_runtime_error (bool error, locus* where, const char* msgid, ...)\n-{\n-  va_list ap;\n-\n-  va_start (ap, msgid);\n-  return gfc_trans_runtime_error_vararg (error, where, msgid, ap);\n-}\n-\n-tree\n-gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n-\t\t\t\tva_list ap)\n+static tree\n+trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n+\t\t\t    va_list ap)\n {\n   stmtblock_t block;\n   tree tmp;\n@@ -376,6 +381,7 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n   char *message;\n   const char *p;\n   int line, nargs, i;\n+  location_t loc;\n \n   /* Compute the number of extra arguments from the format string.  */\n   for (p = msgid, nargs = 0; *p; p++)\n@@ -414,7 +420,6 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n   argarray[1] = arg2;\n   for (i = 0; i < nargs; i++)\n     argarray[2 + i] = va_arg (ap, tree);\n-  va_end (ap);\n   \n   /* Build the function call to runtime_(warning,error)_at; because of the\n      variable number of arguments, we can't use build_call_expr_loc dinput_location,\n@@ -424,8 +429,9 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n   else\n     fntype = TREE_TYPE (gfor_fndecl_runtime_warning_at);\n \n-  tmp = fold_builtin_call_array (input_location, TREE_TYPE (fntype),\n-\t\t\t\t fold_build1_loc (input_location, ADDR_EXPR,\n+  loc = where ? where->lb->location : input_location;\n+  tmp = fold_builtin_call_array (loc, TREE_TYPE (fntype),\n+\t\t\t\t fold_build1_loc (loc, ADDR_EXPR,\n \t\t\t\t\t     build_pointer_type (fntype),\n \t\t\t\t\t     error\n \t\t\t\t\t     ? gfor_fndecl_runtime_error_at\n@@ -437,6 +443,19 @@ gfc_trans_runtime_error_vararg (bool error, locus* where, const char* msgid,\n }\n \n \n+tree\n+gfc_trans_runtime_error (bool error, locus* where, const char* msgid, ...)\n+{\n+  va_list ap;\n+  tree result;\n+\n+  va_start (ap, msgid);\n+  result = trans_runtime_error_vararg (error, where, msgid, ap);\n+  va_end (ap);\n+  return result;\n+}\n+\n+\n /* Generate a runtime error if COND is true.  */\n \n void\n@@ -465,8 +484,8 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n   /* The code to generate the error.  */\n   va_start (ap, msgid);\n   gfc_add_expr_to_block (&block,\n-\t\t\t gfc_trans_runtime_error_vararg (error, where,\n-\t\t\t\t\t\t\t msgid, ap));\n+\t\t\t trans_runtime_error_vararg (error, where,\n+\t\t\t\t\t\t     msgid, ap));\n \n   if (once)\n     gfc_add_modify (&block, tmpvar, boolean_false_node);\n@@ -481,17 +500,19 @@ gfc_trans_runtime_check (bool error, bool once, tree cond, stmtblock_t * pblock,\n     {\n       /* Tell the compiler that this isn't likely.  */\n       if (once)\n-\tcond = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n+\tcond = fold_build2_loc (where->lb->location, TRUTH_AND_EXPR,\n \t\t\t\tlong_integer_type_node, tmpvar, cond);\n       else\n \tcond = fold_convert (long_integer_type_node, cond);\n \n       tmp = build_int_cst (long_integer_type_node, 0);\n-      cond = build_call_expr_loc (input_location,\n+      cond = build_call_expr_loc (where->lb->location,\n \t\t\t      built_in_decls[BUILT_IN_EXPECT], 2, cond, tmp);\n       cond = fold_convert (boolean_type_node, cond);\n \n-      tmp = build3_v (COND_EXPR, cond, body, build_empty_stmt (input_location));\n+      tmp = fold_build3_loc (where->lb->location, COND_EXPR, void_type_node,\n+\t\t\t     cond, body,\n+\t\t\t     build_empty_stmt (where->lb->location));\n       gfc_add_expr_to_block (pblock, tmp);\n     }\n }"}, {"sha": "d4c54c0e37b7bc0448c5e58a67fdab820c634f7c", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55bd9c35eb4196c89c571ebceff7fba7715d4e79/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=55bd9c35eb4196c89c571ebceff7fba7715d4e79", "patch": "@@ -342,6 +342,7 @@ tree gfc_string_to_single_character (tree len, tree str, int kind);\n /* Find the decl containing the auxiliary variables for assigned variables.  */\n void gfc_conv_label_variable (gfc_se * se, gfc_expr * expr);\n /* If the value is not constant, Create a temporary and copy the value.  */\n+tree gfc_evaluate_now_loc (location_t, tree, stmtblock_t *);\n tree gfc_evaluate_now (tree, stmtblock_t *);\n \n /* Find the appropriate variant of a math intrinsic.  */\n@@ -398,6 +399,7 @@ void gfc_add_expr_to_block (stmtblock_t *, tree);\n /* Add a block to the end of a block.  */\n void gfc_add_block_to_block (stmtblock_t *, stmtblock_t *);\n /* Add a MODIFY_EXPR to a block.  */\n+void gfc_add_modify_loc (location_t, stmtblock_t *, tree, tree);\n void gfc_add_modify (stmtblock_t *, tree, tree);\n \n /* Initialize a statement block.  */\n@@ -504,7 +506,6 @@ bool get_array_ctor_strlen (stmtblock_t *, gfc_constructor_base, tree *);\n \n /* Generate a runtime error call.  */\n tree gfc_trans_runtime_error (bool, locus*, const char*, ...);\n-tree gfc_trans_runtime_error_vararg (bool, locus*, const char*, va_list);\n \n /* Generate a runtime warning/error check.  */\n void gfc_trans_runtime_check (bool, bool, tree, stmtblock_t *, locus *,"}]}