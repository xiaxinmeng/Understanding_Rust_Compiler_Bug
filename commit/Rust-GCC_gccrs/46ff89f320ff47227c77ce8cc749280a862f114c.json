{"sha": "46ff89f320ff47227c77ce8cc749280a862f114c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZmZjg5ZjMyMGZmNDcyMjdjNzdjZThjYzc0OTI4MGE4NjJmMTE0Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T13:44:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-08T13:44:17Z"}, "message": "[multiple changes]\n\n2009-04-08  Ed Schonberg  <schonberg@adacore.com>\n\n\t* inline.adb (Back_End_Cannot_Inline): Do not mark a body as inlineable\n\tby the back-end if it contains a call to a subprogram without a\n\tprevious spec that is declared in the same unit.\n\n\t* errout.ads: Update comments on uses of dirs\n\n2009-04-08  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_Concatenate): Make sure nodes are properly typed\n\nFrom-SVN: r145729", "tree": {"sha": "ab6743383a01ccbfe974249760b6c4514bd87339", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab6743383a01ccbfe974249760b6c4514bd87339"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46ff89f320ff47227c77ce8cc749280a862f114c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ff89f320ff47227c77ce8cc749280a862f114c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46ff89f320ff47227c77ce8cc749280a862f114c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46ff89f320ff47227c77ce8cc749280a862f114c/comments", "author": null, "committer": null, "parents": [{"sha": "812f574fdafe3d4a09ac60964b8eeb36cb430837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812f574fdafe3d4a09ac60964b8eeb36cb430837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812f574fdafe3d4a09ac60964b8eeb36cb430837"}], "stats": {"total": 143, "additions": 105, "deletions": 38}, "files": [{"sha": "0231903067f469933c2ba53eab183ff7bf8d17cc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=46ff89f320ff47227c77ce8cc749280a862f114c", "patch": "@@ -1,3 +1,15 @@\n+2009-04-08  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* inline.adb (Back_End_Cannot_Inline): Do not mark a body as inlineable\n+\tby the back-end if it contains a call to a subprogram without a\n+\tprevious spec that is declared in the same unit.\n+\n+\t* errout.ads: Update comments on uses of dirs\n+\n+2009-04-08  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_Concatenate): Make sure nodes are properly typed\n+\n 2009-04-08  Tristan Gingold  <gingold@adacore.com>\n \n \t* sem_prag.adb: Restrict pragma Thread_Local_Storage to library level"}, {"sha": "0d9346335138eadf9e7942b9bc9724706d3e5743", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=46ff89f320ff47227c77ce8cc749280a862f114c", "patch": "@@ -269,8 +269,10 @@ package Errout is\n \n    --      Normally warning messages issued in other than the main unit are\n    --      suppressed. If the message ends with !! then this suppression is\n-   --      avoided. This is currently only used by the Compile_Time_Warning\n-   --      pragma to ensure the message for a with'ed unit is output.\n+   --      avoided. This is currently used by the Compile_Time_Warning pragma\n+   --      to ensure the message for a with'ed unit is output, and for warnings\n+   --      on ineffective back-end inlining, which is detected in units that\n+   --      contain subprograms to be inlined in the main program.\n \n    --    Insertion character ? (Question: warning message)\n    --      The character ? appearing anywhere in a message makes the message"}, {"sha": "190baa6237391f2b0899e3fa41b62b37efff095c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=46ff89f320ff47227c77ce8cc749280a862f114c", "patch": "@@ -2154,7 +2154,7 @@ package body Exp_Ch4 is\n       --  for all computed bounds (which may be out of range of Istyp in the\n       --  case of null ranges).\n \n-      Intyp : Entity_Id;\n+      Artyp : Entity_Id;\n       --  This is the type we use to do arithmetic to compute the bounds and\n       --  lengths of operands. The choice of this type is a little subtle and\n       --  is discussed in a separate section at the start of the body code.\n@@ -2204,14 +2204,14 @@ package body Exp_Ch4 is\n       --  Set to an entity of type Natural that contains the length of an\n       --  operand whose length is not known at compile time. Entries in this\n       --  array are set only if the corresponding entry in Is_Fixed_Length\n-      --  is False. The entity is of type Intyp.\n+      --  is False. The entity is of type Artyp.\n \n       Aggr_Length : array (0 .. N) of Node_Id;\n       --  The J'th entry in an expression node that represents the total length\n       --  of operands 1 through J. It is either an integer literal node, or a\n       --  reference to a constant entity with the right value, so it is fine\n       --  to just do a Copy_Node to get an appropriate copy. The extra zero'th\n-      --  entry always is set to zero. The length is of type Intyp.\n+      --  entry always is set to zero. The length is of type Artyp.\n \n       Low_Bound : Node_Id;\n       --  A tree node representing the low bound of the result (of type Ityp).\n@@ -2230,21 +2230,21 @@ package body Exp_Ch4 is\n       Result : Node_Id;\n       --  Result of the concatenation (of type Ityp)\n \n-      function To_Intyp (X : Node_Id) return Node_Id;\n+      function To_Artyp (X : Node_Id) return Node_Id;\n       --  Given a node of type Ityp, returns the corresponding value of type\n-      --  Intyp. For non-enumeration types, this is the identity. For enum\n+      --  Artyp. For non-enumeration types, this is the identity. For enum\n       --  types, the Pos of the value is returned.\n \n       function To_Ityp (X : Node_Id) return Node_Id;\n       --  The inverse function (uses Val in the case of enumeration types)\n \n       --------------\n-      -- To_Intyp --\n+      -- To_Artyp --\n       --------------\n \n-      function To_Intyp (X : Node_Id) return Node_Id is\n+      function To_Artyp (X : Node_Id) return Node_Id is\n       begin\n-         if Ityp = Base_Type (Intyp) then\n+         if Ityp = Base_Type (Artyp) then\n             return X;\n \n          elsif Is_Enumeration_Type (Ityp) then\n@@ -2255,9 +2255,9 @@ package body Exp_Ch4 is\n                 Expressions    => New_List (X));\n \n          else\n-            return Convert_To (Intyp, X);\n+            return Convert_To (Artyp, X);\n          end if;\n-      end To_Intyp;\n+      end To_Artyp;\n \n       -------------\n       -- To_Ityp --\n@@ -2287,15 +2287,13 @@ package body Exp_Ch4 is\n             --  we analyzed and resolved the expression.\n \n             Set_Parent (X, Cnode);\n-            Analyze_And_Resolve (X);\n+            Analyze_And_Resolve (X, Artyp);\n \n             if Compile_Time_Compare\n-                 (X, Type_High_Bound (Istyp),\n-                  Assume_Valid => False) = GT\n+                 (X, Type_High_Bound (Istyp), Assume_Valid => False) = GT\n               or else\n                Compile_Time_Compare\n-                 (X, Type_High_Bound (Ityp),\n-                  Assume_Valid => False) = GT\n+                 (X, Type_High_Bound (Ityp), Assume_Valid => False) = GT\n             then\n                Apply_Compile_Time_Constraint_Error\n                  (N      => Cnode,\n@@ -2304,7 +2302,7 @@ package body Exp_Ch4 is\n                raise Concatenation_Error;\n \n             else\n-               if Ityp = Base_Type (Intyp) then\n+               if Ityp = Base_Type (Artyp) then\n                   return X;\n                else\n                   return Convert_To (Ityp, X);\n@@ -2343,30 +2341,30 @@ package body Exp_Ch4 is\n       --  arithmetic with POS values, not representation values).\n \n       if Is_Enumeration_Type (Ityp) then\n-         Intyp := Standard_Integer;\n+         Artyp := Standard_Integer;\n \n       --  For modular types, we use a 32-bit modular type for types whose size\n       --  is in the range 1-31 bits. For 32-bit unsigned types, we use the\n       --  identity type, and for larger unsigned types we use 64-bits.\n \n       elsif Is_Modular_Integer_Type (Ityp) then\n          if RM_Size (Ityp) < RM_Size (Standard_Unsigned) then\n-            Intyp := Standard_Unsigned;\n+            Artyp := Standard_Unsigned;\n          elsif RM_Size (Ityp) = RM_Size (Standard_Unsigned) then\n-            Intyp := Ityp;\n+            Artyp := Ityp;\n          else\n-            Intyp := RTE (RE_Long_Long_Unsigned);\n+            Artyp := RTE (RE_Long_Long_Unsigned);\n          end if;\n \n       --  Similar treatment for signed types\n \n       else\n          if RM_Size (Ityp) < RM_Size (Standard_Integer) then\n-            Intyp := Standard_Integer;\n+            Artyp := Standard_Integer;\n          elsif RM_Size (Ityp) = RM_Size (Standard_Integer) then\n-            Intyp := Ityp;\n+            Artyp := Ityp;\n          else\n-            Intyp := Standard_Long_Long_Integer;\n+            Artyp := Standard_Long_Long_Integer;\n          end if;\n       end if;\n \n@@ -2543,7 +2541,7 @@ package body Exp_Ch4 is\n                    Constant_Present    => True,\n \n                    Object_Definition   =>\n-                     New_Occurrence_Of (Intyp, Loc),\n+                     New_Occurrence_Of (Artyp, Loc),\n \n                    Expression          =>\n                      Make_Attribute_Reference (Loc,\n@@ -2600,7 +2598,7 @@ package body Exp_Ch4 is\n                 Constant_Present    => True,\n \n                 Object_Definition   =>\n-                  New_Occurrence_Of (Intyp, Loc),\n+                  New_Occurrence_Of (Artyp, Loc),\n \n                 Expression          =>\n                   Make_Op_Add (Loc,\n@@ -2729,7 +2727,7 @@ package body Exp_Ch4 is\n       High_Bound :=\n         To_Ityp (\n           Make_Op_Add (Loc,\n-            Left_Opnd  => To_Intyp (New_Copy (Low_Bound)),\n+            Left_Opnd  => To_Artyp (New_Copy (Low_Bound)),\n             Right_Opnd =>\n               Make_Op_Subtract (Loc,\n                 Left_Opnd  => New_Copy (Aggr_Length (NN)),\n@@ -2777,12 +2775,12 @@ package body Exp_Ch4 is\n          declare\n             Lo : constant Node_Id :=\n                    Make_Op_Add (Loc,\n-                     Left_Opnd  => To_Intyp (New_Copy (Low_Bound)),\n+                     Left_Opnd  => To_Artyp (New_Copy (Low_Bound)),\n                      Right_Opnd => Aggr_Length (J - 1));\n \n             Hi : constant Node_Id :=\n                    Make_Op_Add (Loc,\n-                     Left_Opnd  => To_Intyp (New_Copy (Low_Bound)),\n+                     Left_Opnd  => To_Artyp (New_Copy (Low_Bound)),\n                      Right_Opnd =>\n                        Make_Op_Subtract (Loc,\n                          Left_Opnd  => Aggr_Length (J),"}, {"sha": "7cda5d5a153f122467f1de68b07bb464fd885208", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46ff89f320ff47227c77ce8cc749280a862f114c/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=46ff89f320ff47227c77ce8cc749280a862f114c", "patch": "@@ -371,7 +371,13 @@ package body Inline is\n       --    inlined under ZCX because the numeric suffix generated by gigi\n       --    will be different in the body and the place of the inlined call.\n       --\n-      --  This procedure must be carefully coordinated with the back end\n+      --  If the body to be inlined contains calls to subprograms declared\n+      --  in the same body that have no previous spec, the back-end cannot\n+      --  inline either because the bodies to be inlined are processed before\n+      --  the rest of the enclosing package body, and gigi will then find\n+      --  references to entities that have not been elaborated yet.\n+      --\n+      --  This procedure must be carefully coordinated with the back end.\n \n       ----------------------------\n       -- Back_End_Cannot_Inline --\n@@ -381,6 +387,40 @@ package body Inline is\n          Decl     : constant Node_Id := Unit_Declaration_Node (Subp);\n          Body_Ent : Entity_Id;\n          Ent      : Entity_Id;\n+         Bad_Call : Node_Id;\n+\n+         function Process (N : Node_Id) return Traverse_Result;\n+         --  Look for calls to subprograms with no previous spec, declared\n+         --  in the same enclosiong package body.\n+\n+         -------------\n+         -- Process --\n+         -------------\n+\n+         function Process (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind (N) = N_Procedure_Call_Statement\n+              or else Nkind (N) = N_Function_Call\n+            then\n+               if Is_Entity_Name (Name (N))\n+                 and then\n+                    Nkind (Unit_Declaration_Node (Entity (Name (N))))\n+                      = N_Subprogram_Body\n+                 and then In_Same_Extended_Unit (Subp, Entity (Name (N)))\n+               then\n+                  Bad_Call := N;\n+                  return Abandon;\n+               else\n+                  return OK;\n+               end if;\n+            else\n+               return OK;\n+            end if;\n+         end Process;\n+\n+         function Has_Exposed_Call is new Traverse_Func (Process);\n+\n+      --  Start of processing for Back_End_Cannot_Inline\n \n       begin\n          if Nkind (Decl) = N_Subprogram_Declaration\n@@ -400,13 +440,12 @@ package body Inline is\n          if Present\n           (Exception_Handlers\n             (Handled_Statement_Sequence\n-                 (Unit_Declaration_Node (Corresponding_Body (Decl)))))\n+              (Unit_Declaration_Node (Corresponding_Body (Decl)))))\n          then\n             return True;\n          end if;\n \n          Ent := First_Entity (Body_Ent);\n-\n          while Present (Ent) loop\n             if Is_Subprogram (Ent)\n               and then Is_Generic_Instance (Ent)\n@@ -416,7 +455,20 @@ package body Inline is\n \n             Next_Entity (Ent);\n          end loop;\n-         return False;\n+\n+         if Has_Exposed_Call\n+              (Unit_Declaration_Node (Corresponding_Body (Decl))) = Abandon\n+         then\n+            if Ineffective_Inline_Warnings then\n+               Error_Msg_N\n+                 (\"?call to subprogram with no separate spec\"\n+                  & \" prevents inlining!!\", Bad_Call);\n+            end if;\n+\n+            return True;\n+         else\n+            return False;\n+         end if;\n       end Back_End_Cannot_Inline;\n \n    --  Start of processing for Add_Inlined_Subprogram\n@@ -445,8 +497,8 @@ package body Inline is\n       end if;\n \n       Inlined.Table (Index).Listed := True;\n-      Succ := Inlined.Table (Index).First_Succ;\n \n+      Succ := Inlined.Table (Index).First_Succ;\n       while Succ /= No_Succ loop\n          Subp := Successors.Table (Succ).Subp;\n          Inlined.Table (Subp).Count := Inlined.Table (Subp).Count - 1;\n@@ -614,14 +666,17 @@ package body Inline is\n                      Load_Needed_Body (Comp_Unit, OK);\n \n                      if not OK then\n+\n+                        --  Warn that a body was not available for inlining\n+                        --  by the back-end.\n+\n                         Error_Msg_Unit_1 := Bname;\n                         Error_Msg_N\n-                          (\"one or more inlined subprograms accessed in $!\",\n+                          (\"one or more inlined subprograms accessed in $!?\",\n                            Comp_Unit);\n                         Error_Msg_File_1 :=\n                           Get_File_Name (Bname, Subunit => False);\n-                        Error_Msg_N (\"\\but file{ was not found!\", Comp_Unit);\n-                        raise Unrecoverable_Error;\n+                        Error_Msg_N (\"\\but file{ was not found!?\", Comp_Unit);\n                      end if;\n                   end if;\n                end;"}]}