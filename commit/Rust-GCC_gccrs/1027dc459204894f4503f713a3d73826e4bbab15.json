{"sha": "1027dc459204894f4503f713a3d73826e4bbab15", "node_id": "C_kwDOANBUbNoAKDEwMjdkYzQ1OTIwNDg5NGY0NTAzZjcxM2EzZDczODI2ZTRiYmFiMTU", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-02-28T14:47:52Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-02-28T16:49:01Z"}, "message": "d: Merge upstream dmd cf63dd8e5, druntime caf14b0f, phobos 41aaf8c26.\n\nD front-end changes:\n\n    - Import dmd v2.099.0-rc.1.\n    - The `main' can now return type `noreturn' and supports return\n      inference.\n\nD Runtime changes:\n\n    - Import druntime v2.099.0-rc.1.\n    - C bindings for stat_t on powerpc-linux has been fixed.\n\nPhobos changes:\n\n    - Import phobos v2.099.0-rc.1.\n\ngcc/d/ChangeLog:\n\n\t* d-target.cc (Target::_init): Initialize C type size fields.\n\t* dmd/MERGE: Merge upstream dmd cf63dd8e5.\n\t* dmd/VERSION: Update version to v2.099.0-rc.1.\n\nlibphobos/ChangeLog:\n\n\t* libdruntime/MERGE: Merge upstream druntime caf14b0f.\n\t* src/MERGE: Merge upstream phobos 41aaf8c26.\n\ngcc/testsuite/ChangeLog:\n\n\t* gdc.dg/torture/simd7413a.d: Update.\n\t* gdc.dg/ubsan/pr88957.d: Update.\n\t* gdc.dg/simd18489.d: New test.\n\t* gdc.dg/torture/simd21727.d: New test.", "tree": {"sha": "606564b15e0978c77c76d0e618c00c25a78aaf38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/606564b15e0978c77c76d0e618c00c25a78aaf38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1027dc459204894f4503f713a3d73826e4bbab15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1027dc459204894f4503f713a3d73826e4bbab15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1027dc459204894f4503f713a3d73826e4bbab15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1027dc459204894f4503f713a3d73826e4bbab15/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "430c89274d7f82810724126637ffdc5507d442f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/430c89274d7f82810724126637ffdc5507d442f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/430c89274d7f82810724126637ffdc5507d442f0"}], "stats": {"total": 2015, "additions": 1164, "deletions": 851}, "files": [{"sha": "610be74ad4876c17c5b9930e3e53dc298ff79f9e", "filename": "gcc/d/d-target.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fd-target.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fd-target.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-target.cc?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -158,9 +158,14 @@ Target::_init (const Param &)\n   Type::thash_t = Type::tsize_t;\n \n   /* Set-up target C ABI.  */\n-  this->c.longsize = int_size_in_bytes (long_integer_type_node);\n-  this->c.long_doublesize = int_size_in_bytes (long_double_type_node);\n+  this->c.boolsize = (BOOL_TYPE_SIZE / BITS_PER_UNIT);\n+  this->c.shortsize = (SHORT_TYPE_SIZE / BITS_PER_UNIT);\n+  this->c.intsize = (INT_TYPE_SIZE / BITS_PER_UNIT);\n+  this->c.longsize = (LONG_TYPE_SIZE / BITS_PER_UNIT);\n+  this->c.long_longsize = (LONG_LONG_TYPE_SIZE / BITS_PER_UNIT);\n+  this->c.long_doublesize = (LONG_DOUBLE_TYPE_SIZE / BITS_PER_UNIT);\n   this->c.wchar_tsize = (WCHAR_TYPE_SIZE / BITS_PER_UNIT);\n+\n   this->c.bitFieldStyle = targetm.ms_bitfield_layout_p (unknown_type_node)\n     ? TargetC::BitFieldStyle::MS : TargetC::BitFieldStyle::Gcc_Clang;\n "}, {"sha": "f08d53aa3cdb7b81dfd8db3d3bbbddabe4b8d75b", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1,4 +1,4 @@\n-cb49e99f80e8111c71035b88fe47fe7d855c300f\n+cf63dd8e5a77ecb68cf5e7c43bf7b6c4c1154bbe\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "4bb69df8e2c67d26061a08e495bd6c7d4fd13fff", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1 +1 @@\n-v2.099.0-beta.1\n+v2.099.0-rc.1"}, {"sha": "fafe90e5357b77fe08063be4bcbd43d3766faa7c", "filename": "gcc/d/dmd/common/outbuffer.d", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcommon%2Foutbuffer.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -82,18 +82,17 @@ struct OutBuffer\n     /**\n     Frees resources associated.\n     */\n-    extern (C++) void dtor() nothrow @trusted\n+    extern (C++) void dtor() pure nothrow @trusted\n     {\n         if (fileMapping)\n         {\n             if (fileMapping.active)\n                 fileMapping.close();\n-            fileMapping = null;\n         }\n         else\n         {\n             debug (stomp) memset(data.ptr, 0xFF, data.length);\n-            free(data.ptr);\n+            pureFree(data.ptr);\n         }\n     }\n \n@@ -102,17 +101,7 @@ struct OutBuffer\n     */\n     extern (C++) ~this() pure nothrow @trusted\n     {\n-        if (fileMapping)\n-        {\n-            if (fileMapping.active)\n-                fileMapping.close();\n-            fileMapping = null;\n-        }\n-        else\n-        {\n-            debug (stomp) memset(data.ptr, 0xFF, data.length);\n-            pureFree(data.ptr);\n-        }\n+        dtor();\n     }\n \n     /// For porting with ease from dmd.backend.outbuf.Outbuffer\n@@ -150,17 +139,10 @@ struct OutBuffer\n     */\n     extern (C++) void destroy() pure nothrow @trusted\n     {\n-        if (fileMapping && fileMapping.active)\n-        {\n-            fileMapping.close();\n-            data = null;\n-            offset = 0;\n-        }\n-        else\n-        {\n-            debug (stomp) memset(data.ptr, 0xFF, data.length);\n-            pureFree(extractData());\n-        }\n+        dtor();\n+        fileMapping = null;\n+        data = null;\n+        offset = 0;\n     }\n \n     /**"}, {"sha": "3ded10a73466be98c700dee05515f6595a55b63f", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -48,8 +48,12 @@ final class CParser(AST) : Parser!AST\n         linkage = LINK.c;\n         Ccompile = true;\n \n-        // Configure sizes for C `long`, `long double`, `wchar_t`\n+        // Configure sizes for C `long`, `long double`, `wchar_t`, ...\n+        this.boolsize = target.boolsize;\n+        this.shortsize = target.shortsize;\n+        this.intsize = target.intsize;\n         this.longsize = target.longsize;\n+        this.long_longsize = target.long_longsize;\n         this.long_doublesize = target.long_doublesize;\n         this.wchar_tsize = target.wchar_tsize;\n \n@@ -2271,36 +2275,36 @@ final class CParser(AST) : Parser!AST\n             case TKW.xshort:\n             case TKW.xsigned | TKW.xshort:\n             case TKW.xsigned | TKW.xshort | TKW.xint:\n-            case TKW.xshort | TKW.xint:         t = AST.Type.tint16; break;\n+            case TKW.xshort | TKW.xint:         t = integerTypeForSize(shortsize); break;\n \n             case TKW.xunsigned | TKW.xshort | TKW.xint:\n-            case TKW.xunsigned | TKW.xshort:    t = AST.Type.tuns16; break;\n+            case TKW.xunsigned | TKW.xshort:    t = unsignedTypeForSize(shortsize); break;\n \n             case TKW.xint:\n             case TKW.xsigned:\n-            case TKW.xsigned | TKW.xint:        t = AST.Type.tint32; break;\n+            case TKW.xsigned | TKW.xint:        t = integerTypeForSize(intsize); break;\n \n             case TKW.xunsigned:\n-            case TKW.xunsigned | TKW.xint:      t = AST.Type.tuns32; break;\n+            case TKW.xunsigned | TKW.xint:      t = unsignedTypeForSize(intsize); break;\n \n             case TKW.xlong:\n             case TKW.xsigned | TKW.xlong:\n             case TKW.xsigned | TKW.xlong | TKW.xint:\n-            case TKW.xlong | TKW.xint:          t = longsize == 4 ? AST.Type.tint32 : AST.Type.tint64; break;\n+            case TKW.xlong | TKW.xint:          t = integerTypeForSize(longsize); break;\n \n             case TKW.xunsigned | TKW.xlong | TKW.xint:\n-            case TKW.xunsigned | TKW.xlong:     t = longsize == 4 ? AST.Type.tuns32 : AST.Type.tuns64; break;\n+            case TKW.xunsigned | TKW.xlong:     t = unsignedTypeForSize(longsize); break;\n \n             case TKW.xllong:\n             case TKW.xsigned | TKW.xllong:\n             case TKW.xsigned | TKW.xllong | TKW.xint:\n-            case TKW.xllong | TKW.xint:          t = AST.Type.tint64; break;\n+            case TKW.xllong | TKW.xint:          t = integerTypeForSize(long_longsize); break;\n \n             case TKW.xunsigned | TKW.xllong | TKW.xint:\n-            case TKW.xunsigned | TKW.xllong:     t = AST.Type.tuns64; break;\n+            case TKW.xunsigned | TKW.xllong:     t = unsignedTypeForSize(long_longsize); break;\n \n             case TKW.xvoid:                     t = AST.Type.tvoid; break;\n-            case TKW.xbool:                     t = AST.Type.tbool; break;\n+            case TKW.xbool:                     t = boolsize == 1 ? AST.Type.tbool : integerTypeForSize(boolsize); break;\n \n             case TKW.xfloat:                    t = AST.Type.tfloat32; break;\n             case TKW.xdouble:                   t = AST.Type.tfloat64; break;\n@@ -4378,6 +4382,48 @@ final class CParser(AST) : Parser!AST\n         return stc;\n     }\n \n+    /***********************\n+     * Return suitable signed integer type for the given size\n+     * Params:\n+     *  size = size of type\n+     * Returns:\n+     *  corresponding signed D integer type\n+     */\n+    private AST.Type integerTypeForSize(ubyte size)\n+    {\n+        if (size <= 1)\n+            return AST.Type.tint8;\n+        if (size <= 2)\n+            return AST.Type.tint16;\n+        if (size <= 4)\n+            return AST.Type.tint32;\n+        if (size <= 8)\n+            return AST.Type.tint64;\n+        error(\"unsupported integer type\");\n+        return AST.Type.terror;\n+    }\n+\n+    /***********************\n+     * Return suitable unsigned integer type for the given size\n+     * Params:\n+     *  size = size of type\n+     * Returns:\n+     *  corresponding unsigned D integer type\n+     */\n+    private AST.Type unsignedTypeForSize(ubyte size)\n+    {\n+        if (size <= 1)\n+            return AST.Type.tuns8;\n+        if (size <= 2)\n+            return AST.Type.tuns16;\n+        if (size <= 4)\n+            return AST.Type.tuns32;\n+        if (size <= 8)\n+            return AST.Type.tuns64;\n+        error(\"unsupported integer type\");\n+        return AST.Type.terror;\n+    }\n+\n     /***********************\n      * Return suitable D float type for C `long double`\n      * Params:"}, {"sha": "9564b03f753f1710c04983039583314740f8f276", "filename": "gcc/d/dmd/cppmangle.d", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fcppmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fcppmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcppmangle.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1713,6 +1713,38 @@ extern(C++):\n          * Ds       char16_t\n          * u <source-name>  # vendor extended type\n          */\n+        if (t.isimaginary() || t.iscomplex())\n+        {\n+            // https://issues.dlang.org/show_bug.cgi?id=22806\n+            // Complex and imaginary types are represented in the same way as\n+            // arrays or vectors in C++.  First substitute the outer type, then\n+            // write out the mangle string of the underlying type.\n+            if (substitute(t))\n+                return;\n+            append(t);\n+            CV_qualifiers(t);\n+\n+            if (t.isimaginary())\n+                buf.writeByte('G'); // 'G' means imaginary\n+            else\n+                buf.writeByte('C'); // 'C' means complex\n+\n+            switch (t.ty)\n+            {\n+                case Timaginary32:\n+                case Tcomplex32:\n+                    return Type.tfloat32.accept(this);\n+                case Timaginary64:\n+                case Tcomplex64:\n+                    return Type.tfloat64.accept(this);\n+                case Timaginary80:\n+                case Tcomplex80:\n+                    return Type.tfloat80.accept(this);\n+                default:\n+                    assert(0);\n+            }\n+        }\n+\n         char c;\n         char p = 0;\n         switch (t.ty)\n@@ -1739,12 +1771,6 @@ extern(C++):\n             case Tchar:                  c = 'c';       break;\n             case Twchar:        p = 'D'; c = 's';       break;  // since C++11\n             case Tdchar:        p = 'D'; c = 'i';       break;  // since C++11\n-            case Timaginary32:  p = 'G'; c = 'f';       break;  // 'G' means imaginary\n-            case Timaginary64:  p = 'G'; c = 'd';       break;\n-            case Timaginary80:  p = 'G'; c = 'e';       break;\n-            case Tcomplex32:    p = 'C'; c = 'f';       break;  // 'C' means complex\n-            case Tcomplex64:    p = 'C'; c = 'd';       break;\n-            case Tcomplex80:    p = 'C'; c = 'e';       break;\n \n             default:\n                 return error(t);\n@@ -1889,11 +1915,11 @@ extern(C++):\n         else if (id == Id.__c_ulonglong)\n             return writeBasicType(t, 0, 'y');\n         else if (id == Id.__c_complex_float)\n-            return writeBasicType(t, 'C', 'f');\n+            return Type.tcomplex32.accept(this);\n         else if (id == Id.__c_complex_double)\n-            return writeBasicType(t, 'C', 'd');\n+            return Type.tcomplex64.accept(this);\n         else if (id == Id.__c_complex_real)\n-            return writeBasicType(t, 'C', 'e');\n+            return Type.tcomplex80.accept(this);\n \n         doSymbol(t);\n     }"}, {"sha": "1e6799f63a1119921b3bcfa1671b9c4103f9d3b6", "filename": "gcc/d/dmd/dmangle.d", "status": "modified", "additions": 331, "deletions": 295, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fdmangle.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fdmangle.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -231,168 +231,19 @@ unittest\n     }\n }\n \n-/***********************\n- * Mangle basic type ty to buf.\n- */\n-\n-private void tyToDecoBuffer(OutBuffer* buf, int ty)\n-{\n-    const c = mangleChar[ty];\n-    buf.writeByte(c);\n-    if (c == 'z')\n-        buf.writeByte(ty == Tint128 ? 'i' : 'k');\n-}\n-\n-/*********************************\n- * Mangling for mod.\n- */\n-private void MODtoDecoBuffer(OutBuffer* buf, MOD mod)\n-{\n-    switch (mod)\n-    {\n-    case 0:\n-        break;\n-    case MODFlags.const_:\n-        buf.writeByte('x');\n-        break;\n-    case MODFlags.immutable_:\n-        buf.writeByte('y');\n-        break;\n-    case MODFlags.shared_:\n-        buf.writeByte('O');\n-        break;\n-    case MODFlags.shared_ | MODFlags.const_:\n-        buf.writestring(\"Ox\");\n-        break;\n-    case MODFlags.wild:\n-        buf.writestring(\"Ng\");\n-        break;\n-    case MODFlags.wildconst:\n-        buf.writestring(\"Ngx\");\n-        break;\n-    case MODFlags.shared_ | MODFlags.wild:\n-        buf.writestring(\"ONg\");\n-        break;\n-    case MODFlags.shared_ | MODFlags.wildconst:\n-        buf.writestring(\"ONgx\");\n-        break;\n-    default:\n-        assert(0);\n-    }\n-}\n-\n private extern (C++) final class Mangler : Visitor\n {\n     alias visit = Visitor.visit;\n public:\n     static assert(Key.sizeof == size_t.sizeof);\n-    AssocArray!(Type, size_t) types;        // Type => (offset+1) in buf\n-    AssocArray!(Identifier, size_t) idents; // Identifier => (offset+1) in buf\n+\n     OutBuffer* buf;\n-    Type rootType;\n+    Backref backref;\n \n     extern (D) this(OutBuffer* buf, Type rootType = null)\n     {\n         this.buf = buf;\n-        this.rootType = rootType;\n-    }\n-\n-    /**\n-    * writes a back reference with the relative position encoded with base 26\n-    *  using upper case letters for all digits but the last digit which uses\n-    *  a lower case letter.\n-    * The decoder has to look up the referenced position to determine\n-    *  whether the back reference is an identifier (starts with a digit)\n-    *  or a type (starts with a letter).\n-    *\n-    * Params:\n-    *  pos           = relative position to encode\n-    */\n-    void writeBackRef(size_t pos)\n-    {\n-        buf.writeByte('Q');\n-        enum base = 26;\n-        size_t mul = 1;\n-        while (pos >= mul * base)\n-            mul *= base;\n-        while (mul >= base)\n-        {\n-            auto dig = cast(ubyte)(pos / mul);\n-            buf.writeByte('A' + dig);\n-            pos -= dig * mul;\n-            mul /= base;\n-        }\n-        buf.writeByte('a' + cast(ubyte)pos);\n-    }\n-\n-    /**\n-    * Back references a non-basic type\n-    *\n-    * The encoded mangling is\n-    *       'Q' <relative position of first occurrence of type>\n-    *\n-    * Params:\n-    *  t = the type to encode via back referencing\n-    *\n-    * Returns:\n-    *  true if the type was found. A back reference has been encoded.\n-    *  false if the type was not found. The current position is saved for later back references.\n-    */\n-    bool backrefType(Type t)\n-    {\n-        if (t.isTypeBasic())\n-            return false;\n-\n-        /**\n-         * https://issues.dlang.org/show_bug.cgi?id=21591\n-         *\n-         * Special case for unmerged TypeFunctions: use the generic merged\n-         * function type as backref cache key to avoid missed backrefs.\n-         *\n-         * Merging is based on mangling, so we need to avoid an infinite\n-         * recursion by excluding the case where `t` is the root type passed to\n-         * `mangleToBuffer()`.\n-         */\n-        if (t != rootType)\n-        {\n-            if (t.isFunction_Delegate_PtrToFunction())\n-            {\n-                t = t.merge2();\n-            }\n-        }\n-\n-        return backrefImpl(types, t);\n-    }\n-\n-    /**\n-    * Back references a single identifier\n-    *\n-    * The encoded mangling is\n-    *       'Q' <relative position of first occurrence of type>\n-    *\n-    * Params:\n-    *  id = the identifier to encode via back referencing\n-    *\n-    * Returns:\n-    *  true if the identifier was found. A back reference has been encoded.\n-    *  false if the identifier was not found. The current position is saved for later back references.\n-    */\n-    bool backrefIdentifier(Identifier id)\n-    {\n-        return backrefImpl(idents, id);\n-    }\n-\n-    private extern(D) bool backrefImpl(T)(ref AssocArray!(T, size_t) aa, T key)\n-    {\n-        auto p = aa.getLvalue(key);\n-        if (*p)\n-        {\n-            const offset = *p - 1;\n-            writeBackRef(buf.length - offset);\n-            return true;\n-        }\n-        *p = buf.length + 1;\n-        return false;\n+        this.backref = Backref(rootType);\n     }\n \n     void mangleSymbol(Dsymbol s)\n@@ -402,14 +253,14 @@ public:\n \n     void mangleType(Type t)\n     {\n-        if (!backrefType(t))\n+        if (!backref.addRefToType(buf, t))\n             t.accept(this);\n     }\n \n     void mangleIdentifier(Identifier id, Dsymbol s)\n     {\n-        if (!backrefIdentifier(id))\n-            toBuffer(id.toString(), s);\n+        if (!backref.addRefToIdentifier(buf, id))\n+            toBuffer(buf, id.toString(), s);\n     }\n \n     ////////////////////////////////////////////////////////////////////////////\n@@ -541,7 +392,7 @@ public:\n \n         // Write argument types\n         foreach (idx, param; t.parameterList)\n-            param.accept(this);\n+            mangleParameter(param);\n         //if (buf.data[buf.length - 1] == '@') assert(0);\n         buf.writeByte('Z' - t.parameterList.varargs); // mark end of arg list\n         if (tret !is null)\n@@ -582,7 +433,7 @@ public:\n         //printf(\"TypeTuple.toDecoBuffer() t = %p, %s\\n\", t, t.toChars());\n         visit(cast(Type)t);\n         Parameter._foreach(t.arguments, (idx, param) {\n-                param.accept(this);\n+                mangleParameter(param);\n                 return 0;\n         });\n         buf.writeByte('Z');\n@@ -643,24 +494,8 @@ public:\n             else\n                 buf.writeByte('0');\n \n-            /* There can be multiple different declarations in the same\n-             * function that have the same mangled name.\n-             * This results in localNum having a non-zero number, which\n-             * is used to add a fake parent of the form `__Sddd` to make\n-             * the mangled names unique.\n-             * https://issues.dlang.org/show_bug.cgi?id=20565\n-             */\n             if (localNum)\n-            {\n-                uint ndigits = 1;\n-                auto n = localNum;\n-                while (n >= 10)\n-                {\n-                    n /= 10;\n-                    ++ndigits;\n-                }\n-                buf.printf(\"%u__S%u\", ndigits + 3, localNum);\n-            }\n+                writeLocalParent(buf, localNum);\n         }\n     }\n \n@@ -692,67 +527,6 @@ public:\n         }\n     }\n \n-    /************************************************************\n-     * Write length prefixed string to buf.\n-     */\n-    extern (D) void toBuffer(const(char)[] id, Dsymbol s)\n-    {\n-        const len = id.length;\n-        if (buf.length + len >= 8 * 1024 * 1024) // 8 megs ought be enough for anyone\n-            s.error(\"excessive length %llu for symbol, possible recursive expansion?\", cast(ulong)(buf.length + len));\n-        else\n-        {\n-            buf.print(len);\n-            buf.writestring(id);\n-        }\n-    }\n-\n-    /************************************************************\n-     * Try to obtain an externally mangled identifier from a declaration.\n-     * If the declaration is at global scope or mixed in at global scope,\n-     * the user might want to call it externally, so an externally mangled\n-     * name is returned. Member functions or nested functions can't be called\n-     * externally in C, so in that case null is returned. C++ does support\n-     * namespaces, so extern(C++) always gives a C++ mangled name.\n-     *\n-     * See also: https://issues.dlang.org/show_bug.cgi?id=20012\n-     *\n-     * Params:\n-     *     d = declaration to mangle\n-     *\n-     * Returns:\n-     *     an externally mangled name or null if the declaration cannot be called externally\n-     */\n-    extern (D) static const(char)[] externallyMangledIdentifier(Declaration d)\n-    {\n-        const par = d.toParent(); //toParent() skips over mixin templates\n-        if (!par || par.isModule() || d.linkage == LINK.cpp ||\n-            (d.linkage == LINK.c && d.isCsymbol() && d.isFuncDeclaration()))\n-        {\n-            if (d.linkage != LINK.d && d.localNum)\n-                d.error(\"the same declaration cannot be in multiple scopes with non-D linkage\");\n-            final switch (d.linkage)\n-            {\n-                case LINK.d:\n-                    break;\n-                case LINK.c:\n-                case LINK.windows:\n-                case LINK.objc:\n-                    return d.ident.toString();\n-                case LINK.cpp:\n-                {\n-                    const p = target.cpp.toMangle(d);\n-                    return p.toDString();\n-                }\n-                case LINK.default_:\n-                case LINK.system:\n-                    d.error(\"forward declaration\");\n-                    return d.ident.toString();\n-            }\n-        }\n-        return null;\n-    }\n-\n     override void visit(Declaration d)\n     {\n         //printf(\"Declaration.mangle(this = %p, '%s', parent = '%s', linkage = %d)\\n\",\n@@ -1009,13 +783,13 @@ public:\n                     if (d.mangleOverride)\n                     {\n                         buf.writeByte('X');\n-                        toBuffer(d.mangleOverride, d);\n+                        toBuffer(buf, d.mangleOverride, d);\n                         continue;\n                     }\n                     if (const id = externallyMangledIdentifier(d))\n                     {\n                         buf.writeByte('X');\n-                        toBuffer(id, d);\n+                        toBuffer(buf, id, d);\n                         continue;\n                     }\n                     if (!d.type || !d.type.deco)\n@@ -1052,7 +826,7 @@ public:\n         if (s.ident)\n             mangleIdentifier(s.ident, s);\n         else\n-            toBuffer(s.toString(), s);\n+            toBuffer(buf, s.toString(), s);\n         //printf(\"Dsymbol.mangle() %s = %s\\n\", s.toChars(), id);\n     }\n \n@@ -1080,68 +854,15 @@ public:\n     override void visit(RealExp e)\n     {\n         buf.writeByte('e');\n-        realToMangleBuffer(e.value);\n-    }\n-\n-    void realToMangleBuffer(real_t value)\n-    {\n-        /* Rely on %A to get portable mangling.\n-         * Must munge result to get only identifier characters.\n-         *\n-         * Possible values from %A  => mangled result\n-         * NAN                      => NAN\n-         * -INF                     => NINF\n-         * INF                      => INF\n-         * -0X1.1BC18BA997B95P+79   => N11BC18BA997B95P79\n-         * 0X1.9P+2                 => 19P2\n-         */\n-        if (CTFloat.isNaN(value))\n-        {\n-            buf.writestring(\"NAN\"); // no -NAN bugs\n-            return;\n-        }\n-\n-        if (value < CTFloat.zero)\n-        {\n-            buf.writeByte('N');\n-            value = -value;\n-        }\n-\n-        if (CTFloat.isInfinity(value))\n-        {\n-            buf.writestring(\"INF\");\n-            return;\n-        }\n-\n-        char[36] buffer = void;\n-        // 'A' format yields [-]0xh.hhhhp+-d\n-        const n = CTFloat.sprint(buffer.ptr, 'A', value);\n-        assert(n < buffer.length);\n-        foreach (const c; buffer[2 .. n])\n-        {\n-            switch (c)\n-            {\n-                case '-':\n-                    buf.writeByte('N');\n-                    break;\n-\n-                case '+':\n-                case '.':\n-                    break;\n-\n-                default:\n-                    buf.writeByte(c);\n-                    break;\n-            }\n-        }\n+        realToMangleBuffer(buf, e.value);\n     }\n \n     override void visit(ComplexExp e)\n     {\n         buf.writeByte('c');\n-        realToMangleBuffer(e.toReal());\n+        realToMangleBuffer(buf, e.toReal());\n         buf.writeByte('c'); // separate the two\n-        realToMangleBuffer(e.toImaginary());\n+        realToMangleBuffer(buf, e.toImaginary());\n     }\n \n     override void visit(NullExp e)\n@@ -1258,7 +979,7 @@ public:\n \n     ////////////////////////////////////////////////////////////////////////////\n \n-    override void visit(Parameter p)\n+    void mangleParameter(Parameter p)\n     {\n         // https://dlang.org/spec/abi.html#Parameter\n \n@@ -1331,3 +1052,318 @@ public:\n         visitWithMask(p.type, (stc & STC.in_) ? MODFlags.const_ : 0);\n     }\n }\n+\n+/***************************************\n+ * Manage back reference mangling\n+ */\n+private struct Backref\n+{\n+    /**\n+    * Back references a non-basic type\n+    *\n+    * The encoded mangling is\n+    *       'Q' <relative position of first occurrence of type>\n+    *\n+    * Params:\n+    *  t = the type to encode via back referencing\n+    *\n+    * Returns:\n+    *  true if the type was found. A back reference has been encoded.\n+    *  false if the type was not found. The current position is saved for later back references.\n+    */\n+    bool addRefToType(OutBuffer* buf, Type t)\n+    {\n+        if (t.isTypeBasic())\n+            return false;\n+\n+        /**\n+         * https://issues.dlang.org/show_bug.cgi?id=21591\n+         *\n+         * Special case for unmerged TypeFunctions: use the generic merged\n+         * function type as backref cache key to avoid missed backrefs.\n+         *\n+         * Merging is based on mangling, so we need to avoid an infinite\n+         * recursion by excluding the case where `t` is the root type passed to\n+         * `mangleToBuffer()`.\n+         */\n+        if (t != rootType)\n+        {\n+            if (t.isFunction_Delegate_PtrToFunction())\n+            {\n+                t = t.merge2();\n+            }\n+        }\n+\n+        return backrefImpl(buf, types, t);\n+    }\n+\n+    /**\n+    * Back references a single identifier\n+    *\n+    * The encoded mangling is\n+    *       'Q' <relative position of first occurrence of type>\n+    *\n+    * Params:\n+    *  id = the identifier to encode via back referencing\n+    *\n+    * Returns:\n+    *  true if the identifier was found. A back reference has been encoded.\n+    *  false if the identifier was not found. The current position is saved for later back references.\n+    */\n+    bool addRefToIdentifier(OutBuffer* buf, Identifier id)\n+    {\n+        return backrefImpl(buf, idents, id);\n+    }\n+\n+  private:\n+\n+    extern(D) bool backrefImpl(T)(OutBuffer* buf, ref AssocArray!(T, size_t) aa, T key)\n+    {\n+        auto p = aa.getLvalue(key);\n+        if (*p)\n+        {\n+            const offset = *p - 1;\n+            writeBackRef(buf, buf.length - offset);\n+            return true;\n+        }\n+        *p = buf.length + 1;\n+        return false;\n+    }\n+\n+    Type rootType;                          /// avoid infinite recursion\n+    AssocArray!(Type, size_t) types;        /// Type => (offset+1) in buf\n+    AssocArray!(Identifier, size_t) idents; /// Identifier => (offset+1) in buf\n+}\n+\n+\n+/***********************\n+ * Mangle basic type ty to buf.\n+ */\n+\n+private void tyToDecoBuffer(OutBuffer* buf, int ty)\n+{\n+    const c = mangleChar[ty];\n+    buf.writeByte(c);\n+    if (c == 'z')\n+        buf.writeByte(ty == Tint128 ? 'i' : 'k');\n+}\n+\n+/*********************************\n+ * Mangling for mod.\n+ */\n+private void MODtoDecoBuffer(OutBuffer* buf, MOD mod)\n+{\n+    switch (mod)\n+    {\n+    case 0:\n+        break;\n+    case MODFlags.const_:\n+        buf.writeByte('x');\n+        break;\n+    case MODFlags.immutable_:\n+        buf.writeByte('y');\n+        break;\n+    case MODFlags.shared_:\n+        buf.writeByte('O');\n+        break;\n+    case MODFlags.shared_ | MODFlags.const_:\n+        buf.writestring(\"Ox\");\n+        break;\n+    case MODFlags.wild:\n+        buf.writestring(\"Ng\");\n+        break;\n+    case MODFlags.wildconst:\n+        buf.writestring(\"Ngx\");\n+        break;\n+    case MODFlags.shared_ | MODFlags.wild:\n+        buf.writestring(\"ONg\");\n+        break;\n+    case MODFlags.shared_ | MODFlags.wildconst:\n+        buf.writestring(\"ONgx\");\n+        break;\n+    default:\n+        assert(0);\n+    }\n+}\n+\n+\n+/**\n+ * writes a back reference with the relative position encoded with base 26\n+ *  using upper case letters for all digits but the last digit which uses\n+ *  a lower case letter.\n+ * The decoder has to look up the referenced position to determine\n+ *  whether the back reference is an identifier (starts with a digit)\n+ *  or a type (starts with a letter).\n+ *\n+ * Params:\n+ *  buf           = buffer to write to\n+ *  pos           = relative position to encode\n+ */\n+private\n+void writeBackRef(OutBuffer* buf, size_t pos)\n+{\n+    buf.writeByte('Q');\n+    enum base = 26;\n+    size_t mul = 1;\n+    while (pos >= mul * base)\n+        mul *= base;\n+    while (mul >= base)\n+    {\n+        auto dig = cast(ubyte)(pos / mul);\n+        buf.writeByte('A' + dig);\n+        pos -= dig * mul;\n+        mul /= base;\n+    }\n+    buf.writeByte('a' + cast(ubyte)pos);\n+}\n+\n+\n+/************************************************************\n+ * Write length prefixed string to buf.\n+ */\n+private\n+extern (D) void toBuffer(OutBuffer* buf, const(char)[] id, Dsymbol s)\n+{\n+    const len = id.length;\n+    if (buf.length + len >= 8 * 1024 * 1024) // 8 megs ought be enough for anyone\n+        s.error(\"excessive length %llu for symbol, possible recursive expansion?\", cast(ulong)(buf.length + len));\n+    else\n+    {\n+        buf.print(len);\n+        buf.writestring(id);\n+    }\n+}\n+\n+\n+/*****\n+ * There can be multiple different declarations in the same\n+ * function that have the same mangled name.\n+ * This results in localNum having a non-zero number, which\n+ * is used to add a fake parent of the form `__Sddd` to make\n+ * the mangled names unique.\n+ * https://issues.dlang.org/show_bug.cgi?id=20565\n+ * Params:\n+ *      buf = buffer to write to\n+ *      localNum = local symbol number\n+ */\n+private\n+void writeLocalParent(OutBuffer* buf, uint localNum)\n+{\n+    uint ndigits = 1;\n+    auto n = localNum;\n+    while (n >= 10)\n+    {\n+        n /= 10;\n+        ++ndigits;\n+    }\n+    buf.printf(\"%u__S%u\", ndigits + 3, localNum);\n+}\n+\n+/*************************\n+ * Write real to buffer.\n+ * Params:\n+ *      buf = buffer to write to\n+ *      value = real to write\n+ */\n+private\n+void realToMangleBuffer(OutBuffer* buf, real_t value)\n+{\n+    /* Rely on %A to get portable mangling.\n+     * Must munge result to get only identifier characters.\n+     *\n+     * Possible values from %A  => mangled result\n+     * NAN                      => NAN\n+     * -INF                     => NINF\n+     * INF                      => INF\n+     * -0X1.1BC18BA997B95P+79   => N11BC18BA997B95P79\n+     * 0X1.9P+2                 => 19P2\n+     */\n+    if (CTFloat.isNaN(value))\n+    {\n+        buf.writestring(\"NAN\"); // no -NAN bugs\n+        return;\n+    }\n+\n+    if (value < CTFloat.zero)\n+    {\n+        buf.writeByte('N');\n+        value = -value;\n+    }\n+\n+    if (CTFloat.isInfinity(value))\n+    {\n+        buf.writestring(\"INF\");\n+        return;\n+    }\n+\n+    char[36] buffer = void;\n+    // 'A' format yields [-]0xh.hhhhp+-d\n+    const n = CTFloat.sprint(buffer.ptr, 'A', value);\n+    assert(n < buffer.length);\n+    foreach (const c; buffer[2 .. n])\n+    {\n+        switch (c)\n+        {\n+            case '-':\n+                buf.writeByte('N');\n+                break;\n+\n+            case '+':\n+            case '.':\n+                break;\n+\n+            default:\n+                buf.writeByte(c);\n+                break;\n+        }\n+    }\n+}\n+\n+/************************************************************\n+ * Try to obtain an externally mangled identifier from a declaration.\n+ * If the declaration is at global scope or mixed in at global scope,\n+ * the user might want to call it externally, so an externally mangled\n+ * name is returned. Member functions or nested functions can't be called\n+ * externally in C, so in that case null is returned. C++ does support\n+ * namespaces, so extern(C++) always gives a C++ mangled name.\n+ *\n+ * See also: https://issues.dlang.org/show_bug.cgi?id=20012\n+ *\n+ * Params:\n+ *     d = declaration to mangle\n+ *\n+ * Returns:\n+ *     an externally mangled name or null if the declaration cannot be called externally\n+ */\n+private\n+extern (D) const(char)[] externallyMangledIdentifier(Declaration d)\n+{\n+    const par = d.toParent(); //toParent() skips over mixin templates\n+    if (!par || par.isModule() || d.linkage == LINK.cpp ||\n+        (d.linkage == LINK.c && d.isCsymbol() && d.isFuncDeclaration()))\n+    {\n+        if (d.linkage != LINK.d && d.localNum)\n+            d.error(\"the same declaration cannot be in multiple scopes with non-D linkage\");\n+        final switch (d.linkage)\n+        {\n+            case LINK.d:\n+                break;\n+            case LINK.c:\n+            case LINK.windows:\n+            case LINK.objc:\n+                return d.ident.toString();\n+            case LINK.cpp:\n+            {\n+                const p = target.cpp.toMangle(d);\n+                return p.toDString();\n+            }\n+            case LINK.default_:\n+            case LINK.system:\n+                d.error(\"forward declaration\");\n+                return d.ident.toString();\n+        }\n+    }\n+    return null;\n+}\n+\n+"}, {"sha": "6568442c17a8f9926543b3500e82a1bba1f4d5e5", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -615,6 +615,14 @@ extern (C++) final class Module : Package\n             const dmdConfFile = global.inifilename.length ? FileName.canonicalName(global.inifilename) : \"not found\";\n             errorSupplemental(loc, \"config file: %.*s\", cast(int)dmdConfFile.length, dmdConfFile.ptr);\n         }\n+        else if (FileName.ext(this.arg) || !loc.isValid())\n+        {\n+            // Modules whose original argument name has an extension, or do not\n+            // have a valid location come from the command-line.\n+            // Error that their file cannot be found and return early.\n+            .error(loc, \"cannot find input file `%s`\", srcfile.toChars());\n+            return false;\n+        }\n         else\n         {\n             // if module is not named 'package' but we're trying to read 'package.d', we're looking for a package module"}, {"sha": "ef25717e79f55d2d17f159d7ce4abaca013c7e3f", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -464,8 +464,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n         //printf(\"sc.stc = %x\\n\", sc.stc);\n         //printf(\"storage_class = x%x\\n\", storage_class);\n \n-        if (global.params.vcomplex)\n-            dsym.type.checkComplexTransition(dsym.loc, sc);\n+        dsym.type.checkComplexTransition(dsym.loc, sc);\n \n         // Calculate type size + safety checks\n         if (sc.func && !sc.intypeof)"}, {"sha": "6692fb9717ec5ecc38c1772c32195938ef77b71f", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -3285,8 +3285,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         else\n             assert(0);\n \n-        if (global.params.vcomplex)\n-            exp.type.checkComplexTransition(exp.loc, sc);\n+        exp.type.checkComplexTransition(exp.loc, sc);\n \n         result = e;\n     }\n@@ -5375,8 +5374,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             return setError();\n         }\n \n-        if (global.params.vcomplex)\n-            ta.checkComplexTransition(exp.loc, sc);\n+        ta.checkComplexTransition(exp.loc, sc);\n \n         Expression e;\n         auto tb = ta.toBasetype();"}, {"sha": "7e0f404dd73a27c023a4f3ddab55421ee856944b", "filename": "gcc/d/dmd/file_manager.d", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -185,11 +185,7 @@ nothrow:\n         if (res == 1)\n             return readToFileBuffer(name);\n \n-        const fullName = lookForSourceFile(name, global.path ? (*global.path)[] : null);\n-        if (!fullName)\n-            return null;\n-\n-        return readToFileBuffer(fullName);\n+        return null;\n     }\n \n     extern(C++) FileBuffer* lookup(const(char)* filename)"}, {"sha": "afc0ebbee16364b4874f5af2f705b5ac0beb1d8d", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -549,9 +549,22 @@ extern (C++) class FuncDeclaration : Declaration\n             if (thandle.ty == Tstruct)\n             {\n                 vthis.storage_class |= STC.ref_;\n-                // if member function is marked 'inout', then 'this' is 'return ref'\n-                if (type.ty == Tfunction && (cast(TypeFunction)type).isInOutQual())\n-                    vthis.storage_class |= STC.return_;\n+\n+                /* if member function is marked 'inout', then 'this' is 'return ref'\n+                 * The same thing is done for `ref inout` parameters in TypeFunction's semantic routine.\n+                 */\n+                if (auto tf = type.isTypeFunction())\n+                {\n+                    /* This feature was a mistake, but existing code relies on it.\n+                     * So only disable it in @safe code and DIP1000 code\n+                     */\n+                    if (!(global.params.useDIP1000 == FeatureState.enabled &&\n+                          tf.trust == TRUST.safe))\n+                    {\n+                        if (tf.isInOutQual())\n+                            vthis.storage_class |= STC.return_;\n+                    }\n+                }\n             }\n         }\n "}, {"sha": "6377e9c7deaa4b13bace2f93aa5894f9e8e492c7", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -60,7 +60,11 @@ class Lexer\n     bool Ccompile;              /// true if compiling ImportC\n \n     // The following are valid only if (Ccompile == true)\n+    ubyte boolsize;             /// size of a C _Bool, default 1\n+    ubyte shortsize;            /// size of a C short, default 2\n+    ubyte intsize;              /// size of a C int, default 4\n     ubyte longsize;             /// size of C long, 4 or 8\n+    ubyte long_longsize;        /// size of a C long long, default 8\n     ubyte long_doublesize;      /// size of C long double, 8 or D real.sizeof\n     ubyte wchar_tsize;          /// size of C wchar_t, 2 or 4\n \n@@ -2312,7 +2316,7 @@ class Lexer\n             case FLAGS.decimal | FLAGS.long_:\n                 /* First that fits: long, long long\n                  */\n-                if (longsize == 4)\n+                if (longsize == 4 || long_longsize == 4)\n                 {\n                     if (n & 0xFFFFFFFF_80000000L)\n                         result = TOK.int64Literal;\n@@ -2329,7 +2333,7 @@ class Lexer\n                 /* First that fits: long, unsigned long, long long,\n                  * unsigned long long\n                  */\n-                if (longsize == 4)\n+                if (longsize == 4 || long_longsize == 4)\n                 {\n                     if (n & 0x8000000000000000L)\n                         result = TOK.uns64Literal;\n@@ -2353,7 +2357,7 @@ class Lexer\n             case FLAGS.decimal  | FLAGS.unsigned | FLAGS.long_:\n                 /* First that fits: unsigned long, unsigned long long\n                  */\n-                if (longsize == 4)\n+                if (longsize == 4 || long_longsize == 4)\n                 {\n                     if (n & 0xFFFFFFFF00000000L)\n                         result = TOK.uns64Literal;\n@@ -2710,6 +2714,8 @@ class Lexer\n             case '2':\n             case '3':\n             case '4':\n+                if (!linemarker)\n+                    goto Lerr;\n                 flags = true;   // linemarker flags seen\n                 ++p;\n                 if ('0' <= *p && *p <= '9')"}, {"sha": "9297ad9dd03693ca94ec4a9dd6cac2a924d4b531", "filename": "gcc/d/dmd/mtype.d", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fmtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fmtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -648,7 +648,15 @@ extern (C++) abstract class Type : ASTNode\n                     goto Lcovariant;\n             }\n             else if (t1n.ty == t2n.ty && t1n.implicitConvTo(t2n))\n+            {\n+                if (t1.isref && t2.isref)\n+                {\n+                    // Treat like pointers to t1n and t2n\n+                    if (t1n.constConv(t2n) < MATCH.constant)\n+                        goto Lnotcovariant;\n+                }\n                 goto Lcovariant;\n+            }\n             else if (t1n.ty == Tnull)\n             {\n                 // NULL is covariant with any pointer type, but not with any"}, {"sha": "1f33c184800ecf94d06893682aafbefa365809ec", "filename": "gcc/d/dmd/root/file.d", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Froot%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffile.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -97,13 +97,13 @@ nothrow:\n             int fd = name.toCStringThen!(slice => open(slice.ptr, O_RDONLY));\n             if (fd == -1)\n             {\n-                //printf(\"\\topen error, errno = %d\\n\",errno);\n+                //perror(\"\\topen error\");\n                 return result;\n             }\n             //printf(\"\\tfile opened\\n\");\n             if (fstat(fd, &buf))\n             {\n-                perror(\"\\tfstat error\");\n+                //perror(\"\\tfstat error\");\n                 close(fd);\n                 return result;\n             }\n@@ -112,12 +112,12 @@ nothrow:\n             numread = .read(fd, buffer, size);\n             if (numread != size)\n             {\n-                perror(\"\\tread error\");\n+                //perror(\"\\tread error\");\n                 goto err2;\n             }\n             if (close(fd) == -1)\n             {\n-                perror(\"\\tclose error\");\n+                //perror(\"\\tclose error\");\n                 goto err;\n             }\n             // Always store a wchar ^Z past end of buffer so scanner has a\n@@ -289,3 +289,35 @@ nothrow:\n     }\n }\n \n+private\n+{\n+    version (linux) version (PPC)\n+    {\n+        // https://issues.dlang.org/show_bug.cgi?id=22823\n+        // Define our own version of stat_t, as older versions of the compiler\n+        // had the st_size field at the wrong offset on PPC.\n+        alias stat_t_imported = core.sys.posix.sys.stat.stat_t;\n+        static if (stat_t_imported.st_size.offsetof != 48)\n+        {\n+            extern (C) nothrow @nogc:\n+            struct stat_t\n+            {\n+                ulong[6] __pad1;\n+                ulong st_size;\n+                ulong[6] __pad2;\n+            }\n+            version (CRuntime_Glibc)\n+            {\n+                int fstat64(int, stat_t*) @trusted;\n+                alias fstat = fstat64;\n+                int stat64(const scope char*, stat_t*) @system;\n+                alias stat = stat64;\n+            }\n+            else\n+            {\n+                int fstat(int, stat_t*) @trusted;\n+                int stat(const scope char*, stat_t*) @system;\n+            }\n+        }\n+    }\n+}"}, {"sha": "9b9460d326976670e4bd726907f77119a069456f", "filename": "gcc/d/dmd/root/speller.d", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Froot%2Fspeller.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Froot%2Fspeller.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fspeller.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -42,6 +42,7 @@ private:\n \n import core.stdc.stdlib;\n import core.stdc.string;\n+import dmd.common.string : SmallBuffer;\n \n enum isSearchFunction(alias fun) = is(searchFunctionType!fun);\n alias searchFunctionType(alias fun) = typeof(() {int x; return fun(\"\", x);}());\n@@ -63,15 +64,8 @@ auto spellerX(alias dg)(const(char)[] seed, bool flag)\n     /* Need buffer to store trial strings in\n      */\n     char[30] tmp = void;\n-    char[] buf;\n-    if (seed.length <= tmp.sizeof - 1)\n-        buf = tmp;\n-    else\n-    {\n-        buf = (cast(char*)alloca(seed.length + 1))[0 .. seed.length + 1]; // leave space for extra char\n-        if (!buf.ptr)\n-            return null; // no matches\n-    }\n+    auto sb = SmallBuffer!char(seed.length + 1, tmp[]);\n+    char[] buf = sb[];\n \n     int cost = int.max;\n     searchFunctionType!dg p = null;\n@@ -164,15 +158,8 @@ auto spellerY(alias dg)(const(char)[] seed, size_t index, out int cost)\n      * space for an extra char for insertions\n      */\n     char[30] tmp = void;        // stack allocations are fastest\n-    char[] buf;\n-    if (seed.length <= tmp.sizeof - 1)\n-        buf = tmp;\n-    else\n-    {\n-        buf = (cast(char*)alloca(seed.length + 1))[0 .. seed.length + 1]; // leave space for extra char\n-        if (!buf.ptr)\n-            return null; // no matches\n-    }\n+    auto sb = SmallBuffer!char(seed.length + 1, tmp[]);\n+    char[] buf = sb[];\n     buf[0 .. index] = seed[0 .. index];\n \n     cost = int.max;             // start with worst possible match"}, {"sha": "ec62292d7dfcf021f13d4e21776c0adbe63b56b9", "filename": "gcc/d/dmd/root/string.d", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Froot%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Froot%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Fstring.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -69,17 +69,12 @@ The return value of `T`\n auto toCStringThen(alias dg)(const(char)[] src) nothrow\n {\n     import dmd.root.rmem : mem;\n+    import dmd.common.string : SmallBuffer;\n \n     const len = src.length + 1;\n     char[512] small = void;\n-    scope ptr = (src.length < (small.length - 1))\n-                    ? small[0 .. len]\n-                    : (cast(char*)mem.xmalloc(len))[0 .. len];\n-    scope (exit)\n-    {\n-        if (&ptr[0] != &small[0])\n-            mem.xfree(&ptr[0]);\n-    }\n+    auto sb = SmallBuffer!char(len, small[]);\n+    scope ptr = sb[];\n     ptr[0 .. src.length] = src[];\n     ptr[src.length] = '\\0';\n     return dg(ptr);"}, {"sha": "b706777a1ed954d6c33151aff3bb139b1505800a", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -468,7 +468,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     {\n                         stc |= STC.variadic;\n                         auto vtypeb = vtype.toBasetype();\n-                        if (vtypeb.ty == Tarray)\n+                        if (vtypeb.ty == Tarray || vtypeb.ty == Tclass)\n                         {\n                             /* Since it'll be pointing into the stack for the array\n                              * contents, it needs to be `scope`\n@@ -620,7 +620,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                         funcdecl.checkDmain();       // Check main() parameters and return type\n                 }\n \n-                if (global.params.vcomplex && f.next !is null)\n+                if (f.next !is null)\n                     f.next.checkComplexTransition(funcdecl.loc, sc);\n \n                 if (funcdecl.returns && !funcdecl.fbody.isErrorStatement())\n@@ -1292,17 +1292,13 @@ private extern(C++) final class Semantic3Visitor : Visitor\n         // Eliminate maybescope's\n         {\n             // Create and fill array[] with maybe candidates from the `this` and the parameters\n-            VarDeclaration[] array = void;\n-\n             VarDeclaration[10] tmp = void;\n             size_t dim = (funcdecl.vthis !is null) + (funcdecl.parameters ? funcdecl.parameters.dim : 0);\n-            if (dim <= tmp.length)\n-                array = tmp[0 .. dim];\n-            else\n-            {\n-                auto ptr = cast(VarDeclaration*)mem.xmalloc(dim * VarDeclaration.sizeof);\n-                array = ptr[0 .. dim];\n-            }\n+\n+            import dmd.common.string : SmallBuffer;\n+            auto sb = SmallBuffer!VarDeclaration(dim, tmp[]);\n+            VarDeclaration[] array = sb[];\n+\n             size_t n = 0;\n             if (funcdecl.vthis)\n                 array[n++] = funcdecl.vthis;\n@@ -1313,11 +1309,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     array[n++] = v;\n                 }\n             }\n-\n             eliminateMaybeScopes(array[0 .. n]);\n-\n-            if (dim > tmp.length)\n-                mem.xfree(array.ptr);\n         }\n \n         // Infer STC.scope_"}, {"sha": "7b9c454b33afc120547d53ce2f9604f6ca0fa62a", "filename": "gcc/d/dmd/target.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftarget.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftarget.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -331,7 +331,11 @@ struct TargetC\n         Gcc_Clang,            /// gcc and clang\n     }\n     bool  crtDestructorsSupported = true; /// Not all platforms support crt_destructor\n+    ubyte boolsize;           /// size of a C `_Bool` type\n+    ubyte shortsize;          /// size of a C `short` or `unsigned short` type\n+    ubyte intsize;            /// size of a C `int` or `unsigned int` type\n     ubyte longsize;           /// size of a C `long` or `unsigned long` type\n+    ubyte long_longsize;      /// size of a C `long long` or `unsigned long long` type\n     ubyte long_doublesize;    /// size of a C `long double`\n     ubyte wchar_tsize;        /// size of a C `wchar_t` type\n     Runtime runtime;          /// vendor of the C runtime to link against"}, {"sha": "f3d3859e2244d772659f55625b17b88e537c4549", "filename": "gcc/d/dmd/target.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftarget.h?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -70,7 +70,11 @@ struct TargetC\n     };\n \n     uint8_t crtDestructorsSupported; // Not all platforms support crt_destructor\n+    uint8_t boolsize;            // size of a C '_Bool' type\n+    uint8_t shortsize;           // size of a C 'short' or 'unsigned short' type\n+    uint8_t intsize;             // size of a C 'int' or 'unsigned int' type\n     uint8_t longsize;            // size of a C 'long' or 'unsigned long' type\n+    uint8_t long_longsize;       // size of a C 'long long' or 'unsigned long long' type\n     uint8_t long_doublesize;     // size of a C 'long double'\n     uint8_t wchar_tsize;         // size of a C 'wchar_t' type\n     Runtime runtime;"}, {"sha": "c23e0fb4a0135bbc6278afe369d175a0f5c33e04", "filename": "gcc/d/dmd/tokens.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftokens.h?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -67,7 +67,7 @@ enum class TOK : unsigned char\n     comment,\n \n     // Operators\n-    lessThan,       // 54\n+    lessThan,\n     greaterThan,\n     lessOrEqual,\n     greaterOrEqual,\n@@ -77,7 +77,7 @@ enum class TOK : unsigned char\n     notIdentity,\n     is_,\n \n-    leftShift,      // 64\n+    leftShift,\n     rightShift,\n     leftShiftAssign,\n     rightShiftAssign,\n@@ -112,7 +112,7 @@ enum class TOK : unsigned char\n     orOr,\n \n     // Numeric literals\n-    int32Literal,   // 104,\n+    int32Literal,\n     uns32Literal,\n     int64Literal,\n     uns64Literal,\n@@ -126,20 +126,20 @@ enum class TOK : unsigned char\n     imaginary80Literal,\n \n     // Char constants\n-    charLiteral,    // 116,\n+    charLiteral,\n     wcharLiteral,\n     dcharLiteral,\n \n     // Leaf operators\n-    identifier,     // 119,\n+    identifier,\n     string_,\n     hexadecimalString,\n     this_,\n     super_,\n     error,\n \n     // Basic types\n-    void_,          // 127\n+    void_,\n     int8,\n     uns8,\n     int16,\n@@ -165,7 +165,7 @@ enum class TOK : unsigned char\n     bool_,\n \n     // Aggregates\n-    struct_,        // 151\n+    struct_,\n     class_,\n     interface_,\n     union_,\n@@ -197,7 +197,7 @@ enum class TOK : unsigned char\n     immutable_,\n \n     // Statements\n-    if_,            // 181\n+    if_,\n     else_,\n     while_,\n     for_,\n@@ -223,7 +223,7 @@ enum class TOK : unsigned char\n     onScopeSuccess,\n \n     // Contracts\n-    invariant_,     // 205\n+    invariant_,\n \n     // Testing\n     unittest_,\n@@ -233,7 +233,7 @@ enum class TOK : unsigned char\n     ref_,\n     macro_,\n \n-    parameters,     // 210\n+    parameters,\n     traits,\n     pure_,\n     nothrow_,"}, {"sha": "616025181632c2229b577198fc1f5c14c2a548a9", "filename": "gcc/d/dmd/traits.d", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftraits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftraits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftraits.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -568,11 +568,8 @@ Expression semanticTraits(TraitsExp e, Scope* sc)\n     }\n     if (e.ident == Id.isDeprecated)\n     {\n-        if (global.params.vcomplex)\n-        {\n-            if (isTypeX(t => t.iscomplex() || t.isimaginary()).toBool().hasValue(true))\n-                return True();\n-        }\n+        if (isTypeX(t => t.iscomplex() || t.isimaginary()).toBool().hasValue(true))\n+            return True();\n         return isDsymX(t => t.isDeprecated());\n     }\n     if (e.ident == Id.isFuture)"}, {"sha": "1f038363dfed207b98b91416cceb0d2d3752d035", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1151,7 +1151,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n             return mtype;\n         }\n         //printf(\"TypeFunction::semantic() this = %p\\n\", this);\n-        //printf(\"TypeFunction::semantic() %s, sc.stc = %llx, fargs = %p\\n\", toChars(), sc.stc, fargs);\n+        //printf(\"TypeFunction::semantic() %s, sc.stc = %llx\\n\", mtype.toChars(), sc.stc);\n \n         bool errors = false;\n \n@@ -1458,6 +1458,17 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                             fparam.storageClass &= ~STC.return_;   // https://issues.dlang.org/show_bug.cgi?id=18963\n                         }\n                     }\n+\n+                    if (i + 1 == dim && tf.parameterList.varargs == VarArg.typesafe &&\n+                        (t.isTypeDArray() || t.isTypeClass()))\n+                    {\n+                        /* This is because they can be constructed on the stack\n+                         * https://dlang.org/spec/function.html#typesafe_variadic_functions\n+                         */\n+                        .error(loc, \"typesafe variadic function parameter `%s` of type `%s` cannot be marked `return`\",\n+                            fparam.ident ? fparam.ident.toChars() : \"\", t.toChars());\n+                        errors = true;\n+                    }\n                 }\n \n                 if (fparam.storageClass & STC.out_)"}, {"sha": "4591f687c07ebb738b2a727c9d7bda69a30c703b", "filename": "gcc/testsuite/gdc.dg/simd18489.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd18489.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd18489.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fsimd18489.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -0,0 +1,8 @@\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do compile { target { avx_runtime || vect_sizes_16B_8B } } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+import core.simd;\n+\n+double dot (double2 a) {\n+    return a.ptr[0] * a.ptr[1];\n+}"}, {"sha": "d277f5366da92719ce3409a7c5c65f8019c3ccd1", "filename": "gcc/testsuite/gdc.dg/torture/simd21727.d", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd21727.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd21727.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd21727.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1,7 +1,7 @@\n-// REQUIRED_ARGS: -m64 -O -inline\n-// DISABLED: win32 linux32 freebsd32 osx32 netbsd32 dragonflybsd32\n // https://issues.dlang.org/show_bug.cgi?id=21727\n-\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do run { target { avx_runtime || vect_sizes_16B_8B } } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n import core.simd;\n \n @nogc nothrow pure @safe:\n@@ -25,10 +25,7 @@ pragma(inline, false) Float4 identity(Float4 a)\n \n pragma(inline, true) Float4 twoTimes(const ref Float4 a)\n {\n-    version (D_SIMD)\n-        return Float4(cast(float4) __simd(XMM.ADDPS, a.mVector, a.mVector));\n-    else // Allow non-DMD compilers to compile this test.\n-        return Float4(a.mVector + a.mVector);\n+    return Float4(a.mVector + a.mVector);\n }\n \n pragma(inline, false) Float4 fourTimes(const Float4 a)", "previous_filename": "gcc/testsuite/gdc.test/runnable/ice21727.d"}, {"sha": "38c9924f63e0d928f7d76846b3e5eb99c0be992d", "filename": "gcc/testsuite/gdc.dg/torture/simd7413a.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd7413a.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd7413a.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Ftorture%2Fsimd7413a.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -2,7 +2,6 @@\n // { dg-additional-options \"-mavx\" { target avx_runtime } }\n // { dg-do run { target { avx_runtime || vect_sizes_16B_8B } } }\n // { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n-// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n import core.simd;\n \n void main()"}, {"sha": "23433d5861f7e5793078f9cbeb1ececf204fdeda", "filename": "gcc/testsuite/gdc.dg/ubsan/pr88957.d", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Fubsan%2Fpr88957.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.dg%2Fubsan%2Fpr88957.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fubsan%2Fpr88957.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1,5 +1,6 @@\n // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=88957\n-// { dg-do compile }\n+// { dg-additional-options \"-mavx\" { target avx_runtime } }\n+// { dg-do compile { target { avx_runtime || vect_sizes_16B_8B } } }\n // { dg-additional-options \"-fsanitize=undefined\" }\n \n alias int4 = __vector(int[4]);"}, {"sha": "2cc386f307ac59992f1e124ebe6ca6d8870a4c07", "filename": "gcc/testsuite/gdc.test/compilable/b18489.d", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c89274d7f82810724126637ffdc5507d442f0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb18489.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c89274d7f82810724126637ffdc5507d442f0/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb18489.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fb18489.d?ref=430c89274d7f82810724126637ffdc5507d442f0", "patch": "@@ -1,8 +0,0 @@\n-// REQUIRED_ARGS: -O -m64\n-import core.simd;\n-\n-double dot (double2 a) {\n-    return a.ptr[0] * a.ptr[1];\n-}\n-\n-void main () { }"}, {"sha": "a5536325adea1ad89889a6de2b6bf7d360881e4d", "filename": "gcc/testsuite/gdc.test/compilable/issue21390.d", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21390.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21390.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fissue21390.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -0,0 +1,3 @@\n+struct S { @disable this(); }\n+// Does not compile: \"default construction is disabled for type `S`\"\n+extern __gshared S gVariable1;"}, {"sha": "5f371da46c8bb20c88feef4d50f9a60d631c735d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail17927.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17927.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17927.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail17927.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -2,11 +2,11 @@\n  * TEST_OUTPUT:\n ---\n fail_compilation/fail17927.d(13): Error: scope variable `this` may not be returned\n+fail_compilation/fail17927.d(15): Error: scope variable `this` may not be returned\n fail_compilation/fail17927.d(21): Error: scope variable `ptr` may not be returned\n fail_compilation/fail17927.d(23): Error: scope variable `ptr` may not be returned\n ---\n */\n-\n // https://issues.dlang.org/show_bug.cgi?id=17927\n \n struct String {"}, {"sha": "11b9c5489935a13b7e0e81cb198178299fc1488d", "filename": "gcc/testsuite/gdc.test/fail_compilation/fix17751.d", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c89274d7f82810724126637ffdc5507d442f0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix17751.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c89274d7f82810724126637ffdc5507d442f0/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix17751.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffix17751.d?ref=430c89274d7f82810724126637ffdc5507d442f0", "patch": "@@ -1,22 +0,0 @@\n-/* REQUIRED_ARGS: -m64\n- * TEST_OUTPUT:\n----\n-fail_compilation/fix17751.d(15): Error: last parameter to `__simd()` must be a constant\n----\n- */\n-\n-// https://issues.dlang.org/show_bug.cgi?id=17751\n-\n-import core.simd;\n-\n-pure @safe V1 simd(XMM opcode, V1, V2)(V1 op1, V2 op2, ubyte imm8)\n-    if (is(V1 == __vector) && is(V2 == __vector))\n-{\n-    return cast(V1)__simd(opcode, op1, op2, imm8);\n-}\n-\n-void main()\n-{\n-    float4 a, b;\n-    a = simd!(XMM.CMPPD)(a, b, 0x7A);\n-}"}, {"sha": "ee1802af6c7e1f6cd7b26e9740ab1962c5fdcdce", "filename": "gcc/testsuite/gdc.test/fail_compilation/issue22826.d", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue22826.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue22826.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fissue22826.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -0,0 +1,7 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/issue22826.d(7): Error: #line integer [\"filespec\"]\\n expected\n+fail_compilation/issue22826.d(7): Error: declaration expected, not `3`\n+---\n+*/\n+#line 12 \"issue22826.d\" 3"}, {"sha": "22565e4a8a2e378a17e147f1d1f86e2eef7fc05c", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21546.d", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21546.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21546.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21546.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -0,0 +1,59 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test21546.d(113): Error: cannot implicitly convert expression `pc` of type `const(int)* delegate() return` to `int* delegate() return`\n+fail_compilation/test21546.d(114): Error: cannot implicitly convert expression `pc` of type `const(int)* delegate() return` to `immutable(int)* delegate() return`\n+fail_compilation/test21546.d(115): Error: cannot implicitly convert expression `pi` of type `immutable(int)* delegate() return` to `int* delegate() return`\n+fail_compilation/test21546.d(213): Error: cannot implicitly convert expression `dc` of type `const(int) delegate() ref return` to `int delegate() ref return`\n+fail_compilation/test21546.d(214): Error: cannot implicitly convert expression `dc` of type `const(int) delegate() ref return` to `immutable(int) delegate() ref return`\n+fail_compilation/test21546.d(215): Error: cannot implicitly convert expression `di` of type `immutable(int) delegate() ref return` to `int delegate() ref return`\n+fail_compilation/test21546.d(305): Error: cannot implicitly convert expression `[dgi]` of type `immutable(int) delegate() ref return[]` to `int delegate() ref return[]`\n+---\n+ */\n+// https://issues.dlang.org/show_bug.cgi?id=21546\n+\n+#line 100\n+\n+alias Pm =           int*  delegate() return;\n+alias Pc =     const(int)* delegate() return;\n+alias Pi = immutable(int)* delegate() return;\n+\n+void f()\n+{\n+    Pm pm;\n+    Pc pc;\n+    Pi pi;\n+    pc = pm;\n+    pc = pi;\n+\n+    pm = pc;\n+    pi = pc;\n+    pm = pi;\n+}\n+\n+#line 200\n+\n+alias DGm = ref           int  delegate() return;\n+alias DGc = ref     const(int) delegate() return;\n+alias DGi = ref immutable(int) delegate() return;\n+\n+void g()\n+{\n+    DGm dm;\n+    DGc dc;\n+    DGi di;\n+    dc = dm;\n+    dc = di;\n+\n+    dm = dc;\n+    di = dc;\n+    dm = di;\n+}\n+\n+#line 300\n+\n+void h()\n+{\n+    immutable int i = 0;\n+    DGi dgi = ref() => i;\n+    DGm[] dgms = [ dgi ];\n+}"}, {"sha": "a0f553ba5bffbcd0aa90557e3864a024d55a5b34", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22023.d", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22023.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22023.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22023.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -0,0 +1,26 @@\n+/* TEST_OUTPUT:\n+---\n+fail_compilation/test22023.d(102): Error: typesafe variadic function parameter `a` of type `int[]` cannot be marked `return`\n+fail_compilation/test22023.d(107): Error: typesafe variadic function parameter `c` of type `test22023.C` cannot be marked `return`\n+---\n+*/\n+\n+// issues.dlang.org/show_bug.cgi?id=22023\n+\n+#line 100\n+\n+@safe:\n+ref int f(return int[] a ...)\n+{\n+    return a[2];\n+}\n+\n+ref int g(return C c ...)\n+{\n+    return c.x;\n+}\n+\n+class C\n+{\n+    int x;\n+}"}, {"sha": "ae96b3bc109d774e4a6e78b32039faef6236f6f5", "filename": "gcc/testsuite/gdc.test/fail_compilation/test22818.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22818.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22818.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest22818.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -0,0 +1,21 @@\n+/* REQUIRED_ARGS: -preview=dip1000\n+ * TEST_OUTPUT:\n+---\n+fail_compilation/test22818.d(104): Error: scope variable `c` may not be returned\n+---\n+*/\n+\n+// issues.dlang.org/show_bug.cgi?id=22818\n+\n+#line 100\n+\n+@safe:\n+ref int g(C c ...)\n+{\n+    return c.x;\n+}\n+\n+class C\n+{\n+    int x;\n+}"}, {"sha": "9b97699b8bae904ae51a3c8aabdd728ccbba87b0", "filename": "gcc/testsuite/gdc.test/runnable/nan.d", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnan.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnan.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnan.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -45,15 +45,26 @@ void test2(T)()\n     assert(a is c);\n \n     static if (T.mant_dig == 64 && T.max_exp == 16384)\n+    {\n         enum size = 10; // x87, exclude padding\n+        enum mant_dig = T.mant_dig;\n+    }\n+    else static if (T.mant_dig == 106)\n+    {\n+        enum size = 8; // IBM, only look at first index\n+        enum mant_dig = 53;\n+    }\n     else\n+    {\n         enum size = T.sizeof;\n+        enum mant_dig = T.mant_dig;\n+    }\n     const pa = (cast(ubyte*) &a)[0 .. size];\n \n     // the highest 2 bits of the mantissa should be set, everything else zero\n-    assert(bittst(pa, T.mant_dig - 1));\n-    assert(bittst(pa, T.mant_dig - 2));\n-    foreach(p; 0..T.mant_dig - 2)\n+    assert(bittst(pa, mant_dig - 1));\n+    assert(bittst(pa, mant_dig - 2));\n+    foreach(p; 0..mant_dig - 2)\n         assert(!bittst(pa, p));\n }\n "}, {"sha": "117070dfe5e1af873fe2aead782433b9cdb51f89", "filename": "gcc/testsuite/gdc.test/runnable/previewin.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fpreviewin.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fpreviewin.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fpreviewin.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -157,10 +157,10 @@ struct WithDtor\n void testin1(in uint p) { static assert(!__traits(isRef, p)); }\n // By ref because of size\n void testin2(in ulong[64] p) { static assert(__traits(isRef, p)); }\n-// By value or ref depending on size\n-void testin3(in ValueT p) { static assert(!__traits(isRef, p)); }\n+// By value or ref depending on size (or structs always passed by reference)\n+void testin3(in ValueT p) { static assert(!__traits(isRef, p) || true); }\n void testin3(in RefT p) { static assert(__traits(isRef, p)); }\n-// By ref because of size\n+// By ref because of size (or arrays always passed by reference)\n void testin4(in ValueT[64] p) { static assert(__traits(isRef, p)); }\n void testin4(in RefT[4] p) { static assert(__traits(isRef, p)); }\n "}, {"sha": "2cec6665a331483f507d2e1b34df8df2fa85f199", "filename": "gcc/testsuite/gdc.test/runnable/sroa13220.d", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/430c89274d7f82810724126637ffdc5507d442f0/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsroa13220.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/430c89274d7f82810724126637ffdc5507d442f0/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsroa13220.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fsroa13220.d?ref=430c89274d7f82810724126637ffdc5507d442f0", "patch": "@@ -1,103 +0,0 @@\n-/* REQUIRED_ARGS: -O -inline -noboundscheck\n- */\n-// https://github.com/dlang/pull/13220\n-\n-version (D_SIMD)\n-{\n-\n-mixin template VectorOps(VectorType, ArrayType: BaseType[N], BaseType, size_t N)\n-{\n-    enum Count = N;\n-    alias Base = BaseType;\n-\n-    BaseType* ptr() return pure nothrow @nogc\n-    {\n-        return array.ptr;\n-    }\n-\n-    // Unary operators\n-    VectorType opUnary(string op)() pure nothrow @safe @nogc\n-    {\n-        VectorType res = void;\n-        mixin(\"res.array[] = \" ~ op ~ \"array[];\");\n-        return res;\n-    }\n-\n-    // Binary operators\n-    VectorType opBinary(string op)(VectorType other) pure const nothrow @safe @nogc\n-    {\n-        VectorType res = void;\n-        mixin(\"res.array[] = array[] \" ~ op ~ \" other.array[];\");\n-        return res;\n-    }\n-\n-    // Assigning a BaseType value\n-    void opAssign(BaseType e) pure nothrow @safe @nogc\n-    {\n-        array[] = e;\n-    }\n-\n-    // Assigning a static array\n-    void opAssign(ArrayType v) pure nothrow @safe @nogc\n-    {\n-        array[] = v[];\n-    }\n-\n-    void opOpAssign(string op)(VectorType other) pure nothrow @safe @nogc\n-    {\n-        mixin(\"array[] \"  ~ op ~ \"= other.array[];\");\n-    }\n-\n-    // Assigning a dyn array\n-    this(ArrayType v) pure nothrow @safe @nogc\n-    {\n-        array[] = v[];\n-    }\n-\n-    // Broadcast constructor\n-    this(BaseType x) pure nothrow @safe @nogc\n-    {\n-        array[] = x;\n-    }\n-\n-    ref inout(BaseType) opIndex(size_t i) inout pure nothrow @safe @nogc\n-    {\n-        return array[i];\n-    }\n-}\n-\n-// Note: can't be @safe with this signature\n-Vec loadUnaligned(Vec)(const(BaseType!Vec)* pvec) @trusted\n-{\n-    // Since this vector is emulated, it doesn't have alignement constraints\n-    // and as such we can just cast it.\n-    return *cast(Vec*)(pvec);\n-}\n-\n-private template BaseType(V)\n-{\n-    alias typeof( ( { V v; return v; }()).array[0]) BaseType;\n-}\n-\n-struct int4\n-{\n-    int[4] array;\n-    mixin VectorOps!(int4, int[4]);\n-}\n-\n-alias __m128i = int4;\n-}\n-\n-int main()\n-{\n-  version (D_SIMD)\n-  {\n-    int4 A = [1, 2, 3, 4];\n-    int4 ia = A;\n-    ia.ptr[2] = 5;\n-    int4 C = ia;\n-    int[4] result = [1, 2, 5, 4];\n-    assert(C.array == result);\n-  }\n-    return 0;\n-}"}, {"sha": "b4acc235289f24b146d8110cd53994c276c40423", "filename": "gcc/testsuite/gdc.test/runnable/test15.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest15.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1425,7 +1425,7 @@ void test19758()\n     int[2] array = [16, 678];\n     union U { int i; bool b; }\n     U u;\n-    u.i = 0xDEADBEEF;\n+    u.i = 0xBFBFBFBF;\n     assert(array[u.b] == 678);\n }\n "}, {"sha": "191ddadc9f2622dace653f8425f7e0f522ae2551", "filename": "gcc/testsuite/gdc.test/runnable/testconst.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestconst.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1623,7 +1623,7 @@ struct S3748\n     const int z = 6;\n     C3748 c;\n \n-    inout(int)* getX() inout\n+    inout(int)* getX() inout return\n     {\n         static assert(!__traits(compiles, {\n             x = 4;\n@@ -3348,9 +3348,9 @@ struct S10758\n {\n     int x;\n         inout(int)   screwUpVal(ref inout(int) _) inout { return x; }\n-    ref inout(int)   screwUpRef(ref inout(int) _) inout { return x; }\n-        inout(int)*  screwUpPtr(ref inout(int) _) inout { return &x; }\n-        inout(int)[] screwUpArr(ref inout(int) _) inout { return (&x)[0 .. 1]; }\n+    ref inout(int)   screwUpRef(ref inout(int) _) inout return { return x; }\n+        inout(int)*  screwUpPtr(ref inout(int) _) inout return { return &x; }\n+        inout(int)[] screwUpArr(ref inout(int) _) inout return { return (&x)[0 .. 1]; }\n }\n \n void test10758(ref inout(int) wx, inout(int)* wp, inout(int)[] wa, inout(S10758) ws)\n@@ -3497,14 +3497,14 @@ inout(int)* delegate(inout(int)*) nest10761(inout(int)* x)\n struct S10761\n {\n     int x;\n-    inout(int)* screwUp() inout { return &x; }\n+    inout(int)* screwUp() inout return { return &x; }\n }\n \n-inout(int)* delegate() inout memfn10761(inout(int)* x)\n+inout(int)* delegate() inout return memfn10761(inout(int)* x)\n {\n     auto s = new inout S10761(1);\n     auto dg = &s.screwUp;\n-    static assert(is(typeof(dg) == inout(int)* delegate() inout));\n+    static assert(is(typeof(dg) == inout(int)* delegate() inout return));\n     return dg;\n }\n \n@@ -3542,7 +3542,7 @@ void test10761()\n         auto dg_m = memfn10761(&mx);\n         auto dg_c = memfn10761(&cx);\n         auto dg_i = memfn10761(&ix);\n-        alias DG = const(int)* delegate() const;\n+        alias DG = const(int)* delegate() return const;\n         static assert(is(typeof(dg_m) == DG));\n         static assert(is(typeof(dg_c) == DG));\n         static assert(is(typeof(dg_i) == DG));"}, {"sha": "4de1eba713281cea52d9a8369cc84b2ed973e827", "filename": "gcc/testsuite/gdc.test/runnable/testscope2.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestscope2.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestscope2.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftestscope2.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -178,7 +178,7 @@ struct S10\n {\n     int x;\n \n-    ref inout(int) foo() inout\n+    ref inout(int) foo() inout return\n     {\n         return x;\n     }"}, {"sha": "8996c9ebb8fd3930f97bd78faf1402fb8c896780", "filename": "gcc/testsuite/gdc.test/runnable/traits_getPointerBitmap.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_getPointerBitmap.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_getPointerBitmap.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftraits_getPointerBitmap.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -213,7 +213,7 @@ void testRTInfo()\n     testType!(fn)           ([ 0b0 ]);\n     testType!(S!fn)         ([ 0b100 ]);\n     testType!(NullType)     ([ 0b0 ]);\n-    version(D_LP64)\n+    static if (__traits(compiles, __vector(float[4])))\n         testType!(__vector(float[4]))  ([ 0b00 ]);\n \n     testType!(Object[int])       ([ 0b1 ]);"}, {"sha": "7c0bb573e2b30e5c43ede8ba35217e85f83f1fc3", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1,4 +1,4 @@\n-55528bd1e963d858eaa63901fc818b957c349fbc\n+caf14b0f4ebbae4157aac89368d6278332ee2aa1\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/druntime repository."}, {"sha": "5560c6229caff3625b59457f74d16b779d13dec4", "filename": "libphobos/libdruntime/core/gc/gcinterface.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fgc%2Fgcinterface.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fgc%2Fgcinterface.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fgc%2Fgcinterface.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -141,13 +141,13 @@ interface GC\n      * Retrieve statistics about garbage collection.\n      * Useful for debugging and tuning.\n      */\n-    core.memory.GC.Stats stats() nothrow;\n+    core.memory.GC.Stats stats() @safe nothrow @nogc;\n \n     /**\n      * Retrieve profile statistics about garbage collection.\n      * Useful for debugging and tuning.\n      */\n-    core.memory.GC.ProfileStats profileStats() nothrow @safe;\n+    core.memory.GC.ProfileStats profileStats() @safe nothrow @nogc;\n \n     /**\n      * add p to list of roots"}, {"sha": "3c1bb5434601daf3adead321d416e414190499f3", "filename": "libphobos/libdruntime/core/internal/gc/bits.d", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fbits.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fbits.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fbits.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -60,7 +60,7 @@ struct GCBits\n             onOutOfMemoryError();\n     }\n \n-    wordtype test(size_t i) const nothrow\n+    wordtype test(size_t i) const scope @trusted pure nothrow @nogc\n     in\n     {\n         assert(i < nbits);\n@@ -70,7 +70,7 @@ struct GCBits\n         return core.bitop.bt(data, i);\n     }\n \n-    int set(size_t i) nothrow\n+    int set(size_t i) scope @trusted pure nothrow @nogc\n     in\n     {\n         assert(i < nbits);\n@@ -80,7 +80,7 @@ struct GCBits\n         return core.bitop.bts(data, i);\n     }\n \n-    int clear(size_t i) nothrow\n+    int clear(size_t i) scope @trusted pure nothrow @nogc\n     in\n     {\n         assert(i <= nbits);\n@@ -91,7 +91,7 @@ struct GCBits\n     }\n \n     // return non-zero if bit already set\n-    size_t setLocked(size_t i) nothrow\n+    size_t setLocked(size_t i) scope @trusted pure nothrow @nogc\n     {\n         version (GNU)\n         {\n@@ -112,7 +112,7 @@ struct GCBits\n         }\n         else version (D_InlineAsm_X86)\n         {\n-            asm @nogc nothrow {\n+            asm pure @nogc nothrow {\n                 mov EAX, this;\n                 mov ECX, data[EAX];\n                 mov EDX, i;\n@@ -123,7 +123,7 @@ struct GCBits\n         }\n         else version (D_InlineAsm_X86_64)\n         {\n-            asm @nogc nothrow {\n+            asm pure @nogc nothrow {\n                 mov RAX, this;\n                 mov RAX, data[RAX];\n                 mov RDX, i;"}, {"sha": "aa51867fc2c7ff9865705c147f2403477576d64f", "filename": "libphobos/libdruntime/core/internal/gc/impl/conservative/gc.d", "status": "modified", "additions": 128, "deletions": 129, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fimpl%2Fconservative%2Fgc.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -38,6 +38,8 @@ import core.gc.config;\n import core.gc.gcinterface;\n \n import core.internal.container.treap;\n+import core.internal.spinlock;\n+import core.internal.gc.pooltable;\n \n import cstdlib = core.stdc.stdlib : calloc, free, malloc, realloc;\n import core.stdc.string : memcpy, memset, memmove;\n@@ -145,7 +147,6 @@ class ConservativeGC : GC\n \n     Gcx *gcx;                   // implementation\n \n-    import core.internal.spinlock;\n     static gcLock = shared(AlignedSpinLock)(SpinLock.Contention.lengthy);\n     static bool _inFinalizer;\n     __gshared bool isPrecise = false;\n@@ -155,7 +156,7 @@ class ConservativeGC : GC\n      *\n      * Throws: InvalidMemoryOperationError on recursive locking during finalization.\n      */\n-    static void lockNR() @nogc nothrow\n+    static void lockNR() @safe @nogc nothrow\n     {\n         if (_inFinalizer)\n             onInvalidMemoryOperationError();\n@@ -685,7 +686,7 @@ class ConservativeGC : GC\n             else if (pagenum + newsz <= pool.npages)\n             {\n                 // Attempt to expand in place (TODO: merge with extend)\n-                if (lpool.pagetable[pagenum + psz] != B_FREE)\n+                if (lpool.pagetable[pagenum + psz] != Bins.B_FREE)\n                     return doMalloc();\n \n                 auto newPages = newsz - psz;\n@@ -695,7 +696,7 @@ class ConservativeGC : GC\n \n                 debug (MEMSTOMP) memset(p + psize, 0xF0, size - psize);\n                 debug (PRINTF) printFreeInfo(pool);\n-                memset(&lpool.pagetable[pagenum + psz], B_PAGEPLUS, newPages);\n+                memset(&lpool.pagetable[pagenum + psz], Bins.B_PAGEPLUS, newPages);\n                 lpool.bPageOffsets[pagenum] = cast(uint) newsz;\n                 for (auto offset = psz; offset < newsz; offset++)\n                     lpool.bPageOffsets[pagenum + offset] = cast(uint) offset;\n@@ -766,7 +767,7 @@ class ConservativeGC : GC\n \n             auto lpool = cast(LargeObjectPool*) pool;\n             size_t pagenum = lpool.pagenumOf(p);\n-            if (lpool.pagetable[pagenum] != B_PAGE)\n+            if (lpool.pagetable[pagenum] != Bins.B_PAGE)\n                 return 0;\n \n             size_t psz = lpool.bPageOffsets[pagenum];\n@@ -777,15 +778,15 @@ class ConservativeGC : GC\n \n             if (pagenum + psz >= lpool.npages)\n                 return 0;\n-            if (lpool.pagetable[pagenum + psz] != B_FREE)\n+            if (lpool.pagetable[pagenum + psz] != Bins.B_FREE)\n                 return 0;\n \n             size_t freesz = lpool.bPageOffsets[pagenum + psz];\n             if (freesz < minsz)\n                 return 0;\n             size_t sz = freesz > maxsz ? maxsz : freesz;\n             debug (MEMSTOMP) memset(pool.baseAddr + (pagenum + psz) * PAGESIZE, 0xF0, sz * PAGESIZE);\n-            memset(lpool.pagetable + pagenum + psz, B_PAGEPLUS, sz);\n+            memset(lpool.pagetable + pagenum + psz, Bins.B_PAGEPLUS, sz);\n             lpool.bPageOffsets[pagenum] = cast(uint) (psz + sz);\n             for (auto offset = psz; offset < psz + sz; offset++)\n                 lpool.bPageOffsets[pagenum + offset] = cast(uint) offset;\n@@ -874,11 +875,11 @@ class ConservativeGC : GC\n         debug(PRINTF) printf(\"pool base = %p, PAGENUM = %d of %d, bin = %d\\n\", pool.baseAddr, pagenum, pool.npages, pool.pagetable[pagenum]);\n         debug(PRINTF) if (pool.isLargeObject) printf(\"Block size = %d\\n\", pool.bPageOffsets[pagenum]);\n \n-        bin = cast(Bins)pool.pagetable[pagenum];\n+        bin = pool.pagetable[pagenum];\n \n         // Verify that the pointer is at the beginning of a block,\n         //  no action should be taken if p is an interior pointer\n-        if (bin > B_PAGE) // B_PAGEPLUS or B_FREE\n+        if (bin > Bins.B_PAGE) // B_PAGEPLUS or B_FREE\n             return;\n         size_t off = (sentinel_sub(p) - pool.baseAddr);\n         size_t base = baseOffset(off, bin);\n@@ -893,7 +894,7 @@ class ConservativeGC : GC\n         if (pool.isLargeObject)              // if large alloc\n         {\n             biti = cast(size_t)(p - pool.baseAddr) >> pool.ShiftBy.Large;\n-            assert(bin == B_PAGE);\n+            assert(bin == Bins.B_PAGE);\n             auto lpool = cast(LargeObjectPool*) pool;\n \n             // Free pages\n@@ -1094,13 +1095,13 @@ class ConservativeGC : GC\n             pool = gcx.findPool(p);\n             assert(pool);\n             pagenum = pool.pagenumOf(p);\n-            bin = cast(Bins)pool.pagetable[pagenum];\n-            assert(bin <= B_PAGE);\n+            bin = pool.pagetable[pagenum];\n+            assert(bin <= Bins.B_PAGE);\n             assert(p == cast(void*)baseOffset(cast(size_t)p, bin));\n \n             debug (PTRCHECK2)\n             {\n-                if (bin < B_PAGE)\n+                if (bin < Bins.B_PAGE)\n                 {\n                     // Check that p is not on a free list\n                     List *list;\n@@ -1299,7 +1300,7 @@ class ConservativeGC : GC\n     }\n \n \n-    core.memory.GC.Stats stats() nothrow\n+    core.memory.GC.Stats stats() @safe nothrow @nogc\n     {\n         typeof(return) ret;\n \n@@ -1332,27 +1333,34 @@ class ConservativeGC : GC\n     //\n     // Implementation of getStats\n     //\n-    private void getStatsNoSync(out core.memory.GC.Stats stats) nothrow\n+    private void getStatsNoSync(out core.memory.GC.Stats stats) @trusted nothrow @nogc\n     {\n-        foreach (pool; gcx.pooltable[0 .. gcx.npools])\n+        // This function is trusted for two reasons: `pool.pagetable` is a pointer,\n+        // which is being sliced in the below foreach, and so is `binPageChain`,\n+        // also sliced a bit later in this function.\n+        // However, both usages are safe as long as the assumption that `npools`\n+        // defines the limit for `pagetable`'s length holds true (see allocation).\n+        // The slicing happens at __LINE__ + 4 and __LINE__ + 24.\n+        // `@trusted` delegates are not used to prevent any performance issue.\n+        foreach (pool; gcx.pooltable[])\n         {\n             foreach (bin; pool.pagetable[0 .. pool.npages])\n             {\n-                if (bin == B_FREE)\n+                if (bin == Bins.B_FREE)\n                     stats.freeSize += PAGESIZE;\n                 else\n                     stats.usedSize += PAGESIZE;\n             }\n         }\n \n         size_t freeListSize;\n-        foreach (n; 0 .. B_PAGE)\n+        foreach (n; 0 .. Bins.B_PAGE)\n         {\n             immutable sz = binsize[n];\n             for (List *list = gcx.bucket[n]; list; list = list.next)\n                 freeListSize += sz;\n \n-            foreach (pool; gcx.pooltable[0 .. gcx.npools])\n+            foreach (pool; gcx.pooltable[])\n             {\n                 if (pool.isLargeObject)\n                     continue;\n@@ -1381,7 +1389,7 @@ enum\n }\n \n \n-enum\n+enum Bins : ubyte\n {\n     B_16,\n     B_32,\n@@ -1405,23 +1413,19 @@ enum\n     B_MAX,\n }\n \n-\n-alias ubyte Bins;\n-\n-\n struct List\n {\n     List *next;\n     Pool *pool;\n }\n \n // non power of two sizes optimized for small remainder within page (<= 64 bytes)\n-immutable short[B_NUMSMALL + 1] binsize = [ 16, 32, 48, 64, 96, 128, 176, 256, 368, 512, 816, 1024, 1360, 2048, 4096 ];\n-immutable short[PAGESIZE / 16][B_NUMSMALL + 1] binbase = calcBinBase();\n+immutable short[Bins.B_NUMSMALL + 1] binsize = [ 16, 32, 48, 64, 96, 128, 176, 256, 368, 512, 816, 1024, 1360, 2048, 4096 ];\n+immutable short[PAGESIZE / 16][Bins.B_NUMSMALL + 1] binbase = calcBinBase();\n \n-short[PAGESIZE / 16][B_NUMSMALL + 1] calcBinBase()\n+short[PAGESIZE / 16][Bins.B_NUMSMALL + 1] calcBinBase()\n {\n-    short[PAGESIZE / 16][B_NUMSMALL + 1] bin;\n+    short[PAGESIZE / 16][Bins.B_NUMSMALL + 1] bin;\n \n     foreach (i, size; binsize)\n     {\n@@ -1440,17 +1444,17 @@ short[PAGESIZE / 16][B_NUMSMALL + 1] calcBinBase()\n \n size_t baseOffset(size_t offset, Bins bin) @nogc nothrow\n {\n-    assert(bin <= B_PAGE);\n+    assert(bin <= Bins.B_PAGE);\n     return (offset & ~(PAGESIZE - 1)) + binbase[bin][(offset & (PAGESIZE - 1)) >> 4];\n }\n \n alias PageBits = GCBits.wordtype[PAGESIZE / 16 / GCBits.BITS_PER_WORD];\n static assert(PAGESIZE % (GCBits.BITS_PER_WORD * 16) == 0);\n \n // bitmask with bits set at base offsets of objects\n-immutable PageBits[B_NUMSMALL] baseOffsetBits = (){\n-    PageBits[B_NUMSMALL] bits;\n-    foreach (bin; 0..B_NUMSMALL)\n+immutable PageBits[Bins.B_NUMSMALL] baseOffsetBits = (){\n+    PageBits[Bins.B_NUMSMALL] bits;\n+    foreach (bin; 0 .. Bins.B_NUMSMALL)\n     {\n         size_t size = binsize[bin];\n         const top = PAGESIZE - size + 1; // ensure <size> bytes available even if unaligned\n@@ -1475,7 +1479,6 @@ private void set(ref PageBits bits, size_t i) @nogc pure nothrow\n \n struct Gcx\n {\n-    import core.internal.spinlock;\n     auto rootsLock = shared(AlignedSpinLock)(SpinLock.Contention.brief);\n     auto rangesLock = shared(AlignedSpinLock)(SpinLock.Contention.brief);\n     Treap!Root roots;\n@@ -1491,11 +1494,9 @@ struct Gcx\n     debug(INVARIANT) bool inCollection;\n     uint disabled; // turn off collections if >0\n \n-    import core.internal.gc.pooltable;\n-    private @property size_t npools() pure const nothrow { return pooltable.length; }\n     PoolTable!Pool pooltable;\n \n-    List*[B_NUMSMALL] bucket; // free list for each small size\n+    List*[Bins.B_NUMSMALL] bucket; // free list for each small size\n \n     // run a collection when reaching those thresholds (number of used pages)\n     float smallCollectThreshold, largeCollectThreshold;\n@@ -1508,7 +1509,7 @@ struct Gcx\n     else\n         alias leakDetector = LeakDetector;\n \n-    SmallObjectPool*[B_NUMSMALL] recoverPool;\n+    SmallObjectPool*[Bins.B_NUMSMALL] recoverPool;\n     version (Posix) __gshared Gcx* instance;\n \n     void initialize()\n@@ -1592,9 +1593,8 @@ struct Gcx\n \n         debug(INVARIANT) initialized = false;\n \n-        for (size_t i = 0; i < npools; i++)\n+        foreach (Pool* pool; this.pooltable[])\n         {\n-            Pool *pool = pooltable[i];\n             mappedPages -= pool.npages;\n             pool.Dtor();\n             cstdlib.free(pool);\n@@ -1635,7 +1635,7 @@ struct Gcx\n             if (!inCollection)\n                 (cast()rangesLock).unlock();\n \n-            for (size_t i = 0; i < B_NUMSMALL; i++)\n+            for (size_t i = 0; i < Bins.B_NUMSMALL; i++)\n             {\n                 size_t j = 0;\n                 List* prev, pprev, ppprev; // keep a short history to inspect in the debugger\n@@ -1752,7 +1752,7 @@ struct Gcx\n         ConservativeGC._inFinalizer = true;\n         scope (failure) ConservativeGC._inFinalizer = false;\n \n-        foreach (pool; pooltable[0 .. npools])\n+        foreach (pool; this.pooltable[])\n         {\n             if (!pool.finals.nbits) continue;\n \n@@ -1816,18 +1816,18 @@ struct Gcx\n     /**\n      * Computes the bin table using CTFE.\n      */\n-    static byte[2049] ctfeBins() nothrow\n+    static Bins[2049] ctfeBins() nothrow\n     {\n-        byte[2049] ret;\n+        Bins[2049] ret;\n         size_t p = 0;\n-        for (Bins b = B_16; b <= B_2048; b++)\n+        for (Bins b = Bins.B_16; b <= Bins.B_2048; b++)\n             for ( ; p <= binsize[b]; p++)\n                 ret[p] = b;\n \n         return ret;\n     }\n \n-    static const byte[2049] binTable = ctfeBins();\n+    static immutable Bins[2049] binTable = ctfeBins();\n \n     /**\n      * Allocate a new pool of at least size bytes.\n@@ -1994,7 +1994,7 @@ struct Gcx\n \n         bool tryAlloc() nothrow\n         {\n-            foreach (p; pooltable[0 .. npools])\n+            foreach (p; this.pooltable[])\n             {\n                 if (!p.isLargeObject || p.freepages < npages)\n                     continue;\n@@ -2094,10 +2094,11 @@ struct Gcx\n         }\n \n         // Allocate successively larger pools up to 8 megs\n-        if (npools)\n-        {   size_t n;\n+        if (this.pooltable.length)\n+        {\n+            size_t n;\n \n-            n = config.minPoolSize + config.incPoolSize * npools;\n+            n = config.minPoolSize + config.incPoolSize * this.pooltable.length;\n             if (n > config.maxPoolSize)\n                 n = config.maxPoolSize;                 // cap pool size\n             n /= PAGESIZE; // convert bytes to pages\n@@ -2139,9 +2140,8 @@ struct Gcx\n     List* allocPage(Bins bin) nothrow\n     {\n         //debug(PRINTF) printf(\"Gcx::allocPage(bin = %d)\\n\", bin);\n-        for (size_t n = 0; n < npools; n++)\n+        foreach (Pool* pool; this.pooltable[])\n         {\n-            Pool* pool = pooltable[n];\n             if (pool.isLargeObject)\n                 continue;\n             if (List* p = (cast(SmallObjectPool*)pool).allocPage(bin))\n@@ -2275,7 +2275,7 @@ struct Gcx\n \n         // let dmd allocate a register for this.pools\n         auto pools = pooltable.pools;\n-        const highpool = pooltable.npools - 1;\n+        const highpool = pooltable.length - 1;\n         const minAddr = pooltable.minAddr;\n         size_t memSize = pooltable.maxAddr - minAddr;\n         Pool* pool = null;\n@@ -2300,7 +2300,6 @@ struct Gcx\n                         bitpos -= rng.bmplength;\n                         rng.pbase += rng.bmplength;\n                     }\n-                    import core.bitop;\n                     if (!core.bitop.bt(rng.ptrbmp, bitpos))\n                     {\n                         debug(MARK_PRINTF) printf(\"\\t\\tskipping non-pointer\\n\");\n@@ -2335,7 +2334,7 @@ struct Gcx\n                     printf(\"\\t\\tfound pool %p, base=%p, pn = %lld, bin = %d\\n\", pool, pool.baseAddr, cast(long)pn, bin);\n \n                 // Adjust bit to be at start of allocated memory block\n-                if (bin < B_PAGE)\n+                if (bin < Bins.B_PAGE)\n                 {\n                     // We don't care abou setting pointsToBase correctly\n                     // because it's ignored for small object pools anyhow.\n@@ -2356,7 +2355,7 @@ struct Gcx\n                         goto LaddRange;\n                     }\n                 }\n-                else if (bin == B_PAGE)\n+                else if (bin == Bins.B_PAGE)\n                 {\n                     biti = offset >> Pool.ShiftBy.Large;\n                     //debug(PRINTF) printf(\"\\t\\tbiti = x%x\\n\", biti);\n@@ -2376,7 +2375,7 @@ struct Gcx\n                         goto LaddLargeRange;\n                     }\n                 }\n-                else if (bin == B_PAGEPLUS)\n+                else if (bin == Bins.B_PAGEPLUS)\n                 {\n                     pn -= pool.bPageOffsets[pn];\n                     biti = pn * (PAGESIZE >> Pool.ShiftBy.Large);\n@@ -2429,7 +2428,7 @@ struct Gcx\n                 else\n                 {\n                     // Don't mark bits in B_FREE pages\n-                    assert(bin == B_FREE);\n+                    assert(bin == Bins.B_FREE);\n                 }\n             }\n         LnextPtr:\n@@ -2526,9 +2525,8 @@ struct Gcx\n     {\n         debug(COLLECT_PRINTF) printf(\"preparing mark.\\n\");\n \n-        for (size_t n = 0; n < npools; n++)\n+        foreach (Pool* pool; this.pooltable[])\n         {\n-            Pool* pool = pooltable[n];\n             if (pool.isLargeObject)\n                 pool.mark.zero();\n             else\n@@ -2598,10 +2596,9 @@ struct Gcx\n         size_t freedLargePages;\n         size_t freedSmallPages;\n         size_t freed;\n-        for (size_t n = 0; n < npools; n++)\n+        foreach (Pool* pool; this.pooltable[])\n         {\n             size_t pn;\n-            Pool* pool = pooltable[n];\n \n             if (pool.isLargeObject)\n             {\n@@ -2612,12 +2609,12 @@ struct Gcx\n                 {\n                     npages = pool.bPageOffsets[pn];\n                     Bins bin = cast(Bins)pool.pagetable[pn];\n-                    if (bin == B_FREE)\n+                    if (bin == Bins.B_FREE)\n                     {\n                         numFree += npages;\n                         continue;\n                     }\n-                    assert(bin == B_PAGE);\n+                    assert(bin == Bins.B_PAGE);\n                     size_t biti = pn;\n \n                     if (!pool.mark.test(biti))\n@@ -2637,7 +2634,7 @@ struct Gcx\n \n                         debug(COLLECT_PRINTF) printf(\"\\tcollecting big %p\\n\", p);\n                         leakDetector.log_free(q, sentinel_size(q, npages * PAGESIZE - SENTINEL_EXTRA));\n-                        pool.pagetable[pn..pn+npages] = B_FREE;\n+                        pool.pagetable[pn..pn+npages] = Bins.B_FREE;\n                         if (pn < pool.searchStart) pool.searchStart = pn;\n                         freedLargePages += npages;\n                         pool.freepages += npages;\n@@ -2671,7 +2668,7 @@ struct Gcx\n                 {\n                     Bins bin = cast(Bins)pool.pagetable[pn];\n \n-                    if (bin < B_PAGE)\n+                    if (bin < Bins.B_PAGE)\n                     {\n                         auto freebitsdata = pool.freebits.data + pn * PageBits.length;\n                         auto markdata = pool.mark.data + pn * PageBits.length;\n@@ -2767,7 +2764,7 @@ struct Gcx\n                         {\n                             pool.freeAllPageBits(pn);\n \n-                            pool.pagetable[pn] = B_FREE;\n+                            pool.pagetable[pn] = Bins.B_FREE;\n                             // add to free chain\n                             pool.binPageChain[pn] = cast(uint) pool.searchStart;\n                             pool.searchStart = pn;\n@@ -2789,7 +2786,8 @@ struct Gcx\n \n         assert(freedLargePages <= usedLargePages);\n         usedLargePages -= freedLargePages;\n-        debug(COLLECT_PRINTF) printf(\"\\tfree'd %u bytes, %u pages from %u pools\\n\", freed, freedLargePages, npools);\n+        debug(COLLECT_PRINTF) printf(\"\\tfree'd %u bytes, %u pages from %u pools\\n\",\n+                                     freed, freedLargePages, this.pooltable.length);\n \n         assert(freedSmallPages <= usedSmallPages);\n         usedSmallPages -= freedSmallPages;\n@@ -2854,12 +2852,12 @@ struct Gcx\n     private SmallObjectPool* setNextRecoverPool(Bins bin, size_t poolIndex) nothrow\n     {\n         Pool* pool;\n-        while (poolIndex < npools &&\n-               ((pool = pooltable[poolIndex]).isLargeObject ||\n+        while (poolIndex < this.pooltable.length &&\n+               ((pool = this.pooltable[poolIndex]).isLargeObject ||\n                 pool.recoverPageFirst[bin] >= pool.npages))\n             poolIndex++;\n \n-        return recoverPool[bin] = poolIndex < npools ? cast(SmallObjectPool*)pool : null;\n+        return recoverPool[bin] = poolIndex < this.pooltable.length ? cast(SmallObjectPool*)pool : null;\n     }\n \n     version (COLLECT_FORK)\n@@ -2928,7 +2926,6 @@ struct Gcx\n         import core.stdc.stdlib : _Exit;\n         debug (PRINTF_TO_FILE)\n         {\n-            import core.stdc.stdio : fflush;\n             fflush(null); // avoid duplicated FILE* output\n         }\n         version (OSX)\n@@ -3153,7 +3150,7 @@ Lmark:\n \n         // init bucket lists\n         bucket[] = null;\n-        foreach (Bins bin; 0..B_NUMSMALL)\n+        foreach (Bins bin; Bins.B_16 .. Bins.B_NUMSMALL)\n             setNextRecoverPool(bin, 0);\n \n         stop = currTime;\n@@ -3188,24 +3185,24 @@ Lmark:\n             auto pn = offset / PAGESIZE;\n             auto bins = cast(Bins)pool.pagetable[pn];\n             size_t biti = void;\n-            if (bins < B_PAGE)\n+            if (bins < Bins.B_PAGE)\n             {\n                 biti = baseOffset(offset, bins) >> pool.ShiftBy.Small;\n                 // doesn't need to check freebits because no pointer must exist\n                 //  to a block that was free before starting the collection\n             }\n-            else if (bins == B_PAGE)\n+            else if (bins == Bins.B_PAGE)\n             {\n                 biti = pn * (PAGESIZE >> pool.ShiftBy.Large);\n             }\n-            else if (bins == B_PAGEPLUS)\n+            else if (bins == Bins.B_PAGEPLUS)\n             {\n                 pn -= pool.bPageOffsets[pn];\n                 biti = pn * (PAGESIZE >> pool.ShiftBy.Large);\n             }\n-            else // bins == B_FREE\n+            else // bins == Bins.B_FREE\n             {\n-                assert(bins == B_FREE);\n+                assert(bins == Bins.B_FREE);\n                 return IsMarked.no;\n             }\n             return pool.mark.test(biti) ? IsMarked.yes : IsMarked.no;\n@@ -3262,8 +3259,11 @@ Lmark:\n \n     /* ============================ Parallel scanning =============================== */\n     version (COLLECT_PARALLEL):\n-    import core.sync.event;\n+\n     import core.atomic;\n+    import core.cpuid;\n+    import core.sync.event;\n+\n     private: // disable invariants for background threads\n \n     static struct ScanThreadData\n@@ -3334,7 +3334,6 @@ Lmark:\n \n     int maxParallelThreads() nothrow\n     {\n-        import core.cpuid;\n         auto threads = threadsPerCPU();\n \n         if (threads == 0)\n@@ -3512,7 +3511,7 @@ struct Pool\n     GCBits is_pointer;  // precise GC only: per-word, not per-block like the rest of them (SmallObjectPool only)\n     size_t npages;\n     size_t freepages;     // The number of pages not in use.\n-    ubyte* pagetable;\n+    Bins* pagetable;\n \n     bool isLargeObject;\n \n@@ -3541,7 +3540,7 @@ struct Pool\n     enum PageRecovered = uint.max;\n \n     // first of chain of pages to recover (SmallObjectPool only)\n-    uint[B_NUMSMALL] recoverPageFirst;\n+    uint[Bins.B_NUMSMALL] recoverPageFirst;\n \n     // precise GC: TypeInfo.rtInfo for allocation (LargeObjectPool only)\n     immutable(size_t)** rtinfo;\n@@ -3611,7 +3610,7 @@ struct Pool\n         noscan.alloc(nbits);\n         appendable.alloc(nbits);\n \n-        pagetable = cast(ubyte*)cstdlib.malloc(npages);\n+        pagetable = cast(Bins*)cstdlib.malloc(npages * Bins.sizeof);\n         if (!pagetable)\n             onOutOfMemoryErrorNoGC();\n \n@@ -3635,7 +3634,7 @@ struct Pool\n             }\n         }\n \n-        memset(pagetable, B_FREE, npages);\n+        memset(pagetable, Bins.B_FREE, npages);\n \n         this.npages = npages;\n         this.freepages = npages;\n@@ -3852,7 +3851,7 @@ struct Pool\n     }\n \n     public\n-    @property bool isFree() const pure nothrow\n+    @property bool isFree() const scope @safe pure nothrow @nogc\n     {\n         return npages == freepages;\n     }\n@@ -3883,22 +3882,22 @@ struct Pool\n     {\n         size_t offset = cast(size_t)(p - baseAddr);\n         size_t pn = offset / PAGESIZE;\n-        Bins   bin = cast(Bins)pagetable[pn];\n+        Bins   bin = pagetable[pn];\n \n         // Adjust bit to be at start of allocated memory block\n-        if (bin < B_NUMSMALL)\n+        if (bin < Bins.B_NUMSMALL)\n         {\n             auto baseOff = baseOffset(offset, bin);\n             const biti = baseOff >> Pool.ShiftBy.Small;\n             if (freebits.test (biti))\n                 return null;\n             return baseAddr + baseOff;\n         }\n-        if (bin == B_PAGE)\n+        if (bin == Bins.B_PAGE)\n         {\n             return baseAddr + (offset & (offset.max ^ (PAGESIZE-1)));\n         }\n-        if (bin == B_PAGEPLUS)\n+        if (bin == Bins.B_PAGEPLUS)\n         {\n             size_t pageOffset = bPageOffsets[pn];\n             offset -= pageOffset * PAGESIZE;\n@@ -3907,7 +3906,7 @@ struct Pool\n             return baseAddr + (offset & (offset.max ^ (PAGESIZE-1)));\n         }\n         // we are in a B_FREE page\n-        assert(bin == B_FREE);\n+        assert(bin == Bins.B_FREE);\n         return null;\n     }\n \n@@ -3944,8 +3943,8 @@ struct Pool\n         {\n             for (size_t i = 0; i < npages; i++)\n             {\n-                Bins bin = cast(Bins)pagetable[i];\n-                assert(bin < B_MAX);\n+                Bins bin = pagetable[i];\n+                assert(bin < Bins.B_MAX);\n             }\n         }\n     }\n@@ -4053,19 +4052,19 @@ struct LargeObjectPool\n             uint np = bPageOffsets[n];\n             assert(np > 0 && np <= npages - n);\n \n-            if (pagetable[n] == B_PAGE)\n+            if (pagetable[n] == Bins.B_PAGE)\n             {\n                 for (uint p = 1; p < np; p++)\n                 {\n-                    assert(pagetable[n + p] == B_PAGEPLUS);\n+                    assert(pagetable[n + p] == Bins.B_PAGEPLUS);\n                     assert(bPageOffsets[n + p] == p);\n                 }\n             }\n-            else if (pagetable[n] == B_FREE)\n+            else if (pagetable[n] == Bins.B_FREE)\n             {\n                 for (uint p = 1; p < np; p++)\n                 {\n-                    assert(pagetable[n + p] == B_FREE);\n+                    assert(pagetable[n + p] == Bins.B_FREE);\n                 }\n                 assert(bPageOffsets[n + np - 1] == np);\n             }\n@@ -4086,17 +4085,17 @@ struct LargeObjectPool\n \n         //debug(PRINTF) printf(\"Pool::allocPages(n = %d)\\n\", n);\n         size_t largest = 0;\n-        if (pagetable[searchStart] == B_PAGEPLUS)\n+        if (pagetable[searchStart] == Bins.B_PAGEPLUS)\n         {\n             searchStart -= bPageOffsets[searchStart]; // jump to B_PAGE\n             searchStart += bPageOffsets[searchStart];\n         }\n-        while (searchStart < npages && pagetable[searchStart] == B_PAGE)\n+        while (searchStart < npages && pagetable[searchStart] == Bins.B_PAGE)\n             searchStart += bPageOffsets[searchStart];\n \n         for (size_t i = searchStart; i < npages; )\n         {\n-            assert(pagetable[i] == B_FREE);\n+            assert(pagetable[i] == Bins.B_FREE);\n \n             auto p = bPageOffsets[i];\n             if (p > n)\n@@ -4107,11 +4106,11 @@ struct LargeObjectPool\n             if (p == n)\n             {\n             L_found:\n-                pagetable[i] = B_PAGE;\n+                pagetable[i] = Bins.B_PAGE;\n                 bPageOffsets[i] = cast(uint) n;\n                 if (n > 1)\n                 {\n-                    memset(&pagetable[i + 1], B_PAGEPLUS, n - 1);\n+                    memset(&pagetable[i + 1], Bins.B_PAGEPLUS, n - 1);\n                     for (auto offset = 1; offset < n; offset++)\n                         bPageOffsets[i + offset] = cast(uint) offset;\n                 }\n@@ -4122,7 +4121,7 @@ struct LargeObjectPool\n                 largest = p;\n \n             i += p;\n-            while (i < npages && pagetable[i] == B_PAGE)\n+            while (i < npages && pagetable[i] == Bins.B_PAGE)\n             {\n                 // we have the size information, so we skip a whole bunch of pages.\n                 i += bPageOffsets[i];\n@@ -4145,8 +4144,8 @@ struct LargeObjectPool\n \n         for (size_t i = pagenum; i < npages + pagenum; i++)\n         {\n-            assert(pagetable[i] < B_FREE);\n-            pagetable[i] = B_FREE;\n+            assert(pagetable[i] < Bins.B_FREE);\n+            pagetable[i] = Bins.B_FREE;\n         }\n         freepages += npages;\n         largestFree = freepages; // invalidate\n@@ -4157,8 +4156,8 @@ struct LargeObjectPool\n      */\n     void setFreePageOffsets(size_t page, size_t num) nothrow @nogc\n     {\n-        assert(pagetable[page] == B_FREE);\n-        assert(pagetable[page + num - 1] == B_FREE);\n+        assert(pagetable[page] == Bins.B_FREE);\n+        assert(pagetable[page + num - 1] == Bins.B_FREE);\n         bPageOffsets[page] = cast(uint)num;\n         if (num > 1)\n             bPageOffsets[page + num - 1] = cast(uint)num;\n@@ -4168,7 +4167,7 @@ struct LargeObjectPool\n     {\n         static if (bwd)\n         {\n-            if (page > 0 && pagetable[page - 1] == B_FREE)\n+            if (page > 0 && pagetable[page - 1] == Bins.B_FREE)\n             {\n                 auto sz = bPageOffsets[page - 1];\n                 page -= sz;\n@@ -4177,7 +4176,7 @@ struct LargeObjectPool\n         }\n         static if (fwd)\n         {\n-            if (page + num < npages && pagetable[page + num] == B_FREE)\n+            if (page + num < npages && pagetable[page + num] == Bins.B_FREE)\n                 num += bPageOffsets[page + num];\n         }\n         setFreePageOffsets(page, num);\n@@ -4197,8 +4196,8 @@ struct LargeObjectPool\n         if (cast(size_t)p & (PAGESIZE - 1)) // check for interior pointer\n             return 0;\n         size_t pagenum = pagenumOf(p);\n-        Bins bin = cast(Bins)pagetable[pagenum];\n-        if (bin != B_PAGE)\n+        Bins bin = pagetable[pagenum];\n+        if (bin != Bins.B_PAGE)\n             return 0;\n         return bPageOffsets[pagenum];\n     }\n@@ -4208,7 +4207,7 @@ struct LargeObjectPool\n     */\n     size_t getSize(size_t pn) const nothrow @nogc\n     {\n-        assert(pagetable[pn] == B_PAGE);\n+        assert(pagetable[pn] == Bins.B_PAGE);\n         return cast(size_t) bPageOffsets[pn] * PAGESIZE;\n     }\n \n@@ -4221,11 +4220,11 @@ struct LargeObjectPool\n \n         size_t offset = cast(size_t)(p - baseAddr);\n         size_t pn = offset / PAGESIZE;\n-        Bins bin = cast(Bins)pagetable[pn];\n+        Bins bin = pagetable[pn];\n \n-        if (bin == B_PAGEPLUS)\n+        if (bin == Bins.B_PAGEPLUS)\n             pn -= bPageOffsets[pn];\n-        else if (bin != B_PAGE)\n+        else if (bin != Bins.B_PAGE)\n             return info;           // no info for free pages\n \n         info.base = baseAddr + pn * PAGESIZE;\n@@ -4238,8 +4237,8 @@ struct LargeObjectPool\n     {\n         foreach (pn; 0 .. npages)\n         {\n-            Bins bin = cast(Bins)pagetable[pn];\n-            if (bin > B_PAGE)\n+            Bins bin = pagetable[pn];\n+            if (bin > Bins.B_PAGE)\n                 continue;\n             size_t biti = pn;\n \n@@ -4265,7 +4264,7 @@ struct LargeObjectPool\n \n             size_t n = 1;\n             for (; pn + n < npages; ++n)\n-                if (pagetable[pn + n] != B_PAGEPLUS)\n+                if (pagetable[pn + n] != Bins.B_PAGEPLUS)\n                     break;\n             debug (MEMSTOMP) memset(baseAddr + pn * PAGESIZE, 0xF3, n * PAGESIZE);\n             freePages(pn, n);\n@@ -4285,7 +4284,7 @@ struct SmallObjectPool\n     {\n         //base.Invariant();\n         uint cntRecover = 0;\n-        foreach (Bins bin; 0 .. B_NUMSMALL)\n+        foreach (Bins bin; Bins.B_16 .. Bins.B_NUMSMALL)\n         {\n             for (auto pn = recoverPageFirst[bin]; pn < npages; pn = binPageChain[pn])\n             {\n@@ -4296,7 +4295,7 @@ struct SmallObjectPool\n         uint cntFree = 0;\n         for (auto pn = searchStart; pn < npages; pn = binPageChain[pn])\n         {\n-            assert(pagetable[pn] == B_FREE);\n+            assert(pagetable[pn] == Bins.B_FREE);\n             cntFree++;\n         }\n         assert(cntFree == freepages);\n@@ -4315,8 +4314,8 @@ struct SmallObjectPool\n     do\n     {\n         size_t pagenum = pagenumOf(p);\n-        Bins bin = cast(Bins)pagetable[pagenum];\n-        assert(bin < B_PAGE);\n+        Bins bin = pagetable[pagenum];\n+        assert(bin < Bins.B_PAGE);\n         if (p != cast(void*)baseOffset(cast(size_t)p, bin)) // check for interior pointer\n             return 0;\n         const biti = cast(size_t)(p - baseAddr) >> ShiftBy.Small;\n@@ -4330,9 +4329,9 @@ struct SmallObjectPool\n         BlkInfo info;\n         size_t offset = cast(size_t)(p - baseAddr);\n         size_t pn = offset / PAGESIZE;\n-        Bins   bin = cast(Bins)pagetable[pn];\n+        Bins   bin = pagetable[pn];\n \n-        if (bin >= B_PAGE)\n+        if (bin >= Bins.B_PAGE)\n             return info;\n \n         auto base = cast(void*)baseOffset(cast(size_t)p, bin);\n@@ -4352,8 +4351,8 @@ struct SmallObjectPool\n     {\n         foreach (pn; 0 .. npages)\n         {\n-            Bins bin = cast(Bins)pagetable[pn];\n-            if (bin >= B_PAGE)\n+            Bins bin = pagetable[pn];\n+            if (bin >= Bins.B_PAGE)\n                 continue;\n \n             immutable size = binsize[bin];\n@@ -4404,13 +4403,13 @@ struct SmallObjectPool\n         if (searchStart >= npages)\n             return null;\n \n-        assert(pagetable[searchStart] == B_FREE);\n+        assert(pagetable[searchStart] == Bins.B_FREE);\n \n     L1:\n         size_t pn = searchStart;\n         searchStart = binPageChain[searchStart];\n         binPageChain[pn] = Pool.PageRecovered;\n-        pagetable[pn] = cast(ubyte)bin;\n+        pagetable[pn] = bin;\n         freepages--;\n \n         // Convert page to free list\n@@ -4537,7 +4536,7 @@ debug(PRINTF) void printFreeInfo(Pool* pool) nothrow\n {\n     uint nReallyFree;\n     foreach (i; 0..pool.npages) {\n-        if (pool.pagetable[i] >= B_FREE) nReallyFree++;\n+        if (pool.pagetable[i] >= Bins.B_FREE) nReallyFree++;\n     }\n \n     printf(\"Pool %p:  %d really free, %d supposedly free\\n\", pool, nReallyFree, pool.freepages);\n@@ -4770,7 +4769,7 @@ debug (LOGGING)\n                 size_t offset = cast(size_t)(p - pool.baseAddr);\n                 size_t biti;\n                 size_t pn = offset / PAGESIZE;\n-                Bins bin = cast(Bins)pool.pagetable[pn];\n+                Bins bin = pool.pagetable[pn];\n                 biti = (offset & (PAGESIZE - 1)) >> pool.shiftBy;\n                 debug(PRINTF) printf(\"\\tbin = %d, offset = x%x, biti = x%x\\n\", bin, offset, biti);\n             }\n@@ -4921,7 +4920,7 @@ unittest\n     assert(p + (260 << 20) == q);\n     assert(q + (65 << 20) == r);\n     GC.free(q);\n-    // should trigger \"assert(bin == B_FREE);\" in mark due to dangling pointer q:\n+    // should trigger \"assert(bin == Bins.B_FREE);\" in mark due to dangling pointer q:\n     GC.collect();\n     // should trigger \"break;\" in extendNoSync:\n     size_t sz = GC.extend(p, 64 << 20, 66 << 20); // trigger size after p large enough (but limited)"}, {"sha": "096633825a2750f3757f7cc0f36b815201e8f6b7", "filename": "libphobos/libdruntime/core/internal/gc/pooltable.d", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fpooltable.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fpooltable.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fpooltable.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -13,15 +13,14 @@ struct PoolTable(Pool)\n {\n     import core.stdc.string : memmove;\n \n-nothrow:\n-    void Dtor()\n+    void Dtor() nothrow @nogc\n     {\n         cstdlib.free(pools);\n         pools = null;\n         npools = 0;\n     }\n \n-    bool insert(Pool* pool)\n+    bool insert(Pool* pool) nothrow @nogc\n     {\n         auto newpools = cast(Pool **)cstdlib.realloc(pools, (npools + 1) * pools[0].sizeof);\n         if (!newpools)\n@@ -51,33 +50,39 @@ nothrow:\n         return true;\n     }\n \n-    @property size_t length() pure const\n+    @property size_t length() const scope @safe pure nothrow @nogc\n     {\n         return npools;\n     }\n \n-    ref inout(Pool*) opIndex(size_t idx) inout pure\n+    ref inout(Pool*) opIndex(size_t idx) inout return @trusted pure nothrow @nogc\n     in { assert(idx < length); }\n     do\n     {\n         return pools[idx];\n     }\n \n-    inout(Pool*)[] opSlice(size_t a, size_t b) inout pure\n+    inout(Pool*)[] opSlice(size_t a, size_t b) inout return @trusted pure nothrow @nogc\n     in { assert(a <= length && b <= length); }\n     do\n     {\n         return pools[a .. b];\n     }\n \n+    /// Returns: A slice over all pools in this `PoolTable`\n+    inout(Pool*)[] opSlice() inout return @trusted pure nothrow @nogc\n+    {\n+        return this.pools[0 .. this.length];\n+    }\n+\n     alias opDollar = length;\n \n     /**\n      * Find Pool that pointer is in.\n      * Return null if not in a Pool.\n      * Assume pooltable[] is sorted.\n      */\n-    Pool *findPool(void *p) nothrow\n+    Pool *findPool(void *p) nothrow @nogc\n     {\n         if (p >= minAddr && p < maxAddr)\n         {\n@@ -109,7 +114,7 @@ nothrow:\n     }\n \n     // semi-stable partition, returns right half for which pred is false\n-    Pool*[] minimize() pure\n+    Pool*[] minimize() pure nothrow @nogc\n     {\n         static void swap(ref Pool* a, ref Pool* b)\n         {\n@@ -151,7 +156,7 @@ nothrow:\n         return pools[npools .. len];\n     }\n \n-    void Invariant() const\n+    void Invariant() const nothrow @nogc\n     {\n         if (!npools) return;\n \n@@ -165,8 +170,8 @@ nothrow:\n         assert(_maxAddr == pools[npools - 1].topAddr);\n     }\n \n-    @property const(void)* minAddr() pure const { return _minAddr; }\n-    @property const(void)* maxAddr() pure const { return _maxAddr; }\n+    @property const(void)* minAddr() const @safe pure nothrow @nogc { return _minAddr; }\n+    @property const(void)* maxAddr() const @safe pure nothrow @nogc { return _maxAddr; }\n \n package:\n     Pool** pools;\n@@ -184,7 +189,7 @@ unittest\n     {\n         byte* baseAddr, topAddr;\n         size_t freepages, npages, ptIndex;\n-        @property bool isFree() const pure nothrow { return freepages == npages; }\n+        @property bool isFree() const scope pure nothrow @nogc { return freepages == npages; }\n     }\n     PoolTable!MockPool pooltable;\n "}, {"sha": "695ef061a8122a5257d189f1ae4ecff0564b3755", "filename": "libphobos/libdruntime/core/internal/gc/proxy.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fproxy.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fproxy.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fgc%2Fproxy.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -209,12 +209,12 @@ extern (C)\n         return instance.query( p );\n     }\n \n-    core.memory.GC.Stats gc_stats() nothrow\n+    core.memory.GC.Stats gc_stats() @safe nothrow @nogc\n     {\n         return instance.stats();\n     }\n \n-    core.memory.GC.ProfileStats gc_profileStats() nothrow @safe\n+    core.memory.GC.ProfileStats gc_profileStats() @safe nothrow @nogc\n     {\n         return instance.profileStats();\n     }"}, {"sha": "f25ba6f1d469b9e55bc1d1cfbf8d2474adaf17ae", "filename": "libphobos/libdruntime/core/memory.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fmemory.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fmemory.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -133,7 +133,7 @@ private\n     }\n \n     extern (C) BlkInfo_ gc_query(return scope void* p) pure nothrow;\n-    extern (C) GC.Stats gc_stats ( ) nothrow @nogc;\n+    extern (C) GC.Stats gc_stats ( ) @safe nothrow @nogc;\n     extern (C) GC.ProfileStats gc_profileStats ( ) nothrow @nogc @safe;\n }\n \n@@ -766,7 +766,7 @@ extern(D):\n      * Returns runtime stats for currently active GC implementation\n      * See `core.memory.GC.Stats` for list of available metrics.\n      */\n-    static Stats stats() nothrow\n+    static Stats stats() @safe nothrow @nogc\n     {\n         return gc_stats();\n     }"}, {"sha": "dfec1ec9f7e7232f97b5f032dd4e208f41e7ad28", "filename": "libphobos/libdruntime/core/stdcpp/string.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdcpp%2Fstring.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -343,7 +343,7 @@ extern(D):\n         ///\n         inout(T)* data() inout @safe                                        { return _Get_data()._Myptr; }\n         ///\n-        inout(T)[] as_array() inout nothrow @trusted                        { return _Get_data()._Myptr[0 .. _Get_data()._Mysize]; }\n+        inout(T)[] as_array() return scope inout nothrow @trusted           { return _Get_data()._Myptr[0 .. _Get_data()._Mysize]; }\n         ///\n         ref inout(T) at(size_type i) inout nothrow @trusted                 { return _Get_data()._Myptr[0 .. _Get_data()._Mysize][i]; }\n \n@@ -1920,7 +1920,7 @@ extern(D):\n         ///\n         inout(T)* data() inout @safe                                        { return __get_pointer(); }\n         ///\n-        inout(T)[] as_array() inout nothrow @trusted                        { return __get_pointer()[0 .. size()]; }\n+        inout(T)[] as_array() return scope inout nothrow @trusted           { return __get_pointer()[0 .. size()]; }\n         ///\n         ref inout(T) at(size_type i) inout nothrow @trusted                 { return __get_pointer()[0 .. size()][i]; }\n \n@@ -2497,8 +2497,8 @@ extern(C++, (StdNamespace)):\n     extern(D) @safe @nogc:\n         pragma(inline, true)\n         {\n-            ref inout(Alloc) _Getal() inout pure nothrow { return _Mypair._Myval1; }\n-            ref inout(ValTy) _Get_data() inout pure nothrow { return _Mypair._Myval2; }\n+            ref inout(Alloc) _Getal() return inout pure nothrow { return _Mypair._Myval1; }\n+            ref inout(ValTy) _Get_data() return inout pure nothrow { return _Mypair._Myval2; }\n         }\n \n         void _Orphan_all() nothrow { _Get_data._Base._Orphan_all(); }"}, {"sha": "1fb4e44cbbfddae4c9bfd0fe846efb4b084d1d88", "filename": "libphobos/libdruntime/core/sys/posix/sys/stat.d", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fstat.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -388,50 +388,93 @@ version (linux)\n     {\n         struct stat_t\n         {\n-            c_ulong     st_dev;\n-            ino_t       st_ino;\n+            dev_t       st_dev;\n+            static if (!__USE_FILE_OFFSET64)\n+            {\n+                ushort  __pad1;\n+                ino_t   st_ino;\n+            }\n+            else\n+                ino_t   st_ino;\n             mode_t      st_mode;\n             nlink_t     st_nlink;\n             uid_t       st_uid;\n             gid_t       st_gid;\n-            c_ulong     st_rdev;\n+            dev_t       st_rdev;\n+            ushort      __pad2;\n             off_t       st_size;\n-            c_ulong     st_blksize;\n-            c_ulong     st_blocks;\n-            c_ulong     st_atime;\n-            c_ulong     st_atime_nsec;\n-            c_ulong     st_mtime;\n-            c_ulong     st_mtime_nsec;\n-            c_ulong     st_ctime;\n-            c_ulong     st_ctime_nsec;\n+            blksize_t   st_blksize;\n+            blkcnt_t    st_blocks;\n+            static if (_DEFAULT_SOURCE || _XOPEN_SOURCE >= 700)\n+            {\n+                timespec    st_atim;\n+                timespec    st_mtim;\n+                timespec    st_ctim;\n+                extern(D) @safe @property inout pure nothrow\n+                {\n+                    ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n+                    ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n+                    ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n+                }\n+            }\n+            else\n+            {\n+                time_t      st_atime;\n+                c_ulong     st_atimensec;\n+                time_t      st_mtime;\n+                c_ulong     st_mtimensec;\n+                time_t      st_ctime;\n+                c_ulong     st_ctimensec;\n+            }\n             c_ulong     __unused4;\n             c_ulong     __unused5;\n         }\n+        static if (__USE_FILE_OFFSET64)\n+            static assert(stat_t.sizeof == 104);\n+        else\n+            static assert(stat_t.sizeof == 88);\n     }\n     else version (PPC64)\n     {\n         struct stat_t\n         {\n-            c_ulong     st_dev;\n+            dev_t       st_dev;\n             ino_t       st_ino;\n             nlink_t     st_nlink;\n             mode_t      st_mode;\n             uid_t       st_uid;\n             gid_t       st_gid;\n-            c_ulong     st_rdev;\n+            int         __pad2;\n+            dev_t       st_rdev;\n             off_t       st_size;\n-            c_ulong     st_blksize;\n-            c_ulong     st_blocks;\n-            c_ulong     st_atime;\n-            c_ulong     st_atime_nsec;\n-            c_ulong     st_mtime;\n-            c_ulong     st_mtime_nsec;\n-            c_ulong     st_ctime;\n-            c_ulong     st_ctime_nsec;\n+            blksize_t   st_blksize;\n+            blkcnt_t    st_blocks;\n+            static if (_DEFAULT_SOURCE || _XOPEN_SOURCE >= 700)\n+            {\n+                timespec    st_atim;\n+                timespec    st_mtim;\n+                timespec    st_ctim;\n+                extern(D) @safe @property inout pure nothrow\n+                {\n+                    ref inout(time_t) st_atime() return { return st_atim.tv_sec; }\n+                    ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }\n+                    ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }\n+                }\n+            }\n+            else\n+            {\n+                time_t      st_atime;\n+                c_ulong     st_atimensec;\n+                time_t      st_mtime;\n+                c_ulong     st_mtimensec;\n+                time_t      st_ctime;\n+                c_ulong     st_ctimensec;\n+            }\n             c_ulong     __unused4;\n             c_ulong     __unused5;\n             c_ulong     __unused6;\n         }\n+        static assert(stat_t.sizeof == 144);\n     }\n     else version (RISCV_Any)\n     {"}, {"sha": "91f218e27fb0e1146fc6baff0d6bee245c8ed7cf", "filename": "libphobos/libdruntime/core/time.d", "status": "modified", "additions": 94, "deletions": 64, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fcore%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Ftime.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -496,6 +496,81 @@ assert(std.datetime.Date(2010, 9, 7) - std.datetime.Date(2010, 10, 3) ==\n  +/\n struct Duration\n {\n+    /++\n+        Converts this `Duration` to a `string`.\n+\n+        The string is meant to be human readable, not machine parseable (e.g.\n+        whether there is an `'s'` on the end of the unit name usually depends on\n+        whether it's plural or not, and empty units are not included unless the\n+        Duration is `zero`). Any code needing a specific string format should\n+        use `total` or `split` to get the units needed to create the desired\n+        string format and create the string itself.\n+\n+        The format returned by toString may or may not change in the future.\n+\n+        Params:\n+          sink = A sink object, expected to be a delegate or aggregate\n+                 implementing `opCall` that accepts a `scope const(char)[]`\n+                 as argument.\n+      +/\n+    void toString (SinkT) (scope SinkT sink) const scope\n+    {\n+        static immutable units = [\n+            \"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"msecs\", \"usecs\"\n+        ];\n+\n+        static void appListSep(SinkT sink, uint pos, bool last)\n+        {\n+            if (pos == 0)\n+                return;\n+            if (!last)\n+                sink(\", \");\n+            else\n+                sink(pos == 1 ? \" and \" : \", and \");\n+        }\n+\n+        static void appUnitVal(string units)(SinkT sink, long val)\n+        {\n+            immutable plural = val != 1;\n+            string unit;\n+            static if (units == \"seconds\")\n+                unit = plural ? \"secs\" : \"sec\";\n+            else static if (units == \"msecs\")\n+                unit = \"ms\";\n+            else static if (units == \"usecs\")\n+                unit = \"\u03bcs\";\n+            else\n+                unit = plural ? units : units[0 .. $-1];\n+            sink(signedToTempString(val));\n+            sink(\" \");\n+            sink(unit);\n+        }\n+\n+        if (_hnsecs == 0)\n+        {\n+            sink(\"0 hnsecs\");\n+            return;\n+        }\n+\n+        long hnsecs = _hnsecs;\n+        uint pos;\n+        static foreach (unit; units)\n+        {\n+            if (auto val = splitUnitsFromHNSecs!unit(hnsecs))\n+            {\n+                appListSep(sink, pos++, hnsecs == 0);\n+                appUnitVal!unit(sink, val);\n+            }\n+            if (hnsecs == 0)\n+                return;\n+        }\n+        if (hnsecs != 0)\n+        {\n+            appListSep(sink, pos++, true);\n+            appUnitVal!\"hnsecs\"(sink, hnsecs);\n+        }\n+    }\n+\n @safe pure:\n \n public:\n@@ -1539,71 +1614,12 @@ public:\n         }\n     }\n \n-\n-    /++\n-        Converts this `Duration` to a `string`.\n-\n-        The string is meant to be human readable, not machine parseable (e.g.\n-        whether there is an `'s'` on the end of the unit name usually depends on\n-        whether it's plural or not, and empty units are not included unless the\n-        Duration is `zero`). Any code needing a specific string format should\n-        use `total` or `split` to get the units needed to create the desired\n-        string format and create the string itself.\n-\n-        The format returned by toString may or may not change in the future.\n-      +/\n-    string toString() const nothrow pure @safe\n+    /// Ditto\n+    string toString() const scope nothrow\n     {\n-        static void appListSep(ref string res, uint pos, bool last)\n-        {\n-            if (pos == 0)\n-                return;\n-            if (!last)\n-                res ~= \", \";\n-            else\n-                res ~= pos == 1 ? \" and \" : \", and \";\n-        }\n-\n-        static void appUnitVal(string units)(ref string res, long val)\n-        {\n-            immutable plural = val != 1;\n-            string unit;\n-            static if (units == \"seconds\")\n-                unit = plural ? \"secs\" : \"sec\";\n-            else static if (units == \"msecs\")\n-                unit = \"ms\";\n-            else static if (units == \"usecs\")\n-                unit = \"\u03bcs\";\n-            else\n-                unit = plural ? units : units[0 .. $-1];\n-            res ~= signedToTempString(val);\n-            res ~= \" \";\n-            res ~= unit;\n-        }\n-\n-        if (_hnsecs == 0)\n-            return \"0 hnsecs\";\n-\n-        template TT(T...) { alias T TT; }\n-        alias units = TT!(\"weeks\", \"days\", \"hours\", \"minutes\", \"seconds\", \"msecs\", \"usecs\");\n-\n-        long hnsecs = _hnsecs; string res; uint pos;\n-        foreach (unit; units)\n-        {\n-            if (auto val = splitUnitsFromHNSecs!unit(hnsecs))\n-            {\n-                appListSep(res, pos++, hnsecs == 0);\n-                appUnitVal!unit(res, val);\n-            }\n-            if (hnsecs == 0)\n-                break;\n-        }\n-        if (hnsecs != 0)\n-        {\n-            appListSep(res, pos++, true);\n-            appUnitVal!\"hnsecs\"(res, hnsecs);\n-        }\n-        return res;\n+        string result;\n+        this.toString((in char[] data) { result ~= data; });\n+        return result;\n     }\n \n     ///\n@@ -1731,6 +1747,20 @@ unittest\n     assert(myTime == 123.msecs);\n }\n \n+// Ensure `toString` doesn't allocate if the sink doesn't\n+version (CoreUnittest) @safe pure nothrow @nogc unittest\n+{\n+    char[256] buffer; size_t len;\n+    scope sink = (in char[] data) {\n+        assert(data.length + len <= buffer.length);\n+        buffer[len .. len + data.length] = data[];\n+        len += data.length;\n+    };\n+    auto dur = Duration(-12_096_020_900_003);\n+    dur.toString(sink);\n+    assert(buffer[0 .. len] == \"-2 weeks, -2 secs, -90 ms, and -3 hnsecs\");\n+}\n+\n /++\n     Converts a $(D TickDuration) to the given units as either an integral\n     value or a floating point value."}, {"sha": "56a2efe735ad476c5595ce2fe63e0d2884daf1c6", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -2649,13 +2649,18 @@ class Throwable : Object\n \n     /**\n      * Get the message describing the error.\n-     * Base behavior is to return the `Throwable.msg` field.\n-     * Override to return some other error message.\n+     *\n+     * This getter is an alternative way to access the Exception's message,\n+     * with the added advantage of being override-able in subclasses.\n+     * Subclasses are hence free to do their own memory managements without\n+     * being tied to the requirement of providing a `string` in a field.\n+     *\n+     * The default behavior is to return the `Throwable.msg` field.\n      *\n      * Returns:\n-     *  Error message\n+     *  A message representing the cause of the `Throwable`\n      */\n-    @__future const(char)[] message() const\n+    @__future const(char)[] message() const @safe nothrow\n     {\n         return this.msg;\n     }"}, {"sha": "e15541e181d3313d79c742a98edc3fa07b49d799", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -1,4 +1,4 @@\n-1a3e80ec25afab6123cdcfe20186f36f006b68bb\n+41aaf8c2636df0e2e3ad39933b321d2b4cd231fa\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "b09b82ab85e03bd7e02779485db749199956063b", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -425,10 +425,10 @@ version (Windows) private void[] readImpl(scope const(char)[] name, scope const(\n             fileSize = makeUlong(sizeLow, sizeHigh);\n         return result;\n     }\n-    static trustedReadFile(HANDLE hFile, void *lpBuffer, ulong nNumberOfBytesToRead)\n+    static trustedReadFile(HANDLE hFile, void *lpBuffer, size_t nNumberOfBytesToRead)\n     {\n         // Read by chunks of size < 4GB (Windows API limit)\n-        ulong totalNumRead = 0;\n+        size_t totalNumRead = 0;\n         while (totalNumRead != nNumberOfBytesToRead)\n         {\n             const uint chunkSize = min(nNumberOfBytesToRead - totalNumRead, 0xffff_0000);"}, {"sha": "c1c5cd2b36e8464574ccf8f6574e7bab7b8e75f0", "filename": "libphobos/src/std/getopt.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Fgetopt.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fgetopt.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -438,7 +438,7 @@ GetoptResult getopt(T...)(ref string[] args, T opts)\n }\n \n ///\n-@system unittest\n+@safe unittest\n {\n     auto args = [\"prog\", \"--foo\", \"-b\"];\n \n@@ -1646,11 +1646,13 @@ Params:\n     text = The text to printed at the beginning of the help output.\n     opt = The `Option` extracted from the `getopt` parameter.\n */\n-void defaultGetoptPrinter(string text, Option[] opt)\n+void defaultGetoptPrinter(string text, Option[] opt) @safe\n {\n     import std.stdio : stdout;\n+    // stdout global __gshared is trusted with a locked text writer\n+    auto w = (() @trusted => stdout.lockingTextWriter())();\n \n-    defaultGetoptFormatter(stdout.lockingTextWriter(), text, opt);\n+    defaultGetoptFormatter(w, text, opt);\n }\n \n /** This function writes the passed text and `Option` into an output range"}, {"sha": "31f58fa5fa9e721f903c4e49d1a2a8997811812b", "filename": "libphobos/src/std/range/primitives.d", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Frange%2Fprimitives.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Frange%2Fprimitives.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frange%2Fprimitives.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -2055,9 +2055,14 @@ if (isBidirectionalRange!Range)\n }\n \n /**\n-   Moves the front of `r` out and returns it. Leaves `r.front` in a\n-   destroyable state that does not allocate any resources (usually equal\n-   to its `.init` value).\n+   Moves the front of `r` out and returns it.\n+\n+   If `r.front` is a struct with a destructor or copy constructor defined, it\n+   is reset to its `.init` value after its value is moved. Otherwise, it is\n+   left unchanged.\n+\n+   In either case, `r.front` is left in a destroyable state that does not\n+   allocate any resources.\n */\n ElementType!R moveFront(R)(R r)\n {"}, {"sha": "0dd636ea67b97dcfa68dd67f63eb506c291d7090", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 94, "deletions": 14, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1027dc459204894f4503f713a3d73826e4bbab15/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=1027dc459204894f4503f713a3d73826e4bbab15", "patch": "@@ -533,15 +533,35 @@ public:\n         /**\n          * Assigns a value to a `SumType`.\n          *\n-         * Assigning to a `SumType` is `@system` if any of the\n-         * `SumType`'s members contain pointers or references, since\n-         * those members may be reachable through external references,\n-         * and overwriting them could therefore lead to memory\n-         * corruption.\n+         * If any of the `SumType`'s members other than the one being assigned\n+         * to contain pointers or references, it is possible for the assignment\n+         * to cause memory corruption (see the\n+         * [\"Memory corruption\" example](#memory-corruption) below for an\n+         * illustration of how). Therefore, such assignments are considered\n+         * `@system`.\n          *\n          * An individual assignment can be `@trusted` if the caller can\n-         * guarantee that there are no outstanding references to $(I any)\n-         * of the `SumType`'s members when the assignment occurs.\n+         * guarantee that there are no outstanding references to any `SumType`\n+         * members that contain pointers or references at the time the\n+         * assignment occurs.\n+         *\n+         * Examples:\n+         *\n+         * $(DIVID memory-corruption, $(H3 Memory corruption))\n+         *\n+         * This example shows how assignment to a `SumType` can be used to\n+         * cause memory corruption in `@system` code. In `@safe` code, the\n+         * assignment `s = 123` would not be allowed.\n+         *\n+         * ---\n+         * SumType!(int*, int) s = new int;\n+         * s.tryMatch!(\n+         *     (ref int* p) {\n+         *         s = 123; // overwrites `p`\n+         *         return *p; // undefined behavior\n+         *     }\n+         * );\n+         * ---\n          */\n         ref SumType opAssign(T rhs);\n     }\n@@ -553,14 +573,35 @@ public:\n             /**\n              * Assigns a value to a `SumType`.\n              *\n-             * Assigning to a `SumType` is `@system` if any of the `SumType`'s\n-             * $(I other) members contain pointers or references, since those\n-             * members may be reachable through external references, and\n-             * overwriting them could therefore lead to memory corruption.\n+             * If any of the `SumType`'s members other than the one being assigned\n+             * to contain pointers or references, it is possible for the assignment\n+             * to cause memory corruption (see the\n+             * [\"Memory corruption\" example](#memory-corruption) below for an\n+             * illustration of how). Therefore, such assignments are considered\n+             * `@system`.\n              *\n              * An individual assignment can be `@trusted` if the caller can\n-             * guarantee that, when the assignment occurs, there are no\n-             * outstanding references to any such members.\n+             * guarantee that there are no outstanding references to any `SumType`\n+             * members that contain pointers or references at the time the\n+             * assignment occurs.\n+             *\n+             * Examples:\n+             *\n+             * $(DIVID memory-corruption, $(H3 Memory corruption))\n+             *\n+             * This example shows how assignment to a `SumType` can be used to\n+             * cause memory corruption in `@system` code. In `@safe` code, the\n+             * assignment `s = 123` would not be allowed.\n+             *\n+             * ---\n+             * SumType!(int*, int) s = new int;\n+             * s.tryMatch!(\n+             *     (ref int* p) {\n+             *         s = 123; // overwrites `p`\n+             *         return *p; // undefined behavior\n+             *     }\n+             * );\n+             * ---\n              */\n             ref SumType opAssign(T rhs)\n             {\n@@ -1528,7 +1569,27 @@ private enum bool isSumTypeInstance(T) = is(T == SumType!Args, Args...);\n }\n \n /// True if `T` is a [SumType] or implicitly converts to one, otherwise false.\n-enum bool isSumType(T) = is(T : SumType!Args, Args...);\n+template isSumType(T)\n+{\n+    static if (is(T : SumType!Args, Args...))\n+    {\n+        enum isSumType = true;\n+    }\n+    else static if (is(T == struct) && __traits(getAliasThis, T).length > 0)\n+    {\n+        // Workaround for https://issues.dlang.org/show_bug.cgi?id=21975\n+        import std.traits : ReturnType;\n+\n+        alias AliasThisType = ReturnType!((T t) =>\n+            __traits(getMember, t, __traits(getAliasThis, T)[0])\n+        );\n+        enum isSumType = .isSumType!AliasThisType;\n+    }\n+    else\n+    {\n+        enum isSumType = false;\n+    }\n+}\n \n ///\n @safe unittest\n@@ -1549,6 +1610,25 @@ enum bool isSumType(T) = is(T : SumType!Args, Args...);\n     assert(!isSumType!ContainsSumType);\n }\n \n+@safe unittest\n+{\n+    static struct AliasThisVar(T)\n+    {\n+        SumType!T payload;\n+        alias payload this;\n+    }\n+\n+    static struct AliasThisFunc(T)\n+    {\n+        SumType!T payload;\n+        ref get() { return payload; }\n+        alias get this;\n+    }\n+\n+    static assert(isSumType!(AliasThisVar!int));\n+    static assert(isSumType!(AliasThisFunc!int));\n+}\n+\n /**\n  * Calls a type-appropriate function with the value held in a [SumType].\n  *"}]}