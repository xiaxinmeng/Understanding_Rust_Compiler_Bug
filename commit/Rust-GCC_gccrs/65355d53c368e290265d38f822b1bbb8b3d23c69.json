{"sha": "65355d53c368e290265d38f822b1bbb8b3d23c69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUzNTVkNTNjMzY4ZTI5MDI2NWQzOGY4MjJiMWJiYjhiM2QyM2M2OQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-06-23T07:43:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-06-23T07:43:21Z"}, "message": "c-gimplify.c (gimplify_decl_stmt): Update gimplify_type_sizes call.\n\n        * c-gimplify.c (gimplify_decl_stmt): Update gimplify_type_sizes call.\n        Use gimplify_and_add.\n        * c-typeck.c (c_finish_if_stmt): Use NULL instead of empty stmt.\n        * gimplify.c (build_and_jump, gimplify_exit_expr,\n        gimplify_init_constructor, gimplify_save_expr, gimple_push_cleanup,\n        gimplify_stmt, gimplify_expr): Likewise.\n        (shortcut_cond_expr): Handle NULL arms of COND_EXPR.\n        (gimplify_statement_list): Remove NULL entries.\n        (gimplify_to_stmt_list): Handle NULL results.\n        (gimplify_type_sizes): Add list_p argument.\n        (gimplify_one_sizepos): Don't use internal pre/post queue.\n        * tree-gimple.h (gimplify_type_sizes): Update.\nada/\n        * trans.c (gnat_gimplify_stmt): Update gimplify_type_sizes call.\n\nFrom-SVN: r83539", "tree": {"sha": "8a64183917aa821491a290388a2d847ef5f31dc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a64183917aa821491a290388a2d847ef5f31dc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65355d53c368e290265d38f822b1bbb8b3d23c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65355d53c368e290265d38f822b1bbb8b3d23c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65355d53c368e290265d38f822b1bbb8b3d23c69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65355d53c368e290265d38f822b1bbb8b3d23c69/comments", "author": null, "committer": null, "parents": [{"sha": "f241bf89479214a544e12446b52eb9d89869aebe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f241bf89479214a544e12446b52eb9d89869aebe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f241bf89479214a544e12446b52eb9d89869aebe"}], "stats": {"total": 167, "additions": 83, "deletions": 84}, "files": [{"sha": "8b63eb29699155c934f6e576f3492829efac65dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -1,3 +1,18 @@\n+2004-06-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* c-gimplify.c (gimplify_decl_stmt): Update gimplify_type_sizes call.\n+\tUse gimplify_and_add.\n+\t* c-typeck.c (c_finish_if_stmt): Use NULL instead of empty stmt.\n+\t* gimplify.c (build_and_jump, gimplify_exit_expr,\n+\tgimplify_init_constructor, gimplify_save_expr, gimple_push_cleanup,\n+\tgimplify_stmt, gimplify_expr): Likewise.\n+\t(shortcut_cond_expr): Handle NULL arms of COND_EXPR.\n+\t(gimplify_statement_list): Remove NULL entries.\n+\t(gimplify_to_stmt_list): Handle NULL results.\n+\t(gimplify_type_sizes): Add list_p argument.\n+\t(gimplify_one_sizepos): Don't use internal pre/post queue.\n+\t* tree-gimple.h (gimplify_type_sizes): Update.\n+\n 2004-06-22  Eric Christopher  <echristo@redhat.com>\n \n \t* config/rs6000/rs6000.md (*insvsi_internal5/6): New patterns."}, {"sha": "e1464ed319c2b7733343b41ff512e3282a0617f9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -1,3 +1,7 @@\n+2004-06-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* trans.c (gnat_gimplify_stmt): Update gimplify_type_sizes call.\n+\n 2004-06-20  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* decl.c (elaborate_expression, elaborate_expression_1): Arguments"}, {"sha": "b321ef9c6ac7fe0160504b3bc7b05162476e13b0", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -4280,11 +4280,11 @@ gnat_gimplify_stmt (tree *stmt_p)\n       {\n \ttree var = DECL_STMT_VAR (stmt);\n \n+\t*stmt_p = NULL_TREE;\n \tif (TREE_CODE (var) == TYPE_DECL)\n-\t  *stmt_p = gimplify_type_sizes (TREE_TYPE (var));\n+\t  gimplify_type_sizes (TREE_TYPE (var), stmt_p);\n \telse if (TREE_CODE (var) == VAR_DECL)\n \t  {\n-\t    *stmt_p = NULL_TREE;\n \t    gimplify_one_sizepos (&DECL_SIZE (var), stmt_p);\n \t    gimplify_one_sizepos (&DECL_SIZE_UNIT (var), stmt_p);\n \n@@ -4302,12 +4302,7 @@ gnat_gimplify_stmt (tree *stmt_p)\n \t\t\t\t\t  NULL_TREE))),\n \t\t   stmt_p);\n \t      }\n-\n-\t    if (*stmt_p == NULL_TREE)\n-\t      *stmt_p = alloc_stmt_list ();\n \t  }\n-\telse\n-\t  *stmt_p = alloc_stmt_list ();\n \treturn GS_ALL_DONE;\n       }\n "}, {"sha": "a3040d0bcd231bb46e0c64d5577a339c48d5acbe", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -476,20 +476,18 @@ gimplify_decl_stmt (tree *stmt_p)\n   tree stmt = *stmt_p;\n   tree decl = DECL_STMT_DECL (stmt);\n \n+  *stmt_p = NULL_TREE;\n+\n   if (TREE_TYPE (decl) == error_mark_node)\n-    {\n-      *stmt_p = NULL;\n-      return GS_ERROR;\n-    }\n-    \n+    return GS_ERROR;\n+\n   if (TREE_CODE (decl) == TYPE_DECL)\n-    *stmt_p = gimplify_type_sizes (TREE_TYPE (decl));\n+    gimplify_type_sizes (TREE_TYPE (decl), stmt_p);\n \n   else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n     {\n       tree init = DECL_INITIAL (decl);\n \n-      *stmt_p = NULL_TREE;\n       gimplify_one_sizepos (&DECL_SIZE (decl), stmt_p);\n       gimplify_one_sizepos (&DECL_SIZE_UNIT (decl), stmt_p);\n \n@@ -508,8 +506,7 @@ gimplify_decl_stmt (tree *stmt_p)\n \t\t\t   tree_cons (NULL_TREE, DECL_SIZE_UNIT (decl),\n \t\t\t\t      NULL_TREE))));\n \n-\t  gimplify_stmt (&alloc_stmt);\n-\t  append_to_statement_list(alloc_stmt, stmt_p);\n+\t  gimplify_and_add (alloc_stmt, stmt_p);\n \t  DECL_DEFER_OUTPUT (decl) = 1;\n \t}\n \n@@ -525,8 +522,7 @@ gimplify_decl_stmt (tree *stmt_p)\n               \n \t      DECL_INITIAL (decl) = NULL_TREE;\n \t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n-\t      gimplify_stmt (&init);\n-\t      append_to_statement_list (init, stmt_p);\n+\t      gimplify_and_add (init, stmt_p);\n \t    }\n \t  else\n \t    /* We must still examine initializers for static variables\n@@ -540,8 +536,6 @@ gimplify_decl_stmt (tree *stmt_p)\n       if (DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n \tgimple_add_tmp_var (decl);\n     }\n-  else\n-    *stmt_p = alloc_stmt_list ();\n \n   return GS_ALL_DONE;\n }"}, {"sha": "a2daf3277e97af139c5df6414457c09660a6e2f7", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -6570,9 +6570,6 @@ c_finish_if_stmt (int stmt_count)\n {\n   if_elt *elt = &if_stack[--if_stack_pointer];\n \n-  if (COND_EXPR_ELSE (elt->if_stmt) == NULL)\n-    COND_EXPR_ELSE (elt->if_stmt) = build_empty_stmt ();\n-\n   if (elt->needs_warning)\n     warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n \t     EXPR_LOCUS (elt->if_stmt));"}, {"sha": "a4baa1e85e4bdba2f0a273e61e164cf1d0bd7203", "filename": "gcc/gimplify.c", "status": "modified", "additions": 54, "deletions": 60, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -1288,7 +1288,7 @@ build_and_jump (tree *label_p)\n {\n   if (label_p == NULL)\n     /* If there's nowhere to jump, just fall through.  */\n-    return alloc_stmt_list ();\n+    return NULL_TREE;\n \n   if (*label_p == NULL_TREE)\n     {\n@@ -1310,7 +1310,7 @@ gimplify_exit_expr (tree *expr_p)\n   tree expr;\n \n   expr = build_and_jump (&gimplify_ctxp->exit_label);\n-  expr = build (COND_EXPR, void_type_node, cond, expr, alloc_stmt_list ());\n+  expr = build (COND_EXPR, void_type_node, cond, expr, NULL_TREE);\n   *expr_p = expr;\n \n   return GS_OK;\n@@ -1403,7 +1403,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t       TU-local symbol, we must invoke the lhd version now.  */\n \t    lhd_set_decl_assembler_name (object);\n \n-\t    *expr_p = alloc_stmt_list ();\n+\t    *expr_p = NULL_TREE;\n \t    break;\n \t  }\n \n@@ -1524,7 +1524,7 @@ gimplify_init_constructor (tree *expr_p, tree *pre_p,\n \t    append_to_statement_list (init, pre_p);\n \t  }\n \n-\t*expr_p = alloc_stmt_list ();\n+\t*expr_p = NULL_TREE;\n       }\n       break;\n \n@@ -2321,21 +2321,22 @@ shortcut_cond_expr (tree expr)\n   tree *true_label_p;\n   tree *false_label_p;\n   bool emit_end, emit_false;\n+  bool then_se = then_ && TREE_SIDE_EFFECTS (then_);\n+  bool else_se = else_ && TREE_SIDE_EFFECTS (else_);\n \n   /* First do simple transformations.  */\n-  if (!TREE_SIDE_EFFECTS (else_))\n+  if (!else_se)\n     {\n       /* If there is no 'else', turn (a && b) into if (a) if (b).  */\n       while (TREE_CODE (pred) == TRUTH_ANDIF_EXPR)\n \t{\n \t  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);\n \t  then_ = shortcut_cond_expr (expr);\n \t  pred = TREE_OPERAND (pred, 0);\n-\t  expr = build (COND_EXPR, void_type_node, pred, then_,\n-\t\t\talloc_stmt_list ());\n+\t  expr = build (COND_EXPR, void_type_node, pred, then_, NULL_TREE);\n \t}\n     }\n-  if (!TREE_SIDE_EFFECTS (then_))\n+  if (!then_se)\n     {\n       /* If there is no 'then', turn\n \t   if (a || b); else d\n@@ -2346,8 +2347,7 @@ shortcut_cond_expr (tree expr)\n \t  TREE_OPERAND (expr, 0) = TREE_OPERAND (pred, 1);\n \t  else_ = shortcut_cond_expr (expr);\n \t  pred = TREE_OPERAND (pred, 0);\n-\t  expr = build (COND_EXPR, void_type_node, pred,\n-\t\t\talloc_stmt_list (), else_);\n+\t  expr = build (COND_EXPR, void_type_node, pred, NULL_TREE, else_);\n \t}\n     }\n \n@@ -2369,18 +2369,22 @@ shortcut_cond_expr (tree expr)\n   /* If our arms just jump somewhere, hijack those labels so we don't\n      generate jumps to jumps.  */\n \n-  if (TREE_CODE (then_) == GOTO_EXPR\n+  if (then_\n+      && TREE_CODE (then_) == GOTO_EXPR\n       && TREE_CODE (GOTO_DESTINATION (then_)) == LABEL_DECL)\n     {\n       true_label = GOTO_DESTINATION (then_);\n-      then_ = alloc_stmt_list ();\n+      then_ = NULL;\n+      then_se = false;\n     }\n \n-  if (TREE_CODE (else_) == GOTO_EXPR\n+  if (else_\n+      && TREE_CODE (else_) == GOTO_EXPR\n       && TREE_CODE (GOTO_DESTINATION (else_)) == LABEL_DECL)\n     {\n       false_label = GOTO_DESTINATION (else_);\n-      else_ = alloc_stmt_list ();\n+      else_ = NULL;\n+      else_se = false;\n     }\n \n   /* If we aren't hijacking a label for the 'then' branch, it falls through.  */\n@@ -2390,21 +2394,23 @@ shortcut_cond_expr (tree expr)\n     true_label_p = NULL;\n \n   /* The 'else' branch also needs a label if it contains interesting code.  */\n-  if (false_label || TREE_SIDE_EFFECTS (else_))\n+  if (false_label || else_se)\n     false_label_p = &false_label;\n   else\n     false_label_p = NULL;\n \n   /* If there was nothing else in our arms, just forward the label(s).  */\n-  if (!TREE_SIDE_EFFECTS (then_) && !TREE_SIDE_EFFECTS (else_))\n+  if (!then_se && !else_se)\n     return shortcut_cond_r (pred, true_label_p, false_label_p);\n \n   /* If our last subexpression already has a terminal label, reuse it.  */\n-  if (TREE_SIDE_EFFECTS (else_))\n+  if (else_se)\n     expr = expr_last (else_);\n-  else\n+  else if (then_se)\n     expr = expr_last (then_);\n-  if (TREE_CODE (expr) == LABEL_EXPR)\n+  else\n+    expr = NULL;\n+  if (expr && TREE_CODE (expr) == LABEL_EXPR)\n     end_label = LABEL_EXPR_LABEL (expr);\n \n   /* If we don't care about jumping to the 'else' branch, jump to the end\n@@ -2422,7 +2428,7 @@ shortcut_cond_expr (tree expr)\n   append_to_statement_list (pred, &expr);\n \n   append_to_statement_list (then_, &expr);\n-  if (TREE_SIDE_EFFECTS (else_))\n+  if (else_se)\n     {\n       t = build_and_jump (&end_label);\n       append_to_statement_list (t, &expr);\n@@ -2897,7 +2903,9 @@ gimplify_statement_list (tree *expr_p)\n       gimplify_stmt (tsi_stmt_ptr (i));\n \n       t = tsi_stmt (i);\n-      if (TREE_CODE (t) == STATEMENT_LIST)\n+      if (t == NULL)\n+\ttsi_delink (&i);\n+      else if (TREE_CODE (t) == STATEMENT_LIST)\n \t{\n \t  tsi_link_before (&i, t, TSI_SAME_STMT);\n \t  tsi_delink (&i);\n@@ -2941,7 +2949,7 @@ gimplify_save_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       tree body = TREE_OPERAND (*expr_p, 0);\n       ret = gimplify_expr (& body, pre_p, post_p, is_gimple_stmt, fb_none);\n       append_to_statement_list (body, pre_p);\n-      *expr_p = alloc_stmt_list ();\n+      *expr_p = NULL;\n     }\n   else\n     *expr_p = TREE_OPERAND (*expr_p, 0)\n@@ -3243,8 +3251,7 @@ gimple_push_cleanup (tree var, tree cleanup, tree *pre_p)\n \t\t\t   boolean_false_node);\n       tree ftrue = build (MODIFY_EXPR, void_type_node, flag,\n \t\t\t  boolean_true_node);\n-      cleanup = build (COND_EXPR, void_type_node, flag, cleanup,\n-\t\t       alloc_stmt_list ());\n+      cleanup = build (COND_EXPR, void_type_node, flag, cleanup, NULL);\n       wce = build (WITH_CLEANUP_EXPR, void_type_node, NULL_TREE,\n \t\t   cleanup, NULL_TREE);\n       append_to_statement_list (ffalse, &gimplify_ctxp->conditional_cleanups);\n@@ -3331,8 +3338,6 @@ void\n gimplify_stmt (tree *stmt_p)\n {\n   gimplify_expr (stmt_p, NULL, NULL, is_gimple_stmt, fb_none);\n-  if (!*stmt_p)\n-    *stmt_p = alloc_stmt_list ();\n }\n \n /* Similarly, but force the result to be a STATEMENT_LIST.  */\n@@ -3341,7 +3346,9 @@ void\n gimplify_to_stmt_list (tree *stmt_p)\n {\n   gimplify_stmt (stmt_p);\n-  if (TREE_CODE (*stmt_p) != STATEMENT_LIST)\n+  if (!*stmt_p)\n+    *stmt_p = alloc_stmt_list ();\n+  else if (TREE_CODE (*stmt_p) != STATEMENT_LIST)\n     {\n       tree t = *stmt_p;\n       *stmt_p = alloc_stmt_list ();\n@@ -3427,7 +3434,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \n       /* Die, die, die, my darling.  */\n       if (save_expr == error_mark_node\n-\t  || TREE_TYPE (save_expr) == error_mark_node)\n+\t  || (TREE_TYPE (save_expr)\n+\t      && TREE_TYPE (save_expr) == error_mark_node))\n \t{\n \t  ret = GS_ERROR;\n \t  break;\n@@ -3814,7 +3822,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n   if (ret == GS_ERROR)\n     {\n       if (is_statement)\n-\t*expr_p = alloc_stmt_list ();\n+\t*expr_p = NULL;\n       goto out;\n     }\n \n@@ -3825,14 +3833,12 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n     abort ();\n #endif\n \n-  if (!*expr_p)\n-    *expr_p = alloc_stmt_list ();\n-  if (fallback == fb_none && !is_gimple_stmt (*expr_p))\n+  if (fallback == fb_none && *expr_p && !is_gimple_stmt (*expr_p))\n     {\n       /* We aren't looking for a value, and we don't have a valid\n \t statement.  If it doesn't have side-effects, throw it away.  */\n       if (!TREE_SIDE_EFFECTS (*expr_p))\n-\t*expr_p = alloc_stmt_list ();\n+\t*expr_p = NULL;\n       else if (!TREE_THIS_VOLATILE (*expr_p))\n \t{\n \t  /* This is probably a _REF that contains something nested that\n@@ -3855,7 +3861,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t       must be converted to a valid statement before we get here.  */\n \t    abort ();\n \n-\t  *expr_p = alloc_stmt_list ();\n+\t  *expr_p = NULL;\n \t}\n       else if (COMPLETE_TYPE_P (TREE_TYPE (*expr_p)))\n \t{\n@@ -3867,7 +3873,7 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n       else\n \t/* We can't do anything useful with a volatile reference to\n \t   incomplete type, so just throw it away.  */\n-\t*expr_p = alloc_stmt_list ();\n+\t*expr_p = NULL;\n     }\n \n   /* If we are gimplifying at the statement level, we're done.  Tack\n@@ -3882,6 +3888,8 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n \t  annotate_all_with_locus (&internal_pre, input_location);\n \t  *expr_p = internal_pre;\n \t}\n+      else if (!*expr_p)\n+\t;\n       else if (TREE_CODE (*expr_p) == STATEMENT_LIST)\n \tannotate_all_with_locus (expr_p, input_location);\n       else\n@@ -3966,53 +3974,46 @@ gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p,\n }\n \n /* Look through TYPE for variable-sized objects and gimplify each such\n-   size that we find.  Return a STATEMENT_LIST containing the result.  */\n+   size that we find.  Add to LIST_P any statements generated.  */\n \n-tree\n-gimplify_type_sizes (tree type)\n+void\n+gimplify_type_sizes (tree type, tree *list_p)\n {\n-  tree stmts = NULL_TREE;\n   tree field;\n \n   switch (TREE_CODE (type))\n     {\n     case ERROR_MARK:\n-      return alloc_stmt_list ();\n+      return;\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case CHAR_TYPE:\n     case REAL_TYPE:\n-      gimplify_one_sizepos (&TYPE_MIN_VALUE (type), &stmts);\n-      gimplify_one_sizepos (&TYPE_MAX_VALUE (type), &stmts);\n+      gimplify_one_sizepos (&TYPE_MIN_VALUE (type), list_p);\n+      gimplify_one_sizepos (&TYPE_MAX_VALUE (type), list_p);\n       break;\n \n     case ARRAY_TYPE:\n       /* These anonymous types don't have declarations, so handle them here. */\n-      append_to_statement_list (gimplify_type_sizes (TYPE_DOMAIN (type)),\n-\t\t\t\t&stmts);\n+      gimplify_type_sizes (TYPE_DOMAIN (type), list_p);\n       break;\n \n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n       for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n \tif (TREE_CODE (field) == FIELD_DECL)\n-\t  gimplify_one_sizepos (&DECL_FIELD_OFFSET (field), &stmts);\n+\t  gimplify_one_sizepos (&DECL_FIELD_OFFSET (field), list_p);\n       break;\n \n     default:\n       break;\n     }\n \n-  gimplify_one_sizepos (&TYPE_SIZE (type), &stmts);\n-  gimplify_one_sizepos (&TYPE_SIZE_UNIT (type), &stmts);\n-\n-  if (!stmts)\n-    stmts = alloc_stmt_list ();\n-\n-  return stmts;\n+  gimplify_one_sizepos (&TYPE_SIZE (type), list_p);\n+  gimplify_one_sizepos (&TYPE_SIZE_UNIT (type), list_p);\n }\n \n /* Subroutine of the above to gimplify one size or position, *EXPR_P.\n@@ -4021,20 +4022,13 @@ gimplify_type_sizes (tree type)\n void\n gimplify_one_sizepos (tree *expr_p, tree *stmt_p)\n {\n-  tree pre = NULL_TREE, post = NULL_TREE;\n-\n   /* We don't do anything if the value isn't there, is constant, or contains\n      A PLACEHOLDER_EXPR.  */\n   if (*expr_p == NULL_TREE || TREE_CONSTANT (*expr_p)\n       || CONTAINS_PLACEHOLDER_P (*expr_p))\n     return;\n \n-  gimplify_expr (expr_p, &pre, &post, is_gimple_val, fb_rvalue);\n-\n-  if (pre)\n-    append_to_statement_list (pre, stmt_p);\n-  if (post)\n-    append_to_statement_list (post, stmt_p);\n+  gimplify_expr (expr_p, stmt_p, NULL, is_gimple_val, fb_rvalue);\n }\n \f\n #ifdef ENABLE_CHECKING"}, {"sha": "9b86e982f08fb3436f20fde086a158f33cd5740c", "filename": "gcc/tree-gimple.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Ftree-gimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65355d53c368e290265d38f822b1bbb8b3d23c69/gcc%2Ftree-gimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.h?ref=65355d53c368e290265d38f822b1bbb8b3d23c69", "patch": "@@ -102,7 +102,7 @@ enum gimplify_status {\n \n extern enum gimplify_status gimplify_expr (tree *, tree *, tree *,\n \t\t\t\t\t   bool (*) (tree), fallback_t);\n-extern tree gimplify_type_sizes (tree);\n+extern void gimplify_type_sizes (tree, tree *);\n extern void gimplify_one_sizepos (tree *, tree *);\n extern void gimplify_stmt (tree *);\n extern void gimplify_to_stmt_list (tree *);"}]}