{"sha": "15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVhYWI5YzBhYzc2N2I1YzFjODE3NTcwNzNiOGNjM2FjMTNjNjdmYg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-02-25T20:40:57Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2003-02-25T20:40:57Z"}, "message": "sched-int.h (INSN_TRAP_CLASS, [...]): Move them from sched-rgn.c.\n\n2003-02-25  Vladimir Makarov  <vmakarov@redhat.com>\n            Richard Henderson  <rth@redhat.com>\n\n\t* sched-int.h (INSN_TRAP_CLASS, WORST_CLASS): Move them from\n\tsched-rgn.c.\n\t(add_forward_dependence): New function prototype.\n\n\t* sched-rgn.c (INSN_TRAP_CLASS, WORST_CLASS): Move them to\n\tsched-init.h.\n\t(CONST_BASED_ADDRESS_P, may_trap_exp, haifa_classify_insn): Move\n\tthem to haifa-sched.c.\n\n\t* haifa-sched.c (CONST_BASED_ADDRESS_P, may_trap_exp,\n\thaifa_classify_insn): Move them from sched-rgn.c.\n\n\t* sched-deps.c (add_dependence): Return flag of creating a new\n\tentry.\n\t(add_forward_dependence): New function.\n\t(compute_forward_dependences): Use the function.\n\n\t* sched-ebb.c (earliest_block_with_similiar_load): New function.\n\t(add_deps_for_risky_insns): New function.\n\t(schedule_ebb): Call the function.\n\nFrom-SVN: r63415", "tree": {"sha": "438a955cba1ac5046f0de88f563fe3a571086f7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/438a955cba1ac5046f0de88f563fe3a571086f7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/comments", "author": null, "committer": null, "parents": [{"sha": "c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8e4f0e96e4039c7ea360edb11ab376afdf8bb8d"}], "stats": {"total": 735, "additions": 452, "deletions": 283}, "files": [{"sha": "c1fdc2ccaca4361bf5fc750be65c6789e1e7907d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "patch": "@@ -1,4 +1,28 @@\n-003-02-20  Aldy Hernandez  <aldyh@redhat.com>\n+2003-02-25  Vladimir Makarov  <vmakarov@redhat.com>\n+            Richard Henderson  <rth@redhat.com>\n+\n+\t* sched-int.h (INSN_TRAP_CLASS, WORST_CLASS): Move them from\n+\tsched-rgn.c.\n+\t(add_forward_dependence): New function prototype.\n+\n+\t* sched-rgn.c (INSN_TRAP_CLASS, WORST_CLASS): Move them to\n+\tsched-init.h.\n+\t(CONST_BASED_ADDRESS_P, may_trap_exp, haifa_classify_insn): Move\n+\tthem to haifa-sched.c.\n+\n+\t* haifa-sched.c (CONST_BASED_ADDRESS_P, may_trap_exp,\n+\thaifa_classify_insn): Move them from sched-rgn.c.\n+\n+\t* sched-deps.c (add_dependence): Return flag of creating a new\n+\tentry.\n+\t(add_forward_dependence): New function.\n+\t(compute_forward_dependences): Use the function.\n+\t\n+\t* sched-ebb.c (earliest_block_with_similiar_load): New function.\n+\t(add_deps_for_risky_insns): New function.\n+\t(schedule_ebb): Call the function.\n+\n+2003-02-20  Aldy Hernandez  <aldyh@redhat.com>\n \n         * doc/tm.texi: Document Rename TARGET_VECTOR_TYPES_COMPATIBLE to\n         TARGET_VECTOR_OPAQUE_P.  Document accordingly."}, {"sha": "8ea2481ce81693bf31e2fa64d524e9f7e3cbd485", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "patch": "@@ -305,6 +305,170 @@ struct ready_list\n   int n_ready;\n };\n \n+static int may_trap_exp PARAMS ((rtx, int));\n+\n+/* Nonzero iff the address is comprised from at most 1 register.  */\n+#define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n+  (GET_CODE (x) == REG\t\t\t\t\t\\\n+   || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\t\\\n+\t|| (GET_CODE (x) == LO_SUM))\t\t\t\\\n+       && (CONSTANT_P (XEXP (x, 0))\t\t\t\\\n+\t   || CONSTANT_P (XEXP (x, 1)))))\n+\n+/* Returns a class that insn with GET_DEST(insn)=x may belong to,\n+   as found by analyzing insn's expression.  */\n+\n+static int\n+may_trap_exp (x, is_store)\n+     rtx x;\n+     int is_store;\n+{\n+  enum rtx_code code;\n+\n+  if (x == 0)\n+    return TRAP_FREE;\n+  code = GET_CODE (x);\n+  if (is_store)\n+    {\n+      if (code == MEM && may_trap_p (x))\n+\treturn TRAP_RISKY;\n+      else\n+\treturn TRAP_FREE;\n+    }\n+  if (code == MEM)\n+    {\n+      /* The insn uses memory:  a volatile load.  */\n+      if (MEM_VOLATILE_P (x))\n+\treturn IRISKY;\n+      /* An exception-free load.  */\n+      if (!may_trap_p (x))\n+\treturn IFREE;\n+      /* A load with 1 base register, to be further checked.  */\n+      if (CONST_BASED_ADDRESS_P (XEXP (x, 0)))\n+\treturn PFREE_CANDIDATE;\n+      /* No info on the load, to be further checked.  */\n+      return PRISKY_CANDIDATE;\n+    }\n+  else\n+    {\n+      const char *fmt;\n+      int i, insn_class = TRAP_FREE;\n+\n+      /* Neither store nor load, check if it may cause a trap.  */\n+      if (may_trap_p (x))\n+\treturn TRAP_RISKY;\n+      /* Recursive step: walk the insn...  */\n+      fmt = GET_RTX_FORMAT (code);\n+      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t{\n+\t  if (fmt[i] == 'e')\n+\t    {\n+\t      int tmp_class = may_trap_exp (XEXP (x, i), is_store);\n+\t      insn_class = WORST_CLASS (insn_class, tmp_class);\n+\t    }\n+\t  else if (fmt[i] == 'E')\n+\t    {\n+\t      int j;\n+\t      for (j = 0; j < XVECLEN (x, i); j++)\n+\t\t{\n+\t\t  int tmp_class = may_trap_exp (XVECEXP (x, i, j), is_store);\n+\t\t  insn_class = WORST_CLASS (insn_class, tmp_class);\n+\t\t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)\n+\t    break;\n+\t}\n+      return insn_class;\n+    }\n+}\n+\n+/* Classifies insn for the purpose of verifying that it can be\n+   moved speculatively, by examining it's patterns, returning:\n+   TRAP_RISKY: store, or risky non-load insn (e.g. division by variable).\n+   TRAP_FREE: non-load insn.\n+   IFREE: load from a globaly safe location.\n+   IRISKY: volatile load.\n+   PFREE_CANDIDATE, PRISKY_CANDIDATE: load that need to be checked for\n+   being either PFREE or PRISKY.  */\n+\n+int\n+haifa_classify_insn (insn)\n+     rtx insn;\n+{\n+  rtx pat = PATTERN (insn);\n+  int tmp_class = TRAP_FREE;\n+  int insn_class = TRAP_FREE;\n+  enum rtx_code code;\n+\n+  if (GET_CODE (pat) == PARALLEL)\n+    {\n+      int i, len = XVECLEN (pat, 0);\n+\n+      for (i = len - 1; i >= 0; i--)\n+\t{\n+\t  code = GET_CODE (XVECEXP (pat, 0, i));\n+\t  switch (code)\n+\t    {\n+\t    case CLOBBER:\n+\t      /* Test if it is a 'store'.  */\n+\t      tmp_class = may_trap_exp (XEXP (XVECEXP (pat, 0, i), 0), 1);\n+\t      break;\n+\t    case SET:\n+\t      /* Test if it is a store.  */\n+\t      tmp_class = may_trap_exp (SET_DEST (XVECEXP (pat, 0, i)), 1);\n+\t      if (tmp_class == TRAP_RISKY)\n+\t\tbreak;\n+\t      /* Test if it is a load.  */\n+\t      tmp_class\n+\t\t= WORST_CLASS (tmp_class,\n+\t\t\t       may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)),\n+\t\t\t\t\t     0));\n+\t      break;\n+\t    case COND_EXEC:\n+\t    case TRAP_IF:\n+\t      tmp_class = TRAP_RISKY;\n+\t      break;\n+\t    default:\n+\t      ;\n+\t    }\n+\t  insn_class = WORST_CLASS (insn_class, tmp_class);\n+\t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      code = GET_CODE (pat);\n+      switch (code)\n+\t{\n+\tcase CLOBBER:\n+\t  /* Test if it is a 'store'.  */\n+\t  tmp_class = may_trap_exp (XEXP (pat, 0), 1);\n+\t  break;\n+\tcase SET:\n+\t  /* Test if it is a store.  */\n+\t  tmp_class = may_trap_exp (SET_DEST (pat), 1);\n+\t  if (tmp_class == TRAP_RISKY)\n+\t    break;\n+\t  /* Test if it is a load.  */\n+\t  tmp_class =\n+\t    WORST_CLASS (tmp_class,\n+\t\t\t may_trap_exp (SET_SRC (pat), 0));\n+\t  break;\n+\tcase COND_EXEC:\n+\tcase TRAP_IF:\n+\t  tmp_class = TRAP_RISKY;\n+\t  break;\n+\tdefault:;\n+\t}\n+      insn_class = tmp_class;\n+    }\n+\n+  return insn_class;\n+}\n+\n /* Forward declarations.  */\n \n /* The scheduler using only DFA description should never use the"}, {"sha": "b3c619df51d613172ef54144daec6040b4fb40c9", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "patch": "@@ -173,10 +173,11 @@ conditions_mutex_p (cond1, cond2)\n }\n \f\n /* Add ELEM wrapped in an INSN_LIST with reg note kind DEP_TYPE to the\n-   LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the type\n-   of dependence that this link represents.  */\n+   LOG_LINKS of INSN, if not already there.  DEP_TYPE indicates the\n+   type of dependence that this link represents.  The function returns\n+   nonzero if a new entry has been added to insn's LOG_LINK.  */\n \n-void\n+int\n add_dependence (insn, elem, dep_type)\n      rtx insn;\n      rtx elem;\n@@ -188,13 +189,13 @@ add_dependence (insn, elem, dep_type)\n \n   /* Don't depend an insn on itself.  */\n   if (insn == elem)\n-    return;\n+    return 0;\n \n   /* We can get a dependency on deleted insns due to optimizations in\n      the register allocation and reloading or due to splitting.  Any\n      such dependency is useless and can be ignored.  */\n   if (GET_CODE (elem) == NOTE)\n-    return;\n+    return 0;\n \n   /* flow.c doesn't handle conditional lifetimes entirely correctly;\n      calls mess up the conditional lifetimes.  */\n@@ -213,7 +214,7 @@ add_dependence (insn, elem, dep_type)\n \t  /* Make sure second instruction doesn't affect condition of first\n \t     instruction if switched.  */\n \t  && !modified_in_p (cond2, insn))\n-\treturn;\n+\treturn 0;\n     }\n \n   present_p = 1;\n@@ -227,7 +228,7 @@ add_dependence (insn, elem, dep_type)\n      elem is a CALL is still required.  */\n   if (GET_CODE (insn) == CALL_INSN\n       && (INSN_BB (elem) != INSN_BB (insn)))\n-    return;\n+    return 0;\n #endif\n \n   /* If we already have a dependency for ELEM, then we do not need to\n@@ -251,7 +252,7 @@ add_dependence (insn, elem, dep_type)\n       else\n \tpresent_p = 0;\n       if (present_p && (int) dep_type >= (int) present_dep_type)\n-\treturn;\n+\treturn 0;\n     }\n #endif\n \n@@ -276,7 +277,7 @@ add_dependence (insn, elem, dep_type)\n \t\tabort ();\n \t    }\n #endif\n-\n+\t  \n \t  /* If this is a more restrictive type of dependence than the existing\n \t     one, then change the existing dependence to this type.  */\n \t  if ((int) dep_type < (int) REG_NOTE_KIND (link))\n@@ -298,8 +299,8 @@ add_dependence (insn, elem, dep_type)\n \t\t\t INSN_LUID (elem));\n \t    }\n #endif\n-\t  return;\n-      }\n+\t  return 0;\n+\t}\n   /* Might want to check one level of transitivity to save conses.  */\n \n   link = alloc_INSN_LIST (elem, LOG_LINKS (insn));\n@@ -321,6 +322,7 @@ add_dependence (insn, elem, dep_type)\n \tSET_BIT (output_dependency_cache[INSN_LUID (insn)], INSN_LUID (elem));\n     }\n #endif\n+  return 1;\n }\n \n /* A convenience wrapper to operate on an entire list.  */\n@@ -1310,6 +1312,46 @@ sched_analyze (deps, head, tail)\n   abort ();\n }\n \f\n+\n+/* The following function adds forward dependence (FROM, TO) with\n+   given DEP_TYPE.  The forward dependence should be not exist before.  */\n+\n+void\n+add_forward_dependence (from, to, dep_type)\n+     rtx from;\n+     rtx to;\n+     enum reg_note dep_type;\n+{\n+  rtx new_link;\n+\n+#ifdef ENABLE_CHECKING\n+  /* If add_dependence is working properly there should never\n+     be notes, deleted insns or duplicates in the backward\n+     links.  Thus we need not check for them here.\n+     \n+     However, if we have enabled checking we might as well go\n+     ahead and verify that add_dependence worked properly.  */\n+  if (GET_CODE (from) == NOTE\n+      || INSN_DELETED_P (from)\n+      || (forward_dependency_cache != NULL\n+\t  && TEST_BIT (forward_dependency_cache[INSN_LUID (from)],\n+\t\t       INSN_LUID (to)))\n+      || (forward_dependency_cache == NULL\n+\t  && find_insn_list (to, INSN_DEPEND (from))))\n+    abort ();\n+  if (forward_dependency_cache != NULL)\n+    SET_BIT (forward_dependency_cache[INSN_LUID (from)],\n+\t     INSN_LUID (to));\n+#endif\n+  \n+  new_link = alloc_INSN_LIST (to, INSN_DEPEND (from));\n+  \n+  PUT_REG_NOTE_KIND (new_link, dep_type);\n+  \n+  INSN_DEPEND (from) = new_link;\n+  INSN_DEP_COUNT (to) += 1;\n+}\n+\n /* Examine insns in the range [ HEAD, TAIL ] and Use the backward\n    dependences from LOG_LINKS to build forward dependences in\n    INSN_DEPEND.  */\n@@ -1320,7 +1362,6 @@ compute_forward_dependences (head, tail)\n {\n   rtx insn, link;\n   rtx next_tail;\n-  enum reg_note dep_type;\n \n   next_tail = NEXT_INSN (tail);\n   for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n@@ -1329,41 +1370,7 @@ compute_forward_dependences (head, tail)\n \tcontinue;\n \n       for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n-\t{\n-\t  rtx x = XEXP (link, 0);\n-\t  rtx new_link;\n-\n-\t  if (x != XEXP (link, 0))\n-\t    continue;\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* If add_dependence is working properly there should never\n-\t     be notes, deleted insns or duplicates in the backward\n-\t     links.  Thus we need not check for them here.\n-\n-\t     However, if we have enabled checking we might as well go\n-\t     ahead and verify that add_dependence worked properly.  */\n-\t  if (GET_CODE (x) == NOTE\n-\t      || INSN_DELETED_P (x)\n-\t      || (forward_dependency_cache != NULL\n-\t\t  && TEST_BIT (forward_dependency_cache[INSN_LUID (x)],\n-\t\t\t       INSN_LUID (insn)))\n-\t      || (forward_dependency_cache == NULL\n-\t\t  && find_insn_list (insn, INSN_DEPEND (x))))\n-\t    abort ();\n-\t  if (forward_dependency_cache != NULL)\n-\t    SET_BIT (forward_dependency_cache[INSN_LUID (x)],\n-\t\t     INSN_LUID (insn));\n-#endif\n-\n-\t  new_link = alloc_INSN_LIST (insn, INSN_DEPEND (x));\n-\n-\t  dep_type = REG_NOTE_KIND (link);\n-\t  PUT_REG_NOTE_KIND (new_link, dep_type);\n-\n-\t  INSN_DEPEND (x) = new_link;\n-\t  INSN_DEP_COUNT (insn) += 1;\n-\t}\n+\tadd_forward_dependence (XEXP (link, 0), insn, REG_NOTE_KIND (link));\n     }\n }\n \f"}, {"sha": "3d25d80da374130e821702602af1accb580b71d5", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "patch": "@@ -56,6 +56,9 @@ static const char *ebb_print_insn PARAMS ((rtx, int));\n static int rank PARAMS ((rtx, rtx));\n static int contributes_to_priority PARAMS ((rtx, rtx));\n static void compute_jump_reg_dependencies PARAMS ((rtx, regset));\n+static basic_block earliest_block_with_similiar_load PARAMS ((basic_block,\n+\t\t\t\t\t\t\t      rtx));\n+static void add_deps_for_risky_insns PARAMS ((rtx, rtx));\n static basic_block schedule_ebb PARAMS ((rtx, rtx));\n static basic_block fix_basic_block_boundaries PARAMS ((basic_block, basic_block, rtx, rtx));\n static void add_missing_bbs PARAMS ((rtx, basic_block, basic_block));\n@@ -339,6 +342,137 @@ fix_basic_block_boundaries (bb, last, head, tail)\n   return bb->prev_bb;\n }\n \n+/* Returns the earliest block in EBB currently being processed where a\n+   \"similar load\" 'insn2' is found, and hence LOAD_INSN can move\n+   speculatively into the found block.  All the following must hold:\n+\n+   (1) both loads have 1 base register (PFREE_CANDIDATEs).\n+   (2) load_insn and load2 have a def-use dependence upon\n+   the same insn 'insn1'.\n+\n+   From all these we can conclude that the two loads access memory\n+   addresses that differ at most by a constant, and hence if moving\n+   load_insn would cause an exception, it would have been caused by\n+   load2 anyhow.\n+\n+   The function uses list (given by LAST_BLOCK) of already processed\n+   blocks in EBB.  The list is formed in `add_deps_for_risky_insns'.  */\n+\n+static basic_block\n+earliest_block_with_similiar_load (last_block, load_insn)\n+     basic_block last_block;\n+     rtx load_insn;\n+{\n+  rtx back_link;\n+  basic_block bb, earliest_block = NULL;\n+\n+  for (back_link = LOG_LINKS (load_insn);\n+       back_link;\n+       back_link = XEXP (back_link, 1))\n+    {\n+      rtx insn1 = XEXP (back_link, 0);\n+\n+      if (GET_MODE (back_link) == VOIDmode)\n+\t{\n+\t  /* Found a DEF-USE dependence (insn1, load_insn).  */\n+\t  rtx fore_link;\n+\n+\t  for (fore_link = INSN_DEPEND (insn1);\n+\t       fore_link;\n+\t       fore_link = XEXP (fore_link, 1))\n+\t    {\n+\t      rtx insn2 = XEXP (fore_link, 0);\n+\t      basic_block insn2_block = BLOCK_FOR_INSN (insn2);\n+\n+\t      if (GET_MODE (fore_link) == VOIDmode)\n+\t\t{\n+\t\t  if (earliest_block != NULL\n+\t\t      && earliest_block->index < insn2_block->index)\n+\t\t    continue;\n+\n+\t\t  /* Found a DEF-USE dependence (insn1, insn2).  */\n+\t\t  if (haifa_classify_insn (insn2) != PFREE_CANDIDATE)\n+\t\t    /* insn2 not guaranteed to be a 1 base reg load.  */\n+\t\t    continue;\n+\t\t  \n+\t\t  for (bb = last_block; bb; bb = bb->aux)\n+\t\t    if (insn2_block == bb)\n+\t\t      break;\n+\n+\t\t  if (!bb)\n+\t\t    /* insn2 is the similar load.  */\n+\t\t    earliest_block = insn2_block;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return earliest_block;\n+}\n+\n+/* The following function adds dependecies between jumps and risky\n+   insns in given ebb.  */\n+\n+static void\n+add_deps_for_risky_insns (head, tail)\n+     rtx head, tail;\n+{\n+  rtx insn, prev;\n+  int class;\n+  rtx last_jump = NULL_RTX;\n+  rtx next_tail = NEXT_INSN (tail);\n+  basic_block last_block = NULL, bb;\n+  \n+  for (insn = head; insn != next_tail; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == JUMP_INSN)\n+      {\n+\tbb = BLOCK_FOR_INSN (insn);\n+\tbb->aux = last_block;\n+\tlast_block = bb;\n+\tlast_jump = insn;\n+      }\n+    else if (INSN_P (insn) && last_jump != NULL_RTX)\n+      {\n+\tclass = haifa_classify_insn (insn);\n+\tprev = last_jump;\n+\tswitch (class)\n+\t  {\n+\t  case PFREE_CANDIDATE:\n+\t    if (flag_schedule_speculative_load)\n+\t      {\n+\t\tbb = earliest_block_with_similiar_load (last_block, insn);\n+\t\tif (bb)\n+\t\t  bb = bb->aux;\n+\t\tif (!bb)\n+\t\t  break;\n+\t\tprev = bb->end;\n+\t      }\n+\t    /* FALLTHRU */\n+\t  case TRAP_RISKY:\n+\t  case IRISKY:\n+\t  case PRISKY_CANDIDATE:\n+\t    /* ??? We could implement better checking PRISKY_CANDIATEs\n+\t       analogous to sched-rgn.c.  */\n+\t    /* We can not change the mode of the backward\n+\t       dependency because REG_DEP_ANTI has the lowest\n+\t       rank.  */\n+\t    if (add_dependence (insn, prev, REG_DEP_ANTI))\n+\t      add_forward_dependence (prev, insn, REG_DEP_ANTI);\n+            break;\n+\t    \n+          default:\n+            break;\n+\t  }\n+      }\n+  /* Maintain the invariant that bb->aux is clear after use.  */\n+  while (last_block)\n+    {\n+      bb = last_block->aux;\n+      last_block->aux = NULL;\n+      last_block = bb;\n+    }\n+}\n+\n /* Schedule a single extended basic block, defined by the boundaries HEAD\n    and TAIL.  */\n \n@@ -365,6 +499,8 @@ schedule_ebb (head, tail)\n   /* Compute INSN_DEPEND.  */\n   compute_forward_dependences (head, tail);\n \n+  add_deps_for_risky_insns (head, tail);\n+\n   if (targetm.sched.dependencies_evaluation_hook)\n     targetm.sched.dependencies_evaluation_hook (head, tail);\n "}, {"sha": "2041a2f5e3910dbf50544a6a93cc5d1b93bb2140", "filename": "gcc/sched-int.h", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "patch": "@@ -258,6 +258,76 @@ extern struct haifa_insn_data *h_i_d;\n extern FILE *sched_dump;\n extern int sched_verbose;\n \n+/* Exception Free Loads:\n+\n+   We define five classes of speculative loads: IFREE, IRISKY,\n+   PFREE, PRISKY, and MFREE.\n+\n+   IFREE loads are loads that are proved to be exception-free, just\n+   by examining the load insn.  Examples for such loads are loads\n+   from TOC and loads of global data.\n+\n+   IRISKY loads are loads that are proved to be exception-risky,\n+   just by examining the load insn.  Examples for such loads are\n+   volatile loads and loads from shared memory.\n+\n+   PFREE loads are loads for which we can prove, by examining other\n+   insns, that they are exception-free.  Currently, this class consists\n+   of loads for which we are able to find a \"similar load\", either in\n+   the target block, or, if only one split-block exists, in that split\n+   block.  Load2 is similar to load1 if both have same single base\n+   register.  We identify only part of the similar loads, by finding\n+   an insn upon which both load1 and load2 have a DEF-USE dependence.\n+\n+   PRISKY loads are loads for which we can prove, by examining other\n+   insns, that they are exception-risky.  Currently we have two proofs for\n+   such loads.  The first proof detects loads that are probably guarded by a\n+   test on the memory address.  This proof is based on the\n+   backward and forward data dependence information for the region.\n+   Let load-insn be the examined load.\n+   Load-insn is PRISKY iff ALL the following hold:\n+\n+   - insn1 is not in the same block as load-insn\n+   - there is a DEF-USE dependence chain (insn1, ..., load-insn)\n+   - test-insn is either a compare or a branch, not in the same block\n+     as load-insn\n+   - load-insn is reachable from test-insn\n+   - there is a DEF-USE dependence chain (insn1, ..., test-insn)\n+\n+   This proof might fail when the compare and the load are fed\n+   by an insn not in the region.  To solve this, we will add to this\n+   group all loads that have no input DEF-USE dependence.\n+\n+   The second proof detects loads that are directly or indirectly\n+   fed by a speculative load.  This proof is affected by the\n+   scheduling process.  We will use the flag  fed_by_spec_load.\n+   Initially, all insns have this flag reset.  After a speculative\n+   motion of an insn, if insn is either a load, or marked as\n+   fed_by_spec_load, we will also mark as fed_by_spec_load every\n+   insn1 for which a DEF-USE dependence (insn, insn1) exists.  A\n+   load which is fed_by_spec_load is also PRISKY.\n+\n+   MFREE (maybe-free) loads are all the remaining loads. They may be\n+   exception-free, but we cannot prove it.\n+\n+   Now, all loads in IFREE and PFREE classes are considered\n+   exception-free, while all loads in IRISKY and PRISKY classes are\n+   considered exception-risky.  As for loads in the MFREE class,\n+   these are considered either exception-free or exception-risky,\n+   depending on whether we are pessimistic or optimistic.  We have\n+   to take the pessimistic approach to assure the safety of\n+   speculative scheduling, but we can take the optimistic approach\n+   by invoking the -fsched_spec_load_dangerous option.  */\n+\n+enum INSN_TRAP_CLASS\n+{\n+  TRAP_FREE = 0, IFREE = 1, PFREE_CANDIDATE = 2,\n+  PRISKY_CANDIDATE = 3, IRISKY = 4, TRAP_RISKY = 5\n+};\n+\n+#define WORST_CLASS(class1, class2) \\\n+((class1 > class2) ? class1 : class2)\n+\n #ifndef __GNUC__\n #define __inline\n #endif\n@@ -278,20 +348,22 @@ extern void visualize_alloc PARAMS ((void));\n extern void visualize_free PARAMS ((void));\n \n /* Functions in sched-deps.c.  */\n-extern void add_dependence PARAMS ((rtx, rtx, enum reg_note));\n+extern int add_dependence PARAMS ((rtx, rtx, enum reg_note));\n extern void add_insn_mem_dependence PARAMS ((struct deps *, rtx *, rtx *, rtx,\n \t\t\t\t\t     rtx));\n extern void sched_analyze PARAMS ((struct deps *, rtx, rtx));\n extern void init_deps PARAMS ((struct deps *));\n extern void free_deps PARAMS ((struct deps *));\n extern void init_deps_global PARAMS ((void));\n extern void finish_deps_global PARAMS ((void));\n+extern void add_forward_dependence PARAMS ((rtx, rtx, enum reg_note));\n extern void compute_forward_dependences PARAMS ((rtx, rtx));\n extern rtx find_insn_list PARAMS ((rtx, rtx));\n extern void init_dependency_caches PARAMS ((int));\n extern void free_dependency_caches PARAMS ((void));\n \n /* Functions in haifa-sched.c.  */\n+extern int haifa_classify_insn PARAMS ((rtx));\n extern void get_block_head_tail PARAMS ((int, rtx *, rtx *));\n extern int no_real_insns_p PARAMS ((rtx, rtx));\n "}, {"sha": "c7e7f808ee93f284885e02aa152118000fb39016", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 0, "deletions": 234, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aab9c0ac767b5c1c81757073b8cc3ac13c67fb/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=15aab9c0ac767b5c1c81757073b8cc3ac13c67fb", "patch": "@@ -288,8 +288,6 @@ static void set_spec_fed PARAMS ((rtx));\n static int is_pfree PARAMS ((rtx, int, int));\n static int find_conditional_protection PARAMS ((rtx, int));\n static int is_conditionally_protected PARAMS ((rtx, int, int));\n-static int may_trap_exp PARAMS ((rtx, int));\n-static int haifa_classify_insn PARAMS ((rtx));\n static int is_prisky PARAMS ((rtx, int, int));\n static int is_exception_free PARAMS ((rtx, int, int));\n \n@@ -1490,91 +1488,13 @@ update_live (insn, src)\n     }\n }\n \n-/* Exception Free Loads:\n-\n-   We define five classes of speculative loads: IFREE, IRISKY,\n-   PFREE, PRISKY, and MFREE.\n-\n-   IFREE loads are loads that are proved to be exception-free, just\n-   by examining the load insn.  Examples for such loads are loads\n-   from TOC and loads of global data.\n-\n-   IRISKY loads are loads that are proved to be exception-risky,\n-   just by examining the load insn.  Examples for such loads are\n-   volatile loads and loads from shared memory.\n-\n-   PFREE loads are loads for which we can prove, by examining other\n-   insns, that they are exception-free.  Currently, this class consists\n-   of loads for which we are able to find a \"similar load\", either in\n-   the target block, or, if only one split-block exists, in that split\n-   block.  Load2 is similar to load1 if both have same single base\n-   register.  We identify only part of the similar loads, by finding\n-   an insn upon which both load1 and load2 have a DEF-USE dependence.\n-\n-   PRISKY loads are loads for which we can prove, by examining other\n-   insns, that they are exception-risky.  Currently we have two proofs for\n-   such loads.  The first proof detects loads that are probably guarded by a\n-   test on the memory address.  This proof is based on the\n-   backward and forward data dependence information for the region.\n-   Let load-insn be the examined load.\n-   Load-insn is PRISKY iff ALL the following hold:\n-\n-   - insn1 is not in the same block as load-insn\n-   - there is a DEF-USE dependence chain (insn1, ..., load-insn)\n-   - test-insn is either a compare or a branch, not in the same block\n-     as load-insn\n-   - load-insn is reachable from test-insn\n-   - there is a DEF-USE dependence chain (insn1, ..., test-insn)\n-\n-   This proof might fail when the compare and the load are fed\n-   by an insn not in the region.  To solve this, we will add to this\n-   group all loads that have no input DEF-USE dependence.\n-\n-   The second proof detects loads that are directly or indirectly\n-   fed by a speculative load.  This proof is affected by the\n-   scheduling process.  We will use the flag  fed_by_spec_load.\n-   Initially, all insns have this flag reset.  After a speculative\n-   motion of an insn, if insn is either a load, or marked as\n-   fed_by_spec_load, we will also mark as fed_by_spec_load every\n-   insn1 for which a DEF-USE dependence (insn, insn1) exists.  A\n-   load which is fed_by_spec_load is also PRISKY.\n-\n-   MFREE (maybe-free) loads are all the remaining loads. They may be\n-   exception-free, but we cannot prove it.\n-\n-   Now, all loads in IFREE and PFREE classes are considered\n-   exception-free, while all loads in IRISKY and PRISKY classes are\n-   considered exception-risky.  As for loads in the MFREE class,\n-   these are considered either exception-free or exception-risky,\n-   depending on whether we are pessimistic or optimistic.  We have\n-   to take the pessimistic approach to assure the safety of\n-   speculative scheduling, but we can take the optimistic approach\n-   by invoking the -fsched_spec_load_dangerous option.  */\n-\n-enum INSN_TRAP_CLASS\n-{\n-  TRAP_FREE = 0, IFREE = 1, PFREE_CANDIDATE = 2,\n-  PRISKY_CANDIDATE = 3, IRISKY = 4, TRAP_RISKY = 5\n-};\n-\n-#define WORST_CLASS(class1, class2) \\\n-((class1 > class2) ? class1 : class2)\n-\n /* Nonzero if block bb_to is equal to, or reachable from block bb_from.  */\n #define IS_REACHABLE(bb_from, bb_to)\t\t\t\t\t\\\n   (bb_from == bb_to\t\t\t\t\t\t\t\\\n    || IS_RGN_ENTRY (bb_from)\t\t\t\t\t\t\\\n    || (TEST_BIT (ancestor_edges[bb_to],\t\t\t\t\t\\\n \t\t EDGE_TO_BIT (IN_EDGES (BB_TO_BLOCK (bb_from))))))\n \n-/* Nonzero iff the address is comprised from at most 1 register.  */\n-#define CONST_BASED_ADDRESS_P(x)\t\t\t\\\n-  (GET_CODE (x) == REG\t\t\t\t\t\\\n-   || ((GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\t\\\n-\t|| (GET_CODE (x) == LO_SUM))\t\t\t\\\n-       && (CONSTANT_P (XEXP (x, 0))\t\t\t\\\n-\t   || CONSTANT_P (XEXP (x, 1)))))\n-\n /* Turns on the fed_by_spec_load flag for insns fed by load_insn.  */\n \n static void\n@@ -1729,160 +1649,6 @@ is_pfree (load_insn, bb_src, bb_trg)\n   return 0;\n }\t\t\t\t/* is_pfree */\n \n-/* Returns a class that insn with GET_DEST(insn)=x may belong to,\n-   as found by analyzing insn's expression.  */\n-\n-static int\n-may_trap_exp (x, is_store)\n-     rtx x;\n-     int is_store;\n-{\n-  enum rtx_code code;\n-\n-  if (x == 0)\n-    return TRAP_FREE;\n-  code = GET_CODE (x);\n-  if (is_store)\n-    {\n-      if (code == MEM && may_trap_p (x))\n-\treturn TRAP_RISKY;\n-      else\n-\treturn TRAP_FREE;\n-    }\n-  if (code == MEM)\n-    {\n-      /* The insn uses memory:  a volatile load.  */\n-      if (MEM_VOLATILE_P (x))\n-\treturn IRISKY;\n-      /* An exception-free load.  */\n-      if (!may_trap_p (x))\n-\treturn IFREE;\n-      /* A load with 1 base register, to be further checked.  */\n-      if (CONST_BASED_ADDRESS_P (XEXP (x, 0)))\n-\treturn PFREE_CANDIDATE;\n-      /* No info on the load, to be further checked.  */\n-      return PRISKY_CANDIDATE;\n-    }\n-  else\n-    {\n-      const char *fmt;\n-      int i, insn_class = TRAP_FREE;\n-\n-      /* Neither store nor load, check if it may cause a trap.  */\n-      if (may_trap_p (x))\n-\treturn TRAP_RISKY;\n-      /* Recursive step: walk the insn...  */\n-      fmt = GET_RTX_FORMAT (code);\n-      for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-\t{\n-\t  if (fmt[i] == 'e')\n-\t    {\n-\t      int tmp_class = may_trap_exp (XEXP (x, i), is_store);\n-\t      insn_class = WORST_CLASS (insn_class, tmp_class);\n-\t    }\n-\t  else if (fmt[i] == 'E')\n-\t    {\n-\t      int j;\n-\t      for (j = 0; j < XVECLEN (x, i); j++)\n-\t\t{\n-\t\t  int tmp_class = may_trap_exp (XVECEXP (x, i, j), is_store);\n-\t\t  insn_class = WORST_CLASS (insn_class, tmp_class);\n-\t\t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)\n-\t\t    break;\n-\t\t}\n-\t    }\n-\t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)\n-\t    break;\n-\t}\n-      return insn_class;\n-    }\n-}\n-\n-/* Classifies insn for the purpose of verifying that it can be\n-   moved speculatively, by examining it's patterns, returning:\n-   TRAP_RISKY: store, or risky non-load insn (e.g. division by variable).\n-   TRAP_FREE: non-load insn.\n-   IFREE: load from a globaly safe location.\n-   IRISKY: volatile load.\n-   PFREE_CANDIDATE, PRISKY_CANDIDATE: load that need to be checked for\n-   being either PFREE or PRISKY.  */\n-\n-static int\n-haifa_classify_insn (insn)\n-     rtx insn;\n-{\n-  rtx pat = PATTERN (insn);\n-  int tmp_class = TRAP_FREE;\n-  int insn_class = TRAP_FREE;\n-  enum rtx_code code;\n-\n-  if (GET_CODE (pat) == PARALLEL)\n-    {\n-      int i, len = XVECLEN (pat, 0);\n-\n-      for (i = len - 1; i >= 0; i--)\n-\t{\n-\t  code = GET_CODE (XVECEXP (pat, 0, i));\n-\t  switch (code)\n-\t    {\n-\t    case CLOBBER:\n-\t      /* Test if it is a 'store'.  */\n-\t      tmp_class = may_trap_exp (XEXP (XVECEXP (pat, 0, i), 0), 1);\n-\t      break;\n-\t    case SET:\n-\t      /* Test if it is a store.  */\n-\t      tmp_class = may_trap_exp (SET_DEST (XVECEXP (pat, 0, i)), 1);\n-\t      if (tmp_class == TRAP_RISKY)\n-\t\tbreak;\n-\t      /* Test if it is a load.  */\n-\t      tmp_class\n-\t\t= WORST_CLASS (tmp_class,\n-\t\t\t       may_trap_exp (SET_SRC (XVECEXP (pat, 0, i)),\n-\t\t\t\t\t     0));\n-\t      break;\n-\t    case COND_EXEC:\n-\t    case TRAP_IF:\n-\t      tmp_class = TRAP_RISKY;\n-\t      break;\n-\t    default:\n-\t      ;\n-\t    }\n-\t  insn_class = WORST_CLASS (insn_class, tmp_class);\n-\t  if (insn_class == TRAP_RISKY || insn_class == IRISKY)\n-\t    break;\n-\t}\n-    }\n-  else\n-    {\n-      code = GET_CODE (pat);\n-      switch (code)\n-\t{\n-\tcase CLOBBER:\n-\t  /* Test if it is a 'store'.  */\n-\t  tmp_class = may_trap_exp (XEXP (pat, 0), 1);\n-\t  break;\n-\tcase SET:\n-\t  /* Test if it is a store.  */\n-\t  tmp_class = may_trap_exp (SET_DEST (pat), 1);\n-\t  if (tmp_class == TRAP_RISKY)\n-\t    break;\n-\t  /* Test if it is a load.  */\n-\t  tmp_class =\n-\t    WORST_CLASS (tmp_class,\n-\t\t\t may_trap_exp (SET_SRC (pat), 0));\n-\t  break;\n-\tcase COND_EXEC:\n-\tcase TRAP_IF:\n-\t  tmp_class = TRAP_RISKY;\n-\t  break;\n-\tdefault:;\n-\t}\n-      insn_class = tmp_class;\n-    }\n-\n-  return insn_class;\n-}\n-\n /* Return 1 if load_insn is prisky (i.e. if load_insn is fed by\n    a load moved speculatively, or if load_insn is protected by\n    a compare on load_insn's address).  */"}]}