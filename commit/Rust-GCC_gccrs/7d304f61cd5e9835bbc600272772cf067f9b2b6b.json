{"sha": "7d304f61cd5e9835bbc600272772cf067f9b2b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzMDRmNjFjZDVlOTgzNWJiYzYwMDI3Mjc3MmNmMDY3ZjliMmI2Yg==", "commit": {"author": {"name": "Emmanuel Briot", "email": "briot@adacore.com", "date": "2007-12-13T10:27:07Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:27:07Z"}, "message": "g-calend.ads (No_Time): New constant, to represent an uninitialized time value\n\n2007-12-06  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-calend.ads (No_Time): New constant, to represent an uninitialized\n\ttime value\n\n\t* g-catiio.ads, g-catiio.adb (Value): Added support for more date\n\tformats.\n\t(Month_Name_To_Number): New subprogram\n\n\t* g-dirope.adb (Get_Current_Dir): On windows, normalize the drive\n\tletter to upper-case.\n\nFrom-SVN: r130839", "tree": {"sha": "59b00f6ec5dd4e255a6400d076e3b74290c96d52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59b00f6ec5dd4e255a6400d076e3b74290c96d52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d304f61cd5e9835bbc600272772cf067f9b2b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d304f61cd5e9835bbc600272772cf067f9b2b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d304f61cd5e9835bbc600272772cf067f9b2b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d304f61cd5e9835bbc600272772cf067f9b2b6b/comments", "author": {"login": "briot", "id": 42402, "node_id": "MDQ6VXNlcjQyNDAy", "avatar_url": "https://avatars.githubusercontent.com/u/42402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/briot", "html_url": "https://github.com/briot", "followers_url": "https://api.github.com/users/briot/followers", "following_url": "https://api.github.com/users/briot/following{/other_user}", "gists_url": "https://api.github.com/users/briot/gists{/gist_id}", "starred_url": "https://api.github.com/users/briot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/briot/subscriptions", "organizations_url": "https://api.github.com/users/briot/orgs", "repos_url": "https://api.github.com/users/briot/repos", "events_url": "https://api.github.com/users/briot/events{/privacy}", "received_events_url": "https://api.github.com/users/briot/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "36fcf362ce30d24b353f5ece90fb8d760af8626c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36fcf362ce30d24b353f5ece90fb8d760af8626c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36fcf362ce30d24b353f5ece90fb8d760af8626c"}], "stats": {"total": 335, "additions": 248, "deletions": 87}, "files": [{"sha": "e3cc79139c84fc442513a5a73a7837b8938061f6", "filename": "gcc/ada/g-calend.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-calend.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-calend.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-calend.ads?ref=7d304f61cd5e9835bbc600272772cf067f9b2b6b", "patch": "@@ -56,6 +56,10 @@ package GNAT.Calendar is\n    subtype Day_In_Year_Number  is Positive range 1 .. 366;\n    subtype Week_In_Year_Number is Positive range 1 .. 53;\n \n+   No_Time : constant Ada.Calendar.Time;\n+   --  A constant set to the first date that can be represented by the type\n+   --  Time. It can be used to indicate an uninitialized date.\n+\n    function Hour       (Date : Ada.Calendar.Time) return Hour_Number;\n    function Minute     (Date : Ada.Calendar.Time) return Minute_Number;\n    function Second     (Date : Ada.Calendar.Time) return Second_Number;\n@@ -131,4 +135,10 @@ private\n    --  the Collected Algorithms of the ACM. The author of algorithm 199 is\n    --  Robert G. Tantzen.\n \n+   No_Time : constant Ada.Calendar.Time :=\n+               Ada.Calendar.Time_Of\n+                 (Ada.Calendar.Year_Number'First,\n+                  Ada.Calendar.Month_Number'First,\n+                  Ada.Calendar.Day_Number'First);\n+\n end GNAT.Calendar;"}, {"sha": "3a6bc39839140d0409100669525dcbaffcd79764", "filename": "gcc/ada/g-catiio.adb", "status": "modified", "additions": 208, "deletions": 81, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-catiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-catiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.adb?ref=7d304f61cd5e9835bbc600272772cf067f9b2b6b", "patch": "@@ -36,6 +36,8 @@ with Ada.Characters.Handling;\n with Ada.Strings.Unbounded;   use Ada.Strings.Unbounded;\n with Ada.Text_IO;\n \n+with GNAT.Case_Util;\n+\n package body GNAT.Calendar.Time_IO is\n \n    type Month_Name is\n@@ -52,6 +54,12 @@ package body GNAT.Calendar.Time_IO is\n       November,\n       December);\n \n+   function Month_Name_To_Number\n+     (Str : String) return Ada.Calendar.Month_Number;\n+   --  Converts a string that contains an abbreviated month name to a month\n+   --  number. Constraint_Error is raised if Str is not a valid month name.\n+   --  Comparison is case insensitive\n+\n    type Padding_Mode is (None, Zero, Space);\n \n    type Sec_Number is mod 2 ** 64;\n@@ -168,6 +176,8 @@ package body GNAT.Calendar.Time_IO is\n          end case;\n       end Pad_Char;\n \n+      --  Local Declarations\n+\n       NI  : constant String := Sec_Number'Image (N);\n       NIP : constant String := Pad_Char & NI (2 .. NI'Last);\n \n@@ -514,12 +524,40 @@ package body GNAT.Calendar.Time_IO is\n       return To_String (Result);\n    end Image;\n \n+   --------------------------\n+   -- Month_Name_To_Number --\n+   --------------------------\n+\n+   function Month_Name_To_Number\n+     (Str : String) return Ada.Calendar.Month_Number\n+   is\n+      subtype String3 is String (1 .. 3);\n+      Abbrev_Upper_Month_Names :\n+        constant array (Ada.Calendar.Month_Number) of String3 :=\n+         (\"JAN\", \"FEB\", \"MAR\", \"APR\", \"MAY\", \"JUN\",\n+          \"JUL\", \"AUG\", \"SEP\", \"OCT\", \"NOV\", \"DEC\");\n+      --  Short version of the month names, used when parsing date strings.\n+\n+      S                                                     : String := Str;\n+\n+   begin\n+      GNAT.Case_Util.To_Upper (S);\n+\n+      for J in Abbrev_Upper_Month_Names'Range loop\n+         if Abbrev_Upper_Month_Names (J) = S then\n+            return J;\n+         end if;\n+      end loop;\n+\n+      return Abbrev_Upper_Month_Names'First;\n+   end Month_Name_To_Number;\n+\n    -----------\n    -- Value --\n    -----------\n \n    function Value (Date : String) return Ada.Calendar.Time is\n-      D          : String (1 .. 19);\n+      D          : String (1 .. 21);\n       D_Length   : constant Natural := Date'Length;\n \n       Year       : Year_Number;\n@@ -531,13 +569,12 @@ package body GNAT.Calendar.Time_IO is\n       Sub_Second : Second_Duration;\n \n       procedure Extract_Date\n-        (Year  : out Year_Number;\n-         Month : out Month_Number;\n-         Day   : out Day_Number;\n-         Y2K   : Boolean := False);\n-      --  Try and extract a date value from string D. Set Y2K to True to\n-      --  account for the 20YY case. Raise Constraint_Error if the portion\n-      --  of D corresponding to the date is not well formatted.\n+        (Year       : out Year_Number;\n+         Month      : out Month_Number;\n+         Day        : out Day_Number;\n+         Time_Start : out Natural);\n+      --  Try and extract a date value from string D. Time_Start is set to the\n+      --  first character that could be the start of time data.\n \n       procedure Extract_Time\n         (Index       : Positive;\n@@ -555,33 +592,133 @@ package body GNAT.Calendar.Time_IO is\n       ------------------\n \n       procedure Extract_Date\n-        (Year  : out Year_Number;\n-         Month : out Month_Number;\n-         Day   : out Day_Number;\n-         Y2K   : Boolean := False)\n+        (Year       : out Year_Number;\n+         Month      : out Month_Number;\n+         Day        : out Day_Number;\n+         Time_Start : out Natural)\n       is\n-         Delim_Index : Positive := 5;\n-\n       begin\n-         if Y2K then\n-            Delim_Index := 3;\n-         end if;\n+         if D (3) = '-' or else D (3) = '/' then\n+            if D_Length = 8 or else D_Length = 17 then\n \n-         if (D (Delim_Index) /= '-' or else D (Delim_Index + 3) /= '-')\n-           and then\n-            (D (Delim_Index) /= '/' or else D (Delim_Index + 3) /= '/')\n-         then\n-            raise Constraint_Error;\n-         end if;\n+               --  Formats are \"yy*mm*dd\" or \"yy*mm*dd hh:mm:ss\"\n+\n+               if D (6) /= D (3) then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value (\"20\" & D (1 .. 2));\n+               Month := Month_Number'Value       (D (4 .. 5));\n+               Day   := Day_Number'Value         (D (7 .. 8));\n+               Time_Start := 10;\n+\n+            elsif D_Length = 10 or else D_Length = 19 then\n+\n+               --  Formats are \"mm*dd*yyyy\" or \"mm*dd*yyyy hh:mm:ss\"\n+\n+               if D (6) /= D (3) then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value  (D (7 .. 10));\n+               Month := Month_Number'Value (D (1 .. 2));\n+               Day   := Day_Number'Value   (D (4 .. 5));\n+               Time_Start := 12;\n+\n+            elsif D_Length = 11 or else D_Length = 20 then\n+\n+               --  Formats are \"dd*mmm*yyyy\" or \"dd*mmm*yyyy hh:mm:ss\"\n+\n+               if D (7) /= D (3) then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value  (D (8 .. 11));\n+               Month := Month_Name_To_Number (D (4 .. 6));\n+               Day   := Day_Number'Value   (D (1 .. 2));\n+               Time_Start := 13;\n+\n+            else\n+               raise Constraint_Error;\n+            end if;\n+\n+         elsif D (3) = ' ' then\n+            if D_Length = 11 or else D_Length = 20 then\n+\n+               --  Possible formats are \"dd mmm yyyy\", \"dd mmm yyyy hh:mm:ss\"\n+\n+               if D (7) /= ' ' then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value  (D (8 .. 11));\n+               Month := Month_Name_To_Number (D (4 .. 6));\n+               Day   := Day_Number'Value   (D (1 .. 2));\n+               Time_Start := 13;\n+\n+            else\n+               raise Constraint_Error;\n+            end if;\n \n-         if Y2K then\n-            Year  := Year_Number'Value (\"20\" & D (1 .. 2));\n-            Month := Month_Number'Value       (D (4 .. 5));\n-            Day   := Day_Number'Value         (D (7 .. 8));\n          else\n-            Year  := Year_Number'Value  (D (1 .. 4));\n-            Month := Month_Number'Value (D (6 .. 7));\n-            Day   := Day_Number'Value   (D (9 .. 10));\n+            if D_Length = 8 or else D_Length = 17 then\n+\n+               --  Possible formats are \"yyyymmdd\" or \"yyyymmdd hh:mm:ss\"\n+\n+               Year  := Year_Number'Value (D (1 .. 4));\n+               Month := Month_Number'Value (D (5 .. 6));\n+               Day   := Day_Number'Value (D (7 .. 8));\n+               Time_Start := 10;\n+\n+            elsif D_Length = 10 or else D_Length = 19 then\n+\n+               --  Possible formats are \"yyyy*mm*dd\" or \"yyyy*mm*dd hh:mm:ss\"\n+\n+               if (D (5) /= '-' and then D (5) /= '/')\n+                 or else D (8) /= D (5)\n+               then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value (D (1 .. 4));\n+               Month := Month_Number'Value (D (6 .. 7));\n+               Day   := Day_Number'Value (D (9 .. 10));\n+               Time_Start := 12;\n+\n+            elsif D_Length = 11 or else D_Length = 20 then\n+\n+               --  Possible formats are \"yyyy*mmm*dd\"\n+\n+               if (D (5) /= '-' and then D (5) /= '/')\n+                 or else D (9) /= D (5)\n+               then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value (D (1 .. 4));\n+               Month := Month_Name_To_Number (D (6 .. 8));\n+               Day   := Day_Number'Value (D (10 .. 11));\n+               Time_Start := 13;\n+\n+            elsif D_Length = 12 or else D_Length = 21 then\n+\n+               --  Formats are \"mmm dd, yyyy\" or \"mmm dd, yyyy hh:mm:ss\"\n+\n+               if D (4) /= ' '\n+                 or else D (7) /= ','\n+                 or else D (8) /= ' '\n+               then\n+                  raise Constraint_Error;\n+               end if;\n+\n+               Year  := Year_Number'Value (D (9 .. 12));\n+               Month := Month_Name_To_Number (D (1 .. 3));\n+               Day   := Day_Number'Value (D (5 .. 6));\n+               Time_Start := 14;\n+\n+            else\n+               raise Constraint_Error;\n+            end if;\n          end if;\n       end Extract_Date;\n \n@@ -594,22 +731,42 @@ package body GNAT.Calendar.Time_IO is\n          Hour        : out Hour_Number;\n          Minute      : out Minute_Number;\n          Second      : out Second_Number;\n-         Check_Space : Boolean := False) is\n-\n+         Check_Space : Boolean := False)\n+      is\n       begin\n-         if Check_Space and then D (Index - 1) /= ' ' then\n-            raise Constraint_Error;\n-         end if;\n+         --  If no time was specified in the string (do not allow trailing\n+         --  character either)\n \n-         if D (Index + 2) /= ':' or else D (Index + 5) /= ':' then\n-            raise Constraint_Error;\n-         end if;\n+         if Index = D_Length + 2 then\n+            Hour   := 0;\n+            Minute := 0;\n+            Second := 0;\n+\n+         else\n+            --  Not enough characters left ?\n+\n+            if Index /= D_Length - 7 then\n+               raise Constraint_Error;\n+            end if;\n \n-         Hour   := Hour_Number'Value   (D (Index     .. Index + 1));\n-         Minute := Minute_Number'Value (D (Index + 3 .. Index + 4));\n-         Second := Second_Number'Value (D (Index + 6 .. Index + 7));\n+            if Check_Space and then D (Index - 1) /= ' ' then\n+               raise Constraint_Error;\n+            end if;\n+\n+            if D (Index + 2) /= ':' or else D (Index + 5) /= ':' then\n+               raise Constraint_Error;\n+            end if;\n+\n+            Hour   := Hour_Number'Value   (D (Index     .. Index + 1));\n+            Minute := Minute_Number'Value (D (Index + 3 .. Index + 4));\n+            Second := Second_Number'Value (D (Index + 6 .. Index + 7));\n+         end if;\n       end Extract_Time;\n \n+      --  Local Declarations\n+\n+      Time_Start : Natural := 1;\n+\n    --  Start of processing for Value\n \n    begin\n@@ -620,8 +777,12 @@ package body GNAT.Calendar.Time_IO is\n \n       if D_Length /= 8\n         and then D_Length /= 10\n+        and then D_Length /= 11\n+        and then D_Length /= 12\n         and then D_Length /= 17\n         and then D_Length /= 19\n+        and then D_Length /= 20\n+        and then D_Length /= 21\n       then\n          raise Constraint_Error;\n       end if;\n@@ -631,47 +792,13 @@ package body GNAT.Calendar.Time_IO is\n \n       D (1 .. D_Length) := Date;\n \n-      --  Case 1:\n-\n-      --    hh:mm:ss\n-      --    yy*mm*dd\n-\n-      if D_Length = 8 then\n-\n-         if D (3) = ':' then\n-            Extract_Time (1, Hour, Minute, Second);\n-         else\n-            Extract_Date (Year, Month, Day, True);\n-            Hour   := 0;\n-            Minute := 0;\n-            Second := 0;\n-         end if;\n-\n-      --  Case 2:\n-\n-      --    yyyy*mm*dd\n-\n-      elsif D_Length = 10 then\n-         Extract_Date (Year, Month, Day);\n-         Hour   := 0;\n-         Minute := 0;\n-         Second := 0;\n-\n-      --  Case 3:\n-\n-      --    yy*mm*dd hh:mm:ss\n-\n-      elsif D_Length = 17 then\n-         Extract_Date (Year, Month, Day, True);\n-         Extract_Time (10, Hour, Minute, Second, True);\n-\n-      --  Case 4:\n-\n-      --    yyyy*mm*dd hh:mm:ss\n-\n+      if D_Length /= 8\n+        or else D (3) /= ':'\n+      then\n+         Extract_Date (Year, Month, Day, Time_Start);\n+         Extract_Time (Time_Start, Hour, Minute, Second, Check_Space => True);\n       else\n-         Extract_Date (Year, Month, Day);\n-         Extract_Time (12, Hour, Minute, Second, True);\n+         Extract_Time (1, Hour, Minute, Second, Check_Space => False);\n       end if;\n \n       --  Sanity checks"}, {"sha": "5c2cbf9834f1cd085620f2bbd469749f65b6feb9", "filename": "gcc/ada/g-catiio.ads", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-catiio.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-catiio.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-catiio.ads?ref=7d304f61cd5e9835bbc600272772cf067f9b2b6b", "patch": "@@ -118,15 +118,26 @@ package GNAT.Calendar.Time_IO is\n \n    function Value (Date : String) return Ada.Calendar.Time;\n    --  Parse the string Date and return its equivalent as a Time value. The\n-   --  following formats are supported:\n+   --  following time format is supported:\n    --\n-   --     yyyy*mm*dd hh:mm:ss  - Delimiter '*' is either '-' or '/'\n-   --     yyyy*mm*dd           - The time of day is set to 00:00:00\n+   --     hh:mm:ss             - Date is the current date\n    --\n-   --     yy*mm*dd hh:mm:ss    - Year is assumend to be 20YY\n-   --     yy*mm*dd             - The time of day is set to 00:00:00\n+   --  The following formats are also supported. They all accept an optional\n+   --  time with the format \"hh:mm:ss\". The time is separated from the date by\n+   --  exactly one space character.\n+   --  When the time is not specified, it is set to 00:00:00. The delimiter '*'\n+   --  must be either '-' and '/' and both occurrences must use the same\n+   --  character.\n+   --  Trailing characters (in particular spaces) are not allowed.\n    --\n-   --     hh:mm:ss             - Date is the current date\n+   --     yyyy*mm*dd\n+   --     yy*mm*dd             - Year is assumed to be 20yy\n+   --     mm*dd*yyyy           - (US date format)\n+   --     dd*mmm*yyyy          - month spelled out\n+   --     yyyy*mmm*dd          - month spelled out\n+   --     yyyymmdd             - Iso format, no separator\n+   --     mmm dd, yyyy         - month spelled out\n+   --     dd mmm yyyy          - month spelled out\n    --\n    --  Constraint_Error is raised if the input string is malformatted or\n    --  the resulting time is not valid."}, {"sha": "774444d08266356d4daac66963277a11435a3492", "filename": "gcc/ada/g-dirope.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-dirope.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d304f61cd5e9835bbc600272772cf067f9b2b6b/gcc%2Fada%2Fg-dirope.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-dirope.adb?ref=7d304f61cd5e9835bbc600272772cf067f9b2b6b", "patch": "@@ -56,6 +56,10 @@ package body GNAT.Directory_Operations is\n    procedure Free is new\n      Ada.Unchecked_Deallocation (Dir_Type_Value, Dir_Type);\n \n+   On_Windows : constant Boolean := GNAT.OS_Lib.Directory_Separator = '\\';\n+   --  An indication that we are on Windows. Used in Get_Current_Dir, to\n+   --  deal with drive letters in the beginning of absolute paths.\n+\n    ---------------\n    -- Base_Name --\n    ---------------\n@@ -591,6 +595,15 @@ package body GNAT.Directory_Operations is\n       end if;\n \n       Dir (Buffer'First .. Last) := Buffer (Buffer'First .. Last);\n+\n+      --  By default, the drive letter on Windows is in upper case\n+\n+      if On_Windows and then Last > Dir'First and then\n+        Dir (Dir'First + 1) = ':'\n+      then\n+         Dir (Dir'First) :=\n+           Ada.Characters.Handling.To_Upper (Dir (Dir'First));\n+      end if;\n    end Get_Current_Dir;\n \n    -------------"}]}