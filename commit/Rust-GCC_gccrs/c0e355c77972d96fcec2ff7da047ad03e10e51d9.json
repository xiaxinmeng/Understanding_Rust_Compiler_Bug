{"sha": "c0e355c77972d96fcec2ff7da047ad03e10e51d9", "node_id": "C_kwDOANBUbNoAKGMwZTM1NWM3Nzk3MmQ5NmZjZWMyZmY3ZGEwNDdhZDAzZTEwZTUxZDk", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-12T14:10:24Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-01-12T14:10:24Z"}, "message": "libstdc++: Avoid overflow in bounds checks [PR103955]\n\nWe currently crash when the floating-point to_chars overloads are passed\na precision value near INT_MAX, ultimately due to overflow in the bounds\nchecks that verify the output range is large enough.\n\nThe simplest portable fix seems to be to replace bounds checks of the form\nA >= B + C (where B + C may overflow) with the otherwise equivalent check\nA >= B && A - B >= C, which is the approach this patch takes.\n\nBefore we could do this in __floating_to_chars_hex, there we first need\nto track the unbounded \"excess\" precision (i.e. the number of trailing\nfractional digits in the output that are guaranteed to be '0') separately\nfrom the bounded \"effective\" precision (i.e. the number of significant\nfractional digits in the output), like we do in __f_t_c_precision.\n\n\tPR libstdc++/103955\n\nlibstdc++-v3/ChangeLog:\n\n\t* src/c++17/floating_to_chars.cc (__floating_to_chars_hex):\n\tTrack the excess precision separately from the effective\n\tprecision.  Avoid overflow in bounds check by splitting it into\n\ttwo checks.\n\t(__floating_to_chars_precision): Avoid overflow in bounds checks\n\tsimilarly.\n\t* testsuite/20_util/to_chars/103955.cc: New test.", "tree": {"sha": "a2b95a8b6186246bc2326919577b618f11f3e5ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2b95a8b6186246bc2326919577b618f11f3e5ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e355c77972d96fcec2ff7da047ad03e10e51d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e355c77972d96fcec2ff7da047ad03e10e51d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e355c77972d96fcec2ff7da047ad03e10e51d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e355c77972d96fcec2ff7da047ad03e10e51d9/comments", "author": null, "committer": null, "parents": [{"sha": "03a1a86b5ee40d4e2402516cbcdf39d981e433b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03a1a86b5ee40d4e2402516cbcdf39d981e433b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03a1a86b5ee40d4e2402516cbcdf39d981e433b3"}], "stats": {"total": 76, "additions": 63, "deletions": 13}, "files": [{"sha": "8da2f2385a01c81de1334073e1d5ba61f9fc6a7d", "filename": "libstdc++-v3/src/c++17/floating_to_chars.cc", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e355c77972d96fcec2ff7da047ad03e10e51d9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e355c77972d96fcec2ff7da047ad03e10e51d9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Ffloating_to_chars.cc?ref=c0e355c77972d96fcec2ff7da047ad03e10e51d9", "patch": "@@ -747,7 +747,8 @@ template<typename T>\n     __glibcxx_assert(shortest_full_precision >= 0);\n \n     int written_exponent = unbiased_exponent;\n-    const int effective_precision = precision.value_or(shortest_full_precision);\n+    int effective_precision = precision.value_or(shortest_full_precision);\n+    int excess_precision = 0;\n     if (effective_precision < shortest_full_precision)\n       {\n \t// When limiting the precision, we need to determine how to round the\n@@ -794,6 +795,11 @@ template<typename T>\n \t      }\n \t  }\n       }\n+    else\n+      {\n+\texcess_precision = effective_precision - shortest_full_precision;\n+\teffective_precision = shortest_full_precision;\n+      }\n \n     // Compute the leading hexit and mask it out from the mantissa.\n     char leading_hexit;\n@@ -816,26 +822,30 @@ template<typename T>\n     // Now before we start writing the string, determine the total length of\n     // the output string and perform a single bounds check.\n     int expected_output_length = sign + 1;\n-    if (effective_precision != 0)\n-      expected_output_length += strlen(\".\") + effective_precision;\n+    if (effective_precision + excess_precision > 0)\n+      expected_output_length += strlen(\".\");\n+    expected_output_length += effective_precision;\n     const int abs_written_exponent = abs(written_exponent);\n     expected_output_length += (abs_written_exponent >= 10000 ? strlen(\"p+ddddd\")\n \t\t\t       : abs_written_exponent >= 1000 ? strlen(\"p+dddd\")\n \t\t\t       : abs_written_exponent >= 100 ? strlen(\"p+ddd\")\n \t\t\t       : abs_written_exponent >= 10 ? strlen(\"p+dd\")\n \t\t\t       : strlen(\"p+d\"));\n-    if (last - first < expected_output_length)\n+    if (last - first < expected_output_length\n+\t|| last - first - expected_output_length < excess_precision)\n       return {last, errc::value_too_large};\n+    char* const expected_output_end = first + expected_output_length + excess_precision;\n \n-    const auto saved_first = first;\n     // Write the negative sign and the leading hexit.\n     if (sign)\n       *first++ = '-';\n     *first++ = leading_hexit;\n \n+    if (effective_precision + excess_precision > 0)\n+      *first++ = '.';\n+\n     if (effective_precision > 0)\n       {\n-\t*first++ = '.';\n \tint written_hexits = 0;\n \t// Extract and mask out the leading nibble after the decimal point,\n \t// write its corresponding hexit, and repeat until the mantissa is\n@@ -863,13 +873,18 @@ template<typename T>\n \t  }\n       }\n \n+    if (excess_precision > 0)\n+      {\n+\tmemset(first, '0', excess_precision);\n+\tfirst += excess_precision;\n+      }\n+\n     // Finally, write the exponent.\n     *first++ = 'p';\n     if (written_exponent >= 0)\n       *first++ = '+';\n     const to_chars_result result = to_chars(first, last, written_exponent);\n-    __glibcxx_assert(result.ec == errc{}\n-\t\t     && result.ptr == saved_first + expected_output_length);\n+    __glibcxx_assert(result.ec == errc{} && result.ptr == expected_output_end);\n     return result;\n   }\n \n@@ -1250,7 +1265,8 @@ template<typename T>\n \t    }\n \n \t// Copy the string from the buffer over to the output range.\n-\tif (last - first < output_length + excess_precision)\n+\tif (last - first < output_length\n+\t    || last - first - output_length < excess_precision)\n \t  return {last, errc::value_too_large};\n \tmemcpy(first, buffer, output_length);\n \tfirst += output_length;\n@@ -1304,7 +1320,8 @@ template<typename T>\n \t  output_length_upper_bound += strlen(\"e+dd\");\n \n \tint output_length;\n-\tif (last - first >= output_length_upper_bound + excess_precision)\n+\tif (last - first >= output_length_upper_bound\n+\t    && last - first - output_length_upper_bound >= excess_precision)\n \t  {\n \t    // The result will definitely fit into the output range, so we can\n \t    // write directly into it.\n@@ -1325,7 +1342,8 @@ template<typename T>\n \t\t\t\t\t\t  buffer, nullptr);\n \t    __glibcxx_assert(output_length == output_length_upper_bound - 1\n \t\t\t     || output_length == output_length_upper_bound);\n-\t    if (last - first < output_length + excess_precision)\n+\t    if (last - first < output_length\n+\t\t|| last - first - output_length < excess_precision)\n \t      return {last, errc::value_too_large};\n \t    memcpy(first, buffer, output_length);\n \t  }\n@@ -1365,7 +1383,8 @@ template<typename T>\n \t  output_length_upper_bound += strlen(\".\") + effective_precision;\n \n \tint output_length;\n-\tif (last - first >= output_length_upper_bound + excess_precision)\n+\tif (last - first >= output_length_upper_bound\n+\t    && last - first - output_length_upper_bound >= excess_precision)\n \t  {\n \t    // The result will definitely fit into the output range, so we can\n \t    // write directly into it.\n@@ -1382,7 +1401,8 @@ template<typename T>\n \t    output_length = ryu::d2fixed_buffered_n(value, effective_precision,\n \t\t\t\t\t\t    buffer);\n \t    __glibcxx_assert(output_length <= output_length_upper_bound);\n-\t    if (last - first < output_length + excess_precision)\n+\t    if (last - first < output_length\n+\t\t|| last - first - output_length < excess_precision)\n \t      return {last, errc::value_too_large};\n \t    memcpy(first, buffer, output_length);\n \t  }"}, {"sha": "3753c87ad8bd5bed0d596e31261412b2a45a70b1", "filename": "libstdc++-v3/testsuite/20_util/to_chars/103955.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e355c77972d96fcec2ff7da047ad03e10e51d9/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F103955.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e355c77972d96fcec2ff7da047ad03e10e51d9/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F103955.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fto_chars%2F103955.cc?ref=c0e355c77972d96fcec2ff7da047ad03e10e51d9", "patch": "@@ -0,0 +1,30 @@\n+// PR libstdc++/103955\n+// Verify we don't crash when the floating-point to_chars overloads are passed\n+// a large precision argument.\n+\n+#include <charconv>\n+\n+#include <climits>\n+#include <initializer_list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  const int size = 12;\n+  char result[size];\n+\n+  for (auto fmt : { std::chars_format::fixed, std::chars_format::scientific,\n+\t\t    std::chars_format::general, std::chars_format::hex })\n+    for (int precision : { INT_MAX, INT_MAX-1, INT_MAX-2 })\n+      {\n+\tauto tcr = std::to_chars(result, result+size, 1.337, fmt, precision);\n+\tVERIFY( tcr.ptr == result+size && tcr.ec == std::errc::value_too_large );\n+      }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}