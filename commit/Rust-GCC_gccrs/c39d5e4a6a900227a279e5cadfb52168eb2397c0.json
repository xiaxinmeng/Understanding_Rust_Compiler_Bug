{"sha": "c39d5e4a6a900227a279e5cadfb52168eb2397c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzM5ZDVlNGE2YTkwMDIyN2EyNzllNWNhZGZiNTIxNjhlYjIzOTdjMA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-05-21T19:00:45Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2015-05-21T19:00:45Z"}, "message": "re PR fortran/66176 (Handle conjg() in inline matmul)\n\n2015-05-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66176\n\t* frontend-passes.c (check_conjg_variable):  New function.\n\t(inline_matmul_assign):  Use it to keep track of conjugated\n\tvariables.\n\n2015-05-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66176\n\t* gfortran.dg/inline_matmul_11.f90:  New test\n\nFrom-SVN: r223499", "tree": {"sha": "8165d2c67bdadaf6dc6e36c47d9d54db67edfa7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8165d2c67bdadaf6dc6e36c47d9d54db67edfa7c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c39d5e4a6a900227a279e5cadfb52168eb2397c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c39d5e4a6a900227a279e5cadfb52168eb2397c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c39d5e4a6a900227a279e5cadfb52168eb2397c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c39d5e4a6a900227a279e5cadfb52168eb2397c0/comments", "author": null, "committer": null, "parents": [{"sha": "2aa3880198cbb4902d9757d32d61f8370325f707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2aa3880198cbb4902d9757d32d61f8370325f707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2aa3880198cbb4902d9757d32d61f8370325f707"}], "stats": {"total": 116, "additions": 104, "deletions": 12}, "files": [{"sha": "860f8f9160de6481bb211e934c8e14067a23eb57", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c39d5e4a6a900227a279e5cadfb52168eb2397c0", "patch": "@@ -1,3 +1,10 @@\n+2015-05-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66176\n+\t* frontend-passes.c (check_conjg_variable):  New function.\n+\t(inline_matmul_assign):  Use it to keep track of conjugated\n+\tvariables.\n+\n 2015-05-20  Andre Vehreschild  <vehre@gmx.de>\n \n \tPR fortran/65548"}, {"sha": "aeee73e048900ab6798888056358048128719b4d", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 59, "deletions": 12, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=c39d5e4a6a900227a279e5cadfb52168eb2397c0", "patch": "@@ -2700,6 +2700,45 @@ has_dimen_vector_ref (gfc_expr *e)\n   return false;\n }\n \n+/* If handed an expression of the form\n+\n+   CONJG(A)\n+\n+   check if A can be handled by matmul and return if there is an uneven number\n+   of CONJG calls.  Return a pointer to the array when everything is OK, NULL\n+   otherwise. The caller has to check for the correct rank.  */\n+\n+static gfc_expr*\n+check_conjg_variable (gfc_expr *e, bool *conjg)\n+{\n+  *conjg = false;\n+\n+  do\n+    {\n+      if (e->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  gcc_assert (e->rank == 1 || e->rank == 2);\n+\t  return e;\n+\t}\n+      else if (e->expr_type == EXPR_FUNCTION)\n+\t{\n+\t  if (e->value.function.isym == NULL)\n+\t    return NULL;\n+\n+\t  if (e->value.function.isym->id == GFC_ISYM_CONJG)\n+\t    *conjg = !*conjg;\n+\t  else return NULL;\n+\t}\n+      else\n+\treturn NULL;\n+\n+      e = e->value.function.actual->expr;\n+    }\n+  while(1);\n+\n+  return NULL;\n+}\n+\n /* Inline assignments of the form c = matmul(a,b).\n    Handle only the cases currently where b and c are rank-two arrays.\n \n@@ -2744,6 +2783,7 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   int i;\n   gfc_code *if_limit = NULL;\n   gfc_code **next_code_point;\n+  bool conjg_a, conjg_b;\n \n   if (co->op != EXEC_ASSIGN)\n     return 0;\n@@ -2760,30 +2800,29 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n   changed_statement = NULL;\n \n   a = expr2->value.function.actual;\n-  matrix_a = a->expr;\n-  b = a->next;\n-  matrix_b = b->expr;\n-\n-  /* Currently only handling direct variables.  Transpose etc. will come\n-     later.  */\n+  matrix_a = check_conjg_variable (a->expr, &conjg_a);\n+  if (matrix_a == NULL)\n+    return 0;\n \n-  if (matrix_a->expr_type != EXPR_VARIABLE\n-      || matrix_b->expr_type != EXPR_VARIABLE)\n+  b = a->next;\n+  matrix_b = check_conjg_variable (b->expr, &conjg_b);\n+  if (matrix_b == NULL)\n     return 0;\n \n   if (has_dimen_vector_ref (expr1) || has_dimen_vector_ref (matrix_a)\n       || has_dimen_vector_ref (matrix_b))\n     return 0;\n \n+  /* We do not handle data dependencies yet.  */\n+  if (gfc_check_dependency (expr1, matrix_a, true)\n+      || gfc_check_dependency (expr1, matrix_b, true))\n+    return 0;\n+\n   if (matrix_a->rank == 2)\n     m_case = matrix_b->rank == 1 ? A2B1 : A2B2;\n   else\n     m_case = A1B2;\n \n-  /* We do not handle data dependencies yet.  */\n-  if (gfc_check_dependency (expr1, matrix_a, true)\n-      || gfc_check_dependency (expr1, matrix_b, true))\n-    return 0;\n \n   ns = insert_block ();\n \n@@ -3056,6 +3095,14 @@ inline_matmul_assign (gfc_code **c, int *walk_subtrees,\n       gcc_unreachable();\n     }\n \n+  if (conjg_a)\n+    ascalar = gfc_build_intrinsic_call (ns, GFC_ISYM_CONJG, \"conjg\",\n+\t\t\t\t\tmatrix_a->where, 1, ascalar);\n+\n+  if (conjg_b)\n+    bscalar = gfc_build_intrinsic_call (ns, GFC_ISYM_CONJG, \"conjg\", \n+\t\t\t\t\tmatrix_b->where, 1, bscalar);\n+\n   /* First loop comes after the zero assignment.  */\n   assign_zero->next = do_1;\n "}, {"sha": "73a3e569210a523af4e7a9368d8be76a714927f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c39d5e4a6a900227a279e5cadfb52168eb2397c0", "patch": "@@ -1,3 +1,8 @@\n+2015-05-21  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66176\n+\t* gfortran.dg/inline_matmul_11.f90:  New test.\n+\n 2015-05-21  Andreas Tobler  <andreast@gcc.gnu.org>\n \n \t* gcc.target/i386/pr32219-1.c: Use 'dg-require-effective-target pie'"}, {"sha": "c3733bac4270987a583238a822b6af8924c672c2", "filename": "gcc/testsuite/gfortran.dg/inline_matmul_11.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c39d5e4a6a900227a279e5cadfb52168eb2397c0/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_matmul_11.f90?ref=c39d5e4a6a900227a279e5cadfb52168eb2397c0", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do  run }\n+! { dg-additional-options \"-ffrontend-optimize -fdump-tree-original\" }\n+! PR fortran/66176 - inline conjg for matml.\n+program main\n+  complex, dimension(3,2) :: a\n+  complex, dimension(2,4) :: b, b2\n+  complex, dimension(3,4) :: c,c2\n+  complex, dimension(3,4) :: res1, res2, res3\n+\n+  data a/(2.,-3.),(-5.,-7.),(11.,-13.),(-17.,-19.),(23.,-29.),(-31.,-37.) /\n+  data b/(41.,-43.),(-47.,-53.),(59.,-61.),(-67.,-71.),(73.,-79.),&\n+       & (-83.,-89.),(97.,-101.), (-103.,-107.)/\n+\n+  data res1 /  (-255.,1585.),(-3124.,72.),(-612.,2376.),(-275.,2181.), &\n+       & (-4322.,202.),(-694.,3242.),(-371.,2713.),( -5408.,244.),(-944.,4012.),&\n+       & (-391.,3283.),(-6664.,352.),(-1012.,4756.)/\n+\n+  data res2 / (2017.,-45.),(552.,2080.),(4428.,36.),(2789.,11.),(650.,2858.),&\n+       & (6146.,182.),(3485.,3.),(860.,3548.),(7696.,232.),(4281.,49.),&\n+       & (956.,4264.),(9532.,344.)/\n+\n+  c = matmul(a,b)\n+  if (any(res1 /= c)) call abort\n+  b2 = conjg(b)\n+  c = matmul(a,conjg(b2))\n+  if (any(res1 /= c)) call abort\n+  c = matmul(a,conjg(b))\n+  if (any(res2 /= c)) call abort\n+  c = matmul(conjg(a), b)\n+  if (any(conjg(c) /= res2)) call abort\n+end program main\n+! { dg-final { scan-tree-dump-times \"_gfortran_matmul\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}