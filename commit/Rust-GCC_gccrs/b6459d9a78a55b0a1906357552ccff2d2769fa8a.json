{"sha": "b6459d9a78a55b0a1906357552ccff2d2769fa8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY0NTlkOWE3OGE1NWIwYTE5MDYzNTc1NTJjY2ZmMmQyNzY5ZmE4YQ==", "commit": {"author": {"name": "Anthony Green", "email": "green@redhat.com", "date": "2002-02-09T00:50:05Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2002-02-09T00:50:05Z"}, "message": "xscale-elf support\n\nFrom-SVN: r49626", "tree": {"sha": "c68d180cfc2d82b626c6a1cf2c655d6cf7a53e32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c68d180cfc2d82b626c6a1cf2c655d6cf7a53e32"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6459d9a78a55b0a1906357552ccff2d2769fa8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6459d9a78a55b0a1906357552ccff2d2769fa8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6459d9a78a55b0a1906357552ccff2d2769fa8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6459d9a78a55b0a1906357552ccff2d2769fa8a/comments", "author": {"login": "atgreen", "id": 89993, "node_id": "MDQ6VXNlcjg5OTkz", "avatar_url": "https://avatars.githubusercontent.com/u/89993?v=4", "gravatar_id": "", "url": "https://api.github.com/users/atgreen", "html_url": "https://github.com/atgreen", "followers_url": "https://api.github.com/users/atgreen/followers", "following_url": "https://api.github.com/users/atgreen/following{/other_user}", "gists_url": "https://api.github.com/users/atgreen/gists{/gist_id}", "starred_url": "https://api.github.com/users/atgreen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/atgreen/subscriptions", "organizations_url": "https://api.github.com/users/atgreen/orgs", "repos_url": "https://api.github.com/users/atgreen/repos", "events_url": "https://api.github.com/users/atgreen/events{/privacy}", "received_events_url": "https://api.github.com/users/atgreen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85aa876c4b7cf8d07c36dccaded74ca02e546eca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85aa876c4b7cf8d07c36dccaded74ca02e546eca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85aa876c4b7cf8d07c36dccaded74ca02e546eca"}], "stats": {"total": 143, "additions": 89, "deletions": 54}, "files": [{"sha": "2e03111751ea0368bce1395756ca8773b3f4fc7d", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=b6459d9a78a55b0a1906357552ccff2d2769fa8a", "patch": "@@ -1,3 +1,14 @@\n+2001-02-08  Anthony Green  <green@redhat.com>\n+\n+\t* include/private/gcconfig.h: Add XSCALE NOSYS support for bare\n+\t  board embedded targets.\n+\t* os_dep.c: Avoid signal handling code for NOSYS/ECOS targets.\n+\t  Use GC_get_stack_base for NOSYS/ECOS targets.  Clean up some\n+\t  redundant uses of ECOS.\n+\t* misc.c: Use NOSYS where ECOS is being used.\n+\t  Don't define GC_write twice for ECOS systems.\n+\t  (GC_write): New function for NOSYS targets.\n+\n 2002-02-06  Adam Megacz <adam@xwt.org>\n \n         * boehm-gc/include/gc.h: (GC_CreateThread) This function is"}, {"sha": "647bd5af3f7c60386e343db722868229fb74e4be", "filename": "boehm-gc/include/private/gcconfig.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgcconfig.h?ref=b6459d9a78a55b0a1906357552ccff2d2769fa8a", "patch": "@@ -39,6 +39,13 @@\n # endif\n \n /* Determine the machine type: */\n+# if defined(__XSCALE__)\n+#    define ARM32\n+#    if !defined(LINUX)\n+#      define NOSYS\n+#      define mach_type_known\n+#    endif\n+# endif\n # if defined(sun) && defined(mc68000)\n #    define M68K\n #    define SUNOS4\n@@ -1495,6 +1502,15 @@\n #     define OS_TYPE \"MSWINCE\"\n #     define DATAEND /* not needed */\n #   endif\n+#   ifdef NOSYS\n+      /* __data_start is usually defined in the target linker script.  */\n+      extern int __data_start;\n+#     define DATASTART (ptr_t)(&__data_start)\n+#     define USE_GENERIC_PUSH_REGS\n+      /* __stack_base__ is set in newlib/libc/sys/arm/crt0.S  */\n+      extern void *__stack_base__;\n+#     define STACKBOTTOM ((ptr_t) (__stack_base__))\n+#   endif\n #endif\n \n # ifdef SH"}, {"sha": "842d9a669bbceadb4bb15e572d2f92b9e4aaa58a", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=b6459d9a78a55b0a1906357552ccff2d2769fa8a", "patch": "@@ -69,7 +69,7 @@\n #   endif\n # endif\n \n-#ifdef ECOS\n+#if defined(NOSYS) || defined(ECOS)\n #undef STACKBASE\n #endif\n \n@@ -744,7 +744,8 @@ int GC_tmp;  /* Should really be local ... */\n # endif\n #endif\n \n-#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(OS2) && !defined(MACOS)\n+#if !defined(MSWIN32) && !defined(MSWINCE) && !defined(OS2) \\\n+    && !defined(MACOS)  && !defined(ECOS) && !defined(NOSYS)\n int GC_write(fd, buf, len)\n int fd;\n GC_CONST char *buf;\n@@ -767,14 +768,22 @@ size_t len;\n }\n #endif /* UN*X */\n \n-#if defined(ECOS)\n+#ifdef ECOS\n int GC_write(fd, buf, len)\n {\n   _Jv_diag_write (buf, len);\n   return len;\n }\n #endif\n \n+#ifdef NOSYS\n+int GC_write(fd, buf, len)\n+{\n+  /* No writing.  */\n+  return len;\n+}\n+#endif\n+\n \n #if defined(MSWIN32) || defined(MSWINCE)\n #   define WRITE(f, buf, len) GC_write(buf, len)"}, {"sha": "a84a80816f4d2d735f24723e43e1ec2759ee14ec", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 50, "deletions": 51, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6459d9a78a55b0a1906357552ccff2d2769fa8a/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=b6459d9a78a55b0a1906357552ccff2d2769fa8a", "patch": "@@ -333,7 +333,8 @@ void GC_enable_signals(void)\n \n #  if !defined(PCR) && !defined(AMIGA) && !defined(MSWIN32) \\\n       && !defined(MSWINCE) \\\n-      && !defined(MACOS) && !defined(DJGPP) && !defined(DOS4GW)\n+      && !defined(MACOS) && !defined(DJGPP) && !defined(DOS4GW) \\\n+      && !defined(NOSYS) && !defined(ECOS)\n \n #   if defined(sigmask) && !defined(UTS4) && !defined(HURD)\n \t/* Use the traditional BSD interface */\n@@ -516,7 +517,7 @@ ptr_t GC_get_stack_base()\n #   undef GC_AMIGA_SB\n # endif /* AMIGA */\n \n-# if defined(NEED_FIND_LIMIT) || (defined(UNIX_LIKE) && !defined(ECOS))\n+# if defined(NEED_FIND_LIMIT) || defined(UNIX_LIKE)\n \n #   ifdef __STDC__\n \ttypedef void (*handler)(int);\n@@ -540,8 +541,7 @@ ptr_t GC_get_stack_base()\n       handler h;\n #   endif\n     {\n-# ifndef ECOS\n-#\tif defined(SUNOS5SIGS) || defined(IRIX5)  \\\n+#     if defined(SUNOS5SIGS) || defined(IRIX5)  \\\n         || defined(OSF1) || defined(HURD)\n \t  struct sigaction\tact;\n \n@@ -579,7 +579,6 @@ ptr_t GC_get_stack_base()\n \t    old_bus_handler = signal(SIGBUS, h);\n #\t  endif\n #\tendif\n-# endif /* ECOS */\n     }\n # endif /* NEED_FIND_LIMIT || UNIX_LIKE */\n \n@@ -602,21 +601,19 @@ ptr_t GC_get_stack_base()\n     \n     void GC_reset_fault_handler()\n     {\n-# ifndef ECOS\n-#       if defined(SUNOS5SIGS) || defined(IRIX5) \\\n-\t   || defined(OSF1) || defined(HURD)\n-\t  (void) sigaction(SIGSEGV, &old_segv_act, 0);\n-#\t  if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n-\t     || defined(HPUX) || defined(HURD)\n-\t      (void) sigaction(SIGBUS, &old_bus_act, 0);\n-#\t  endif\n-#       else\n-  \t  (void) signal(SIGSEGV, old_segv_handler);\n-#\t  ifdef SIGBUS\n-\t    (void) signal(SIGBUS, old_bus_handler);\n-#\t  endif\n-#       endif\n-# endif /* ECOS */\n+#     if defined(SUNOS5SIGS) || defined(IRIX5) \\\n+\t || defined(OSF1) || defined(HURD)\n+\t(void) sigaction(SIGSEGV, &old_segv_act, 0);\n+#\tif defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \\\n+\t   || defined(HPUX) || defined(HURD)\n+\t    (void) sigaction(SIGBUS, &old_bus_act, 0);\n+#\tendif\n+#      else\n+\t(void) signal(SIGSEGV, old_segv_handler);\n+#\tifdef SIGBUS\n+\t  (void) signal(SIGBUS, old_bus_handler);\n+#\tendif\n+#     endif\n     }\n \n     /* Return the first nonaddressible location > p (up) or \t*/\n@@ -625,39 +622,41 @@ ptr_t GC_get_stack_base()\n     ptr_t p;\n     GC_bool up;\n     {\n-# ifndef ECOS\n-        static VOLATILE ptr_t result;\n-    \t\t/* Needs to be static, since otherwise it may not be\t*/\n-    \t\t/* preserved across the longjmp.  Can safely be \t*/\n-    \t\t/* static since it's only called once, with the\t\t*/\n-    \t\t/* allocation lock held.\t\t\t\t*/\n-\n-\n-\tGC_setup_temporary_fault_handler();\n-\tif (setjmp(GC_jmp_buf) == 0) {\n-\t    result = (ptr_t)(((word)(p))\n-\t\t\t      & ~(MIN_PAGE_SIZE-1));\n-\t    for (;;) {\n- \t        if (up) {\n-\t\t    result += MIN_PAGE_SIZE;\n- \t        } else {\n-\t\t    result -= MIN_PAGE_SIZE;\n- \t        }\n-\t\tGC_noop1((word)(*result));\n-\t    }\n-\t}\n-\tGC_reset_fault_handler();\n- \tif (!up) {\n+      static VOLATILE ptr_t result;\n+  \t\t/* Needs to be static, since otherwise it may not be\t*/\n+  \t\t/* preserved across the longjmp.  Can safely be \t*/\n+  \t\t/* static since it's only called once, with the\t\t*/\n+  \t\t/* allocation lock held.\t\t\t\t*/\n+\n+\n+      GC_setup_temporary_fault_handler();\n+      if (setjmp(GC_jmp_buf) == 0) {\n+\tresult = (ptr_t)(((word)(p))\n+\t\t\t & ~(MIN_PAGE_SIZE-1));\n+\tfor (;;) {\n+\t  if (up) {\n \t    result += MIN_PAGE_SIZE;\n- \t}\n-\treturn(result);\n-# else /* ECOS */\n-\tabort();\n-# endif /* ECOS */\n+\t  } else {\n+\t    result -= MIN_PAGE_SIZE;\n+\t  }\n+\t  GC_noop1((word)(*result));\n+\t}\n+      }\n+      GC_reset_fault_handler();\n+      if (!up) {\n+\tresult += MIN_PAGE_SIZE;\n+      }\n+      return(result);\n     }\n # endif\n \n-# ifndef ECOS\n+# if defined(ECOS) || defined(NOSYS)\n+ptr_t GC_get_stack_base()\n+{\n+  return STACKBOTTOM;\n+}\n+\n+#else\n \n #ifdef LINUX_STACKBOTTOM\n \n@@ -761,7 +760,7 @@ ptr_t GC_get_stack_base()\n #endif /* FREEBSD_STACKBOTTOM */\n \n #if !defined(BEOS) && !defined(AMIGA) && !defined(MSWIN32) \\\n-    && !defined(MSWINCE) && !defined(OS2) && !defined(ECOS)\n+    && !defined(MSWINCE) && !defined(OS2)\n \n ptr_t GC_get_stack_base()\n {\n@@ -815,7 +814,7 @@ ptr_t GC_get_stack_base()\n     \treturn(result);\n #   endif /* STACKBOTTOM */\n }\n-# endif /* ECOS */\n+# endif /* NOSYS ECOS */\n \n # endif /* ! AMIGA, !OS 2, ! MS Windows, !BEOS */\n "}]}