{"sha": "302b150e73ef172cbdd9b6735c580746f694618c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAyYjE1MGU3M2VmMTcyY2JkZDliNjczNWM1ODA3NDZmNjk0NjE4Yw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-07-21T04:44:10Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2008-07-21T04:44:10Z"}, "message": "re PR libfortran/36857 (Non-English locale breaks gfortran float formatting (\"printf is broken\"))\n\n2008-07-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/36857\n\t* io/write_float.def: Comment out locale dependent code and fix general\n\tcomments.\n\nFrom-SVN: r138021", "tree": {"sha": "a258b1d92af9602654e72eacbb1a483b32e2750f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a258b1d92af9602654e72eacbb1a483b32e2750f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/302b150e73ef172cbdd9b6735c580746f694618c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302b150e73ef172cbdd9b6735c580746f694618c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/302b150e73ef172cbdd9b6735c580746f694618c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/302b150e73ef172cbdd9b6735c580746f694618c/comments", "author": null, "committer": null, "parents": [{"sha": "8ca7338928eb2a6b871c772b13ffe6911a34deeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ca7338928eb2a6b871c772b13ffe6911a34deeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ca7338928eb2a6b871c772b13ffe6911a34deeb"}], "stats": {"total": 59, "additions": 34, "deletions": 25}, "files": [{"sha": "48a20e99d2187d8f0dd15203cdcf5f4025524dc3", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302b150e73ef172cbdd9b6735c580746f694618c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302b150e73ef172cbdd9b6735c580746f694618c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=302b150e73ef172cbdd9b6735c580746f694618c", "patch": "@@ -1,3 +1,9 @@\n+2008-07-20  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/36857\n+\t* io/write_float.def: Comment out locale dependent code and fix general\n+\tcomments.\n+\t\n 2008-07-07  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/36341"}, {"sha": "ed4c45f6277ef2898beeb8acf934df58abf631ab", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/302b150e73ef172cbdd9b6735c580746f694618c/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/302b150e73ef172cbdd9b6735c580746f694618c/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=302b150e73ef172cbdd9b6735c580746f694618c", "patch": "@@ -99,32 +99,13 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n   if (d < 0)\n     internal_error (&dtp->common, \"Unspecified precision\");\n \n-  /* Use sprintf to print the number in the format +D.DDDDe+ddd\n-     For an N digit exponent, this gives us (MIN_FIELD_WIDTH-5)-N digits\n-     after the decimal point, plus another one before the decimal point.  */\n-\n   sign = calculate_sign (dtp, sign_bit);\n-\n-  /* #   The result will always contain a decimal point, even if no\n-   *     digits follow it\n-   *\n-   * -   The converted value is to be left adjusted on the field boundary\n-   *\n-   * +   A sign (+ or -) always be placed before a number\n-   *\n-   * MIN_FIELD_WIDTH  minimum field width\n-   *\n-   * *   (ndigits-1) is used as the precision\n-   *\n-   *   e format: [-]d.ddde\u00c2\u00b1dd where there is one digit before the\n-   *   decimal-point character and the number of digits after it is\n-   *   equal to the precision. The exponent always contains at least two\n-   *   digits; if the value is zero, the exponent is 00.\n-   */\n-\n-  /* Check the given string has punctuation in the correct places.  */\n-  if (d != 0 && (buffer[2] != '.' || buffer[ndigits + 2] != 'e'))\n-      internal_error (&dtp->common, \"printf is broken\");\n+  \n+  /* The following code checks the given string has punctuation in the correct\n+     places.  Uncomment if needed for debugging.\n+     if (d != 0 && ((buffer[2] != '.' && buffer[2] != ',')\n+\t\t    || buffer[ndigits + 2] != 'e'))\n+       internal_error (&dtp->common, \"printf is broken\");  */\n \n   /* Read the exponent back in.  */\n   e = atoi (&buffer[ndigits + 3]) + 1;\n@@ -702,8 +683,30 @@ OUTPUT_FLOAT_FMT_G(16)\n \n #undef OUTPUT_FLOAT_FMT_G\n \n+\n /* Define a macro to build code for write_float.  */\n \n+  /* Note: Before output_float is called, sprintf is used to print to buffer the\n+     number in the format +D.DDDDe+ddd. For an N digit exponent, this gives us\n+     (MIN_FIELD_WIDTH-5)-N digits after the decimal point, plus another one\n+     before the decimal point.\n+\n+     #   The result will always contain a decimal point, even if no\n+\t digits follow it\n+\n+     -   The converted value is to be left adjusted on the field boundary\n+\n+     +   A sign (+ or -) always be placed before a number\n+\n+     MIN_FIELD_WIDTH  minimum field width\n+\n+     *   (ndigits-1) is used as the precision\n+\n+     e format: [-]d.ddde\u00c2\u00b1dd where there is one digit before the\n+       decimal-point character and the number of digits after it is\n+       equal to the precision. The exponent always contains at least two\n+       digits; if the value is zero, the exponent is 00.  */\n+\n #ifdef HAVE_SNPRINTF\n \n #define DTOA \\"}]}