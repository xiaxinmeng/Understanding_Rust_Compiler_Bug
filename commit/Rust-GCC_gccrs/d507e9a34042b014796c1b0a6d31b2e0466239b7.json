{"sha": "d507e9a34042b014796c1b0a6d31b2e0466239b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUwN2U5YTM0MDQyYjAxNDc5NmMxYjBhNmQzMWIyZTA0NjYyMzliNw==", "commit": {"author": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2012-10-23T17:36:39Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2012-10-23T17:36:39Z"}, "message": "AArch64 [8/10] Fixup botched commit.\n\nFrom-SVN: r192733", "tree": {"sha": "6377db541a4e4b8f626f1fab82e280049b5f35a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6377db541a4e4b8f626f1fab82e280049b5f35a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d507e9a34042b014796c1b0a6d31b2e0466239b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d507e9a34042b014796c1b0a6d31b2e0466239b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d507e9a34042b014796c1b0a6d31b2e0466239b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d507e9a34042b014796c1b0a6d31b2e0466239b7/comments", "author": null, "committer": null, "parents": [{"sha": "24034425f50001b28e63fcd9ca6f1d080d342b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24034425f50001b28e63fcd9ca6f1d080d342b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24034425f50001b28e63fcd9ca6f1d080d342b4f"}], "stats": {"total": 510, "additions": 510, "deletions": 0}, "files": [{"sha": "49611303b023206cd9cd72511e49fe4aadca340c", "filename": "libgcc/config/aarch64/crti.S", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fcrti.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fcrti.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Fcrti.S?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,68 @@\n+# Machine description for AArch64 architecture.\n+# Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+# Contributed by ARM Ltd.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+/* An executable stack is *not* required for these functions.  */\n+#if defined(__ELF__) && defined(__linux__)\n+.section .note.GNU-stack,\"\",%progbits\n+.previous\n+#endif\n+\n+# This file creates a stack frame for the contents of the .fini and\n+# .init sections.  Users may put any desired instructions in those\n+# sections.\n+\n+#ifdef __ELF__\n+#define TYPE(x) .type x,function\n+#else\n+#define TYPE(x)\n+#endif\n+\n+\t# Note - this macro is complemented by the FUNC_END macro\n+\t# in crtn.S.  If you change this macro you must also change\n+\t# that macro match.\n+.macro FUNC_START\n+\t#  Create a stack frame and save any call-preserved registers\n+\tstp\tx29, x30, [sp, #-16]!\n+\tstp\tx27, x28, [sp, #-16]!\n+\tstp\tx25, x26, [sp, #-16]!\n+\tstp\tx23, x24, [sp, #-16]!\n+\tstp\tx21, x22, [sp, #-16]!\n+\tstp\tx19, x20, [sp, #-16]!\n+.endm\n+\n+\t.section\t\".init\"\n+\t.align 2\n+\t.global\t_init\n+\tTYPE(_init)\n+_init:\n+\tFUNC_START\n+\n+\n+\t.section\t\".fini\"\n+\t.align\t2\n+\t.global\t_fini\n+\tTYPE(_fini)\n+_fini:\n+\tFUNC_START\n+\n+# end of crti.S"}, {"sha": "70dbc19c59275ce591025de1fc4b39596628730b", "filename": "libgcc/config/aarch64/crtn.S", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fcrtn.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fcrtn.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Fcrtn.S?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,61 @@\n+# Machine description for AArch64 architecture.\n+# Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+# Contributed by ARM Ltd.\n+#\n+# This file is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by the\n+# Free Software Foundation; either version 3, or (at your option) any\n+# later version.\n+#\n+# This file is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# Under Section 7 of GPL version 3, you are granted additional\n+# permissions described in the GCC Runtime Library Exception, version\n+# 3.1, as published by the Free Software Foundation.\n+#\n+# You should have received a copy of the GNU General Public License and\n+# a copy of the GCC Runtime Library Exception along with this program;\n+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+# <http://www.gnu.org/licenses/>.\n+\n+/* An executable stack is *not* required for these functions.  */\n+#if defined(__ELF__) && defined(__linux__)\n+.section .note.GNU-stack,\"\",%progbits\n+.previous\n+#endif\n+\n+# This file just makes sure that the .fini and .init sections do in\n+# fact return.  Users may put any desired instructions in those sections.\n+# This file is the last thing linked into any executable.\n+\n+\t# Note - this macro is complemented by the FUNC_START macro\n+\t# in crti.S.  If you change this macro you must also change\n+\t# that macro match.\n+\t#\n+\t# Note - we do not try any fancy optimizations of the return\n+\t# sequences here, it is just not worth it.  Instead keep things\n+\t# simple.  Restore all the save resgisters, including the link\n+\t# register and then perform the correct function return instruction.\n+.macro FUNC_END\n+\tldp\tx19, x20, [sp], #16\n+\tldp\tx21, x22, [sp], #16\n+\tldp\tx23, x24, [sp], #16\n+\tldp\tx25, x26, [sp], #16\n+\tldp\tx27, x28, [sp], #16\n+\tldp\tx29, x30, [sp], #16\n+\tret\n+.endm\n+\n+\n+\t.section\t\".init\"\n+\t;;\n+\tFUNC_END\n+\n+\t.section\t\".fini\"\n+\t;;\n+\tFUNC_END\n+\n+# end of crtn.S"}, {"sha": "1e2d40b7d98e306dc761db222e7f12a090ef8e5e", "filename": "libgcc/config/aarch64/linux-unwind.h", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Flinux-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Flinux-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Flinux-unwind.h?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,143 @@\n+/* Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 3, or (at your option) any\n+   later version.\n+\n+   This file is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef inhibit_libc\n+\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR aarch64_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+aarch64_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t      _Unwind_FrameState * fs)\n+{\n+  /* The kernel creates an rt_sigframe on the stack immediately prior\n+     to delivering a signal.\n+\n+     This structure must have the same shape as the linux kernel\n+     equivalent.  */\n+  struct rt_sigframe\n+  {\n+    siginfo_t info;\n+    struct ucontext uc;\n+  };\n+\n+  struct rt_sigframe *rt_;\n+  _Unwind_Ptr new_cfa;\n+  unsigned *pc = context->ra;\n+  struct sigcontext *sc;\n+  struct _aarch64_ctx *extension_marker;\n+  int i;\n+\n+  /* A signal frame will have a return address pointing to\n+     __default_sa_restorer. This code is hardwired as:\n+\n+     0xd2801168         movz x8, #0x8b\n+     0xd4000001         svc  0x0\n+   */\n+  if (pc[0] != 0xd2801168 || pc[1] != 0xd4000001)\n+    {\n+      return _URC_END_OF_STACK;\n+    }\n+\n+  rt_ = context->cfa;\n+  sc = &rt_->uc.uc_mcontext;\n+\n+/* This define duplicates the definition in aarch64.md */\n+#define SP_REGNUM 31\n+\n+  new_cfa = (_Unwind_Ptr) sc;\n+  fs->regs.cfa_how = CFA_REG_OFFSET;\n+  fs->regs.cfa_reg = STACK_POINTER_REGNUM;\n+  fs->regs.cfa_offset = new_cfa - (_Unwind_Ptr) context->cfa;\n+\n+  for (i = 0; i < AARCH64_DWARF_NUMBER_R; i++)\n+    {\n+      fs->regs.reg[AARCH64_DWARF_R0 + i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[AARCH64_DWARF_R0 + i].loc.offset =\n+\t(_Unwind_Ptr) & (sc->regs[i]) - new_cfa;\n+    }\n+\n+  /* The core context may be extended with an arbitrary set of\n+     additional contexts appended sequentially. Each additional\n+     context contains a magic identifier and size in bytes.  The size\n+     field can be used to skip over unrecognized context extensions.\n+     The end of the context sequence is marked by a context with magic\n+     0 or size 0.  */\n+  for (extension_marker = (struct _aarch64_ctx *) &sc->__reserved;\n+       extension_marker->magic;\n+       extension_marker = (struct _aarch64_ctx *)\n+       ((unsigned char *) extension_marker + extension_marker->size))\n+    {\n+      if (extension_marker->magic == FPSIMD_MAGIC)\n+\t{\n+\t  struct fpsimd_context *ctx =\n+\t    (struct fpsimd_context *) extension_marker;\n+\t  int i;\n+\n+\t  for (i = 0; i < AARCH64_DWARF_NUMBER_V; i++)\n+\t    {\n+\t      _Unwind_Sword offset;\n+\n+\t      fs->regs.reg[AARCH64_DWARF_V0 + i].how = REG_SAVED_OFFSET;\n+\n+\t      /* sigcontext contains 32 128bit registers for V0 to\n+\t\t V31.  The kernel will have saved the contents of the\n+\t\t V registers.  We want to unwind the callee save D\n+\t\t registers.  Each D register comprises the least\n+\t\t significant half of the corresponding V register.  We\n+\t\t need to offset into the saved V register dependent on\n+\t\t our endianness to find the saved D register.  */\n+\n+\t      offset = (_Unwind_Ptr) & (ctx->vregs[i]) - new_cfa;\n+\n+\t      /* The endianness adjustment code below expects that a\n+\t\t saved V register is 16 bytes.  */\n+\t      gcc_assert (sizeof (ctx->vregs[0]) == 16);\n+#if defined (__AARCH64EB__)\n+\t      offset = offset + 8;\n+#endif\n+\t      fs->regs.reg[AARCH64_DWARF_V0 + i].loc.offset = offset;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* There is context provided that we do not recognize!  */\n+\t}\n+    }\n+\n+  fs->regs.reg[31].how = REG_SAVED_OFFSET;\n+  fs->regs.reg[31].loc.offset = (_Unwind_Ptr) & (sc->sp) - new_cfa;\n+\n+  fs->signal_frame = 1;\n+\n+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_VAL_OFFSET;\n+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset =\n+    (_Unwind_Ptr) (sc->pc) - new_cfa;\n+\n+  fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+#endif"}, {"sha": "3a09ae7605f295af6ba40acc05d33b2fec7a96b2", "filename": "libgcc/config/aarch64/sfp-machine.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fsfp-machine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fsfp-machine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Fsfp-machine.h?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,153 @@\n+/* Machine description for AArch64 architecture.\n+   Copyright (C) 2009, 2010, 2011, 2012 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define _FP_W_TYPE_SIZE\t\t64\n+#define _FP_W_TYPE\t\tunsigned long\n+#define _FP_WS_TYPE\t\tsigned long\n+#define _FP_I_TYPE\t\tint\n+\n+typedef int TItype __attribute__ ((mode (TI)));\n+typedef unsigned int UTItype __attribute__ ((mode (TI)));\n+#define TI_BITS (__CHAR_BIT__ * (int)sizeof(TItype))\n+\n+/* The type of the result of a floating point comparison.  This must\n+   match __libgcc_cmp_return__ in GCC for the target.  */\n+typedef int __gcc_CMPtype __attribute__ ((mode (__libgcc_cmp_return__)));\n+#define CMPtype __gcc_CMPtype\n+\n+#define _FP_MUL_MEAT_Q(R,X,Y)\t\t\t\t\\\n+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)\n+\n+#define _FP_DIV_MEAT_Q(R,X,Y)\t_FP_DIV_MEAT_2_udiv(Q,R,X,Y)\n+\n+#define _FP_NANFRAC_S\t\t((_FP_QNANBIT_S << 1) - 1)\n+#define _FP_NANFRAC_D\t\t((_FP_QNANBIT_D << 1) - 1)\n+#define _FP_NANFRAC_Q\t\t((_FP_QNANBIT_Q << 1) - 1), -1\n+#define _FP_NANSIGN_S\t\t0\n+#define _FP_NANSIGN_D\t\t0\n+#define _FP_NANSIGN_Q\t\t0\n+\n+#define _FP_KEEPNANFRACP 1\n+\n+/* This appears to be in line with the VFP conventions in the v7-a\n+   ARM-ARM. Need to check with the v8 version.  */\n+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if ((_FP_FRAC_HIGH_RAW_##fs(X) & _FP_QNANBIT_##fs)\t\t\\\n+\t&& !(_FP_FRAC_HIGH_RAW_##fs(Y) & _FP_QNANBIT_##fs))\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = Y##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,Y);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tR##_s = X##_s;\t\t\t\t\t\t\\\n+\t_FP_FRAC_COPY_##wc(R,X);\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    R##_c = FP_CLS_NAN;\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define FP_EX_INVALID\t0x01\n+#define FP_EX_DIVZERO\t0x02\n+#define FP_EX_OVERFLOW\t0x04\n+#define FP_EX_UNDERFLOW\t0x08\n+#define FP_EX_INEXACT\t0x10\n+\n+#define FP_HANDLE_EXCEPTIONS\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    const float fp_max = __FLT_MAX__;\t\t\t\t\t\\\n+    const float fp_min = __FLT_MIN__;\t\t\t\t\t\\\n+    const float fp_1e32 = 1.0e32f;\t\t\t\t\t\\\n+    const float fp_zero = 0.0;\t\t\t\t\t\t\\\n+    const float fp_one = 1.0;\t\t\t\t\t\t\\\n+    unsigned fpsr;\t\t\t\t\t\t\t\\\n+    if (_fex & FP_EX_INVALID)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        __asm__ __volatile__ (\"fdiv\\ts0, %s0, %s0\"\t\t\t\\\n+\t\t\t      :\t\t\t\t\t\t\\\n+\t\t\t      : \"w\" (fp_zero)\t\t\t\t\\\n+\t\t\t      : \"s0\");\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"mrs\\t%0, fpsr\" : \"=r\" (fpsr));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (_fex & FP_EX_DIVZERO)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"fdiv\\ts0, %s0, %s1\"\t\t\t\\\n+\t\t\t      :\t\t\t\t\t\t\\\n+\t\t\t      : \"w\" (fp_one), \"w\" (fp_zero)\t\t\\\n+\t\t\t      : \"s0\");\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"mrs\\t%0, fpsr\" : \"=r\" (fpsr));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (_fex & FP_EX_OVERFLOW)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        __asm__ __volatile__ (\"fadd\\ts0, %s0, %s1\"\t\t\t\\\n+\t\t\t      :\t\t\t\t\t\t\\\n+\t\t\t      : \"w\" (fp_max), \"w\" (fp_1e32)\t\t\\\n+\t\t\t      : \"s0\");\t\t\t\t\t\\\n+        __asm__ __volatile__ (\"mrs\\t%0, fpsr\" : \"=r\" (fpsr));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (_fex & FP_EX_UNDERFLOW)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"fmul\\ts0, %s0, %s0\"\t\t\t\\\n+\t\t\t      :\t\t\t\t\t\t\\\n+\t\t\t      : \"w\" (fp_min)\t\t\t\t\\\n+\t\t\t      : \"s0\");\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"mrs\\t%0, fpsr\" : \"=r\" (fpsr));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (_fex & FP_EX_INEXACT)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"fsub\\ts0, %s0, %s1\"\t\t\t\\\n+\t\t\t      :\t\t\t\t\t\t\\\n+\t\t\t      : \"w\" (fp_max), \"w\" (fp_one)\t\t\\\n+\t\t\t      : \"s0\");\t\t\t\t\t\\\n+\t__asm__ __volatile__ (\"mrs\\t%0, fpsr\" : \"=r\" (fpsr));\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#define FP_RND_NEAREST\t\t0\n+#define FP_RND_ZERO\t\t0xc00000\n+#define FP_RND_PINF\t\t0x400000\n+#define FP_RND_MINF\t\t0x800000\n+\n+#define _FP_DECL_EX \\\n+  unsigned long int _fpcr __attribute__ ((unused)) = FP_RND_NEAREST\n+\n+#define FP_INIT_ROUNDMODE\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    __asm__ __volatile__ (\"mrs\t%0, fpcr\"\t\\\n+\t\t\t  : \"=r\" (_fpcr));\t\\\n+  } while (0)\n+\n+#define FP_ROUNDMODE (_fpcr & 0xc00000)\n+\n+#define\t__LITTLE_ENDIAN\t1234\n+#define\t__BIG_ENDIAN\t4321\n+\n+#if defined __AARCH64EB__\n+# define __BYTE_ORDER __BIG_ENDIAN\n+#else\n+# define __BYTE_ORDER __LITTLE_ENDIAN\n+#endif\n+\n+\n+/* Define ALIASNAME as a strong alias for NAME.  */\n+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)\n+# define _strong_alias(name, aliasname) \\\n+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));"}, {"sha": "d7b621ee6d8504371a547e616ffeac4f1f37a6a1", "filename": "libgcc/config/aarch64/sync-cache.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fsync-cache.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Fsync-cache.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Fsync-cache.c?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,57 @@\n+/* Machine description for AArch64 architecture.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by ARM Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+void\n+__aarch64_sync_cache_range (const void *base, const void *end)\n+{\n+  unsigned icache_lsize;\n+  unsigned dcache_lsize;\n+  static unsigned int cache_info = 0;\n+  const char *address;\n+\n+  if (! cache_info)\n+    /* CTR_EL0 [3:0] contains log2 of icache line size in words.\n+       CTR_EL0 [19:16] contains log2 of dcache line size in words.  */\n+    asm volatile (\"mrs\\t%0, ctr_el0\":\"=r\" (cache_info));\n+\n+  icache_lsize = 4 << (cache_info & 0xF);\n+  dcache_lsize = 4 << ((cache_info >> 16) & 0xF);\n+\n+  /* Loop over the address range, clearing one cache line at once.\n+     Data cache must be flushed to unification first to make sure the\n+     instruction cache fetches the updated data.  'end' is exclusive,\n+     as per the GNU definition of __clear_cache.  */\n+\n+  for (address = base; address < (const char *) end; address += dcache_lsize)\n+    asm volatile (\"dc\\tcvau, %0\"\n+\t\t  :\n+\t\t  : \"r\" (address)\n+\t\t  : \"memory\");\n+\n+  asm volatile (\"dsb\\tish\" : : : \"memory\");\n+\n+  for (address = base; address < (const char *) end; address += icache_lsize)\n+    asm volatile (\"ic\\tivau, %0\"\n+\t\t  :\n+\t\t  : \"r\" (address)\n+\t\t  : \"memory\");\n+\n+  asm volatile (\"dsb\\tish; isb\" : : : \"memory\");\n+}"}, {"sha": "002cb832902f87703a973bef0ee741c0516455bf", "filename": "libgcc/config/aarch64/t-aarch64", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Ft-aarch64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Ft-aarch64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Ft-aarch64?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,21 @@\n+# Machine description for AArch64 architecture.\n+# Copyright (C) 2012 Free Software Foundation, Inc.\n+# Contributed by ARM Ltd.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+# General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+LIB2ADD += $(srcdir)/config/aarch64/sync-cache.c"}, {"sha": "6500b5243e415e5bc10cd352cba8a75f05e8b433", "filename": "libgcc/config/aarch64/t-softfp", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Ft-softfp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d507e9a34042b014796c1b0a6d31b2e0466239b7/libgcc%2Fconfig%2Faarch64%2Ft-softfp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Faarch64%2Ft-softfp?ref=d507e9a34042b014796c1b0a6d31b2e0466239b7", "patch": "@@ -0,0 +1,7 @@\n+softfp_float_modes := tf\n+softfp_int_modes := si di ti\n+softfp_extensions := sftf dftf\n+softfp_truncations := tfsf tfdf\n+softfp_exclude_libgcc2 := n\n+\n+TARGET_LIBGCC2_CFLAGS += -Wno-missing-prototypes"}]}