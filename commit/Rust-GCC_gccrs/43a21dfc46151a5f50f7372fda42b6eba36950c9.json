{"sha": "43a21dfc46151a5f50f7372fda42b6eba36950c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNhMjFkZmM0NjE1MWE1ZjUwZjczNzJmZGE0MmI2ZWJhMzY5NTBjOQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-03-25T16:16:41Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-03-25T16:16:41Z"}, "message": "re PR middle-end/9707 (Unnecessary range test in switches with less than 4 cases)\n\n\tPR optimization/9707.\n\t* stmt.c (emit_case_nodes): Emit equality comparisons instead\n\tof recursing if both children are single-valued cases with no\n\tchildren.\n\nFrom-SVN: r79954", "tree": {"sha": "b8180448c0f7c82d4935723ff1e395c1211301e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8180448c0f7c82d4935723ff1e395c1211301e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43a21dfc46151a5f50f7372fda42b6eba36950c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a21dfc46151a5f50f7372fda42b6eba36950c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43a21dfc46151a5f50f7372fda42b6eba36950c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43a21dfc46151a5f50f7372fda42b6eba36950c9/comments", "author": null, "committer": null, "parents": [{"sha": "6d11af89b1c8723f644edcd243ba109b0cb2507d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d11af89b1c8723f644edcd243ba109b0cb2507d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d11af89b1c8723f644edcd243ba109b0cb2507d"}], "stats": {"total": 43, "additions": 43, "deletions": 0}, "files": [{"sha": "e63bbffaf125710e665a09fdc4094329ae587587", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a21dfc46151a5f50f7372fda42b6eba36950c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a21dfc46151a5f50f7372fda42b6eba36950c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43a21dfc46151a5f50f7372fda42b6eba36950c9", "patch": "@@ -1,3 +1,10 @@\n+2004-03-25  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\tPR optimization/9707.\n+\t* stmt.c (emit_case_nodes): Emit equality comparisons instead\n+\tof recursing if both children are single-valued cases with no\n+\tchildren.\n+\n 2004-03-25  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (vfp_print_multi): Remove."}, {"sha": "a28a01484d77ee04e27068ef01022f58bca1ee36", "filename": "gcc/stmt.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43a21dfc46151a5f50f7372fda42b6eba36950c9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43a21dfc46151a5f50f7372fda42b6eba36950c9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=43a21dfc46151a5f50f7372fda42b6eba36950c9", "patch": "@@ -6200,6 +6200,42 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t      emit_case_nodes (index, node->right, default_label, index_type);\n \t    }\n \n+\t  /* If both children are single-valued cases with no\n+\t     children, finish up all the work.  This way, we can save\n+\t     one ordered comparison.  */\n+\t  else if (tree_int_cst_equal (node->right->low, node->right->high)\n+\t\t   && node->right->left == 0\n+\t\t   && node->right->right == 0\n+\t\t   && tree_int_cst_equal (node->left->low, node->left->high)\n+\t\t   && node->left->left == 0\n+\t\t   && node->left->right == 0)\n+\t    {\n+\t      /* Neither node is bounded.  First distinguish the two sides;\n+\t\t then emit the code for one side at a time.  */\n+\n+\t      /* See if the value matches what the right hand side\n+\t\t wants.  */\n+\t      do_jump_if_equal (index,\n+\t\t\t\tconvert_modes (mode, imode,\n+\t\t\t\t\t       expand_expr (node->right->low,\n+\t\t\t\t\t\t\t    NULL_RTX,\n+\t\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t\t       unsignedp),\n+\t\t\t\tlabel_rtx (node->right->code_label),\n+\t\t\t\tunsignedp);\n+\n+\t      /* See if the value matches what the left hand side\n+\t\t wants.  */\n+\t      do_jump_if_equal (index,\n+\t\t\t\tconvert_modes (mode, imode,\n+\t\t\t\t\t       expand_expr (node->left->low,\n+\t\t\t\t\t\t\t    NULL_RTX,\n+\t\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t\t       unsignedp),\n+\t\t\t\tlabel_rtx (node->left->code_label),\n+\t\t\t\tunsignedp);\n+\t    }\n+\n \t  else\n \t    {\n \t      /* Neither node is bounded.  First distinguish the two sides;"}]}