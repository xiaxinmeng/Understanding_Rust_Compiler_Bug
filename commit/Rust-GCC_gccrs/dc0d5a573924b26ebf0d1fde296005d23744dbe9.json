{"sha": "dc0d5a573924b26ebf0d1fde296005d23744dbe9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwZDVhNTczOTI0YjI2ZWJmMGQxZmRlMjk2MDA1ZDIzNzQ0ZGJlOQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2010-07-16T23:47:46Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-07-16T23:47:46Z"}, "message": "re PR target/42235 (redundant memory move from parameter space to spill space)\n\n\tPR target/42235\n\t* postreload.c (reload_cse_move2add): Return bool, true if anything.\n\tchanged.  All callers changed.\n\t(move2add_use_add2_insn): Likewise.\n\t(move2add_use_add3_insn): Likewise.\n\t(reload_cse_regs): If reload_cse_move2add changed anything, rerun\n\treload_combine.\n\t(RELOAD_COMBINE_MAX_USES): Bump to 16.\n\t(last_jump_ruid): New static variable.\n\t(struct reg_use): New members CONTAINING_MEM and RUID.\n\t(reg_state): New members ALL_OFFSETS_MATCH and REAL_STORE_RUID.\n\t(reload_combine_split_one_ruid, reload_combine_split_ruids,\n\treload_combine_purge_insn_uses, reload_combine_closest_single_use\n\treload_combine_purge_reg_uses_after_ruid,\n\treload_combine_recognize_const_pattern): New static functions.\n\t(reload_combine_recognize_pattern): Verify that ALL_OFFSETS_MATCH\n\tis true for our reg and that we have available index regs.\n\t(reload_combine_note_use): New args RUID and CONTAINING_MEM.  All\n\tcallers changed.  Use them to initialize fields in struct reg_use.\n\t(reload_combine): Initialize last_jump_ruid.  Be careful when to\n\ttake PREV_INSN of the scanned insn.  Update REAL_STORE_RUID fields.\n\tCall reload_combine_recognize_const_pattern.\n\t(reload_combine_note_store): Update REAL_STORE_RUID field.\n\n\t* gcc.target/arm/pr42235.c: New test.\n\nFrom-SVN: r162270", "tree": {"sha": "876f84aaa9762b825bd64c37a7fd832781c04b7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/876f84aaa9762b825bd64c37a7fd832781c04b7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc0d5a573924b26ebf0d1fde296005d23744dbe9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0d5a573924b26ebf0d1fde296005d23744dbe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc0d5a573924b26ebf0d1fde296005d23744dbe9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0d5a573924b26ebf0d1fde296005d23744dbe9/comments", "author": null, "committer": null, "parents": [{"sha": "ebc258f1b3474932a21d56758fd28a45e03ae984", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebc258f1b3474932a21d56758fd28a45e03ae984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebc258f1b3474932a21d56758fd28a45e03ae984"}], "stats": {"total": 532, "additions": 465, "deletions": 67}, "files": [{"sha": "77938c311f2dcd27f1a7c91305536953991e25e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc0d5a573924b26ebf0d1fde296005d23744dbe9", "patch": "@@ -1,3 +1,29 @@\n+2010-07-17  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\tPR target/42235\n+\t* postreload.c (reload_cse_move2add): Return bool, true if anything.\n+\tchanged.  All callers changed.\n+\t(move2add_use_add2_insn): Likewise.\n+\t(move2add_use_add3_insn): Likewise.\n+\t(reload_cse_regs): If reload_cse_move2add changed anything, rerun\n+\treload_combine.\n+\t(RELOAD_COMBINE_MAX_USES): Bump to 16.\n+\t(last_jump_ruid): New static variable.\n+\t(struct reg_use): New members CONTAINING_MEM and RUID.\n+\t(reg_state): New members ALL_OFFSETS_MATCH and REAL_STORE_RUID.\n+\t(reload_combine_split_one_ruid, reload_combine_split_ruids,\n+\treload_combine_purge_insn_uses, reload_combine_closest_single_use\n+\treload_combine_purge_reg_uses_after_ruid,\n+\treload_combine_recognize_const_pattern): New static functions.\n+\t(reload_combine_recognize_pattern): Verify that ALL_OFFSETS_MATCH\n+\tis true for our reg and that we have available index regs.\n+\t(reload_combine_note_use): New args RUID and CONTAINING_MEM.  All\n+\tcallers changed.  Use them to initialize fields in struct reg_use.\n+\t(reload_combine): Initialize last_jump_ruid.  Be careful when to\n+\ttake PREV_INSN of the scanned insn.  Update REAL_STORE_RUID fields.\n+\tCall reload_combine_recognize_const_pattern.\n+\t(reload_combine_note_store): Update REAL_STORE_RUID field.\n+\n 2010-07-16  Jason Merrill  <jason@redhat.com>\n \n \t* Makefile.in (opts-common.o): Depend on options.h."}, {"sha": "cd504e2d203ed3eb5efef0a51342af50360f5596", "filename": "gcc/postreload.c", "status": "modified", "additions": 424, "deletions": 67, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=dc0d5a573924b26ebf0d1fde296005d23744dbe9", "patch": "@@ -56,22 +56,27 @@ static int reload_cse_simplify_set (rtx, rtx);\n static int reload_cse_simplify_operands (rtx, rtx);\n \n static void reload_combine (void);\n-static void reload_combine_note_use (rtx *, rtx);\n+static void reload_combine_note_use (rtx *, rtx, int, rtx);\n static void reload_combine_note_store (rtx, const_rtx, void *);\n \n-static void reload_cse_move2add (rtx);\n+static bool reload_cse_move2add (rtx);\n static void move2add_note_store (rtx, const_rtx, void *);\n \n /* Call cse / combine like post-reload optimization phases.\n    FIRST is the first instruction.  */\n void\n reload_cse_regs (rtx first ATTRIBUTE_UNUSED)\n {\n+  bool moves_converted;\n   reload_cse_regs_1 (first);\n   reload_combine ();\n-  reload_cse_move2add (first);\n+  moves_converted = reload_cse_move2add (first);\n   if (flag_expensive_optimizations)\n-    reload_cse_regs_1 (first);\n+    {\n+      if (moves_converted)\n+\treload_combine ();\n+      reload_cse_regs_1 (first);\n+    }\n }\n \n /* See whether a single set SET is a noop.  */\n@@ -660,30 +665,43 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \n /* The maximum number of uses of a register we can keep track of to\n    replace them with reg+reg addressing.  */\n-#define RELOAD_COMBINE_MAX_USES 6\n+#define RELOAD_COMBINE_MAX_USES 16\n \n-/* INSN is the insn where a register has been used, and USEP points to the\n-   location of the register within the rtl.  */\n-struct reg_use { rtx insn, *usep; };\n+/* Describes a recorded use of a register.  */\n+struct reg_use\n+{\n+  /* The insn where a register has been used.  */\n+  rtx insn;\n+  /* Points to the memory reference enclosing the use, if any, NULL_RTX\n+     otherwise.  */\n+  rtx containing_mem;\n+  /* Location of the register withing INSN.  */\n+  rtx *usep;\n+  /* The reverse uid of the insn.  */\n+  int ruid;\n+};\n \n /* If the register is used in some unknown fashion, USE_INDEX is negative.\n    If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID\n-   indicates where it becomes live again.\n+   indicates where it is first set or clobbered.\n    Otherwise, USE_INDEX is the index of the last encountered use of the\n-   register (which is first among these we have seen since we scan backwards),\n-   OFFSET contains the constant offset that is added to the register in\n-   all encountered uses, and USE_RUID indicates the first encountered, i.e.\n-   last, of these uses.\n+   register (which is first among these we have seen since we scan backwards).\n+   USE_RUID indicates the first encountered, i.e. last, of these uses.\n+   If ALL_OFFSETS_MATCH is true, all encountered uses were inside a PLUS\n+   with a constant offset; OFFSET contains this constant in that case.\n    STORE_RUID is always meaningful if we only want to use a value in a\n    register in a different place: it denotes the next insn in the insn\n-   stream (i.e. the last encountered) that sets or clobbers the register.  */\n+   stream (i.e. the last encountered) that sets or clobbers the register.\n+   REAL_STORE_RUID is similar, but clobbers are ignored when updating it.  */\n static struct\n   {\n     struct reg_use reg_use[RELOAD_COMBINE_MAX_USES];\n-    int use_index;\n     rtx offset;\n+    int use_index;\n     int store_ruid;\n+    int real_store_ruid;\n     int use_ruid;\n+    bool all_offsets_match;\n   } reg_state[FIRST_PSEUDO_REGISTER];\n \n /* Reverse linear uid.  This is increased in reload_combine while scanning\n@@ -694,6 +712,9 @@ static int reload_combine_ruid;\n /* The RUID of the last label we encountered in reload_combine.  */\n static int last_label_ruid;\n \n+/* The RUID of the last jump we encountered in reload_combine.  */\n+static int last_jump_ruid;\n+\n /* The register numbers of the first and last index register.  A value of\n    -1 in LAST_INDEX_REG indicates that we've previously computed these\n    values and found no suitable index registers.  */\n@@ -703,6 +724,311 @@ static int last_index_reg;\n #define LABEL_LIVE(LABEL) \\\n   (label_live[CODE_LABEL_NUMBER (LABEL) - min_labelno])\n \n+/* Subroutine of reload_combine_split_ruids, called to fix up a single\n+   ruid pointed to by *PRUID if it is higher than SPLIT_RUID.  */\n+\n+static inline void\n+reload_combine_split_one_ruid (int *pruid, int split_ruid)\n+{\n+  if (*pruid > split_ruid)\n+    (*pruid)++;\n+}\n+\n+/* Called when we insert a new insn in a position we've already passed in\n+   the scan.  Examine all our state, increasing all ruids that are higher\n+   than SPLIT_RUID by one in order to make room for a new insn.  */\n+\n+static void\n+reload_combine_split_ruids (int split_ruid)\n+{\n+  unsigned i;\n+\n+  reload_combine_split_one_ruid (&reload_combine_ruid, split_ruid);\n+  reload_combine_split_one_ruid (&last_label_ruid, split_ruid);\n+  reload_combine_split_one_ruid (&last_jump_ruid, split_ruid);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int j, idx = reg_state[i].use_index;\n+      reload_combine_split_one_ruid (&reg_state[i].use_ruid, split_ruid);\n+      reload_combine_split_one_ruid (&reg_state[i].store_ruid, split_ruid);\n+      reload_combine_split_one_ruid (&reg_state[i].real_store_ruid,\n+\t\t\t\t     split_ruid);\n+      if (idx < 0)\n+\tcontinue;\n+      for (j = idx; j < RELOAD_COMBINE_MAX_USES; j++)\n+\t{\n+\t  reload_combine_split_one_ruid (&reg_state[i].reg_use[j].ruid,\n+\t\t\t\t\t split_ruid);\n+\t}\n+    }\n+}\n+\n+/* Called when we are about to rescan a previously encountered insn with\n+   reload_combine_note_use after modifying some part of it.  This clears all\n+   information about uses in that particular insn.  */\n+\n+static void\n+reload_combine_purge_insn_uses (rtx insn)\n+{\n+  unsigned i;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      int j, k, idx = reg_state[i].use_index;\n+      if (idx < 0)\n+\tcontinue;\n+      j = k = RELOAD_COMBINE_MAX_USES;\n+      while (j-- > idx)\n+\t{\n+\t  if (reg_state[i].reg_use[j].insn != insn)\n+\t    {\n+\t      k--;\n+\t      if (k != j)\n+\t\treg_state[i].reg_use[k] = reg_state[i].reg_use[j];\n+\t    }\n+\t}\n+      reg_state[i].use_index = k;\n+    }\n+}\n+\n+/* Called when we need to forget about all uses of REGNO after an insn\n+   which is identified by RUID.  */\n+\n+static void\n+reload_combine_purge_reg_uses_after_ruid (unsigned regno, int ruid)\n+{\n+  int j, k, idx = reg_state[regno].use_index;\n+  if (idx < 0)\n+    return;\n+  j = k = RELOAD_COMBINE_MAX_USES;\n+  while (j-- > idx)\n+    {\n+      if (reg_state[regno].reg_use[j].ruid >= ruid)\n+\t{\n+\t  k--;\n+\t  if (k != j)\n+\t    reg_state[regno].reg_use[k] = reg_state[regno].reg_use[j];\n+\t}\n+    }\n+  reg_state[regno].use_index = k;\n+}\n+\n+/* Find the use of REGNO with the ruid that is highest among those\n+   lower than RUID_LIMIT, and return it if it is the only use of this\n+   reg in the insn.  Return NULL otherwise.  */\n+\n+static struct reg_use *\n+reload_combine_closest_single_use (unsigned regno, int ruid_limit)\n+{\n+  int i, best_ruid = 0;\n+  int use_idx = reg_state[regno].use_index;\n+  struct reg_use *retval;\n+\n+  if (use_idx < 0)\n+    return NULL;\n+  retval = NULL;\n+  for (i = use_idx; i < RELOAD_COMBINE_MAX_USES; i++)\n+    {\n+      int this_ruid = reg_state[regno].reg_use[i].ruid;\n+      if (this_ruid >= ruid_limit)\n+\tcontinue;\n+      if (this_ruid > best_ruid)\n+\t{\n+\t  best_ruid = this_ruid;\n+\t  retval = reg_state[regno].reg_use + i;\n+\t}\n+      else if (this_ruid == best_ruid)\n+\tretval = NULL;\n+    }\n+  if (last_label_ruid >= best_ruid)\n+    return NULL;\n+  return retval;\n+}\n+\n+/* Called by reload_combine when scanning INSN.  This function tries to detect\n+   patterns where a constant is added to a register, and the result is used\n+   in an address.\n+   Return true if no further processing is needed on INSN; false if it wasn't\n+   recognized and should be handled normally.  */\n+\n+static bool\n+reload_combine_recognize_const_pattern (rtx insn)\n+{\n+  int from_ruid = reload_combine_ruid;\n+  rtx set, pat, reg, src, addreg;\n+  unsigned int regno;\n+  struct reg_use *use;\n+  bool must_move_add;\n+  rtx add_moved_after_insn = NULL_RTX;\n+  int add_moved_after_ruid = 0;\n+  int clobbered_regno = -1;\n+\n+  set = single_set (insn);\n+  if (set == NULL_RTX)\n+    return false;\n+\n+  reg = SET_DEST (set);\n+  src = SET_SRC (set);\n+  if (!REG_P (reg)\n+      || hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] != 1\n+      || GET_MODE (reg) != Pmode\n+      || reg == stack_pointer_rtx)\n+    return false;\n+\n+  regno = REGNO (reg);\n+\n+  /* We look for a REG1 = REG2 + CONSTANT insn, followed by either\n+     uses of REG1 inside an address, or inside another add insn.  If\n+     possible and profitable, merge the addition into subsequent\n+     uses.  */\n+  if (GET_CODE (src) != PLUS\n+      || !REG_P (XEXP (src, 0))\n+      || !CONSTANT_P (XEXP (src, 1)))\n+    return false;\n+\n+  addreg = XEXP (src, 0);\n+  must_move_add = rtx_equal_p (reg, addreg);\n+\n+  pat = PATTERN (insn);\n+  if (must_move_add && set != pat)\n+    {\n+      /* We have to be careful when moving the add; apart from the\n+\t single_set there may also be clobbers.  Recognize one special\n+\t case, that of one clobber alongside the set (likely a clobber\n+\t of the CC register).  */\n+      gcc_assert (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      if (XVECLEN (pat, 0) != 2 || XVECEXP (pat, 0, 0) != set\n+\t  || GET_CODE (XVECEXP (pat, 0, 1)) != CLOBBER\n+\t  || !REG_P (XEXP (XVECEXP (pat, 0, 1), 0)))\n+\treturn false;\n+      clobbered_regno = REGNO (XEXP (XVECEXP (pat, 0, 1), 0));\n+    }\n+\n+  do\n+    {\n+      use = reload_combine_closest_single_use (regno, from_ruid);\n+\n+      if (use)\n+\t/* Start the search for the next use from here.  */\n+\tfrom_ruid = use->ruid;\n+\n+      if (use && GET_MODE (*use->usep) == Pmode)\n+\t{\n+\t  rtx use_insn = use->insn;\n+\t  int use_ruid = use->ruid;\n+\t  rtx mem = use->containing_mem;\n+\t  bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (use_insn));\n+\n+\t  /* Avoid moving the add insn past a jump.  */\n+\t  if (must_move_add && use_ruid < last_jump_ruid)\n+\t    break;\n+\n+\t  /* If the add clobbers another hard reg in parallel, don't move\n+\t     it past a real set of this hard reg.  */\n+\t  if (must_move_add && clobbered_regno >= 0\n+\t      && reg_state[clobbered_regno].real_store_ruid >= use_ruid)\n+\t    break;\n+\n+\t  /* Avoid moving a use of ADDREG past a point where it\n+\t     is stored.  */\n+\t  if (reg_state[REGNO (addreg)].store_ruid >= use_ruid)\n+\t    break;\n+\n+\t  if (mem != NULL_RTX)\n+\t    {\n+\t      addr_space_t as = MEM_ADDR_SPACE (mem);\n+\t      rtx oldaddr = XEXP (mem, 0);\n+\t      rtx newaddr = NULL_RTX;\n+\t      int old_cost = address_cost (oldaddr, GET_MODE (mem), as, speed);\n+\t      int new_cost;\n+\n+\t      newaddr = simplify_replace_rtx (oldaddr, reg, copy_rtx (src));\n+\t      if (memory_address_addr_space_p (GET_MODE (mem), newaddr, as))\n+\t\t{\n+\t\t  XEXP (mem, 0) = newaddr;\n+\t\t  new_cost = address_cost (newaddr, GET_MODE (mem), as, speed);\n+\t\t  XEXP (mem, 0) = oldaddr;\n+\t\t  if (new_cost <= old_cost\n+\t\t      && validate_change (use_insn,\n+\t\t\t\t\t  &XEXP (mem, 0), newaddr, 0))\n+\t\t    {\n+\t\t      reload_combine_purge_insn_uses (use_insn);\n+\t\t      reload_combine_note_use (&PATTERN (use_insn), use_insn,\n+\t\t\t\t\t       use_ruid, NULL_RTX);\n+\n+\t\t      if (must_move_add)\n+\t\t\t{\n+\t\t\t  add_moved_after_insn = use_insn;\n+\t\t\t  add_moved_after_ruid = use_ruid;\n+\t\t\t}\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx new_set = single_set (use_insn);\n+\t      if (new_set\n+\t\t  && REG_P (SET_DEST (new_set))\n+\t\t  && GET_CODE (SET_SRC (new_set)) == PLUS\n+\t\t  && REG_P (XEXP (SET_SRC (new_set), 0))\n+\t\t  && CONSTANT_P (XEXP (SET_SRC (new_set), 1)))\n+\t\t{\n+\t\t  rtx new_src;\n+\t\t  int old_cost = rtx_cost (SET_SRC (new_set), SET, speed);\n+\n+\t\t  gcc_assert (rtx_equal_p (XEXP (SET_SRC (new_set), 0), reg));\n+\t\t  new_src = simplify_replace_rtx (SET_SRC (new_set), reg,\n+\t\t\t\t\t\t  copy_rtx (src));\n+\n+\t\t  if (rtx_cost (new_src, SET, speed) <= old_cost\n+\t\t      && validate_change (use_insn, &SET_SRC (new_set),\n+\t\t\t\t\t  new_src, 0))\n+\t\t    {\n+\t\t      reload_combine_purge_insn_uses (use_insn);\n+\t\t      reload_combine_note_use (&SET_SRC (new_set), use_insn,\n+\t\t\t\t\t       use_ruid, NULL_RTX);\n+\n+\t\t      if (must_move_add)\n+\t\t\t{\n+\t\t\t  /* See if that took care of the add insn.  */\n+\t\t\t  if (rtx_equal_p (SET_DEST (new_set), reg))\n+\t\t\t    {\n+\t\t\t      delete_insn (insn);\n+\t\t\t      return true;\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    {\n+\t\t\t      add_moved_after_insn = use_insn;\n+\t\t\t      add_moved_after_ruid = use_ruid;\n+\t\t\t    }\n+\t\t\t}\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  /* If we get here, we couldn't handle this use.  */\n+\t  if (must_move_add)\n+\t    break;\n+\t}\n+    }\n+  while (use);\n+\n+  if (!must_move_add || add_moved_after_insn == NULL_RTX)\n+    /* Process the add normally.  */\n+    return false;\n+\n+  reorder_insns (insn, insn, add_moved_after_insn);\n+  reload_combine_purge_reg_uses_after_ruid (regno, add_moved_after_ruid);\n+  reload_combine_split_ruids (add_moved_after_ruid - 1);\n+  reload_combine_note_use (&PATTERN (insn), insn,\n+\t\t\t   add_moved_after_ruid, NULL_RTX);\n+  reg_state[regno].store_ruid = add_moved_after_ruid;\n+\n+  return true;\n+}\n+\n /* Called by reload_combine when scanning INSN.  Try to detect a pattern we\n    can handle and improve.  Return true if no further processing is needed on\n    INSN; false if it wasn't recognized and should be handled normally.  */\n@@ -713,6 +1039,18 @@ reload_combine_recognize_pattern (rtx insn)\n   rtx set, reg, src;\n   unsigned int regno;\n \n+  set = single_set (insn);\n+  if (set == NULL_RTX)\n+    return false;\n+\n+  reg = SET_DEST (set);\n+  src = SET_SRC (set);\n+  if (!REG_P (reg)\n+      || hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] != 1)\n+    return false;\n+\n+  regno = REGNO (reg);\n+\n   /* Look for (set (REGX) (CONST_INT))\n      (set (REGX) (PLUS (REGX) (REGY)))\n      ...\n@@ -726,19 +1064,10 @@ reload_combine_recognize_pattern (rtx insn)\n      and that we know all uses of REGX before it dies.\n      Also, explicitly check that REGX != REGY; our life information\n      does not yet show whether REGY changes in this insn.  */\n-  set = single_set (insn);\n-  if (set == NULL_RTX)\n-    return false;\n-\n-  reg = SET_DEST (set);\n-  src = SET_SRC (set);\n-  if (!REG_P (reg)\n-      || hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] != 1)\n-    return false;\n-\n-  regno = REGNO (reg);\n \n   if (GET_CODE (src) == PLUS\n+      && reg_state[regno].all_offsets_match\n+      && last_index_reg != -1\n       && REG_P (XEXP (src, 1))\n       && rtx_equal_p (XEXP (src, 0), reg)\n       && !rtx_equal_p (XEXP (src, 1), reg)\n@@ -822,7 +1151,9 @@ reload_combine_recognize_pattern (rtx insn)\n \t\t   i < RELOAD_COMBINE_MAX_USES; i++)\n \t\treload_combine_note_use\n \t\t  (&XEXP (*reg_state[regno].reg_use[i].usep, 1),\n-\t\t   reg_state[regno].reg_use[i].insn);\n+\t\t   reg_state[regno].reg_use[i].insn,\n+\t\t   reg_state[regno].reg_use[i].ruid,\n+\t\t   reg_state[regno].reg_use[i].containing_mem);\n \n \t      if (reg_state[REGNO (base)].use_ruid\n \t\t  > reg_state[regno].use_ruid)\n@@ -850,7 +1181,7 @@ reload_combine_recognize_pattern (rtx insn)\n static void\n reload_combine (void)\n {\n-  rtx insn;\n+  rtx insn, prev;\n   int i;\n   basic_block bb;\n   unsigned int r;\n@@ -881,11 +1212,13 @@ reload_combine (void)\n \t}\n     }\n \n+#if 0\n   /* If reg+reg can be used in offsetable memory addresses, the main chunk of\n      reload has already used it where appropriate, so there is no use in\n      trying to generate it now.  */\n   if (double_reg_address_ok || last_index_reg == -1)\n     return;\n+#endif\n \n   /* Set up LABEL_LIVE and EVER_LIVE_AT_START.  The register lifetime\n      information is a bit fuzzy immediately after reload, but it's\n@@ -912,20 +1245,23 @@ reload_combine (void)\n     }\n \n   /* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */\n-  last_label_ruid = reload_combine_ruid = 0;\n+  last_label_ruid = last_jump_ruid = reload_combine_ruid = 0;\n   for (r = 0; r < FIRST_PSEUDO_REGISTER; r++)\n     {\n-      reg_state[r].store_ruid = reload_combine_ruid;\n+      reg_state[r].store_ruid = 0;\n+      reg_state[r].real_store_ruid = 0;\n       if (fixed_regs[r])\n \treg_state[r].use_index = -1;\n       else\n \treg_state[r].use_index = RELOAD_COMBINE_MAX_USES;\n     }\n \n-  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+  for (insn = get_last_insn (); insn; insn = prev)\n     {\n       rtx note;\n \n+      prev = PREV_INSN (insn);\n+\n       /* We cannot do our optimization across labels.  Invalidating all the use\n \t information we have would be costly, so we just note where the label\n \t is and then later disable any optimization that would cross it.  */\n@@ -941,7 +1277,11 @@ reload_combine (void)\n \n       reload_combine_ruid++;\n \n-      if (reload_combine_recognize_pattern (insn))\n+      if (JUMP_P (insn))\n+\tlast_jump_ruid = reload_combine_ruid;\n+\n+      if (reload_combine_recognize_const_pattern (insn)\n+\t  || reload_combine_recognize_pattern (insn))\n \tcontinue;\n \n       note_stores (PATTERN (insn), reload_combine_note_store, NULL);\n@@ -998,7 +1338,8 @@ reload_combine (void)\n \t      reg_state[i].use_index = -1;\n \t}\n \n-      reload_combine_note_use (&PATTERN (insn), insn);\n+      reload_combine_note_use (&PATTERN (insn), insn,\n+\t\t\t       reload_combine_ruid, NULL_RTX);\n       for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t{\n \t  if (REG_NOTE_KIND (note) == REG_INC\n@@ -1007,6 +1348,7 @@ reload_combine (void)\n \t      int regno = REGNO (XEXP (note, 0));\n \n \t      reg_state[regno].store_ruid = reload_combine_ruid;\n+\t      reg_state[regno].real_store_ruid = reload_combine_ruid;\n \t      reg_state[regno].use_index = -1;\n \t    }\n \t}\n@@ -1016,8 +1358,8 @@ reload_combine (void)\n }\n \n /* Check if DST is a register or a subreg of a register; if it is,\n-   update reg_state[regno].store_ruid and reg_state[regno].use_index\n-   accordingly.  Called via note_stores from reload_combine.  */\n+   update store_ruid, real_store_ruid and use_index in the reg_state\n+   structure accordingly.  Called via note_stores from reload_combine.  */\n \n static void\n reload_combine_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n@@ -1041,21 +1383,23 @@ reload_combine_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n   /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n      careful with registers / register parts that are not full words.\n      Similarly for ZERO_EXTRACT.  */\n-  if (GET_CODE (set) != SET\n-      || GET_CODE (SET_DEST (set)) == ZERO_EXTRACT\n+  if (GET_CODE (SET_DEST (set)) == ZERO_EXTRACT\n       || GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)\n     {\n       for (i = hard_regno_nregs[regno][mode] - 1 + regno; i >= regno; i--)\n \t{\n \t  reg_state[i].use_index = -1;\n \t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t  reg_state[i].real_store_ruid = reload_combine_ruid;\n \t}\n     }\n   else\n     {\n       for (i = hard_regno_nregs[regno][mode] - 1 + regno; i >= regno; i--)\n \t{\n \t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t  if (GET_CODE (set) == SET)\n+\t    reg_state[i].real_store_ruid = reload_combine_ruid;\n \t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n \t}\n     }\n@@ -1066,7 +1410,7 @@ reload_combine_note_store (rtx dst, const_rtx set, void *data ATTRIBUTE_UNUSED)\n    *XP is the pattern of INSN, or a part of it.\n    Called from reload_combine, and recursively by itself.  */\n static void\n-reload_combine_note_use (rtx *xp, rtx insn)\n+reload_combine_note_use (rtx *xp, rtx insn, int ruid, rtx containing_mem)\n {\n   rtx x = *xp;\n   enum rtx_code code = x->code;\n@@ -1079,7 +1423,7 @@ reload_combine_note_use (rtx *xp, rtx insn)\n     case SET:\n       if (REG_P (SET_DEST (x)))\n \t{\n-\t  reload_combine_note_use (&SET_SRC (x), insn);\n+\t  reload_combine_note_use (&SET_SRC (x), insn, ruid, NULL_RTX);\n \t  return;\n \t}\n       break;\n@@ -1143,29 +1487,28 @@ reload_combine_note_use (rtx *xp, rtx insn)\n \tif (use_index < 0)\n \t  return;\n \n-\tif (use_index != RELOAD_COMBINE_MAX_USES - 1)\n-\t  {\n-\t    /* We have found another use for a register that is already\n-\t       used later.  Check if the offsets match; if not, mark the\n-\t       register as used in an unknown fashion.  */\n-\t    if (! rtx_equal_p (offset, reg_state[regno].offset))\n-\t      {\n-\t\treg_state[regno].use_index = -1;\n-\t\treturn;\n-\t      }\n-\t  }\n-\telse\n+\tif (use_index == RELOAD_COMBINE_MAX_USES - 1)\n \t  {\n \t    /* This is the first use of this register we have seen since we\n \t       marked it as dead.  */\n \t    reg_state[regno].offset = offset;\n-\t    reg_state[regno].use_ruid = reload_combine_ruid;\n+\t    reg_state[regno].all_offsets_match = true;\n+\t    reg_state[regno].use_ruid = ruid;\n \t  }\n+\telse if (! rtx_equal_p (offset, reg_state[regno].offset))\n+\t  reg_state[regno].all_offsets_match = false;\n+\n \treg_state[regno].reg_use[use_index].insn = insn;\n+\treg_state[regno].reg_use[use_index].ruid = ruid;\n+\treg_state[regno].reg_use[use_index].containing_mem = containing_mem;\n \treg_state[regno].reg_use[use_index].usep = xp;\n \treturn;\n       }\n \n+    case MEM:\n+      containing_mem = x;\n+      break;\n+\n     default:\n       break;\n     }\n@@ -1175,11 +1518,12 @@ reload_combine_note_use (rtx *xp, rtx insn)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\treload_combine_note_use (&XEXP (x, i), insn);\n+\treload_combine_note_use (&XEXP (x, i), insn, ruid, containing_mem);\n       else if (fmt[i] == 'E')\n \t{\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t    reload_combine_note_use (&XVECEXP (x, i, j), insn);\n+\t    reload_combine_note_use (&XVECEXP (x, i, j), insn, ruid,\n+\t\t\t\t     containing_mem);\n \t}\n     }\n }\n@@ -1227,9 +1571,10 @@ static int move2add_last_label_luid;\n    while REG is known to already have value (SYM + offset).\n    This function tries to change INSN into an add instruction\n    (set (REG) (plus (REG) (OFF - offset))) using the known value.\n-   It also updates the information about REG's known value.  */\n+   It also updates the information about REG's known value.\n+   Return true if we made a change.  */\n \n-static void\n+static bool\n move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n {\n   rtx pat = PATTERN (insn);\n@@ -1238,6 +1583,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n   rtx new_src = gen_int_mode (INTVAL (off) - reg_offset[regno],\n \t\t\t      GET_MODE (reg));\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n+  bool changed = false;\n \n   /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n      use (set (reg) (reg)) instead.\n@@ -1252,13 +1598,13 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n \t (reg)), would be discarded.  Maybe we should\n \t try a truncMN pattern?  */\n       if (INTVAL (off) == reg_offset [regno])\n-\tvalidate_change (insn, &SET_SRC (pat), reg, 0);\n+\tchanged = validate_change (insn, &SET_SRC (pat), reg, 0);\n     }\n   else if (rtx_cost (new_src, PLUS, speed) < rtx_cost (src, SET, speed)\n \t   && have_add2_insn (reg, new_src))\n     {\n       rtx tem = gen_rtx_PLUS (GET_MODE (reg), reg, new_src);\n-      validate_change (insn, &SET_SRC (pat), tem, 0);\n+      changed = validate_change (insn, &SET_SRC (pat), tem, 0);\n     }\n   else if (sym == NULL_RTX && GET_MODE (reg) != BImode)\n     {\n@@ -1283,8 +1629,9 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n \t\t\t     gen_rtx_STRICT_LOW_PART (VOIDmode,\n \t\t\t\t\t\t      narrow_reg),\n \t\t\t     narrow_src);\n-\t      if (validate_change (insn, &PATTERN (insn),\n-\t\t\t\t   new_set, 0))\n+\t      changed = validate_change (insn, &PATTERN (insn),\n+\t\t\t\t\t new_set, 0);\n+\t      if (changed)\n \t\tbreak;\n \t    }\n \t}\n@@ -1294,6 +1641,7 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n   reg_mode[regno] = GET_MODE (reg);\n   reg_symbol_ref[regno] = sym;\n   reg_offset[regno] = INTVAL (off);\n+  return changed;\n }\n \n \n@@ -1303,9 +1651,10 @@ move2add_use_add2_insn (rtx reg, rtx sym, rtx off, rtx insn)\n    value (SYM + offset) and change INSN into an add instruction\n    (set (REG) (plus (the found register) (OFF - offset))) if such\n    a register is found.  It also updates the information about\n-   REG's known value.  */\n+   REG's known value.\n+   Return true iff we made a change.  */\n \n-static void\n+static bool\n move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n {\n   rtx pat = PATTERN (insn);\n@@ -1315,6 +1664,7 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n   int min_regno = 0;\n   bool speed = optimize_bb_for_speed_p (BLOCK_FOR_INSN (insn));\n   int i;\n+  bool changed = false;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (reg_set_luid[i] > move2add_last_label_luid\n@@ -1359,20 +1709,25 @@ move2add_use_add3_insn (rtx reg, rtx sym, rtx off, rtx insn)\n \t\t\t\t      GET_MODE (reg));\n \t  tem = gen_rtx_PLUS (GET_MODE (reg), tem, new_src);\n \t}\n-      validate_change (insn, &SET_SRC (pat), tem, 0);\n+      if (validate_change (insn, &SET_SRC (pat), tem, 0))\n+\tchanged = true;\n     }\n   reg_set_luid[regno] = move2add_luid;\n   reg_base_reg[regno] = -1;\n   reg_mode[regno] = GET_MODE (reg);\n   reg_symbol_ref[regno] = sym;\n   reg_offset[regno] = INTVAL (off);\n+  return changed;\n }\n \n-static void\n+/* Convert move insns with constant inputs to additions if they are cheaper.\n+   Return true if any changes were made.  */\n+static bool\n reload_cse_move2add (rtx first)\n {\n   int i;\n   rtx insn;\n+  bool changed = false;\n \n   for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; i--)\n     {\n@@ -1433,7 +1788,7 @@ reload_cse_move2add (rtx first)\n \t\t  && reg_base_reg[regno] < 0\n \t\t  && reg_symbol_ref[regno] == NULL_RTX)\n \t\t{\n-\t\t  move2add_use_add2_insn (reg, NULL_RTX, src, insn);\n+\t\t  changed |= move2add_use_add2_insn (reg, NULL_RTX, src, insn);\n \t\t  continue;\n \t\t}\n \n@@ -1494,6 +1849,7 @@ reload_cse_move2add (rtx first)\n \t\t\t}\n \t\t      if (success)\n \t\t\tdelete_insn (insn);\n+\t\t      changed |= success;\n \t\t      insn = next;\n \t\t      reg_mode[regno] = GET_MODE (reg);\n \t\t      reg_offset[regno] =\n@@ -1539,12 +1895,12 @@ reload_cse_move2add (rtx first)\n \t\t  && reg_base_reg[regno] < 0\n \t\t  && reg_symbol_ref[regno] != NULL_RTX\n \t\t  && rtx_equal_p (sym, reg_symbol_ref[regno]))\n-\t\tmove2add_use_add2_insn (reg, sym, off, insn);\n+\t\tchanged |= move2add_use_add2_insn (reg, sym, off, insn);\n \n \t      /* Otherwise, we have to find a register whose value is sum\n \t\t of sym and some constant value.  */\n \t      else\n-\t\tmove2add_use_add3_insn (reg, sym, off, insn);\n+\t\tchanged |= move2add_use_add3_insn (reg, sym, off, insn);\n \n \t      continue;\n \t    }\n@@ -1599,6 +1955,7 @@ reload_cse_move2add (rtx first)\n \t    }\n \t}\n     }\n+  return changed;\n }\n \n /* SET is a SET or CLOBBER that sets DST.  DATA is the insn which"}, {"sha": "10ee3472053f666ac3c089ff6d86ee37bd92545a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dc0d5a573924b26ebf0d1fde296005d23744dbe9", "patch": "@@ -1,3 +1,7 @@\n+2010-07-17  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* gcc.target/arm/pr42235.c: New test.\n+\n 2010-07-16  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/32505"}, {"sha": "478abcc076569570677b4a4142da2863d9a79f27", "filename": "gcc/testsuite/gcc.target/arm/pr42235.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42235.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0d5a573924b26ebf0d1fde296005d23744dbe9/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42235.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr42235.c?ref=dc0d5a573924b26ebf0d1fde296005d23744dbe9", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-options \"-mthumb -O2 -march=armv5te\" }  */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+/* { dg-final { scan-assembler-not \"add\\[\\\\t \\]*r.,\\[\\\\t \\]*r.,\\[\\\\t \\]*\\#1\" } } */\n+/* { dg-final { scan-assembler-not \"add\\[\\\\t \\]*r.,\\[\\\\t \\]*\\#1\" } } */\n+\n+#include <string.h>\n+\n+int foo (char *x)\n+{\n+  memset (x, 0, 6);\n+}"}]}