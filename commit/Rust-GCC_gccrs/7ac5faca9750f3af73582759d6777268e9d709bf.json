{"sha": "7ac5faca9750f3af73582759d6777268e9d709bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2FjNWZhY2E5NzUwZjNhZjczNTgyNzU5ZDY3NzcyNjhlOWQ3MDliZg==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2007-03-02T11:01:19Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-03-02T11:01:19Z"}, "message": "AnnotationInvocationHandler.java: Whitespace only changes.\n\n2007-03-02  Andrew Haley  <aph@redhat.com>\n\n\t* sun/reflect/annotation/AnnotationInvocationHandler.java:\n\tWhitespace only changes.\n\n2007-03-02  Andrew Haley  <aph@redhat.com>\n\n\t* sun/reflect/annotation/AnnotationInvocationHandler.java: Moved\n\tfrom Classpath to libgcj local.\n\nFrom-SVN: r122471", "tree": {"sha": "e3903468047e110a9a0786cf218b4a08d289401d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3903468047e110a9a0786cf218b4a08d289401d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ac5faca9750f3af73582759d6777268e9d709bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac5faca9750f3af73582759d6777268e9d709bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ac5faca9750f3af73582759d6777268e9d709bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ac5faca9750f3af73582759d6777268e9d709bf/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2c6e7979854d03e0153fc702298a6fbbf268eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c6e7979854d03e0153fc702298a6fbbf268eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c6e7979854d03e0153fc702298a6fbbf268eb6"}], "stats": {"total": 658, "additions": 334, "deletions": 324}, "files": [{"sha": "96cdf2dcbdabc770ebae4187c6ad6225d8334383", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac5faca9750f3af73582759d6777268e9d709bf/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac5faca9750f3af73582759d6777268e9d709bf/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=7ac5faca9750f3af73582759d6777268e9d709bf", "patch": "@@ -1,3 +1,13 @@\n+2007-03-02  Andrew Haley  <aph@redhat.com>\n+\n+\t* sun/reflect/annotation/AnnotationInvocationHandler.java:\n+\tWhitespace only changes.\n+\n+2007-03-02  Andrew Haley  <aph@redhat.com>\n+\n+\t* sun/reflect/annotation/AnnotationInvocationHandler.java: Moved\n+\tfrom Classpath to libgcj local.\n+\n 2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>\n \n \t* Makefile.am: Add dummy install-pdf target."}, {"sha": "ccfe86039ccd744f8b019927894d5380e800f3b8", "filename": "libjava/sun/reflect/annotation/AnnotationInvocationHandler.java", "status": "modified", "additions": 324, "deletions": 324, "changes": 648, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ac5faca9750f3af73582759d6777268e9d709bf/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ac5faca9750f3af73582759d6777268e9d709bf/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java?ref=7ac5faca9750f3af73582759d6777268e9d709bf", "patch": "@@ -61,336 +61,336 @@\n public final class AnnotationInvocationHandler\n   implements InvocationHandler, Serializable\n {\n-    private static final long serialVersionUID = 6182022883658399397L;\n-    private final Class type;\n-    private final Map memberValues;\n-\n-    /**\n-     * Construct a new invocation handler for an annotation proxy.\n-     * Note that the VM is responsible for filling the memberValues map\n-     * with the default values of all the annotation members.\n-     */\n-    public AnnotationInvocationHandler(Class type, Map memberValues)\n-    {\n-        this.type = type;\n-        this.memberValues = memberValues;\n-    }\n-\n-    public static Annotation create(Class type, Map memberValues)\n-    {\n-      for (Method m : type.getDeclaredMethods())\n-\t{\n-\t  String name = m.getName();\n-\t  if (! memberValues.containsKey(name))\n-\t    {\n-\t      // FIXME: what to do about exceptions here?\n-\t      memberValues.put(name, m.getDefaultValue());\n-\t    }\n-\t}\n-      AnnotationInvocationHandler handler\n-\t= new AnnotationInvocationHandler(type, memberValues);\n-      return (Annotation) Proxy.newProxyInstance(type.getClassLoader(),\n-\t\t\t\t\t\t new Class[] { type },\n-\t\t\t\t\t\t handler);\n-    }\n-\n-    /**\n-     * Compare an instance of AnnotationInvocationHandler with another object.\n-     * Note that the other object does not have to be an\n-     * AnnotationInvocationHandler, any implementation of the annotation\n-     * interface is allowed to be compared for equality.\n-     * Note that this makes the equals method asymmetric, but this behavior\n-     * is specified by Annotation.equals and identical to the JDK.\n-     *\n-     * This method is public for use by other parts of the VM. Some VMs\n-     * (can) use different representations of annotations that reuse this\n-     * method.\n-     */\n-    public static boolean equals(Class type, Map memberValues, Object other)\n-    {\n-        if (type.isInstance(other))\n-        {\n-            try\n-            {\n-                Method[] methods = type.getDeclaredMethods();\n-                if (methods.length == memberValues.size())\n-                {\n-                    for (int i = 0; i < methods.length; i++)\n-                    {\n-                        String key = methods[i].getName();\n-                        Object val = methods[i].invoke(other, new Object[0]);\n-                        if (! deepEquals(memberValues.get(key), val))\n-                        {\n-                            return false;\n-                        }\n-                    }\n-                    return true;\n-                }\n-            }\n-            catch (IllegalAccessException _)\n-            {\n-                // Ignore exception, like the JDK\n-            }\n-            catch (InvocationTargetException _)\n-            {\n-                // Ignore exception, like the JDK\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static boolean deepEquals(Object o1, Object o2)\n-    {\n-        if (o1 == o2)\n-            return true;\n-\n-        if (o1 == null || o2 == null)\n-            return false;\n-\n-        if (o1 instanceof boolean[] && o2 instanceof boolean[])\n-            return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n-\n-        if (o1 instanceof byte[] && o2 instanceof byte[])\n-            return Arrays.equals((byte[]) o1, (byte[]) o2);\n-\n-        if (o1 instanceof char[] && o2 instanceof char[])\n-            return Arrays.equals((char[]) o1, (char[]) o2);\n-\n-        if (o1 instanceof short[] && o2 instanceof short[])\n-            return Arrays.equals((short[]) o1, (short[]) o2);\n-\n-        if (o1 instanceof int[] && o2 instanceof int[])\n-            return Arrays.equals((int[]) o1, (int[]) o2);\n-\n-        if (o1 instanceof float[] && o2 instanceof float[])\n-            return Arrays.equals((float[]) o1, (float[]) o2);\n-\n-        if (o1 instanceof long[] && o2 instanceof long[])\n-            return Arrays.equals((long[]) o1, (long[]) o2);\n-\n-        if (o1 instanceof double[] && o2 instanceof double[])\n-            return Arrays.equals((double[]) o1, (double[]) o2);\n-\n-        if (o1 instanceof Object[] && o2 instanceof Object[])\n-            return Arrays.equals((Object[]) o1, (Object[]) o2);\n-\n-        return o1.equals(o2);\n-    }\n-\n-    private static int deepHashCode(Object obj)\n-    {\n-        if (obj instanceof boolean[])\n-            return Arrays.hashCode((boolean[]) obj);\n-\n-        if (obj instanceof byte[])\n-            return Arrays.hashCode((byte[]) obj);\n-\n-        if (obj instanceof char[])\n-            return Arrays.hashCode((char[]) obj);\n-\n-        if (obj instanceof short[])\n-            return Arrays.hashCode((short[]) obj);\n-\n-        if (obj instanceof int[])\n-            return Arrays.hashCode((int[]) obj);\n-\n-        if (obj instanceof float[])\n-            return Arrays.hashCode((float[]) obj);\n-\n-        if (obj instanceof long[])\n-            return Arrays.hashCode((long[]) obj);\n-\n-        if (obj instanceof double[])\n-            return Arrays.hashCode((double[]) obj);\n-\n-        if (obj instanceof Object[])\n-            return Arrays.hashCode((Object[]) obj);\n-\n-        return obj.hashCode();\n-    }\n-\n-    /**\n-     * Compute the hashCode for an annotation. Note that the algorithm is\n-     * specified by Annotation.hashCode.\n-     *\n-     * This method is public for use by other parts of the VM. Some VMs\n-     * (can) use different representations of annotations that reuse this\n-     * method.\n-     */\n-    public static int hashCode(Class type, Map memberValues)\n-    {\n-        int h = 0;\n-        Iterator iter = memberValues.keySet().iterator();\n-        while (iter.hasNext())\n-        {\n-            Object key = iter.next();\n-            Object val = memberValues.get(key);\n-            h += deepHashCode(val) ^ 127 * key.hashCode();\n-        }\n-        return h;\n-    }\n-\n-    private static String deepToString(Object obj)\n-    {\n-        if (obj instanceof boolean[])\n-            return Arrays.toString((boolean[]) obj);\n+  private static final long serialVersionUID = 6182022883658399397L;\n+  private final Class type;\n+  private final Map memberValues;\n+\n+  /**\n+   * Construct a new invocation handler for an annotation proxy.\n+   * Note that the VM is responsible for filling the memberValues map\n+   * with the default values of all the annotation members.\n+   */\n+  public AnnotationInvocationHandler(Class type, Map memberValues)\n+  {\n+    this.type = type;\n+    this.memberValues = memberValues;\n+  }\n+\n+  public static Annotation create(Class type, Map memberValues)\n+  {\n+    for (Method m : type.getDeclaredMethods())\n+      {\n+\tString name = m.getName();\n+\tif (! memberValues.containsKey(name))\n+\t  {\n+\t    // FIXME: what to do about exceptions here?\n+\t    memberValues.put(name, m.getDefaultValue());\n+\t  }\n+      }\n+    AnnotationInvocationHandler handler\n+      = new AnnotationInvocationHandler(type, memberValues);\n+    return (Annotation) Proxy.newProxyInstance(type.getClassLoader(),\n+\t\t\t\t\t       new Class[] { type },\n+\t\t\t\t\t       handler);\n+  }\n+\n+  /**\n+   * Compare an instance of AnnotationInvocationHandler with another object.\n+   * Note that the other object does not have to be an\n+   * AnnotationInvocationHandler, any implementation of the annotation\n+   * interface is allowed to be compared for equality.\n+   * Note that this makes the equals method asymmetric, but this behavior\n+   * is specified by Annotation.equals and identical to the JDK.\n+   *\n+   * This method is public for use by other parts of the VM. Some VMs\n+   * (can) use different representations of annotations that reuse this\n+   * method.\n+   */\n+  public static boolean equals(Class type, Map memberValues, Object other)\n+  {\n+    if (type.isInstance(other))\n+      {\n+\ttry\n+\t  {\n+\t    Method[] methods = type.getDeclaredMethods();\n+\t    if (methods.length == memberValues.size())\n+\t      {\n+\t\tfor (int i = 0; i < methods.length; i++)\n+\t\t  {\n+\t\t    String key = methods[i].getName();\n+\t\t    Object val = methods[i].invoke(other, new Object[0]);\n+\t\t    if (! deepEquals(memberValues.get(key), val))\n+\t\t      {\n+\t\t\treturn false;\n+\t\t      }\n+\t\t  }\n+\t\treturn true;\n+\t      }\n+\t  }\n+\tcatch (IllegalAccessException _)\n+\t  {\n+\t    // Ignore exception, like the JDK\n+\t  }\n+\tcatch (InvocationTargetException _)\n+\t  {\n+\t    // Ignore exception, like the JDK\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  private static boolean deepEquals(Object o1, Object o2)\n+  {\n+    if (o1 == o2)\n+      return true;\n+\n+    if (o1 == null || o2 == null)\n+      return false;\n+\n+    if (o1 instanceof boolean[] && o2 instanceof boolean[])\n+      return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n+\n+    if (o1 instanceof byte[] && o2 instanceof byte[])\n+      return Arrays.equals((byte[]) o1, (byte[]) o2);\n+\n+    if (o1 instanceof char[] && o2 instanceof char[])\n+      return Arrays.equals((char[]) o1, (char[]) o2);\n+\n+    if (o1 instanceof short[] && o2 instanceof short[])\n+      return Arrays.equals((short[]) o1, (short[]) o2);\n+\n+    if (o1 instanceof int[] && o2 instanceof int[])\n+      return Arrays.equals((int[]) o1, (int[]) o2);\n+\n+    if (o1 instanceof float[] && o2 instanceof float[])\n+      return Arrays.equals((float[]) o1, (float[]) o2);\n+\n+    if (o1 instanceof long[] && o2 instanceof long[])\n+      return Arrays.equals((long[]) o1, (long[]) o2);\n+\n+    if (o1 instanceof double[] && o2 instanceof double[])\n+      return Arrays.equals((double[]) o1, (double[]) o2);\n+\n+    if (o1 instanceof Object[] && o2 instanceof Object[])\n+      return Arrays.equals((Object[]) o1, (Object[]) o2);\n+\n+    return o1.equals(o2);\n+  }\n+\n+  private static int deepHashCode(Object obj)\n+  {\n+    if (obj instanceof boolean[])\n+      return Arrays.hashCode((boolean[]) obj);\n+\n+    if (obj instanceof byte[])\n+      return Arrays.hashCode((byte[]) obj);\n+\n+    if (obj instanceof char[])\n+      return Arrays.hashCode((char[]) obj);\n+\n+    if (obj instanceof short[])\n+      return Arrays.hashCode((short[]) obj);\n+\n+    if (obj instanceof int[])\n+      return Arrays.hashCode((int[]) obj);\n+\n+    if (obj instanceof float[])\n+      return Arrays.hashCode((float[]) obj);\n+\n+    if (obj instanceof long[])\n+      return Arrays.hashCode((long[]) obj);\n+\n+    if (obj instanceof double[])\n+      return Arrays.hashCode((double[]) obj);\n+\n+    if (obj instanceof Object[])\n+      return Arrays.hashCode((Object[]) obj);\n+\n+    return obj.hashCode();\n+  }\n+\n+  /**\n+   * Compute the hashCode for an annotation. Note that the algorithm is\n+   * specified by Annotation.hashCode.\n+   *\n+   * This method is public for use by other parts of the VM. Some VMs\n+   * (can) use different representations of annotations that reuse this\n+   * method.\n+   */\n+  public static int hashCode(Class type, Map memberValues)\n+  {\n+    int h = 0;\n+    Iterator iter = memberValues.keySet().iterator();\n+    while (iter.hasNext())\n+      {\n+\tObject key = iter.next();\n+\tObject val = memberValues.get(key);\n+\th += deepHashCode(val) ^ 127 * key.hashCode();\n+      }\n+    return h;\n+  }\n+\n+  private static String deepToString(Object obj)\n+  {\n+    if (obj instanceof boolean[])\n+      return Arrays.toString((boolean[]) obj);\n \n-        if (obj instanceof byte[])\n-            return Arrays.toString((byte[]) obj);\n+    if (obj instanceof byte[])\n+      return Arrays.toString((byte[]) obj);\n \n-        if (obj instanceof char[])\n-            return Arrays.toString((char[]) obj);\n+    if (obj instanceof char[])\n+      return Arrays.toString((char[]) obj);\n \n-        if (obj instanceof short[])\n-            return Arrays.toString((short[]) obj);\n+    if (obj instanceof short[])\n+      return Arrays.toString((short[]) obj);\n \n-        if (obj instanceof int[])\n-            return Arrays.toString((int[]) obj);\n+    if (obj instanceof int[])\n+      return Arrays.toString((int[]) obj);\n \n-        if (obj instanceof float[])\n-            return Arrays.toString((float[]) obj);\n+    if (obj instanceof float[])\n+      return Arrays.toString((float[]) obj);\n \n-        if (obj instanceof long[])\n-            return Arrays.toString((long[]) obj);\n+    if (obj instanceof long[])\n+      return Arrays.toString((long[]) obj);\n \n-        if (obj instanceof double[])\n-            return Arrays.toString((double[]) obj);\n+    if (obj instanceof double[])\n+      return Arrays.toString((double[]) obj);\n \n-        if (obj instanceof Object[])\n-            return Arrays.toString((Object[]) obj);\n-\n-        return obj.toString();\n-    }\n-\n-    /**\n-     * This method is public for use by other parts of the VM. Some VMs\n-     * (can) use different representations of annotations that reuse this\n-     * method.\n-     */\n-    public static String toString(Class type, Map memberValues)\n-    {\n-        StringBuffer sb = new StringBuffer();\n-        sb.append('@').append(type.getName()).append('(');\n-        String sep = \"\";\n-        Iterator iter = memberValues.keySet().iterator();\n-        while (iter.hasNext())\n-        {\n-            Object key = iter.next();\n-            Object val = memberValues.get(key);\n-            sb.append(sep).append(key).append('=').append(deepToString(val));\n-            sep = \", \";\n-        }\n-        sb.append(')');\n-        return sb.toString();\n-    }\n-\n-    private static Class getBoxedReturnType(Method method)\n-    {\n-        Class returnType = method.getReturnType();\n-\n-        if (returnType == boolean.class)\n-            return Boolean.class;\n-\n-        if (returnType == byte.class)\n-            return Byte.class;\n-\n-        if (returnType == char.class)\n-            return Character.class;\n-\n-        if (returnType == short.class)\n-            return Short.class;\n-\n-        if (returnType == int.class)\n-            return Integer.class;\n-\n-        if (returnType == float.class)\n-            return Float.class;\n-\n-        if (returnType == long.class)\n-            return Long.class;\n-\n-        if (returnType == double.class)\n-            return Double.class;\n-\n-        return returnType;\n-    }\n-\n-    private Object arrayClone(Object obj)\n-    {\n-        if (obj instanceof boolean[])\n-\t    return ((boolean[]) obj).clone();\n-\n-        if (obj instanceof byte[])\n-\t    return ((byte[]) obj).clone();\n-\n-        if (obj instanceof char[])\n-\t    return ((char[]) obj).clone();\n-\n-        if (obj instanceof short[])\n-\t    return ((short[]) obj).clone();\n-\n-        if (obj instanceof int[])\n-\t    return ((int[]) obj).clone();\n-\n-        if (obj instanceof float[])\n-\t    return ((float[]) obj).clone();\n-\n-        if (obj instanceof long[])\n-\t    return ((long[]) obj).clone();\n-\n-        if (obj instanceof double[])\n-\t    return ((double[]) obj).clone();\n-\n-        if (obj instanceof Object[])\n-\t    return ((Object[]) obj).clone();\n-\n-        return obj;\n-    }\n-\n-    public Object invoke(Object proxy, Method method, Object[] args)\n-      throws Throwable\n-    {\n-        String methodName = method.getName().intern();\n-        if (args == null || args.length == 0)\n-        {\n-            if (methodName == \"toString\")\n-            {\n-                return toString(type, memberValues);\n-            }\n-            else if (methodName == \"hashCode\")\n-            {\n-                return Integer.valueOf(hashCode(type, memberValues));\n-            }\n-            else if (methodName == \"annotationType\")\n-            {\n-                return type;\n-            }\n-            else\n-            {\n-                Object val = memberValues.get(methodName);\n-                if (val == null)\n-                {\n-                    throw new IncompleteAnnotationException(type, methodName);\n-                }\n-                if (! getBoxedReturnType(method).isInstance(val))\n-                {\n-                    throw new AnnotationTypeMismatchException(method,\n-                        val.getClass().getName());\n-                }\n-\t\tif (val.getClass().isArray())\n-\t\t{\n-\t\t    val = arrayClone(val);\n-\t\t}\n-                return val;\n-            }\n-        }\n-        else if (args.length == 1)\n-        {\n-            if (methodName == \"equals\")\n-            {\n-                return Boolean.valueOf(equals(type, memberValues, args[0]));\n-            }\n-        }\n-        throw new InternalError(\"Invalid annotation proxy\");\n-    }\n+    if (obj instanceof Object[])\n+      return Arrays.toString((Object[]) obj);\n+\n+    return obj.toString();\n+  }\n+\n+  /**\n+   * This method is public for use by other parts of the VM. Some VMs\n+   * (can) use different representations of annotations that reuse this\n+   * method.\n+   */\n+  public static String toString(Class type, Map memberValues)\n+  {\n+    StringBuffer sb = new StringBuffer();\n+    sb.append('@').append(type.getName()).append('(');\n+    String sep = \"\";\n+    Iterator iter = memberValues.keySet().iterator();\n+    while (iter.hasNext())\n+      {\n+\tObject key = iter.next();\n+\tObject val = memberValues.get(key);\n+\tsb.append(sep).append(key).append('=').append(deepToString(val));\n+\tsep = \", \";\n+      }\n+    sb.append(')');\n+    return sb.toString();\n+  }\n+\n+  private static Class getBoxedReturnType(Method method)\n+  {\n+    Class returnType = method.getReturnType();\n+\n+    if (returnType == boolean.class)\n+      return Boolean.class;\n+\n+    if (returnType == byte.class)\n+      return Byte.class;\n+\n+    if (returnType == char.class)\n+      return Character.class;\n+\n+    if (returnType == short.class)\n+      return Short.class;\n+\n+    if (returnType == int.class)\n+      return Integer.class;\n+\n+    if (returnType == float.class)\n+      return Float.class;\n+\n+    if (returnType == long.class)\n+      return Long.class;\n+\n+    if (returnType == double.class)\n+      return Double.class;\n+\n+    return returnType;\n+  }\n+\n+  private Object arrayClone(Object obj)\n+  {\n+    if (obj instanceof boolean[])\n+      return ((boolean[]) obj).clone();\n+\n+    if (obj instanceof byte[])\n+      return ((byte[]) obj).clone();\n+\n+    if (obj instanceof char[])\n+      return ((char[]) obj).clone();\n+\n+    if (obj instanceof short[])\n+      return ((short[]) obj).clone();\n+\n+    if (obj instanceof int[])\n+      return ((int[]) obj).clone();\n+\n+    if (obj instanceof float[])\n+      return ((float[]) obj).clone();\n+\n+    if (obj instanceof long[])\n+      return ((long[]) obj).clone();\n+\n+    if (obj instanceof double[])\n+      return ((double[]) obj).clone();\n+\n+    if (obj instanceof Object[])\n+      return ((Object[]) obj).clone();\n+\n+    return obj;\n+  }\n+\n+  public Object invoke(Object proxy, Method method, Object[] args)\n+    throws Throwable\n+  {\n+    String methodName = method.getName().intern();\n+    if (args == null || args.length == 0)\n+      {\n+\tif (methodName == \"toString\")\n+\t  {\n+\t    return toString(type, memberValues);\n+\t  }\n+\telse if (methodName == \"hashCode\")\n+\t  {\n+\t    return Integer.valueOf(hashCode(type, memberValues));\n+\t  }\n+\telse if (methodName == \"annotationType\")\n+\t  {\n+\t    return type;\n+\t  }\n+\telse\n+\t  {\n+\t    Object val = memberValues.get(methodName);\n+\t    if (val == null)\n+\t      {\n+\t\tthrow new IncompleteAnnotationException(type, methodName);\n+\t      }\n+\t    if (! getBoxedReturnType(method).isInstance(val))\n+\t      {\n+\t\tthrow new AnnotationTypeMismatchException(method,\n+\t\t\t\t\t\t\t  val.getClass().getName());\n+\t      }\n+\t    if (val.getClass().isArray())\n+\t      {\n+\t\tval = arrayClone(val);\n+\t      }\n+\t    return val;\n+\t  }\n+      }\n+    else if (args.length == 1)\n+      {\n+\tif (methodName == \"equals\")\n+\t  {\n+\t    return Boolean.valueOf(equals(type, memberValues, args[0]));\n+\t  }\n+      }\n+    throw new InternalError(\"Invalid annotation proxy\");\n+  }\n }"}]}