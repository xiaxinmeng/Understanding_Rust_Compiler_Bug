{"sha": "e10a635c274f90cc2241394b1d17e291adcbf153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEwYTYzNWMyNzRmOTBjYzIyNDEzOTRiMWQxN2UyOTFhZGNiZjE1Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-01T22:52:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-01T22:52:34Z"}, "message": "tree-ssa-ccp.c (ccp_folder): New class derived from substitute_and_fold_engine.\n\n\t* tree-ssa-ccp.c (ccp_folder): New class derived from\n\tsubstitute_and_fold_engine.\n\t(ccp_folder::get_value): New member function.\n\t(ccp_folder::fold_stmt): Renamed from ccp_fold_stmt.\n\t(ccp_fold_stmt): Remove prototype.\n\t(ccp_finalize): Call substitute_and_fold from the ccp_class.\n\t* tree-ssa-copy.c (copy_folder): New class derived from\n\tsubstitute_and_fold_engine.\n\t(copy_folder::get_value): Renamed from get_value.\n\t(fini_copy_prop): Call substitute_and_fold from copy_folder class.\n\t* tree-vrp.c (vrp_folder): New class derived from\n\tsubstitute_and_fold_engine.\n\t(vrp_folder::fold_stmt): Renamed from vrp_fold_stmt.\n\t(vrp_folder::get_value): New member function.\n\t(vrp_finalize): Call substitute_and_fold from vrp_folder class.\n\t(evrp_dom_walker::before_dom_children): Similarly for replace_uses_in.\n\t* tree-ssa-propagate.h (substitute_and_fold_engine): New class to\n\tprovide a class interface to folder/substitute routines.\n\t(ssa_prop_fold_stmt_fn): Remove typedef.\n\t(ssa_prop_get_value_fn): Likewise.\n\t(subsitute_and_fold): Remove prototype.\n\t(replace_uses_in): Likewise.\n\t* tree-ssa-propagate.c (substitute_and_fold_engine::replace_uses_in):\n\tRenamed from replace_uses_in.  Call the virtual member function\n\t(substitute_and_fold_engine::replace_phi_args_in): Similarly.\n\t(substitute_and_fold_dom_walker): Remove initialization of\n\tdata member entries for calbacks.  Add substitute_and_fold_engine\n\tmember and initialize it.\n\t(substitute_and_fold_dom_walker::before_dom_children0: Use the\n\tmember functions for get_value, replace_phi_args_in c\n\treplace_uses_in, and fold_stmt calls.\n\t(substitute_and_fold_engine::substitute_and_fold): Renamed from\n\tsubstitute_and_fold.  Remove assert.   Update ctor call.\n\nFrom-SVN: r254330", "tree": {"sha": "9ebad3083f2dd86e7aad41a9fa1673917493aea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ebad3083f2dd86e7aad41a9fa1673917493aea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e10a635c274f90cc2241394b1d17e291adcbf153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10a635c274f90cc2241394b1d17e291adcbf153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e10a635c274f90cc2241394b1d17e291adcbf153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e10a635c274f90cc2241394b1d17e291adcbf153/comments", "author": null, "committer": null, "parents": [{"sha": "d9a3704a0bc83286afc179bc5e638ad6f7460bb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9a3704a0bc83286afc179bc5e638ad6f7460bb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9a3704a0bc83286afc179bc5e638ad6f7460bb3"}], "stats": {"total": 173, "additions": 124, "deletions": 49}, "files": [{"sha": "d91f77058b671f95c0a77b6ca4dce47aa21cde55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e10a635c274f90cc2241394b1d17e291adcbf153", "patch": "@@ -1,5 +1,39 @@\n 2017-11-01  Jeff Law  <law@redhat.com>\n \n+\t* tree-ssa-ccp.c (ccp_folder): New class derived from\n+\tsubstitute_and_fold_engine.\n+\t(ccp_folder::get_value): New member function.\n+\t(ccp_folder::fold_stmt): Renamed from ccp_fold_stmt.\n+\t(ccp_fold_stmt): Remove prototype.\n+\t(ccp_finalize): Call substitute_and_fold from the ccp_class.\n+\t* tree-ssa-copy.c (copy_folder): New class derived from\n+\tsubstitute_and_fold_engine.\n+\t(copy_folder::get_value): Renamed from get_value.\n+\t(fini_copy_prop): Call substitute_and_fold from copy_folder class.\n+\t* tree-vrp.c (vrp_folder): New class derived from\n+\tsubstitute_and_fold_engine.\n+\t(vrp_folder::fold_stmt): Renamed from vrp_fold_stmt.\n+\t(vrp_folder::get_value): New member function.\n+\t(vrp_finalize): Call substitute_and_fold from vrp_folder class.\n+\t(evrp_dom_walker::before_dom_children): Similarly for replace_uses_in.\n+\t* tree-ssa-propagate.h (substitute_and_fold_engine): New class to\n+\tprovide a class interface to folder/substitute routines.\n+\t(ssa_prop_fold_stmt_fn): Remove typedef.\n+\t(ssa_prop_get_value_fn): Likewise.\n+\t(subsitute_and_fold): Remove prototype.\n+\t(replace_uses_in): Likewise.\n+\t* tree-ssa-propagate.c (substitute_and_fold_engine::replace_uses_in):\n+\tRenamed from replace_uses_in.  Call the virtual member function\n+\t(substitute_and_fold_engine::replace_phi_args_in): Similarly.\n+\t(substitute_and_fold_dom_walker): Remove initialization of\n+\tdata member entries for calbacks.  Add substitute_and_fold_engine\n+\tmember and initialize it.\n+\t(substitute_and_fold_dom_walker::before_dom_children0: Use the\n+\tmember functions for get_value, replace_phi_args_in c\n+\treplace_uses_in, and fold_stmt calls.\n+\t(substitute_and_fold_engine::substitute_and_fold): Renamed from\n+\tsubstitute_and_fold.  Remove assert.   Update ctor call.\n+\n \t* tree-ssa-propagate.h (ssa_prop_visit_stmt_fn): Remove typedef.\n \t(ssa_prop_visit_phi_fn): Likewise.\n \t(class ssa_propagation_engine): New class to provide an interface"}, {"sha": "283567c18c35cecba9b8070d875479fc635e182d", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=e10a635c274f90cc2241394b1d17e291adcbf153", "patch": "@@ -188,7 +188,6 @@ static ccp_prop_value_t *const_val;\n static unsigned n_const_val;\n \n static void canonicalize_value (ccp_prop_value_t *);\n-static bool ccp_fold_stmt (gimple_stmt_iterator *);\n static void ccp_lattice_meet (ccp_prop_value_t *, ccp_prop_value_t *);\n \n /* Dump constant propagation value VAL to file OUTF prefixed by PREFIX.  */\n@@ -909,6 +908,24 @@ do_dbg_cnt (void)\n }\n \n \n+/* We want to provide our own GET_VALUE and FOLD_STMT virtual methods.  */\n+class ccp_folder : public substitute_and_fold_engine\n+{\n+ public:\n+  tree get_value (tree) FINAL OVERRIDE;\n+  bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n+};\n+\n+/* This method just wraps GET_CONSTANT_VALUE for now.  Over time\n+   naked calls to GET_CONSTANT_VALUE should be eliminated in favor\n+   of calling member functions.  */\n+\n+tree\n+ccp_folder::get_value (tree op)\n+{\n+  return get_constant_value (op);\n+}\n+\n /* Do final substitution of propagated values, cleanup the flowgraph and\n    free allocated storage.  If NONZERO_P, record nonzero bits.\n \n@@ -967,7 +984,8 @@ ccp_finalize (bool nonzero_p)\n     }\n \n   /* Perform substitutions based on the known constant values.  */\n-  something_changed = substitute_and_fold (get_constant_value, ccp_fold_stmt);\n+  class ccp_folder ccp_folder;\n+  something_changed = ccp_folder.substitute_and_fold ();\n \n   free (const_val);\n   const_val = NULL;\n@@ -2176,8 +2194,8 @@ fold_builtin_alloca_with_align (gimple *stmt)\n /* Fold the stmt at *GSI with CCP specific information that propagating\n    and regular folding does not catch.  */\n \n-static bool\n-ccp_fold_stmt (gimple_stmt_iterator *gsi)\n+bool\n+ccp_folder::fold_stmt (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n "}, {"sha": "1f9dbf523460e0bb19c322129eed1bb3501a777a", "filename": "gcc/tree-ssa-copy.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-copy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-copy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-copy.c?ref=e10a635c274f90cc2241394b1d17e291adcbf153", "patch": "@@ -489,10 +489,16 @@ init_copy_prop (void)\n     }\n }\n \n+class copy_folder : public substitute_and_fold_engine\n+{\n+ public:\n+  tree get_value (tree) FINAL OVERRIDE;\n+};\n+\n /* Callback for substitute_and_fold to get at the final copy-of values.  */\n \n-static tree\n-get_value (tree name)\n+tree\n+copy_folder::get_value (tree name)\n {\n   tree val;\n   if (SSA_NAME_VERSION (name) >= n_copy_of)\n@@ -557,7 +563,8 @@ fini_copy_prop (void)\n \t}\n     }\n \n-  bool changed = substitute_and_fold (get_value, NULL);\n+  class copy_folder copy_folder;\n+  bool changed = copy_folder.substitute_and_fold ();\n   if (changed)\n     {\n       free_numbers_of_iterations_estimates (cfun);"}, {"sha": "62955bef9c585fdab089a6c0bba791cbfb22c0f5", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=e10a635c274f90cc2241394b1d17e291adcbf153", "patch": "@@ -853,7 +853,7 @@ static struct prop_stats_d prop_stats;\n    PROP_VALUE. Return true if at least one reference was replaced.  */\n \n bool\n-replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value)\n+substitute_and_fold_engine::replace_uses_in (gimple *stmt)\n {\n   bool replaced = false;\n   use_operand_p use;\n@@ -862,7 +862,7 @@ replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value)\n   FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)\n     {\n       tree tuse = USE_FROM_PTR (use);\n-      tree val = (*get_value) (tuse);\n+      tree val = get_value (tuse);\n \n       if (val == tuse || val == NULL_TREE)\n \tcontinue;\n@@ -891,8 +891,8 @@ replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value)\n /* Replace propagated values into all the arguments for PHI using the\n    values from PROP_VALUE.  */\n \n-static bool\n-replace_phi_args_in (gphi *phi, ssa_prop_get_value_fn get_value)\n+bool\n+substitute_and_fold_engine::replace_phi_args_in (gphi *phi)\n {\n   size_t i;\n   bool replaced = false;\n@@ -909,7 +909,7 @@ replace_phi_args_in (gphi *phi, ssa_prop_get_value_fn get_value)\n \n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n-\t  tree val = (*get_value) (arg);\n+\t  tree val = get_value (arg);\n \n \t  if (val && val != arg && may_propagate_copy (arg, val))\n \t    {\n@@ -960,10 +960,10 @@ class substitute_and_fold_dom_walker : public dom_walker\n {\n public:\n     substitute_and_fold_dom_walker (cdi_direction direction,\n-\t\t\t\t    ssa_prop_get_value_fn get_value_fn_,\n-\t\t\t\t    ssa_prop_fold_stmt_fn fold_fn_)\n-\t: dom_walker (direction), get_value_fn (get_value_fn_),\n-      fold_fn (fold_fn_), something_changed (false)\n+\t\t\t\t    class substitute_and_fold_engine *engine)\n+\t: dom_walker (direction),\n+          something_changed (false),\n+\t  substitute_and_fold_engine (engine)\n     {\n       stmts_to_remove.create (0);\n       stmts_to_fixup.create (0);\n@@ -979,12 +979,12 @@ class substitute_and_fold_dom_walker : public dom_walker\n     virtual edge before_dom_children (basic_block);\n     virtual void after_dom_children (basic_block) {}\n \n-    ssa_prop_get_value_fn get_value_fn;\n-    ssa_prop_fold_stmt_fn fold_fn;\n     bool something_changed;\n     vec<gimple *> stmts_to_remove;\n     vec<gimple *> stmts_to_fixup;\n     bitmap need_eh_cleanup;\n+\n+    class substitute_and_fold_engine *substitute_and_fold_engine;\n };\n \n edge\n@@ -1001,7 +1001,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \tcontinue;\n       if (res && TREE_CODE (res) == SSA_NAME)\n \t{\n-\t  tree sprime = get_value_fn (res);\n+\t  tree sprime = substitute_and_fold_engine->get_value (res);\n \t  if (sprime\n \t      && sprime != res\n \t      && may_propagate_copy (res, sprime))\n@@ -1010,7 +1010,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t      continue;\n \t    }\n \t}\n-      something_changed |= replace_phi_args_in (phi, get_value_fn);\n+      something_changed |= substitute_and_fold_engine->replace_phi_args_in (phi);\n     }\n \n   /* Propagate known values into stmts.  In some case it exposes\n@@ -1027,7 +1027,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       tree lhs = gimple_get_lhs (stmt);\n       if (lhs && TREE_CODE (lhs) == SSA_NAME)\n \t{\n-\t  tree sprime = get_value_fn (lhs);\n+\t  tree sprime = substitute_and_fold_engine->get_value (lhs);\n \t  if (sprime\n \t      && sprime != lhs\n \t      && may_propagate_copy (lhs, sprime)\n@@ -1056,7 +1056,7 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n \t\t\t   && gimple_call_noreturn_p (stmt));\n \n       /* Replace real uses in the statement.  */\n-      did_replace |= replace_uses_in (stmt, get_value_fn);\n+      did_replace |= substitute_and_fold_engine->replace_uses_in (stmt);\n \n       /* If we made a replacement, fold the statement.  */\n       if (did_replace)\n@@ -1069,16 +1069,13 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n       /* Some statements may be simplified using propagator\n \t specific information.  Do this before propagating\n \t into the stmt to not disturb pass specific information.  */\n-      if (fold_fn)\n+      update_stmt_if_modified (stmt);\n+      if (substitute_and_fold_engine->fold_stmt(&i))\n \t{\n-\t  update_stmt_if_modified (stmt);\n-\t  if ((*fold_fn)(&i))\n-\t    {\n-\t      did_replace = true;\n-\t      prop_stats.num_stmts_folded++;\n-\t      stmt = gsi_stmt (i);\n-\t      gimple_set_modified (stmt, true);\n-\t    }\n+\t  did_replace = true;\n+\t  prop_stats.num_stmts_folded++;\n+\t  stmt = gsi_stmt (i);\n+\t  gimple_set_modified (stmt, true);\n \t}\n \n       /* If this is a control statement the propagator left edges\n@@ -1164,19 +1161,15 @@ substitute_and_fold_dom_walker::before_dom_children (basic_block bb)\n    Return TRUE when something changed.  */\n \n bool\n-substitute_and_fold (ssa_prop_get_value_fn get_value_fn,\n-\t\t     ssa_prop_fold_stmt_fn fold_fn)\n+substitute_and_fold_engine::substitute_and_fold (void)\n {\n-  gcc_assert (get_value_fn);\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nSubstituting values and folding statements\\n\\n\");\n \n   memset (&prop_stats, 0, sizeof (prop_stats));\n \n   calculate_dominance_info (CDI_DOMINATORS);\n-  substitute_and_fold_dom_walker walker(CDI_DOMINATORS,\n-\t\t\t\t\tget_value_fn, fold_fn);\n+  substitute_and_fold_dom_walker walker (CDI_DOMINATORS, this);\n   walker.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n   /* We cannot remove stmts during the BB walk, especially not release"}, {"sha": "629ae770ee8f15435898407a46f0be178d5ad4a4", "filename": "gcc/tree-ssa-propagate.h", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-propagate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-ssa-propagate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.h?ref=e10a635c274f90cc2241394b1d17e291adcbf153", "patch": "@@ -61,25 +61,18 @@ enum ssa_prop_result {\n };\n \n \n-/* Call-back functions used by the value propagation engine.  */\n-typedef bool (*ssa_prop_fold_stmt_fn) (gimple_stmt_iterator *gsi);\n-typedef tree (*ssa_prop_get_value_fn) (tree);\n-\n-\n extern bool valid_gimple_rhs_p (tree);\n extern void move_ssa_defining_stmt_for_defs (gimple *, gimple *);\n extern bool update_gimple_call (gimple_stmt_iterator *, tree, int, ...);\n extern bool update_call_from_tree (gimple_stmt_iterator *, tree);\n extern bool stmt_makes_single_store (gimple *);\n-extern bool substitute_and_fold (ssa_prop_get_value_fn, ssa_prop_fold_stmt_fn);\n extern bool may_propagate_copy (tree, tree);\n extern bool may_propagate_copy_into_stmt (gimple *, tree);\n extern bool may_propagate_copy_into_asm (tree);\n extern void propagate_value (use_operand_p, tree);\n extern void replace_exp (use_operand_p, tree);\n extern void propagate_tree_value (tree *, tree);\n extern void propagate_tree_value_into_stmt (gimple_stmt_iterator *, tree);\n-extern bool replace_uses_in (gimple *stmt, ssa_prop_get_value_fn get_value);\n \n /* Public interface into the SSA propagation engine.  Clients should inherit\n    from this class and provide their own visitors.  */\n@@ -104,4 +97,14 @@ class ssa_propagation_engine\n \n };\n \n+class substitute_and_fold_engine\n+{\n+ public:\n+  bool substitute_and_fold (void);\n+  bool replace_uses_in (gimple *);\n+  virtual bool fold_stmt (gimple_stmt_iterator *) { return false; }\n+  virtual tree get_value (tree) { return NULL_TREE; }\n+  bool replace_phi_args_in (gphi *);\n+};\n+\n #endif /* _TREE_SSA_PROPAGATE_H  */"}, {"sha": "63ee1568990df20ff81dbf4a84176c0a17b6b590", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e10a635c274f90cc2241394b1d17e291adcbf153/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e10a635c274f90cc2241394b1d17e291adcbf153", "patch": "@@ -10530,17 +10530,36 @@ fold_predicate_in (gimple_stmt_iterator *si)\n   return false;\n }\n \n+class vrp_folder : public substitute_and_fold_engine\n+{\n+ public:\n+  tree get_value (tree) FINAL OVERRIDE;\n+  bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n+};\n+\n /* Callback for substitute_and_fold folding the stmt at *SI.  */\n \n-static bool\n-vrp_fold_stmt (gimple_stmt_iterator *si)\n+bool\n+vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n {\n   if (fold_predicate_in (si))\n     return true;\n \n   return simplify_stmt_using_ranges (si);\n }\n \n+/* If OP has a value range with a single constant value return that,\n+   otherwise return NULL_TREE.  This returns OP itself if OP is a\n+   constant.\n+\n+   Implemented as a pure wrapper right now, but this will change.  */\n+\n+tree\n+vrp_folder::get_value (tree op)\n+{\n+  return op_with_constant_singleton_value_range (op);\n+}\n+\n /* Return the LHS of any ASSERT_EXPR where OP appears as the first\n    argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates\n    BB.  If no such ASSERT_EXPR is found, return OP.  */\n@@ -10882,7 +10901,8 @@ vrp_finalize (bool warn_array_bounds_p)\n \t\t\t  wi::to_wide (vr_value[i]->max));\n       }\n \n-  substitute_and_fold (op_with_constant_singleton_value_range, vrp_fold_stmt);\n+  class vrp_folder vrp_folder;\n+  vrp_folder.substitute_and_fold ();\n \n   if (warn_array_bounds && warn_array_bounds_p)\n     check_all_array_refs ();\n@@ -11219,8 +11239,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t}\n \n       /* Try folding stmts with the VR discovered.  */\n-      bool did_replace\n-\t= replace_uses_in (stmt, op_with_constant_singleton_value_range);\n+      class vrp_folder vrp_folder;\n+      bool did_replace = vrp_folder.replace_uses_in (stmt);\n       if (fold_stmt (&gsi, follow_single_use_edges)\n \t  || did_replace)\n \t{"}]}