{"sha": "2ede092bd71ef3748866d32ae7267eb8ff8b15e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVkZTA5MmJkNzFlZjM3NDg4NjZkMzJhZTcyNjdlYjhmZjhiMTVlMg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-09-05T07:52:27Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-09-05T07:52:27Z"}, "message": "checks.adb (Check_Needed): New procedure...\n\n2005-09-01  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Check_Needed): New procedure, deals with removing checks\n\tbased on analysis of short-circuited forms. Also generates warnings for\n\timproper use of non-short-circuited forms.\n\tCode clean ups.\n\nFrom-SVN: r103857", "tree": {"sha": "359619ed3ffb7e6470ef81008d5c53034cf88ca4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/359619ed3ffb7e6470ef81008d5c53034cf88ca4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ede092bd71ef3748866d32ae7267eb8ff8b15e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ede092bd71ef3748866d32ae7267eb8ff8b15e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ede092bd71ef3748866d32ae7267eb8ff8b15e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ede092bd71ef3748866d32ae7267eb8ff8b15e2/comments", "author": null, "committer": null, "parents": [{"sha": "18605ccc2b1bdac4b7ef05c433ef6bff28d78d96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18605ccc2b1bdac4b7ef05c433ef6bff28d78d96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18605ccc2b1bdac4b7ef05c433ef6bff28d78d96"}], "stats": {"total": 418, "additions": 228, "deletions": 190}, "files": [{"sha": "8bb91714202301bbcb13bc18a63cbec6918e3235", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 228, "deletions": 190, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ede092bd71ef3748866d32ae7267eb8ff8b15e2/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ede092bd71ef3748866d32ae7267eb8ff8b15e2/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=2ede092bd71ef3748866d32ae7267eb8ff8b15e2", "patch": "@@ -218,6 +218,30 @@ package body Checks is\n    --  routine. The Do_Static flag indicates that only a static check is\n    --  to be done.\n \n+   type Check_Type is (Access_Check, Division_Check);\n+   function Check_Needed (Nod : Node_Id; Check : Check_Type) return Boolean;\n+   --  This function is used to see if an access or division by zero check is\n+   --  needed. The check is to be applied to a single variable appearing in the\n+   --  source, and N is the node for the reference. If N is not of this form,\n+   --  True is returned with no further processing. If N is of the right form,\n+   --  then further processing determines if the given Check is needed.\n+   --\n+   --  The particular circuit is to see if we have the case of a check that is\n+   --  not needed because it appears in the right operand of a short circuited\n+   --  conditional where the left operand guards the check. For example:\n+   --\n+   --    if Var = 0 or else Q / Var > 12 then\n+   --       ...\n+   --    end if;\n+   --\n+   --  In this example, the division check is not required. At the same time\n+   --  we can issue warnings for suspicious use of non-short-circuited forms,\n+   --  such as:\n+   --\n+   --    if Var = 0 or Q / Var > 12 then\n+   --       ...\n+   --    end if;\n+\n    procedure Find_Check\n      (Expr        : Node_Id;\n       Check_Type  : Character;\n@@ -254,10 +278,6 @@ package body Checks is\n    --  that the access value is non-null, since the checks do not\n    --  not apply to null access values.\n \n-   procedure Install_Null_Excluding_Check (N : Node_Id);\n-   --  Determines whether an access node requires a runtime access check and\n-   --  if so inserts the appropriate run-time check\n-\n    procedure Install_Static_Check (R_Cno : Node_Id; Loc : Source_Ptr);\n    --  Called by Apply_{Length,Range}_Checks to rewrite the tree with the\n    --  Constraint_Error node.\n@@ -380,13 +400,18 @@ package body Checks is\n       elsif Access_Checks_Suppressed (Etype (P)) then\n          return;\n \n-         --  We do not need checks if we are not generating code (i.e. the\n-         --  expander is not active). This is not just an optimization, there\n-         --  are cases (e.g. with pragma Debug) where generating the checks\n-         --  can cause real trouble).\n+      --  We do not need checks if we are not generating code (i.e. the\n+      --  expander is not active). This is not just an optimization, there\n+      --  are cases (e.g. with pragma Debug) where generating the checks\n+      --  can cause real trouble).\n \n       elsif not Expander_Active then\n          return;\n+\n+      --  We do not need checks if not needed because of short circuiting\n+\n+      elsif not Check_Needed (P, Access_Check) then\n+         return;\n       end if;\n \n       --  Case where P is an entity name\n@@ -1360,7 +1385,8 @@ package body Checks is\n \n    begin\n       if Expander_Active\n-        and not Backend_Divide_Checks_On_Target\n+        and then not Backend_Divide_Checks_On_Target\n+        and then Check_Needed (Right, Division_Check)\n       then\n          Determine_Range (Right, ROK, Rlo, Rhi);\n \n@@ -1382,7 +1408,6 @@ package body Checks is\n          --  Test for extremely annoying case of xxx'First divided by -1\n \n          if Do_Overflow_Check (N) then\n-\n             if Nkind (N) = N_Op_Divide\n               and then Is_Signed_Integer_Type (Typ)\n             then\n@@ -2420,6 +2445,121 @@ package body Checks is\n       return Cond;\n    end Build_Discriminant_Checks;\n \n+   ------------------\n+   -- Check_Needed --\n+   ------------------\n+\n+   function Check_Needed (Nod : Node_Id; Check : Check_Type) return Boolean is\n+      N : Node_Id;\n+      P : Node_Id;\n+      K : Node_Kind;\n+      L : Node_Id;\n+      R : Node_Id;\n+\n+   begin\n+      --  Always check if not simple entity\n+\n+      if Nkind (Nod) not in N_Has_Entity\n+        or else not Comes_From_Source (Nod)\n+      then\n+         return True;\n+      end if;\n+\n+      --  Look up tree for short circuit\n+\n+      N := Nod;\n+      loop\n+         P := Parent (N);\n+         K := Nkind (P);\n+\n+         if K not in N_Subexpr then\n+            return True;\n+\n+         --  Or/Or Else case, left operand must be equality test\n+\n+         elsif K = N_Op_Or or else K = N_Or_Else then\n+            exit when N = Right_Opnd (P)\n+              and then Nkind (Left_Opnd (P)) = N_Op_Eq;\n+\n+         --  And/And then case, left operand must be inequality test. Note that\n+         --  at this stage, the expander will have changed a/=b to not (a=b).\n+\n+         elsif K = N_Op_And or else K = N_And_Then then\n+            exit when N = Right_Opnd (P)\n+              and then Nkind (Left_Opnd (P)) = N_Op_Not\n+              and then Nkind (Right_Opnd (Left_Opnd (P))) = N_Op_Eq;\n+         end if;\n+\n+         N := P;\n+      end loop;\n+\n+      --  If we fall through the loop, then we have a conditional with an\n+      --  appropriate test as its left operand. So test further.\n+\n+      L := Left_Opnd (P);\n+\n+      if Nkind (L) = N_Op_Not then\n+         L := Right_Opnd (L);\n+      end if;\n+\n+      R := Right_Opnd (L);\n+      L := Left_Opnd (L);\n+\n+      --  Left operand of test must match original variable\n+\n+      if Nkind (L) not in N_Has_Entity\n+        or else Entity (L) /= Entity (Nod)\n+      then\n+         return True;\n+      end if;\n+\n+      --  Right operand of test mus be key value (zero or null)\n+\n+      case Check is\n+         when Access_Check =>\n+            if Nkind (R) /= N_Null then\n+               return True;\n+            end if;\n+\n+         when Division_Check =>\n+            if not Compile_Time_Known_Value (R)\n+              or else Expr_Value (R) /= Uint_0\n+            then\n+               return True;\n+            end if;\n+      end case;\n+\n+      --  Here we have the optimizable case, warn if not short-circuited\n+\n+      if K = N_Op_And or else K = N_Op_Or then\n+         case Check is\n+            when Access_Check =>\n+               Error_Msg_N\n+                 (\"Constraint_Error may be raised (access check)?\",\n+                  Parent (Nod));\n+            when Division_Check =>\n+               Error_Msg_N\n+                 (\"Constraint_Error may be raised (zero divide)?\",\n+                  Parent (Nod));\n+         end case;\n+\n+         if K = N_Op_And then\n+            Error_Msg_N (\"use `AND THEN` instead of AND?\", P);\n+         else\n+            Error_Msg_N (\"use `OR ELSE` instead of OR?\", P);\n+         end if;\n+\n+         --  If not short-circuited, we need the ckeck\n+\n+         return True;\n+\n+      --  If short-circuited, we can omit the check\n+\n+      else\n+         return False;\n+      end if;\n+   end Check_Needed;\n+\n    -----------------------------------\n    -- Check_Valid_Lvalue_Subscripts --\n    -----------------------------------\n@@ -2467,222 +2607,120 @@ package body Checks is\n       Related_Nod        : Node_Id;\n       Has_Null_Exclusion : Boolean := False;\n \n-      type Msg_Kind is (Components, Formals, Objects);\n-      Msg_K : Msg_Kind := Objects;\n-      --  Used by local subprograms to generate precise error messages\n+   begin\n+      pragma Assert (K = N_Parameter_Specification\n+                       or else K = N_Object_Declaration\n+                       or else K = N_Discriminant_Specification\n+                       or else K = N_Component_Declaration);\n \n-      procedure Check_Must_Be_Access\n-        (Typ                : Entity_Id;\n-         Has_Null_Exclusion : Boolean);\n-      --  ??? local subprograms must have comment on spec\n+      Typ := Etype (Defining_Identifier (N));\n \n-      procedure Check_Already_Null_Excluding_Type\n-        (Typ                : Entity_Id;\n-         Has_Null_Exclusion : Boolean;\n-         Related_Nod        : Node_Id);\n-      --  ??? local subprograms must have comment on spec\n+      pragma Assert (Is_Access_Type (Typ)\n+        or else (K = N_Object_Declaration and then Is_Array_Type (Typ)));\n \n-      procedure Check_Must_Be_Initialized\n-        (N           : Node_Id;\n-         Related_Nod : Node_Id);\n-      --  ??? local subprograms must have comment on spec\n+      case K is\n+         when N_Parameter_Specification =>\n+            Related_Nod        := Parameter_Type (N);\n+            Has_Null_Exclusion := Null_Exclusion_Present (N);\n \n-      procedure Check_Null_Not_Allowed (N : Node_Id);\n-      --  ??? local subprograms must have comment on spec\n+         when N_Object_Declaration =>\n+            Related_Nod        := Object_Definition (N);\n+            Has_Null_Exclusion := Null_Exclusion_Present (N);\n \n-      --  ??? following bodies lack comments\n+         when N_Discriminant_Specification =>\n+            Related_Nod        := Discriminant_Type (N);\n+            Has_Null_Exclusion := Null_Exclusion_Present (N);\n \n-      --------------------------\n-      -- Check_Must_Be_Access --\n-      --------------------------\n+         when N_Component_Declaration =>\n+            if Present (Access_Definition (Component_Definition (N))) then\n+               Related_Nod := Component_Definition (N);\n+               Has_Null_Exclusion :=\n+                 Null_Exclusion_Present\n+                   (Access_Definition (Component_Definition (N)));\n+            else\n+               Related_Nod :=\n+                 Subtype_Indication (Component_Definition (N));\n+               Has_Null_Exclusion :=\n+                 Null_Exclusion_Present (Component_Definition (N));\n+            end if;\n \n-      procedure Check_Must_Be_Access\n-        (Typ                : Entity_Id;\n-         Has_Null_Exclusion : Boolean)\n-      is\n-      begin\n-         if Has_Null_Exclusion\n-           and then not Is_Access_Type (Typ)\n-         then\n-            Error_Msg_N (\"(Ada 2005) must be an access type\", Related_Nod);\n-         end if;\n-      end Check_Must_Be_Access;\n+         when others =>\n+            raise Program_Error;\n+      end case;\n \n-      ---------------------------------------\n-      -- Check_Already_Null_Excluding_Type --\n-      ---------------------------------------\n+      --  Enforce legality rule 3.10 (14/1): A null_exclusion is only allowed\n+      --  of the access subtype does not exclude null.\n \n-      procedure Check_Already_Null_Excluding_Type\n-        (Typ                : Entity_Id;\n-         Has_Null_Exclusion : Boolean;\n-         Related_Nod        : Node_Id)\n-      is\n-      begin\n-         if Has_Null_Exclusion\n-           and then Can_Never_Be_Null (Typ)\n-         then\n-            Error_Msg_N\n-              (\"(Ada 2005) already a null-excluding type\", Related_Nod);\n-         end if;\n-      end Check_Already_Null_Excluding_Type;\n+      if Has_Null_Exclusion\n+        and then Can_Never_Be_Null (Typ)\n \n-      -------------------------------\n-      -- Check_Must_Be_Initialized --\n-      -------------------------------\n+         --  No need to check itypes that have the null-excluding attribute\n+         --  because they were checked at their point of creation\n \n-      procedure Check_Must_Be_Initialized\n-        (N           : Node_Id;\n-         Related_Nod : Node_Id)\n-      is\n-         Expr        : constant Node_Id := Expression (N);\n+        and then not Is_Itype (Typ)\n+      then\n+         Error_Msg_N\n+           (\"(Ada 2005) already a null-excluding type\", Related_Nod);\n+      end if;\n \n-      begin\n-         pragma Assert (Nkind (N) = N_Component_Declaration\n-                          or else Nkind (N) = N_Object_Declaration);\n-\n-         if not Present (Expr) then\n-            case Msg_K is\n-               when Components =>\n-                  Error_Msg_N\n-                    (\"(Ada 2005) null-excluding components must be \" &\n-                     \"initialized\", Related_Nod);\n-\n-               when Formals =>\n-                  Error_Msg_N\n-                    (\"(Ada 2005) null-excluding formals must be initialized\",\n-                     Related_Nod);\n-\n-               when Objects =>\n-                  Error_Msg_N\n-                    (\"(Ada 2005) null-excluding objects must be initialized\",\n-                     Related_Nod);\n-            end case;\n-         end if;\n-      end Check_Must_Be_Initialized;\n+      --  Check that null-excluding objects are always initialized\n+\n+      if K = N_Object_Declaration\n+        and then not Present (Expression (N))\n+      then\n+         --  Add a an expression that assignates null. This node is needed\n+         --  by Apply_Compile_Time_Constraint_Error, that will replace this\n+         --  node by a Constraint_Error node.\n+\n+         Set_Expression (N, Make_Null (Sloc (N)));\n+         Set_Etype (Expression (N), Etype (Defining_Identifier (N)));\n \n-      ----------------------------\n-      -- Check_Null_Not_Allowed --\n-      ----------------------------\n+         Apply_Compile_Time_Constraint_Error\n+           (N      => Expression (N),\n+            Msg    => \"(Ada 2005) null-excluding objects must be initialized?\",\n+            Reason => CE_Null_Not_Allowed);\n+      end if;\n \n-      procedure Check_Null_Not_Allowed (N : Node_Id) is\n+      --  Check that the null value is not used as a single expression to\n+      --  assignate a value to a null-excluding component, formal or object;\n+      --  otherwise generate a warning message at the sloc of Related_Nod and\n+      --  replace Expression (N) by an N_Contraint_Error node.\n+\n+      declare\n          Expr : constant Node_Id := Expression (N);\n \n       begin\n          if Present (Expr)\n            and then Nkind (Expr) = N_Null\n          then\n-            case Msg_K is\n-               when Components =>\n+            case K is\n+               when N_Discriminant_Specification  |\n+                    N_Component_Declaration      =>\n                   Apply_Compile_Time_Constraint_Error\n                      (N      => Expr,\n                       Msg    => \"(Ada 2005) NULL not allowed in\"\n                                   & \" null-excluding components?\",\n-                      Reason => CE_Null_Not_Allowed,\n-                      Rep    => False);\n+                      Reason => CE_Null_Not_Allowed);\n \n-               when Formals =>\n+               when N_Parameter_Specification =>\n                   Apply_Compile_Time_Constraint_Error\n                      (N      => Expr,\n                       Msg    => \"(Ada 2005) NULL not allowed in\"\n                                   & \" null-excluding formals?\",\n-                      Reason => CE_Null_Not_Allowed,\n-                      Rep    => False);\n+                      Reason => CE_Null_Not_Allowed);\n \n-               when Objects =>\n+               when N_Object_Declaration =>\n                   Apply_Compile_Time_Constraint_Error\n                      (N      => Expr,\n                       Msg    => \"(Ada 2005) NULL not allowed in\"\n                                   & \" null-excluding objects?\",\n-                      Reason => CE_Null_Not_Allowed,\n-                      Rep    => False);\n+                      Reason => CE_Null_Not_Allowed);\n+\n+               when others =>\n+                  null;\n             end case;\n          end if;\n-      end Check_Null_Not_Allowed;\n-\n-   --  Start of processing for Null_Exclusion_Static_Checks\n-\n-   begin\n-      pragma Assert (K = N_Component_Declaration\n-                       or else K = N_Parameter_Specification\n-                       or else K = N_Object_Declaration\n-                       or else K = N_Discriminant_Specification\n-                       or else K = N_Allocator);\n-\n-      case K is\n-         when N_Component_Declaration =>\n-            Msg_K := Components;\n-\n-            if not Present (Access_Definition (Component_Definition (N))) then\n-               Has_Null_Exclusion  := Null_Exclusion_Present\n-                                        (Component_Definition (N));\n-               Typ := Etype (Subtype_Indication (Component_Definition (N)));\n-               Related_Nod := Subtype_Indication (Component_Definition (N));\n-               Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n-               Check_Already_Null_Excluding_Type\n-                 (Typ, Has_Null_Exclusion, Related_Nod);\n-               Check_Must_Be_Initialized (N, Related_Nod);\n-            end if;\n-\n-            Check_Null_Not_Allowed (N);\n-\n-         when N_Parameter_Specification =>\n-            Msg_K := Formals;\n-            Has_Null_Exclusion := Null_Exclusion_Present (N);\n-            Typ := Entity (Parameter_Type (N));\n-            Related_Nod := Parameter_Type (N);\n-            Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n-            Check_Already_Null_Excluding_Type\n-              (Typ, Has_Null_Exclusion, Related_Nod);\n-            Check_Null_Not_Allowed (N);\n-\n-         when N_Object_Declaration =>\n-            Msg_K := Objects;\n-\n-            if Nkind (Object_Definition (N)) /= N_Access_Definition then\n-               Has_Null_Exclusion := Null_Exclusion_Present (N);\n-               Typ := Entity (Object_Definition (N));\n-               Related_Nod := Object_Definition (N);\n-               Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n-               Check_Already_Null_Excluding_Type\n-                 (Typ, Has_Null_Exclusion, Related_Nod);\n-               Check_Must_Be_Initialized (N, Related_Nod);\n-            end if;\n-\n-            Check_Null_Not_Allowed (N);\n-\n-         when N_Discriminant_Specification =>\n-            Msg_K := Components;\n-\n-            if Nkind (Discriminant_Type (N)) /= N_Access_Definition then\n-               Has_Null_Exclusion := Null_Exclusion_Present (N);\n-               Typ := Etype (Defining_Identifier (N));\n-               Related_Nod := Discriminant_Type (N);\n-               Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n-               Check_Already_Null_Excluding_Type\n-                 (Typ, Has_Null_Exclusion, Related_Nod);\n-            end if;\n-\n-            Check_Null_Not_Allowed (N);\n-\n-         when N_Allocator =>\n-            Msg_K := Objects;\n-            Has_Null_Exclusion := Null_Exclusion_Present (N);\n-            Typ := Etype (Expression (N));\n-\n-            if Nkind (Expression (N)) = N_Qualified_Expression then\n-               Related_Nod := Subtype_Mark (Expression (N));\n-            else\n-               Related_Nod := Expression (N);\n-            end if;\n-\n-            Check_Must_Be_Access (Typ, Has_Null_Exclusion);\n-            Check_Already_Null_Excluding_Type\n-              (Typ, Has_Null_Exclusion, Related_Nod);\n-            Check_Null_Not_Allowed (N);\n-\n-         when others =>\n-            raise Program_Error;\n-      end case;\n+      end;\n    end Null_Exclusion_Static_Checks;\n \n    ----------------------------------"}]}