{"sha": "7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q4MTAyNzYyYzFiMzdiZDFiMGI1OTc5NWE2N2ZmYzBkYTY2MzFhNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-09-12T15:49:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-09-12T15:49:38Z"}, "message": "re PR debug/50299 (entryval: bigendian 32bit->64bit extension breaks address match)\n\n\tPR debug/50299\n\t* calls.c (load_register_parameters): Use use_reg_mode instead\n\tof use_reg when adding a single register CALL_INSN_FUNCTION_USAGE\n\tentry.\n\t(expand_call): Set EXPR_LIST mode to TYPE_MODE of the argument\n\tfor stack CALL_INSN_FUNCTION_USAGE uses.\n\t* expr.h (use_reg_mode): New prototype.\n\t(use_reg): Changed into inline around use_reg_mode.\n\t* expr.c (use_reg): Renamed to...\n\t(use_reg_mode): ... this.  Added MODE argument, set EXPR_LIST\n\tmode to that mode instead of VOIDmode.\n\t* var-tracking.c (prepare_call_arguments): Don't track parameters\n\twhose EXPR_LIST mode is VOIDmode, BLKmode or X mode isn't convertible\n\tto it using lowpart_subreg.  Convert VALUE and REG/MEM to the\n\tEXPR_LIST mode.\n\nFrom-SVN: r178784", "tree": {"sha": "34a400a54600fe6c44115b7bb2447a9fc4285f81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34a400a54600fe6c44115b7bb2447a9fc4285f81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "886a64f901a20efd755f9fc3e71419902b0cfd41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886a64f901a20efd755f9fc3e71419902b0cfd41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886a64f901a20efd755f9fc3e71419902b0cfd41"}], "stats": {"total": 79, "additions": 58, "deletions": 21}, "files": [{"sha": "a8bc80ad66ce0d77c0b6d30a7b944a9b045862b7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "patch": "@@ -1,3 +1,21 @@\n+2011-09-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/50299\n+\t* calls.c (load_register_parameters): Use use_reg_mode instead\n+\tof use_reg when adding a single register CALL_INSN_FUNCTION_USAGE\n+\tentry.\n+\t(expand_call): Set EXPR_LIST mode to TYPE_MODE of the argument\n+\tfor stack CALL_INSN_FUNCTION_USAGE uses.\n+\t* expr.h (use_reg_mode): New prototype.\n+\t(use_reg): Changed into inline around use_reg_mode.\n+\t* expr.c (use_reg): Renamed to...\n+\t(use_reg_mode): ... this.  Added MODE argument, set EXPR_LIST\n+\tmode to that mode instead of VOIDmode.\n+\t* var-tracking.c (prepare_call_arguments): Don't track parameters\n+\twhose EXPR_LIST mode is VOIDmode, BLKmode or X mode isn't convertible\n+\tto it using lowpart_subreg.  Convert VALUE and REG/MEM to the\n+\tEXPR_LIST mode.\n+\n 2011-09-12  Georg-Johann Lay  <avr@gjlay.de>\n \n \tPR target/43746"}, {"sha": "1413c8d9dd6d51a5d258cb10d6392cf2bd92e1c0", "filename": "gcc/calls.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "patch": "@@ -1756,7 +1756,8 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t  if (GET_CODE (reg) == PARALLEL)\n \t    use_group_regs (call_fusage, reg);\n \t  else if (nregs == -1)\n-\t    use_reg (call_fusage, reg);\n+\t    use_reg_mode (call_fusage, reg,\n+\t\t\t  TYPE_MODE (TREE_TYPE (args[i].tree_value)));\n \t  else if (nregs > 0)\n \t    use_regs (call_fusage, REGNO (reg), nregs);\n \t}\n@@ -2815,10 +2816,10 @@ expand_call (tree exp, rtx target, int ignore)\n \t      }\n \n \t  if (args[i].stack)\n-\t    call_fusage = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t\t\t     gen_rtx_USE (VOIDmode,\n-\t\t\t\t\t\t\t  args[i].stack),\n-\t\t\t\t\t     call_fusage);\n+\t    call_fusage\n+\t      = gen_rtx_EXPR_LIST (TYPE_MODE (TREE_TYPE (args[i].tree_value)),\n+\t\t\t\t   gen_rtx_USE (VOIDmode, args[i].stack),\n+\t\t\t\t   call_fusage);\n \t}\n \n       /* If we have a parm that is passed in registers but not in memory"}, {"sha": "e4bb633d717edb4dd014205866f58e1671da9c4d", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "patch": "@@ -2184,13 +2184,12 @@ copy_blkmode_from_reg (rtx tgtblk, rtx srcreg, tree type)\n    to by CALL_FUSAGE.  REG must denote a hard register.  */\n \n void\n-use_reg (rtx *call_fusage, rtx reg)\n+use_reg_mode (rtx *call_fusage, rtx reg, enum machine_mode mode)\n {\n   gcc_assert (REG_P (reg) && REGNO (reg) < FIRST_PSEUDO_REGISTER);\n \n   *call_fusage\n-    = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t gen_rtx_USE (VOIDmode, reg), *call_fusage);\n+    = gen_rtx_EXPR_LIST (mode, gen_rtx_USE (VOIDmode, reg), *call_fusage);\n }\n \n /* Add USE expressions to *CALL_FUSAGE for each of NREGS consecutive regs,"}, {"sha": "16521866bfe1e293e17154da2fb12613108ba0d2", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "patch": "@@ -321,8 +321,16 @@ extern void emit_group_store (rtx, rtx, tree, int);\n /* Copy BLKmode object from a set of registers.  */\n extern rtx copy_blkmode_from_reg (rtx, rtx, tree);\n \n+/* Mark REG as holding a parameter for the next CALL_INSN.\n+   Mode is TYPE_MODE of the non-promoted parameter, or VOIDmode.  */\n+extern void use_reg_mode (rtx *, rtx, enum machine_mode);\n+\n /* Mark REG as holding a parameter for the next CALL_INSN.  */\n-extern void use_reg (rtx *, rtx);\n+static inline void\n+use_reg (rtx *fusage, rtx reg)\n+{\n+  use_reg_mode (fusage, reg, VOIDmode);\n+}\n \n /* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n    for the next CALL_INSN.  */"}, {"sha": "214f58a8ac2d619c02820eb22eca8487bbd8c809", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d8102762c1b37bd1b0b59795a67ffc0da6631a5/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=7d8102762c1b37bd1b0b59795a67ffc0da6631a5", "patch": "@@ -5730,11 +5730,18 @@ prepare_call_arguments (basic_block bb, rtx insn)\n       {\n \trtx item = NULL_RTX;\n \tx = XEXP (XEXP (link, 0), 0);\n-\tif (REG_P (x))\n+\tif (GET_MODE (link) == VOIDmode\n+\t    || GET_MODE (link) == BLKmode\n+\t    || (GET_MODE (link) != GET_MODE (x)\n+\t\t&& (GET_MODE_CLASS (GET_MODE (link)) != MODE_INT\n+\t\t    || GET_MODE_CLASS (GET_MODE (x)) != MODE_INT)))\n+\t  /* Can't do anything for these, if the original type mode\n+\t     isn't known or can't be converted.  */;\n+\telse if (REG_P (x))\n \t  {\n \t    cselib_val *val = cselib_lookup (x, GET_MODE (x), 0, VOIDmode);\n \t    if (val && cselib_preserved_value_p (val))\n-\t      item = gen_rtx_CONCAT (GET_MODE (x), x, val->val_rtx);\n+\t      item = val->val_rtx;\n \t    else if (GET_MODE_CLASS (GET_MODE (x)) == MODE_INT)\n \t      {\n \t\tenum machine_mode mode = GET_MODE (x);\n@@ -5749,10 +5756,7 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t\t    val = cselib_lookup (reg, mode, 0, VOIDmode);\n \t\t    if (val && cselib_preserved_value_p (val))\n \t\t      {\n-\t\t\titem = gen_rtx_CONCAT (GET_MODE (x), x,\n-\t\t\t\t\t       lowpart_subreg (GET_MODE (x),\n-\t\t\t\t\t\t\t       val->val_rtx,\n-\t\t\t\t\t\t\t       mode));\n+\t\t\titem = val->val_rtx;\n \t\t\tbreak;\n \t\t      }\n \t\t  }\n@@ -5776,7 +5780,7 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t      }\n \t    val = cselib_lookup (mem, GET_MODE (mem), 0, VOIDmode);\n \t    if (val && cselib_preserved_value_p (val))\n-\t      item = gen_rtx_CONCAT (GET_MODE (x), copy_rtx (x), val->val_rtx);\n+\t      item = val->val_rtx;\n \t    else if (GET_MODE_CLASS (GET_MODE (mem)) != MODE_INT)\n \t      {\n \t\t/* For non-integer stack argument see also if they weren't\n@@ -5787,15 +5791,22 @@ prepare_call_arguments (basic_block bb, rtx insn)\n \t\t    val = cselib_lookup (adjust_address_nv (mem, imode, 0),\n \t\t\t\t\t imode, 0, VOIDmode);\n \t\t    if (val && cselib_preserved_value_p (val))\n-\t\t      item = gen_rtx_CONCAT (GET_MODE (x), copy_rtx (x),\n-\t\t\t\t\t     lowpart_subreg (GET_MODE (x),\n-\t\t\t\t\t\t\t     val->val_rtx,\n-\t\t\t\t\t\t\t     imode));\n+\t\t      item = lowpart_subreg (GET_MODE (x), val->val_rtx,\n+\t\t\t\t\t     imode);\n \t\t  }\n \t      }\n \t  }\n \tif (item)\n-\t  call_arguments = gen_rtx_EXPR_LIST (VOIDmode, item, call_arguments);\n+\t  {\n+\t    rtx x2 = x;\n+\t    if (GET_MODE (item) != GET_MODE (link))\n+\t      item = lowpart_subreg (GET_MODE (link), item, GET_MODE (item));\n+\t    if (GET_MODE (x2) != GET_MODE (link))\n+\t      x2 = lowpart_subreg (GET_MODE (link), x2, GET_MODE (x2));\n+\t    item = gen_rtx_CONCAT (GET_MODE (link), x2, item);\n+\t    call_arguments\n+\t      = gen_rtx_EXPR_LIST (VOIDmode, item, call_arguments);\n+\t  }\n \tif (t && t != void_list_node)\n \t  {\n \t    tree argtype = TREE_VALUE (t);"}]}