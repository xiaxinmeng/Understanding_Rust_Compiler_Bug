{"sha": "1702d32ea7e8974b5146d445612960e6ddf6dca4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTcwMmQzMmVhN2U4OTc0YjUxNDZkNDQ1NjEyOTYwZTZkZGY2ZGNhNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-05-17T13:58:28Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-05-17T13:58:28Z"}, "message": "init.c (build_new_1): Call suspend_momentary around the creation of values that must be saved for...\n\n\t* init.c (build_new_1): Call suspend_momentary around the creation\n\tof values that must be saved for exception handling.\n\t* parse.y (.build_new_placement): New non-terminal.\n\t(unary_expr, new_placement): Use it.\n\t* parse.c: Regenerated.\n\nFrom-SVN: r19819", "tree": {"sha": "05592e8a3fbd2c06541566ea57838e8f9da71dc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05592e8a3fbd2c06541566ea57838e8f9da71dc8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1702d32ea7e8974b5146d445612960e6ddf6dca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1702d32ea7e8974b5146d445612960e6ddf6dca4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1702d32ea7e8974b5146d445612960e6ddf6dca4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1702d32ea7e8974b5146d445612960e6ddf6dca4/comments", "author": null, "committer": null, "parents": [{"sha": "0211b6ab9e54351f4f27a607f2a477ff939c6e09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0211b6ab9e54351f4f27a607f2a477ff939c6e09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0211b6ab9e54351f4f27a607f2a477ff939c6e09"}], "stats": {"total": 7564, "additions": 3837, "deletions": 3727}, "files": [{"sha": "b18b5d4bc4e4bfc40d4e27e48b9d9fda740ba298", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1702d32ea7e8974b5146d445612960e6ddf6dca4", "patch": "@@ -1,3 +1,11 @@\n+Sun May 17 13:53:48 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* init.c (build_new_1): Call suspend_momentary around the creation\n+\tof values that must be saved for exception handling.\n+\t* parse.y (.build_new_placement): New non-terminal.\n+\t(unary_expr, new_placement): Use it.\n+\t* parse.c: Regenerated.\n+\t\n Sun May 17 12:32:08 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl.c (duplicate_decls): Use CANONICAL_TYPE_VARIANT to compare"}, {"sha": "61b3eafcd2b27fa2910fe83995497b1eb9514bcf", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=1702d32ea7e8974b5146d445612960e6ddf6dca4", "patch": "@@ -2316,10 +2316,20 @@ build_new_1 (exp)\n     }\n   else\n     {\n+      int susp;\n+\n+      if (flag_exceptions)\n+\t/* We will use RVAL when generating an exception handler for\n+\t   this new-expression, so we must save it.  */\n+\tsusp = suspend_momentary ();\n+\n       rval = build_op_new_call\n \t(code, true_type, expr_tree_cons (NULL_TREE, size, placement),\n \t LOOKUP_NORMAL | (use_global_new * LOOKUP_GLOBAL));\n       rval = cp_convert (build_pointer_type (true_type), rval);\n+\n+      if (flag_exceptions)\n+\tresume_momentary (susp);\n     }\n \n   /*        unless an allocation function is declared with an empty  excep-"}, {"sha": "8c290be6e546c00d7c0264e67404126c96882572", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3782, "deletions": 3709, "changes": 7491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=1702d32ea7e8974b5146d445612960e6ddf6dca4"}, {"sha": "81a36d1f91bd1552cb85ab1bfabf308cc98640fe", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1702d32ea7e8974b5146d445612960e6ddf6dca4/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=1702d32ea7e8974b5146d445612960e6ddf6dca4", "patch": "@@ -243,7 +243,7 @@ empty_parms ()\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> operator_name\n %type <ttype> object aggr\n-%type <itype> new delete\n+%type <itype> new delete .begin_new_placement\n /* %type <ttype> primary_no_id */\n %type <ttype> nonmomentary_expr maybe_parmlist\n %type <itype> initdcl0 notype_initdcl0 member_init_list initdcl0_innards\n@@ -1031,16 +1031,29 @@ unary_expr:\n \t| new new_placement new_type_id new_initializer\n \t\t{ $$ = build_new ($2, $3.t, $4, $1); \n \t\t  check_for_new_type (\"new\", $3); }\n-\t| new '(' type_id ')'  %prec EMPTY\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t),\n+        /* The .begin_new_placement in the following rules is\n+\t   necessary to avoid shift/reduce conflicts that lead to\n+\t   mis-parsing some expressions.  Of course, these constructs\n+\t   are not really new-placement and it is bogus to call\n+\t   begin_new_placement.  But, the parser cannot always tell at this\n+\t   point whether the next thing is an expression or a type-id,\n+\t   so there is nothing we can do.  Fortunately,\n+\t   begin_new_placement does nothing harmful.  When we rewrite\n+\t   the parser, this lossage should be removed, of course.  */\n+\t| new '(' .begin_new_placement type_id \n+                { finish_new_placement (NULL_TREE, $3); }\n+\t    ')'  %prec EMPTY\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($4.t),\n \t\t\t\t  NULL_TREE, $1); \n-\t\t  check_for_new_type (\"new\", $3); }\n-\t| new '(' type_id ')' new_initializer\n-\t\t{ $$ = build_new (NULL_TREE, groktypename($3.t), $5, $1); \n-\t\t  check_for_new_type (\"new\", $3); }\n+\t\t  check_for_new_type (\"new\", $4); }\n+\t| new '(' .begin_new_placement type_id \n+                { finish_new_placement (NULL_TREE, $3); }\n+            ')' new_initializer\n+\t\t{ $$ = build_new (NULL_TREE, groktypename($4.t), $7, $1); \n+\t\t  check_for_new_type (\"new\", $4); }\n \t| new new_placement '(' type_id ')'  %prec EMPTY\n \t\t{ $$ = build_new ($2, groktypename($4.t), NULL_TREE, $1); \n-\t\t  check_for_new_type (\"new\", $4); }\n+\t  check_for_new_type (\"new\", $4); }\n \t| new new_placement '(' type_id ')' new_initializer\n \t\t{ $$ = build_new ($2, groktypename($4.t), $6, $1); \n \t\t  check_for_new_type (\"new\", $4); }\n@@ -1061,16 +1074,19 @@ unary_expr:\n \t\t{ $$ = build_x_unary_op (IMAGPART_EXPR, $2); }\n \t;\n \n+.begin_new_placement:\n+                { $$ = begin_new_placement (); }\n+\n new_placement:\n \t  '(' \n-                { $<itype>$ = begin_new_placement (); }\n+\t    .begin_new_placement\n             nonnull_exprlist ')'\n-                { $$ = finish_new_placement ($3, $<itype>1); }\n+                { $$ = finish_new_placement ($3, $2); }\n \t| '{' \n-                { cp_pedwarn (\"old style placement syntax, use () instead\");\n-\t\t  $<itype>$ = begin_new_placement (); }\n+\t    .begin_new_placement\n \t    nonnull_exprlist '}'\n-                { $$ = finish_new_placement ($3, $<itype>1); }\n+                { cp_pedwarn (\"old style placement syntax, use () instead\");\n+\t\t  $$ = finish_new_placement ($3, $2); }\n \t;\n \n new_initializer:\n@@ -2552,14 +2568,17 @@ new_type_id:\n \t\t{ $$.t = build_decl_list ($1.t, NULL_TREE); \n \t\t  $$.new_type_flag = $1.new_type_flag; }\n \t/* GNU extension to allow arrays of arbitrary types with\n-\t   non-constant dimension.  */\n-\t| '(' type_id ')' '[' expr ']'\n+\t   non-constant dimension.  For the use of begin_new_placement\n+\t   here, see the comments in unary_expr above.  */\n+\t| '(' .begin_new_placement type_id \n+                { finish_new_placement (NULL_TREE, $2); }\n+\t   ')' '[' expr ']'\n \t\t{\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n-\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($2.t), $5);\n-\t\t  $$.t = build_decl_list (TREE_PURPOSE ($2.t), $$.t);\n-\t\t  $$.new_type_flag = $2.new_type_flag;\n+\t\t  $$.t = build_parse_node (ARRAY_REF, TREE_VALUE ($3.t), $7);\n+\t\t  $$.t = build_decl_list (TREE_PURPOSE ($3.t), $$.t);\n+\t\t  $$.new_type_flag = $3.new_type_flag;\n \t\t}\n \t;\n "}]}