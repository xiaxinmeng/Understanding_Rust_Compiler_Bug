{"sha": "86a0740499715b497e753af5b73c33ccb934c70b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODZhMDc0MDQ5OTcxNWI0OTdlNzUzYWY1YjczYzMzY2NiOTM0YzcwYg==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2005-07-25T12:05:07Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2005-07-25T12:05:07Z"}, "message": "expr.c (highest_pow2_factor): Make extern.\n\n        * expr.c (highest_pow2_factor): Make extern.\n        * tree-data-ref.c (ptr_decl_may_alias_p): New function.\n        (ptr_ptr_may_alias_p, may_alias_p, record_ptr_differ_p,\n        record_array_differ_p, array_ptr_differ_p): Likewise.\n        (base_object_differ_p): Rename (from array_base_name_differ_p). Support\n        additional cases. Call the above functions.\n        (base_addr_differ_p): Moved from tree-vect-analyze.c. Call\n        base_object_differ_p when there are two base objects. Otherwise, compare\n        base address and offset. Call may_alias_p.\n        (dump_data_reference): Use a correct field name.\n        (analyze_array): Make static. Initialize new data-ref fields.\n        (analyze_indirect_ref): New function.\n        (init_data_ref): Initialize new data-ref fields.\n        (strip_conversion): Moved from tree-vect-analyze.c.\n        (analyze_offset_expr, get_ptr_offset, address_analysis, object_analysis):\n        Likewise.\n        (analyze_offset): New function.\n        (create_data_ref): Likewise.\n        (initialize_data_dependence_relation): Call base_addr_differ_p. Compare\n        dimensions for ARRAY_REFs only.\n        (build_classic_dist_vector): Make static.\n        (access_functions_are_affine_or_constant_p): Call macro to get the\n        address of access functions.\n        (compute_all_dependences): Add new parameter\n        compute_self_and_read_read_dependences. Compute self and read-read\n        dependences if it is true.\n        (find_data_references_in_loop): Call create_data_ref. Initialize new\n        data-ref fields.\n        (compute_data_dependences_for_loop): Add new parameter\n        compute_self_and_read_read_dependences. Remove parameter nb_loops,\n        compute nb_loops. Call compute_all_dependences, build_classic_dist_vector\n        and build_classic_dir_vector with correct parameters.\n        (analyze_all_data_dependences): Call compute_data_dependences_for_loop with\n        correct parameters. Compare dimensions for ARRAY_REFs only.\n        (free_data_refs): Call macro to free access functions.\n        * tree-data-ref.h (struct first_location_in_loop): New structure. Move\n        fields from stmt_vinfo.\n        (struct base_object_info): New structure.\n        (struct data_reference): Move fields to base_object_info. Add fields\n        first_location and object_info for above structures. Move fields from\n        stmt_info: memtag, ptr_info, subvars, misalignment. Add new field aligned_to.\n        Add macros to access the new fields.\n        Update functions declarations.\n        * tree-flow.h (is_aliased_with): Declare.\n        * tree-loop-linear.c (linear_transform_loops): Call\n        compute_data_dependences_for_loop with correct parameters.\n        * tree-ssa-alias.c (is_aliased_with): New function.\n        * tree-vect-analyze.c (vect_get_ptr_offset): Remove.\n        (vect_analyze_offset_expr, vect_base_addr_differ_p): Likewise.\n        (vect_analyze_data_ref_dependence): Get ddr. Remove call to\n        vect_base_addr_differ_p, compute_subscript_distance and\n        build_classic_dist_vector. Add printings. Check absolute value of\n        distance.\n        (vect_analyze_data_ref_dependences): Go through ddrs instead of data-refs.\n        (vect_compute_data_ref_alignment): Get the fields of data-ref instead of\n        stmt. Check aligned_to. Check if the base is aligned. Remove conversion\n        to bytes. Add printing.\n        (vect_compute_data_refs_alignment): Go through loads and stores in one loop.\n        (vect_enhance_data_refs_alignment, vect_analyze_data_refs_alignment,\n        vect_analyze_data_ref_access): Likewise.\n        (vect_analyze_pointer_ref_access): Remove.\n        (vect_address_analysis, vect_object_analysis): Likewise.\n        (vect_analyze_data_refs): Call compute_data_dependences_for_loop to find\n        and analyze data-refs in the loop.\n        * tree-vect-transform.c (vect_create_addr_base_for_vector_ref): Get the\n        fields of data-ref instead of stmt. Add init to the offset from the base.\n        (vect_create_data_ref_ptr): Get the fields of data-ref instead of stmt.\n        (vect_update_init_of_dr): Likewise.\n        (vect_update_inits_of_drs): Go through loads and stores in one loop.\n        * tree-vectorizer.c (new_stmt_vec_info): Remove initialization of removed\n        fields.\n        (new_loop_vec_info): Initialize new fields.\n        (destroy_loop_vec_info): Free new fields.\n        (vect_strip_conversion): Remove.\n        * tree-vectorizer.h (enum verbosity_levels): Add new verbosity level.\n        (struct _loop_vec_info): Unify data_ref_writes and data_ref_reads into\n        datarefs. Add new field ddrs.\n        Add macros for the new fields access.\n        (struct _stmt_vec_info): Remove: base_address, initial_offset, step,\n        base_aligned_p, misalignment, memtag, ptr_info and subvars.\n        Remove their macros.\n        * tree.h (highest_pow2_factor): Declare.\n\nFrom-SVN: r102356", "tree": {"sha": "2c7091212ab12d18c54b6a9e333f0b9450742dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c7091212ab12d18c54b6a9e333f0b9450742dab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86a0740499715b497e753af5b73c33ccb934c70b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a0740499715b497e753af5b73c33ccb934c70b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a0740499715b497e753af5b73c33ccb934c70b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a0740499715b497e753af5b73c33ccb934c70b/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fdfb2046e90d49c41efee579b8b7c76adebd26e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fdfb2046e90d49c41efee579b8b7c76adebd26e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fdfb2046e90d49c41efee579b8b7c76adebd26e"}], "stats": {"total": 3788, "additions": 2446, "deletions": 1342}, "files": [{"sha": "68be3ab65cf165118a5252d619f5de0392ba0115", "filename": "gcc/ChangeLog", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -1,3 +1,88 @@\n+2005-07-25  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* expr.c (highest_pow2_factor): Make extern.\n+\t* tree-data-ref.c (ptr_decl_may_alias_p): New function.\n+\t(ptr_ptr_may_alias_p, may_alias_p, record_ptr_differ_p,\n+\trecord_array_differ_p, array_ptr_differ_p): Likewise.\n+\t(base_object_differ_p): Rename (from array_base_name_differ_p). Support\n+\tadditional cases. Call the above functions.\n+\t(base_addr_differ_p): Moved from tree-vect-analyze.c. Call\n+\tbase_object_differ_p when there are two base objects. Otherwise, compare\n+\tbase address and offset. Call may_alias_p.\n+\t(dump_data_reference): Use a correct field name.\n+\t(analyze_array): Make static. Initialize new data-ref fields.\n+\t(analyze_indirect_ref): New function.\n+\t(init_data_ref): Initialize new data-ref fields.   \n+\t(strip_conversion): Moved from tree-vect-analyze.c. \n+\t(analyze_offset_expr, get_ptr_offset, address_analysis, object_analysis):\n+\tLikewise.\n+\t(analyze_offset): New function.\n+ \t(create_data_ref): Likewise.\n+\t(initialize_data_dependence_relation): Call base_addr_differ_p. Compare\n+\tdimensions for ARRAY_REFs only.\n+\t(build_classic_dist_vector): Make static.\n+\t(access_functions_are_affine_or_constant_p): Call macro to get the\n+\taddress of access functions.\n+\t(compute_all_dependences): Add new parameter\n+\tcompute_self_and_read_read_dependences. Compute self and read-read  \n+\tdependences if it is true.\n+\t(find_data_references_in_loop): Call create_data_ref. Initialize new\n+\tdata-ref fields.\n+\t(compute_data_dependences_for_loop): Add new parameter\n+\tcompute_self_and_read_read_dependences. Remove parameter nb_loops,\n+\tcompute nb_loops. Call compute_all_dependences, build_classic_dist_vector\n+\tand build_classic_dir_vector with correct parameters.\n+\t(analyze_all_data_dependences): Call compute_data_dependences_for_loop with\n+\tcorrect parameters. Compare dimensions for ARRAY_REFs only.\n+\t(free_data_refs): Call macro to free access functions.\n+\t* tree-data-ref.h (struct first_location_in_loop): New structure. Move\n+\tfields from stmt_vinfo.\n+\t(struct base_object_info): New structure.\n+\t(struct data_reference): Move fields to base_object_info. Add fields   \n+\tfirst_location and object_info for above structures. Move fields from\n+\tstmt_info: memtag, ptr_info, subvars, misalignment. Add new field aligned_to.\n+\tAdd macros to access the new fields.\n+\tUpdate functions declarations.\n+\t* tree-flow.h (is_aliased_with): Declare.\n+\t* tree-loop-linear.c (linear_transform_loops): Call\n+\tcompute_data_dependences_for_loop with correct parameters.\n+\t* tree-ssa-alias.c (is_aliased_with): New function.\n+ \t* tree-vect-analyze.c (vect_get_ptr_offset): Remove.\n+\t(vect_analyze_offset_expr, vect_base_addr_differ_p): Likewise.\n+\t(vect_analyze_data_ref_dependence): Get ddr. Remove call to\n+\tvect_base_addr_differ_p, compute_subscript_distance and\n+\tbuild_classic_dist_vector. Add printings. Check absolute value of\n+\tdistance.\n+\t(vect_analyze_data_ref_dependences): Go through ddrs instead of data-refs.\n+\t(vect_compute_data_ref_alignment): Get the fields of data-ref instead of\n+\tstmt. Check aligned_to. Check if the base is aligned. Remove conversion\n+\tto bytes. Add printing.\n+\t(vect_compute_data_refs_alignment): Go through loads and stores in one loop.\n+\t(vect_enhance_data_refs_alignment, vect_analyze_data_refs_alignment,\n+\tvect_analyze_data_ref_access): Likewise.\n+\t(vect_analyze_pointer_ref_access): Remove.\n+\t(vect_address_analysis, vect_object_analysis): Likewise.\n+\t(vect_analyze_data_refs): Call compute_data_dependences_for_loop to find\n+\tand analyze data-refs in the loop.\n+\t* tree-vect-transform.c (vect_create_addr_base_for_vector_ref): Get the  \n+\tfields of data-ref instead of stmt. Add init to the offset from the base.\n+\t(vect_create_data_ref_ptr): Get the fields of data-ref instead of stmt.\n+\t(vect_update_init_of_dr): Likewise.\n+\t(vect_update_inits_of_drs): Go through loads and stores in one loop.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Remove initialization of removed\n+\tfields.\n+\t(new_loop_vec_info): Initialize new fields.\n+\t(destroy_loop_vec_info): Free new fields.\n+\t(vect_strip_conversion): Remove.\n+\t* tree-vectorizer.h (enum verbosity_levels): Add new verbosity level.\n+\t(struct _loop_vec_info): Unify data_ref_writes and data_ref_reads into\n+\tdatarefs. Add new field ddrs. \n+\tAdd macros for the new fields access.\n+\t(struct _stmt_vec_info): Remove: base_address, initial_offset, step,\n+\tbase_aligned_p, misalignment, memtag, ptr_info and subvars.\n+\tRemove their macros.\n+\t* tree.h (highest_pow2_factor): Declare.\n+\n 2005-07-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* calls.c (store_one_arg): Check for sibling call MEM arguments"}, {"sha": "c263ebf95e848f23d9857d72bcfae70f946784f3", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -145,7 +145,6 @@ static void store_constructor (tree, rtx, int, HOST_WIDE_INT);\n static rtx store_field (rtx, HOST_WIDE_INT, HOST_WIDE_INT, enum machine_mode,\n \t\t\ttree, tree, int);\n \n-static unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n static unsigned HOST_WIDE_INT highest_pow2_factor_for_target (tree, tree);\n \n static int is_aligning_offset (tree, tree);\n@@ -6047,7 +6046,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n /* Return the highest power of two that EXP is known to be a multiple of.\n    This is used in updating alignment of MEMs in array references.  */\n \n-static unsigned HOST_WIDE_INT\n+unsigned HOST_WIDE_INT\n highest_pow2_factor (tree exp)\n {\n   unsigned HOST_WIDE_INT c0, c1;"}, {"sha": "4656f1b6b628d85a61c35d85471feec52fd54459", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -1,3 +1,19 @@\n+2005-07-25  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* gcc.dg/vect/vect.exp: Change verbosity level to 4.\n+\t* gfortran.dg/vect/vect.exp, g++.dg/vect/vect.exp: Likewise.\n+\t* gcc.dg/vect/pr20122.c: Add vectorizable version of the loop.\n+\t* gcc.dg/vect/vect-100.c: New test.\n+\t* gcc.dg/vect/vect-101.c, gcc.dg/vect/vect-102.c,\n+\tgcc.dg/vect/vect-103.c, gcc.dg/vect/vect-104.c,\n+\tgcc.dg/vect/vect-105.c, gcc.dg/vect/vect-115.c: Likewise.\n+\t* gcc.dg/vect/vect-116.c: Renamed (from vect-100.c).\n+\t* gcc.dg/vect/vect-43.c: Add vectorizable version of the loop.\n+\t* gcc.dg/vect/vect-91.c: Now 3 loops are vectorizable.\n+\t* gfortran.dg/vect/vect-4.f90: Now vectorizable.\n+\t* gfortran.dg/vect/pr19049.f90: New testcase.\n+\t* g++.dg/vect/pr21218.cc, gcc.dg/tree-ssa/ltrans-8.c: Likewise.\n+\n 2005-07-25  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/execute/20050713-1.c: New test."}, {"sha": "73331d22702ed2ae4d0b27810fbb63edf6017d01", "filename": "gcc/testsuite/g++.dg/vect/pr21218.cc", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr21218.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr21218.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr21218.cc?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+\n+struct A\n+{\n+    double d[2];\n+    double foo(int i) { return d[i]; }\n+};\n+\n+struct B : public A {};\n+\n+void bar(B& b)\n+{\n+    for (int i=0; i<2; ++i)\n+        b.d[i] = b.foo(i);\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "f36310166735210c3121ddf6fd7adf460e393966", "filename": "gcc/testsuite/g++.dg/vect/vect.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fvect.exp?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -40,7 +40,7 @@ set DEFAULT_VECTCFLAGS \"\"\n \n # These flags are used for all targets.\n lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \\\n-  \"-ftree-vectorizer-verbose=3\" \"-fdump-tree-vect-stats\"\n+  \"-ftree-vectorizer-verbose=4\" \"-fdump-tree-vect-stats\"\n \n # Skip these tests for targets that do not support generating vector\n # code.  Set additional target-dependent vector flags, which can be"}, {"sha": "80c9c0180d7b4e19401cb8f95f4107f6f9151166", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-8.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-8.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+double foo(double *a)\n+{\n+       int i,j;\n+       double r = 0.0;\n+      for (i=0; i<8; ++i)\n+               for (j=0; j<8; ++j)\n+                      r += a[j*8+i];\n+       return r;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ "}, {"sha": "a713e5e1fa84f63f9b485ed287fa961117528ab7", "filename": "gcc/testsuite/gcc.dg/vect/pr20122.c", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr20122.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr20122.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr20122.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -7,8 +7,10 @@ typedef short ashort __attribute__ ((__aligned__(16)));\n ashort Kernshort[24];\n static void VecBug(ashort Kernel[8][24]) __attribute__((noinline));\n static void VecBug(ashort Kernel[8][24]);\n+static void VecBug2(ashort Kernel[8][24]) __attribute__((noinline));\n+static void VecBug2(ashort Kernel[8][24]);\n \n-/* Doesn't occur of only inner-loop. */\n+/* Not vectorizable: Kernel may alias Kernshort - a global array.  */\n static void VecBug(ashort Kernel[8][24])\n {\n   int k,i;\n@@ -17,6 +19,21 @@ static void VecBug(ashort Kernel[8][24])\n             Kernshort[i] = Kernel[k][i];\n }\n \n+/* Vectorizable: Kernshort2 is local.  */\n+static void VecBug2(ashort Kernel[8][24])\n+{\n+  int k,i;\n+  ashort Kernshort2[24];\n+    for (k = 0; k<8; k++)\n+        for (i = 0; i<24; i++)\n+            Kernshort2[i] = Kernel[k][i];\n+\n+    for (k = 0; k<8; k++)\n+        for (i = 0; i<24; i++)\n+            if (Kernshort2[i] != Kernel[k][i])\n+                abort ();\n+}\n+\n int main (int argc, char **argv)\n {\n     check_vect ();\n@@ -29,6 +46,7 @@ int main (int argc, char **argv)\n             Kernel[k][i] = 0;\n \n     VecBug(Kernel);\n+    VecBug2(Kernel);\n \n     return 0;\n }"}, {"sha": "c1b9e401897860c5e171819792dde32a6be20831", "filename": "gcc/testsuite/gcc.dg/vect/vect-100.c", "status": "modified", "additions": 65, "deletions": 15, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-100.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -1,28 +1,78 @@\n-/* Assuming we can vectorize char multiplication, here's an execute test.  */\n+/* { dg-require-effective-target vect_int } */\n \n+#include <stdlib.h>\n #include <stdarg.h>\n #include \"tree-vect.h\"\n \n-extern void abort (void);\n-void foo()\n+#define N 9\n+\n+struct extraction\n {\n-  static unsigned char A[256], B[256], C[256];\n+  int a[N];\n+  int b[N];\n+};\n+\n+static int a[N] = {1,2,3,4,5,6,7,8,9};\n+static int b[N] = {2,3,4,5,6,7,8,9,0};\n+\n+int main1 () {\n   int i;\n+  struct extraction *p;\n+  \n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n \n-  for (i = 0; i < 256; ++i)\n-    A[i] = B[i] = i;\n+  /* Not vectorizable: p may alias a and/or b, since they are globals.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      p->a[i] = a[i];\n+      p->b[i] = b[i];\n+    }\n \n-  for (i = 0; i < 256; ++i)\n-    C[i] = A[i] * B[i];\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+    {\n+       if (p->a[i] != a[i] || p->b[i] != b[i])\n+         abort();\n+    }\n \n-  for (i = 0; i < 256; ++i)\n-    if (C[i] != (unsigned char)(i * i))\n-      abort ();\n+  return 0;\n }\n \n-int main()\n-{\n-  check_vect ();\n-  foo();\n+int main2 () {\n+  int i;\n+  int c[N] = {1,2,3,4,5,6,7,8,9};\n+  int d[N] = {2,3,4,5,6,7,8,9,0};\n+  struct extraction *p;\n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n+\n+  /* Vectorizable: c and d are local arrays.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      p->a[i] = c[i];\n+      p->b[i] = d[i];\n+    }\n+\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+    {\n+       if (p->a[i] != c[i] || p->b[i] != d[i])\n+         abort();\n+    }\n+\n   return 0;\n }\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  main1 ();\n+  main2 ();\n+  \n+  return 0;\t\n+}\n+\n+/* Requires versioning.  */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "e195a58af5f85de78460762330021406ca3ad6a3", "filename": "gcc/testsuite/gcc.dg/vect/vect-101.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-101.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-101.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-101.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 9\n+\n+struct extraction\n+{\n+  int a[N];\n+  int b[N];\n+};\n+\n+static int a[N] = {1,2,3,4,5,6,7,8,9};\n+static int b[N] = {2,3,4,5,6,7,8,9,0};\n+\n+int main1 (int x, int y) {\n+  int i;\n+  struct extraction *p;\n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n+\n+  /* Not vectorizable: different unknown offset.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      *((int *)p + x + i) = a[i];\n+      *((int *)p + y + i) = b[i];\n+    }\n+\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+    {\n+       if (p->a[i] != a[i] || p->b[i] != b[i])\n+         abort();\n+    }\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 (0, N);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"can't determine dependence\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "af3261d01f8380b56e61e6f4e750e6b1f28fcdfa", "filename": "gcc/testsuite/gcc.dg/vect/vect-102.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-102.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-102.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-102.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 9\n+\n+struct extraction\n+{\n+  int a[N];\n+  int b[N];\n+};\n+\n+static int a[N] = {1,2,3,4,5,6,7,8,9};\n+static int b[N] = {2,3,4,5,6,7,8,9,9};\n+\n+int main1 (int x, int y) {\n+  int i;\n+  struct extraction *p;\n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n+\n+  for (i = 0; i < N; i++)\n+    {\n+       p->a[i] = a[i];\n+       if (x == 135)\n+\t abort (); /* to avoid vectorization  */\n+    }\n+\n+  /* Not vectorizable: distance 1.  */\n+  for (i = 0; i < N - 1; i++)\n+    {\n+       *((int *)p + x + i) = *((int *)p + x + i + 1);\n+    }\n+\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+    {\n+       if (p->a[i] != b[i])\n+         abort();\n+    }\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 (0, N);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"possible dependence between data-refs\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "effa97e15edffd68fa18934bf415aae92b17fc2e", "filename": "gcc/testsuite/gcc.dg/vect/vect-103.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-103.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,57 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 9\n+\n+struct extraction\n+{\n+  int a[N];\n+  int b[N];\n+};\n+\n+static int a[N] = {1,2,3,4,5,6,7,8,9};\n+static int b[N] = {17,24,7,0,2,3,4,31,82};\n+static int c[N] = {9,17,24,7,0,2,3,4,31};\n+\n+int main1 (int x, int y) {\n+  int i;\n+  struct extraction *p;\n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n+\n+  for (i = 0; i < N; i++)\n+    {\n+       p->a[i] = a[i];\n+       p->b[i] = b[i];\n+       if (x == 135)\n+\t abort (); /* to avoid vectorization  */\n+    }\n+\n+  /* Vectorizable: distance > VF.  */\n+  for (i = 0; i < N; i++)\n+    {\n+       *((int *)p + x + i) = *((int *)p + x + i + 8);\n+    }\n+\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+    {\n+       if (p->a[i] != c[i])\n+         abort();\n+    }\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 (0, N);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"dependence distance modulo vf == 0\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "6d16da6b32e6759fe20c7d59ddf5b5980cbf558a", "filename": "gcc/testsuite/gcc.dg/vect/vect-104.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-104.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-104.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-104.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 3\n+\n+struct extraction\n+{\n+  int a[N][N];\n+  int b[N][N];\n+};\n+\n+static int a[N][N] = {{1,2,3},{4,5,6},{7,8,9}};\n+static int b[N][N] = {{17,24,7},{0,2,3},{4,31,82}};\n+static int c[N][N] = {{1,2,3},{4,6,8},{8,9,9}};\n+\n+int main1 (int x) {\n+  int i,j;\n+  struct extraction *p;\n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n+\n+  for (i = 0; i < N; i++)\n+   {\n+    for (j = 0; j < N; j++)\n+     {\n+       p->a[i][j] = a[i][j];\n+       p->b[i][j] = b[i][j];\n+       if (x == 135)\n+\t abort (); /* to avoid vectorization  */\n+     }\n+   }\n+\n+  /* Not vectorizable: distance = 1.  */\n+  for (i = 1; i < N; i++)\n+  {\n+    for (j = 0; j < N; j++)\n+    {\n+       *((int *)p + x + i + j) = *((int *)p + x + i + j + 1);\n+    }\n+  }\n+\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+   {\n+    for (j = 0; j < N; j++)\n+     {\n+       if (p->a[i][j] != c[i][j])\n+         abort();\n+     }\n+  }\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 (N);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"possible dependence between data-refs\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "c8f8e5b6813522d7caabc744ebf79335bcf317c0", "filename": "gcc/testsuite/gcc.dg/vect/vect-105.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-105.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-105.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-105.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 4\n+\n+struct extraction\n+{\n+  int a[N][N];\n+  int b[N][N];\n+};\n+\n+static int a[N][N] = {{1,2,3,11},{4,5,6,12},{7,8,9,13},{34,45,67,83}};\n+static int b[N][N] = {{17,28,15,23},{0,2,3,24},{4,31,82,25},{29,31,432,256}};\n+static int c[N][N] = {{1,2,3,11},{4,9,13,34},{45,67,83,13},{34,45,67,83}};\n+\n+int main1 (int x) {\n+  int i,j;\n+  struct extraction *p;\n+  p = (struct extraction *) malloc (sizeof (struct extraction));\n+\n+  for (i = 0; i < N; i++)\n+   {\n+    for (j = 0; j < N; j++)\n+     {\n+       p->a[i][j] = a[i][j];\n+       p->b[i][j] = b[i][j];\n+       if (x == 135)\n+\t abort (); /* to avoid vectorization  */\n+     }\n+   }\n+\n+  /* Vectorizable: distance > number of iterations.  */\n+  for (i = 1; i < N; i++)\n+  {\n+    for (j = 0; j < N; j++)\n+    {\n+       *((int *)p + x + i + j) = *((int *)p + x + i + j + 5);\n+    }\n+  }\n+\n+  /* check results: */\n+  for (i = 0; i < N; i++)\n+   {\n+    for (j = 0; j < N; j++)\n+     {\n+       if (p->a[i][j] != c[i][j])\n+         abort();\n+     }\n+  }\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+\n+  return main1 (N);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"possible dependence between data-refs\" 0 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "fe055fb0defc3cc644f41505391a645fbc37b9d5", "filename": "gcc/testsuite/gcc.dg/vect/vect-115.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-115.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-115.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-115.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 16\n+\n+struct s{\n+  int b[N];\n+  int c[N];\n+  int m;\n+};\n+\n+struct t{\n+  struct s strc_s;\n+  int m;\n+};\n+\n+struct test1{\n+  struct t strc_t;\n+  struct t *ptr_t;\n+  int k;\n+  int l;\n+};\n+\n+int main1 ()\n+{\n+  int i;\n+  struct test1 tmp1;\n+  int a[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  struct t tmp2;\n+\n+  tmp1.ptr_t = &tmp2;\n+\n+  /* DR bases comparison: record and array.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.strc_t.strc_s.b[i] = a[i];\n+    }\n+\n+  /* Check results.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (tmp1.strc_t.strc_s.b[i] != a[i])\n+\tabort();\n+    }\n+\n+  /* DR bases comparison: record containing ptr and array.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.ptr_t->strc_s.c[i] = a[i];\n+    }\n+\n+  /* Check results.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (tmp1.ptr_t->strc_s.c[i] != a[i])\n+\tabort();\n+    }\n+\n+    \n+  return 0;\n+}\n+       \n+int main (void)\n+{\n+  check_vect ();\n+    \n+  return main1 ();\n+}\n+          \n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  \n+"}, {"sha": "3b803fc71b6a0fb708c0343f9d83abb68779f503", "filename": "gcc/testsuite/gcc.dg/vect/vect-116.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-116.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-116.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-116.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,28 @@\n+/* Assuming we can vectorize char multiplication, here's an execute test.  */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+extern void abort (void);\n+void foo()\n+{\n+  static unsigned char A[256], B[256], C[256];\n+  int i;\n+\n+  for (i = 0; i < 256; ++i)\n+    A[i] = B[i] = i;\n+\n+  for (i = 0; i < 256; ++i)\n+    C[i] = A[i] * B[i];\n+\n+  for (i = 0; i < 256; ++i)\n+    if (C[i] != (unsigned char)(i * i))\n+      abort ();\n+}\n+\n+int main()\n+{\n+  check_vect ();\n+  foo();\n+  return 0;\n+}"}, {"sha": "12db333b39bbfdf7622dab65277d8fdbbc280a66", "filename": "gcc/testsuite/gcc.dg/vect/vect-43.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-43.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -29,7 +29,7 @@ main1 (afloat * pa)\n   afloat pb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n   afloat pc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n \n-\n+ /* Not vectorizable: pa may alias pb and/or pc, since their addresses escape.  */\n   for (i = 0; i < N; i++)\n     {\n       pa[i] = pb[i] * pc[i];\n@@ -40,6 +40,29 @@ main1 (afloat * pa)\n   return 0;\n }\n \n+int\n+main2 (afloat * pa)\n+{\n+  int i;\n+  afloat pb[N] = {0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57};\n+  afloat pc[N] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19};\n+\n+  /* Vectorizable: pb and pc addresses do not escape.  */\n+  for (i = 0; i < N; i++)\n+    {\n+      pa[i] = pb[i] * pc[i];\n+    }   \n+  \n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (pa[i] != (pb[i] * pc[i]))\n+        abort ();\n+    }\n+  \n+  return 0;\n+}\n+\n int main (void)\n {\n   int i;\n@@ -50,6 +73,7 @@ int main (void)\n   check_vect ();\n \n   main1 (a);\n+  main2 (a);\n   return 0;\n }\n "}, {"sha": "d72bd4c8cf016b90537194e20e339096b59bd8cd", "filename": "gcc/testsuite/gcc.dg/vect/vect-91.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-91.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -11,10 +11,7 @@ extern int a[N];\n /* The alignment of 'pa' is unknown. \n    Yet we do know that both the read access and write access have \n    the same alignment. Peeling to align one of the accesses will \n-   align the other.\n-\n-   Not vectorized yet due to problems in dataref analysis that\n-   are fixed in autovect-branch but not yet in mainline.  */\n+   align the other.  */\n \n int\n main1 (int * pa)\n@@ -60,11 +57,8 @@ main3 ()\n   return 0;\n }\n \n-/* Currently only the loops in main2 and main3 get vectorized. After the merge \n-   of the datarefs-analysis cleanups from autovect-branch to mainline, the loop\n-   in main1 will also be vectorized.  */ \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" { xfail vect_no_int_add } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 3 \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 0 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 2 \"vect\" } } */\n-/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 3 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 3 \"vect\" } } */\n /* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "07b7e946f803bbf0f4f7de20f85369751e3d8097", "filename": "gcc/testsuite/gcc.dg/vect/vect.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect.exp?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -24,7 +24,7 @@ set DEFAULT_VECTCFLAGS \"\"\n \n # These flags are used for all targets.\n lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \\\n-  \"-ftree-vectorizer-verbose=3\" \"-fdump-tree-vect-stats\"\n+  \"-ftree-vectorizer-verbose=4\" \"-fdump-tree-vect-stats\"\n \n # If the target system supports vector instructions, the default action\n # for a test is 'run', otherwise it's 'compile'.  Save current default."}, {"sha": "6c8030cce30dad8c615c54b3114f008876662525", "filename": "gcc/testsuite/gfortran.dg/vect/pr19049.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr19049.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr19049.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr19049.f90?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do compile }\n+! { dg-require-effective-target vect_float }\n+\n+subroutine s111 (ntimes,ld,n,ctime,dtime,a,b,c,d,e,aa,bb,cc) \n+!     linear dependence testing\n+!     no dependence - vectorizable\n+!     but not consecutive access\n+\n+      integer ntimes, ld, n, i, nl\n+      real a(n), b(n), c(n), d(n), e(n), aa(ld,n), bb(ld,n), cc(ld,n)\n+      real t1, t2, second, chksum, ctime, dtime, cs1d\n+      do 1 nl = 1,2*ntimes\n+      do 10 i = 2,n,2\n+         a(i) = a(i-1) + b(i)\n+  10  continue\n+      call dummy(ld,n,a,b,c,d,e,aa,bb,cc,1.)\n+  1   continue\n+      return\n+      end\n+\n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 0 \"vect\" } }\n+! { dg-final { scan-tree-dump-times \"complicated access pattern\" 1 \"vect\" } }\n+! { dg-final { cleanup-tree-dump \"vect\" } }\n+"}, {"sha": "74f4e97678e8d2800e85291fb1461ee36ec25a19", "filename": "gcc/testsuite/gfortran.dg/vect/vect-4.f90", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect-4.f90?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -9,10 +9,8 @@ SUBROUTINE SAXPY(X, Y, A)\n Y = Y + A * X\n END\n \n-! fail to vectorize due to aliasing problems in dataref analysis that are\n-! solved in autvect-branch but not yet in mainline.\n-! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } \n-! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" { xfail *-*-* } } }\n-! { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" { xfail *-*-* } } }\n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } \n+! { dg-final { scan-tree-dump-times \"Alignment of access forced using peeling\" 1 \"vect\" } }\n+! { dg-final { scan-tree-dump-times \"Vectorizing an unaligned access\" 1 \"vect\" } }\n+! { dg-final { scan-tree-dump-times \"accesses have the same alignment.\" 1 \"vect\" } }\n ! { dg-final { cleanup-tree-dump \"vect\" } }"}, {"sha": "7f1ec2d7ce1ca44dd507db275f5acfc5d7487b3a", "filename": "gcc/testsuite/gfortran.dg/vect/vect.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fvect.exp?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -25,7 +25,7 @@ set DEFAULT_VECTCFLAGS \"\"\n \n # These flags are used for all targets.\n lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \\\n-  \"-ftree-vectorizer-verbose=3\" \"-fdump-tree-vect-stats\"\n+  \"-ftree-vectorizer-verbose=4\" \"-fdump-tree-vect-stats\"\n \n # If the target system supports vector instructions, the default action\n # for a test is 'run', otherwise it's 'compile'.  Save current default."}, {"sha": "05361a2fc1628f451dfbbf381bbafd24b354aac7", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1393, "deletions": 84, "changes": 1477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -94,20 +94,195 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n \n+static tree object_analysis (tree, tree, bool, struct data_reference **, \n+\t\t\t     tree *, tree *, tree *, tree *, tree *,\n+\t\t\t     struct ptr_info_def **, subvar_t *);\n+static struct data_reference * init_data_ref (tree, tree, tree, tree, bool, \n+\t\t\t\t\t      tree, tree, tree, tree, tree, \n+\t\t\t\t\t      struct ptr_info_def *,\n+\t\t\t\t\t      enum  data_ref_type);\n+\n+/* Determine if PTR and DECL may alias, the result is put in ALIASED.\n+   Return FALSE if there is no type memory tag for PTR.\n+*/\n+static bool\n+ptr_decl_may_alias_p (tree ptr, tree decl, \n+\t\t      struct data_reference *ptr_dr, \n+\t\t      bool *aliased)\n+{\n+  tree tag;\n+   \n+  gcc_assert (TREE_CODE (ptr) == SSA_NAME && DECL_P (decl));\n+\n+  tag = get_var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+  if (!tag)\n+    tag = DR_MEMTAG (ptr_dr);\n+  if (!tag)\n+    return false;\n+  \n+  *aliased = is_aliased_with (tag, decl);      \n+  return true;\n+}\n+\n+\n+/* Determine if two pointers may alias, the result is put in ALIASED.\n+   Return FALSE if there is no type memory tag for one of the pointers.\n+*/\n+static bool\n+ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b, \n+\t\t     struct data_reference *dra, \n+\t\t     struct data_reference *drb, \n+\t\t     bool *aliased)\n+{  \n+  tree tag_a, tag_b;\n+\n+  tag_a = get_var_ann (SSA_NAME_VAR (ptr_a))->type_mem_tag;\n+  if (!tag_a)\n+    tag_a = DR_MEMTAG (dra);\n+  if (!tag_a)\n+    return false;\n+  tag_b = get_var_ann (SSA_NAME_VAR (ptr_b))->type_mem_tag;\n+  if (!tag_b)\n+    tag_b = DR_MEMTAG (drb);\n+  if (!tag_b)\n+    return false;\n+  *aliased = (tag_a == tag_b);\n+  return true;\n+}\n+\n+\n+/* Determine if BASE_A and BASE_B may alias, the result is put in ALIASED.\n+   Return FALSE if there is no type memory tag for one of the symbols.\n+*/\n+static bool\n+may_alias_p (tree base_a, tree base_b,\n+\t     struct data_reference *dra,\n+\t     struct data_reference *drb,\n+\t     bool *aliased)\n+{\n+  if (TREE_CODE (base_a) == ADDR_EXPR || TREE_CODE (base_b) == ADDR_EXPR)\n+    {\n+      if (TREE_CODE (base_a) == ADDR_EXPR && TREE_CODE (base_b) == ADDR_EXPR)\n+\t{\n+\t *aliased = (TREE_OPERAND (base_a, 0) == TREE_OPERAND (base_b, 0));\n+\t return true;\n+\t}\n+      if (TREE_CODE (base_a) == ADDR_EXPR)\n+\treturn ptr_decl_may_alias_p (base_b, TREE_OPERAND (base_a, 0), drb, \n+\t\t\t\t     aliased);\n+      else\n+\treturn ptr_decl_may_alias_p (base_a, TREE_OPERAND (base_b, 0), dra, \n+\t\t\t\t     aliased);\n+    }\n+\n+  return ptr_ptr_may_alias_p (base_a, base_b, dra, drb, aliased);\n+}\n+\n+\n+/* Determine if a pointer (BASE_A) and a record/union access (BASE_B)\n+   are not aliased. Return TRUE if they differ.  */\n+static bool\n+record_ptr_differ_p (struct data_reference *dra,\n+\t\t     struct data_reference *drb)\n+{\n+  bool aliased;\n+  tree base_a = DR_BASE_OBJECT (dra);\n+  tree base_b = DR_BASE_OBJECT (drb);\n+\n+  if (TREE_CODE (base_b) != COMPONENT_REF)\n+    return false;\n+\n+  /* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.\n+     For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.  \n+     Probably will be unnecessary with struct alias analysis.  */\n+  while (TREE_CODE (base_b) == COMPONENT_REF)\n+     base_b = TREE_OPERAND (base_b, 0);\n+  /* Compare a record/union access (b.c[i] or p->c[i]) and a pointer\n+     ((*q)[i]).  */\n+  if (TREE_CODE (base_a) == INDIRECT_REF\n+      && ((TREE_CODE (base_b) == VAR_DECL\n+\t   && (ptr_decl_may_alias_p (TREE_OPERAND (base_a, 0), base_b, dra, \n+\t\t\t\t     &aliased)\n+\t       && !aliased))\n+\t  || (TREE_CODE (base_b) == INDIRECT_REF\n+\t      && (ptr_ptr_may_alias_p (TREE_OPERAND (base_a, 0), \n+\t\t\t\t       TREE_OPERAND (base_b, 0), dra, drb, \n+\t\t\t\t       &aliased)\n+\t\t  && !aliased))))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+    \n+/* Determine if an array access (BASE_A) and a record/union access (BASE_B)\n+   are not aliased. Return TRUE if they differ.  */\n+static bool\n+record_array_differ_p (struct data_reference *dra,\n+\t\t       struct data_reference *drb)\n+{  \n+  bool aliased;\n+  tree base_a = DR_BASE_OBJECT (dra);\n+  tree base_b = DR_BASE_OBJECT (drb);\n+\n+  if (TREE_CODE (base_b) != COMPONENT_REF)\n+    return false;\n+\n+  /* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.\n+     For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.  \n+     Probably will be unnecessary with struct alias analysis.  */\n+  while (TREE_CODE (base_b) == COMPONENT_REF)\n+     base_b = TREE_OPERAND (base_b, 0);\n+\n+  /* Compare a record/union access (b.c[i] or p->c[i]) and an array access \n+     (a[i]). In case of p->c[i] use alias analysis to verify that p is not\n+     pointing to a.  */\n+  if (TREE_CODE (base_a) == VAR_DECL\n+      && (TREE_CODE (base_b) == VAR_DECL\n+\t  || (TREE_CODE (base_b) == INDIRECT_REF\n+\t      && (ptr_decl_may_alias_p (TREE_OPERAND (base_b, 0), base_a, drb, \n+\t\t\t\t\t&aliased)\n+\t\t  && !aliased))))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+\n+/* Determine if an array access (BASE_A) and a pointer (BASE_B)\n+   are not aliased. Return TRUE if they differ.  */\n+static bool\n+array_ptr_differ_p (tree base_a, tree base_b, \t     \n+\t\t    struct data_reference *drb)\n+{  \n+  bool aliased;\n+\n+  /* In case one of the bases is a pointer (a[i] and (*p)[i]), we check with the\n+     help of alias analysis that p is not pointing to a.  */\n+  if (TREE_CODE (base_a) == VAR_DECL && TREE_CODE (base_b) == INDIRECT_REF \n+      && (ptr_decl_may_alias_p (TREE_OPERAND (base_b, 0), base_a, drb, &aliased)\n+\t  && !aliased))\n+    return true;\n+  else\n+    return false;\n+}\n+\n+\n /* This is the simplest data dependence test: determines whether the\n    data references A and B access the same array/region.  Returns\n    false when the property is not computable at compile time.\n    Otherwise return true, and DIFFER_P will record the result. This\n    utility will not be necessary when alias_sets_conflict_p will be\n    less conservative.  */\n \n-bool\n-array_base_name_differ_p (struct data_reference *a,\n-                          struct data_reference *b,\n-                          bool *differ_p)\n+static bool\n+base_object_differ_p (struct data_reference *a,\n+\t\t      struct data_reference *b,\n+\t\t      bool *differ_p)\n {\n-  tree base_a = DR_BASE_NAME (a);\n-  tree base_b = DR_BASE_NAME (b);\n+  tree base_a = DR_BASE_OBJECT (a);\n+  tree base_b = DR_BASE_OBJECT (b);\n+  bool aliased;\n \n   if (!base_a || !base_b)\n     return false;\n@@ -152,6 +327,26 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n+  /* In case one of the bases is a pointer (a[i] and (*p)[i]), we check with the\n+     help of alias analysis that p is not pointing to a.  */\n+  if (array_ptr_differ_p (base_a, base_b, b) \n+      || array_ptr_differ_p (base_b, base_a, a))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+\n+  /* If the bases are pointers ((*q)[i] and (*p)[i]), we check with the\n+     help of alias analysis they don't point to the same bases.  */\n+  if (TREE_CODE (base_a) == INDIRECT_REF && TREE_CODE (base_b) == INDIRECT_REF \n+      && (may_alias_p (TREE_OPERAND (base_a, 0), TREE_OPERAND (base_b, 0), a, b, \n+\t\t       &aliased)\n+\t  && !aliased))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+\n   /* Compare two record/union bases s.a and t.b: s != t or (a != b and\n      s and t are not unions).  */\n   if (TREE_CODE (base_a) == COMPONENT_REF && TREE_CODE (base_b) == COMPONENT_REF\n@@ -166,13 +361,18 @@ array_base_name_differ_p (struct data_reference *a,\n       return true;\n     }\n \n-  /* Compare a record/union access and an array access.  */ \n-  if ((TREE_CODE (base_a) == VAR_DECL\n-       && (TREE_CODE (base_b) == COMPONENT_REF\n-           && TREE_CODE (TREE_OPERAND (base_b, 0)) == VAR_DECL))\n-      || (TREE_CODE (base_b) == VAR_DECL\n-       && (TREE_CODE (base_a) == COMPONENT_REF\n-           && TREE_CODE (TREE_OPERAND (base_a, 0)) == VAR_DECL)))\n+  /* Compare a record/union access (b.c[i] or p->c[i]) and a pointer\n+     ((*q)[i]).  */\n+  if (record_ptr_differ_p (a, b) || record_ptr_differ_p (b, a))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+\n+  /* Compare a record/union access (b.c[i] or p->c[i]) and an array access \n+     (a[i]). In case of p->c[i] use alias analysis to verify that p is not\n+     pointing to a.  */\n+  if (record_array_differ_p (a, b) || record_array_differ_p (b, a))\n     {\n       *differ_p = true;\n       return true;\n@@ -181,6 +381,90 @@ array_base_name_differ_p (struct data_reference *a,\n   return false;\n }\n \n+/* Function base_addr_differ_p.\n+\n+   This is the simplest data dependence test: determines whether the\n+   data references A and B access the same array/region.  Returns\n+   false when the property is not computable at compile time.\n+   Otherwise return true, and DIFFER_P will record the result. This\n+   utility will not be necessary when alias_sets_conflict_p will be\n+   less conservative.  */\n+\n+\n+static bool\n+base_addr_differ_p (struct data_reference *dra,\n+\t\t    struct data_reference *drb,\n+\t\t    bool *differ_p)\n+{\n+  tree addr_a = DR_BASE_ADDRESS (dra);\n+  tree addr_b = DR_BASE_ADDRESS (drb);\n+  tree type_a, type_b;\n+  bool aliased;\n+\n+  if (!addr_a || !addr_b)\n+    return false;\n+\n+  type_a = TREE_TYPE (addr_a);\n+  type_b = TREE_TYPE (addr_b);\n+\n+  gcc_assert (POINTER_TYPE_P (type_a) &&  POINTER_TYPE_P (type_b));\n+  \n+  /* Compare base objects first if possible. If DR_BASE_OBJECT is NULL, it means\n+     that the data-ref is of INDIRECT_REF, and alias analysis will be applied to \n+     reveal the dependence.  */\n+  if (DR_BASE_OBJECT (dra) && DR_BASE_OBJECT (drb))\n+    return base_object_differ_p (dra, drb, differ_p);\n+\n+  /* If base addresses are the same, we check the offsets, since the access of \n+     the data-ref is described by {base addr + offset} and its access function,\n+     i.e., in order to decide whether the bases of data-refs are the same we \n+     compare both base addresses and offsets.  */\n+  if (addr_a == addr_b \n+      || (TREE_CODE (addr_a) == ADDR_EXPR && TREE_CODE (addr_b) == ADDR_EXPR\n+         && TREE_OPERAND (addr_a, 0) == TREE_OPERAND (addr_b, 0)))\n+    {\n+      /* Compare offsets.  */\n+      tree offset_a = DR_OFFSET (dra); \n+      tree offset_b = DR_OFFSET (drb);\n+      \n+      gcc_assert (!DR_BASE_OBJECT (dra) && !DR_BASE_OBJECT (drb));\n+\n+      STRIP_NOPS (offset_a);\n+      STRIP_NOPS (offset_b);\n+\n+      /* FORNOW: we only compare offsets that are MULT_EXPR, i.e., we don't handle\n+\t PLUS_EXPR.  */\n+      if ((offset_a == offset_b)\n+\t  || (TREE_CODE (offset_a) == MULT_EXPR \n+\t      && TREE_CODE (offset_b) == MULT_EXPR\n+\t      && TREE_OPERAND (offset_a, 0) == TREE_OPERAND (offset_b, 0)\n+\t      && TREE_OPERAND (offset_a, 1) == TREE_OPERAND (offset_b, 1)))\n+\t{\n+\t  *differ_p = false;\n+\t  return true;\n+\t}\n+    }\n+\n+  /* Apply alias analysis.  */\n+  if (may_alias_p (addr_a, addr_b, dra, drb, &aliased) && !aliased)\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+  \n+  /* An instruction writing through a restricted pointer is \"independent\" of any \n+     instruction reading or writing through a different pointer, in the same \n+     block/scope.  */\n+  else if ((TYPE_RESTRICT (type_a) && !DR_IS_READ (dra))\n+      || (TYPE_RESTRICT (type_b) && !DR_IS_READ (drb)))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+\n /* Returns true iff A divides B.  */\n \n static inline bool \n@@ -262,7 +546,7 @@ dump_data_reference (FILE *outf,\n   fprintf (outf, \"  ref: \");\n   print_generic_stmt (outf, DR_REF (dr), 0);\n   fprintf (outf, \"  base_name: \");\n-  print_generic_stmt (outf, DR_BASE_NAME (dr), 0);\n+  print_generic_stmt (outf, DR_BASE_OBJECT (dr), 0);\n   \n   for (i = 0; i < DR_NUM_DIMENSIONS (dr); i++)\n     {\n@@ -546,10 +830,11 @@ analyze_array_indexes (struct loop *loop,\n    set to true when REF is in the right hand side of an\n    assignment.  */\n \n-struct data_reference *\n+static struct data_reference *\n analyze_array (tree stmt, tree ref, bool is_read)\n {\n   struct data_reference *res;\n+  VEC(tree,heap) *acc_fns;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -563,17 +848,96 @@ analyze_array (tree stmt, tree ref, bool is_read)\n   \n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n-  DR_ACCESS_FNS (res) = VEC_alloc (tree, heap, 3);\n-  DR_BASE_NAME (res) = analyze_array_indexes \n-    (loop_containing_stmt (stmt), &(DR_ACCESS_FNS (res)), ref, stmt);\n+  acc_fns = VEC_alloc (tree, heap, 3);\n+  DR_BASE_OBJECT (res) = analyze_array_indexes \n+    (loop_containing_stmt (stmt), &acc_fns, ref, stmt);\n+  DR_TYPE (res) = ARRAY_REF_TYPE;\n+  DR_SET_ACCESS_FNS (res, acc_fns);\n   DR_IS_READ (res) = is_read;\n+  DR_BASE_ADDRESS (res) = NULL_TREE;\n+  DR_OFFSET (res) = NULL_TREE;\n+  DR_INIT (res) = NULL_TREE;\n+  DR_STEP (res) = NULL_TREE;\n+  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n+  DR_MEMTAG (res) = NULL_TREE;\n+  DR_PTR_INFO (res) = NULL;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n   \n   return res;\n }\n \n+\n+/* Analyze an indirect memory reference, REF, that comes from STMT.\n+   IS_READ is true if this is an indirect load, and false if it is\n+   an indirect store.\n+   Return a new data reference structure representing the indirect_ref, or\n+   NULL if we cannot describe the access function.  */\n+  \n+static struct data_reference *\n+analyze_indirect_ref (tree stmt, tree ref, bool is_read) \n+{\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  tree ptr_ref = TREE_OPERAND (ref, 0);\n+  tree access_fn = analyze_scalar_evolution (loop, ptr_ref);\n+  tree init = initial_condition_in_loop_num (access_fn, loop->num);\n+  tree base_address = NULL_TREE, evolution, step = NULL_TREE;\n+  struct ptr_info_def *ptr_info = NULL;\n+\n+  if (TREE_CODE (ptr_ref) == SSA_NAME)\n+    ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n+\n+  STRIP_NOPS (init);   \n+  if (access_fn == chrec_dont_know || !init || init == chrec_dont_know)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"\\nBad access function of ptr: \");\n+\t  print_generic_expr (dump_file, ref, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return NULL;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"\\nAccess function of ptr: \");\n+      print_generic_expr (dump_file, access_fn, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (!expr_invariant_in_loop_p (loop, init))\n+    {\n+    if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"\\ninitial condition is not loop invariant.\\n\");\t\n+    }\n+  else\n+    {\n+      base_address = init;\n+      evolution = evolution_part_in_loop_num (access_fn, loop->num);\n+      if (evolution != chrec_dont_know)\n+\t{       \n+\t  if (!evolution)\n+\t    step = ssize_int (0);\n+\t  else  \n+\t    {\n+\t      if (TREE_CODE (evolution) == INTEGER_CST)\n+\t\tstep = fold_convert (ssizetype, evolution);\n+\t      else\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  fprintf (dump_file, \"\\nnon constant step for ptr access.\\n\");\t\n+\t    }\n+\t}\n+      else\n+\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t  fprintf (dump_file, \"\\nunknown evolution of ptr.\\n\");\t\n+    }\n+  return init_data_ref (stmt, ref, NULL_TREE, access_fn, is_read, base_address, \n+\t\t\tNULL_TREE, step, NULL_TREE, NULL_TREE, \n+\t\t\tptr_info, POINTER_REF_TYPE);\n+}\n+\n /* For a data reference REF contained in the statement STMT, initialize\n    a DATA_REFERENCE structure, and return it.  */\n \n@@ -582,9 +946,17 @@ init_data_ref (tree stmt,\n \t       tree ref,\n \t       tree base,\n \t       tree access_fn,\n-\t       bool is_read)\n+\t       bool is_read,\n+\t       tree base_address,\n+\t       tree init_offset,\n+\t       tree step,\n+\t       tree misalign,\n+\t       tree memtag,\n+               struct ptr_info_def *ptr_info,\n+\t       enum data_ref_type type)\n {\n   struct data_reference *res;\n+  VEC(tree,heap) *acc_fns;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -598,10 +970,19 @@ init_data_ref (tree stmt,\n   \n   DR_STMT (res) = stmt;\n   DR_REF (res) = ref;\n-  DR_ACCESS_FNS (res) = VEC_alloc (tree, heap, 5);\n-  DR_BASE_NAME (res) = base;\n+  DR_BASE_OBJECT (res) = base;\n+  DR_TYPE (res) = type;\n+  acc_fns = VEC_alloc (tree, heap, 3);\n+  DR_SET_ACCESS_FNS (res, acc_fns);\n   VEC_quick_push (tree, DR_ACCESS_FNS (res), access_fn);\n   DR_IS_READ (res) = is_read;\n+  DR_BASE_ADDRESS (res) = base_address;\n+  DR_OFFSET (res) = init_offset;\n+  DR_INIT (res) = NULL_TREE;\n+  DR_STEP (res) = step;\n+  DR_OFFSET_MISALIGNMENT (res) = misalign;\n+  DR_MEMTAG (res) = memtag;\n+  DR_PTR_INFO (res) = ptr_info;\n   \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n@@ -611,6 +992,869 @@ init_data_ref (tree stmt,\n \n \f\n \n+/* Function strip_conversions\n+\n+   Strip conversions that don't narrow the mode.  */\n+\n+static tree \n+strip_conversion (tree expr)\n+{\n+  tree to, ti, oprnd0;\n+  \n+  while (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n+    {\n+      to = TREE_TYPE (expr);\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      ti = TREE_TYPE (oprnd0);\n+ \n+      if (!INTEGRAL_TYPE_P (to) || !INTEGRAL_TYPE_P (ti))\n+\treturn NULL_TREE;\n+      if (GET_MODE_SIZE (TYPE_MODE (to)) < GET_MODE_SIZE (TYPE_MODE (ti)))\n+\treturn NULL_TREE;\n+      \n+      expr = oprnd0;\n+    }\n+  return expr; \n+}\n+\f\n+\n+/* Function analyze_offset_expr\n+\n+   Given an offset expression EXPR received from get_inner_reference, analyze\n+   it and create an expression for INITIAL_OFFSET by substituting the variables \n+   of EXPR with initial_condition of the corresponding access_fn in the loop. \n+   E.g., \n+      for i\n+         for (j = 3; j < N; j++)\n+            a[j].b[i][j] = 0;\n+\t \n+   For a[j].b[i][j], EXPR will be 'i * C_i + j * C_j + C'. 'i' cannot be \n+   substituted, since its access_fn in the inner loop is i. 'j' will be \n+   substituted with 3. An INITIAL_OFFSET will be 'i * C_i + C`', where\n+   C` =  3 * C_j + C.\n+\n+   Compute MISALIGN (the misalignment of the data reference initial access from\n+   its base). Misalignment can be calculated only if all the variables can be \n+   substituted with constants, otherwise, we record maximum possible alignment\n+   in ALIGNED_TO. In the above example, since 'i' cannot be substituted, MISALIGN \n+   will be NULL_TREE, and the biggest divider of C_i (a power of 2) will be \n+   recorded in ALIGNED_TO.\n+\n+   STEP is an evolution of the data reference in this loop in bytes.\n+   In the above example, STEP is C_j.\n+\n+   Return FALSE, if the analysis fails, e.g., there is no access_fn for a \n+   variable. In this case, all the outputs (INITIAL_OFFSET, MISALIGN, ALIGNED_TO\n+   and STEP) are NULL_TREEs. Otherwise, return TRUE.\n+\n+*/\n+\n+static bool\n+analyze_offset_expr (tree expr, \n+\t\t     struct loop *loop, \n+\t\t     tree *initial_offset,\n+\t\t     tree *misalign,\n+\t\t     tree *aligned_to,\n+\t\t     tree *step)\n+{\n+  tree oprnd0;\n+  tree oprnd1;\n+  tree left_offset = ssize_int (0);\n+  tree right_offset = ssize_int (0);\n+  tree left_misalign = ssize_int (0);\n+  tree right_misalign = ssize_int (0);\n+  tree left_step = ssize_int (0);\n+  tree right_step = ssize_int (0);\n+  enum tree_code code;\n+  tree init, evolution;\n+  tree left_aligned_to = NULL_TREE, right_aligned_to = NULL_TREE;\n+\n+  *step = NULL_TREE;\n+  *misalign = NULL_TREE;\n+  *aligned_to = NULL_TREE;  \n+  *initial_offset = NULL_TREE;\n+\n+  /* Strip conversions that don't narrow the mode.  */\n+  expr = strip_conversion (expr);\n+  if (!expr)\n+    return false;\n+\n+  /* Stop conditions:\n+     1. Constant.  */\n+  if (TREE_CODE (expr) == INTEGER_CST)\n+    {\n+      *initial_offset = fold_convert (ssizetype, expr);\n+      *misalign = fold_convert (ssizetype, expr);      \n+      *step = ssize_int (0);\n+      return true;\n+    }\n+\n+  /* 2. Variable. Try to substitute with initial_condition of the corresponding\n+     access_fn in the current loop.  */\n+  if (SSA_VAR_P (expr))\n+    {\n+      tree access_fn = analyze_scalar_evolution (loop, expr);\n+\n+      if (access_fn == chrec_dont_know)\n+\t/* No access_fn.  */\n+\treturn false;\n+\n+      init = initial_condition_in_loop_num (access_fn, loop->num);\n+      if (init == expr && !expr_invariant_in_loop_p (loop, init))\n+\t/* Not enough information: may be not loop invariant.  \n+\t   E.g., for a[b[i]], we get a[D], where D=b[i]. EXPR is D, its \n+\t   initial_condition is D, but it depends on i - loop's induction\n+\t   variable.  */\t  \n+\treturn false;\n+\n+      evolution = evolution_part_in_loop_num (access_fn, loop->num);\n+      if (evolution && TREE_CODE (evolution) != INTEGER_CST)\n+\t/* Evolution is not constant.  */\n+\treturn false;\n+\n+      if (TREE_CODE (init) == INTEGER_CST)\n+\t*misalign = fold_convert (ssizetype, init);\n+      else\n+\t/* Not constant, misalignment cannot be calculated.  */\n+\t*misalign = NULL_TREE;\n+\n+      *initial_offset = fold_convert (ssizetype, init); \n+\n+      *step = evolution ? fold_convert (ssizetype, evolution) : ssize_int (0);\n+      return true;      \n+    }\n+\n+  /* Recursive computation.  */\n+  if (!BINARY_CLASS_P (expr))\n+    {\n+      /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+        {\n+\t  fprintf (dump_file, \"\\nNot binary expression \");\n+          print_generic_expr (dump_file, expr, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return false;\n+    }\n+  oprnd0 = TREE_OPERAND (expr, 0);\n+  oprnd1 = TREE_OPERAND (expr, 1);\n+\n+  if (!analyze_offset_expr (oprnd0, loop, &left_offset, &left_misalign, \n+\t\t\t    &left_aligned_to, &left_step)\n+      || !analyze_offset_expr (oprnd1, loop, &right_offset, &right_misalign, \n+\t\t\t       &right_aligned_to, &right_step))\n+    return false;\n+\n+  /* The type of the operation: plus, minus or mult.  */\n+  code = TREE_CODE (expr);\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+      if (TREE_CODE (right_offset) != INTEGER_CST)\n+\t/* RIGHT_OFFSET can be not constant. For example, for arrays of variable \n+\t   sized types. \n+\t   FORNOW: We don't support such cases.  */\n+\treturn false;\n+\n+      /* Strip conversions that don't narrow the mode.  */\n+      left_offset = strip_conversion (left_offset);      \n+      if (!left_offset)\n+\treturn false;      \n+      /* Misalignment computation.  */\n+      if (SSA_VAR_P (left_offset))\n+\t{\n+\t  /* If the left side contains variables that can't be substituted with \n+\t     constants, the misalignment is unknown. However, if the right side \n+\t     is a multiple of some alignment, we know that the expression is\n+\t     aligned to it. Therefore, we record such maximum possible value.\n+\t   */\n+\t  *misalign = NULL_TREE;\n+\t  *aligned_to = ssize_int (highest_pow2_factor (right_offset));\n+\t}\n+      else \n+\t{\n+\t  /* The left operand was successfully substituted with constant.  */\t  \n+\t  if (left_misalign)\n+\t    {\n+\t      /* In case of EXPR '(i * C1 + j) * C2', LEFT_MISALIGN is \n+\t\t NULL_TREE.  */\n+\t      *misalign  = size_binop (code, left_misalign, right_misalign);\n+\t      if (left_aligned_to && right_aligned_to)\n+\t\t*aligned_to = size_binop (MIN_EXPR, left_aligned_to, \n+\t\t\t\t\t  right_aligned_to);\n+\t      else \n+\t\t*aligned_to = left_aligned_to ? \n+\t\t  left_aligned_to : right_aligned_to;\n+\t    }\n+\t  else\n+\t    *misalign = NULL_TREE; \n+\t}\n+\n+      /* Step calculation.  */\n+      /* Multiply the step by the right operand.  */\n+      *step  = size_binop (MULT_EXPR, left_step, right_offset);\n+      break;\n+   \n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* Combine the recursive calculations for step and misalignment.  */\n+      *step = size_binop (code, left_step, right_step);\n+\n+      /* Unknown alignment.  */\n+      if ((!left_misalign && !left_aligned_to)\n+\t  || (!right_misalign && !right_aligned_to))\n+\t{\n+\t  *misalign = NULL_TREE;\n+\t  *aligned_to = NULL_TREE;\n+\t  break;\n+\t}\n+\n+      if (left_misalign && right_misalign)\n+\t*misalign = size_binop (code, left_misalign, right_misalign);\n+      else\n+\t*misalign = left_misalign ? left_misalign : right_misalign;\n+\n+      if (left_aligned_to && right_aligned_to)\n+\t*aligned_to = size_binop (MIN_EXPR, left_aligned_to, right_aligned_to);\n+      else \n+\t*aligned_to = left_aligned_to ? left_aligned_to : right_aligned_to;\n+\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Compute offset.  */\n+  *initial_offset = fold_convert (ssizetype, \n+\t\t\t\t  fold_build2 (code, TREE_TYPE (left_offset), \n+\t\t\t\t\t       left_offset, \n+\t\t\t\t\t       right_offset));\n+  return true;\n+}\n+\n+/* Function address_analysis\n+\n+   Return the BASE of the address expression EXPR.\n+   Also compute the OFFSET from BASE, MISALIGN and STEP.\n+\n+   Input:\n+   EXPR - the address expression that is being analyzed\n+   STMT - the statement that contains EXPR or its original memory reference\n+   IS_READ - TRUE if STMT reads from EXPR, FALSE if writes to EXPR\n+   DR - data_reference struct for the original memory reference\n+\n+   Output:\n+   BASE (returned value) - the base of the data reference EXPR.\n+   INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)\n+   MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the\n+              computation is impossible \n+   ALIGNED_TO - maximum alignment of EXPR or NULL_TREE if MISALIGN can be \n+                calculated (doesn't depend on variables)\n+   STEP - evolution of EXPR in the loop\n+ \n+   If something unexpected is encountered (an unsupported form of data-ref),\n+   then NULL_TREE is returned.  \n+ */\n+\n+static tree\n+address_analysis (tree expr, tree stmt, bool is_read, struct data_reference *dr, \n+\t\t  tree *offset, tree *misalign, tree *aligned_to, tree *step)\n+{\n+  tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n+  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n+  tree dummy, address_aligned_to = NULL_TREE;\n+  struct ptr_info_def *dummy1;\n+  subvar_t dummy2;\n+\n+  switch (TREE_CODE (expr))\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* EXPR is of form {base +/- offset} (or {offset +/- base}).  */\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+\n+      STRIP_NOPS (oprnd0);\n+      STRIP_NOPS (oprnd1);\n+      \n+      /* Recursively try to find the base of the address contained in EXPR.\n+\t For offset, the returned base will be NULL.  */\n+      base_addr0 = address_analysis (oprnd0, stmt, is_read, dr, &address_offset, \n+\t\t\t\t     &address_misalign, &address_aligned_to, \n+\t\t\t\t     step);\n+\n+      base_addr1 = address_analysis (oprnd1, stmt, is_read,  dr, &address_offset, \n+\t\t\t\t     &address_misalign, &address_aligned_to, \n+\t\t\t\t     step);\n+\n+      /* We support cases where only one of the operands contains an \n+\t address.  */\n+      if ((base_addr0 && base_addr1) || (!base_addr0 && !base_addr1))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \n+\t\t    \"\\neither more than one address or no addresses in expr \");\n+\t      print_generic_expr (dump_file, expr, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\t\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* To revert STRIP_NOPS.  */\n+      oprnd0 = TREE_OPERAND (expr, 0);\n+      oprnd1 = TREE_OPERAND (expr, 1);\n+      \n+      offset_expr = base_addr0 ? \n+\tfold_convert (ssizetype, oprnd1) : fold_convert (ssizetype, oprnd0);\n+\n+      /* EXPR is of form {base +/- offset} (or {offset +/- base}). If offset is \n+\t a number, we can add it to the misalignment value calculated for base,\n+\t otherwise, misalignment is NULL.  */\n+      if (TREE_CODE (offset_expr) == INTEGER_CST && address_misalign)\n+\t{\n+\t  *misalign = size_binop (TREE_CODE (expr), address_misalign, \n+\t\t\t\t  offset_expr);\n+\t  *aligned_to = address_aligned_to;\n+\t}\n+      else\n+\t{\n+\t  *misalign = NULL_TREE;\n+\t  *aligned_to = NULL_TREE;\n+\t}\n+\n+      /* Combine offset (from EXPR {base + offset}) with the offset calculated\n+\t for base.  */\n+      *offset = size_binop (TREE_CODE (expr), address_offset, offset_expr);\n+      return base_addr0 ? base_addr0 : base_addr1;\n+\n+    case ADDR_EXPR:\n+      base_address = object_analysis (TREE_OPERAND (expr, 0), stmt, is_read, \n+\t\t\t\t      &dr, offset, misalign, aligned_to, step, \n+\t\t\t\t      &dummy, &dummy1, &dummy2);\n+      return base_address;\n+\n+    case SSA_NAME:\n+      if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nnot pointer SSA_NAME \");\n+\t      print_generic_expr (dump_file, expr, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\t\n+\t  return NULL_TREE;\n+\t}\n+      *aligned_to = ssize_int (TYPE_ALIGN_UNIT (TREE_TYPE (TREE_TYPE (expr))));\n+      *misalign = ssize_int (0);\n+      *offset = ssize_int (0);\n+      *step = ssize_int (0);\n+      return expr;\n+      \n+    default:\n+      return NULL_TREE;\n+    }\n+}\n+\n+\n+/* Function object_analysis\n+\n+   Create a data-reference structure DR for MEMREF.\n+   Return the BASE of the data reference MEMREF if the analysis is possible.\n+   Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.\n+   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset  \n+   'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET \n+   instantiated with initial_conditions of access_functions of variables, \n+   and STEP is the evolution of the DR_REF in this loop.\n+   \n+   Function get_inner_reference is used for the above in case of ARRAY_REF and\n+   COMPONENT_REF.\n+\n+   The structure of the function is as follows:\n+   Part 1:\n+   Case 1. For handled_component_p refs \n+          1.1 build data-reference structure for MEMREF\n+          1.2 call get_inner_reference\n+            1.2.1 analyze offset expr received from get_inner_reference\n+          (fall through with BASE)\n+   Case 2. For declarations \n+          2.1 set MEMTAG\n+   Case 3. For INDIRECT_REFs \n+          3.1 build data-reference structure for MEMREF\n+\t  3.2 analyze evolution and initial condition of MEMREF\n+\t  3.3 set data-reference structure for MEMREF\n+          3.4 call address_analysis to analyze INIT of the access function\n+\t  3.5 extract memory tag\n+\n+   Part 2:\n+   Combine the results of object and address analysis to calculate \n+   INITIAL_OFFSET, STEP and misalignment info.   \n+\n+   Input:\n+   MEMREF - the memory reference that is being analyzed\n+   STMT - the statement that contains MEMREF\n+   IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n+   \n+   Output:\n+   BASE_ADDRESS (returned value) - the base address of the data reference MEMREF\n+                                   E.g, if MEMREF is a.b[k].c[i][j] the returned\n+\t\t\t           base is &a.\n+   DR - data_reference struct for MEMREF\n+   INITIAL_OFFSET - initial offset of MEMREF from BASE (an expression)\n+   MISALIGN - offset of MEMREF from BASE in bytes (a constant) modulo alignment of \n+              ALIGNMENT or NULL_TREE if the computation is impossible\n+   ALIGNED_TO - maximum alignment of EXPR or NULL_TREE if MISALIGN can be \n+                calculated (doesn't depend on variables)\n+   STEP - evolution of the DR_REF in the loop\n+   MEMTAG - memory tag for aliasing purposes\n+   PTR_INFO - NULL or points-to aliasing info from a pointer SSA_NAME\n+   SUBVARS - Sub-variables of the variable\n+\n+   If the analysis of MEMREF evolution in the loop fails, NULL_TREE is returned, \n+   but DR can be created anyway.\n+   \n+*/\n+ \n+static tree\n+object_analysis (tree memref, tree stmt, bool is_read, \n+\t\t struct data_reference **dr, tree *offset, tree *misalign, \n+\t\t tree *aligned_to, tree *step, tree *memtag,\n+\t\t struct ptr_info_def **ptr_info, subvar_t *subvars)\n+{\n+  tree base = NULL_TREE, base_address = NULL_TREE;\n+  tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n+  tree object_step = ssize_int (0), address_step = ssize_int (0);\n+  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n+  HOST_WIDE_INT pbitsize, pbitpos;\n+  tree poffset, bit_pos_in_bytes;\n+  enum machine_mode pmode;\n+  int punsignedp, pvolatilep;\n+  tree ptr_step = ssize_int (0), ptr_init = NULL_TREE;\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  struct data_reference *ptr_dr = NULL;\n+  tree object_aligned_to = NULL_TREE, address_aligned_to = NULL_TREE;\n+\n+ *ptr_info = NULL;\n+\n+  /* Part 1:  */\n+  /* Case 1. handled_component_p refs.  */\n+  if (handled_component_p (memref))\n+    {\n+      /* 1.1 build data-reference structure for MEMREF.  */\n+      /* TODO: handle COMPONENT_REFs.  */\n+      if (!(*dr))\n+\t{ \n+\t  if (TREE_CODE (memref) == ARRAY_REF)\n+\t    *dr = analyze_array (stmt, memref, is_read);\t  \n+\t  else\n+\t    {\n+\t      /* FORNOW.  */\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t{\n+\t\t  fprintf (dump_file, \"\\ndata-ref of unsupported type \");\n+\t\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t\t  fprintf (dump_file, \"\\n\");\n+\t\t}\n+\t      return NULL_TREE;\n+\t    }\n+\t}\n+\n+      /* 1.2 call get_inner_reference.  */\n+      /* Find the base and the offset from it.  */\n+      base = get_inner_reference (memref, &pbitsize, &pbitpos, &poffset,\n+\t\t\t\t  &pmode, &punsignedp, &pvolatilep, false);\n+      if (!base)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nfailed to get inner ref for \");\n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\t  \n+\t  return NULL_TREE;\n+\t}\n+\n+      /* 1.2.1 analyze offset expr received from get_inner_reference.  */\n+      if (poffset \n+\t  && !analyze_offset_expr (poffset, loop, &object_offset, \n+\t\t\t\t   &object_misalign, &object_aligned_to,\n+\t\t\t\t   &object_step))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nfailed to compute offset or step for \");\n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* Add bit position to OFFSET and MISALIGN.  */\n+\n+      bit_pos_in_bytes = ssize_int (pbitpos/BITS_PER_UNIT);\n+      /* Check that there is no remainder in bits.  */\n+      if (pbitpos%BITS_PER_UNIT)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"\\nbit offset alignment.\\n\");\n+\t  return NULL_TREE;\n+\t}\n+      object_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, object_offset);     \n+      if (object_misalign) \n+\tobject_misalign = size_binop (PLUS_EXPR, object_misalign, \n+\t\t\t\t      bit_pos_in_bytes); \n+      \n+      memref = base; /* To continue analysis of BASE.  */\n+      /* fall through  */\n+    }\n+  \n+  /*  Part 1: Case 2. Declarations.  */ \n+  if (DECL_P (memref))\n+    {\n+      /* We expect to get a decl only if we already have a DR.  */\n+      if (!(*dr))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nunhandled decl \");\n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* TODO: if during the analysis of INDIRECT_REF we get to an object, put \n+\t the object in BASE_OBJECT field if we can prove that this is O.K., \n+\t i.e., the data-ref access is bounded by the bounds of the BASE_OBJECT.\n+\t (e.g., if the object is an array base 'a', where 'a[N]', we must prove\n+\t that every access with 'p' (the original INDIRECT_REF based on '&a')\n+\t in the loop is within the array boundaries - from a[0] to a[N-1]).\n+\t Otherwise, our alias analysis can be incorrect.\n+\t Even if an access function based on BASE_OBJECT can't be build, update\n+\t BASE_OBJECT field to enable us to prove that two data-refs are \n+\t different (without access function, distance analysis is impossible).\n+      */\n+     if (SSA_VAR_P (memref) && var_can_have_subvars (memref))\t\n+\t*subvars = get_subvars_for_var (memref);\n+      base_address = build_fold_addr_expr (memref);\n+      /* 2.1 set MEMTAG.  */\n+      *memtag = memref;\n+    }\n+\n+  /* Part 1:  Case 3. INDIRECT_REFs.  */\n+  else if (TREE_CODE (memref) == INDIRECT_REF)\n+    {\n+      tree ptr_ref = TREE_OPERAND (memref, 0);\n+      if (TREE_CODE (ptr_ref) == SSA_NAME)\n+        *ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n+\n+      /* 3.1 build data-reference structure for MEMREF.  */\n+      ptr_dr = analyze_indirect_ref (stmt, memref, is_read);\n+      if (!ptr_dr)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nfailed to create dr for \");\n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\t\n+\t  return NULL_TREE;      \n+\t}\n+\n+      /* 3.2 analyze evolution and initial condition of MEMREF.  */\n+      ptr_step = DR_STEP (ptr_dr);\n+      ptr_init = DR_BASE_ADDRESS (ptr_dr);\n+      if (!ptr_init || !ptr_step || !POINTER_TYPE_P (TREE_TYPE (ptr_init)))\n+\t{\n+\t  *dr = (*dr) ? *dr : ptr_dr;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nbad pointer access \");\n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (integer_zerop (ptr_step) && !(*dr))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS)) \n+\t    fprintf (dump_file, \"\\nptr is loop invariant.\\n\");\t\n+\t  *dr = ptr_dr;\n+\t  return NULL_TREE;\n+\t\n+\t  /* If there exists DR for MEMREF, we are analyzing the base of\n+\t     handled component (PTR_INIT), which not necessary has evolution in \n+\t     the loop.  */\n+\t}\n+      object_step = size_binop (PLUS_EXPR, object_step, ptr_step);\n+\n+      /* 3.3 set data-reference structure for MEMREF.  */\n+      if (!*dr)\n+        *dr = ptr_dr;\n+\n+      /* 3.4 call address_analysis to analyze INIT of the access \n+\t function.  */\n+      base_address = address_analysis (ptr_init, stmt, is_read, *dr, \n+\t\t\t\t       &address_offset, &address_misalign, \n+\t\t\t\t       &address_aligned_to, &address_step);\n+      if (!base_address)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nfailed to analyze address \");\n+\t      print_generic_expr (dump_file, ptr_init, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* 3.5 extract memory tag.  */\n+      switch (TREE_CODE (base_address))\n+\t{\n+\tcase SSA_NAME:\n+\t  *memtag = get_var_ann (SSA_NAME_VAR (base_address))->type_mem_tag;\n+\t  if (!(*memtag) && TREE_CODE (TREE_OPERAND (memref, 0)) == SSA_NAME)\n+\t    *memtag = get_var_ann (\n+\t\t      SSA_NAME_VAR (TREE_OPERAND (memref, 0)))->type_mem_tag;\n+\t  break;\n+\tcase ADDR_EXPR:\n+\t  *memtag = TREE_OPERAND (base_address, 0);\n+\t  break;\n+\tdefault:\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"\\nno memtag for \"); \n+\t      print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t      fprintf (dump_file, \"\\n\");\n+\t    }\n+\t  *memtag = NULL_TREE;\n+\t  break;\n+\t}\n+    }      \n+    \n+  if (!base_address)\n+    {\n+      /* MEMREF cannot be analyzed.  */\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"\\ndata-ref of unsupported type \");\n+\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return NULL_TREE;\n+    }\n+\n+  if (SSA_VAR_P (*memtag) && var_can_have_subvars (*memtag))\n+    *subvars = get_subvars_for_var (*memtag);\n+\t\n+  /* Part 2: Combine the results of object and address analysis to calculate \n+     INITIAL_OFFSET, STEP and misalignment info.  */\n+  *offset = size_binop (PLUS_EXPR, object_offset, address_offset);\n+\n+  if ((!object_misalign && !object_aligned_to)\n+      || (!address_misalign && !address_aligned_to))\n+    {\n+      *misalign = NULL_TREE;\n+      *aligned_to = NULL_TREE;\n+    }  \n+  else \n+    {\n+      if (object_misalign && address_misalign)\n+\t*misalign = size_binop (PLUS_EXPR, object_misalign, address_misalign);\n+      else\n+\t*misalign = object_misalign ? object_misalign : address_misalign;\n+      if (object_aligned_to && address_aligned_to)\n+\t*aligned_to = size_binop (MIN_EXPR, object_aligned_to, \n+\t\t\t\t  address_aligned_to);\n+      else\n+\t*aligned_to = object_aligned_to ? \n+\t  object_aligned_to : address_aligned_to; \n+    }\n+  *step = size_binop (PLUS_EXPR, object_step, address_step); \n+\n+  return base_address;\n+}\n+\n+/* Function analyze_offset.\n+   \n+   Extract INVARIANT and CONSTANT parts from OFFSET. \n+\n+*/\n+static void \n+analyze_offset (tree offset, tree *invariant, tree *constant)\n+{\n+  tree op0, op1, constant_0, constant_1, invariant_0, invariant_1;\n+  enum tree_code code = TREE_CODE (offset);\n+\n+  *invariant = NULL_TREE;\n+  *constant = NULL_TREE;\n+\n+  /* Not PLUS/MINUS expression - recursion stop condition.  */\n+  if (code != PLUS_EXPR && code != MINUS_EXPR)\n+    {\n+      if (TREE_CODE (offset) == INTEGER_CST)\n+\t*constant = offset;\n+      else\n+\t*invariant = offset;\n+      return;\n+    }\n+\n+  op0 = TREE_OPERAND (offset, 0);\n+  op1 = TREE_OPERAND (offset, 1);\n+\n+  /* Recursive call with the operands.  */\n+  analyze_offset (op0, &invariant_0, &constant_0);\n+  analyze_offset (op1, &invariant_1, &constant_1);\n+\n+  /* Combine the results.  */\n+  *constant = constant_0 ? constant_0 : constant_1;\n+  if (invariant_0 && invariant_1)\n+    *invariant = \n+      fold (build (code, TREE_TYPE (invariant_0), invariant_0, invariant_1));\n+  else\n+    *invariant = invariant_0 ? invariant_0 : invariant_1;\n+}\n+\n+\n+/* Function create_data_ref.\n+   \n+   Create a data-reference structure for MEMREF. Set its DR_BASE_ADDRESS,\n+   DR_OFFSET, DR_INIT, DR_STEP, DR_OFFSET_MISALIGNMENT, DR_ALIGNED_TO,\n+   DR_MEMTAG, and DR_POINTSTO_INFO fields. \n+\n+   Input:\n+   MEMREF - the memory reference that is being analyzed\n+   STMT - the statement that contains MEMREF\n+   IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n+\n+   Output:\n+   DR (returned value) - data_reference struct for MEMREF\n+*/\n+\n+static struct data_reference *\n+create_data_ref (tree memref, tree stmt, bool is_read)\n+{\n+  struct data_reference *dr = NULL;\n+  tree base_address, offset, step, misalign, memtag;\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  tree invariant = NULL_TREE, constant = NULL_TREE;\n+  tree type_size, init_cond;\n+  struct ptr_info_def *ptr_info;\n+  subvar_t subvars = NULL;\n+  tree aligned_to;\n+\n+  if (!memref)\n+    return NULL;\n+\n+  base_address = object_analysis (memref, stmt, is_read, &dr, &offset, \n+\t\t\t\t  &misalign, &aligned_to, &step, &memtag, \n+\t\t\t\t  &ptr_info, &subvars);\n+  if (!dr || !base_address)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"\\ncreate_data_ref: failed to create a dr for \");\n+\t  print_generic_expr (dump_file, memref, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+      return NULL;\n+    }\n+\n+  DR_BASE_ADDRESS (dr) = base_address;\n+  DR_OFFSET (dr) = offset;\n+  DR_INIT (dr) = ssize_int (0);\n+  DR_STEP (dr) = step;\n+  DR_OFFSET_MISALIGNMENT (dr) = misalign;\n+  DR_ALIGNED_TO (dr) = aligned_to;\n+  DR_MEMTAG (dr) = memtag;\n+  DR_PTR_INFO (dr) = ptr_info;\n+  DR_SUBVARS (dr) = subvars;\n+  \n+  type_size = fold_convert (ssizetype, TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n+\n+  /* Change the access function for INIDIRECT_REFs, according to \n+     DR_BASE_ADDRESS.  Analyze OFFSET calculated in object_analysis. OFFSET is \n+     an expression that can contain loop invariant expressions and constants.\n+     We put the constant part in the initial condition of the access function\n+     (for data dependence tests), and in DR_INIT of the data-ref. The loop\n+     invariant part is put in DR_OFFSET. \n+     The evolution part of the access function is STEP calculated in\n+     object_analysis divided by the size of data type.\n+  */\n+  if (!DR_BASE_OBJECT (dr))\n+    {\n+      tree access_fn;\n+      tree new_step;\n+\n+      /* Extract CONSTANT and INVARIANT from OFFSET, and put them in DR_INIT and\n+\t DR_OFFSET fields of DR.  */\n+      analyze_offset (offset, &invariant, &constant); \n+      if (constant)\n+\t{\n+\t  DR_INIT (dr) = fold_convert (ssizetype, constant);\n+\t  init_cond = fold (build (TRUNC_DIV_EXPR, TREE_TYPE (constant), \n+\t\t\t\t   constant, type_size));\n+\t}\n+      else\n+\tDR_INIT (dr) = init_cond = ssize_int (0);;\n+\n+      if (invariant)\n+\tDR_OFFSET (dr) = invariant;\n+      else\n+\tDR_OFFSET (dr) = ssize_int (0);\n+\n+      /* Update access function.  */\n+      access_fn = DR_ACCESS_FN (dr, 0);\n+      new_step = size_binop (TRUNC_DIV_EXPR,  \n+\t\t\t     fold_convert (ssizetype, step), type_size);\n+\n+      access_fn = chrec_replace_initial_condition (access_fn, init_cond);\n+      access_fn = reset_evolution_in_loop (loop->num, access_fn, new_step);\n+\n+      VEC_replace (tree, DR_ACCESS_FNS (dr), 0, access_fn);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      struct ptr_info_def *pi = DR_PTR_INFO (dr);\n+\n+      fprintf (dump_file, \"\\nCreated dr for \");\n+      print_generic_expr (dump_file, memref, TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tbase_address: \");\n+      print_generic_expr (dump_file, DR_BASE_ADDRESS (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\toffset from base address: \");\n+      print_generic_expr (dump_file, DR_OFFSET (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tconstant offset from base address: \");\n+      print_generic_expr (dump_file, DR_INIT (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tbase_object: \");\n+      print_generic_expr (dump_file, DR_BASE_OBJECT (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\\tstep: \");\n+      print_generic_expr (dump_file, DR_STEP (dr), TDF_SLIM);\n+      fprintf (dump_file, \"B\\n\\tmisalignment from base: \");\n+      print_generic_expr (dump_file, DR_OFFSET_MISALIGNMENT (dr), TDF_SLIM);\n+      if (DR_OFFSET_MISALIGNMENT (dr))\n+\tfprintf (dump_file, \"B\");\n+      if (DR_ALIGNED_TO (dr))\n+\t{\n+\t  fprintf (dump_file, \"\\n\\taligned to: \");\n+\t  print_generic_expr (dump_file, DR_ALIGNED_TO (dr), TDF_SLIM);\n+\t}\n+      fprintf (dump_file, \"\\n\\tmemtag: \");\n+      print_generic_expr (dump_file, DR_MEMTAG (dr), TDF_SLIM);\n+      fprintf (dump_file, \"\\n\");\n+      if (pi && pi->name_mem_tag)\n+        {\n+          fprintf (dump_file, \"\\n\\tnametag: \");\n+          print_generic_expr (dump_file, pi->name_mem_tag, TDF_SLIM);\n+          fprintf (dump_file, \"\\n\");\n+        }\n+    }  \n+  return dr;  \n+}\n+\n+\n /* Returns true when all the functions of a tree_vec CHREC are the\n    same.  */\n \n@@ -692,43 +1936,58 @@ initialize_data_dependence_relation (struct data_reference *a,\n {\n   struct data_dependence_relation *res;\n   bool differ_p;\n+  unsigned int i;  \n   \n   res = xmalloc (sizeof (struct data_dependence_relation));\n   DDR_A (res) = a;\n   DDR_B (res) = b;\n \n-  if (a == NULL || b == NULL \n-      || DR_BASE_NAME (a) == NULL_TREE\n-      || DR_BASE_NAME (b) == NULL_TREE)\n-    DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n+  if (a == NULL || b == NULL)\n+    {\n+      DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n+      return res;\n+    }   \n+\n+  /* When A and B are arrays and their dimensions differ, we directly\n+     initialize the relation to \"there is no dependence\": chrec_known.  */\n+  if (DR_BASE_OBJECT (a) && DR_BASE_OBJECT (b)\n+      && DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b))\n+    {\n+      DDR_ARE_DEPENDENT (res) = chrec_known;\n+      return res;\n+    }\n \n-  /* When the dimensions of A and B differ, we directly initialize\n-     the relation to \"there is no dependence\": chrec_known.  */\n-  else if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)\n-\t   || (array_base_name_differ_p (a, b, &differ_p) && differ_p))\n-    DDR_ARE_DEPENDENT (res) = chrec_known;\n-  \n-  else\n+    /* Compare the bases of the data-refs.  */\n+  if (!base_addr_differ_p (a, b, &differ_p))\n     {\n-      unsigned int i;\n-      DDR_AFFINE_P (res) = true;\n-      DDR_ARE_DEPENDENT (res) = NULL_TREE;\n-      DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n-      DDR_SIZE_VECT (res) = 0;\n-      DDR_DIST_VECT (res) = NULL;\n-      DDR_DIR_VECT (res) = NULL;\n+      /* Can't determine whether the data-refs access the same memory \n+\t region.  */\n+      DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n+      return res;\n+    }\n+  if (differ_p)\n+    {\n+      DDR_ARE_DEPENDENT (res) = chrec_known;    \n+      return res;\n+    }\n+  \n+  DDR_AFFINE_P (res) = true;\n+  DDR_ARE_DEPENDENT (res) = NULL_TREE;\n+  DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n+  DDR_SIZE_VECT (res) = 0;\n+  DDR_DIST_VECT (res) = NULL;\n+  DDR_DIR_VECT (res) = NULL;\n       \n-      for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n-\t{\n-\t  struct subscript *subscript;\n+  for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n+    {\n+      struct subscript *subscript;\n \t  \n-\t  subscript = xmalloc (sizeof (struct subscript));\n-\t  SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n-\t  SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n-\t  SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n-\t  SUB_DISTANCE (subscript) = chrec_dont_know;\n-\t  VARRAY_PUSH_GENERIC_PTR (DDR_SUBSCRIPTS (res), subscript);\n-\t}\n+      subscript = xmalloc (sizeof (struct subscript));\n+      SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n+      SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n+      SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n+      SUB_DISTANCE (subscript) = chrec_dont_know;\n+      VARRAY_PUSH_GENERIC_PTR (DDR_SUBSCRIPTS (res), subscript);\n     }\n   \n   return res;\n@@ -1768,7 +3027,7 @@ subscript_dependence_tester (struct data_dependence_relation *ddr)\n    starting at FIRST_LOOP_DEPTH. \n    Return TRUE otherwise.  */\n \n-bool\n+static bool\n build_classic_dist_vector (struct data_dependence_relation *ddr, \n \t\t\t   int nb_loops, int first_loop_depth)\n {\n@@ -2123,7 +3382,7 @@ static bool\n access_functions_are_affine_or_constant_p (struct data_reference *a)\n {\n   unsigned int i;\n-  VEC(tree,heap) **fns = &DR_ACCESS_FNS (a);\n+  VEC(tree,heap) **fns = DR_ACCESS_FNS_ADDR (a);\n   tree t;\n   \n   for (i = 0; VEC_iterate (tree, *fns, i, t); i++)\n@@ -2202,13 +3461,15 @@ DEF_VEC_P(ddr_p);\n DEF_VEC_ALLOC_P(ddr_p,heap);\n \n /* Compute a subset of the data dependence relation graph.  Don't\n-   compute read-read relations, and avoid the computation of the\n-   opposite relation, i.e. when AB has been computed, don't compute BA.\n+   compute read-read and self relations if \n+   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is FALSE, and avoid the computation \n+   of the opposite relation, i.e. when AB has been computed, don't compute BA.\n    DATAREFS contains a list of data references, and the result is set\n    in DEPENDENCE_RELATIONS.  */\n \n static void \n compute_all_dependences (varray_type datarefs, \n+\t\t\t bool compute_self_and_read_read_dependences,\n \t\t\t VEC(ddr_p,heap) **dependence_relations)\n {\n   unsigned int i, j, N;\n@@ -2226,12 +3487,17 @@ compute_all_dependences (varray_type datarefs,\n \n \ta = VARRAY_GENERIC_PTR (datarefs, i);\n \tb = VARRAY_GENERIC_PTR (datarefs, j);\n+\tif (DR_IS_READ (a) && DR_IS_READ (b)\n+            && !compute_self_and_read_read_dependences)\n+\t  continue;\n \tddr = initialize_data_dependence_relation (a, b);\n \n \tVEC_safe_push (ddr_p, heap, *dependence_relations, ddr);\n \tcompute_affine_dependence (ddr);\n \tcompute_subscript_distance (ddr);\n       }\n+  if (!compute_self_and_read_read_dependences)\n+    return;\n \n   /* Compute self dependence relation of each dataref to itself.  */\n \n@@ -2263,6 +3529,7 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n   basic_block bb, *bbs;\n   unsigned int i;\n   block_stmt_iterator bsi;\n+  struct data_reference *dr;\n \n   bbs = get_loop_body (loop);\n \n@@ -2289,33 +3556,55 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t  switch (TREE_CODE (stmt))\n \t    {\n \t    case MODIFY_EXPR:\n-\t      if (TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_REF)\n-\t\tVARRAY_PUSH_GENERIC_PTR \n-\t\t  (*datarefs, analyze_array (stmt, TREE_OPERAND (stmt, 0),\n-\t\t\t\t\t     false));\n-\n-\t      if (TREE_CODE (TREE_OPERAND (stmt, 1)) == ARRAY_REF)\n-\t\tVARRAY_PUSH_GENERIC_PTR \n-\t\t  (*datarefs, analyze_array (stmt, TREE_OPERAND (stmt, 1),\n-\t\t\t\t\t     true));\n+\t      {\n+\t\tbool one_inserted = false;\n+\t\ttree opnd0 = TREE_OPERAND (stmt, 0);\n+\t\ttree opnd1 = TREE_OPERAND (stmt, 1);\n+\t\t\n+\t\tif (TREE_CODE (opnd0) == ARRAY_REF \n+\t\t    || TREE_CODE (opnd0) == INDIRECT_REF)\n+\t\t  {\n+\t\t    dr = create_data_ref (opnd0, stmt, false);\n+\t\t    if (dr) \n+\t\t      {\n+\t\t\tVARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n+\t\t\tone_inserted = true;\n+\t\t      }\n+\t\t  }\n+\n+\t\tif (TREE_CODE (opnd1) == ARRAY_REF \n+\t\t    || TREE_CODE (opnd1) == INDIRECT_REF)\n+\t\t  {\n+\t\t    dr = create_data_ref (opnd1, stmt, true);\n+\t\t    if (dr) \n+\t\t      {\n+\t\t\tVARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n+\t\t\tone_inserted = true;\n+\t\t      }\n+\t\t  }\n \n-\t      if (TREE_CODE (TREE_OPERAND (stmt, 0)) != ARRAY_REF\n-\t\t  && TREE_CODE (TREE_OPERAND (stmt, 1)) != ARRAY_REF)\n-\t\tgoto insert_dont_know_node;\n+\t\tif (!one_inserted)\n+\t\t  goto insert_dont_know_node;\n \n-\t      break;\n+\t\tbreak;\n+\t      }\n \n \t    case CALL_EXPR:\n \t      {\n \t\ttree args;\n \t\tbool one_inserted = false;\n \n-\t\tfor (args = TREE_OPERAND (stmt, 1); args; args = TREE_CHAIN (args))\n-\t\t  if (TREE_CODE (TREE_VALUE (args)) == ARRAY_REF)\n+\t\tfor (args = TREE_OPERAND (stmt, 1); args; \n+\t\t     args = TREE_CHAIN (args))\n+\t\t  if (TREE_CODE (TREE_VALUE (args)) == ARRAY_REF\n+\t\t      || TREE_CODE (TREE_VALUE (args)) == INDIRECT_REF)\n \t\t    {\n-\t\t      VARRAY_PUSH_GENERIC_PTR \n-\t\t\t(*datarefs, analyze_array (stmt, TREE_VALUE (args), true));\n-\t\t      one_inserted = true;\n+\t\t      dr = create_data_ref (TREE_VALUE (args), stmt, true);\n+\t\t      if (dr)\n+\t\t\t{\n+\t\t\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n+\t\t\t  one_inserted = true;\n+\t\t\t}\n \t\t    }\n \n \t\tif (!one_inserted)\n@@ -2332,9 +3621,18 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \t\t  res = xmalloc (sizeof (struct data_reference));\n \t\t  DR_STMT (res) = NULL_TREE;\n \t\t  DR_REF (res) = NULL_TREE;\n-\t\t  DR_ACCESS_FNS (res) = NULL;\n-\t\t  DR_BASE_NAME (res) = NULL;\n+\t\t  DR_BASE_OBJECT (res) = NULL;\n+\t\t  DR_TYPE (res) = ARRAY_REF_TYPE;\n+\t\t  DR_SET_ACCESS_FNS (res, NULL);\n+\t\t  DR_BASE_OBJECT (res) = NULL;\n \t\t  DR_IS_READ (res) = false;\n+\t\t  DR_BASE_ADDRESS (res) = NULL_TREE;\n+\t\t  DR_OFFSET (res) = NULL_TREE;\n+\t\t  DR_INIT (res) = NULL_TREE;\n+\t\t  DR_STEP (res) = NULL_TREE;\n+\t\t  DR_OFFSET_MISALIGNMENT (res) = NULL_TREE;\n+\t\t  DR_MEMTAG (res) = NULL_TREE;\n+\t\t  DR_PTR_INFO (res) = NULL;\n \t\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, res);\n \n \t\t  free (bbs);\n@@ -2362,17 +3660,25 @@ find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n \n /* Given a loop nest LOOP, the following vectors are returned:\n    *DATAREFS is initialized to all the array elements contained in this loop, \n-   *DEPENDENCE_RELATIONS contains the relations between the data references.  */\n+   *DEPENDENCE_RELATIONS contains the relations between the data references.  \n+   Compute read-read and self relations if \n+   COMPUTE_SELF_AND_READ_READ_DEPENDENCES is TRUE.  */\n \n void\n-compute_data_dependences_for_loop (unsigned nb_loops, \n-\t\t\t\t   struct loop *loop,\n+compute_data_dependences_for_loop (struct loop *loop, \n+\t\t\t\t   bool compute_self_and_read_read_dependences,\n \t\t\t\t   varray_type *datarefs,\n \t\t\t\t   varray_type *dependence_relations)\n {\n-  unsigned int i;\n+  unsigned int i, nb_loops;\n   VEC(ddr_p,heap) *allrelations;\n   struct data_dependence_relation *ddr;\n+  struct loop *loop_nest = loop;\n+\n+  while (loop_nest && loop_nest->outer && loop_nest->outer->outer)\n+    loop_nest = loop_nest->outer;\n+\n+  nb_loops = loop_nest->level;\n \n   /* If one of the data references is not computable, give up without\n      spending time to compute other dependences.  */\n@@ -2390,14 +3696,15 @@ compute_data_dependences_for_loop (unsigned nb_loops,\n     }\n \n   allrelations = NULL;\n-  compute_all_dependences (*datarefs, &allrelations);\n+  compute_all_dependences (*datarefs, compute_self_and_read_read_dependences,\n+\t\t\t   &allrelations);\n \n   for (i = 0; VEC_iterate (ddr_p, allrelations, i, ddr); i++)\n     {\n-      if (build_classic_dist_vector (ddr, nb_loops, loop->depth))\n+      if (build_classic_dist_vector (ddr, nb_loops, loop_nest->depth))\n \t{\n \t  VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n-\t  build_classic_dir_vector (ddr, nb_loops, loop->depth);\n+\t  build_classic_dir_vector (ddr, nb_loops, loop_nest->depth);\n \t}\n     }\n }\n@@ -2438,7 +3745,7 @@ analyze_all_data_dependences (struct loops *loops)\n \t\t\t   \"dependence_relations\");\n \n   /* Compute DDs on the whole function.  */\n-  compute_data_dependences_for_loop (loops->num, loops->parray[0], \n+  compute_data_dependences_for_loop (loops->parray[0], false,\n \t\t\t\t     &datarefs, &dependence_relations);\n \n   if (dump_file)\n@@ -2470,8 +3777,10 @@ analyze_all_data_dependences (struct loops *loops)\n \t\t  struct data_reference *b = DDR_B (ddr);\n \t\t  bool differ_p;\t\n \t      \n-\t\t  if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)\n-\t\t      || (array_base_name_differ_p (a, b, &differ_p) && differ_p))\n+\t\t  if ((DR_BASE_OBJECT (a) && DR_BASE_OBJECT (b)\n+\t\t       && DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b))\n+\t\t      || (base_object_differ_p (a, b, &differ_p) \n+\t\t\t  && differ_p))\n \t\t    nb_basename_differ++;\n \t\t  else\n \t\t    nb_bot_relations++;\n@@ -2533,7 +3842,7 @@ free_data_refs (varray_type datarefs)\n \tVARRAY_GENERIC_PTR (datarefs, i);\n       if (dr)\n \t{\n-\t  VEC_free (tree, heap, DR_ACCESS_FNS (dr));\n+\t  DR_FREE_ACCESS_FNS (dr);\n \t  free (dr);\n \t}\n     }"}, {"sha": "d0e670149d3c75b36f43c2f5df3f4ea5c67da2c1", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 105, "deletions": 19, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -24,6 +24,50 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"lambda.h\"\n \n+/** {base_address + offset + init} is the first location accessed by data-ref \n+      in the loop, and step is the stride of data-ref in the loop in bytes;\n+      e.g.:\n+    \n+                       Example 1                      Example 2\n+      data-ref         a[j].b[i][j]                   a + x + 16B (a is int*)\n+      \n+First location info:\n+      base_address     &a                             a\n+      offset           j_0*D_j + i_0*D_i + C_a        x\n+      init             C_b                            16\n+      step             D_j                            4\n+      access_fn        NULL                           {16, +, 1}\n+\n+Base object info:\n+      base_object      a                              NULL\n+      access_fn        <access_fns of indexes of b>   NULL\n+\n+  **/\n+struct first_location_in_loop\n+{\n+  tree base_address;\n+  tree offset;\n+  tree init;\n+  tree step;\n+  /* Access function related to first location in the loop.  */\n+  VEC(tree,heap) *access_fns;\n+\n+};\n+\n+struct base_object_info\n+{\n+  /* The object.  */\n+  tree base_object;\n+  \n+  /* A list of chrecs.  Access functions related to BASE_OBJECT.  */\n+  VEC(tree,heap) *access_fns;\n+};\n+\n+enum data_ref_type {\n+  ARRAY_REF_TYPE,\n+  POINTER_REF_TYPE\n+};\n+\n struct data_reference\n {\n   /* A pointer to the statement that contains this DR.  */\n@@ -32,27 +76,74 @@ struct data_reference\n   /* A pointer to the ARRAY_REF node.  */\n   tree ref;\n \n-  /* The name of the array.  */\n-  tree base_name;\n-  \n-  /* A list of chrecs.  */\n-  VEC(tree,heap) *access_fns;\n-\n   /* Auxiliary info specific to a pass.  */\n   int aux;\n \n   /* True when the data reference is in RHS of a stmt.  */\n   bool is_read;\n \n+  /* First location accessed by the data-ref in the loop.  */\n+  struct first_location_in_loop first_location;\n+\n+  /* Base object related info.  */\n+  struct base_object_info object_info;\n+\n+  /* Aliasing information.  This field represents the symbol that\n+     should be aliased by a pointer holding the address of this data\n+     reference.  If the original data reference was a pointer\n+     dereference, then this field contains the memory tag that should\n+     be used by the new vector-pointer.  */\n+  tree memtag;\n+  struct ptr_info_def *ptr_info;\n+  subvar_t subvars;\n+\n+  /* Alignment information.  */ \n+  /* The offset of the data-reference from its base in bytes.  */\n+  tree misalignment;\n+  /* The maximum data-ref's alignment.  */\n+  tree aligned_to;\n+\n+  /* The type of the data-ref.  */\n+  enum data_ref_type type;\n };\n \n-#define DR_STMT(DR) DR->stmt\n-#define DR_REF(DR) DR->ref\n-#define DR_BASE_NAME(DR) DR->base_name\n-#define DR_ACCESS_FNS(DR) DR->access_fns\n-#define DR_ACCESS_FN(DR, I) VEC_index (tree, DR_ACCESS_FNS (DR), I)\n-#define DR_NUM_DIMENSIONS(DR) VEC_length (tree, DR_ACCESS_FNS (DR))\n-#define DR_IS_READ(DR) DR->is_read\n+#define DR_STMT(DR)                (DR)->stmt\n+#define DR_REF(DR)                 (DR)->ref\n+#define DR_BASE_OBJECT(DR)         (DR)->object_info.base_object\n+#define DR_TYPE(DR)                (DR)->type\n+#define DR_ACCESS_FNS(DR)\\\n+  (DR_TYPE(DR) == ARRAY_REF_TYPE ?  \\\n+   (DR)->object_info.access_fns : (DR)->first_location.access_fns)\n+#define DR_ACCESS_FN(DR, I)        VEC_index (tree, DR_ACCESS_FNS (DR), I)\n+#define DR_NUM_DIMENSIONS(DR)      VEC_length (tree, DR_ACCESS_FNS (DR))  \n+#define DR_IS_READ(DR)             (DR)->is_read\n+#define DR_BASE_ADDRESS(DR)        (DR)->first_location.base_address\n+#define DR_OFFSET(DR)              (DR)->first_location.offset\n+#define DR_INIT(DR)                (DR)->first_location.init\n+#define DR_STEP(DR)                (DR)->first_location.step\n+#define DR_MEMTAG(DR)              (DR)->memtag\n+#define DR_ALIGNED_TO(DR)          (DR)->aligned_to\n+#define DR_OFFSET_MISALIGNMENT(DR) (DR)->misalignment\n+#define DR_PTR_INFO(DR)            (DR)->ptr_info\n+#define DR_SUBVARS(DR)             (DR)->subvars\n+\n+#define DR_ACCESS_FNS_ADDR(DR)       \\\n+  (DR_TYPE(DR) == ARRAY_REF_TYPE ?   \\\n+   &((DR)->object_info.access_fns) : &((DR)->first_location.access_fns))\n+#define DR_SET_ACCESS_FNS(DR, ACC_FNS)         \\\n+{                                              \\\n+  if (DR_TYPE(DR) == ARRAY_REF_TYPE)           \\\n+    (DR)->object_info.access_fns = ACC_FNS;    \\\n+  else                                         \\\n+    (DR)->first_location.access_fns = ACC_FNS; \\\n+}\n+#define DR_FREE_ACCESS_FNS(DR)                              \\\n+{                                                           \\\n+  if (DR_TYPE(DR) == ARRAY_REF_TYPE)                        \\\n+    VEC_free (tree, heap, (DR)->object_info.access_fns);    \\\n+  else                                                      \\\n+    VEC_free (tree, heap, (DR)->first_location.access_fns); \\\n+}\n \n enum data_dependence_direction {\n   dir_positive, \n@@ -156,10 +247,8 @@ extern struct data_dependence_relation *initialize_data_dependence_relation\n (struct data_reference *, struct data_reference *);\n extern void compute_affine_dependence (struct data_dependence_relation *);\n extern void analyze_all_data_dependences (struct loops *);\n-extern void compute_data_dependences_for_loop (unsigned, struct loop *, \n+extern void compute_data_dependences_for_loop (struct loop *, bool,\n \t\t\t\t\t       varray_type *, varray_type *);\n-extern struct data_reference * init_data_ref (tree, tree, tree, tree, bool);\n-extern struct data_reference *analyze_array (tree, tree, bool);\n \n extern void dump_subscript (FILE *, struct subscript *);\n extern void dump_ddrs (FILE *, varray_type);\n@@ -171,13 +260,10 @@ extern void dump_data_dependence_relation (FILE *,\n extern void dump_data_dependence_relations (FILE *, varray_type);\n extern void dump_data_dependence_direction (FILE *, \n \t\t\t\t\t    enum data_dependence_direction);\n-extern bool array_base_name_differ_p (struct data_reference *, \n-\t\t\t\t      struct data_reference *, bool *);\n extern void free_dependence_relation (struct data_dependence_relation *);\n extern void free_dependence_relations (varray_type);\n extern void free_data_refs (varray_type);\n extern void compute_subscript_distance (struct data_dependence_relation *);\n-extern bool build_classic_dist_vector (struct data_dependence_relation *, int, int);\n \n \n \f"}, {"sha": "4a0b48007c59ba532d92e330854fb89d2893cf10", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -606,6 +606,7 @@ extern void debug_points_to_info (void);\n extern void dump_points_to_info_for (FILE *, tree);\n extern void debug_points_to_info_for (tree);\n extern bool may_be_aliased (tree);\n+extern bool is_aliased_with (tree, tree);\n extern struct ptr_info_def *get_ptr_info (tree);\n extern void add_type_alias (tree, tree);\n extern void new_type_alias (tree, tree);"}, {"sha": "0b13e2b5524018d84e0461a9e0b75c274ff31ef6", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -295,7 +295,7 @@ linear_transform_loops (struct loops *loops)\n \t\t\t       \"dependence_relations\");\n       \n   \n-      compute_data_dependences_for_loop (depth, loop_nest,\n+      compute_data_dependences_for_loop (loop_nest, true,\n \t\t\t\t\t &datarefs, &dependence_relations);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{"}, {"sha": "62c741e9f3427bb70ad2aac00988149c56be43d4", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -2219,6 +2219,40 @@ may_be_aliased (tree var)\n }\n \n \n+/* Given two symbols return TRUE if one is in the alias set of the other.  */\n+bool\n+is_aliased_with (tree tag, tree sym)\n+{\n+  size_t i;\n+  varray_type aliases;\n+\n+  if (var_ann (sym)->is_alias_tag)\n+    {\n+      aliases = var_ann (tag)->may_aliases;\n+\n+      if (aliases == NULL)\n+\treturn false;\n+\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+\tif (VARRAY_TREE (aliases, i) == sym)\n+\t  return true;\n+    }\n+  else\n+    {\n+      aliases = var_ann (sym)->may_aliases;\n+\n+      if (aliases == NULL)\n+\treturn false;\n+\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+\tif (VARRAY_TREE (aliases, i) == tag)\n+\t  return true;\n+    }\n+\n+  return false;\n+}\n+\n+\n /* Add VAR to the list of may-aliases of PTR's type tag.  If PTR\n    doesn't already have a type tag, create one.  */\n "}, {"sha": "45deb5c0952c7319dff845d01a66616ecb402599", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 192, "deletions": 1067, "changes": 1259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -57,234 +57,10 @@ static void vect_mark_relevant (VEC(tree,heap) **, tree, bool, bool);\n static bool vect_stmt_relevant_p (tree, loop_vec_info, bool *, bool *);\n static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_analyze_data_ref_dependence\n-  (struct data_reference *, struct data_reference *, loop_vec_info);\n-static bool vect_compute_data_ref_alignment (struct data_reference *);\n+  (struct data_dependence_relation *, loop_vec_info);\n+static bool vect_compute_data_ref_alignment (struct data_reference *); \n static bool vect_analyze_data_ref_access (struct data_reference *);\n-static struct data_reference * vect_analyze_pointer_ref_access \n-  (tree, tree, bool, tree, tree *, tree *);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n-static tree vect_get_ptr_offset (tree, tree, tree *);\n-static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n-\t\t\t\t      tree *, tree *);\n-static bool vect_base_addr_differ_p (struct data_reference *,\n-\t\t\t\t     struct data_reference *drb, bool *);\n-static tree vect_object_analysis (tree, tree, bool, tree, \n-\t\t\t\t  struct data_reference **, tree *, tree *, \n-\t\t\t\t  tree *, bool *, tree *, struct ptr_info_def **,\n-\t\t\t\t  subvar_t *);\n-static tree vect_address_analysis (tree, tree, bool, tree, \n-\t\t\t\t   struct data_reference *, tree *, tree *, \n-\t\t\t\t   tree *, bool *);\n-\n-\n-/* Function vect_get_ptr_offset\n-\n-   Compute the OFFSET modulo vector-type alignment of pointer REF in bits.  */\n-\n-static tree \n-vect_get_ptr_offset (tree ref ATTRIBUTE_UNUSED, \n-\t\t     tree vectype ATTRIBUTE_UNUSED, \n-\t\t     tree *offset ATTRIBUTE_UNUSED)\n-{\n-  /* TODO: Use alignment information.  */\n-  return NULL_TREE; \n-}\n-\n-\n-/* Function vect_analyze_offset_expr\n-\n-   Given an offset expression EXPR received from get_inner_reference, analyze\n-   it and create an expression for INITIAL_OFFSET by substituting the variables \n-   of EXPR with initial_condition of the corresponding access_fn in the loop. \n-   E.g., \n-      for i\n-         for (j = 3; j < N; j++)\n-            a[j].b[i][j] = 0;\n-\t \n-   For a[j].b[i][j], EXPR will be 'i * C_i + j * C_j + C'. 'i' cannot be \n-   substituted, since its access_fn in the inner loop is i. 'j' will be \n-   substituted with 3. An INITIAL_OFFSET will be 'i * C_i + C`', where\n-   C` =  3 * C_j + C.\n-\n-   Compute MISALIGN (the misalignment of the data reference initial access from\n-   its base) if possible. Misalignment can be calculated only if all the\n-   variables can be substituted with constants, or if a variable is multiplied\n-   by a multiple of VECTYPE_ALIGNMENT. In the above example, since 'i' cannot\n-   be substituted, MISALIGN will be NULL_TREE in case that C_i is not a multiple\n-   of VECTYPE_ALIGNMENT, and C` otherwise. (We perform MISALIGN modulo \n-   VECTYPE_ALIGNMENT computation in the caller of this function).\n-\n-   STEP is an evolution of the data reference in this loop in bytes.\n-   In the above example, STEP is C_j.\n-\n-   Return FALSE, if the analysis fails, e.g., there is no access_fn for a \n-   variable. In this case, all the outputs (INITIAL_OFFSET, MISALIGN and STEP) \n-   are NULL_TREEs. Otherwise, return TRUE.\n-\n-*/\n-\n-static bool\n-vect_analyze_offset_expr (tree expr, \n-\t\t\t  struct loop *loop, \n-\t\t\t  tree vectype_alignment,\n-\t\t\t  tree *initial_offset,\n-\t\t\t  tree *misalign,\n-\t\t\t  tree *step)\n-{\n-  tree oprnd0;\n-  tree oprnd1;\n-  tree left_offset = ssize_int (0);\n-  tree right_offset = ssize_int (0);\n-  tree left_misalign = ssize_int (0);\n-  tree right_misalign = ssize_int (0);\n-  tree left_step = ssize_int (0);\n-  tree right_step = ssize_int (0);\n-  enum tree_code code;\n-  tree init, evolution;\n-\n-  *step = NULL_TREE;\n-  *misalign = NULL_TREE;\n-  *initial_offset = NULL_TREE;\n-\n-  /* Strip conversions that don't narrow the mode.  */\n-  expr = vect_strip_conversion (expr);\n-  if (!expr)\n-    return false;\n-\n-  /* Stop conditions:\n-     1. Constant.  */\n-  if (TREE_CODE (expr) == INTEGER_CST)\n-    {\n-      *initial_offset = fold_convert (ssizetype, expr);\n-      *misalign = fold_convert (ssizetype, expr);      \n-      *step = ssize_int (0);\n-      return true;\n-    }\n-\n-  /* 2. Variable. Try to substitute with initial_condition of the corresponding\n-     access_fn in the current loop.  */\n-  if (SSA_VAR_P (expr))\n-    {\n-      tree access_fn = analyze_scalar_evolution (loop, expr);\n-\n-      if (access_fn == chrec_dont_know)\n-\t/* No access_fn.  */\n-\treturn false;\n-\n-      init = initial_condition_in_loop_num (access_fn, loop->num);\n-      if (init == expr && !expr_invariant_in_loop_p (loop, init))\n-\t/* Not enough information: may be not loop invariant.  \n-\t   E.g., for a[b[i]], we get a[D], where D=b[i]. EXPR is D, its \n-\t   initial_condition is D, but it depends on i - loop's induction\n-\t   variable.  */\t  \n-\treturn false;\n-\n-      evolution = evolution_part_in_loop_num (access_fn, loop->num);\n-      if (evolution && TREE_CODE (evolution) != INTEGER_CST)\n-\t/* Evolution is not constant.  */\n-\treturn false;\n-\n-      if (TREE_CODE (init) == INTEGER_CST)\n-\t*misalign = fold_convert (ssizetype, init);\n-      else\n-\t/* Not constant, misalignment cannot be calculated.  */\n-\t*misalign = NULL_TREE;\n-\n-      *initial_offset = fold_convert (ssizetype, init); \n-\n-      *step = evolution ? fold_convert (ssizetype, evolution) : ssize_int (0);\n-      return true;      \n-    }\n-\n-  /* Recursive computation.  */\n-  if (!BINARY_CLASS_P (expr))\n-    {\n-      /* We expect to get binary expressions (PLUS/MINUS and MULT).  */\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        {\n-\t  fprintf (vect_dump, \"Not binary expression \");\n-          print_generic_expr (vect_dump, expr, TDF_SLIM);\n-\t}\n-      return false;\n-    }\n-  oprnd0 = TREE_OPERAND (expr, 0);\n-  oprnd1 = TREE_OPERAND (expr, 1);\n-\n-  if (!vect_analyze_offset_expr (oprnd0, loop, vectype_alignment, &left_offset, \n-\t\t\t\t&left_misalign, &left_step)\n-      || !vect_analyze_offset_expr (oprnd1, loop, vectype_alignment, \n-\t\t\t\t   &right_offset, &right_misalign, &right_step))\n-    return false;\n-\n-  /* The type of the operation: plus, minus or mult.  */\n-  code = TREE_CODE (expr);\n-  switch (code)\n-    {\n-    case MULT_EXPR:\n-      if (TREE_CODE (right_offset) != INTEGER_CST)\n-\t/* RIGHT_OFFSET can be not constant. For example, for arrays of variable \n-\t   sized types. \n-\t   FORNOW: We don't support such cases.  */\n-\treturn false;\n-\n-      /* Strip conversions that don't narrow the mode.  */\n-      left_offset = vect_strip_conversion (left_offset);      \n-      if (!left_offset)\n-\treturn false;      \n-      /* Misalignment computation.  */\n-      if (SSA_VAR_P (left_offset))\n-\t{\n-\t  /* If the left side contains variables that can't be substituted with \n-\t     constants, we check if the right side is a multiple of ALIGNMENT.\n-\t   */\n-\t  if (integer_zerop (size_binop (TRUNC_MOD_EXPR, right_offset, \n-\t\t\t          fold_convert (ssizetype, vectype_alignment))))\n-\t    *misalign = ssize_int (0);\n-\t  else\n-\t    /* If the remainder is not zero or the right side isn't constant,\n-\t       we can't compute  misalignment.  */\n-\t    *misalign = NULL_TREE;\n-\t}\n-      else \n-\t{\n-\t  /* The left operand was successfully substituted with constant.  */\t  \n-\t  if (left_misalign)\n-\t    /* In case of EXPR '(i * C1 + j) * C2', LEFT_MISALIGN is \n-\t       NULL_TREE.  */\n-\t    *misalign  = size_binop (code, left_misalign, right_misalign);\n-\t  else\n-\t    *misalign = NULL_TREE; \n-\t}\n-\n-      /* Step calculation.  */\n-      /* Multiply the step by the right operand.  */\n-      *step  = size_binop (MULT_EXPR, left_step, right_offset);\n-      break;\n-   \n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      /* Combine the recursive calculations for step and misalignment.  */\n-      *step = size_binop (code, left_step, right_step);\n-   \n-      if (left_misalign && right_misalign)\n-\t*misalign  = size_binop (code, left_misalign, right_misalign);\n-      else\n-\t*misalign = NULL_TREE;\n-    \n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Compute offset.  */\n-  *initial_offset = fold_convert (ssizetype, \n-\t\t\t\t  fold_build2 (code, TREE_TYPE (left_offset),\n-\t\t\t\t\t       left_offset,\n-\t\t\t\t\t       right_offset));\n-  return true;\n-}\n-\n \n /* Function vect_determine_vectorization_factor\n \n@@ -780,144 +556,63 @@ vect_analyze_scalar_cycles (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_base_addr_differ_p.\n-\n-   This is the simplest data dependence test: determines whether the\n-   data references A and B access the same array/region.  Returns\n-   false when the property is not computable at compile time.\n-   Otherwise return true, and DIFFER_P will record the result. This\n-   utility will not be necessary when alias_sets_conflict_p will be\n-   less conservative.  */\n-\n-static bool\n-vect_base_addr_differ_p (struct data_reference *dra,\n-\t\t\t struct data_reference *drb,\n-\t\t\t bool *differ_p)\n-{\n-  tree stmt_a = DR_STMT (dra);\n-  stmt_vec_info stmt_info_a = vinfo_for_stmt (stmt_a);   \n-  tree stmt_b = DR_STMT (drb);\n-  stmt_vec_info stmt_info_b = vinfo_for_stmt (stmt_b);   \n-  tree addr_a = STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info_a);\n-  tree addr_b = STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info_b);\n-  tree type_a = TREE_TYPE (addr_a);\n-  tree type_b = TREE_TYPE (addr_b);\n-  HOST_WIDE_INT alias_set_a, alias_set_b;\n-\n-  gcc_assert (POINTER_TYPE_P (type_a) &&  POINTER_TYPE_P (type_b));\n-  \n-  /* Both references are ADDR_EXPR, i.e., we have the objects.  */\n-  if (TREE_CODE (addr_a) == ADDR_EXPR && TREE_CODE (addr_b) == ADDR_EXPR)\n-    return array_base_name_differ_p (dra, drb, differ_p);  \n-\n-  alias_set_a = (TREE_CODE (addr_a) == ADDR_EXPR) ? \n-    get_alias_set (TREE_OPERAND (addr_a, 0)) : get_alias_set (addr_a);\n-  alias_set_b = (TREE_CODE (addr_b) == ADDR_EXPR) ? \n-    get_alias_set (TREE_OPERAND (addr_b, 0)) : get_alias_set (addr_b);\n-\n-  if (!alias_sets_conflict_p (alias_set_a, alias_set_b))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-  \n-  /* An instruction writing through a restricted pointer is \"independent\" of any \n-     instruction reading or writing through a different pointer, in the same \n-     block/scope.  */\n-  else if ((TYPE_RESTRICT (type_a) && !DR_IS_READ (dra))\n-      || (TYPE_RESTRICT (type_b) && !DR_IS_READ (drb)))\n-    {\n-      *differ_p = true;\n-      return true;\n-    }\n-  return false;\n-}\n-\n-\n /* Function vect_analyze_data_ref_dependence.\n \n    Return TRUE if there (might) exist a dependence between a memory-reference\n    DRA and a memory-reference DRB.  */\n-\n+      \n static bool\n-vect_analyze_data_ref_dependence (struct data_reference *dra,\n-\t\t\t\t  struct data_reference *drb, \n-\t\t\t\t  loop_vec_info loop_vinfo)\n+vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n+                                  loop_vec_info loop_vinfo)\n {\n-  bool differ_p; \n-  struct data_dependence_relation *ddr;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   int vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n   int dist = 0;\n   unsigned int loop_depth = 0;\n-  struct loop *loop_nest = loop;  \n-  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra));\n+  struct loop *loop_nest = loop;\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+  stmt_vec_info stmtinfo_a = vinfo_for_stmt (DR_STMT (dra)); \n   stmt_vec_info stmtinfo_b = vinfo_for_stmt (DR_STMT (drb));\n+         \n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+    return false;\n   \n-  if (!vect_base_addr_differ_p (dra, drb, &differ_p))\n+  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         {\n           fprintf (vect_dump,\n-                \"not vectorized: can't determine dependence between: \");\n+                   \"not vectorized: can't determine dependence between \");\n           print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n       return true;\n     }\n \n-  if (differ_p)\n-    return false;\n-\n-  ddr = initialize_data_dependence_relation (dra, drb);\n-  compute_affine_dependence (ddr);\n-\n-  if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n-    return false;\n-\n-  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+  if (!DDR_DIST_VECT (ddr))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n         {\n-          fprintf (vect_dump, \n-                   \"not vectorized: can't determine dependence between \"); \n+          fprintf (vect_dump, \"not vectorized: bad dist vector for \");\n           print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n           fprintf (vect_dump, \" and \");\n           print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n         }\n       return true;\n-    }\n+    }    \n \n   /* Find loop depth.  */\n-  while (loop_nest)\n+  while (loop_nest && loop_nest->outer && loop_nest->outer->outer)\n     {\n-      if (loop_nest->outer && loop_nest->outer->outer)\n-\t{\n-\t  loop_nest = loop_nest->outer;\n-\t  loop_depth++;\n-\t}\n-      else\n-\tbreak;\n-    }\n-\n-  /* Compute distance vector.  */\n-  compute_subscript_distance (ddr);\n-  build_classic_dist_vector (ddr, vect_loops_num, loop_nest->depth);\n-\n-  if (!DDR_DIST_VECT (ddr))\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t{\n-\t  fprintf (vect_dump, \"not vectorized: bad dist vector for \");\n-\t  print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-\t  fprintf (vect_dump, \" and \");\n-\t  print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n-\t}      \n-      return true;\n+      loop_nest = loop_nest->outer;\n+      loop_depth++;\n     }\n-\n+         \n   dist = DDR_DIST_VECT (ddr)[loop_depth];\n+  if (vect_print_dump_info (REPORT_DR_DETAILS))\n+    fprintf (vect_dump, \"dependence distance  = %d.\",dist);\n \n   /* Same loop iteration.  */\n   if (dist % vectorization_factor == 0)\n@@ -926,76 +621,59 @@ vect_analyze_data_ref_dependence (struct data_reference *dra,\n       VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_a), drb);\n       VEC_safe_push (dr_p, heap, STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b), dra);\n       if (vect_print_dump_info (REPORT_ALIGNMENT))\n-\tfprintf (vect_dump, \"accesses have the same alignment.\");\n+        fprintf (vect_dump, \"accesses have the same alignment.\");\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+        {\n+          fprintf (vect_dump, \"dependence distance modulo vf == 0 between \");\n+          print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n+          fprintf (vect_dump, \" and \");\n+          print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n+        }\n       return false;\n-    }\n+    }    \n \n-  if (dist >= vectorization_factor)\n-    /* Dependence distance does not create dependence, as far as vectorization\n-       is concerned, in this case.  */\n-    return false;\n-    \n+  if (abs (dist) >= vectorization_factor)\n+    {\n+      /* Dependence distance does not create dependence, as far as vectorization\n+         is concerned, in this case.  */\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+        fprintf (vect_dump, \"dependence distance >= VF.\");\n+       return false;\n+    }\n+  \n   if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n     {\n       fprintf (vect_dump,\n-\t\"not vectorized: possible dependence between data-refs \");\n+        \"not vectorized: possible dependence between data-refs \");\n       print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n       fprintf (vect_dump, \" and \");\n       print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n     }\n-\n+        \n   return true;\n }\n \n \n /* Function vect_analyze_data_ref_dependences.\n-\n+          \n    Examine all the data references in the loop, and make sure there do not\n    exist any data dependences between them.  */\n-\n+         \n static bool\n vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n {\n-  unsigned int i, j;\n-  varray_type loop_write_refs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  varray_type loop_read_refs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n-\n-  /* Examine store-store (output) dependences.  */\n+  unsigned int i;\n+  varray_type ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n+  if (vect_print_dump_info (REPORT_DETAILS)) \n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"compare all store-store pairs.\");\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_refs); i++)\n-    {\n-      for (j = i + 1; j < VARRAY_ACTIVE_SIZE (loop_write_refs); j++)\n-\t{\n-\t  struct data_reference *dra =\n-\t    VARRAY_GENERIC_PTR (loop_write_refs, i);\n-\t  struct data_reference *drb =\n-\t    VARRAY_GENERIC_PTR (loop_write_refs, j);\n-\t  if (vect_analyze_data_ref_dependence (dra, drb, loop_vinfo))\n-\t    return false;\n-\t}\n-    }\n-\n-  /* Examine load-store (true/anti) dependences.  */\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"compare all load-store pairs.\");\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_refs); i++)\n+     \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddrs); i++)\n     {\n-      for (j = 0; j < VARRAY_ACTIVE_SIZE (loop_write_refs); j++)\n-\t{\n-\t  struct data_reference *dra = VARRAY_GENERIC_PTR (loop_read_refs, i);\n-\t  struct data_reference *drb =\n-\t    VARRAY_GENERIC_PTR (loop_write_refs, j);\n-\t  if (vect_analyze_data_ref_dependence (dra, drb, loop_vinfo))\n-\t    return false;\n-\t}\n+      struct data_dependence_relation *ddr = VARRAY_GENERIC_PTR (ddrs, i);\n+     \n+      if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n+        return false;\n     }\n \n   return true;\n@@ -1021,22 +699,26 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);  \n   tree ref = DR_REF (dr);\n   tree vectype;\n-  tree base, alignment;\n-  bool base_aligned_p;\n+  tree base, base_addr;\n+  bool base_aligned;\n   tree misalign;\n+  tree aligned_to, alignment;\n    \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"vect_compute_data_ref_alignment:\");\n \n   /* Initialize misalignment to unknown.  */\n   DR_MISALIGNMENT (dr) = -1;\n \n-  misalign = STMT_VINFO_VECT_MISALIGNMENT (stmt_info);\n-  base_aligned_p = STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info);\n-  base = build_fold_indirect_ref (STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n+  misalign = DR_OFFSET_MISALIGNMENT (dr);\n+  aligned_to = DR_ALIGNED_TO (dr);\n+  base_addr = DR_BASE_ADDRESS (dr);\n+  base = build_fold_indirect_ref (base_addr);\n   vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n \n-  if (!misalign)\n+  if ((aligned_to && tree_int_cst_compare (aligned_to, alignment) < 0)\n+      || !misalign)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n \t{\n@@ -1046,7 +728,18 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       return true;\n     }\n \n-  if (!base_aligned_p) \n+  if ((DECL_P (base) \n+       && tree_int_cst_compare (ssize_int (DECL_ALIGN_UNIT (base)),\n+\t\t\t\talignment) >= 0)\n+      || (TREE_CODE (base_addr) == SSA_NAME\n+\t  && tree_int_cst_compare (ssize_int (TYPE_ALIGN_UNIT (TREE_TYPE (\n+\t\t\t\t\t\t      TREE_TYPE (base_addr)))),\n+\t\t\t\t   alignment) >= 0))\n+    base_aligned = true;\n+  else\n+    base_aligned = false;   \n+\n+  if (!base_aligned) \n     {\n       if (!vect_can_force_dr_alignment_p (base, TYPE_ALIGN (vectype)))\n \t{\n@@ -1068,15 +761,13 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n     }\n \n   /* At this point we assume that the base is aligned.  */\n-  gcc_assert (base_aligned_p \n+  gcc_assert (base_aligned\n \t      || (TREE_CODE (base) == VAR_DECL \n \t\t  && DECL_ALIGN (base) >= TYPE_ALIGN (vectype)));\n \n-  /* Alignment required, in bytes:  */\n-  alignment = ssize_int (TYPE_ALIGN (vectype)/BITS_PER_UNIT);\n-\n   /* Modulo alignment.  */\n   misalign = size_binop (TRUNC_MOD_EXPR, misalign, alignment);\n+\n   if (tree_int_cst_sgn (misalign) < 0)\n     {\n       /* Negative misalignment value.  */\n@@ -1088,7 +779,10 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n   DR_MISALIGNMENT (dr) = tree_low_cst (misalign, 1);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"misalign = %d bytes\", DR_MISALIGNMENT (dr));\n+    {\n+      fprintf (vect_dump, \"misalign = %d bytes of ref \", DR_MISALIGNMENT (dr));\n+      print_generic_expr (vect_dump, ref, TDF_SLIM);\n+    }\n \n   return true;\n }\n@@ -1106,20 +800,12 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n static bool\n vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n+  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   unsigned int i;\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      if (!vect_compute_data_ref_alignment (dr))\n-\treturn false;\n-    }\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       if (!vect_compute_data_ref_alignment (dr))\n \treturn false;\n     }\n@@ -1141,13 +827,13 @@ vect_compute_data_refs_alignment (loop_vec_info loop_vinfo)\n static void\n vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n-  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n+  varray_type loop_datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   varray_type datarefs;\n   VEC(dr_p,heap) *same_align_drs;\n   struct data_reference *dr0 = NULL;\n   struct data_reference *dr;\n   unsigned int i, j;\n+  bool check_loads;\n \n   /*\n      This pass will require a cost model to guide it whether to apply peeling \n@@ -1248,10 +934,10 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n      TODO: Use a better cost model.  */\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_datarefs); i++)\n     {\n-      dr0 = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      if (!aligned_access_p (dr0))\n+      dr0 = VARRAY_GENERIC_PTR (loop_datarefs, i);\n+      if (!DR_IS_READ (dr0) && !aligned_access_p (dr0))\n \t{\n \t  LOOP_VINFO_UNALIGNED_DR (loop_vinfo) = dr0;\n \t  LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo) = DR_MISALIGNMENT (dr0);\n@@ -1285,14 +971,15 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  npeel = LOOP_VINFO_VECT_FACTOR (loop_vinfo) - mis;\n \t}\n \n-      datarefs = loop_write_datarefs;\n+      datarefs = loop_datarefs;\n+      check_loads = false;\n       for (j = 0; j < 2; j++)\n \t{\n \t  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n \t    {\n \t      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n \n-\t      if (dr == dr0)\n+\t      if (dr == dr0 || (!check_loads && DR_IS_READ (dr)))\n \t\tcontinue;\n \t      if (known_alignment_for_access_p (dr)\n \t\t  && DR_MISALIGNMENT (dr) == DR_MISALIGNMENT (dr0))\n@@ -1309,7 +996,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      else\n \t\tDR_MISALIGNMENT (dr) = -1;\n \t    }\n-\t  datarefs = loop_read_datarefs;\n+\t  check_loads = true;\n \t}\n \n       same_align_drs = \n@@ -1334,8 +1021,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n static bool\n vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n {\n-  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n-  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n+  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n   enum dr_alignment_support supportable_dr_alignment;\n   unsigned int i;\n \n@@ -1364,29 +1050,19 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n   /* Finally, check that all the data references in the loop can be\n      handled with respect to their alignment.  */\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n-      if (!supportable_dr_alignment)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: unsupported unaligned load.\");\n-\t  return false;\n-\t}\n-      if (supportable_dr_alignment != dr_aligned \n-\t  && (vect_print_dump_info (REPORT_ALIGNMENT)))\n-\tfprintf (vect_dump, \"Vectorizing an unaligned access.\");\n-    }\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr);\n       if (!supportable_dr_alignment)\n \t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: unsupported unaligned store.\");\n-\t  return false;\n+            if (DR_IS_READ (dr))\n+              fprintf (vect_dump,\n+                       \"not vectorized: unsupported unaligned load.\");\n+            else\n+              fprintf (vect_dump,\n+                       \"not vectorized: unsupported unaligned store.\");\n+ \t    return false;\n \t}\n       if (supportable_dr_alignment != dr_aligned \n \t  && (vect_print_dump_info (REPORT_ALIGNMENT)))\n@@ -1395,7 +1071,6 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n   if (LOOP_VINFO_UNALIGNED_DR (loop_vinfo)\n       && vect_print_dump_info (REPORT_ALIGNMENT))\n     fprintf (vect_dump, \"Alignment of access forced using peeling.\");\n-\n   return true;\n }\n \n@@ -1408,9 +1083,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo)\n static bool\n vect_analyze_data_ref_access (struct data_reference *dr)\n {\n-  tree stmt = DR_STMT (dr);\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt); \n-  tree step = STMT_VINFO_VECT_STEP (stmt_info);\n+  tree step = DR_STEP (dr);\n   tree scalar_type = TREE_TYPE (DR_REF (dr));\n \n   if (!step || tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type)))\n@@ -1436,29 +1109,15 @@ static bool\n vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n {\n   unsigned int i;\n-  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n+  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_ref_accesses ===\");\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      bool ok = vect_analyze_data_ref_access (dr);\n-      if (!ok)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n-\t  return false;\n-\t}\n-    }\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n-      bool ok = vect_analyze_data_ref_access (dr);\n-      if (!ok)\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n+      if (!vect_analyze_data_ref_access (dr))\n \t{\n \t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n \t    fprintf (vect_dump, \"not vectorized: complicated access pattern.\");\n@@ -1470,640 +1129,106 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo)\n }\n \n \n-/* Function vect_analyze_pointer_ref_access.\n-\n-   Input:\n-   STMT - a stmt that contains a data-ref.\n-   MEMREF - a data-ref in STMT, which is an INDIRECT_REF.\n-   ACCESS_FN - the access function of MEMREF.\n-\n-   Output:\n-   If the data-ref access is vectorizable, return a data_reference structure\n-   that represents it (DR). Otherwise - return NULL.  \n-   STEP - the stride of MEMREF in the loop.\n-   INIT - the initial condition of MEMREF in the loop.\n-*/\n-\n-static struct data_reference *\n-vect_analyze_pointer_ref_access (tree memref, tree stmt, bool is_read, \n-\t\t\t\t tree access_fn, tree *ptr_init, tree *ptr_step)\n-{\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree step, init;\t\n-  tree reftype, innertype;\n-  tree indx_access_fn; \n-  int loopnum = loop->num;\n-  struct data_reference *dr;\n-\n-  if (!vect_is_simple_iv_evolution (loopnum, access_fn, &init, &step))\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: pointer access is not simple.\");\t\n-      return NULL;\n-    }\n-\n-  STRIP_NOPS (init);\n-\n-  if (!expr_invariant_in_loop_p (loop, init))\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \n-\t\t \"not vectorized: initial condition is not loop invariant.\");\t\n-      return NULL;\n-    }\n-\n-  if (TREE_CODE (step) != INTEGER_CST)\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \n-\t\t\"not vectorized: non constant step for pointer access.\");\t\n-      return NULL;\n-    }\n-\n-  reftype = TREE_TYPE (TREE_OPERAND (memref, 0));\n-  if (!POINTER_TYPE_P (reftype)) \n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\t\n-      return NULL;\n-    }\n-\n-  if (!POINTER_TYPE_P (TREE_TYPE (init))) \n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: unexpected pointer access form.\");\n-      return NULL;\n-    }\n-\n-  *ptr_step = fold_convert (ssizetype, step);\n-  innertype = TREE_TYPE (reftype);\n-  if (!COMPLETE_TYPE_P (innertype))\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: pointer to incomplete type.\");\n-      return NULL;\n-    }\n-   \n-  /* Check that STEP is a multiple of type size.  */\n-  if (!integer_zerop (size_binop (TRUNC_MOD_EXPR, *ptr_step, \n- \t\t        fold_convert (ssizetype, TYPE_SIZE_UNIT (innertype)))))\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: non consecutive access.\");\t\n-      return NULL;\n-    }\n-   \n-  indx_access_fn = \n-\tbuild_polynomial_chrec (loopnum, integer_zero_node, integer_one_node);\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    {\n-      fprintf (vect_dump, \"Access function of ptr indx: \");\n-      print_generic_expr (vect_dump, indx_access_fn, TDF_SLIM);\n-    }\n-  dr = init_data_ref (stmt, memref, NULL_TREE, indx_access_fn, is_read);\n-  *ptr_init = init;\n-  return dr;\n-}\n-\n-\n-/* Function vect_address_analysis\n-\n-   Return the BASE of the address expression EXPR.\n-   Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.\n-\n-   Input:\n-   EXPR - the address expression that is being analyzed\n-   STMT - the statement that contains EXPR or its original memory reference\n-   IS_READ - TRUE if STMT reads from EXPR, FALSE if writes to EXPR\n-   VECTYPE - the type that defines the alignment (i.e, we compute\n-             alignment relative to TYPE_ALIGN(VECTYPE))\n-   DR - data_reference struct for the original memory reference\n-\n-   Output:\n-   BASE (returned value) - the base of the data reference EXPR.\n-   INITIAL_OFFSET - initial offset of EXPR from BASE (an expression)\n-   MISALIGN - offset of EXPR from BASE in bytes (a constant) or NULL_TREE if the\n-              computation is impossible\n-   STEP - evolution of EXPR in the loop\n-   BASE_ALIGNED - indicates if BASE is aligned\n- \n-   If something unexpected is encountered (an unsupported form of data-ref),\n-   then NULL_TREE is returned.  \n- */\n-\n-static tree\n-vect_address_analysis (tree expr, tree stmt, bool is_read, tree vectype, \n-\t\t       struct data_reference *dr, tree *offset, tree *misalign,\n-\t\t       tree *step, bool *base_aligned)\n-{\n-  tree oprnd0, oprnd1, base_address, offset_expr, base_addr0, base_addr1;\n-  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n-  tree dummy;\n-  struct ptr_info_def *dummy1;\n-  subvar_t dummy2;\n-\n-  switch (TREE_CODE (expr))\n-    {\n-    case PLUS_EXPR:\n-    case MINUS_EXPR:\n-      /* EXPR is of form {base +/- offset} (or {offset +/- base}).  */\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      oprnd1 = TREE_OPERAND (expr, 1);\n-\n-      STRIP_NOPS (oprnd0);\n-      STRIP_NOPS (oprnd1);\n-      \n-      /* Recursively try to find the base of the address contained in EXPR.\n-\t For offset, the returned base will be NULL.  */\n-      base_addr0 = vect_address_analysis (oprnd0, stmt, is_read, vectype, dr, \n-\t\t\t\t     &address_offset, &address_misalign, step, \n-\t\t\t\t     base_aligned);\n-\n-      base_addr1 = vect_address_analysis (oprnd1, stmt, is_read, vectype, dr, \n-\t\t\t\t     &address_offset, &address_misalign, step, \n-\t\t\t\t     base_aligned);\n-\n-      /* We support cases where only one of the operands contains an \n-\t address.  */\n-      if ((base_addr0 && base_addr1) || (!base_addr0 && !base_addr1))\n-\treturn NULL_TREE;\n-\n-      /* To revert STRIP_NOPS.  */\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      oprnd1 = TREE_OPERAND (expr, 1);\n-      \n-      offset_expr = base_addr0 ? \n-\tfold_convert (ssizetype, oprnd1) : fold_convert (ssizetype, oprnd0);\n-\n-      /* EXPR is of form {base +/- offset} (or {offset +/- base}). If offset is \n-\t a number, we can add it to the misalignment value calculated for base,\n-\t otherwise, misalignment is NULL.  */\n-      if (TREE_CODE (offset_expr) == INTEGER_CST && address_misalign)\n-\t*misalign = size_binop (TREE_CODE (expr), address_misalign, \n-\t\t\t\toffset_expr);\n-      else\n-\t*misalign = NULL_TREE;\n-\n-      /* Combine offset (from EXPR {base + offset}) with the offset calculated\n-\t for base.  */\n-      *offset = size_binop (TREE_CODE (expr), address_offset, offset_expr);\n-      return base_addr0 ? base_addr0 : base_addr1;\n-\n-    case ADDR_EXPR:\n-      base_address = vect_object_analysis (TREE_OPERAND (expr, 0), stmt,\n-\t\t\t\t\t   is_read, vectype, &dr, offset, \n-\t\t\t\t\t   misalign, step, base_aligned, \n-\t\t\t\t\t   &dummy, &dummy1, &dummy2);\n-      return base_address;\n-\n-    case SSA_NAME:\n-      if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n-\treturn NULL_TREE;\n-\n-      if (TYPE_ALIGN (TREE_TYPE (TREE_TYPE (expr))) < TYPE_ALIGN (vectype)) \n-\t{\n-\t  if (vect_get_ptr_offset (expr, vectype, misalign))\n-\t    *base_aligned = true;\t  \n-\t  else\n-\t    *base_aligned = false;\n-\t}\n-      else\n-\t{\t  \n-\t  *base_aligned = true;\n-\t  *misalign = ssize_int (0);\n-\t}\n-      *offset = ssize_int (0);\n-      *step = ssize_int (0);\n-      return expr;\n-      \n-    default:\n-      return NULL_TREE;\n-    }\n-}\n-\n-\n-/* Function vect_object_analysis\n-\n-   Return the BASE of the data reference MEMREF.\n-   Also compute the INITIAL_OFFSET from BASE, MISALIGN and STEP.\n-   E.g., for EXPR a.b[i] + 4B, BASE is a, and OFFSET is the overall offset  \n-   'a.b[i] + 4B' from a (can be an expression), MISALIGN is an OFFSET \n-   instantiated with initial_conditions of access_functions of variables, \n-   modulo alignment, and STEP is the evolution of the DR_REF in this loop.\n-\n-   Function get_inner_reference is used for the above in case of ARRAY_REF and\n-   COMPONENT_REF.\n-\n-   The structure of the function is as follows:\n-   Part 1:\n-   Case 1. For handled_component_p refs \n-          1.1 call get_inner_reference\n-            1.1.1 analyze offset expr received from get_inner_reference\n-\t  1.2. build data-reference structure for MEMREF\n-        (fall through with BASE)\n-   Case 2. For declarations \n-          2.1 check alignment\n-          2.2 update DR_BASE_NAME if necessary for alias\n-   Case 3. For INDIRECT_REFs \n-          3.1 get the access function\n-\t  3.2 analyze evolution of MEMREF\n-\t  3.3 set data-reference structure for MEMREF\n-          3.4 call vect_address_analysis to analyze INIT of the access function\n-\n-   Part 2:\n-   Combine the results of object and address analysis to calculate \n-   INITIAL_OFFSET, STEP and misalignment info.   \n-\n-   Input:\n-   MEMREF - the memory reference that is being analyzed\n-   STMT - the statement that contains MEMREF\n-   IS_READ - TRUE if STMT reads from MEMREF, FALSE if writes to MEMREF\n-   VECTYPE - the type that defines the alignment (i.e, we compute\n-             alignment relative to TYPE_ALIGN(VECTYPE))\n-   \n-   Output:\n-   BASE_ADDRESS (returned value) - the base address of the data reference MEMREF\n-                                   E.g, if MEMREF is a.b[k].c[i][j] the returned\n-\t\t\t           base is &a.\n-   DR - data_reference struct for MEMREF\n-   INITIAL_OFFSET - initial offset of MEMREF from BASE (an expression)\n-   MISALIGN - offset of MEMREF from BASE in bytes (a constant) or NULL_TREE if \n-              the computation is impossible\n-   STEP - evolution of the DR_REF in the loop\n-   BASE_ALIGNED - indicates if BASE is aligned\n-   MEMTAG - memory tag for aliasing purposes\n-   PTR_INFO - NULL or points-to aliasing info from a pointer SSA_NAME\n-   SUBVAR - Sub-variables of the variable\n- \n-   If something unexpected is encountered (an unsupported form of data-ref),\n-   then NULL_TREE is returned.  */\n-\n-static tree\n-vect_object_analysis (tree memref, tree stmt, bool is_read,\n-\t\t      tree vectype, struct data_reference **dr,\n-\t\t      tree *offset, tree *misalign, tree *step,\n-\t\t      bool *base_aligned, tree *memtag,\n-\t\t      struct ptr_info_def **ptr_info, subvar_t *subvars)\n-{\n-  tree base = NULL_TREE, base_address = NULL_TREE;\n-  tree object_offset = ssize_int (0), object_misalign = ssize_int (0);\n-  tree object_step = ssize_int (0), address_step = ssize_int (0);\n-  bool object_base_aligned = true, address_base_aligned = true;\n-  tree address_offset = ssize_int (0), address_misalign = ssize_int (0);\n-  HOST_WIDE_INT pbitsize, pbitpos;\n-  tree poffset, bit_pos_in_bytes;\n-  enum machine_mode pmode;\n-  int punsignedp, pvolatilep;\n-  tree ptr_step = ssize_int (0), ptr_init = NULL_TREE;\n-  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n-  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  struct data_reference *ptr_dr = NULL;\n-  tree access_fn, evolution_part, address_to_analyze;\n-\n-  *ptr_info = NULL;\n-   \n-  /* Part 1: */\n-  /* Case 1. handled_component_p refs.  */\n-  if (handled_component_p (memref))\n-    {\n-      /* 1.1 call get_inner_reference.  */\n-      /* Find the base and the offset from it.  */\n-      base = get_inner_reference (memref, &pbitsize, &pbitpos, &poffset,\n-\t\t\t\t  &pmode, &punsignedp, &pvolatilep, false);\n-      if (!base)\n-\treturn NULL_TREE;\n-\n-      /* 1.1.1 analyze offset expr received from get_inner_reference.  */\n-      if (poffset \n-\t  && !vect_analyze_offset_expr (poffset, loop, TYPE_SIZE_UNIT (vectype), \n-\t\t\t\t&object_offset, &object_misalign, &object_step))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    {\n-\t      fprintf (vect_dump, \"failed to compute offset or step for \");\n-\t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n-\n-      /* Add bit position to OFFSET and MISALIGN.  */\n-\n-      bit_pos_in_bytes = ssize_int (pbitpos/BITS_PER_UNIT);\n-      /* Check that there is no remainder in bits.  */\n-      if (pbitpos%BITS_PER_UNIT)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"bit offset alignment.\");\n-\t  return NULL_TREE;\n-\t}\n-      object_offset = size_binop (PLUS_EXPR, bit_pos_in_bytes, object_offset);     \n-      if (object_misalign) \n-\tobject_misalign = size_binop (PLUS_EXPR, object_misalign, \n-\t\t\t\t      bit_pos_in_bytes); \n-\n-      /* Create data-reference for MEMREF. TODO: handle COMPONENT_REFs.  */\n-      if (!(*dr))\n-\t{ \n-\t  if (TREE_CODE (memref) == ARRAY_REF)\n-\t    *dr = analyze_array (stmt, memref, is_read);\n-\t  else\n-\t    /* FORNOW.  */\n-\t    return NULL_TREE;\n-\t}\n-      memref = base; /* To continue analysis of BASE.  */\n-      /* fall through  */\n-    }\n-  \n-  /*  Part 1: Case 2. Declarations.  */ \n-  if (DECL_P (memref))\n-    {\n-      /* We expect to get a decl only if we already have a DR.  */\n-      if (!(*dr))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    {\n-\t      fprintf (vect_dump, \"unhandled decl \");\n-\t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n-\n-      /* 2.1 check the alignment.  */\n-      if (DECL_ALIGN (memref) >= TYPE_ALIGN (vectype))\n-\tobject_base_aligned = true;\n-      else\n-\tobject_base_aligned = false;\n-\n-      /* 2.2 update DR_BASE_NAME if necessary.  */\n-      if (!DR_BASE_NAME ((*dr)))\n-\t/* For alias analysis.  In case the analysis of INDIRECT_REF brought \n-\t   us to object.  */\n-\tDR_BASE_NAME ((*dr)) = memref;\n-\n-      if (SSA_VAR_P (memref) && var_can_have_subvars (memref))\t\n-\t*subvars = get_subvars_for_var (memref);\n-      base_address = build_fold_addr_expr (memref);\n-      *memtag = memref;\n-    }\n-\n-  /* Part 1:  Case 3. INDIRECT_REFs.  */\n-  else if (TREE_CODE (memref) == INDIRECT_REF)\n-    {\n-      tree ptr_ref = TREE_OPERAND (memref, 0);\n-      if (TREE_CODE (ptr_ref) == SSA_NAME)\n-        *ptr_info = SSA_NAME_PTR_INFO (ptr_ref);\n-\n-      /* 3.1 get the access function.  */\n-      access_fn = analyze_scalar_evolution (loop, ptr_ref);\n-      if (!access_fn)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    fprintf (vect_dump, \"not vectorized: complicated pointer access.\");\t\n-\t  return NULL_TREE;\n-\t}\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\t{\n-\t  fprintf (vect_dump, \"Access function of ptr: \");\n-\t  print_generic_expr (vect_dump, access_fn, TDF_SLIM);\n-\t}\n-\n-      /* 3.2 analyze evolution of MEMREF.  */\n-      evolution_part = evolution_part_in_loop_num (access_fn, loop->num);\n-      if (evolution_part)\n-\t{\n-\t  ptr_dr = vect_analyze_pointer_ref_access (memref, stmt, is_read, \n-\t\t\t\t         access_fn, &ptr_init, &ptr_step);\n-\t  if (!(ptr_dr))\n-\t    return NULL_TREE; \n-\t  \n-\t  object_step = size_binop (PLUS_EXPR, object_step, ptr_step);\n-\t  address_to_analyze = ptr_init;\n-\t}\n-      else\n-\t{\n-\t  if (!(*dr))\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t\tfprintf (vect_dump, \"not vectorized: ptr is loop invariant.\");\t\n-\t      return NULL_TREE;\n-\t    }\n-\t  /* Since there exists DR for MEMREF, we are analyzing the init of \n-\t     the access function, which not necessary has evolution in the \n-\t     loop.  */\n-\t  address_to_analyze = initial_condition_in_loop_num (access_fn,\n-                                                              loop->num);\n-\t}\n-      \n-      /* 3.3 set data-reference structure for MEMREF.  */\n-      *dr = (*dr) ? *dr : ptr_dr;\n-\n-      /* 3.4 call vect_address_analysis to analyze INIT of the access \n-\t function.  */\n-      base_address = vect_address_analysis (address_to_analyze, stmt, is_read, \n-\t\t\t       vectype, *dr, &address_offset, &address_misalign, \n-\t\t\t       &address_step, &address_base_aligned);\n-      if (!base_address)\n-\treturn NULL_TREE;\n-\n-      switch (TREE_CODE (base_address))\n-\t{\n-\tcase SSA_NAME:\n-\t  *memtag = get_var_ann (SSA_NAME_VAR (base_address))->type_mem_tag;\n-\t  if (!(*memtag) && TREE_CODE (TREE_OPERAND (memref, 0)) == SSA_NAME)\n-\t    *memtag = get_var_ann (\n-\t\t      SSA_NAME_VAR (TREE_OPERAND (memref, 0)))->type_mem_tag;\n-\t  break;\n-\tcase ADDR_EXPR:\n-\t  *memtag = TREE_OPERAND (base_address, 0);\n-\t  break;\n-\tdefault:\n-\t  if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t    {\n-\t      fprintf (vect_dump, \"not vectorized: no memtag ref: \"); \n-\t      print_generic_expr (vect_dump, memref, TDF_SLIM);\n-\t    }\n-\t  return NULL_TREE;\n-\t}\n-    }\n-    \t    \n-  if (!base_address)\n-    /* MEMREF cannot be analyzed.  */\n-    return NULL_TREE;\n-\n-  if (SSA_VAR_P (*memtag) && var_can_have_subvars (*memtag))\n-    *subvars = get_subvars_for_var (*memtag);\n-\n-  /* Part 2: Combine the results of object and address analysis to calculate \n-     INITIAL_OFFSET, STEP and misalignment info.  */\n-  *offset = size_binop (PLUS_EXPR, object_offset, address_offset);\n-  if (object_misalign && address_misalign)\n-    *misalign = size_binop (PLUS_EXPR, object_misalign, address_misalign);\n-  else\n-    *misalign = NULL_TREE;\n-  *step = size_binop (PLUS_EXPR, object_step, address_step); \n-  *base_aligned = object_base_aligned && address_base_aligned;\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    {\n-      fprintf (vect_dump, \"Results of object analysis for: \");\n-      print_generic_expr (vect_dump, memref, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\\tbase_address: \");\n-      print_generic_expr (vect_dump, base_address, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\\toffset: \");\n-      print_generic_expr (vect_dump, *offset, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\\tstep: \");\n-      print_generic_expr (vect_dump, *step, TDF_SLIM);\n-      fprintf (vect_dump, \"\\n\\tbase aligned %d\\n\\tmisalign: \", *base_aligned);\n-      print_generic_expr (vect_dump, *misalign, TDF_SLIM);\n-    }\n-  return base_address;\n-}\n-\n-\n /* Function vect_analyze_data_refs.\n \n-   Find all the data references in the loop.\n+  Find all the data references in the loop.\n \n-   The general structure of the analysis of data refs in the vectorizer is as \n+   The general structure of the analysis of data refs in the vectorizer is as\n    follows:\n-   1- vect_analyze_data_refs(loop): \n-      Find and analyze all data-refs in the loop:\n-          foreach ref\n-\t     base_address = vect_object_analysis(ref)\n-      1.1- vect_object_analysis(ref): \n-           Analyze ref, and build a DR (data_reference struct) for it;\n-           compute base, initial_offset, step and alignment. \n-           Call get_inner_reference for refs handled in this function.\n-           Call vect_addr_analysis(addr) to analyze pointer type expressions.\n-      Set ref_stmt.base, ref_stmt.initial_offset, ref_stmt.alignment,  \n-      ref_stmt.memtag, ref_stmt.ptr_info and ref_stmt.step accordingly. \n-   2- vect_analyze_dependences(): apply dependence testing using ref_stmt.DR\n+   1- vect_analyze_data_refs(loop): call compute_data_dependences_for_loop to\n+      find and analyze all data-refs in the loop and their dependences.\n+   2- vect_analyze_dependences(): apply dependence testing using ddrs.\n    3- vect_analyze_drs_alignment(): check that ref_stmt.alignment is ok.\n    4- vect_analyze_drs_access(): check that ref_stmt.step is ok.\n \n-   FORNOW: Handle aligned INDIRECT_REFs and ARRAY_REFs \n-\t   which base is really an array (not a pointer) and which alignment \n-\t   can be forced. This restriction will be relaxed.  */\n+*/\n \n static bool\n-vect_analyze_data_refs (loop_vec_info loop_vinfo)\n+vect_analyze_data_refs (loop_vec_info loop_vinfo)  \n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  int nbbs = loop->num_nodes;\n-  block_stmt_iterator si;\n-  int j;\n-  struct data_reference *dr;\n+  unsigned int i;\n+  varray_type datarefs;\n+  tree scalar_type;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_data_refs ===\");\n \n-  for (j = 0; j < nbbs; j++)\n-    {\n-      basic_block bb = bbs[j];\n-      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-\t{\n-\t  bool is_read = false;\n-\t  tree stmt = bsi_stmt (si);\n-\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n-\t  varray_type *datarefs = NULL;\n-\t  tree memref = NULL;\n-\t  tree scalar_type, vectype;\t  \n-\t  tree base, offset, misalign, step, tag;\n-\t  struct ptr_info_def *ptr_info;\n-\t  bool base_aligned;\n-\t  subvar_t subvars = NULL;\n-\t  bool no_vuse, no_vmaymust;\n-\n-\t  /* Assumption: there exists a data-ref in stmt, if and only if \n-             it has vuses/vdefs.  */\n-\n-\t  no_vuse = ZERO_SSA_OPERANDS (stmt, SSA_OP_VUSE);\n-\t  no_vmaymust = ZERO_SSA_OPERANDS (stmt,\n-\t\t\t\t\t   SSA_OP_VMAYDEF | SSA_OP_VMUSTDEF);\n-\t  if (no_vuse && no_vmaymust)\n-\t    continue;\n+  compute_data_dependences_for_loop (loop, false,\n+                                     &(LOOP_VINFO_DATAREFS (loop_vinfo)),\n+                                     &(LOOP_VINFO_DDRS (loop_vinfo)));\n \n-\t  if (!no_vuse && !no_vmaymust)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t{\n-\t\t  fprintf (vect_dump, \"unexpected vdefs and vuses in stmt: \");\n-\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-\t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t{\n-\t\t  fprintf (vect_dump, \"unexpected vops in stmt: \");\n-\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n-\n-\t  if (!no_vuse)\n-\t    {\n-\t      memref = TREE_OPERAND (stmt, 1);\n-\t      datarefs = &(LOOP_VINFO_DATAREF_READS (loop_vinfo));\n-\t      is_read = true;\n-\t    } \n-\t  else /* vdefs */\n-\t    {\n-\t      memref = TREE_OPERAND (stmt, 0);\n-\t      datarefs = &(LOOP_VINFO_DATAREF_WRITES (loop_vinfo));\n-\t      is_read = false;\n-\t    }\n-\t  \n-\t  scalar_type = TREE_TYPE (memref);\n-\t  vectype = get_vectype_for_scalar_type (scalar_type);\n-\t  if (!vectype)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_DETAILS))\n-\t\t{\n-\t\t  fprintf (vect_dump, \"no vectype for stmt: \");\n-\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t  fprintf (vect_dump, \" scalar_type: \");\n-\t\t  print_generic_expr (vect_dump, scalar_type, TDF_DETAILS);\n-\t\t}\n-\t      /* It is not possible to vectorize this data reference.  */\n-\t      return false;\n-\t    }\n-\t /* Analyze MEMREF. If it is of a supported form, build data_reference\n-\t     struct for it (DR).  */\n-\t  dr = NULL; \n-\t  base = vect_object_analysis (memref, stmt, is_read, vectype, &dr, \n-\t\t\t\t       &offset, &misalign, &step, \n-\t\t\t\t       &base_aligned, &tag, &ptr_info,\n-\t\t\t\t       &subvars);\n-\t  if (!base)\n-\t    {\n-\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\t\t{\n-\t\t  fprintf (vect_dump, \"not vectorized: unhandled data ref: \"); \n-\t\t  print_generic_expr (vect_dump, stmt, TDF_SLIM);\n-\t\t}\n-\t      return false;\n-\t    }\n-\t  STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info) = base;\n-\t  STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n-\t  STMT_VINFO_VECT_STEP (stmt_info) = step;\n-\t  STMT_VINFO_VECT_MISALIGNMENT (stmt_info) = misalign;\n-\t  STMT_VINFO_VECT_BASE_ALIGNED_P (stmt_info) = base_aligned;\n-\t  STMT_VINFO_MEMTAG (stmt_info) = tag;\n-\t  STMT_VINFO_PTR_INFO (stmt_info) = ptr_info;\n-\t  STMT_VINFO_SUBVARS (stmt_info) = subvars;\n-\t  STMT_VINFO_VECTYPE (stmt_info) = vectype;\n-\t  VARRAY_PUSH_GENERIC_PTR (*datarefs, dr);\n-\t  STMT_VINFO_DATA_REF (stmt_info) = dr;\n-\t}\n+  /* Go through the data-refs, check that the analysis succeeded. Update pointer\n+     from stmt_vec_info struct to DR and vectype.  */\n+  datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+    {\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n+      tree stmt;\n+      stmt_vec_info stmt_info;\n+   \n+      if (!dr || !DR_REF (dr))\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+              fprintf (vect_dump, \"not vectorized: unhandled data-ref \");\n+          return false;\n+        }\n+ \n+      /* Update DR field in stmt_vec_info struct.  */\n+      stmt = DR_STMT (dr);\n+      stmt_info = vinfo_for_stmt (stmt);\n+  \n+      if (STMT_VINFO_DATA_REF (stmt_info))\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+            {\n+              fprintf (vect_dump,\n+                       \"not vectorized: more than one data ref in stmt: \");\n+              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+            }\n+          return false;\n+        }\n+      STMT_VINFO_DATA_REF (stmt_info) = dr;\n+     \n+      /* Check that analysis of the data-ref succeeded.  */\n+      if (!DR_BASE_ADDRESS (dr) || !DR_OFFSET (dr) || !DR_INIT (dr)\n+          || !DR_STEP (dr))   \n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+            {\n+              fprintf (vect_dump, \"not vectorized: data ref analysis failed \");\n+              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+            }\n+          return false;\n+        }\n+      if (!DR_MEMTAG (dr))\n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+            {\n+              fprintf (vect_dump, \"not vectorized: no memory tag for \");\n+              print_generic_expr (vect_dump, DR_REF (dr), TDF_SLIM);\n+            }\n+          return false;\n+        }\n+                       \n+      /* Set vectype for STMT.  */\n+      scalar_type = TREE_TYPE (DR_REF (dr));\n+      STMT_VINFO_VECTYPE (stmt_info) =\n+                get_vectype_for_scalar_type (scalar_type);\n+      if (!STMT_VINFO_VECTYPE (stmt_info)) \n+        {\n+          if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+            {\n+              fprintf (vect_dump,\n+                       \"not vectorized: no vectype for stmt: \");\n+              print_generic_expr (vect_dump, stmt, TDF_SLIM);\n+              fprintf (vect_dump, \" scalar_type: \");\n+              print_generic_expr (vect_dump, scalar_type, TDF_DETAILS);\n+            }\n+          return false;\n+        }\n     }\n-\n+      \n   return true;\n }\n "}, {"sha": "9dab8bcda4bff77455f0fdc6cebf2c31d4668b9e", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -189,8 +189,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree data_ref_base = \n-    unshare_expr (STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info));\n+  tree data_ref_base = unshare_expr (DR_BASE_ADDRESS (dr));\n   tree base_name = build_fold_indirect_ref (data_ref_base);\n   tree ref = DR_REF (dr);\n   tree scalar_type = TREE_TYPE (ref);\n@@ -199,9 +198,11 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n   tree new_temp;\n   tree addr_base, addr_expr;\n   tree dest, new_stmt;\n-  tree base_offset = unshare_expr (STMT_VINFO_VECT_INIT_OFFSET (stmt_info));\n+  tree base_offset = unshare_expr (DR_OFFSET (dr));\n+  tree init = unshare_expr (DR_INIT (dr));\n \n   /* Create base_offset */\n+  base_offset = size_binop (PLUS_EXPR, base_offset, init);\n   dest = create_tmp_var (TREE_TYPE (base_offset), \"base_off\");\n   add_referenced_tmp_var (dest);\n   base_offset = force_gimple_operand (base_offset, &new_stmt, false, dest);  \n@@ -212,7 +213,7 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n       tree tmp = create_tmp_var (TREE_TYPE (base_offset), \"offset\");\n       add_referenced_tmp_var (tmp);\n       offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset), offset,\n-\t\t\t    STMT_VINFO_VECT_STEP (stmt_info));\n+\t\t\t    DR_STEP (dr));\n       base_offset = fold_build2 (PLUS_EXPR, TREE_TYPE (base_offset),\n \t\t\t\t base_offset, offset);\n       base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);  \n@@ -328,9 +329,9 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   tree ptr_update;\n   tree data_ref_ptr;\n   tree type, tmp, size;\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n \n-  base_name =  build_fold_indirect_ref (unshare_expr (\n-\t\t      STMT_VINFO_VECT_DR_BASE_ADDRESS (stmt_info)));\n+  base_name =  build_fold_indirect_ref (unshare_expr (DR_BASE_ADDRESS (dr)));\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -357,9 +358,9 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   \n   \n   /** (2) Add aliasing information to the new vector-pointer:\n-          (The points-to info (SSA_NAME_PTR_INFO) may be defined later.)  **/\n+          (The points-to info (DR_PTR_INFO) may be defined later.)  **/\n   \n-  tag = STMT_VINFO_MEMTAG (stmt_info);\n+  tag = DR_MEMTAG (dr);\n   gcc_assert (tag);\n \n   /* If tag is a variable (and NOT_A_TAG) than a new type alias\n@@ -369,7 +370,7 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   else\n     var_ann (vect_ptr)->type_mem_tag = tag;\n \n-  var_ann (vect_ptr)->subvars = STMT_VINFO_SUBVARS (stmt_info);\n+  var_ann (vect_ptr)->subvars = DR_SUBVARS (dr);\n \n   /** (3) Calculate the initial address the vector-pointer, and set\n           the vector-pointer to point to it before the loop:  **/\n@@ -397,9 +398,8 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   if (only_init) /* No update in loop is required.  */\n     {\n       /* Copy the points-to information if it exists. */\n-      if (STMT_VINFO_PTR_INFO (stmt_info))\n-        duplicate_ssa_name_ptr_info (vect_ptr_init,\n-                                     STMT_VINFO_PTR_INFO (stmt_info));\n+      if (DR_PTR_INFO (dr))\n+        duplicate_ssa_name_ptr_info (vect_ptr_init, DR_PTR_INFO (dr));\n       return vect_ptr_init;\n     }\n \n@@ -433,8 +433,8 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n   data_ref_ptr = TREE_OPERAND (vec_stmt, 0);\n \n   /* Copy the points-to information if it exists. */\n-  if (STMT_VINFO_PTR_INFO (stmt_info))\n-    duplicate_ssa_name_ptr_info (data_ref_ptr, STMT_VINFO_PTR_INFO (stmt_info));\n+  if (DR_PTR_INFO (dr))\n+    duplicate_ssa_name_ptr_info (data_ref_ptr, DR_PTR_INFO (dr));\n   return data_ref_ptr;\n }\n \n@@ -2625,18 +2625,16 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters)\n    NITERS iterations were peeled from LOOP.  DR represents a data reference\n    in LOOP.  This function updates the information recorded in DR to\n    account for the fact that the first NITERS iterations had already been \n-   executed.  Specifically, it updates the OFFSET field of stmt_info.  */\n+   executed.  Specifically, it updates the OFFSET field of DR.  */\n \n static void\n vect_update_init_of_dr (struct data_reference *dr, tree niters)\n {\n-  stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n-  tree offset = STMT_VINFO_VECT_INIT_OFFSET (stmt_info);\n+  tree offset = DR_OFFSET (dr);\n       \n-  niters = fold_build2 (MULT_EXPR, TREE_TYPE (niters), niters,\n-\t\t\tSTMT_VINFO_VECT_STEP (stmt_info));\n+  niters = fold_build2 (MULT_EXPR, TREE_TYPE (niters), niters, DR_STEP (dr));\n   offset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset, niters);\n-  STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n+  DR_OFFSET (dr) = offset;\n }\n \n \n@@ -2652,21 +2650,14 @@ static void\n vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n {\n   unsigned int i;\n-  varray_type loop_write_datarefs = LOOP_VINFO_DATAREF_WRITES (loop_vinfo);\n-  varray_type loop_read_datarefs = LOOP_VINFO_DATAREF_READS (loop_vinfo);\n+  varray_type datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n \n   if (vect_dump && (dump_flags & TDF_DETAILS))\n     fprintf (vect_dump, \"=== vect_update_inits_of_dr ===\");\n \n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_write_datarefs); i++)\n-    {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_write_datarefs, i);\n-      vect_update_init_of_dr (dr, niters);\n-    }\n-\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (loop_read_datarefs); i++)\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n     {\n-      struct data_reference *dr = VARRAY_GENERIC_PTR (loop_read_datarefs, i);\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n       vect_update_init_of_dr (dr, niters);\n     }\n }"}, {"sha": "4a9bbe8f49c1b10d013166141fbab9d7a462b592", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -1347,14 +1347,6 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;\n   else\n     STMT_VINFO_DEF_TYPE (res) = vect_loop_def;\n-  STMT_VINFO_MEMTAG (res) = NULL;\n-  STMT_VINFO_PTR_INFO (res) = NULL;\n-  STMT_VINFO_SUBVARS (res) = NULL;\n-  STMT_VINFO_VECT_DR_BASE_ADDRESS (res) = NULL;\n-  STMT_VINFO_VECT_INIT_OFFSET (res) = NULL_TREE;\n-  STMT_VINFO_VECT_STEP (res) = NULL_TREE;\n-  STMT_VINFO_VECT_BASE_ALIGNED_P (res) = false;\n-  STMT_VINFO_VECT_MISALIGNMENT (res) = NULL_TREE;\n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n \n   return res;\n@@ -1407,10 +1399,8 @@ new_loop_vec_info (struct loop *loop)\n   LOOP_VINFO_VECTORIZABLE_P (res) = 0;\n   LOOP_PEELING_FOR_ALIGNMENT (res) = 0;\n   LOOP_VINFO_VECT_FACTOR (res) = 0;\n-  VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_WRITES (res), 20,\n-\t\t\t   \"loop_write_datarefs\");\n-  VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREF_READS (res), 20,\n-\t\t\t   \"loop_read_datarefs\");\n+  VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DATAREFS (res), 20, \"loop_datarefs\");\n+  VARRAY_GENERIC_PTR_INIT (LOOP_VINFO_DDRS (res), 20, \"loop_ddrs\");\n   LOOP_VINFO_UNALIGNED_DR (res) = NULL;\n \n   return res;\n@@ -1470,39 +1460,13 @@ destroy_loop_vec_info (loop_vec_info loop_vinfo)\n     }\n \n   free (LOOP_VINFO_BBS (loop_vinfo));\n-  varray_clear (LOOP_VINFO_DATAREF_WRITES (loop_vinfo));\n-  varray_clear (LOOP_VINFO_DATAREF_READS (loop_vinfo));\n+  varray_clear (LOOP_VINFO_DATAREFS (loop_vinfo));\n+  varray_clear (LOOP_VINFO_DDRS (loop_vinfo));\n \n   free (loop_vinfo);\n }\n \n \n-/* Function vect_strip_conversions\n-\n-   Strip conversions that don't narrow the mode.  */\n-\n-tree \n-vect_strip_conversion (tree expr)\n-{\n-  tree to, ti, oprnd0;\n-  \n-  while (TREE_CODE (expr) == NOP_EXPR || TREE_CODE (expr) == CONVERT_EXPR)\n-    {\n-      to = TREE_TYPE (expr);\n-      oprnd0 = TREE_OPERAND (expr, 0);\n-      ti = TREE_TYPE (oprnd0);\n- \n-      if (!INTEGRAL_TYPE_P (to) || !INTEGRAL_TYPE_P (ti))\n-\treturn NULL_TREE;\n-      if (GET_MODE_SIZE (TYPE_MODE (to)) < GET_MODE_SIZE (TYPE_MODE (ti)))\n-\treturn NULL_TREE;\n-      \n-      expr = oprnd0;\n-    }\n-  return expr; \n-}\n-\n-\n /* Function vect_force_dr_alignment_p.\n \n    Returns whether the alignment of a DECL can be forced to be aligned"}, {"sha": "5fdca3d65021dc1f10bb749fd6be8e6a1f78078b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 19, "deletions": 63, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -73,6 +73,7 @@ enum verbosity_levels {\n   REPORT_VECTORIZED_LOOPS,\n   REPORT_UNVECTORIZED_LOOPS,\n   REPORT_ALIGNMENT,\n+  REPORT_DR_DETAILS,\n   REPORT_BAD_FORM_LOOPS,\n   REPORT_OUTER_LOOPS,\n   REPORT_DETAILS,\n@@ -116,27 +117,29 @@ typedef struct _loop_vec_info {\n                  unaligned_dr.  */\n   int peeling_for_alignment;\n \n-  /* All data references in the loop that are being written to.  */\n-  varray_type data_ref_writes;\n+  /* All data references in the loop.  */\n+  varray_type datarefs;\n \n-  /* All data references in the loop that are being read from.  */\n-  varray_type data_ref_reads;\n+  /* All data dependences in the loop.  */\n+  varray_type ddrs;\n \n+  /* The loop location in the source.  */\n+  LOC loop_line_number;\n } *loop_vec_info;\n \n-/* Access Functions.  */\n-#define LOOP_VINFO_LOOP(L)           (L)->loop\n-#define LOOP_VINFO_BBS(L)            (L)->bbs\n-#define LOOP_VINFO_EXIT_COND(L)      (L)->exit_cond\n-#define LOOP_VINFO_NITERS(L)         (L)->num_iters\n-#define LOOP_VINFO_VECTORIZABLE_P(L) (L)->vectorizable\n-#define LOOP_VINFO_VECT_FACTOR(L)    (L)->vectorization_factor\n-#define LOOP_VINFO_DATAREF_WRITES(L) (L)->data_ref_writes\n-#define LOOP_VINFO_DATAREF_READS(L)  (L)->data_ref_reads\n-#define LOOP_VINFO_INT_NITERS(L) (TREE_INT_CST_LOW ((L)->num_iters))\n+  /* Access Functions.  */\n+#define LOOP_VINFO_LOOP(L)            (L)->loop\n+#define LOOP_VINFO_BBS(L)             (L)->bbs\n+#define LOOP_VINFO_EXIT_COND(L)       (L)->exit_cond\n+#define LOOP_VINFO_NITERS(L)          (L)->num_iters\n+#define LOOP_VINFO_VECTORIZABLE_P(L)  (L)->vectorizable\n+#define LOOP_VINFO_VECT_FACTOR(L)     (L)->vectorization_factor\n+#define LOOP_VINFO_DATAREFS(L)        (L)->datarefs\n+#define LOOP_VINFO_DDRS(L)            (L)->ddrs\n+#define LOOP_VINFO_INT_NITERS(L)      (TREE_INT_CST_LOW ((L)->num_iters))\n #define LOOP_PEELING_FOR_ALIGNMENT(L) (L)->peeling_for_alignment\n-#define LOOP_VINFO_UNALIGNED_DR(L) (L)->unaligned_dr\n-\n+#define LOOP_VINFO_UNALIGNED_DR(L)    (L)->unaligned_dr\n+#define LOOP_VINFO_LOC(L)             (L)->loop_line_number\n \n #define LOOP_VINFO_NITERS_KNOWN_P(L)                     \\\n (host_integerp ((L)->num_iters,0)                        \\\n@@ -192,45 +195,6 @@ typedef struct _stmt_vec_info {\n   /* Information about the data-ref (access function, etc).  */\n   struct data_reference *data_ref_info;\n \n-  /* Aliasing information.  This field represents the symbol that\n-     should be aliased by a pointer holding the address of this data\n-     reference.  If the original data reference was a pointer\n-     dereference, then this field contains the memory tag that should\n-     be used by the new vector-pointer.  */\n-  tree memtag;\n-  struct ptr_info_def *ptr_info;\n-  subvar_t subvars;\n-\n-  /** The following fields are used to store the information about \n-      data-reference. {base_address + initial_offset} is the first location \n-      accessed by data-ref in the loop, and step is the stride of data-ref in \n-      the loop in bytes;\n-      e.g.:\n-    \n-                       Example 1                      Example 2\n-      data-ref         a[j].b[i][j]                   a + 4B (a is int*)\n-      \n-      base_address     &a                             a\n-      initial_offset   j_0*D_j + i_0*D_i + C          4\n-      step             D_j                            4\n-\n-      data-reference structure info:\n-      base_name        a                              NULL\n-      access_fn        <access_fns of indexes of b>   (0, +, 1)\n-\n-  **/\n-  /* The above base_address, offset and step.  */\n-  tree base_address;\n-  tree initial_offset;\n-  tree step;\n-\n-  /* Alignment information. Whether the base of the data-reference is aligned \n-     to vectype.  */\n-  bool base_aligned_p;\n-  /* Alignment information. The offset of the data-reference from its base \n-     in bytes.  */\n-  tree misalignment;\n-\n   /* List of datarefs that are known to have the same alignment as the dataref\n      of this stmt.  */\n   VEC(dr_p,heap) *same_align_refs;\n@@ -249,14 +213,6 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_VECTYPE(S)             (S)->vectype\n #define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n #define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n-#define STMT_VINFO_MEMTAG(S)              (S)->memtag\n-#define STMT_VINFO_PTR_INFO(S)            (S)->ptr_info\n-#define STMT_VINFO_SUBVARS(S)             (S)->subvars\n-#define STMT_VINFO_VECT_DR_BASE_ADDRESS(S)(S)->base_address\n-#define STMT_VINFO_VECT_INIT_OFFSET(S)    (S)->initial_offset\n-#define STMT_VINFO_VECT_STEP(S)           (S)->step\n-#define STMT_VINFO_VECT_BASE_ALIGNED_P(S) (S)->base_aligned_p\n-#define STMT_VINFO_VECT_MISALIGNMENT(S)   (S)->misalignment\n #define STMT_VINFO_SAME_ALIGN_REFS(S)     (S)->same_align_refs\n #define STMT_VINFO_DEF_TYPE(S)            (S)->def_type\n "}, {"sha": "df730a54af260d78c41b3ebe6886b624578bdc3b", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86a0740499715b497e753af5b73c33ccb934c70b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=86a0740499715b497e753af5b73c33ccb934c70b", "patch": "@@ -4174,4 +4174,7 @@ extern void init_object_sizes (void);\n extern void fini_object_sizes (void);\n extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n \n+/* In expr.c.  */\n+extern unsigned HOST_WIDE_INT highest_pow2_factor (tree);\n+\n #endif  /* GCC_TREE_H  */"}]}