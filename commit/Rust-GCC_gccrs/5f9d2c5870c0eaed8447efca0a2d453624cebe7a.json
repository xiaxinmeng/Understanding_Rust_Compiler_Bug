{"sha": "5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY5ZDJjNTg3MGMwZWFlZDg0NDdlZmNhMGEyZDQ1MzYyNGNlYmU3YQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-07-16T06:49:39Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-07-16T06:49:39Z"}, "message": "fold-const.c (int_const_binop_1): Abstract...\n\n        * fold-const.c (int_const_binop_1): Abstract...\n        (wide_int_binop): ...wide int code here.\n\t(poly_int_binop): ...poly int code here.\n\t(tree_binop): ...tree code here.\n        * fold-const.h (wide_int_binop): New.\n        * tree-vrp.c (vrp_int_const_binop): Call wide_int_binop.\n\tRemove useless PLUS/MINUS_EXPR case.\n        (zero_nonzero_bits_from_vr): Move wide int code...\n        (zero_nonzero_bits_from_bounds): ...here.\n        (extract_range_from_binary_expr_1): Move mask optimization code...\n        (range_easy_mask_min_max): ...here.\n        * tree-vrp.h (zero_nonzero_bits_from_bounds): New.\n        (range_easy_mask_min_max): New.\n\nFrom-SVN: r262676", "tree": {"sha": "4ab834e2c0791a891484a44e2e4d8ae246f635c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ab834e2c0791a891484a44e2e4d8ae246f635c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5933c6856604f4c83d8e4fadcd4627c1e0e4e500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5933c6856604f4c83d8e4fadcd4627c1e0e4e500", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5933c6856604f4c83d8e4fadcd4627c1e0e4e500"}], "stats": {"total": 471, "additions": 242, "deletions": 229}, "files": [{"sha": "bcec7f95e25428aac7eaba310a2aa3741e54bf3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "patch": "@@ -1,3 +1,19 @@\n+2018-07-16  Aldy Hernandez  <aldyh@redhat.com>\n+\n+        * fold-const.c (int_const_binop_1): Abstract...\n+        (wide_int_binop): ...wide int code here.\n+\t(poly_int_binop): ...poly int code here.\n+\tAbstract the rest of int_const_binop_1 into int_const_binop.\n+        * fold-const.h (wide_int_binop): New.\n+        * tree-vrp.c (vrp_int_const_binop): Call wide_int_binop.\n+\tRemove useless PLUS/MINUS_EXPR case.\n+        (zero_nonzero_bits_from_vr): Move wide int code...\n+        (zero_nonzero_bits_from_bounds): ...here.\n+        (extract_range_from_binary_expr_1): Move mask optimization code...\n+        (range_easy_mask_min_max): ...here.\n+        * tree-vrp.h (zero_nonzero_bits_from_bounds): New.\n+        (range_easy_mask_min_max): New.\n+\n 2018-07-15  Jeff Law  <law@redhat.com>\n \n \tPR target/85993"}, {"sha": "b318fc7705fe50e50d415c89598810203b6c45a6", "filename": "gcc/fold-const.c", "status": "modified", "additions": 109, "deletions": 104, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "patch": "@@ -966,21 +966,17 @@ int_binop_types_match_p (enum tree_code code, const_tree type1, const_tree type2\n \t && TYPE_MODE (type1) == TYPE_MODE (type2);\n }\n \n-/* Subroutine of int_const_binop_1 that handles two INTEGER_CSTs.  */\n+/* Combine two wide ints ARG1 and ARG2 under operation CODE to produce\n+   a new constant in RES.  Return FALSE if we don't know how to\n+   evaluate CODE at compile-time.  */\n \n-static tree\n-int_const_binop_2 (enum tree_code code, const_tree parg1, const_tree parg2,\n-\t\t   int overflowable)\n+bool\n+wide_int_binop (wide_int &res,\n+\t\tenum tree_code code, const wide_int &arg1, const wide_int &arg2,\n+\t\tsignop sign, wi::overflow_type *overflow)\n {\n-  wide_int res;\n-  tree t;\n-  tree type = TREE_TYPE (parg1);\n-  signop sign = TYPE_SIGN (type);\n-  wi::overflow_type overflow = wi::OVF_NONE;\n-\n-  wi::tree_to_wide_ref arg1 = wi::to_wide (parg1);\n-  wide_int arg2 = wi::to_wide (parg2, TYPE_PRECISION (type));\n-\n+  wide_int tmp;\n+  *overflow = wi::OVF_NONE;\n   switch (code)\n     {\n     case BIT_IOR_EXPR:\n@@ -999,49 +995,53 @@ int_const_binop_2 (enum tree_code code, const_tree parg1, const_tree parg2,\n     case LSHIFT_EXPR:\n       if (wi::neg_p (arg2))\n \t{\n-\t  arg2 = -arg2;\n+\t  tmp = -arg2;\n \t  if (code == RSHIFT_EXPR)\n \t    code = LSHIFT_EXPR;\n \t  else\n \t    code = RSHIFT_EXPR;\n \t}\n+      else\n+        tmp = arg2;\n \n       if (code == RSHIFT_EXPR)\n \t/* It's unclear from the C standard whether shifts can overflow.\n \t   The following code ignores overflow; perhaps a C standard\n \t   interpretation ruling is needed.  */\n-\tres = wi::rshift (arg1, arg2, sign);\n+\tres = wi::rshift (arg1, tmp, sign);\n       else\n-\tres = wi::lshift (arg1, arg2);\n+\tres = wi::lshift (arg1, tmp);\n       break;\n \n     case RROTATE_EXPR:\n     case LROTATE_EXPR:\n       if (wi::neg_p (arg2))\n \t{\n-\t  arg2 = -arg2;\n+\t  tmp = -arg2;\n \t  if (code == RROTATE_EXPR)\n \t    code = LROTATE_EXPR;\n \t  else\n \t    code = RROTATE_EXPR;\n \t}\n+      else\n+        tmp = arg2;\n \n       if (code == RROTATE_EXPR)\n-\tres = wi::rrotate (arg1, arg2);\n+\tres = wi::rrotate (arg1, tmp);\n       else\n-\tres = wi::lrotate (arg1, arg2);\n+\tres = wi::lrotate (arg1, tmp);\n       break;\n \n     case PLUS_EXPR:\n-      res = wi::add (arg1, arg2, sign, &overflow);\n+      res = wi::add (arg1, arg2, sign, overflow);\n       break;\n \n     case MINUS_EXPR:\n-      res = wi::sub (arg1, arg2, sign, &overflow);\n+      res = wi::sub (arg1, arg2, sign, overflow);\n       break;\n \n     case MULT_EXPR:\n-      res = wi::mul (arg1, arg2, sign, &overflow);\n+      res = wi::mul (arg1, arg2, sign, overflow);\n       break;\n \n     case MULT_HIGHPART_EXPR:\n@@ -1051,50 +1051,50 @@ int_const_binop_2 (enum tree_code code, const_tree parg1, const_tree parg2,\n     case TRUNC_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::div_trunc (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::div_trunc (arg1, arg2, sign, overflow);\n       break;\n \n     case FLOOR_DIV_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::div_floor (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::div_floor (arg1, arg2, sign, overflow);\n       break;\n \n     case CEIL_DIV_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::div_ceil (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::div_ceil (arg1, arg2, sign, overflow);\n       break;\n \n     case ROUND_DIV_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::div_round (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::div_round (arg1, arg2, sign, overflow);\n       break;\n \n     case TRUNC_MOD_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::mod_trunc (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::mod_trunc (arg1, arg2, sign, overflow);\n       break;\n \n     case FLOOR_MOD_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::mod_floor (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::mod_floor (arg1, arg2, sign, overflow);\n       break;\n \n     case CEIL_MOD_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::mod_ceil (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::mod_ceil (arg1, arg2, sign, overflow);\n       break;\n \n     case ROUND_MOD_EXPR:\n       if (arg2 == 0)\n-\treturn NULL_TREE;\n-      res = wi::mod_round (arg1, arg2, sign, &overflow);\n+\treturn false;\n+      res = wi::mod_round (arg1, arg2, sign, overflow);\n       break;\n \n     case MIN_EXPR:\n@@ -1106,89 +1106,94 @@ int_const_binop_2 (enum tree_code code, const_tree parg1, const_tree parg2,\n       break;\n \n     default:\n-      return NULL_TREE;\n+      return false;\n     }\n-\n-  t = force_fit_type (type, res, overflowable,\n-\t\t      (((sign == SIGNED || overflowable == -1)\n-\t\t\t&& overflow)\n-\t\t       | TREE_OVERFLOW (parg1) | TREE_OVERFLOW (parg2)));\n-\n-  return t;\n+  return true;\n }\n \n-/* Combine two integer constants PARG1 and PARG2 under operation CODE\n-   to produce a new constant.  Return NULL_TREE if we don't know how\n+/* Combine two poly int's ARG1 and ARG2 under operation CODE to\n+   produce a new constant in RES.  Return FALSE if we don't know how\n    to evaluate CODE at compile-time.  */\n \n-static tree\n-int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n-\t\t   int overflowable)\n+static bool\n+poly_int_binop (poly_wide_int &res, enum tree_code code,\n+\t\tconst_tree arg1, const_tree arg2,\n+\t\tsignop sign, wi::overflow_type *overflow)\n {\n-  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n-    return int_const_binop_2 (code, arg1, arg2, overflowable);\n-\n   gcc_assert (NUM_POLY_INT_COEFFS != 1);\n-\n-  if (poly_int_tree_p (arg1) && poly_int_tree_p (arg2))\n+  gcc_assert (poly_int_tree_p (arg1) && poly_int_tree_p (arg2));\n+  switch (code)\n     {\n-      poly_wide_int res;\n-      wi::overflow_type overflow;\n-      tree type = TREE_TYPE (arg1);\n-      signop sign = TYPE_SIGN (type);\n-      switch (code)\n-\t{\n-\tcase PLUS_EXPR:\n-\t  res = wi::add (wi::to_poly_wide (arg1),\n-\t\t\t wi::to_poly_wide (arg2), sign, &overflow);\n-\t  break;\n+    case PLUS_EXPR:\n+      res = wi::add (wi::to_poly_wide (arg1),\n+\t\t     wi::to_poly_wide (arg2), sign, overflow);\n+      break;\n \n-\tcase MINUS_EXPR:\n-\t  res = wi::sub (wi::to_poly_wide (arg1),\n-\t\t\t wi::to_poly_wide (arg2), sign, &overflow);\n-\t  break;\n+    case MINUS_EXPR:\n+      res = wi::sub (wi::to_poly_wide (arg1),\n+\t\t     wi::to_poly_wide (arg2), sign, overflow);\n+      break;\n \n-\tcase MULT_EXPR:\n-\t  if (TREE_CODE (arg2) == INTEGER_CST)\n-\t    res = wi::mul (wi::to_poly_wide (arg1),\n-\t\t\t   wi::to_wide (arg2), sign, &overflow);\n-\t  else if (TREE_CODE (arg1) == INTEGER_CST)\n-\t    res = wi::mul (wi::to_poly_wide (arg2),\n-\t\t\t   wi::to_wide (arg1), sign, &overflow);\n-\t  else\n-\t    return NULL_TREE;\n-\t  break;\n+    case MULT_EXPR:\n+      if (TREE_CODE (arg2) == INTEGER_CST)\n+\tres = wi::mul (wi::to_poly_wide (arg1),\n+\t\t       wi::to_wide (arg2), sign, overflow);\n+      else if (TREE_CODE (arg1) == INTEGER_CST)\n+\tres = wi::mul (wi::to_poly_wide (arg2),\n+\t\t       wi::to_wide (arg1), sign, overflow);\n+      else\n+\treturn NULL_TREE;\n+      break;\n \n-\tcase LSHIFT_EXPR:\n-\t  if (TREE_CODE (arg2) == INTEGER_CST)\n-\t    res = wi::to_poly_wide (arg1) << wi::to_wide (arg2);\n-\t  else\n-\t    return NULL_TREE;\n-\t  break;\n+    case LSHIFT_EXPR:\n+      if (TREE_CODE (arg2) == INTEGER_CST)\n+\tres = wi::to_poly_wide (arg1) << wi::to_wide (arg2);\n+      else\n+\treturn false;\n+      break;\n \n-\tcase BIT_IOR_EXPR:\n-\t  if (TREE_CODE (arg2) != INTEGER_CST\n-\t      || !can_ior_p (wi::to_poly_wide (arg1), wi::to_wide (arg2),\n-\t\t\t     &res))\n-\t    return NULL_TREE;\n-\t  break;\n+    case BIT_IOR_EXPR:\n+      if (TREE_CODE (arg2) != INTEGER_CST\n+\t  || !can_ior_p (wi::to_poly_wide (arg1), wi::to_wide (arg2),\n+\t\t\t &res))\n+\treturn false;\n+      break;\n \n-\tdefault:\n-\t  return NULL_TREE;\n-\t}\n-      return force_fit_type (type, res, overflowable,\n-\t\t\t     (((sign == SIGNED || overflowable == -1)\n-\t\t\t       && overflow)\n-\t\t\t      | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2)));\n+    default:\n+      return false;\n     }\n-\n-  return NULL_TREE;\n+  return true;\n }\n \n+/* Combine two integer constants ARG1 and ARG2 under operation CODE to\n+   produce a new constant.  Return NULL_TREE if we don't know how to\n+   evaluate CODE at compile-time.  */\n+\n tree\n-int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2)\n+int_const_binop (enum tree_code code, const_tree arg1, const_tree arg2,\n+\t\t int overflowable)\n {\n-  return int_const_binop_1 (code, arg1, arg2, 1);\n+  bool success = false;\n+  poly_wide_int poly_res;\n+  tree type = TREE_TYPE (arg1);\n+  signop sign = TYPE_SIGN (type);\n+  wi::overflow_type overflow = wi::OVF_NONE;\n+\n+  if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg2) == INTEGER_CST)\n+    {\n+      wide_int warg1 = wi::to_wide (arg1), res;\n+      wide_int warg2 = wi::to_wide (arg2, TYPE_PRECISION (type));\n+      success = wide_int_binop (res, code, warg1, warg2, sign, &overflow);\n+      poly_res = res;\n+    }\n+  else if (poly_int_tree_p (arg1) && poly_int_tree_p (arg2))\n+    success = poly_int_binop (poly_res, code, arg1, arg2, sign, &overflow);\n+  if (success)\n+    return force_fit_type (type, poly_res, overflowable,\n+\t\t\t   (((sign == SIGNED || overflowable == -1)\n+\t\t\t     && overflow)\n+\t\t\t    | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2)));\n+  return NULL_TREE;\n }\n \n /* Return true if binary operation OP distributes over addition in operand\n@@ -1925,7 +1930,7 @@ size_binop_loc (location_t loc, enum tree_code code, tree arg0, tree arg1)\n       /* Handle general case of two integer constants.  For sizetype\n          constant calculations we always want to know about overflow,\n \t even in the unsigned case.  */\n-      tree res = int_const_binop_1 (code, arg0, arg1, -1);\n+      tree res = int_const_binop (code, arg0, arg1, -1);\n       if (res != NULL_TREE)\n \treturn res;\n     }"}, {"sha": "1b9ccc0fca3d7d1306f37cb5947132ea8646d2c0", "filename": "gcc/fold-const.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ffold-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ffold-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.h?ref=5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "patch": "@@ -100,7 +100,10 @@ extern tree fold_bit_and_mask (tree, tree, enum tree_code,\n \t\t\t       tree, enum tree_code, tree, tree,\n \t\t\t       tree, enum tree_code, tree, tree, tree *);\n extern tree fold_read_from_constant_string (tree);\n-extern tree int_const_binop (enum tree_code, const_tree, const_tree);\n+extern bool wide_int_binop (wide_int &res, enum tree_code,\n+\t\t\t    const wide_int &arg1, const wide_int &arg2,\n+\t\t\t    signop, wi::overflow_type *);\n+extern tree int_const_binop (enum tree_code, const_tree, const_tree, int = 1);\n #define build_fold_addr_expr(T)\\\n         build_fold_addr_expr_loc (UNKNOWN_LOCATION, (T))\n extern tree build_fold_addr_expr_loc (location_t, tree);"}, {"sha": "2e1ee86a161afe08aaafeefd34cf9c3612bfe329", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 107, "deletions": 124, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "patch": "@@ -956,11 +956,13 @@ value_range_constant_singleton (value_range *vr)\n   return NULL_TREE;\n }\n \n-/* Wrapper around int_const_binop.  Return true if we can compute the\n-   result; i.e. if the operation doesn't overflow or if the overflow is\n-   undefined.  In the latter case (if the operation overflows and\n-   overflow is undefined), then adjust the result to be -INF or +INF\n-   depending on CODE, VAL1 and VAL2.  Return the value in *RES.\n+/* Wrapper around wide_int_binop that adjusts for overflow.\n+\n+   Return true if we can compute the result; i.e. if the operation\n+   doesn't overflow or if the overflow is undefined.  In the latter\n+   case (if the operation overflows and overflow is undefined), then\n+   adjust the result to be -INF or +INF depending on CODE, VAL1 and\n+   VAL2.  Return the value in *RES.\n \n    Return false for division by zero, for which the result is\n    indeterminate.  */\n@@ -970,78 +972,36 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2, wide_int *res)\n {\n   wi::overflow_type overflow = wi::OVF_NONE;\n   signop sign = TYPE_SIGN (TREE_TYPE (val1));\n+  wide_int w1 = wi::to_wide (val1);\n+  wide_int w2 = wi::to_wide (val2);\n \n   switch (code)\n     {\n     case RSHIFT_EXPR:\n     case LSHIFT_EXPR:\n-      {\n-\twide_int wval2 = wi::to_wide (val2, TYPE_PRECISION (TREE_TYPE (val1)));\n-\tif (wi::neg_p (wval2))\n-\t  {\n-\t    wval2 = -wval2;\n-\t    if (code == RSHIFT_EXPR)\n-\t      code = LSHIFT_EXPR;\n-\t    else\n-\t      code = RSHIFT_EXPR;\n-\t  }\n-\n-\tif (code == RSHIFT_EXPR)\n-\t  /* It's unclear from the C standard whether shifts can overflow.\n-\t     The following code ignores overflow; perhaps a C standard\n-\t     interpretation ruling is needed.  */\n-\t  *res = wi::rshift (wi::to_wide (val1), wval2, sign);\n-\telse\n-\t  *res = wi::lshift (wi::to_wide (val1), wval2);\n-\tbreak;\n-      }\n-\n+      w2 = wi::to_wide (val2, TYPE_PRECISION (TREE_TYPE (val1)));\n+      /* FALLTHRU */\n     case MULT_EXPR:\n-      *res = wi::mul (wi::to_wide (val1),\n-\t\t      wi::to_wide (val2), sign, &overflow);\n-      break;\n-\n     case TRUNC_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n-      if (val2 == 0)\n-\treturn false;\n-      else\n-\t*res = wi::div_trunc (wi::to_wide (val1),\n-\t\t\t      wi::to_wide (val2), sign, &overflow);\n-      break;\n-\n     case FLOOR_DIV_EXPR:\n-      if (val2 == 0)\n-\treturn false;\n-      *res = wi::div_floor (wi::to_wide (val1),\n-\t\t\t    wi::to_wide (val2), sign, &overflow);\n-      break;\n-\n     case CEIL_DIV_EXPR:\n-      if (val2 == 0)\n-\treturn false;\n-      *res = wi::div_ceil (wi::to_wide (val1),\n-\t\t\t   wi::to_wide (val2), sign, &overflow);\n-      break;\n-\n     case ROUND_DIV_EXPR:\n-      if (val2 == 0)\n+      if (!wide_int_binop (*res, code, w1, w2, sign, &overflow))\n \treturn false;\n-      *res = wi::div_round (wi::to_wide (val1),\n-\t\t\t    wi::to_wide (val2), sign, &overflow);\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n+  /* If the operation overflowed return -INF or +INF depending on the\n+     operation and the combination of signs of the operands.  */\n   if (overflow\n       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n     {\n-      /* If the operation overflowed return -INF or +INF depending\n-\t on the operation and the combination of signs of the operands.  */\n-      int sgn1 = tree_int_cst_sgn (val1);\n-      int sgn2 = tree_int_cst_sgn (val2);\n+      int sign1 = tree_int_cst_sgn (val1);\n+      int sign2 = tree_int_cst_sgn (val2);\n \n       /* Notice that we only need to handle the restricted set of\n \t operations handled by extract_range_from_binary_expr.\n@@ -1053,64 +1013,47 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2, wide_int *res)\n \n       /* For multiplication, the sign of the overflow is given\n \t by the comparison of the signs of the operands.  */\n-      if ((code == MULT_EXPR && sgn1 == sgn2)\n-          /* For addition, the operands must be of the same sign\n-\t     to yield an overflow.  Its sign is therefore that\n-\t     of one of the operands, for example the first.  */\n-\t  || (code == PLUS_EXPR && sgn1 >= 0)\n-\t  /* For subtraction, operands must be of\n-\t     different signs to yield an overflow.  Its sign is\n-\t     therefore that of the first operand or the opposite of\n-\t     that of the second operand.  A first operand of 0 counts\n-\t     as positive here, for the corner case 0 - (-INF), which\n-\t     overflows, but must yield +INF.  */\n-\t  || (code == MINUS_EXPR && sgn1 >= 0)\n+      if ((code == MULT_EXPR && sign1 == sign2)\n \t  /* For division, the only case is -INF / -1 = +INF.  */\n \t  || code == TRUNC_DIV_EXPR\n \t  || code == FLOOR_DIV_EXPR\n \t  || code == CEIL_DIV_EXPR\n \t  || code == EXACT_DIV_EXPR\n \t  || code == ROUND_DIV_EXPR)\n-\t*res = wi::max_value (TYPE_PRECISION (TREE_TYPE (val1)),\n-\t\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n+\t*res = wi::max_value (TYPE_PRECISION (TREE_TYPE (val1)), sign);\n       else\n-\t*res = wi::min_value (TYPE_PRECISION (TREE_TYPE (val1)),\n-\t\t\t      TYPE_SIGN (TREE_TYPE (val1)));\n+\t*res = wi::min_value (TYPE_PRECISION (TREE_TYPE (val1)), sign);\n       return true;\n     }\n \n   return !overflow;\n }\n \n-\n-/* For range VR compute two wide_int bitmasks.  In *MAY_BE_NONZERO\n-   bitmask if some bit is unset, it means for all numbers in the range\n+/* For range [LB, UB] compute two wide_int bitmasks.  In *MAY_BE_NONZERO\n+   bitmask, if some bit is unset, it means for all numbers in the range\n    the bit is 0, otherwise it might be 0 or 1.  In *MUST_BE_NONZERO\n-   bitmask if some bit is set, it means for all numbers in the range\n+   bitmask, if some bit is set, it means for all numbers in the range\n    the bit is 1, otherwise it might be 0 or 1.  */\n \n-bool\n-zero_nonzero_bits_from_vr (const tree expr_type,\n-\t\t\t   value_range *vr,\n-\t\t\t   wide_int *may_be_nonzero,\n-\t\t\t   wide_int *must_be_nonzero)\n+void\n+zero_nonzero_bits_from_bounds (signop sign,\n+\t\t\t       const wide_int &lb, const wide_int &ub,\n+\t\t\t       wide_int *may_be_nonzero,\n+\t\t\t       wide_int *must_be_nonzero)\n {\n-  *may_be_nonzero = wi::minus_one (TYPE_PRECISION (expr_type));\n-  *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n-  if (!range_int_cst_p (vr))\n-    return false;\n+  *may_be_nonzero = wi::minus_one (lb.get_precision ());\n+  *must_be_nonzero = wi::zero (lb.get_precision ());\n \n-  if (range_int_cst_singleton_p (vr))\n+  if (wi::eq_p (lb, ub))\n     {\n-      *may_be_nonzero = wi::to_wide (vr->min);\n+      *may_be_nonzero = lb;\n       *must_be_nonzero = *may_be_nonzero;\n     }\n-  else if (tree_int_cst_sgn (vr->min) >= 0\n-\t   || tree_int_cst_sgn (vr->max) < 0)\n+  else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n     {\n-      wide_int xor_mask = wi::to_wide (vr->min) ^ wi::to_wide (vr->max);\n-      *may_be_nonzero = wi::to_wide (vr->min) | wi::to_wide (vr->max);\n-      *must_be_nonzero = wi::to_wide (vr->min) & wi::to_wide (vr->max);\n+      wide_int xor_mask = lb ^ ub;\n+      *may_be_nonzero = lb | ub;\n+      *must_be_nonzero = lb & ub;\n       if (xor_mask != 0)\n \t{\n \t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n@@ -1119,7 +1062,26 @@ zero_nonzero_bits_from_vr (const tree expr_type,\n \t  *must_be_nonzero = wi::bit_and_not (*must_be_nonzero, mask);\n \t}\n     }\n+}\n \n+/* Like zero_nonzero_bits_from_bounds, but use the range in value_range VR.  */\n+\n+bool\n+zero_nonzero_bits_from_vr (const tree expr_type,\n+\t\t\t   value_range *vr,\n+\t\t\t   wide_int *may_be_nonzero,\n+\t\t\t   wide_int *must_be_nonzero)\n+{\n+  if (!range_int_cst_p (vr))\n+    {\n+      *may_be_nonzero = wi::minus_one (TYPE_PRECISION (expr_type));\n+      *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n+      return false;\n+    }\n+\n+  zero_nonzero_bits_from_bounds (TYPE_SIGN (expr_type),\n+\t\t\t\t wi::to_wide (vr->min), wi::to_wide (vr->max),\n+\t\t\t\t may_be_nonzero, must_be_nonzero);\n   return true;\n }\n \n@@ -1275,6 +1237,52 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n \t\t   wide_int_to_tree (type, max), NULL);\n }\n \n+/* For op & or | attempt to optimize:\n+\n+\t[LB, UB] op Z\n+   into:\n+\t[LB op Z, UB op Z]\n+\n+   if Z is a constant which (for op | its bitwise not) has n\n+   consecutive least significant bits cleared followed by m 1\n+   consecutive bits set immediately above it and either\n+   m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n+\n+   The least significant n bits of all the values in the range are\n+   cleared or set, the m bits above it are preserved and any bits\n+   above these are required to be the same for all values in the\n+   range.\n+\n+   Return TRUE if the min and max can simply be folded.  */\n+\n+bool\n+range_easy_mask_min_max (tree_code code,\n+\t\t\t const wide_int &lb, const wide_int &ub,\n+\t\t\t const wide_int &mask)\n+\n+{\n+  wide_int w = mask;\n+  int m = 0, n = 0;\n+  if (code == BIT_IOR_EXPR)\n+    w = ~w;\n+  if (wi::eq_p (w, 0))\n+    n = w.get_precision ();\n+  else\n+    {\n+      n = wi::ctz (w);\n+      w = ~(w | wi::mask (n, false, w.get_precision ()));\n+      if (wi::eq_p (w, 0))\n+\tm = w.get_precision () - n;\n+      else\n+\tm = wi::ctz (w) - n;\n+    }\n+  wide_int new_mask = wi::mask (m + n, true, w.get_precision ());\n+  if ((new_mask & lb) == (new_mask & ub))\n+    return true;\n+\n+  return false;\n+}\n+\n /* If BOUND will include a symbolic bound, adjust it accordingly,\n    otherwise leave it as is.\n \n@@ -2175,39 +2183,14 @@ extract_range_from_binary_expr_1 (value_range *vr,\n \t      vr1p = &vr0;\n \t    }\n \t  /* For op & or | attempt to optimize:\n-\t     [x, y] op z into [x op z, y op z]\n-\t     if z is a constant which (for op | its bitwise not) has n\n-\t     consecutive least significant bits cleared followed by m 1\n-\t     consecutive bits set immediately above it and either\n-\t     m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n-\t     The least significant n bits of all the values in the range are\n-\t     cleared or set, the m bits above it are preserved and any bits\n-\t     above these are required to be the same for all values in the\n-\t     range.  */\n-\t  if (vr0p && range_int_cst_p (vr0p))\n+\t     [x, y] op z into [x op z, y op z].  */\n+\t  if (vr0p && range_int_cst_p (vr0p)\n+\t      && range_easy_mask_min_max (code, wi::to_wide (vr0p->min),\n+\t\t\t\t\t  wi::to_wide (vr0p->max),\n+\t\t\t\t\t  wi::to_wide (vr1p->min)))\n \t    {\n-\t      wide_int w = wi::to_wide (vr1p->min);\n-\t      int m = 0, n = 0;\n-\t      if (code == BIT_IOR_EXPR)\n-\t\tw = ~w;\n-\t      if (wi::eq_p (w, 0))\n-\t\tn = TYPE_PRECISION (expr_type);\n-\t      else\n-\t\t{\n-\t\t  n = wi::ctz (w);\n-\t\t  w = ~(w | wi::mask (n, false, w.get_precision ()));\n-\t\t  if (wi::eq_p (w, 0))\n-\t\t    m = TYPE_PRECISION (expr_type) - n;\n-\t\t  else\n-\t\t    m = wi::ctz (w) - n;\n-\t\t}\n-\t      wide_int mask = wi::mask (m + n, true, w.get_precision ());\n-\t      if ((mask & wi::to_wide (vr0p->min))\n-\t\t  == (mask & wi::to_wide (vr0p->max)))\n-\t\t{\n-\t\t  min = int_const_binop (code, vr0p->min, vr1p->min);\n-\t\t  max = int_const_binop (code, vr0p->max, vr1p->min);\n-\t\t}\n+\t      min = int_const_binop (code, vr0p->min, vr1p->min);\n+\t      max = int_const_binop (code, vr0p->max, vr1p->min);\n \t    }\n \t}\n "}, {"sha": "946e26e29b446fdfec9eb1c556341b7fad251ace", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f9d2c5870c0eaed8447efca0a2d453624cebe7a/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=5f9d2c5870c0eaed8447efca0a2d453624cebe7a", "patch": "@@ -112,8 +112,14 @@ extern bool range_int_cst_p (value_range *);\n extern int operand_less_p (tree, tree);\n extern bool find_case_label_range (gswitch *, tree, tree, size_t *, size_t *);\n extern bool find_case_label_index (gswitch *, size_t, tree, size_t *);\n+extern void zero_nonzero_bits_from_bounds (signop, const wide_int&,\n+\t\t\t\t\t   const wide_int&, wide_int *,\n+\t\t\t\t\t   wide_int *);\n extern bool zero_nonzero_bits_from_vr (const tree, value_range *,\n \t\t\t\t       wide_int *, wide_int *);\n+extern bool range_easy_mask_min_max (tree_code,\n+\t\t\t\t     const wide_int &lb, const wide_int &ub,\n+\t\t\t\t     const wide_int &mask);\n extern bool overflow_comparison_p (tree_code, tree, tree, bool, tree *);\n extern bool range_int_cst_singleton_p (value_range *);\n extern int value_inside_range (tree, tree, tree);"}]}