{"sha": "3f27e3f86a86d69b43ed3572b979081e826b98bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YyN2UzZjg2YTg2ZDY5YjQzZWQzNTcyYjk3OTA4MWU4MjZiOThiZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-12-13T22:47:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-12-13T22:47:13Z"}, "message": "Make-lang.in (JAVA_LEX_C): Added chartables.h.\n\n\t* Make-lang.in (JAVA_LEX_C): Added chartables.h.\n\t* lex.c (java_ignorable_control_p): Removed.\n\t(java_letter_or_digit_p): Removed.\n\t(java_start_char_p): New function.\n\t(java_read_char): Return `int', not `unicode_t'.  Changed\n\tcallers.\n\t(java_read_unicode): Likewise.\n\t(java_read_unicode_collapsing_terminators): Likewise.\n\t(java_get_unicode): Likewise.\n\t(java_new_lexer): Initialize hit_eof.\n\t(java_parse_end_comment): Take `int' argument.\n\t(java_parse_doc_section): Likewise.\n\t(java_parse_escape_sequence): Don't allow backlash-newline.\n\tReturn `int'.\n\t* lex.h (JAVA_DIGIT_P): Removed.\n\t(_JAVA_LETTER_OR_DIGIT_P): Removed.\n\t(_JAVA_IDENTIFIER_IGNORABLE): Removed.\n\t(JAVA_START_CHAR_P): Renamed from JAVA_ID_CHAR_P.\n\t(JAVA_PART_CHAR_P): New macro.\n\t(UEOF): Now -1.\n\t(JAVA_CHAR_ERROR): Now -2.\n\t(java_lexer): New field `hit_eof'.\n\t* chartables.h: New file.\n\t* gen-table.pl: new file.\n\nFrom-SVN: r38237", "tree": {"sha": "21ad640aa08f09f61043bd296ec51af6e339a547", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21ad640aa08f09f61043bd296ec51af6e339a547"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f27e3f86a86d69b43ed3572b979081e826b98bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f27e3f86a86d69b43ed3572b979081e826b98bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f27e3f86a86d69b43ed3572b979081e826b98bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f27e3f86a86d69b43ed3572b979081e826b98bf/comments", "author": null, "committer": null, "parents": [{"sha": "568aac9cf7c95ef4102838d126decf016d98ea46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/568aac9cf7c95ef4102838d126decf016d98ea46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/568aac9cf7c95ef4102838d126decf016d98ea46"}], "stats": {"total": 3980, "additions": 3616, "deletions": 364}, "files": [{"sha": "f5c1a0e77d16b5031c71d5a09e4675be731ba60a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=3f27e3f86a86d69b43ed3572b979081e826b98bf", "patch": "@@ -1,3 +1,30 @@\n+2000-11-07  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* Make-lang.in (JAVA_LEX_C): Added chartables.h.\n+\t* lex.c (java_ignorable_control_p): Removed.\n+\t(java_letter_or_digit_p): Removed.\n+\t(java_start_char_p): New function.\n+\t(java_read_char): Return `int', not `unicode_t'.  Changed\n+\tcallers.\n+\t(java_read_unicode): Likewise.\n+\t(java_read_unicode_collapsing_terminators): Likewise.\n+\t(java_get_unicode): Likewise.\n+\t(java_new_lexer): Initialize hit_eof.\n+\t(java_parse_end_comment): Take `int' argument.\n+\t(java_parse_doc_section): Likewise.\n+\t(java_parse_escape_sequence): Don't allow backlash-newline.\n+\tReturn `int'.\n+\t* lex.h (JAVA_DIGIT_P): Removed.\n+\t(_JAVA_LETTER_OR_DIGIT_P): Removed.\n+\t(_JAVA_IDENTIFIER_IGNORABLE): Removed.\n+\t(JAVA_START_CHAR_P): Renamed from JAVA_ID_CHAR_P.\n+\t(JAVA_PART_CHAR_P): New macro.\n+\t(UEOF): Now -1.\n+\t(JAVA_CHAR_ERROR): Now -2.\n+\t(java_lexer): New field `hit_eof'.\n+\t* chartables.h: New file.\n+\t* gen-table.pl: new file.\n+\n 2000-11-20  Tom Tromey  <tromey@cygnus.com>\n             Alexandre Petit-Bianco  <apbianco@cygnus.com>\n "}, {"sha": "d15a1181f1cb65534aeeb39e29c68d8ad4dee237", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=3f27e3f86a86d69b43ed3572b979081e826b98bf", "patch": "@@ -214,7 +214,7 @@ java.stage4: stage4-start\n #\f\n # .o:.h dependencies.\n JAVA_TREE_H = $(TREE_H) java/java-tree.h java/java-tree.def\n-JAVA_LEX_C = java/lex.c java/keyword.h\n+JAVA_LEX_C = java/lex.c java/keyword.h java/chartables.h\n \n java/parse.o: java/parse.c java/jcf-reader.c $(CONFIG_H) system.h \\\n   function.h $(JAVA_TREE_H) $(JAVA_LEX_C) java/parse.h java/lex.h $(GGC_H)"}, {"sha": "c00c226308177dec3babeddc968595cf9217620c", "filename": "gcc/java/chartables.h", "status": "added", "additions": 3212, "deletions": 0, "changes": 3212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Fchartables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Fchartables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fchartables.h?ref=3f27e3f86a86d69b43ed3572b979081e826b98bf"}, {"sha": "d631ab383f5f4de285a9e8f64e84df8a9fa567cb", "filename": "gcc/java/gen-table.pl", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Fgen-table.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Fgen-table.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgen-table.pl?ref=3f27e3f86a86d69b43ed3572b979081e826b98bf", "patch": "@@ -0,0 +1,256 @@\n+#! /usr/bin/perl\n+\n+#    Copyright (C) 2000 Free Software Foundation\n+\n+#    This program is free software; you can redistribute it and/or modify\n+#    it under the terms of the GNU General Public License as published by\n+#    the Free Software Foundation; either version 2, or (at your option)\n+#    any later version.\n+\n+#    This program is distributed in the hope that it will be useful,\n+#    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+#    GNU General Public License for more details.\n+\n+#    You should have received a copy of the GNU General Public License\n+#    along with this program; if not, write to the Free Software\n+#    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n+#    02111-1307, USA.\n+\n+# gen-table.pl - Generate tables for gcj from Unicode data.\n+# Usage: perl gen-table.pl DATA-FILE\n+\n+# Names of fields in Unicode data table.\n+$CODE = 0;\n+$NAME = 1;\n+$CATEGORY = 2;\n+$COMBINING_CLASSES = 3;\n+$BIDI_CATEGORY = 4;\n+$DECOMPOSITION = 5;\n+$DECIMAL_VALUE = 6;\n+$DIGIT_VALUE = 7;\n+$NUMERIC_VALUE = 8;\n+$MIRRORED = 9;\n+$OLD_NAME = 10;\n+$COMMENT = 11;\n+$UPPER = 12;\n+$LOWER = 13;\n+$TITLE = 14;\n+\n+# Start of special-cased gaps in Unicode data table.\n+%gaps = (\n+\t 0x4e00 => \"CJK\",\n+\t 0xac00 => \"Hangul\",\n+\t 0xd800 => \"Unassigned High Surrogate\",\n+\t 0xdb80 => \"Private Use High Surrogate\",\n+\t 0xdc00 => \"Low Surrogate\",\n+\t 0xe000 => \"Private Use\"\n+\t );\n+\n+# This lists control characters which are also considered whitespace.\n+# This is a somewhat odd list, taken from the JCL definition of\n+# Character.isIdentifierIgnorable.\n+%whitespace_controls =\n+    (\n+     0x0009 => 1,\n+     0x000a => 1,\n+     0x000b => 1,\n+     0x000c => 1,\n+     0x000d => 1,\n+     0x001c => 1,\n+     0x001d => 1,\n+     0x001e => 1,\n+     0x001f => 1\n+     );\n+\n+open (INPUT, \"< $ARGV[0]\") || exit 1;\n+\n+$last_code = -1;\n+while (<INPUT>)\n+{\n+    chop;\n+    @fields = split (';', $_, 30);\n+    if ($#fields != 14)\n+    {\n+\tprint STDERR \"Entry for $fields[$CODE] has wrong number of fields\\n\";\n+    }\n+\n+    $code = hex ($fields[$CODE]);\n+    if ($code > $last_code + 1)\n+    {\n+\t# Found a gap.\n+\tif (defined $gaps{$code})\n+\t{\n+\t    # Fill the gap with the last character read.\n+\t    @gfields = @fields;\n+\t}\n+\telse\n+\t{\n+\t    # The gap represents undefined characters.  Only the type\n+\t    # matters.\n+\t    @gfields = ('', '', 'Cn', '0', '', '', '', '', '', '', '',\n+\t\t\t'', '', '', '');\n+\t}\n+\tfor (++$last_code; $last_code < $code; ++$last_code)\n+\t{\n+\t    $gfields{$CODE} = sprintf (\"%04x\", $last_code);\n+\t    &process_one ($last_code, @gfields);\n+\t}\n+    }\n+    &process_one ($code, @fields);\n+    $last_code = $code;\n+}\n+\n+close (INPUT);\n+\n+@gfields = ('', '', 'Cn', '0', '', '', '', '', '', '', '',\n+\t    '', '', '', '');\n+for (++$last_code; $last_code < 0x10000; ++$last_code)\n+{\n+    $gfields{$CODE} = sprintf (\"%04x\", $last_code);\n+    &process_one ($last_code, @gfields);\n+}\n+--$last_code;\t\t\t# Want last to be 0xFFFF.\n+\n+&print_tables ($last_code);\n+\n+exit 0;\n+\n+# Process a single character.\n+sub process_one\n+{\n+    my ($code, @fields) = @_;\n+\n+    my $value = '';\n+    my $type = $fields[$CATEGORY];\n+\n+    # See if the character is a valid identifier start.\n+    if ($type =~ /L./\t\t# Letter\n+\t|| $type eq 'Pc'\t# Connecting punctuation\n+\t|| $type eq 'Sc')\t# Currency symbol\n+    {\n+\t$value = 'LETTER_START';\n+    }\n+\n+    # See if the character is a valid identifier member.\n+    if ($type =~ /L./\t\t# Letter\n+\t|| $type eq 'Pc'\t# Connecting punctuation\n+\t|| $type eq 'Sc'\t# Currency symbol\n+\t|| $type =~ /N[dl]/\t# Number: decimal or letter\n+\t|| $type =~ /M[nc]/\t# Mark: non-spacing or combining\n+\t|| ($type eq 'Cc'\t# Certain controls\n+\t    && ! defined $whitespace_controls{$code})\n+\t|| ($code >= 0x200c\t# Join controls\n+\t    && $code <= 0x200f)\n+\t|| ($code >= 0x202a\t# Bidi controls -- note that there\n+\t\t\t\t# is a typo in the JCL where these are\n+\t\t\t\t# concerned.\n+\t    && $code <= 0x202e)\n+\t|| ($code >= 0x206a\t# Format controls\n+\t    && $code <= 0x206f)\n+\t|| $code == 0xfeff)\t# ZWNBSP\n+    {\n+\tif ($value eq '')\n+\t{\n+\t    $value = 'LETTER_PART';\n+\t}\n+\telse\n+\t{\n+\t    $value = 'LETTER_PART | ' . $value;\n+\t}\n+    }\n+\n+    if ($value eq '')\n+    {\n+\t$value = '0';\n+    }\n+    else\n+    {\n+\t$value = '(' . $value . ')';\n+    }\n+\n+    $map[$code] = $value;\n+}\n+\n+sub print_tables\n+{\n+    my ($last) = @_;\n+\n+    local ($bytes_out) = 0;\n+\n+    open (OUT, \"> chartables.h\");\n+\n+    print OUT \"/* This file is automatically generated.  DO NOT EDIT!\\n\";\n+    print OUT \"   Instead, edit gen-table.pl and re-run.  */\\n\\n\";\n+\n+    print OUT \"#ifndef CHARTABLES_H\\n\";\n+    print OUT \"#define CHARTABLES_H\\n\\n\";\n+\n+    print OUT \"#define LETTER_START 1\\n\";\n+    print OUT \"#define LETTER_PART  2\\n\\n\";\n+\n+    for ($count = 0; $count <= $last; $count += 256)\n+    {\n+\t$row[$count / 256] = &print_row ($count, '(char *) ', 'char', 1,\n+\t\t\t\t\t 'page');\n+    }\n+\n+    print OUT \"static char *type_table[256] = {\\n\";\n+    for ($count = 0; $count <= $last; $count += 256)\n+    {\n+\tprint OUT \",\\n\" if $count > 0;\n+\tprint OUT \"  \", $row[$count / 256];\n+\t$bytes_out += 4;\n+    }\n+    print OUT \"\\n};\\n\\n\";\n+\n+    print OUT \"#endif /* CHARTABLES_H */\\n\";\n+\n+    close (OUT);\n+\n+    printf \"Generated %d bytes\\n\", $bytes_out;\n+}\n+\n+# Print a single \"row\" of a two-level table.\n+sub print_row\n+{\n+    my ($start, $def_pfx, $typname, $typsize, $name) = @_;\n+\n+    my ($i);\n+    my (@values);\n+    my ($flag) = 1;\n+    my ($off);\n+    for ($off = 0; $off < 256; ++$off)\n+    {\n+\t$values[$off] = $map[$off + $start];\n+\tif ($values[$off] ne $values[0])\n+\t{\n+\t    $flag = 0;\n+\t}\n+    }\n+    if ($flag)\n+    {\n+\treturn $def_pfx . $values[0];\n+    }\n+\n+    printf OUT \"static %s %s%d[256] = {\\n  \", $typname, $name, $start / 256;\n+    my ($column) = 2;\n+    for ($i = $start; $i < $start + 256; ++$i)\n+    {\n+\tprint OUT \", \"\n+\t    if $i > $start;\n+\tmy ($text) = $values[$i - $start];\n+\tif (length ($text) + $column + 2 > 78)\n+\t{\n+\t    print OUT \"\\n  \";\n+\t    $column = 2;\n+\t}\n+\tprint OUT $text;\n+\t$column += length ($text) + 2;\n+    }\n+    print OUT \"\\n};\\n\\n\";\n+\n+    $bytes_out += 256 * $typsize;\n+\n+    return sprintf \"%s%d\", $name, $start / 256;\n+}"}, {"sha": "dddb3cd44557086311dfbdc0b0881403f206a17b", "filename": "gcc/java/lex.c", "status": "modified", "additions": 89, "deletions": 48, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=3f27e3f86a86d69b43ed3572b979081e826b98bf", "patch": "@@ -36,6 +36,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n \n #include \"keyword.h\"\n #include \"flags.h\"\n+#include \"chartables.h\"\n \n /* Function declaration  */\n static char *java_sprint_unicode PARAMS ((struct java_line *, int));\n@@ -46,17 +47,17 @@ static int java_is_eol PARAMS ((FILE *, int));\n static tree build_wfl_node PARAMS ((tree));\n #endif\n static void java_store_unicode PARAMS ((struct java_line *, unicode_t, int));\n-static unicode_t java_parse_escape_sequence PARAMS ((void));\n-static int java_letter_or_digit_p PARAMS ((unicode_t));\n-static int java_ignorable_control_p PARAMS ((unicode_t));\n-static int java_parse_doc_section PARAMS ((unicode_t));\n-static void java_parse_end_comment PARAMS ((unicode_t));\n-static unicode_t java_get_unicode PARAMS ((void));\n-static unicode_t java_read_unicode PARAMS ((java_lexer *, int *));\n-static unicode_t java_read_unicode_collapsing_terminators\n-    PARAMS ((java_lexer *, int *));\n+static int java_parse_escape_sequence PARAMS ((void));\n+static int java_start_char_p PARAMS ((unicode_t));\n+static int java_part_char_p PARAMS ((unicode_t));\n+static int java_parse_doc_section PARAMS ((int));\n+static void java_parse_end_comment PARAMS ((int));\n+static int java_get_unicode PARAMS ((void));\n+static int java_read_unicode PARAMS ((java_lexer *, int *));\n+static int java_read_unicode_collapsing_terminators PARAMS ((java_lexer *,\n+\t\t\t\t\t\t\t     int *));\n static void java_store_unicode PARAMS ((struct java_line *, unicode_t, int));\n-static unicode_t java_read_char PARAMS ((java_lexer *));\n+static int java_read_char PARAMS ((java_lexer *));\n static void java_allocate_new_line PARAMS ((void));\n static void java_unget_unicode PARAMS ((void));\n static unicode_t java_sneak_unicode PARAMS ((void));\n@@ -217,6 +218,7 @@ java_new_lexer (finput, encoding)\n   lex->finput = finput;\n   lex->bs_count = 0;\n   lex->unget_value = 0;\n+  lex->hit_eof = 0;\n \n #ifdef HAVE_ICONV\n   lex->handle = iconv_open (\"UCS-2\", encoding);\n@@ -298,7 +300,7 @@ java_destroy_lexer (lex)\n   free (lex);\n }\n \n-static unicode_t\n+static int\n java_read_char (lex)\n      java_lexer *lex;\n {\n@@ -496,12 +498,12 @@ java_store_unicode (l, c, unicode_escape_p)\n   l->unicode_escape_p [l->size++] = unicode_escape_p;\n }\n \n-static unicode_t\n+static int\n java_read_unicode (lex, unicode_escape_p)\n      java_lexer *lex;\n      int *unicode_escape_p;\n {\n-  unicode_t c;\n+  int c;\n \n   c = java_read_char (lex);\n   *unicode_escape_p = 0;\n@@ -549,12 +551,12 @@ java_read_unicode (lex, unicode_escape_p)\n   return (unicode_t) '\\\\';\n }\n \n-static unicode_t\n+static int\n java_read_unicode_collapsing_terminators (lex, unicode_escape_p)\n      java_lexer *lex;\n      int *unicode_escape_p;\n {\n-  unicode_t c = java_read_unicode (lex, unicode_escape_p);\n+  int c = java_read_unicode (lex, unicode_escape_p);\n \n   if (c == '\\r')\n     {\n@@ -571,13 +573,18 @@ java_read_unicode_collapsing_terminators (lex, unicode_escape_p)\n   return c;\n }\n \n-static unicode_t\n+static int\n java_get_unicode ()\n {\n   /* It's time to read a line when... */\n   if (!ctxp->c_line || ctxp->c_line->current == ctxp->c_line->size)\n     {\n-      unicode_t c;\n+      int c;\n+      int found_chars = 0;\n+\n+      if (ctxp->lexer->hit_eof)\n+\treturn UEOF;\n+\n       java_allocate_new_line ();\n       if (ctxp->c_line->line[0] != '\\n')\n \t{\n@@ -586,15 +593,24 @@ java_get_unicode ()\n \t      int unicode_escape_p;\n \t      c = java_read_unicode_collapsing_terminators (ctxp->lexer,\n \t\t\t\t\t\t\t    &unicode_escape_p);\n-\t      java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n-\t      if (ctxp->c_line->white_space_only \n-\t\t  && !JAVA_WHITE_SPACE_P (c)\n-\t\t  && c != '\\n'\n-\t\t  && c != UEOF)\n-\t\tctxp->c_line->white_space_only = 0;\n+\t      if (c != UEOF)\n+\t\t{\n+\t\t  found_chars = 1;\n+\t\t  java_store_unicode (ctxp->c_line, c, unicode_escape_p);\n+\t\t  if (ctxp->c_line->white_space_only \n+\t\t      && !JAVA_WHITE_SPACE_P (c)\n+\t\t      && c != '\\n')\n+\t\t    ctxp->c_line->white_space_only = 0;\n+\t\t}\n \t      if ((c == '\\n') || (c == UEOF))\n \t\tbreak;\n \t    }\n+\n+\t  if (c == UEOF && ! found_chars)\n+\t    {\n+\t      ctxp->lexer->hit_eof = 1;\n+\t      return UEOF;\n+\t    }\n \t}\n     }\n   ctxp->c_line->char_col += JAVA_COLUMN_DELTA (0);\n@@ -606,9 +622,8 @@ java_get_unicode ()\n  * C is the first character following the '/' and '*'. */\n static void\n java_parse_end_comment (c)\n-     unicode_t c;\n+     int c;\n {\n-\n   for ( ;; c = java_get_unicode ())\n     {\n       switch (c)\n@@ -637,7 +652,7 @@ java_parse_end_comment (c)\n \n static int\n java_parse_doc_section (c)\n-     unicode_t c;\n+     int c;\n {\n   int valid_tag = 0, seen_star = 0;\n \n@@ -655,10 +670,10 @@ java_parse_doc_section (c)\n \t}\n       c = java_get_unicode();\n     }\n-  \n+\n   if (c == UEOF)\n     java_lex_error (\"Comment not terminated at end of input\", 0);\n-  \n+\n   if (seen_star && (c == '/'))\n     return 1;\t\t\t/* Goto step1 in caller */\n \n@@ -673,7 +688,7 @@ java_parse_doc_section (c)\n \t  c = java_get_unicode ();\n \t  tag [tag_index++] = c;\n \t}\n-      \n+\n       if (c == UEOF)\n \tjava_lex_error (\"Comment not terminated at end of input\", 0);\n       tag [tag_index] = '\\0';\n@@ -685,28 +700,51 @@ java_parse_doc_section (c)\n   return 0;\n }\n \n-/* This function to be used only by JAVA_ID_CHAR_P (), otherwise it\n-   will return a wrong result.  */\n+/* Return true if C is a valid start character for a Java identifier.\n+   This is only called if C >= 128 -- smaller values are handled\n+   inline.  However, this function handles all values anyway.  */\n static int\n-java_letter_or_digit_p (c)\n+java_start_char_p (c)\n      unicode_t c;\n {\n-  return _JAVA_LETTER_OR_DIGIT_P (c);\n+  unsigned int hi = c / 256;\n+  char *page = type_table[hi];\n+  unsigned long val = (unsigned long) page;\n+  int flags;\n+\n+  if ((val & ~ (LETTER_PART | LETTER_START)) != 0)\n+    flags = page[c & 255];\n+  else\n+    flags = val;\n+\n+  return flags & LETTER_START;\n }\n \n-/* This function to be used only by JAVA_ID_CHAR_P ().  */\n+/* Return true if C is a valid part character for a Java identifier.\n+   This is only called if C >= 128 -- smaller values are handled\n+   inline.  However, this function handles all values anyway.  */\n static int\n-java_ignorable_control_p (c)\n+java_part_char_p (c)\n      unicode_t c;\n {\n-  return _JAVA_IDENTIFIER_IGNORABLE (c);\n+  unsigned int hi = c / 256;\n+  char *page = type_table[hi];\n+  unsigned long val = (unsigned long) page;\n+  int flags;\n+\n+  if ((val & ~ (LETTER_PART | LETTER_START)) != 0)\n+    flags = page[c & 255];\n+  else\n+    flags = val;\n+\n+  return flags & LETTER_PART;\n }\n \n-static unicode_t\n+static int\n java_parse_escape_sequence ()\n {\n   unicode_t char_lit;\n-  unicode_t c;\n+  int c;\n \n   switch (c = java_get_unicode ())\n     {\n@@ -754,8 +792,6 @@ java_parse_escape_sequence ()\n \n \treturn char_lit;\n       }\n-    case '\\n':\n-      return '\\n';\t\t/* ULT, caught latter as a specific error */\n     default:\n       java_lex_error (\"Invalid character in escape sequence\", 0);\n       return JAVA_CHAR_ERROR;\n@@ -840,7 +876,8 @@ java_lex (java_lval)\n #endif\n      YYSTYPE *java_lval;\n {\n-  unicode_t c, first_unicode;\n+  int c;\n+  unicode_t first_unicode;\n   int ascii_index, all_ascii;\n   char *string;\n \n@@ -863,7 +900,7 @@ java_lex (java_lval)\n       if ((c = java_get_unicode ()) == UEOF)\n \treturn 0;\t\t/* Ok here */\n       else\n-\tjava_unget_unicode ();\t/* Caught latter at the end the function */\n+\tjava_unget_unicode ();\t/* Caught later, at the end of the function */\n     }\n   /* Handle EOF here */\n   if (c == UEOF)\t/* Should probably do something here... */\n@@ -1189,7 +1226,7 @@ java_lex (java_lval)\n   /* Character literals */\n   if (c == '\\'')\n     {\n-      unicode_t char_lit;\n+      int char_lit;\n       if ((c = java_get_unicode ()) == '\\\\')\n \tchar_lit = java_parse_escape_sequence ();\n       else\n@@ -1206,7 +1243,7 @@ java_lex (java_lval)\n       if (c != '\\'')\n \tjava_lex_error (\"Syntax error in character literal\", 0);\n \n-      if (c == JAVA_CHAR_ERROR)\n+      if (char_lit == JAVA_CHAR_ERROR)\n         char_lit = 0;\t\t/* We silently convert it to zero */\n \n       JAVA_LEX_CHAR_LIT (char_lit);\n@@ -1225,7 +1262,11 @@ java_lex (java_lval)\n \t{\n \t  if (c == '\\\\')\n \t    c = java_parse_escape_sequence ();\n-\t  no_error &= (c != JAVA_CHAR_ERROR ? 1 : 0);\n+\t  if (c == JAVA_CHAR_ERROR)\n+\t    {\n+\t      no_error = 0;\n+\t      c = 0;\t\t/* We silently convert it to zero.  */\n+\t    }\n \t  java_unicode_2_utf8 (c);\n \t}\n       if (c == '\\n' || c == UEOF) /* ULT */\n@@ -1469,7 +1510,7 @@ java_lex (java_lval)\n   \n   /* Keyword, boolean literal or null literal */\n   for (first_unicode = c, all_ascii = 1, ascii_index = 0; \n-       JAVA_ID_CHAR_P (c); c = java_get_unicode ())\n+       JAVA_PART_CHAR_P (c); c = java_get_unicode ())\n     {\n       java_unicode_2_utf8 (c);\n       if (all_ascii && c >= 128)\n@@ -1554,8 +1595,8 @@ java_lex (java_lval)\n \t}\n     }\n   \n-  /* We may have and ID here */\n-  if (JAVA_ID_CHAR_P(first_unicode) && !JAVA_DIGIT_P (first_unicode))\n+  /* We may have an ID here */\n+  if (JAVA_START_CHAR_P (first_unicode))\n     {\n       JAVA_LEX_ID (string);\n       java_lval->node = BUILD_ID_WFL (GET_IDENTIFIER (string));"}, {"sha": "7934b50f592a0b64933522f7fa5ea92d309890ad", "filename": "gcc/java/lex.h", "status": "modified", "additions": 31, "deletions": 315, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f27e3f86a86d69b43ed3572b979081e826b98bf/gcc%2Fjava%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.h?ref=3f27e3f86a86d69b43ed3572b979081e826b98bf", "patch": "@@ -78,7 +78,7 @@ typedef unsigned short unicode_t;\n /* Line information containers  */\n struct java_line {\n   unicode_t *line;\t\t/* The line's unicode */\n-  char      *unicode_escape_p;\t/* The maching char was a unicode escape */\n+  char      *unicode_escape_p;\t/* The matching char was a unicode escape */\n   unicode_t ahead[1];\t\t/* Character ahead */\n   char unicode_escape_ahead_p;\t/* Character ahead is a unicode escape */\n   int max;\t\t\t/* buffer's max size */\n@@ -114,6 +114,9 @@ typedef struct java_lexer\n   /* If nonzero, a value that was pushed back.  */\n   unicode_t unget_value;\n \n+  /* If nonzero, we've hit EOF.  Used only by java_get_unicode().  */\n+  int hit_eof : 1;\n+\n #ifdef HAVE_ICONV\n   /* Nonzero if we've read any bytes.  We only recognize the\n      byte-order-marker (BOM) as the first word.  */\n@@ -141,7 +144,7 @@ typedef struct java_lexer\n \n   /* This is a buffer of characters already converted by iconv.  We\n      use `char' here because we're assuming that iconv() converts to\n-     big-endian UCS-2, and then we convert it ourselves.  */\n+     UCS-2, and then we convert it ourselves.  */\n   unsigned char out_buffer[1024];\n \n   /* Index of first valid output character.  -1 if no valid\n@@ -251,325 +254,38 @@ extern void set_float_handler PARAMS ((jmp_buf));\n /* Macros to decode character ranges */\n #define RANGE(c, l, h)           (((c) >= l && (c) <= h))\n #define JAVA_WHITE_SPACE_P(c) (c == ' ' || c == '\\t' || c == '\\f')\n-#define JAVA_ID_CHAR_P(c)     ((c < 128 && (RANGE (c, 'A', 'Z') ||\t\\\n-\t\t\t\t\t    RANGE (c, 'a', 'z') ||\t\\\n-\t\t\t\t\t    RANGE (c, '0', '9') ||\t\\\n-\t\t\t\t\t    c == '_'         ||\t\t\\\n-\t\t\t\t\t    c == '$'))       ||\t\t\\\n-\t\t\t       java_ignorable_control_p (c)  ||\t\t\\\n-\t\t\t       (c > 127 && java_letter_or_digit_p (c)))\n-#define JAVA_ASCII_DIGIT(c)    RANGE(c,'0', '9')\n-#define JAVA_ASCII_OCTDIGIT(c) RANGE(c,'0', '7')\n-#define JAVA_ASCII_HEXDIGIT(c) (RANGE(c,'0', '9') || \t\\\n-\t\t\t\tRANGE(c,'a', 'f') ||\t\\\n-\t\t\t\tRANGE(c,'A', 'F'))\n-#define JAVA_ASCII_FPCHAR(c)   (RANGE(c,'d', 'f') || RANGE(c,'D', 'F') || \\\n+#define JAVA_START_CHAR_P(c) ((c < 128\t\t\t\t\t      \\\n+\t\t\t       && (RANGE (c, 'A', 'Z')\t\t\t      \\\n+\t\t\t\t   || RANGE (c, 'a', 'z')\t\t      \\\n+\t\t\t\t   || c == '_'\t\t\t\t      \\\n+\t\t\t\t   || c == '$'))\t\t\t      \\\n+                              || (c >= 128 && java_start_char_p (c)))\n+#define JAVA_PART_CHAR_P(c) ((c < 128\t\t\t\t\t      \\\n+\t\t\t       && (RANGE (c, 'A', 'Z')\t\t\t      \\\n+\t\t\t\t   || RANGE (c, 'a', 'z')\t\t      \\\n+\t\t\t\t   || RANGE (c, '0', '9')\t\t      \\\n+\t\t\t\t   || c == '_'\t\t\t\t      \\\n+\t\t\t\t   || c == '$'\t\t\t\t      \\\n+\t\t\t\t   || c == 0x0000\t\t\t      \\\n+\t\t\t\t   || RANGE (c, 0x01, 0x08)\t\t      \\\n+\t\t\t\t   || RANGE (c, 0x0e, 0x1b)\t\t      \\\n+\t\t\t\t   || c == 0x7f))\t\t\t      \\\n+                              || (c >= 128 && java_part_char_p (c)))\n+#define JAVA_ASCII_DIGIT(c)    RANGE (c, '0', '9')\n+#define JAVA_ASCII_OCTDIGIT(c) RANGE (c, '0', '7')\n+#define JAVA_ASCII_HEXDIGIT(c) (RANGE (c, '0', '9') || \t\\\n+\t\t\t\tRANGE (c, 'a', 'f') ||\t\\\n+\t\t\t\tRANGE (c, 'A', 'F'))\n+#define JAVA_ASCII_FPCHAR(c)   (RANGE (c, 'd', 'f') || RANGE (c, 'D', 'F') || \\\n \t\t\t\tc == '.' || JAVA_ASCII_DIGIT (c))\n #define JAVA_FP_SUFFIX(c)      (c == 'D' || c == 'd' || c == 'f' || c == 'F')\n #define JAVA_FP_EXP(c)         (c == 'E' || c == 'F')\n #define JAVA_FP_PM(c)          (c == '-' || c == '+')\n-#define JAVA_ASCII_LETTER(c)   (RANGE(c,'a', 'z') || RANGE(c,'A', 'Z'))\n-#define JAVA_DIGIT_P(c)\t\t\t\t\t\t\t      \\\n-   (RANGE (c, 0x030, 0x039) || /* ISO-Latin-1 (and ASCII) digits ('0'-'9') */ \\\n-    RANGE (c, 0x660, 0x669) || /* Arabic-Indic digits */\t\t      \\\n-    RANGE (c, 0x6F0, 0x6F9) || /* Eastern Arabic-Indic digits */\t      \\\n-    RANGE (c, 0x966, 0x96F) || /* Devanagari digits */\t\t\t      \\\n-    RANGE (c, 0x9E6, 0x9EF) || /* Bengali digits */\t\t\t      \\\n-    RANGE (c, 0xA66, 0xA6F) || /* Gurmukhi digits */\t\t\t      \\\n-    RANGE (c, 0xAE6, 0xAEF) || /* Gujarati digits */\t\t\t      \\\n-    RANGE (c, 0xB66, 0xB6F) || /* Oriya digits */\t\t\t      \\\n-    RANGE (c, 0xBE7, 0xBEF) || /* Tamil digits */\t\t\t      \\\n-    RANGE (c, 0xC66, 0xC6F) || /* Telugu digits */\t\t\t      \\\n-    RANGE (c, 0xCE6, 0xCEF) || /* Kannada digits */\t\t\t      \\\n-    RANGE (c, 0xD66, 0xD6F) || /* Malayalam digits */\t\t\t      \\\n-    RANGE (c, 0xE50, 0xE59) || /* Thai digits */\t\t\t      \\\n-    RANGE (c, 0xED0, 0xED9))   /* Lao digits */\n-\n-/* This is not to be used as a stand alone macro. Use JAVA_ID_CHAR_P()\n-   or the forcoming JAVA_LETTER_OR_DIGIT_P() instead.\n-   It need to be split by region. FIXME.  */\n-#define _JAVA_LETTER_OR_DIGIT_P(c)\t\t\\\n-   (RANGE (c, 0x00C0, 0x00D6) ||\t\t\\\n-    RANGE (c, 0x00D8, 0x00F6) ||\t\t\\\n-    RANGE (c, 0x00F8, 0x01F5) ||\t\t\\\n-    RANGE (c, 0x01FA, 0x0217) ||\t\t\\\n-    RANGE (c, 0x0250, 0x02A8) ||\t\t\\\n-    RANGE (c, 0x02B0, 0x02DE) ||\t\t\\\n-    RANGE (c, 0x02E0, 0x02E9) ||\t\t\\\n-    RANGE (c, 0x0300, 0x0345) ||\t\t\\\n-    RANGE (c, 0x0360, 0x0361) ||\t\t\\\n-    RANGE (c, 0x0374, 0x0375) ||\t\t\\\n-    c == 0x037A            ||\t\t\t\\\n-    c == 0x037E            ||\t\t\t\\\n-    RANGE (c, 0x0384, 0x038A) ||\t\t\\\n-    c == 0x038C            ||\t\t\t\\\n-    c == 0x038E            ||\t\t\t\\\n-    RANGE (c, 0x038F, 0x03A1) ||\t\t\\\n-    RANGE (c, 0x03A3, 0x03CE) ||\t\t\\\n-    RANGE (c, 0x03D0, 0x03D6) ||\t\t\\\n-    RANGE (c, 0x03DA, 0x03E2) ||\t\t\\\n-    c == 0x03DA            ||\t\t\t\\\n-    c == 0x03DC            ||\t\t\t\\\n-    c == 0x03DE            ||\t\t\t\\\n-    c == 0x03E0            ||\t\t\t\\\n-    RANGE (c, 0x03E2, 0x03F3) ||\t\t\\\n-    RANGE (c, 0x0401, 0x040C) ||\t\t\\\n-    RANGE (c, 0x040E, 0x044F) ||\t\t\\\n-    RANGE (c, 0x0451, 0x045C) ||\t\t\\\n-    RANGE (c, 0x045E, 0x0486) ||\t\t\\\n-    RANGE (c, 0x0490, 0x04C4) ||\t\t\\\n-    RANGE (c, 0x04C7, 0x04C8) ||\t\t\\\n-    RANGE (c, 0x04CB, 0x04CC) ||\t\t\\\n-    RANGE (c, 0x04D0, 0x04EB) ||\t\t\\\n-    RANGE (c, 0x04EE, 0x04F5) ||\t\t\\\n-    RANGE (c, 0x04F8, 0x04F9) ||\t\t\\\n-    RANGE (c, 0x0531, 0x0556) ||\t\t\\\n-    RANGE (c, 0x0559, 0x055F) ||\t\t\\\n-    RANGE (c, 0x0561, 0x0587) ||\t\t\\\n-    c == 0x0589            ||\t\t\t\\\n-    RANGE (c, 0x05B0, 0x05B9) ||\t\t\\\n-    RANGE (c, 0x05BB, 0x05C3) ||\t\t\\\n-    RANGE (c, 0x05D0, 0x05EA) ||\t\t\\\n-    RANGE (c, 0x05F0, 0x05F4) ||\t\t\\\n-    c == 0x060C            ||\t\t\t\\\n-    c == 0x061B            ||\t\t\t\\\n-    c == 0x061F            ||\t\t\t\\\n-    c == 0x0621            ||\t\t\t\\\n-    RANGE (c, 0x0622, 0x063A) ||\t\t\\\n-    RANGE (c, 0x0640, 0x0652) ||\t\t\\\n-    RANGE (c, 0x0660, 0x066D) ||\t\t\\\n-    RANGE (c, 0x0670, 0x06B7) ||\t\t\\\n-    RANGE (c, 0x06BA, 0x06BE) ||\t\t\\\n-    RANGE (c, 0x06C0, 0x06CE) ||\t\t\\\n-    RANGE (c, 0x06D0, 0x06ED) ||\t\t\\\n-    RANGE (c, 0x06F0, 0x06F9) ||\t\t\\\n-    RANGE (c, 0x0901, 0x0903) ||\t\t\\\n-    RANGE (c, 0x0905, 0x0939) ||\t\t\\\n-    RANGE (c, 0x093C, 0x094D) ||\t\t\\\n-    RANGE (c, 0x0950, 0x0954) ||\t\t\\\n-    RANGE (c, 0x0958, 0x0970) ||\t\t\\\n-    RANGE (c, 0x0981, 0x0983) ||\t\t\\\n-    RANGE (c, 0x0985, 0x098C) ||\t\t\\\n-    RANGE (c, 0x098F, 0x0990) ||\t\t\\\n-    RANGE (c, 0x0993, 0x09A8) ||\t\t\\\n-    RANGE (c, 0x09AA, 0x09B0) ||\t\t\\\n-    c == 0x09B2            ||\t\t\t\\\n-    RANGE (c, 0x09B6, 0x09B9) ||\t\t\\\n-    c == 0x09BC            ||\t\t\t\\\n-    c == 0x09BE            ||\t\t\t\\\n-    RANGE (c, 0x09BF, 0x09C4) ||\t\t\\\n-    RANGE (c, 0x09C7, 0x09C8) ||\t\t\\\n-    RANGE (c, 0x09CB, 0x09CD) ||\t\t\\\n-    c == 0x09D7            ||\t\t\t\\\n-    RANGE (c, 0x09DC, 0x09DD) ||\t\t\\\n-    RANGE (c, 0x09DF, 0x09E3) ||\t\t\\\n-    RANGE (c, 0x09E6, 0x09FA) ||\t\t\\\n-    c == 0x0A02            ||\t\t\t\\\n-    RANGE (c, 0x0A05, 0x0A0A) ||\t\t\\\n-    RANGE (c, 0x0A0F, 0x0A10) ||\t\t\\\n-    RANGE (c, 0x0A13, 0x0A28) ||\t\t\\\n-    RANGE (c, 0x0A2A, 0x0A30) ||\t\t\\\n-    RANGE (c, 0x0A32, 0x0A33) ||\t\t\\\n-    RANGE (c, 0x0A35, 0x0A36) ||\t\t\\\n-    RANGE (c, 0x0A38, 0x0A39) ||\t\t\\\n-    c == 0x0A3C            ||\t\t\t\\\n-    c == 0x0A3E            ||\t\t\t\\\n-    RANGE (c, 0x0A3F, 0x0A42) ||\t\t\\\n-    RANGE (c, 0x0A47, 0x0A48) ||\t\t\\\n-    RANGE (c, 0x0A4B, 0x0A4D) ||\t\t\\\n-    RANGE (c, 0x0A59, 0x0A5C) ||\t\t\\\n-    c == 0x0A5E            ||\t\t\t\\\n-    RANGE (c, 0x0A66, 0x0A74) ||\t\t\\\n-    RANGE (c, 0x0A81, 0x0A83) ||\t\t\\\n-    RANGE (c, 0x0A85, 0x0A8B) ||\t\t\\\n-    c == 0x0A8D            ||\t\t\t\\\n-    c == 0x0A8F            ||\t\t\t\\\n-    RANGE (c, 0x0A90, 0x0A91) ||\t\t\\\n-    RANGE (c, 0x0A93, 0x0AA8) ||\t\t\\\n-    RANGE (c, 0x0AAA, 0x0AB0) ||\t\t\\\n-    RANGE (c, 0x0AB2, 0x0AB3) ||\t\t\\\n-    RANGE (c, 0x0AB5, 0x0AB9) ||\t\t\\\n-    RANGE (c, 0x0ABC, 0x0AC5) ||\t\t\\\n-    RANGE (c, 0x0AC7, 0x0AC9) ||\t\t\\\n-    RANGE (c, 0x0ACB, 0x0ACD) ||\t\t\\\n-    c == 0x0AD0            ||\t\t\t\\\n-    c == 0x0AE0            ||\t\t\t\\\n-    RANGE (c, 0x0AE6, 0x0AEF) ||\t\t\\\n-    RANGE (c, 0x0B01, 0x0B03) ||\t\t\\\n-    RANGE (c, 0x0B05, 0x0B0C) ||\t\t\\\n-    RANGE (c, 0x0B0F, 0x0B10) ||\t\t\\\n-    RANGE (c, 0x0B13, 0x0B28) ||\t\t\\\n-    RANGE (c, 0x0B2A, 0x0B30) ||\t\t\\\n-    RANGE (c, 0x0B32, 0x0B33) ||\t\t\\\n-    RANGE (c, 0x0B36, 0x0B39) ||\t\t\\\n-    RANGE (c, 0x0B3C, 0x0B43) ||\t\t\\\n-    RANGE (c, 0x0B47, 0x0B48) ||\t\t\\\n-    RANGE (c, 0x0B4B, 0x0B4D) ||\t\t\\\n-    RANGE (c, 0x0B56, 0x0B57) ||\t\t\\\n-    RANGE (c, 0x0B5C, 0x0B5D) ||\t\t\\\n-    RANGE (c, 0x0B5F, 0x0B61) ||\t\t\\\n-    RANGE (c, 0x0B66, 0x0B70) ||\t\t\\\n-    RANGE (c, 0x0B82, 0x0B83) ||\t\t\\\n-    RANGE (c, 0x0B85, 0x0B8A) ||\t\t\\\n-    RANGE (c, 0x0B8E, 0x0B90) ||\t\t\\\n-    RANGE (c, 0x0B92, 0x0B95) ||\t\t\\\n-    RANGE (c, 0x0B99, 0x0B9A) ||\t\t\\\n-    c == 0x0B9C            ||\t\t\t\\\n-    c == 0x0B9E            ||\t\t\t\\\n-    c == 0x0B9F            ||\t\t\t\\\n-    RANGE (c, 0x0BA3, 0x0BA4) ||\t\t\\\n-    RANGE (c, 0x0BA8, 0x0BAA) ||\t\t\\\n-    RANGE (c, 0x0BAE, 0x0BB5) ||\t\t\\\n-    RANGE (c, 0x0BB7, 0x0BB9) ||\t\t\\\n-    RANGE (c, 0x0BBE, 0x0BC2) ||\t\t\\\n-    RANGE (c, 0x0BC6, 0x0BC8) ||\t\t\\\n-    RANGE (c, 0x0BCA, 0x0BCD) ||\t\t\\\n-    c == 0x0BD7            ||\t\t\t\\\n-    RANGE (c, 0x0BE7, 0x0BF2) ||\t\t\\\n-    RANGE (c, 0x0C01, 0x0C03) ||\t\t\\\n-    RANGE (c, 0x0C05, 0x0C0C) ||\t\t\\\n-    RANGE (c, 0x0C0E, 0x0C10) ||\t\t\\\n-    RANGE (c, 0x0C12, 0x0C28) ||\t\t\\\n-    RANGE (c, 0x0C2A, 0x0C33) ||\t\t\\\n-    RANGE (c, 0x0C35, 0x0C39) ||\t\t\\\n-    RANGE (c, 0x0C3E, 0x0C44) ||\t\t\\\n-    RANGE (c, 0x0C46, 0x0C48) ||\t\t\\\n-    RANGE (c, 0x0C4A, 0x0C4D) ||\t\t\\\n-    RANGE (c, 0x0C55, 0x0C56) ||\t\t\\\n-    RANGE (c, 0x0C60, 0x0C61) ||\t\t\\\n-    RANGE (c, 0x0C66, 0x0C6F) ||\t\t\\\n-    RANGE (c, 0x0C82, 0x0C83) ||\t\t\\\n-    RANGE (c, 0x0C85, 0x0C8C) ||\t\t\\\n-    RANGE (c, 0x0C8E, 0x0C90) ||\t\t\\\n-    RANGE (c, 0x0C92, 0x0CA8) ||\t\t\\\n-    RANGE (c, 0x0CAA, 0x0CB3) ||\t\t\\\n-    RANGE (c, 0x0CB5, 0x0CB9) ||\t\t\\\n-    RANGE (c, 0x0CBE, 0x0CC4) ||\t\t\\\n-    RANGE (c, 0x0CC6, 0x0CC8) ||\t\t\\\n-    RANGE (c, 0x0CCA, 0x0CCD) ||\t\t\\\n-    RANGE (c, 0x0CD5, 0x0CD6) ||\t\t\\\n-    c == 0x0CDE            ||\t\t\t\\\n-    c == 0x0CE0            ||\t\t\t\\\n-    c == 0x0CE1            ||\t\t\t\\\n-    RANGE (c, 0x0CE6, 0x0CEF) ||\t\t\\\n-    RANGE (c, 0x0D02, 0x0D03) ||\t\t\\\n-    RANGE (c, 0x0D05, 0x0D0C) ||\t\t\\\n-    RANGE (c, 0x0D0E, 0x0D10) ||\t\t\\\n-    RANGE (c, 0x0D12, 0x0D28) ||\t\t\\\n-    RANGE (c, 0x0D2A, 0x0D39) ||\t\t\\\n-    RANGE (c, 0x0D3E, 0x0D43) ||\t\t\\\n-    RANGE (c, 0x0D46, 0x0D48) ||\t\t\\\n-    RANGE (c, 0x0D4A, 0x0D4D) ||\t\t\\\n-    c == 0x0D57            ||\t\t\t\\\n-    RANGE (c, 0x0D60, 0x0D61) ||\t\t\\\n-    RANGE (c, 0x0D66, 0x0D6F) ||\t\t\\\n-    RANGE (c, 0x0E01, 0x0E3A) ||\t\t\\\n-    RANGE (c, 0x0E3F, 0x0E5B) ||\t\t\\\n-    RANGE (c, 0x0E81, 0x0E82) ||\t\t\\\n-    c == 0x0E84            ||\t\t\t\\\n-    RANGE (c, 0x0E87, 0x0E88) ||\t\t\\\n-    c == 0x0E8A            ||\t\t\t\\\n-    c == 0x0E8D            ||\t\t\t\\\n-    RANGE (c, 0x0E94, 0x0E97) ||\t\t\\\n-    RANGE (c, 0x0E99, 0x0E9F) ||\t\t\\\n-    RANGE (c, 0x0EA1, 0x0EA3) ||\t\t\\\n-    c == 0x0EA5            ||\t\t\t\\\n-    c == 0x0EA7            ||\t\t\t\\\n-    RANGE (c, 0x0EAA, 0x0EAB) ||\t\t\\\n-    RANGE (c, 0x0EAD, 0x0EB9) ||\t\t\\\n-    RANGE (c, 0x0EBB, 0x0EBD) ||\t\t\\\n-    RANGE (c, 0x0EC0, 0x0EC4) ||\t\t\\\n-    c == 0x0EC6            ||\t\t\t\\\n-    c == 0x0EC8            ||\t\t\t\\\n-    RANGE (c, 0x0EC9, 0x0ECD) ||\t\t\\\n-    RANGE (c, 0x0ED0, 0x0ED9) ||\t\t\\\n-    RANGE (c, 0x0EDC, 0x0EDD) ||\t\t\\\n-    RANGE (c, 0x10A0, 0x10C5) ||\t\t\\\n-    RANGE (c, 0x10D0, 0x10F6) ||\t\t\\\n-    c == 0x10FB            ||\t\t\t\\\n-    RANGE (c, 0x1100, 0x1159) ||\t\t\\\n-    RANGE (c, 0x115F, 0x11A2) ||\t\t\\\n-    RANGE (c, 0x11A8, 0x11F9) ||\t\t\\\n-    RANGE (c, 0x1E00, 0x1E9A) ||\t\t\\\n-    RANGE (c, 0x1EA0, 0x1EF9) ||\t\t\\\n-    RANGE (c, 0x1F00, 0x1F15) ||\t\t\\\n-    RANGE (c, 0x1F18, 0x1F1D) ||\t\t\\\n-    RANGE (c, 0x1F20, 0x1F45) ||\t\t\\\n-    RANGE (c, 0x1F48, 0x1F4D) ||\t\t\\\n-    RANGE (c, 0x1F50, 0x1F57) ||\t\t\\\n-    c == 0x1F59            ||\t\t\t\\\n-    c == 0x1F5B            ||\t\t\t\\\n-    c == 0x1F5D            ||\t\t\t\\\n-    RANGE (c, 0x1F5F, 0x1F7D) ||\t\t\\\n-    RANGE (c, 0x1F80, 0x1FB4) ||\t\t\\\n-    RANGE (c, 0x1FB6, 0x1FC4) ||\t\t\\\n-    RANGE (c, 0x1FC6, 0x1FD3) ||\t\t\\\n-    RANGE (c, 0x1FD6, 0x1FDB) ||\t\t\\\n-    RANGE (c, 0x1FDD, 0x1FEF) ||\t\t\\\n-    RANGE (c, 0x1FF2, 0x1FF4) ||\t\t\\\n-    RANGE (c, 0x1FF6, 0x1FFE) ||\t\t\\\n-    RANGE (c, 0x3041, 0x3094) ||\t\t\\\n-    RANGE (c, 0x3099, 0x309E) ||\t\t\\\n-    RANGE (c, 0x30A1, 0x30FE) ||\t\t\\\n-    RANGE (c, 0x3105, 0x312C) ||\t\t\\\n-    RANGE (c, 0x3131, 0x318E) ||\t\t\\\n-    RANGE (c, 0x3190, 0x319F) ||\t\t\\\n-    RANGE (c, 0x3200, 0x321C) ||\t\t\\\n-    RANGE (c, 0x3220, 0x3243) ||\t\t\\\n-    RANGE (c, 0x3260, 0x327B) ||\t\t\\\n-    RANGE (c, 0x327F, 0x32B0) ||\t\t\\\n-    RANGE (c, 0x32C0, 0x32CB) ||\t\t\\\n-    RANGE (c, 0x32D0, 0x32FE) ||\t\t\\\n-    RANGE (c, 0x3300, 0x3376) ||\t\t\\\n-    RANGE (c, 0x337B, 0x33DD) ||\t\t\\\n-    RANGE (c, 0x33E0, 0x33FE) ||\t\t\\\n-    RANGE (c, 0x3400, 0x9FA5) ||\t\t\\\n-    RANGE (c, 0xF900, 0xFA2D) ||\t\t\\\n-    RANGE (c, 0xFB00, 0xFB06) ||\t\t\\\n-    RANGE (c, 0xFB13, 0xFB17) ||\t\t\\\n-    RANGE (c, 0xFB1E, 0xFB36) ||\t\t\\\n-    RANGE (c, 0xFB38, 0xFB3C) ||\t\t\\\n-    c == 0xFB3E            ||\t\t\t\\\n-    c == 0xFB40            ||\t\t\t\\\n-    c == 0xFB41            ||\t\t\t\\\n-    c == 0xFB43            ||\t\t\t\\\n-    c == 0xFB44            ||\t\t\t\\\n-    c == 0xFB46            ||\t\t\t\\\n-    RANGE (c, 0xFB47, 0xFBB1) ||\t\t\\\n-    RANGE (c, 0xFBD3, 0xFD3F) ||\t\t\\\n-    RANGE (c, 0xFD50, 0xFD8F) ||\t\t\\\n-    RANGE (c, 0xFD92, 0xFDC7) ||\t\t\\\n-    RANGE (c, 0xFDF0, 0xFDFB) ||\t\t\\\n-    RANGE (c, 0xFE70, 0xFE72) ||\t\t\\\n-    c == 0xFE74            ||\t\t\t\\\n-    c == 0xFE76            ||\t\t\t\\\n-    RANGE (c, 0xFE77, 0xFEFC) ||\t\t\\\n-    RANGE (c, 0xFF10, 0xFF19) ||\t\t\\\n-    RANGE (c, 0xFF21, 0xFF3A) ||\t\t\\\n-    RANGE (c, 0xFF41, 0xFF5A) ||\t\t\\\n-    RANGE (c, 0xFF66, 0xFFBE) ||\t\t\\\n-    RANGE (c, 0xFFC2, 0xFFC7) ||\t\t\\\n-    RANGE (c, 0xFFCA, 0xFFCF) ||\t\t\\\n-    RANGE (c, 0xFFD2, 0xFFD7) ||\t\t\\\n-    RANGE (c, 0xFFDA, 0xFFDC))\n-\n-/* Identifier-ignorable characters.  This should not be used\n-   standalone.  Note that the JCL says 200a->200e.  That is a typo.\n-   The correct values are 202a->202e.  Note also that we test against\n-   0x0000 separately to avoid a warning.  */\n-#define _JAVA_IDENTIFIER_IGNORABLE(c)\t\t\t\t\t      \\\n-  (c == 0x0000\t\t\t\t\t\t\t\t      \\\n-   || RANGE (c, 0x0001, 0x0008)\t\t\t\t\t\t      \\\n-   || RANGE (c, 0x000e, 0x001b)\t\t\t\t\t\t      \\\n-   || RANGE (c, 0x007f, 0x009f)\t\t\t\t\t\t      \\\n-   || RANGE (c, 0x200c, 0x200f)\t\t\t\t\t\t      \\\n-   || RANGE (c, 0x202a, 0x202e)\t\t\t\t\t\t      \\\n-   || RANGE (c, 0x206a, 0x206f)\t\t\t\t\t\t      \\\n-   || c == 0xfeff)\n+#define JAVA_ASCII_LETTER(c)   (RANGE (c, 'a', 'z') || RANGE (c, 'A', 'Z'))\n \n /* Constants  */\n-#define JAVA_CHAR_ERROR 0xFFC1\t/* This is an illegal unicode!?! FIXME */\n #define JAVA_READ_BUFFER 256\n-#define UEOF (unicode_t)0xffff\n+#define JAVA_CHAR_ERROR -2\n+#define UEOF -1\n \n #endif"}]}