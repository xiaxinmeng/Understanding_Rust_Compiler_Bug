{"sha": "b2aa172ff69591452e3566c105f2a4cd8450eab5", "node_id": "C_kwDOANBUbNoAKGIyYWExNzJmZjY5NTkxNDUyZTM1NjZjMTA1ZjJhNGNkODQ1MGVhYjU", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-10T17:08:13Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-10T19:28:10Z"}, "message": "Refactor code to reuse a canonical way to compile functions and constants\n\nThis is a big cleanup so all paths that compile functions and constants\nend up in the same path so we avoid any duplication in how we actually\ncompile a function.", "tree": {"sha": "f9ba781f9c6b29fd8d70f1964f7e238d1ade4f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9ba781f9c6b29fd8d70f1964f7e238d1ade4f77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2aa172ff69591452e3566c105f2a4cd8450eab5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2aa172ff69591452e3566c105f2a4cd8450eab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2aa172ff69591452e3566c105f2a4cd8450eab5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2aa172ff69591452e3566c105f2a4cd8450eab5/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b487d72cd2ba46671f5a1bcc20970f2dad1b759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b487d72cd2ba46671f5a1bcc20970f2dad1b759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b487d72cd2ba46671f5a1bcc20970f2dad1b759"}], "stats": {"total": 1671, "additions": 648, "deletions": 1023}, "files": [{"sha": "4f762160a5469d7d7c34ef91efac7f83318a2b76", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -96,6 +96,8 @@ GRS_OBJS = \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-compile-pattern.o \\\n     rust/rust-base62.o \\\n+    rust/rust-compile-item.o \\\n+    rust/rust-compile-implitem.o \\\n     rust/rust-compile-expr.o \\\n     rust/rust-compile-type.o \\\n     rust/rust-constexpr.o \\"}, {"sha": "85d85b907ce2ea06b5b7c2ed7bb6535cfe0a5d84", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -17,6 +17,11 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-base.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-fnparam.h\"\n+#include \"rust-compile-var-decl.h\"\n+\n #include \"fold-const.h\"\n #include \"stringpool.h\"\n \n@@ -169,5 +174,280 @@ HIRCompileBase::address_expression (tree expr, Location location)\n   return build_fold_addr_expr_loc (location.gcc_location (), expr);\n }\n \n+std::vector<Bvariable *>\n+HIRCompileBase::compile_locals_for_block (Context *ctx, Resolver::Rib &rib,\n+\t\t\t\t\t  tree fndecl)\n+{\n+  std::vector<Bvariable *> locals;\n+  rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n+    Resolver::Definition d;\n+    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n+    rust_assert (ok);\n+\n+    HIR::Stmt *decl = nullptr;\n+    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+    rust_assert (ok);\n+\n+    // if its a function we extract this out side of this fn context\n+    // and it is not a local to this function\n+    bool is_item = ctx->get_mappings ()->lookup_hir_item (\n+\t\t     decl->get_mappings ().get_crate_num (),\n+\t\t     decl->get_mappings ().get_hirid ())\n+\t\t   != nullptr;\n+    if (is_item)\n+      {\n+\tHIR::Item *item = static_cast<HIR::Item *> (decl);\n+\tCompileItem::compile (item, ctx);\n+\treturn true;\n+      }\n+\n+    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+    locals.push_back (compiled);\n+\n+    return true;\n+  });\n+\n+  return locals;\n+}\n+\n+void\n+HIRCompileBase::compile_function_body (Context *ctx, tree fndecl,\n+\t\t\t\t       HIR::BlockExpr &function_body,\n+\t\t\t\t       bool has_return_type)\n+{\n+  for (auto &s : function_body.get_statements ())\n+    {\n+      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  tree compiled_stmt\n+\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n+\t  ctx->add_statement (compiled_stmt);\n+\t}\n+    }\n+\n+  if (function_body.has_expr ())\n+    {\n+      // the previous passes will ensure this is a valid return\n+      // or a valid trailing expression\n+      tree compiled_expr\n+\t= CompileExpr::Compile (function_body.expr.get (), ctx);\n+\n+      if (compiled_expr != nullptr)\n+\t{\n+\t  if (has_return_type)\n+\t    {\n+\t      std::vector<tree> retstmts;\n+\t      retstmts.push_back (compiled_expr);\n+\n+\t      auto ret = ctx->get_backend ()->return_statement (\n+\t\tfndecl, retstmts,\n+\t\tfunction_body.get_final_expr ()->get_locus ());\n+\t      ctx->add_statement (ret);\n+\t    }\n+\t  else\n+\t    {\n+\t      tree final_stmt\n+\t\t= ctx->get_backend ()->expression_statement (fndecl,\n+\t\t\t\t\t\t\t     compiled_expr);\n+\t      ctx->add_statement (final_stmt);\n+\t    }\n+\t}\n+    }\n+}\n+\n+tree\n+HIRCompileBase::compile_function (\n+  Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+  std::vector<HIR::FunctionParam> &function_params,\n+  const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n+  AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n+  const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n+  bool function_has_return)\n+{\n+  tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  std::string ir_symbol_name\n+    = canonical_path->get () + fntype->subst_as_string ();\n+\n+  // we don't mangle the main fn since we haven't implemented the main shim\n+  bool is_main_fn = fn_name.compare (\"main\") == 0;\n+  std::string asm_name = fn_name;\n+  if (!is_main_fn)\n+    asm_name = ctx->mangle_item (fntype, *canonical_path);\n+\n+  unsigned int flags = 0;\n+  tree fndecl = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n+\t\t\t\t\t       asm_name, flags, locus);\n+  setup_attributes_on_fndecl (fndecl, is_main_fn, !visibility.is_error (),\n+\t\t\t      qualifiers, outer_attrs);\n+  setup_abi_options (fndecl, fntype->get_abi ());\n+\n+  // insert into the context\n+  ctx->insert_function_decl (fntype, fndecl);\n+\n+  // setup the params\n+  TyTy::BaseType *tyret = fntype->get_return_type ();\n+  std::vector<Bvariable *> param_vars;\n+  if (!self_param.is_error ())\n+    {\n+      rust_assert (fntype->is_method ());\n+      TyTy::BaseType *self_tyty_lookup = fntype->get_self_type ();\n+\n+      tree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+      Bvariable *compiled_self_param\n+\t= CompileSelfParam::compile (ctx, fndecl, self_param, self_type,\n+\t\t\t\t     self_param.get_locus ());\n+\n+      param_vars.push_back (compiled_self_param);\n+      ctx->insert_var_decl (self_param.get_mappings ().get_hirid (),\n+\t\t\t    compiled_self_param);\n+    }\n+\n+  // offset from + 1 for the TyTy::FnType being used when this is a method to\n+  // skip over Self on the FnType\n+  bool is_method = !self_param.is_error ();\n+  size_t i = is_method ? 1 : 0;\n+  for (auto &referenced_param : function_params)\n+    {\n+      auto tyty_param = fntype->param_at (i++);\n+      auto param_tyty = tyty_param.second;\n+      auto compiled_param_type = TyTyResolveCompile::compile (ctx, param_tyty);\n+\n+      Location param_locus = referenced_param.get_locus ();\n+      Bvariable *compiled_param_var\n+\t= CompileFnParam::compile (ctx, fndecl, &referenced_param,\n+\t\t\t\t   compiled_param_type, param_locus);\n+\n+      param_vars.push_back (compiled_param_var);\n+      ctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\t\t\t    compiled_param_var);\n+    }\n+\n+  if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n+    return error_mark_node;\n+\n+  // lookup locals\n+  auto body_mappings = function_body->get_mappings ();\n+  Resolver::Rib *rib = nullptr;\n+  bool ok\n+    = ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (), &rib);\n+  rust_assert (ok);\n+\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n+\n+  tree enclosing_scope = NULL_TREE;\n+  Location start_location = function_body->get_locus ();\n+  Location end_location = function_body->get_end_locus ();\n+\n+  tree code_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n+  ctx->push_block (code_block);\n+\n+  Bvariable *return_address = nullptr;\n+  if (function_has_return)\n+    {\n+      tree return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+\n+      return_address\n+\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n+\t\t\t\t\t\t   return_type, NULL,\n+\t\t\t\t\t\t   address_is_taken, locus,\n+\t\t\t\t\t\t   &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+    }\n+\n+  ctx->push_fn (fndecl, return_address);\n+  compile_function_body (ctx, fndecl, *function_body, function_has_return);\n+  tree bind_tree = ctx->pop_block ();\n+\n+  gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+  DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+  ctx->pop_fn ();\n+  ctx->push_function (fndecl);\n+\n+  return fndecl;\n+}\n+\n+tree\n+HIRCompileBase::compile_constant_item (\n+  Context *ctx, TyTy::BaseType *resolved_type,\n+  const Resolver::CanonicalPath *canonical_path, HIR::Expr *const_value_expr,\n+  Location locus)\n+{\n+  const std::string &ident = canonical_path->get ();\n+  tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+  tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n+\n+  bool is_block_expr\n+    = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n+\n+  // compile the expression\n+  tree folded_expr = error_mark_node;\n+  if (!is_block_expr)\n+    {\n+      tree value = CompileExpr::Compile (const_value_expr, ctx);\n+      folded_expr = ConstCtx::fold (value);\n+    }\n+  else\n+    {\n+      // in order to compile a block expr we want to reuse as much existing\n+      // machineary that we already have. This means the best approach is to\n+      // make a _fake_ function with a block so it can hold onto temps then\n+      // use our constexpr code to fold it completely or error_mark_node\n+      Backend::typed_identifier receiver;\n+      tree compiled_fn_type = ctx->get_backend ()->function_type (\n+\treceiver, {}, {Backend::typed_identifier (\"_\", const_type, locus)},\n+\tNULL, locus);\n+\n+      tree fndecl\n+\t= ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0, locus);\n+      TREE_READONLY (fndecl) = 1;\n+\n+      tree enclosing_scope = NULL_TREE;\n+      HIR::BlockExpr *function_body\n+\t= static_cast<HIR::BlockExpr *> (const_value_expr);\n+      Location start_location = function_body->get_locus ();\n+      Location end_location = function_body->get_end_locus ();\n+\n+      tree code_block\n+\t= ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n+\t\t\t\t      start_location, end_location);\n+      ctx->push_block (code_block);\n+\n+      bool address_is_taken = false;\n+      tree ret_var_stmt = NULL_TREE;\n+      Bvariable *return_address\n+\t= ctx->get_backend ()->temporary_variable (fndecl, code_block,\n+\t\t\t\t\t\t   const_type, NULL,\n+\t\t\t\t\t\t   address_is_taken, locus,\n+\t\t\t\t\t\t   &ret_var_stmt);\n+\n+      ctx->add_statement (ret_var_stmt);\n+      ctx->push_fn (fndecl, return_address);\n+\n+      compile_function_body (ctx, fndecl, *function_body, true);\n+      tree bind_tree = ctx->pop_block ();\n+\n+      gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n+      DECL_SAVED_TREE (fndecl) = bind_tree;\n+\n+      ctx->pop_fn ();\n+\n+      // lets fold it into a call expr\n+      tree call = build_call_array_loc (locus.gcc_location (), const_type,\n+\t\t\t\t\tfndecl, 0, NULL);\n+      folded_expr = ConstCtx::fold (call);\n+    }\n+\n+  return ctx->get_backend ()->named_constant_expression (const_type, ident,\n+\t\t\t\t\t\t\t folded_expr, locus);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "17e889cd11a926945271e4670248cc846510df16", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -35,14 +35,9 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n \n   Context *ctx;\n \n+protected:\n   Context *get_context () { return ctx; }\n \n-  void compile_function_body (tree fndecl, HIR::BlockExpr &function_body,\n-\t\t\t      bool has_return_type);\n-\n-  bool compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n-\t\t\t\t std::vector<Bvariable *> &locals);\n-\n   tree coercion_site (tree rvalue, TyTy::BaseType *actual,\n \t\t      TyTy::BaseType *expected, Location lvalue_locus,\n \t\t      Location rvalue_locus);\n@@ -81,6 +76,26 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n   static tree address_expression (tree, Location);\n \n   static bool mark_addressable (tree, Location);\n+\n+  static std::vector<Bvariable *>\n+  compile_locals_for_block (Context *ctx, Resolver::Rib &rib, tree fndecl);\n+\n+  static void compile_function_body (Context *ctx, tree fndecl,\n+\t\t\t\t     HIR::BlockExpr &function_body,\n+\t\t\t\t     bool has_return_type);\n+\n+  static tree compile_function (\n+    Context *ctx, const std::string &fn_name, HIR::SelfParam &self_param,\n+    std::vector<HIR::FunctionParam> &function_params,\n+    const HIR::FunctionQualifiers &qualifiers, HIR::Visibility &visibility,\n+    AST::AttrVec &outer_attrs, Location locus, HIR::BlockExpr *function_body,\n+    const Resolver::CanonicalPath *canonical_path, TyTy::FnType *fntype,\n+    bool function_has_return);\n+\n+  static tree\n+  compile_constant_item (Context *ctx, TyTy::BaseType *resolved_type,\n+\t\t\t const Resolver::CanonicalPath *canonical_path,\n+\t\t\t HIR::Expr *const_value_expr, Location locus);\n };\n \n } // namespace Compile"}, {"sha": "ab560e8bf34a2c1e93b4411f199e60b9ad933284", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -18,6 +18,7 @@\n \n #include \"rust-compile.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n@@ -713,7 +714,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n   tree fn = NULL_TREE;\n   if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n     {\n-      return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+      return address_expression (fn, expr_locus);\n     }\n \n   // Now we can try and resolve the address since this might be a forward\n@@ -765,8 +766,7 @@ CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n       // contain an implementation we should actually return\n       // error_mark_node\n \n-      return CompileTraitItem::Compile (receiver,\n-\t\t\t\t\ttrait_item_ref->get_hir_trait_item (),\n+      return CompileTraitItem::Compile (trait_item_ref->get_hir_trait_item (),\n \t\t\t\t\tctx, fntype, true, expr_locus);\n     }\n   else\n@@ -1343,8 +1343,7 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n     }\n   else if (ctx->lookup_function_decl (ref, &fn))\n     {\n-      translated\n-\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n+      translated = address_expression (fn, expr.get_locus ());\n     }\n   else if (ctx->lookup_var_decl (ref, &var))\n     {"}, {"sha": "1412e7a42eb01bb52d4cabe0e089e120bc1ae427", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -21,12 +21,6 @@\n \n #include \"rust-compile-base.h\"\n #include \"rust-compile-intrinsic.h\"\n-#include \"rust-compile-tyty.h\"\n-#include \"rust-compile-implitem.h\"\n-#include \"rust-compile-var-decl.h\"\n-#include \"rust-compile-stmt.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-fnparam.h\"\n \n namespace Rust {\n namespace Compile {"}, {"sha": "8dc18d3c5cc30527298a65955763268d562e4688", "filename": "gcc/rust/backend/rust-compile-implitem.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -0,0 +1,102 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-fnparam.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileTraitItem::visit (HIR::TraitItemConst &constant)\n+{\n+  rust_assert (concrete != nullptr);\n+  TyTy::BaseType *resolved_type = concrete;\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    constant.get_mappings ().get_crate_num (),\n+    constant.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  HIR::Expr *const_value_expr = constant.get_expr ().get ();\n+  tree const_expr\n+    = compile_constant_item (ctx, resolved_type, canonical_path,\n+\t\t\t     const_value_expr, constant.get_locus ());\n+  ctx->push_const (const_expr);\n+  ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+\n+  reference = const_expr;\n+}\n+\n+void\n+CompileTraitItem::visit (HIR::TraitItemFunc &func)\n+{\n+  rust_assert (func.has_block_defined ());\n+\n+  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\t  reference = address_expression (lookup, ref_locus);\n+\t  return;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n+    &canonical_path);\n+  rust_assert (ok);\n+\n+  // FIXME\n+  HIR::Visibility vis (HIR::Visibility::PublicVisType::NONE,\n+\t\t       AST::SimplePath::create_empty ());\n+  HIR::TraitFunctionDecl &function = func.get_decl ();\n+  tree fndecl\n+    = compile_function (ctx, function.get_function_name (),\n+\t\t\tfunction.get_self (), function.get_function_params (),\n+\t\t\tfunction.get_qualifiers (), vis,\n+\t\t\tfunc.get_outer_attrs (), func.get_locus (),\n+\t\t\tfunc.get_block_expr ().get (), canonical_path, fntype,\n+\t\t\tfunction.has_return_type ());\n+  reference = address_expression (fndecl, ref_locus);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "60b7246201d5a20add8ebad82afbf1551ca1a7ca", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 12, "deletions": 492, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -19,19 +19,17 @@\n #ifndef RUST_COMPILE_IMPLITEM_H\n #define RUST_COMPILE_IMPLITEM_H\n \n-#include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n-#include \"rust-compile-var-decl.h\"\n-#include \"rust-compile-stmt.h\"\n+#include \"rust-compile-item.h\"\n #include \"rust-compile-expr.h\"\n #include \"rust-compile-fnparam.h\"\n \n namespace Rust {\n namespace Compile {\n \n-class CompileInherentImplItem : public HIRCompileBase\n+// this is a proxy for HIR::ImplItem's back to use the normel HIR::Item path\n+class CompileInherentImplItem : public CompileItem\n {\n-  using Rust::Compile::HIRCompileBase::visit;\n+  using Rust::Compile::CompileItem::visit;\n \n public:\n   static tree Compile (HIR::ImplItem *item, Context *ctx,\n@@ -50,278 +48,23 @@ class CompileInherentImplItem : public HIRCompileBase\n     return compiler.reference;\n   }\n \n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok\n-      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n-\t\t\t\t\t&resolved_type);\n-    rust_assert (ok);\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ident = canonical_path->get ();\n-    tree const_expr = ctx->get_backend ()->named_constant_expression (\n-      type, constant.get_identifier (), value, constant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    reference = const_expr;\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    TyTy::BaseType *fntype_tyty;\n-    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fntype_tyty))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// we cant do anything for this only when it is used and a concrete type\n-\t// is given\n-\tif (concrete == nullptr)\n-\t  return;\n-\telse\n-\t  {\n-\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-\t    fntype = static_cast<TyTy::FnType *> (concrete);\n-\t  }\n-      }\n-\n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    tree lookup = NULL_TREE;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t   fntype->get_id (), fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  {\n-\t    tree dummy = NULL_TREE;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      {\n-\t\tctx->insert_function_decl (fntype, lookup);\n-\t      }\n-\t    reference\n-\t      = ctx->get_backend ()->function_code_expression (lookup,\n-\t\t\t\t\t\t\t       ref_locus);\n-\t    return;\n-\t  }\n-      }\n-\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n-\n-    // convert to the actual function type\n-    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ir_symbol_name\n-      = canonical_path->get () + fntype->subst_as_string ();\n-    std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n-\n-    unsigned int flags = 0;\n-    tree fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n-\t\t\t\t       asm_name, flags, function.get_locus ());\n-    setup_attributes_on_fndecl (fndecl, false, function.has_visibility (),\n-\t\t\t\tfunction.get_qualifiers (),\n-\t\t\t\tfunction.get_outer_attrs ());\n-    ctx->insert_function_decl (fntype, fndecl);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n-\n-    if (function.is_method ())\n-      {\n-\t// insert self\n-\tTyTy::BaseType *self_tyty_lookup = nullptr;\n-\tif (!ctx->get_tyctx ()->lookup_type (\n-\t      function.get_self_param ().get_mappings ().get_hirid (),\n-\t      &self_tyty_lookup))\n-\t  {\n-\t    rust_error_at (function.get_self_param ().get_locus (),\n-\t\t\t   \"failed to lookup self param type\");\n-\t    return;\n-\t  }\n-\n-\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n-\tif (self_type == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self_param ().get_locus (),\n-\t\t\t   \"failed to compile self param type\");\n-\t    return;\n-\t  }\n-\n-\tBvariable *compiled_self_param\n-\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self_param (),\n-\t\t\t\t       self_type,\n-\t\t\t\t       function.get_self_param ().get_locus ());\n-\tif (compiled_self_param == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self_param ().get_locus (),\n-\t\t\t   \"failed to compile self param variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_self_param);\n-\tctx->insert_var_decl (\n-\t  function.get_self_param ().get_mappings ().get_hirid (),\n-\t  compiled_self_param);\n-      }\n-\n-    // offset from + 1 for the TyTy::FnType being used when this is a method to\n-    // skip over Self on the FnType\n-    size_t i = function.is_method () ? 1 : 0;\n-    for (auto referenced_param : function.get_function_params ())\n-      {\n-\tauto tyty_param = fntype->param_at (i);\n-\tauto param_tyty = tyty_param.second;\n-\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\tif (compiled_param_type == nullptr)\n-\t  {\n-\t    rust_error_at (referenced_param.get_locus (),\n-\t\t\t   \"failed to compile parameter type\");\n-\t    return;\n-\t  }\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n-\t  {\n-\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = function.get_definition ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    tree enclosing_scope = NULL_TREE;\n-    HIR::BlockExpr *function_body = function.get_definition ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_end_locus ();\n-\n-    tree code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_function_return_type ())\n-      {\n-\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  function.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, *function.get_definition ().get (),\n-\t\t\t   function.has_function_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-    ctx->push_function (fndecl);\n-\n-    reference\n-      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n-  }\n-\n private:\n   CompileInherentImplItem (Context *ctx, TyTy::BaseType *concrete,\n \t\t\t   Location ref_locus)\n-    : HIRCompileBase (ctx), concrete (concrete),\n-      reference (ctx->get_backend ()->error_expression ()),\n-      ref_locus (ref_locus)\n+    : CompileItem (ctx, concrete, ref_locus)\n   {}\n-\n-  TyTy::BaseType *concrete;\n-  tree reference;\n-  Location ref_locus;\n };\n \n class CompileTraitItem : public HIRCompileBase\n {\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static tree Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n-\t\t       Context *ctx, TyTy::BaseType *concrete,\n-\t\t       bool is_query_mode = false,\n+  static tree Compile (HIR::TraitItem *item, Context *ctx,\n+\t\t       TyTy::BaseType *concrete, bool is_query_mode = false,\n \t\t       Location ref_locus = Location ())\n   {\n-    CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n+    CompileTraitItem compiler (ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n \n     if (is_query_mode\n@@ -332,240 +75,17 @@ class CompileTraitItem : public HIRCompileBase\n     return compiler.reference;\n   }\n \n-  void visit (HIR::TraitItemConst &constant) override\n-  {\n-    rust_assert (concrete != nullptr);\n-    TyTy::BaseType *resolved_type = concrete;\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ident = canonical_path->get ();\n-    tree const_expr = ctx->get_backend ()->named_constant_expression (\n-      type, constant.get_name (), value, constant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    reference = const_expr;\n-  }\n-\n-  void visit (HIR::TraitItemFunc &func) override\n-  {\n-    rust_assert (func.has_block_defined ());\n-\n-    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (concrete);\n-\n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    tree lookup = NULL_TREE;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t   fntype->get_id (), fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  {\n-\t    tree dummy = NULL_TREE;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      {\n-\t\tctx->insert_function_decl (fntype, lookup);\n-\t      }\n-\t    reference\n-\t      = ctx->get_backend ()->function_code_expression (lookup,\n-\t\t\t\t\t\t\t       ref_locus);\n-\t    return;\n-\t  }\n-      }\n-\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n-\n-    // convert to the actual function type\n-    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n-    HIR::TraitFunctionDecl &function = func.get_decl ();\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      func.get_mappings ().get_crate_num (), func.get_mappings ().get_nodeid (),\n-      &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string fn_identifier = canonical_path->get ();\n-    std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n-\n-    unsigned int flags = 0;\n-    tree fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n-\t\t\t\t       asm_name, flags, func.get_locus ());\n-    setup_attributes_on_fndecl (fndecl, false, false,\n-\t\t\t\tfunc.get_decl ().get_qualifiers (),\n-\t\t\t\tfunc.get_outer_attrs ());\n-    ctx->insert_function_decl (fntype, fndecl);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n-\n-    if (function.is_method ())\n-      {\n-\t// insert self\n-\tTyTy::BaseType *self_tyty_lookup = nullptr;\n-\tif (!ctx->get_tyctx ()->lookup_type (\n-\t      function.get_self ().get_mappings ().get_hirid (),\n-\t      &self_tyty_lookup))\n-\t  {\n-\t    rust_error_at (function.get_self ().get_locus (),\n-\t\t\t   \"failed to lookup self param type\");\n-\t    return;\n-\t  }\n-\n-\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n-\tif (self_type == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self ().get_locus (),\n-\t\t\t   \"failed to compile self param type\");\n-\t    return;\n-\t  }\n+  void visit (HIR::TraitItemConst &constant) override;\n \n-\tBvariable *compiled_self_param\n-\t  = CompileSelfParam::compile (ctx, fndecl, function.get_self (),\n-\t\t\t\t       self_type,\n-\t\t\t\t       function.get_self ().get_locus ());\n-\tif (compiled_self_param == nullptr)\n-\t  {\n-\t    rust_error_at (function.get_self ().get_locus (),\n-\t\t\t   \"failed to compile self param variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_self_param);\n-\tctx->insert_var_decl (function.get_self ().get_mappings ().get_hirid (),\n-\t\t\t      compiled_self_param);\n-      }\n-\n-    // offset from + 1 for the TyTy::FnType being used when this is a method to\n-    // skip over Self on the FnType\n-    size_t i = function.is_method () ? 1 : 0;\n-    for (auto referenced_param : function.get_function_params ())\n-      {\n-\tauto tyty_param = fntype->param_at (i);\n-\tauto param_tyty = tyty_param.second;\n-\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\tif (compiled_param_type == nullptr)\n-\t  {\n-\t    rust_error_at (referenced_param.get_locus (),\n-\t\t\t   \"failed to compile parameter type\");\n-\t    return;\n-\t  }\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n-\t  {\n-\t    rust_error_at (param_locus, \"Failed to compile parameter variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (func.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = func.get_block_expr ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (func.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    tree enclosing_scope = NULL_TREE;\n-    HIR::BlockExpr *function_body = func.get_block_expr ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_end_locus ();\n-\n-    tree code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_return_type ())\n-      {\n-\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  func.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, *func.get_block_expr ().get (),\n-\t\t\t   function.has_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (func.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-    ctx->push_function (fndecl);\n-\n-    reference\n-      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n-  }\n+  void visit (HIR::TraitItemFunc &func) override;\n \n private:\n-  CompileTraitItem (const TyTy::BaseType *self, Context *ctx,\n-\t\t    TyTy::BaseType *concrete, Location ref_locus)\n-    : HIRCompileBase (ctx), self (self), concrete (concrete),\n+  CompileTraitItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)\n+    : HIRCompileBase (ctx), concrete (concrete),\n       reference (ctx->get_backend ()->error_expression ()),\n       ref_locus (ref_locus)\n   {}\n \n-  const TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n   tree reference;\n   Location ref_locus;"}, {"sha": "d42cc1ef9984d002369ce167d5cda892d6ac4301", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -0,0 +1,202 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-extern.h\"\n+#include \"rust-constexpr.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileItem::visit (HIR::StaticItem &var)\n+{\n+  // have we already compiled this?\n+  Bvariable *static_decl_ref = nullptr;\n+  if (ctx->lookup_var_decl (var.get_mappings ().get_hirid (), &static_decl_ref))\n+    {\n+      reference\n+\t= ctx->get_backend ()->var_expression (static_decl_ref, ref_locus);\n+      return;\n+    }\n+\n+  TyTy::BaseType *resolved_type = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n+\t\t\t\t\t    &resolved_type);\n+  rust_assert (ok);\n+\n+  tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+  tree value = CompileExpr::Compile (var.get_expr (), ctx);\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  ok = ctx->get_mappings ()->lookup_canonical_path (\n+    var.get_mappings ().get_crate_num (), var.get_mappings ().get_nodeid (),\n+    &canonical_path);\n+  rust_assert (ok);\n+\n+  std::string name = canonical_path->get ();\n+  std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n+\n+  bool is_external = false;\n+  bool is_hidden = false;\n+  bool in_unique_section = true;\n+\n+  Bvariable *static_global\n+    = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n+\t\t\t\t\t    is_hidden, in_unique_section,\n+\t\t\t\t\t    var.get_locus ());\n+  ctx->get_backend ()->global_variable_set_init (static_global, value);\n+\n+  ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n+  ctx->push_var (static_global);\n+\n+  reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n+}\n+\n+void\n+CompileItem::visit (HIR::ConstantItem &constant)\n+{\n+  // resolve the type\n+  TyTy::BaseType *resolved_type = nullptr;\n+  bool ok\n+    = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n+\t\t\t\t      &resolved_type);\n+  rust_assert (ok);\n+\n+  // canonical path\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  ok = ctx->get_mappings ()->lookup_canonical_path (\n+    constant.get_mappings ().get_crate_num (),\n+    constant.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  HIR::Expr *const_value_expr = constant.get_expr ();\n+  tree const_expr\n+    = compile_constant_item (ctx, resolved_type, canonical_path,\n+\t\t\t     const_value_expr, constant.get_locus ());\n+\n+  ctx->push_const (const_expr);\n+  ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n+  reference = const_expr;\n+}\n+\n+void\n+CompileItem::visit (HIR::Function &function)\n+{\n+  TyTy::BaseType *fntype_tyty;\n+  if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n+\t\t\t\t       &fntype_tyty))\n+    {\n+      rust_fatal_error (function.get_locus (),\n+\t\t\t\"failed to lookup function type\");\n+      return;\n+    }\n+\n+  rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // we cant do anything for this only when it is used and a concrete type\n+      // is given\n+      if (concrete == nullptr)\n+\treturn;\n+      else\n+\t{\n+\t  rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n+\t  fntype = static_cast<TyTy::FnType *> (concrete);\n+\t}\n+    }\n+\n+  // items can be forward compiled which means we may not need to invoke this\n+  // code. We might also have already compiled this generic function as well.\n+  tree lookup = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n+\t\t\t\t fntype->get_id (), fntype))\n+    {\n+      // has this been added to the list then it must be finished\n+      if (ctx->function_completed (lookup))\n+\t{\n+\t  tree dummy = NULL_TREE;\n+\t  if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t    {\n+\t      ctx->insert_function_decl (fntype, lookup);\n+\t    }\n+\n+\t  reference = address_expression (lookup, ref_locus);\n+\t  return;\n+\t}\n+    }\n+\n+  if (fntype->has_subsititions_defined ())\n+    {\n+      // override the Hir Lookups for the substituions in this context\n+      fntype->override_context ();\n+    }\n+\n+  const Resolver::CanonicalPath *canonical_path = nullptr;\n+  bool ok = ctx->get_mappings ()->lookup_canonical_path (\n+    function.get_mappings ().get_crate_num (),\n+    function.get_mappings ().get_nodeid (), &canonical_path);\n+  rust_assert (ok);\n+\n+  tree fndecl\n+    = compile_function (ctx, function.get_function_name (),\n+\t\t\tfunction.get_self_param (),\n+\t\t\tfunction.get_function_params (),\n+\t\t\tfunction.get_qualifiers (), function.get_visibility (),\n+\t\t\tfunction.get_outer_attrs (), function.get_locus (),\n+\t\t\tfunction.get_definition ().get (), canonical_path,\n+\t\t\tfntype, function.has_function_return_type ());\n+  reference = address_expression (fndecl, ref_locus);\n+}\n+\n+void\n+CompileItem::visit (HIR::ImplBlock &impl_block)\n+{\n+  TyTy::BaseType *self_lookup = nullptr;\n+  if (!ctx->get_tyctx ()->lookup_type (\n+\timpl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n+    {\n+      rust_error_at (impl_block.get_locus (), \"failed to resolve type of impl\");\n+      return;\n+    }\n+\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    CompileInherentImplItem::Compile (impl_item.get (), ctx);\n+}\n+\n+void\n+CompileItem::visit (HIR::ExternBlock &extern_block)\n+{\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      CompileExternItem::compile (item.get (), ctx, concrete);\n+    }\n+}\n+\n+void\n+CompileItem::visit (HIR::Module &module)\n+{\n+  for (auto &item : module.get_items ())\n+    CompileItem::compile (item.get (), ctx);\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "71f259f06435d5f5d0b67e2c0b3548d48aa9524e", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 6, "deletions": 361, "changes": 367, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -20,14 +20,6 @@\n #define RUST_COMPILE_ITEM\n \n #include \"rust-compile-base.h\"\n-#include \"rust-compile-tyty.h\"\n-#include \"rust-compile-implitem.h\"\n-#include \"rust-compile-var-decl.h\"\n-#include \"rust-compile-stmt.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-fnparam.h\"\n-#include \"rust-compile-extern.h\"\n-#include \"rust-constexpr.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -54,364 +46,17 @@ class CompileItem : public HIRCompileBase\n     return compiler.reference;\n   }\n \n-  void visit (HIR::StaticItem &var) override\n-  {\n-    // have we already compiled this?\n-    Bvariable *static_decl_ref = nullptr;\n-    if (ctx->lookup_var_decl (var.get_mappings ().get_hirid (),\n-\t\t\t      &static_decl_ref))\n-      {\n-\treference\n-\t  = ctx->get_backend ()->var_expression (static_decl_ref, ref_locus);\n-\treturn;\n-      }\n-\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (var.get_mappings ().get_hirid (),\n-\t\t\t\t\t      &resolved_type);\n-    rust_assert (ok);\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (var.get_expr (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      var.get_mappings ().get_crate_num (), var.get_mappings ().get_nodeid (),\n-      &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string name = canonical_path->get ();\n-    std::string asm_name = ctx->mangle_item (resolved_type, *canonical_path);\n-\n-    bool is_external = false;\n-    bool is_hidden = false;\n-    bool in_unique_section = true;\n-\n-    Bvariable *static_global\n-      = ctx->get_backend ()->global_variable (name, asm_name, type, is_external,\n-\t\t\t\t\t      is_hidden, in_unique_section,\n-\t\t\t\t\t      var.get_locus ());\n-    ctx->get_backend ()->global_variable_set_init (static_global, value);\n-\n-    ctx->insert_var_decl (var.get_mappings ().get_hirid (), static_global);\n-    ctx->push_var (static_global);\n-\n-    reference = ctx->get_backend ()->var_expression (static_global, ref_locus);\n-  }\n-\n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    // resolve the type\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok\n-      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n-\t\t\t\t\t&resolved_type);\n-    rust_assert (ok);\n-\n-    // canonical path\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-    std::string ident = canonical_path->get ();\n-\n-    // types\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n-\n-    HIR::Expr *const_value_expr = constant.get_expr ();\n-    bool is_block_expr\n-      = const_value_expr->get_expression_type () == HIR::Expr::ExprType::Block;\n-\n-    // compile the expression\n-    tree folded_expr = error_mark_node;\n-    if (!is_block_expr)\n-      {\n-\ttree value = CompileExpr::Compile (constant.get_expr (), ctx);\n-\tfolded_expr = ConstCtx::fold (value);\n-      }\n-    else\n-      {\n-\t// in order to compile a block expr we want to reuse as much existing\n-\t// machineary that we already have. This means the best approach is to\n-\t// make a _fake_ function with a block so it can hold onto temps then\n-\t// use our constexpr code to fold it completely or error_mark_node\n-\tBackend::typed_identifier receiver;\n-\ttree compiled_fn_type = ctx->get_backend ()->function_type (\n-\t  receiver, {},\n-\t  {Backend::typed_identifier (\"_\", const_type, constant.get_locus ())},\n-\t  NULL, constant.get_locus ());\n-\n-\ttree fndecl\n-\t  = ctx->get_backend ()->function (compiled_fn_type, ident, \"\", 0,\n-\t\t\t\t\t   constant.get_locus ());\n-\tTREE_READONLY (fndecl) = 1;\n-\n-\ttree enclosing_scope = NULL_TREE;\n-\tHIR::BlockExpr *function_body\n-\t  = static_cast<HIR::BlockExpr *> (constant.get_expr ());\n-\tLocation start_location = function_body->get_locus ();\n-\tLocation end_location = function_body->get_end_locus ();\n-\n-\ttree code_block\n-\t  = ctx->get_backend ()->block (fndecl, enclosing_scope, {},\n-\t\t\t\t\tstart_location, end_location);\n-\tctx->push_block (code_block);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\tBvariable *return_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, const_type, NULL, address_is_taken,\n-\t  constant.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-\tctx->push_fn (fndecl, return_address);\n-\n-\tcompile_function_body (fndecl, *function_body, true);\n-\n-\tctx->pop_block ();\n-\n-\tauto body = ctx->get_backend ()->block_statement (code_block);\n-\tif (!ctx->get_backend ()->function_set_body (fndecl, body))\n-\t  {\n-\t    rust_error_at (constant.get_locus (),\n-\t\t\t   \"failed to set body to constant function\");\n-\t    return;\n-\t  }\n-\n-\tctx->pop_fn ();\n-\n-\t// lets fold it into a call expr\n-\ttree call = build_call_array_loc (constant.get_locus ().gcc_location (),\n-\t\t\t\t\t  const_type, fndecl, 0, NULL);\n-\tfolded_expr = ConstCtx::fold (call);\n-      }\n-\n-    tree const_expr\n-      = ctx->get_backend ()->named_constant_expression (const_type, ident,\n-\t\t\t\t\t\t\tfolded_expr,\n-\t\t\t\t\t\t\tconstant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    reference = const_expr;\n-  }\n-\n-  void visit (HIR::Function &function) override\n-  {\n-    TyTy::BaseType *fntype_tyty;\n-    if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n-\t\t\t\t\t &fntype_tyty))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to lookup function type\");\n-\treturn;\n-      }\n-\n-    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// we cant do anything for this only when it is used and a concrete type\n-\t// is given\n-\tif (concrete == nullptr)\n-\t  return;\n-\telse\n-\t  {\n-\t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n-\t    fntype = static_cast<TyTy::FnType *> (concrete);\n-\t  }\n-      }\n-\n-    // items can be forward compiled which means we may not need to invoke this\n-    // code. We might also have already compiled this generic function as well.\n-    tree lookup = NULL_TREE;\n-    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n-\t\t\t\t   fntype->get_id (), fntype))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  {\n-\t    tree dummy = NULL_TREE;\n-\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n-\t      {\n-\t\tctx->insert_function_decl (fntype, lookup);\n-\t      }\n+  void visit (HIR::StaticItem &var) override;\n \n-\t    reference\n-\t      = ctx->get_backend ()->function_code_expression (lookup,\n-\t\t\t\t\t\t\t       ref_locus);\n-\t    return;\n-\t  }\n-      }\n+  void visit (HIR::ConstantItem &constant) override;\n \n-    if (fntype->has_subsititions_defined ())\n-      {\n-\t// override the Hir Lookups for the substituions in this context\n-\tfntype->override_context ();\n-      }\n+  void visit (HIR::Function &function) override;\n \n-    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+  void visit (HIR::ImplBlock &impl_block) override;\n \n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    bool ok = ctx->get_mappings ()->lookup_canonical_path (\n-      function.get_mappings ().get_crate_num (),\n-      function.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n+  void visit (HIR::ExternBlock &extern_block) override;\n \n-    std::string ir_symbol_name\n-      = canonical_path->get () + fntype->subst_as_string ();\n-    std::string asm_name = function.get_function_name ();\n-\n-    // we don't mangle the main fn since we haven't implemented the main shim\n-    // yet\n-    bool is_main_fn = function.get_function_name ().compare (\"main\") == 0;\n-    if (!is_main_fn)\n-      {\n-\tasm_name = ctx->mangle_item (fntype, *canonical_path);\n-      }\n-\n-    unsigned int flags = 0;\n-    tree fndecl\n-      = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n-\t\t\t\t       asm_name, flags, function.get_locus ());\n-    setup_attributes_on_fndecl (fndecl, is_main_fn, function.has_visibility (),\n-\t\t\t\tfunction.get_qualifiers (),\n-\t\t\t\tfunction.get_outer_attrs ());\n-\n-    // insert into the context\n-    ctx->insert_function_decl (fntype, fndecl);\n-\n-    // setup the params\n-    TyTy::BaseType *tyret = fntype->get_return_type ();\n-    std::vector<Bvariable *> param_vars;\n-\n-    size_t i = 0;\n-    for (auto &it : fntype->get_params ())\n-      {\n-\tHIR::FunctionParam &referenced_param\n-\t  = function.get_function_params ().at (i);\n-\tauto param_tyty = it.second;\n-\tauto compiled_param_type\n-\t  = TyTyResolveCompile::compile (ctx, param_tyty);\n-\n-\tLocation param_locus\n-\t  = ctx->get_mappings ()->lookup_location (param_tyty->get_ref ());\n-\tBvariable *compiled_param_var\n-\t  = CompileFnParam::compile (ctx, fndecl, &referenced_param,\n-\t\t\t\t     compiled_param_type, param_locus);\n-\tif (compiled_param_var == nullptr)\n-\t  {\n-\t    rust_error_at (param_locus, \"failed to compile parameter variable\");\n-\t    return;\n-\t  }\n-\n-\tparam_vars.push_back (compiled_param_var);\n-\n-\tctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n-\t\t\t      compiled_param_var);\n-\ti++;\n-      }\n-\n-    if (!ctx->get_backend ()->function_set_parameters (fndecl, param_vars))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup parameter variables\");\n-\treturn;\n-      }\n-\n-    // lookup locals\n-    auto block_expr = function.get_definition ().get ();\n-    auto body_mappings = block_expr->get_mappings ();\n-\n-    Resolver::Rib *rib = nullptr;\n-    if (!ctx->get_resolver ()->find_name_rib (body_mappings.get_nodeid (),\n-\t\t\t\t\t      &rib))\n-      {\n-\trust_fatal_error (function.get_locus (),\n-\t\t\t  \"failed to setup locals per block\");\n-\treturn;\n-      }\n-\n-    std::vector<Bvariable *> locals;\n-    ok = compile_locals_for_block (*rib, fndecl, locals);\n-    rust_assert (ok);\n-\n-    tree enclosing_scope = NULL_TREE;\n-    HIR::BlockExpr *function_body = function.get_definition ().get ();\n-    Location start_location = function_body->get_locus ();\n-    Location end_location = function_body->get_end_locus ();\n-\n-    tree code_block\n-      = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t    start_location, end_location);\n-    ctx->push_block (code_block);\n-\n-    Bvariable *return_address = nullptr;\n-    if (function.has_function_return_type ())\n-      {\n-\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n-\n-\tbool address_is_taken = false;\n-\ttree ret_var_stmt = NULL_TREE;\n-\n-\treturn_address = ctx->get_backend ()->temporary_variable (\n-\t  fndecl, code_block, return_type, NULL, address_is_taken,\n-\t  function.get_locus (), &ret_var_stmt);\n-\n-\tctx->add_statement (ret_var_stmt);\n-      }\n-\n-    ctx->push_fn (fndecl, return_address);\n-\n-    compile_function_body (fndecl, *function.get_definition ().get (),\n-\t\t\t   function.has_function_return_type ());\n-\n-    ctx->pop_block ();\n-    auto body = ctx->get_backend ()->block_statement (code_block);\n-    if (!ctx->get_backend ()->function_set_body (fndecl, body))\n-      {\n-\trust_error_at (function.get_locus (), \"failed to set body to function\");\n-\treturn;\n-      }\n-\n-    ctx->pop_fn ();\n-    ctx->push_function (fndecl);\n-\n-    reference\n-      = ctx->get_backend ()->function_code_expression (fndecl, ref_locus);\n-  }\n-\n-  void visit (HIR::ImplBlock &impl_block) override\n-  {\n-    TyTy::BaseType *self_lookup = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (\n-\t  impl_block.get_type ()->get_mappings ().get_hirid (), &self_lookup))\n-      {\n-\trust_error_at (impl_block.get_locus (),\n-\t\t       \"failed to resolve type of impl\");\n-\treturn;\n-      }\n-\n-    for (auto &impl_item : impl_block.get_impl_items ())\n-      CompileInherentImplItem::Compile (impl_item.get (), ctx);\n-  }\n-\n-  void visit (HIR::ExternBlock &extern_block) override\n-  {\n-    for (auto &item : extern_block.get_extern_items ())\n-      {\n-\tCompileExternItem::compile (item.get (), ctx, concrete);\n-      }\n-  }\n-\n-  void visit (HIR::Module &module) override\n-  {\n-    for (auto &item : module.get_items ())\n-      CompileItem::compile (item.get (), ctx);\n-  }\n+  void visit (HIR::Module &module) override;\n \n protected:\n   CompileItem (Context *ctx, TyTy::BaseType *concrete, Location ref_locus)"}, {"sha": "2ef123202039c19096050feaaca71ca5fbcedc79", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -16,10 +16,10 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-linemap.h\"\n-#include \"rust-backend.h\"\n #include \"rust-compile-resolve-path.h\"\n #include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n \n@@ -131,7 +131,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n       tree fn = NULL_TREE;\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n-\t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+\t  return address_expression (fn, expr_locus);\n \t}\n     }\n \n@@ -245,8 +245,8 @@ HIRCompileBase::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t      associated->setup_associated_types ();\n \n \t      return CompileTraitItem::Compile (\n-\t\treceiver, trait_item_ref->get_hir_trait_item (), ctx, lookup,\n-\t\ttrue, expr_locus);\n+\t\ttrait_item_ref->get_hir_trait_item (), ctx, lookup, true,\n+\t\texpr_locus);\n \t    }\n \t  else\n \t    {"}, {"sha": "24a2084bae289fc513de3a7259e331ecccc1fbd8", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -48,34 +48,6 @@ class CompileStmt : public HIRCompileBase\n     translated = CompileExpr::Compile (stmt.get_expr (), ctx);\n   }\n \n-  void visit (HIR::ConstantItem &constant) override\n-  {\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok\n-      = ctx->get_tyctx ()->lookup_type (constant.get_mappings ().get_hirid (),\n-\t\t\t\t\t&resolved_type);\n-    rust_assert (ok);\n-\n-    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n-\n-    const Resolver::CanonicalPath *canonical_path = nullptr;\n-    ok = ctx->get_mappings ()->lookup_canonical_path (\n-      constant.get_mappings ().get_crate_num (),\n-      constant.get_mappings ().get_nodeid (), &canonical_path);\n-    rust_assert (ok);\n-\n-    std::string ident = canonical_path->get ();\n-    tree const_expr\n-      = ctx->get_backend ()->named_constant_expression (type, ident, value,\n-\t\t\t\t\t\t\tconstant.get_locus ());\n-\n-    ctx->push_const (const_expr);\n-    ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);\n-\n-    translated = const_expr;\n-  }\n-\n   void visit (HIR::LetStmt &stmt) override\n   {\n     // nothing to do"}, {"sha": "fcbfc05a6c599559aebd277b50d292c45ac90cc3", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 10, "deletions": 90, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -16,14 +16,16 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-#include \"rust-compile.h\"\n-#include \"rust-compile-item.h\"\n-#include \"rust-compile-expr.h\"\n-#include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-implitem.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-compile-stmt.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -67,9 +69,8 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n       return;\n     }\n \n-  std::vector<Bvariable *> locals;\n-  bool ok = compile_locals_for_block (*rib, fndecl, locals);\n-  rust_assert (ok);\n+  std::vector<Bvariable *> locals\n+    = compile_locals_for_block (ctx, *rib, fndecl);\n \n   tree enclosing_scope = ctx->peek_enclosing_scope ();\n   tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n@@ -203,87 +204,6 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n \n // Shared methods in compilation\n \n-void\n-HIRCompileBase::compile_function_body (tree fndecl,\n-\t\t\t\t       HIR::BlockExpr &function_body,\n-\t\t\t\t       bool has_return_type)\n-{\n-  for (auto &s : function_body.get_statements ())\n-    {\n-      auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n-      if (compiled_expr != nullptr)\n-\t{\n-\t  tree compiled_stmt\n-\t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n-\t  ctx->add_statement (compiled_stmt);\n-\t}\n-    }\n-\n-  if (function_body.has_expr ())\n-    {\n-      // the previous passes will ensure this is a valid return\n-      // or a valid trailing expression\n-      tree compiled_expr\n-\t= CompileExpr::Compile (function_body.expr.get (), ctx);\n-\n-      if (compiled_expr != nullptr)\n-\t{\n-\t  if (has_return_type)\n-\t    {\n-\t      std::vector<tree> retstmts;\n-\t      retstmts.push_back (compiled_expr);\n-\n-\t      auto ret = ctx->get_backend ()->return_statement (\n-\t\tfndecl, retstmts,\n-\t\tfunction_body.get_final_expr ()->get_locus ());\n-\t      ctx->add_statement (ret);\n-\t    }\n-\t  else\n-\t    {\n-\t      tree final_stmt\n-\t\t= ctx->get_backend ()->expression_statement (fndecl,\n-\t\t\t\t\t\t\t     compiled_expr);\n-\t      ctx->add_statement (final_stmt);\n-\t    }\n-\t}\n-    }\n-}\n-\n-bool\n-HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n-\t\t\t\t\t  std::vector<Bvariable *> &locals)\n-{\n-  rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-    Resolver::Definition d;\n-    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-    rust_assert (ok);\n-\n-    HIR::Stmt *decl = nullptr;\n-    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-    rust_assert (ok);\n-\n-    // if its a function we extract this out side of this fn context\n-    // and it is not a local to this function\n-    bool is_item = ctx->get_mappings ()->lookup_hir_item (\n-\t\t     decl->get_mappings ().get_crate_num (),\n-\t\t     decl->get_mappings ().get_hirid ())\n-\t\t   != nullptr;\n-    if (is_item)\n-      {\n-\tHIR::Item *item = static_cast<HIR::Item *> (decl);\n-\tCompileItem::compile (item, ctx);\n-\treturn true;\n-      }\n-\n-    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-    locals.push_back (compiled);\n-\n-    return true;\n-  });\n-\n-  return true;\n-}\n-\n tree\n HIRCompileBase::coercion_site (tree rvalue, TyTy::BaseType *actual,\n \t\t\t       TyTy::BaseType *expected, Location lvalue_locus,\n@@ -533,8 +453,8 @@ HIRCompileBase::compute_address_for_trait_item (\n   rust_assert (trait_item_has_definition);\n \n   HIR::TraitItem *trait_item = ref->get_hir_trait_item ();\n-  return CompileTraitItem::Compile (root, trait_item, ctx, trait_item_fntype,\n-\t\t\t\t    true, locus);\n+  return CompileTraitItem::Compile (trait_item, ctx, trait_item_fntype, true,\n+\t\t\t\t    locus);\n }\n \n bool"}, {"sha": "d1cb762dce2bae7dde7c3a88ebe3924dbce9bc1b", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -510,7 +510,6 @@ struct FunctionParam\n {\n   std::unique_ptr<Pattern> param_name;\n   std::unique_ptr<Type> type;\n-\n   Location locus;\n   Analysis::NodeMapping mappings;\n \n@@ -1226,11 +1225,7 @@ class Function : public VisItem, public ImplItem\n \n   bool is_method () const { return !self.is_error (); }\n \n-  SelfParam &get_self_param ()\n-  {\n-    rust_assert (is_method ());\n-    return self;\n-  }\n+  SelfParam &get_self_param () { return self; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -2242,11 +2237,7 @@ struct TraitFunctionDecl\n \n   bool is_method () const { return !self.is_error (); }\n \n-  SelfParam &get_self ()\n-  {\n-    rust_assert (is_method ());\n-    return self;\n-  }\n+  SelfParam &get_self () { return self; }\n \n   Identifier get_function_name () const { return function_name; }\n \n@@ -2341,7 +2332,8 @@ class TraitItemFunc : public TraitItem\n     return TraitItemKind::FUNC;\n   }\n \n-  AST::AttrVec get_outer_attrs () const { return outer_attrs; }\n+  AST::AttrVec &get_outer_attrs () { return outer_attrs; }\n+  const AST::AttrVec &get_outer_attrs () const { return outer_attrs; }\n \n protected:\n   // Clone function implementation as (not pure) virtual method"}, {"sha": "ac856af97560d1e8e94cb8c9d5fa3eb79b4a2c6b", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -251,10 +251,6 @@ class Backend\n   // Return an expression that converts EXPR to TYPE.\n   virtual tree convert_expression (tree type, tree expr, Location) = 0;\n \n-  // Create an expression for the address of a function.  This is used to\n-  // get the address of the code for a function.\n-  virtual tree function_code_expression (tree, Location) = 0;\n-\n   // Return an expression for the field at INDEX in BSTRUCT.\n   virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n     = 0;"}, {"sha": "b648365f253db75f6a1d48c49dd6ed97102a169e", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2aa172ff69591452e3566c105f2a4cd8450eab5/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=b2aa172ff69591452e3566c105f2a4cd8450eab5", "patch": "@@ -229,8 +229,6 @@ class Gcc_backend : public Backend\n \n   tree convert_expression (tree type, tree expr, Location);\n \n-  tree function_code_expression (tree, Location);\n-\n   tree struct_field_expression (tree, size_t, Location);\n \n   tree compound_expression (tree, tree, Location);\n@@ -1305,18 +1303,6 @@ Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n   return ret;\n }\n \n-// Get the address of a function.\n-\n-tree\n-Gcc_backend::function_code_expression (tree func, Location location)\n-{\n-  if (func == error_mark_node)\n-    return this->error_expression ();\n-\n-  tree ret = build_fold_addr_expr_loc (location.gcc_location (), func);\n-  return ret;\n-}\n-\n // Return an expression for the field at INDEX in BSTRUCT.\n \n tree"}]}