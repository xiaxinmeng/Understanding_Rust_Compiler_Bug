{"sha": "081564faed7cc138dfcaa48021cc01a94fd1ba3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgxNTY0ZmFlZDdjYzEzOGRmY2FhNDgwMjFjYzAxYTk0ZmQxYmEzYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-04-29T21:31:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-04-29T21:31:53Z"}, "message": "runtime: Support -buildmode=c-shared.\n\nThese changes permit using the go tool from the upcoming Go\n1.5 release with -buildmode=c-archive to build gccgo code into\nan archive file that can be linked with a C program.\n\nFrom-SVN: r222594", "tree": {"sha": "12e6811acbf892c31a8a0e6baa6cf5a49ed6beaa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12e6811acbf892c31a8a0e6baa6cf5a49ed6beaa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/081564faed7cc138dfcaa48021cc01a94fd1ba3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081564faed7cc138dfcaa48021cc01a94fd1ba3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/081564faed7cc138dfcaa48021cc01a94fd1ba3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081564faed7cc138dfcaa48021cc01a94fd1ba3c/comments", "author": null, "committer": null, "parents": [{"sha": "2f79da78f3bdb1dd1176f0c50262b8dde9ea188b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f79da78f3bdb1dd1176f0c50262b8dde9ea188b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f79da78f3bdb1dd1176f0c50262b8dde9ea188b"}], "stats": {"total": 341, "additions": 333, "deletions": 8}, "files": [{"sha": "fa4fcaa6404e581624a86c2e0cf9d7a2738cdf1c", "filename": "libgo/Makefile.am", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -105,7 +105,7 @@ toolexeclib_LTLIBRARIES = libgo-llgo.la\n toolexeclib_LIBRARIES = libgobegin-llgo.a\n else\n toolexeclib_LTLIBRARIES = libgo.la\n-toolexeclib_LIBRARIES = libgobegin.a libnetgo.a\n+toolexeclib_LIBRARIES = libgobegin.a libgolibbegin.a libnetgo.a\n endif\n \n toolexeclibgo_DATA = \\\n@@ -2036,6 +2036,11 @@ libgobegin_llgo_a_SOURCES = \\\n libgobegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n libgobegin_llgo_a_CFLAGS = $(AM_CFLAGS) -fPIC\n \n+libgolibbegin_a_SOURCES = \\\n+\truntime/go-libmain.c\n+\n+libgolibbegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n+\n libnetgo_a_SOURCES = $(go_netgo_files)\n libnetgo_a_LIBADD = netgo.o\n \n@@ -2067,7 +2072,7 @@ BUILDPACKAGE = \\\n BUILDNETGO = \\\n \t$(MKDIR_P) $(@D); \\\n \tfiles=`echo $^ | sed -e 's/[^ ]*\\.gox//g'`; \\\n-\t$(GOCOMPILE) -I . -c -fgo-pkgpath=net -o $@ $$files\n+\t$(GOCOMPILE) -I . -c -fPIC -fgo-pkgpath=net -o $@ $$files\n \n GOTESTFLAGS =\n GOBENCH = "}, {"sha": "99ffbb276118264bad688990646cb9bb49707ea7", "filename": "libgo/Makefile.in", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -136,6 +136,10 @@ libgobegin_a_AR = $(AR) $(ARFLAGS)\n libgobegin_a_LIBADD =\n am_libgobegin_a_OBJECTS = libgobegin_a-go-main.$(OBJEXT)\n libgobegin_a_OBJECTS = $(am_libgobegin_a_OBJECTS)\n+libgolibbegin_a_AR = $(AR) $(ARFLAGS)\n+libgolibbegin_a_LIBADD =\n+am_libgolibbegin_a_OBJECTS = libgolibbegin_a-go-libmain.$(OBJEXT)\n+libgolibbegin_a_OBJECTS = $(am_libgolibbegin_a_OBJECTS)\n libnetgo_a_AR = $(AR) $(ARFLAGS)\n libnetgo_a_DEPENDENCIES = netgo.o\n am__objects_1 =\n@@ -264,8 +268,8 @@ LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n SOURCES = $(libgobegin_llgo_a_SOURCES) $(libgobegin_a_SOURCES) \\\n-\t$(libnetgo_a_SOURCES) $(libgo_llgo_la_SOURCES) \\\n-\t$(libgo_la_SOURCES)\n+\t$(libgolibbegin_a_SOURCES) $(libnetgo_a_SOURCES) \\\n+\t$(libgo_llgo_la_SOURCES) $(libgo_la_SOURCES)\n MULTISRCTOP = \n MULTIBUILDTOP = \n MULTIDIRS = \n@@ -532,7 +536,7 @@ AM_MAKEFLAGS = \\\n FLAGS_TO_PASS = $(AM_MAKEFLAGS)\n @GOC_IS_LLGO_FALSE@toolexeclib_LTLIBRARIES = libgo.la\n @GOC_IS_LLGO_TRUE@toolexeclib_LTLIBRARIES = libgo-llgo.la\n-@GOC_IS_LLGO_FALSE@toolexeclib_LIBRARIES = libgobegin.a libnetgo.a\n+@GOC_IS_LLGO_FALSE@toolexeclib_LIBRARIES = libgobegin.a libgolibbegin.a libnetgo.a\n @GOC_IS_LLGO_TRUE@toolexeclib_LIBRARIES = libgobegin-llgo.a\n toolexeclibgo_DATA = \\\n \tbufio.gox \\\n@@ -2102,6 +2106,10 @@ libgobegin_llgo_a_SOURCES = \\\n # Use -fPIC for libgobegin so that it can be put in a PIE.\n libgobegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n libgobegin_llgo_a_CFLAGS = $(AM_CFLAGS) -fPIC\n+libgolibbegin_a_SOURCES = \\\n+\truntime/go-libmain.c\n+\n+libgolibbegin_a_CFLAGS = $(AM_CFLAGS) -fPIC\n libnetgo_a_SOURCES = $(go_netgo_files)\n libnetgo_a_LIBADD = netgo.o\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n@@ -2132,7 +2140,7 @@ BUILDPACKAGE = \\\n BUILDNETGO = \\\n \t$(MKDIR_P) $(@D); \\\n \tfiles=`echo $^ | sed -e 's/[^ ]*\\.gox//g'`; \\\n-\t$(GOCOMPILE) -I . -c -fgo-pkgpath=net -o $@ $$files\n+\t$(GOCOMPILE) -I . -c -fPIC -fgo-pkgpath=net -o $@ $$files\n \n GOTESTFLAGS = \n GOBENCH = \n@@ -2421,6 +2429,10 @@ libgobegin.a: $(libgobegin_a_OBJECTS) $(libgobegin_a_DEPENDENCIES)\n \t-rm -f libgobegin.a\n \t$(libgobegin_a_AR) libgobegin.a $(libgobegin_a_OBJECTS) $(libgobegin_a_LIBADD)\n \t$(RANLIB) libgobegin.a\n+libgolibbegin.a: $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_DEPENDENCIES) \n+\t-rm -f libgolibbegin.a\n+\t$(libgolibbegin_a_AR) libgolibbegin.a $(libgolibbegin_a_OBJECTS) $(libgolibbegin_a_LIBADD)\n+\t$(RANLIB) libgolibbegin.a\n libnetgo.a: $(libnetgo_a_OBJECTS) $(libnetgo_a_DEPENDENCIES) \n \t-rm -f libnetgo.a\n \t$(libnetgo_a_AR) libnetgo.a $(libnetgo_a_OBJECTS) $(libnetgo_a_LIBADD)\n@@ -2546,6 +2558,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lfstack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgobegin_a-go-main.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgobegin_llgo_a-go-main.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libgolibbegin_a-go-libmain.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_futex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n@@ -2631,6 +2644,20 @@ libgobegin_a-go-main.obj: runtime/go-main.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgobegin_a_CFLAGS) $(CFLAGS) -c -o libgobegin_a-go-main.obj `if test -f 'runtime/go-main.c'; then $(CYGPATH_W) 'runtime/go-main.c'; else $(CYGPATH_W) '$(srcdir)/runtime/go-main.c'; fi`\n \n+libgolibbegin_a-go-libmain.o: runtime/go-libmain.c\n+@am__fastdepCC_TRUE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgolibbegin_a_CFLAGS) $(CFLAGS) -MT libgolibbegin_a-go-libmain.o -MD -MP -MF $(DEPDIR)/libgolibbegin_a-go-libmain.Tpo -c -o libgolibbegin_a-go-libmain.o `test -f 'runtime/go-libmain.c' || echo '$(srcdir)/'`runtime/go-libmain.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libgolibbegin_a-go-libmain.Tpo $(DEPDIR)/libgolibbegin_a-go-libmain.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-libmain.c' object='libgolibbegin_a-go-libmain.o' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgolibbegin_a_CFLAGS) $(CFLAGS) -c -o libgolibbegin_a-go-libmain.o `test -f 'runtime/go-libmain.c' || echo '$(srcdir)/'`runtime/go-libmain.c\n+\n+libgolibbegin_a-go-libmain.obj: runtime/go-libmain.c\n+@am__fastdepCC_TRUE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgolibbegin_a_CFLAGS) $(CFLAGS) -MT libgolibbegin_a-go-libmain.obj -MD -MP -MF $(DEPDIR)/libgolibbegin_a-go-libmain.Tpo -c -o libgolibbegin_a-go-libmain.obj `if test -f 'runtime/go-libmain.c'; then $(CYGPATH_W) 'runtime/go-libmain.c'; else $(CYGPATH_W) '$(srcdir)/runtime/go-libmain.c'; fi`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libgolibbegin_a-go-libmain.Tpo $(DEPDIR)/libgolibbegin_a-go-libmain.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-libmain.c' object='libgolibbegin_a-go-libmain.obj' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libgolibbegin_a_CFLAGS) $(CFLAGS) -c -o libgolibbegin_a-go-libmain.obj `if test -f 'runtime/go-libmain.c'; then $(CYGPATH_W) 'runtime/go-libmain.c'; else $(CYGPATH_W) '$(srcdir)/runtime/go-libmain.c'; fi`\n+\n go-append.lo: runtime/go-append.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-append.lo -MD -MP -MF $(DEPDIR)/go-append.Tpo -c -o go-append.lo `test -f 'runtime/go-append.c' || echo '$(srcdir)/'`runtime/go-append.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-append.Tpo $(DEPDIR)/go-append.Plo"}, {"sha": "a36eac92704eb55e1680495559f0806ec1805bf1", "filename": "libgo/runtime/go-cgo.c", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fgo-cgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fgo-cgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cgo.c?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -8,6 +8,9 @@\n #include \"go-alloc.h\"\n #include \"interface.h\"\n #include \"go-panic.h\"\n+#include \"go-type.h\"\n+\n+extern void __go_receive (ChanType *, Hchan *, byte *);\n \n /* Prepare to call from code written in Go to code written in C or\n    C++.  This takes the current goroutine out of the Go scheduler, as\n@@ -86,6 +89,15 @@ syscall_cgocallback ()\n \n   runtime_exitsyscall ();\n \n+  if (runtime_g ()->ncgo == 0)\n+    {\n+      /* The C call to Go came from a thread not currently running any\n+\t Go.  In the case of -buildmode=c-archive or c-shared, this\n+\t call may be coming in before package initialization is\n+\t complete.  Wait until it is.  */\n+      __go_receive (NULL, runtime_main_init_done, NULL);\n+    }\n+\n   mp = runtime_m ();\n   if (mp->needextram)\n     {\n@@ -177,3 +189,65 @@ _cgo_panic (const char *p)\n \n   __go_panic (e);\n }\n+\n+/* Used for _cgo_wait_runtime_init_done.  This is based on code in\n+   runtime/cgo/gcc_libinit.c in the master library.  */\n+\n+static pthread_cond_t runtime_init_cond = PTHREAD_COND_INITIALIZER;\n+static pthread_mutex_t runtime_init_mu = PTHREAD_MUTEX_INITIALIZER;\n+static _Bool runtime_init_done;\n+\n+/* This is called by exported cgo functions to ensure that the runtime\n+   has been initialized before we enter the function.  This is needed\n+   when building with -buildmode=c-archive or similar.  */\n+\n+void\n+_cgo_wait_runtime_init_done (void)\n+{\n+  int err;\n+\n+  if (__atomic_load_n (&runtime_init_done, __ATOMIC_ACQUIRE))\n+    return;\n+\n+  err = pthread_mutex_lock (&runtime_init_mu);\n+  if (err != 0)\n+    abort ();\n+  while (!__atomic_load_n (&runtime_init_done, __ATOMIC_ACQUIRE))\n+    {\n+      err = pthread_cond_wait (&runtime_init_cond, &runtime_init_mu);\n+      if (err != 0)\n+\tabort ();\n+    }\n+  err = pthread_mutex_unlock (&runtime_init_mu);\n+  if (err != 0)\n+    abort ();\n+}\n+\n+/* This is called by runtime_main after the Go runtime is\n+   initialized.  */\n+\n+void\n+_cgo_notify_runtime_init_done (void)\n+{\n+  int err;\n+\n+  err = pthread_mutex_lock (&runtime_init_mu);\n+  if (err != 0)\n+    abort ();\n+  __atomic_store_n (&runtime_init_done, 1, __ATOMIC_RELEASE);\n+  err = pthread_cond_broadcast (&runtime_init_cond);\n+  if (err != 0)\n+    abort ();\n+  err = pthread_mutex_unlock (&runtime_init_mu);\n+  if (err != 0)\n+    abort ();\n+}\n+\n+// runtime_iscgo is set to true if some cgo code is linked in.\n+// This is done by a constructor in the cgo generated code.\n+_Bool runtime_iscgo;\n+\n+// runtime_cgoHasExtraM is set on startup when an extra M is created\n+// for cgo.  The extra M must be created before any C/C++ code calls\n+// cgocallback.\n+_Bool runtime_cgoHasExtraM;"}, {"sha": "f578aab43b7f244b4e66ff1302a6aabc44c264c8", "filename": "libgo/runtime/go-libmain.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fgo-libmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fgo-libmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-libmain.c?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -0,0 +1,114 @@\n+/* go-libmain.c -- the startup function for a Go library.\n+\n+   Copyright 2015 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <time.h>\n+#include <unistd.h>\n+\n+#include \"runtime.h\"\n+#include \"go-alloc.h\"\n+#include \"array.h\"\n+#include \"arch.h\"\n+#include \"malloc.h\"\n+\n+/* This is used when building a standalone Go library using the Go\n+   command's -buildmode=c-archive or -buildmode=c-shared option.  It\n+   starts up the Go code as a global constructor but does not take any\n+   other action.  The main program is written in some other language\n+   and calls exported Go functions as needed.  */\n+\n+static void die (const char *, int);\n+static void initfn (int, char **, char **);\n+static void *gostart (void *);\n+\n+/* Used to pass arguments to the thread that runs the Go startup.  */\n+\n+struct args {\n+  int argc;\n+  char **argv;\n+};\n+\n+/* We use .init_array so that we can get the command line arguments.\n+   This obviously assumes .init_array support; different systems may\n+   require other approaches.  */\n+\n+typedef void (*initarrayfn) (int, char **, char **);\n+\n+static initarrayfn initarray[1]\n+__attribute__ ((section (\".init_array\"), used)) =\n+  { initfn };\n+\n+/* This function is called at program startup time.  It starts a new\n+   thread to do the actual Go startup, so that program startup is not\n+   paused waiting for the Go initialization functions.  Exported cgo\n+   functions will wait for initialization to complete if\n+   necessary.  */\n+\n+static void\n+initfn (int argc, char **argv, char** env __attribute__ ((unused)))\n+{\n+  int err;\n+  pthread_attr_t attr;\n+  struct args *a;\n+  pthread_t tid;\n+\n+  a = (struct args *) malloc (sizeof *a);\n+  if (a == NULL)\n+    die (\"malloc\", errno);\n+  a->argc = argc;\n+  a->argv = argv;\n+\n+  err = pthread_attr_init (&attr);\n+  if (err != 0)\n+    die (\"pthread_attr_init\", err);\n+  err = pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);\n+  if (err != 0)\n+    die (\"pthread_attr_setdetachstate\", err);\n+\n+  err = pthread_create (&tid, &attr, gostart, (void *) a);\n+  if (err != 0)\n+    die (\"pthread_create\", err);\n+\n+  err = pthread_attr_destroy (&attr);\n+  if (err != 0)\n+    die (\"pthread_attr_destroy\", err);\n+}\n+\n+/* Start up the Go runtime.  */\n+\n+static void *\n+gostart (void *arg)\n+{\n+  struct args *a = (struct args *) arg;\n+\n+  runtime_isarchive = true;\n+\n+  if (runtime_isstarted)\n+    return NULL;\n+  runtime_isstarted = true;\n+\n+  runtime_check ();\n+  runtime_args (a->argc, (byte **) a->argv);\n+  runtime_osinit ();\n+  runtime_schedinit ();\n+  __go_go (runtime_main, NULL);\n+  runtime_mstart (runtime_m ());\n+  abort ();\n+}\n+\n+/* If something goes wrong during program startup, crash.  There is no\n+   way to report failure and nobody to whom to report it.  */\n+\n+static void\n+die (const char *fn, int err)\n+{\n+  fprintf (stderr, \"%s: %d\\n\", fn, err);\n+  exit (EXIT_FAILURE);\n+}"}, {"sha": "8e9ceab9f3a4531d6a2c2d5e0a1086c5d3cf8b9d", "filename": "libgo/runtime/go-main.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fgo-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fgo-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-main.c?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -35,6 +35,12 @@ extern char **environ;\n int\n main (int argc, char **argv)\n {\n+  runtime_isarchive = false;\n+\n+  if (runtime_isstarted)\n+    return NULL;\n+  runtime_isstarted = true;\n+\n   runtime_check ();\n   runtime_args (argc, (byte **) argv);\n   runtime_osinit ();"}, {"sha": "babad01ea95bcb8168151ac7f1f3a4aa9b39f6d3", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -372,7 +372,6 @@ enum\n Sched\truntime_sched;\n int32\truntime_gomaxprocs;\n uint32\truntime_needextram = 1;\n-bool\truntime_iscgo = true;\n M\truntime_m0;\n G\truntime_g0;\t// idle goroutine for m0\n G*\truntime_lastg;\n@@ -389,6 +388,8 @@ G**\truntime_allg;\n uintptr runtime_allglen;\n static\tuintptr allgcap;\n \n+bool\truntime_isarchive;\n+\n void* runtime_mstart(void*);\n static void runqput(P*, G*);\n static G* runqget(P*);\n@@ -428,6 +429,8 @@ static bool preemptall(void);\n static bool exitsyscallfast(void);\n static void allgadd(G*);\n \n+bool runtime_isstarted;\n+\n // The bootstrap sequence is:\n //\n //\tcall osinit\n@@ -490,6 +493,64 @@ runtime_schedinit(void)\n extern void main_init(void) __asm__ (GOSYM_PREFIX \"__go_init_main\");\n extern void main_main(void) __asm__ (GOSYM_PREFIX \"main.main\");\n \n+// Used to determine the field alignment.\n+\n+struct field_align\n+{\n+  char c;\n+  Hchan *p;\n+};\n+\n+// main_init_done is a signal used by cgocallbackg that initialization\n+// has been completed.  It is made before _cgo_notify_runtime_init_done,\n+// so all cgo calls can rely on it existing.  When main_init is\n+// complete, it is closed, meaning cgocallbackg can reliably receive\n+// from it.\n+Hchan *runtime_main_init_done;\n+\n+// The chan bool type, for runtime_main_init_done.\n+\n+extern const struct __go_type_descriptor bool_type_descriptor\n+  __asm__ (GOSYM_PREFIX \"__go_tdn_bool\");\n+\n+static struct __go_channel_type chan_bool_type_descriptor =\n+  {\n+    /* __common */\n+    {\n+      /* __code */\n+      GO_CHAN,\n+      /* __align */\n+      __alignof (Hchan *),\n+      /* __field_align */\n+      offsetof (struct field_align, p) - 1,\n+      /* __size */\n+      sizeof (Hchan *),\n+      /* __hash */\n+      0, /* This value doesn't matter.  */\n+      /* __hashfn */\n+      __go_type_hash_error,\n+      /* __equalfn */\n+      __go_type_equal_error,\n+      /* __gc */\n+      NULL, /* This value doesn't matter */\n+      /* __reflection */\n+      NULL, /* This value doesn't matter */\n+      /* __uncommon */\n+      NULL,\n+      /* __pointer_to_this */\n+      NULL,\n+      /* __zero */\n+      NULL /* This value doesn't matter */\n+    },\n+    /* __element_type */\n+    &bool_type_descriptor,\n+    /* __dir */\n+    CHANNEL_BOTH_DIR\n+  };\n+\n+extern Hchan *__go_new_channel (ChanType *, uintptr);\n+extern void closechan(Hchan *) __asm__ (GOSYM_PREFIX \"runtime.closechan\");\n+\n static void\n initDone(void *arg __attribute__ ((unused))) {\n \truntime_unlockOSThread();\n@@ -535,8 +596,15 @@ runtime_main(void* dummy __attribute__((unused)))\n \tif(m != &runtime_m0)\n \t\truntime_throw(\"runtime_main not on m0\");\n \t__go_go(runtime_MHeap_Scavenger, nil);\n+\n+\truntime_main_init_done = __go_new_channel(&chan_bool_type_descriptor, 0);\n+\n+\t_cgo_notify_runtime_init_done();\n+\n \tmain_init();\n \n+\tclosechan(runtime_main_init_done);\n+\n \tif(g->defer != &d || d.__pfn != initDone)\n \t\truntime_throw(\"runtime: bad defer entry after init\");\n \tg->defer = d.__next;\n@@ -547,6 +615,14 @@ runtime_main(void* dummy __attribute__((unused)))\n \t// roots.\n \tmstats.enablegc = 1;\n \n+\tif(runtime_isarchive) {\n+\t\t// This is not a complete program, but is instead a\n+\t\t// library built using -buildmode=c-archive or\n+\t\t// c-shared.  Now that we are initialized, there is\n+\t\t// nothing further to do.\n+\t\treturn;\n+\t}\n+\n \tmain_main();\n \n \t// Make racy client program work: if panicking on\n@@ -1011,8 +1087,14 @@ runtime_mstart(void* mp)\n \n \t// Install signal handlers; after minit so that minit can\n \t// prepare the thread to be able to handle the signals.\n-\tif(m == &runtime_m0)\n+\tif(m == &runtime_m0) {\n+\t\tif(runtime_iscgo && !runtime_cgoHasExtraM) {\n+\t\t\truntime_cgoHasExtraM = true;\n+\t\t\truntime_newextram();\n+\t\t\truntime_needextram = 0;\n+\t\t}\n \t\truntime_initsig();\n+\t}\n \t\n \tif(m->mstartfn)\n \t\tm->mstartfn();\n@@ -2747,6 +2829,13 @@ checkdead(void)\n \tint32 run, grunning, s;\n \tuintptr i;\n \n+\t// For -buildmode=c-shared or -buildmode=c-archive it's OK if\n+\t// there are no running goroutines.  The calling program is\n+\t// assumed to be running.\n+\tif(runtime_isarchive) {\n+\t\treturn;\n+\t}\n+\n \t// -1 for sysmon\n \trun = runtime_sched.mcount - runtime_sched.nmidle - runtime_sched.nmidlelocked - 1 - countextra();\n \tif(run > 0)\n@@ -3332,6 +3421,7 @@ void\n runtime_proc_scan(struct Workbuf** wbufp, void (*enqueue1)(struct Workbuf**, Obj))\n {\n \tenqueue1(wbufp, (Obj){(byte*)&runtime_sched, sizeof runtime_sched, 0});\n+\tenqueue1(wbufp, (Obj){(byte*)&runtime_main_init_done, sizeof runtime_main_init_done, 0});\n }\n \n // Return whether we are waiting for a GC.  This gc toolchain uses"}, {"sha": "b9264236227a532461281a30b9ecc0c7499067f4", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/081564faed7cc138dfcaa48021cc01a94fd1ba3c/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=081564faed7cc138dfcaa48021cc01a94fd1ba3c", "patch": "@@ -509,6 +509,9 @@ extern\tuint32\truntime_Hchansize;\n extern\tDebugVars\truntime_debug;\n extern\tuintptr\truntime_maxstacksize;\n \n+extern\tbool\truntime_isstarted;\n+extern\tbool\truntime_isarchive;\n+\n /*\n  * common functions and data\n  */\n@@ -845,3 +848,9 @@ struct time_now_ret\n \n struct time_now_ret now() __asm__ (GOSYM_PREFIX \"time.now\")\n   __attribute__ ((no_split_stack));\n+\n+extern void _cgo_wait_runtime_init_done (void);\n+extern void _cgo_notify_runtime_init_done (void);\n+extern _Bool runtime_iscgo;\n+extern _Bool runtime_cgoHasExtraM;\n+extern Hchan *runtime_main_init_done;"}]}