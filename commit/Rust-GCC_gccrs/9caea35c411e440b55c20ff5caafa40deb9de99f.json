{"sha": "9caea35c411e440b55c20ff5caafa40deb9de99f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNhZWEzNWM0MTFlNDQwYjU1YzIwZmY1Y2FhZmE0MGRlYjlkZTk5Zg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2001-11-02T01:11:05Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2001-11-02T01:11:05Z"}, "message": "m68hc11.c: Fix comment formatting.\n\n\t* config/m68hc11/m68hc11.c: Fix comment formatting.\n\t* config/m68hc11/m68hc11.h: Likewise.\n\t* config/m68hc11/m68hc11.md: Likewise.\n\nFrom-SVN: r46706", "tree": {"sha": "f97f4e5f42773eb070c142775a9ad33f69f3aa28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f97f4e5f42773eb070c142775a9ad33f69f3aa28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9caea35c411e440b55c20ff5caafa40deb9de99f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caea35c411e440b55c20ff5caafa40deb9de99f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9caea35c411e440b55c20ff5caafa40deb9de99f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9caea35c411e440b55c20ff5caafa40deb9de99f/comments", "author": null, "committer": null, "parents": [{"sha": "157689c6d3a24540fd59d402e4622991e5ac9c0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/157689c6d3a24540fd59d402e4622991e5ac9c0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/157689c6d3a24540fd59d402e4622991e5ac9c0b"}], "stats": {"total": 162, "additions": 84, "deletions": 78}, "files": [{"sha": "a83e0a4649b24cf12f535e667f0352e7fc9fcefe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9caea35c411e440b55c20ff5caafa40deb9de99f", "patch": "@@ -1,3 +1,9 @@\n+2001-11-01  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/m68hc11/m68hc11.c: Fix comment formatting.\n+\t* config/m68hc11/m68hc11.h: Likewise.\n+\t* config/m68hc11/m68hc11.md: Likewise.\n+\n 2001-11-01  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c-typeck.c (default_conversion): Retain the original expression"}, {"sha": "b60ccc24137607b076609611dac8f808e27ca84d", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=9caea35c411e440b55c20ff5caafa40deb9de99f", "patch": "@@ -79,7 +79,7 @@ static void m68hc11_asm_out_destructor PARAMS ((rtx, int));\n \n rtx m68hc11_soft_tmp_reg;\n \n-/* Must be set to 1 to produce debug messages. */\n+/* Must be set to 1 to produce debug messages.  */\n int debug_m6811 = 0;\n \n extern FILE *asm_out_file;\n@@ -299,7 +299,7 @@ m68hc11_conditional_register_usage ()\n }\n \f\n \n-/* Reload and register operations. */\n+/* Reload and register operations.  */\n \n static const char *const reg_class_names[] = REG_CLASS_NAMES;\n \n@@ -689,7 +689,7 @@ m68hc11_reload_operands (operands)\n \n   mode = GET_MODE (operands[1]);\n \n-  /* Input reload of indirect addressing (MEM (PLUS (REG) (CONST))). */\n+  /* Input reload of indirect addressing (MEM (PLUS (REG) (CONST))).  */\n   if (A_REG_P (operands[0]) && memory_reload_operand (operands[1], mode))\n     {\n       rtx big_offset = XEXP (XEXP (operands[1], 0), 1);\n@@ -771,7 +771,7 @@ m68hc11_reload_operands (operands)\n \t}\n     }\n \n-  /* Use the normal gen_movhi pattern. */\n+  /* Use the normal gen_movhi pattern.  */\n   return 0;\n }\n \n@@ -1201,7 +1201,7 @@ m68hc11_function_arg_pass_by_reference (cum, mode, type, named)\n      int named ATTRIBUTE_UNUSED;\n {\n   return ((type && TREE_CODE (type) == ARRAY_TYPE)\n-\t  /* Consider complex values as aggregates, so care for TCmode. */\n+\t  /* Consider complex values as aggregates, so care for TCmode.  */\n \t  /*|| GET_MODE_SIZE (mode) > 4 SCz, temporary */\n \t  /*|| (type && AGGREGATE_TYPE_P (type))) */ );\n }\n@@ -2005,7 +2005,7 @@ dead_register_here (x, reg)\n       }\n \n   /* Scan forward to see if the register is set in some insns and never\n-     used since then. */\n+     used since then.  */\n   for (p = x /*NEXT_INSN (x) */ ; p; p = NEXT_INSN (p))\n     {\n       rtx body;\n@@ -2029,7 +2029,7 @@ dead_register_here (x, reg)\n \t    return 1;\n \t}\n \n-      /* Register is used (may be in source or in dest). */\n+      /* Register is used (may be in source or in dest).  */\n       if (reg_mentioned_p (reg, p)\n \t  || (x_reg != 0 && GET_MODE (p) == SImode\n \t      && reg_mentioned_p (x_reg, p)))\n@@ -2085,7 +2085,7 @@ asm_print_register (file, regno)\n    't' generate the temporary scratch register.  The operand is\n        ignored.\n    'T' generate the low-part temporary scratch register.  The operand is\n-       ignored.   */\n+       ignored.  */\n \n void\n print_operand (file, op, letter)\n@@ -2781,7 +2781,7 @@ m68hc11_emit_logical (mode, code, operands)\n \t}\n     }\n \n-  /* The logical operation is similar to a copy. */\n+  /* The logical operation is similar to a copy.  */\n   else if (need_copy)\n     {\n       rtx src;\n@@ -3063,7 +3063,7 @@ m68hc11_gen_movhi (insn, operands)\n     }\n   /* Some moves to a hard register are special. Not all of them\n      are really supported and we have to use a temporary\n-     location to provide them (either the stack of a temp var). */\n+     location to provide them (either the stack of a temp var).  */\n   if (H_REG_P (operands[0]))\n     {\n       switch (REGNO (operands[0]))\n@@ -3093,7 +3093,7 @@ m68hc11_gen_movhi (insn, operands)\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* %t means *ZTMP scratch register. */\n+\t\t  /* %t means *ZTMP scratch register.  */\n \t\t  output_asm_insn (\"sty\\t%t1\", operands);\n \t\t  output_asm_insn (\"ldd\\t%t1\", operands);\n \t\t}\n@@ -3339,7 +3339,7 @@ m68hc11_gen_movqi (insn, operands)\n {\n   /* Move a register or memory to the same location.\n      This is possible because such insn can appear\n-     in a non-optimizing mode. */\n+     in a non-optimizing mode.  */\n   if (operands[0] == operands[1] || rtx_equal_p (operands[0], operands[1]))\n     {\n       cc_status = cc_prev_status;\n@@ -3811,7 +3811,7 @@ m68hc11_notice_keep_cc (reg)\n \n \f\n \n-/* Machine Specific Reorg. */\n+/* Machine Specific Reorg.  */\n \n /* Z register replacement:\n \n@@ -3884,7 +3884,7 @@ int z_replacement_completed = 0;\n /* Analyze the insn to find out which replacement register to use and\n    the boundaries of the replacement.\n    Returns 0 if we reached the last insn to be replaced, 1 if we can\n-   continue replacement in next insns. */\n+   continue replacement in next insns.  */\n \n static int\n m68hc11_check_z_replacement (insn, info)\n@@ -4672,7 +4672,7 @@ m68hc11_z_replacement (insn)\n \t\tfatal_insn (\"Cannot do z-register replacement\", insn);\n \t    }\n \n-\t  /* Likewise for (REG:QI Z). */\n+\t  /* Likewise for (REG:QI Z).  */\n \t  if (reg_mentioned_p (z_reg, insn))\n \t    {\n \t      if (replace_reg_qi == NULL_RTX)\n@@ -4905,7 +4905,7 @@ m68hc11_reorg (first)\n \n /* Cost functions.  */\n \n-/* Cost of moving memory. */\n+/* Cost of moving memory.  */\n int\n m68hc11_memory_move_cost (mode, class, in)\n      enum machine_mode mode;\n@@ -4962,7 +4962,7 @@ m68hc11_address_cost (addr)\n   switch (GET_CODE (addr))\n     {\n     case REG:\n-      /* Make the cost of hard registers and specially SP, FP small. */\n+      /* Make the cost of hard registers and specially SP, FP small.  */\n       if (REGNO (addr) < FIRST_PSEUDO_REGISTER)\n \tcost = 0;\n       else\n@@ -5205,7 +5205,7 @@ m68hc11_rtx_costs (x, code, outer_code)\n \f\n \n /* print_options - called at the start of the code generation for a\n-   module. */\n+   module.  */\n \n extern char *asm_file_name;\n "}, {"sha": "211a65fc1a475e6a4769a9690a668805541d85f8", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=9caea35c411e440b55c20ff5caafa40deb9de99f", "patch": "@@ -79,7 +79,7 @@ Boston, MA 02111-1307, USA.\n #define inhibit_libc\n \n /* Forward type declaration for prototypes definitions.\n-   rtx_ptr is equivalent to rtx. Can't use the same name. */\n+   rtx_ptr is equivalent to rtx. Can't use the same name.  */\n struct rtx_def;\n typedef struct rtx_def *rtx_ptr;\n \n@@ -88,7 +88,7 @@ typedef union tree_node *tree_ptr;\n \n /* We can't declare enum machine_mode forward nor include 'machmode.h' here.\n    Prototypes defined here will use an int instead. It's better than no\n-   prototype at all. */\n+   prototype at all.  */\n typedef int enum_machine_mode;\n \n /*****************************************************************************\n@@ -235,7 +235,7 @@ extern const struct processor_costs *m68hc11_cost;\n #define BYTES_BIG_ENDIAN \t1\n \n /* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields. */\n+   in instructions that operate on numbered bit-fields.  */\n #define BITS_BIG_ENDIAN         0\n \n /* Define this if most significant word of a multiword number is numbered.  */\n@@ -282,7 +282,7 @@ extern const struct processor_costs *m68hc11_cost;\n #define FUNCTION_BOUNDARY\t8\n \n /* Biggest alignment that any data type can require on this machine,\n-   in bits. */\n+   in bits.  */\n #define BIGGEST_ALIGNMENT\t8\n \n /* Alignment of field after `int : 0' in a structure.  */\n@@ -302,7 +302,7 @@ extern const struct processor_costs *m68hc11_cost;\n    appropriate sizes.  */\n #define MAX_FIXED_MODE_SIZE\t64\n \n-/* Floats are checked in a generic way. */\n+/* Floats are checked in a generic way.  */\n /* #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) */\n \n \n@@ -393,7 +393,7 @@ extern const struct processor_costs *m68hc11_cost;\n    (see Z register replacement notes in m68hc11.c).  */\n #define SOFT_Z_REGNUM            11\n \n-/* The soft-register which is used to save either X or Y. */\n+/* The soft-register which is used to save either X or Y.  */\n #define SOFT_SAVED_XY_REGNUM     12\n \n /* A fake clobber register for 68HC12 patterns.  */\n@@ -436,22 +436,22 @@ SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n \"*_.d25\", \"*_.d26\", \"*_.d27\", \"*_.d28\", \\\n \"*_.d29\", \"*_.d30\", \"*_.d31\", \"*_.d32\"\n \n-/* First available soft-register for GCC. */\n+/* First available soft-register for GCC.  */\n #define SOFT_REG_FIRST          (SOFT_SAVED_XY_REGNUM+2)\n \n-/* Last available soft-register for GCC. */\n+/* Last available soft-register for GCC.  */\n #define SOFT_REG_LAST           (SOFT_REG_FIRST+MAX_SOFT_REG_COUNT)\n #define SOFT_FP_REGNUM\t\t(SOFT_REG_LAST)\n #define SOFT_AP_REGNUM\t\t(SOFT_FP_REGNUM+1)\n \n /* Number of actual hardware registers. The hardware registers are assigned\n    numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. \n    All registers that the compiler knows about must be given numbers, even\n-   those that are not normally considered general registers. */\n+   those that are not normally considered general registers.  */\n #define FIRST_PSEUDO_REGISTER\t(SOFT_REG_LAST+2)\n \n /* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator. */\n+   for the register allocator.  */\n #define FIXED_REGISTERS \\\n   {0, 0, 0, 1, 1, 1, 1, 1,   0, 1,  1,   1,1, 1, SOFT_REG_FIXED, 1, 1}\n /* X, D, Y, SP,PC,A, B, CCR, Z, FP,ZTMP,ZR,XYR, FK, D1 - D32, SOFT-FP, AP */\n@@ -466,7 +466,7 @@ SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n /* Define this macro to change register usage conditional on target flags.\n \n    The soft-registers are disabled or enabled according to the\n-  -msoft-reg-count=<n> option. */\n+  -msoft-reg-count=<n> option.  */\n \n \n #define CONDITIONAL_REGISTER_USAGE (m68hc11_conditional_register_usage ())\n@@ -540,10 +540,10 @@ enum reg_class\n   X_REGS,\t\t\t/* 16-bit X register */\n   Y_REGS,\t\t\t/* 16-bit Y register */\n   SP_REGS,\t\t\t/* 16 bit stack pointer */\n-  DA_REGS,\t\t\t/* 8-bit A reg. */\n-  DB_REGS,\t\t\t/* 8-bit B reg. */\n+  DA_REGS,\t\t\t/* 8-bit A reg.  */\n+  DB_REGS,\t\t\t/* 8-bit B reg.  */\n   Z_REGS,\t\t\t/* 16-bit fake Z register */\n-  D8_REGS,\t\t\t/* 8-bit A or B reg. */\n+  D8_REGS,\t\t\t/* 8-bit A or B reg.  */\n   Q_REGS,\t\t\t/* 8-bit (byte (QI)) data (A, B or D) */\n   D_OR_X_REGS,\t\t\t/* D or X register */\n   D_OR_Y_REGS,\t\t\t/* D or Y register */\n@@ -574,12 +574,12 @@ enum reg_class\n   LIM_REG_CLASSES\n };\n \n-/* alias GENERAL_REGS to G_REGS. */\n+/* alias GENERAL_REGS to G_REGS.  */\n #define GENERAL_REGS\tG_REGS\n \n #define N_REG_CLASSES\t(int) LIM_REG_CLASSES\n \n-/* Give names of register classes as strings for dump file.   */\n+/* Give names of register classes as strings for dump file.  */\n #define REG_CLASS_NAMES \\\n { \"NO_REGS\",                                    \\\n       \"D_REGS\",                                 \\\n@@ -899,7 +899,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n   \n    This space can either be allocated by the caller or be a part of the\n    machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'\n-   says which. */\n+   says which.  */\n /* #define REG_PARM_STACK_SPACE(FNDECL)\t2 */\n \n /* Define this macro if REG_PARM_STACK_SPACE is defined but stack\n@@ -934,7 +934,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n \n    We have two registers that are eliminated on the 6811. The psuedo arg\n    pointer and pseudo frame pointer registers can always be eliminated;\n-   they are replaced with either the stack or the real frame pointer. */\n+   they are replaced with either the stack or the real frame pointer.  */\n \n #define ELIMINABLE_REGS\t\t\t\t\t\\\n {{ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\\\n@@ -945,7 +945,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms may be\n    accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c. */\n+   This is computed in `reload', in reload1.c.  */\n #define FRAME_POINTER_REQUIRED\t0\n \n /* Given FROM and TO register numbers, say whether this elimination is allowed.\n@@ -973,7 +973,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n \n /* If we generate an insn to push BYTES bytes, this says how many the\n    stack pointer really advances by. No rounding or alignment needed\n-   for MC6811. */\n+   for MC6811.  */\n #define PUSH_ROUNDING(BYTES)\t(BYTES)\n \n /* Value is 1 if returning from a function call automatically pops the\n@@ -982,7 +982,7 @@ extern enum reg_class m68hc11_tmp_regs_class;\n    an identifier node for the subroutine name.\n   \n    The standard MC6811 call, with arg count word, includes popping the\n-   args as part of the call template. */\n+   args as part of the call template.  */\n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)\t0\n \n /* Nonzero if type TYPE should be returned in memory.\n@@ -1014,7 +1014,7 @@ typedef struct m68hc11_args\n    The pointer is passed in whatever way is appropriate for passing a pointer\n    to that type.\n  \n-   64-bit numbers are passed by reference. */\n+   64-bit numbers are passed by reference.  */\n #define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED) \\\n     m68hc11_function_arg_pass_by_reference (& (CUM), (MODE), (TYPE), (NAMED))\n \n@@ -1036,12 +1036,12 @@ typedef struct m68hc11_args\n    does not make a copy.  Instead, it passes a pointer to the \"live\"\n    value.  The called function must not modify this value.  If it can\n    be determined that the value won't be modified, it need not make a\n-   copy; otherwise a copy must be made. */\n+   copy; otherwise a copy must be made.  */\n #define FUNCTION_ARG_CALLEE_COPIES(CUM, MODE, TYPE, NAMED)\t\t\\\n     ((NAMED) && FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n-   function whose data type is FNTYPE. For a library call, FNTYPE is 0. */\n+   function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */\n #define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT) \\\n     (m68hc11_init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n \n@@ -1133,7 +1133,7 @@ typedef struct m68hc11_args\n     asm_fprintf (FILE, \"\\tldy LP%d\\n\\tjsr mcount\\n\", (LABELNO))\n \n /* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done. */\n+   basic block profiling info, if that has not already been done.  */\n #define FUNCTION_BLOCK_PROFILER(FILE, BLOCK_OR_LABEL)\t\\\n     m68hc11_function_block_profiler(FILE, BLOCK_OR_LABEL)\n \n@@ -1324,7 +1324,7 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n \tindexed\t\t\tN,X\n --------------------------------------------------------------*/\n \n-/* The range of index that is allowed by indirect addressing. */\n+/* The range of index that is allowed by indirect addressing.  */\n \n #define VALID_MIN_OFFSET m68hc11_min_offset\n #define VALID_MAX_OFFSET m68hc11_max_offset\n@@ -1345,7 +1345,7 @@ extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n   (((GET_CODE (X) == PRE_DEC) || (GET_CODE (X) == POST_INC)) \\\n \t&& SP_REG_P (XEXP (X, 0)))\n \n-/* Go to ADDR if X is a valid address. */\n+/* Go to ADDR if X is a valid address.  */\n #ifndef REG_OK_STRICT\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n { \\\n@@ -1730,7 +1730,7 @@ do { long l;\t\t\t\t\t\t\\\n #define PRINT_OPERAND(FILE, X, CODE) \\\n   print_operand (FILE, X, CODE)\n \n-/* Print a memory operand whose address is X, on file FILE. */\n+/* Print a memory operand whose address is X, on file FILE.  */\n #define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n   print_operand_address (FILE, ADDR)\n \n@@ -1744,12 +1744,12 @@ do { long l;\t\t\t\t\t\t\\\n #undef ASM_OUTPUT_REG_PUSH\n #undef ASM_OUTPUT_REG_POP\n \n-/* This is how to output an element of a case-vector that is relative. */\n+/* This is how to output an element of a case-vector that is relative.  */\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n   asm_fprintf (FILE, \"\\t%s\\tL%d-L%d\\n\", ASM_SHORT, VALUE, REL)\n \n-/* This is how to output an element of a case-vector that is absolute. */\n+/* This is how to output an element of a case-vector that is absolute.  */\n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n   asm_fprintf (FILE, \"\\t%s\\t.L%d\\n\", ASM_SHORT, VALUE)\n \n@@ -1765,9 +1765,9 @@ do { long l;\t\t\t\t\t\t\\\n /* Assembler Commands for Exception Regions.  */\n \n /* Default values provided by GCC should be ok. Assumming that DWARF-2\n-   frame unwind info is ok for this platform. */\n+   frame unwind info is ok for this platform.  */\n \n-/* How to renumber registers for dbx and gdb. */\n+/* How to renumber registers for dbx and gdb.  */\n #define DBX_REGISTER_NUMBER(REGNO) \\\n  ((REGNO))\n \n@@ -1778,7 +1778,7 @@ do { long l;\t\t\t\t\t\t\\\n    an empty string, or any arbitrary string (such as \".\", \".L%\", etc)\n    without having to make any other changes to account for the specific\n    definition.  Note it is a string literal, not interpreted by printf\n-   and friends. */\n+   and friends.  */\n #define LOCAL_LABEL_PREFIX \".\"\n \n /* The prefix for immediate operands.  */\n@@ -1812,7 +1812,7 @@ do { long l;\t\t\t\t\t\t\\\n    for the index in the tablejump instruction.  */\n #define CASE_VECTOR_MODE\tPmode\n \n-/* Specify the tree operation to be used to convert reals to integers. */\n+/* Specify the tree operation to be used to convert reals to integers.  */\n #define IMPLICIT_FIX_EXPR\tFIX_ROUND_EXPR\n \n /* This flag, if defined, says the same insns that convert to a signed fixnum"}, {"sha": "c1b80f53fb0b9054bfc5f30f2343abc28f07a9dd", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9caea35c411e440b55c20ff5caafa40deb9de99f/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=9caea35c411e440b55c20ff5caafa40deb9de99f", "patch": "@@ -1092,15 +1092,15 @@\n   rtx push = m68hc11_gen_lowpart (HImode, low);\n   rtx src  = operands[1];\n \n-   /* Source operand must be in a hard register. */\n+   /* Source operand must be in a hard register.  */\n    if (!H_REG_P (src))\n      {\n        src = gen_rtx (REG, QImode, REGNO (operands[2]));\n        emit_move_insn (src, operands[1]);\n      }\n \n    /* Source is in D, we can push B then one word of 0 and we do\n-      a correction on the stack pointer. */\n+      a correction on the stack pointer.  */\n    if (D_REG_P (src))\n      {\n        emit_move_insn (m68hc11_gen_lowpart (QImode, push), src);\n@@ -1150,7 +1150,7 @@\n   rtx low2 = m68hc11_gen_lowpart (HImode, low);\n   rtx src  = operands[1];\n \n-   /* Source operand must be in a hard register. */\n+   /* Source operand must be in a hard register.  */\n    if (!H_REG_P (src))\n      {\n        src = gen_rtx (REG, QImode, REGNO (operands[2]));\n@@ -1432,7 +1432,7 @@\n   else if (X_REG_P (operands[0]))\n     {\n       /* X can be used as an indexed addressing in the source.\n-         Get the value before clearing it. */\n+         Get the value before clearing it.  */\n       if (reg_mentioned_p (ix_reg, operands[1]))\n         {\n           output_asm_insn (\\\"ldab\\\\t%b1\\\", operands);\n@@ -1599,7 +1599,7 @@\n   else\n     {\n       /* X can be used as a indexed addressing in the source.\n-         Get the value before clearing it. */\n+         Get the value before clearing it.  */\n       x_reg_used = reg_mentioned_p (ix_reg, operands[1]);\n       if (x_reg_used)\n         {\n@@ -1812,7 +1812,7 @@\n     }\n   ops[2] = gen_label_rtx ();\n \n-  /* ldx preserves the carry, propagate it by incrementing X directly. */\n+  /* ldx preserves the carry, propagate it by incrementing X directly.  */\n   output_asm_insn (\\\"addd\\\\t%0\\\", ops);\n   if (!X_REG_P (operands[2]))\n     output_asm_insn (\\\"ldx\\\\t%1\\\", ops);\n@@ -1886,7 +1886,7 @@\n       output_asm_insn (\\\"clra\\\", ops);\n     }\n \n-  /* ldx preserves the carry, propagate it by incrementing X directly. */\n+  /* ldx preserves the carry, propagate it by incrementing X directly.  */\n   output_asm_insn (\\\"addb\\\\t%b0\\\", ops);\n   output_asm_insn (\\\"adca\\\\t%h1\\\", ops);\n   if (!X_REG_P (operands[2]))\n@@ -2200,7 +2200,7 @@\n     }\n \n   /* For X and Y increment, the flags are not complete. Only the Z flag\n-     is updated. For SP increment, flags are not changed. */\n+     is updated. For SP increment, flags are not changed.  */\n   if (SP_REG_P (operands[0]))\n     {\n       cc_status = cc_prev_status; \n@@ -2328,7 +2328,7 @@\n   if (GET_CODE (operands[2]) != CONST_INT)\n     {\n       /* Adding to an address register or with another/same register\n-         is not possible. This must be replaced. */\n+         is not possible. This must be replaced.  */\n       if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n         return \\\"#\\\";\n \n@@ -2679,20 +2679,20 @@\n       output_asm_insn (\\\"xgdx\\\", operands);\n \n       /* The status flags correspond to the addd. xgdx/y and tx/ys do not\n-         modify the flags. */\n+         modify the flags.  */\n       output_asm_insn (\\\"txs\\\", operands);\n       return \\\"xgdx\\\";\n     }\n \n   /* Need to transfer to SP to X,Y and then to D register.\n-     Register X,Y is lost, this is specified by the (clobber) statement. */\n+     Register X,Y is lost, this is specified by the (clobber) statement.  */\n   output_asm_insn (\\\"ts%3\\\", operands);\n   output_asm_insn (\\\"xgd%3\\\", operands);\n   output_asm_insn (\\\"subd\\\\t%2\\\", operands);\n   output_asm_insn (\\\"xgd%3\\\", operands);\n \n    /* The status flags correspond to the addd. xgdx/y and tx/ys do not\n-      modify the flags. */\n+      modify the flags.  */\n   return \\\"t%3s\\\";\n }\")\n \n@@ -2705,7 +2705,7 @@\n   \"*\n {\n   /* Adding to an address register or with another/same register\n-     is not possible.  This must be replaced. */\n+     is not possible.  This must be replaced.  */\n   if (A_REG_P (operands[0]) || H_REG_P (operands[2]))\n     return \\\"#\\\";\n \n@@ -3640,7 +3640,7 @@\n \t     (match_operand:HI 2 \"general_operand\" \"dAuim\")]))]\n   \"z_replacement_completed == 2\n    /* If we are adding a small constant to X or Y, it's\n-     better to use one or several inx/iny instructions. */\n+     better to use one or several inx/iny instructions.  */\n    && !(GET_CODE (operands[3]) == PLUS \n         && ((TARGET_M6812 \n \t     && (immediate_operand (operands[2], HImode)\n@@ -3656,7 +3656,7 @@\n    (parallel [(set (reg:HI D_REGNUM) (match_dup 0))\n               (set (match_dup 0) (reg:HI D_REGNUM))])]\n   \"\n-   /* Save the operand2 in a temporary location and use it. */\n+   /* Save the operand2 in a temporary location and use it.  */\n    if ((H_REG_P (operands[2])\n         || reg_mentioned_p  (operands[0], operands[2]))\n        && !(SP_REG_P (operands[2]) && GET_CODE (operands[3]) == PLUS))\n@@ -3690,7 +3690,7 @@\n \t     (match_operand:HI 2 \"general_operand\" \"dAuim\")]))]\n   \"z_replacement_completed == 2\n    /* If we are adding a small constant to X or Y, it's\n-     better to use one or several inx/iny instructions. */\n+     better to use one or several inx/iny instructions.  */\n    && !(GET_CODE (operands[3]) == PLUS \n         && ((TARGET_M6812 \n \t    && (immediate_operand (operands[2], HImode)\n@@ -3764,17 +3764,17 @@\n        && !rtx_equal_p (operands[0], operands[1]))\n       || reg_mentioned_p (operands[0], operands[1]))\n     {\n-      /* Move to the destination register, before the xgdx. */\n+      /* Move to the destination register, before the xgdx.  */\n       operands[4] = gen_rtx (REG, GET_MODE (operands[1]), \n \t\t\t     REGNO (operands[0]));\n       operands[5] = operands[1];\n \n-      /* Apply the operation on D. */\n+      /* Apply the operation on D.  */\n       operands[3] = gen_rtx (REG, GET_MODE (operands[1]), HARD_D_REGNUM);\n     }\n   else\n     {\n-      /* Generate a copy to same register (nop). */\n+      /* Generate a copy to same register (nop).  */\n       operands[4] = operands[5] = operands[0];\n       operands[3] = operands[1];\n     }\n@@ -3796,7 +3796,7 @@\n \t     (match_operand:QI 2 \"general_operand\" \"dxyuim\")]))]\n   \"z_replacement_completed == 2\n    /* Reject a (plus:QI (reg:QI X) (const_int 1|-1)) because the\n-      incqi pattern generates a better code. */\n+      incqi pattern generates a better code.  */\n    && !(GET_CODE (operands[3]) == PLUS\n         && GET_CODE (operands[2]) == CONST_INT\n         && (INTVAL (operands[2]) == 1 || INTVAL (operands[2]) == -1))\"\n@@ -3812,7 +3812,7 @@\n       register appears in the source, we have to save the operand[2]\n       value in a temporary location and then use that temp.\n       Otherwise, it's ok and we generate a (set (D) (D)) that\n-      will result in a nop. */\n+      will result in a nop.  */\n    if (H_REG_P (operands[2]))\n      {\n        operands[5] = gen_rtx (REG, HImode, SOFT_TMP_REGNUM);\n@@ -3892,11 +3892,11 @@\n        && !rtx_equal_p (operands[0], operands[1]))\n       || reg_mentioned_p (operands[0], operands[1]))\n     {\n-      /* Move to the destination register, before the xgdx. */\n+      /* Move to the destination register, before the xgdx.  */\n       operands[4] = operands[0];\n       operands[5] = operands[1];\n \n-      /* Apply the operation on D. */\n+      /* Apply the operation on D.  */\n       operands[6] = gen_rtx (REG, QImode, HARD_D_REGNUM);\n     }\n   else\n@@ -4009,7 +4009,7 @@\n   \"\n {\n   /* The result pattern only works for D register.\n-     Generate 2 one_cmplhi2 instructions. */\n+     Generate 2 one_cmplhi2 instructions.  */\n   if (!D_REG_P (operands[0]))\n     {\n       rtx ops[2];\n@@ -4614,7 +4614,7 @@\n       output_asm_insn (\\\"clrb\\\", operands);\n       output_asm_insn (\\\"rola\\\", operands);\n \n-\t/* Clear A without clearing the carry flag. */\n+\t/* Clear A without clearing the carry flag.  */\n       output_asm_insn (\\\"tba\\\", operands);\n       output_asm_insn (\\\"bcc\\\\t%l0\\\", ops);\n       output_asm_insn (\\\"coma\\\", operands);\n@@ -4645,7 +4645,7 @@\n \t  output_asm_insn (\\\"asrb\\\", operands);\n \t  val--;\n         }\n-\t/* Status is ok. */\n+\t/* Status is ok.  */\n       return \\\"\\\";\n     }\n   if (val == 7)"}]}