{"sha": "f4a233434d41848d9ae3bcb0f9518dfd986143ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRhMjMzNDM0ZDQxODQ4ZDlhZTNiY2IwZjk1MThkZmQ5ODYxNDNiYQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-01-08T00:29:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-01-08T00:29:08Z"}, "message": "exception.cc (__eh_alloc, __eh_free): New fns.\n\n\t* exception.cc (__eh_alloc, __eh_free): New fns.\n\t(__cp_push_exception, __cp_pop_exception): Use them.\n\t(__uncatch_exception): Call terminate here if no exception.\n\t* except.c (build_terminate_handler): New fn.\n\t(expand_start_catch_block): Use it.\n\t(expand_exception_blocks): Likewise.\n\t(alloc_eh_object): New fn.\n\t(expand_throw): Use it.  Protect exception init with terminate.\n\t* typeck.c (build_modify_expr): Remove code that ignores trivial\n\tmethods.\n\nFrom-SVN: r17309", "tree": {"sha": "42ae0005def9da50e4d8303d7729478f43847f8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42ae0005def9da50e4d8303d7729478f43847f8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4a233434d41848d9ae3bcb0f9518dfd986143ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a233434d41848d9ae3bcb0f9518dfd986143ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4a233434d41848d9ae3bcb0f9518dfd986143ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4a233434d41848d9ae3bcb0f9518dfd986143ba/comments", "author": null, "committer": null, "parents": [{"sha": "b450b6999c574123b3abb03979882ca35b4caa3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b450b6999c574123b3abb03979882ca35b4caa3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b450b6999c574123b3abb03979882ca35b4caa3a"}], "stats": {"total": 196, "additions": 150, "deletions": 46}, "files": [{"sha": "02f3a8762c1bdd705ecc38ed301b66dbc5838b5b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f4a233434d41848d9ae3bcb0f9518dfd986143ba", "patch": "@@ -1,3 +1,16 @@\n+Wed Jan  7 23:47:13 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* exception.cc (__eh_alloc, __eh_free): New fns.\n+\t(__cp_push_exception, __cp_pop_exception): Use them.\n+\t(__uncatch_exception): Call terminate here if no exception.\n+\t* except.c (build_terminate_handler): New fn.\n+\t(expand_start_catch_block): Use it.\n+\t(expand_exception_blocks): Likewise.\n+\t(alloc_eh_object): New fn.\n+\t(expand_throw): Use it.  Protect exception init with terminate.\n+\t* typeck.c (build_modify_expr): Remove code that ignores trivial \n+\tmethods.\n+\n Mon Dec 22 11:36:27 1997  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n  \n \t* call.c (add_builtin_candidate): Add default case in enumeration"}, {"sha": "36c64e12d65fc668e6aa87e5752838508e801cc4", "filename": "gcc/cp/except.c", "status": "modified", "additions": 102, "deletions": 14, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=f4a233434d41848d9ae3bcb0f9518dfd986143ba", "patch": "@@ -477,6 +477,18 @@ push_eh_cleanup ()\n   resume_momentary (yes);\n }\n \n+/* Build up a call to terminate on the function obstack, for use as an\n+   exception handler.  */\n+\n+tree\n+build_terminate_handler ()\n+{\n+  int yes = suspend_momentary ();\n+  tree term = build_function_call (Terminate, NULL_TREE);\n+  resume_momentary (yes);\n+  return term;\n+}\n+\n /* call this to start a catch block. Typename is the typename, and identifier\n    is the variable to place the object in or NULL if the variable doesn't\n    matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n@@ -582,15 +594,12 @@ expand_start_catch_block (declspecs, declarator)\n          must call terminate.  See eh23.C.  */\n       if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n \t{\n-\t  int yes = suspend_momentary ();\n-\t  tree term = build_function_call (Terminate, NULL_TREE);\n-\t  resume_momentary (yes);\n-\n \t  /* Generate the copy constructor call directly so we can wrap it.\n \t     See also expand_default_init.  */\n \t  init = ocp_convert (TREE_TYPE (decl), init,\n \t\t\t      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n-\t  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init, term);\n+\t  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n+\t\t\tbuild_terminate_handler ());\n \t}\n \n       /* Let `cp_finish_decl' know that this initializer is ok.  */\n@@ -854,7 +863,7 @@ expand_exception_blocks ()\n       catch_clauses = NULL_RTX;\n \n       if (exceptions_via_longjmp == 0)\n-\texpand_eh_region_end (build_function_call (Terminate, NULL_TREE));\n+\texpand_eh_region_end (build_terminate_handler ());\n \n       expand_leftover_cleanups ();\n \n@@ -914,6 +923,41 @@ end_anon_func ()\n   pop_cp_function_context (NULL_TREE);\n }\n \n+/* Return a pointer to a buffer for an exception object of type TYPE.  */\n+\n+tree\n+alloc_eh_object (type)\n+     tree type;\n+{\n+  tree fn, exp;\n+\n+  fn = get_identifier (\"__eh_alloc\");\n+  if (IDENTIFIER_GLOBAL_VALUE (fn))\n+    fn = IDENTIFIER_GLOBAL_VALUE (fn);\n+  else\n+    {\n+      /* Declare __eh_alloc (size_t), as defined in exception.cc.  */\n+      tree tmp;\n+      push_obstacks_nochange ();\n+      end_temporary_allocation ();\n+      tmp = tree_cons (NULL_TREE, sizetype, void_list_node);\n+      fn = build_lang_decl (FUNCTION_DECL, fn,\n+\t\t\t    build_function_type (ptr_type_node, tmp));\n+      DECL_EXTERNAL (fn) = 1;\n+      TREE_PUBLIC (fn) = 1;\n+      DECL_ARTIFICIAL (fn) = 1;\n+      pushdecl_top_level (fn);\n+      make_function_rtl (fn);\n+      assemble_external (fn);\n+      pop_obstacks ();\n+    }\n+\n+  exp = build_function_call (fn, expr_tree_cons\n+\t\t\t     (NULL_TREE, size_in_bytes (type), NULL_TREE));\n+  exp = build1 (NOP_EXPR, build_pointer_type (type), exp);\n+  return exp;\n+}\n+\n /* Expand a throw statement.  This follows the following\n    algorithm:\n \n@@ -965,17 +1009,61 @@ expand_throw (exp)\n \t}\n       else\n \t{\n-\t  tree object;\n+\t  tree object, ptr;\n+\n+\t  /* OK, this is kind of wacky.  The WP says that we call\n+\t     terminate\n+\n+\t     when the exception handling mechanism, after completing\n+\t     evaluation of the expression to be thrown but before the\n+\t     exception is caught (_except.throw_), calls a user function\n+\t     that exits via an uncaught exception.\n+\n+\t     So we have to protect the actual initialization of the\n+\t     exception object with terminate(), but evaluate the expression\n+\t     first.  We also expand the call to __eh_alloc\n+\t     first.  Since there could be temps in the expression, we need\n+\t     to handle that, too.  */\n \n-\t  /* Make a copy of the thrown object.  WP 15.1.5  */\n-\t  exp = build_new (NULL_TREE, TREE_TYPE (exp),\n-\t\t\t   build_expr_list (NULL_TREE, exp),\n-\t\t\t   0);\n+\t  expand_start_target_temps ();\n+\n+#if 0\n+\t  /* Unfortunately, this doesn't work.  */\n+\t  preexpand_calls (exp);\n+#else\n+\t  /* Store the throw expression into a temp.  This can be less\n+\t     efficient than storing it into the allocated space directly, but\n+\t     oh well.  To do this efficiently we would need to insinuate\n+\t     ourselves into expand_call.  */\n+\t  if (TREE_SIDE_EFFECTS (exp))\n+\t    {\n+\t      tree temp = build (VAR_DECL, TREE_TYPE (exp));\n+\t      DECL_ARTIFICIAL (temp) = 1;\n+\t      layout_decl (temp, 0);\n+\t      DECL_RTL (temp) = assign_temp (TREE_TYPE (exp), 2, 0, 1);\n+\t      expand_expr (build (INIT_EXPR, TREE_TYPE (exp), temp, exp),\n+\t\t\t   NULL_RTX, VOIDmode, 0);\n+\t      expand_decl_cleanup (NULL_TREE, maybe_build_cleanup (temp));\n+\t      exp = temp;\n+\t    }\n+#endif\n+\n+\t  /* Allocate the space for the exception.  */\n+\t  ptr = save_expr (alloc_eh_object (TREE_TYPE (exp)));\n+\t  expand_expr (ptr, const0_rtx, VOIDmode, 0);\n+\n+\t  expand_eh_region_start ();\n+\n+\t  object = build_indirect_ref (ptr, NULL_PTR);\n+\t  exp = build_modify_expr (object, INIT_EXPR, exp);\n \n \t  if (exp == error_mark_node)\n \t    error (\"  in thrown expression\");\n \n-\t  object = build_indirect_ref (exp, NULL_PTR);\n+\t  expand_expr (exp, const0_rtx, VOIDmode, 0);\n+\t  expand_eh_region_end (build_terminate_handler ());\n+\t  expand_end_target_temps ();\n+\n \t  throw_type = build_eh_type (object);\n \n \t  if (TYPE_HAS_DESTRUCTOR (TREE_TYPE (object)))\n@@ -988,6 +1076,8 @@ expand_throw (exp)\n \t      /* Pretend it's a normal function.  */\n \t      cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);\n \t    }\n+\n+\t  exp = ptr;\n \t}\n \n       if (cleanup == NULL_TREE)\n@@ -1021,8 +1111,6 @@ expand_throw (exp)\n \t  pop_obstacks ();\n \t}\n \n-      /* The throw expression is a full-expression.  */\n-      exp = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (exp), exp);\n       e = expr_tree_cons (NULL_TREE, exp, expr_tree_cons\n \t\t\t  (NULL_TREE, throw_type, expr_tree_cons\n \t\t\t   (NULL_TREE, cleanup, NULL_TREE)));"}, {"sha": "0276ed7dad8b1b38d607e5a6fe3bdadda2a4b940", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=f4a233434d41848d9ae3bcb0f9518dfd986143ba", "patch": "@@ -29,6 +29,7 @@\n \n #include \"typeinfo\"\n #include \"exception\"\n+#include <stddef.h>\n \n /* Define terminate, unexpected, set_terminate, set_unexpected as\n    well as the default terminate func and default unexpected func.  */\n@@ -108,13 +109,37 @@ __cp_exception_info (void)\n   return *__get_eh_info ();\n }\n \n+/* Allocate a buffer for a cp_eh_info and an exception object of size SIZE,\n+   and return a pointer to the beginning of the object's space.  */\n+\n+extern \"C\" void * malloc (size_t);\n+extern \"C\" void *\n+__eh_alloc (size_t size)\n+{\n+  void *p = malloc (size);\n+  if (p == 0)\n+    terminate ();\n+  return p;\n+}\n+\n+/* Free the memory for an cp_eh_info and associated exception, given\n+   a pointer to the cp_eh_info.  */\n+\n+extern \"C\" void free (void *);\n+extern \"C\" void\n+__eh_free (void *p)\n+{\n+  free (p);\n+}\n+\n /* Compiler hook to push a new exception onto the stack.\n    Used by expand_throw().  */\n \n extern \"C\" void\n __cp_push_exception (void *value, void *type, void (*cleanup)(void *, int))\n {\n-  cp_eh_info *p = new cp_eh_info;\n+  cp_eh_info *p = (cp_eh_info *) __eh_alloc (sizeof (cp_eh_info));\n+\n   p->value = value;\n   p->type = type;\n   p->cleanup = cleanup;\n@@ -155,23 +180,22 @@ __cp_pop_exception (cp_eh_info *p)\n   *q = p->next;\n \n   if (p->cleanup)\n-    /* 3 is a magic value for destructors; see build_delete().  */\n-    p->cleanup (p->value, 3);\n-  else if (__is_pointer (p->type))\n-    /* do nothing; pointers are passed directly in p->value.  */;\n-  else\n-    delete p->value;\n+    /* 2 is a magic value for destructors; see build_delete().  */\n+    p->cleanup (p->value, 2);\n \n-  delete p;\n+  if (! __is_pointer (p->type))\n+    __eh_free (p->value);\n+\n+  __eh_free (p);\n }\n \n extern \"C\" void\n __uncatch_exception (void)\n {\n   cp_eh_info *p = __cp_exception_info ();\n-  if (p)\n-    p->caught = false;\n-  /* otherwise __throw will call terminate(); don't crash here.  */\n+  if (p == 0)\n+    terminate ();\n+  p->caught = false;\n }\n \n /* As per [except.unexpected]:"}, {"sha": "993835556623783be03d895c7fc227ba2dcec3fe", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4a233434d41848d9ae3bcb0f9518dfd986143ba/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f4a233434d41848d9ae3bcb0f9518dfd986143ba", "patch": "@@ -5844,14 +5844,6 @@ build_modify_expr (lhs, modifycode, rhs)\n     {\n       if (! IS_AGGR_TYPE (lhstype))\n \t/* Do the default thing */;\n-      else if (! TYPE_HAS_CONSTRUCTOR (lhstype))\n-\t{\n-\t  cp_error (\"`%T' has no constructors\", lhstype);\n-\t  return error_mark_node;\n-\t}\n-      else if (TYPE_HAS_TRIVIAL_INIT_REF (lhstype)\n-\t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n-\t/* Do the default thing */;\n       else\n \t{\n \t  result = build_method_call (lhs, ctor_identifier,\n@@ -5867,19 +5859,6 @@ build_modify_expr (lhs, modifycode, rhs)\n       /* `operator=' is not an inheritable operator.  */\n       if (! IS_AGGR_TYPE (lhstype))\n \t/* Do the default thing */;\n-      else if (! TYPE_HAS_ASSIGNMENT (lhstype))\n-\t{\n-\t  cp_error (\"`%T' does not define operator=\", lhstype);\n-\t  return error_mark_node;\n-\t}\n-      else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (lhstype)\n-\t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n-\t{\n-\t  build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t  lhs, rhs, make_node (NOP_EXPR));\n-\n-\t  /* Do the default thing */;\n-\t}\n       else\n \t{\n \t  result = build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,"}]}