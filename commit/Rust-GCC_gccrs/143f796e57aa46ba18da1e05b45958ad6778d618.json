{"sha": "143f796e57aa46ba18da1e05b45958ad6778d618", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQzZjc5NmU1N2FhNDZiYTE4ZGExZTA1YjQ1OTU4YWQ2Nzc4ZDYxOA==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2007-01-10T16:55:10Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2007-01-10T16:55:10Z"}, "message": "URL.java: Removed.\n\n2007-01-10  Gary Benson  <gbenson@redhat.com>\n\n\t* java/net/URL.java: Removed.\n\t* sources.am, Makefile.in: Rebuilt.\n\nFrom-SVN: r120644", "tree": {"sha": "67d013bfddb91d7bb3146ea141537a6c98b27432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67d013bfddb91d7bb3146ea141537a6c98b27432"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/143f796e57aa46ba18da1e05b45958ad6778d618", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143f796e57aa46ba18da1e05b45958ad6778d618", "html_url": "https://github.com/Rust-GCC/gccrs/commit/143f796e57aa46ba18da1e05b45958ad6778d618", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/143f796e57aa46ba18da1e05b45958ad6778d618/comments", "author": null, "committer": null, "parents": [{"sha": "2326ba44e4287372dcf2d885048fe4c87f7bb805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2326ba44e4287372dcf2d885048fe4c87f7bb805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2326ba44e4287372dcf2d885048fe4c87f7bb805"}], "stats": {"total": 986, "additions": 10, "deletions": 976}, "files": [{"sha": "2e1fb0487482684f19f38219485c8e5c325b4f97", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=143f796e57aa46ba18da1e05b45958ad6778d618", "patch": "@@ -1,3 +1,8 @@\n+2007-01-10  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/net/URL.java: Removed.\n+\t* sources.am, Makefile.in: Rebuilt.\n+\n 2007-01-10  Matthias Klose  <doko@debian.org>\n \n \t* Makefile.am (install-exec-hook): Support $(DESTDIR)."}, {"sha": "bae8e2244513f3ff6103be6ec7e272f4ce005eb0", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=143f796e57aa46ba18da1e05b45958ad6778d618", "patch": "@@ -4395,7 +4395,7 @@ classpath/java/net/SocketPermission.java \\\n classpath/java/net/SocketTimeoutException.java \\\n classpath/java/net/URI.java \\\n classpath/java/net/URISyntaxException.java \\\n-java/net/URL.java \\\n+classpath/java/net/URL.java \\\n java/net/URLClassLoader.java \\\n classpath/java/net/URLConnection.java \\\n classpath/java/net/URLDecoder.java \\"}, {"sha": "b4932208003a26135932e55697d13218d3d2cb94", "filename": "libjava/classpath/lib/java/net/URL$1.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURL%241.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURL%241.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURL%241.class?ref=143f796e57aa46ba18da1e05b45958ad6778d618"}, {"sha": "8eb71fda53ddbd687efd63032e92ffffd1cc15d5", "filename": "libjava/classpath/lib/java/net/URL.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURL.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURL.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURL.class?ref=143f796e57aa46ba18da1e05b45958ad6778d618"}, {"sha": "f0553c968bcc75f3a848937d9336ea13973b4608", "filename": "libjava/java/net/URL.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fjava%2Fnet%2FURL.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fjava%2Fnet%2FURL.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.h?ref=143f796e57aa46ba18da1e05b45958ad6778d618", "patch": "@@ -34,6 +34,9 @@ class java::net::URL : public ::java::lang::Object\n   URL(::java::lang::String *);\n   URL(::java::net::URL *, ::java::lang::String *);\n   URL(::java::net::URL *, ::java::lang::String *, ::java::net::URLStreamHandler *);\n+private:\n+  URL(::java::net::URL *, ::java::lang::String *, ::java::net::URLStreamHandler *, jboolean);\n+public:\n   jboolean equals(::java::lang::Object *);\n   ::java::lang::Object * getContent();\n   ::java::lang::Object * getContent(JArray< ::java::lang::Class * > *);"}, {"sha": "0ae7c1cfb96ee62aae67f3c4448f9a238215aab8", "filename": "libjava/java/net/URL.java", "status": "removed", "additions": 0, "deletions": 974, "changes": 974, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2326ba44e4287372dcf2d885048fe4c87f7bb805/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2326ba44e4287372dcf2d885048fe4c87f7bb805/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=2326ba44e4287372dcf2d885048fe4c87f7bb805", "patch": "@@ -1,974 +0,0 @@\n-/* URL.java -- Uniform Resource Locator Class\n-   Copyright (C) 1998, 1999, 2000, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-package java.net;\n-\n-import gnu.java.net.URLParseError;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.HashMap;\n-import java.util.StringTokenizer;\n-\n-\n-/*\n- * Written using on-line Java Platform 1.2 API Specification, as well\n- * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n- * Status:  Believed complete and correct.\n- */\n-\n-/**\n-  * This final class represents an Internet Uniform Resource Locator (URL).\n-  * For details on the syntax of URL's and what they can be used for,\n-  * refer to RFC 1738, available from <a\n-  * href=\"http://ds.internic.net/rfcs/rfc1738.txt\">\n-  * http://ds.internic.net/rfcs/rfc1738.txt</a>\n-  * <p>\n-  * There are a great many protocols supported by URL's such as \"http\",\n-  * \"ftp\", and \"file\".  This object can handle any arbitrary URL for which\n-  * a URLStreamHandler object can be written.  Default protocol handlers\n-  * are provided for the \"http\" and \"ftp\" protocols.  Additional protocols\n-  * handler implementations may be provided in the future.  In any case,\n-  * an application or applet can install its own protocol handlers that\n-  * can be \"chained\" with other protocol hanlders in the system to extend\n-  * the base functionality provided with this class. (Note, however, that\n-  * unsigned applets cannot access properties by default or install their\n-  * own protocol handlers).\n-  * <p>\n-  * This chaining is done via the system property java.protocol.handler.pkgs\n-  * If this property is set, it is assumed to be a \"|\" separated list of\n-  * package names in which to attempt locating protocol handlers.  The\n-  * protocol handler is searched for by appending the string\n-  * \".&lt;protocol&gt;.Handler\" to each packed in the list until a hander is\n-  * found. If a protocol handler is not found in this list of packages, or if\n-  * the property does not exist, then the default protocol handler of\n-  * \"gnu.java.net.&lt;protocol&gt;.Handler\" is tried.  If this is\n-  * unsuccessful, a MalformedURLException is thrown.\n-  * <p>\n-  * All of the constructor methods of URL attempt to load a protocol\n-  * handler and so any needed protocol handlers must be installed when\n-  * the URL is constructed.\n-  * <p>\n-  * Here is an example of how URL searches for protocol handlers.  Assume\n-  * the value of java.protocol.handler.pkgs is \"com.foo|com.bar\" and the\n-  * URL is \"news://comp.lang.java.programmer\".  URL would looking the\n-  * following places for protocol handlers:\n-  * <p><pre>\n-  * com.foo.news.Handler\n-  * com.bar.news.Handler\n-  * gnu.java.net.news.Handler\n-  * </pre><p>\n-  * If the protocol handler is not found in any of those locations, a\n-  * MalformedURLException would be thrown.\n-  * <p>\n-  * Please note that a protocol handler must be a subclass of\n-  * URLStreamHandler.\n-  * <p>\n-  * Normally, this class caches protocol handlers.  Once it finds a handler\n-  * for a particular protocol, it never tries to look up a new handler\n-  * again.  However, if the system property\n-  * gnu.java.net.nocache_protocol_handlers is set, then this\n-  * caching behavior is disabled.  This property is specific to this\n-  * implementation.  Sun's JDK may or may not do protocol caching, but it\n-  * almost certainly does not examine this property.\n-  * <p>\n-  * Please also note that an application can install its own factory for\n-  * loading protocol handlers (see setURLStreamHandlerFactory).  If this is\n-  * done, then the above information is superseded and the behavior of this\n-  * class in loading protocol handlers is dependent on that factory.\n-  *\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  * @author Warren Levy (warrenl@cygnus.com)\n-  *\n-  * @see URLStreamHandler\n-  */\n-public final class URL implements Serializable\n-{\n-  private static final String DEFAULT_SEARCH_PATH =\n-    \"gnu.java.net.protocol|gnu.inet\";\n-\n-  // Cached System ClassLoader\n-  private static ClassLoader systemClassLoader;\n-\n-  /**\n-   * The name of the protocol for this URL.\n-   * The protocol is always stored in lower case.\n-   */\n-  private String protocol;\n-\n-  /**\n-   * The \"authority\" portion of the URL.\n-   */\n-  private String authority;\n-\n-  /**\n-   * The hostname or IP address of this protocol.\n-   * This includes a possible user. For example <code>joe@some.host.net</code>.\n-   */\n-  private String host;\n-\n-  /**\n-   * The user information necessary to establish the connection.\n-   */\n-  private String userInfo;\n-\n-  /**\n-   * The port number of this protocol or -1 if the port number used is\n-   * the default for this protocol.\n-   */\n-  private int port = -1; // Initialize for constructor using context.\n-\n-  /**\n-   * The \"file\" portion of the URL. It is defined as <code>path[?query]</code>.\n-   */\n-  private String file;\n-\n-  /**\n-   * The anchor portion of the URL.\n-   */\n-  private String ref;\n-\n-  /**\n-   * This is the hashCode for this URL\n-   */\n-  private int hashCode;\n-\n-  /**\n-   * The protocol handler in use for this URL\n-   */\n-  transient URLStreamHandler ph;\n-\n-  /**\n-   * If an application installs its own protocol handler factory, this is\n-   * where we keep track of it.\n-   */\n-  private static URLStreamHandlerFactory factory;\n-  private static final long serialVersionUID = -7627629688361524110L;\n-\n-  /**\n-   * This a table where we cache protocol handlers to avoid the overhead\n-   * of looking them up each time.\n-   */\n-  private static HashMap ph_cache = new HashMap();\n-\n-  /**\n-   * Whether or not to cache protocol handlers.\n-   */\n-  private static boolean cache_handlers;\n-\n-  static\n-    {\n-      String s = System.getProperty(\"gnu.java.net.nocache_protocol_handlers\");\n-\n-      if (s == null)\n-\tcache_handlers = true;\n-      else\n-\tcache_handlers = false;\n-    }\n-\n-  /**\n-   * Constructs a URL and loads a protocol handler for the values passed as\n-   * arguments.\n-   *\n-   * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n-   * @param host The hostname or IP address to connect to\n-   * @param port The port number to use, or -1 to use the protocol's\n-   * default port\n-   * @param file The \"file\" portion of the URL.\n-   *\n-   * @exception MalformedURLException If a protocol handler cannot be loaded or\n-   * a parse error occurs.\n-   */\n-  public URL(String protocol, String host, int port, String file)\n-    throws MalformedURLException\n-  {\n-    this(protocol, host, port, file, null);\n-  }\n-\n-  /**\n-   * Constructs a URL and loads a protocol handler for the values passed in\n-   * as arugments.  Uses the default port for the protocol.\n-   *\n-   * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n-   * @param host The hostname or IP address for this URL\n-   * @param file The \"file\" portion of this URL.\n-   *\n-   * @exception MalformedURLException If a protocol handler cannot be loaded or\n-   * a parse error occurs.\n-   */\n-  public URL(String protocol, String host, String file)\n-    throws MalformedURLException\n-  {\n-    this(protocol, host, -1, file, null);\n-  }\n-\n-  /**\n-   * This method initializes a new instance of <code>URL</code> with the\n-   * specified protocol, host, port, and file.  Additionally, this method\n-   * allows the caller to specify a protocol handler to use instead of\n-   * the default.  If this handler is specified, the caller must have\n-   * the \"specifyStreamHandler\" permission (see <code>NetPermission</code>)\n-   * or a <code>SecurityException</code> will be thrown.\n-   *\n-   * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n-   * @param host The hostname or IP address to connect to\n-   * @param port The port number to use, or -1 to use the protocol's default\n-   * port\n-   * @param file The \"file\" portion of the URL.\n-   * @param ph The protocol handler to use with this URL.\n-   *\n-   * @exception MalformedURLException If no protocol handler can be loaded\n-   * for the specified protocol.\n-   * @exception SecurityException If the <code>SecurityManager</code> exists\n-   * and does not allow the caller to specify its own protocol handler.\n-   *\n-   * @since 1.2\n-   */\n-  public URL(String protocol, String host, int port, String file,\n-             URLStreamHandler ph) throws MalformedURLException\n-  {\n-    if (protocol == null)\n-      throw new MalformedURLException(\"null protocol\");\n-    protocol = protocol.toLowerCase();\n-    this.protocol = protocol;\n-\n-    if (ph != null)\n-      {\n-\tSecurityManager s = System.getSecurityManager();\n-\tif (s != null)\n-\t  s.checkPermission(new NetPermission(\"specifyStreamHandler\"));\n-\n-\tthis.ph = ph;\n-      }\n-    else\n-      this.ph = getURLStreamHandler(protocol);\n-\n-    if (this.ph == null)\n-      throw new MalformedURLException(\"Protocol handler not found: \"\n-                                      + protocol);\n-\n-    this.host = host;\n-    this.port = port;\n-    this.authority = (host != null) ? host : \"\";\n-    if (port >= 0 && host != null)\n-\tthis.authority += \":\" + port;\n-\n-    int hashAt = file.indexOf('#');\n-    if (hashAt < 0)\n-      {\n-\tthis.file = file;\n-\tthis.ref = null;\n-      }\n-    else\n-      {\n-\tthis.file = file.substring(0, hashAt);\n-\tthis.ref = file.substring(hashAt + 1);\n-      }\n-    hashCode = hashCode(); // Used for serialization.\n-  }\n-\n-  /**\n-   * Initializes a URL from a complete string specification such as\n-   * \"http://www.urbanophile.com/arenn/\".  First the protocol name is parsed\n-   * out of the string.  Then a handler is located for that protocol and\n-   * the parseURL() method of that protocol handler is used to parse the\n-   * remaining fields.\n-   *\n-   * @param spec The complete String representation of a URL\n-   *\n-   * @exception MalformedURLException If a protocol handler cannot be found\n-   * or the URL cannot be parsed\n-   */\n-  public URL(String spec) throws MalformedURLException\n-  {\n-    this((URL) null, spec != null ? spec : \"\", (URLStreamHandler) null);\n-  }\n-\n-  /**\n-   * This method parses a String representation of a URL within the\n-   * context of an existing URL.  Principally this means that any\n-   * fields not present the URL are inheritied from the context URL.\n-   * This allows relative URL's to be easily constructed.  If the\n-   * context argument is null, then a complete URL must be specified\n-   * in the URL string.  If the protocol parsed out of the URL is\n-   * different from the context URL's protocol, then then URL String\n-   * is also expected to be a complete URL.\n-   *\n-   * @param context The context on which to parse the specification\n-   * @param spec The string to parse an URL\n-   *\n-   * @exception MalformedURLException If a protocol handler cannot be found\n-   * for the URL cannot be parsed\n-   */\n-  public URL(URL context, String spec) throws MalformedURLException\n-  {\n-    this(context, spec, (URLStreamHandler) null);\n-  }\n-\n-  /**\n-   * Creates an URL from given arguments\n-   * This method parses a String representation of a URL within the\n-   * context of an existing URL.  Principally this means that any fields\n-   * not present the URL are inheritied from the context URL.  This allows\n-   * relative URL's to be easily constructed.  If the context argument is\n-   * null, then a complete URL must be specified in the URL string.\n-   * If the protocol parsed out of the URL is different\n-   * from the context URL's protocol, then then URL String is also\n-   * expected to be a complete URL.\n-   * <p>\n-   * Additionally, this method allows the caller to specify a protocol handler\n-   * to use instead of  the default.  If this handler is specified, the caller\n-   * must have the \"specifyStreamHandler\" permission\n-   * (see <code>NetPermission</code>) or a <code>SecurityException</code>\n-   * will be thrown.\n-   *\n-   * @param context The context in which to parse the specification\n-   * @param spec The string to parse as an URL\n-   * @param ph The stream handler for the URL\n-   *\n-   * @exception MalformedURLException If a protocol handler cannot be found\n-   * or the URL cannot be parsed\n-   * @exception SecurityException If the <code>SecurityManager</code> exists\n-   * and does not allow the caller to specify its own protocol handler.\n-   *\n-   * @since 1.2\n-   */\n-  public URL(URL context, String spec, URLStreamHandler ph)\n-    throws MalformedURLException\n-  {\n-    /* A protocol is defined by the doc as the substring before a ':'\n-     * as long as the ':' occurs before any '/'.\n-     *\n-     * If context is null, then spec must be an absolute URL.\n-     *\n-     * The relative URL need not specify all the components of a URL.\n-     * If the protocol, host name, or port number is missing, the value\n-     * is inherited from the context.  A bare file component is appended\n-     * to the context's file.  The optional anchor is not inherited.\n-     */\n-\n-    // If this is an absolute URL, then ignore context completely.\n-    // An absolute URL must have chars prior to \"://\" but cannot have a colon\n-    // right after the \"://\".  The second colon is for an optional port value\n-    // and implies that the host from the context is used if available.\n-    int colon;\n-    int slash = spec.indexOf('/');\n-    if ((colon = spec.indexOf(\"://\", 1)) > 0\n-\t&& ((colon < slash || slash < 0))\n-        && ! spec.regionMatches(colon, \"://:\", 0, 4))\n-      context = null;\n-\n-    if ((colon = spec.indexOf(':')) > 0\n-        && (colon < slash || slash < 0))\n-      {\n-\t// Protocol specified in spec string.\n-\tprotocol = spec.substring(0, colon).toLowerCase();\n-\tif (context != null && context.protocol.equals(protocol))\n-\t  {\n-\t    // The 1.2 doc specifically says these are copied to the new URL.\n-\t    host = context.host;\n-\t    port = context.port;\n-            userInfo = context.userInfo;\n-\t    authority = context.authority;\n-\t  }\n-      }\n-    else if (context != null)\n-      {\n-\t// Protocol NOT specified in spec string.\n-\t// Use context fields (except ref) as a foundation for relative URLs.\n-\tcolon = -1;\n-\tprotocol = context.protocol;\n-\thost = context.host;\n-\tport = context.port;\n-        userInfo = context.userInfo;\n-\tif (spec.indexOf(\":/\", 1) < 0)\n-\t  {\n-\t    file = context.file;\n-\t    if (file == null || file.length() == 0)\n-\t      file = \"/\";\n-\t  }\n-\tauthority = context.authority;\n-      }\n-    else // Protocol NOT specified in spec. and no context available.\n-      throw new MalformedURLException(\"Absolute URL required with null\"\n-\t\t\t\t      + \" context: \" + spec);\n-\n-    protocol = protocol.trim();\n-\n-    if (ph != null)\n-      {\n-\tSecurityManager s = System.getSecurityManager();\n-\tif (s != null)\n-\t  s.checkPermission(new NetPermission(\"specifyStreamHandler\"));\n-\n-\tthis.ph = ph;\n-      }\n-    else\n-      this.ph = getURLStreamHandler(protocol);\n-\n-    if (this.ph == null)\n-      throw new MalformedURLException(\"Protocol handler not found: \"\n-                                      + protocol);\n-\n-    // JDK 1.2 doc for parseURL specifically states that any '#' ref\n-    // is to be excluded by passing the 'limit' as the indexOf the '#'\n-    // if one exists, otherwise pass the end of the string.\n-    int hashAt = spec.indexOf('#', colon + 1);\n-\n-    try\n-      {\n-\tthis.ph.parseURL(this, spec, colon + 1,\n-\t                 hashAt < 0 ? spec.length() : hashAt);\n-      }\n-    catch (URLParseError e)\n-      {\n-\tthrow new MalformedURLException(e.getMessage());\n-      }\n-\n-    if (hashAt >= 0)\n-      ref = spec.substring(hashAt + 1);\n-\n-    hashCode = hashCode(); // Used for serialization.\n-  }\n-\n-  /**\n-   * Test another URL for equality with this one.  This will be true only if\n-   * the argument is non-null and all of the fields in the URL's match\n-   * exactly (ie, protocol, host, port, file, and ref).  Overrides\n-   * Object.equals(), implemented by calling the equals method of the handler.\n-   *\n-   * @param obj The URL to compare with\n-   *\n-   * @return true if the URL is equal, false otherwise\n-   */\n-  public boolean equals(Object obj)\n-  {\n-    if (! (obj instanceof URL))\n-      return false;\n-\n-    return ph.equals(this, (URL) obj);\n-  }\n-\n-  /**\n-   * Returns the contents of this URL as an object by first opening a\n-   * connection, then calling the getContent() method against the connection\n-   *\n-   * @return A content object for this URL\n-   * @exception IOException If opening the connection or getting the\n-   * content fails.\n-   *\n-   * @since 1.3\n-   */\n-  public Object getContent() throws IOException\n-  {\n-    return openConnection().getContent();\n-  }\n-\n-  /**\n-   * Gets the contents of this URL\n-   *\n-   * @param classes The allow classes for the content object.\n-   *\n-   * @return a context object for this URL.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public Object getContent(Class[] classes) throws IOException\n-  {\n-    // FIXME: implement this\n-    return getContent();\n-  }\n-\n-  /**\n-   * Returns the file portion of the URL.\n-   * Defined as <code>path[?query]</code>.\n-   * Returns the empty string if there is no file portion.\n-   *\n-   * @return The filename specified in this URL, or an empty string if empty.\n-   */\n-  public String getFile()\n-  {\n-    return file == null ? \"\" : file;\n-  }\n-\n-  /**\n-   * Returns the path of the URL. This is the part of the file before any '?'\n-   * character.\n-   *\n-   * @return The path specified in this URL, or null if empty.\n-   *\n-   * @since 1.3\n-   */\n-  public String getPath()\n-  {\n-    // The spec says we need to return an empty string, but some\n-    // applications depends on receiving null when the path is empty.\n-    if (file == null)\n-      return null;\n-    int quest = file.indexOf('?');\n-    return quest < 0 ? getFile() : file.substring(0, quest);\n-  }\n-\n-  /**\n-   * Returns the authority of the URL\n-   *\n-   * @return The authority specified in this URL.\n-   *\n-   * @since 1.3\n-   */\n-  public String getAuthority()\n-  {\n-    return authority;\n-  }\n-\n-  /**\n-   * Returns the host of the URL\n-   *\n-   * @return The host specified in this URL.\n-   */\n-  public String getHost()\n-  {\n-    int at = (host == null) ? -1 : host.indexOf('@');\n-    return at < 0 ? host : host.substring(at + 1, host.length());\n-  }\n-\n-  /**\n-   * Returns the port number of this URL or -1 if the default port number is\n-   * being used.\n-   *\n-   * @return The port number\n-   *\n-   * @see #getDefaultPort()\n-   */\n-  public int getPort()\n-  {\n-    return port;\n-  }\n-\n-  /**\n-   * Returns the default port of the URL. If the StreamHandler for the URL\n-   * protocol does not define a default port it returns -1.\n-   *\n-   * @return The default port of the current protocol.\n-   */\n-  public int getDefaultPort()\n-  {\n-    return ph.getDefaultPort();\n-  }\n-\n-  /**\n-   * Returns the protocol of the URL\n-   *\n-   * @return The specified protocol.\n-   */\n-  public String getProtocol()\n-  {\n-    return protocol;\n-  }\n-\n-  /**\n-   * Returns the ref (sometimes called the \"# reference\" or \"anchor\") portion\n-   * of the URL.\n-   *\n-   * @return The ref\n-   */\n-  public String getRef()\n-  {\n-    return ref;\n-  }\n-\n-  /**\n-   * Returns the user information of the URL. This is the part of the host\n-   * name before the '@'.\n-   *\n-   * @return the user at a particular host or null when no user defined.\n-   */\n-  public String getUserInfo()\n-  {\n-    if (userInfo != null)\n-      return userInfo;\n-    int at = (host == null) ? -1 : host.indexOf('@');\n-    return at < 0 ? null : host.substring(0, at);\n-  }\n-\n-  /**\n-   * Returns the query of the URL. This is the part of the file before the\n-   * '?'.\n-   *\n-   * @return the query part of the file, or null when there is no query part.\n-   */\n-  public String getQuery()\n-  {\n-    int quest = (file == null) ? -1 : file.indexOf('?');\n-    return quest < 0 ? null : file.substring(quest + 1, file.length());\n-  }\n-\n-  /**\n-   * Returns a hashcode computed by the URLStreamHandler of this URL\n-   *\n-   * @return The hashcode for this URL.\n-   */\n-  public int hashCode()\n-  {\n-    if (hashCode != 0)\n-      return hashCode; // Use cached value if available.\n-    else\n-      return ph.hashCode(this);\n-  }\n-\n-  /**\n-   * Returns a URLConnection object that represents a connection to the remote\n-   * object referred to by the URL. The URLConnection is created by calling the\n-   * openConnection() method of the protocol handler\n-   *\n-   * @return A URLConnection for this URL\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public URLConnection openConnection() throws IOException\n-  {\n-    return ph.openConnection(this);\n-  }\n-\n-  /**\n-   * Opens a connection to this URL and returns an InputStream for reading\n-   * from that connection\n-   *\n-   * @return An <code>InputStream</code> for this URL.\n-   *\n-   * @exception IOException If an error occurs\n-   */\n-  public InputStream openStream() throws IOException\n-  {\n-    return openConnection().getInputStream();\n-  }\n-\n-  /**\n-   * Tests whether or not another URL refers to the same \"file\" as this one.\n-   * This will be true if and only if the passed object is not null, is a\n-   * URL, and matches all fields but the ref (ie, protocol, host, port,\n-   * and file);\n-   *\n-   * @param url The URL object to test with\n-   *\n-   * @return true if URL matches this URL's file, false otherwise\n-   */\n-  public boolean sameFile(URL url)\n-  {\n-    return ph.sameFile(this, url);\n-  }\n-\n-  /**\n-   * Sets the specified fields of the URL. This is not a public method so\n-   * that only URLStreamHandlers can modify URL fields. This might be called\n-   * by the <code>parseURL()</code> method in that class. URLs are otherwise\n-   * constant. If the given protocol does not exist, it will keep the previously\n-   * set protocol.\n-   *\n-   * @param protocol The protocol name for this URL\n-   * @param host The hostname or IP address for this URL\n-   * @param port The port number of this URL\n-   * @param file The \"file\" portion of this URL.\n-   * @param ref The anchor portion of this URL.\n-   */\n-  protected void set(String protocol, String host, int port, String file,\n-                     String ref)\n-  {\n-    URLStreamHandler protocolHandler = null;\n-    protocol = protocol.toLowerCase();\n-    if (! this.protocol.equals(protocol))\n-      protocolHandler = getURLStreamHandler(protocol);\n-    \n-    // It is an hidden feature of the JDK. If the protocol does not exist,\n-    // we keep the previously initialized protocol.\n-    if (protocolHandler != null)\n-      {\n-\tthis.ph = protocolHandler;\n-\tthis.protocol = protocol;\n-      }\n-    this.authority = \"\";\n-    this.port = port;\n-    this.host = host;\n-    this.file = file;\n-    this.ref = ref;\n-\n-    if (host != null)\n-      this.authority += host;\n-    if (port >= 0)\n-      this.authority += \":\" + port;\n-\n-    hashCode = hashCode(); // Used for serialization.\n-  }\n-\n-  /**\n-   * Sets the specified fields of the URL. This is not a public method so\n-   * that only URLStreamHandlers can modify URL fields. URLs are otherwise\n-   * constant. If the given protocol does not exist, it will keep the previously\n-   * set protocol.\n-   *\n-   * @param protocol The protocol name for this URL.\n-   * @param host The hostname or IP address for this URL.\n-   * @param port The port number of this URL.\n-   * @param authority The authority of this URL.\n-   * @param userInfo The user and password (if needed) of this URL.\n-   * @param path The \"path\" portion of this URL.\n-   * @param query The query of this URL.\n-   * @param ref The anchor portion of this URL.\n-   *\n-   * @since 1.3\n-   */\n-  protected void set(String protocol, String host, int port, String authority,\n-                     String userInfo, String path, String query, String ref)\n-  {\n-    URLStreamHandler protocolHandler = null;\n-    protocol = protocol.toLowerCase();\n-    if (! this.protocol.equals(protocol))\n-      protocolHandler = getURLStreamHandler(protocol);\n-    \n-    // It is an hidden feature of the JDK. If the protocol does not exist,\n-    // we keep the previously initialized protocol.\n-    if (protocolHandler != null)\n-      {\n-\tthis.ph = protocolHandler;\n-\tthis.protocol = protocol;\n-      }\n-    this.host = host;\n-    this.userInfo = userInfo;\n-    this.port = port;\n-    this.authority = authority;\n-    if (query == null)\n-      this.file = path;\n-    else\n-      this.file = path + \"?\" + query;\n-    this.ref = ref;\n-    hashCode = hashCode(); // Used for serialization.\n-  }\n-\n-  /**\n-   * Sets the URLStreamHandlerFactory for this class.  This factory is\n-   * responsible for returning the appropriate protocol handler for\n-   * a given URL.\n-   *\n-   * @param fac The URLStreamHandlerFactory class to use\n-   *\n-   * @exception Error If the factory is alread set.\n-   * @exception SecurityException If a security manager exists and its\n-   * checkSetFactory method doesn't allow the operation\n-   */\n-  public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory fac)\n-  {\n-    if (factory != null)\n-      throw new Error(\"URLStreamHandlerFactory already set\");\n-\n-    // Throw an exception if an extant security mgr precludes\n-    // setting the factory.\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkSetFactory();\n-    factory = fac;\n-  }\n-\n-  /**\n-   * Returns a String representing this URL.  The String returned is\n-   * created by calling the protocol handler's toExternalForm() method.\n-   *\n-   * @return A string for this URL\n-   */\n-  public String toExternalForm()\n-  {\n-    // Identical to toString().\n-    return ph.toExternalForm(this);\n-  }\n-\n-  /**\n-   * Returns a String representing this URL.  Identical to toExternalForm().\n-   * The value returned is created by the protocol handler's\n-   * toExternalForm method.  Overrides Object.toString()\n-   *\n-   * @return A string for this URL\n-   */\n-  public String toString()\n-  {\n-    // Identical to toExternalForm().\n-    return ph.toExternalForm(this);\n-  }\n-\n-  /**\n-   * This internal method is used in two different constructors to load\n-   * a protocol handler for this URL.\n-   *\n-   * @param protocol The protocol to load a handler for\n-   *\n-   * @return A URLStreamHandler for this protocol, or null when not found.\n-   */\n-  private static synchronized URLStreamHandler getURLStreamHandler(String protocol)\n-  {\n-    URLStreamHandler ph = null;\n-\n-    // First, see if a protocol handler is in our cache.\n-    if (cache_handlers)\n-      {\n-\tif ((ph = (URLStreamHandler) ph_cache.get(protocol)) != null)\n-\t  return ph;\n-      }\n-\n-    // If a non-default factory has been set, use it to find the protocol.\n-    if (factory != null)\n-      {\n-\tph = factory.createURLStreamHandler(protocol);\n-      }\n-    else if (protocol.equals(\"core\"))\n-      {\n- \tph = new gnu.java.net.protocol.core.Handler();\n-      }\n-    else if (protocol.equals(\"file\"))\n-      {\n-\t// This is an interesting case.  It's tempting to think that we\n-\t// could call Class.forName (\"gnu.java.net.protocol.file.Handler\") to\n-\t// get the appropriate class.  Unfortunately, if we do that the\n-\t// program will never terminate, because getURLStreamHandler is\n-\t// eventually called by Class.forName.\n-\t//\n-\t// Treating \"file\" as a special case is the minimum that will\n-\t// fix this problem.  If other protocols are required in a\n-\t// statically linked application they will need to be handled in\n-\t// the same way as \"file\".\n-\tph = new gnu.java.net.protocol.file.Handler();\n-      }\n-\n-    // Non-default factory may have returned null or a factory wasn't set.\n-    // Use the default search algorithm to find a handler for this protocol.\n-    if (ph == null)\n-      {\n-\t// Get the list of packages to check and append our default handler\n-\t// to it, along with the JDK specified default as a last resort.\n-\t// Except in very unusual environments the JDK specified one shouldn't\n-\t// ever be needed (or available).\n-\tString ph_search_path =\n-\t  System.getProperty(\"java.protocol.handler.pkgs\");\n-\n-\t// Tack our default package on at the ends.\n-\tif (ph_search_path != null)\n-\t  ph_search_path += \"|\" + DEFAULT_SEARCH_PATH;\n-\telse\n-\t  ph_search_path = DEFAULT_SEARCH_PATH;\n-\n-\t// Finally loop through our search path looking for a match.\n-\tStringTokenizer pkgPrefix = new StringTokenizer(ph_search_path, \"|\");\n-\n-\t// Cache the systemClassLoader\n-\tif (systemClassLoader == null)\n-\t  {\n-\t    systemClassLoader = (ClassLoader) AccessController.doPrivileged\n-\t      (new PrivilegedAction() {\n-\t\t  public Object run()\n-\t          {\n-\t\t    return ClassLoader.getSystemClassLoader();\n-\t\t  }\n-\t\t});\n-\t  }\n-\n-\tdo\n-\t  {\n-\t    try\n-\t      {\n-\t\t// Try to get a class from the system/application\n-\t\t// classloader, initialize it, make an instance\n-\t\t// and try to cast it to a URLStreamHandler.\n-\t\tString clsName =\n-\t\t  (pkgPrefix.nextToken() + \".\" + protocol + \".Handler\");\n-\t\tClass c = Class.forName(clsName, true, systemClassLoader);\n-\t\tph = (URLStreamHandler) c.newInstance();\n-\t      }\n-            catch (ThreadDeath death)\n-              {\n-                throw death;\n-              }\n-\t    catch (Throwable t)\n-\t      {\n-\t\t// Ignored.\n-\t      }\n-\t  }\n-\t while (ph == null && pkgPrefix.hasMoreTokens());\n-      }\n-\n-    // Update the hashtable with the new protocol handler.\n-    if (ph != null && cache_handlers)\n-      ph_cache.put(protocol, ph);\n-    else\n-      ph = null;\n-\n-    return ph;\n-  }\n-\n-  private void readObject(ObjectInputStream ois)\n-    throws IOException, ClassNotFoundException\n-  {\n-    ois.defaultReadObject();\n-    this.ph = getURLStreamHandler(protocol);\n-    if (this.ph == null)\n-      throw new IOException(\"Handler for protocol \" + protocol + \" not found\");\n-  }\n-\n-  private void writeObject(ObjectOutputStream oos) throws IOException\n-  {\n-    oos.defaultWriteObject();\n-  }\n-\n-  /**\n-   * Returns the equivalent <code>URI</code> object for this <code>URL</code>.\n-   * This is the same as calling <code>new URI(this.toString())</code>.\n-   * RFC2396-compliant URLs are guaranteed a successful conversion to\n-   * a <code>URI</code> instance.  However, there are some values which\n-   * form valid URLs, but which do not also form RFC2396-compliant URIs.\n-   *\n-   * @throws URISyntaxException if this URL is not RFC2396-compliant,\n-   *         and thus can not be successfully converted to a URI.\n-   */\n-  public URI toURI()\n-    throws URISyntaxException\n-  {\n-    return new URI(toString());\n-  }\n-\n-}"}, {"sha": "fea09f26961c73bbef9ab862e7159ba7bfdaedf4", "filename": "libjava/sources.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/143f796e57aa46ba18da1e05b45958ad6778d618/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=143f796e57aa46ba18da1e05b45958ad6778d618", "patch": "@@ -4845,7 +4845,7 @@ classpath/java/net/SocketPermission.java \\\n classpath/java/net/SocketTimeoutException.java \\\n classpath/java/net/URI.java \\\n classpath/java/net/URISyntaxException.java \\\n-java/net/URL.java \\\n+classpath/java/net/URL.java \\\n java/net/URLClassLoader.java \\\n classpath/java/net/URLConnection.java \\\n classpath/java/net/URLDecoder.java \\"}]}