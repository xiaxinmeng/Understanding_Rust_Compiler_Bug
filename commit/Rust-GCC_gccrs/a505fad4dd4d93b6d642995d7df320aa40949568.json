{"sha": "a505fad4dd4d93b6d642995d7df320aa40949568", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUwNWZhZDRkZDRkOTNiNmQ2NDI5OTVkN2RmMzIwYWE0MDk0OTU2OA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-02-26T01:00:12Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-02-26T01:00:12Z"}, "message": "analyzer: eliminate dedupe_candidate [PR96374]\n\nIn gcc/analyzer/diagnostic-manager.cc the code partitions\nsaved_diagnostic instances by dedupe_key, and tries to find the \"best\"\nsaved_diagnostic for each dedupe_key.\n\nIdeally we would find the shortest feasible path for each\nsaved_diagnostic and pick the winner in each deduplication set.\n\nCurrently we merely approximate that by finding the shortest path for\neach saved_diagnostic, and checking to see if it feasible, rejecting\nthe saved_diagnostic if it is not.  The \"shortest path, or nothing if\nit's infeasible\" is not the same as the \"shortest feasible path\", and\nthis leads to false negatives, where we reject valid diagnostics,\ntracked as PR analyzer/96374.\n\nI have been attempting various fixes for this, but in doing so I\nfound that the existing structure of the code makes things unnecessarily\nawkward: each dedupe_set had a a dedupe_candidate which stored the\nbest epath for that set, creating it from the shortest path when that\ndedupe_candidate was constructed.\n\nThis patch eliminates the dedupe_candidate, instead storing the best\nepath for each saved_diagnostic within the saved_diagnostic itself,\nalong with any feasibility_problem, and eliminating a redundant \"status\"\nfield.  The logic for finding the best epath is moved to a new\nepath_finder::get_best_epath subroutine, introducing an epath_finder\nclass to give a place to cache state.\n\nThis patch merely copies over the existing logic to\nepath_finder::get_best_epath, so no functional change is intended,\nbut the patch simplifies the logic and makes it much easier to\nexperiment with alternate implementations as I try to fix\nPR analyzer/96374.\n\nI attempted another version of this patch in which I added a dedupe_set\nclass and partitioned saved_diagnostics into them as the diagnostics were\nadded, but in this earlier iteration of the patch there were regressions\ne.g. from gcc.dg/analyzer/zlib-4.c where 4 deduplication sets became 3.\nThe issue was that the deduplication logic needs source locations, which\nneed gimple statements, and the stmt_finder needs epaths to run.  Finding\nthe epaths needs the full egraph (as opposed to the egraph in its state\nat the time when the diagnostic is saved).  Hence the partitioning needs to\nhappen after the egraph is fully explored.  I backed up the earlier patch\nkit to:\n  https://dmalcolm.fedorapeople.org/gcc/2021-02-23/feasibility-v0.3-relative-to-72d78655a91bb2f89ac4432cfd6374380d6f9987/\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/96374\n\t* diagnostic-manager.cc (class epath_finder): New.\n\t(epath_finder::get_best_epath): New.\n\t(saved_diagnostic::saved_diagnostic): Update for replacement of\n\tm_state and m_epath_length with m_best_epath.\n\t(saved_diagnostic::~saved_diagnostic): Delete m_best_epath.\n\t(saved_diagnostic::to_json): Update \"path_length\" to be optional.\n\t(saved_diagnostic::calc_best_epath): New, based on\n\tdedupe_winners::add and parts of dedupe_key::dedupe_key.\n\t(saved_diagnostic::get_epath_length): New.\n\t(saved_diagnostic::add_duplicate): New.\n\t(dedupe_key::dedupe_key): Drop epath param.  Move invocation of\n\tstmt_finder to saved_diagnostic::calc_best_epath.\n\t(class dedupe_candidate): Delete.\n\t(class dedupe_hash_map_traits): Update to use saved_diagnotic *\n\trather than dedupe_candidate * as the value_type/compare_type.\n\t(dedupe_winners::~dedupe_winners): Don't delete the values.\n\t(dedupe_winners::add): Convert param from shortest_exploded_paths to\n\tepath_finder.  Drop \"eg\" param.  Drop dedupe_candidate, moving\n\tpath generation and feasiblity checking to\n\tepath_finder::get_best_epath.  Update winner-selection for move\n\tof epaths from dedupe_candidate to saved_diagnostic.\n\t(dedupe_winners::emit_best):  Update for removal of class\n\tdedupe_candidate.\n\t(dedupe_winners::map_t): Update to use saved_diagnotic * rather\n\tthan dedupe_candidate * as the value_type/compare_type.\n\t(diagnostic_manager::emit_saved_diagnostics): Move\n\tshortest_exploded_paths instance into epath_finder and pass that\n\taround instead.\n\t(diagnostic_manager::emit_saved_diagnostic): Drop epath, stmt\n\tand num_dupes params, instead getting these from the\n\tsaved_diagnostic.  Use correct location in inform_n call.\n\t* diagnostic-manager.h (class epath_finder): New forward decl.\n\t(saved_diagnostic::status): Drop enum.\n\t(saved_diagnostic::set_feasible): Drop.\n\t(saved_diagnostic::set_infeasible): Drop.\n\t(saved_diagnostic::get_status): Drop.\n\t(saved_diagnostic::calc_best_epath): New decl.\n\t(saved_diagnostic::get_best_epath): New decl.\n\t(saved_diagnostic::get_epath_length): New decl.\n\t(saved_diagnostic::set_epath_length): Drop.\n\t(saved_diagnostic::get_epath_length): Drop inline implementation.\n\t(saved_diagnostic::add_duplicate): New.\n\t(saved_diagnostic::get_num_dupes): New.\n\t(saved_diagnostic::m_d): Document ownership.\n\t(saved_diagnostic::m_trailing_eedge): Make const.\n\t(saved_diagnostic::m_status): Drop field.\n\t(saved_diagnostic::m_epath_length): Drop field.\n\t(saved_diagnostic::m_best_epath): New field.\n\t(saved_diagnostic::m_problem): Document ownership.\n\t(saved_diagnostic::m_duplicates): New field.\n\t(diagnostic_manager::emit_saved_diagnostic): Drop params epath,\n\tstmt, and num_dupes.\n\t* engine.cc (exploded_graph_annotator::print_saved_diagnostic):\n\tUpdate for changes to saved_diagnostic class.\n\t* exploded-graph.h (exploded_path::feasible_p): Drop unused\n\toverloaded decl.", "tree": {"sha": "1b498cfef000011a8588d1a300408b1d6f2cbe83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b498cfef000011a8588d1a300408b1d6f2cbe83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a505fad4dd4d93b6d642995d7df320aa40949568", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a505fad4dd4d93b6d642995d7df320aa40949568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a505fad4dd4d93b6d642995d7df320aa40949568", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a505fad4dd4d93b6d642995d7df320aa40949568/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bd409cfc83683a9be5c6b3b8f9a3ec8959f9356"}], "stats": {"total": 450, "additions": 244, "deletions": 206}, "files": [{"sha": "f0f447f14dc6513db08ab6ed8836051c2bdc6149", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 210, "deletions": 140, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=a505fad4dd4d93b6d642995d7df320aa40949568", "patch": "@@ -64,6 +64,104 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n+/* State for finding the shortest feasible exploded_path for a\n+   saved_diagnostic.\n+   This is shared between all diagnostics, so that we avoid repeating work.  */\n+\n+class epath_finder\n+{\n+public:\n+  epath_finder (const exploded_graph &eg)\n+  : m_eg (eg),\n+    m_sep (eg, eg.get_origin ())\n+  {\n+  }\n+\n+  logger *get_logger () const { return m_eg.get_logger (); }\n+\n+  exploded_path *get_best_epath (const exploded_node *enode,\n+\t\t\t\t const char *desc,\n+\t\t\t\t feasibility_problem **out_problem);\n+\n+private:\n+  const exploded_graph &m_eg;\n+  shortest_exploded_paths m_sep;\n+};\n+\n+/* class epath_finder.  */\n+\n+/* Get the \"best\" exploded_path for reaching ENODE from the origin,\n+   returning ownership of it to the caller.\n+\n+   Ideally we want to report the shortest feasible path.\n+   Return NULL if we could not find a feasible path\n+   (when flag_analyzer_feasibility is true).\n+\n+   If flag_analyzer_feasibility is false, then simply return the\n+   shortest path.\n+\n+   Use DESC when logging.\n+\n+   Write any feasiblity_problem to *OUT_PROBLEM.  */\n+\n+exploded_path *\n+epath_finder::get_best_epath (const exploded_node *enode,\n+\t\t\t      const char *desc,\n+\t\t\t      feasibility_problem **out_problem)\n+{\n+  logger *logger = get_logger ();\n+  LOG_SCOPE (logger);\n+\n+  unsigned snode_idx = enode->get_supernode ()->m_index;\n+  if (logger)\n+    logger->log (\"considering %qs at EN: %i, SN: %i\",\n+\t\t desc, enode->m_index, snode_idx);\n+\n+  /* State-merging means that not every path in the egraph corresponds\n+     to a feasible one w.r.t. states.\n+\n+     We want to find the shortest feasible path from the origin to ENODE\n+     in the egraph.\n+\n+     As a crude approximation to this, we find the shortest path, and\n+     determine if it is feasible.  This could introduce false negatives,\n+     as there could be longer feasible paths within the egraph.\n+     (PR analyzer/96374).  */\n+\n+  exploded_path *epath = new exploded_path (m_sep.get_shortest_path (enode));\n+  if (epath->feasible_p (logger, out_problem, m_eg.get_engine (), &m_eg))\n+    {\n+      if (logger)\n+\tlogger->log (\"accepting %qs at EN: %i, SN: %i with feasible path\",\n+\t\t     desc, enode->m_index,\n+\t\t     snode_idx);\n+    }\n+  else\n+    {\n+      if (flag_analyzer_feasibility)\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n+\t\t\t \" due to infeasible path\",\n+\t\t\t desc, enode->m_index,\n+\t\t\t snode_idx);\n+\t  delete epath;\n+\t  return NULL;\n+\t}\n+      else\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"accepting %qs at EN: %i, SN: %i\"\n+\t\t\t \" despite infeasible path (due to %qs)\",\n+\t\t\t desc, enode->m_index,\n+\t\t\t snode_idx,\n+\t\t\t \"-fno-analyzer-feasibility\");\n+\t}\n+    }\n+\n+  return epath;\n+}\n+\n /* class saved_diagnostic.  */\n \n /* saved_diagnostic's ctor.\n@@ -83,7 +181,7 @@ saved_diagnostic::saved_diagnostic (const state_machine *sm,\n   m_stmt_finder (stmt_finder ? stmt_finder->clone () : NULL),\n   m_var (var), m_sval (sval), m_state (state),\n   m_d (d), m_trailing_eedge (NULL),\n-  m_status (STATUS_NEW), m_epath_length (0), m_problem (NULL)\n+  m_best_epath (NULL), m_problem (NULL)\n {\n   gcc_assert (m_stmt || m_stmt_finder);\n \n@@ -98,6 +196,7 @@ saved_diagnostic::~saved_diagnostic ()\n {\n   delete m_stmt_finder;\n   delete m_d;\n+  delete m_best_epath;\n   delete m_problem;\n }\n \n@@ -121,7 +220,7 @@ saved_diagnostic::operator== (const saved_diagnostic &other) const\n     \"snode\": int,\n     \"sval\": optional str,\n     \"state\": optional str,\n-    \"path_length\": int,\n+    \"path_length\": optional int,\n     \"pending_diagnostic\": str}.  */\n \n json::object *\n@@ -137,7 +236,8 @@ saved_diagnostic::to_json () const\n     sd_obj->set (\"sval\", m_sval->to_json ());\n   if (m_state)\n     sd_obj->set (\"state\", m_state->to_json ());\n-  sd_obj->set (\"path_length\", new json::integer_number (m_epath_length));\n+  if (m_best_epath)\n+    sd_obj->set (\"path_length\", new json::integer_number (get_epath_length ()));\n   sd_obj->set (\"pending_diagnostic\", new json::string (m_d->get_kind ()));\n \n   /* We're not yet JSONifying the following fields:\n@@ -152,6 +252,64 @@ saved_diagnostic::to_json () const\n   return sd_obj;\n }\n \n+/* Use PF to find the best exploded_path for this saved_diagnostic,\n+   and store it in m_best_epath.\n+   If m_stmt is still NULL, use m_stmt_finder on the epath to populate\n+   m_stmt.\n+   Return true if a best path was found.  */\n+\n+bool\n+saved_diagnostic::calc_best_epath (epath_finder *pf)\n+{\n+  logger *logger = pf->get_logger ();\n+  LOG_SCOPE (logger);\n+  delete m_best_epath;\n+  delete m_problem;\n+  m_problem = NULL;\n+\n+  m_best_epath = pf->get_best_epath (m_enode, m_d->get_kind (),\n+\t\t\t\t     &m_problem);\n+\n+  /* Handle failure to find a feasible path.  */\n+  if (m_best_epath == NULL)\n+    {\n+      gcc_assert (m_problem);\n+      return false;\n+    }\n+\n+  gcc_assert (m_best_epath);\n+  if (m_stmt == NULL)\n+    {\n+      gcc_assert (m_stmt_finder);\n+      m_stmt = m_stmt_finder->find_stmt (*m_best_epath);\n+    }\n+  gcc_assert (m_stmt);\n+\n+  return true;\n+}\n+\n+unsigned\n+saved_diagnostic::get_epath_length () const\n+{\n+  gcc_assert (m_best_epath);\n+  return m_best_epath->length ();\n+}\n+\n+/* Record that OTHER (and its duplicates) are duplicates\n+   of this saved_diagnostic.  */\n+\n+void\n+saved_diagnostic::add_duplicate (saved_diagnostic *other)\n+{\n+  gcc_assert (other);\n+  m_duplicates.reserve (m_duplicates.length ()\n+\t\t\t+ other->m_duplicates.length ()\n+\t\t\t+ 1);\n+  m_duplicates.splice (other->m_duplicates);\n+  other->m_duplicates.truncate (0);\n+  m_duplicates.safe_push (other);\n+}\n+\n /* State for building a checker_path from a particular exploded_path.\n    In particular, this precomputes reachability information: the set of\n    source enodes for which a path be found to the diagnostic enode.  */\n@@ -279,23 +437,15 @@ diagnostic_manager::to_json () const\n \n /* A class for identifying sets of duplicated pending_diagnostic.\n \n-   We want to find the simplest dedupe_candidate amongst those that share a\n+   We want to find the simplest saved_diagnostic amongst those that share a\n    dedupe_key.  */\n \n class dedupe_key\n {\n public:\n-  dedupe_key (const saved_diagnostic &sd,\n-\t      const exploded_path &epath)\n+  dedupe_key (const saved_diagnostic &sd)\n   : m_sd (sd), m_stmt (sd.m_stmt)\n   {\n-    /* Support deferring the choice of stmt until after an emission path has\n-     been built, using an optional stmt_finder.  */\n-    if (m_stmt == NULL)\n-      {\n-\tgcc_assert (sd.m_stmt_finder);\n-\tm_stmt = sd.m_stmt_finder->find_stmt (epath);\n-      }\n     gcc_assert (m_stmt);\n   }\n \n@@ -344,41 +494,14 @@ class dedupe_key\n   const gimple *m_stmt;\n };\n \n-/* The value of a slot for a dedupe_key within dedupe_winners:\n-   the exploded_path for the best candidate for that key, and the\n-   number of duplicates seen so far.  */\n-\n-class dedupe_candidate\n-{\n-public:\n-  // has the exploded_path\n-  dedupe_candidate (const shortest_exploded_paths &sp,\n-\t\t    saved_diagnostic *sd)\n-  : m_epath (sp.get_shortest_path (sd->m_enode)),\n-    m_num_dupes (0)\n-  {\n-  }\n-\n-  unsigned length () const { return m_epath.length (); }\n-  const exploded_path &get_path () const { return m_epath; }\n-\n-  void add_duplicate () { m_num_dupes++; }\n-  int get_num_dupes () const { return m_num_dupes; }\n-\n-private:\n-  exploded_path m_epath;\n-public:\n-  int m_num_dupes;\n-};\n-\n /* Traits for use by dedupe_winners.  */\n \n class dedupe_hash_map_traits\n {\n public:\n   typedef const dedupe_key *key_type;\n-  typedef dedupe_candidate *value_type;\n-  typedef dedupe_candidate *compare_type;\n+  typedef saved_diagnostic *value_type;\n+  typedef saved_diagnostic *compare_type;\n \n   static inline hashval_t hash (const key_type &v)\n   {\n@@ -417,7 +540,7 @@ class dedupe_hash_map_traits\n };\n \n /* A class for deduplicating diagnostics and finding (and emitting) the\n-   best diagnostic within each partition.  */\n+   best saved_diagnostic within each partition.  */\n \n class dedupe_winners\n {\n@@ -426,113 +549,62 @@ class dedupe_winners\n \n   ~dedupe_winners ()\n   {\n-    /* Delete all keys and candidates.  */\n+    /* Delete all keys, but not the saved_diagnostics.  */\n     for (map_t::iterator iter = m_map.begin ();\n \t iter != m_map.end ();\n \t ++iter)\n-      {\n-\tdelete (*iter).first;\n-\tdelete (*iter).second;\n-      }\n+      delete (*iter).first;\n   }\n \n-  /* Determine an exploded_path for SD using SP and, if it's feasible,\n-     determine if it's the best seen so far for its dedupe_key.\n-     Retain the winner for each dedupe_key, and discard the rest.  */\n+  /* Determine an exploded_path for SD using PF and, if it's feasible,\n+     determine if SD is the best seen so far for its dedupe_key.\n+     Record the winning SD for each dedupe_key.  */\n \n   void add (logger *logger,\n-\t    const shortest_exploded_paths &sp,\n-\t    const exploded_graph *eg,\n+\t    epath_finder *pf,\n \t    saved_diagnostic *sd)\n   {\n-    /* Build a dedupe_candidate for SD.\n-       This uses SP to build an exploded_path.  */\n-    dedupe_candidate *dc = new dedupe_candidate (sp, sd);\n-\n-    sd->set_epath_length (dc->length ());\n-\n-    /* Verify that the epath is feasible.\n-       State-merging means that not every path in the epath corresponds\n-       to a feasible one w.r.t. states.\n-       Here we simply check each duplicate saved_diagnostic's\n-       shortest_path, and reject any that aren't feasible.\n-       This could introduce false negatives, as there could be longer\n-       feasible paths within the egraph.  */\n-    if (logger)\n-      logger->log (\"considering %qs at EN: %i, SN: %i\",\n-\t\t   sd->m_d->get_kind (), sd->m_enode->m_index,\n-\t\t   sd->m_snode->m_index);\n-\n-    feasibility_problem *p = NULL;\n-    if (dc->get_path ().feasible_p (logger, &p, m_engine, eg))\n-      {\n-\tif (logger)\n-\t  logger->log (\"accepting %qs at EN: %i, SN: %i with feasible path\",\n-\t\t       sd->m_d->get_kind (), sd->m_enode->m_index,\n-\t\t       sd->m_snode->m_index);\n-\tsd->set_feasible ();\n-      }\n-    else\n-      {\n-\tif (flag_analyzer_feasibility)\n-\t  {\n-\t    if (logger)\n-\t      logger->log (\"rejecting %qs at EN: %i, SN: %i\"\n-\t\t\t   \" due to infeasible path\",\n-\t\t\t   sd->m_d->get_kind (), sd->m_enode->m_index,\n-\t\t\t   sd->m_snode->m_index);\n-\t    sd->set_infeasible (p);\n-\t    delete dc;\n-\t    return;\n-\t  }\n-\telse\n-\t  {\n-\t    if (logger)\n-\t      logger->log (\"accepting %qs at EN: %i, SN: %i\"\n-\t\t\t   \" despite infeasible path (due to %qs)\",\n-\t\t\t   sd->m_d->get_kind (), sd->m_enode->m_index,\n-\t\t\t   sd->m_snode->m_index,\n-\t\t\t   \"-fno-analyzer-feasibility\");\n-\t    sd->set_infeasible (p);\n-\t  }\n-      }\n+    /* Determine best epath for SD.  */\n+    if (!sd->calc_best_epath (pf))\n+      return;\n \n-    dedupe_key *key = new dedupe_key (*sd, dc->get_path ());\n-    if (dedupe_candidate **slot = m_map.get (key))\n+    dedupe_key *key = new dedupe_key (*sd);\n+    if (saved_diagnostic **slot = m_map.get (key))\n       {\n \tif (logger)\n \t  logger->log (\"already have this dedupe_key\");\n \n-\t(*slot)->add_duplicate ();\n+\tsaved_diagnostic *cur_best_sd = *slot;\n \n-\tif (dc->length () < (*slot)->length ())\n+\tif (sd->get_epath_length () < cur_best_sd->get_epath_length ())\n \t  {\n \t    /* We've got a shorter path for the key; replace\n-\t       the current candidate.  */\n+\t       the current candidate, marking it as a duplicate of SD.  */\n \t    if (logger)\n \t      logger->log (\"length %i is better than existing length %i;\"\n \t\t\t   \" taking over this dedupe_key\",\n-\t\t\t   dc->length (), (*slot)->length ());\n-\t    dc->m_num_dupes = (*slot)->get_num_dupes ();\n-\t    delete *slot;\n-\t    *slot = dc;\n+\t\t\t   sd->get_epath_length (),\n+\t\t\t   cur_best_sd->get_epath_length ());\n+\t    sd->add_duplicate (cur_best_sd);\n+\t    *slot = sd;\n \t  }\n \telse\n-\t  /* We haven't beaten the current best candidate;\n-\t     drop the new candidate.  */\n+\t  /* We haven't beaten the current best candidate; add SD\n+\t     as a duplicate of it.  */\n \t  {\n \t    if (logger)\n \t      logger->log (\"length %i isn't better than existing length %i;\"\n \t\t\t   \" dropping this candidate\",\n-\t\t\t   dc->length (), (*slot)->length ());\n-\t    delete dc;\n+\t\t\t   sd->get_epath_length (),\n+\t\t\t   cur_best_sd->get_epath_length ());\n+\t    cur_best_sd->add_duplicate (sd);\n \t  }\n \tdelete key;\n       }\n     else\n       {\n \t/* This is the first candidate for this key.  */\n-\tm_map.put (key, dc);\n+\tm_map.put (key, sd);\n \tif (logger)\n \t  logger->log (\"first candidate for this dedupe_key\");\n       }\n@@ -557,27 +629,24 @@ class dedupe_winners\n     /* Sort into a good emission order.  */\n     keys.qsort (dedupe_key::comparator);\n \n-    /* Emit the best candidate for each key.  */\n+    /* Emit the best saved_diagnostics for each key.  */\n     int i;\n     const dedupe_key *key;\n     FOR_EACH_VEC_ELT (keys, i, key)\n       {\n-\tdedupe_candidate **slot = m_map.get (key);\n+\tsaved_diagnostic **slot = m_map.get (key);\n \tgcc_assert (*slot);\n-\tconst dedupe_candidate &dc = **slot;\n-\n-\tdm->emit_saved_diagnostic (eg, key->m_sd,\n-\t\t\t\t   dc.get_path (), key->m_stmt,\n-\t\t\t\t   dc.get_num_dupes ());\n+\tconst saved_diagnostic *sd = *slot;\n+\tdm->emit_saved_diagnostic (eg, *sd);\n       }\n   }\n \n private:\n   engine *m_engine;\n \n-  /* This maps from each dedupe_key to a current best dedupe_candidate.  */\n+  /* This maps from each dedupe_key to a current best saved_diagnostic.  */\n \n-  typedef hash_map<const dedupe_key *, dedupe_candidate *,\n+  typedef hash_map<const dedupe_key *, saved_diagnostic *,\n \t\t   dedupe_hash_map_traits> map_t;\n   map_t m_map;\n };\n@@ -604,7 +673,7 @@ diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n     return;\n \n   /* Compute the shortest_paths once, sharing it between all diagnostics.  */\n-  shortest_exploded_paths sp (eg, eg.get_origin ());\n+  epath_finder pf (eg);\n \n   /* Iterate through all saved diagnostics, adding them to a dedupe_winners\n      instance.  This partitions the saved diagnostics by dedupe_key,\n@@ -615,39 +684,39 @@ diagnostic_manager::emit_saved_diagnostics (const exploded_graph &eg)\n   int i;\n   saved_diagnostic *sd;\n   FOR_EACH_VEC_ELT (m_saved_diagnostics, i, sd)\n-    best_candidates.add (get_logger (), sp, &eg, sd);\n+    best_candidates.add (get_logger (), &pf, sd);\n \n   /* For each dedupe-key, call emit_saved_diagnostic on the \"best\"\n      saved_diagnostic.  */\n   best_candidates.emit_best (this, eg);\n }\n \n-/* Given a saved_diagnostic SD at STMT with feasible path EPATH through EG,\n+/* Given a saved_diagnostic SD with m_best_epath through EG,\n    create an checker_path of suitable events and use it to call\n    SD's underlying pending_diagnostic \"emit\" vfunc to emit a diagnostic.  */\n \n void\n diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n-\t\t\t\t\t   const saved_diagnostic &sd,\n-\t\t\t\t\t   const exploded_path &epath,\n-\t\t\t\t\t   const gimple *stmt,\n-\t\t\t\t\t   int num_dupes)\n+\t\t\t\t\t   const saved_diagnostic &sd)\n {\n   LOG_SCOPE (get_logger ());\n   log (\"sd: %qs at SN: %i\", sd.m_d->get_kind (), sd.m_snode->m_index);\n-  log (\"num dupes: %i\", num_dupes);\n+  log (\"num dupes: %i\", sd.get_num_dupes ());\n \n   pretty_printer *pp = global_dc->printer->clone ();\n \n+  const exploded_path *epath = sd.get_best_epath ();\n+  gcc_assert (epath);\n+\n   /* Precompute all enodes from which the diagnostic is reachable.  */\n-  path_builder pb (eg, epath, sd.get_feasibility_problem (), sd);\n+  path_builder pb (eg, *epath, sd.get_feasibility_problem (), sd);\n \n   /* This is the diagnostic_path subclass that will be built for\n      the diagnostic.  */\n   checker_path emission_path;\n \n   /* Populate emission_path with a full description of EPATH.  */\n-  build_emission_path (pb, epath, &emission_path);\n+  build_emission_path (pb, *epath, &emission_path);\n \n   /* Now prune it to just cover the most pertinent events.  */\n   prune_path (&emission_path, sd.m_sm, sd.m_sval, sd.m_state);\n@@ -656,7 +725,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n      We use the final enode from the epath, which might be different from\n      the sd.m_enode, as the dedupe code doesn't care about enodes, just\n      snodes.  */\n-  emission_path.add_final_event (sd.m_sm, epath.get_final_enode (), stmt,\n+  emission_path.add_final_event (sd.m_sm, epath->get_final_enode (), sd.m_stmt,\n \t\t\t\t sd.m_var, sd.m_state);\n \n   /* The \"final\" event might not be final; if the saved_diagnostic has a\n@@ -667,7 +736,7 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n \n   emission_path.prepare_for_emission (sd.m_d);\n \n-  location_t loc = get_stmt_location (stmt, sd.m_snode->m_fun);\n+  location_t loc = get_stmt_location (sd.m_stmt, sd.m_snode->m_fun);\n \n   /* Allow the pending_diagnostic to fix up the primary location\n      and any locations for events.  */\n@@ -681,8 +750,9 @@ diagnostic_manager::emit_saved_diagnostic (const exploded_graph &eg,\n   auto_cfun sentinel (sd.m_snode->m_fun);\n   if (sd.m_d->emit (&rich_loc))\n     {\n+      unsigned num_dupes = sd.get_num_dupes ();\n       if (flag_analyzer_show_duplicate_count && num_dupes > 0)\n-\tinform_n (stmt->location, num_dupes,\n+\tinform_n (loc, num_dupes,\n \t\t  \"%i duplicate\", \"%i duplicates\",\n \t\t  num_dupes);\n     }"}, {"sha": "c55807851fd77832f8c6bc5a2279ba45b62f2ca0", "filename": "gcc/analyzer/diagnostic-manager.h", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fdiagnostic-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.h?ref=a505fad4dd4d93b6d642995d7df320aa40949568", "patch": "@@ -23,18 +23,13 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace ana {\n \n+class epath_finder;\n+\n /* A to-be-emitted diagnostic stored within diagnostic_manager.  */\n \n class saved_diagnostic\n {\n public:\n-  enum status\n-  {\n-   STATUS_NEW,\n-   STATUS_INFEASIBLE_PATH,\n-   STATUS_FEASIBLE_PATH\n-  };\n-\n   saved_diagnostic (const state_machine *sm,\n \t\t    const exploded_node *enode,\n \t\t    const supernode *snode, const gimple *stmt,\n@@ -48,26 +43,17 @@ class saved_diagnostic\n \n   json::object *to_json () const;\n \n-  void set_feasible ()\n-  {\n-    gcc_assert (m_status == STATUS_NEW);\n-    m_status = STATUS_FEASIBLE_PATH;\n-  }\n-  void set_infeasible (feasibility_problem *p)\n-  {\n-    gcc_assert (m_status == STATUS_NEW);\n-    m_status = STATUS_INFEASIBLE_PATH;\n-    m_problem = p; // take ownership\n-  }\n   const feasibility_problem *get_feasibility_problem () const\n   {\n     return m_problem;\n   }\n \n-  enum status get_status () const { return m_status; }\n+  bool calc_best_epath (epath_finder *pf);\n+  const exploded_path *get_best_epath () const { return m_best_epath; }\n+  unsigned get_epath_length () const;\n \n-  void set_epath_length (unsigned length) { m_epath_length = length; }\n-  unsigned get_epath_length () const { return m_epath_length; }\n+  void add_duplicate (saved_diagnostic *other);\n+  unsigned get_num_dupes () const { return m_duplicates.length (); }\n \n   //private:\n   const state_machine *m_sm;\n@@ -78,15 +64,16 @@ class saved_diagnostic\n   tree m_var;\n   const svalue *m_sval;\n   state_machine::state_t m_state;\n-  pending_diagnostic *m_d;\n-  exploded_edge *m_trailing_eedge;\n+  pending_diagnostic *m_d; // owned\n+  const exploded_edge *m_trailing_eedge;\n \n private:\n   DISABLE_COPY_AND_ASSIGN (saved_diagnostic);\n \n-  enum status m_status;\n-  unsigned m_epath_length;\n-  feasibility_problem *m_problem;\n+  exploded_path *m_best_epath; // owned\n+  feasibility_problem *m_problem; // owned\n+\n+  auto_vec<const saved_diagnostic *> m_duplicates;\n };\n \n class path_builder;\n@@ -126,10 +113,7 @@ class diagnostic_manager : public log_user\n   void emit_saved_diagnostics (const exploded_graph &eg);\n \n   void emit_saved_diagnostic (const exploded_graph &eg,\n-\t\t\t      const saved_diagnostic &sd,\n-\t\t\t      const exploded_path &epath,\n-\t\t\t      const gimple *stmt,\n-\t\t\t      int num_dupes);\n+\t\t\t      const saved_diagnostic &sd);\n \n   unsigned get_num_diagnostics () const\n   {"}, {"sha": "6077cc82795b58c0f09c2f1812e822c43dd19950", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=a505fad4dd4d93b6d642995d7df320aa40949568", "patch": "@@ -4581,45 +4581,30 @@ class exploded_graph_annotator : public dot_annotator\n     pp_printf (pp, \"DIAGNOSTIC: %s\", sd->m_d->get_kind ());\n     gv->end_tdtr ();\n     gv->begin_trtd ();\n-    pp_printf (pp, \"epath length: %i\", sd->get_epath_length ());\n+    if (sd->get_best_epath ())\n+      pp_printf (pp, \"epath length: %i\", sd->get_epath_length ());\n+    else\n+      pp_printf (pp, \"no best epath\");\n     gv->end_tdtr ();\n-    switch (sd->get_status ())\n+    if (const feasibility_problem *p = sd->get_feasibility_problem ())\n       {\n-      default:\n-      case saved_diagnostic::STATUS_NEW:\n-\tgcc_unreachable ();\n-\tbreak;\n-      case saved_diagnostic::STATUS_INFEASIBLE_PATH:\n-\t{\n-\t  gv->begin_trtd ();\n-\t  pp_printf (pp, \"INFEASIBLE\");\n-\t  gv->end_tdtr ();\n-\t  const feasibility_problem *p = sd->get_feasibility_problem ();\n-\t  gcc_assert (p);\n-\t  gv->begin_trtd ();\n-\t  pp_printf (pp, \"at eedge %i: EN:%i -> EN:%i\",\n-\t\t     p->m_eedge_idx,\n-\t\t     p->m_eedge.m_src->m_index,\n-\t\t     p->m_eedge.m_dest->m_index);\n-\t  pp_write_text_as_html_like_dot_to_stream (pp);\n-\t  gv->end_tdtr ();\n-\t  gv->begin_trtd ();\n-\t  p->m_eedge.m_sedge->dump (pp);\n-\t  pp_write_text_as_html_like_dot_to_stream (pp);\n-\t  gv->end_tdtr ();\n-\t  gv->begin_trtd ();\n-\t  pp_gimple_stmt_1 (pp, p->m_last_stmt, 0, (dump_flags_t)0);\n-\t  pp_write_text_as_html_like_dot_to_stream (pp);\n-\t  gv->end_tdtr ();\n-\t  /* Ideally we'd print p->m_model here; see the notes above about\n-\t     tooltips.  */\n-\t}\n-\tbreak;\n-      case saved_diagnostic::STATUS_FEASIBLE_PATH:\n \tgv->begin_trtd ();\n-\tpp_printf (pp, \"FEASIBLE\");\n+\tpp_printf (pp, \"INFEASIBLE at eedge %i: EN:%i -> EN:%i\",\n+\t\t   p->m_eedge_idx,\n+\t\t   p->m_eedge.m_src->m_index,\n+\t\t   p->m_eedge.m_dest->m_index);\n+\tpp_write_text_as_html_like_dot_to_stream (pp);\n \tgv->end_tdtr ();\n-\tbreak;\n+\tgv->begin_trtd ();\n+\tp->m_eedge.m_sedge->dump (pp);\n+\tpp_write_text_as_html_like_dot_to_stream (pp);\n+\tgv->end_tdtr ();\n+\tgv->begin_trtd ();\n+\tpp_gimple_stmt_1 (pp, p->m_last_stmt, 0, (dump_flags_t)0);\n+\tpp_write_text_as_html_like_dot_to_stream (pp);\n+\tgv->end_tdtr ();\n+\t/* Ideally we'd print p->m_model here; see the notes above about\n+\t   tooltips.  */\n       }\n     pp_printf (pp, \"</TABLE>\");\n     gv->end_tdtr ();"}, {"sha": "2d4cb9fcce0af5c441fc45a254af6dd7f163c585", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a505fad4dd4d93b6d642995d7df320aa40949568/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=a505fad4dd4d93b6d642995d7df320aa40949568", "patch": "@@ -879,7 +879,6 @@ class exploded_path\n   void dump (FILE *fp) const;\n   void dump () const;\n \n-  bool feasible_p (logger *logger, feasibility_problem **out) const;\n   bool feasible_p (logger *logger, feasibility_problem **out,\n \t\t    engine *eng, const exploded_graph *eg) const;\n "}]}