{"sha": "ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwYWI5NjNmMjYyNDBmOTYzMWIxODA2YWIwNzNjZDdiOWNkNGFlZQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-03-16T21:03:15Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2012-03-16T21:03:15Z"}, "message": "re PR libstdc++/52476 ([DR 518] Unordered multimap reorders equivalent elements)\n\n2012-03-15  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\tPR libstdc++/52476\n\t* include/bits/hashtable.h (_Hashtable<>::_M_rehash_aux): Add.\n\t(_Hashtable<>::_M_rehash): Use the latter.\n\t* testsuite/23_containers/unordered_multimap/insert/52476.cc: New.\n\t* testsuite/23_containers/unordered_multiset/insert/52476.cc: New.\n\nFrom-SVN: r185476", "tree": {"sha": "c189c33aac76976d0531f629a133a130a91f5754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c189c33aac76976d0531f629a133a130a91f5754"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/comments", "author": null, "committer": null, "parents": [{"sha": "d66823158e896f40597005f456cb4fdf8420470e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d66823158e896f40597005f456cb4fdf8420470e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d66823158e896f40597005f456cb4fdf8420470e"}], "stats": {"total": 304, "additions": 279, "deletions": 25}, "files": [{"sha": "c48b1fa30912a2ecfe14378cb910773bfebdce38", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "patch": "@@ -1,3 +1,11 @@\n+2012-03-16  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/52476\n+\t* include/bits/hashtable.h (_Hashtable<>::_M_rehash_aux): Add.\n+\t(_Hashtable<>::_M_rehash): Use the latter.\n+\t* testsuite/23_containers/unordered_multimap/insert/52476.cc: New.\n+\t* testsuite/23_containers/unordered_multiset/insert/52476.cc: New.\n+\n 2012-03-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config/os/solaris/solaris2.8: Rename to ..."}, {"sha": "41418a8a509465547a0f7d32d99c63cd54e46492", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 135, "deletions": 25, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "patch": "@@ -596,6 +596,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // reserve, if present, comes from _Rehash_base.\n \n     private:\n+      // Helper rehash method used when keys are unique.\n+      void _M_rehash_aux(size_type __n, std::true_type);\n+\n+      // Helper rehash method used when keys can be non-unique.\n+      void _M_rehash_aux(size_type __n, std::false_type);\n+\n       // Unconditionally change size of bucket array to n, restore hash policy\n       // state to __state on exception.\n       void _M_rehash(size_type __n, const _RehashPolicyState& __state);\n@@ -1592,41 +1598,145 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       __try\n \t{\n-\t  _Bucket* __new_buckets = _M_allocate_buckets(__n);\n-\t  _Node* __p = _M_begin();\n-\t  _M_before_begin._M_nxt = nullptr;\n-\t  std::size_t __cur_bbegin_bkt;\n-\t  while (__p)\n+\t  _M_rehash_aux(__n, integral_constant<bool, __uk>());\n+\t}\n+      __catch(...)\n+\t{\n+\t  // A failure here means that buckets allocation failed.  We only\n+\t  // have to restore hash policy previous state.\n+\t  _M_rehash_policy._M_reset(__state);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+\n+  // Rehash when there is no equivalent elements.\n+  template<typename _Key, typename _Value,\n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_rehash_aux(size_type __n, std::true_type)\n+    {\n+      _Bucket* __new_buckets = _M_allocate_buckets(__n);\n+      _Node* __p = _M_begin();\n+      _M_before_begin._M_nxt = nullptr;\n+      std::size_t __bbegin_bkt;\n+      while (__p)\n+\t{\n+\t  _Node* __next = __p->_M_next();\n+\t  std::size_t __bkt = _HCBase::_M_bucket_index(__p, __n);\n+\t  if (!__new_buckets[__bkt])\n \t    {\n-\t      _Node* __next = __p->_M_next();\n-\t      std::size_t __new_index = _HCBase::_M_bucket_index(__p, __n);\n-\t      if (!__new_buckets[__new_index])\n+\t      __p->_M_nxt = _M_before_begin._M_nxt;\n+\t      _M_before_begin._M_nxt = __p;\n+\t      __new_buckets[__bkt] = &_M_before_begin;\n+\t      if (__p->_M_nxt)\n+\t\t__new_buckets[__bbegin_bkt] = __p;\n+\t      __bbegin_bkt = __bkt;\n+\t    }\n+\t  else\n+\t    {\n+\t      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;\n+\t      __new_buckets[__bkt]->_M_nxt = __p;\n+\t    }\n+\t  __p = __next;\n+\t}\n+      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+      _M_bucket_count = __n;\n+      _M_buckets = __new_buckets;\n+    }\n+\n+  // Rehash when there can be equivalent elements, preserve their relative\n+  // order.\n+  template<typename _Key, typename _Value,\n+\t   typename _Allocator, typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n+\t   bool __chc, bool __cit, bool __uk>\n+    void\n+    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+    _M_rehash_aux(size_type __n, std::false_type)\n+    {\n+      _Bucket* __new_buckets = _M_allocate_buckets(__n);\n+\n+      _Node* __p = _M_begin();\n+      _M_before_begin._M_nxt = nullptr;\n+      std::size_t __bbegin_bkt;\n+      std::size_t __prev_bkt;\n+      _Node* __prev_p = nullptr;\n+      bool __check_bucket = false;\n+\n+      while (__p)\n+\t{\n+\t  bool __check_now = true;\n+\t  _Node* __next = __p->_M_next();\n+\t  std::size_t __bkt = _HCBase::_M_bucket_index(__p, __n);\n+\n+\t  if (!__new_buckets[__bkt])\n+\t    {\n+\t      __p->_M_nxt = _M_before_begin._M_nxt;\n+\t      _M_before_begin._M_nxt = __p;\n+\t      __new_buckets[__bkt] = &_M_before_begin;\n+\t      if (__p->_M_nxt)\n+\t\t__new_buckets[__bbegin_bkt] = __p;\n+\t      __bbegin_bkt = __bkt;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (__prev_p && __prev_bkt == __bkt)\n \t\t{\n-\t\t  __p->_M_nxt = _M_before_begin._M_nxt;\n-\t\t  _M_before_begin._M_nxt = __p;\n-\t\t  __new_buckets[__new_index] = &_M_before_begin;\n-\t\t  if (__p->_M_nxt)\n-\t\t    __new_buckets[__cur_bbegin_bkt] = __p;\n-\t\t  __cur_bbegin_bkt = __new_index;\n+\t\t  // Previous insert was already in this bucket, we insert after\n+\t\t  // the previously inserted one to preserve equivalent elements\n+\t\t  // relative order.\n+\t\t  __p->_M_nxt = __prev_p->_M_nxt;\n+\t\t  __prev_p->_M_nxt = __p;\n+\n+\t\t  // Inserting after a node in a bucket require to check that we\n+\t\t  // haven't change the bucket last node, in this case next\n+\t\t  // bucket containing its before begin node must be updated. We\n+\t\t  // schedule a check as soon as we move out of the sequence of\n+\t\t  // equivalent nodes to limit the number of checks.\n+\t\t  __check_bucket = true;\n+\t\t  __check_now = false;\n \t\t}\n \t      else\n \t\t{\n-\t\t  __p->_M_nxt = __new_buckets[__new_index]->_M_nxt;\n-\t\t  __new_buckets[__new_index]->_M_nxt = __p;\n+\t\t  __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;\n+\t\t  __new_buckets[__bkt]->_M_nxt = __p;\n \t\t}\n-\t      __p = __next;\n \t    }\n-\t  _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n-\t  _M_bucket_count = __n;\n-\t  _M_buckets = __new_buckets;\n+\t  \n+\t  if (__check_now && __check_bucket)\n+\t    {\n+\t      // Check if we shall update the next bucket because of insertions\n+\t      // into __prev_bkt bucket.\n+\t      if (__prev_p->_M_nxt)\n+\t\t{\n+\t\t  std::size_t __next_bkt\n+\t\t    = _HCBase::_M_bucket_index(__prev_p->_M_next(), __n);\n+\t\t  if (__next_bkt != __prev_bkt)\n+\t\t    __new_buckets[__next_bkt] = __prev_p;\n+\t\t}\n+\t      __check_bucket = false;\n+\t    }\n+\t  __prev_p = __p;\n+\t  __prev_bkt = __bkt;\n+\t  __p = __next;\n \t}\n-      __catch(...)\n+\n+      if (__check_bucket && __prev_p->_M_nxt)\n \t{\n-\t  // A failure here means that buckets allocation failed.  We only\n-\t  // have to restore hash policy previous state.\n-\t  _M_rehash_policy._M_reset(__state);\n-\t  __throw_exception_again;\n+\t  std::size_t __next_bkt\n+\t    = _HCBase::_M_bucket_index(__prev_p->_M_next(), __n);\n+\t  if (__next_bkt != __prev_bkt)\n+\t    __new_buckets[__next_bkt] = __prev_p;\n \t}\n+\n+      _M_deallocate_buckets(_M_buckets, _M_bucket_count);\n+      _M_bucket_count = __n;\n+      _M_buckets = __new_buckets;\n     }\n \n _GLIBCXX_END_NAMESPACE_VERSION"}, {"sha": "f4f78398878393271226faa0637b2600997a1c6c", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/52476.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F52476.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F52476.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2F52476.cc?ref=ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_map>\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+  \n+  unordered_multimap<int, int> mmap;\n+  vector<int> values;\n+\n+  size_t nb_bkts = mmap.bucket_count();\n+  int i = 0;\n+  for (;; ++i)\n+    {\n+      mmap.insert(make_pair(0, i));\n+      if (mmap.bucket_count() != nb_bkts)\n+\t// Container got rehash\n+\tbreak;\n+      values.clear();\n+      transform(mmap.begin(), mmap.end(), back_inserter(values),\n+\t\t[](const pair<int, int>& p) { return p.second; });\n+    }\n+\n+  vector<int> rehash_values;\n+  transform(mmap.begin(), mmap.end(), back_inserter(rehash_values),\n+\t    [](const pair<int, int>& p) { return p.second; });\n+  // Remove the value that result in a rehash\n+  rehash_values.erase(remove(rehash_values.begin(), rehash_values.end(), i));\n+\n+  VERIFY( rehash_values == values );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "45eeb71f55be6583c0cd2d9f02ae60e0e3798d83", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/52476.cc", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F52476.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac0ab963f26240f9631b1806ab073cd7b9cd4aee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F52476.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2F52476.cc?ref=ac0ab963f26240f9631b1806ab073cd7b9cd4aee", "patch": "@@ -0,0 +1,77 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <unordered_set>\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+namespace\n+{\n+  struct pair_hash\n+  {\n+    std::size_t\n+    operator()(const std::pair<int, int>& p) const noexcept\n+    { return std::hash<int>()(p.first); }\n+  };\n+\n+  struct pair_equal_to\n+  {\n+    bool\n+    operator()(const std::pair<int, int>& x,\n+\t       const std::pair<int, int>& y) const noexcept\n+    { return x.first == y.first; }\n+  };\n+}\n+\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+  \n+  unordered_multiset<pair<int, int>, pair_hash, pair_equal_to> mset;\n+  vector<int> values;\n+\n+  size_t nb_bkts = mset.bucket_count();\n+  int i = 0;\n+  for (;; ++i)\n+    {\n+      mset.insert(make_pair(0, i));\n+      if (mset.bucket_count() != nb_bkts)\n+\t// Container got rehash\n+\tbreak;\n+      values.clear();\n+      transform(mset.begin(), mset.end(), back_inserter(values),\n+\t\t[](const pair<int, int>& p) { return p.second; });\n+    }\n+\n+  vector<int> rehash_values;\n+  transform(mset.begin(), mset.end(), back_inserter(rehash_values),\n+\t    [](const pair<int, int>& p) { return p.second; });\n+  // Remove the value that result in a rehash\n+  rehash_values.erase(remove(rehash_values.begin(), rehash_values.end(), i));\n+\n+  VERIFY( rehash_values == values );\n+}\n+  \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}