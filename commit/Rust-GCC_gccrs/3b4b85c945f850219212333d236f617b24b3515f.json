{"sha": "3b4b85c945f850219212333d236f617b24b3515f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0Yjg1Yzk0NWY4NTAyMTkyMTIzMzNkMjM2ZjYxN2IyNGIzNTE1Zg==", "commit": {"author": {"name": "Bernardo Innocenti", "email": "bernie@develer.com", "date": "2004-02-09T00:48:13Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2004-02-09T00:48:13Z"}, "message": "m68k.c, m68k.md (SGS, [...]): Remove code to support SGS assembler.\n\n\t* config/m68k/m68k.c, config/m68k/m68k.md (SGS, SGS_CMP_ORDER): Remove\n\tcode to support SGS assembler.  Reformat adjacent code where possible.\n\t* config/m68k/m68k.c (switch_table_difference_label_flag): Remove definition.\n\t* config/m68k/m68k.h (PRINT_OPERAND_PUNCT_VALID_P): Remove support for '%#'.\n\t* config/m68k/linux.h, config/m68k/m68k.c,\n\t* config/m68k/math-68881.h: Replace `%#' with `#' in inline asm macros and\n\tasm_printf() format strings.\n\t* config/m68k/m68kelf.h (ASM_OUTPUT_CASE_END): Remove macro definition.\n\t* config/m68k/linux.h: Update copyright.\n\t* config/m68k/linux.h, config/m68k/m68k.c: Remove traling whitespace.\n\nFrom-SVN: r77518", "tree": {"sha": "11456680402b6510cc15ccd72b7085a43bf32769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11456680402b6510cc15ccd72b7085a43bf32769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b4b85c945f850219212333d236f617b24b3515f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4b85c945f850219212333d236f617b24b3515f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b4b85c945f850219212333d236f617b24b3515f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b4b85c945f850219212333d236f617b24b3515f/comments", "author": {"login": "codewiz", "id": 1184492, "node_id": "MDQ6VXNlcjExODQ0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1184492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/codewiz", "html_url": "https://github.com/codewiz", "followers_url": "https://api.github.com/users/codewiz/followers", "following_url": "https://api.github.com/users/codewiz/following{/other_user}", "gists_url": "https://api.github.com/users/codewiz/gists{/gist_id}", "starred_url": "https://api.github.com/users/codewiz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/codewiz/subscriptions", "organizations_url": "https://api.github.com/users/codewiz/orgs", "repos_url": "https://api.github.com/users/codewiz/repos", "events_url": "https://api.github.com/users/codewiz/events{/privacy}", "received_events_url": "https://api.github.com/users/codewiz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "413b591234e6820305614cf4ebcdd1ba2f239054", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/413b591234e6820305614cf4ebcdd1ba2f239054", "html_url": "https://github.com/Rust-GCC/gccrs/commit/413b591234e6820305614cf4ebcdd1ba2f239054"}], "stats": {"total": 649, "additions": 189, "deletions": 460}, "files": [{"sha": "4d8c2cb181e1ea0bf84bc4970ac6f41d01459e90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -1,3 +1,16 @@\n+2004-02-08  Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k.c, config/m68k/m68k.md (SGS, SGS_CMP_ORDER): Remove\n+\tcode to support SGS assembler.  Reformat adjacent code where possible.\n+\t* config/m68k/m68k.c (switch_table_difference_label_flag): Remove definition.\n+\t* config/m68k/m68k.h (PRINT_OPERAND_PUNCT_VALID_P): Remove support for '%#'.\n+\t* config/m68k/linux.h, config/m68k/m68k.c,\n+\t* config/m68k/math-68881.h: Replace `%#' with `#' in inline asm macros and\n+\tasm_printf() format strings.\n+\t* config/m68k/m68kelf.h (ASM_OUTPUT_CASE_END): Remove macro definition.\n+\t* config/m68k/linux.h: Update copyright.\n+\t* config/m68k/linux.h, config/m68k/m68k.c: Remove traling whitespace.\n+\n 2004-02-08  Andreas Schwab  <schwab@suse.de>\n             Bernardo Innocenti  <bernie@develer.com>\n "}, {"sha": "687e0b0d297248c22a50eb3ec72092b03315ca24", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -1,6 +1,7 @@\n /* Definitions for Motorola 68k running Linux-based GNU systems with\n    ELF format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -27,7 +28,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* for 68k machines this only needs to be TRUE for the 68000 */\n \n-#undef STRICT_ALIGNMENT     \n+#undef STRICT_ALIGNMENT\n #define STRICT_ALIGNMENT 0\n \n #undef SUBTARGET_SWITCHES\n@@ -61,13 +62,13 @@ Boston, MA 02111-1307, USA.  */\n \n #undef SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\"\n- \n+\n #undef PTRDIFF_TYPE\n #define PTRDIFF_TYPE \"int\"\n-  \n+\n #undef WCHAR_TYPE\n #define WCHAR_TYPE \"long int\"\n-   \n+\n #undef WCHAR_TYPE_SIZE\n #define WCHAR_TYPE_SIZE BITS_PER_WORD\n \n@@ -218,7 +219,7 @@ Boston, MA 02111-1307, USA.  */\n    the precise function being called is known, FUNC is its\n    FUNCTION_DECL; otherwise, FUNC is 0.  For m68k/SVR4 generate the\n    result in d0, a0, or fp0 as appropriate.  */\n-   \n+\n #undef FUNCTION_VALUE\n #define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n   (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_68881\t\t\t\\\n@@ -276,18 +277,18 @@ do {\t\t\t\t\t\t\t\t\t\\\n    scope  - the scope of the flush (see the cpush insn)\n    cache  - which cache to flush (see the cpush insn)\n    len    - a factor relating to the number of flushes to perform:\n-   \t    len/16 lines, or len/4096 pages.  */\n+\t    len/16 lines, or len/4096 pages.  */\n \n #define CLEAR_INSN_CACHE(BEG, END)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   register unsigned long _beg __asm (\"%d1\") = (unsigned long) (BEG);\t\\\n   unsigned long _end = (unsigned long) (END);\t\t\t\t\\\n   register unsigned long _len __asm (\"%d4\") = (_end - _beg + 32);\t\\\n   __asm __volatile\t\t\t\t\t\t\t\\\n-    (\"move%.l %#123, %/d0\\n\\t\"\t/* system call nr */\t\t\t\\\n-     \"move%.l %#1, %/d2\\n\\t\"\t/* clear lines */\t\t\t\\\n-     \"move%.l %#3, %/d3\\n\\t\"\t/* insn+data caches */\t\t\t\\\n-     \"trap %#0\"\t\t\t\t\t\t\t\t\\\n+    (\"move%.l #123, %/d0\\n\\t\"\t/* system call nr */\t\t\t\\\n+     \"move%.l #1, %/d2\\n\\t\"\t/* clear lines */\t\t\t\\\n+     \"move%.l #3, %/d3\\n\\t\"\t/* insn+data caches */\t\t\t\\\n+     \"trap #0\"\t\t\t\t\t\t\t\t\\\n      : /* no outputs */\t\t\t\t\t\t\t\\\n      : \"d\" (_beg), \"d\" (_len)\t\t\t\t\t\t\\\n      : \"%d0\", \"%d2\", \"%d3\");\t\t\t\t\t\t\\"}, {"sha": "2deb7b58beea56cec9da7c7313fca950e3976363", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 49, "deletions": 115, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -91,10 +91,6 @@ struct m68k_frame\n /* Current frame information calculated by m68k_compute_frame_layout().  */\n static struct m68k_frame current_frame;\n \n-/* This flag is used to communicate between movhi and ASM_OUTPUT_CASE_END,\n-   if SGS_SWITCH_TABLE.  */\n-int switch_table_difference_label_flag;\n-\n static rtx find_addr_reg (rtx);\n static const char *singlemove_string (rtx *);\n static void m68k_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -1127,8 +1123,8 @@ output_dbcc_and_branch (rtx *operands)\n     {\n       case SImode:\n         output_asm_insn (MOTOROLA ?\n-\t\t\t   \"clr%.w %0\\n\\tsubq%.l %#1,%0\\n\\tjbpl %l1\" :\n-\t\t\t   \"clr%.w %0\\n\\tsubq%.l %#1,%0\\n\\tjpl %l1\",\n+\t\t\t   \"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjbpl %l1\" :\n+\t\t\t   \"clr%.w %0\\n\\tsubq%.l #1,%0\\n\\tjpl %l1\",\n \t\t\t operands);\n         break;\n \n@@ -1176,48 +1172,30 @@ output_scc_di(rtx op, rtx operand1, rtx operand2, rtx dest)\n   loperands[4] = gen_label_rtx();\n   if (operand2 != const0_rtx)\n     {\n-      if (MOTOROLA)\n-#ifdef SGS_CMP_ORDER\n-        output_asm_insn (\"cmp%.l %0,%2\\n\\tjbne %l4\\n\\tcmp%.l %1,%3\", loperands);\n-#else\n-        output_asm_insn (\"cmp%.l %2,%0\\n\\tjbne %l4\\n\\tcmp%.l %3,%1\", loperands);\n-#endif\n-      else\n-#ifdef SGS_CMP_ORDER\n-        output_asm_insn (\"cmp%.l %0,%2\\n\\tjne %l4\\n\\tcmp%.l %1,%3\", loperands);\n-#else\n-        output_asm_insn (\"cmp%.l %2,%0\\n\\tjne %l4\\n\\tcmp%.l %3,%1\", loperands);\n-#endif\n+      output_asm_insn (MOTOROLA ?\n+\t  \"cmp%.l %2,%0\\n\\tjbne %l4\\n\\tcmp%.l %3,%1\" :\n+          \"cmp%.l %2,%0\\n\\tjne %l4\\n\\tcmp%.l %3,%1\",\n+\tloperands);\n     }\n   else\n     {\n       if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (loperands[0]))\n \toutput_asm_insn (\"tst%.l %0\", loperands);\n       else\n \t{\n-#ifdef SGS_CMP_ORDER\n-\t  output_asm_insn (\"cmp%.w %0,%#0\", loperands);\n-#else\n-\t  output_asm_insn (\"cmp%.w %#0,%0\", loperands);\n-#endif\n+\t  output_asm_insn (\"cmp%.w #0,%0\", loperands);\n \t}\n \n       output_asm_insn (MOTOROLA ? \"jbne %l4\" : \"jne %l4\", loperands);\n \n       if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (loperands[1]))\n \toutput_asm_insn (\"tst%.l %1\", loperands);\n       else\n-\t{\n-#ifdef SGS_CMP_ORDER\n-\t  output_asm_insn (\"cmp%.w %1,%#0\", loperands);\n-#else\n-\t  output_asm_insn (\"cmp%.w %#0,%1\", loperands);\n-#endif\n-\t}\n+\toutput_asm_insn (\"cmp%.w #0,%1\", loperands);\n     }\n \n   loperands[5] = dest;\n-  \n+\n   switch (op_code)\n     {\n       case EQ:\n@@ -1693,7 +1671,7 @@ output_move_const_into_data_reg (rtx *operands)\n       return \"moveq %1,%0\\n\\tnot%.w %0\";\n     case NEGW :\n       CC_STATUS_INIT;\n-      return \"moveq %#-128,%0\\n\\tneg%.w %0\";\n+      return \"moveq #-128,%0\\n\\tneg%.w %0\";\n     case SWAP :\n       {\n \tunsigned u = i;\n@@ -1795,23 +1773,12 @@ output_move_himode (rtx *operands)\n       && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS)\n     {\n       rtx labelref = XEXP (XEXP (operands[1], 0), 1);\n-#if MOTOROLA && !defined (SGS_SWITCH_TABLES)\n-#ifdef SGS\n-      asm_fprintf (asm_out_file, \"\\tset %LLI%d,.+2\\n\",\n-\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#else /* not SGS */\n-      asm_fprintf (asm_out_file, \"\\t.set %LLI%d,.+2\\n\",\n-\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#endif /* not SGS */\n-#else /* SGS_SWITCH_TABLES or not MOTOROLA */\n-      (*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#ifdef SGS_SWITCH_TABLES\n-      /* Set flag saying we need to define the symbol\n-\t LD%n (with value L%n-LI%n) at the end of the switch table.  */\n-      switch_table_difference_label_flag = 1;\n-#endif /* SGS_SWITCH_TABLES */\n-#endif /* SGS_SWITCH_TABLES or not MOTOROLA */\n+      if (MOTOROLA)\n+\tasm_fprintf (asm_out_file, \"\\t.set %LLI%d,.+2\\n\",\n+\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+      else\n+\t(*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n+\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n     }\n   return \"move%.w %1,%0\";\n }\n@@ -1840,7 +1807,7 @@ output_move_qimode (rtx *operands)\n       if (!reg_mentioned_p (stack_pointer_rtx, operands[1]))\n \t{\n \t  xoperands[3] = stack_pointer_rtx;\n-\t  output_asm_insn (\"subq%.l %#2,%3\\n\\tmove%.b %1,%2\", xoperands);\n+\t  output_asm_insn (\"subq%.l #2,%3\\n\\tmove%.b %1,%2\", xoperands);\n \t}\n       else\n \toutput_asm_insn (\"move%.b %1,%-\\n\\tmove%.b %@,%2\", xoperands);\n@@ -1982,9 +1949,9 @@ output_move_double (rtx *operands)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       if (size == 12)\n-        output_asm_insn (\"sub%.l %#12,%0\", operands);\n+        output_asm_insn (\"sub%.l #12,%0\", operands);\n       else\n-        output_asm_insn (\"subq%.l %#8,%0\", operands);\n+        output_asm_insn (\"subq%.l #8,%0\", operands);\n       if (GET_MODE (operands[1]) == XFmode)\n \toperands[0] = gen_rtx_MEM (XFmode, operands[0]);\n       else if (GET_MODE (operands[0]) == DFmode)\n@@ -1997,9 +1964,9 @@ output_move_double (rtx *operands)\n     {\n       operands[1] = XEXP (XEXP (operands[1], 0), 0);\n       if (size == 12)\n-        output_asm_insn (\"sub%.l %#12,%1\", operands);\n+        output_asm_insn (\"sub%.l #12,%1\", operands);\n       else\n-        output_asm_insn (\"subq%.l %#8,%1\", operands);\n+        output_asm_insn (\"subq%.l #8,%1\", operands);\n       if (GET_MODE (operands[1]) == XFmode)\n \toperands[1] = gen_rtx_MEM (XFmode, operands[1]);\n       else if (GET_MODE (operands[1]) == DFmode)\n@@ -2193,34 +2160,34 @@ output_move_double (rtx *operands)\n       if (addreg0)\n \t{\n \t  if (size == 12)\n-\t    output_asm_insn (\"addq%.l %#8,%0\", &addreg0);\n+\t    output_asm_insn (\"addq%.l #8,%0\", &addreg0);\n \t  else\n-\t    output_asm_insn (\"addq%.l %#4,%0\", &addreg0);\n+\t    output_asm_insn (\"addq%.l #4,%0\", &addreg0);\n \t}\n       if (addreg1)\n \t{\n \t  if (size == 12)\n-\t    output_asm_insn (\"addq%.l %#8,%0\", &addreg1);\n+\t    output_asm_insn (\"addq%.l #8,%0\", &addreg1);\n \t  else\n-\t    output_asm_insn (\"addq%.l %#4,%0\", &addreg1);\n+\t    output_asm_insn (\"addq%.l #4,%0\", &addreg1);\n \t}\n \n       /* Do that word.  */\n       output_asm_insn (singlemove_string (latehalf), latehalf);\n \n       /* Undo the adds we just did.  */\n       if (addreg0)\n-\toutput_asm_insn (\"subq%.l %#4,%0\", &addreg0);\n+\toutput_asm_insn (\"subq%.l #4,%0\", &addreg0);\n       if (addreg1)\n-\toutput_asm_insn (\"subq%.l %#4,%0\", &addreg1);\n+\toutput_asm_insn (\"subq%.l #4,%0\", &addreg1);\n \n       if (size == 12)\n \t{\n \t  output_asm_insn (singlemove_string (middlehalf), middlehalf);\n \t  if (addreg0)\n-\t    output_asm_insn (\"subq%.l %#4,%0\", &addreg0);\n+\t    output_asm_insn (\"subq%.l #4,%0\", &addreg0);\n \t  if (addreg1)\n-\t    output_asm_insn (\"subq%.l %#4,%0\", &addreg1);\n+\t    output_asm_insn (\"subq%.l #4,%0\", &addreg1);\n \t}\n \n       /* Do low-numbered word.  */\n@@ -2235,18 +2202,18 @@ output_move_double (rtx *operands)\n   if (size == 12)\n     {\n       if (addreg0)\n-\toutput_asm_insn (\"addq%.l %#4,%0\", &addreg0);\n+\toutput_asm_insn (\"addq%.l #4,%0\", &addreg0);\n       if (addreg1)\n-\toutput_asm_insn (\"addq%.l %#4,%0\", &addreg1);\n+\toutput_asm_insn (\"addq%.l #4,%0\", &addreg1);\n \n       output_asm_insn (singlemove_string (middlehalf), middlehalf);\n     }\n \n   /* Make any unoffsettable addresses point at high-numbered word.  */\n   if (addreg0)\n-    output_asm_insn (\"addq%.l %#4,%0\", &addreg0);\n+    output_asm_insn (\"addq%.l #4,%0\", &addreg0);\n   if (addreg1)\n-    output_asm_insn (\"addq%.l %#4,%0\", &addreg1);\n+    output_asm_insn (\"addq%.l #4,%0\", &addreg1);\n \n   /* Do that word.  */\n   output_asm_insn (singlemove_string (latehalf), latehalf);\n@@ -2255,16 +2222,16 @@ output_move_double (rtx *operands)\n   if (addreg0)\n     {\n       if (size == 12)\n-        output_asm_insn (\"subq%.l %#8,%0\", &addreg0);\n+        output_asm_insn (\"subq%.l #8,%0\", &addreg0);\n       else\n-        output_asm_insn (\"subq%.l %#4,%0\", &addreg0);\n+        output_asm_insn (\"subq%.l #4,%0\", &addreg0);\n     }\n   if (addreg1)\n     {\n       if (size == 12)\n-        output_asm_insn (\"subq%.l %#8,%0\", &addreg1);\n+        output_asm_insn (\"subq%.l #8,%0\", &addreg1);\n       else\n-        output_asm_insn (\"subq%.l %#4,%0\", &addreg1);\n+        output_asm_insn (\"subq%.l #4,%0\", &addreg1);\n     }\n \n   return \"\";\n@@ -2314,27 +2281,9 @@ output_addsi3 (rtx *operands)\n       if (GET_CODE (operands[2]) == CONST_INT\n \t  && (INTVAL (operands[2]) < -32768 || INTVAL (operands[2]) > 32767))\n         return \"move%.l %2,%0\\n\\tadd%.l %1,%0\";\n-#ifdef SGS\n       if (GET_CODE (operands[2]) == REG)\n-\treturn \"lea 0(%1,%2.l),%0\";\n-      else\n-\treturn \"lea %c2(%1),%0\";\n-#else /* !SGS */\n-      if (MOTOROLA)\n-\t{\n-\t  if (GET_CODE (operands[2]) == REG)\n-\t   return \"lea (%1,%2.l),%0\";\n-\t  else\n-\t   return \"lea (%c2,%1),%0\";\n-\t}\n-      else /* !MOTOROLA (MIT syntax) */\n-\t{\n-\t  if (GET_CODE (operands[2]) == REG)\n-\t    return \"lea %1@(0,%2:l),%0\";\n-\t  else\n-\t    return \"lea %1@(%c2),%0\";\n-\t}\n-#endif /* !SGS */\n+\treturn MOTOROLA ? \"lea (%1,%2.l),%0\" : \"lea %1@(0,%2:l),%0\";\n+      return MOTOROLA ? \"lea (%c2,%1),%0\" : \"lea %1@(%c2),%0\";\n     }\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n@@ -2356,13 +2305,13 @@ output_addsi3 (rtx *operands)\n \t      && INTVAL (operands[2]) <= 16)\n \t    {\n \t      operands[2] = GEN_INT (INTVAL (operands[2]) - 8);\n-\t      return \"addq%.l %#8,%0\\n\\taddq%.l %2,%0\";\n+\t      return \"addq%.l #8,%0\\n\\taddq%.l %2,%0\";\n \t    }\n \t  if (INTVAL (operands[2]) < -8\n \t      && INTVAL (operands[2]) >= -16)\n \t    {\n \t      operands[2] = GEN_INT (- INTVAL (operands[2]) - 8);\n-\t      return \"subq%.l %#8,%0\\n\\tsubq%.l %2,%0\";\n+\t      return \"subq%.l #8,%0\\n\\tsubq%.l %2,%0\";\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0])\n@@ -2496,7 +2445,7 @@ output_move_const_double (rtx *operands)\n     {\n       static char buf[40];\n \n-      sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n+      sprintf (buf, \"fmovecr #0x%x,%%0\", code & 0xff);\n       return buf;\n     }\n   return \"fmove%.d %1,%0\";\n@@ -2511,7 +2460,7 @@ output_move_const_single (rtx *operands)\n     {\n       static char buf[40];\n \n-      sprintf (buf, \"fmovecr %%#0x%x,%%0\", code & 0xff);\n+      sprintf (buf, \"fmovecr #0x%x,%%0\", code & 0xff);\n       return buf;\n     }\n   return \"fmove%.s %f1,%0\";\n@@ -2791,20 +2740,13 @@ print_operand (FILE *file, rtx op, int letter)\n    offset is output in word mode (eg movel a5@(_foo:w), a0).  When generating\n    -fPIC code the offset is output in long mode (eg movel a5@(_foo:l), a0) */\n \n-#ifndef ASM_OUTPUT_CASE_FETCH\n-# if MOTOROLA\n-#  ifdef SGS\n-#   define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n-\tasm_fprintf (file, \"%LLD%d(%Rpc,%s.\", labelno, regname)\n-#  else /* !SGS */\n-#   define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n-\tasm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.\", labelno, labelno, regname)\n-#  endif /* !SGS */\n-# else /* !MOTOROLA */\n+#if MOTOROLA\n #  define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n+\tasm_fprintf (file, \"%LL%d-%LLI%d.b(%Rpc,%s.\", labelno, labelno, regname)\n+#else /* !MOTOROLA */\n+# define ASM_OUTPUT_CASE_FETCH(file, labelno, regname)\\\n \tasm_fprintf (file, \"%Rpc@(%LL%d-%LLI%d-2:b,%s:\", labelno, labelno, regname)\n-# endif /* !MOTOROLA */\n-#endif /* ASM_OUTPUT_CASE_FETCH */\n+#endif /* !MOTOROLA */\n \n void\n print_operand_address (FILE *file, rtx addr)\n@@ -3034,15 +2976,7 @@ print_operand_address (FILE *file, rtx addr)\n \t    && INTVAL (addr) < 0x8000\n \t    && INTVAL (addr) >= -0x8000)\n \t  {\n-\t    if (MOTOROLA)\n-#ifdef SGS\n-\t      /* Many SGS assemblers croak on size specifiers for constants.  */\n-\t      fprintf (file, \"%d\", (int) INTVAL (addr));\n-#else\n-\t      fprintf (file, \"%d.w\", (int) INTVAL (addr));\n-#endif\n-\t    else /* !MOTOROLA */\n-\t      fprintf (file, \"%d:w\", (int) INTVAL (addr));\n+\t    fprintf (file, MOTOROLA ? \"%d.w\" : \"%d:w\", (int) INTVAL (addr));\n \t  }\n \telse if (GET_CODE (addr) == CONST_INT)\n \t  {"}, {"sha": "f4d83390a3c14fcc88dadb6943e8e05ca8d7df68", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -1629,8 +1629,6 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n        sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n    '@' for a reference to the top word on the stack:\n        sp@, (sp) or (%sp) depending on the style of syntax.\n-   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n-       but & in SGS syntax).\n    '!' for the fpcr register (used in some float-to-fixed conversions).\n    '$' for the letter `s' in an op code, but only on the 68040.\n    '&' for the letter `d' in an op code, but only on the 68040.\n@@ -1645,9 +1643,8 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n        or print pair of registers as rx:ry.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n-   || (CODE) == '+' || (CODE) == '@' || (CODE) == '!'\t\t\t\\\n-   || (CODE) == '$' || (CODE) == '&' || (CODE) == '/')\n+  ((CODE) == '.' || (CODE) == '-' || (CODE) == '+' || (CODE) == '@'\t\\\n+   || (CODE) == '!' || (CODE) == '$' || (CODE) == '&' || (CODE) == '/')\n \n /* A C compound statement to output to stdio stream STREAM the\n    assembler syntax for an instruction operand X.  X is an RTL"}, {"sha": "f7c396c4bc7f04042ff876733ac68e68f2380f4a", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 104, "deletions": 307, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -69,7 +69,6 @@\n \n ;;- Assembler specs:\n ;;- \"%.\"    size separator (\".\" or \"\")\t\t\tmove%.l d0,d1\n-;;- \"%#\"    immediate separator (\"#\" or \"\")\t\tmove%.l %#0,d0\n ;;- \"%-\"    push operand \"sp@-\"\t\t\t\tmove%.l d0,%-\n ;;- \"%+\"    pop operand \"sp@+\"\t\t\t\tmove%.l d0,%+\n ;;- \"%@\"    top of stack \"sp@\"\t\t\t\tmove%.l d0,%@\n@@ -201,11 +200,7 @@\n   /* If you think that the 68020 does not support tstl a0,\n      reread page B-167 of the 68020 manual more carefully.  */\n   /* On an address reg, cmpw may replace cmpl.  */\n-#ifdef SGS_CMP_ORDER\n-  return \"cmp%.w %0,%#0\";\n-#else\n-  return \"cmp%.w %#0,%0\";\n-#endif\n+  return \"cmp%.w #0,%0\";\n })\n \n ;; This can't use an address register, because comparisons\n@@ -330,36 +325,19 @@\n   \"!TARGET_COLDFIRE\"\n {\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-#ifdef SGS_CMP_ORDER\n-    return \"cmpm%.l %0,%1\";\n-#else\n     return \"cmpm%.l %1,%0\";\n-#endif\n   if (REG_P (operands[1])\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    { cc_status.flags |= CC_REVERSED;\n-#ifdef SGS_CMP_ORDER\n-      return \"cmp%.l %d1,%d0\";\n-#else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n       return \"cmp%.l %d0,%d1\";\n-#endif\n     }\n   if (ADDRESS_REG_P (operands[0])\n       && GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) < 0x8000\n       && INTVAL (operands[1]) >= -0x8000)\n-    {\n-#ifdef SGS_CMP_ORDER\n-      return \"cmp%.w %0,%1\";\n-#else\n-      return \"cmp%.w %1,%0\";\n-#endif\n-    }\n-#ifdef SGS_CMP_ORDER\n-  return \"cmp%.l %d0,%d1\";\n-#else\n+    return \"cmp%.w %1,%0\";\n   return \"cmp%.l %d1,%d0\";\n-#endif\n })\n \n (define_insn \"\"\n@@ -370,18 +348,11 @@\n {\n   if (REG_P (operands[1])\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    { cc_status.flags |= CC_REVERSED;\n-#ifdef SGS_CMP_ORDER\n-      return \"cmp%.l %d1,%d0\";\n-#else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n       return \"cmp%.l %d0,%d1\";\n-#endif\n     }\n-#ifdef SGS_CMP_ORDER\n-  return \"cmp%.l %d0,%d1\";\n-#else\n   return \"cmp%.l %d1,%d0\";\n-#endif\n })\n \n (define_expand \"cmphi\"\n@@ -398,25 +369,14 @@\n   \"!TARGET_COLDFIRE\"\n {\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-#ifdef SGS_CMP_ORDER\n-    return \"cmpm%.w %0,%1\";\n-#else\n     return \"cmpm%.w %1,%0\";\n-#endif\n   if ((REG_P (operands[1]) && !ADDRESS_REG_P (operands[1]))\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    { cc_status.flags |= CC_REVERSED;\n-#ifdef SGS_CMP_ORDER\n-      return \"cmp%.w %d1,%d0\";\n-#else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n       return \"cmp%.w %d0,%d1\";\n-#endif\n     }\n-#ifdef SGS_CMP_ORDER\n-  return \"cmp%.w %d0,%d1\";\n-#else\n   return \"cmp%.w %d1,%d0\";\n-#endif\n })\n \n (define_expand \"cmpqi\"\n@@ -433,25 +393,14 @@\n   \"!TARGET_COLDFIRE\"\n {\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-#ifdef SGS_CMP_ORDER\n-    return \"cmpm%.b %0,%1\";\n-#else\n     return \"cmpm%.b %1,%0\";\n-#endif\n   if (REG_P (operands[1])\n       || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    { cc_status.flags |= CC_REVERSED;\n-#ifdef SGS_CMP_ORDER\n-      return \"cmp%.b %d1,%d0\";\n-#else\n+    {\n+      cc_status.flags |= CC_REVERSED;\n       return \"cmp%.b %d0,%d1\";\n-#endif\n     }\n-#ifdef SGS_CMP_ORDER\n-  return \"cmp%.b %d0,%d1\";\n-#else\n   return \"cmp%.b %d1,%d0\";\n-#endif\n })\n \n (define_expand \"cmpdf\"\n@@ -471,17 +420,6 @@\n   \"TARGET_68881\"\n {\n   cc_status.flags = CC_IN_68881;\n-#ifdef SGS_CMP_ORDER\n-  if (REG_P (operands[0]))\n-    {\n-      if (REG_P (operands[1]))\n-\treturn \"fcmp%.x %0,%1\";\n-      else\n-        return \"fcmp%.d %0,%f1\";\n-    }\n-  cc_status.flags |= CC_REVERSED;\n-  return \"fcmp%.d %1,%f0\";\n-#else\n   if (REG_P (operands[0]))\n     {\n       if (REG_P (operands[1]))\n@@ -491,7 +429,6 @@\n     }\n   cc_status.flags |= CC_REVERSED;\n   return \"fcmp%.d %f0,%1\";\n-#endif\n })\n \n (define_expand \"cmpsf\"\n@@ -511,17 +448,6 @@\n   \"TARGET_68881\"\n {\n   cc_status.flags = CC_IN_68881;\n-#ifdef SGS_CMP_ORDER\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \"fcmp%.x %0,%1\";\n-      else\n-        return \"fcmp%.s %0,%f1\";\n-    }\n-  cc_status.flags |= CC_REVERSED;\n-  return \"fcmp%.s %1,%f0\";\n-#else\n   if (FP_REG_P (operands[0]))\n     {\n       if (FP_REG_P (operands[1]))\n@@ -531,7 +457,6 @@\n     }\n   cc_status.flags |= CC_REVERSED;\n   return \"fcmp%.s %f0,%1\";\n-#endif\n })\n \f\n ;; Recognizers for btst instructions.\n@@ -691,18 +616,11 @@\n       if (!TARGET_68040 && !TARGET_68060)\n \treturn \"sub%.l %0,%0\";\n       else\n-\treturn MOTOROLA ?\n-#ifdef SGS\n-\t  /* Many SGS assemblers croak on size specifiers for constants.  */\n-\t  \"lea 0,%0\" :\n-#else\n-\t  \"lea 0.w,%0\" :\n-#endif\n-\t  \"lea 0:w,%0\";\n+\treturn MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n     }\n   /* moveq is faster on the 68000.  */\n   if (DATA_REG_P (operands[0]) && (!TARGET_68020 && !TARGET_COLDFIRE))\n-    return \"moveq %#0,%0\";\n+    return \"moveq #0,%0\";\n   return \"clr%.l %0\";\n })\n \n@@ -893,19 +811,12 @@\n \t  if (!TARGET_68040 && !TARGET_68060)\n \t    return \"sub%.l %0,%0\";\n \t  else\n-\t    return MOTOROLA ?\n-#ifdef SGS\n-\t      /* Many SGS assemblers croak on size specifiers for constants.  */\n-\t      \"lea 0,%0\" :\n-#else\n-\t      \"lea 0.w,%0\" :\n-#endif\n-\t      \"lea 0:w,%0\";\n+\t    return MOTOROLA ? \"lea 0.w,%0\" : \"lea 0:w,%0\";\n \t}\n       /* moveq is faster on the 68000.  */\n       if (DATA_REG_P (operands[0]) && !(TARGET_68020 || TARGET_COLDFIRE))\n \t{\n-\t  return \"moveq %#0,%0\";\n+\t  return \"moveq #0,%0\";\n \t}\n       return \"clr%.l %0\";\n     }\n@@ -1225,7 +1136,7 @@\n {\n   CC_STATUS_INIT;\n   operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  return \"moveq %#0,%0\\;moveq %#0,%2\\;move%.b %1,%2\";\n+  return \"moveq #0,%0\\;moveq #0,%2\\;move%.b %1,%2\";\n })\n \n (define_insn \"zero_extendhidi2\"\n@@ -1235,7 +1146,7 @@\n {\n   CC_STATUS_INIT;\n   operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  return \"moveq %#0,%0\\;moveq %#0,%2\\;move%.w %1,%2\";\n+  return \"moveq #0,%0\\;moveq #0,%2\\;move%.w %1,%2\";\n })\n \n ;; this is the canonical form for (lshiftrt:DI x 32)\n@@ -1341,9 +1252,9 @@\n     {\n       if (GET_CODE (operands[1]) == REG\n \t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \"and%.l %#0xFFFF,%0\";\n+\treturn \"and%.l #0xFFFF,%0\";\n       if (reg_mentioned_p (operands[0], operands[1]))\n-        return \"move%.w %1,%0\\;and%.l %#0xFFFF,%0\";\n+        return \"move%.w %1,%0\\;and%.l #0xFFFF,%0\";\n       return \"clr%.l %0\\;move%.w %1,%0\";\n     }\n   else if (GET_CODE (operands[0]) == MEM\n@@ -1369,10 +1280,10 @@\n     {\n       if (GET_CODE (operands[1]) == REG\n \t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn (!TARGET_COLDFIRE ? \"and%.w %#0xFF,%0\" : \"and%.l %#0xFF,%0\");\n+\treturn (!TARGET_COLDFIRE ? \"and%.w #0xFF,%0\" : \"and%.l #0xFF,%0\");\n       if (reg_mentioned_p (operands[0], operands[1]))\n-\treturn (!TARGET_COLDFIRE ? \"move%.b %1,%0\\;and%.w %#0xFF,%0\" \n-\t\t\t     : \"move%.b %1,%0\\;and%.l %#0xFF,%0\");\n+\treturn (!TARGET_COLDFIRE ? \"move%.b %1,%0\\;and%.w #0xFF,%0\" \n+\t\t\t     : \"move%.b %1,%0\\;and%.l #0xFF,%0\");\n       return \"clr%.w %0\\;move%.b %1,%0\";\n     }\n   else if (GET_CODE (operands[0]) == MEM\n@@ -1409,33 +1320,25 @@\n     {\n       if (GET_CODE (operands[1]) == REG\n \t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \"and%.l %#0xFF,%0\";\n+\treturn \"and%.l #0xFF,%0\";\n       if (reg_mentioned_p (operands[0], operands[1]))\n-        return \"move%.b %1,%0\\;and%.l %#0xFF,%0\";\n+        return \"move%.b %1,%0\\;and%.l #0xFF,%0\";\n       return \"clr%.l %0\\;move%.b %1,%0\";\n     }\n   else if (GET_CODE (operands[0]) == MEM\n \t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       return MOTOROLA ?\n-#ifdef SGS\n-\t\"clr%.l -(%0)\\;move%.b %1,3(%0)\" :\n-#else\n \t\"clr%.l -(%0)\\;move%.b %1,(3,%0)\" :\n-#endif\n \t\"clrl %0@-\\;moveb %1,%0@(3)\";\n     }\n   else if (GET_CODE (operands[0]) == MEM\n \t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n     {\n       operands[0] = XEXP (XEXP (operands[0], 0), 0);\n       return MOTOROLA ?\n-#ifdef SGS\n-\t\"clr%.l (%0)+\\;move%.b %1,-1(%0)\" :\n-#else\n \t\"clr%.l (%0)+\\;move%.b %1,(-1,%0)\" :\n-#endif\n \t\"clrl %0@+\\;moveb %1,%0@(-1)\";\n     }\n   else\n@@ -1678,7 +1581,7 @@\n   \"TARGET_68881 && TARGET_68040\"\n {\n   CC_STATUS_INIT;\n-  return \"fmovem%.l %!,%2\\;moveq %#16,%3\\;or%.l %2,%3\\;and%.w %#-33,%3\\;fmovem%.l %3,%!\\;fmove%.l %1,%0\\;fmovem%.l %2,%!\";\n+  return \"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.l %1,%0\\;fmovem%.l %2,%!\";\n })\n \n (define_insn \"fix_truncdfhi2\"\n@@ -1689,7 +1592,7 @@\n   \"TARGET_68881 && TARGET_68040\"\n {\n   CC_STATUS_INIT;\n-  return \"fmovem%.l %!,%2\\;moveq %#16,%3\\;or%.l %2,%3\\;and%.w %#-33,%3\\;fmovem%.l %3,%!\\;fmove%.w %1,%0\\;fmovem%.l %2,%!\";\n+  return \"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.w %1,%0\\;fmovem%.l %2,%!\";\n })\n \n (define_insn \"fix_truncdfqi2\"\n@@ -1700,7 +1603,7 @@\n   \"TARGET_68881 && TARGET_68040\"\n {\n   CC_STATUS_INIT;\n-  return \"fmovem%.l %!,%2\\;moveq %#16,%3\\;or%.l %2,%3\\;and%.w %#-33,%3\\;fmovem%.l %3,%!\\;fmove%.b %1,%0\\;fmovem%.l %2,%!\";\n+  return \"fmovem%.l %!,%2\\;moveq #16,%3\\;or%.l %2,%3\\;and%.w #-33,%3\\;fmovem%.l %3,%!\\;fmove%.b %1,%0\\;fmovem%.l %2,%!\";\n })\n \n ;; Convert a float to a float whose value is an integer.\n@@ -1952,7 +1855,7 @@\n     }\n   output_asm_insn (\"move%.l %1,%0\", operands);\n   output_asm_insn (MOTOROLA ? \"jbpl %l3\" : \"jpl %l3\", operands);\n-  output_asm_insn (\"addq%.l %#1,%2\", operands);\n+  output_asm_insn (\"addq%.l #1,%2\", operands);\n   (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n \t\t\t\tCODE_LABEL_NUMBER (operands[3]));\n   return \"\";\n@@ -2027,13 +1930,13 @@\n \t      && INTVAL (operands[2]) <= 16)\n \t    {\n \t      operands[2] = GEN_INT (INTVAL (operands[2]) - 8);\n-\t      return \"addq%.w %#8,%0\\;addq%.w %2,%0\";\n+\t      return \"addq%.w #8,%0\\;addq%.w %2,%0\";\n \t    }\n \t  if (INTVAL (operands[2]) < -8\n \t      && INTVAL (operands[2]) >= -16)\n \t    {\n \t      operands[2] = GEN_INT (- INTVAL (operands[2]) - 8);\n-\t      return \"subq%.w %#8,%0\\;subq%.w %2,%0\";\n+\t      return \"subq%.w #8,%0\\;subq%.w %2,%0\";\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n@@ -2082,13 +1985,13 @@\n \t      && INTVAL (operands[1]) <= 16)\n \t    {\n \t      operands[1] = GEN_INT (INTVAL (operands[1]) - 8);\n-\t      return \"addq%.w %#8,%0\\;addq%.w %1,%0\";\n+\t      return \"addq%.w #8,%0\\;addq%.w %1,%0\";\n \t    }\n \t  if (INTVAL (operands[1]) < -8\n \t      && INTVAL (operands[1]) >= -16)\n \t    {\n \t      operands[1] = GEN_INT (- INTVAL (operands[1]) - 8);\n-\t      return \"subq%.w %#8,%0\\;subq%.w %1,%0\";\n+\t      return \"subq%.w #8,%0\\;subq%.w %1,%0\";\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n@@ -2131,13 +2034,13 @@\n \t      && INTVAL (operands[1]) <= 16)\n \t    {\n \t      operands[1] = GEN_INT (INTVAL (operands[1]) - 8);\n-\t      return \"addq%.w %#8,%0\\;addq%.w %1,%0\";\n+\t      return \"addq%.w #8,%0\\;addq%.w %1,%0\";\n \t    }\n \t  if (INTVAL (operands[1]) < -8\n \t      && INTVAL (operands[1]) >= -16)\n \t    {\n \t      operands[1] = GEN_INT (- INTVAL (operands[1]) - 8);\n-\t      return \"subq%.w %#8,%0\\;subq%.w %1,%0\";\n+\t      return \"subq%.w #8,%0\\;subq%.w %1,%0\";\n \t    }\n \t}\n       if (ADDRESS_REG_P (operands[0]) && !TARGET_68040)\n@@ -3083,8 +2986,8 @@\n   \"!TARGET_COLDFIRE || TARGET_CF_HWDIV\"\n {\n   output_asm_insn (MOTOROLA ?\n-    \"and%.l %#0xFFFF,%0\\;divu%.w %2,%0\" :\n-    \"and%.l %#0xFFFF,%0\\;divu %2,%0\",\n+    \"and%.l #0xFFFF,%0\\;divu%.w %2,%0\" :\n+    \"and%.l #0xFFFF,%0\\;divu %2,%0\",\n     operands);\n   if (!find_reg_note(insn, REG_UNUSED, operands[3]))\n     {\n@@ -3281,7 +3184,7 @@\n \t  case -1 :\n \t    /* FIXME : a scratch register would be welcome here if operand[0]\n \t       is not a register */\n-\t    output_asm_insn (\"move%.l %#-1,%0\", operands);\n+\t    output_asm_insn (\"move%.l #-1,%0\", operands);\n \t    break;\n \t  default :\n \t    {\n@@ -3303,7 +3206,7 @@\n \t  case -1 :\n \t    /* FIXME : a scratch register would be welcome here if operand[0]\n \t       is not a register */\n-\t    output_asm_insn (\"move%.l %#-1,%0\", operands);\n+\t    output_asm_insn (\"move%.l #-1,%0\", operands);\n \t    break;\n \t  default :\n \t    {\n@@ -4019,7 +3922,7 @@\n   if (INTVAL (operands[2]) == 1)\n     return \"add%.l %1,%1\\;addx%.l %0,%0\";\n   else if (INTVAL (operands[2]) == 8)\n-    return \"rol%.l %#8,%1\\;rol%.l %#8,%0\\;move%.b %1,%0\\;clr%.b %1\";\n+    return \"rol%.l #8,%1\\;rol%.l #8,%0\\;move%.b %1,%0\\;clr%.b %1\";\n   else if (INTVAL (operands[2]) == 16)\n     return \"swap %1\\;swap %0\\;move%.w %1,%0\\;clr%.w %1\";\n   else if (INTVAL (operands[2]) == 48)\n@@ -4033,7 +3936,7 @@\n       operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n       output_asm_insn (INTVAL (operands[2]) <= 8 ? \"asl%.l %2,%1\" :\n \t\t\t\"moveq %2,%0\\;asl%.l %0,%1\", operands);\n-      return \"mov%.l %1,%0\\;moveq %#0,%1\";\n+      return \"mov%.l %1,%0\\;moveq #0,%1\";\n     }\n })\n \n@@ -4215,19 +4118,19 @@\n     return \"add%.l %0,%0\\;subx%.l %0,%0\\;move%.l %0,%1\";\n   CC_STATUS_INIT;\n   if (INTVAL (operands[2]) == 1)\n-    return \"asr%.l %#1,%0\\;roxr%.l %#1,%1\";\n+    return \"asr%.l #1,%0\\;roxr%.l #1,%1\";\n   else if (INTVAL (operands[2]) == 8)\n-    return \"move%.b %0,%1\\;asr%.l %#8,%0\\;ror%.l %#8,%1\";\n+    return \"move%.b %0,%1\\;asr%.l #8,%0\\;ror%.l #8,%1\";\n   else if (INTVAL (operands[2]) == 16)\n     return \"move%.w %0,%1\\;swap %0\\;ext%.l %0\\;swap %1\";\n   else if (INTVAL (operands[2]) == 48)\n     return \"swap %0\\;ext%.l %0\\;move%.l %0,%1\\;smi %0\\;ext%.w %0\";\n   else if (INTVAL (operands[2]) == 31)\n     return \"add%.l %1,%1\\;addx%.l %0,%0\\;move%.l %0,%1\\;subx%.l %0,%0\";\n   else if (INTVAL (operands[2]) == 2)\n-    return \"asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\";\n+    return \"asr%.l #1,%0\\;roxr%.l #1,%1\\;asr%.l #1,%0\\;roxr%.l #1,%1\";\n   else if (INTVAL (operands[2]) == 3)\n-    return \"asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\\;asr%.l %#1,%0\\;roxr%.l %#1,%1\";\n+    return \"asr%.l #1,%0\\;roxr%.l #1,%1\\;asr%.l #1,%0\\;roxr%.l #1,%1\\;asr%.l #1,%0\\;roxr%.l #1,%1\";\n   else /* 32 < INTVAL (operands[2]) <= 63 */\n     {\n       operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n@@ -4381,23 +4284,23 @@\n     return \"add%.l %0,%0\\;clr%.l %0\\;clr%.l %1\\;addx%.l %1,%1\";\n   CC_STATUS_INIT;\n   if (INTVAL (operands[2]) == 1)\n-    return \"lsr%.l %#1,%0\\;roxr%.l %#1,%1\";\n+    return \"lsr%.l #1,%0\\;roxr%.l #1,%1\";\n   else if (INTVAL (operands[2]) == 8)\n-    return \"move%.b %0,%1\\;lsr%.l %#8,%0\\;ror%.l %#8,%1\";\n+    return \"move%.b %0,%1\\;lsr%.l #8,%0\\;ror%.l #8,%1\";\n   else if (INTVAL (operands[2]) == 16)\n     return \"move%.w %0,%1\\;clr%.w %0\\;swap %1\\;swap %0\";\n   else if (INTVAL (operands[2]) == 48)\n     return \"move%.l %0,%1\\;clr%.w %1\\;clr%.l %0\\;swap %1\";\n   else if (INTVAL (operands[2]) == 2)\n-    return \"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\";\n+    return \"lsr%.l #1,%0\\;roxr%.l #1,%1\\;lsr%.l #1,%0\\;roxr%.l #1,%1\";\n   else if (INTVAL (operands[2]) == 3)\n-    return \"lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\\;lsr%.l %#1,%0\\;roxr%.l %#1,%1\";\n+    return \"lsr%.l #1,%0\\;roxr%.l #1,%1\\;lsr%.l #1,%0\\;roxr%.l #1,%1\\;lsr%.l #1,%0\\;roxr%.l #1,%1\";\n   else /* 32 < INTVAL (operands[2]) <= 63 */\n     {\n       operands[2] = GEN_INT (INTVAL (operands[2]) - 32);\n       output_asm_insn (INTVAL (operands[2]) <= 8 ? \"lsr%.l %2,%0\" :\n \t\t\t\"moveq %2,%1\\;lsr%.l %1,%0\", operands);\n-      return \"mov%.l %0,%1\\;moveq %#0,%0\";\n+      return \"mov%.l %0,%1\\;moveq #0,%0\";\n     }\n })\n \n@@ -5527,13 +5430,9 @@\n   else\n     {\n       if (MOTOROLA)\n-#ifdef SGS_CMP_ORDER\n-\toutput_asm_insn (\"cmp%.w %0,%#0\\;jbne %l4\\;cmp%.w %3,%#0\\;jbeq %l1\", operands);\n-#else\n-\toutput_asm_insn (\"cmp%.w %#0,%0\\;jbne %l4\\;cmp%.w %#0,%3\\;jbeq %l1\", operands);\n-#endif\n+\toutput_asm_insn (\"cmp%.w #0,%0\\;jbne %l4\\;cmp%.w #0,%3\\;jbeq %l1\", operands);\n       else\n-\toutput_asm_insn (\"cmp%.w %#0,%0\\;jne %l4\\;cmp%.w %#0,%3\\;jeq %l1\", operands);\n+\toutput_asm_insn (\"cmp%.w #0,%0\\;jne %l4\\;cmp%.w #0,%3\\;jeq %l1\", operands);\n     }\n   (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n \t\t\t\tCODE_LABEL_NUMBER (operands[4]));\n@@ -5596,13 +5495,9 @@\n   else\n     {\n       if (MOTOROLA)\n-#ifdef SGS_CMP_ORDER\n-\treturn \"cmp%.w %0,%#0\\;jbne %l1\\;cmp%.w %3,%#0\\;jbne %l1\";\n-#else\n-\treturn \"cmp%.w %#0,%0\\;jbne %l1\\;cmp%.w %#0,%3\\;jbne %l1\";\n-#endif\n+\treturn \"cmp%.w #0,%0\\;jbne %l1\\;cmp%.w #0,%3\\;jbne %l1\";\n       else\n-\treturn \"cmp%.w %#0,%0\\;jne %l1\\;cmp%.w %#0,%3\\;jne %l1\";\n+\treturn \"cmp%.w #0,%0\\;jne %l1\\;cmp%.w #0,%3\\;jne %l1\";\n     }\n })\n \n@@ -5635,13 +5530,8 @@\n   else\n     {\n       /* On an address reg, cmpw may replace cmpl.  */\n-#ifdef SGS_CMP_ORDER\n-      output_asm_insn(\"cmp%.w %0,%#0\", operands);\n-#else\n-      output_asm_insn(\"cmp%.w %#0,%0\", operands);\n-#endif\n+      output_asm_insn(\"cmp%.w #0,%0\", operands);\n     }\n-\n   return MOTOROLA ? \"jbpl %l1\" : \"jpl %l1\";\n })\n \n@@ -5674,11 +5564,7 @@\n   else\n     {\n       /* On an address reg, cmpw may replace cmpl.  */\n-#ifdef SGS_CMP_ORDER\n-      output_asm_insn(\"cmp%.w %0,%#0\", operands);\n-#else\n-      output_asm_insn(\"cmp%.w %#0,%0\", operands);\n-#endif\n+      output_asm_insn(\"cmp%.w #0,%0\", operands);\n     }\n \n   return MOTOROLA ? \"jbmi %l1\" : \"jmi %l1\";\n@@ -6163,45 +6049,17 @@\n #ifdef ASM_RETURN_CASE_JUMP\n   ASM_RETURN_CASE_JUMP;\n #else\n-#ifdef SGS\n-#ifdef ASM_OUTPUT_CASE_LABEL\n-  if (TARGET_COLDFIRE) \n-    {\n-      if (ADDRESS_REG_P (operands[0]))\n-\treturn \"jmp 6(%%pc,%0.l)\";\n-      else\n-\treturn \"ext%.l %0\\;jmp 6(%%pc,%0.l)\";\n-    }\n-  else\n-    return \"jmp 6(%%pc,%0.w)\";\n-#else\n-  if (TARGET_COLDFIRE)\n-    {\n-      if (ADDRESS_REG_P (operands[0]))\n-\treturn \"jmp 2(%%pc,%0.l)\";\n-      else\n-\treturn \"extl %0\\;jmp 2(%%pc,%0.l)\";\n-    }\n-  else\n-    return \"jmp 2(%%pc,%0.w)\";\n-#endif\n-#else /* not SGS */\n   if (TARGET_COLDFIRE)\n     {\n       if (ADDRESS_REG_P (operands[0]))\n-\t{\n-\t  return MOTOROLA ? \"jmp (2,pc,%0.l)\" : \"jmp pc@(2,%0:l)\";\n-\t}\n+\treturn MOTOROLA ? \"jmp (2,pc,%0.l)\" : \"jmp pc@(2,%0:l)\";\n       else if (MOTOROLA)\n \treturn \"ext%.l %0\\;jmp (2,pc,%0.l)\";\n       else\n \treturn \"extl %0\\;jmp pc@(2,%0:l)\";\n     }\n   else\n-    {\n-      return MOTOROLA ? \"jmp (2,pc,%0.w)\" : \"jmp pc@(2,%0:w)\";\n-    }\n-#endif\n+    return MOTOROLA ? \"jmp (2,pc,%0.w)\" : \"jmp pc@(2,%0:w)\";\n #endif\n })\n \n@@ -6222,20 +6080,12 @@\n   if (DATA_REG_P (operands[0]))\n     return \"dbra %0,%l1\";\n   if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (MOTOROLA)\n-\treturn \"subq%.w %#1,%0\\;jbcc %l1\";\n-      else\n-\treturn \"subqw %#1,%0\\;jcc %l1\";\n-    }\n-  if (MOTOROLA)\n-#ifdef SGS_CMP_ORDER\n-    return \"subq%.w %#1,%0\\;cmp%.w %0,%#-1\\;jbne %l1\";\n-#else /* not SGS_CMP_ORDER */\n-    return \"subq%.w %#1,%0\\;cmp%.w %#-1,%0\\;jbne %l1\";\n-#endif\n-  else\n-    return \"subqw %#1,%0\\;cmpw %#-1,%0\\;jne %l1\";\n+    return MOTOROLA ?\n+      \"subq%.w #1,%0\\;jbcc %l1\" :\n+      \"subqw #1,%0\\;jcc %l1\";\n+  return MOTOROLA ?\n+    \"subq%.w #1,%0\\;cmp%.w #-1,%0\\;jbne %l1\" :\n+    \"subqw #1,%0\\;cmpw #-1,%0\\;jne %l1\";\n })\n \n (define_insn \"\"\n@@ -6251,26 +6101,17 @@\n   \"!TARGET_COLDFIRE\"\n {\n   CC_STATUS_INIT;\n-  if (MOTOROLA)\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        return \"dbra %0,%l1\\;clr%.w %0\\;subq%.l %#1,%0\\;jbcc %l1\";\n-      if (GET_CODE (operands[0]) == MEM)\n-        return \"subq%.l %#1,%0\\;jbcc %l1\";\n-#ifdef SGS_CMP_ORDER\n-      return \"subq.l %#1,%0\\;cmp.l %0,%#-1\\;jbne %l1\";\n-#else /* not SGS_CMP_ORDER */\n-      return \"subq.l %#1,%0\\;cmp.l %#-1,%0\\;jbne %l1\";\n-#endif /* not SGS_CMP_ORDER */\n-    }\n-  else\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        return \"dbra %0,%l1\\;clr%.w %0\\;subql %#1,%0\\;jcc %l1\";\n-      if (GET_CODE (operands[0]) == MEM)\n-        return \"subql %#1,%0\\;jcc %l1\";\n-      return \"subql %#1,%0\\;cmpl %#-1,%0\\;jne %l1\";\n-    }\n+  if (DATA_REG_P (operands[0]))\n+    return MOTOROLA ?\n+      \"dbra %0,%l1\\;clr%.w %0\\;subq%.l #1,%0\\;jbcc %l1\" :\n+      \"dbra %0,%l1\\;clr%.w %0\\;subq%.l #1,%0\\;jcc %l1\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    return MOTOROLA ?\n+      \"subq%.l #1,%0\\;jbcc %l1\" :\n+      \"subq%.l #1,%0\\;jcc %l1\";\n+  return MOTOROLA ?\n+    \"subq.l #1,%0\\;cmp.l #-1,%0\\;jbne %l1\" :\n+    \"subql #1,%0\\;cmpl #-1,%0\\;jne %l1\";\n })\n \n ;; Two dbra patterns that use REG_NOTES info generated by strength_reduce.\n@@ -6289,26 +6130,15 @@\n   \"!TARGET_COLDFIRE && find_reg_note (insn, REG_NONNEG, 0)\"\n {\n   CC_STATUS_INIT;\n-  if (MOTOROLA)\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        return \"dbra %0,%l1\";\n-      if (GET_CODE (operands[0]) == MEM)\n-        return \"subq%.w %#1,%0\\;jbcc %l1\";\n-#ifdef SGS_CMP_ORDER\n-      return \"subq.w %#1,%0\\;cmp.w %0,%#-1\\;jbne %l1\";\n-#else /* not SGS_CMP_ORDER */\n-      return \"subq.w %#1,%0\\;cmp.w %#-1,%0\\;jbne %l1\";\n-#endif /* not SGS_CMP_ORDER */\n-    }\n-  else\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        return \"dbra %0,%l1\";\n-      if (GET_CODE (operands[0]) == MEM)\n-        return \"subqw %#1,%0\\;jcc %l1\";\n-      return \"subqw %#1,%0\\;cmpw %#-1,%0\\;jne %l1\";\n-    }\n+  if (DATA_REG_P (operands[0]))\n+    return \"dbra %0,%l1\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    return MOTOROLA ?\n+      \"subq%.w #1,%0\\;jbcc %l1\" :\n+      \"subq%.w #1,%0\\;jcc %l1\";\n+  return MOTOROLA ?\n+    \"subq.w #1,%0\\;cmp.w #-1,%0\\;jbne %l1\" :\n+    \"subqw #1,%0\\;cmpw #-1,%0\\;jne %l1\";\n })\n \n (define_expand \"decrement_and_branch_until_zero\"\n@@ -6339,26 +6169,17 @@\n   \"!TARGET_COLDFIRE && find_reg_note (insn, REG_NONNEG, 0)\"\n {\n   CC_STATUS_INIT;\n-  if (MOTOROLA)\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        return \"dbra %0,%l1\\;clr%.w %0\\;subq%.l %#1,%0\\;jbcc %l1\";\n-      if (GET_CODE (operands[0]) == MEM)\n-        return \"subq%.l %#1,%0\\;jbcc %l1\";\n-#ifdef SGS_CMP_ORDER\n-      return \"subq.l %#1,%0\\;cmp.l %0,%#-1\\;jbne %l1\";\n-#else /* not SGS_CMP_ORDER */\n-      return \"subq.l %#1,%0\\;cmp.l %#-1,%0\\;jbne %l1\";\n-#endif /* not SGS_CMP_ORDER */\n-    }\n-  else\n-    {\n-      if (DATA_REG_P (operands[0]))\n-        return \"dbra %0,%l1\\;clr%.w %0\\;subql %#1,%0\\;jcc %l1\";\n-      if (GET_CODE (operands[0]) == MEM)\n-        return \"subql %#1,%0\\;jcc %l1\";\n-      return \"subql %#1,%0\\;cmpl %#-1,%0\\;jne %l1\";\n-    }\n+  if (DATA_REG_P (operands[0]))\n+    return MOTOROLA ?\n+      \"dbra %0,%l1\\;clr%.w %0\\;subq%.l #1,%0\\;jbcc %l1\" :\n+      \"dbra %0,%l1\\;clr%.w %0\\;subql #1,%0\\;jcc %l1\";\n+  if (GET_CODE (operands[0]) == MEM)\n+    return MOTOROLA ?\n+      \"subq%.l #1,%0\\;jbcc %l1\" :\n+      \"subql #1,%0\\;jcc %l1\";\n+  return MOTOROLA ?\n+    \"subq.l #1,%0\\;cmp.l #-1,%0\\;jbne %l1\" :\n+    \"subql #1,%0\\;cmpl #-1,%0\\;jne %l1\";\n })\n \n \n@@ -6556,25 +6377,13 @@\n       && GET_CODE (XEXP (operands[1], 0)) != PLUS)\n     {\n       rtx labelref = XEXP (operands[1], 1);\n-#if MOTOROLA && !defined (SGS_SWITCH_TABLES)\n-#ifdef SGS\n-      asm_fprintf (asm_out_file, \"\\\\tset %LLI%d,.+2\\\\n\",\n-\t\t   CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#else /* not SGS */\n-      asm_fprintf (asm_out_file, \"\\\\t.set %LLI%d,.+2\\\\n\",\n-\t           CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#endif /* not SGS */\n-#else /* SGS_SWITCH_TABLES or not MOTOROLA */\n-      (*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-#ifdef SGS_SWITCH_TABLES\n-      /* Set flag saying we need to define the symbol\n-\t LD%n (with value L%n-LI%n) at the end of the switch table.  */\n-      switch_table_difference_label_flag = 1;\n-#endif /* SGS_SWITCH_TABLES */\n-#endif /* SGS_SWITCH_TABLES or not MOTOROLA */\n+      if (MOTOROLA)\n+        asm_fprintf (asm_out_file, \"\\\\t.set %LLI%d,.+2\\\\n\",\n+\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n+      else\n+        (*targetm.asm_out.internal_label) (asm_out_file, \"LI\",\n+\t\t     CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n     }\n-\n   return \"lea %a1,%0\";\n })\n \f\n@@ -6623,7 +6432,7 @@\n       else if (TARGET_CPU32 && INTVAL (xoperands[1]) <= 16) \n \t{\n \t  xoperands[1] = GEN_INT (INTVAL (xoperands[1]) - 8);\n-\t  output_asm_insn (\"addq%.w %#8,%0\\;addq%.w %1,%0\", xoperands);\n+\t  output_asm_insn (\"addq%.w #8,%0\\;addq%.w %1,%0\", xoperands);\n \t}\n       else if (INTVAL (xoperands[1]) <= 0x7FFF)\n         {\n@@ -6667,7 +6476,7 @@\n       else if (TARGET_CPU32 && INTVAL (xoperands[1]) <= 16)\n \t{\n \t  xoperands[1] = GEN_INT (INTVAL (xoperands[1]) - 8);\n-\t  output_asm_insn (\"addq%.w %#8,%0\\;addq%.w %1,%0\", xoperands);\n+\t  output_asm_insn (\"addq%.w #8,%0\\;addq%.w %1,%0\", xoperands);\n \t}\n       else if (INTVAL (xoperands[1]) <= 0x7FFF)\n         {\n@@ -6704,9 +6513,9 @@\n     = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 3));\n   xoperands[3] = stack_pointer_rtx;\n   if (!TARGET_COLDFIRE)\n-    output_asm_insn (\"subq%.w %#4,%3\\;move%.b %1,%2\", xoperands);\n+    output_asm_insn (\"subq%.w #4,%3\\;move%.b %1,%2\", xoperands);\n   else\n-    output_asm_insn (\"subq%.l %#4,%3\\;move%.b %1,%2\", xoperands);\n+    output_asm_insn (\"subq%.l #4,%3\\;move%.b %1,%2\", xoperands);\n   return \"\";\n })\n \n@@ -6869,17 +6678,6 @@\n   \"TARGET_68881\"\n {\n   cc_status.flags = CC_IN_68881;\n-#ifdef SGS_CMP_ORDER\n-  if (REG_P (operands[0]))\n-    {\n-      if (REG_P (operands[1]))\n-\treturn \"fcmp%.x %0,%1\";\n-      else\n-        return \"fcmp%.x %0,%f1\";\n-    }\n-  cc_status.flags |= CC_REVERSED;\n-  return \"fcmp%.x %1,%f0\";\n-#else\n   if (REG_P (operands[0]))\n     {\n       if (REG_P (operands[1]))\n@@ -6889,7 +6687,6 @@\n     }\n   cc_status.flags |= CC_REVERSED;\n   return \"fcmp%.x %f0,%1\";\n-#endif\n })\n \n (define_insn \"extendsfxf2\"\n@@ -7311,7 +7108,7 @@\n (define_insn \"trap\"\n   [(trap_if (const_int -1) (const_int 7))]\n   \"\"\n-  \"trap %#7\")\n+  \"trap #7\")\n \n (define_insn \"conditional_trap\"\n   [(trap_if (match_operator 0 \"valid_dbcc_comparison_p\""}, {"sha": "68218e556d27457e0ae4fa353fabd817a3effca1", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -191,19 +191,6 @@ do {\t\t\t\t\t\t\t\t\\\n   putc ('\\n', (FILE));\t\t\t\t\t\t\\\n } while (0)\n \n-/* SVR4 m68k assembler is bitching on the syntax `2.b'.\n-   So use the \"LLDnnn-LLnnn\" format.  Define LLDnnn after the table.  */\n-\n-#undef ASM_OUTPUT_CASE_END\n-#define ASM_OUTPUT_CASE_END(FILE,NUM,TABLE)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (switch_table_difference_label_flag)\t\t\t\t\\\n-    asm_fprintf ((FILE), \"%s%LLD%d,%LL%d\\n\", SET_ASM_OP, (NUM), (NUM));\t\\\n-  switch_table_difference_label_flag = 0;\t\t\t\t\\\n-} while (0)\n-\n-extern int switch_table_difference_label_flag;\n-\n #undef ASM_OUTPUT_COMMON\n #undef ASM_OUTPUT_LOCAL\n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\"}, {"sha": "6d9f8b2d4a1f8d39d47e0b02f13fac125cc48e4d", "filename": "gcc/config/m68k/math-68881.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fmath-68881.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b4b85c945f850219212333d236f617b24b3515f/gcc%2Fconfig%2Fm68k%2Fmath-68881.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fmath-68881.h?ref=3b4b85c945f850219212333d236f617b24b3515f", "patch": "@@ -57,7 +57,7 @@\n ({\t\t\t\t\t\t\t\t\t\\\n   double huge_val;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  __asm (\"fmove%.d %#0x7ff0000000000000,%0\"\t/* Infinity */\t\t\\\n+  __asm (\"fmove%.d #0x7ff0000000000000,%0\"\t/* Infinity */\t\t\\\n \t : \"=f\" (huge_val)\t\t\t\t\t\t\\\n \t : /* no inputs */);\t\t\t\t\t\t\\\n   huge_val;\t\t\t\t\t\t\t\t\\\n@@ -135,10 +135,10 @@ atan2 (double y, double x)\n {\n   double pi, pi_over_2;\n \n-  __asm (\"fmovecr%.x %#0,%0\"\t\t/* extended precision pi */\n+  __asm (\"fmovecr%.x #0,%0\"\t\t/* extended precision pi */\n \t : \"=f\" (pi)\n \t : /* no inputs */ );\n-  __asm (\"fscale%.b %#-1,%0\"\t\t/* no loss of accuracy */\n+  __asm (\"fscale%.b #-1,%0\"\t\t/* no loss of accuracy */\n \t : \"=f\" (pi_over_2)\n \t : \"0\" (pi));\n   if (x > 0)\n@@ -178,7 +178,7 @@ atan2 (double y, double x)\n \t      double value;\n \n \t      errno = EDOM;\n-\t      __asm (\"fmove%.d %#0x7fffffffffffffff,%0\" \t/* quiet NaN */\n+\t      __asm (\"fmove%.d #0x7fffffffffffffff,%0\"\t/* quiet NaN */\n \t\t     : \"=f\" (value)\n \t\t     : /* no inputs */);\n \t      return value;\n@@ -317,7 +317,7 @@ pow (double x, double y)\n \t  double value;\n \n \t  errno = EDOM;\n-\t  __asm (\"fmove%.d %#0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n+\t  __asm (\"fmove%.d #0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n \t\t : \"=f\" (value)\n \t\t : /* no inputs */);\n \t  return value;\n@@ -333,7 +333,7 @@ pow (double x, double y)\n       if (y == temp)\n         {\n \t  int i = (int) y;\n-\t  \n+\n \t  if ((i & 1) == 0)\t\t\t/* even */\n \t    return exp (y * log (-x));\n \t  else\n@@ -344,7 +344,7 @@ pow (double x, double y)\n \t  double value;\n \n \t  errno = EDOM;\n-\t  __asm (\"fmove%.d %#0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n+\t  __asm (\"fmove%.d #0x7fffffffffffffff,%0\"\t\t/* quiet NaN */\n \t\t : \"=f\" (value)\n \t\t : /* no inputs */);\n \t  return value;\n@@ -497,15 +497,15 @@ frexp (double x, int *exp)\n   double mantissa;\n \n   __asm (\"fgetexp%.x %1,%0\"\n-\t : \"=f\" (float_exponent) \t/* integer-valued float */\n+\t : \"=f\" (float_exponent)\t/* integer-valued float */\n \t : \"f\" (x));\n   int_exponent = (int) float_exponent;\n   __asm (\"fgetman%.x %1,%0\"\n \t : \"=f\" (mantissa)\t\t/* 1.0 <= mantissa < 2.0 */\n \t : \"f\" (x));\n   if (mantissa != 0)\n     {\n-      __asm (\"fscale%.b %#-1,%0\"\n+      __asm (\"fscale%.b #-1,%0\"\n \t     : \"=f\" (mantissa)\t\t/* mantissa /= 2.0 */\n \t     : \"0\" (mantissa));\n       int_exponent += 1;"}]}