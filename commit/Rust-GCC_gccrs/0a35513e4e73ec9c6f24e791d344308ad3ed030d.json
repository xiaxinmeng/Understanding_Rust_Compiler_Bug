{"sha": "0a35513e4e73ec9c6f24e791d344308ad3ed030d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEzNTUxM2U0ZTczZWM5YzZmMjRlNzkxZDM0NDMwOGFkM2VkMDMwZA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2011-11-08T11:13:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2011-11-08T11:13:41Z"}, "message": "Merge from transactional-memory branch.\n\nFrom-SVN: r181154", "tree": {"sha": "e07de8d0b6265f8d72388d335bd471022e753d57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e07de8d0b6265f8d72388d335bd471022e753d57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a35513e4e73ec9c6f24e791d344308ad3ed030d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a35513e4e73ec9c6f24e791d344308ad3ed030d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a35513e4e73ec9c6f24e791d344308ad3ed030d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a35513e4e73ec9c6f24e791d344308ad3ed030d/comments", "author": null, "committer": null, "parents": [{"sha": "287188ea072dd887a17dd56360531c3a22307e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287188ea072dd887a17dd56360531c3a22307e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/287188ea072dd887a17dd56360531c3a22307e7c"}], "stats": {"total": 54010, "additions": 53780, "deletions": 230}, "files": [{"sha": "d6ae1b1aa8c8c2093b29e69a43334ca9f8b82900", "filename": "ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,15 @@\n+2011-11-07  Aldy Hernandez  <aldyh@redhat.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* Makefile.def (lang_env_dependencies): libitm is c++.\n+\tAdd libitm target module.\n+\t* configure.ac: Likewise.\n+\t* config/mmap.m4: New file.\n+\t* contrib/gcc_update: Add libitm to touch data.\n+\t* Makefile.in, configure: Rebuild.\n+\n 2011-11-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* Makefile.tpl (EXTRA_GCC_FLAGS): Remove LIBGCC2_CFLAGS,"}, {"sha": "b94dabfffe932c081f60499bbc48873e2b366941", "filename": "Makefile.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -139,6 +139,7 @@ target_modules = { module= boehm-gc; };\n target_modules = { module= rda; };\n target_modules = { module= libada; };\n target_modules = { module= libgomp; bootstrap= true; lib_path=.libs; };\n+target_modules = { module= libitm; lib_path=.libs; };\n \n // These are (some of) the make targets to be done in each subdirectory.\n // Not all; these are the ones which don't have special options.\n@@ -470,6 +471,7 @@ dependencies = { module=all-m4; on=all-build-texinfo; };\n // environment (e.g. on libstdc++).  By default target modules depend\n // on libgcc and newlib/libgloss.\n lang_env_dependencies = { module=libjava; cxx=true; };\n+lang_env_dependencies = { module=libitm; cxx=true; };\n lang_env_dependencies = { module=newlib; no_c=true; };\n lang_env_dependencies = { module=libgloss; no_c=true; };\n lang_env_dependencies = { module=libgcc; no_gcc=true; no_c=true; };"}, {"sha": "900c325849bf9b2c05bbda950101da4e59131fdc", "filename": "Makefile.in", "status": "modified", "additions": 490, "deletions": 5, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -594,7 +594,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -612,6 +612,10 @@ TARGET_LIB_PATH_libssp = $$r/$(TARGET_SUBDIR)/libssp/.libs:\n TARGET_LIB_PATH_libgomp = $$r/$(TARGET_SUBDIR)/libgomp/.libs:\n @endif target-libgomp\n \n+@if target-libitm\n+TARGET_LIB_PATH_libitm = $$r/$(TARGET_SUBDIR)/libitm/.libs:\n+@endif target-libitm\n+\n \n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n@@ -947,7 +951,8 @@ configure-target:  \\\n     maybe-configure-target-boehm-gc \\\n     maybe-configure-target-rda \\\n     maybe-configure-target-libada \\\n-    maybe-configure-target-libgomp\n+    maybe-configure-target-libgomp \\\n+    maybe-configure-target-libitm\n \n # The target built for a native non-bootstrap build.\n .PHONY: all\n@@ -1094,6 +1099,7 @@ all-target: maybe-all-target-libada\n @if target-libgomp-no-bootstrap\n all-target: maybe-all-target-libgomp\n @endif target-libgomp-no-bootstrap\n+all-target: maybe-all-target-libitm\n \n # Do a target for all the subdirectories.  A ``make do-X'' will do a\n # ``make X'' in all subdirectories (because, in general, there is a\n@@ -1176,6 +1182,7 @@ info-target: maybe-info-target-boehm-gc\n info-target: maybe-info-target-rda\n info-target: maybe-info-target-libada\n info-target: maybe-info-target-libgomp\n+info-target: maybe-info-target-libitm\n \n .PHONY: do-dvi\n do-dvi:\n@@ -1253,6 +1260,7 @@ dvi-target: maybe-dvi-target-boehm-gc\n dvi-target: maybe-dvi-target-rda\n dvi-target: maybe-dvi-target-libada\n dvi-target: maybe-dvi-target-libgomp\n+dvi-target: maybe-dvi-target-libitm\n \n .PHONY: do-pdf\n do-pdf:\n@@ -1330,6 +1338,7 @@ pdf-target: maybe-pdf-target-boehm-gc\n pdf-target: maybe-pdf-target-rda\n pdf-target: maybe-pdf-target-libada\n pdf-target: maybe-pdf-target-libgomp\n+pdf-target: maybe-pdf-target-libitm\n \n .PHONY: do-html\n do-html:\n@@ -1407,6 +1416,7 @@ html-target: maybe-html-target-boehm-gc\n html-target: maybe-html-target-rda\n html-target: maybe-html-target-libada\n html-target: maybe-html-target-libgomp\n+html-target: maybe-html-target-libitm\n \n .PHONY: do-TAGS\n do-TAGS:\n@@ -1484,6 +1494,7 @@ TAGS-target: maybe-TAGS-target-boehm-gc\n TAGS-target: maybe-TAGS-target-rda\n TAGS-target: maybe-TAGS-target-libada\n TAGS-target: maybe-TAGS-target-libgomp\n+TAGS-target: maybe-TAGS-target-libitm\n \n .PHONY: do-install-info\n do-install-info:\n@@ -1561,6 +1572,7 @@ install-info-target: maybe-install-info-target-boehm-gc\n install-info-target: maybe-install-info-target-rda\n install-info-target: maybe-install-info-target-libada\n install-info-target: maybe-install-info-target-libgomp\n+install-info-target: maybe-install-info-target-libitm\n \n .PHONY: do-install-pdf\n do-install-pdf:\n@@ -1638,6 +1650,7 @@ install-pdf-target: maybe-install-pdf-target-boehm-gc\n install-pdf-target: maybe-install-pdf-target-rda\n install-pdf-target: maybe-install-pdf-target-libada\n install-pdf-target: maybe-install-pdf-target-libgomp\n+install-pdf-target: maybe-install-pdf-target-libitm\n \n .PHONY: do-install-html\n do-install-html:\n@@ -1715,6 +1728,7 @@ install-html-target: maybe-install-html-target-boehm-gc\n install-html-target: maybe-install-html-target-rda\n install-html-target: maybe-install-html-target-libada\n install-html-target: maybe-install-html-target-libgomp\n+install-html-target: maybe-install-html-target-libitm\n \n .PHONY: do-installcheck\n do-installcheck:\n@@ -1792,6 +1806,7 @@ installcheck-target: maybe-installcheck-target-boehm-gc\n installcheck-target: maybe-installcheck-target-rda\n installcheck-target: maybe-installcheck-target-libada\n installcheck-target: maybe-installcheck-target-libgomp\n+installcheck-target: maybe-installcheck-target-libitm\n \n .PHONY: do-mostlyclean\n do-mostlyclean:\n@@ -1869,6 +1884,7 @@ mostlyclean-target: maybe-mostlyclean-target-boehm-gc\n mostlyclean-target: maybe-mostlyclean-target-rda\n mostlyclean-target: maybe-mostlyclean-target-libada\n mostlyclean-target: maybe-mostlyclean-target-libgomp\n+mostlyclean-target: maybe-mostlyclean-target-libitm\n \n .PHONY: do-clean\n do-clean:\n@@ -1946,6 +1962,7 @@ clean-target: maybe-clean-target-boehm-gc\n clean-target: maybe-clean-target-rda\n clean-target: maybe-clean-target-libada\n clean-target: maybe-clean-target-libgomp\n+clean-target: maybe-clean-target-libitm\n \n .PHONY: do-distclean\n do-distclean:\n@@ -2023,6 +2040,7 @@ distclean-target: maybe-distclean-target-boehm-gc\n distclean-target: maybe-distclean-target-rda\n distclean-target: maybe-distclean-target-libada\n distclean-target: maybe-distclean-target-libgomp\n+distclean-target: maybe-distclean-target-libitm\n \n .PHONY: do-maintainer-clean\n do-maintainer-clean:\n@@ -2100,6 +2118,7 @@ maintainer-clean-target: maybe-maintainer-clean-target-boehm-gc\n maintainer-clean-target: maybe-maintainer-clean-target-rda\n maintainer-clean-target: maybe-maintainer-clean-target-libada\n maintainer-clean-target: maybe-maintainer-clean-target-libgomp\n+maintainer-clean-target: maybe-maintainer-clean-target-libitm\n \n \n # Here are the targets which correspond to the do-X targets.\n@@ -2231,7 +2250,8 @@ check-target:  \\\n     maybe-check-target-boehm-gc \\\n     maybe-check-target-rda \\\n     maybe-check-target-libada \\\n-    maybe-check-target-libgomp\n+    maybe-check-target-libgomp \\\n+    maybe-check-target-libitm\n \n do-check:\n \t@: $(MAKE); $(unstage)\n@@ -2380,7 +2400,8 @@ install-target:  \\\n     maybe-install-target-boehm-gc \\\n     maybe-install-target-rda \\\n     maybe-install-target-libada \\\n-    maybe-install-target-libgomp\n+    maybe-install-target-libgomp \\\n+    maybe-install-target-libitm\n \n uninstall:\n \t@echo \"the uninstall target is not supported in this tree\"\n@@ -2476,7 +2497,8 @@ install-strip-target:  \\\n     maybe-install-strip-target-boehm-gc \\\n     maybe-install-strip-target-rda \\\n     maybe-install-strip-target-libada \\\n-    maybe-install-strip-target-libgomp\n+    maybe-install-strip-target-libgomp \\\n+    maybe-install-strip-target-libitm\n \n \n ### other supporting targets\n@@ -40142,6 +40164,463 @@ maintainer-clean-target-libgomp:\n \n \n \n+\n+\n+.PHONY: configure-target-libitm maybe-configure-target-libitm\n+maybe-configure-target-libitm:\n+@if gcc-bootstrap\n+configure-target-libitm: stage_current\n+@endif gcc-bootstrap\n+@if target-libitm\n+maybe-configure-target-libitm: configure-target-libitm\n+configure-target-libitm: \n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libitm...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libitm ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libitm/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libitm/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libitm/multilib.tmp $(TARGET_SUBDIR)/libitm/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libitm/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libitm/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libitm/multilib.tmp $(TARGET_SUBDIR)/libitm/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libitm/multilib.tmp $(TARGET_SUBDIR)/libitm/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libitm/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libitm ; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libitm; \\\n+\tcd \"$(TARGET_SUBDIR)/libitm\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libitm/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libitm\"; \\\n+\tlibsrcdir=\"$$s/libitm\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif target-libitm\n+\n+\n+\n+\n+\n+.PHONY: all-target-libitm maybe-all-target-libitm\n+maybe-all-target-libitm:\n+@if gcc-bootstrap\n+all-target-libitm: stage_current\n+@endif gcc-bootstrap\n+@if target-libitm\n+TARGET-target-libitm=all\n+maybe-all-target-libitm: all-target-libitm\n+all-target-libitm: configure-target-libitm\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t$(TARGET-target-libitm))\n+@endif target-libitm\n+\n+\n+\n+\n+\n+.PHONY: check-target-libitm maybe-check-target-libitm\n+maybe-check-target-libitm:\n+@if target-libitm\n+maybe-check-target-libitm: check-target-libitm\n+\n+check-target-libitm:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libitm\n+\n+.PHONY: install-target-libitm maybe-install-target-libitm\n+maybe-install-target-libitm:\n+@if target-libitm\n+maybe-install-target-libitm: install-target-libitm\n+\n+install-target-libitm: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libitm\n+\n+.PHONY: install-strip-target-libitm maybe-install-strip-target-libitm\n+maybe-install-strip-target-libitm:\n+@if target-libitm\n+maybe-install-strip-target-libitm: install-strip-target-libitm\n+\n+install-strip-target-libitm: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libitm\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libitm info-target-libitm\n+maybe-info-target-libitm:\n+@if target-libitm\n+maybe-info-target-libitm: info-target-libitm\n+\n+info-target-libitm: \\\n+    configure-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-dvi-target-libitm dvi-target-libitm\n+maybe-dvi-target-libitm:\n+@if target-libitm\n+maybe-dvi-target-libitm: dvi-target-libitm\n+\n+dvi-target-libitm: \\\n+    configure-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-pdf-target-libitm pdf-target-libitm\n+maybe-pdf-target-libitm:\n+@if target-libitm\n+maybe-pdf-target-libitm: pdf-target-libitm\n+\n+pdf-target-libitm: \\\n+    configure-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-html-target-libitm html-target-libitm\n+maybe-html-target-libitm:\n+@if target-libitm\n+maybe-html-target-libitm: html-target-libitm\n+\n+html-target-libitm: \\\n+    configure-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-TAGS-target-libitm TAGS-target-libitm\n+maybe-TAGS-target-libitm:\n+@if target-libitm\n+maybe-TAGS-target-libitm: TAGS-target-libitm\n+\n+TAGS-target-libitm: \\\n+    configure-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-install-info-target-libitm install-info-target-libitm\n+maybe-install-info-target-libitm:\n+@if target-libitm\n+maybe-install-info-target-libitm: install-info-target-libitm\n+\n+install-info-target-libitm: \\\n+    configure-target-libitm \\\n+    info-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-install-pdf-target-libitm install-pdf-target-libitm\n+maybe-install-pdf-target-libitm:\n+@if target-libitm\n+maybe-install-pdf-target-libitm: install-pdf-target-libitm\n+\n+install-pdf-target-libitm: \\\n+    configure-target-libitm \\\n+    pdf-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-install-html-target-libitm install-html-target-libitm\n+maybe-install-html-target-libitm:\n+@if target-libitm\n+maybe-install-html-target-libitm: install-html-target-libitm\n+\n+install-html-target-libitm: \\\n+    configure-target-libitm \\\n+    html-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-installcheck-target-libitm installcheck-target-libitm\n+maybe-installcheck-target-libitm:\n+@if target-libitm\n+maybe-installcheck-target-libitm: installcheck-target-libitm\n+\n+installcheck-target-libitm: \\\n+    configure-target-libitm \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-mostlyclean-target-libitm mostlyclean-target-libitm\n+maybe-mostlyclean-target-libitm:\n+@if target-libitm\n+maybe-mostlyclean-target-libitm: mostlyclean-target-libitm\n+\n+mostlyclean-target-libitm: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-clean-target-libitm clean-target-libitm\n+maybe-clean-target-libitm:\n+@if target-libitm\n+maybe-clean-target-libitm: clean-target-libitm\n+\n+clean-target-libitm: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-distclean-target-libitm distclean-target-libitm\n+maybe-distclean-target-libitm:\n+@if target-libitm\n+maybe-distclean-target-libitm: distclean-target-libitm\n+\n+distclean-target-libitm: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+.PHONY: maybe-maintainer-clean-target-libitm maintainer-clean-target-libitm\n+maybe-maintainer-clean-target-libitm:\n+@if target-libitm\n+maybe-maintainer-clean-target-libitm: maintainer-clean-target-libitm\n+\n+maintainer-clean-target-libitm: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libitm/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libitm\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libitm && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libitm\n+\n+\n+\n @if target-libmudflap\n .PHONY: check-target-libmudflap-c++\n check-target-libmudflap-c++:\n@@ -42233,6 +42712,7 @@ configure-stage3-target-libgomp: maybe-all-stage3-gcc\n configure-stage4-target-libgomp: maybe-all-stage4-gcc\n configure-stageprofile-target-libgomp: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libgomp: maybe-all-stagefeedback-gcc\n+configure-target-libitm: stage_last\n @endif gcc-bootstrap\n \n @if gcc-no-bootstrap\n@@ -42255,6 +42735,7 @@ configure-target-boehm-gc: maybe-all-gcc\n configure-target-rda: maybe-all-gcc\n configure-target-libada: maybe-all-gcc\n configure-target-libgomp: maybe-all-gcc\n+configure-target-libitm: maybe-all-gcc\n @endif gcc-no-bootstrap\n \n \n@@ -43028,6 +43509,7 @@ configure-target-boehm-gc: maybe-all-target-libgcc\n configure-target-rda: maybe-all-target-libgcc\n configure-target-libada: maybe-all-target-libgcc\n configure-target-libgomp: maybe-all-target-libgcc\n+configure-target-libitm: maybe-all-target-libgcc\n @endif gcc-no-bootstrap\n \n \n@@ -43067,6 +43549,9 @@ configure-target-libada: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libgomp: maybe-all-target-newlib maybe-all-target-libgloss\n \n+configure-target-libitm: maybe-all-target-newlib maybe-all-target-libgloss\n+configure-target-libitm: maybe-all-target-libstdc++-v3\n+\n \n CONFIGURE_GDB_TK = @CONFIGURE_GDB_TK@\n GDB_TK = @GDB_TK@"}, {"sha": "39d79afc7494403675cf03e1a3bcb69b957725e0", "filename": "config/mmap.m4", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/config%2Fmmap.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/config%2Fmmap.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fmmap.m4?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,97 @@\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from gcc\n+\n+dnl\n+dnl mmap(2) blacklisting.  Some platforms provide the mmap library routine\n+dnl but don't support all of the features we need from it.\n+dnl\n+AC_DEFUN([GCC_AC_FUNC_MMAP_BLACKLIST],\n+[\n+AC_CHECK_HEADER([sys/mman.h],\n+\t\t[gcc_header_sys_mman_h=yes], [gcc_header_sys_mman_h=no])\n+AC_CHECK_FUNC([mmap], [gcc_func_mmap=yes], [gcc_func_mmap=no])\n+if test \"$gcc_header_sys_mman_h\" != yes \\\n+ || test \"$gcc_func_mmap\" != yes; then\n+   gcc_cv_func_mmap_file=no\n+   gcc_cv_func_mmap_dev_zero=no\n+   gcc_cv_func_mmap_anon=no\n+else\n+   AC_CACHE_CHECK([whether read-only mmap of a plain file works], \n+  gcc_cv_func_mmap_file,\n+  [# Add a system to this blacklist if \n+   # mmap(0, stat_size, PROT_READ, MAP_PRIVATE, fd, 0) doesn't return a\n+   # memory area containing the same data that you'd get if you applied\n+   # read() to the same fd.  The only system known to have a problem here\n+   # is VMS, where text files have record structure.\n+   case \"$host_os\" in\n+     vms* | ultrix*) \n+        gcc_cv_func_mmap_file=no ;;\n+     *)\n+        gcc_cv_func_mmap_file=yes;;\n+   esac])\n+   AC_CACHE_CHECK([whether mmap from /dev/zero works],\n+  gcc_cv_func_mmap_dev_zero,\n+  [# Add a system to this blacklist if it has mmap() but /dev/zero\n+   # does not exist, or if mmapping /dev/zero does not give anonymous\n+   # zeroed pages with both the following properties:\n+   # 1. If you map N consecutive pages in with one call, and then\n+   #    unmap any subset of those pages, the pages that were not\n+   #    explicitly unmapped remain accessible.\n+   # 2. If you map two adjacent blocks of memory and then unmap them\n+   #    both at once, they must both go away.\n+   # Systems known to be in this category are Windows (all variants),\n+   # VMS, and Darwin.\n+   case \"$host_os\" in\n+     vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)\n+        gcc_cv_func_mmap_dev_zero=no ;;\n+     *)\n+        gcc_cv_func_mmap_dev_zero=yes;;\n+   esac])\n+\n+   # Unlike /dev/zero, the MAP_ANON(YMOUS) defines can be probed for.\n+   AC_CACHE_CHECK([for MAP_ANON(YMOUS)], gcc_cv_decl_map_anon,\n+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n+[#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+],\n+[int n = MAP_ANONYMOUS;])],\n+    gcc_cv_decl_map_anon=yes,\n+    gcc_cv_decl_map_anon=no)])\n+\n+   if test $gcc_cv_decl_map_anon = no; then\n+     gcc_cv_func_mmap_anon=no\n+   else\n+     AC_CACHE_CHECK([whether mmap with MAP_ANON(YMOUS) works],\n+     gcc_cv_func_mmap_anon,\n+  [# Add a system to this blacklist if it has mmap() and MAP_ANON or\n+   # MAP_ANONYMOUS, but using mmap(..., MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)\n+   # doesn't give anonymous zeroed pages with the same properties listed\n+   # above for use of /dev/zero.\n+   # Systems known to be in this category are Windows, VMS, and SCO Unix.\n+   case \"$host_os\" in\n+     vms* | cygwin* | pe | mingw* | sco* | udk* )\n+        gcc_cv_func_mmap_anon=no ;;\n+     *)\n+        gcc_cv_func_mmap_anon=yes;;\n+   esac])\n+   fi\n+fi\n+\n+if test $gcc_cv_func_mmap_file = yes; then\n+  AC_DEFINE(HAVE_MMAP_FILE, 1,\n+\t    [Define if read-only mmap of a plain file works.])\n+fi\n+if test $gcc_cv_func_mmap_dev_zero = yes; then\n+  AC_DEFINE(HAVE_MMAP_DEV_ZERO, 1,\n+\t    [Define if mmap of /dev/zero works.])\n+fi\n+if test $gcc_cv_func_mmap_anon = yes; then\n+  AC_DEFINE(HAVE_MMAP_ANON, 1,\n+\t    [Define if mmap with MAP_ANON(YMOUS) works.])\n+fi\n+])"}, {"sha": "03d00483411fec61eb37ab2f9200ecbf1516a5e9", "filename": "configure", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -2681,6 +2681,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n+\t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n \t\ttarget-libssp \\\n@@ -3056,6 +3057,24 @@ if test x$enable_libgomp = x ; then\n     esac\n fi\n \n+# Disable libitm on non POSIX hosted systems.\n+if test x$enable_libitm = x ; then\n+    # Enable libitm by default on hosted POSIX systems.\n+    case \"${target}\" in\n+    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu)\n+\t;;\n+    *-*-netbsd* | *-*-freebsd* | *-*-openbsd*)\n+\t;;\n+    *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11*)\n+\t;;\n+    *-*-darwin* | *-*-aix*)\n+\t;;\n+    *)\n+\tnoconfigdirs=\"$noconfigdirs target-libitm\"\n+\t;;\n+    esac\n+fi\n+\n # Disable libssp for some systems.\n case \"${target}\" in\n   avr-*-*)"}, {"sha": "4bca6d82f4650e4003c4d79e02b6552fb410ae26", "filename": "configure.ac", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -154,6 +154,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n+\t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n \t\ttarget-libssp \\\n@@ -492,6 +493,24 @@ if test x$enable_libgomp = x ; then\n     esac\n fi\n \n+# Disable libitm on non POSIX hosted systems.\n+if test x$enable_libitm = x ; then\n+    # Enable libitm by default on hosted POSIX systems.\n+    case \"${target}\" in\n+    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu)\n+\t;;\n+    *-*-netbsd* | *-*-freebsd* | *-*-openbsd*)\n+\t;;\n+    *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11*)\n+\t;;\n+    *-*-darwin* | *-*-aix*)\n+\t;;\n+    *)\n+\tnoconfigdirs=\"$noconfigdirs target-libitm\"\n+\t;;\n+    esac\n+fi\n+\n # Disable libssp for some systems.\n case \"${target}\" in\n   avr-*-*)"}, {"sha": "b3828975b687cb193d5676e475f59b7e34d7f4d9", "filename": "contrib/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,9 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* gcc_update: Add libitm to touch data.\n+\n 2011-11-07   Quentin Neill  <quentin.neill@amd.com>\n \n \t* compare_tests: Add ability to compare all .sum"}, {"sha": "3612880c2a458a0a93ae167985e91d034b367ea8", "filename": "contrib/gcc_update", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -136,6 +136,11 @@ libgomp/Makefile.in: libgomp/Makefile.am libgomp/aclocal.m4\n libgomp/testsuite/Makefile.in: libgomp/Makefile.am libgomp/aclocal.m4\n libgomp/configure: libgomp/configure.ac libgomp/aclocal.m4\n libgomp/config.h.in: libgomp/configure.ac libgomp/aclocal.m4\n+libitm/aclocal.m4: libitm/configure.ac libitm/acinclude.m4\n+libitm/Makefile.in: libitm/Makefile.am libitm/aclocal.m4\n+libitm/testsuite/Makefile.in: libitm/testsuite/Makefile.am libitm/aclocal.m4\n+libitm/configure: libitm/configure.ac libitm/aclocal.m4\n+libitm/config.h.in: libitm/configure.ac libitm/aclocal.m4\n # Top level\n Makefile.in: Makefile.tpl Makefile.def\n configure: configure.ac config/acx.m4"}, {"sha": "e6816e58628d1228d3335ae599b059880d3603fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,201 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Andrew MacLeod  <amacleod@redhat.com>\n+\t    Torvald Riegel  <triegel@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* gtm-builtins.def: New file.\n+\t* trans-mem.c: New file.\n+\t* trans-mem.h: New file.\n+\n+\t* opts.c (finish_options): Error out when using -flto and\n+\t-fgnu-tm.\n+\n+\t* config/i386/i386.c: Define TARGET_VECTORIZE* transactional variants.\n+\t(ix86_handle_tm_regparm_attribute, struct bdesc_tm,\n+\tix86_builtin_tm_load, ix86_builtin_tm_store,\n+\tix86_init_tm_builtins): New.\n+\t(ix86_init_builtins): Initialize TM builtins.\n+\t(struct ix86_attribute_table): Add \"*tm regparm\".\n+\t* config/i386/i386-builtin-types.def (PV2SI): Define.\n+\t(PCV2SI): Define.\n+\tDefine V2SI_FTYPE_PCV2SI.\n+\tDefine V4SF_FTYPE_PCV4SF.\n+\tDefine V8SF_FTYPE_PCV8SF.\n+\tDefine VOID_PV2SI_V2SI.\n+\n+\t* doc/invoke.texi (C Dialect Options): Document -fgnu-tm and\n+\ttm-max-aggregate-size.\n+\t* doc/tm.texi.in: Add TARGET_VECTORIZE_BUILTIN_TM_LOAD and\n+\tTARGET_VECTORIZE_BUILTIN_TM_STORE hooks.\n+\t* doc/tm.texi: Regenerate.\n+\n+\t* attribs.c (apply_tm_attr): New.\n+\t(init_attributes): Allow '*' prefix for overrides.\n+\t(register_attribute): Likewise.\n+\t* builtin-attrs.def (ATTR_TM_TMPURE, ATTR_TM_REGPARM): New.\n+\t(ATTR_TM_NOTHROW_LIST, ATTR_TM_TMPURE_NOTHROW_LIST,\n+\tATTR_TM_PURE_TMPURE_NOTHROW_LIST, ATTR_TM_NORETURN_NOTHROW_LIST,\n+\tATTR_TM_CONST_NOTHROW_LIST, ATTR_TMPURE_MALLOC_NOTHROW_LIST,\n+\tATTR_TMPURE_NOTHROW_LIST): New.\n+\t* builtin-types.def (BT_FN_I[1248]_VPTR, BT_FN_FLOAT_VPTR,\n+\tBT_FN_DOUBLE_VPTR, BT_FN_LDOUBLE_VPTR, BT_FN_VOID_VPTR_I[1248],\n+\tBT_FN_VOID_VPTR_FLOAT, BT_FN_VOID_VPTR_DOUBLE,\n+\tBT_FN_VOID_VPTR_LDOUBLE, BT_FN_VOID_VPTR_SIZE): New.\n+\t* builtins.def: Include gtm-builtins.def. Add comments regarding\n+\ttransactional memory synchronization.\n+\t(DEF_TM_BUILTIN): New.\n+\t* c-parser.c (struct c_parser): Add in_transaction.\n+\t(c_parser_transaction, c_parser_transaction_expression,\n+\tc_parser_transaction_cancel, c_parser_transaction_attributes): New.\n+\t(c_parser_attribute_any_word): Split out from c_parser_attributes.\n+\t(c_parser_statement_after_labels): Handle RID_TRANSACTION*.\n+\t(c_parser_unary_expression): Same.\n+\t* c-tree.h (c_finish_transaction): Declare.\n+\t* c-typeck.c (c_finish_transaction): New.\n+\t(build_function_call_vec): Call tm_malloc_replacement.\n+\t* calls.c (is_tm_builtin): New.\n+\t(flags_from_decl_or_type): Add ECF_TM_BUILTIN and ECF_TM_PURE.\n+\t* cfgbuild.c (make_edges): Add edges for REG_TM notes.\n+\t* cfgexpand.c (expand_call_stmt): Call\n+\tmark_transaction_restart_calls.\n+\t(gimple_expand_cfg): Free the tm_restart map.\n+\t(mark_transaction_restart_calls): New.\n+\t* cfgrtl.c (purge_dead_edges): Look for REG_TM notes.\n+\t* cgraph.c (dump_cgraph_node): Handle tm_clone.\n+\t* cgraph.h (struct cgraph_node): Add tm_clone field.\n+\t(decl_is_tm_clone): New.\n+\t(struct cgraph_local_info): Add tm_may_enter_irr.\n+\t(cgraph_copy_node_for_versioning): Declare.\n+\t* cgraphunit.c (cgraph_copy_node_for_versioning): Export;\n+\tcopy analyzed from old version.\n+\t* combine.c (distribute_notes): Handle REG_TM notes.\n+\t* common.opt: Add -fgnu-tm.\n+\t* crtstuff.c (__TMC_LIST__, __TMC_END__): New.\n+\t(__do_global_dtors_aux): Deregister clone table.\n+\t(frame_dummy): Register clone table.\n+\t* emit-rtl.c (try_split): Handle REG_TM. Early return if no function\n+\tbody.\n+\t* gimple-low.c (lower_stmt): Handle GIMPLE_EH_ELSE and\n+\tGIMPLE_TRANSACTION.\n+\t(gimple_stmt_may_fallthru): Handle GIMPLE_EH_ELSE.\n+\t* gimple-pretty-print.c: Include trans-mem.h.\n+\t(dump_gimple_fmt): Add %x.\n+\t(dump_gimple_call): Dump arguments for calls to _ITM_beginTransaction.\n+\t(dump_gimple_eh_else, dump_gimple_transaction): New.\n+\t(dump_gimple_stmt): Handle GIMPLE_EH_ELSE and GIMPLE_TRANSACTION.\n+\t* gimple.c (gimple_build_eh_else, gimple_build_transaction): New.\n+\t(walk_gimple_seq): Honor removed_stmt. Document usage of removed_stmt\n+\tfield.\n+\t(walk_gimple_op): Handle GIMPLE_TRANSACTION.\n+\t(walk_gimple_stmt): Initialize and honor removed_stmt.\n+\tHandle GIMPLE_EH_ELSE and GIMPLE_TRANSACTION.\n+\t(gimple_copy): Handle GIMPLE_EH_ELSE and GIMPLE_TRANSACTION.\n+\t* gimple.def (GIMPLE_TRANSACTION, GIMPLE_EH_ELSE): New.\n+\t* gimple.h (struct gimple_statement_eh_else,\n+\tgimple_statement_transaction, GTMA_*): New.\n+\t(gimple_statement_d): Add gimple_statement_eh_else and\n+\tgimple_transaction.\n+\t(gimple_build_eh_else, gimple_build_transaction,\n+\tgimple_fold_call, diagnose_tm_safe_errors): Declare.\n+\t(get_call_expr_in): Remove prototype.\n+\t(gimple_has_substatements): Add GIMPLE_EH_ELSE and GIMPLE_TRANSACTION.\n+\t(gimple_eh_else_n_body, gimple_eh_else_e_body,\n+\tgimple_eh_else_set_n_body, gimple_eh_else_set_e_body,\n+\tgimple_transaction_body, gimple_transaction_label,\n+\tgimple_transaction_label_ptr, gimple_transaction_subcode,\n+\tgimple_transaction_set_body, gimple_transaction_set_label,\n+\tgimple_transaction_set_subcode): New.\n+\t(struct walk_stmt_info): Use BOOL_BITFIELD; add removed_stmt.\n+\t* gimplify.c (create_tmp_var_name): Use clean_symbol_name.\n+\t(voidify_wrapper_expr): Handle TRANSACTION_EXPR.\n+\t(gimplify_transaction): New.\n+\t(gimplify_expr): Handle TRANSACTION_EXPR.\n+\t* gsstruct.def (GSS_EH_ELSE, GSS_TRANSACTION): New.\n+\t* ipa-inline.c (can_inline_edge_p): Do not inline TM safe calling\n+\tTM pure functions.\n+\t* Makefile.in: Add trans-mem.o and dependencies.\n+\t(BUILTINS_DEF): Add gtm-builtins.def.\n+\t(gimple-pretty-print.o): Depend on TRANS_MEM_H.\n+\t(GTFILES): Add trans-mem.c.\n+\t* omp-low.c (WALK_SUBSTMTS): Add GIMPLE_TRANSACTION.\n+\t* output.h (record_tm_clone_pair, finish_tm_clone_pairs,\n+\tget_tm_clone_pair): Declare.\n+\t* params.def (PARAM_TM_MAX_AGGREGATE_SIZE): New.\n+\t* passes.c (init_optimization_passes): Place transactional memory\n+\tpasses.\n+\t* print-tree.c (print_node): Dump tm-clone.\n+\t* recog.c (peep2_attempt): Handle REG_TM.\n+\t* reg-notes.def (TM): New.\n+\t* rtlanal.c (alloc_reg_note): Handle REG_TM.\n+\t* target.def (builtin_tm_load, builtin_tm_store): New.\n+\t* targhooks.c (default_builtin_tm_load_store): New.\n+\t* targhooks.h (default_builtin_tm_load_store): Declare.\n+\t* timevar.def (TV_TRANS_MEM): New.\n+\t* toplev.c (compile_file): Call finish_tm_clone_pairs.\n+\t* tree-cfg.c (make_edges): Handle GIMPLE_TRANSACTION.\n+\t(cleanup_dead_labels): Handle GIMPLE_TRANSACTION. Avoid unnecessary\n+\twrites into the statements to update labels.\n+\t(is_ctrl_altering_stmt): Add TM ending statements. Handle\n+\tGIMPLE_TRANSACTION.\n+\t(verify_gimple_transaction): New.\n+\t(verify_gimple_stmt): Handle GIMPLE_TRANSACTION.\n+\t(verify_gimple_in_seq_2): Handle GIMPLE_EH_ELSE and GIMPLE_TRANSACTION.\n+\t(gimple_redirect_edge_and_branch): Handle TM_TRANSACTION.\n+\t(dump_function_to_file): Display [tm-clone] if applicable.\n+\t* tree-eh.c (struct_ptr_eq): Make inline and move to tree.h.\n+\t(struct_ptr_hash): Same.\n+\t(collect_finally_tree): Handle GIMPLE_EH_ELSE.\n+\t(replace_goto_queue_1): Likewise.\n+\t(get_eh_else): New.\n+\t(honor_protect_cleanup_actions): Handle GIMPLE_EH_ELSE.\n+\t(lower_try_finally_nofallthru): Likewise.\n+\t(lower_try_finally_onedest): Likewise.\n+\t(lower_try_finally_copy): Likewise.\n+\t(lower_try_finally_switch): Likewise.\n+\t(lower_try_finally): Likewise.\n+\t(decide_copy_try_finally): Likewise.\n+\t(lower_eh_constructs_2): Likewise.\n+\t(refactor_eh_r): Likewise.\n+\t* tree-flow.h (struct gimple_df): Add tm_restart field.\n+\tDefine tm_restart_node.\n+\t* tree-inline.c (remap_gimple_stmt): Handle GIMPLE_TRANSACTION.\n+\t(estimate_num_insns): Likewise.\n+\t(init_inline_once): Init tm_cost.\n+\t* tree-inline.h (struct eni_weights_d): Add tm_cost.\n+\t* tree-pass.h (pass_diagnose_tm_blocks, pass_lower_tm, pass_tm_init,\n+\tpass_tm_mark, pass_tm_memopt, pass_tm_edges, pass_ipa_tm): Declare.\n+\t* tree-pretty-print.c (dump_generic_node): Handle TRANSACTION_EXPR.\n+\t* tree-ssa-alias.c (ref_maybe_used_by_call_p_1): Handle\n+\tBUILT_IN_TM_MEMSET, BUILT_IN_TM_MEMCPY, BUILT_IN_TM_MEMMOVE.\n+\tAdd support for TM vector loads.  Add support for TM logging builtins.\n+\t(call_may_clobber_ref_p_1): Add support for vector stores.\n+\t* tree-ssa-structalias.c (find_func_aliases): Add support for TM\n+\tvector stores and loads. Handle BUILT_IN_TM_MEMSET,\n+\tBUILT_IN_TM_MEMCPY, BUILT_IN_TM_MEMMOVE.\n+\t* tree.c (strip_invariant_refs): Moved from gimple.c to here.\n+\t(local_define_builtin): Handle ECF_TM_PURE.\n+\t(build_common_builtin_nodes): Set __builtin_eh_pointer to ECF_TM_PURE.\n+\t* tree.def (TRANSACTION_EXPR): New.\n+\t* tree.h (strip_invariant_refs): Moved from gimple.h to here.\n+\t(TRANSACTION_EXPR_BODY, TRANSACTION_EXPR_CHECK,\n+\tTRANSACTION_EXPR_OUTER, TRANSACTION_EXPR_RELAXED,\n+\tBUILTIN_TM_LOAD_STORE_P, BUILTIN_TM_LOAD_P, BUILTIN_TM_STORE_P,\n+\tCASE_BUILT_IN_TM_LOAD, CASE_BUILT_IN_TM_STORE): New.\n+\t(ECF_TM_PURE, ECF_TM_BUILTIN): New.\n+\t(struct tree_function_decl): Add tm_clone_flag.\n+\t(struct_ptr_eq, struct_ptr_hash): New.\n+\t(apply_tm_attr): Declare.\n+\t(is_tm_safe_or_pure): New.\n+\t(build_tm_abort_call, is_tm_safe, is_tm_pure,\n+\tis_tm_may_cancel_outer, is_tm_ending_fndecl, record_tm_replacement,\n+\ttm_malloc_replacement): Declare.\n+\t* varasm.c (tm_clone_hash): New.\n+\t(record_tm_clone_pair, finish_tm_clone_pairs, get_tm_clone_pair,\n+\tdump_tm_clone_to_vec, dump_tm_clone_pairs, tm_alias_pair_cmp): New.\n+\t(struct tm_alias_pair): New.  Declare VEC types for object.\n+\n 2011-11-07  Richard Henderson  <rth@redhat.com>\n \n \t* optabs.h (OTI_sync_compare_and_swap, OTI_sync_lock_test_and_set,"}, {"sha": "9ec2df1485bf22973fd2c01ce7a500268b491739", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -856,7 +856,8 @@ RTL_H = $(RTL_BASE_H) genrtl.h vecir.h\n RTL_ERROR_H = $(RTL_H) $(DIAGNOSTIC_CORE_H)\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n-BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def\n+BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n+\tgtm-builtins.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_H = tree.h all-tree.def tree.def c-family/c-common.def \\\n@@ -869,6 +870,7 @@ BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) cfghooks.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n \tvecir.h $(GGC_H) $(BASIC_BLOCK_H) $(TARGET_H) tree-ssa-operands.h \\\n \ttree-ssa-alias.h $(INTERNAL_FN_H)\n+TRANS_MEM_H = trans-mem.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n COVERAGE_H = coverage.h $(GCOV_IO_H)\n DEMANGLE_H = $(srcdir)/../include/demangle.h\n@@ -1352,6 +1354,7 @@ OBJS = \\\n \ttimevar.o \\\n \ttoplev.o \\\n \ttracer.o \\\n+\ttrans-mem.o \\\n \ttree-affine.o \\\n \ttree-call-cdce.o \\\n \ttree-cfg.o \\\n@@ -2158,6 +2161,12 @@ gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n \t$(CFGLOOP_H) $(TARGET_H) $(IPA_PROP_H) $(LTO_STREAMER_H) \\\n \ttarget-globals.h\n \n+trans-mem.o : trans-mem.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+\t$(TREE_H) $(GIMPLE_H) $(TREE_FLOW_H) $(TREE_PASS_H) $(TREE_INLINE_H) \\\n+\t$(DIAGNOSTIC_CORE_H) $(DEMANGLE_H) output.h $(TRANS_MEM_H) \\\n+\t$(PARAMS_H) $(TARGET_H) langhooks.h \\\n+\ttree-pretty-print.h gimple-pretty-print.h\n+\n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n \t$(GGC_H) $(HASHTAB_H) $(DIAGNOSTIC_CORE_H) $(PARAMS_H) hosthooks.h\t\\\n \t$(HOSTHOOKS_DEF_H) $(VEC_H) $(PLUGIN_H) $(GGC_INTERNAL_H) $(TIMEVAR_H)\n@@ -2684,6 +2693,7 @@ gimple.o : gimple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n gimple-pretty-print.o : gimple-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(TREE_H) $(DIAGNOSTIC_H) $(HASHTAB_H) $(TREE_FLOW_H) \\\n    $(TM_H) coretypes.h $(TREE_PASS_H) $(GIMPLE_H) value-prof.h \\\n+   $(TRANS_MEM_H) \\\n    tree-pretty-print.h gimple-pretty-print.h\n tree-mudflap.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n    $(GIMPLE_H) $(DIAGNOSTIC_H) $(DEMANGLE_H) $(HASHTAB_H) langhooks.h tree-mudflap.h \\\n@@ -3733,6 +3743,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/lto-symtab.c \\\n   $(srcdir)/tree-ssa-alias.h \\\n   $(srcdir)/ipa-prop.h \\\n+  $(srcdir)/trans-mem.c \\\n   $(srcdir)/lto-streamer.h \\\n   $(srcdir)/target-globals.h \\\n   $(srcdir)/ipa-inline.h \\"}, {"sha": "0e94fd29cb55da9b7be5f42e11e0a5b0427413ef", "filename": "gcc/attribs.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -166,16 +166,18 @@ init_attributes (void)\n \t  gcc_assert (strcmp (attribute_tables[i][j].name,\n \t\t\t      attribute_tables[i][k].name));\n     }\n-  /* Check that no name occurs in more than one table.  */\n+  /* Check that no name occurs in more than one table.  Names that\n+     begin with '*' are exempt, and may be overridden.  */\n   for (i = 0; i < ARRAY_SIZE (attribute_tables); i++)\n     {\n       size_t j, k, l;\n \n       for (j = i + 1; j < ARRAY_SIZE (attribute_tables); j++)\n \tfor (k = 0; attribute_tables[i][k].name != NULL; k++)\n \t  for (l = 0; attribute_tables[j][l].name != NULL; l++)\n-\t    gcc_assert (strcmp (attribute_tables[i][k].name,\n-\t\t\t\tattribute_tables[j][l].name));\n+\t    gcc_assert (attribute_tables[i][k].name[0] == '*'\n+\t\t\t|| strcmp (attribute_tables[i][k].name,\n+\t\t\t\t   attribute_tables[j][l].name));\n     }\n #endif\n \n@@ -207,7 +209,7 @@ register_attribute (const struct attribute_spec *attr)\n   slot = htab_find_slot_with_hash (attribute_hash, &str,\n \t\t\t\t   substring_hash (str.str, str.length),\n \t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n+  gcc_assert (!*slot || attr->name[0] == '*');\n   *slot = (void *) CONST_CAST (struct attribute_spec *, attr);\n }\n \n@@ -484,3 +486,12 @@ decl_attributes (tree *node, tree attributes, int flags)\n \n   return returned_attrs;\n }\n+\n+/* Subroutine of set_method_tm_attributes.  Apply TM attribute ATTR\n+   to the method FNDECL.  */\n+\n+void\n+apply_tm_attr (tree fndecl, tree attr)\n+{\n+  decl_attributes (&TREE_TYPE (fndecl), tree_cons (attr, NULL, NULL), 0);\n+}"}, {"sha": "619794e85c87fbdc339e318032388eb2d08626d4", "filename": "gcc/builtin-attrs.def", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fbuiltin-attrs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fbuiltin-attrs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-attrs.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -96,6 +96,8 @@ DEF_ATTR_IDENT (ATTR_SENTINEL, \"sentinel\")\n DEF_ATTR_IDENT (ATTR_STRFMON, \"strfmon\")\n DEF_ATTR_IDENT (ATTR_STRFTIME, \"strftime\")\n DEF_ATTR_IDENT (ATTR_TYPEGENERIC, \"type generic\")\n+DEF_ATTR_IDENT (ATTR_TM_REGPARM, \"*tm regparm\")\n+DEF_ATTR_IDENT (ATTR_TM_TMPURE, \"transaction_pure\")\n \n DEF_ATTR_TREE_LIST (ATTR_NOVOPS_LIST, ATTR_NOVOPS, ATTR_NULL, ATTR_NULL)\n \n@@ -227,6 +229,26 @@ DEF_FORMAT_ATTRIBUTE_NOTHROW(STRFMON,3,3_4)\n #undef DEF_FORMAT_ATTRIBUTE_NOTHROW\n #undef DEF_FORMAT_ATTRIBUTE_BOTH\n \n+/* Transactional memory variants of the above.  */\n+\n+DEF_ATTR_TREE_LIST (ATTR_TM_NOTHROW_LIST,\n+\t\t    ATTR_TM_REGPARM, ATTR_NULL, ATTR_NOTHROW_LIST)\n+DEF_ATTR_TREE_LIST (ATTR_TM_TMPURE_NOTHROW_LIST,\n+\t\t    ATTR_TM_TMPURE, ATTR_NULL, ATTR_TM_NOTHROW_LIST)\n+DEF_ATTR_TREE_LIST (ATTR_TM_PURE_TMPURE_NOTHROW_LIST,\n+\t\t    ATTR_PURE, ATTR_NULL, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_ATTR_TREE_LIST (ATTR_TM_NORETURN_NOTHROW_LIST,\n+\t\t    ATTR_TM_REGPARM, ATTR_NULL, ATTR_NORETURN_NOTHROW_LIST)\n+DEF_ATTR_TREE_LIST (ATTR_TM_CONST_NOTHROW_LIST,\n+\t\t    ATTR_TM_REGPARM, ATTR_NULL, ATTR_CONST_NOTHROW_LIST)\n+\n+/* Same attributes used for BUILT_IN_MALLOC except with TM_PURE thrown in.  */\n+DEF_ATTR_TREE_LIST (ATTR_TMPURE_MALLOC_NOTHROW_LIST,\n+\t\t   ATTR_TM_TMPURE, ATTR_NULL, ATTR_MALLOC_NOTHROW_LIST)\n+/* Same attributes used for BUILT_IN_FREE except with TM_PURE thrown in.  */\n+DEF_ATTR_TREE_LIST (ATTR_TMPURE_NOTHROW_LIST,\n+\t\t   ATTR_TM_TMPURE, ATTR_NULL, ATTR_NOTHROW_LIST)\n+\n /* Construct a tree for a format_arg attribute.  */\n #define DEF_FORMAT_ARG_ATTRIBUTE(FA)\t\t\t\t\t\\\n   DEF_ATTR_TREE_LIST (ATTR_FORMAT_ARG_##FA, ATTR_FORMAT_ARG,\t\t\\"}, {"sha": "8edf744461ee2278fadec2a0fe407ae363fcaa61", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -530,3 +530,24 @@ DEF_FUNCTION_TYPE_VAR_5 (BT_FN_INT_INT_INT_INT_INT_INT_VAR,\n DEF_POINTER_TYPE (BT_PTR_FN_VOID_VAR, BT_FN_VOID_VAR)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_FN_VOID_VAR_PTR_SIZE,\n \t\t     BT_PTR, BT_PTR_FN_VOID_VAR, BT_PTR, BT_SIZE)\n+\n+\n+DEF_FUNCTION_TYPE_1 (BT_FN_I1_VPTR, BT_I1, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_I2_VPTR, BT_I2, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_I4_VPTR, BT_I4, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_I8_VPTR, BT_I8, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_VPTR, BT_FLOAT, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_VPTR, BT_DOUBLE, BT_VOLATILE_PTR)\n+DEF_FUNCTION_TYPE_1 (BT_FN_LDOUBLE_VPTR, BT_LONGDOUBLE, BT_VOLATILE_PTR)\n+\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_I1, BT_VOID, BT_VOLATILE_PTR, BT_I1)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_I2, BT_VOID, BT_VOLATILE_PTR, BT_I2)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_I4, BT_VOID, BT_VOLATILE_PTR, BT_I4)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_I8, BT_VOID, BT_VOLATILE_PTR, BT_I8)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_FLOAT, BT_VOID, BT_VOLATILE_PTR, BT_FLOAT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_DOUBLE, BT_VOID,\n+\t\t     BT_VOLATILE_PTR, BT_DOUBLE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_LDOUBLE, BT_VOID,\n+\t\t     BT_VOLATILE_PTR, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VPTR_SIZE, BT_VOID,\n+\t\t     BT_VOLATILE_PTR, BT_SIZE)"}, {"sha": "616fca7359726077c75c679261c3b49c276e2138", "filename": "gcc/builtins.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -142,6 +142,13 @@ along with GCC; see the file COPYING3.  If not see\n                false, true, true, ATTRS, false, \\\n \t       (flag_openmp || flag_tree_parallelize_loops))\n \n+/* Builtin used by the implementation of GNU TM.  These\n+   functions are mapped to the actual implementation of the STM library. */\n+#undef DEF_TM_BUILTIN\n+#define DEF_TM_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+\t       false, true, true, ATTRS, false, flag_tm)\n+\n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for\n    `errno'.  If !flag_errno_math they are instead \"const\".  */\n@@ -624,6 +631,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_APPLY_ARGS, \"apply_args\", BT_FN_PTR_VAR, ATTR_L\n DEF_GCC_BUILTIN        (BUILT_IN_BSWAP32, \"bswap32\", BT_FN_UINT32_UINT32, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_BSWAP64, \"bswap64\", BT_FN_UINT64_UINT64, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_CLEAR_CACHE, \"__clear_cache\", BT_FN_VOID_PTR_PTR, ATTR_NOTHROW_LEAF_LIST)\n+/* [trans-mem]: Adjust BUILT_IN_TM_CALLOC if BUILT_IN_CALLOC is changed.  */\n DEF_LIB_BUILTIN        (BUILT_IN_CALLOC, \"calloc\", BT_FN_PTR_SIZE_SIZE, ATTR_MALLOC_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_CLASSIFY_TYPE, \"classify_type\", BT_FN_INT_VAR, ATTR_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_CLZ, \"clz\", BT_FN_INT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -662,6 +670,7 @@ DEF_EXT_LIB_BUILTIN    (BUILT_IN_FFSL, \"ffsl\", BT_FN_INT_LONG, ATTR_CONST_NOTHRO\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_FFSLL, \"ffsll\", BT_FN_INT_LONGLONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN        (BUILT_IN_FORK, \"fork\", BT_FN_PID, ATTR_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_FRAME_ADDRESS, \"frame_address\", BT_FN_PTR_UINT, ATTR_NULL)\n+/* [trans-mem]: Adjust BUILT_IN_TM_FREE if BUILT_IN_FREE is changed.  */\n DEF_LIB_BUILTIN        (BUILT_IN_FREE, \"free\", BT_FN_VOID_PTR, ATTR_NOTHROW_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_FROB_RETURN_ADDR, \"frob_return_addr\", BT_FN_PTR_PTR, ATTR_NULL)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_GETTEXT, \"gettext\", BT_FN_STRING_CONST_STRING, ATTR_FORMAT_ARG_1)\n@@ -698,6 +707,7 @@ DEF_GCC_BUILTIN        (BUILT_IN_ISUNORDERED, \"isunordered\", BT_FN_INT_VAR, ATTR\n DEF_LIB_BUILTIN        (BUILT_IN_LABS, \"labs\", BT_FN_LONG_LONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_C99_BUILTIN        (BUILT_IN_LLABS, \"llabs\", BT_FN_LONGLONG_LONGLONG, ATTR_CONST_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_LONGJMP, \"longjmp\", BT_FN_VOID_PTR_INT, ATTR_NORETURN_NOTHROW_LEAF_LIST)\n+/* [trans-mem]: Adjust BUILT_IN_TM_MALLOC if BUILT_IN_MALLOC is changed.  */\n DEF_LIB_BUILTIN        (BUILT_IN_MALLOC, \"malloc\", BT_FN_PTR_SIZE, ATTR_MALLOC_NOTHROW_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_NEXT_ARG, \"next_arg\", BT_FN_PTR_VAR, ATTR_LEAF_LIST)\n DEF_GCC_BUILTIN        (BUILT_IN_PARITY, \"parity\", BT_FN_INT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n@@ -793,3 +803,6 @@ DEF_BUILTIN_STUB (BUILT_IN_EH_COPY_VALUES, \"__builtin_eh_copy_values\")\n \n /* OpenMP builtins.  */\n #include \"omp-builtins.def\"\n+\n+/* GTM builtins. */\n+#include \"gtm-builtins.def\""}, {"sha": "914c9163dc88f429545257af1756c51903924c6e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,19 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Torvald Riegel  <triegel@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* c-common.c (handle_tm_wrap_attribute,\n+\thandle_tm_attribute, ignore_attribute, parse_tm_stmt_attr): New.\n+\t(struct c_common_reswords): Added __transaction* keywords.\n+\t(struct c_common_attribute_table): Added transaction* and tm_regparm\n+\tattributes.\n+\t* c-common.h: Added RID_TRANSACTION*. Added TM_ATTR* and TM_STMT*\n+\tmasks.\n+\t(parse_tm_stmt_attr, tm_attr_to_mask, tm_mask_to_attr,\n+\tfind_tm_attribute): Declare.\n+\n 2011-11-07  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/35688"}, {"sha": "a68233113217fa0622e44fd2293649b94327929e", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -357,6 +357,8 @@ static tree handle_returns_twice_attribute (tree *, tree, tree, int, bool *);\n static tree handle_no_limit_stack_attribute (tree *, tree, tree, int,\n \t\t\t\t\t     bool *);\n static tree handle_pure_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_tm_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_tm_wrap_attribute (tree *, tree, tree, int, bool *);\n static tree handle_novops_attribute (tree *, tree, tree, int, bool *);\n static tree handle_deprecated_attribute (tree *, tree, tree, int,\n \t\t\t\t\t bool *);\n@@ -372,6 +374,7 @@ static tree handle_type_generic_attribute (tree *, tree, tree, int, bool *);\n static tree handle_alloc_size_attribute (tree *, tree, tree, int, bool *);\n static tree handle_target_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n+static tree ignore_attribute (tree *, tree, tree, int, bool *);\n static tree handle_no_split_stack_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n \n@@ -474,6 +477,9 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__signed\",\t\tRID_SIGNED,\t0 },\n   { \"__signed__\",\tRID_SIGNED,\t0 },\n   { \"__thread\",\t\tRID_THREAD,\t0 },\n+  { \"__transaction_atomic\", RID_TRANSACTION_ATOMIC, 0 },\n+  { \"__transaction_relaxed\", RID_TRANSACTION_RELAXED, 0 },\n+  { \"__transaction_cancel\", RID_TRANSACTION_CANCEL, 0 },\n   { \"__typeof\",\t\tRID_TYPEOF,\t0 },\n   { \"__typeof__\",\tRID_TYPEOF,\t0 },\n   { \"__underlying_type\", RID_UNDERLYING_TYPE, D_CXXONLY },\n@@ -666,6 +672,20 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_no_limit_stack_attribute, false },\n   { \"pure\",                   0, 0, true,  false, false,\n \t\t\t      handle_pure_attribute, false },\n+  { \"transaction_callable\",   0, 0, false, true,  false,\n+\t\t\t      handle_tm_attribute, false },\n+  { \"transaction_unsafe\",     0, 0, false, true,  false,\n+\t\t\t      handle_tm_attribute, false },\n+  { \"transaction_safe\",       0, 0, false, true,  false,\n+\t\t\t      handle_tm_attribute, false },\n+  { \"transaction_may_cancel_outer\", 0, 0, false, true, false,\n+\t\t\t      handle_tm_attribute, false },\n+  /* ??? These two attributes didn't make the transition from the\n+     Intel language document to the multi-vendor language document.  */\n+  { \"transaction_pure\",       0, 0, false, true,  false,\n+\t\t\t      handle_tm_attribute, false },\n+  { \"transaction_wrap\",       1, 1, true,  false,  false,\n+\t\t\t     handle_tm_wrap_attribute, false },\n   /* For internal use (marking of builtins) only.  The name contains space\n      to prevent its usage in source code.  */\n   { \"no vops\",                0, 0, true,  false, false,\n@@ -707,6 +727,10 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      handle_target_attribute, false },\n   { \"optimize\",               1, -1, true, false, false,\n \t\t\t      handle_optimize_attribute, false },\n+  /* For internal use only.  The leading '*' both prevents its usage in\n+     source code and signals that it may be overridden by machine tables.  */\n+  { \"*tm regparm\",            0, 0, false, true, true,\n+\t\t\t      ignore_attribute, false },\n   { \"no_split_stack\",\t      0, 0, true,  false, false,\n \t\t\t      handle_no_split_stack_attribute, false },\n   /* For internal use (marking of builtins and runtime functions) only.\n@@ -7315,6 +7339,223 @@ handle_pure_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n   return NULL_TREE;\n }\n \n+/* Digest an attribute list destined for a transactional memory statement.\n+   ALLOWED is the set of attributes that are allowed for this statement;\n+   return the attribute we parsed.  Multiple attributes are never allowed.  */\n+\n+int\n+parse_tm_stmt_attr (tree attrs, int allowed)\n+{\n+  tree a_seen = NULL;\n+  int m_seen = 0;\n+\n+  for ( ; attrs ; attrs = TREE_CHAIN (attrs))\n+    {\n+      tree a = TREE_PURPOSE (attrs);\n+      int m = 0;\n+\n+      if (is_attribute_p (\"outer\", a))\n+\tm = TM_STMT_ATTR_OUTER;\n+\n+      if ((m & allowed) == 0)\n+\t{\n+\t  warning (OPT_Wattributes, \"%qE attribute directive ignored\", a);\n+\t  continue;\n+\t}\n+\n+      if (m_seen == 0)\n+\t{\n+\t  a_seen = a;\n+\t  m_seen = m;\n+\t}\n+      else if (m_seen == m)\n+\twarning (OPT_Wattributes, \"%qE attribute duplicated\", a);\n+      else\n+\twarning (OPT_Wattributes, \"%qE attribute follows %qE\", a, a_seen);\n+    }\n+\n+  return m_seen;\n+}\n+\n+/* Transform a TM attribute name into a maskable integer and back.\n+   Note that NULL (i.e. no attribute) is mapped to UNKNOWN, corresponding\n+   to how the lack of an attribute is treated.  */\n+\n+int\n+tm_attr_to_mask (tree attr)\n+{\n+  if (attr == NULL)\n+    return 0;\n+  if (is_attribute_p (\"transaction_safe\", attr))\n+    return TM_ATTR_SAFE;\n+  if (is_attribute_p (\"transaction_callable\", attr))\n+    return TM_ATTR_CALLABLE;\n+  if (is_attribute_p (\"transaction_pure\", attr))\n+    return TM_ATTR_PURE;\n+  if (is_attribute_p (\"transaction_unsafe\", attr))\n+    return TM_ATTR_IRREVOCABLE;\n+  if (is_attribute_p (\"transaction_may_cancel_outer\", attr))\n+    return TM_ATTR_MAY_CANCEL_OUTER;\n+  return 0;\n+}\n+\n+tree\n+tm_mask_to_attr (int mask)\n+{\n+  const char *str;\n+  switch (mask)\n+    {\n+    case TM_ATTR_SAFE:\n+      str = \"transaction_safe\";\n+      break;\n+    case TM_ATTR_CALLABLE:\n+      str = \"transaction_callable\";\n+      break;\n+    case TM_ATTR_PURE:\n+      str = \"transaction_pure\";\n+      break;\n+    case TM_ATTR_IRREVOCABLE:\n+      str = \"transaction_unsafe\";\n+      break;\n+    case TM_ATTR_MAY_CANCEL_OUTER:\n+      str = \"transaction_may_cancel_outer\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return get_identifier (str);\n+}\n+\n+/* Return the first TM attribute seen in LIST.  */\n+\n+tree\n+find_tm_attribute (tree list)\n+{\n+  for (; list ; list = TREE_CHAIN (list))\n+    {\n+      tree name = TREE_PURPOSE (list);\n+      if (tm_attr_to_mask (name) != 0)\n+\treturn name;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Handle the TM attributes; arguments as in struct attribute_spec.handler.\n+   Here we accept only function types, and verify that none of the other\n+   function TM attributes are also applied.  */\n+/* ??? We need to accept class types for C++, but not C.  This greatly\n+   complicates this function, since we can no longer rely on the extra\n+   processing given by function_type_required.  */\n+\n+static tree\n+handle_tm_attribute (tree *node, tree name, tree args,\n+\t\t     int flags, bool *no_add_attrs)\n+{\n+  /* Only one path adds the attribute; others don't.  */\n+  *no_add_attrs = true;\n+\n+  switch (TREE_CODE (*node))\n+    {\n+    case RECORD_TYPE:\n+    case UNION_TYPE:\n+      /* Only tm_callable and tm_safe apply to classes.  */\n+      if (tm_attr_to_mask (name) & ~(TM_ATTR_SAFE | TM_ATTR_CALLABLE))\n+\tgoto ignored;\n+      /* FALLTHRU */\n+\n+    case FUNCTION_TYPE:\n+    case METHOD_TYPE:\n+      {\n+\ttree old_name = find_tm_attribute (TYPE_ATTRIBUTES (*node));\n+\tif (old_name == name)\n+\t  ;\n+\telse if (old_name != NULL_TREE)\n+\t  error (\"type was previously declared %qE\", old_name);\n+\telse\n+\t  *no_add_attrs = false;\n+      }\n+      break;\n+\n+    case POINTER_TYPE:\n+      {\n+\tenum tree_code subcode = TREE_CODE (TREE_TYPE (*node));\n+\tif (subcode == FUNCTION_TYPE || subcode == METHOD_TYPE)\n+\t  {\n+\t    tree fn_tmp = TREE_TYPE (*node);\n+\t    decl_attributes (&fn_tmp, tree_cons (name, args, NULL), 0);\n+\t    *node = build_pointer_type (fn_tmp);\n+\t    break;\n+\t  }\n+      }\n+      /* FALLTHRU */\n+\n+    default:\n+      /* If a function is next, pass it on to be tried next.  */\n+      if (flags & (int) ATTR_FLAG_FUNCTION_NEXT)\n+\treturn tree_cons (name, args, NULL);\n+\n+    ignored:\n+      warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle the TM_WRAP attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_tm_wrap_attribute (tree *node, tree name, tree args,\n+\t\t\t  int ARG_UNUSED (flags), bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+\n+  /* We don't need the attribute even on success, since we\n+     record the entry in an external table.  */\n+  *no_add_attrs = true;\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    warning (OPT_Wattributes, \"%qE attribute ignored\", name);\n+  else\n+    {\n+      tree wrap_decl = TREE_VALUE (args);\n+      if (TREE_CODE (wrap_decl) != IDENTIFIER_NODE\n+\t  && TREE_CODE (wrap_decl) != VAR_DECL\n+\t  && TREE_CODE (wrap_decl) != FUNCTION_DECL)\n+\terror (\"%qE argument not an identifier\", name);\n+      else\n+\t{\n+\t  if (TREE_CODE (wrap_decl) == IDENTIFIER_NODE)\n+\t    wrap_decl = lookup_name (wrap_decl);\n+\t  if (wrap_decl && TREE_CODE (wrap_decl) == FUNCTION_DECL)\n+\t    {\n+\t      if (lang_hooks.types_compatible_p (TREE_TYPE (decl),\n+\t\t\t\t\t\t TREE_TYPE (wrap_decl)))\n+\t\trecord_tm_replacement (wrap_decl, decl);\n+\t      else\n+\t\terror (\"%qD is not compatible with %qD\", wrap_decl, decl);\n+\t    }\n+\t  else\n+\t    error (\"transaction_wrap argument is not a function\");\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Ignore the given attribute.  Used when this attribute may be usefully\n+   overridden by the target, but is not used generically.  */\n+\n+static tree\n+ignore_attribute (tree * ARG_UNUSED (node), tree ARG_UNUSED (name),\n+\t\t  tree ARG_UNUSED (args), int ARG_UNUSED (flags),\n+\t\t  bool *no_add_attrs)\n+{\n+  *no_add_attrs = true;\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"no vops\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "4d65dd1b7f1760163c7fd77aac23665b73057cfa", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -113,6 +113,9 @@ enum rid\n      as a normal identifier.  */\n   RID_CXX_COMPAT_WARN,\n \n+  /* GNU transactional memory extension */\n+  RID_TRANSACTION_ATOMIC, RID_TRANSACTION_RELAXED, RID_TRANSACTION_CANCEL,\n+\n   /* Too many ways of getting the name of a function as a string */\n   RID_FUNCTION_NAME, RID_PRETTY_FUNCTION_NAME, RID_C99_FUNCTION_NAME,\n \n@@ -1073,6 +1076,28 @@ c_tree_chain_next (tree t)\n   return NULL;\n }\n \n+/* Mask used by tm_stmt_attr.  */\n+#define TM_STMT_ATTR_OUTER\t2\n+#define TM_STMT_ATTR_ATOMIC\t4\n+#define TM_STMT_ATTR_RELAXED\t8\n+\n+extern int parse_tm_stmt_attr (tree, int);\n+\n+/* Mask used by tm_attr_to_mask and tm_mask_to_attr.  Note that these\n+   are ordered specifically such that more restrictive attributes are\n+   at lower bit positions.  This fact is known by the C++ tm attribute\n+   inheritance code such that least bit extraction (mask & -mask) results\n+   in the most restrictive attribute.  */\n+#define TM_ATTR_SAFE\t\t\t1\n+#define TM_ATTR_CALLABLE\t\t2\n+#define TM_ATTR_PURE\t\t\t4\n+#define TM_ATTR_IRREVOCABLE\t\t8\n+#define TM_ATTR_MAY_CANCEL_OUTER\t16\n+\n+extern int tm_attr_to_mask (tree);\n+extern tree tm_mask_to_attr (int);\n+extern tree find_tm_attribute (tree);\n+\n /* A suffix-identifier value doublet that represents user-defined literals\n    for C++-0x.  */\n struct GTY(()) tree_userdef_literal {"}, {"sha": "aed390f31e8f9cbe20bb5f2472baea35d248fa39", "filename": "gcc/c-parser.c", "status": "modified", "additions": 301, "deletions": 52, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -195,6 +195,9 @@ typedef struct GTY(()) c_parser {\n      undesirable to bind an identifier to an Objective-C class, even\n      if a class with that name exists.  */\n   BOOL_BITFIELD objc_need_raw_identifier : 1;\n+  /* Nonzero if we're processing a __transaction statement.  The value\n+     is 1 | TM_STMT_ATTR_*.  */\n+  unsigned int in_transaction : 4;\n   /* True if we are in a context where the Objective-C \"Property attribute\"\n      keywords are valid.  */\n   BOOL_BITFIELD objc_property_attr_context : 1;\n@@ -1171,6 +1174,9 @@ static struct c_expr c_parser_postfix_expression_after_paren_type (c_parser *,\n static struct c_expr c_parser_postfix_expression_after_primary (c_parser *,\n \t\t\t\t\t\t\t\tlocation_t loc,\n \t\t\t\t\t\t\t\tstruct c_expr);\n+static tree c_parser_transaction (c_parser *, enum rid);\n+static struct c_expr c_parser_transaction_expression (c_parser *, enum rid);\n+static tree c_parser_transaction_cancel (c_parser *);\n static struct c_expr c_parser_expression (c_parser *);\n static struct c_expr c_parser_expression_conv (c_parser *);\n static VEC(tree,gc) *c_parser_expr_list (c_parser *, bool, bool,\n@@ -3413,6 +3419,66 @@ c_parser_simple_asm_expr (c_parser *parser)\n   return str;\n }\n \n+static tree\n+c_parser_attribute_any_word (c_parser *parser)\n+{\n+  tree attr_name = NULL_TREE;\n+\n+  if (c_parser_next_token_is (parser, CPP_KEYWORD))\n+    {\n+      /* ??? See comment above about what keywords are accepted here.  */\n+      bool ok;\n+      switch (c_parser_peek_token (parser)->keyword)\n+\t{\n+\tcase RID_STATIC:\n+\tcase RID_UNSIGNED:\n+\tcase RID_LONG:\n+\tcase RID_INT128:\n+\tcase RID_CONST:\n+\tcase RID_EXTERN:\n+\tcase RID_REGISTER:\n+\tcase RID_TYPEDEF:\n+\tcase RID_SHORT:\n+\tcase RID_INLINE:\n+\tcase RID_NORETURN:\n+\tcase RID_VOLATILE:\n+\tcase RID_SIGNED:\n+\tcase RID_AUTO:\n+\tcase RID_RESTRICT:\n+\tcase RID_COMPLEX:\n+\tcase RID_THREAD:\n+\tcase RID_INT:\n+\tcase RID_CHAR:\n+\tcase RID_FLOAT:\n+\tcase RID_DOUBLE:\n+\tcase RID_VOID:\n+\tcase RID_DFLOAT32:\n+\tcase RID_DFLOAT64:\n+\tcase RID_DFLOAT128:\n+\tcase RID_BOOL:\n+\tcase RID_FRACT:\n+\tcase RID_ACCUM:\n+\tcase RID_SAT:\n+\tcase RID_TRANSACTION_ATOMIC:\n+\tcase RID_TRANSACTION_CANCEL:\n+\t  ok = true;\n+\t  break;\n+\tdefault:\n+\t  ok = false;\n+\t  break;\n+\t}\n+      if (!ok)\n+\treturn NULL_TREE;\n+\n+      /* Accept __attribute__((__const)) as __attribute__((const)) etc.  */\n+      attr_name = ridpointers[(int) c_parser_peek_token (parser)->keyword];\n+    }\n+  else if (c_parser_next_token_is (parser, CPP_NAME))\n+    attr_name = c_parser_peek_token (parser)->value;\n+\n+  return attr_name;\n+}\n+\n /* Parse (possibly empty) attributes.  This is a GNU extension.\n \n    attributes:\n@@ -3473,57 +3539,10 @@ c_parser_attributes (c_parser *parser)\n \t      c_parser_consume_token (parser);\n \t      continue;\n \t    }\n-\t  if (c_parser_next_token_is (parser, CPP_KEYWORD))\n-\t    {\n-\t      /* ??? See comment above about what keywords are\n-\t\t accepted here.  */\n-\t      bool ok;\n-\t      switch (c_parser_peek_token (parser)->keyword)\n-\t\t{\n-\t\tcase RID_STATIC:\n-\t\tcase RID_UNSIGNED:\n-\t\tcase RID_LONG:\n-\t\tcase RID_INT128:\n-\t\tcase RID_CONST:\n-\t\tcase RID_EXTERN:\n-\t\tcase RID_REGISTER:\n-\t\tcase RID_TYPEDEF:\n-\t\tcase RID_SHORT:\n-\t\tcase RID_INLINE:\n-\t\tcase RID_NORETURN:\n-\t\tcase RID_VOLATILE:\n-\t\tcase RID_SIGNED:\n-\t\tcase RID_AUTO:\n-\t\tcase RID_RESTRICT:\n-\t\tcase RID_COMPLEX:\n-\t\tcase RID_THREAD:\n-\t\tcase RID_INT:\n-\t\tcase RID_CHAR:\n-\t\tcase RID_FLOAT:\n-\t\tcase RID_DOUBLE:\n-\t\tcase RID_VOID:\n-\t\tcase RID_DFLOAT32:\n-\t\tcase RID_DFLOAT64:\n-\t\tcase RID_DFLOAT128:\n-\t\tcase RID_BOOL:\n-\t\tcase RID_FRACT:\n-\t\tcase RID_ACCUM:\n-\t\tcase RID_SAT:\n-\t\t  ok = true;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  ok = false;\n-\t\t  break;\n-\t\t}\n-\t      if (!ok)\n-\t\tbreak;\n-\t      /* Accept __attribute__((__const)) as __attribute__((const))\n-\t\t etc.  */\n-\t      attr_name\n-\t\t= ridpointers[(int) c_parser_peek_token (parser)->keyword];\n-\t    }\n-\t  else\n-\t    attr_name = c_parser_peek_token (parser)->value;\n+\n+\t  attr_name = c_parser_attribute_any_word (parser);\n+\t  if (attr_name == NULL)\n+\t    break;\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is_not (parser, CPP_OPEN_PAREN))\n \t    {\n@@ -4394,7 +4413,14 @@ c_parser_label (c_parser *parser)\n      atomic-directive expression-statement\n \n    ordered-construct:\n-     ordered-directive structured-block  */\n+     ordered-directive structured-block\n+\n+   Transactional Memory:\n+\n+   statement:\n+     transaction-statement\n+     transaction-cancel-statement\n+*/\n \n static void\n c_parser_statement (c_parser *parser)\n@@ -4485,6 +4511,14 @@ c_parser_statement_after_labels (c_parser *parser)\n \tcase RID_ASM:\n \t  stmt = c_parser_asm_statement (parser);\n \t  break;\n+\tcase RID_TRANSACTION_ATOMIC:\n+\tcase RID_TRANSACTION_RELAXED:\n+\t  stmt = c_parser_transaction (parser,\n+\t      c_parser_peek_token (parser)->keyword);\n+\t  break;\n+\tcase RID_TRANSACTION_CANCEL:\n+\t  stmt = c_parser_transaction_cancel (parser);\n+\t  goto expect_semicolon;\n \tcase RID_AT_THROW:\n \t  gcc_assert (c_dialect_objc ());\n \t  c_parser_consume_token (parser);\n@@ -5812,6 +5846,11 @@ c_parser_cast_expression (c_parser *parser, struct c_expr *after)\n    unary-operator: one of\n      __extension__ __real__ __imag__\n \n+   Transactional Memory:\n+\n+   unary-expression:\n+     transaction-expression\n+\n    In addition, the GNU syntax treats ++ and -- as unary operators, so\n    they may be applied to cast expressions with errors for non-lvalues\n    given later.  */\n@@ -5919,6 +5958,10 @@ c_parser_unary_expression (c_parser *parser)\n \t  op = c_parser_cast_expression (parser, NULL);\n \t  op = default_function_array_conversion (exp_loc, op);\n \t  return parser_build_unary_op (op_loc, IMAGPART_EXPR, op);\n+\tcase RID_TRANSACTION_ATOMIC:\n+\tcase RID_TRANSACTION_RELAXED:\n+\t  return c_parser_transaction_expression (parser,\n+\t      c_parser_peek_token (parser)->keyword);\n \tdefault:\n \t  return c_parser_postfix_expression (parser);\n \t}\n@@ -10535,6 +10578,212 @@ c_parser_omp_threadprivate (c_parser *parser)\n   c_parser_skip_to_pragma_eol (parser);\n }\n \n+/* Parse a transaction attribute (GCC Extension).\n+\n+   transaction-attribute:\n+     attributes\n+     [ [ any-word ] ]\n+\n+   The transactional memory language description is written for C++,\n+   and uses the C++0x attribute syntax.  For compatibility, allow the\n+   bracket style for transactions in C as well.  */\n+\n+static tree\n+c_parser_transaction_attributes (c_parser *parser)\n+{\n+  tree attr_name, attr = NULL;\n+\n+  if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n+    return c_parser_attributes (parser);\n+\n+  if (!c_parser_next_token_is (parser, CPP_OPEN_SQUARE))\n+    return NULL_TREE;\n+  c_parser_consume_token (parser);\n+  if (!c_parser_require (parser, CPP_OPEN_SQUARE, \"expected %<[%>\"))\n+    goto error1;\n+\n+  attr_name = c_parser_attribute_any_word (parser);\n+  if (attr_name)\n+    {\n+      c_parser_consume_token (parser);\n+      attr = build_tree_list (attr_name, NULL_TREE);\n+    }\n+  else\n+    c_parser_error (parser, \"expected identifier\");\n+\n+  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+ error1:\n+  c_parser_skip_until_found (parser, CPP_CLOSE_SQUARE, \"expected %<]%>\");\n+  return attr;\n+}\n+\n+/* Parse a __transaction_atomic or __transaction_relaxed statement\n+   (GCC Extension).\n+\n+   transaction-statement:\n+     __transaction_atomic transaction-attribute[opt] compound-statement\n+     __transaction_relaxed compound-statement\n+\n+   Note that the only valid attribute is: \"outer\".\n+*/\n+\n+static tree\n+c_parser_transaction (c_parser *parser, enum rid keyword)\n+{\n+  unsigned int old_in = parser->in_transaction;\n+  unsigned int this_in = 1, new_in;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree stmt, attrs;\n+\n+  gcc_assert ((keyword == RID_TRANSACTION_ATOMIC\n+      || keyword == RID_TRANSACTION_RELAXED)\n+      && c_parser_next_token_is_keyword (parser, keyword));\n+  c_parser_consume_token (parser);\n+\n+  if (keyword == RID_TRANSACTION_RELAXED)\n+    this_in |= TM_STMT_ATTR_RELAXED;\n+  else\n+    {\n+      attrs = c_parser_transaction_attributes (parser);\n+      if (attrs)\n+\tthis_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);\n+    }\n+\n+  /* Keep track if we're in the lexical scope of an outer transaction.  */\n+  new_in = this_in | (old_in & TM_STMT_ATTR_OUTER);\n+\n+  parser->in_transaction = new_in;\n+  stmt = c_parser_compound_statement (parser);\n+  parser->in_transaction = old_in;\n+\n+  if (flag_tm)\n+    stmt = c_finish_transaction (loc, stmt, this_in);\n+  else\n+    error_at (loc, (keyword == RID_TRANSACTION_ATOMIC ?\n+\t\"%<__transaction_atomic%> without transactional memory support enabled\"\n+\t: \"%<__transaction_relaxed %> \"\n+\t\"without transactional memory support enabled\"));\n+\n+  return stmt;\n+}\n+\n+/* Parse a __transaction_atomic or __transaction_relaxed expression\n+   (GCC Extension).\n+\n+   transaction-expression:\n+     __transaction_atomic ( expression )\n+     __transaction_relaxed ( expression )\n+*/\n+\n+static struct c_expr\n+c_parser_transaction_expression (c_parser *parser, enum rid keyword)\n+{\n+  struct c_expr ret;\n+  unsigned int old_in = parser->in_transaction;\n+  unsigned int this_in = 1;\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree attrs;\n+\n+  gcc_assert ((keyword == RID_TRANSACTION_ATOMIC\n+      || keyword == RID_TRANSACTION_RELAXED)\n+      && c_parser_next_token_is_keyword (parser, keyword));\n+  c_parser_consume_token (parser);\n+\n+  if (keyword == RID_TRANSACTION_RELAXED)\n+    this_in |= TM_STMT_ATTR_RELAXED;\n+  else\n+    {\n+      attrs = c_parser_transaction_attributes (parser);\n+      if (attrs)\n+\tthis_in |= parse_tm_stmt_attr (attrs, 0);\n+    }\n+\n+  parser->in_transaction = this_in;\n+  if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+    {\n+      tree expr = c_parser_expression (parser).value;\n+      ret.original_type = TREE_TYPE (expr);\n+      ret.value = build1 (TRANSACTION_EXPR, ret.original_type, expr);\n+      if (this_in & TM_STMT_ATTR_RELAXED)\n+\tTRANSACTION_EXPR_RELAXED (ret.value) = 1;\n+      SET_EXPR_LOCATION (ret.value, loc);\n+      ret.original_code = TRANSACTION_EXPR;\n+    }\n+  else\n+    {\n+      c_parser_error (parser, \"expected %<(%>\");\n+      ret.value = error_mark_node;\n+      ret.original_code = ERROR_MARK;\n+      ret.original_type = NULL;\n+    }\n+  parser->in_transaction = old_in;\n+\n+  if (!flag_tm)\n+    error_at (loc, (keyword == RID_TRANSACTION_ATOMIC ?\n+\t\"%<__transaction_atomic%> without transactional memory support enabled\"\n+\t: \"%<__transaction_relaxed %> \"\n+\t\"without transactional memory support enabled\"));\n+\n+  return ret;\n+}\n+\n+/* Parse a __transaction_cancel statement (GCC Extension).\n+\n+   transaction-cancel-statement:\n+     __transaction_cancel transaction-attribute[opt] ;\n+\n+   Note that the only valid attribute is \"outer\".\n+*/\n+\n+static tree\n+c_parser_transaction_cancel(c_parser *parser)\n+{\n+  location_t loc = c_parser_peek_token (parser)->location;\n+  tree attrs;\n+  bool is_outer = false;\n+\n+  gcc_assert (c_parser_next_token_is_keyword (parser, RID_TRANSACTION_CANCEL));\n+  c_parser_consume_token (parser);\n+\n+  attrs = c_parser_transaction_attributes (parser);\n+  if (attrs)\n+    is_outer = (parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER) != 0);\n+\n+  if (!flag_tm)\n+    {\n+      error_at (loc, \"%<__transaction_cancel%> without \"\n+\t\t\"transactional memory support enabled\");\n+      goto ret_error;\n+    }\n+  else if (parser->in_transaction & TM_STMT_ATTR_RELAXED)\n+    {\n+      error_at (loc, \"%<__transaction_cancel%> within a \"\n+\t\t\"%<__transaction_relaxed%>\");\n+      goto ret_error;\n+    }\n+  else if (is_outer)\n+    {\n+      if ((parser->in_transaction & TM_STMT_ATTR_OUTER) == 0\n+\t  && !is_tm_may_cancel_outer (current_function_decl))\n+\t{\n+\t  error_at (loc, \"outer %<__transaction_cancel%> not \"\n+\t\t    \"within outer %<__transaction_atomic%>\");\n+\t  error_at (loc, \"  or a %<transaction_may_cancel_outer%> function\");\n+\t  goto ret_error;\n+\t}\n+    }\n+  else if (parser->in_transaction == 0)\n+    {\n+      error_at (loc, \"%<__transaction_cancel%> not within \"\n+\t\t\"%<__transaction_atomic%>\");\n+      goto ret_error;\n+    }\n+\n+  return add_stmt (build_tm_abort_call (loc, is_outer));\n+\n+ ret_error:\n+  return build1 (NOP_EXPR, void_type_node, error_mark_node);\n+}\n \f\n /* Parse a single source file.  */\n "}, {"sha": "51c660c0346b3cfcc513ea2b21fc9f34e9181248", "filename": "gcc/c-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -603,6 +603,7 @@ extern tree c_begin_omp_task (void);\n extern tree c_finish_omp_task (location_t, tree, tree);\n extern tree c_finish_omp_clauses (tree);\n extern tree c_build_va_arg (location_t, tree, tree);\n+extern tree c_finish_transaction (location_t, tree, int);\n extern tree c_build_vec_perm_expr (location_t, tree, tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if"}, {"sha": "4a134b0e52412ed206170d6288482ee3fe40a209", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -2716,6 +2716,9 @@ build_function_call_vec (location_t loc, tree function, VEC(tree,gc) *params,\n \treturn tem;\n \n       name = DECL_NAME (function);\n+\n+      if (flag_tm)\n+\ttm_malloc_replacement (function);\n       fundecl = function;\n       /* Atomic functions have type checking/casting already done.  They are \n \t often rewritten and don't match the original parameter list.  */\n@@ -10922,6 +10925,19 @@ c_finish_omp_clauses (tree clauses)\n   return clauses;\n }\n \n+/* Create a transaction node.  */\n+\n+tree\n+c_finish_transaction (location_t loc, tree block, int flags)\n+{\n+  tree stmt = build_stmt (loc, TRANSACTION_EXPR, block);\n+  if (flags & TM_STMT_ATTR_OUTER)\n+    TRANSACTION_EXPR_OUTER (stmt) = 1;\n+  if (flags & TM_STMT_ATTR_RELAXED)\n+    TRANSACTION_EXPR_RELAXED (stmt) = 1;\n+  return add_stmt (stmt);\n+}\n+\n /* Make a variant type in the proper way for C/C++, propagating qualifiers\n    down to the element type of an array.  */\n "}, {"sha": "382de7fcdebedbc74b76ebc940c70a9c0905677d", "filename": "gcc/calls.c", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -611,6 +611,69 @@ alloca_call_p (const_tree exp)\n   return false;\n }\n \n+/* Return TRUE if FNDECL is either a TM builtin or a TM cloned\n+   function.  Return FALSE otherwise.  */\n+\n+static bool\n+is_tm_builtin (const_tree fndecl)\n+{\n+  if (fndecl == NULL)\n+    return false;\n+\n+  if (decl_is_tm_clone (fndecl))\n+    return true;\n+\n+  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n+    {\n+      switch (DECL_FUNCTION_CODE (fndecl))\n+\t{\n+\tcase BUILT_IN_TM_COMMIT:\n+\tcase BUILT_IN_TM_COMMIT_EH:\n+\tcase BUILT_IN_TM_ABORT:\n+\tcase BUILT_IN_TM_IRREVOCABLE:\n+\tcase BUILT_IN_TM_GETTMCLONE_IRR:\n+\tcase BUILT_IN_TM_MEMCPY:\n+\tcase BUILT_IN_TM_MEMMOVE:\n+\tcase BUILT_IN_TM_MEMSET:\n+\tCASE_BUILT_IN_TM_STORE (1):\n+\tCASE_BUILT_IN_TM_STORE (2):\n+\tCASE_BUILT_IN_TM_STORE (4):\n+\tCASE_BUILT_IN_TM_STORE (8):\n+\tCASE_BUILT_IN_TM_STORE (FLOAT):\n+\tCASE_BUILT_IN_TM_STORE (DOUBLE):\n+\tCASE_BUILT_IN_TM_STORE (LDOUBLE):\n+\tCASE_BUILT_IN_TM_STORE (M64):\n+\tCASE_BUILT_IN_TM_STORE (M128):\n+\tCASE_BUILT_IN_TM_STORE (M256):\n+\tCASE_BUILT_IN_TM_LOAD (1):\n+\tCASE_BUILT_IN_TM_LOAD (2):\n+\tCASE_BUILT_IN_TM_LOAD (4):\n+\tCASE_BUILT_IN_TM_LOAD (8):\n+\tCASE_BUILT_IN_TM_LOAD (FLOAT):\n+\tCASE_BUILT_IN_TM_LOAD (DOUBLE):\n+\tCASE_BUILT_IN_TM_LOAD (LDOUBLE):\n+\tCASE_BUILT_IN_TM_LOAD (M64):\n+\tCASE_BUILT_IN_TM_LOAD (M128):\n+\tCASE_BUILT_IN_TM_LOAD (M256):\n+\tcase BUILT_IN_TM_LOG:\n+\tcase BUILT_IN_TM_LOG_1:\n+\tcase BUILT_IN_TM_LOG_2:\n+\tcase BUILT_IN_TM_LOG_4:\n+\tcase BUILT_IN_TM_LOG_8:\n+\tcase BUILT_IN_TM_LOG_FLOAT:\n+\tcase BUILT_IN_TM_LOG_DOUBLE:\n+\tcase BUILT_IN_TM_LOG_LDOUBLE:\n+\tcase BUILT_IN_TM_LOG_M64:\n+\tcase BUILT_IN_TM_LOG_M128:\n+\tcase BUILT_IN_TM_LOG_M256:\n+\t  return true;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Detect flags (function attributes) from the function decl or type node.  */\n \n int\n@@ -644,10 +707,28 @@ flags_from_decl_or_type (const_tree exp)\n       if (TREE_NOTHROW (exp))\n \tflags |= ECF_NOTHROW;\n \n+      if (flag_tm)\n+\t{\n+\t  if (is_tm_builtin (exp))\n+\t    flags |= ECF_TM_BUILTIN;\n+\t  else if ((flags & ECF_CONST) != 0\n+\t\t   || lookup_attribute (\"transaction_pure\",\n+\t\t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (exp))))\n+\t    flags |= ECF_TM_PURE;\n+\t}\n+\n       flags = special_function_p (exp, flags);\n     }\n-  else if (TYPE_P (exp) && TYPE_READONLY (exp))\n-    flags |= ECF_CONST;\n+  else if (TYPE_P (exp))\n+    {\n+      if (TYPE_READONLY (exp))\n+\tflags |= ECF_CONST;\n+\n+      if (flag_tm\n+\t  && ((flags & ECF_CONST) != 0\n+\t      || lookup_attribute (\"transaction_pure\", TYPE_ATTRIBUTES (exp))))\n+\tflags |= ECF_TM_PURE;\n+    }\n \n   if (TREE_THIS_VOLATILE (exp))\n     {"}, {"sha": "692fea8a17b3d87b1e7e6ef9b8a1f28228eb120c", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -338,18 +338,30 @@ make_edges (basic_block min, basic_block max, int update_p)\n \t  /* Add any appropriate EH edges.  */\n \t  rtl_make_eh_edge (edge_cache, bb, insn);\n \n-\t  if (code == CALL_INSN && nonlocal_goto_handler_labels)\n+\t  if (code == CALL_INSN)\n \t    {\n-\t      /* ??? This could be made smarter: in some cases it's possible\n-\t\t to tell that certain calls will not do a nonlocal goto.\n-\t\t For example, if the nested functions that do the nonlocal\n-\t\t gotos do not have their addresses taken, then only calls to\n-\t\t those functions or to other nested functions that use them\n-\t\t could possibly do nonlocal gotos.  */\n \t      if (can_nonlocal_goto (insn))\n-\t\tfor (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n-\t\t  make_label_edge (edge_cache, bb, XEXP (x, 0),\n-\t\t\t\t   EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+\t\t{\n+\t\t  /* ??? This could be made smarter: in some cases it's\n+\t\t     possible to tell that certain calls will not do a\n+\t\t     nonlocal goto.  For example, if the nested functions\n+\t\t     that do the nonlocal gotos do not have their addresses\n+\t\t     taken, then only calls to those functions or to other\n+\t\t     nested functions that use them could possibly do\n+\t\t     nonlocal gotos.  */\n+\t\t  for (x = nonlocal_goto_handler_labels; x; x = XEXP (x, 1))\n+\t\t    make_label_edge (edge_cache, bb, XEXP (x, 0),\n+\t\t\t\t     EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+\t\t}\n+\n+\t      if (flag_tm)\n+\t\t{\n+\t\t  rtx note;\n+\t\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t\t    if (REG_NOTE_KIND (note) == REG_TM)\n+\t\t      make_label_edge (edge_cache, bb, XEXP (note, 0),\n+\t\t\t\t       EDGE_ABNORMAL | EDGE_ABNORMAL_CALL);\n+\t\t}\n \t    }\n \t}\n "}, {"sha": "3d733337cffe93cf5effebb95094878af1ec83bb", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1802,6 +1802,38 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n   return new_bb;\n }\n \n+/* Mark all calls that can have a transaction restart.  */\n+\n+static void\n+mark_transaction_restart_calls (gimple stmt)\n+{\n+  struct tm_restart_node dummy;\n+  void **slot;\n+\n+  if (!cfun->gimple_df->tm_restart)\n+    return;\n+\n+  dummy.stmt = stmt;\n+  slot = htab_find_slot (cfun->gimple_df->tm_restart, &dummy, NO_INSERT);\n+  if (slot)\n+    {\n+      struct tm_restart_node *n = (struct tm_restart_node *) *slot;\n+      tree list = n->label_or_list;\n+      rtx insn;\n+\n+      for (insn = next_real_insn (get_last_insn ());\n+\t   !CALL_P (insn);\n+\t   insn = next_real_insn (insn))\n+\tcontinue;\n+\n+      if (TREE_CODE (list) == LABEL_DECL)\n+\tadd_reg_note (insn, REG_TM, label_rtx (list));\n+      else\n+\tfor (; list ; list = TREE_CHAIN (list))\n+\t  add_reg_note (insn, REG_TM, label_rtx (TREE_VALUE (list)));\n+    }\n+}\n+\n /* A subroutine of expand_gimple_stmt_1, expanding one GIMPLE_CALL\n    statement STMT.  */\n \n@@ -1888,6 +1920,8 @@ expand_call_stmt (gimple stmt)\n     expand_assignment (lhs, exp, false);\n   else\n     expand_expr_real_1 (exp, const0_rtx, VOIDmode, EXPAND_NORMAL, NULL);\n+\n+  mark_transaction_restart_calls (stmt);\n }\n \n /* A subroutine of expand_gimple_stmt, expanding one gimple statement\n@@ -4455,6 +4489,14 @@ gimple_expand_cfg (void)\n   /* After expanding, the return labels are no longer needed. */\n   return_label = NULL;\n   naked_return_label = NULL;\n+\n+  /* After expanding, the tm_restart map is no longer needed.  */\n+  if (cfun->gimple_df->tm_restart)\n+    {\n+      htab_delete (cfun->gimple_df->tm_restart);\n+      cfun->gimple_df->tm_restart = NULL;\n+    }\n+\n   /* Tag the blocks with a depth number so that change_scope can find\n      the common parent easily.  */\n   set_block_levels (DECL_INITIAL (cfun->decl), 0);"}, {"sha": "6e9f70ed719a266c5bad4b65fa5d1b1897d9a7bd", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -2246,6 +2246,8 @@ purge_dead_edges (basic_block bb)\n \t    ;\n \t  else if ((e->flags & EDGE_EH) && can_throw_internal (insn))\n \t    ;\n+\t  else if (flag_tm && find_reg_note (insn, REG_TM, NULL))\n+\t    ;\n \t  else\n \t    remove = true;\n \t}"}, {"sha": "2d226d49939fca2910c7ce4b5ad2d5d69ccca58b", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1840,6 +1840,8 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" only_called_at_exit\");\n   else if (node->alias)\n     fprintf (f, \" alias\");\n+  if (node->tm_clone)\n+    fprintf (f, \" tm_clone\");\n \n   fprintf (f, \"\\n\");\n "}, {"sha": "9e98ce9e2ef337289bf29a9af59d6a6a9b269ad3", "filename": "gcc/cgraph.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -98,6 +98,9 @@ struct GTY(()) cgraph_local_info {\n   /* True when the function has been originally extern inline, but it is\n      redefined now.  */\n   unsigned redefined_extern_inline : 1;\n+\n+  /* True if the function may enter serial irrevocable mode.  */\n+  unsigned tm_may_enter_irr : 1;\n };\n \n /* Information about the function that needs to be computed globally\n@@ -245,6 +248,11 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   unsigned only_called_at_startup : 1;\n   /* True when function can only be called at startup (from static dtor).  */\n   unsigned only_called_at_exit : 1;\n+  /* True when function is the transactional clone of a function which\n+     is called only from inside transactions.  */\n+  /* ?? We should be able to remove this.  We have enough bits in\n+     cgraph to calculate it.  */\n+  unsigned tm_clone : 1;\n };\n \n typedef struct cgraph_node *cgraph_node_ptr;\n@@ -565,6 +573,8 @@ void verify_cgraph_node (struct cgraph_node *);\n void cgraph_build_static_cdtor (char which, tree body, int priority);\n void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n+struct cgraph_node * cgraph_copy_node_for_versioning (struct cgraph_node *,\n+\t\ttree, VEC(cgraph_edge_p,heap)*, bitmap);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n \t\t\t\t\t\tVEC(ipa_replace_map_p,gc)*,\n@@ -1082,4 +1092,14 @@ cgraph_edge_recursive_p (struct cgraph_edge *e)\n   else\n     return e->caller->decl == callee->decl;\n }\n+\n+/* Return true if the TM_CLONE bit is set for a given FNDECL.  */\n+static inline bool\n+decl_is_tm_clone (const_tree fndecl)\n+{\n+  struct cgraph_node *n = cgraph_get_node (fndecl);\n+  if (n)\n+    return n->tm_clone;\n+  return false;\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "e401b8f2f2b354a8dfa27289736468c2076e0104", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -2272,7 +2272,7 @@ update_call_expr (struct cgraph_node *new_version)\n    was copied to prevent duplications of calls that are dead\n    in the clone.  */\n \n-static struct cgraph_node *\n+struct cgraph_node *\n cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \t\t\t\t tree new_decl,\n \t\t\t\t VEC(cgraph_edge_p,heap) *redirect_callers,\n@@ -2286,7 +2286,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    new_version = cgraph_create_node (new_decl);\n \n-   new_version->analyzed = true;\n+   new_version->analyzed = old_version->analyzed;\n    new_version->local = old_version->local;\n    new_version->local.externally_visible = false;\n    new_version->local.local = true;"}, {"sha": "ad9aa38987192225ddcb54138dd8d60b3a02272f", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -13286,6 +13286,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \n \tcase REG_NORETURN:\n \tcase REG_SETJMP:\n+\tcase REG_TM:\n \t  /* These notes must remain with the call.  It should not be\n \t     possible for both I2 and I3 to be a call.  */\n \t  if (CALL_P (i3))"}, {"sha": "4eb5b30b1c4c32eb23dbe939964af9867716e9b5", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1194,6 +1194,10 @@ floop-block\n Common Report Var(flag_loop_block) Optimization\n Enable Loop Blocking transformation\n \n+fgnu-tm\n+Common Report Var(flag_tm)\n+Enable support for GNU transactional memory\n+\n floop-flatten\n Common Report Var(flag_loop_flatten) Optimization\n Enable Loop Flattening transformation"}, {"sha": "5dcb68c2d43b3fede3f536016cb3408d28c1267e", "filename": "gcc/config/i386/i386-builtin-types.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-builtin-types.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -114,6 +114,7 @@ DEF_POINTER_TYPE (PINT, INT)\n DEF_POINTER_TYPE (PULONGLONG, ULONGLONG)\n DEF_POINTER_TYPE (PUNSIGNED, UNSIGNED)\n \n+DEF_POINTER_TYPE (PV2SI, V2SI)\n DEF_POINTER_TYPE (PV2DF, V2DF)\n DEF_POINTER_TYPE (PV2DI, V2DI)\n DEF_POINTER_TYPE (PV2SF, V2SF)\n@@ -124,6 +125,7 @@ DEF_POINTER_TYPE (PV8SF, V8SF)\n DEF_POINTER_TYPE (PV4SI, V4SI)\n DEF_POINTER_TYPE (PV8SI, V8SI)\n \n+DEF_POINTER_TYPE (PCV2SI, V2SI, CONST)\n DEF_POINTER_TYPE (PCV2DF, V2DF, CONST)\n DEF_POINTER_TYPE (PCV2SF, V2SF, CONST)\n DEF_POINTER_TYPE (PCV4DF, V4DF, CONST)\n@@ -175,6 +177,7 @@ DEF_FUNCTION_TYPE (V2SF, V2SI)\n DEF_FUNCTION_TYPE (V2SI, V2DF)\n DEF_FUNCTION_TYPE (V2SI, V2SF)\n DEF_FUNCTION_TYPE (V2SI, V2SI)\n+DEF_FUNCTION_TYPE (V2SI, PCV2SI)\n DEF_FUNCTION_TYPE (V2SI, V4SF)\n DEF_FUNCTION_TYPE (V32QI, PCCHAR)\n DEF_FUNCTION_TYPE (V4DF, PCDOUBLE)\n@@ -188,6 +191,7 @@ DEF_FUNCTION_TYPE (V4SF, PCFLOAT)\n DEF_FUNCTION_TYPE (V4SF, V2DF)\n DEF_FUNCTION_TYPE (V4SF, V4DF)\n DEF_FUNCTION_TYPE (V4SF, V4SF)\n+DEF_FUNCTION_TYPE (V4SF, PCV4SF)\n DEF_FUNCTION_TYPE (V4SF, V4SI)\n DEF_FUNCTION_TYPE (V4SF, V8SF)\n DEF_FUNCTION_TYPE (V4SF, V8HI)\n@@ -203,6 +207,7 @@ DEF_FUNCTION_TYPE (V8HI, V8HI)\n DEF_FUNCTION_TYPE (V8QI, V8QI)\n DEF_FUNCTION_TYPE (V8SF, PCFLOAT)\n DEF_FUNCTION_TYPE (V8SF, PCV4SF)\n+DEF_FUNCTION_TYPE (V8SF, PCV8SF)\n DEF_FUNCTION_TYPE (V8SF, V4SF)\n DEF_FUNCTION_TYPE (V8SF, V8SF)\n DEF_FUNCTION_TYPE (V8SF, V8SI)\n@@ -353,9 +358,12 @@ DEF_FUNCTION_TYPE (VOID, PFLOAT, V4SF)\n DEF_FUNCTION_TYPE (VOID, PFLOAT, V8SF)\n DEF_FUNCTION_TYPE (VOID, PINT, INT)\n DEF_FUNCTION_TYPE (VOID, PULONGLONG, ULONGLONG)\n+DEF_FUNCTION_TYPE (VOID, PV2SI, V2SI)\n DEF_FUNCTION_TYPE (VOID, PV2DI, V2DI)\n DEF_FUNCTION_TYPE (VOID, PV2SF, V4SF)\n DEF_FUNCTION_TYPE (VOID, PV4DI, V4DI)\n+DEF_FUNCTION_TYPE (VOID, PV4SF, V4SF)\n+DEF_FUNCTION_TYPE (VOID, PV8SF, V8SF)\n DEF_FUNCTION_TYPE (VOID, UNSIGNED, UNSIGNED)\n \n DEF_FUNCTION_TYPE (INT, V16QI, V16QI, INT)"}, {"sha": "799e12b2b14f9862d827200ef34f37b203cdd7af", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 194, "deletions": 1, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -5028,6 +5028,40 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* The transactional memory builtins are implicitly regparm or fastcall\n+   depending on the ABI.  Override the generic do-nothing attribute that\n+   these builtins were declared with, and replace it with one of the two\n+   attributes that we expect elsewhere.  */\n+\n+static tree\n+ix86_handle_tm_regparm_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n+    \t\t\t\t  tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t  int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t  bool *no_add_attrs)\n+{\n+  tree alt;\n+\n+  /* In no case do we want to add the placeholder attribute.  */\n+  *no_add_attrs = true;\n+\n+  /* The 64-bit ABI is unchanged for transactional memory.  */\n+  if (TARGET_64BIT)\n+    return NULL_TREE;\n+\n+  /* ??? Is there a better way to validate 32-bit windows?  We have\n+     cfun->machine->call_abi, but that seems to be set only for 64-bit.  */\n+  if (CHECK_STACK_LIMIT > 0)\n+    alt = tree_cons (get_identifier (\"fastcall\"), NULL, NULL);\n+  else\n+    {\n+      alt = tree_cons (NULL, build_int_cst (NULL, 2), NULL);\n+      alt = tree_cons (get_identifier (\"regparm\"), alt, NULL);\n+    }\n+  decl_attributes (node, alt, flags);\n+\n+  return NULL_TREE;\n+}\n+\n /* This function determines from TYPE the calling-convention.  */\n \n unsigned int\n@@ -26790,6 +26824,154 @@ static const struct builtin_description bdesc_multi_arg[] =\n   { OPTION_MASK_ISA_XOP, CODE_FOR_xop_vpermil2v8sf3,     \"__builtin_ia32_vpermil2ps256\", IX86_BUILTIN_VPERMIL2PS256, UNKNOWN, (int)MULTI_ARG_4_SF2_SI_I1 },\n \n };\n+\f\n+/* TM vector builtins.  */\n+\n+/* Reuse the existing x86-specific `struct builtin_description' cause\n+   we're lazy.  Add casts to make them fit.  */\n+static const struct builtin_description bdesc_tm[] =\n+{\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_WM64\", (enum ix86_builtins) BUILT_IN_TM_STORE_M64, UNKNOWN, VOID_FTYPE_PV2SI_V2SI },\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_WaRM64\", (enum ix86_builtins) BUILT_IN_TM_STORE_WAR_M64, UNKNOWN, VOID_FTYPE_PV2SI_V2SI },\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_WaWM64\", (enum ix86_builtins) BUILT_IN_TM_STORE_WAW_M64, UNKNOWN, VOID_FTYPE_PV2SI_V2SI },\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_RM64\", (enum ix86_builtins) BUILT_IN_TM_LOAD_M64, UNKNOWN, V2SI_FTYPE_PCV2SI },\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_RaRM64\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RAR_M64, UNKNOWN, V2SI_FTYPE_PCV2SI },\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_RaWM64\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RAW_M64, UNKNOWN, V2SI_FTYPE_PCV2SI },\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_RfWM64\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RFW_M64, UNKNOWN, V2SI_FTYPE_PCV2SI },\n+\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_WM128\", (enum ix86_builtins) BUILT_IN_TM_STORE_M128, UNKNOWN, VOID_FTYPE_PV4SF_V4SF },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_WaRM128\", (enum ix86_builtins) BUILT_IN_TM_STORE_WAR_M128, UNKNOWN, VOID_FTYPE_PV4SF_V4SF },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_WaWM128\", (enum ix86_builtins) BUILT_IN_TM_STORE_WAW_M128, UNKNOWN, VOID_FTYPE_PV4SF_V4SF },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_RM128\", (enum ix86_builtins) BUILT_IN_TM_LOAD_M128, UNKNOWN, V4SF_FTYPE_PCV4SF },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_RaRM128\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RAR_M128, UNKNOWN, V4SF_FTYPE_PCV4SF },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_RaWM128\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RAW_M128, UNKNOWN, V4SF_FTYPE_PCV4SF },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_RfWM128\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RFW_M128, UNKNOWN, V4SF_FTYPE_PCV4SF },\n+\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_WM256\", (enum ix86_builtins) BUILT_IN_TM_STORE_M256, UNKNOWN, VOID_FTYPE_PV8SF_V8SF },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_WaRM256\", (enum ix86_builtins) BUILT_IN_TM_STORE_WAR_M256, UNKNOWN, VOID_FTYPE_PV8SF_V8SF },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_WaWM256\", (enum ix86_builtins) BUILT_IN_TM_STORE_WAW_M256, UNKNOWN, VOID_FTYPE_PV8SF_V8SF },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_RM256\", (enum ix86_builtins) BUILT_IN_TM_LOAD_M256, UNKNOWN, V8SF_FTYPE_PCV8SF },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_RaRM256\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RAR_M256, UNKNOWN, V8SF_FTYPE_PCV8SF },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_RaWM256\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RAW_M256, UNKNOWN, V8SF_FTYPE_PCV8SF },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_RfWM256\", (enum ix86_builtins) BUILT_IN_TM_LOAD_RFW_M256, UNKNOWN, V8SF_FTYPE_PCV8SF },\n+\n+  { OPTION_MASK_ISA_MMX, CODE_FOR_nothing, \"__builtin__ITM_LM64\", (enum ix86_builtins) BUILT_IN_TM_LOG_M64, UNKNOWN, VOID_FTYPE_PCVOID },\n+  { OPTION_MASK_ISA_SSE, CODE_FOR_nothing, \"__builtin__ITM_LM128\", (enum ix86_builtins) BUILT_IN_TM_LOG_M128, UNKNOWN, VOID_FTYPE_PCVOID },\n+  { OPTION_MASK_ISA_AVX, CODE_FOR_nothing, \"__builtin__ITM_LM256\", (enum ix86_builtins) BUILT_IN_TM_LOG_M256, UNKNOWN, VOID_FTYPE_PCVOID },\n+};\n+\n+/* TM callbacks.  */\n+\n+/* Return the builtin decl needed to load a vector of TYPE.  */\n+\n+static tree\n+ix86_builtin_tm_load (tree type)\n+{\n+  if (TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      switch (tree_low_cst (TYPE_SIZE (type), 1))\n+\t{\n+\tcase 64:\n+\t  return builtin_decl_explicit (BUILT_IN_TM_LOAD_M64);\n+\tcase 128:\n+\t  return builtin_decl_explicit (BUILT_IN_TM_LOAD_M128);\n+\tcase 256:\n+\t  return builtin_decl_explicit (BUILT_IN_TM_LOAD_M256);\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Return the builtin decl needed to store a vector of TYPE.  */\n+\n+static tree\n+ix86_builtin_tm_store (tree type)\n+{\n+  if (TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      switch (tree_low_cst (TYPE_SIZE (type), 1))\n+\t{\n+\tcase 64:\n+\t  return builtin_decl_explicit (BUILT_IN_TM_STORE_M64);\n+\tcase 128:\n+\t  return builtin_decl_explicit (BUILT_IN_TM_STORE_M128);\n+\tcase 256:\n+\t  return builtin_decl_explicit (BUILT_IN_TM_STORE_M256);\n+\t}\n+    }\n+  return NULL_TREE;\n+}\n+\f\n+/* Initialize the transactional memory vector load/store builtins.  */\n+\n+static void\n+ix86_init_tm_builtins (void)\n+{\n+  enum ix86_builtin_func_type ftype;\n+  const struct builtin_description *d;\n+  size_t i;\n+  tree decl;\n+  tree attrs_load, attrs_type_load, attrs_store, attrs_type_store;\n+  tree attrs_log, attrs_type_log;\n+\n+  if (!flag_tm)\n+    return;\n+\n+  /* Use whatever attributes a normal TM load has.  */\n+  decl = builtin_decl_explicit (BUILT_IN_TM_LOAD_1);\n+  attrs_load = DECL_ATTRIBUTES (decl);\n+  attrs_type_load = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+  /* Use whatever attributes a normal TM store has.  */\n+  decl = builtin_decl_explicit (BUILT_IN_TM_STORE_1);\n+  attrs_store = DECL_ATTRIBUTES (decl);\n+  attrs_type_store = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+  /* Use whatever attributes a normal TM log has.  */\n+  decl = builtin_decl_explicit (BUILT_IN_TM_LOG);\n+  attrs_log = DECL_ATTRIBUTES (decl);\n+  attrs_type_log = TYPE_ATTRIBUTES (TREE_TYPE (decl));\n+\n+  for (i = 0, d = bdesc_tm;\n+       i < ARRAY_SIZE (bdesc_tm);\n+       i++, d++)\n+    {\n+      if ((d->mask & ix86_isa_flags) != 0\n+\t  || (lang_hooks.builtin_function\n+\t      == lang_hooks.builtin_function_ext_scope))\n+\t{\n+\t  tree type, attrs, attrs_type;\n+\t  enum built_in_function code = (enum built_in_function) d->code;\n+\n+\t  ftype = (enum ix86_builtin_func_type) d->flag;\n+\t  type = ix86_get_builtin_func_type (ftype);\n+\n+\t  if (BUILTIN_TM_LOAD_P (code))\n+\t    {\n+\t      attrs = attrs_load;\n+\t      attrs_type = attrs_type_load;\n+\t    }\n+\t  else if (BUILTIN_TM_STORE_P (code))\n+\t    {\n+\t      attrs = attrs_store;\n+\t      attrs_type = attrs_type_store;\n+\t    }\n+\t  else\n+\t    {\n+\t      attrs = attrs_log;\n+\t      attrs_type = attrs_type_log;\n+\t    }\n+\t  decl = add_builtin_function (d->name, type, code, BUILT_IN_NORMAL,\n+\t\t\t\t       /* The builtin without the prefix for\n+\t\t\t\t\t  calling it directly.  */\n+\t\t\t\t       d->name + strlen (\"__builtin_\"),\n+\t\t\t\t       attrs);\n+\t  /* add_builtin_function() will set the DECL_ATTRIBUTES, now\n+\t     set the TYPE_ATTRIBUTES.  */\n+\t  decl_attributes (&TREE_TYPE (decl), attrs_type, ATTR_FLAG_BUILT_IN);\n+\n+\t  set_builtin_decl (code, decl, false);\n+\t}\n+    }\n+}\n \n /* Set up all the MMX/SSE builtins, even builtins for instructions that are not\n    in the current target ISA to allow the user to compile particular modules\n@@ -27163,6 +27345,7 @@ ix86_init_builtins (void)\n   TREE_READONLY (t) = 1;\n   ix86_builtins[(int) IX86_BUILTIN_COPYSIGNQ] = t;\n \n+  ix86_init_tm_builtins ();\n   ix86_init_mmx_sse_builtins ();\n \n   if (TARGET_LP64)\n@@ -29921,7 +30104,6 @@ avx_vperm2f128_parallel (rtx par, enum machine_mode mode)\n   return mask + 1;\n }\n \f\n-\n /* Store OPERAND to the memory after reload is completed.  This means\n    that we can't easily use assign_stack_local.  */\n rtx\n@@ -34784,6 +34966,11 @@ static const struct attribute_spec ix86_attribute_table[] =\n      for FP arguments.  */\n   { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute,\n     true },\n+  /* The transactional memory builtins are implicitly regparm or fastcall\n+     depending on the ABI.  Override the generic do-nothing attribute that\n+     these builtins were declared with.  */\n+  { \"*tm regparm\", 0, 0, false, true, true, ix86_handle_tm_regparm_attribute,\n+    true },\n   /* force_align_arg_pointer says this function realigns the stack at entry.  */\n   { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,\n     false, true,  true, ix86_handle_cconv_attribute, false },\n@@ -37954,6 +38141,12 @@ ix86_autovectorize_vector_sizes (void)\n #define TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION \\\n   ix86_builtin_vectorized_function\n \n+#undef TARGET_VECTORIZE_BUILTIN_TM_LOAD\n+#define TARGET_VECTORIZE_BUILTIN_TM_LOAD ix86_builtin_tm_load\n+\n+#undef TARGET_VECTORIZE_BUILTIN_TM_STORE\n+#define TARGET_VECTORIZE_BUILTIN_TM_STORE ix86_builtin_tm_store\n+\n #undef TARGET_VECTORIZE_BUILTIN_GATHER\n #define TARGET_VECTORIZE_BUILTIN_GATHER ix86_vectorize_builtin_gather\n "}, {"sha": "15b44b5cfb85630e01bd15eb9a6a9022d31c5a35", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,40 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Torvald Riegel  <triegel@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* call.c (build_new_function_call): Call tm_malloc_replacement.\n+\t* class.c (check_bases): Compute transaction attributes for the\n+\tclass based on its base classes.\n+\t(look_for_tm_attr_overrides, set_one_vmethod_tm_attributes,\n+\tset_method_tm_attributes): New.\n+\t(finish_struct_1): Call set_method_tm_attributes.\n+\t* cp-tree.h (begin_transaction_stmt, finish_transaction_stmt,\n+\tbuild_transaction_expr): Declare.\n+\t(TRANSACTION_EXPR_IS_STMT): New.\n+\t* decl.c (push_cp_library_fn): Set attribute to transaction_safe.\n+\t* except.c (do_get_exception_ptr): Apply transaction_pure.\n+\t(do_begin_catch): Mark _ITM_cxa_begin_catch transaction_pure and\n+\trecord as transactional-memory wrapper.\n+\t(do_end_catch): Similarly for _ITM_cxa_end_catch.\n+\t(do_allocate_exception): Similarly for _ITM_cxa_allocate_exception.\n+\t(build_throw): Similarly for _ITM_cxa_throw. Make __cxa_rethrow pure.\n+\t* parser.h (struct cp_parser): Add in_transaction flag.\n+\t* parser.c (enum non_integral_constant): Add NIC_TRANSACTION.\n+\t(cp_parser_non_integral_constant_expression): Handle NIC_TRANSACTION.\n+\t(enum required_token): Add transaction tokens.\n+\t(cp_parser_transaction, cp_parser_transaction_expression,\n+\tcp_parser_function_transaction, cp_parser_transaction_cancel,\n+\tcp_parser_txn_attribute_opt): New.\n+\t(cp_parser_unary_expression): Handle RID_TRANSACTION*.\n+\t(cp_parser_statement, cp_parser_function_definition_after_declarator,\n+\tcp_parser_token_starts_function_definition_p): Same.\n+\t(cp_parser_required_error): Handle RT_TRANSACTION*.\n+\t* pt.c (tsubst_expr): Handle TRANSACTION_EXPR.\n+\t* semantics.c (begin_transaction_stmt, finish_transaction_stmt,\n+\tbuild_transaction_expr): New.\n+\n 2011-11-08  Dodji Seketeli  <dodji@redhat.com>\n \n \tFix context handling of alias-declaration"}, {"sha": "578905e41e60d0f03acac8f69d3b85e680b5aa08", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -3826,6 +3826,9 @@ build_new_function_call (tree fn, VEC(tree,gc) **args, bool koenig_p,\n \treturn error_mark_node;\n     }\n \n+  if (flag_tm)\n+    tm_malloc_replacement (fn);\n+\n   /* If this function was found without using argument dependent\n      lookup, then we want to ignore any undeclared friend\n      functions.  */"}, {"sha": "be632be64c804c1392f17f5fdf45f599cf4f9a65", "filename": "gcc/cp/class.c", "status": "modified", "additions": 151, "deletions": 3, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1227,13 +1227,12 @@ check_bases (tree t,\n \t     int* no_const_asn_ref_p)\n {\n   int i;\n-  int seen_non_virtual_nearly_empty_base_p;\n+  bool seen_non_virtual_nearly_empty_base_p = 0;\n+  int seen_tm_mask = 0;\n   tree base_binfo;\n   tree binfo;\n   tree field = NULL_TREE;\n \n-  seen_non_virtual_nearly_empty_base_p = 0;\n-\n   if (!CLASSTYPE_NON_STD_LAYOUT (t))\n     for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n       if (TREE_CODE (field) == FIELD_DECL)\n@@ -1338,6 +1337,23 @@ check_bases (tree t,\n \t\t  break;\n \t\t}\n \t}\n+\n+      /* Don't bother collecting tm attributes if transactional memory\n+\t support is not enabled.  */\n+      if (flag_tm)\n+\t{\n+\t  tree tm_attr = find_tm_attribute (TYPE_ATTRIBUTES (basetype));\n+\t  if (tm_attr)\n+\t    seen_tm_mask |= tm_attr_to_mask (tm_attr);\n+\t}\n+    }\n+\n+  /* If one of the base classes had TM attributes, and the current class\n+     doesn't define its own, then the current class inherits one.  */\n+  if (seen_tm_mask && !find_tm_attribute (TYPE_ATTRIBUTES (t)))\n+    {\n+      tree tm_attr = tm_mask_to_attr (seen_tm_mask & -seen_tm_mask);\n+      TYPE_ATTRIBUTES (t) = tree_cons (tm_attr, NULL, TYPE_ATTRIBUTES (t));\n     }\n }\n \n@@ -4258,6 +4274,137 @@ clone_constructors_and_destructors (tree t)\n     clone_function_decl (OVL_CURRENT (fns), /*update_method_vec_p=*/1);\n }\n \n+/* Subroutine of set_one_vmethod_tm_attributes.  Search base classes\n+   of TYPE for virtual functions which FNDECL overrides.  Return a\n+   mask of the tm attributes found therein.  */\n+\n+static int\n+look_for_tm_attr_overrides (tree type, tree fndecl)\n+{\n+  tree binfo = TYPE_BINFO (type);\n+  tree base_binfo;\n+  int ix, found = 0;\n+\n+  for (ix = 0; BINFO_BASE_ITERATE (binfo, ix, base_binfo); ++ix)\n+    {\n+      tree o, basetype = BINFO_TYPE (base_binfo);\n+\n+      if (!TYPE_POLYMORPHIC_P (basetype))\n+\tcontinue;\n+\n+      o = look_for_overrides_here (basetype, fndecl);\n+      if (o)\n+\tfound |= tm_attr_to_mask (find_tm_attribute\n+\t\t\t\t  (TYPE_ATTRIBUTES (TREE_TYPE (o))));\n+      else\n+\tfound |= look_for_tm_attr_overrides (basetype, fndecl);\n+    }\n+\n+  return found;\n+}\n+\n+/* Subroutine of set_method_tm_attributes.  Handle the checks and\n+   inheritance for one virtual method FNDECL.  */\n+\n+static void\n+set_one_vmethod_tm_attributes (tree type, tree fndecl)\n+{\n+  tree tm_attr;\n+  int found, have;\n+\n+  found = look_for_tm_attr_overrides (type, fndecl);\n+\n+  /* If FNDECL doesn't actually override anything (i.e. T is the\n+     class that first declares FNDECL virtual), then we're done.  */\n+  if (found == 0)\n+    return;\n+\n+  tm_attr = find_tm_attribute (TYPE_ATTRIBUTES (TREE_TYPE (fndecl)));\n+  have = tm_attr_to_mask (tm_attr);\n+\n+  /* Intel STM Language Extension 3.0, Section 4.2 table 4:\n+     tm_pure must match exactly, otherwise no weakening of\n+     tm_safe > tm_callable > nothing.  */\n+  /* ??? The tm_pure attribute didn't make the transition to the\n+     multivendor language spec.  */\n+  if (have == TM_ATTR_PURE)\n+    {\n+      if (found != TM_ATTR_PURE)\n+\t{\n+\t  found &= -found;\n+\t  goto err_override;\n+\t}\n+    }\n+  /* If the overridden function is tm_pure, then FNDECL must be.  */\n+  else if (found == TM_ATTR_PURE && tm_attr)\n+    goto err_override;\n+  /* Look for base class combinations that cannot be satisfied.  */\n+  else if (found != TM_ATTR_PURE && (found & TM_ATTR_PURE))\n+    {\n+      found &= ~TM_ATTR_PURE;\n+      found &= -found;\n+      error_at (DECL_SOURCE_LOCATION (fndecl),\n+\t\t\"method overrides both %<transaction_pure%> and %qE methods\",\n+\t\ttm_mask_to_attr (found));\n+    }\n+  /* If FNDECL did not declare an attribute, then inherit the most\n+     restrictive one.  */\n+  else if (tm_attr == NULL)\n+    {\n+      apply_tm_attr (fndecl, tm_mask_to_attr (found & -found));\n+    }\n+  /* Otherwise validate that we're not weaker than a function\n+     that is being overridden.  */\n+  else\n+    {\n+      found &= -found;\n+      if (found <= TM_ATTR_CALLABLE && have > found)\n+\tgoto err_override;\n+    }\n+  return;\n+\n+ err_override:\n+  error_at (DECL_SOURCE_LOCATION (fndecl),\n+\t    \"method declared %qE overriding %qE method\",\n+\t    tm_attr, tm_mask_to_attr (found));\n+}\n+\n+/* For each of the methods in T, propagate a class-level tm attribute.  */\n+\n+static void\n+set_method_tm_attributes (tree t)\n+{\n+  tree class_tm_attr, fndecl;\n+\n+  /* Don't bother collecting tm attributes if transactional memory\n+     support is not enabled.  */\n+  if (!flag_tm)\n+    return;\n+\n+  /* Process virtual methods first, as they inherit directly from the\n+     base virtual function and also require validation of new attributes.  */\n+  if (TYPE_CONTAINS_VPTR_P (t))\n+    {\n+      tree vchain;\n+      for (vchain = BINFO_VIRTUALS (TYPE_BINFO (t)); vchain;\n+\t   vchain = TREE_CHAIN (vchain))\n+\tset_one_vmethod_tm_attributes (t, BV_FN (vchain));\n+    }\n+\n+  /* If the class doesn't have an attribute, nothing more to do.  */\n+  class_tm_attr = find_tm_attribute (TYPE_ATTRIBUTES (t));\n+  if (class_tm_attr == NULL)\n+    return;\n+\n+  /* Any method that does not yet have a tm attribute inherits\n+     the one from the class.  */\n+  for (fndecl = TYPE_METHODS (t); fndecl; fndecl = TREE_CHAIN (fndecl))\n+    {\n+      if (!find_tm_attribute (TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n+\tapply_tm_attr (fndecl, class_tm_attr);\n+    }\n+}\n+\n /* Returns true iff class T has a user-defined constructor other than\n    the default constructor.  */\n \n@@ -5841,6 +5988,7 @@ finish_struct_1 (tree t)\n     }\n \n   finish_struct_bits (t);\n+  set_method_tm_attributes (t);\n \n   /* Complete the rtl for any static member objects of the type we're\n      working on.  */"}, {"sha": "32d08caf9cc061ee1197460aaaf7cdb7ce92f771", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -73,6 +73,7 @@ c-common.h, not after.\n       VEC_INIT_EXPR_IS_CONSTEXPR (in VEC_INIT_EXPR)\n       DECL_OVERRIDE_P (in FUNCTION_DECL)\n       IMPLICIT_CONV_EXPR_DIRECT_INIT (in IMPLICIT_CONV_EXPR)\n+      TRANSACTION_EXPR_IS_STMT (in TRANSACTION_EXPR)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -3890,6 +3891,10 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n   TREE_TYPE (OMP_CLAUSE_RANGE_CHECK (NODE, OMP_CLAUSE_PRIVATE, \\\n \t\t\t\t     OMP_CLAUSE_COPYPRIVATE))\n \n+/* Nonzero if this transaction expression's body contains statements.  */\n+#define TRANSACTION_EXPR_IS_STMT(NODE) \\\n+   TREE_LANG_FLAG_0 (TRANSACTION_EXPR_CHECK (NODE))\n+\n /* These macros provide convenient access to the various _STMT nodes\n    created when parsing template declarations.  */\n #define TRY_STMTS(NODE)\t\tTREE_OPERAND (TRY_BLOCK_CHECK (NODE), 0)\n@@ -5556,6 +5561,9 @@ extern void finish_omp_atomic\t\t\t(enum tree_code, enum tree_code,\n extern void finish_omp_barrier\t\t\t(void);\n extern void finish_omp_flush\t\t\t(void);\n extern void finish_omp_taskwait\t\t\t(void);\n+extern tree begin_transaction_stmt\t\t(location_t, tree *, int);\n+extern void finish_transaction_stmt\t\t(tree, tree, int);\n+extern tree build_transaction_expr\t\t(location_t, tree, int);\n extern void finish_omp_taskyield\t\t(void);\n extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool, bool);\n extern tree baselink_for_fns                    (tree);"}, {"sha": "1c46adf99a1d11652ebdc36eb1170c50614844d6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -4001,6 +4001,8 @@ push_cp_library_fn (enum tree_code operator_code, tree type)\n \t\t\t\t operator_code,\n \t\t\t\t type);\n   pushdecl (fn);\n+  if (flag_tm)\n+    apply_tm_attr (fn, get_identifier (\"transaction_safe\"));\n   return fn;\n }\n "}, {"sha": "670a66f161154d4f79635cb2ae7aff8781ab6a89", "filename": "gcc/cp/except.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -173,6 +173,9 @@ do_get_exception_ptr (void)\n     {\n       /* Declare void* __cxa_get_exception_ptr (void *) throw().  */\n       fn = declare_nothrow_library_fn (fn, ptr_type_node, ptr_type_node);\n+\n+      if (flag_tm)\n+\tapply_tm_attr (fn, get_identifier (\"transaction_pure\"));\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error,\n@@ -192,6 +195,17 @@ do_begin_catch (void)\n     {\n       /* Declare void* __cxa_begin_catch (void *) throw().  */\n       fn = declare_nothrow_library_fn (fn, ptr_type_node, ptr_type_node);\n+\n+      /* Create its transactional-memory equivalent.  */\n+      if (flag_tm)\n+\t{\n+\t  tree fn2 = get_identifier (\"_ITM_cxa_begin_catch\");\n+\t  if (!get_global_value_if_present (fn2, &fn2))\n+\t    fn2 = declare_nothrow_library_fn (fn2, ptr_type_node,\n+\t\t\t\t\t      ptr_type_node);\n+\t  apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t  record_tm_replacement (fn, fn2);\n+\t}\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error,\n@@ -231,6 +245,19 @@ do_end_catch (tree type)\n       fn = push_void_library_fn (fn, void_list_node);\n       /* This can throw if the destructor for the exception throws.  */\n       TREE_NOTHROW (fn) = 0;\n+\n+      /* Create its transactional-memory equivalent.  */\n+      if (flag_tm)\n+\t{\n+\t  tree fn2 = get_identifier (\"_ITM_cxa_end_catch\");\n+\t  if (!get_global_value_if_present (fn2, &fn2))\n+\t    {\n+\t      fn2 = push_void_library_fn (fn2, void_list_node);\n+\t      TREE_NOTHROW (fn2) = 0;\n+\t    }\n+\t  apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t  record_tm_replacement (fn, fn2);\n+\t}\n     }\n \n   cleanup = cp_build_function_call_vec (fn, NULL, tf_warning_or_error);\n@@ -581,6 +608,16 @@ do_allocate_exception (tree type)\n     {\n       /* Declare void *__cxa_allocate_exception(size_t) throw().  */\n       fn = declare_nothrow_library_fn (fn, ptr_type_node, size_type_node);\n+\n+      if (flag_tm)\n+\t{\n+\t  tree fn2 = get_identifier (\"_ITM_cxa_allocate_exception\");\n+\t  if (!get_global_value_if_present (fn2, &fn2))\n+\t    fn2 = declare_nothrow_library_fn (fn2, ptr_type_node,\n+\t\t\t\t\t      size_type_node);\n+\t  apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t  record_tm_replacement (fn, fn2);\n+\t}\n     }\n \n   return cp_build_function_call_nary (fn, tf_warning_or_error,\n@@ -712,6 +749,15 @@ build_throw (tree exp)\n \t\t\t\t\t  ptr_type_node, ptr_type_node,\n \t\t\t\t\t  cleanup_type, NULL_TREE);\n \t  fn = push_throw_library_fn (fn, tmp);\n+\n+\t  if (flag_tm)\n+\t    {\n+\t      tree fn2 = get_identifier (\"_ITM_cxa_throw\");\n+\t      if (!get_global_value_if_present (fn2, &fn2))\n+\t\tfn2 = push_throw_library_fn (fn2, tmp);\n+\t      apply_tm_attr (fn2, get_identifier (\"transaction_pure\"));\n+\t      record_tm_replacement (fn, fn2);\n+\t    }\n \t}\n \n       /* [except.throw]\n@@ -831,6 +877,9 @@ build_throw (tree exp)\n \t    (fn, build_function_type_list (void_type_node, NULL_TREE));\n \t}\n \n+      if (flag_tm)\n+\tapply_tm_attr (fn, get_identifier (\"transaction_pure\"));\n+\n       /* ??? Indicate that this function call allows exceptions of the type\n \t of the enclosing catch block (if known).  */\n       exp = cp_build_function_call_vec (fn, NULL, tf_warning_or_error);"}, {"sha": "12f3c4011facacb698002b3beb072076ebbcf54b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 332, "deletions": 7, "changes": 339, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -106,7 +106,9 @@ typedef enum non_integral_constant {\n   /* a comma operator */\n   NIC_COMMA,\n   /* a call to a constructor */\n-  NIC_CONSTRUCTOR\n+  NIC_CONSTRUCTOR,\n+  /* a transaction expression */\n+  NIC_TRANSACTION\n } non_integral_constant;\n \n /* The various kinds of errors about name-lookup failing. */\n@@ -171,7 +173,10 @@ typedef enum required_token {\n   RT_INTERATION, /* iteration-statement */\n   RT_JUMP, /* jump-statement */\n   RT_CLASS_KEY, /* class-key */\n-  RT_CLASS_TYPENAME_TEMPLATE /* class, typename, or template */\n+  RT_CLASS_TYPENAME_TEMPLATE, /* class, typename, or template */\n+  RT_TRANSACTION_ATOMIC, /* __transaction_atomic */\n+  RT_TRANSACTION_RELAXED, /* __transaction_relaxed */\n+  RT_TRANSACTION_CANCEL /* __transaction_cancel */\n } required_token;\n \n /* Prototypes.  */\n@@ -2106,6 +2111,17 @@ static bool cp_parser_extension_opt\n static void cp_parser_label_declaration\n   (cp_parser *);\n \n+/* Transactional Memory Extensions */\n+\n+static tree cp_parser_transaction\n+  (cp_parser *, enum rid);\n+static tree cp_parser_transaction_expression\n+  (cp_parser *, enum rid);\n+static bool cp_parser_function_transaction\n+  (cp_parser *, enum rid);\n+static tree cp_parser_transaction_cancel\n+  (cp_parser *);\n+\n enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n static bool cp_parser_pragma\n   (cp_parser *, enum pragma_context);\n@@ -2671,6 +2687,10 @@ cp_parser_non_integral_constant_expression (cp_parser  *parser,\n \t\terror (\"a call to a constructor \"\n \t\t       \"cannot appear in a constant-expression\");\n \t\treturn true;\n+\t      case NIC_TRANSACTION:\n+\t\terror (\"a transaction expression \"\n+\t\t       \"cannot appear in a constant-expression\");\n+\t\treturn true;\n \t      case NIC_THIS:\n \t\tmsg = \"this\";\n \t\tbreak;\n@@ -6372,6 +6392,10 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  }\n \t  break;\n \n+\tcase RID_TRANSACTION_ATOMIC:\n+\tcase RID_TRANSACTION_RELAXED:\n+\t  return cp_parser_transaction_expression (parser, keyword);\n+\n \tcase RID_NOEXCEPT:\n \t  {\n \t    tree expr;\n@@ -8506,6 +8530,11 @@ cp_parser_lambda_body (cp_parser* parser, tree lambda_expr)\n      declaration-statement\n      try-block\n \n+  TM Extension:\n+\n+   statement:\n+     atomic-statement\n+\n   IN_COMPOUND is true when the statement is nested inside a\n   cp_parser_compound_statement; this matters for certain pragmas.\n \n@@ -8582,6 +8611,14 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  cp_parser_declaration_statement (parser);\n \t  return;\n \t  \n+\tcase RID_TRANSACTION_ATOMIC:\n+\tcase RID_TRANSACTION_RELAXED:\n+\t  statement = cp_parser_transaction (parser, keyword);\n+\t  break;\n+\tcase RID_TRANSACTION_CANCEL:\n+\t  statement = cp_parser_transaction_cancel (parser);\n+\t  break;\n+\n \tdefault:\n \t  /* It might be a keyword like `int' that can start a\n \t     declaration-statement.  */\n@@ -15194,6 +15231,11 @@ cp_parser_asm_definition (cp_parser* parser)\n    function-definition:\n      __extension__ function-definition\n \n+   TM Extension:\n+\n+   function-definition:\n+     decl-specifier-seq [opt] declarator function-transaction-block\n+\n    The DECL_SPECIFIERS apply to this declarator.  Returns a\n    representation of the entity declared.  If MEMBER_P is TRUE, then\n    this declarator appears in a class scope.  The new DECL created by\n@@ -20911,12 +20953,19 @@ cp_parser_function_definition_after_declarator (cp_parser* parser,\n \n   start_lambda_scope (current_function_decl);\n \n-  /* If the next token is `try', then we are looking at a\n-     function-try-block.  */\n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRY))\n+  /* If the next token is `try', `__transaction_atomic', or\n+     `__transaction_relaxed`, then we are looking at either function-try-block\n+     or function-transaction-block.  Note that all of these include the\n+     function-body.  */\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRANSACTION_ATOMIC))\n+    ctor_initializer_p = cp_parser_function_transaction (parser,\n+\tRID_TRANSACTION_ATOMIC);\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer,\n+      RID_TRANSACTION_RELAXED))\n+    ctor_initializer_p = cp_parser_function_transaction (parser,\n+\tRID_TRANSACTION_RELAXED);\n+  else if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRY))\n     ctor_initializer_p = cp_parser_function_try_block (parser);\n-  /* A function-try-block includes the function-body, so we only do\n-     this next part if we're not processing a function-try-block.  */\n   else\n     ctor_initializer_p\n       = cp_parser_ctor_initializer_opt_and_function_body (parser);\n@@ -22073,6 +22122,12 @@ cp_parser_required_error (cp_parser *parser,\n       case RT_AT_THROW:\n \tcp_parser_error (parser, \"expected %<@throw%>\");\n \treturn;\n+      case RT_TRANSACTION_ATOMIC:\n+\tcp_parser_error (parser, \"expected %<__transaction_atomic%>\");\n+\treturn;\n+      case RT_TRANSACTION_RELAXED:\n+\tcp_parser_error (parser, \"expected %<__transaction_relaxed%>\");\n+\treturn;\n       default:\n \tbreak;\n     }\n@@ -22303,6 +22358,10 @@ cp_parser_token_starts_function_definition_p (cp_token* token)\n \t  || token->type == CPP_COLON\n \t  /* A function-try-block begins with `try'.  */\n \t  || token->keyword == RID_TRY\n+\t  /* A function-transaction-block begins with `__transaction_atomic'\n+\t     or `__transaction_relaxed'.  */\n+\t  || token->keyword == RID_TRANSACTION_ATOMIC\n+\t  || token->keyword == RID_TRANSACTION_RELAXED\n \t  /* The named return value extension begins with `return'.  */\n \t  || token->keyword == RID_RETURN);\n }\n@@ -26623,6 +26682,272 @@ cp_parser_omp_construct (cp_parser *parser, cp_token *pragma_tok)\n     SET_EXPR_LOCATION (stmt, pragma_tok->location);\n }\n \f\n+/* Transactional Memory parsing routines.  */\n+\n+/* Parse a transaction attribute.\n+\n+   txn-attribute:\n+\tattribute\n+\t[ [ identifier ] ]\n+\n+   ??? Simplify this when C++0x bracket attributes are\n+   implemented properly.  */\n+\n+static tree\n+cp_parser_txn_attribute_opt (cp_parser *parser)\n+{\n+  cp_token *token;\n+  tree attr_name, attr = NULL;\n+\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n+    return cp_parser_attributes_opt (parser);\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_OPEN_SQUARE))\n+    return NULL_TREE;\n+  cp_lexer_consume_token (parser->lexer);\n+  if (!cp_parser_require (parser, CPP_OPEN_SQUARE, RT_OPEN_SQUARE))\n+    goto error1;\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_NAME || token->type == CPP_KEYWORD)\n+    {\n+      token = cp_lexer_consume_token (parser->lexer);\n+\n+      attr_name = (token->type == CPP_KEYWORD\n+\t\t   /* For keywords, use the canonical spelling,\n+\t\t      not the parsed identifier.  */\n+\t\t   ? ridpointers[(int) token->keyword]\n+\t\t   : token->u.value);\n+      attr = build_tree_list (attr_name, NULL_TREE);\n+    }\n+  else\n+    cp_parser_error (parser, \"expected identifier\");\n+\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+ error1:\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+  return attr;\n+}\n+\n+/* Parse a __transaction_atomic or __transaction_relaxed statement.\n+\n+   transaction-statement:\n+     __transaction_atomic txn-attribute[opt] txn-exception-spec[opt]\n+       compound-statement\n+     __transaction_relaxed txn-exception-spec[opt] compound-statement\n+\n+   ??? The exception specification is not yet implemented.\n+*/\n+\n+static tree\n+cp_parser_transaction (cp_parser *parser, enum rid keyword)\n+{\n+  unsigned char old_in = parser->in_transaction;\n+  unsigned char this_in = 1, new_in;\n+  cp_token *token;\n+  tree stmt, attrs;\n+\n+  gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n+      || keyword == RID_TRANSACTION_RELAXED);\n+  token = cp_parser_require_keyword (parser, keyword,\n+      (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC\n+\t  : RT_TRANSACTION_RELAXED));\n+  gcc_assert (token != NULL);\n+\n+  if (keyword == RID_TRANSACTION_RELAXED)\n+    this_in |= TM_STMT_ATTR_RELAXED;\n+  else\n+    {\n+      attrs = cp_parser_txn_attribute_opt (parser);\n+      if (attrs)\n+\tthis_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);\n+    }\n+\n+  /* Keep track if we're in the lexical scope of an outer transaction.  */\n+  new_in = this_in | (old_in & TM_STMT_ATTR_OUTER);\n+\n+  stmt = begin_transaction_stmt (token->location, NULL, this_in);\n+\n+  parser->in_transaction = new_in;\n+  cp_parser_compound_statement (parser, NULL, false, false);\n+  parser->in_transaction = old_in;\n+\n+  finish_transaction_stmt (stmt, NULL, this_in);\n+\n+  return stmt;\n+}\n+\n+/* Parse a __transaction_atomic or __transaction_relaxed expression.\n+\n+   transaction-expression:\n+     __transaction_atomic txn-exception-spec[opt] ( expression )\n+     __transaction_relaxed txn-exception-spec[opt] ( expression )\n+\n+   ??? The exception specification is not yet implemented.\n+*/\n+\n+static tree\n+cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n+{\n+  unsigned char old_in = parser->in_transaction;\n+  unsigned char this_in = 1;\n+  cp_token *token;\n+  tree ret;\n+\n+  gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n+      || keyword == RID_TRANSACTION_RELAXED);\n+\n+  if (!flag_tm)\n+    error (keyword == RID_TRANSACTION_RELAXED\n+\t   ? G_(\"%<__transaction_relaxed%> without transactional memory \"\n+\t\t\"support enabled\")\n+\t   : G_(\"%<__transaction_atomic%> without transactional memory \"\n+\t\t\"support enabled\"));\n+\n+  token = cp_parser_require_keyword (parser, keyword,\n+      (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC\n+\t  : RT_TRANSACTION_RELAXED));\n+  gcc_assert (token != NULL);\n+\n+  if (keyword == RID_TRANSACTION_RELAXED)\n+    this_in |= TM_STMT_ATTR_RELAXED;\n+\n+  parser->in_transaction = this_in;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      tree expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+      ret = build_transaction_expr (token->location, expr, this_in);\n+    }\n+  else\n+    {\n+      cp_parser_error (parser, \"expected %<(%>\");\n+      ret = error_mark_node;\n+    }\n+  parser->in_transaction = old_in;\n+\n+  if (cp_parser_non_integral_constant_expression (parser, NIC_TRANSACTION))\n+    return error_mark_node;\n+\n+  return (flag_tm ? ret : error_mark_node);\n+}\n+\n+/* Parse a function-transaction-block.\n+\n+   function-transaction-block:\n+     __transaction_atomic txn-attribute[opt] ctor-initializer[opt]\n+\t function-body\n+     __transaction_atomic txn-attribute[opt] function-try-block\n+     __transaction_relaxed ctor-initializer[opt] function-body\n+     __transaction_relaxed function-try-block\n+*/\n+\n+static bool\n+cp_parser_function_transaction (cp_parser *parser, enum rid keyword)\n+{\n+  unsigned char old_in = parser->in_transaction;\n+  unsigned char new_in = 1;\n+  tree compound_stmt, stmt, attrs;\n+  bool ctor_initializer_p;\n+  cp_token *token;\n+\n+  gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n+      || keyword == RID_TRANSACTION_RELAXED);\n+  token = cp_parser_require_keyword (parser, keyword,\n+      (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC\n+\t  : RT_TRANSACTION_RELAXED));\n+  gcc_assert (token != NULL);\n+\n+  if (keyword == RID_TRANSACTION_RELAXED)\n+    new_in |= TM_STMT_ATTR_RELAXED;\n+  else\n+    {\n+      attrs = cp_parser_txn_attribute_opt (parser);\n+      if (attrs)\n+\tnew_in |= parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER);\n+    }\n+\n+  stmt = begin_transaction_stmt (token->location, &compound_stmt, new_in);\n+\n+  parser->in_transaction = new_in;\n+\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_TRY))\n+    ctor_initializer_p = cp_parser_function_try_block (parser);\n+  else\n+    ctor_initializer_p\n+      = cp_parser_ctor_initializer_opt_and_function_body (parser);\n+\n+  parser->in_transaction = old_in;\n+\n+  finish_transaction_stmt (stmt, compound_stmt, new_in);\n+\n+  return ctor_initializer_p;\n+}\n+\n+/* Parse a __transaction_cancel statement.\n+\n+   cancel-statement:\n+     __transaction_cancel txn-attribute[opt] ;\n+     __transaction_cancel txn-attribute[opt] throw-expression ;\n+\n+   ??? Cancel and throw is not yet implemented.  */\n+\n+static tree\n+cp_parser_transaction_cancel (cp_parser *parser)\n+{\n+  cp_token *token;\n+  bool is_outer = false;\n+  tree stmt, attrs;\n+\n+  token = cp_parser_require_keyword (parser, RID_TRANSACTION_CANCEL,\n+\t\t\t\t     RT_TRANSACTION_CANCEL);\n+  gcc_assert (token != NULL);\n+\n+  attrs = cp_parser_txn_attribute_opt (parser);\n+  if (attrs)\n+    is_outer = (parse_tm_stmt_attr (attrs, TM_STMT_ATTR_OUTER) != 0);\n+\n+  /* ??? Parse cancel-and-throw here.  */\n+\n+  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+\n+  if (!flag_tm)\n+    {\n+      error_at (token->location, \"%<__transaction_cancel%> without \"\n+\t\t\"transactional memory support enabled\");\n+      return error_mark_node;\n+    }\n+  else if (parser->in_transaction & TM_STMT_ATTR_RELAXED)\n+    {\n+      error_at (token->location, \"%<__transaction_cancel%> within a \"\n+\t\t\"%<__transaction_relaxed%>\");\n+      return error_mark_node;\n+    }\n+  else if (is_outer)\n+    {\n+      if ((parser->in_transaction & TM_STMT_ATTR_OUTER) == 0\n+\t  && !is_tm_may_cancel_outer (current_function_decl))\n+\t{\n+\t  error_at (token->location, \"outer %<__transaction_cancel%> not \"\n+\t\t    \"within outer %<__transaction_atomic%>\");\n+\t  error_at (token->location,\n+\t\t    \"  or a %<transaction_may_cancel_outer%> function\");\n+\t  return error_mark_node;\n+\t}\n+    }\n+  else if (parser->in_transaction == 0)\n+    {\n+      error_at (token->location, \"%<__transaction_cancel%> not within \"\n+\t\t\"%<__transaction_atomic%>\");\n+      return error_mark_node;\n+    }\n+\n+  stmt = build_tm_abort_call (token->location, is_outer);\n+  add_stmt (stmt);\n+  finish_stmt ();\n+\n+  return stmt;\n+}\n+\f\n /* The parser.  */\n \n static GTY (()) cp_parser *the_parser;"}, {"sha": "5b95f0892de3f6304d406d0dab2d59bfb852308d", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -329,6 +329,10 @@ typedef struct GTY(()) cp_parser {\n      a local class.  */\n   bool in_function_body;\n \n+  /* Nonzero if we're processing a __transaction_atomic or\n+     __transaction_relaxed statement.  */\n+  unsigned char in_transaction;\n+\n   /* TRUE if we can auto-correct a colon to a scope operator.  */\n   bool colon_corrects_to_scope_p;\n "}, {"sha": "8c91a9ed021e7c86d30a7da39fe75ca7c794d7e0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -13108,6 +13108,28 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t}\n       break;\n \n+    case TRANSACTION_EXPR:\n+      {\n+\tint flags = 0;\n+\tflags |= (TRANSACTION_EXPR_OUTER (t) ? TM_STMT_ATTR_OUTER : 0);\n+\tflags |= (TRANSACTION_EXPR_RELAXED (t) ? TM_STMT_ATTR_RELAXED : 0);\n+\n+        if (TRANSACTION_EXPR_IS_STMT (t))\n+          {\n+            stmt = begin_transaction_stmt (input_location, NULL, flags);\n+            RECUR (TRANSACTION_EXPR_BODY (t));\n+            finish_transaction_stmt (stmt, NULL, flags);\n+          }\n+        else\n+          {\n+            stmt = build_transaction_expr (EXPR_LOCATION (t),\n+\t\t\t\t\t   RECUR (TRANSACTION_EXPR_BODY (t)),\n+\t\t\t\t\t   flags);\n+            return stmt;\n+          }\n+      }\n+      break;\n+\n     case EXPR_PACK_EXPANSION:\n       error (\"invalid use of pack expansion expression\");\n       return error_mark_node;"}, {"sha": "508e2529fbe1184ab8277055072c2cd5fc167155", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -4968,6 +4968,64 @@ finish_omp_taskyield (void)\n   finish_expr_stmt (stmt);\n }\n \f\n+/* Begin a __transaction_atomic or __transaction_relaxed statement.\n+   If PCOMPOUND is non-null, this is for a function-transaction-block, and we\n+   should create an extra compound stmt.  */\n+\n+tree\n+begin_transaction_stmt (location_t loc, tree *pcompound, int flags)\n+{\n+  tree r;\n+\n+  if (pcompound)\n+    *pcompound = begin_compound_stmt (0);\n+\n+  r = build_stmt (loc, TRANSACTION_EXPR, NULL_TREE);\n+\n+  /* Only add the statement to the function if support enabled.  */\n+  if (flag_tm)\n+    add_stmt (r);\n+  else\n+    error_at (loc, ((flags & TM_STMT_ATTR_RELAXED) != 0\n+\t\t    ? G_(\"%<__transaction_relaxed%> without \"\n+\t\t\t \"transactional memory support enabled\")\n+\t\t    : G_(\"%<__transaction_atomic%> without \"\n+\t\t\t \"transactional memory support enabled\")));\n+\n+  TRANSACTION_EXPR_BODY (r) = push_stmt_list ();\n+  return r;\n+}\n+\n+/* End a __transaction_atomic or __transaction_relaxed statement.\n+   If COMPOUND_STMT is non-null, this is for a function-transaction-block,\n+   and we should end the compound.  */\n+\n+void\n+finish_transaction_stmt (tree stmt, tree compound_stmt, int flags)\n+{\n+  TRANSACTION_EXPR_BODY (stmt) = pop_stmt_list (TRANSACTION_EXPR_BODY (stmt));\n+  TRANSACTION_EXPR_OUTER (stmt) = (flags & TM_STMT_ATTR_OUTER) != 0;\n+  TRANSACTION_EXPR_RELAXED (stmt) = (flags & TM_STMT_ATTR_RELAXED) != 0;\n+  TRANSACTION_EXPR_IS_STMT (stmt) = 1;\n+\n+  if (compound_stmt)\n+    finish_compound_stmt (compound_stmt);\n+  finish_stmt ();\n+}\n+\n+/* Build a __transaction_atomic or __transaction_relaxed expression.  */\n+\n+tree\n+build_transaction_expr (location_t loc, tree expr, int flags)\n+{\n+  tree ret;\n+  ret = build1 (TRANSACTION_EXPR, TREE_TYPE (expr), expr);\n+  if (flags & TM_STMT_ATTR_RELAXED)\n+\tTRANSACTION_EXPR_RELAXED (ret) = 1;\n+  SET_EXPR_LOCATION (ret, loc);\n+  return ret;\n+}\n+\f\n void\n init_cp_semantics (void)\n {\n@@ -8099,6 +8157,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case STMT_EXPR:\n     case EXPR_STMT:\n     case BIND_EXPR:\n+    case TRANSACTION_EXPR:\n       if (flags & tf_error)\n         error (\"expression %qE is not a constant-expression\", t);\n       return false;"}, {"sha": "3a5a3414cd9fd34de94c7bf632ec210b8f6e89f5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1723,6 +1723,19 @@ Program Interface v3.0 @w{@uref{http://www.openmp.org/}}.  This option\n implies @option{-pthread}, and thus is only supported on targets that\n have support for @option{-pthread}.\n \n+@item -fgnu-tm\n+@opindex fgnu-tm\n+When the option @option{-fgnu-tm} is specified, the compiler will\n+generate code for the Linux variant of Intel's current Transactional\n+Memory ABI specification document (Revision 1.1, May 6 2009).  This is\n+an experimental feature whose interface may change in future versions\n+of GCC, as the official specification changes.  Please note that not\n+all architectures are supported for this feature.\n+\n+For more information on GCC's support for transactional memory,\n+@xref{Enabling libitm,,The GNU Transactional Memory Library,libitm,GNU\n+Transactional Memory Library}.\n+\n @item -fms-extensions\n @opindex fms-extensions\n Accept some non-standard constructs used in Microsoft header files.\n@@ -9113,6 +9126,13 @@ parameters only when their cumulative size is less or equal to\n @option{ipa-sra-ptr-growth-factor} times the size of the original\n pointer parameter.\n \n+@item tm-max-aggregate-size\n+When making copies of thread-local variables in a transaction, this\n+parameter specifies the size in bytes after which variables will be\n+saved with the logging functions as opposed to save/restore code\n+sequence pairs.  This option only applies when using\n+@option{-fgnu-tm}.\n+\n @item graphite-max-nb-scop-params\n To avoid exponential effects in the Graphite loop transforms, the\n number of parameters in a Static Control Part (SCoP) is bounded.  The"}, {"sha": "d96932b4e4833f85ac8eb9d85e940674bc9041cc", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -5758,6 +5758,14 @@ mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n The default is zero which means to not iterate over other vector sizes.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_TM_LOAD (tree)\n+This hook should return the built-in decl needed to load a vector of the given type within a transaction.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_TM_STORE (tree)\n+This hook should return the built-in decl needed to store a vector of the given type within a transaction.\n+@end deftypefn\n+\n @deftypefn {Target Hook} tree TARGET_VECTORIZE_BUILTIN_GATHER (const_tree @var{mem_vectype}, const_tree @var{index_type}, int @var{scale})\n Target builtin that implements vector gather operation.  @var{mem_vectype}\n is the vector type of the load and @var{index_type} is scalar type of"}, {"sha": "146e38a35e1dadc74a57e2e0e95354787b265b3f", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -5696,6 +5696,10 @@ mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n The default is zero which means to not iterate over other vector sizes.\n @end deftypefn\n \n+@hook TARGET_VECTORIZE_BUILTIN_TM_LOAD\n+\n+@hook TARGET_VECTORIZE_BUILTIN_TM_STORE\n+\n @hook TARGET_VECTORIZE_BUILTIN_GATHER\n Target builtin that implements vector gather operation.  @var{mem_vectype}\n is the vector type of the load and @var{index_type} is scalar type of"}, {"sha": "4a27a058b83f4bfc706103ccbf9555a79388915b", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -3595,6 +3595,7 @@ try_split (rtx pat, rtx trial, int last)\n \n \tcase REG_NORETURN:\n \tcase REG_SETJMP:\n+\tcase REG_TM:\n \t  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))\n \t    {\n \t      if (CALL_P (insn))"}, {"sha": "f6deba179389d0e3019eb64da162eeb4858783eb", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -396,6 +396,11 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       lower_sequence (gimple_eh_filter_failure (stmt), data);\n       break;\n \n+    case GIMPLE_EH_ELSE:\n+      lower_sequence (gimple_eh_else_n_body (stmt), data);\n+      lower_sequence (gimple_eh_else_e_body (stmt), data);\n+      break;\n+\n     case GIMPLE_NOP:\n     case GIMPLE_ASM:\n     case GIMPLE_ASSIGN:\n@@ -446,6 +451,10 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n       data->cannot_fallthru = false;\n       return;\n \n+    case GIMPLE_TRANSACTION:\n+      lower_sequence (gimple_transaction_body (stmt), data);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -727,6 +736,10 @@ gimple_stmt_may_fallthru (gimple stmt)\n       return (gimple_seq_may_fallthru (gimple_try_eval (stmt))\n \t      && gimple_seq_may_fallthru (gimple_try_cleanup (stmt)));\n \n+    case GIMPLE_EH_ELSE:\n+      return (gimple_seq_may_fallthru (gimple_eh_else_n_body (stmt))\n+\t      || gimple_seq_may_fallthru (gimple_eh_else_e_body (stmt)));\n+\n     case GIMPLE_CALL:\n       /* Functions that do not return do not fall through.  */\n       return (gimple_call_flags (stmt) & ECF_NORETURN) == 0;"}, {"sha": "df703b4ce75a3a781ec1a83a8fd737c56a5ca54c", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 166, "deletions": 4, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"gimple.h\"\n #include \"value-prof.h\"\n+#include \"trans-mem.h\"\n \n #define INDENT(SPACE)\t\t\t\t\t\t\t\\\n   do { int i; for (i = 0; i < SPACE; i++) pp_space (buffer); } while (0)\n@@ -162,6 +163,7 @@ debug_gimple_seq (gimple_seq seq)\n      'd' - outputs an int as a decimal,\n      's' - outputs a string,\n      'n' - outputs a newline,\n+     'x' - outputs an int as hexadecimal,\n      '+' - increases indent by 2 then outputs a newline,\n      '-' - decreases indent by 2 then outputs a newline.   */\n \n@@ -216,6 +218,10 @@ dump_gimple_fmt (pretty_printer *buffer, int spc, int flags,\n                 newline_and_indent (buffer, spc);\n                 break;\n \n+\t      case 'x':\n+\t\tpp_scalar (buffer, \"%x\", va_arg (args, int));\n+\t\tbreak;\n+\n               case '+':\n                 spc += 2;\n                 newline_and_indent (buffer, spc);\n@@ -622,6 +628,7 @@ static void\n dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n {\n   tree lhs = gimple_call_lhs (gs);\n+  tree fn = gimple_call_fn (gs);\n \n   if (flags & TDF_ALIAS)\n     {\n@@ -648,8 +655,7 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n \tdump_gimple_fmt (buffer, spc, flags, \"%G <%s, %T\", gs,\n \t\t\t internal_fn_name (gimple_call_internal_fn (gs)), lhs);\n       else\n-\tdump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T\",\n-\t\t\t gs, gimple_call_fn (gs), lhs);\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T\", gs, fn, lhs);\n       if (gimple_call_num_args (gs) > 0)\n         {\n           pp_string (buffer, \", \");\n@@ -672,7 +678,7 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n       if (gimple_call_internal_p (gs))\n \tpp_string (buffer, internal_fn_name (gimple_call_internal_fn (gs)));\n       else\n-\tprint_call_name (buffer, gimple_call_fn (gs), flags);\n+\tprint_call_name (buffer, fn, flags);\n       pp_string (buffer, \" (\");\n       dump_gimple_call_args (buffer, gs, flags);\n       pp_character (buffer, ')');\n@@ -689,9 +695,59 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n   if (gimple_call_return_slot_opt_p (gs))\n     pp_string (buffer, \" [return slot optimization]\");\n-\n   if (gimple_call_tail_p (gs))\n     pp_string (buffer, \" [tail call]\");\n+\n+  /* Dump the arguments of _ITM_beginTransaction sanely.  */\n+  if (TREE_CODE (fn) == ADDR_EXPR)\n+    fn = TREE_OPERAND (fn, 0);\n+  if (TREE_CODE (fn) == FUNCTION_DECL && decl_is_tm_clone (fn))\n+    pp_string (buffer, \" [tm-clone]\");\n+  if (TREE_CODE (fn) == FUNCTION_DECL\n+      && DECL_BUILT_IN_CLASS (fn) == BUILT_IN_NORMAL\n+      && DECL_FUNCTION_CODE (fn) == BUILT_IN_TM_START\n+      && gimple_call_num_args (gs) > 0)\n+    {\n+      tree t = gimple_call_arg (gs, 0);\n+      unsigned HOST_WIDE_INT props;\n+      gcc_assert (TREE_CODE (t) == INTEGER_CST);\n+\n+      pp_string (buffer, \" [ \");\n+\n+      /* Get the transaction code properties.  */\n+      props = TREE_INT_CST_LOW (t);\n+\n+      if (props & PR_INSTRUMENTEDCODE)\n+\tpp_string (buffer, \"instrumentedCode \");\n+      if (props & PR_UNINSTRUMENTEDCODE)\n+\tpp_string (buffer, \"uninstrumentedCode \");\n+      if (props & PR_HASNOXMMUPDATE)\n+\tpp_string (buffer, \"hasNoXMMUpdate \");\n+      if (props & PR_HASNOABORT)\n+\tpp_string (buffer, \"hasNoAbort \");\n+      if (props & PR_HASNOIRREVOCABLE)\n+\tpp_string (buffer, \"hasNoIrrevocable \");\n+      if (props & PR_DOESGOIRREVOCABLE)\n+\tpp_string (buffer, \"doesGoIrrevocable \");\n+      if (props & PR_HASNOSIMPLEREADS)\n+\tpp_string (buffer, \"hasNoSimpleReads \");\n+      if (props & PR_AWBARRIERSOMITTED)\n+\tpp_string (buffer, \"awBarriersOmitted \");\n+      if (props & PR_RARBARRIERSOMITTED)\n+\tpp_string (buffer, \"RaRBarriersOmitted \");\n+      if (props & PR_UNDOLOGCODE)\n+\tpp_string (buffer, \"undoLogCode \");\n+      if (props & PR_PREFERUNINSTRUMENTED)\n+\tpp_string (buffer, \"preferUninstrumented \");\n+      if (props & PR_EXCEPTIONBLOCK)\n+\tpp_string (buffer, \"exceptionBlock \");\n+      if (props & PR_HASELSE)\n+\tpp_string (buffer, \"hasElse \");\n+      if (props & PR_READONLY)\n+\tpp_string (buffer, \"readOnly \");\n+\n+      pp_string (buffer, \"]\");\n+    }\n }\n \n \n@@ -947,6 +1003,24 @@ dump_gimple_eh_must_not_throw (pretty_printer *buffer, gimple gs,\n }\n \n \n+/* Dump a GIMPLE_EH_ELSE tuple on the pretty_printer BUFFER, SPC spaces of\n+   indent.  FLAGS specifies details to show in the dump (see TDF_* in\n+   tree-pass.h).  */\n+\n+static void\n+dump_gimple_eh_else (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  if (flags & TDF_RAW)\n+    dump_gimple_fmt (buffer, spc, flags,\n+\t\t     \"%G <%+N_BODY <%S>%nE_BODY <%S>%->\", gs,\n+\t\t     gimple_eh_else_n_body (gs), gimple_eh_else_e_body (gs));\n+  else\n+    dump_gimple_fmt (buffer, spc, flags,\n+\t\t    \"<<<if_normal_exit>>>%+{%S}%-<<<else_eh_exit>>>%+{%S}\",\n+\t\t     gimple_eh_else_n_body (gs), gimple_eh_else_e_body (gs));\n+}\n+\n+\n /* Dump a GIMPLE_RESX tuple on the pretty_printer BUFFER, SPC spaces of\n    indent.  FLAGS specifies details to show in the dump (see TDF_* in\n    tree-pass.h).  */\n@@ -1269,6 +1343,86 @@ dump_gimple_omp_return (pretty_printer *buffer, gimple gs, int spc, int flags)\n     }\n }\n \n+/* Dump a GIMPLE_TRANSACTION tuple on the pretty_printer BUFFER.  */\n+\n+static void\n+dump_gimple_transaction (pretty_printer *buffer, gimple gs, int spc, int flags)\n+{\n+  unsigned subcode = gimple_transaction_subcode (gs);\n+\n+  if (flags & TDF_RAW)\n+    {\n+      dump_gimple_fmt (buffer, spc, flags,\n+\t\t       \"%G [SUBCODE=%x,LABEL=%T] <%+BODY <%S> >\",\n+\t\t       gs, subcode, gimple_transaction_label (gs),\n+\t\t       gimple_transaction_body (gs));\n+    }\n+  else\n+    {\n+      if (subcode & GTMA_IS_OUTER)\n+\tpp_string (buffer, \"__transaction_atomic [[outer]]\");\n+      else if (subcode & GTMA_IS_RELAXED)\n+\tpp_string (buffer, \"__transaction_relaxed\");\n+      else\n+\tpp_string (buffer, \"__transaction_atomic\");\n+      subcode &= ~GTMA_DECLARATION_MASK;\n+\n+      if (subcode || gimple_transaction_label (gs))\n+\t{\n+\t  pp_string (buffer, \"  //\");\n+\t  if (gimple_transaction_label (gs))\n+\t    {\n+\t      pp_string (buffer, \" LABEL=\");\n+\t      dump_generic_node (buffer, gimple_transaction_label (gs),\n+\t\t\t\t spc, flags, false);\n+\t    }\n+\t  if (subcode)\n+\t    {\n+\t      pp_string (buffer, \" SUBCODE=[ \");\n+\t      if (subcode & GTMA_HAVE_ABORT)\n+\t\t{\n+\t\t  pp_string (buffer, \"GTMA_HAVE_ABORT \");\n+\t\t  subcode &= ~GTMA_HAVE_ABORT;\n+\t\t}\n+\t      if (subcode & GTMA_HAVE_LOAD)\n+\t\t{\n+\t\t  pp_string (buffer, \"GTMA_HAVE_LOAD \");\n+\t\t  subcode &= ~GTMA_HAVE_LOAD;\n+\t\t}\n+\t      if (subcode & GTMA_HAVE_STORE)\n+\t\t{\n+\t\t  pp_string (buffer, \"GTMA_HAVE_STORE \");\n+\t\t  subcode &= ~GTMA_HAVE_STORE;\n+\t\t}\n+\t      if (subcode & GTMA_MAY_ENTER_IRREVOCABLE)\n+\t\t{\n+\t\t  pp_string (buffer, \"GTMA_MAY_ENTER_IRREVOCABLE \");\n+\t\t  subcode &= ~GTMA_MAY_ENTER_IRREVOCABLE;\n+\t\t}\n+\t      if (subcode & GTMA_DOES_GO_IRREVOCABLE)\n+\t\t{\n+\t\t  pp_string (buffer, \"GTMA_DOES_GO_IRREVOCABLE \");\n+\t\t  subcode &= ~GTMA_DOES_GO_IRREVOCABLE;\n+\t\t}\n+\t      if (subcode)\n+\t\tpp_printf (buffer, \"0x%x \", subcode);\n+\t      pp_string (buffer, \"]\");\n+\t    }\n+\t}\n+\n+      if (!gimple_seq_empty_p (gimple_transaction_body (gs)))\n+\t{\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '{');\n+\t  pp_newline (buffer);\n+\t  dump_gimple_seq (buffer, gimple_transaction_body (gs),\n+\t\t\t   spc + 4, flags);\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  pp_character (buffer, '}');\n+\t}\n+    }\n+}\n+\n /* Dump a GIMPLE_ASM tuple on the pretty_printer BUFFER, SPC spaces of\n    indent.  FLAGS specifies details to show in the dump (see TDF_* in\n    tree-pass.h).  */\n@@ -1855,6 +2009,10 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n       dump_gimple_eh_must_not_throw (buffer, gs, spc, flags);\n       break;\n \n+    case GIMPLE_EH_ELSE:\n+      dump_gimple_eh_else (buffer, gs, spc, flags);\n+      break;\n+\n     case GIMPLE_RESX:\n       dump_gimple_resx (buffer, gs, spc, flags);\n       break;\n@@ -1877,6 +2035,10 @@ dump_gimple_stmt (pretty_printer *buffer, gimple gs, int spc, int flags)\n       pp_string (buffer, \" predictor.\");\n       break;\n \n+    case GIMPLE_TRANSACTION:\n+      dump_gimple_transaction (buffer, gs, spc, flags);\n+      break;\n+\n     default:\n       GIMPLE_NIY;\n     }"}, {"sha": "e803f56d0a384d58caa8ab982820e29e70327cdb", "filename": "gcc/gimple.c", "status": "modified", "additions": 81, "deletions": 56, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -743,6 +743,17 @@ gimple_build_eh_must_not_throw (tree decl)\n   return p;\n }\n \n+/* Build a GIMPLE_EH_ELSE statement.  */\n+\n+gimple\n+gimple_build_eh_else (gimple_seq n_body, gimple_seq e_body)\n+{\n+  gimple p = gimple_alloc (GIMPLE_EH_ELSE, 0);\n+  gimple_eh_else_set_n_body (p, n_body);\n+  gimple_eh_else_set_e_body (p, e_body);\n+  return p;\n+}\n+\n /* Build a GIMPLE_TRY statement.\n \n    EVAL is the expression to evaluate.\n@@ -1146,6 +1157,17 @@ gimple_build_omp_atomic_store (tree val)\n   return p;\n }\n \n+/* Build a GIMPLE_TRANSACTION statement.  */\n+\n+gimple\n+gimple_build_transaction (gimple_seq body, tree label)\n+{\n+  gimple p = gimple_alloc (GIMPLE_TRANSACTION, 0);\n+  gimple_transaction_set_body (p, body);\n+  gimple_transaction_set_label (p, label);\n+  return p;\n+}\n+\n /* Build a GIMPLE_PREDICT statement.  PREDICT is one of the predictors from\n    predict.def, OUTCOME is NOT_TAKEN or TAKEN.  */\n \n@@ -1319,9 +1341,11 @@ gimple_seq_copy (gimple_seq src)\n /* Walk all the statements in the sequence SEQ calling walk_gimple_stmt\n    on each one.  WI is as in walk_gimple_stmt.\n \n-   If walk_gimple_stmt returns non-NULL, the walk is stopped, the\n-   value is stored in WI->CALLBACK_RESULT and the statement that\n-   produced the value is returned.\n+   If walk_gimple_stmt returns non-NULL, the walk is stopped, and the\n+   value is stored in WI->CALLBACK_RESULT.  Also, the statement that\n+   produced the value is returned if this statement has not been\n+   removed by a callback (wi->removed_stmt).  If the statement has\n+   been removed, NULL is returned.\n \n    Otherwise, all the statements are walked and NULL returned.  */\n \n@@ -1331,7 +1355,7 @@ walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n {\n   gimple_stmt_iterator gsi;\n \n-  for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gsi = gsi_start (seq); !gsi_end_p (gsi); )\n     {\n       tree ret = walk_gimple_stmt (&gsi, callback_stmt, callback_op, wi);\n       if (ret)\n@@ -1340,8 +1364,12 @@ walk_gimple_seq (gimple_seq seq, walk_stmt_fn callback_stmt,\n \t     to hold it.  */\n \t  gcc_assert (wi);\n \t  wi->callback_result = ret;\n-\t  return gsi_stmt (gsi);\n+\n+\t  return wi->removed_stmt ? NULL : gsi_stmt (gsi);\n \t}\n+\n+      if (!wi->removed_stmt)\n+\tgsi_next (&gsi);\n     }\n \n   if (wi)\n@@ -1680,6 +1708,13 @@ walk_gimple_op (gimple stmt, walk_tree_fn callback_op,\n \treturn ret;\n       break;\n \n+    case GIMPLE_TRANSACTION:\n+      ret = walk_tree (gimple_transaction_label_ptr (stmt), callback_op,\n+\t\t       wi, pset);\n+      if (ret)\n+\treturn ret;\n+      break;\n+\n       /* Tuples that do not have operands.  */\n     case GIMPLE_NOP:\n     case GIMPLE_RESX:\n@@ -1730,10 +1765,13 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n   gimple stmt = gsi_stmt (*gsi);\n \n   if (wi)\n-    wi->gsi = *gsi;\n+    {\n+      wi->gsi = *gsi;\n+      wi->removed_stmt = false;\n \n-  if (wi && wi->want_locations && gimple_has_location (stmt))\n-    input_location = gimple_location (stmt);\n+      if (wi->want_locations && gimple_has_location (stmt))\n+\tinput_location = gimple_location (stmt);\n+    }\n \n   ret = NULL;\n \n@@ -1750,6 +1788,9 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n \t a value to return.  */\n       gcc_assert (tree_ret == NULL);\n \n+      if (wi && wi->removed_stmt)\n+\treturn NULL;\n+\n       /* Re-read stmt in case the callback changed it.  */\n       stmt = gsi_stmt (*gsi);\n     }\n@@ -1786,6 +1827,17 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n \treturn wi->callback_result;\n       break;\n \n+    case GIMPLE_EH_ELSE:\n+      ret = walk_gimple_seq (gimple_eh_else_n_body (stmt),\n+\t\t\t     callback_stmt, callback_op, wi);\n+      if (ret)\n+\treturn wi->callback_result;\n+      ret = walk_gimple_seq (gimple_eh_else_e_body (stmt),\n+\t\t\t     callback_stmt, callback_op, wi);\n+      if (ret)\n+\treturn wi->callback_result;\n+      break;\n+\n     case GIMPLE_TRY:\n       ret = walk_gimple_seq (gimple_try_eval (stmt), callback_stmt, callback_op,\n \t                     wi);\n@@ -1813,8 +1865,8 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n     case GIMPLE_OMP_TASK:\n     case GIMPLE_OMP_SECTIONS:\n     case GIMPLE_OMP_SINGLE:\n-      ret = walk_gimple_seq (gimple_omp_body (stmt), callback_stmt, callback_op,\n-\t                     wi);\n+      ret = walk_gimple_seq (gimple_omp_body (stmt), callback_stmt,\n+\t\t\t     callback_op, wi);\n       if (ret)\n \treturn wi->callback_result;\n       break;\n@@ -1826,6 +1878,13 @@ walk_gimple_stmt (gimple_stmt_iterator *gsi, walk_stmt_fn callback_stmt,\n \treturn wi->callback_result;\n       break;\n \n+    case GIMPLE_TRANSACTION:\n+      ret = walk_gimple_seq (gimple_transaction_body (stmt),\n+\t\t\t     callback_stmt, callback_op, wi);\n+      if (ret)\n+\treturn wi->callback_result;\n+      break;\n+\n     default:\n       gcc_assert (!gimple_has_substatements (stmt));\n       break;\n@@ -2252,6 +2311,13 @@ gimple_copy (gimple stmt)\n \t  gimple_eh_filter_set_types (copy, t);\n \t  break;\n \n+\tcase GIMPLE_EH_ELSE:\n+\t  new_seq = gimple_seq_copy (gimple_eh_else_n_body (stmt));\n+\t  gimple_eh_else_set_n_body (copy, new_seq);\n+\t  new_seq = gimple_seq_copy (gimple_eh_else_e_body (stmt));\n+\t  gimple_eh_else_set_e_body (copy, new_seq);\n+\t  break;\n+\n \tcase GIMPLE_TRY:\n \t  new_seq = gimple_seq_copy (gimple_try_eval (stmt));\n \t  gimple_try_set_eval (copy, new_seq);\n@@ -2327,6 +2393,11 @@ gimple_copy (gimple stmt)\n \t  gimple_omp_set_body (copy, new_seq);\n \t  break;\n \n+\tcase GIMPLE_TRANSACTION:\n+\t  new_seq = gimple_seq_copy (gimple_transaction_body (stmt));\n+\t  gimple_transaction_set_body (copy, new_seq);\n+\t  break;\n+\n \tcase GIMPLE_WITH_CLEANUP_EXPR:\n \t  new_seq = gimple_seq_copy (gimple_wce_cleanup (stmt));\n \t  gimple_wce_set_cleanup (copy, new_seq);\n@@ -2782,37 +2853,6 @@ is_gimple_address (const_tree t)\n     }\n }\n \n-/* Strip out all handled components that produce invariant\n-   offsets.  */\n-\n-static const_tree\n-strip_invariant_refs (const_tree op)\n-{\n-  while (handled_component_p (op))\n-    {\n-      switch (TREE_CODE (op))\n-\t{\n-\tcase ARRAY_REF:\n-\tcase ARRAY_RANGE_REF:\n-\t  if (!is_gimple_constant (TREE_OPERAND (op, 1))\n-\t      || TREE_OPERAND (op, 2) != NULL_TREE\n-\t      || TREE_OPERAND (op, 3) != NULL_TREE)\n-\t    return NULL;\n-\t  break;\n-\n-\tcase COMPONENT_REF:\n-\t  if (TREE_OPERAND (op, 2) != NULL_TREE)\n-\t    return NULL;\n-\t  break;\n-\n-\tdefault:;\n-\t}\n-      op = TREE_OPERAND (op, 0);\n-    }\n-\n-  return op;\n-}\n-\n /* Return true if T is a gimple invariant address.  */\n \n bool\n@@ -3075,21 +3115,6 @@ is_gimple_mem_ref_addr (tree t)\n \t\t  || decl_address_invariant_p (TREE_OPERAND (t, 0)))));\n }\n \n-/* If T makes a function call, return the corresponding CALL_EXPR operand.\n-   Otherwise, return NULL_TREE.  */\n-\n-tree\n-get_call_expr_in (tree t)\n-{\n-  if (TREE_CODE (t) == MODIFY_EXPR)\n-    t = TREE_OPERAND (t, 1);\n-  if (TREE_CODE (t) == WITH_SIZE_EXPR)\n-    t = TREE_OPERAND (t, 0);\n-  if (TREE_CODE (t) == CALL_EXPR)\n-    return t;\n-  return NULL_TREE;\n-}\n-\n \n /* Given a memory reference expression T, return its base address.\n    The base address of a memory reference expression is the main"}, {"sha": "5ae97025cb21efb5d9acea1588a3b54a48f4b850", "filename": "gcc/gimple.def", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -124,6 +124,14 @@ DEFGSCODE(GIMPLE_ASM, \"gimple_asm\", GSS_ASM)\n     CHAIN is the optional static chain link for nested functions.  */\n DEFGSCODE(GIMPLE_CALL, \"gimple_call\", GSS_CALL)\n \n+/* GIMPLE_TRANSACTION <BODY, LABEL> represents __transaction_atomic and\n+   __transaction_relaxed blocks.\n+   BODY is the sequence of statements inside the transaction.\n+   LABEL is a label for the statement immediately following the\n+   transaction.  This is before RETURN so that it has MEM_OPS,\n+   so that it can clobber global memory.  */\n+DEFGSCODE(GIMPLE_TRANSACTION, \"gimple_transaction\", GSS_TRANSACTION)\n+\n /* GIMPLE_RETURN <RETVAL> represents return statements.\n \n    RETVAL is the value to return or NULL.  If a value is returned it\n@@ -151,6 +159,12 @@ DEFGSCODE(GIMPLE_EH_FILTER, \"gimple_eh_filter\", GSS_EH_FILTER)\n    be invoked if an exception propagates to this point.  */\n DEFGSCODE(GIMPLE_EH_MUST_NOT_THROW, \"gimple_eh_must_not_throw\", GSS_EH_MNT)\n \n+/* GIMPLE_EH_ELSE <N_BODY, E_BODY> must be the sole contents of\n+   a GIMPLE_TRY_FINALLY node.  For all normal exits from the try block,\n+   N_BODY is run; for all exception exits from the try block,\n+   E_BODY is run.  */\n+DEFGSCODE(GIMPLE_EH_ELSE, \"gimple_eh_else\", GSS_EH_ELSE)\n+\n /* GIMPLE_RESX resumes execution after an exception.  */\n DEFGSCODE(GIMPLE_RESX, \"gimple_resx\", GSS_EH_CTRL)\n "}, {"sha": "ffecc2617af42c7d48af612c93d80f0b3a7a0141", "filename": "gcc/gimple.h", "status": "modified", "additions": 157, "deletions": 11, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -487,6 +487,15 @@ struct GTY(()) gimple_statement_eh_filter {\n   gimple_seq failure;\n };\n \n+/* GIMPLE_EH_ELSE */\n+\n+struct GTY(()) gimple_statement_eh_else {\n+  /* [ WORD 1-4 ]  */\n+  struct gimple_statement_base gsbase;\n+\n+  /* [ WORD 5,6 ] */\n+  gimple_seq n_body, e_body;\n+};\n \n /* GIMPLE_EH_MUST_NOT_THROW */\n \n@@ -757,6 +766,43 @@ struct GTY(()) gimple_statement_omp_atomic_store {\n   tree val;\n };\n \n+/* GIMPLE_TRANSACTION.  */\n+\n+/* Bits to be stored in the GIMPLE_TRANSACTION subcode.  */\n+\n+/* The __transaction_atomic was declared [[outer]] or it is\n+   __transaction_relaxed.  */\n+#define GTMA_IS_OUTER\t\t\t(1u << 0)\n+#define GTMA_IS_RELAXED\t\t\t(1u << 1)\n+#define GTMA_DECLARATION_MASK\t\t(GTMA_IS_OUTER | GTMA_IS_RELAXED)\n+\n+/* The transaction is seen to not have an abort.  */\n+#define GTMA_HAVE_ABORT\t\t\t(1u << 2)\n+/* The transaction is seen to have loads or stores.  */\n+#define GTMA_HAVE_LOAD\t\t\t(1u << 3)\n+#define GTMA_HAVE_STORE\t\t\t(1u << 4)\n+/* The transaction MAY enter serial irrevocable mode in its dynamic scope.  */\n+#define GTMA_MAY_ENTER_IRREVOCABLE\t(1u << 5)\n+/* The transaction WILL enter serial irrevocable mode.\n+   An irrevocable block post-dominates the entire transaction, such\n+   that all invocations of the transaction will go serial-irrevocable.\n+   In such case, we don't bother instrumenting the transaction, and\n+   tell the runtime that it should begin the transaction in\n+   serial-irrevocable mode.  */\n+#define GTMA_DOES_GO_IRREVOCABLE\t(1u << 6)\n+\n+struct GTY(()) gimple_statement_transaction\n+{\n+  /* [ WORD 1-10 ]  */\n+  struct gimple_statement_with_memory_ops_base gsbase;\n+\n+  /* [ WORD 11 ] */\n+  gimple_seq body;\n+\n+  /* [ WORD 12 ] */\n+  tree label;\n+};\n+\n #define DEFGSSTRUCT(SYM, STRUCT, HAS_TREE_OP)\tSYM,\n enum gimple_statement_structure_enum {\n #include \"gsstruct.def\"\n@@ -779,6 +825,7 @@ union GTY ((desc (\"gimple_statement_structure (&%h)\"), variable_size)) gimple_st\n   struct gimple_statement_catch GTY ((tag (\"GSS_CATCH\"))) gimple_catch;\n   struct gimple_statement_eh_filter GTY ((tag (\"GSS_EH_FILTER\"))) gimple_eh_filter;\n   struct gimple_statement_eh_mnt GTY ((tag (\"GSS_EH_MNT\"))) gimple_eh_mnt;\n+  struct gimple_statement_eh_else GTY ((tag (\"GSS_EH_ELSE\"))) gimple_eh_else;\n   struct gimple_statement_phi GTY ((tag (\"GSS_PHI\"))) gimple_phi;\n   struct gimple_statement_eh_ctrl GTY ((tag (\"GSS_EH_CTRL\"))) gimple_eh_ctrl;\n   struct gimple_statement_try GTY ((tag (\"GSS_TRY\"))) gimple_try;\n@@ -793,6 +840,7 @@ union GTY ((desc (\"gimple_statement_structure (&%h)\"), variable_size)) gimple_st\n   struct gimple_statement_omp_continue GTY ((tag (\"GSS_OMP_CONTINUE\"))) gimple_omp_continue;\n   struct gimple_statement_omp_atomic_load GTY ((tag (\"GSS_OMP_ATOMIC_LOAD\"))) gimple_omp_atomic_load;\n   struct gimple_statement_omp_atomic_store GTY ((tag (\"GSS_OMP_ATOMIC_STORE\"))) gimple_omp_atomic_store;\n+  struct gimple_statement_transaction GTY((tag (\"GSS_TRANSACTION\"))) gimple_transaction;\n };\n \n /* In gimple.c.  */\n@@ -846,6 +894,7 @@ gimple gimple_build_asm_vec (const char *, VEC(tree,gc) *, VEC(tree,gc) *,\n gimple gimple_build_catch (tree, gimple_seq);\n gimple gimple_build_eh_filter (tree, gimple_seq);\n gimple gimple_build_eh_must_not_throw (tree);\n+gimple gimple_build_eh_else (gimple_seq, gimple_seq);\n gimple gimple_build_try (gimple_seq, gimple_seq, enum gimple_try_flags);\n gimple gimple_build_wce (gimple_seq);\n gimple gimple_build_resx (int);\n@@ -868,6 +917,7 @@ gimple gimple_build_omp_single (gimple_seq, tree);\n gimple gimple_build_cdt (tree, tree);\n gimple gimple_build_omp_atomic_load (tree, tree);\n gimple gimple_build_omp_atomic_store (tree);\n+gimple gimple_build_transaction (gimple_seq, tree);\n gimple gimple_build_predict (enum br_predictor, enum prediction);\n enum gimple_statement_structure_enum gss_for_assign (enum tree_code);\n void sort_case_labels (VEC(tree,heap) *);\n@@ -963,8 +1013,6 @@ extern bool is_gimple_non_addressable (tree t);\n \n /* Returns true iff T is a valid call address expression.  */\n extern bool is_gimple_call_addr (tree);\n-/* If T makes a function call, returns the CALL_EXPR operand.  */\n-extern tree get_call_expr_in (tree t);\n \n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n@@ -1076,6 +1124,9 @@ extern tree canonicalize_cond_expr_cond (tree);\n /* In omp-low.c.  */\n extern tree omp_reduction_init (tree, tree);\n \n+/* In trans-mem.c.  */\n+extern void diagnose_tm_safe_errors (tree);\n+\n /* In tree-nested.c.  */\n extern void lower_nested_functions (tree);\n extern void insert_field_into_struct (tree, tree);\n@@ -1134,6 +1185,7 @@ gimple_has_substatements (gimple g)\n     case GIMPLE_BIND:\n     case GIMPLE_CATCH:\n     case GIMPLE_EH_FILTER:\n+    case GIMPLE_EH_ELSE:\n     case GIMPLE_TRY:\n     case GIMPLE_OMP_FOR:\n     case GIMPLE_OMP_MASTER:\n@@ -1145,6 +1197,7 @@ gimple_has_substatements (gimple g)\n     case GIMPLE_OMP_SINGLE:\n     case GIMPLE_OMP_CRITICAL:\n     case GIMPLE_WITH_CLEANUP_EXPR:\n+    case GIMPLE_TRANSACTION:\n       return true;\n \n     default:\n@@ -3177,6 +3230,35 @@ gimple_eh_must_not_throw_set_fndecl (gimple gs, tree decl)\n   gs->gimple_eh_mnt.fndecl = decl;\n }\n \n+/* GIMPLE_EH_ELSE accessors.  */\n+\n+static inline gimple_seq\n+gimple_eh_else_n_body (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n+  return gs->gimple_eh_else.n_body;\n+}\n+\n+static inline gimple_seq\n+gimple_eh_else_e_body (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n+  return gs->gimple_eh_else.e_body;\n+}\n+\n+static inline void\n+gimple_eh_else_set_n_body (gimple gs, gimple_seq seq)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n+  gs->gimple_eh_else.n_body = seq;\n+}\n+\n+static inline void\n+gimple_eh_else_set_e_body (gimple gs, gimple_seq seq)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_EH_ELSE);\n+  gs->gimple_eh_else.e_body = seq;\n+}\n \n /* GIMPLE_TRY accessors. */\n \n@@ -4555,6 +4637,67 @@ gimple_omp_continue_set_control_use (gimple g, tree use)\n   g->gimple_omp_continue.control_use = use;\n }\n \n+/* Return the body for the GIMPLE_TRANSACTION statement GS.  */\n+\n+static inline gimple_seq\n+gimple_transaction_body (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  return gs->gimple_transaction.body;\n+}\n+\n+/* Return the label associated with a GIMPLE_TRANSACTION.  */\n+\n+static inline tree\n+gimple_transaction_label (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  return gs->gimple_transaction.label;\n+}\n+\n+static inline tree *\n+gimple_transaction_label_ptr (gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  return &gs->gimple_transaction.label;\n+}\n+\n+/* Return the subcode associated with a GIMPLE_TRANSACTION.  */\n+\n+static inline unsigned int\n+gimple_transaction_subcode (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  return gs->gsbase.subcode;\n+}\n+\n+/* Set BODY to be the body for the GIMPLE_TRANSACTION statement GS.  */\n+\n+static inline void\n+gimple_transaction_set_body (gimple gs, gimple_seq body)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  gs->gimple_transaction.body = body;\n+}\n+\n+/* Set the label associated with a GIMPLE_TRANSACTION.  */\n+\n+static inline void\n+gimple_transaction_set_label (gimple gs, tree label)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  gs->gimple_transaction.label = label;\n+}\n+\n+/* Set the subcode associated with a GIMPLE_TRANSACTION.  */\n+\n+static inline void\n+gimple_transaction_set_subcode (gimple gs, unsigned int subcode)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_TRANSACTION);\n+  gs->gsbase.subcode = subcode;\n+}\n+\n \n /* Return a pointer to the return value for GIMPLE_RETURN GS.  */\n \n@@ -4981,6 +5124,12 @@ struct walk_stmt_info\n      will be visited more than once.  */\n   struct pointer_set_t *pset;\n \n+  /* Operand returned by the callbacks.  This is set when calling\n+     walk_gimple_seq.  If the walk_stmt_fn or walk_tree_fn callback\n+     returns non-NULL, this field will contain the tree returned by\n+     the last callback.  */\n+  tree callback_result;\n+\n   /* Indicates whether the operand being examined may be replaced\n      with something that matches is_gimple_val (if true) or something\n      slightly more complicated (if false).  \"Something\" technically\n@@ -4993,23 +5142,20 @@ struct walk_stmt_info\n      statement 'foo (&var)', the flag VAL_ONLY will initially be set\n      to true, however, when walking &var, the operand of that\n      ADDR_EXPR does not need to be a GIMPLE value.  */\n-  bool val_only;\n+  BOOL_BITFIELD val_only : 1;\n \n   /* True if we are currently walking the LHS of an assignment.  */\n-  bool is_lhs;\n+  BOOL_BITFIELD is_lhs : 1;\n \n   /* Optional.  Set to true by the callback functions if they made any\n      changes.  */\n-  bool changed;\n+  BOOL_BITFIELD changed : 1;\n \n   /* True if we're interested in location information.  */\n-  bool want_locations;\n+  BOOL_BITFIELD want_locations : 1;\n \n-  /* Operand returned by the callbacks.  This is set when calling\n-     walk_gimple_seq.  If the walk_stmt_fn or walk_tree_fn callback\n-     returns non-NULL, this field will contain the tree returned by\n-     the last callback.  */\n-  tree callback_result;\n+  /* True if we've removed the statement that was processed.  */\n+  BOOL_BITFIELD removed_stmt : 1;\n };\n \n /* Callback for walk_gimple_stmt.  Called for every statement found"}, {"sha": "99e0d0dad901b4de59b73899520ce4b9ae1b655d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -413,6 +413,8 @@ create_tmp_var_name (const char *prefix)\n       char *preftmp = ASTRDUP (prefix);\n \n       remove_suffix (preftmp, strlen (preftmp));\n+      clean_symbol_name (preftmp);\n+\n       prefix = preftmp;\n     }\n \n@@ -1072,6 +1074,12 @@ voidify_wrapper_expr (tree wrapper, tree temp)\n \t\t}\n \t      break;\n \n+\t    case TRANSACTION_EXPR:\n+\t      TREE_SIDE_EFFECTS (*p) = 1;\n+\t      TREE_TYPE (*p) = void_type_node;\n+\t      p = &TRANSACTION_EXPR_BODY (*p);\n+\t      break;\n+\n \t    default:\n \t      goto out;\n \t    }\n@@ -6527,6 +6535,53 @@ gimplify_omp_atomic (tree *expr_p, gimple_seq *pre_p)\n    return GS_ALL_DONE;\n }\n \n+/* Gimplify a TRANSACTION_EXPR.  This involves gimplification of the\n+   body, and adding some EH bits.  */\n+\n+static enum gimplify_status\n+gimplify_transaction (tree *expr_p, gimple_seq *pre_p)\n+{\n+  tree expr = *expr_p, temp, tbody = TRANSACTION_EXPR_BODY (expr);\n+  gimple g;\n+  gimple_seq body = NULL;\n+  struct gimplify_ctx gctx;\n+  int subcode = 0;\n+\n+  /* Wrap the transaction body in a BIND_EXPR so we have a context\n+     where to put decls for OpenMP.  */\n+  if (TREE_CODE (tbody) != BIND_EXPR)\n+    {\n+      tree bind = build3 (BIND_EXPR, void_type_node, NULL, tbody, NULL);\n+      TREE_SIDE_EFFECTS (bind) = 1;\n+      SET_EXPR_LOCATION (bind, EXPR_LOCATION (tbody));\n+      TRANSACTION_EXPR_BODY (expr) = bind;\n+    }\n+\n+  push_gimplify_context (&gctx);\n+  temp = voidify_wrapper_expr (*expr_p, NULL);\n+\n+  g = gimplify_and_return_first (TRANSACTION_EXPR_BODY (expr), &body);\n+  pop_gimplify_context (g);\n+\n+  g = gimple_build_transaction (body, NULL);\n+  if (TRANSACTION_EXPR_OUTER (expr))\n+    subcode = GTMA_IS_OUTER;\n+  else if (TRANSACTION_EXPR_RELAXED (expr))\n+    subcode = GTMA_IS_RELAXED;\n+  gimple_transaction_set_subcode (g, subcode);\n+\n+  gimplify_seq_add_stmt (pre_p, g);\n+\n+  if (temp)\n+    {\n+      *expr_p = temp;\n+      return GS_OK;\n+    }\n+\n+  *expr_p = NULL_TREE;\n+  return GS_ALL_DONE;\n+}\n+\n /* Convert the GENERIC expression tree *EXPR_P to GIMPLE.  If the\n    expression produces a value to be used as an operand inside a GIMPLE\n    statement, the value will be stored back in *EXPR_P.  This value will\n@@ -7251,6 +7306,10 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = gimplify_omp_atomic (expr_p, pre_p);\n \t  break;\n \n+\tcase TRANSACTION_EXPR:\n+\t  ret = gimplify_transaction (expr_p, pre_p);\n+\t  break;\n+\n \tcase TRUTH_AND_EXPR:\n \tcase TRUTH_OR_EXPR:\n \tcase TRUTH_XOR_EXPR:"}, {"sha": "0e5727f2d9852fc9c0d4e21de139c4b24eca2292", "filename": "gcc/gsstruct.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgsstruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgsstruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgsstruct.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -38,6 +38,7 @@ DEFGSSTRUCT(GSS_CATCH, gimple_statement_catch, false)\n DEFGSSTRUCT(GSS_EH_FILTER, gimple_statement_eh_filter, false)\n DEFGSSTRUCT(GSS_EH_MNT, gimple_statement_eh_mnt, false)\n DEFGSSTRUCT(GSS_EH_CTRL, gimple_statement_eh_ctrl, false)\n+DEFGSSTRUCT(GSS_EH_ELSE, gimple_statement_eh_else, false)\n DEFGSSTRUCT(GSS_WCE, gimple_statement_wce, false)\n DEFGSSTRUCT(GSS_OMP, gimple_statement_omp, false)\n DEFGSSTRUCT(GSS_OMP_CRITICAL, gimple_statement_omp_critical, false)\n@@ -49,3 +50,4 @@ DEFGSSTRUCT(GSS_OMP_SINGLE, gimple_statement_omp_single, false)\n DEFGSSTRUCT(GSS_OMP_CONTINUE, gimple_statement_omp_continue, false)\n DEFGSSTRUCT(GSS_OMP_ATOMIC_LOAD, gimple_statement_omp_atomic_load, false)\n DEFGSSTRUCT(GSS_OMP_ATOMIC_STORE, gimple_statement_omp_atomic_store, false)\n+DEFGSSTRUCT(GSS_TRANSACTION, gimple_statement_transaction, false)"}, {"sha": "9fcbdb0cc36c56a2bcef0f18feb6261b9fd8a6bc", "filename": "gcc/gtm-builtins.def", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgtm-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fgtm-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgtm-builtins.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,208 @@\n+DEF_TM_BUILTIN (BUILT_IN_TM_START, \"_ITM_beginTransaction\",\n+\t\tBT_FN_UINT_UINT, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_COMMIT, \"_ITM_commitTransaction\",\n+\t\tBT_FN_VOID, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_COMMIT_EH, \"_ITM_commitTransactionEH\",\n+\t\tBT_FN_VOID_PTR, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_ABORT, \"_ITM_abortTransaction\",\n+\t\tBT_FN_INT, ATTR_TM_NORETURN_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_IRREVOCABLE, \"_ITM_changeTransactionMode\",\n+\t\tBT_FN_INT_INT, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_MEMCPY, \"_ITM_memcpyRtWt\",\n+\t\tBT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_MEMMOVE, \"_ITM_memmoveRtWt\",\n+\t\tBT_FN_PTR_PTR_CONST_PTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_MEMSET, \"_ITM_memsetW\",\n+\t       \tBT_FN_PTR_PTR_INT_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_GETTMCLONE_IRR, \"_ITM_getTMCloneOrIrrevocable\",\n+\t\tBT_FN_PTR_PTR, ATTR_TM_CONST_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_GETTMCLONE_SAFE, \"_ITM_getTMCloneSafe\",\n+\t\tBT_FN_PTR_PTR, ATTR_TM_CONST_NOTHROW_LIST)\n+\n+/* Memory allocation builtins.  */\n+DEF_TM_BUILTIN (BUILT_IN_TM_MALLOC, \"_ITM_malloc\",\n+\t\tBT_FN_PTR_SIZE, ATTR_TMPURE_MALLOC_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_CALLOC, \"_ITM_calloc\",\n+\t\tBT_FN_PTR_SIZE_SIZE, ATTR_TMPURE_MALLOC_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_FREE, \"_ITM_free\",\n+\t\tBT_FN_VOID_PTR, ATTR_TMPURE_NOTHROW_LIST)\n+\n+/* Logging builtins.  */\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_1, \"_ITM_LU1\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_2, \"_ITM_LU2\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_4, \"_ITM_LU4\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_8, \"_ITM_LU8\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_FLOAT, \"_ITM_LF\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_DOUBLE, \"_ITM_LD\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG_LDOUBLE, \"_ITM_LE\",\n+\t\tBT_FN_VOID_VPTR, ATTR_TM_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOG, \"_ITM_LB\",\n+\t\tBT_FN_VOID_VPTR_SIZE, ATTR_TM_TMPURE_NOTHROW_LIST)\n+\n+/* These stubs should get defined in the backend if applicable.  */\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOG_M64, \"__builtin__ITM_LM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOG_M128, \"__builtin__ITM_LM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOG_M256, \"__builtin__ITM_LM256\")\n+\n+/* Writes.\n+\n+   Note: The writes must follow the following order: STORE, WAR, WAW.\n+   The TM optimizations depend on this order.\n+\n+   BUILT_IN_TM_STORE_1 must be the first builtin.\n+   BUILTIN_TM_LOAD_STORE_P depends on this.  */\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_1, \"_ITM_WU1\",\n+\t\tBT_FN_VOID_VPTR_I1, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_1, \"_ITM_WaRU1\",\n+\t\tBT_FN_VOID_VPTR_I1, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_1, \"_ITM_WaWU1\",\n+\t\tBT_FN_VOID_VPTR_I1, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_2, \"_ITM_WU2\",\n+\t\tBT_FN_VOID_VPTR_I2, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_2, \"_ITM_WaRU2\",\n+\t\tBT_FN_VOID_VPTR_I2, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_2, \"_ITM_WaWU2\",\n+\t\tBT_FN_VOID_VPTR_I2, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_4, \"_ITM_WU4\",\n+\t\tBT_FN_VOID_VPTR_I4, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_4, \"_ITM_WaRU4\",\n+\t\tBT_FN_VOID_VPTR_I4, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_4, \"_ITM_WaWU4\",\n+\t\tBT_FN_VOID_VPTR_I4, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_8, \"_ITM_WU8\",\n+\t\tBT_FN_VOID_VPTR_I8, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_8, \"_ITM_WaRU8\",\n+\t\tBT_FN_VOID_VPTR_I8, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_8, \"_ITM_WaWU8\",\n+\t\tBT_FN_VOID_VPTR_I8, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_FLOAT, \"_ITM_WF\",\n+\t\tBT_FN_VOID_VPTR_FLOAT, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_FLOAT, \"_ITM_WaRF\",\n+\t\tBT_FN_VOID_VPTR_FLOAT, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_FLOAT, \"_ITM_WaWF\",\n+\t\tBT_FN_VOID_VPTR_FLOAT, ATTR_TM_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_DOUBLE, \"_ITM_WD\",\n+\t\tBT_FN_VOID_VPTR_DOUBLE, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_DOUBLE, \"_ITM_WaRD\",\n+\t\tBT_FN_VOID_VPTR_DOUBLE, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_DOUBLE, \"_ITM_WaWD\",\n+\t\tBT_FN_VOID_VPTR_DOUBLE, ATTR_TM_NOTHROW_LIST)\n+\n+/* These stubs should get defined in the backend if applicable.  */\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_M64, \"__builtin__ITM_WM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_WAR_M64, \"__builtin__ITM_WaRM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_WAW_M64, \"__builtin__ITM_WaWM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_M128, \"__builtin__ITM_WM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_WAR_M128, \"__builtin__ITM_WaRM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_WAW_M128, \"__builtin__ITM_WaWM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_M256, \"__builtin__ITM_WM256\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_WAR_M256, \"__builtin__ITM_WaRM256\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_STORE_WAW_M256, \"__builtin__ITM_WaWM256\")\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_LDOUBLE, \"_ITM_WE\",\n+\t\tBT_FN_VOID_VPTR_LDOUBLE, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAR_LDOUBLE, \"_ITM_WaRE\",\n+\t\tBT_FN_VOID_VPTR_LDOUBLE, ATTR_TM_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_STORE_WAW_LDOUBLE, \"_ITM_WaWE\",\n+\t\tBT_FN_VOID_VPTR_LDOUBLE, ATTR_TM_NOTHROW_LIST)\n+/* Note: BUILT_IN_TM_STORE_WAW_LDOUBLE must be the last TM store.\n+   BUILTIN_TM_STORE_P depends on this.  */\n+\n+/* Reads.\n+\n+   Note: The reads must follow the following order: LOAD, RAR, RAW, RFW.\n+   The TM optimizations depend on this order.  */\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_1, \"_ITM_RU1\",\n+\t\tBT_FN_I1_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_1, \"_ITM_RaRU1\",\n+\t\tBT_FN_I1_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_1, \"_ITM_RaWU1\",\n+\t\tBT_FN_I1_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_1, \"_ITM_RfWU1\",\n+\t\tBT_FN_I1_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_2, \"_ITM_RU2\",\n+\t\tBT_FN_I2_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_2, \"_ITM_RaRU2\",\n+\t\tBT_FN_I2_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_2, \"_ITM_RaWU2\",\n+\t\tBT_FN_I2_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_2, \"_ITM_RfWU2\",\n+\t\tBT_FN_I2_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_4, \"_ITM_RU4\",\n+\t\tBT_FN_I4_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_4, \"_ITM_RaRU4\",\n+\t\tBT_FN_I4_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_4, \"_ITM_RaWU4\",\n+\t\tBT_FN_I4_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_4, \"_ITM_RfWU4\",\n+\t\tBT_FN_I4_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_8, \"_ITM_RU8\",\n+\t\tBT_FN_I8_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_8, \"_ITM_RaRU8\",\n+\t\tBT_FN_I8_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_8, \"_ITM_RaWU8\",\n+\t\tBT_FN_I8_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_8, \"_ITM_RfWU8\",\n+\t\tBT_FN_I8_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_FLOAT, \"_ITM_RF\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_FLOAT, \"_ITM_RaRF\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_FLOAT, \"_ITM_RaWF\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_FLOAT, \"_ITM_RfWF\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_DOUBLE, \"_ITM_RD\",\n+\t\tBT_FN_DOUBLE_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_DOUBLE, \"_ITM_RaRD\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_DOUBLE, \"_ITM_RaWD\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_DOUBLE, \"_ITM_RfWD\",\n+\t\tBT_FN_FLOAT_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+/* These stubs should get defined in the backend if applicable.  */\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_M64, \"__builtin__ITM_RM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RAR_M64, \"__builtin__ITM_RaRM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RAW_M64, \"__builtin__ITM_RaRM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RFW_M64, \"__builtin__ITM_RfWM64\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_M128, \"__builtin__ITM_RM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RAR_M128, \"__builtin__ITM_RaRM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RAW_M128, \"__builtin__ITM_RaRM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RFW_M128, \"__builtin__ITM_RfWM128\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_M256, \"__builtin__ITM_RM256\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RAR_M256, \"__builtin__ITM_RaRM256\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RAW_M256, \"__builtin__ITM_RaRM256\")\n+DEF_BUILTIN_STUB (BUILT_IN_TM_LOAD_RFW_M256, \"__builtin__ITM_RfWM256\")\n+\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_LDOUBLE, \"_ITM_RE\",\n+\t\tBT_FN_LDOUBLE_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAR_LDOUBLE, \"_ITM_RaRE\",\n+\t\tBT_FN_LDOUBLE_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RAW_LDOUBLE, \"_ITM_RaWE\",\n+\t\tBT_FN_LDOUBLE_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+DEF_TM_BUILTIN (BUILT_IN_TM_LOAD_RFW_LDOUBLE, \"_ITM_RfWE\",\n+\t\tBT_FN_LDOUBLE_VPTR, ATTR_TM_PURE_TMPURE_NOTHROW_LIST)\n+\n+/* Note: BUILT_IN_TM_LOAD_RFW_LDOUBLE must be the last TM load as well\n+   as the last builtin.  BUILTIN_TM_LOAD_STORE_P and BUILTIN_TM_LOAD_P\n+   depend on this.  */"}, {"sha": "3dadf8d12d75866fdbfac21c02af71d97e975d78", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -284,6 +284,14 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n       e->inline_failed = CIF_EH_PERSONALITY;\n       inlinable = false;\n     }\n+  /* TM pure functions should not get inlined if the outer function is\n+     a TM safe function.  */\n+  else if (is_tm_pure (callee->decl)\n+\t   && is_tm_safe (e->caller->decl))\n+    {\n+      e->inline_failed = CIF_UNSPECIFIED;\n+      inlinable = false;\n+    }\n   /* Don't inline if the callee can throw non-call exceptions but the\n      caller cannot.\n      FIXME: this is obviously wrong for LTO where STRUCT_FUNCTION is missing."}, {"sha": "dc61c0bdf54fb6d3b8085cf91af9bff72be8a4fa", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -139,6 +139,7 @@ static tree scan_omp_1_op (tree *, int *, void *);\n     case GIMPLE_TRY: \\\n     case GIMPLE_CATCH: \\\n     case GIMPLE_EH_FILTER: \\\n+    case GIMPLE_TRANSACTION: \\\n       /* The sub-statements for these should be walked.  */ \\\n       *handled_ops_p = false; \\\n       break;"}, {"sha": "9fdb22631d0ff7652f526e2783c44a7631b151ba", "filename": "gcc/opts.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -784,6 +784,8 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n #endif\n       if (!opts->x_flag_fat_lto_objects && !HAVE_LTO_PLUGIN)\n         error_at (loc, \"-fno-fat-lto-objects are supported only with linker plugin.\");\n+      if (opts->x_flag_tm)\n+\terror_at (loc, \"LTO is currently not supported with transactional memory\");\n }\n   if ((opts->x_flag_lto_partition_balanced != 0) + (opts->x_flag_lto_partition_1to1 != 0)\n        + (opts->x_flag_lto_partition_none != 0) >= 1)"}, {"sha": "e47eddf2735a8fc027a08dea7bf295d01c5e8dd9", "filename": "gcc/output.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -606,6 +606,10 @@ extern bool unlikely_text_section_p (section *);\n extern void switch_to_section (section *);\n extern void output_section_asm_op (const void *);\n \n+extern void record_tm_clone_pair (tree, tree);\n+extern void finish_tm_clone_pairs (void);\n+extern tree get_tm_clone_pair (tree);\n+\n extern void default_asm_output_source_filename (FILE *, const char *);\n extern void output_file_directive (FILE *, const char *);\n "}, {"sha": "239b684b5fcc425b32ad59f392b8927632414a47", "filename": "gcc/params.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -872,6 +872,13 @@ DEFPARAM (PARAM_IPA_SRA_PTR_GROWTH_FACTOR,\n \t  \"a pointer to an aggregate with\",\n \t  2, 0, 0)\n \n+DEFPARAM (PARAM_TM_MAX_AGGREGATE_SIZE,\n+\t  \"tm-max-aggregate-size\",\n+\t  \"Size in bytes after which thread-local aggregates should be \"\n+\t  \"instrumented with the logging functions instead of save/restore \"\n+\t  \"pairs\",\n+\t  9, 0, 0)\n+\n DEFPARAM (PARAM_IPA_CP_VALUE_LIST_SIZE,\n \t  \"ipa-cp-value-list-size\",\n \t  \"Maximum size of a list of values associated with each parameter for \""}, {"sha": "a3512419ee2a85ed69f6b89995c122b2b7cd4edb", "filename": "gcc/passes.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1174,9 +1174,11 @@ init_optimization_passes (void)\n   p = &all_lowering_passes;\n   NEXT_PASS (pass_warn_unused_result);\n   NEXT_PASS (pass_diagnose_omp_blocks);\n+  NEXT_PASS (pass_diagnose_tm_blocks);\n   NEXT_PASS (pass_mudflap_1);\n   NEXT_PASS (pass_lower_omp);\n   NEXT_PASS (pass_lower_cf);\n+  NEXT_PASS (pass_lower_tm);\n   NEXT_PASS (pass_refactor_eh);\n   NEXT_PASS (pass_lower_eh);\n   NEXT_PASS (pass_build_cfg);\n@@ -1241,6 +1243,7 @@ init_optimization_passes (void)\n     }\n   NEXT_PASS (pass_ipa_increase_alignment);\n   NEXT_PASS (pass_ipa_matrix_reorg);\n+  NEXT_PASS (pass_ipa_tm);\n   NEXT_PASS (pass_ipa_lower_emutls);\n   *p = NULL;\n \n@@ -1400,6 +1403,13 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_uncprop);\n       NEXT_PASS (pass_local_pure_const);\n     }\n+  NEXT_PASS (pass_tm_init);\n+    {\n+      struct opt_pass **p = &pass_tm_init.pass.sub;\n+      NEXT_PASS (pass_tm_mark);\n+      NEXT_PASS (pass_tm_memopt);\n+      NEXT_PASS (pass_tm_edges);\n+    }\n   NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_cleanup_eh);\n   NEXT_PASS (pass_lower_resx);"}, {"sha": "7fb71d0b47543ce7fc4b2257aebb8b3d8bdced7a", "filename": "gcc/print-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -424,6 +424,8 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \tfputs (\" built-in\", file);\n       if (code == FUNCTION_DECL && DECL_STATIC_CHAIN (node))\n \tfputs (\" static-chain\", file);\n+      if (TREE_CODE (node) == FUNCTION_DECL && decl_is_tm_clone (node))\n+\tfputs (\" tm-clone\", file);\n \n       if (code == FIELD_DECL && DECL_PACKED (node))\n \tfputs (\" packed\", file);"}, {"sha": "ae05204eee5550f1aa16f10b943fd286c1b4198f", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -3287,6 +3287,7 @@ peep2_attempt (basic_block bb, rtx insn, int match_len, rtx attempt)\n \t  {\n \t  case REG_NORETURN:\n \t  case REG_SETJMP:\n+\t  case REG_TM:\n \t    add_reg_note (new_insn, REG_NOTE_KIND (note),\n \t\t\t  XEXP (note, 0));\n \t    break;"}, {"sha": "f2f097385a6ea01f3f0adffb87f81bdc1811a079", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -203,6 +203,11 @@ REG_NOTE (CROSSING_JUMP)\n    functions that can return twice.  */\n REG_NOTE (SETJMP)\n \n+/* This kind of note is generated at each transactional memory\n+   builtin, to indicate we need to generate transaction restart\n+   edges for this insn.  */\n+REG_NOTE (TM)\n+\n /* Indicates the cumulative offset of the stack pointer accounting\n    for pushed arguments.  This will only be generated when\n    ACCUMULATE_OUTGOING_ARGS is false.  */"}, {"sha": "7c4a49bef09e3148717b600ed6585914a8194934", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1918,6 +1918,7 @@ alloc_reg_note (enum reg_note kind, rtx datum, rtx list)\n     case REG_CC_USER:\n     case REG_LABEL_TARGET:\n     case REG_LABEL_OPERAND:\n+    case REG_TM:\n       /* These types of register notes use an INSN_LIST rather than an\n \t EXPR_LIST, so that copying is done right and dumps look\n \t better.  */"}, {"sha": "62bd06e976fbdf8a732149ff7fac4eaf44debc00", "filename": "gcc/target.def", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1003,6 +1003,24 @@ DEFHOOK\n  (enum machine_mode mode, const_tree type, int misalignment, bool is_packed),\n  default_builtin_support_vector_misalignment)\n \n+/* Return the builtin decl needed to load a vector of TYPE.  */\n+DEFHOOK\n+(builtin_tm_load,\n+ \"This hook should return the built-in decl needed to load a vector of the \"\n+ \"given type within a transaction.\",\n+ tree,\n+ (tree),\n+ default_builtin_tm_load_store)\n+\n+/* Return the builtin decl needed to store a vector of TYPE.  */\n+DEFHOOK\n+(builtin_tm_store,\n+ \"This hook should return the built-in decl needed to store a vector of the \"\n+ \"given type within a transaction.\",\n+ tree,\n+ (tree),\n+ default_builtin_tm_load_store)\n+\n /* Returns the preferred mode for SIMD operations for the specified\n    scalar mode.  */\n DEFHOOK"}, {"sha": "2b4fd27bdfa36bfd05ccb9816bbdcbd3fa96449d", "filename": "gcc/targhooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1214,6 +1214,12 @@ default_have_conditional_execution (void)\n #endif\n }\n \n+tree\n+default_builtin_tm_load_store (tree ARG_UNUSED (type))\n+{\n+  return NULL_TREE;\n+}\n+\n /* Compute cost of moving registers to/from memory.  */\n \n int"}, {"sha": "861811543f8f03792342807757eed73e2a7c6824", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -152,6 +152,9 @@ extern bool default_addr_space_subset_p (addr_space_t, addr_space_t);\n extern rtx default_addr_space_convert (rtx, tree, tree);\n extern unsigned int default_case_values_threshold (void);\n extern bool default_have_conditional_execution (void);\n+\n+extern tree default_builtin_tm_load_store (tree);\n+\n extern int default_memory_move_cost (enum machine_mode, reg_class_t, bool);\n extern int default_register_move_cost (enum machine_mode, reg_class_t,\n \t\t\t\t       reg_class_t);"}, {"sha": "c095293b347b78f323d874fd52b87e53572d5e78", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,14 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\t    Aldy Hernandez  <aldyh@redhat.com>\n+\t    Torvald Riegel  <triegel@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* g++.dg/dg.exp: Run transactional memory tests.\n+\t* g++.dg/tm: New directory with new tests.\n+\t* gcc.dg/tm: New directory with new tests.\n+\t* c-c++-common/tm: New directory with new tests.\n+\n 2011-11-08  Dodji Seketeli  <dodji@redhat.com>\n \n \tFix context handling of alias-declaration"}, {"sha": "c25336d682a214b8a21116d27574a56072b78bce", "filename": "gcc/testsuite/c-c++-common/tm/20100127.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2F20100127.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2F20100127.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2F20100127.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+/* Test that `nontrxn' doesn't end up inside the transaction.  */\n+\n+typedef struct node {\n+  int * val;\n+  struct node *next;\n+} node_t;\n+\n+node_t *next;\n+int nontrxn1, nontrxn;\n+\n+static int set_remove(int * val)\n+{\n+  int result;\n+  int * v;\n+  __transaction_relaxed {\n+    v = next->val;\n+    result = (v == val);\n+    if (result)\n+      result = 2;\n+  }\n+  return result;\n+}\n+\n+void test(void *data)\n+{\n+  extern void bark(void);\n+  if (set_remove(0))\n+    bark();\n+  nontrxn = 99;\t\t\t/* Should be outside transaction.  */\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_ITM_W.*nontrxn\" 0 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "90830f41cf353c712e73810945c8aac499c2a201", "filename": "gcc/testsuite/c-c++-common/tm/abort-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+\n+void f(void)\n+{\n+  __transaction_cancel;\t\t/* { dg-error \"without transactional\" } */\n+}"}, {"sha": "727c63432ace091b808eecf229c4762742c8a17d", "filename": "gcc/testsuite/c-c++-common/tm/abort-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+int g;\n+void f(void)\n+{\n+  __transaction_atomic {\n+    if (g == 0)\n+      __transaction_cancel;\n+  }\n+}"}, {"sha": "f2cf5b5dc2a51acf9a1d25758948a3eb5ecf670c", "filename": "gcc/testsuite/c-c++-common/tm/abort-3.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fabort-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+\n+void f(void)\n+{\n+  __transaction_atomic {   /* { dg-error \"__transaction_atomic. without trans\" } */\n+    __transaction_cancel;  /* { dg-error \"_cancel. without trans\" } */\n+  }\n+}"}, {"sha": "e301f1f48cf1a014305c96246f26a7b12dfbaa1e", "filename": "gcc/testsuite/c-c++-common/tm/atomic-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fatomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fatomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fatomic-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+\n+int g;\n+void f(void)\n+{\n+  __transaction_atomic {\t/* { dg-error \"without transactional memory\" } */\n+    g++;\n+  }\n+}"}, {"sha": "f232766240ad54c70445347bfd701c232f89b461", "filename": "gcc/testsuite/c-c++-common/tm/atomic-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fatomic-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fatomic-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fatomic-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+int g;\n+void f(void)\n+{\n+  __transaction_atomic {\n+    g++;\n+  }\n+}"}, {"sha": "536aeb33fdd8d02388eee1c79a7bf6d36b652f9e", "filename": "gcc/testsuite/c-c++-common/tm/attrib-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fattrib-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fattrib-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fattrib-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+#define TC\t__attribute__((transaction_callable))\n+#define TU\t__attribute__((transaction_unsafe))\n+#define TP\t__attribute__((transaction_pure))\n+#define TS\t__attribute__((transaction_safe))\n+extern void f1(void) TC;\n+extern void f2(void) TU;\n+extern void f3(void) TP;\n+extern void f4(void) TS;\n+\n+extern void g1(void) TC TS;\t/* { dg-error \"previously declared\" } */\n+\n+extern int v1 TP;\t\t/* { dg-warning \"ignored\" } */\n+\n+typedef void t1(void) TC;\n+typedef void (*t2)(void) TC;\n+typedef int t3 TC;\t\t/* { dg-warning \"ignored\" } */\n+\n+typedef void u0(void);\n+typedef u0 u1 TC;\n+typedef u1 u2 TP;\t\t/* { dg-error \"previously declared\" } */\n+typedef u0 *u3 TS;\n+typedef u3 u4 TU;\t\t/* { dg-error \"previously declared\" } */"}, {"sha": "6d60f2648c4467065d2f84c7903151947b2126c7", "filename": "gcc/testsuite/c-c++-common/tm/cancel-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fcancel-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fcancel-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fcancel-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void unsafe(void) __attribute__((transaction_unsafe));\n+\n+void\n+f(void)\n+{\n+  int a;\n+  __transaction_atomic {\n+    a = 1;\n+    __transaction_atomic {\n+      __transaction_cancel;\n+    }\n+  }\n+  unsafe();\n+}"}, {"sha": "31df167fae9241bc567ad88229d599f7e75bcdbf", "filename": "gcc/testsuite/c-c++-common/tm/freq.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ffreq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ffreq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ffreq.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+extern __attribute__((transaction_safe)) void TMreleaseNode ();\n+\n+int global;\n+\n+__attribute__((transaction_safe))\n+void\n+TMrbtree_insert ()\n+{\n+  if (global)\n+    TMreleaseNode();\n+}"}, {"sha": "7d429fbbc850b5130d7951f69d857893c9bc9e23", "filename": "gcc/testsuite/c-c++-common/tm/inline-asm-2.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+__attribute__((transaction_callable))\n+void func()\n+{\n+  __asm__ (\"\");\n+}"}, {"sha": "eefd347dc8ff71a1568270c0276337555ed4dd44", "filename": "gcc/testsuite/c-c++-common/tm/inline-asm.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Finline-asm.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O1\" } */\n+\n+static inline void\n+inline_death ()\n+{\n+  __asm__ (\"\");\t\t\t/* { dg-error \"asm not allowed\" } */\n+}\n+\n+void\n+tranfunction ()\n+{\n+  __transaction_atomic\n+    {\n+      inline_death ();\n+    }\n+}"}, {"sha": "961f7fe79c0b5c0f6678419a80e0a85fab825d91", "filename": "gcc/testsuite/c-c++-common/tm/ipa-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fipa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fipa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fipa-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-ipa-tmipa\" } */\n+\n+int val, george;\n+\n+extern void func();\n+\n+int set_remove(void)\n+{\n+  int result = 8;\n+  __transaction_atomic  {\n+    result = george;\n+    if (val)\n+      goto out;\n+  }\n+ out:\n+  func();\n+  return result;\n+}\n+\n+\n+/* { dg-final { scan-ipa-dump-not \"getTMCloneOrIrrevocable\" \"tmipa\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tmipa\" } } */"}, {"sha": "de7a766e36cb64742629ea933048270c5d1e3196", "filename": "gcc/testsuite/c-c++-common/tm/malloc.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fmalloc.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmmark\" } */\n+\n+#include <stdlib.h>\n+\n+char *z;\n+\n+void foobar(void)\n+{\n+    char *p, *q;\n+    __transaction_atomic {\n+\tp = (char *)malloc(123);\n+\tq = (char *)calloc(555,1);\n+\tfree(q);\n+\tfree(p);\n+    }\n+    z = (char *)malloc (666);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" malloc .666\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin__ITM_malloc\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin__ITM_calloc\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin__ITM_free\" 2 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "fa841b261647c8389242111aca2d6aa83f3cbd27", "filename": "gcc/testsuite/c-c++-common/tm/memcpy-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fmemcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fmemcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fmemcpy-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+#include <string.h>\n+\n+__attribute__((transaction_safe))\n+void *wmemcpy(void *dest, const void *src, size_t n)\n+{\n+    return memcpy(dest, src, n);\n+}"}, {"sha": "b9fcc765efc9ea7032c5929edca35f192f17efca", "filename": "gcc/testsuite/c-c++-common/tm/omp.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fomp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fomp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fomp.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fopenmp\" } */\n+\n+__attribute__ ((transaction_pure))\n+unsigned long rdtsc();\n+\n+typedef struct ENTER_EXIT_TIMES\n+{\n+  unsigned long enter;\n+} times_t;\n+\n+void ParClassify()\n+{\n+  void * Parent;\n+#pragma omp parallel private(Parent)\n+  {\n+    times_t inside;\n+    __transaction_atomic {\n+       inside.enter = rdtsc();\n+    }\n+  }\n+}"}, {"sha": "7dbf2e8310ade9a082919f99e243bd3c906af15d", "filename": "gcc/testsuite/c-c++-common/tm/outer-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fouter-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fouter-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fouter-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void mco(void) __attribute__((transaction_may_cancel_outer));\n+\n+void\n+f(void)\n+{\n+  mco();\t\t\t/* { dg-error \"\" } */\n+  __transaction_atomic {\n+    mco();\t\t\t/* { dg-error \"\" } */\n+  }\n+  __transaction_relaxed {\n+    mco();\t\t\t/* { dg-error \"\" } */\n+  }\n+  __transaction_atomic [[outer]] {\n+    mco();\n+  }\n+}\n+\n+void __attribute__((transaction_may_cancel_outer))\n+g(void)\n+{\n+  mco();\n+  __transaction_atomic {\n+    mco();\n+  }\n+  __transaction_atomic [[outer]] {\t/* { dg-error \"\" } */\n+    mco();\n+  }\n+}"}, {"sha": "b2a43530575859513afa90ef4555a2a1d5c398af", "filename": "gcc/testsuite/c-c++-common/tm/safe-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void ts(void) __attribute__((transaction_safe));\n+void tp(void) __attribute__((transaction_pure));\n+void tc(void) __attribute__((transaction_callable));\n+void ti(void) __attribute__((transaction_unsafe));\n+void tm(void) __attribute__((transaction_may_cancel_outer));\n+void tu(void);\n+int fc(int) __attribute__((const));\n+\n+typedef void (*Fs) (void) __attribute__((transaction_safe));\n+typedef void (*Fc) (void) __attribute__((transaction_callable));\n+typedef void (*Fi) (void) __attribute__((transaction_unsafe));\n+typedef void (*Fm) (void) __attribute__((transaction_may_cancel_outer));\n+extern Fs ps;\n+extern Fc pc;\n+extern Fi pi;\n+extern Fm pm;\n+extern void (*pu)(void);\n+\n+int __attribute__((transaction_safe))\n+foo(void)\n+{\n+  int i;\n+\n+  ts();\n+  tp();\n+  tc();\t\t\t/* { dg-error \"unsafe function call\" } */\n+  ti();\t\t\t/* { dg-error \"unsafe function call\" } */\n+\n+  /* ??? Direct function calls without markups are handled later\n+     than pass_diagnose_tm_blocks, which means we'll exit with\n+     errors before getting there.  This test moved to safe-3.c.  */\n+  /* tu(); */\n+\n+  (*ps)();\n+  (*pc)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pi)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pu)();\t\t/* { dg-error \"unsafe function call\" } */\n+\n+  asm(\"\");\t\t/* { dg-error \"asm not allowed\" } */\n+  asm(\"\" : \"=g\"(i));\t/* { dg-error \"asm not allowed\" } */\n+\n+  return fc(i);\n+}\n+\n+int __attribute__((transaction_may_cancel_outer))\n+bar(void)\n+{\n+  int i;\n+\n+  ts();\n+  tp();\n+  tc();\t\t\t/* { dg-error \"unsafe function call\" } */\n+  ti();\t\t\t/* { dg-error \"unsafe function call\" } */\n+  tm();\n+\n+  (*ps)();\n+  (*pc)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pi)();\t\t/* { dg-error \"unsafe function call\" } */\n+  (*pm)();\n+  (*pu)();\t\t/* { dg-error \"unsafe function call\" } */\n+\n+  asm(\"\");\t\t/* { dg-error \"asm not allowed\" } */\n+  asm(\"\" : \"=g\"(i));\t/* { dg-error \"asm not allowed\" } */\n+\n+  return fc(i);\n+}"}, {"sha": "a6729ba428bf20b67258086bd13c062aebf50599", "filename": "gcc/testsuite/c-c++-common/tm/safe-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void mco(void) __attribute__((transaction_may_cancel_outer));\n+\n+void\n+f(void)\n+{\n+  mco();\t\t\t/* { dg-error \"\" } */\n+  __transaction_atomic {\n+    mco();\t\t\t/* { dg-error \"\" } */\n+  }\n+  __transaction_relaxed {\n+    mco();\t\t\t/* { dg-error \"\" } */\n+  }\n+  __transaction_atomic [[outer]] {\n+    mco();\n+  }\n+  __transaction_atomic [[outer]] {\n+    __transaction_atomic {\n+      __transaction_atomic {\n+\t__transaction_atomic {\n+\t  mco();\n+\t}\n+      }\n+    }\n+  }\n+}\n+\n+void __attribute__((transaction_may_cancel_outer))\n+g(void)\n+{\n+  mco();\n+  __transaction_atomic {\n+    __transaction_atomic {\n+      __transaction_atomic {\n+\t__transaction_atomic {\n+\t  mco();\n+\t}\n+      }\n+    }\n+  }\n+}"}, {"sha": "8a883db5ef0519480c6fdc3875851ec4129cffcb", "filename": "gcc/testsuite/c-c++-common/tm/safe-3.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fsafe-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void f_extern (void);\n+void f_first (void);\n+void f_later (void);\n+\n+extern int x;\n+\n+void f_first (void) { x++; }\n+\n+void __attribute__((transaction_safe))\n+test_safe (void)\n+{\n+  f_extern ();\t\t/* { dg-error \"unsafe function call\" } */\n+  f_first ();\n+  f_later ();\n+}\n+\n+void __attribute__((transaction_may_cancel_outer))\n+test_mco (void)\n+{\n+  f_extern ();\t\t/* { dg-error \"unsafe function call\" } */\n+  f_first ();\n+  f_later ();\n+}\n+\n+void\n+test_atomic (void)\n+{\n+  __transaction_atomic {\n+    f_extern ();\t/* { dg-error \"unsafe function call\" } */\n+    f_first ();\n+    f_later ();\n+  }\n+  __transaction_relaxed {\n+    f_extern ();\n+    f_first ();\n+    f_later ();\n+  }\n+  __transaction_atomic [[outer]] {\n+    f_extern ();\t/* { dg-error \"unsafe function call\" } */\n+    f_first ();\n+    f_later ();\n+  }\n+}\n+\n+void f_later () { f_first(); test_safe(); }"}, {"sha": "0ef6526db7be8e14e8f6e0876a762c2e1700fa6c", "filename": "gcc/testsuite/c-c++-common/tm/trxn-expr-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* Make sure that we don't just crash without -fgnu-tm enabled.  */\n+/* { dg-options \"\" } */\n+\n+int x;\n+\n+int foo(void)\n+{\n+  return __transaction_atomic (x + 1);\t\t/* { dg-error \"\" } */\n+}\n+\n+int bar(void)\n+{\n+  return __transaction_relaxed (x + 1);\t\t/* { dg-error \"\" } */\n+}"}, {"sha": "53d4677e3e6879ba983b32984bb140a221c0ed1b", "filename": "gcc/testsuite/c-c++-common/tm/trxn-expr.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Ftrxn-expr.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmmark\" } */\n+\n+int y, x, york;\n+\n+void foobar(void)\n+{\n+  x = y + __transaction_atomic (york);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_ITM_RU.*york\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"_ITM_RU\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "04b5b6f0dcbc696675e907db9e83019cd31e98dc", "filename": "gcc/testsuite/c-c++-common/tm/wrap-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fwrap-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fwrap-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftm%2Fwrap-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-optimized\" } */\n+\n+void orig(void);\n+void xyzzy(void) __attribute__((transaction_wrap (orig)));\n+\n+void foo() { __transaction_relaxed { orig (); } }\n+\n+/* { dg-final { scan-tree-dump-times \"xyzzy\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "ad1f7e23700e055d8e90d32aabb979529f476c6c", "filename": "gcc/testsuite/g++.dg/dg.exp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdg.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -47,6 +47,7 @@ set tests [prune $tests $srcdir/$subdir/gomp/*]\n set tests [prune $tests $srcdir/$subdir/tree-prof/*]\n set tests [prune $tests $srcdir/$subdir/torture/*]\n set tests [prune $tests $srcdir/$subdir/graphite/*]\n+set tests [prune $tests $srcdir/$subdir/tm/*]\n set tests [prune $tests $srcdir/$subdir/guality/*]\n set tests [prune $tests $srcdir/$subdir/simulate-thread/*]\n "}, {"sha": "087ce32b2a69e2451a891521c176ffc9f007344f", "filename": "gcc/testsuite/g++.dg/tm/20100429.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2F20100429.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2F20100429.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2F20100429.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+int foo(int a);\n+int foo(float a);\n+int\n+bar(int a)\n+{\n+  int r;\n+  __transaction_atomic\n+    {\n+      r = foo(a); // { dg-error \"unsafe function call 'int foo\\\\(int\\\\)'\" }\n+    }\n+  return r;\n+}"}, {"sha": "bda2df0607c4dd55dbd948b73cf7dd54d3391f8a", "filename": "gcc/testsuite/g++.dg/tm/20100727.C", "status": "added", "additions": 796, "deletions": 0, "changes": 796, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2F20100727.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2F20100727.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2F20100727.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,796 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+typedef long int ptrdiff_t;\n+typedef long unsigned int size_t;\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  using::ptrdiff_t;\n+  using::size_t;\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  struct input_iterator_tag\n+  {\n+  };\n+  struct output_iterator_tag\n+  {\n+  };\n+  struct forward_iterator_tag:public input_iterator_tag\n+  {\n+  };\n+  struct bidirectional_iterator_tag:public forward_iterator_tag\n+  {\n+  };\n+  struct random_access_iterator_tag:public bidirectional_iterator_tag\n+  {\n+  };\n+  template < typename _Category, typename _Tp, typename _Distance =\n+    ptrdiff_t, typename _Pointer = _Tp *, typename _Reference =\n+    _Tp & >struct iterator\n+  {\n+    typedef _Category iterator_category;\n+    typedef _Tp value_type;\n+    typedef _Distance difference_type;\n+    typedef _Pointer pointer;\n+    typedef _Reference reference;\n+  };\n+  template < typename _Iterator > struct iterator_traits\n+  {\n+    typedef typename _Iterator::iterator_category iterator_category;\n+    typedef typename _Iterator::value_type value_type;\n+    typedef typename _Iterator::difference_type difference_type;\n+    typedef typename _Iterator::pointer pointer;\n+    typedef typename _Iterator::reference reference;\n+  };\n+  template < typename _Tp > struct iterator_traits <_Tp * >\n+  {\n+    typedef random_access_iterator_tag iterator_category;\n+    typedef _Tp value_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef _Tp *pointer;\n+    typedef _Tp & reference;\n+  };\n+  template < typename _Tp > struct iterator_traits <const _Tp *>\n+  {\n+    typedef random_access_iterator_tag iterator_category;\n+    typedef _Tp value_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef const _Tp *pointer;\n+    typedef const _Tp & reference;\n+  };\n+  template < typename _Iter > inline typename iterator_traits <\n+    _Iter >::iterator_category __iterator_category (const _Iter &)\n+  {\n+    return typename iterator_traits < _Iter >::iterator_category ();\n+  }\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+template < typename _Iterator > class reverse_iterator:public iterator < typename iterator_traits < _Iterator >::iterator_category,\n+    typename iterator_traits < _Iterator >::value_type,\n+    typename iterator_traits < _Iterator >::difference_type,\n+    typename iterator_traits < _Iterator >::pointer,\n+    typename iterator_traits < _Iterator >::reference >\n+  {\n+  protected:_Iterator current;\n+    typedef iterator_traits < _Iterator > __traits_type;\n+  public:typedef _Iterator iterator_type;\n+    typedef typename __traits_type::difference_type difference_type;\n+    typedef typename __traits_type::pointer pointer;\n+    typedef typename __traits_type::reference reference;\n+  reverse_iterator ():current ()\n+    {\n+    } explicit reverse_iterator (iterator_type __x):current (__x)\n+    {\n+    } reverse_iterator (const reverse_iterator & __x):current (__x.current)\n+    {\n+    } template < typename _Iter > reverse_iterator (const reverse_iterator <\n+\t\t\t\t\t\t    _Iter >\n+\t\t\t\t\t\t    &__x):current (__x.\n+\t\t\t\t\t\t\t\t   base ())\n+    {\n+    } iterator_type base () const\n+    {\n+      return current;\n+    }\n+    reference operator* () const\n+    {\n+      _Iterator __tmp = current;\n+\treturn *--__tmp;\n+    }\n+    pointer operator-> () const\n+    {\n+      return &(operator* ());\n+    }\n+    reverse_iterator & operator++ ()\n+    {\n+      --current;\n+      return *this;\n+    }\n+    reverse_iterator operator++ (int)\n+    {\n+      reverse_iterator __tmp = *this;\n+      --current;\n+      return __tmp;\n+    }\n+    reverse_iterator & operator-- ()\n+    {\n+      ++current;\n+      return *this;\n+    }\n+    reverse_iterator operator-- (int)\n+    {\n+      reverse_iterator __tmp = *this;\n+      ++current;\n+      return __tmp;\n+    }\n+    reverse_iterator operator+ (difference_type __n) const\n+    {\n+      return reverse_iterator (current - __n);\n+    }\n+    reverse_iterator & operator+= (difference_type __n)\n+    {\n+      current -= __n;\n+      return *this;\n+    }\n+    reverse_iterator operator- (difference_type __n) const\n+    {\n+      return reverse_iterator (current + __n);\n+    }\n+    reverse_iterator & operator-= (difference_type __n)\n+    {\n+      current += __n;\n+      return *this;\n+    }\n+    reference operator[] (difference_type __n) const\n+    {\n+      return *(*this + __n);\n+    }\n+  };\n+  template < typename _Iterator >\n+    inline bool operator== (const reverse_iterator < _Iterator > &__x,\n+\t\t\t    const reverse_iterator < _Iterator > &__y)\n+  {\n+    return __x.base () == __y.base ();\n+  }\n+  template < typename _Iterator >\n+    inline bool operator< (const reverse_iterator < _Iterator > &__x,\n+\t\t\t   const reverse_iterator < _Iterator > &__y)\n+  {\n+    return __y.base () < __x.base ();\n+  }\n+  template < typename _Iterator >\n+    inline bool operator!= (const reverse_iterator < _Iterator > &__x,\n+\t\t\t    const reverse_iterator < _Iterator > &__y)\n+  {\n+    return !(__x == __y);\n+  }\n+  template < typename _Iterator >\n+    inline bool operator> (const reverse_iterator < _Iterator > &__x,\n+\t\t\t   const reverse_iterator < _Iterator > &__y)\n+  {\n+    return __y < __x;\n+  }\n+  template < typename _Iterator >\n+    inline bool operator<= (const reverse_iterator < _Iterator > &__x,\n+\t\t\t    const reverse_iterator < _Iterator > &__y)\n+  {\n+    return !(__y < __x);\n+  }\n+  template < typename _Iterator >\n+    inline bool operator>= (const reverse_iterator < _Iterator > &__x,\n+\t\t\t    const reverse_iterator < _Iterator > &__y)\n+  {\n+    return !(__x < __y);\n+  }\n+  template < typename _Iterator > inline typename reverse_iterator <\n+    _Iterator >::difference_type operator- (const reverse_iterator <\n+\t\t\t\t\t    _Iterator > &__x,\n+\t\t\t\t\t    const reverse_iterator <\n+\t\t\t\t\t    _Iterator > &__y)\n+  {\n+    return __y.base () - __x.base ();\n+  }\n+  template < typename _Iterator > inline reverse_iterator < _Iterator >\n+    operator+ (typename reverse_iterator < _Iterator >::difference_type __n,\n+\t       const reverse_iterator < _Iterator > &__x)\n+  {\n+    return reverse_iterator < _Iterator > (__x.base () - __n);\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline bool operator== (const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorL > &__x,\n+\t\t\t\t\t\t  const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorR > &__y)\n+  {\n+    return __x.base () == __y.base ();\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline bool operator< (const reverse_iterator <\n+\t\t\t\t\t\t _IteratorL > &__x,\n+\t\t\t\t\t\t const reverse_iterator <\n+\t\t\t\t\t\t _IteratorR > &__y)\n+  {\n+    return __y.base () < __x.base ();\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline bool operator!= (const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorL > &__x,\n+\t\t\t\t\t\t  const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorR > &__y)\n+  {\n+    return !(__x == __y);\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline bool operator> (const reverse_iterator <\n+\t\t\t\t\t\t _IteratorL > &__x,\n+\t\t\t\t\t\t const reverse_iterator <\n+\t\t\t\t\t\t _IteratorR > &__y)\n+  {\n+    return __y < __x;\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline bool operator<= (const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorL > &__x,\n+\t\t\t\t\t\t  const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorR > &__y)\n+  {\n+    return !(__y < __x);\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline bool operator>= (const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorL > &__x,\n+\t\t\t\t\t\t  const reverse_iterator <\n+\t\t\t\t\t\t  _IteratorR > &__y)\n+  {\n+    return !(__x < __y);\n+  }\n+  template < typename _IteratorL,\n+    typename _IteratorR > inline typename reverse_iterator <\n+    _IteratorL >::difference_type operator- (const reverse_iterator <\n+\t\t\t\t\t     _IteratorL > &__x,\n+\t\t\t\t\t     const reverse_iterator <\n+\t\t\t\t\t     _IteratorR > &__y)\n+  {\n+    return __y.base () - __x.base ();\n+  }\n+template < typename _Container > class back_insert_iterator:public iterator < output_iterator_tag, void, void, void,\n+    void >\n+  {\n+  protected:_Container * container;\n+  public:typedef _Container container_type;\n+    explicit back_insert_iterator (_Container & __x):container (&__x)\n+    {\n+    } back_insert_iterator & operator= (typename _Container::\n+\t\t\t\t\tconst_reference __value)\n+    {\n+      container->push_back (__value);\n+      return *this;\n+    }\n+    back_insert_iterator & operator* ()\n+    {\n+      return *this;\n+    }\n+    back_insert_iterator & operator++ ()\n+    {\n+      return *this;\n+    }\n+    back_insert_iterator operator++ (int)\n+    {\n+      return *this;\n+    }\n+  };\n+  template < typename _Container > inline back_insert_iterator < _Container >\n+    back_inserter (_Container & __x)\n+  {\n+    return back_insert_iterator < _Container > (__x);\n+  }\n+template < typename _Container > class front_insert_iterator:public iterator < output_iterator_tag, void, void, void,\n+    void >\n+  {\n+  protected:_Container * container;\n+  public:typedef _Container container_type;\n+    explicit front_insert_iterator (_Container & __x):container (&__x)\n+    {\n+    } front_insert_iterator & operator= (typename _Container::\n+\t\t\t\t\t const_reference __value)\n+    {\n+      container->push_front (__value);\n+      return *this;\n+    }\n+    front_insert_iterator & operator* ()\n+    {\n+      return *this;\n+    }\n+    front_insert_iterator & operator++ ()\n+    {\n+      return *this;\n+    }\n+    front_insert_iterator operator++ (int)\n+    {\n+      return *this;\n+    }\n+  };\n+  template < typename _Container > inline front_insert_iterator < _Container >\n+    front_inserter (_Container & __x)\n+  {\n+    return front_insert_iterator < _Container > (__x);\n+  }\n+template < typename _Container > class insert_iterator:public iterator < output_iterator_tag, void, void, void,\n+    void >\n+  {\n+  protected:_Container * container;\n+    typename _Container::iterator iter;\n+  public:typedef _Container container_type;\n+      insert_iterator (_Container & __x,\n+\t\t       typename _Container::iterator __i):container (&__x),\n+      iter (__i)\n+    {\n+    } insert_iterator & operator= (typename _Container::\n+\t\t\t\t   const_reference __value)\n+    {\n+      iter = container->insert (iter, __value);\n+      ++iter;\n+      return *this;\n+    }\n+    insert_iterator & operator* ()\n+    {\n+      return *this;\n+    }\n+    insert_iterator & operator++ ()\n+    {\n+      return *this;\n+    }\n+    insert_iterator & operator++ (int)\n+    {\n+      return *this;\n+    }\n+  };\n+  template < typename _Container,\n+    typename _Iterator > inline insert_iterator < _Container >\n+    inserter (_Container & __x, _Iterator __i)\n+  {\n+    return insert_iterator < _Container > (__x,\n+\t\t\t\t\t   typename _Container::\n+\t\t\t\t\t   iterator (__i));\n+  }\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\")))\n+{\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  template < typename _Tp > class new_allocator\n+  {\n+  public:typedef size_t size_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef _Tp *pointer;\n+    typedef const _Tp *const_pointer;\n+    typedef _Tp & reference;\n+    typedef const _Tp & const_reference;\n+    typedef _Tp value_type;\n+    template < typename _Tp1 > struct rebind\n+    {\n+      typedef new_allocator < _Tp1 > other;\n+    };\n+    new_allocator ()throw ()\n+    {\n+    } new_allocator (const new_allocator &) throw ()\n+    {\n+    } template < typename _Tp1 > new_allocator (const new_allocator < _Tp1 >\n+\t\t\t\t\t\t&) throw ()\n+    {\n+    } ~new_allocator ()throw ()\n+    {\n+    } pointer address (reference __x) const\n+    {\n+      return &__x;\n+    }\n+    const_pointer address (const_reference __x) const\n+    {\n+      return &__x;\n+    }\n+    pointer allocate (size_type __n, const void * = 0)\n+    {\n+      return static_cast < _Tp * >(::operator  new (__n * sizeof (_Tp)));\n+    }\n+    void deallocate (pointer __p, size_type)\n+    {\n+      ::operator  delete (__p);\n+    } size_type max_size () const throw ()\n+    {\n+      return size_t (-1) / sizeof (_Tp);\n+    }\n+    void construct (pointer __p, const _Tp & __val)\n+    {\n+      ::new ((void *) __p) _Tp (__val);\n+    } void destroy (pointer __p)\n+    {\n+      __p->~_Tp ();\n+  }};\n+  template < typename _Tp > inline bool operator== (const new_allocator <\n+\t\t\t\t\t\t    _Tp > &,\n+\t\t\t\t\t\t    const new_allocator <\n+\t\t\t\t\t\t    _Tp > &)\n+  {\n+    return true;\n+  }\n+  template < typename _Tp > inline bool operator!= (const new_allocator <\n+\t\t\t\t\t\t    _Tp > &,\n+\t\t\t\t\t\t    const new_allocator <\n+\t\t\t\t\t\t    _Tp > &)\n+  {\n+    return false;\n+  }\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Tp > class allocator;\n+  template <> class allocator < void >\n+  {\n+  public:typedef size_t size_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef void *pointer;\n+    typedef const void *const_pointer;\n+    typedef void value_type;\n+      template < typename _Tp1 > struct rebind\n+    {\n+      typedef allocator < _Tp1 > other;\n+    };\n+  };\n+template < typename _Tp > class allocator:public __gnu_cxx::new_allocator <\n+    _Tp >\n+  {\n+  public:typedef size_t size_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef _Tp *pointer;\n+    typedef const _Tp *const_pointer;\n+    typedef _Tp & reference;\n+    typedef const _Tp & const_reference;\n+    typedef _Tp value_type;\n+    template < typename _Tp1 > struct rebind\n+    {\n+      typedef allocator < _Tp1 > other;\n+    };\n+    allocator ()throw ()\n+    {\n+    } allocator (const allocator & __a) throw ():__gnu_cxx::new_allocator <\n+      _Tp > (__a)\n+    {\n+    } template < typename _Tp1 > allocator (const allocator < _Tp1 >\n+\t\t\t\t\t    &) throw ()\n+    {\n+    } ~allocator ()throw ()\n+    {\n+  }};\n+  template < typename _T1,\n+    typename _T2 > inline bool operator== (const allocator < _T1 > &,\n+\t\t\t\t\t   const allocator < _T2 > &)\n+  {\n+    return true;\n+  }\n+  template < typename _Tp > inline bool operator== (const allocator < _Tp > &,\n+\t\t\t\t\t\t    const allocator < _Tp > &)\n+  {\n+    return true;\n+  }\n+  template < typename _T1,\n+    typename _T2 > inline bool operator!= (const allocator < _T1 > &,\n+\t\t\t\t\t   const allocator < _T2 > &)\n+  {\n+    return false;\n+  }\n+  template < typename _Tp > inline bool operator!= (const allocator < _Tp > &,\n+\t\t\t\t\t\t    const allocator < _Tp > &)\n+  {\n+    return false;\n+  }\n+  template < typename _Alloc, bool = __is_empty (_Alloc) > struct __alloc_swap\n+  {\n+    static void _S_do_it (_Alloc &, _Alloc &)\n+    {\n+  }};\n+  template < typename _Alloc > struct __alloc_swap <_Alloc, false >\n+  {\n+    static void _S_do_it (_Alloc & __one, _Alloc & __two)\n+    {\n+      if (__one != __two)\n+\tswap (__one, __two);\n+    }\n+  };\n+  template < typename _Alloc, bool = __is_empty (_Alloc) > struct __alloc_neq\n+  {\n+    static bool _S_do_it (const _Alloc &, const _Alloc &)\n+    {\n+      return false;\n+    }\n+  };\n+  template < typename _Alloc > struct __alloc_neq <_Alloc, false >\n+  {\n+    static bool _S_do_it (const _Alloc & __one, const _Alloc & __two)\n+    {\n+      return __one != __two;\n+    }\n+  };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  struct _List_node_base\n+  {\n+    _List_node_base *_M_next;\n+    _List_node_base *_M_prev;\n+    static void swap (_List_node_base & __x, _List_node_base & __y) throw ();\n+    void _M_transfer (_List_node_base * const __first,\n+\t\t      _List_node_base * const __last) throw ();\n+    void _M_reverse () throw ();\n+    void _M_hook (_List_node_base * const __position) throw ();\n+    void _M_unhook () throw ();\n+  };\n+  template < typename _Tp > struct _List_node:public _List_node_base\n+  {\n+    _Tp _M_data;\n+  };\n+  template < typename _Tp > struct _List_iterator\n+  {\n+    typedef _List_iterator < _Tp > _Self;\n+    typedef _List_node < _Tp > _Node;\n+    typedef ptrdiff_t difference_type;\n+    typedef std::bidirectional_iterator_tag iterator_category;\n+    typedef _Tp value_type;\n+    typedef _Tp *pointer;\n+    typedef _Tp & reference;\n+      _List_iterator ():_M_node ()\n+    {\n+    } explicit _List_iterator (_List_node_base * __x):_M_node (__x)\n+    {\n+    } reference operator* () const\n+    {\n+      return static_cast < _Node * >(_M_node)->_M_data;\n+    }\n+    pointer operator-> () const\n+    {\n+      return &static_cast < _Node * >(_M_node)->_M_data;\n+    }\n+    _Self & operator++ ()\n+    {\n+      _M_node = _M_node->_M_next;\n+      return *this;\n+    }\n+    _Self operator++ (int)\n+    {\n+      _Self __tmp = *this;\n+      _M_node = _M_node->_M_next;\n+      return __tmp;\n+    }\n+    _Self & operator-- ()\n+    {\n+      _M_node = _M_node->_M_prev;\n+      return *this;\n+    }\n+    _Self operator-- (int)\n+    {\n+      _Self __tmp = *this;\n+      _M_node = _M_node->_M_prev;\n+      return __tmp;\n+    }\n+    bool operator== (const _Self & __x) const\n+    {\n+      return _M_node == __x._M_node;\n+    }\n+    bool operator!= (const _Self & __x) const\n+    {\n+      return _M_node != __x._M_node;\n+    }\n+    _List_node_base *_M_node;\n+  };\n+  template < typename _Tp > struct _List_const_iterator\n+  {\n+    typedef _List_const_iterator < _Tp > _Self;\n+    typedef const _List_node < _Tp > _Node;\n+    typedef _List_iterator < _Tp > iterator;\n+    typedef ptrdiff_t difference_type;\n+    typedef std::bidirectional_iterator_tag iterator_category;\n+    typedef _Tp value_type;\n+    typedef const _Tp *pointer;\n+    typedef const _Tp & reference;\n+      _List_const_iterator ():_M_node ()\n+    {\n+    } explicit _List_const_iterator (const _List_node_base *\n+\t\t\t\t     __x):_M_node (__x)\n+    {\n+    } _List_const_iterator (const iterator & __x):_M_node (__x._M_node)\n+    {\n+    } reference operator* () const\n+    {\n+      return static_cast < _Node * >(_M_node)->_M_data;\n+    }\n+    pointer operator-> () const\n+    {\n+      return &static_cast < _Node * >(_M_node)->_M_data;\n+    }\n+    _Self & operator++ ()\n+    {\n+      _M_node = _M_node->_M_next;\n+      return *this;\n+    }\n+    _Self operator++ (int)\n+    {\n+      _Self __tmp = *this;\n+      _M_node = _M_node->_M_next;\n+      return __tmp;\n+    }\n+    _Self & operator-- ()\n+    {\n+      _M_node = _M_node->_M_prev;\n+      return *this;\n+    }\n+    _Self operator-- (int)\n+    {\n+      _Self __tmp = *this;\n+      _M_node = _M_node->_M_prev;\n+      return __tmp;\n+    }\n+    bool operator== (const _Self & __x) const\n+    {\n+      return _M_node == __x._M_node;\n+    }\n+    bool operator!= (const _Self & __x) const\n+    {\n+      return _M_node != __x._M_node;\n+    }\n+    const _List_node_base *_M_node;\n+  };\n+  template < typename _Tp, typename _Alloc > class _List_base\n+  {\n+  protected:typedef typename _Alloc::template rebind < _List_node < _Tp >\n+      >::other _Node_alloc_type;\n+    typedef typename _Alloc::template rebind < _Tp >::other _Tp_alloc_type;\n+    struct _List_impl:public _Node_alloc_type\n+    {\n+      _List_node_base _M_node;\n+\t_List_impl ():_Node_alloc_type (), _M_node ()\n+      {\n+      } _List_impl (const _Node_alloc_type & __a):_Node_alloc_type (__a),\n+\t_M_node ()\n+      {\n+    }};\n+    _List_impl _M_impl;\n+    _List_node < _Tp > *_M_get_node ()\n+    {\n+      return _M_impl._Node_alloc_type::allocate (1);\n+    }\n+    void _M_put_node (_List_node < _Tp > *__p)\n+    {\n+      _M_impl._Node_alloc_type::deallocate (__p, 1);\n+  } public:typedef _Alloc allocator_type;\n+    _Node_alloc_type & _M_get_Node_allocator ()\n+    {\n+      return *static_cast < _Node_alloc_type * >(&this->_M_impl);\n+    }\n+    const _Node_alloc_type & _M_get_Node_allocator () const\n+    {\n+      return *static_cast < const _Node_alloc_type *>(&this->_M_impl);\n+    } _Tp_alloc_type _M_get_Tp_allocator () const\n+    {\n+      return _Tp_alloc_type (_M_get_Node_allocator ());\n+    }\n+    allocator_type get_allocator () const\n+    {\n+      return allocator_type (_M_get_Node_allocator ());\n+    }\n+    _List_base ():_M_impl ()\n+    {\n+      _M_init ();\n+    }\n+  _List_base (const allocator_type & __a):_M_impl (__a)\n+    {\n+      _M_init ();\n+    } ~_List_base ()\n+    {\n+      _M_clear ();\n+    } void _M_clear ();\n+    void _M_init ()\n+    {\n+      this->_M_impl._M_node._M_next = &this->_M_impl._M_node;\n+      this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;\n+  }};\n+template < typename _Tp, typename _Alloc = std::allocator < _Tp > >class list:protected _List_base < _Tp,\n+    _Alloc\n+    >\n+  {\n+    typedef typename _Alloc::value_type _Alloc_value_type;\n+    typedef _List_base < _Tp, _Alloc > _Base;\n+    typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;\n+  public:typedef _Tp value_type;\n+    typedef typename _Tp_alloc_type::pointer pointer;\n+    typedef typename _Tp_alloc_type::const_pointer const_pointer;\n+    typedef typename _Tp_alloc_type::reference reference;\n+    typedef typename _Tp_alloc_type::const_reference const_reference;\n+    typedef _List_iterator < _Tp > iterator;\n+    typedef _List_const_iterator < _Tp > const_iterator;\n+    typedef std::reverse_iterator < const_iterator > const_reverse_iterator;\n+    typedef std::reverse_iterator < iterator > reverse_iterator;\n+    typedef size_t size_type;\n+    typedef ptrdiff_t difference_type;\n+    typedef _Alloc allocator_type;\n+  protected:typedef _List_node < _Tp > _Node;\n+    using _Base::_M_impl;\n+    using _Base::_M_put_node;\n+    using _Base::_M_get_node;\n+    using _Base::_M_get_Tp_allocator;\n+    using _Base::_M_get_Node_allocator;\n+  public:iterator begin ()\n+    {\n+      return iterator (this->_M_impl._M_node._M_next);\n+    }\n+    const_iterator begin () const\n+    {\n+      return const_iterator (this->_M_impl._M_node._M_next);\n+    }\n+    iterator end ()\n+    {\n+      return iterator (&this->_M_impl._M_node);\n+    }\n+    void remove (const _Tp & __value);\n+    template < typename _Predicate > void remove_if (_Predicate);\n+    void _M_erase (iterator __position)\n+    {\n+      __position._M_node->_M_unhook ();\n+      _Node *__n = static_cast < _Node * >(__position._M_node);\n+      _M_get_Tp_allocator ().destroy (&__n->_M_data);\n+      _M_put_node (__n);\n+    } void _M_check_equal_allocators (list & __x)\n+    {\n+      if (std::__alloc_neq <\n+\t  typename _Base::_Node_alloc_type >::\n+\t  _S_do_it (_M_get_Node_allocator (), __x._M_get_Node_allocator ()));\n+    }\n+  };\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\")))\n+{\n+  template < typename _Tp, typename _Alloc > void list < _Tp,\n+    _Alloc >::remove (const value_type & __value)\n+  {\n+    iterator __first = begin ();\n+    iterator __last = end ();\n+    iterator __extra = __last;\n+    while (__first != __last)\n+      {\n+\titerator __next = __first;\n+\t++__next;\n+\tif (*__first == __value)\n+\t  {\n+\t    if (&*__first != &__value)\n+\t      _M_erase (__first);\n+\t    else\n+\t      __extra = __first;\n+\t  }\n+\t__first = __next;\n+      }\n+    if (__extra != __last)\n+      _M_erase (__extra);\n+  }\n+}\n+\n+class Unit\n+{\n+public:int dummy;\n+};\n+class Building\n+{\n+public:__attribute__ ((transaction_callable)) void removeUnitFromInside (Unit *\n+\t\t\t\t\t\t\t\t    unit);\n+    std::list < Unit * >unitsInside;\n+};\n+void\n+Building::removeUnitFromInside (Unit * unit)\n+{\n+  unitsInside.remove (unit);\n+}"}, {"sha": "4459c703bdc0cc6697493acb42c1f25c6d1e9f21", "filename": "gcc/testsuite/g++.dg/tm/alias.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Falias.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Falias.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Falias.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,20 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O0\" }\n+\n+/* Test that we generate transactional clones for both the base and\n+   the complete dtor for class Itemset.  */\n+\n+class Itemset {\n+public:\n+   __attribute__((transaction_safe)) ~Itemset();\n+  __attribute__((transaction_safe)) void operator delete(void *);\n+private:\n+};\n+\n+__attribute__((transaction_safe))\n+Itemset::~Itemset()\n+{\n+}\n+\n+// { dg-final { scan-assembler \"_ZGTtN7ItemsetD1Ev\" } }\n+// { dg-final { scan-assembler \"_ZGTtN7ItemsetD2Ev\" } }"}, {"sha": "6a418e559cfe19cc285c06deb3d694e5d937a763", "filename": "gcc/testsuite/g++.dg/tm/attrib-2.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-2.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -fdump-tree-optimized-asmname\" }\n+\n+struct __attribute__((transaction_safe)) Tsafe\n+{\n+  void f();\n+};\n+\n+void Tsafe::f() { }\n+\n+struct __attribute__((transaction_callable)) Tcall\n+{\n+  void f();\n+};\n+\n+void Tcall::f() { }\n+\n+// { dg-final { scan-tree-dump-times \"_ZN5Tsafe1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZN5Tcall1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZGTtN5Tsafe1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZGTtN5Tcall1fEv\" 1 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "a2c9718bc095101b485c3ed721a6ce5804edc623", "filename": "gcc/testsuite/g++.dg/tm/attrib-3.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-3.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -fdump-tree-optimized-asmname\" }\n+\n+struct __attribute__((transaction_safe)) A\n+{\n+};\n+\n+struct B : public A\n+{\n+  void f();\n+};\n+\n+struct C\n+{\n+};\n+\n+struct D : public C\n+{\n+};\n+\n+struct E : public D, public A\n+{\n+  void f();\n+};\n+\n+void B::f() { }\n+void E::f() { }\n+\n+// { dg-final { scan-tree-dump-times \"_ZN1B1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZGTtN1B1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZN1E1fEv\" 1 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"_ZGTtN1E1fEv\" 1 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }"}, {"sha": "b589b9d41a2631758774a400c85b964b295bcdf5", "filename": "gcc/testsuite/g++.dg/tm/attrib-4.C", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fattrib-4.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,48 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+#define __ts\t__attribute__((transaction_safe))\n+#define __tc\t__attribute__((transaction_callable))\n+#define __tp\t__attribute__((transaction_pure))\n+#define __tu\t__attribute__((transaction_unsafe))\n+\n+struct __ts A\n+{\n+  virtual void f();\n+  virtual void g();\n+};\n+\n+struct __tc B : public A\n+{\n+  void f() __tc;  // { dg-error \".transaction_callable. overriding .transaction_safe.\" }\n+  void g();\n+  virtual void h();\n+};\n+\n+struct C : public B\n+{\n+  void g() __tc;  // { dg-error \".transaction_callable. overriding .transaction_safe.\" }\n+};\n+\n+struct C2 : public B\n+{\n+  void g() __ts;\n+  void h() __tu;  // { dg-error \".transaction_unsafe. overriding .transaction_callable.\" }\n+};\n+\n+struct D\n+{\n+  virtual void f() __tp;\n+  virtual void g() __tp;\n+};\n+\n+struct E : public D\n+{\n+  void f() __ts;  // { dg-error \".transaction_safe. overriding .transaction_pure.\" }\n+  void g();\n+};\n+\n+struct F : public E\n+{\n+  void g() __ts;  // { dg-error \".transaction_safe. overriding .transaction_pure.\" }\n+};"}, {"sha": "dac850aac076fff49f29ce4f0b6fd95baf59293c", "filename": "gcc/testsuite/g++.dg/tm/fatomic-1.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ffatomic-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ffatomic-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ffatomic-1.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+struct S\n+{\n+  int i, j, k;\n+  S();\n+};\n+\n+S::S() __transaction_atomic : i(1), j(2), k(3) { }"}, {"sha": "1f4e19e9891a8e120964287522e6a9aa101afebb", "filename": "gcc/testsuite/g++.dg/tm/nested-1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-1.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+class HashTree\n+{\n+public:\n+   __attribute__((transaction_safe))\n+   int add_element2();\n+private:\n+   int Count;\n+};\n+\n+\n+__attribute__((transaction_safe))\n+int HashTree::add_element2()\n+{\n+ int tt;\n+  __transaction_atomic {\n+    tt = Count;\n+ }\n+ return tt;\n+}"}, {"sha": "c6d5d98ba7a86000b2f90c72e62719ed79576a20", "filename": "gcc/testsuite/g++.dg/tm/nested-2.C", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-2.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O\" }\n+\n+typedef unsigned long int uint64_t;\n+extern int *hash_indx;\n+\n+typedef struct\n+{\n+  uint64_t exit_atomicsec_time;\n+} ent_ex_times;\n+class HashTree\n+{\n+public:\n+   __attribute__((transaction_safe))\n+   void *operator new(__SIZE_TYPE__);\n+   __attribute__((transaction_safe))\n+   int add_element();\n+private:\n+   HashTree **Hash_table;\n+   int Count;\n+};\n+\n+\n+__attribute__((transaction_safe))\n+int HashTree::add_element()\n+{\n+ ent_ex_times enter_exit_times_inside;\n+ int val = hash_indx[5];\n+ int tt;\n+ if (Hash_table[val] == __null)\n+ {\n+  __transaction_atomic {\n+    Hash_table[val] = new HashTree;\n+  }\n+ }\n+ __transaction_atomic {\n+ tt = Count++;\n+ enter_exit_times_inside.exit_atomicsec_time = 5;\n+ }\n+ return tt;\n+}"}, {"sha": "19718c34a02fdbc490fe476b988fc1de82f7671e", "filename": "gcc/testsuite/g++.dg/tm/nested-3.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fnested-3.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O0\" }\n+\n+// Same as nested-2.C but with no optimization.\n+\n+typedef unsigned long int uint64_t;\n+extern int *hash_indx;\n+\n+typedef struct\n+{\n+  uint64_t exit_atomicsec_time;\n+} ent_ex_times;\n+class HashTree\n+{\n+public:\n+   __attribute__((transaction_safe))\n+   void *operator new(__SIZE_TYPE__);\n+   __attribute__((transaction_safe))\n+   int add_element();\n+private:\n+   HashTree **Hash_table;\n+   int Count;\n+};\n+\n+\n+__attribute__((transaction_safe))\n+int HashTree::add_element()\n+{\n+ ent_ex_times enter_exit_times_inside;\n+ int val = hash_indx[5];\n+ int tt;\n+ if (Hash_table[val] == __null)\n+ {\n+  __transaction_atomic {\n+    Hash_table[val] = new HashTree;\n+  }\n+ }\n+ __transaction_atomic {\n+ tt = Count++;\n+ enter_exit_times_inside.exit_atomicsec_time = 5;\n+ }\n+ return tt;\n+}"}, {"sha": "8dd41a5bfe8384e8454429ce678649408b44e3f2", "filename": "gcc/testsuite/g++.dg/tm/opt-1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fopt-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fopt-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fopt-1.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O\" }\n+\n+struct S\n+{\n+  virtual void f() __attribute__((transaction_safe));\n+};\n+\n+void f(S *s) { __transaction_atomic { s->f(); } }"}, {"sha": "ab10c34baaac997aa963f3470c55fa659ceaac3a", "filename": "gcc/testsuite/g++.dg/tm/pr45940-2.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-2.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O1\" }\n+\n+__attribute__((transaction_pure))\n+inline int atomic_exchange_and_add(int dv )\n+{\n+    int r;\n+    __asm__ (\"\" : \"=r\"(r));\n+    return r;\n+}\n+\n+class sp_counted_base\n+{\n+public:\n+    __attribute__((transaction_safe))\n+    void release()\n+    {\n+\tif( atomic_exchange_and_add(-1 ) == 1 )\n+\t{\n+\t}\n+    }\n+};\n+\n+sp_counted_base *base;\n+\n+void here(){\n+  __transaction_atomic {\n+    base->release();\n+  }\n+}"}, {"sha": "c8caee6c8b976242b6d10007f331a68720ecac1b", "filename": "gcc/testsuite/g++.dg/tm/pr45940-3.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-3.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,69 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O0\" }\n+\n+__attribute__((transaction_safe))\n+void* operator new (__SIZE_TYPE__);\n+\n+__attribute__((transaction_pure))\n+inline int atomic_exchange_and_add( int * pw, int dv )\n+{\n+    int r;\n+    __asm__ (\"\" : \"=r\"(r));\n+    return r;\n+}\n+\n+class sp_counted_base\n+{\n+protected:\n+    int use_count_;        // #shared\n+public:\n+    __attribute__((transaction_safe))\n+    virtual void dispose() = 0; // nothrow\n+\n+    __attribute__((transaction_safe))\n+    void release() // nothrow\n+    {\n+\tif( atomic_exchange_and_add( &use_count_, -1 ) == 1 )\n+\t{\n+\t    dispose();\n+\t}\n+    }\n+};\n+\n+class sp_counted_base_x86 : public sp_counted_base\n+{\n+public:\n+  void dispose()\n+  {\n+    release();\n+  }\n+};\n+\n+class shared_count\n+{\n+private:\n+    sp_counted_base * pi_;\n+public:\n+    int j;\n+    __attribute__((transaction_safe))\n+    shared_count(): pi_(new sp_counted_base_x86()), j(0)\n+    {\n+    }\n+    __attribute__((transaction_safe))\n+    ~shared_count() // nothrow\n+    {\n+\tif( pi_ != 0 ) pi_->release();\n+    }\n+};\n+\n+volatile int i = 1;\n+shared_count * c;\n+int main()\n+{\n+  if ( i == 0) {\n+    __transaction_atomic {\n+     shared_count sc;\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "d1cb8d55ae6772385d1189a3e0d02f89b8369974", "filename": "gcc/testsuite/g++.dg/tm/pr45940-4.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940-4.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,69 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O1\" }\n+\n+__attribute__((transaction_safe))\n+void* operator new (__SIZE_TYPE__);\n+\n+__attribute__((transaction_pure))\n+inline int atomic_exchange_and_add( int * pw, int dv )\n+{\n+    int r;\n+    __asm__ (\"\" : \"=r\"(r));\n+    return r;\n+}\n+\n+class sp_counted_base\n+{\n+protected:\n+    int use_count_;        // #shared\n+public:\n+    __attribute__((transaction_safe))\n+    virtual void dispose() = 0; // nothrow\n+\n+    __attribute__((transaction_safe))\n+    void release() // nothrow\n+    {\n+\tif( atomic_exchange_and_add( &use_count_, -1 ) == 1 )\n+\t{\n+\t    dispose();\n+\t}\n+    }\n+};\n+\n+class sp_counted_base_x86 : public sp_counted_base\n+{\n+public:\n+  void dispose()\n+  {\n+    release();\n+  }\n+};\n+\n+class shared_count\n+{\n+private:\n+    sp_counted_base * pi_;\n+public:\n+    int j;\n+    __attribute__((transaction_safe))\n+    shared_count(): pi_(new sp_counted_base_x86()), j(0)\n+    {\n+    }\n+    __attribute__((transaction_safe))\n+    ~shared_count() // nothrow\n+    {\n+\tif( pi_ != 0 ) pi_->release();\n+    }\n+};\n+\n+volatile int i = 1;\n+shared_count * c;\n+int main()\n+{\n+  if ( i == 0) {\n+    __transaction_atomic {\n+     shared_count sc;\n+    }\n+  }\n+  return 0;\n+}"}, {"sha": "3e9a2c3f8da3f9de96217ccc8e98f4c957e37172", "filename": "gcc/testsuite/g++.dg/tm/pr45940.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr45940.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O0\" }\n+\n+__attribute__((transaction_pure))\n+inline int atomic_exchange_and_add(int dv )\n+{\n+    int r;\n+    __asm__ (\"\" : \"=r\"(r));\n+    return r;\n+}\n+\n+class sp_counted_base\n+{\n+public:\n+    __attribute__((transaction_safe))\n+    void release()\n+    {\n+\tif( atomic_exchange_and_add(-1 ) == 1 )\n+\t{\n+\t}\n+    }\n+};\n+\n+sp_counted_base *base;\n+\n+void here(){\n+  __transaction_atomic {\n+    base->release();\n+  }\n+}"}, {"sha": "b4b13af5bf1337aa8c067f4709836bbb15efbc3c", "filename": "gcc/testsuite/g++.dg/tm/pr46269.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46269.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46269.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46269.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+static inline void atomic_exchange_and_add()\n+{\n+  __asm__  (\"\");\n+}\n+\n+template<class T> class shared_ptr\n+{\n+public:\n+  shared_ptr( T * p )\n+  {\n+    atomic_exchange_and_add();\n+  }\n+};\n+\n+class BuildingCompletedEvent\n+{\n+  public:\n+  __attribute__((transaction_callable)) void updateBuildingSite(void);\n+  __attribute__((transaction_pure)) BuildingCompletedEvent();\n+};\n+\n+void BuildingCompletedEvent::updateBuildingSite(void)\n+{\n+  shared_ptr<BuildingCompletedEvent> event(new BuildingCompletedEvent());\n+}\n+"}, {"sha": "291e620a38792d0f221f46f03cc2c2954bf33a69", "filename": "gcc/testsuite/g++.dg/tm/pr46270.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46270.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46270.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46270.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+#include <list>\n+class Game\n+{\n+public:\n+  struct BuildProject\n+  {\n+    int posX;\n+  };\n+  std::list<BuildProject> buildProjects;\n+};\n+\n+static Game game;\n+static std::list<std::list<Game::BuildProject>::iterator> erasableBuildProjects;\n+\n+static void *buildProjectSyncStepConcurrently(int id, int localTeam)\n+{\n+  __transaction_relaxed {\n+    std::list<std::list<Game::BuildProject>::iterator>::iterator it\n+      = erasableBuildProjects.begin();\n+    game.buildProjects.erase( (std::list<Game::BuildProject>\n+\t\t\t       ::iterator) *it);\n+  }\n+  return 0;\n+}"}, {"sha": "7b3c613c3f5f732266b3c3b48c3cbe15588ff40b", "filename": "gcc/testsuite/g++.dg/tm/pr46300.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46300.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46300.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46300.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,8 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+void foo(){\n+    __transaction_atomic {\n+\tthrow 5;\n+    }\n+}"}, {"sha": "2f0ef93f2d46ed0449415e218758dbfb536f1147", "filename": "gcc/testsuite/g++.dg/tm/pr46567.C", "status": "added", "additions": 2676, "deletions": 0, "changes": 2676, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46567.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46567.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46567.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,2676 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O2\" }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__ size_t;\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  using ::ptrdiff_t;\n+  using ::size_t;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  void\n+  __throw_bad_exception(void) __attribute__((__noreturn__));\n+  void\n+  __throw_bad_alloc(void) __attribute__((__noreturn__));\n+  void\n+  __throw_bad_cast(void) __attribute__((__noreturn__));\n+  void\n+  __throw_bad_typeid(void) __attribute__((__noreturn__));\n+  void\n+  __throw_logic_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_domain_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_invalid_argument(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_length_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_out_of_range(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_runtime_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_range_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_overflow_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_underflow_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_ios_failure(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_system_error(int) __attribute__((__noreturn__));\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Iterator, typename _Container>\n+    class __normal_iterator;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  struct __true_type { };\n+  struct __false_type { };\n+  template<bool>\n+    struct __truth_type\n+    { typedef __false_type __type; };\n+  template<>\n+    struct __truth_type<true>\n+    { typedef __true_type __type; };\n+  template<class _Sp, class _Tp>\n+    struct __traitor\n+    {\n+      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };\n+      typedef typename __truth_type<__value>::__type __type;\n+    };\n+  template<typename, typename>\n+    struct __are_same\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __are_same<_Tp, _Tp>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_void\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<>\n+    struct __is_void<void>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_integer\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<>\n+    struct __is_integer<bool>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<signed char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<unsigned char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<wchar_t>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<short>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<unsigned short>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<int>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<unsigned int>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<long>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<unsigned long>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<long long>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_integer<unsigned long long>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_floating\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<>\n+    struct __is_floating<float>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_floating<double>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_floating<long double>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_pointer\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_pointer<_Tp*>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_normal_iterator\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<typename _Iterator, typename _Container>\n+    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,\n+\t     _Container> >\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_arithmetic\n+    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >\n+    { };\n+  template<typename _Tp>\n+    struct __is_fundamental\n+    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >\n+    { };\n+  template<typename _Tp>\n+    struct __is_scalar\n+    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >\n+    { };\n+  template<typename _Tp>\n+    struct __is_char\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<>\n+    struct __is_char<char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_char<wchar_t>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_byte\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+  template<>\n+    struct __is_byte<char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_byte<signed char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<>\n+    struct __is_byte<unsigned char>\n+    {\n+      enum { __value = 1 };\n+      typedef __true_type __type;\n+    };\n+  template<typename _Tp>\n+    struct __is_move_iterator\n+    {\n+      enum { __value = 0 };\n+      typedef __false_type __type;\n+    };\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<bool, typename>\n+    struct __enable_if\n+    { };\n+  template<typename _Tp>\n+    struct __enable_if<true, _Tp>\n+    { typedef _Tp __type; };\n+  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n+    struct __conditional_type\n+    { typedef _Iftrue __type; };\n+  template<typename _Iftrue, typename _Iffalse>\n+    struct __conditional_type<false, _Iftrue, _Iffalse>\n+    { typedef _Iffalse __type; };\n+  template<typename _Tp>\n+    struct __add_unsigned\n+    {\n+    private:\n+      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;\n+    public:\n+      typedef typename __if_type::__type __type;\n+    };\n+  template<>\n+    struct __add_unsigned<char>\n+    { typedef unsigned char __type; };\n+  template<>\n+    struct __add_unsigned<signed char>\n+    { typedef unsigned char __type; };\n+  template<>\n+    struct __add_unsigned<short>\n+    { typedef unsigned short __type; };\n+  template<>\n+    struct __add_unsigned<int>\n+    { typedef unsigned int __type; };\n+  template<>\n+    struct __add_unsigned<long>\n+    { typedef unsigned long __type; };\n+  template<>\n+    struct __add_unsigned<long long>\n+    { typedef unsigned long long __type; };\n+  template<>\n+    struct __add_unsigned<bool>;\n+  template<>\n+    struct __add_unsigned<wchar_t>;\n+  template<typename _Tp>\n+    struct __remove_unsigned\n+    {\n+    private:\n+      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;\n+    public:\n+      typedef typename __if_type::__type __type;\n+    };\n+  template<>\n+    struct __remove_unsigned<char>\n+    { typedef signed char __type; };\n+  template<>\n+    struct __remove_unsigned<unsigned char>\n+    { typedef signed char __type; };\n+  template<>\n+    struct __remove_unsigned<unsigned short>\n+    { typedef short __type; };\n+  template<>\n+    struct __remove_unsigned<unsigned int>\n+    { typedef int __type; };\n+  template<>\n+    struct __remove_unsigned<unsigned long>\n+    { typedef long __type; };\n+  template<>\n+    struct __remove_unsigned<unsigned long long>\n+    { typedef long long __type; };\n+  template<>\n+    struct __remove_unsigned<bool>;\n+  template<>\n+    struct __remove_unsigned<wchar_t>;\n+  template<typename _Type>\n+    inline bool\n+    __is_null_pointer(_Type* __ptr)\n+    { return __ptr == 0; }\n+  template<typename _Type>\n+    inline bool\n+    __is_null_pointer(_Type)\n+    { return false; }\n+  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>\n+    struct __promote\n+    { typedef double __type; };\n+  template<typename _Tp>\n+    struct __promote<_Tp, false>\n+    { typedef _Tp __type; };\n+  template<typename _Tp, typename _Up>\n+    struct __promote_2\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+    public:\n+      typedef __typeof__(__type1() + __type2()) __type;\n+    };\n+  template<typename _Tp, typename _Up, typename _Vp>\n+    struct __promote_3\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+      typedef typename __promote<_Vp>::__type __type3;\n+    public:\n+      typedef __typeof__(__type1() + __type2() + __type3()) __type;\n+    };\n+  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>\n+    struct __promote_4\n+    {\n+    private:\n+      typedef typename __promote<_Tp>::__type __type1;\n+      typedef typename __promote<_Up>::__type __type2;\n+      typedef typename __promote<_Vp>::__type __type3;\n+      typedef typename __promote<_Wp>::__type __type4;\n+    public:\n+      typedef __typeof__(__type1() + __type2() + __type3() + __type4()) __type;\n+    };\n+}\n+\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Value>\n+    struct __numeric_traits_integer\n+    {\n+      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);\n+      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);\n+      static const bool __is_signed = ((_Value)(-1) < 0);\n+      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));\n+    };\n+  template<typename _Value>\n+    const _Value __numeric_traits_integer<_Value>::__min;\n+  template<typename _Value>\n+    const _Value __numeric_traits_integer<_Value>::__max;\n+  template<typename _Value>\n+    const bool __numeric_traits_integer<_Value>::__is_signed;\n+  template<typename _Value>\n+    const int __numeric_traits_integer<_Value>::__digits;\n+  template<typename _Value>\n+    struct __numeric_traits_floating\n+    {\n+      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 3010 / 10000);\n+      static const bool __is_signed = true;\n+      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);\n+      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);\n+    };\n+  template<typename _Value>\n+    const int __numeric_traits_floating<_Value>::__max_digits10;\n+  template<typename _Value>\n+    const bool __numeric_traits_floating<_Value>::__is_signed;\n+  template<typename _Value>\n+    const int __numeric_traits_floating<_Value>::__digits10;\n+  template<typename _Value>\n+    const int __numeric_traits_floating<_Value>::__max_exponent10;\n+  template<typename _Value>\n+    struct __numeric_traits\n+    : public __conditional_type<std::__is_integer<_Value>::__value,\n+    __numeric_traits_integer<_Value>,\n+    __numeric_traits_floating<_Value> >::__type\n+    { };\n+}\n+\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp>\n+    inline void\n+    swap(_Tp& __a, _Tp& __b)\n+    {\n+\n+      _Tp __tmp = (__a);\n+      __a = (__b);\n+      __b = (__tmp);\n+    }\n+  template<typename _Tp, size_t _Nm>\n+    inline void\n+    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])\n+    {\n+      for (size_t __n = 0; __n < _Nm; ++__n)\n+ swap(__a[__n], __b[__n]);\n+    }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<class _T1, class _T2>\n+    struct pair\n+    {\n+      typedef _T1 first_type;\n+      typedef _T2 second_type;\n+      _T1 first;\n+      _T2 second;\n+      pair()\n+      : first(), second() { }\n+      pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) { }\n+      template<class _U1, class _U2>\n+\tpair(const pair<_U1, _U2>& __p)\n+ : first(__p.first),\n+   second(__p.second) { }\n+    };\n+  template<class _T1, class _T2>\n+    inline bool\n+    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return __x.first == __y.first && __x.second == __y.second; }\n+  template<class _T1, class _T2>\n+    inline bool\n+    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return __x.first < __y.first\n+      || (!(__y.first < __x.first) && __x.second < __y.second); }\n+  template<class _T1, class _T2>\n+    inline bool\n+    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return !(__x == __y); }\n+  template<class _T1, class _T2>\n+    inline bool\n+    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return __y < __x; }\n+  template<class _T1, class _T2>\n+    inline bool\n+    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return !(__y < __x); }\n+  template<class _T1, class _T2>\n+    inline bool\n+    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)\n+    { return !(__x < __y); }\n+  template<class _T1, class _T2>\n+    inline pair<_T1, _T2>\n+    make_pair(_T1 __x, _T2 __y)\n+    { return pair<_T1, _T2>(__x, __y); }\n+}\n+\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  struct input_iterator_tag { };\n+  struct output_iterator_tag { };\n+  struct forward_iterator_tag : public input_iterator_tag { };\n+  struct bidirectional_iterator_tag : public forward_iterator_tag { };\n+  struct random_access_iterator_tag : public bidirectional_iterator_tag { };\n+  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,\n+\t   typename _Pointer = _Tp*, typename _Reference = _Tp&>\n+    struct iterator\n+    {\n+      typedef _Category iterator_category;\n+      typedef _Tp value_type;\n+      typedef _Distance difference_type;\n+      typedef _Pointer pointer;\n+      typedef _Reference reference;\n+    };\n+  template<typename _Iterator>\n+    struct iterator_traits\n+    {\n+      typedef typename _Iterator::iterator_category iterator_category;\n+      typedef typename _Iterator::value_type value_type;\n+      typedef typename _Iterator::difference_type difference_type;\n+      typedef typename _Iterator::pointer pointer;\n+      typedef typename _Iterator::reference reference;\n+    };\n+  template<typename _Tp>\n+    struct iterator_traits<_Tp*>\n+    {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef _Tp& reference;\n+    };\n+  template<typename _Tp>\n+    struct iterator_traits<const _Tp*>\n+    {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef const _Tp* pointer;\n+      typedef const _Tp& reference;\n+    };\n+  template<typename _Iter>\n+    inline typename iterator_traits<_Iter>::iterator_category\n+    __iterator_category(const _Iter&)\n+    { return typename iterator_traits<_Iter>::iterator_category(); }\n+}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::difference_type\n+    __distance(_InputIterator __first, _InputIterator __last,\n+\t       input_iterator_tag)\n+    {\n+\n+      typename iterator_traits<_InputIterator>::difference_type __n = 0;\n+      while (__first != __last)\n+ {\n+   ++__first;\n+   ++__n;\n+ }\n+      return __n;\n+    }\n+  template<typename _RandomAccessIterator>\n+    inline typename iterator_traits<_RandomAccessIterator>::difference_type\n+    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t       random_access_iterator_tag)\n+    {\n+\n+      return __last - __first;\n+    }\n+  template<typename _InputIterator>\n+    inline typename iterator_traits<_InputIterator>::difference_type\n+    distance(_InputIterator __first, _InputIterator __last)\n+    {\n+      return std::__distance(__first, __last,\n+\tstd::__iterator_category(__first));\n+    }\n+  template<typename _InputIterator, typename _Distance>\n+    inline void\n+    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)\n+    {\n+\n+      while (__n--)\n+ ++__i;\n+    }\n+  template<typename _BidirectionalIterator, typename _Distance>\n+    inline void\n+    __advance(_BidirectionalIterator& __i, _Distance __n,\n+       bidirectional_iterator_tag)\n+    {\n+\n+      if (__n > 0)\n+\twhile (__n--)\n+   ++__i;\n+      else\n+\twhile (__n++)\n+   --__i;\n+    }\n+  template<typename _RandomAccessIterator, typename _Distance>\n+    inline void\n+    __advance(_RandomAccessIterator& __i, _Distance __n,\n+\t      random_access_iterator_tag)\n+    {\n+\n+      __i += __n;\n+    }\n+  template<typename _InputIterator, typename _Distance>\n+    inline void\n+    advance(_InputIterator& __i, _Distance __n)\n+    {\n+      typename iterator_traits<_InputIterator>::difference_type __d = __n;\n+      std::__advance(__i, __d, std::__iterator_category(__i));\n+    }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Iterator>\n+    class reverse_iterator\n+    : public iterator<typename iterator_traits<_Iterator>::iterator_category,\n+\ttypename iterator_traits<_Iterator>::value_type,\n+\ttypename iterator_traits<_Iterator>::difference_type,\n+\ttypename iterator_traits<_Iterator>::pointer,\n+\t\t      typename iterator_traits<_Iterator>::reference>\n+    {\n+    protected:\n+      _Iterator current;\n+    public:\n+      typedef _Iterator iterator_type;\n+      typedef typename iterator_traits<_Iterator>::difference_type\n+\t      difference_type;\n+      typedef typename iterator_traits<_Iterator>::reference reference;\n+      typedef typename iterator_traits<_Iterator>::pointer pointer;\n+    public:\n+      reverse_iterator() : current() { }\n+      explicit\n+      reverse_iterator(iterator_type __x) : current(__x) { }\n+      reverse_iterator(const reverse_iterator& __x)\n+      : current(__x.current) { }\n+      template<typename _Iter>\n+\treverse_iterator(const reverse_iterator<_Iter>& __x)\n+ : current(__x.base()) { }\n+      iterator_type\n+      base() const\n+      { return current; }\n+      reference\n+      operator*() const\n+      {\n+ _Iterator __tmp = current;\n+ return *--__tmp;\n+      }\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+      reverse_iterator&\n+      operator++()\n+      {\n+ --current;\n+ return *this;\n+      }\n+      reverse_iterator\n+      operator++(int)\n+      {\n+ reverse_iterator __tmp = *this;\n+ --current;\n+ return __tmp;\n+      }\n+      reverse_iterator&\n+      operator--()\n+      {\n+ ++current;\n+ return *this;\n+      }\n+      reverse_iterator\n+      operator--(int)\n+      {\n+ reverse_iterator __tmp = *this;\n+ ++current;\n+ return __tmp;\n+      }\n+      reverse_iterator\n+      operator+(difference_type __n) const\n+      { return reverse_iterator(current - __n); }\n+      reverse_iterator&\n+      operator+=(difference_type __n)\n+      {\n+ current -= __n;\n+ return *this;\n+      }\n+      reverse_iterator\n+      operator-(difference_type __n) const\n+      { return reverse_iterator(current + __n); }\n+      reverse_iterator&\n+      operator-=(difference_type __n)\n+      {\n+ current += __n;\n+ return *this;\n+      }\n+      reference\n+      operator[](difference_type __n) const\n+      { return *(*this + __n); }\n+    };\n+  template<typename _Iterator>\n+    inline bool\n+    operator==(const reverse_iterator<_Iterator>& __x,\n+\tconst reverse_iterator<_Iterator>& __y)\n+    { return __x.base() == __y.base(); }\n+  template<typename _Iterator>\n+    inline bool\n+    operator<(const reverse_iterator<_Iterator>& __x,\n+       const reverse_iterator<_Iterator>& __y)\n+    { return __y.base() < __x.base(); }\n+  template<typename _Iterator>\n+    inline bool\n+    operator!=(const reverse_iterator<_Iterator>& __x,\n+\tconst reverse_iterator<_Iterator>& __y)\n+    { return !(__x == __y); }\n+  template<typename _Iterator>\n+    inline bool\n+    operator>(const reverse_iterator<_Iterator>& __x,\n+       const reverse_iterator<_Iterator>& __y)\n+    { return __y < __x; }\n+  template<typename _Iterator>\n+    inline bool\n+    operator<=(const reverse_iterator<_Iterator>& __x,\n+\tconst reverse_iterator<_Iterator>& __y)\n+    { return !(__y < __x); }\n+  template<typename _Iterator>\n+    inline bool\n+    operator>=(const reverse_iterator<_Iterator>& __x,\n+\tconst reverse_iterator<_Iterator>& __y)\n+    { return !(__x < __y); }\n+  template<typename _Iterator>\n+    inline typename reverse_iterator<_Iterator>::difference_type\n+    operator-(const reverse_iterator<_Iterator>& __x,\n+       const reverse_iterator<_Iterator>& __y)\n+    { return __y.base() - __x.base(); }\n+  template<typename _Iterator>\n+    inline reverse_iterator<_Iterator>\n+    operator+(typename reverse_iterator<_Iterator>::difference_type __n,\n+       const reverse_iterator<_Iterator>& __x)\n+    { return reverse_iterator<_Iterator>(__x.base() - __n); }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline bool\n+    operator==(const reverse_iterator<_IteratorL>& __x,\n+\tconst reverse_iterator<_IteratorR>& __y)\n+    { return __x.base() == __y.base(); }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline bool\n+    operator<(const reverse_iterator<_IteratorL>& __x,\n+       const reverse_iterator<_IteratorR>& __y)\n+    { return __y.base() < __x.base(); }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline bool\n+    operator!=(const reverse_iterator<_IteratorL>& __x,\n+\tconst reverse_iterator<_IteratorR>& __y)\n+    { return !(__x == __y); }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline bool\n+    operator>(const reverse_iterator<_IteratorL>& __x,\n+       const reverse_iterator<_IteratorR>& __y)\n+    { return __y < __x; }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline bool\n+    operator<=(const reverse_iterator<_IteratorL>& __x,\n+\tconst reverse_iterator<_IteratorR>& __y)\n+    { return !(__y < __x); }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline bool\n+    operator>=(const reverse_iterator<_IteratorL>& __x,\n+\tconst reverse_iterator<_IteratorR>& __y)\n+    { return !(__x < __y); }\n+  template<typename _IteratorL, typename _IteratorR>\n+    inline typename reverse_iterator<_IteratorL>::difference_type\n+    operator-(const reverse_iterator<_IteratorL>& __x,\n+       const reverse_iterator<_IteratorR>& __y)\n+    { return __y.base() - __x.base(); }\n+  template<typename _Container>\n+    class back_insert_iterator\n+    : public iterator<output_iterator_tag, void, void, void, void>\n+    {\n+    protected:\n+      _Container* container;\n+    public:\n+      typedef _Container container_type;\n+      explicit\n+      back_insert_iterator(_Container& __x) : container(&__x) { }\n+      back_insert_iterator&\n+      operator=(typename _Container::const_reference __value)\n+      {\n+ container->push_back(__value);\n+ return *this;\n+      }\n+      back_insert_iterator&\n+      operator*()\n+      { return *this; }\n+      back_insert_iterator&\n+      operator++()\n+      { return *this; }\n+      back_insert_iterator\n+      operator++(int)\n+      { return *this; }\n+    };\n+  template<typename _Container>\n+    inline back_insert_iterator<_Container>\n+    back_inserter(_Container& __x)\n+    { return back_insert_iterator<_Container>(__x); }\n+  template<typename _Container>\n+    class front_insert_iterator\n+    : public iterator<output_iterator_tag, void, void, void, void>\n+    {\n+    protected:\n+      _Container* container;\n+    public:\n+      typedef _Container container_type;\n+      explicit front_insert_iterator(_Container& __x) : container(&__x) { }\n+      front_insert_iterator&\n+      operator=(typename _Container::const_reference __value)\n+      {\n+ container->push_front(__value);\n+ return *this;\n+      }\n+      front_insert_iterator&\n+      operator*()\n+      { return *this; }\n+      front_insert_iterator&\n+      operator++()\n+      { return *this; }\n+      front_insert_iterator\n+      operator++(int)\n+      { return *this; }\n+    };\n+  template<typename _Container>\n+    inline front_insert_iterator<_Container>\n+    front_inserter(_Container& __x)\n+    { return front_insert_iterator<_Container>(__x); }\n+  template<typename _Container>\n+    class insert_iterator\n+    : public iterator<output_iterator_tag, void, void, void, void>\n+    {\n+    protected:\n+      _Container* container;\n+      typename _Container::iterator iter;\n+    public:\n+      typedef _Container container_type;\n+      insert_iterator(_Container& __x, typename _Container::iterator __i)\n+      : container(&__x), iter(__i) {}\n+      insert_iterator&\n+      operator=(typename _Container::const_reference __value)\n+      {\n+ iter = container->insert(iter, __value);\n+ ++iter;\n+ return *this;\n+      }\n+      insert_iterator&\n+      operator*()\n+      { return *this; }\n+      insert_iterator&\n+      operator++()\n+      { return *this; }\n+      insert_iterator&\n+      operator++(int)\n+      { return *this; }\n+    };\n+  template<typename _Container, typename _Iterator>\n+    inline insert_iterator<_Container>\n+    inserter(_Container& __x, _Iterator __i)\n+    {\n+      return insert_iterator<_Container>(__x,\n+      typename _Container::iterator(__i));\n+    }\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  using std::iterator_traits;\n+  using std::iterator;\n+  template<typename _Iterator, typename _Container>\n+    class __normal_iterator\n+    {\n+    protected:\n+      _Iterator _M_current;\n+    public:\n+      typedef _Iterator iterator_type;\n+      typedef typename iterator_traits<_Iterator>::iterator_category\n+\t\t\t\t\t\t\t     iterator_category;\n+      typedef typename iterator_traits<_Iterator>::value_type value_type;\n+      typedef typename iterator_traits<_Iterator>::difference_type\n+\t\t\t\t\t\t\t     difference_type;\n+      typedef typename iterator_traits<_Iterator>::reference reference;\n+      typedef typename iterator_traits<_Iterator>::pointer pointer;\n+      __normal_iterator() : _M_current(_Iterator()) { }\n+      explicit\n+      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }\n+      template<typename _Iter>\n+\t__normal_iterator(const __normal_iterator<_Iter,\n+     typename __enable_if<\n+\t      (std::__are_same<_Iter, typename _Container::pointer>::__value),\n+\t_Container>::__type>& __i)\n+\t: _M_current(__i.base()) { }\n+      reference\n+      operator*() const\n+      { return *_M_current; }\n+      pointer\n+      operator->() const\n+      { return _M_current; }\n+      __normal_iterator&\n+      operator++()\n+      {\n+ ++_M_current;\n+ return *this;\n+      }\n+      __normal_iterator\n+      operator++(int)\n+      { return __normal_iterator(_M_current++); }\n+      __normal_iterator&\n+      operator--()\n+      {\n+ --_M_current;\n+ return *this;\n+      }\n+      __normal_iterator\n+      operator--(int)\n+      { return __normal_iterator(_M_current--); }\n+      reference\n+      operator[](const difference_type& __n) const\n+      { return _M_current[__n]; }\n+      __normal_iterator&\n+      operator+=(const difference_type& __n)\n+      { _M_current += __n; return *this; }\n+      __normal_iterator\n+      operator+(const difference_type& __n) const\n+      { return __normal_iterator(_M_current + __n); }\n+      __normal_iterator&\n+      operator-=(const difference_type& __n)\n+      { _M_current -= __n; return *this; }\n+      __normal_iterator\n+      operator-(const difference_type& __n) const\n+      { return __normal_iterator(_M_current - __n); }\n+      const _Iterator&\n+      base() const\n+      { return _M_current; }\n+    };\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline bool\n+    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\tconst __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() == __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline bool\n+    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\tconst __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() == __rhs.base(); }\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline bool\n+    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\tconst __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() != __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline bool\n+    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\tconst __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() != __rhs.base(); }\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline bool\n+    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() < __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline bool\n+    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,\n+       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() < __rhs.base(); }\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline bool\n+    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() > __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline bool\n+    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,\n+       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() > __rhs.base(); }\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline bool\n+    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\tconst __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() <= __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline bool\n+    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\tconst __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() <= __rhs.base(); }\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline bool\n+    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+\tconst __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() >= __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline bool\n+    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,\n+\tconst __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() >= __rhs.base(); }\n+  template<typename _IteratorL, typename _IteratorR, typename _Container>\n+    inline typename __normal_iterator<_IteratorL, _Container>::difference_type\n+    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n+       const __normal_iterator<_IteratorR, _Container>& __rhs)\n+    { return __lhs.base() - __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline typename __normal_iterator<_Iterator, _Container>::difference_type\n+    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,\n+       const __normal_iterator<_Iterator, _Container>& __rhs)\n+    { return __lhs.base() - __rhs.base(); }\n+  template<typename _Iterator, typename _Container>\n+    inline __normal_iterator<_Iterator, _Container>\n+    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type\n+       __n, const __normal_iterator<_Iterator, _Container>& __i)\n+    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }\n+}\n+namespace std\n+{\n+  namespace __debug { }\n+}\n+namespace __gnu_debug\n+{\n+  using namespace std::__debug;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<bool _BoolType>\n+    struct __iter_swap\n+    {\n+      template<typename _ForwardIterator1, typename _ForwardIterator2>\n+\tstatic void\n+\titer_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n+\t{\n+\t  typedef typename iterator_traits<_ForwardIterator1>::value_type\n+\t    _ValueType1;\n+\t  _ValueType1 __tmp = (*__a);\n+\t  *__a = (*__b);\n+\t  *__b = (__tmp);\n+ }\n+    };\n+  template<>\n+    struct __iter_swap<true>\n+    {\n+      template<typename _ForwardIterator1, typename _ForwardIterator2>\n+\tstatic void\n+\titer_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n+\t{\n+\t  swap(*__a, *__b);\n+\t}\n+    };\n+  template<typename _ForwardIterator1, typename _ForwardIterator2>\n+    inline void\n+    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n+    {\n+      typedef typename iterator_traits<_ForwardIterator1>::value_type\n+ _ValueType1;\n+      typedef typename iterator_traits<_ForwardIterator2>::value_type\n+ _ValueType2;\n+\n+\n+\n+\n+      typedef typename iterator_traits<_ForwardIterator1>::reference\n+ _ReferenceType1;\n+      typedef typename iterator_traits<_ForwardIterator2>::reference\n+ _ReferenceType2;\n+      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value\n+ && __are_same<_ValueType1&, _ReferenceType1>::__value\n+ && __are_same<_ValueType2&, _ReferenceType2>::__value>::\n+ iter_swap(__a, __b);\n+    }\n+  template<typename _ForwardIterator1, typename _ForwardIterator2>\n+    _ForwardIterator2\n+    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+  _ForwardIterator2 __first2)\n+    {\n+\n+\n+      ;\n+      for (; __first1 != __last1; ++__first1, ++__first2)\n+ std::iter_swap(__first1, __first2);\n+      return __first2;\n+    }\n+  template<typename _Tp>\n+    inline const _Tp&\n+    min(const _Tp& __a, const _Tp& __b)\n+    {\n+\n+      if (__b < __a)\n+ return __b;\n+      return __a;\n+    }\n+  template<typename _Tp>\n+    inline const _Tp&\n+    max(const _Tp& __a, const _Tp& __b)\n+    {\n+\n+      if (__a < __b)\n+ return __b;\n+      return __a;\n+    }\n+  template<typename _Tp, typename _Compare>\n+    inline const _Tp&\n+    min(const _Tp& __a, const _Tp& __b, _Compare __comp)\n+    {\n+      if (__comp(__b, __a))\n+ return __b;\n+      return __a;\n+    }\n+  template<typename _Tp, typename _Compare>\n+    inline const _Tp&\n+    max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n+    {\n+      if (__comp(__a, __b))\n+ return __b;\n+      return __a;\n+    }\n+  template<typename _Iterator,\n+    bool _IsNormal = __is_normal_iterator<_Iterator>::__value>\n+    struct __niter_base\n+    {\n+      static _Iterator\n+      __b(_Iterator __it)\n+      { return __it; }\n+    };\n+  template<typename _Iterator>\n+    struct __niter_base<_Iterator, true>\n+    {\n+      static typename _Iterator::iterator_type\n+      __b(_Iterator __it)\n+      { return __it.base(); }\n+    };\n+  template<typename _Iterator,\n+    bool _IsMove = __is_move_iterator<_Iterator>::__value>\n+    struct __miter_base\n+    {\n+      static _Iterator\n+      __b(_Iterator __it)\n+      { return __it; }\n+    };\n+  template<typename _Iterator>\n+    struct __miter_base<_Iterator, true>\n+    {\n+      static typename _Iterator::iterator_type\n+      __b(_Iterator __it)\n+      { return __it.base(); }\n+    };\n+  template<bool, bool, typename>\n+    struct __copy_move\n+    {\n+      template<typename _II, typename _OI>\n+\tstatic _OI\n+\t__copy_m(_II __first, _II __last, _OI __result)\n+\t{\n+   for (; __first != __last; ++__result, ++__first)\n+     *__result = *__first;\n+   return __result;\n+ }\n+    };\n+  template<>\n+    struct __copy_move<false, false, random_access_iterator_tag>\n+    {\n+      template<typename _II, typename _OI>\n+\tstatic _OI\n+\t__copy_m(_II __first, _II __last, _OI __result)\n+\t{\n+   typedef typename iterator_traits<_II>::difference_type _Distance;\n+   for(_Distance __n = __last - __first; __n > 0; --__n)\n+     {\n+       *__result = *__first;\n+       ++__first;\n+       ++__result;\n+     }\n+   return __result;\n+ }\n+    };\n+  template<bool _IsMove>\n+    struct __copy_move<_IsMove, true, random_access_iterator_tag>\n+    {\n+      template<typename _Tp>\n+\tstatic _Tp*\n+\t__copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+\t{\n+   __builtin_memmove(__result, __first,\n+       sizeof(_Tp) * (__last - __first));\n+   return __result + (__last - __first);\n+ }\n+    };\n+  template<bool _IsMove, typename _II, typename _OI>\n+    inline _OI\n+    __copy_move_a(_II __first, _II __last, _OI __result)\n+    {\n+      typedef typename iterator_traits<_II>::value_type _ValueTypeI;\n+      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;\n+      typedef typename iterator_traits<_II>::iterator_category _Category;\n+      const bool __simple = (__is_pod(_ValueTypeI)\n+\t\t      && __is_pointer<_II>::__value\n+\t\t      && __is_pointer<_OI>::__value\n+\t&& __are_same<_ValueTypeI, _ValueTypeO>::__value);\n+      return std::__copy_move<_IsMove, __simple,\n+\t\t       _Category>::__copy_m(__first, __last, __result);\n+    }\n+  template<typename _CharT>\n+    struct char_traits;\n+  template<typename _CharT, typename _Traits>\n+    class istreambuf_iterator;\n+  template<typename _CharT, typename _Traits>\n+    class ostreambuf_iterator;\n+  template<bool _IsMove, typename _CharT>\n+    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n+      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type\n+    __copy_move_a2(_CharT*, _CharT*,\n+     ostreambuf_iterator<_CharT, char_traits<_CharT> >);\n+  template<bool _IsMove, typename _CharT>\n+    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n+      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type\n+    __copy_move_a2(const _CharT*, const _CharT*,\n+     ostreambuf_iterator<_CharT, char_traits<_CharT> >);\n+  template<bool _IsMove, typename _CharT>\n+    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,\n+\t_CharT*>::__type\n+    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,\n+     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);\n+  template<bool _IsMove, typename _II, typename _OI>\n+    inline _OI\n+    __copy_move_a2(_II __first, _II __last, _OI __result)\n+    {\n+      return _OI(std::__copy_move_a<_IsMove>\n+   (std::__niter_base<_II>::__b(__first),\n+    std::__niter_base<_II>::__b(__last),\n+    std::__niter_base<_OI>::__b(__result)));\n+    }\n+  template<typename _II, typename _OI>\n+    inline _OI\n+    copy(_II __first, _II __last, _OI __result)\n+    {\n+\n+\n+      ;\n+      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>\n+       (std::__miter_base<_II>::__b(__first),\n+\tstd::__miter_base<_II>::__b(__last), __result));\n+    }\n+  template<bool, bool, typename>\n+    struct __copy_move_backward\n+    {\n+      template<typename _BI1, typename _BI2>\n+\tstatic _BI2\n+\t__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n+\t{\n+   while (__first != __last)\n+     *--__result = *--__last;\n+   return __result;\n+ }\n+    };\n+  template<>\n+    struct __copy_move_backward<false, false, random_access_iterator_tag>\n+    {\n+      template<typename _BI1, typename _BI2>\n+\tstatic _BI2\n+\t__copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)\n+\t{\n+   typename iterator_traits<_BI1>::difference_type __n;\n+   for (__n = __last - __first; __n > 0; --__n)\n+     *--__result = *--__last;\n+   return __result;\n+ }\n+    };\n+  template<bool _IsMove>\n+    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>\n+    {\n+      template<typename _Tp>\n+\tstatic _Tp*\n+\t__copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+\t{\n+   const ptrdiff_t _Num = __last - __first;\n+   __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n+   return __result - _Num;\n+ }\n+    };\n+  template<bool _IsMove, typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)\n+    {\n+      typedef typename iterator_traits<_BI1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_BI2>::value_type _ValueType2;\n+      typedef typename iterator_traits<_BI1>::iterator_category _Category;\n+      const bool __simple = (__is_pod(_ValueType1)\n+\t\t      && __is_pointer<_BI1>::__value\n+\t\t      && __is_pointer<_BI2>::__value\n+\t&& __are_same<_ValueType1, _ValueType2>::__value);\n+      return std::__copy_move_backward<_IsMove, __simple,\n+\t\t\t\t_Category>::__copy_move_b(__first,\n+\t __last,\n+\t __result);\n+    }\n+  template<bool _IsMove, typename _BI1, typename _BI2>\n+    inline _BI2\n+    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)\n+    {\n+      return _BI2(std::__copy_move_backward_a<_IsMove>\n+    (std::__niter_base<_BI1>::__b(__first),\n+     std::__niter_base<_BI1>::__b(__last),\n+     std::__niter_base<_BI2>::__b(__result)));\n+    }\n+  template<typename _BI1, typename _BI2>\n+    inline _BI2\n+    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n+    {\n+\n+\n+\n+      ;\n+      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>\n+       (std::__miter_base<_BI1>::__b(__first),\n+\tstd::__miter_base<_BI1>::__b(__last), __result));\n+    }\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline typename\n+    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type\n+    __fill_a(_ForwardIterator __first, _ForwardIterator __last,\n+       const _Tp& __value)\n+    {\n+      for (; __first != __last; ++__first)\n+ *__first = __value;\n+    }\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline typename\n+    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type\n+    __fill_a(_ForwardIterator __first, _ForwardIterator __last,\n+      const _Tp& __value)\n+    {\n+      const _Tp __tmp = __value;\n+      for (; __first != __last; ++__first)\n+ *__first = __tmp;\n+    }\n+  template<typename _Tp>\n+    inline typename\n+    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type\n+    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)\n+    {\n+      const _Tp __tmp = __c;\n+      __builtin_memset(__first, static_cast<unsigned char>(__tmp),\n+\t __last - __first);\n+    }\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline void\n+    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n+    {\n+\n+      ;\n+      std::__fill_a(std::__niter_base<_ForwardIterator>::__b(__first),\n+      std::__niter_base<_ForwardIterator>::__b(__last), __value);\n+    }\n+  template<typename _OutputIterator, typename _Size, typename _Tp>\n+    inline typename\n+    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type\n+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)\n+    {\n+      for (; __n > 0; --__n, ++__first)\n+ *__first = __value;\n+      return __first;\n+    }\n+  template<typename _OutputIterator, typename _Size, typename _Tp>\n+    inline typename\n+    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type\n+    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)\n+    {\n+      const _Tp __tmp = __value;\n+      for (; __n > 0; --__n, ++__first)\n+ *__first = __tmp;\n+      return __first;\n+    }\n+  template<typename _Size, typename _Tp>\n+    inline typename\n+    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type\n+    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)\n+    {\n+      std::__fill_a(__first, __first + __n, __c);\n+      return __first + __n;\n+    }\n+  template<typename _OI, typename _Size, typename _Tp>\n+    inline _OI\n+    fill_n(_OI __first, _Size __n, const _Tp& __value)\n+    {\n+\n+      return _OI(std::__fill_n_a(std::__niter_base<_OI>::__b(__first),\n+     __n, __value));\n+    }\n+  template<bool _BoolType>\n+    struct __equal\n+    {\n+      template<typename _II1, typename _II2>\n+\tstatic bool\n+\tequal(_II1 __first1, _II1 __last1, _II2 __first2)\n+\t{\n+   for (; __first1 != __last1; ++__first1, ++__first2)\n+     if (!(*__first1 == *__first2))\n+       return false;\n+   return true;\n+ }\n+    };\n+  template<>\n+    struct __equal<true>\n+    {\n+      template<typename _Tp>\n+\tstatic bool\n+\tequal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)\n+\t{\n+   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)\n+       * (__last1 - __first1));\n+ }\n+    };\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)\n+    {\n+      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n+      const bool __simple = (__is_integer<_ValueType1>::__value\n+\t\t      && __is_pointer<_II1>::__value\n+\t\t      && __is_pointer<_II2>::__value\n+\t&& __are_same<_ValueType1, _ValueType2>::__value);\n+      return std::__equal<__simple>::equal(__first1, __last1, __first2);\n+    }\n+  template<typename, typename>\n+    struct __lc_rai\n+    {\n+      template<typename _II1, typename _II2>\n+\tstatic _II1\n+\t__newlast1(_II1, _II1 __last1, _II2, _II2)\n+\t{ return __last1; }\n+      template<typename _II>\n+\tstatic bool\n+\t__cnd2(_II __first, _II __last)\n+\t{ return __first != __last; }\n+    };\n+  template<>\n+    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>\n+    {\n+      template<typename _RAI1, typename _RAI2>\n+\tstatic _RAI1\n+\t__newlast1(_RAI1 __first1, _RAI1 __last1,\n+     _RAI2 __first2, _RAI2 __last2)\n+\t{\n+   const typename iterator_traits<_RAI1>::difference_type\n+     __diff1 = __last1 - __first1;\n+   const typename iterator_traits<_RAI2>::difference_type\n+     __diff2 = __last2 - __first2;\n+   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;\n+ }\n+      template<typename _RAI>\n+\tstatic bool\n+\t__cnd2(_RAI, _RAI)\n+\t{ return true; }\n+    };\n+  template<bool _BoolType>\n+    struct __lexicographical_compare\n+    {\n+      template<typename _II1, typename _II2>\n+\tstatic bool __lc(_II1, _II1, _II2, _II2);\n+    };\n+  template<bool _BoolType>\n+    template<typename _II1, typename _II2>\n+      bool\n+      __lexicographical_compare<_BoolType>::\n+      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+      {\n+ typedef typename iterator_traits<_II1>::iterator_category _Category1;\n+ typedef typename iterator_traits<_II2>::iterator_category _Category2;\n+ typedef std::__lc_rai<_Category1, _Category2> __rai_type;\n+ __last1 = __rai_type::__newlast1(__first1, __last1,\n+      __first2, __last2);\n+ for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n+      ++__first1, ++__first2)\n+   {\n+     if (*__first1 < *__first2)\n+       return true;\n+     if (*__first2 < *__first1)\n+       return false;\n+   }\n+ return __first1 == __last1 && __first2 != __last2;\n+      }\n+  template<>\n+    struct __lexicographical_compare<true>\n+    {\n+      template<typename _Tp, typename _Up>\n+\tstatic bool\n+\t__lc(const _Tp* __first1, const _Tp* __last1,\n+      const _Up* __first2, const _Up* __last2)\n+ {\n+   const size_t __len1 = __last1 - __first1;\n+   const size_t __len2 = __last2 - __first2;\n+   const int __result = __builtin_memcmp(__first1, __first2,\n+      std::min(__len1, __len2));\n+   return __result != 0 ? __result < 0 : __len1 < __len2;\n+ }\n+    };\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,\n+      _II2 __first2, _II2 __last2)\n+    {\n+      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n+      const bool __simple =\n+ (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value\n+  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed\n+  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed\n+  && __is_pointer<_II1>::__value\n+  && __is_pointer<_II2>::__value);\n+      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,\n+\t   __first2, __last2);\n+    }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    equal(_II1 __first1, _II1 __last1, _II2 __first2)\n+    {\n+\n+\n+\n+      ;\n+      return std::__equal_aux(std::__niter_base<_II1>::__b(__first1),\n+\t std::__niter_base<_II1>::__b(__last1),\n+\t std::__niter_base<_II2>::__b(__first2));\n+    }\n+  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n+    inline bool\n+    equal(_IIter1 __first1, _IIter1 __last1,\n+   _IIter2 __first2, _BinaryPredicate __binary_pred)\n+    {\n+\n+\n+      ;\n+      for (; __first1 != __last1; ++__first1, ++__first2)\n+ if (!bool(__binary_pred(*__first1, *__first2)))\n+   return false;\n+      return true;\n+    }\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    lexicographical_compare(_II1 __first1, _II1 __last1,\n+       _II2 __first2, _II2 __last2)\n+    {\n+      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n+\n+\n+\n+\n+      ;\n+      ;\n+      return std::__lexicographical_compare_aux\n+ (std::__niter_base<_II1>::__b(__first1),\n+  std::__niter_base<_II1>::__b(__last1),\n+  std::__niter_base<_II2>::__b(__first2),\n+  std::__niter_base<_II2>::__b(__last2));\n+    }\n+  template<typename _II1, typename _II2, typename _Compare>\n+    bool\n+    lexicographical_compare(_II1 __first1, _II1 __last1,\n+       _II2 __first2, _II2 __last2, _Compare __comp)\n+    {\n+      typedef typename iterator_traits<_II1>::iterator_category _Category1;\n+      typedef typename iterator_traits<_II2>::iterator_category _Category2;\n+      typedef std::__lc_rai<_Category1, _Category2> __rai_type;\n+\n+\n+      ;\n+      ;\n+      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);\n+      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n+    ++__first1, ++__first2)\n+ {\n+   if (__comp(*__first1, *__first2))\n+     return true;\n+   if (__comp(*__first2, *__first1))\n+     return false;\n+ }\n+      return __first1 == __last1 && __first2 != __last2;\n+    }\n+  template<typename _InputIterator1, typename _InputIterator2>\n+    pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+      _InputIterator2 __first2)\n+    {\n+\n+\n+\n+      ;\n+      while (__first1 != __last1 && *__first1 == *__first2)\n+\t{\n+   ++__first1;\n+   ++__first2;\n+\t}\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+    }\n+  template<typename _InputIterator1, typename _InputIterator2,\n+    typename _BinaryPredicate>\n+    pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+      _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n+    {\n+\n+\n+      ;\n+      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))\n+\t{\n+   ++__first1;\n+   ++__first2;\n+\t}\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+    }\n+}\n+\n+extern \"C++\" {\n+namespace std\n+{\n+  class exception\n+  {\n+  public:\n+    exception() throw() { }\n+    virtual ~exception() throw();\n+    virtual const char* what() const throw();\n+  };\n+  class bad_exception : public exception\n+  {\n+  public:\n+    bad_exception() throw() { }\n+    virtual ~bad_exception() throw();\n+    virtual const char* what() const throw();\n+  };\n+  typedef void (*terminate_handler) ();\n+  typedef void (*unexpected_handler) ();\n+  terminate_handler set_terminate(terminate_handler) throw();\n+  void terminate() __attribute__ ((__noreturn__));\n+  unexpected_handler set_unexpected(unexpected_handler) throw();\n+  void unexpected() __attribute__ ((__noreturn__));\n+  bool uncaught_exception() throw();\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  void __verbose_terminate_handler();\n+}\n+}\n+extern \"C++\" {\n+namespace std\n+{\n+  class bad_alloc : public exception\n+  {\n+  public:\n+    bad_alloc() throw() { }\n+    virtual ~bad_alloc() throw();\n+    virtual const char* what() const throw();\n+  };\n+  struct nothrow_t { };\n+  extern const nothrow_t nothrow;\n+  typedef void (*new_handler)();\n+  new_handler set_new_handler(new_handler) throw();\n+}\n+void* operator new(std::size_t) throw (std::bad_alloc);\n+void* operator new[](std::size_t) throw (std::bad_alloc);\n+void operator delete(void*) throw();\n+void operator delete[](void*) throw();\n+void* operator new(std::size_t, const std::nothrow_t&) throw();\n+void* operator new[](std::size_t, const std::nothrow_t&) throw();\n+void operator delete(void*, const std::nothrow_t&) throw();\n+void operator delete[](void*, const std::nothrow_t&) throw();\n+inline void* operator new(std::size_t, void* __p) throw() { return __p; }\n+inline void* operator new[](std::size_t, void* __p) throw() { return __p; }\n+inline void operator delete (void*, void*) throw() { }\n+inline void operator delete[](void*, void*) throw() { }\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  template<typename _Tp>\n+    class new_allocator\n+    {\n+    public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp& reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp value_type;\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef new_allocator<_Tp1> other; };\n+      new_allocator() throw() { }\n+      new_allocator(const new_allocator&) throw() { }\n+      template<typename _Tp1>\n+\tnew_allocator(const new_allocator<_Tp1>&) throw() { }\n+      ~new_allocator() throw() { }\n+      pointer\n+      address(reference __x) const { return &__x; }\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+      pointer\n+      allocate(size_type __n, const void* = 0)\n+      {\n+ if (__builtin_expect(__n > this->max_size(), false))\n+   std::__throw_bad_alloc();\n+ return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n+      }\n+      void\n+      deallocate(pointer __p, size_type)\n+      { ::operator delete(__p); }\n+      size_type\n+      max_size() const throw()\n+      { return size_t(-1) / sizeof(_Tp); }\n+      void\n+      construct(pointer __p, const _Tp& __val)\n+      { ::new((void *)__p) _Tp(__val); }\n+      void\n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\n+    { return true; }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\n+    { return false; }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp>\n+    class allocator;\n+  template<>\n+    class allocator<void>\n+    {\n+    public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef void* pointer;\n+      typedef const void* const_pointer;\n+      typedef void value_type;\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef allocator<_Tp1> other; };\n+    };\n+  template<typename _Tp>\n+    class allocator: public __gnu_cxx::new_allocator<_Tp>\n+    {\n+   public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp& reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp value_type;\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef allocator<_Tp1> other; };\n+      allocator() throw() { }\n+      allocator(const allocator& __a) throw()\n+      : __gnu_cxx::new_allocator<_Tp>(__a) { }\n+      template<typename _Tp1>\n+\tallocator(const allocator<_Tp1>&) throw() { }\n+      ~allocator() throw() { }\n+    };\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator==(const allocator<_T1>&, const allocator<_T2>&)\n+    { return true; }\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const allocator<_Tp>&, const allocator<_Tp>&)\n+    { return true; }\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator!=(const allocator<_T1>&, const allocator<_T2>&)\n+    { return false; }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)\n+    { return false; }\n+  extern template class allocator<char>;\n+  extern template class allocator<wchar_t>;\n+  template<typename _Alloc, bool = __is_empty(_Alloc)>\n+    struct __alloc_swap\n+    { static void _S_do_it(_Alloc&, _Alloc&) { } };\n+  template<typename _Alloc>\n+    struct __alloc_swap<_Alloc, false>\n+    {\n+      static void\n+      _S_do_it(_Alloc& __one, _Alloc& __two)\n+      {\n+ if (__one != __two)\n+   swap(__one, __two);\n+      }\n+    };\n+  template<typename _Alloc, bool = __is_empty(_Alloc)>\n+    struct __alloc_neq\n+    {\n+      static bool\n+      _S_do_it(const _Alloc&, const _Alloc&)\n+      { return false; }\n+    };\n+  template<typename _Alloc>\n+    struct __alloc_neq<_Alloc, false>\n+    {\n+      static bool\n+      _S_do_it(const _Alloc& __one, const _Alloc& __two)\n+      { return __one != __two; }\n+    };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  struct _List_node_base\n+  {\n+    _List_node_base* _M_next;\n+    _List_node_base* _M_prev;\n+    static void\n+    swap(_List_node_base& __x, _List_node_base& __y);\n+    void\n+    transfer(_List_node_base * const __first,\n+      _List_node_base * const __last);\n+    void\n+    reverse();\n+    void\n+    hook(_List_node_base * const __position);\n+    void\n+    unhook();\n+  };\n+  template<typename _Tp>\n+    struct _List_node : public _List_node_base\n+    {\n+      _Tp _M_data;\n+    };\n+  template<typename _Tp>\n+    struct _List_iterator\n+    {\n+      typedef _List_iterator<_Tp> _Self;\n+      typedef _List_node<_Tp> _Node;\n+      typedef ptrdiff_t difference_type;\n+      typedef std::bidirectional_iterator_tag iterator_category;\n+      typedef _Tp value_type;\n+      typedef _Tp* pointer;\n+      typedef _Tp& reference;\n+      _List_iterator()\n+      : _M_node() { }\n+      explicit\n+      _List_iterator(_List_node_base* __x)\n+      : _M_node(__x) { }\n+      reference\n+      operator*() const\n+      { return static_cast<_Node*>(_M_node)->_M_data; }\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Node*>(_M_node)->_M_data; }\n+      _Self&\n+      operator++()\n+      {\n+ _M_node = _M_node->_M_next;\n+ return *this;\n+      }\n+      _Self\n+      operator++(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _M_node->_M_next;\n+ return __tmp;\n+      }\n+      _Self&\n+      operator--()\n+      {\n+ _M_node = _M_node->_M_prev;\n+ return *this;\n+      }\n+      _Self\n+      operator--(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _M_node->_M_prev;\n+ return __tmp;\n+      }\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+      _List_node_base* _M_node;\n+    };\n+  template<typename _Tp>\n+    struct _List_const_iterator\n+    {\n+      typedef _List_const_iterator<_Tp> _Self;\n+      typedef const _List_node<_Tp> _Node;\n+      typedef _List_iterator<_Tp> iterator;\n+      typedef ptrdiff_t difference_type;\n+      typedef std::bidirectional_iterator_tag iterator_category;\n+      typedef _Tp value_type;\n+      typedef const _Tp* pointer;\n+      typedef const _Tp& reference;\n+      _List_const_iterator()\n+      : _M_node() { }\n+      explicit\n+      _List_const_iterator(const _List_node_base* __x)\n+      : _M_node(__x) { }\n+      _List_const_iterator(const iterator& __x)\n+      : _M_node(__x._M_node) { }\n+      reference\n+      operator*() const\n+      { return static_cast<_Node*>(_M_node)->_M_data; }\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Node*>(_M_node)->_M_data; }\n+      _Self&\n+      operator++()\n+      {\n+ _M_node = _M_node->_M_next;\n+ return *this;\n+      }\n+      _Self\n+      operator++(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _M_node->_M_next;\n+ return __tmp;\n+      }\n+      _Self&\n+      operator--()\n+      {\n+ _M_node = _M_node->_M_prev;\n+ return *this;\n+      }\n+      _Self\n+      operator--(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _M_node->_M_prev;\n+ return __tmp;\n+      }\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+      const _List_node_base* _M_node;\n+    };\n+  template<typename _Val>\n+    inline bool\n+    operator==(const _List_iterator<_Val>& __x,\n+\tconst _List_const_iterator<_Val>& __y)\n+    { return __x._M_node == __y._M_node; }\n+  template<typename _Val>\n+    inline bool\n+    operator!=(const _List_iterator<_Val>& __x,\n+\t       const _List_const_iterator<_Val>& __y)\n+    { return __x._M_node != __y._M_node; }\n+  template<typename _Tp, typename _Alloc>\n+    class _List_base\n+    {\n+    protected:\n+      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other\n+\t_Node_alloc_type;\n+      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n+      struct _List_impl\n+      : public _Node_alloc_type\n+      {\n+ _List_node_base _M_node;\n+ _List_impl()\n+ : _Node_alloc_type(), _M_node()\n+ { }\n+ _List_impl(const _Node_alloc_type& __a)\n+ : _Node_alloc_type(__a), _M_node()\n+ { }\n+      };\n+      _List_impl _M_impl;\n+      _List_node<_Tp>*\n+      _M_get_node()\n+      { return _M_impl._Node_alloc_type::allocate(1); }\n+      void\n+      _M_put_node(_List_node<_Tp>* __p)\n+      { _M_impl._Node_alloc_type::deallocate(__p, 1); }\n+  public:\n+      typedef _Alloc allocator_type;\n+      _Node_alloc_type&\n+      _M_get_Node_allocator()\n+      { return *static_cast<_Node_alloc_type*>(&this->_M_impl); }\n+      const _Node_alloc_type&\n+      _M_get_Node_allocator() const\n+      { return *static_cast<const _Node_alloc_type*>(&this->_M_impl); }\n+      _Tp_alloc_type\n+      _M_get_Tp_allocator() const\n+      { return _Tp_alloc_type(_M_get_Node_allocator()); }\n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(_M_get_Node_allocator()); }\n+      _List_base()\n+      : _M_impl()\n+      { _M_init(); }\n+      _List_base(const allocator_type& __a)\n+      : _M_impl(__a)\n+      { _M_init(); }\n+      ~_List_base()\n+      { _M_clear(); }\n+      void\n+      _M_clear();\n+      void\n+      _M_init()\n+      {\n+\tthis->_M_impl._M_node._M_next = &this->_M_impl._M_node;\n+\tthis->_M_impl._M_node._M_prev = &this->_M_impl._M_node;\n+      }\n+    };\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n+    class list : protected _List_base<_Tp, _Alloc>\n+    {\n+      typedef typename _Alloc::value_type _Alloc_value_type;\n+\n+\n+      typedef _List_base<_Tp, _Alloc> _Base;\n+      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;\n+    public:\n+      typedef _Tp value_type;\n+      typedef typename _Tp_alloc_type::pointer pointer;\n+      typedef typename _Tp_alloc_type::const_pointer const_pointer;\n+      typedef typename _Tp_alloc_type::reference reference;\n+      typedef typename _Tp_alloc_type::const_reference const_reference;\n+      typedef _List_iterator<_Tp> iterator;\n+      typedef _List_const_iterator<_Tp> const_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      typedef std::reverse_iterator<iterator> reverse_iterator;\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Alloc allocator_type;\n+    protected:\n+      typedef _List_node<_Tp> _Node;\n+      using _Base::_M_impl;\n+      using _Base::_M_put_node;\n+      using _Base::_M_get_node;\n+      using _Base::_M_get_Tp_allocator;\n+      using _Base::_M_get_Node_allocator;\n+      _Node*\n+      _M_create_node(const value_type& __x)\n+      {\n+ _Node* __p = this->_M_get_node();\n+ try\n+   {\n+     _M_get_Tp_allocator().construct(&__p->_M_data, __x);\n+   }\n+ catch(...)\n+   {\n+     _M_put_node(__p);\n+     throw;\n+   }\n+ return __p;\n+      }\n+    public:\n+      list()\n+      : _Base() { }\n+      explicit\n+      list(const allocator_type& __a)\n+      : _Base(__a) { }\n+      explicit\n+      list(size_type __n, const value_type& __value = value_type(),\n+    const allocator_type& __a = allocator_type())\n+      : _Base(__a)\n+      { _M_fill_initialize(__n, __value); }\n+      list(const list& __x)\n+      : _Base(__x._M_get_Node_allocator())\n+      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }\n+      template<typename _InputIterator>\n+\tlist(_InputIterator __first, _InputIterator __last,\n+      const allocator_type& __a = allocator_type())\n+\t: _Base(__a)\n+\t{\n+   typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+   _M_initialize_dispatch(__first, __last, _Integral());\n+ }\n+      list&\n+      operator=(const list& __x);\n+      void\n+      assign(size_type __n, const value_type& __val)\n+      { _M_fill_assign(__n, __val); }\n+      template<typename _InputIterator>\n+\tvoid\n+\tassign(_InputIterator __first, _InputIterator __last)\n+\t{\n+   typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+   _M_assign_dispatch(__first, __last, _Integral());\n+ }\n+      allocator_type\n+      get_allocator() const\n+      { return _Base::get_allocator(); }\n+      iterator\n+      begin()\n+      { return iterator(this->_M_impl._M_node._M_next); }\n+      const_iterator\n+      begin() const\n+      { return const_iterator(this->_M_impl._M_node._M_next); }\n+      iterator\n+      end()\n+      { return iterator(&this->_M_impl._M_node); }\n+      const_iterator\n+      end() const\n+      { return const_iterator(&this->_M_impl._M_node); }\n+      reverse_iterator\n+      rbegin()\n+      { return reverse_iterator(end()); }\n+      const_reverse_iterator\n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+      reverse_iterator\n+      rend()\n+      { return reverse_iterator(begin()); }\n+      const_reverse_iterator\n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+      bool\n+      empty() const\n+      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }\n+      size_type\n+      size() const\n+      { return std::distance(begin(), end()); }\n+      size_type\n+      max_size() const\n+      { return _M_get_Node_allocator().max_size(); }\n+      void\n+      resize(size_type __new_size, value_type __x = value_type());\n+      reference\n+      front()\n+      { return *begin(); }\n+      const_reference\n+      front() const\n+      { return *begin(); }\n+      reference\n+      back()\n+      {\n+ iterator __tmp = end();\n+ --__tmp;\n+ return *__tmp;\n+      }\n+      const_reference\n+      back() const\n+      {\n+ const_iterator __tmp = end();\n+ --__tmp;\n+ return *__tmp;\n+      }\n+      void\n+      push_front(const value_type& __x)\n+      { this->_M_insert(begin(), __x); }\n+      void\n+      pop_front()\n+      { this->_M_erase(begin()); }\n+      void\n+      push_back(const value_type& __x)\n+      { this->_M_insert(end(), __x); }\n+      void\n+      pop_back()\n+      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }\n+      iterator\n+      insert(iterator __position, const value_type& __x);\n+      void\n+      insert(iterator __position, size_type __n, const value_type& __x)\n+      {\n+ list __tmp(__n, __x, _M_get_Node_allocator());\n+ splice(__position, __tmp);\n+      }\n+      template<typename _InputIterator>\n+\tvoid\n+\tinsert(iterator __position, _InputIterator __first,\n+\t_InputIterator __last)\n+\t{\n+   list __tmp(__first, __last, _M_get_Node_allocator());\n+   splice(__position, __tmp);\n+ }\n+      iterator\n+      erase(iterator __position);\n+      iterator\n+      erase(iterator __first, iterator __last)\n+      {\n+ while (__first != __last)\n+   __first = erase(__first);\n+ return __last;\n+      }\n+      void\n+      swap(list& __x)\n+      {\n+ _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);\n+ std::__alloc_swap<typename _Base::_Node_alloc_type>::\n+   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());\n+      }\n+      void\n+      clear()\n+      {\n+\t_Base::_M_clear();\n+\t_Base::_M_init();\n+      }\n+      void\n+      splice(iterator __position, list& __x)\n+      {\n+ if (!__x.empty())\n+   {\n+     _M_check_equal_allocators(__x);\n+     this->_M_transfer(__position, __x.begin(), __x.end());\n+   }\n+      }\n+      void\n+      splice(iterator __position, list& __x, iterator __i)\n+      {\n+ iterator __j = __i;\n+ ++__j;\n+ if (__position == __i || __position == __j)\n+   return;\n+ if (this != &__x)\n+   _M_check_equal_allocators(__x);\n+ this->_M_transfer(__position, __i, __j);\n+      }\n+      void\n+      splice(iterator __position, list& __x, iterator __first,\n+      iterator __last)\n+      {\n+ if (__first != __last)\n+   {\n+     if (this != &__x)\n+       _M_check_equal_allocators(__x);\n+     this->_M_transfer(__position, __first, __last);\n+   }\n+      }\n+      void\n+      remove(const _Tp& __value);\n+      template<typename _Predicate>\n+\tvoid\n+\tremove_if(_Predicate);\n+      void\n+      unique();\n+      template<typename _BinaryPredicate>\n+\tvoid\n+\tunique(_BinaryPredicate);\n+      void\n+      merge(list& __x);\n+      template<typename _StrictWeakOrdering>\n+\tvoid\n+\tmerge(list&, _StrictWeakOrdering);\n+      void\n+      reverse()\n+      { this->_M_impl._M_node.reverse(); }\n+      void\n+      sort();\n+      template<typename _StrictWeakOrdering>\n+\tvoid\n+\tsort(_StrictWeakOrdering);\n+    protected:\n+      template<typename _Integer>\n+\tvoid\n+\t_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+\t{ _M_fill_initialize(static_cast<size_type>(__n), __x); }\n+      template<typename _InputIterator>\n+\tvoid\n+\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+\t  __false_type)\n+\t{\n+   for (; __first != __last; ++__first)\n+     push_back(*__first);\n+ }\n+      void\n+      _M_fill_initialize(size_type __n, const value_type& __x)\n+      {\n+ for (; __n > 0; --__n)\n+   push_back(__x);\n+      }\n+      template<typename _Integer>\n+\tvoid\n+\t_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n+\t{ _M_fill_assign(__n, __val); }\n+      template<typename _InputIterator>\n+\tvoid\n+\t_M_assign_dispatch(_InputIterator __first, _InputIterator __last,\n+      __false_type);\n+      void\n+      _M_fill_assign(size_type __n, const value_type& __val);\n+      void\n+      _M_transfer(iterator __position, iterator __first, iterator __last)\n+      { __position._M_node->transfer(__first._M_node, __last._M_node); }\n+      void\n+      _M_insert(iterator __position, const value_type& __x)\n+      {\n+\t_Node* __tmp = _M_create_node(__x);\n+\t__tmp->hook(__position._M_node);\n+      }\n+      void\n+      _M_erase(iterator __position)\n+      {\n+\t__position._M_node->unhook();\n+\t_Node* __n = static_cast<_Node*>(__position._M_node);\n+ _M_get_Tp_allocator().destroy(&__n->_M_data);\n+\t_M_put_node(__n);\n+      }\n+      void\n+      _M_check_equal_allocators(list& __x)\n+      {\n+ if (std::__alloc_neq<typename _Base::_Node_alloc_type>::\n+     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))\n+   __throw_runtime_error((\"list::_M_check_equal_allocators\"));\n+      }\n+    };\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    {\n+      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;\n+      const_iterator __end1 = __x.end();\n+      const_iterator __end2 = __y.end();\n+      const_iterator __i1 = __x.begin();\n+      const_iterator __i2 = __y.begin();\n+      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)\n+ {\n+   ++__i1;\n+   ++__i2;\n+ }\n+      return __i1 == __end1 && __i2 == __end2;\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    { return std::lexicographical_compare(__x.begin(), __x.end(),\n+       __y.begin(), __y.end()); }\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    { return !(__x == __y); }\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    { return __y < __x; }\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    { return !(__y < __x); }\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n+    { return !(__x < __y); }\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n+    { __x.swap(__y); }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    _List_base<_Tp, _Alloc>::\n+    _M_clear()\n+    {\n+      typedef _List_node<_Tp> _Node;\n+      _Node* __cur = static_cast<_Node*>(this->_M_impl._M_node._M_next);\n+      while (__cur != &this->_M_impl._M_node)\n+ {\n+   _Node* __tmp = __cur;\n+   __cur = static_cast<_Node*>(__cur->_M_next);\n+   _M_get_Tp_allocator().destroy(&__tmp->_M_data);\n+   _M_put_node(__tmp);\n+ }\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    typename list<_Tp, _Alloc>::iterator\n+    list<_Tp, _Alloc>::\n+    insert(iterator __position, const value_type& __x)\n+    {\n+      _Node* __tmp = _M_create_node(__x);\n+      __tmp->hook(__position._M_node);\n+      return iterator(__tmp);\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    typename list<_Tp, _Alloc>::iterator\n+    list<_Tp, _Alloc>::\n+    erase(iterator __position)\n+    {\n+      iterator __ret = iterator(__position._M_node->_M_next);\n+      _M_erase(__position);\n+      return __ret;\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp, _Alloc>::\n+    resize(size_type __new_size, value_type __x)\n+    {\n+      iterator __i = begin();\n+      size_type __len = 0;\n+      for (; __i != end() && __len < __new_size; ++__i, ++__len)\n+\t;\n+      if (__len == __new_size)\n+\terase(__i, end());\n+      else\n+\tinsert(end(), __new_size - __len, __x);\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    list<_Tp, _Alloc>&\n+    list<_Tp, _Alloc>::\n+    operator=(const list& __x)\n+    {\n+      if (this != &__x)\n+ {\n+   iterator __first1 = begin();\n+   iterator __last1 = end();\n+   const_iterator __first2 = __x.begin();\n+   const_iterator __last2 = __x.end();\n+   for (; __first1 != __last1 && __first2 != __last2;\n+\t++__first1, ++__first2)\n+     *__first1 = *__first2;\n+   if (__first2 == __last2)\n+     erase(__first1, __last1);\n+   else\n+     insert(__last1, __first2, __last2);\n+ }\n+      return *this;\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp, _Alloc>::\n+    _M_fill_assign(size_type __n, const value_type& __val)\n+    {\n+      iterator __i = begin();\n+      for (; __i != end() && __n > 0; ++__i, --__n)\n+\t*__i = __val;\n+      if (__n > 0)\n+\tinsert(end(), __n, __val);\n+      else\n+\terase(__i, end());\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _InputIterator>\n+      void\n+      list<_Tp, _Alloc>::\n+      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,\n+    __false_type)\n+      {\n+\titerator __first1 = begin();\n+\titerator __last1 = end();\n+\tfor (; __first1 != __last1 && __first2 != __last2;\n+      ++__first1, ++__first2)\n+\t  *__first1 = *__first2;\n+\tif (__first2 == __last2)\n+\t  erase(__first1, __last1);\n+\telse\n+\t  insert(__last1, __first2, __last2);\n+      }\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp, _Alloc>::\n+    remove(const value_type& __value)\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      iterator __extra = __last;\n+      while (__first != __last)\n+ {\n+   iterator __next = __first;\n+   ++__next;\n+   if (*__first == __value)\n+     {\n+       if (&*__first != &__value)\n+  _M_erase(__first);\n+       else\n+  __extra = __first;\n+     }\n+   __first = __next;\n+ }\n+      if (__extra != __last)\n+ _M_erase(__extra);\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp, _Alloc>::\n+    unique()\n+    {\n+      iterator __first = begin();\n+      iterator __last = end();\n+      if (__first == __last)\n+ return;\n+      iterator __next = __first;\n+      while (++__next != __last)\n+ {\n+   if (*__first == *__next)\n+     _M_erase(__next);\n+   else\n+     __first = __next;\n+   __next = __first;\n+ }\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp, _Alloc>::\n+    merge(list& __x)\n+    {\n+      if (this != &__x)\n+ {\n+   _M_check_equal_allocators(__x);\n+   iterator __first1 = begin();\n+   iterator __last1 = end();\n+   iterator __first2 = __x.begin();\n+   iterator __last2 = __x.end();\n+   while (__first1 != __last1 && __first2 != __last2)\n+     if (*__first2 < *__first1)\n+       {\n+  iterator __next = __first2;\n+  _M_transfer(__first1, __first2, ++__next);\n+  __first2 = __next;\n+       }\n+     else\n+       ++__first1;\n+   if (__first2 != __last2)\n+     _M_transfer(__last1, __first2, __last2);\n+ }\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+      void\n+      list<_Tp, _Alloc>::\n+      merge(list& __x, _StrictWeakOrdering __comp)\n+      {\n+ if (this != &__x)\n+   {\n+     _M_check_equal_allocators(__x);\n+     iterator __first1 = begin();\n+     iterator __last1 = end();\n+     iterator __first2 = __x.begin();\n+     iterator __last2 = __x.end();\n+     while (__first1 != __last1 && __first2 != __last2)\n+       if (__comp(*__first2, *__first1))\n+  {\n+    iterator __next = __first2;\n+    _M_transfer(__first1, __first2, ++__next);\n+    __first2 = __next;\n+  }\n+       else\n+  ++__first1;\n+     if (__first2 != __last2)\n+       _M_transfer(__last1, __first2, __last2);\n+   }\n+      }\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    list<_Tp, _Alloc>::\n+    sort()\n+    {\n+      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node\n+   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)\n+      {\n+\tlist __carry;\n+\tlist __tmp[64];\n+\tlist * __fill = &__tmp[0];\n+\tlist * __counter;\n+\tdo\n+   {\n+     __carry.splice(__carry.begin(), *this, begin());\n+     for(__counter = &__tmp[0];\n+  __counter != __fill && !__counter->empty();\n+  ++__counter)\n+       {\n+  __counter->merge(__carry);\n+  __carry.swap(*__counter);\n+       }\n+     __carry.swap(*__counter);\n+     if (__counter == __fill)\n+       ++__fill;\n+   }\n+ while ( !empty() );\n+\tfor (__counter = &__tmp[1]; __counter != __fill; ++__counter)\n+\t  __counter->merge(*(__counter - 1));\n+\tswap( *(__fill - 1) );\n+      }\n+    }\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _Predicate>\n+      void\n+      list<_Tp, _Alloc>::\n+      remove_if(_Predicate __pred)\n+      {\n+\titerator __first = begin();\n+\titerator __last = end();\n+\twhile (__first != __last)\n+   {\n+     iterator __next = __first;\n+     ++__next;\n+     if (__pred(*__first))\n+       _M_erase(__first);\n+     __first = __next;\n+   }\n+      }\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _BinaryPredicate>\n+      void\n+      list<_Tp, _Alloc>::\n+      unique(_BinaryPredicate __binary_pred)\n+      {\n+\titerator __first = begin();\n+\titerator __last = end();\n+\tif (__first == __last)\n+   return;\n+\titerator __next = __first;\n+\twhile (++__next != __last)\n+   {\n+     if (__binary_pred(*__first, *__next))\n+       _M_erase(__next);\n+     else\n+       __first = __next;\n+     __next = __first;\n+   }\n+      }\n+  template<typename _Tp, typename _Alloc>\n+    template <typename _StrictWeakOrdering>\n+      void\n+      list<_Tp, _Alloc>::\n+      sort(_StrictWeakOrdering __comp)\n+      {\n+ if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node\n+     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)\n+   {\n+     list __carry;\n+     list __tmp[64];\n+     list * __fill = &__tmp[0];\n+     list * __counter;\n+     do\n+       {\n+  __carry.splice(__carry.begin(), *this, begin());\n+  for(__counter = &__tmp[0];\n+      __counter != __fill && !__counter->empty();\n+      ++__counter)\n+    {\n+      __counter->merge(__carry, __comp);\n+      __carry.swap(*__counter);\n+    }\n+  __carry.swap(*__counter);\n+  if (__counter == __fill)\n+    ++__fill;\n+       }\n+     while ( !empty() );\n+     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)\n+       __counter->merge(*(__counter - 1), __comp);\n+     swap(*(__fill - 1));\n+   }\n+      }\n+}\n+extern void foobarit(void);\n+class Game\n+{\n+public:\n+\tstruct BuildProject\n+\t{\n+\t\tint posX;\n+\t};\n+\tstd::list<BuildProject> buildProjects;\n+};\n+static Game game;\n+static std::list<std::list<Game::BuildProject>::iterator>\n+erasableBuildProjects;\n+void *buildProjectSyncStepConcurrently(int id, int localTeam)\n+{\n+\t__transaction_relaxed {\n+\t\tstd::list<std::list<Game::BuildProject>::iterator>::iterator it\n+= erasableBuildProjects.begin();\n+\t\tfoobarit();\n+\t\tgame.buildProjects.erase( (std::list<Game::BuildProject>\n+::iterator) *it);\n+\t}\n+\treturn 0;\n+}\n+"}, {"sha": "9431615b0fb31af5ed717e1b9d1849fc3273ef5e", "filename": "gcc/testsuite/g++.dg/tm/pr46646.C", "status": "added", "additions": 890, "deletions": 0, "changes": 890, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46646.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46646.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46646.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,890 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O0\"}\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<class _T1, class _T2>\n+    struct pair\n+    {\n+      typedef _T1 first_type;\n+      typedef _T2 second_type;\n+      _T1 first;\n+      _T2 second;\n+      pair()\n+      : first(), second() { }\n+      pair(const _T1& __a, const _T2& __b)\n+      : first(__a), second(__b) { }\n+    };\n+}\n+\n+\n+typedef long int ptrdiff_t;\n+typedef __SIZE_TYPE__ size_t;\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  using ::ptrdiff_t;\n+  using ::size_t;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  struct input_iterator_tag { };\n+  struct output_iterator_tag { };\n+  struct forward_iterator_tag : public input_iterator_tag { };\n+  struct bidirectional_iterator_tag : public forward_iterator_tag { };\n+  struct random_access_iterator_tag : public bidirectional_iterator_tag { };\n+  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,\n+\t   typename _Pointer = _Tp*, typename _Reference = _Tp&>\n+    struct iterator\n+    {\n+      typedef _Category iterator_category;\n+      typedef _Tp value_type;\n+      typedef _Distance difference_type;\n+      typedef _Pointer pointer;\n+      typedef _Reference reference;\n+    };\n+  template<typename _Iterator>\n+    struct iterator_traits\n+    {\n+      typedef typename _Iterator::iterator_category iterator_category;\n+      typedef typename _Iterator::value_type value_type;\n+      typedef typename _Iterator::difference_type difference_type;\n+      typedef typename _Iterator::pointer pointer;\n+      typedef typename _Iterator::reference reference;\n+    };\n+  template<typename _Tp>\n+    struct iterator_traits<_Tp*>\n+    {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef _Tp& reference;\n+    };\n+  template<typename _Tp>\n+    struct iterator_traits<const _Tp*>\n+    {\n+      typedef random_access_iterator_tag iterator_category;\n+      typedef _Tp value_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef const _Tp* pointer;\n+      typedef const _Tp& reference;\n+    };\n+  template<typename _Iter>\n+    inline typename iterator_traits<_Iter>::iterator_category\n+    __iterator_category(const _Iter&)\n+    { return typename iterator_traits<_Iter>::iterator_category(); }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Iterator>\n+    class reverse_iterator\n+    : public iterator<typename iterator_traits<_Iterator>::iterator_category,\n+\ttypename iterator_traits<_Iterator>::value_type,\n+\ttypename iterator_traits<_Iterator>::difference_type,\n+\ttypename iterator_traits<_Iterator>::pointer,\n+\t\t      typename iterator_traits<_Iterator>::reference>\n+    {\n+    protected:\n+      _Iterator current;\n+      typedef iterator_traits<_Iterator> __traits_type;\n+    public:\n+      typedef _Iterator iterator_type;\n+      typedef typename __traits_type::difference_type difference_type;\n+      typedef typename __traits_type::pointer pointer;\n+      typedef typename __traits_type::reference reference;\n+      reverse_iterator() : current() { }\n+      explicit\n+      reverse_iterator(iterator_type __x) : current(__x) { }\n+      reverse_iterator(const reverse_iterator& __x)\n+      : current(__x.current) { }\n+      template<typename _Iter>\n+\treverse_iterator(const reverse_iterator<_Iter>& __x)\n+ : current(__x.base()) { }\n+      iterator_type\n+      base() const\n+      { return current; }\n+      reference\n+      operator*() const\n+      {\n+ _Iterator __tmp = current;\n+ return *--__tmp;\n+      }\n+      pointer\n+      operator->() const\n+      { return &(operator*()); }\n+      reverse_iterator&\n+      operator++()\n+      {\n+ --current;\n+ return *this;\n+      }\n+      reverse_iterator\n+      operator++(int)\n+      {\n+ reverse_iterator __tmp = *this;\n+ --current;\n+ return __tmp;\n+      }\n+      reverse_iterator&\n+      operator--()\n+      {\n+ ++current;\n+ return *this;\n+      }\n+      reverse_iterator\n+      operator--(int)\n+      {\n+ reverse_iterator __tmp = *this;\n+ ++current;\n+ return __tmp;\n+      }\n+      reverse_iterator\n+      operator+(difference_type __n) const\n+      { return reverse_iterator(current - __n); }\n+      reverse_iterator&\n+      operator+=(difference_type __n)\n+      {\n+ current -= __n;\n+ return *this;\n+      }\n+      reverse_iterator\n+      operator-(difference_type __n) const\n+      { return reverse_iterator(current + __n); }\n+      reverse_iterator&\n+      operator-=(difference_type __n)\n+      {\n+ current += __n;\n+ return *this;\n+      }\n+      reference\n+      operator[](difference_type __n) const\n+      { return *(*this + __n); }\n+    };\n+}\n+\n+\n+\n+extern \"C++\" {\n+namespace std\n+{\n+  class exception\n+  {\n+  public:\n+    exception() throw() { }\n+    virtual ~exception() throw();\n+    virtual const char* what() const throw();\n+  };\n+  class bad_exception : public exception\n+  {\n+  public:\n+    bad_exception() throw() { }\n+    virtual ~bad_exception() throw();\n+    virtual const char* what() const throw();\n+  };\n+  typedef void (*terminate_handler) ();\n+  typedef void (*unexpected_handler) ();\n+  terminate_handler set_terminate(terminate_handler) throw();\n+  void terminate() throw() __attribute__ ((__noreturn__));\n+  unexpected_handler set_unexpected(unexpected_handler) throw();\n+  void unexpected() __attribute__ ((__noreturn__));\n+  bool uncaught_exception() throw() __attribute__ ((__pure__));\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  void __verbose_terminate_handler();\n+}\n+}\n+extern \"C++\" {\n+namespace std\n+{\n+  class bad_alloc : public exception\n+  {\n+  public:\n+    bad_alloc() throw() { }\n+    virtual ~bad_alloc() throw();\n+    virtual const char* what() const throw();\n+  };\n+  struct nothrow_t { };\n+  extern const nothrow_t nothrow;\n+  typedef void (*new_handler)();\n+  new_handler set_new_handler(new_handler) throw();\n+}\n+\n+void* operator new(std::size_t, const std::nothrow_t&) throw();\n+void* operator new[](std::size_t, const std::nothrow_t&) throw();\n+void operator delete(void*, const std::nothrow_t&) throw();\n+void operator delete[](void*, const std::nothrow_t&) throw();\n+inline void* operator new(std::size_t, void* __p) throw() { return __p; }\n+inline void* operator new[](std::size_t, void* __p) throw() { return __p; }\n+inline void operator delete (void*, void*) throw() { }\n+inline void operator delete[](void*, void*) throw() { }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  void\n+  __throw_bad_exception(void) __attribute__((__noreturn__));\n+  __attribute__((transaction_safe))\n+  void\n+  __throw_bad_alloc(void) __attribute__((__noreturn__));\n+  void\n+  __throw_bad_cast(void) __attribute__((__noreturn__));\n+  void\n+  __throw_bad_typeid(void) __attribute__((__noreturn__));\n+  void\n+  __throw_logic_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_domain_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_invalid_argument(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_length_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_out_of_range(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_runtime_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_range_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_overflow_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_underflow_error(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_ios_failure(const char*) __attribute__((__noreturn__));\n+  void\n+  __throw_system_error(int) __attribute__((__noreturn__));\n+  void\n+  __throw_future_error(int) __attribute__((__noreturn__));\n+  void\n+  __throw_bad_function_call() __attribute__((__noreturn__));\n+}\n+\n+\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp>\n+    inline void\n+    swap(_Tp& __a, _Tp& __b)\n+    {\n+\n+      _Tp __tmp = (__a);\n+      __a = (__b);\n+      __b = (__tmp);\n+    }\n+  template<typename _Tp, size_t _Nm>\n+    inline void\n+    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])\n+    {\n+      for (size_t __n = 0; __n < _Nm; ++__n)\n+ swap(__a[__n], __b[__n]);\n+    }\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+  using std::size_t;\n+  using std::ptrdiff_t;\n+  template<typename _Tp>\n+    class new_allocator\n+    {\n+    public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp& reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp value_type;\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef new_allocator<_Tp1> other; };\n+      new_allocator() throw() { }\n+      new_allocator(const new_allocator&) throw() { }\n+      template<typename _Tp1>\n+\tnew_allocator(const new_allocator<_Tp1>&) throw() { }\n+      ~new_allocator() throw() { }\n+      pointer\n+      address(reference __x) const { return &__x; }\n+      const_pointer\n+      address(const_reference __x) const { return &__x; }\n+      __attribute__((transaction_safe))\n+      pointer\n+      allocate(size_type __n, const void* = 0)\n+      {\n+ if (__n > this->max_size())\n+   std::__throw_bad_alloc();\n+ return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));\n+      }\n+__attribute__((transaction_safe))\n+void\n+      deallocate(pointer __p, size_type)\n+      { ::operator delete(__p); }\n+      size_type\n+      max_size() const throw()\n+      { return size_t(-1) / sizeof(_Tp); }\n+      void\n+      construct(pointer __p, const _Tp& __val)\n+      { ::new((void *)__p) _Tp(__val); }\n+      void\n+      destroy(pointer __p) { __p->~_Tp(); }\n+    };\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\n+    { return true; }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)\n+    { return false; }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Tp>\n+    class allocator;\n+  template<>\n+    class allocator<void>\n+    {\n+    public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef void* pointer;\n+      typedef const void* const_pointer;\n+      typedef void value_type;\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef allocator<_Tp1> other; };\n+    };\n+  template<typename _Tp>\n+    class allocator: public __gnu_cxx::new_allocator<_Tp>\n+    {\n+   public:\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Tp* pointer;\n+      typedef const _Tp* const_pointer;\n+      typedef _Tp& reference;\n+      typedef const _Tp& const_reference;\n+      typedef _Tp value_type;\n+      template<typename _Tp1>\n+\tstruct rebind\n+\t{ typedef allocator<_Tp1> other; };\n+      allocator() throw() { }\n+      allocator(const allocator& __a) throw()\n+      : __gnu_cxx::new_allocator<_Tp>(__a) { }\n+      template<typename _Tp1>\n+\tallocator(const allocator<_Tp1>&) throw() { }\n+      ~allocator() throw() { }\n+    };\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator==(const allocator<_T1>&, const allocator<_T2>&)\n+    { return true; }\n+  template<typename _Tp>\n+    inline bool\n+    operator==(const allocator<_Tp>&, const allocator<_Tp>&)\n+    { return true; }\n+  template<typename _T1, typename _T2>\n+    inline bool\n+    operator!=(const allocator<_T1>&, const allocator<_T2>&)\n+    { return false; }\n+  template<typename _Tp>\n+    inline bool\n+    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)\n+    { return false; }\n+  //extern template class allocator<char>;\n+  //  extern template class allocator<wchar_t>;\n+  template<typename _Alloc, bool = __is_empty(_Alloc)>\n+    struct __alloc_swap\n+    { static void _S_do_it(_Alloc&, _Alloc&) { } };\n+  template<typename _Alloc>\n+    struct __alloc_swap<_Alloc, false>\n+    {\n+      static void\n+      _S_do_it(_Alloc& __one, _Alloc& __two)\n+      {\n+ if (__one != __two)\n+   swap(__one, __two);\n+      }\n+    };\n+  template<typename _Alloc, bool = __is_empty(_Alloc)>\n+    struct __alloc_neq\n+    {\n+      static bool\n+      _S_do_it(const _Alloc&, const _Alloc&)\n+      { return false; }\n+    };\n+  template<typename _Alloc>\n+    struct __alloc_neq<_Alloc, false>\n+    {\n+      static bool\n+      _S_do_it(const _Alloc& __one, const _Alloc& __two)\n+      { return __one != __two; }\n+    };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Arg, typename _Result>\n+    struct unary_function\n+    {\n+      typedef _Arg argument_type;\n+      typedef _Result result_type;\n+    };\n+  template<typename _Arg1, typename _Arg2, typename _Result>\n+    struct binary_function\n+    {\n+      typedef _Arg1 first_argument_type;\n+      typedef _Arg2 second_argument_type;\n+      typedef _Result result_type;\n+    };\n+  template<typename _Tp>\n+    struct equal_to : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x == __y; }\n+    };\n+  template<typename _Tp>\n+    struct not_equal_to : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x != __y; }\n+    };\n+  template<typename _Tp>\n+    struct greater : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x > __y; }\n+    };\n+  template<typename _Tp>\n+    struct less : public binary_function<_Tp, _Tp, bool>\n+    {\n+      bool\n+      operator()(const _Tp& __x, const _Tp& __y) const\n+      { return __x < __y; }\n+    };\n+  template<typename _Tp>\n+    struct _Identity : public unary_function<_Tp,_Tp>\n+    {\n+      _Tp&\n+      operator()(_Tp& __x) const\n+      { return __x; }\n+      const _Tp&\n+      operator()(const _Tp& __x) const\n+      { return __x; }\n+    };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  enum _Rb_tree_color { _S_red = false, _S_black = true };\n+  struct _Rb_tree_node_base\n+  {\n+    typedef _Rb_tree_node_base* _Base_ptr;\n+    typedef const _Rb_tree_node_base* _Const_Base_ptr;\n+    _Rb_tree_color _M_color;\n+    _Base_ptr _M_parent;\n+    _Base_ptr _M_left;\n+    _Base_ptr _M_right;\n+    static _Base_ptr\n+    _S_minimum(_Base_ptr __x)\n+    {\n+      while (__x->_M_left != 0) __x = __x->_M_left;\n+      return __x;\n+    }\n+    static _Const_Base_ptr\n+    _S_minimum(_Const_Base_ptr __x)\n+    {\n+      while (__x->_M_left != 0) __x = __x->_M_left;\n+      return __x;\n+    }\n+    static _Base_ptr\n+    _S_maximum(_Base_ptr __x)\n+    {\n+      while (__x->_M_right != 0) __x = __x->_M_right;\n+      return __x;\n+    }\n+    static _Const_Base_ptr\n+    _S_maximum(_Const_Base_ptr __x)\n+    {\n+      while (__x->_M_right != 0) __x = __x->_M_right;\n+      return __x;\n+    }\n+  };\n+  template<typename _Val>\n+    struct _Rb_tree_node : public _Rb_tree_node_base\n+    {\n+      typedef _Rb_tree_node<_Val>* _Link_type;\n+      _Val _M_value_field;\n+    };\n+  __attribute__ ((__pure__)) _Rb_tree_node_base*\n+  _Rb_tree_increment(_Rb_tree_node_base* __x) throw ();\n+  __attribute__ ((__pure__)) const _Rb_tree_node_base*\n+  _Rb_tree_increment(const _Rb_tree_node_base* __x) throw ();\n+  __attribute__ ((__pure__)) _Rb_tree_node_base*\n+  _Rb_tree_decrement(_Rb_tree_node_base* __x) throw ();\n+  __attribute__ ((__pure__)) const _Rb_tree_node_base*\n+  _Rb_tree_decrement(const _Rb_tree_node_base* __x) throw ();\n+  template<typename _Tp>\n+    struct _Rb_tree_iterator\n+    {\n+      typedef _Tp value_type;\n+      typedef _Tp& reference;\n+      typedef _Tp* pointer;\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Rb_tree_iterator<_Tp> _Self;\n+      typedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+      typedef _Rb_tree_node<_Tp>* _Link_type;\n+      _Rb_tree_iterator()\n+      : _M_node() { }\n+      explicit\n+      _Rb_tree_iterator(_Link_type __x)\n+      : _M_node(__x) { }\n+      reference\n+      operator*() const\n+      { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }\n+      _Self&\n+      operator++()\n+      {\n+ _M_node = _Rb_tree_increment(_M_node);\n+ return *this;\n+      }\n+      _Self\n+      operator++(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _Rb_tree_increment(_M_node);\n+ return __tmp;\n+      }\n+      _Self&\n+      operator--()\n+      {\n+ _M_node = _Rb_tree_decrement(_M_node);\n+ return *this;\n+      }\n+      _Self\n+      operator--(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _Rb_tree_decrement(_M_node);\n+ return __tmp;\n+      }\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+      _Base_ptr _M_node;\n+  };\n+  template<typename _Tp>\n+    struct _Rb_tree_const_iterator\n+    {\n+      typedef _Tp value_type;\n+      typedef const _Tp& reference;\n+      typedef const _Tp* pointer;\n+      typedef _Rb_tree_iterator<_Tp> iterator;\n+      typedef bidirectional_iterator_tag iterator_category;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Rb_tree_const_iterator<_Tp> _Self;\n+      typedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n+      typedef const _Rb_tree_node<_Tp>* _Link_type;\n+      _Rb_tree_const_iterator()\n+      : _M_node() { }\n+      explicit\n+      _Rb_tree_const_iterator(_Link_type __x)\n+      : _M_node(__x) { }\n+      _Rb_tree_const_iterator(const iterator& __it)\n+      : _M_node(__it._M_node) { }\n+      reference\n+      operator*() const\n+      { return static_cast<_Link_type>(_M_node)->_M_value_field; }\n+      pointer\n+      operator->() const\n+      { return &static_cast<_Link_type>(_M_node)->_M_value_field; }\n+      _Self&\n+      operator++()\n+      {\n+ _M_node = _Rb_tree_increment(_M_node);\n+ return *this;\n+      }\n+      _Self\n+      operator++(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _Rb_tree_increment(_M_node);\n+ return __tmp;\n+      }\n+      _Self&\n+      operator--()\n+      {\n+ _M_node = _Rb_tree_decrement(_M_node);\n+ return *this;\n+      }\n+      _Self\n+      operator--(int)\n+      {\n+ _Self __tmp = *this;\n+ _M_node = _Rb_tree_decrement(_M_node);\n+ return __tmp;\n+      }\n+      bool\n+      operator==(const _Self& __x) const\n+      { return _M_node == __x._M_node; }\n+      bool\n+      operator!=(const _Self& __x) const\n+      { return _M_node != __x._M_node; }\n+      _Base_ptr _M_node;\n+    };\n+  void\n+  _Rb_tree_insert_and_rebalance(const bool __insert_left,\n+\t\t\t\t_Rb_tree_node_base* __x,\n+\t\t\t\t_Rb_tree_node_base* __p,\n+\t\t\t\t_Rb_tree_node_base& __header) throw ();\n+  _Rb_tree_node_base*\n+  _Rb_tree_rebalance_for_erase(_Rb_tree_node_base* const __z,\n+\t  _Rb_tree_node_base& __header) throw ();\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+\t   typename _Compare, typename _Alloc = allocator<_Val> >\n+    class _Rb_tree\n+    {\n+      typedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other\n+\t      _Node_allocator;\n+    protected:\n+      typedef _Rb_tree_node_base* _Base_ptr;\n+      typedef const _Rb_tree_node_base* _Const_Base_ptr;\n+    public:\n+      typedef _Key key_type;\n+      typedef _Val value_type;\n+      typedef value_type* pointer;\n+      typedef const value_type* const_pointer;\n+      typedef value_type& reference;\n+      typedef const value_type& const_reference;\n+      typedef _Rb_tree_node<_Val>* _Link_type;\n+      typedef const _Rb_tree_node<_Val>* _Const_Link_type;\n+      typedef size_t size_type;\n+      typedef ptrdiff_t difference_type;\n+      typedef _Alloc allocator_type;\n+      _Node_allocator&\n+      _M_get_Node_allocator()\n+      { return *static_cast<_Node_allocator*>(&this->_M_impl); }\n+      const _Node_allocator&\n+      _M_get_Node_allocator() const\n+      { return *static_cast<const _Node_allocator*>(&this->_M_impl); }\n+      allocator_type\n+      get_allocator() const\n+      { return allocator_type(_M_get_Node_allocator()); }\n+    protected:\n+      _Link_type\n+      _M_get_node()\n+      { return _M_impl._Node_allocator::allocate(1); }\n+      __attribute__((transaction_safe))\n+      void\n+      _M_put_node(_Link_type __p)\n+      { _M_impl._Node_allocator::deallocate(__p, 1); }\n+      __attribute__((transaction_safe))\n+      _Link_type\n+      _M_create_node(const value_type& __x)\n+      {\n+ _Link_type __tmp = _M_get_node();\n+ try\n+   { get_allocator().construct(&__tmp->_M_value_field, __x); }\n+ catch(...)\n+   {\n+     _M_put_node(__tmp);\n+     throw;\n+   }\n+ return __tmp;\n+      }\n+      void\n+      _M_destroy_node(_Link_type __p)\n+      {\n+ get_allocator().destroy(&__p->_M_value_field);\n+ _M_put_node(__p);\n+      }\n+    protected:\n+      template<typename _Key_compare,\n+\tbool _Is_pod_comparator = __is_pod(_Key_compare)>\n+\tstruct _Rb_tree_impl : public _Node_allocator\n+\t{\n+   _Key_compare _M_key_compare;\n+   _Rb_tree_node_base _M_header;\n+   size_type _M_node_count;\n+   _Rb_tree_impl()\n+   : _Node_allocator(), _M_key_compare(), _M_header(),\n+     _M_node_count(0)\n+   { _M_initialize(); }\n+   _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)\n+   : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),\n+     _M_node_count(0)\n+   { _M_initialize(); }\n+ private:\n+   void\n+   _M_initialize()\n+   {\n+     this->_M_header._M_color = _S_red;\n+     this->_M_header._M_parent = 0;\n+     this->_M_header._M_left = &this->_M_header;\n+     this->_M_header._M_right = &this->_M_header;\n+   }\n+ };\n+      _Rb_tree_impl<_Compare> _M_impl;\n+    protected:\n+      _Base_ptr&\n+      _M_root()\n+      { return this->_M_impl._M_header._M_parent; }\n+      _Const_Base_ptr\n+      _M_root() const\n+      { return this->_M_impl._M_header._M_parent; }\n+      _Base_ptr&\n+      _M_leftmost()\n+      { return this->_M_impl._M_header._M_left; }\n+      _Const_Base_ptr\n+      _M_leftmost() const\n+      { return this->_M_impl._M_header._M_left; }\n+      _Base_ptr&\n+      _M_rightmost()\n+      { return this->_M_impl._M_header._M_right; }\n+      _Const_Base_ptr\n+      _M_rightmost() const\n+      { return this->_M_impl._M_header._M_right; }\n+      _Link_type\n+      _M_begin()\n+      { return static_cast<_Link_type>(this->_M_impl._M_header._M_parent); }\n+      _Const_Link_type\n+      _M_begin() const\n+      {\n+ return static_cast<_Const_Link_type>\n+   (this->_M_impl._M_header._M_parent);\n+      }\n+      _Link_type\n+      _M_end()\n+      { return static_cast<_Link_type>(&this->_M_impl._M_header); }\n+      _Const_Link_type\n+      _M_end() const\n+      { return static_cast<_Const_Link_type>(&this->_M_impl._M_header); }\n+      static const_reference\n+      _S_value(_Const_Link_type __x)\n+      { return __x->_M_value_field; }\n+      static const _Key&\n+      _S_key(_Const_Link_type __x)\n+      { return _KeyOfValue()(_S_value(__x)); }\n+      static _Link_type\n+      _S_left(_Base_ptr __x)\n+      { return static_cast<_Link_type>(__x->_M_left); }\n+      static _Const_Link_type\n+      _S_left(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x->_M_left); }\n+      static _Link_type\n+      _S_right(_Base_ptr __x)\n+      { return static_cast<_Link_type>(__x->_M_right); }\n+      static _Const_Link_type\n+      _S_right(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x->_M_right); }\n+      static const_reference\n+      _S_value(_Const_Base_ptr __x)\n+      { return static_cast<_Const_Link_type>(__x)->_M_value_field; }\n+      static const _Key&\n+      _S_key(_Const_Base_ptr __x)\n+      { return _KeyOfValue()(_S_value(__x)); }\n+    public:\n+      typedef _Rb_tree_iterator<value_type> iterator;\n+      typedef _Rb_tree_const_iterator<value_type> const_iterator;\n+      typedef std::reverse_iterator<iterator> reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+    private:\n+      iterator\n+      _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,\n+   const value_type& __v);\n+    public:\n+      _Rb_tree() { }\n+      iterator\n+      begin()\n+      {\n+ return iterator(static_cast<_Link_type>\n+   (this->_M_impl._M_header._M_left));\n+      }\n+      const_iterator\n+      begin() const\n+      {\n+ return const_iterator(static_cast<_Const_Link_type>\n+\t (this->_M_impl._M_header._M_left));\n+      }\n+      iterator\n+      end()\n+      { return iterator(static_cast<_Link_type>(&this->_M_impl._M_header)); }\n+      const_iterator\n+      end() const\n+      {\n+ return const_iterator(static_cast<_Const_Link_type>\n+\t (&this->_M_impl._M_header));\n+      }\n+      pair<iterator, bool>\n+      _M_insert_unique(const value_type& __x);\n+    };\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+\t   typename _Compare, typename _Alloc>\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)\n+    {\n+      _Link_type __z = _M_create_node(__v);\n+      return iterator(__z);\n+    }\n+  template<typename _Key, typename _Val, typename _KeyOfValue,\n+\t   typename _Compare, typename _Alloc>\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+      _Compare, _Alloc>::iterator, bool>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_insert_unique(const _Val& __v)\n+    {\n+      _Link_type __x = _M_begin();\n+      _Link_type __y = _M_end();\n+      iterator __j = iterator(__y);\n+ return pair<iterator, bool>(_M_insert_(__x, __y, __v), true);\n+    }\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+  template<typename _Key, typename _Compare = std::less<_Key>,\n+    typename _Alloc = std::allocator<_Key> >\n+    class set\n+    {\n+    public:\n+      typedef _Key key_type;\n+      typedef _Key value_type;\n+      typedef _Compare key_compare;\n+      typedef _Compare value_compare;\n+      typedef _Alloc allocator_type;\n+    private:\n+      typedef typename _Alloc::template rebind<_Key>::other _Key_alloc_type;\n+      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,\n+\t key_compare, _Key_alloc_type> _Rep_type;\n+      _Rep_type _M_t;\n+    public:\n+      typedef typename _Key_alloc_type::pointer pointer;\n+      typedef typename _Key_alloc_type::const_pointer const_pointer;\n+      typedef typename _Key_alloc_type::reference reference;\n+      typedef typename _Key_alloc_type::const_reference const_reference;\n+      typedef typename _Rep_type::const_iterator iterator;\n+      typedef typename _Rep_type::const_iterator const_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;\n+      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+      typedef typename _Rep_type::size_type size_type;\n+      typedef typename _Rep_type::difference_type difference_type;\n+      std::pair<iterator, bool>\n+      insert(const value_type& __x)\n+      {\n+   _M_t._M_insert_unique(__x);\n+      }\n+    };\n+}\n+__attribute__((transaction_pure))\n+void* operator new(size_t);\n+__attribute__((transaction_pure))\n+void operator delete(void*);\n+class Widget\n+{\n+private:\n+};\n+class Screen\n+{\n+protected:\n+std::set<Widget *> widgets;\n+public:\n+void addWidget(Widget* widget);\n+};\n+void Screen::addWidget(Widget* widget)\n+{\n+widgets.insert(widget);\n+}"}, {"sha": "f8f3a1d3117fa6b43408f22b95cf408216e7f56c", "filename": "gcc/testsuite/g++.dg/tm/pr46653.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46653.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46653.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46653.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O\" }\n+\n+class shared_count\n+{\n+public:\n+    volatile int j;\n+  shared_count() : j(0) { }\n+};\n+\n+shared_count * c;\n+int main()\n+{\n+  __transaction_atomic {\n+    shared_count sc;\n+  }\n+  return 0;\n+}"}, {"sha": "130b58cdd992be4ac551d4d60aaca876fe87eeb1", "filename": "gcc/testsuite/g++.dg/tm/pr46714.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46714.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46714.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46714.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O\" }\n+\n+static int asdf __attribute__ ((__weakref__(\"funky\")));\n+\n+class Building\n+{\n+public:\n+  __attribute__((transaction_safe)) ~Building(void);\n+};\n+\n+Building::~Building()\n+{\n+}"}, {"sha": "eac5438313877f5a49a3a685365c7a8f510811a6", "filename": "gcc/testsuite/g++.dg/tm/pr46941.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46941.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46941.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr46941.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,37 @@\n+// { dg-do \"compile\" }\n+// { dg-options \"-fgnu-tm\" }\n+\n+class Obj\n+{\n+  int dummy;\n+};\n+\n+__attribute__((transaction_safe))\n+Obj* allocate()\n+{\n+  return new Obj;\n+}\n+\n+__attribute__((transaction_safe))\n+void deallocate(Obj * o)\n+{\n+  delete o;\n+}\n+\n+__attribute__((transaction_safe))\n+Obj* allocatearray()\n+{\n+  return new Obj[2];\n+}\n+\n+__attribute__((transaction_safe))\n+void deallocatearray(Obj *o[])\n+{\n+  delete [] o;\n+}\n+\n+/* The delete/new operators are handled by the libitm runtime.  */\n+/* { dg-final { scan-assembler \"_ZGTtnw\\[mj\\]\" } } */\n+/* { dg-final { scan-assembler \"_ZGTtna\\[mj\\]\" } } */\n+/* { dg-final { scan-assembler \"_ZGTtdlPv\" } } */\n+/* { dg-final { scan-assembler \"_ZGTtdaPv\" } } */"}, {"sha": "ead3361fae218d0160840113ac7155f0c3375f04", "filename": "gcc/testsuite/g++.dg/tm/pr47340.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47340.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47340.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47340.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,11 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+void* operator new(__SIZE_TYPE__) throw (int);\n+\n+void *point;\n+\n+void funky()\n+{\n+  point = new (int);\n+}"}, {"sha": "8e7e27297cecf9b8a4c29a6f7edefdf51e3b661d", "filename": "gcc/testsuite/g++.dg/tm/pr47530.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47530.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47530.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47530.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,79 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O2 -fdump-tree-optimized\" }\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern void *malloc(size_t);\n+\n+namespace bench\n+{\n+    class LLNode\n+    {\n+    \tLLNode* next;\n+    \tint data;\n+\n+    public:\n+\t__attribute__((transaction_safe))\n+\tLLNode(int val, LLNode* m_next)\n+\t{\n+\t\tdata = val;\n+\t\tnext = m_next;\n+\t}\n+\t__attribute__((transaction_safe))\n+\t  ~LLNode(){}\n+\t__attribute__((transaction_safe))\n+\t  int get_val()  {return data;}\n+\t__attribute__((transaction_safe))\n+\t  LLNode* get_next()  {return next;}\n+\t__attribute__((transaction_safe))\n+\t  void set_val(int val) {data = val;}\n+\t__attribute__((transaction_safe))\n+\t  void set_next(LLNode* n)  {next = n;}\n+\t__attribute__((transaction_safe))\n+\t  void *operator new(size_t size);\n+    };\n+\n+    class LinkedList\n+    {\n+      LLNode* head;\n+    public:\n+\tLinkedList();\n+\tvoid insert(int val);\n+    };\n+}\n+\n+using bench::LinkedList;\n+using bench::LLNode;\n+\n+\n+__attribute__((transaction_safe))\n+void* LLNode::operator new(size_t size)\n+{\n+  return malloc(size);\n+}\n+\n+LinkedList::LinkedList() : head(new LLNode(-1, 0)) { }\n+\n+void LinkedList::insert(int val)\n+{\n+  __transaction_atomic {\n+    LLNode* prev = head;\n+    LLNode* curr = head->get_next();\n+\n+    while (curr != 0) {\n+      if (curr->get_val() >= val)\n+\tbreak;\n+      prev = curr;\n+      curr = prev->get_next();\n+    }\n+\n+    if (!curr || (curr->get_val() > val)){\n+      LLNode* tmp = new LLNode(val,curr);\n+      prev->set_next(tmp);\n+    }\n+  }\n+}\n+\n+// Make sure we don't do tail optimization on the commit.\n+// { dg-final { scan-tree-dump-times \"commitTransaction...; .tail call\" 0 \"optimized\" } }\n+// { dg-final { cleanup-tree-dump \"optimized\" } }\n+"}, {"sha": "28841bb15ad631d86d4016a6b8505e06e9eee0b8", "filename": "gcc/testsuite/g++.dg/tm/pr47554.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47554.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47554.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47554.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+class list\n+{\n+\tpublic:     list()\n+\t{\n+\t}\n+\tlist(const list&)\n+\t{\n+\t}\n+\tconst list&       _M_get_Node_allocator() const\n+\t{\n+\t}\n+\tlist       _M_get_Tp_allocator() const\n+\t{\n+\t\treturn list(_M_get_Node_allocator());\n+\t}\n+};\n+static list buildProjects;\n+static void build()\n+{\n+\t__transaction_relaxed\n+\t{\n+\t\tbuildProjects._M_get_Tp_allocator();\n+\t}\n+}"}, {"sha": "239d9222e8ef593e663100f3b45acc9170368690", "filename": "gcc/testsuite/g++.dg/tm/pr47573.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47573.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47573.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47573.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+template<typename _Tp> class allocator\n+{\n+\tpublic:\n+\tallocator() { }\n+};\n+extern template class allocator<char>;\n+\n+template<typename _Alloc = allocator<char> > class basic_string\n+{\n+\tpublic:\n+\t_Alloc _M_dataplus;\n+\n+\t__attribute__((transaction_safe))\n+\tbasic_string() : _M_dataplus(_Alloc())\n+\t{\n+\t}\n+};\n+\n+int getStringHeight()\n+{\n+\tbasic_string<> tmp;\n+}"}, {"sha": "7cd9e1006d12b8e36326847701fc71bba02f3a26", "filename": "gcc/testsuite/g++.dg/tm/pr47746.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47746.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47746.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fpr47746.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm\" }\n+\n+class InputStream\n+{\n+\tpublic:\n+\tvirtual unsigned int readUint32 () = 0;\n+};\n+\n+class Building\n+{\n+\tpublic:\n+\t__attribute__((transaction_safe)) Building (InputStream *stream);\n+\t__attribute__((transaction_safe)) void freeGradients ();\n+\tvoid load (InputStream *stream);\n+};\n+\n+Building::Building (InputStream *stream)\n+{\n+\tload(stream);\n+}\n+\n+void Building::load (InputStream *stream)\n+{\n+\tint j = (int)stream->readUint32 ();\n+\tfreeGradients ();\n+}"}, {"sha": "b93828a1dc3bf730d589d6f8dc2d9cebe84d668c", "filename": "gcc/testsuite/g++.dg/tm/template-1.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftemplate-1.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" }\n+\n+struct TrueFalse\n+{\n+  static bool v() { return true; }\n+};\n+\n+int global;\n+\n+template<typename T> int foo()\n+{\n+  __transaction_atomic { global += 2; }\n+  return __transaction_atomic (global + 1);\n+}\n+\n+template<typename T> int bar() __transaction_atomic\n+{\n+  return global + 3;\n+}\n+\n+template<typename T> void bar2() __transaction_atomic\n+{\n+  global += 4;\n+}\n+\n+int f1()\n+{\n+  bar2<TrueFalse>();\n+  return foo<TrueFalse>() + bar<TrueFalse>();\n+}\n+\n+/* 4 transactions overall, two of the write to global:  */\n+/* { dg-final { scan-tree-dump-times \"ITM_RU4\\\\s*\\\\(&global\" 4 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_WU4\\\\s*\\\\(&global\" 2 \"tmmark\" } } */"}, {"sha": "d8c76fe1e88d442a9c74b6b60100fe1cb2ed10be", "filename": "gcc/testsuite/g++.dg/tm/tm.exp", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Ftm.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,39 @@\n+#   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib g++-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CXXFLAGS\n+if ![info exists DEFAULT_CXXFLAGS] then {\n+    set DEFAULT_CXXFLAGS \" -ansi -pedantic-errors -Wno-long-long\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Run the tests that are shared with C.\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/tm/*.c]] \\\n+\t\"\" $DEFAULT_CXXFLAGS\n+# Run the C++ only tests.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \\\n+\t\"\" $DEFAULT_CXXFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "2c5bb39f7ed8ee2d41fa81dc9cb75b2b4449c64c", "filename": "gcc/testsuite/g++.dg/tm/vector-1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fvector-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fvector-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fvector-1.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+// { dg-do compile }\n+// { dg-options \"-fgnu-tm -O3\" }\n+\n+class HashTree\n+{\n+   __attribute__((transaction_safe)) void rehash();\n+   HashTree **Hash_table;\n+   int Hash_function;\n+};\n+\n+__attribute__((transaction_safe)) void HashTree::rehash()\n+{\n+   for (int i=0; i < Hash_function; i++)\n+      Hash_table[i] = 0;\n+}"}, {"sha": "564fbf87e1b478c727273fe1942c0c0b501087d5", "filename": "gcc/testsuite/g++.dg/tm/wrap-2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fwrap-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fwrap-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftm%2Fwrap-2.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+#define W(X)\t__attribute__((transaction_wrap(X)))\n+void f1(void);\n+void f2(int);\n+int i3;\n+int f7(void);\n+\n+void g1(void) W(f1);\n+void g2(void) W(f2);\t/* { dg-error \"is not compatible\" } */\n+void g3(void) W(i3);\t/* { dg-error \"is not a function\" } */\n+void g4(void) W(f4);\t/* { dg-error \"not declared in this scope\\|not an identifier\" } */\n+void g5(void) W(1);\t/* { dg-error \"not an identifier\" } */\n+void g6(void) W(\"f1\");\t/* { dg-error \"not an identifier\" } */\n+void g7(void) W(f7);\t/* { dg-error \"is not compatible\" } */"}, {"sha": "d9b3b0ed3bc8f1857a1b38a67db32e5b61d2a08b", "filename": "gcc/testsuite/gcc.dg/tm/20091013.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20091013.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20091013.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20091013.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O2\" } */\n+\n+extern long ringo(long int);\n+int g,i;\n+\n+f()\n+{\n+  __transaction_relaxed {\n+    for (i=0; i < 10; ++i)\n+      ringo(g);\n+  }\n+}"}, {"sha": "1d75d153a2c19a1d76f0b110071ba2c37a20e099", "filename": "gcc/testsuite/gcc.dg/tm/20091221.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20091221.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20091221.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20091221.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmedge\" } */\n+\n+int i;\n+extern void virgin () __attribute__((transaction_pure));\n+\n+foo()\n+{\n+\t__transaction_atomic {\n+\t    virgin(i);\n+\t}\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"readOnly\" 1 \"tmedge\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */"}, {"sha": "3f1dd10fea2c683952f0024a71dad3e2416e4ff5", "filename": "gcc/testsuite/gcc.dg/tm/20100125.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100125.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100125.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100125.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+/* Test that the call to george() doesn't end up inside the transaction.  */\n+\n+int trxn;\n+\n+void set_remove(int * val)\n+{\n+  __transaction_atomic {\n+      trxn = 5;\n+  }\n+  george();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"getTMCloneOrIrrevocable\" 0 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "009b7901a39db32bac8865c973187e983b4294b8", "filename": "gcc/testsuite/gcc.dg/tm/20100519.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100519.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100519.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100519.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+typedef struct coordinate {\n+    double x;\n+} coordinate_t;\n+\n+coordinate_t elementPtrC[3];\n+\n+__attribute__((transaction_safe))\n+void TMelement_alloc (coordinate_t* coordinates, int numCoordinate)\n+{\n+   int i;\n+   for (i = 0; i < numCoordinate; i++) {\n+      elementPtrC[i] = coordinates[i];\n+   }\n+}"}, {"sha": "a3578cb27974bed9e6620a5fb695706e860e0558", "filename": "gcc/testsuite/gcc.dg/tm/20100524-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100524-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100524-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100524-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O0\" } */\n+\n+typedef struct {\n+\tint value[5];\n+} type_t;\n+\n+__attribute__((transaction_safe))\n+type_t func_move ();\n+\n+__attribute__((transaction_safe))\n+type_t func_push (int type)\n+{\n+\ttype_t trace;\n+\n+\tif (type == 9)\n+\t\ttrace = func_move();\n+\n+\treturn trace;\n+}"}, {"sha": "3061063394dd65a4449501b91889b42b9bcf5190", "filename": "gcc/testsuite/gcc.dg/tm/20100603.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100603.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100603.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100603.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-optimized\" } */\n+\n+int jj;\n+\n+__attribute__((transaction_safe))\n+static void poof ()\n+{\n+  if (jj)\n+    return;\n+   poof();\n+}\n+\n+__attribute__((transaction_safe))\n+void TMlist_free ()\n+{\n+    poof();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Function poof ._ZGTt4poof\" 1 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "760f81ec6dd891dfdefffd5b39105d1e6039e3f0", "filename": "gcc/testsuite/gcc.dg/tm/20100609.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100609.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100609.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100609.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+extern void funcNoReturn() __attribute__ ((__noreturn__));\n+\n+int later;\n+\n+void MyFunc()\n+{\n+  __transaction_relaxed {\n+\tfuncNoReturn();\n+\tlater=8;\n+  }\n+}"}, {"sha": "0985b9ebc23fde7fe478e2c937f725cdbc5708c8", "filename": "gcc/testsuite/gcc.dg/tm/20100610.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100610.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100610.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100610.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,90 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O3\" } */\n+\n+/* The function calculateCircumCircle() should get inlined into the TM\n+   clone for TMelement_alloc(), so we don't need to generate a TM\n+   clone for calculateCircumCircle().  We also don't need to put its\n+   entry into the clone table since it's static.  */\n+\n+/* { dg-final { scan-assembler-not \"ZGTt21calculateCircumCircle\" } } */\n+\n+extern double sqrt(double) __attribute__((transaction_pure));\n+extern void *xmalloc(int) __attribute__((transaction_safe));\n+\n+typedef struct coordinate {\n+    double x;\n+    double y;\n+} coordinate_t;\n+typedef struct element {\n+    coordinate_t coordinates[3];\n+    long numCoordinate;\n+    coordinate_t circumCenter;\n+    double circumRadius;\n+} element_t;\n+\n+__attribute__((transaction_safe))\n+double\n+coordinate_distance (coordinate_t* coordinatePtr, coordinate_t* aPtr)\n+{\n+    return sqrt( coordinatePtr->x );\n+}\n+\n+__attribute__((transaction_safe))\n+static void\n+calculateCircumCircle (element_t* elementPtr)\n+{\n+    long numCoordinate = elementPtr->numCoordinate;\n+    coordinate_t* coordinates = elementPtr->coordinates;\n+    coordinate_t* circumCenterPtr = &elementPtr->circumCenter;\n+    ((void) (0));\n+    if (numCoordinate == 2) {\n+\tcircumCenterPtr->x = (coordinates[0].x + coordinates[1].x) / 2.0;\n+\tcircumCenterPtr->y = (coordinates[0].y + coordinates[1].y) / 2.0;\n+    }\n+ else {\n+\tdouble ax = coordinates[0].x;\n+\tdouble ay = coordinates[0].y;\n+\tdouble bx = coordinates[1].x;\n+\tdouble by = coordinates[1].y;\n+\tdouble cx = coordinates[2].x;\n+\tdouble cy = coordinates[2].y;\n+\tdouble bxDelta = bx - ax;\n+\tdouble byDelta = by - ay;\n+\tdouble cxDelta = cx - ax;\n+\tdouble cyDelta = cy - ay;\n+\tdouble bDistance2 = (bxDelta * bxDelta) + (byDelta * byDelta);\n+\tdouble cDistance2 = (cxDelta * cxDelta) + (cyDelta * cyDelta);\n+\tdouble xNumerator = (byDelta * cDistance2) - (cyDelta * bDistance2);\n+\tdouble yNumerator = (bxDelta * cDistance2) - (cxDelta * bDistance2);\n+\tdouble denominator = 2 * ((bxDelta * cyDelta) - (cxDelta * byDelta));\n+\tdouble rx = ax - (xNumerator / denominator);\n+\tdouble ry = ay + (yNumerator / denominator);\n+\tcircumCenterPtr->x = rx;\n+\tcircumCenterPtr->y = ry;\n+    }\n+    elementPtr->circumRadius = coordinate_distance(circumCenterPtr,\n+\t\t\t\t\t\t   &coordinates[0]);\n+}\n+\n+element_t*\n+element_alloc (coordinate_t* coordinates, long numCoordinate)\n+{\n+    element_t* elementPtr;\n+    elementPtr = (element_t*)xmalloc(sizeof(element_t));\n+    if (elementPtr) {\n+\tcalculateCircumCircle(elementPtr);\n+    }\n+    return elementPtr;\n+}\n+\n+__attribute__((transaction_safe))\n+element_t*\n+TMelement_alloc (coordinate_t* coordinates, long numCoordinate)\n+{\n+    element_t* elementPtr;\n+    elementPtr = (element_t*)xmalloc(sizeof(element_t));\n+    if (elementPtr) {\n+\tcalculateCircumCircle(elementPtr);\n+    }\n+    return elementPtr;\n+}"}, {"sha": "4341e7d35ea8f4fb2e48fd8326c82a935edb7d4f", "filename": "gcc/testsuite/gcc.dg/tm/20100615-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100615-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100615-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100615-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+__attribute__((transaction_safe))\n+void Info_RemoveKey (char *s)\n+{\n+\tchar    *o = 0;\n+\twhile (1)\n+\t{\n+\t\ts++;\n+\t\twhile (*s)\n+\t\t{\n+\t\t\tif (!*s)\n+\t\t\t\treturn;\n+\t\t\t*o++ = *s++;\n+\t\t}\n+\t\t*o = 0;\n+\t}\n+}"}, {"sha": "3d9e4684e5d39bc1875a46fea5139cb55b800789", "filename": "gcc/testsuite/gcc.dg/tm/20100615.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100615.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100615.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20100615.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+/* Since the non TM version of new_node() gets optimized away, it\n+   shouldn't appear in the clone table either.  */\n+/* { dg-final { scan-assembler-not \"tm_clone_table\" } } */\n+\n+#define NULL 0\n+extern void *malloc (__SIZE_TYPE__);\n+\n+__attribute__((transaction_pure))\n+void exit(int status);\n+\n+typedef struct node {\n+} node_t;\n+\n+__attribute__((transaction_safe))\n+static node_t *new_node(node_t *next)\n+{\n+  node_t *node;\n+  node = (node_t *)malloc(sizeof(node_t));\n+  if (node == NULL) {\n+    exit(1);\n+  }\n+  return NULL;\n+}\n+\n+static node_t *set_new()\n+{\n+  node_t *min, *max;\n+  __transaction_atomic {\n+    max = new_node(NULL);\n+    min = new_node(max);\n+  }\n+  return min;\n+}\n+\n+int main(int argc, char **argv)\n+{\n+  set_new();\n+  return 0;\n+}"}, {"sha": "22edae0fb4c7fadf200282215c4c20b7c48a244f", "filename": "gcc/testsuite/gcc.dg/tm/20110216.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20110216.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20110216.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2F20110216.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+int george;\n+\n+__attribute__((transaction_callable))\n+void q1()\n+{\n+  __transaction_atomic {\n+      george=999;\n+  }\n+  q1();\n+}\n+\n+/* { dg-final { scan-assembler-not \"_ITM_getTMCloneOrIrrevocable\" } } */"}, {"sha": "364aa7140861d8715fa26cae8438623195612d07", "filename": "gcc/testsuite/gcc.dg/tm/alias-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Falias-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Falias-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Falias-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-ealias -O\" } */\n+\n+typedef __UINTPTR_TYPE__ ptrcast;\n+\n+#if (__SIZEOF_POINTER__ == 4)\n+#define TM_LOAD  __builtin__ITM_RU4\n+#define TM_STORE __builtin__ITM_WU4\n+#elif (__SIZEOF_POINTER__ == 8)\n+#define TM_LOAD __builtin__ITM_RU8\n+#define TM_STORE __builtin__ITM_WU8\n+#else\n+#error Add target support here\n+#endif\n+\n+struct mystruct_type {\n+  ptrcast *ptr;\n+} *mystruct;\n+\n+ptrcast *someptr, **pp;\n+ptrcast ui;\n+\n+void f(void)\n+{\n+  __transaction_atomic {\n+    ui = TM_LOAD  (&mystruct);\n+    mystruct = (struct mystruct_type *) ui;\n+    ui = TM_LOAD  (&someptr);\n+    someptr = (ptrcast *) ui;\n+    ui = (ptrcast) someptr;\n+    pp = &mystruct->ptr;\n+    TM_STORE (pp, ui);\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"mystruct = \\{ .*ESCAPED\" 1 \"ealias\" } } */\n+/* { dg-final { scan-tree-dump-times \"someptr = same as mystruct\" 1 \"ealias\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"ui\\..* = same as mystruct\" 1 \"ealias\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"pp\\..* = same as mystruct\" 1 \"ealias\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"ealias\" } } */"}, {"sha": "761a99c2ab03107a7d1a9ef70bc4f2146add505a", "filename": "gcc/testsuite/gcc.dg/tm/alias-2.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Falias-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Falias-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Falias-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-ealias -O\" } */\n+\n+typedef __UINTPTR_TYPE__ ptrcast;\n+\n+#if (__SIZEOF_POINTER__ == 4)\n+#define TM_LOAD  __builtin__ITM_RU4\n+#define TM_STORE __builtin__ITM_WU4\n+#elif (__SIZEOF_POINTER__ == 8)\n+#define TM_LOAD __builtin__ITM_RU8\n+#define TM_STORE __builtin__ITM_WU8\n+#else\n+#error Add target support here\n+#endif\n+\n+void candy ();\n+\n+struct mystruct_type {\n+  ptrcast *ptr;\n+} *mystruct, *mystruct2;\n+\n+ptrcast *someptr, **pp;\n+ptrcast ui;\n+\n+void tootsie_roll () __attribute__((transaction_wrap (candy)));\n+void tootsie_roll ()\n+{\n+  ui = TM_LOAD  (&mystruct);\n+  mystruct2 = (struct mystruct_type *) ui;\n+\n+  pp = &mystruct2->ptr;\n+}\n+\n+void foo()\n+{\n+  candy();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ui\\..* = same as mystruct\" 1 \"ealias\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"mystruct.*ESCAPED\" 1 \"ealias\" } } */\n+/* { dg-final { scan-tree-dump-times \"pp = same as mystruct\" 1 \"ealias\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"ealias\" } } */"}, {"sha": "16061476e08e8663a59535f2cac70a2ec826d911", "filename": "gcc/testsuite/gcc.dg/tm/data-1.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdata-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdata-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdata-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+/* Test read and write on all basic types.  */\n+\n+static char gc;\n+static signed char gsc;\n+static unsigned char guc;\n+\n+static short gs;\n+static unsigned short gus;\n+\n+static int gi;\n+static unsigned int gui;\n+\n+static long gl;\n+static unsigned long gul;\n+\n+static long long gll;\n+static unsigned long long gull;\n+\n+static float gf;\n+static double gd;\n+static long double gld;\n+\n+void f(void)\n+{\n+  __transaction_atomic {\n+    gc++;\n+    gsc++;\n+    guc++;\n+\n+    gs++;\n+    gus++;\n+\n+    gi++;\n+    gui++;\n+\n+    gl++;\n+    gul++;\n+\n+    gll++;\n+    gull++;\n+\n+    gf++;\n+    gd++;\n+    gld++;\n+  }\n+}"}, {"sha": "3e2a604bfb31366f5b110ee5ce0f4273b5dc3fa0", "filename": "gcc/testsuite/gcc.dg/tm/data-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdata-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdata-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdata-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+/* Test read and write on all basic types.  */\n+\n+struct S\n+{\n+  int x[10];\n+};\n+\n+static struct S g;\n+\n+extern void fill (struct S *);\n+\n+void f(void)\n+{\n+  struct S l;\n+  fill(&l);\n+\n+  __transaction_atomic {\n+    g = l;\n+  }\n+}"}, {"sha": "fae5d6bed422c1de7aee07d3c892980c848edce0", "filename": "gcc/testsuite/gcc.dg/tm/debug-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdebug-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdebug-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fdebug-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O0 -fdump-tree-tmmark-lineno\" } */\n+\n+/* Test that instrumented statements have correct location info.  */\n+\n+int a,b, c, z;\n+\n+testing(){\n+    c=9;\n+}\n+\n+main() {\n+\tb = 9898;\n+\t__transaction_relaxed {\n+\t\tz = c;\n+\t\ta = 888;\n+\t\ttesting();\n+\t}\n+\treturn 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \": 13:.*b = 9898\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \": 14:.*__transaction\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \": 15:.*ITM_WU. \\\\(&z\" 1 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \": 16:.*ITM_WU. \\\\(&a\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "eade848bd8bc7925e4fe54ccdcb222a13a16fb96", "filename": "gcc/testsuite/gcc.dg/tm/indirect-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Findirect-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Findirect-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Findirect-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void foo(void (*fn)(void))\n+{\n+  __transaction_relaxed {\n+    fn();\n+  }\n+}"}, {"sha": "ec1cdca70322373fbc7e5c4501e8447c5f4b57c8", "filename": "gcc/testsuite/gcc.dg/tm/ipa-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmmark-asmname\" } */\n+\n+void foo(void) __attribute__((transaction_safe));\n+\n+void bar(void)\n+{\n+  __transaction_atomic {\n+    foo();\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_ZGTt3foo\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "e7a02cb19261bea4f560eb685b201a405590db71", "filename": "gcc/testsuite/gcc.dg/tm/ipa-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmmark-asmname\" } */\n+\n+void foo(void);\n+\n+void bar(void)\n+{\n+  __transaction_relaxed {\n+    foo();\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"_ZGTt3foo\" 0 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "cb1b433bcbd4908809d70917d2dbd38fd8f067b6", "filename": "gcc/testsuite/gcc.dg/tm/ipa-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fipa-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+static int x;\n+\n+void __attribute__((transaction_callable))\n+foo(void)\n+{\n+  x++;\n+}\n+\n+/* { dg-final { scan-assembler \"_ZGTt3foo\" } } */"}, {"sha": "60f629133ee26e45cc5e45936992ddc2be77edab", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+int global;\n+int george;\n+\n+extern crap() __attribute__((transaction_unsafe));\n+\n+foo()\n+{\n+\t__transaction_relaxed {\n+\t\tglobal++;\n+\t\tcrap();\n+\t\tgeorge++;\n+\t}\n+}"}, {"sha": "17ac8a5f0c077ae3e71cf137f95f06947ba017d7", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmedge\" } */\n+\n+/* Test that a direct call to __builtin__ITM_changeTransactionMode()\n+   sets the irrevocable bit.  */\n+\n+int global;\n+int george;\n+\n+foo()\n+{\n+\t__transaction_relaxed {\n+\t\tglobal++;\n+\t\t__builtin__ITM_changeTransactionMode (0);\n+\t\tgeorge++;\n+\t}\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"doesGoIrrevocable\" 1 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"hasNoIrrevocable\" 0 \"tmedge\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */"}, {"sha": "c08547948035e992e71bb87340995a8f5a991dec", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmmark\" } */\n+\n+extern void bar(void) __attribute__((transaction_callable));\n+\n+foo()\n+{\n+\t__transaction_relaxed {\n+\t\tbar();\n+\t}\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GTMA_MAY_ENTER_IRREVOCABLE\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "ee759b84ef062e915eed94bceb1d9739d84350b0", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-4.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmmark\" } */\n+\n+void orig(void);\n+void xyz(void) __attribute__((transaction_wrap (orig)));\n+\n+\n+foo()\n+{\n+\t__transaction_relaxed {\n+\t\torig();\n+\t}\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GTMA_MAY_ENTER_IRREVOCABLE\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "155879f1a214f3450307db2141d12635c1687b99", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-5.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-5.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-ipa-tmipa -O\" } */\n+\n+int a;\n+\n+void foo(void) __attribute__((transaction_safe));\n+void bar(void) __attribute__((transaction_safe));\n+void danger(void) __attribute__((transaction_unsafe));\n+\n+void wildthing()\n+{\n+  /* All blocks should be propagated as irrevocable.  */\n+  __transaction_relaxed {\n+    if (a)\n+      foo();\n+    else\n+      bar();\n+    danger();\n+  }\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"GTMA_DOES_GO_IRREVOCABLE\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 3 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 4 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 5 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 6 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tmipa\" } } */"}, {"sha": "2399131210bb8f1afb74c169140e4ec1d0019fc5", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-6.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-6.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-ipa-tmipa -O\" } */\n+\n+int a, trxn, eee;\n+\n+void foo(void) __attribute__((transaction_safe));\n+void bar(void) __attribute__((transaction_safe));\n+void danger(void) __attribute__((transaction_unsafe));\n+\n+void wildthing()\n+{\n+  /* All blocks should be propagated as irrevocable.  */\n+  __transaction_relaxed {\n+    if (eee) {\n+      if (a)\n+\tfoo();\n+      else\n+\tbar();\n+      danger();\n+    } else {\n+      danger();\n+    }\n+  }\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"GTMA_DOES_GO_IRREVOCABLE\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 3 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 4 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 5 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 6 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 7 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 8 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { scan-ipa-dump-times \"bb 9 goes irr\" 1 \"tmipa\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tmipa\" } } */"}, {"sha": "ea8a00f0c5532747814cfa217d7d06c4daeba304", "filename": "gcc/testsuite/gcc.dg/tm/irrevocable-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Firrevocable-7.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-ipa-tmipa\" } */\n+\n+extern void bark(void);\n+\n+__attribute__((transaction_callable))\n+int foo()\n+{\n+      bark();\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"changeTransactionMode \\\\(0\\\\)\" 1 \"tmipa\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tmipa\" } } */"}, {"sha": "5388a81e2821628969e9b9b6014184d2a5ed9f99", "filename": "gcc/testsuite/gcc.dg/tm/memopt-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmemopt\" } */\n+\n+long g, xxx, yyy;\n+extern george() __attribute__((transaction_callable));\n+extern ringo(long int);\n+int i;\n+\n+f()\n+{\n+  __transaction_relaxed {\n+    g = 666;\n+    george();\n+    if (i == 9)\n+      goto bye;\n+    xxx=8;\n+    yyy=9;\n+    for (i=0; i < 10; ++i)\n+      ringo(g);\n+  bye:\n+    ringo(g);\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transforming: .*_ITM_RaWU8 \\\\(&g\\\\);\" 1 \"tmmemopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"transforming: .*_ITM_WaRU4 \\\\(&i,\" 1 \"tmmemopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"transforming: .*_ITM_RaWU4 \\\\(&i\\\\);\" 1 \"tmmemopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"transforming: .*_ITM_WaWU4 \\\\(&i,\" 1 \"tmmemopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmemopt\" } } */"}, {"sha": "5caa6b53d6b072be334761cdd41ee42fd3242720", "filename": "gcc/testsuite/gcc.dg/tm/memopt-10.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-10.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+extern int something(void) __attribute__((transaction_safe));\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc,transaction_safe));\n+\n+int f()\n+{\n+  int *p;\n+\n+  p = malloc (sizeof (*p) * 100);\n+\n+  __transaction_atomic {\n+    /* p[5] is thread private, but not transaction local since the\n+       malloc is outside of the transaction.  We can use the logging\n+       functions for this.  */\n+    p[5] = 123;\n+\n+    if (something())\n+      __transaction_cancel;\n+  }\n+  return p[5];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ITM_LU\" 0 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_WU\" 0 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"tm_save\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "07972a4fd4e7a89d5078d2976eeafb22c5a69fbb", "filename": "gcc/testsuite/gcc.dg/tm/memopt-11.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-11.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+extern int something(void) __attribute__((transaction_safe));\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc,transaction_safe));\n+\n+int f()\n+{\n+  int *p;\n+\n+  p = malloc (sizeof (*p) * 100);\n+  foo(p[5]);\n+\n+  __transaction_atomic {\n+    /* p[5] is thread private, however the SSA_NAME that holds the\n+       address dominates the entire transaction (transaction\n+       invariant) so we can use a save/restore pair.  */\n+    p[5] = 123;\n+\n+    if (something())\n+      __transaction_cancel;\n+  }\n+  return p[5];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ITM_LU\" 0 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"ITM_WU\" 0 \"tmmark\" } } */\n+/* { dg-final { scan-tree-dump-times \"tm_save\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "5520ecef27a1f6bfca06dfc70c48fb917bd74dde", "filename": "gcc/testsuite/gcc.dg/tm/memopt-12.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-12.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+extern int test(void) __attribute__((transaction_safe));\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc,transaction_safe));\n+\n+struct large { int foo[500]; };\n+\n+int f()\n+{\n+  int *p1, *p2, *p3;\n+\n+  p1 = malloc (sizeof (*p1)*5000);\n+  __transaction_atomic {\n+    *p1 = 0;\n+\n+    p2 = malloc (sizeof (*p2)*6000);\n+    *p2 = 1;\n+\n+    /* p3 = PHI (p1, p2) */\n+    if (test())\n+      p3 = p1;\n+    else\n+      p3 = p2;\n+\n+    /* Since both p1 and p2 are thread-private, we can inherit the\n+       logging already done.  No ITM_W* instrumentation necessary.  */\n+    *p3 = 555;\n+  }\n+  return p3[something()];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ITM_WU\" 0 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "6e93b7feaea5f11eb27baf2167503bc12aa0abb1", "filename": "gcc/testsuite/gcc.dg/tm/memopt-13.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-13.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+struct large { int x[100]; };\n+struct large large_global;\n+extern struct large function (void) __attribute__((transaction_safe));\n+\n+void f()\n+{\n+  __transaction_atomic {\n+      large_global = function();\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"memmoveRtWt \\\\\\(&large_global,\" 1 \"tmmark\" } } */"}, {"sha": "975c794337c67c58b449690c093bb848a82546b2", "filename": "gcc/testsuite/gcc.dg/tm/memopt-15.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-15.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile { target { x86_64-*-linux* } } } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+/* Test the TM vector logging functions.  */\n+\n+typedef int __attribute__((vector_size (16))) vectype;\n+extern int something(void) __attribute__((transaction_safe));\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc,transaction_safe));\n+\n+vectype vecky;\n+\n+vectype f()\n+{\n+  vectype *p;\n+\n+  p = malloc (sizeof (*p) * 100);\n+\n+  __transaction_atomic {\n+    /* p[5] is thread private, but not transaction local since the\n+       malloc is outside of the transaction.  We can use the logging\n+       functions for this.  */\n+    p[5] = vecky;\n+\n+    if (something())\n+      __transaction_cancel;\n+  }\n+  return p[5];\n+}\n+\n+/* { dg-final { scan-assembler \"_ITM_LM128\" } } */"}, {"sha": "08aa9acdcbc29e59f2b7f9d81ff6f4a80b14895f", "filename": "gcc/testsuite/gcc.dg/tm/memopt-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmemopt\" } */\n+\n+char c;\n+\n+void f(void)\n+{\n+  __transaction_atomic {\n+    ++c;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"transforming.*RfWU1 \\\\(&c\" 1 \"tmmemopt\" } } */\n+/* { dg-final { scan-tree-dump-times \"transforming.*WaWU1 \\\\(&c\" 1 \"tmmemopt\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmemopt\" } } */"}, {"sha": "62a3e0e9f2a8a33e59bdf5b2cb6c5a71f5654fab", "filename": "gcc/testsuite/gcc.dg/tm/memopt-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+struct large { int x[100]; };\n+extern int test(void) __attribute__((transaction_safe));\n+\n+int f()\n+{\n+  int i = readint();\n+  struct large lala = { 0 };\n+  __transaction_atomic {\n+    lala.x[i] = 666;\n+    if (test())\n+      __transaction_cancel;\n+  }\n+  return lala.x[0];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"logging: lala.x\\\\\\[i_1\\\\\\]\" 1 \"tmmark\" { xfail *-*-* }  } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "9284971844186f128374219bf90367c3d7605c92", "filename": "gcc/testsuite/gcc.dg/tm/memopt-4.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-4.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmedge\" } */\n+\n+/* Test thread-local memory optimizations: save/restore pairs.  */\n+\n+struct large { int x[100]; };\n+struct large bark();\n+extern int test (void) __attribute__((transaction_safe));\n+\n+int f()\n+{\n+  int i = readint();\n+  struct large lala = bark();\n+  __transaction_atomic {\n+    lala.x[55] = 666;\n+    if (test())\n+      __transaction_cancel;\n+  }\n+  return lala.x[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"tm_save.\\[0-9_\\]+ = lala.x\\\\\\[55\\\\\\]\" 1 \"tmedge\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"lala.x\\\\\\[55\\\\\\] = tm_save\" 1 \"tmedge\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */"}, {"sha": "7b377a580350338c41ca5993f5e001b0a71ad37c", "filename": "gcc/testsuite/gcc.dg/tm/memopt-5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-5.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmedge --param tm-max-aggregate-size=1\" } */\n+\n+/* Test thread-local memory optimizations: logging function.  */\n+\n+struct large { int x[100]; };\n+struct large bark();\n+extern int test (void) __attribute__((transaction_safe));\n+\n+int f()\n+{\n+  int i = readint();\n+  struct large lala = bark();\n+  __transaction_atomic {\n+    lala.x[55] = 666;\n+    if (test())\n+      __transaction_cancel;\n+  }\n+  return lala.x[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ITM_LU\\[0-9\\] \\\\\\(&lala.x\\\\\\[55\\\\\\]\" 1 \"tmedge\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */"}, {"sha": "f43437367725c3c5da1bfc674aa6f984a0e4506b", "filename": "gcc/testsuite/gcc.dg/tm/memopt-6.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-6.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmedge --param tm-max-aggregate-size=1\" } */\n+\n+struct large { int x[100]; };\n+struct large bark();\n+extern int test (void) __attribute__((transaction_safe));\n+struct large lacopy;\n+\n+int f()\n+{\n+  int i = readint();\n+  struct large lala = bark();\n+  __transaction_atomic {\n+    lala.x[55] = 666;\n+    lala = lacopy;\t\t/* Aggregate instrumentation.  */\n+  }\n+  return lala.x[i];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"memmoveRtWt \\\\\\(&lala, &lacopy\" 1 \"tmedge\" } } */"}, {"sha": "f8af2a95e6646f90fed688a2ca39bc669f29b30b", "filename": "gcc/testsuite/gcc.dg/tm/memopt-7.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-7.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmedge --param tm-max-aggregate-size=999\" } */\n+\n+/* Test save/restore pairs for aggregates.  */\n+\n+struct large { int x[100]; };\n+extern struct large foobie (void) __attribute__((transaction_safe));\n+int asdf;\n+\n+int f()\n+{\n+  struct large lala;\n+  struct large lacopy = foobie();\n+  __transaction_atomic {\n+    lala = lacopy;\n+  }\n+  return lala.x[asdf];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"tm_save.\\[0-9_\\]+ = lala\" 1 \"tmedge\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"lala = tm_save\" 1 \"tmedge\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */"}, {"sha": "10320e7895054cda99199dddc19f27684325bcf4", "filename": "gcc/testsuite/gcc.dg/tm/memopt-8.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-8.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+extern int something(void) __attribute__((transaction_safe));\n+extern int escape(int *) __attribute__((transaction_safe));\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc,transaction_safe));\n+\n+int f()\n+{\n+  int *p;\n+\n+  __transaction_atomic {\n+    p = malloc (sizeof (*p) * 100);\n+    escape (p);\n+\n+    /* This should be instrumented because P escapes.  */\n+    p[5] = 123;\n+\n+    if (something())\n+      __transaction_cancel;\n+  }\n+  return p[5];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ITM_WU\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "0c34f20b9262c9586abbe738f8a643e977ffc5f5", "filename": "gcc/testsuite/gcc.dg/tm/memopt-9.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemopt-9.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O -fdump-tree-tmmark\" } */\n+\n+extern int something(void) __attribute__((transaction_safe));\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc,transaction_safe));\n+\n+struct large { int foo[500]; };\n+\n+int f()\n+{\n+  int *p;\n+  struct large *lp;\n+\n+  __transaction_atomic {\n+    p = malloc (sizeof (*p) * 100);\n+    lp = malloc (sizeof (*lp) * 100);\n+\n+    /* No instrumentation necessary; P and LP are transaction local.  */\n+    p[5] = 123;\n+    lp->foo[66] = 123;\n+\n+    if (something())\n+      __transaction_cancel;\n+  }\n+  return p[5];\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"ITM_WU\" 0 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "743ada137833d3fd57601dd67d4975305a4c01be", "filename": "gcc/testsuite/gcc.dg/tm/memset-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemset-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemset-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemset-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmlower\" } */\n+\n+char array[4];\n+\n+void *memset(void *s, int c, __SIZE_TYPE__);\n+\n+int main()\n+{\n+  __transaction_atomic {\n+    memset(array, 'b', sizeof(4));\n+  }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"GTMA_HAVE_STORE\" 1 \"tmlower\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmlower\" } } */"}, {"sha": "3b73ec6ee74001616b399b1ccdcde717d83fd46d", "filename": "gcc/testsuite/gcc.dg/tm/memset.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fmemset.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+extern void *memset (void *, int, __SIZE_TYPE__);\n+\n+char array[4] = \"aaaa\";\n+\n+__attribute__((transaction_safe))\n+void *my_memset()\n+{\n+  return memset(array,'b',4);\n+}\n+\n+\n+int main()\n+{\n+\n+\t__transaction_atomic {\n+\t\tmy_memset();\n+\t}\n+\treturn 0;\n+}\n+\n+/* { dg-final { scan-assembler \"_ITM_memsetW\" } } */"}, {"sha": "afadb83c1833d8c52d432463213d15db6c293b5a", "filename": "gcc/testsuite/gcc.dg/tm/nested-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fnested-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fnested-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fnested-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+extern int foo(int) __attribute__((transaction_safe));\n+void bar(void)\n+{\n+  __transaction_atomic {\n+    if (foo(1))\n+      __transaction_atomic {\n+\tif (foo(2))\n+\t  __transaction_atomic {\n+\t    if (foo(3))\n+\t      __transaction_atomic {\n+\t\tif (foo(4))\n+\t\t  foo(5);\n+\t\telse\n+\t\t  __transaction_cancel;\n+\t      }\n+\t    else\n+\t      __transaction_cancel;\n+\t  }\n+\telse\n+\t  __transaction_cancel;\n+      }\n+    else\n+      __transaction_cancel;\n+  }\n+}"}, {"sha": "205ca8d7eac6a13e1181152581030a563636a139", "filename": "gcc/testsuite/gcc.dg/tm/nested-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fnested-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fnested-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fnested-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+void foobar(void)\n+{\n+    __transaction_atomic {\n+       foobar();\n+    }\n+}\n+\n+void doit(void) __attribute__((transaction_safe));\n+\n+__attribute__((transaction_callable))\n+void callable(void)\n+{\n+  __transaction_atomic {\n+    doit();\n+  }\n+}"}, {"sha": "87a8c72bd4337e8782431dd6aee537151219c604", "filename": "gcc/testsuite/gcc.dg/tm/opt-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fopt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fopt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fopt-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+extern void usleep (int) __attribute__((transaction_pure));\n+extern int rand(void) __attribute__((pure, transaction_pure));\n+extern int printf (const char *, ...);\n+extern void *malloc (__SIZE_TYPE__) __attribute__((malloc));\n+extern void xyzzy (void * (*)(void *));\n+\n+typedef struct\n+{\n+  int id;\n+} parm;\n+\n+int gvar;\n+\n+void *hello(void *arg)\n+{\n+  parm *p=(parm *)arg;\n+  int tmp = p->id;\n+  int tmp3;\n+  printf (\"Thread reads %d.\\n\", tmp);\n+  __transaction_atomic\n+    {\n+      int tmp2 = gvar;\n+      usleep ((int) (10.0*rand()/(10+1.0))/100);\n+      gvar = tmp + tmp2;\n+      tmp3 = gvar;\n+    }\n+  printf(\"tmp3 = %d\\n\", tmp3);\n+  return 0;\n+}\n+\n+int\n+main()\n+{\n+  int i, n = rand();\n+\n+  for (i=0; i<n; i++)\n+    xyzzy (hello);\n+\n+  return 0;\n+}"}, {"sha": "d9e2b8a6db0d3560fc8bba3a39c18e1e37bcb84c", "filename": "gcc/testsuite/gcc.dg/tm/opt-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fopt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fopt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fopt-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O2\" } */\n+\n+int foo(int *arr, int v)\n+{\n+  int r = 0;\n+  int i;\n+  __transaction_atomic {\n+    for (i = 0; i < 10; ++i)\n+      if (arr[i] < 27)\n+\tr += arr[i] += v;\n+  }\n+  return r;\n+}"}, {"sha": "c811840677628b3c0099c2db1c5a4ffc2d34845f", "filename": "gcc/testsuite/gcc.dg/tm/pr45985.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr45985.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr45985.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr45985.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+__attribute__((transaction_unsafe))\n+void illegal();\n+\n+static int a = 0;\n+void func()\n+{\n+  __transaction_relaxed {\n+    if( a == 0)\n+      illegal();\n+  }\n+}"}, {"sha": "bfe0078bfdbf505b2e72d2319c9bca9de40e94e4", "filename": "gcc/testsuite/gcc.dg/tm/pr46567-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46567-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46567-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46567-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+int funky();\n+int global;\n+\n+void SeqfileGetLine()\n+{\n+  funky();\n+}\n+\n+__attribute__((transaction_callable)) void readLoop()\n+{\n+\tSeqfileGetLine();\n+\tif (global)\n+\t  funky();\n+\n+}"}, {"sha": "bcc59adf509eb8b8e66cabe91bfd556eb8699b4c", "filename": "gcc/testsuite/gcc.dg/tm/pr46567.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46567.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46567.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46567.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,18 @@\n+__attribute__((transaction_callable))\n+static void SeqfileGetLine ()\n+{\n+  SSIGetFilePosition ();\n+}\n+\n+__attribute__((transaction_callable))\n+static void readLoop (int addfirst)\n+{\n+  if (!addfirst)\n+    {\n+      if (!addfirst)\n+\t{\n+\t  SSIGetFilePosition ();\n+\t}\n+      SeqfileGetLine ();\n+    }\n+}"}, {"sha": "bb63b685844b54114724c0a21410b7b7f64199a6", "filename": "gcc/testsuite/gcc.dg/tm/pr46654.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46654.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46654.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr46654.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+extern void baz(int);\n+\n+int y;\n+void foo(volatile int x)\n+{\n+  __transaction_atomic {\n+    x = 5; /* { dg-error \"invalid volatile use of 'x' inside transaction\" } */\n+    x += y;\n+    y++;\n+  }\n+  baz(x);\n+}\n+\n+\n+volatile int i = 0;\n+\n+void george()\n+{\n+  __transaction_atomic {\n+   if (i == 2) /* { dg-error \"invalid volatile use of 'i' inside transaction\" } */\n+     i = 1;\n+  }\n+}"}, {"sha": "80b976bd4cb7b92c08cce5ac7d2280e047fb893f", "filename": "gcc/testsuite/gcc.dg/tm/pr47520.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47520.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47520.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47520.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O\" } */\n+\n+struct ReadSeqVars\n+{\n+\tint format;\n+\tchar *ss;\n+};\n+\n+void rms_feof(struct ReadSeqVars *);\n+\n+__attribute__((transaction_callable)) int ReadSeq(struct ReadSeqVars *V)\n+{\n+\tif (V->format > 1)\n+\t{\n+\t\tif ((V->format != 2) && (V->ss != (void*)0) )\n+\t\t{\n+\t\t\tV->format = 3;\n+\t\t}\n+\t}\n+\telse\n+\t{\n+\t\tint i = 0;\n+\t\tfor (i = 0; i < 1; i++)\n+\t\t{\n+\t\t}\n+\t\trms_feof(V);\n+\t}\n+}"}, {"sha": "d18e2e11fb8cda5400c2cfbf72bae622da0fae7c", "filename": "gcc/testsuite/gcc.dg/tm/pr47690.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47690.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47690.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47690.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+int george;\n+\n+void q1()\n+{\n+  __transaction_atomic {\n+      george=999;\n+  }\n+  q1();\n+}\n+\n+/* { dg-final { scan-assembler-not \"ZGTt2q1\" } } */"}, {"sha": "c4b254930c1faf9387f3e62273a1d9d71f0f4117", "filename": "gcc/testsuite/gcc.dg/tm/pr47905.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47905.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47905.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fpr47905.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile }\n+   { dg-options \"-fgnu-tm\" } */\n+\n+void funcA();\n+void funcB();\n+\n+void *thread()\n+{\n+\t__transaction_relaxed\n+\t{\n+\t\tfuncA();\n+\t};\n+\tfuncB();\n+}"}, {"sha": "8969024048633dc2f6308b21c8303eef4d684326", "filename": "gcc/testsuite/gcc.dg/tm/props-1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmedge -fdump-tree-tmlower\" } */\n+\n+int global;\n+\n+foo(int local)\n+{\n+  __transaction_atomic {\n+    local++;\n+    if (++global == 10)\n+      __transaction_cancel;\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" instrumentedCode\" 1 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"hasNoAbort\" 0 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"GTMA_HAVE_ABORT\" 1 \"tmlower\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmlower\" } } */"}, {"sha": "56a3ffa1367489b7c64ce8be8f656a3eb02ef0d8", "filename": "gcc/testsuite/gcc.dg/tm/props-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-ipa-tmipa\" } */\n+\n+/* Test that irrevocability gets set for the obvious case.  */\n+\n+int global;\n+int george;\n+\n+extern crap() __attribute__((transaction_unsafe));\n+\n+foo(){\n+    __transaction_relaxed {\n+\tglobal++;\n+\tcrap();\n+\tgeorge++;\n+    }\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"GTMA_MAY_ENTER_IRREVOCABLE\" 1 \"tmipa\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tmipa\" } } */"}, {"sha": "48f2230cdd2539d4e45ab96f16ac25d27e6c6dde", "filename": "gcc/testsuite/gcc.dg/tm/props-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-ipa-tmipa\" } */\n+\n+/* Test that indirect calls set the irrevocable bit.  */\n+\n+void (*indirect)(void);\n+\n+foo(){\n+    __transaction_relaxed {\n+      (*indirect)();\n+    }\n+}\n+\n+/* { dg-final { scan-ipa-dump-times \"GTMA_MAY_ENTER_IRREVOCABLE\" 1 \"tmipa\" } } */\n+/* { dg-final { cleanup-ipa-dump \"tmipa\" } } */"}, {"sha": "c9d0c2b288759fa4726be1c9d58b2c770092c164", "filename": "gcc/testsuite/gcc.dg/tm/props-4.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fprops-4.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-tmedge -fdump-tree-tmmark\" } */\n+\n+int a, b;\n+\n+void __attribute((transaction_may_cancel_outer,noinline)) cancel1()\n+{\n+  __transaction_cancel [[outer]];\n+}\n+\n+void\n+foo(void)\n+{\n+  __transaction_atomic [[outer]] {\n+    a = 2;\n+    __transaction_atomic {\n+      b = 2;\n+      cancel1();\n+    }\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \" instrumentedCode\" 1 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"hasNoAbort\" 0 \"tmedge\" } } */\n+/* { dg-final { scan-tree-dump-times \"LABEL=<L0>\" 1 \"tmmark\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmedge\" } } */\n+/* { dg-final { cleanup-tree-dump \"tmmark\" } } */"}, {"sha": "3d24481d5a8ad248043de2bbc7e10bcaf0889d94", "filename": "gcc/testsuite/gcc.dg/tm/tm.exp", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Ftm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Ftm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Ftm.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,39 @@\n+#   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Run the tests that are shared with C++ testing.\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/tm/*c]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+# Run the C-only tests.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\]]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "824368a1a347611b3f9b68de104982bbbfffad2c", "filename": "gcc/testsuite/gcc.dg/tm/unsafe.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Funsafe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Funsafe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Funsafe.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+__attribute__((transaction_callable))\n+static int func ()\n+{\n+  return 12345;\n+}\n+\n+int main()\n+{\n+  __transaction_atomic { return func(); } /* { dg-error \"unsafe function call .func. \" } */\n+}"}, {"sha": "7c8aa3e778ddc63d94d0eac091867d07a195ec8b", "filename": "gcc/testsuite/gcc.dg/tm/unused.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Funused.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Funused.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Funused.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -Wall\" } */\n+\n+__attribute__((transaction_safe))\n+static int unused_func ()\t/* { dg-warning \"defined but not used\" } */\n+{\n+  return 12345;\n+}\n+\n+int main()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"_ZGTt11unused_func:\" } } */"}, {"sha": "2dc43b0a5177a906a0c452758eb72e50a0ecd1cd", "filename": "gcc/testsuite/gcc.dg/tm/vector-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fvector-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fvector-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fvector-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -O3\" } */\n+\n+/* On x86-64, the vectorizer creates V2DI uses which we must handle.\n+   Similarly for other vector architectures.  */\n+\n+void ** newElements;\n+\n+__attribute__((transaction_safe))\n+long\n+TMqueue_push (void** queuePtr)\n+{\n+   long src;\n+   for (src = 1; src < 9; src++) {\n+     newElements[src+1] = queuePtr[src];\n+   }\n+   return 1;\n+}"}, {"sha": "29486335a44f6a7d7ec95ff3db390146010f2dbc", "filename": "gcc/testsuite/gcc.dg/tm/wrap-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm\" } */\n+\n+#define W(X)\t__attribute__((transaction_wrap(X)))\n+void f1(void);\n+void f2(int);\n+int i3;\n+int f7(void);\n+\n+void g1(void) W(f1);\n+void g2(void) W(f2);\t/* { dg-error \"is not compatible\" } */\n+void g3(void) W(i3);\t/* { dg-error \"is not a function\" } */\n+void g4(void) W(f4);\t/* { dg-error \"is not a function\" } */\n+void g5(void) W(1);\t/* { dg-error \"not an identifier\" } */\n+void g6(void) W(\"f1\");\t/* { dg-error \"not an identifier\" } */\n+void g7(void) W(f7);\t/* { dg-error \"is not compatible\" } */"}, {"sha": "0734436809fd80d201ebc9f8dfe1f90584befa3c", "filename": "gcc/testsuite/gcc.dg/tm/wrap-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-3.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-optimized\" } */\n+\n+void free (void *);\n+void wrapper (void *) __attribute__((transaction_wrap (free)));\n+void *p;\n+\n+void foo()\n+{\n+  __transaction_relaxed { free (p); }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"free\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "9e1e70c544fc407f6b711a66b58cec564b3c85ab", "filename": "gcc/testsuite/gcc.dg/tm/wrap-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftm%2Fwrap-4.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fgnu-tm -fdump-tree-optimized -O2\" } */\n+\n+static void candy() { candycane(); }\n+\n+static void tootsie_roll () __attribute__((transaction_wrap (candy)));\n+static void tootsie_roll () { bark(); }\n+\n+void foo()\n+{\n+  __transaction_relaxed { candy(); }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"candy\" 0 \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "d4a60fceefadb0dc06bd00ecc288ec79913a9e77", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -184,6 +184,7 @@ DEFTIMEVAR (TV_TREE_COPY_RENAME\t     , \"tree rename SSA copies\")\n DEFTIMEVAR (TV_TREE_SSA_VERIFY       , \"tree SSA verifier\")\n DEFTIMEVAR (TV_TREE_STMT_VERIFY      , \"tree STMT verifier\")\n DEFTIMEVAR (TV_TREE_SWITCH_CONVERSION, \"tree switch initialization conversion\")\n+DEFTIMEVAR (TV_TRANS_MEM             , \"transactional memory\")\n DEFTIMEVAR (TV_TREE_STRLEN           , \"tree strlen optimization\")\n DEFTIMEVAR (TV_CGRAPH_VERIFY         , \"callgraph verifier\")\n DEFTIMEVAR (TV_DOM_FRONTIERS         , \"dominance frontiers\")"}, {"sha": "de255b4c3f72af7c803b5d84154b81a4abdcc7cb", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -599,6 +599,7 @@ compile_file (void)\n \n       output_shared_constant_pool ();\n       output_object_blocks ();\n+  finish_tm_clone_pairs ();\n \n       /* Write out any pending weak symbol declarations.  */\n       weak_finish ();"}, {"sha": "3c0bd600943f33ed57bee293c22ed7a6df69f674", "filename": "gcc/trans-mem.c", "status": "added", "additions": 4914, "deletions": 0, "changes": 4914, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "95e9e7e5f007804fbc2294fb001426d1086c8f86", "filename": "gcc/trans-mem.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftrans-mem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftrans-mem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,35 @@\n+/* Miscellaneous transactional memory support definitions.\n+   Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* These defines must match the enumerations in libitm.h.  */\n+#define PR_INSTRUMENTEDCODE\t0x0001\n+#define PR_UNINSTRUMENTEDCODE\t0x0002\n+#define PR_HASNOXMMUPDATE\t0x0004\n+#define PR_HASNOABORT\t\t0x0008\n+#define PR_HASNOIRREVOCABLE\t0x0020\n+#define PR_DOESGOIRREVOCABLE\t0x0040\n+#define PR_HASNOSIMPLEREADS\t0x0080\n+#define PR_AWBARRIERSOMITTED\t0x0100\n+#define PR_RARBARRIERSOMITTED\t0x0200\n+#define PR_UNDOLOGCODE\t\t0x0400\n+#define PR_PREFERUNINSTRUMENTED\t0x0800\n+#define PR_EXCEPTIONBLOCK\t0x1000\n+#define PR_HASELSE\t\t0x2000\n+#define PR_READONLY\t\t0x4000"}, {"sha": "d81cc670bf4f55c9dcd1e48733d25702291d2729", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 93, "deletions": 16, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -117,6 +117,7 @@ static int gimple_verify_flow_info (void);\n static void gimple_make_forwarder_block (edge);\n static void gimple_cfg2vcg (FILE *);\n static gimple first_non_label_stmt (basic_block);\n+static bool verify_gimple_transaction (gimple);\n \n /* Flowgraph optimization and cleanup.  */\n static void gimple_merge_blocks (basic_block, basic_block);\n@@ -666,6 +667,15 @@ make_edges (void)\n \t\t}\n \t      break;\n \n+\t    case GIMPLE_TRANSACTION:\n+\t      {\n+\t\ttree abort_label = gimple_transaction_label (last);\n+\t\tif (abort_label)\n+\t\t  make_edge (bb, label_to_block (abort_label), 0);\n+\t\tfallthru = true;\n+\t      }\n+\t      break;\n+\n \t    default:\n \t      gcc_assert (!stmt_ends_bb_p (last));\n \t      fallthru = true;\n@@ -1196,22 +1206,30 @@ cleanup_dead_labels (void)\n   FOR_EACH_BB (bb)\n     {\n       gimple stmt = last_stmt (bb);\n+      tree label, new_label;\n+\n       if (!stmt)\n \tcontinue;\n \n       switch (gimple_code (stmt))\n \t{\n \tcase GIMPLE_COND:\n-\t  {\n-\t    tree true_label = gimple_cond_true_label (stmt);\n-\t    tree false_label = gimple_cond_false_label (stmt);\n+\t  label = gimple_cond_true_label (stmt);\n+\t  if (label)\n+\t    {\n+\t      new_label = main_block_label (label);\n+\t      if (new_label != label)\n+\t\tgimple_cond_set_true_label (stmt, new_label);\n+\t    }\n \n-\t    if (true_label)\n-\t      gimple_cond_set_true_label (stmt, main_block_label (true_label));\n-\t    if (false_label)\n-\t      gimple_cond_set_false_label (stmt, main_block_label (false_label));\n-\t    break;\n-\t  }\n+\t  label = gimple_cond_false_label (stmt);\n+\t  if (label)\n+\t    {\n+\t      new_label = main_block_label (label);\n+\t      if (new_label != label)\n+\t\tgimple_cond_set_false_label (stmt, new_label);\n+\t    }\n+\t  break;\n \n \tcase GIMPLE_SWITCH:\n \t  {\n@@ -1221,8 +1239,10 @@ cleanup_dead_labels (void)\n \t    for (i = 0; i < n; ++i)\n \t      {\n \t\ttree case_label = gimple_switch_label (stmt, i);\n-\t\ttree label = main_block_label (CASE_LABEL (case_label));\n-\t\tCASE_LABEL (case_label) = label;\n+\t\tlabel = CASE_LABEL (case_label);\n+\t\tnew_label = main_block_label (label);\n+\t\tif (new_label != label)\n+\t\t  CASE_LABEL (case_label) = new_label;\n \t      }\n \t    break;\n \t  }\n@@ -1243,13 +1263,27 @@ cleanup_dead_labels (void)\n \t/* We have to handle gotos until they're removed, and we don't\n \t   remove them until after we've created the CFG edges.  */\n \tcase GIMPLE_GOTO:\n-          if (!computed_goto_p (stmt))\n+\t  if (!computed_goto_p (stmt))\n \t    {\n-\t      tree new_dest = main_block_label (gimple_goto_dest (stmt));\n-\t      gimple_goto_set_dest (stmt, new_dest);\n+\t      label = gimple_goto_dest (stmt);\n+\t      new_label = main_block_label (label);\n+\t      if (new_label != label)\n+\t\tgimple_goto_set_dest (stmt, new_label);\n \t    }\n \t  break;\n \n+\tcase GIMPLE_TRANSACTION:\n+\t  {\n+\t    tree label = gimple_transaction_label (stmt);\n+\t    if (label)\n+\t      {\n+\t\ttree new_label = main_block_label (label);\n+\t\tif (new_label != label)\n+\t\t  gimple_transaction_set_label (stmt, new_label);\n+\t      }\n+\t  }\n+\t  break;\n+\n \tdefault:\n \t  break;\n       }\n@@ -2272,6 +2306,13 @@ is_ctrl_altering_stmt (gimple t)\n \tif (flags & ECF_NORETURN)\n \t  return true;\n \n+\t/* TM ending statements have backedges out of the transaction.\n+\t   Return true so we split the basic block containing them.\n+\t   Note that the TM_BUILTIN test is merely an optimization.  */\n+\tif ((flags & ECF_TM_BUILTIN)\n+\t    && is_tm_ending_fndecl (gimple_call_fndecl (t)))\n+\t  return true;\n+\n \t/* BUILT_IN_RETURN call is same as return statement.  */\n \tif (gimple_call_builtin_p (t, BUILT_IN_RETURN))\n \t  return true;\n@@ -2293,6 +2334,10 @@ is_ctrl_altering_stmt (gimple t)\n       /* OpenMP directives alter control flow.  */\n       return true;\n \n+    case GIMPLE_TRANSACTION:\n+      /* A transaction start alters control flow.  */\n+      return true;\n+\n     default:\n       break;\n     }\n@@ -4063,7 +4108,6 @@ verify_gimple_switch (gimple stmt)\n   return false;\n }\n \n-\n /* Verify a gimple debug statement STMT.\n    Returns true if anything is wrong.  */\n \n@@ -4164,6 +4208,9 @@ verify_gimple_stmt (gimple stmt)\n     case GIMPLE_ASM:\n       return false;\n \n+    case GIMPLE_TRANSACTION:\n+      return verify_gimple_transaction (stmt);\n+\n     /* Tuples that do not have tree operands.  */\n     case GIMPLE_NOP:\n     case GIMPLE_PREDICT:\n@@ -4280,10 +4327,19 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n \t  err |= verify_gimple_in_seq_2 (gimple_eh_filter_failure (stmt));\n \t  break;\n \n+\tcase GIMPLE_EH_ELSE:\n+\t  err |= verify_gimple_in_seq_2 (gimple_eh_else_n_body (stmt));\n+\t  err |= verify_gimple_in_seq_2 (gimple_eh_else_e_body (stmt));\n+\t  break;\n+\n \tcase GIMPLE_CATCH:\n \t  err |= verify_gimple_in_seq_2 (gimple_catch_handler (stmt));\n \t  break;\n \n+\tcase GIMPLE_TRANSACTION:\n+\t  err |= verify_gimple_transaction (stmt);\n+\t  break;\n+\n \tdefault:\n \t  {\n \t    bool err2 = verify_gimple_stmt (stmt);\n@@ -4297,6 +4353,18 @@ verify_gimple_in_seq_2 (gimple_seq stmts)\n   return err;\n }\n \n+/* Verify the contents of a GIMPLE_TRANSACTION.  Returns true if there\n+   is a problem, otherwise false.  */\n+\n+static bool\n+verify_gimple_transaction (gimple stmt)\n+{\n+  tree lab = gimple_transaction_label (stmt);\n+  if (lab != NULL && TREE_CODE (lab) != LABEL_DECL)\n+    return true;\n+  return verify_gimple_in_seq_2 (gimple_transaction_body (stmt));\n+}\n+\n \n /* Verify the GIMPLE statements inside the statement list STMTS.  */\n \n@@ -5061,6 +5129,13 @@ gimple_redirect_edge_and_branch (edge e, basic_block dest)\n \tredirect_eh_dispatch_edge (stmt, e, dest);\n       break;\n \n+    case GIMPLE_TRANSACTION:\n+      /* The ABORT edge has a stored label associated with it, otherwise\n+\t the edges are simply redirectable.  */\n+      if (e->flags == 0)\n+\tgimple_transaction_set_label (stmt, gimple_block_label (dest));\n+      break;\n+\n     default:\n       /* Otherwise it must be a fallthru edge, and we don't need to\n \t do anything besides redirecting it.  */\n@@ -6443,8 +6518,10 @@ dump_function_to_file (tree fn, FILE *file, int flags)\n   bool ignore_topmost_bind = false, any_var = false;\n   basic_block bb;\n   tree chain;\n+  bool tmclone = TREE_CODE (fn) == FUNCTION_DECL && decl_is_tm_clone (fn);\n \n-  fprintf (file, \"%s (\", lang_hooks.decl_printable_name (fn, 2));\n+  fprintf (file, \"%s %s(\", lang_hooks.decl_printable_name (fn, 2),\n+\t   tmclone ? \"[tm-clone] \" : \"\");\n \n   arg = DECL_ARGUMENTS (fn);\n   while (arg)"}, {"sha": "440ac0f4082d42804db1c2fd3ed9c59549d5f6ea", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 133, "deletions": 40, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -54,26 +54,6 @@ using_eh_for_cleanups (void)\n \n /* Misc functions used in this file.  */\n \n-/* Compare and hash for any structure which begins with a canonical\n-   pointer.  Assumes all pointers are interchangeable, which is sort\n-   of already assumed by gcc elsewhere IIRC.  */\n-\n-static int\n-struct_ptr_eq (const void *a, const void *b)\n-{\n-  const void * const * x = (const void * const *) a;\n-  const void * const * y = (const void * const *) b;\n-  return *x == *y;\n-}\n-\n-static hashval_t\n-struct_ptr_hash (const void *a)\n-{\n-  const void * const * x = (const void * const *) a;\n-  return (size_t)*x >> 4;\n-}\n-\n-\n /* Remember and lookup EH landing pad data for arbitrary statements.\n    Really this means any statement that could_throw_p.  We could\n    stuff this information into the stmt_ann data structure, but:\n@@ -284,6 +264,11 @@ collect_finally_tree (gimple stmt, gimple region)\n       collect_finally_tree_1 (gimple_eh_filter_failure (stmt), region);\n       break;\n \n+    case GIMPLE_EH_ELSE:\n+      collect_finally_tree_1 (gimple_eh_else_n_body (stmt), region);\n+      collect_finally_tree_1 (gimple_eh_else_e_body (stmt), region);\n+      break;\n+\n     default:\n       /* A type, a decl, or some kind of statement that we're not\n \t interested in.  Don't walk them.  */\n@@ -534,6 +519,10 @@ replace_goto_queue_1 (gimple stmt, struct leh_tf_state *tf,\n     case GIMPLE_EH_FILTER:\n       replace_goto_queue_stmt_list (gimple_eh_filter_failure (stmt), tf);\n       break;\n+    case GIMPLE_EH_ELSE:\n+      replace_goto_queue_stmt_list (gimple_eh_else_n_body (stmt), tf);\n+      replace_goto_queue_stmt_list (gimple_eh_else_e_body (stmt), tf);\n+      break;\n \n     default:\n       /* These won't have gotos in them.  */\n@@ -921,6 +910,21 @@ lower_try_finally_fallthru_label (struct leh_tf_state *tf)\n   return label;\n }\n \n+/* A subroutine of lower_try_finally.  If FINALLY consits of a\n+   GIMPLE_EH_ELSE node, return it.  */\n+\n+static inline gimple\n+get_eh_else (gimple_seq finally)\n+{\n+  gimple x = gimple_seq_first_stmt (finally);\n+  if (gimple_code (x) == GIMPLE_EH_ELSE)\n+    {\n+      gcc_assert (gimple_seq_singleton_p (finally));\n+      return x;\n+    }\n+  return NULL;\n+}\n+\n /* A subroutine of lower_try_finally.  If the eh_protect_cleanup_actions\n    langhook returns non-null, then the language requires that the exception\n    path out of a try_finally be treated specially.  To wit: the code within\n@@ -950,7 +954,7 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n   gimple_stmt_iterator gsi;\n   bool finally_may_fallthru;\n   gimple_seq finally;\n-  gimple x;\n+  gimple x, eh_else;\n \n   /* First check for nothing to do.  */\n   if (lang_hooks.eh_protect_cleanup_actions == NULL)\n@@ -960,12 +964,18 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n     return;\n \n   finally = gimple_try_cleanup (tf->top_p);\n-  finally_may_fallthru = gimple_seq_may_fallthru (finally);\n+  eh_else = get_eh_else (finally);\n \n   /* Duplicate the FINALLY block.  Only need to do this for try-finally,\n-     and not for cleanups.  */\n-  if (this_state)\n+     and not for cleanups.  If we've got an EH_ELSE, extract it now.  */\n+  if (eh_else)\n+    {\n+      finally = gimple_eh_else_e_body (eh_else);\n+      gimple_try_set_cleanup (tf->top_p, gimple_eh_else_n_body (eh_else));\n+    }\n+  else if (this_state)\n     finally = lower_try_finally_dup_block (finally, outer_state);\n+  finally_may_fallthru = gimple_seq_may_fallthru (finally);\n \n   /* If this cleanup consists of a TRY_CATCH_EXPR with TRY_CATCH_IS_CLEANUP\n      set, the handler of the TRY_CATCH_EXPR is another cleanup which ought\n@@ -1011,7 +1021,7 @@ lower_try_finally_nofallthru (struct leh_state *state,\n \t\t\t      struct leh_tf_state *tf)\n {\n   tree lab;\n-  gimple x;\n+  gimple x, eh_else;\n   gimple_seq finally;\n   struct goto_queue_node *q, *qe;\n \n@@ -1034,15 +1044,35 @@ lower_try_finally_nofallthru (struct leh_state *state,\n \n   replace_goto_queue (tf);\n \n-  lower_eh_constructs_1 (state, finally);\n-  gimple_seq_add_seq (&tf->top_p_seq, finally);\n+  /* Emit the finally block into the stream.  Lower EH_ELSE at this time.  */\n+  eh_else = get_eh_else (finally);\n+  if (eh_else)\n+    {\n+      finally = gimple_eh_else_n_body (eh_else);\n+      lower_eh_constructs_1 (state, finally);\n+      gimple_seq_add_seq (&tf->top_p_seq, finally);\n \n-  if (tf->may_throw)\n+      if (tf->may_throw)\n+\t{\n+\t  finally = gimple_eh_else_e_body (eh_else);\n+\t  lower_eh_constructs_1 (state, finally);\n+\n+\t  emit_post_landing_pad (&eh_seq, tf->region);\n+\t  gimple_seq_add_seq (&eh_seq, finally);\n+\t}\n+    }\n+  else\n     {\n-      emit_post_landing_pad (&eh_seq, tf->region);\n+      lower_eh_constructs_1 (state, finally);\n+      gimple_seq_add_seq (&tf->top_p_seq, finally);\n \n-      x = gimple_build_goto (lab);\n-      gimple_seq_add_stmt (&eh_seq, x);\n+      if (tf->may_throw)\n+\t{\n+\t  emit_post_landing_pad (&eh_seq, tf->region);\n+\n+\t  x = gimple_build_goto (lab);\n+\t  gimple_seq_add_stmt (&eh_seq, x);\n+\t}\n     }\n }\n \n@@ -1062,6 +1092,18 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n   finally = gimple_try_cleanup (tf->top_p);\n   tf->top_p_seq = gimple_try_eval (tf->top_p);\n \n+  /* Since there's only one destination, and the destination edge can only\n+     either be EH or non-EH, that implies that all of our incoming edges\n+     are of the same type.  Therefore we can lower EH_ELSE immediately.  */\n+  x = get_eh_else (finally);\n+  if (x)\n+    {\n+      if (tf->may_throw)\n+\tfinally = gimple_eh_else_e_body (x);\n+      else\n+\tfinally = gimple_eh_else_n_body (x);\n+    }\n+\n   lower_eh_constructs_1 (state, finally);\n \n   if (tf->may_throw)\n@@ -1132,11 +1174,18 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n   gimple_seq finally;\n   gimple_seq new_stmt;\n   gimple_seq seq;\n-  gimple x;\n+  gimple x, eh_else;\n   tree tmp;\n   location_t tf_loc = gimple_location (tf->try_finally_expr);\n \n   finally = gimple_try_cleanup (tf->top_p);\n+\n+  /* Notice EH_ELSE, and simplify some of the remaining code\n+     by considering FINALLY to be the normal return path only.  */\n+  eh_else = get_eh_else (finally);\n+  if (eh_else)\n+    finally = gimple_eh_else_n_body (eh_else);\n+\n   tf->top_p_seq = gimple_try_eval (tf->top_p);\n   new_stmt = NULL;\n \n@@ -1153,7 +1202,12 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n \n   if (tf->may_throw)\n     {\n-      seq = lower_try_finally_dup_block (finally, state);\n+      /* We don't need to copy the EH path of EH_ELSE,\n+\t since it is only emitted once.  */\n+      if (eh_else)\n+\tseq = gimple_eh_else_e_body (eh_else);\n+      else\n+\tseq = lower_try_finally_dup_block (finally, state);\n       lower_eh_constructs_1 (state, seq);\n \n       emit_post_landing_pad (&eh_seq, tf->region);\n@@ -1252,7 +1306,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   tree last_case;\n   VEC (tree,heap) *case_label_vec;\n   gimple_seq switch_body;\n-  gimple x;\n+  gimple x, eh_else;\n   tree tmp;\n   gimple switch_stmt;\n   gimple_seq finally;\n@@ -1263,9 +1317,10 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   location_t finally_loc;\n \n   switch_body = gimple_seq_alloc ();\n+  finally = gimple_try_cleanup (tf->top_p);\n+  eh_else = get_eh_else (finally);\n \n   /* Mash the TRY block to the head of the chain.  */\n-  finally = gimple_try_cleanup (tf->top_p);\n   tf->top_p_seq = gimple_try_eval (tf->top_p);\n \n   /* The location of the finally is either the last stmt in the finally\n@@ -1281,7 +1336,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   nlabels = VEC_length (tree, tf->dest_array);\n   return_index = nlabels;\n   eh_index = return_index + tf->may_return;\n-  fallthru_index = eh_index + tf->may_throw;\n+  fallthru_index = eh_index + (tf->may_throw && !eh_else);\n   ndests = fallthru_index + tf->may_fallthru;\n \n   finally_tmp = create_tmp_var (integer_type_node, \"finally_tmp\");\n@@ -1319,7 +1374,23 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       gimple_seq_add_stmt (&switch_body, x);\n     }\n \n-  if (tf->may_throw)\n+  /* For EH_ELSE, emit the exception path (plus resx) now, then\n+     subsequently we only need consider the normal path.  */\n+  if (eh_else)\n+    {\n+      if (tf->may_throw)\n+\t{\n+\t  finally = gimple_eh_else_e_body (eh_else);\n+\t  lower_eh_constructs_1 (state, finally);\n+\n+\t  emit_post_landing_pad (&eh_seq, tf->region);\n+\t  gimple_seq_add_seq (&eh_seq, finally);\n+\t  emit_resx (&eh_seq, tf->region);\n+\t}\n+\n+      finally = gimple_eh_else_n_body (eh_else);\n+    }\n+  else if (tf->may_throw)\n     {\n       emit_post_landing_pad (&eh_seq, tf->region);\n \n@@ -1452,12 +1523,22 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n    the estimate of the size of the switch machinery we'd have to add.  */\n \n static bool\n-decide_copy_try_finally (int ndests, gimple_seq finally)\n+decide_copy_try_finally (int ndests, bool may_throw, gimple_seq finally)\n {\n   int f_estimate, sw_estimate;\n+  gimple eh_else;\n+\n+  /* If there's an EH_ELSE involved, the exception path is separate\n+     and really doesn't come into play for this computation.  */\n+  eh_else = get_eh_else (finally);\n+  if (eh_else)\n+    {\n+      ndests -= may_throw;\n+      finally = gimple_eh_else_n_body (eh_else);\n+    }\n \n   if (!optimize)\n-    return false;\n+    return ndests == 1;\n \n   /* Finally estimate N times, plus N gotos.  */\n   f_estimate = count_insns_seq (finally, &eni_size_weights);\n@@ -1563,7 +1644,8 @@ lower_try_finally (struct leh_state *state, gimple tp)\n   /* We can easily special-case redirection to a single destination.  */\n   else if (ndests == 1)\n     lower_try_finally_onedest (state, &this_tf);\n-  else if (decide_copy_try_finally (ndests, gimple_try_cleanup (tp)))\n+  else if (decide_copy_try_finally (ndests, this_tf.may_throw,\n+\t\t\t\t    gimple_try_cleanup (tp)))\n     lower_try_finally_copy (state, &this_tf);\n   else\n     lower_try_finally_switch (state, &this_tf);\n@@ -1928,6 +2010,9 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n \t\tcase GIMPLE_EH_MUST_NOT_THROW:\n \t\t    replace = lower_eh_must_not_throw (state, stmt);\n \t\t    break;\n+\t\tcase GIMPLE_EH_ELSE:\n+\t\t    /* This code is only valid with GIMPLE_TRY_FINALLY.  */\n+\t\t    gcc_unreachable ();\n \t\tdefault:\n \t\t    replace = lower_cleanup (state, stmt);\n \t\t    break;\n@@ -1942,6 +2027,10 @@ lower_eh_constructs_2 (struct leh_state *state, gimple_stmt_iterator *gsi)\n       /* Return since we don't want gsi_next () */\n       return;\n \n+    case GIMPLE_EH_ELSE:\n+      /* We should be eliminating this in lower_try_finally et al.  */\n+      gcc_unreachable ();\n+\n     default:\n       /* A type, a decl, or some kind of statement that we're not\n \t interested in.  Don't walk them.  */\n@@ -2832,6 +2921,10 @@ refactor_eh_r (gimple_seq seq)\n \t  case GIMPLE_EH_FILTER:\n \t    refactor_eh_r (gimple_eh_filter_failure (one));\n \t    break;\n+\t  case GIMPLE_EH_ELSE:\n+\t    refactor_eh_r (gimple_eh_else_n_body (one));\n+\t    refactor_eh_r (gimple_eh_else_e_body (one));\n+\t    break;\n \t  default:\n \t    break;\n \t  }"}, {"sha": "211c1079f3c410dc836855485314a351e5b9dd3e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -33,6 +33,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n \n \n+/* This structure is used to map a gimple statement to a label,\n+   or list of labels to represent transaction restart.  */\n+\n+struct GTY(()) tm_restart_node {\n+  gimple stmt;\n+  tree label_or_list;\n+};\n+\n /* Gimple dataflow datastructure. All publicly available fields shall have\n    gimple_ accessor defined in tree-flow-inline.h, all publicly modifiable\n    fields should have gimple_set accessor.  */\n@@ -80,6 +88,10 @@ struct GTY(()) gimple_df {\n   unsigned int ipa_pta : 1;\n \n   struct ssa_operands ssa_operands;\n+\n+  /* Map gimple stmt to tree label (or list of labels) for transaction\n+     restart and abort.  */\n+  htab_t GTY ((param_is (struct tm_restart_node))) tm_restart;\n };\n \n /* Accessors for internal use only.  Generic code should use abstraction"}, {"sha": "4ca4fa464f976bfcf98322209aa6696bbbb6a3aa", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1365,6 +1365,12 @@ remap_gimple_stmt (gimple stmt, copy_body_data *id)\n \t    = gimple_build_omp_critical (s1, gimple_omp_critical_name (stmt));\n \t  break;\n \n+\tcase GIMPLE_TRANSACTION:\n+\t  s1 = remap_gimple_seq (gimple_transaction_body (stmt), id);\n+\t  copy = gimple_build_transaction (s1, gimple_transaction_label (stmt));\n+\t  gimple_transaction_set_subcode (copy, gimple_transaction_subcode (stmt));\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -3600,6 +3606,11 @@ estimate_num_insns (gimple stmt, eni_weights *weights)\n       return (weights->omp_cost\n               + estimate_num_insns_seq (gimple_omp_body (stmt), weights));\n \n+    case GIMPLE_TRANSACTION:\n+      return (weights->tm_cost\n+\t      + estimate_num_insns_seq (gimple_transaction_body (stmt),\n+\t\t\t\t\tweights));\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -3639,6 +3650,7 @@ init_inline_once (void)\n   eni_size_weights.target_builtin_call_cost = 1;\n   eni_size_weights.div_mod_cost = 1;\n   eni_size_weights.omp_cost = 40;\n+  eni_size_weights.tm_cost = 10;\n   eni_size_weights.time_based = false;\n   eni_size_weights.return_cost = 1;\n \n@@ -3650,6 +3662,7 @@ init_inline_once (void)\n   eni_time_weights.target_builtin_call_cost = 1;\n   eni_time_weights.div_mod_cost = 10;\n   eni_time_weights.omp_cost = 40;\n+  eni_time_weights.tm_cost = 40;\n   eni_time_weights.time_based = true;\n   eni_time_weights.return_cost = 2;\n }\n@@ -4041,9 +4054,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \n /* Expand call statements reachable from STMT_P.\n    We can only have CALL_EXPRs as the \"toplevel\" tree code or nested\n-   in a MODIFY_EXPR.  See gimple.c:get_call_expr_in().  We can\n-   unfortunately not use that function here because we need a pointer\n-   to the CALL_EXPR, not the tree itself.  */\n+   in a MODIFY_EXPR.  */\n \n static bool\n gimple_expand_calls_inline (basic_block bb, copy_body_data *id)"}, {"sha": "2aac5f8b9d36dd6a07377edeafe0df40156c877d", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -144,6 +144,9 @@ typedef struct eni_weights_d\n   /* Cost for omp construct.  */\n   unsigned omp_cost;\n \n+  /* Cost for tm transaction.  */\n+  unsigned tm_cost;\n+\n   /* Cost of return.  */\n   unsigned return_cost;\n "}, {"sha": "cc8847e8dff3422e0bf210cfd0d617c2169b3585", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -447,6 +447,12 @@ extern struct gimple_opt_pass pass_build_cgraph_edges;\n extern struct gimple_opt_pass pass_local_pure_const;\n extern struct gimple_opt_pass pass_tracer;\n extern struct gimple_opt_pass pass_warn_unused_result;\n+extern struct gimple_opt_pass pass_diagnose_tm_blocks;\n+extern struct gimple_opt_pass pass_lower_tm;\n+extern struct gimple_opt_pass pass_tm_init;\n+extern struct gimple_opt_pass pass_tm_mark;\n+extern struct gimple_opt_pass pass_tm_memopt;\n+extern struct gimple_opt_pass pass_tm_edges;\n extern struct gimple_opt_pass pass_split_functions;\n extern struct gimple_opt_pass pass_feedback_split_functions;\n \n@@ -469,6 +475,7 @@ extern struct ipa_opt_pass_d pass_ipa_pure_const;\n extern struct simple_ipa_opt_pass pass_ipa_pta;\n extern struct ipa_opt_pass_d pass_ipa_lto_wpa_fixup;\n extern struct ipa_opt_pass_d pass_ipa_lto_finish_out;\n+extern struct simple_ipa_opt_pass pass_ipa_tm;\n extern struct ipa_opt_pass_d pass_ipa_profile;\n extern struct ipa_opt_pass_d pass_ipa_cdtor_merge;\n "}, {"sha": "d0546c6c1cac3be810427af85acb18812f1b2825", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -2264,6 +2264,26 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       is_expr = false;\n       break;\n \n+    case TRANSACTION_EXPR:\n+      if (TRANSACTION_EXPR_OUTER (node))\n+\tpp_string (buffer, \"__transaction_atomic [[outer]]\");\n+      else if (TRANSACTION_EXPR_RELAXED (node))\n+\tpp_string (buffer, \"__transaction_relaxed\");\n+      else\n+\tpp_string (buffer, \"__transaction_atomic\");\n+      if (!(flags & TDF_SLIM) && TRANSACTION_EXPR_BODY (node))\n+\t{\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_character (buffer, '{');\n+\t  newline_and_indent (buffer, spc + 2);\n+\t  dump_generic_node (buffer, TRANSACTION_EXPR_BODY (node),\n+\t\t\t     spc + 2, flags, false);\n+\t  newline_and_indent (buffer, spc);\n+\t  pp_character (buffer, '}');\n+\t}\n+      is_expr = false;\n+      break;\n+\n     case REDUC_MAX_EXPR:\n       pp_string (buffer, \" REDUC_MAX_EXPR < \");\n       dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);"}, {"sha": "cd22209357907bf9337815c683d9f5588cb86eda", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1182,6 +1182,8 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n \tcase BUILT_IN_MEMPCPY:\n \tcase BUILT_IN_STPCPY:\n \tcase BUILT_IN_STPNCPY:\n+\tcase BUILT_IN_TM_MEMCPY:\n+\tcase BUILT_IN_TM_MEMMOVE:\n \t  {\n \t    ao_ref dref;\n \t    tree size = NULL_TREE;\n@@ -1228,6 +1230,32 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n \t\t\t\t\t   size);\n \t    return refs_may_alias_p_1 (&dref, ref, false);\n \t  }\n+\n+\t/* The following functions read memory pointed to by their\n+\t   first argument.  */\n+\tCASE_BUILT_IN_TM_LOAD (1):\n+\tCASE_BUILT_IN_TM_LOAD (2):\n+\tCASE_BUILT_IN_TM_LOAD (4):\n+\tCASE_BUILT_IN_TM_LOAD (8):\n+\tCASE_BUILT_IN_TM_LOAD (FLOAT):\n+\tCASE_BUILT_IN_TM_LOAD (DOUBLE):\n+\tCASE_BUILT_IN_TM_LOAD (LDOUBLE):\n+\tCASE_BUILT_IN_TM_LOAD (M64):\n+\tCASE_BUILT_IN_TM_LOAD (M128):\n+\tCASE_BUILT_IN_TM_LOAD (M256):\n+\tcase BUILT_IN_TM_LOG:\n+\tcase BUILT_IN_TM_LOG_1:\n+\tcase BUILT_IN_TM_LOG_2:\n+\tcase BUILT_IN_TM_LOG_4:\n+\tcase BUILT_IN_TM_LOG_8:\n+\tcase BUILT_IN_TM_LOG_FLOAT:\n+\tcase BUILT_IN_TM_LOG_DOUBLE:\n+\tcase BUILT_IN_TM_LOG_LDOUBLE:\n+\tcase BUILT_IN_TM_LOG_M64:\n+\tcase BUILT_IN_TM_LOG_M128:\n+\tcase BUILT_IN_TM_LOG_M256:\n+\t  return ptr_deref_may_alias_ref_p_1 (gimple_call_arg (call, 0), ref);\n+\n \t/* These read memory pointed to by the first argument.  */\n \tcase BUILT_IN_STRDUP:\n \tcase BUILT_IN_STRNDUP:\n@@ -1250,6 +1278,7 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n \tcase BUILT_IN_STACK_SAVE:\n \tcase BUILT_IN_STACK_RESTORE:\n \tcase BUILT_IN_MEMSET:\n+\tcase BUILT_IN_TM_MEMSET:\n \tcase BUILT_IN_MEMSET_CHK:\n \tcase BUILT_IN_FREXP:\n \tcase BUILT_IN_FREXPF:\n@@ -1480,6 +1509,19 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n \tcase BUILT_IN_STRCAT:\n \tcase BUILT_IN_STRNCAT:\n \tcase BUILT_IN_MEMSET:\n+\tcase BUILT_IN_TM_MEMSET:\n+\tCASE_BUILT_IN_TM_STORE (1):\n+\tCASE_BUILT_IN_TM_STORE (2):\n+\tCASE_BUILT_IN_TM_STORE (4):\n+\tCASE_BUILT_IN_TM_STORE (8):\n+\tCASE_BUILT_IN_TM_STORE (FLOAT):\n+\tCASE_BUILT_IN_TM_STORE (DOUBLE):\n+\tCASE_BUILT_IN_TM_STORE (LDOUBLE):\n+\tCASE_BUILT_IN_TM_STORE (M64):\n+\tCASE_BUILT_IN_TM_STORE (M128):\n+\tCASE_BUILT_IN_TM_STORE (M256):\n+\tcase BUILT_IN_TM_MEMCPY:\n+\tcase BUILT_IN_TM_MEMMOVE:\n \t  {\n \t    ao_ref dref;\n \t    tree size = NULL_TREE;"}, {"sha": "fe0c4e9c3890e4dc84746138ad6c70765cdcaff9", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -4024,6 +4024,8 @@ find_func_aliases_for_builtin_call (gimple t)\n       case BUILT_IN_STPCPY_CHK:\n       case BUILT_IN_STRCAT_CHK:\n       case BUILT_IN_STRNCAT_CHK:\n+      case BUILT_IN_TM_MEMCPY:\n+      case BUILT_IN_TM_MEMMOVE:\n \t{\n \t  tree res = gimple_call_lhs (t);\n \t  tree dest = gimple_call_arg (t, (DECL_FUNCTION_CODE (fndecl)\n@@ -4056,6 +4058,7 @@ find_func_aliases_for_builtin_call (gimple t)\n \t}\n       case BUILT_IN_MEMSET:\n       case BUILT_IN_MEMSET_CHK:\n+      case BUILT_IN_TM_MEMSET:\n \t{\n \t  tree res = gimple_call_lhs (t);\n \t  tree dest = gimple_call_arg (t, 0);\n@@ -4197,6 +4200,50 @@ find_func_aliases_for_builtin_call (gimple t)\n \t    }\n \t  return true;\n \t}\n+      CASE_BUILT_IN_TM_STORE (1):\n+      CASE_BUILT_IN_TM_STORE (2):\n+      CASE_BUILT_IN_TM_STORE (4):\n+      CASE_BUILT_IN_TM_STORE (8):\n+      CASE_BUILT_IN_TM_STORE (FLOAT):\n+      CASE_BUILT_IN_TM_STORE (DOUBLE):\n+      CASE_BUILT_IN_TM_STORE (LDOUBLE):\n+      CASE_BUILT_IN_TM_STORE (M64):\n+      CASE_BUILT_IN_TM_STORE (M128):\n+      CASE_BUILT_IN_TM_STORE (M256):\n+\t{\n+\t  tree addr = gimple_call_arg (t, 0);\n+\t  tree src = gimple_call_arg (t, 1);\n+\n+\t  get_constraint_for (addr, &lhsc);\n+\t  do_deref (&lhsc);\n+\t  get_constraint_for (src, &rhsc);\n+\t  process_all_all_constraints (lhsc, rhsc);\n+\t  VEC_free (ce_s, heap, lhsc);\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t  return true;\n+\t}\n+      CASE_BUILT_IN_TM_LOAD (1):\n+      CASE_BUILT_IN_TM_LOAD (2):\n+      CASE_BUILT_IN_TM_LOAD (4):\n+      CASE_BUILT_IN_TM_LOAD (8):\n+      CASE_BUILT_IN_TM_LOAD (FLOAT):\n+      CASE_BUILT_IN_TM_LOAD (DOUBLE):\n+      CASE_BUILT_IN_TM_LOAD (LDOUBLE):\n+      CASE_BUILT_IN_TM_LOAD (M64):\n+      CASE_BUILT_IN_TM_LOAD (M128):\n+      CASE_BUILT_IN_TM_LOAD (M256):\n+\t{\n+\t  tree dest = gimple_call_lhs (t);\n+\t  tree addr = gimple_call_arg (t, 0);\n+\n+\t  get_constraint_for (dest, &lhsc);\n+\t  get_constraint_for (addr, &rhsc);\n+\t  do_deref (&rhsc);\n+\t  process_all_all_constraints (lhsc, rhsc);\n+\t  VEC_free (ce_s, heap, lhsc);\n+\t  VEC_free (ce_s, heap, rhsc);\n+\t  return true;\n+\t}\n       /* Variadic argument handling needs to be handled in IPA\n \t mode as well.  */\n       case BUILT_IN_VA_START:"}, {"sha": "ba6c2e1ef8a142265ab92891166fe16e7e42d63e", "filename": "gcc/tree.c", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -9428,6 +9428,8 @@ local_define_builtin (const char *name, tree type, enum built_in_function code,\n   if (ecf_flags & ECF_LEAF)\n     DECL_ATTRIBUTES (decl) = tree_cons (get_identifier (\"leaf\"),\n \t\t\t\t\tNULL, DECL_ATTRIBUTES (decl));\n+  if ((ecf_flags & ECF_TM_PURE) && flag_tm)\n+    apply_tm_attr (decl, get_identifier (\"transaction_pure\"));\n \n   set_builtin_decl (code, decl, true);\n }\n@@ -9593,7 +9595,8 @@ build_common_builtin_nodes (void)\n   ftype = build_function_type_list (ptr_type_node,\n \t\t\t\t    integer_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_eh_pointer\", ftype, BUILT_IN_EH_POINTER,\n-\t\t\t\"__builtin_eh_pointer\", ECF_PURE | ECF_NOTHROW | ECF_LEAF);\n+\t\t\t\"__builtin_eh_pointer\",\n+\t\t\tECF_PURE | ECF_NOTHROW | ECF_LEAF | ECF_TM_PURE);\n \n   tmp = lang_hooks.types.type_for_mode (targetm.eh_return_filter_mode (), 0);\n   ftype = build_function_type_list (tmp, integer_type_node, NULL_TREE);\n@@ -11142,6 +11145,37 @@ tree_strip_sign_nop_conversions (tree exp)\n   return exp;\n }\n \n+/* Strip out all handled components that produce invariant\n+   offsets.  */\n+\n+const_tree\n+strip_invariant_refs (const_tree op)\n+{\n+  while (handled_component_p (op))\n+    {\n+      switch (TREE_CODE (op))\n+\t{\n+\tcase ARRAY_REF:\n+\tcase ARRAY_RANGE_REF:\n+\t  if (!is_gimple_constant (TREE_OPERAND (op, 1))\n+\t      || TREE_OPERAND (op, 2) != NULL_TREE\n+\t      || TREE_OPERAND (op, 3) != NULL_TREE)\n+\t    return NULL;\n+\t  break;\n+\n+\tcase COMPONENT_REF:\n+\t  if (TREE_OPERAND (op, 2) != NULL_TREE)\n+\t    return NULL;\n+\t  break;\n+\n+\tdefault:;\n+\t}\n+      op = TREE_OPERAND (op, 0);\n+    }\n+\n+  return op;\n+}\n+\n static GTY(()) tree gcc_eh_personality_decl;\n \n /* Return the GCC personality function decl.  */"}, {"sha": "2a2363e7037e82bd262f890df3a04083afd11d19", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1076,6 +1076,10 @@ DEFTREECODE (OMP_ATOMIC_CAPTURE_NEW, \"omp_atomic_capture_new\", tcc_statement, 2)\n /* OpenMP clauses.  */\n DEFTREECODE (OMP_CLAUSE, \"omp_clause\", tcc_exceptional, 0)\n \n+/* TRANSACTION_EXPR tree code.\n+   Operand 0: BODY: contains body of the transaction.  */\n+DEFTREECODE (TRANSACTION_EXPR, \"transaction_expr\", tcc_expression, 1)\n+\n /* Reduction operations.\n    Operations that take a vector of elements and \"reduce\" it to a scalar\n    result (e.g. summing the elements of the vector, finding the minimum over"}, {"sha": "3e1e225bd4e823f0f15129a623541c5fc5043b44", "filename": "gcc/tree.h", "status": "modified", "additions": 80, "deletions": 1, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -539,6 +539,9 @@ struct GTY(()) tree_common {\n        ENUM_IS_SCOPED in\n \t   ENUMERAL_TYPE\n \n+       TRANSACTION_EXPR_OUTER in\n+\t   TRANSACTION_EXPR\n+\n    public_flag:\n \n        TREE_OVERFLOW in\n@@ -566,6 +569,9 @@ struct GTY(()) tree_common {\n        OMP_CLAUSE_PRIVATE_DEBUG in\n            OMP_CLAUSE_PRIVATE\n \n+       TRANSACTION_EXPR_RELAXED in\n+\t   TRANSACTION_EXPR\n+\n    private_flag:\n \n        TREE_PRIVATE in\n@@ -1809,6 +1815,14 @@ extern void protected_set_expr_location (tree, location_t);\n #define CALL_EXPR_ARGP(NODE) \\\n   (&(TREE_OPERAND (CALL_EXPR_CHECK (NODE), 0)) + 3)\n \n+/* TM directives and accessors.  */\n+#define TRANSACTION_EXPR_BODY(NODE) \\\n+  TREE_OPERAND (TRANSACTION_EXPR_CHECK (NODE), 0)\n+#define TRANSACTION_EXPR_OUTER(NODE) \\\n+  (TRANSACTION_EXPR_CHECK (NODE)->base.static_flag)\n+#define TRANSACTION_EXPR_RELAXED(NODE) \\\n+  (TRANSACTION_EXPR_CHECK (NODE)->base.public_flag)\n+\n /* OpenMP directive and clause accessors.  */\n \n #define OMP_BODY(NODE) \\\n@@ -3455,6 +3469,29 @@ struct GTY(())\n #define DECL_NO_INLINE_WARNING_P(NODE) \\\n   (FUNCTION_DECL_CHECK (NODE)->function_decl.no_inline_warning_flag)\n \n+/* Nonzero if a FUNCTION_CODE is a TM load/store.  */\n+#define BUILTIN_TM_LOAD_STORE_P(FN) \\\n+  ((FN) >= BUILT_IN_TM_STORE_1 && (FN) <= BUILT_IN_TM_LOAD_RFW_LDOUBLE)\n+\n+/* Nonzero if a FUNCTION_CODE is a TM load.  */\n+#define BUILTIN_TM_LOAD_P(FN) \\\n+  ((FN) >= BUILT_IN_TM_LOAD_1 && (FN) <= BUILT_IN_TM_LOAD_RFW_LDOUBLE)\n+\n+/* Nonzero if a FUNCTION_CODE is a TM store.  */\n+#define BUILTIN_TM_STORE_P(FN) \\\n+  ((FN) >= BUILT_IN_TM_STORE_1 && (FN) <= BUILT_IN_TM_STORE_WAW_LDOUBLE)\n+\n+#define CASE_BUILT_IN_TM_LOAD(FN)\t\\\n+  case BUILT_IN_TM_LOAD_##FN:\t\t\\\n+  case BUILT_IN_TM_LOAD_RAR_##FN:\t\\\n+  case BUILT_IN_TM_LOAD_RAW_##FN:\t\\\n+  case BUILT_IN_TM_LOAD_RFW_##FN\n+\n+#define CASE_BUILT_IN_TM_STORE(FN)\t\\\n+  case BUILT_IN_TM_STORE_##FN:\t\t\\\n+  case BUILT_IN_TM_STORE_WAR_##FN:\t\\\n+  case BUILT_IN_TM_STORE_WAW_##FN\n+\n /* Nonzero in a FUNCTION_DECL that should be always inlined by the inliner\n    disregarding size and cost heuristics.  This is equivalent to using\n    the always_inline attribute without the required diagnostics if the\n@@ -3542,8 +3579,9 @@ struct GTY(()) tree_function_decl {\n   unsigned pure_flag : 1;\n   unsigned looping_const_or_pure_flag : 1;\n   unsigned has_debug_args_flag : 1;\n+  unsigned tm_clone_flag : 1;\n \n-  /* 2 bits left */\n+  /* 1 bit left */\n };\n \n /* The source language of the translation-unit.  */\n@@ -5153,6 +5191,7 @@ extern bool auto_var_in_fn_p (const_tree, const_tree);\n extern tree build_low_bits_mask (tree, unsigned);\n extern tree tree_strip_nop_conversions (tree);\n extern tree tree_strip_sign_nop_conversions (tree);\n+extern const_tree strip_invariant_refs (const_tree);\n extern tree lhd_gcc_personality (void);\n extern void assign_assembler_name_if_neeeded (tree);\n extern void warn_deprecated_use (tree, tree);\n@@ -5178,6 +5217,25 @@ extern void expand_return (tree);\n /* In tree-eh.c */\n extern void using_eh_for_cleanups (void);\n \n+/* Compare and hash for any structure which begins with a canonical\n+   pointer.  Assumes all pointers are interchangeable, which is sort\n+   of already assumed by gcc elsewhere IIRC.  */\n+\n+static inline int\n+struct_ptr_eq (const void *a, const void *b)\n+{\n+  const void * const * x = (const void * const *) a;\n+  const void * const * y = (const void * const *) b;\n+  return *x == *y;\n+}\n+\n+static inline hashval_t\n+struct_ptr_hash (const void *a)\n+{\n+  const void * const * x = (const void * const *) a;\n+  return (intptr_t)*x >> 4;\n+}\n+\n /* In fold-const.c */\n \n /* Non-zero if we are folding constants inside an initializer; zero\n@@ -5546,6 +5604,10 @@ extern tree build_duplicate_type (tree);\n #define ECF_NOVOPS\t\t  (1 << 9)\n /* The function does not lead to calls within current function unit.  */\n #define ECF_LEAF\t\t  (1 << 10)\n+/* Nonzero if this call does not affect transactions.  */\n+#define ECF_TM_PURE\t\t  (1 << 11)\n+/* Nonzero if this call is into the transaction runtime library.  */\n+#define ECF_TM_BUILTIN\t\t  (1 << 12)\n \n extern int flags_from_decl_or_type (const_tree);\n extern int call_expr_flags (const_tree);\n@@ -5596,6 +5658,8 @@ extern void init_attributes (void);\n    a decl attribute to the declaration rather than to its type).  */\n extern tree decl_attributes (tree *, tree, int);\n \n+extern void apply_tm_attr (tree, tree);\n+\n /* In integrate.c */\n extern void set_decl_abstract_flags (tree, int);\n extern void set_decl_origin_self (tree);\n@@ -5808,6 +5872,21 @@ extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);\n extern tree build_personality_function (const char *);\n \n+/* In trans-mem.c.  */\n+extern tree build_tm_abort_call (location_t, bool);\n+extern bool is_tm_safe (const_tree);\n+extern bool is_tm_pure (const_tree);\n+extern bool is_tm_may_cancel_outer (tree);\n+extern bool is_tm_ending_fndecl (tree);\n+extern void record_tm_replacement (tree, tree);\n+extern void tm_malloc_replacement (tree);\n+\n+static inline bool\n+is_tm_safe_or_pure (const_tree x)\n+{\n+  return is_tm_safe (x) || is_tm_pure (x);\n+}\n+\n /* In tree-inline.c.  */\n \n void init_inline_once (void);"}, {"sha": "ed27dce7b0a94de1a2f0de1961cdddd40e9ff203", "filename": "gcc/varasm.c", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -5859,6 +5859,162 @@ assemble_alias (tree decl, tree target)\n     }\n }\n \n+/* Record and output a table of translations from original function\n+   to its transaction aware clone.  Note that tm_pure functions are\n+   considered to be their own clone.  */\n+\n+static GTY((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n+     htab_t tm_clone_hash;\n+\n+void\n+record_tm_clone_pair (tree o, tree n)\n+{\n+  struct tree_map **slot, *h;\n+\n+  if (tm_clone_hash == NULL)\n+    tm_clone_hash = htab_create_ggc (32, tree_map_hash, tree_map_eq, 0);\n+\n+  h = ggc_alloc_tree_map ();\n+  h->hash = htab_hash_pointer (o);\n+  h->base.from = o;\n+  h->to = n;\n+\n+  slot = (struct tree_map **)\n+    htab_find_slot_with_hash (tm_clone_hash, h, h->hash, INSERT);\n+  *slot = h;\n+}\n+\n+tree\n+get_tm_clone_pair (tree o)\n+{\n+  if (tm_clone_hash)\n+    {\n+      struct tree_map *h, in;\n+\n+      in.base.from = o;\n+      in.hash = htab_hash_pointer (o);\n+      h = (struct tree_map *) htab_find_with_hash (tm_clone_hash,\n+\t\t\t\t\t\t   &in, in.hash);\n+      if (h)\n+\treturn h->to;\n+    }\n+  return NULL_TREE;\n+}\n+\n+typedef struct tm_alias_pair\n+{\n+  unsigned int uid;\n+  tree from;\n+  tree to;\n+} tm_alias_pair;\n+\n+DEF_VEC_O(tm_alias_pair);\n+DEF_VEC_ALLOC_O(tm_alias_pair,heap);\n+\n+/* Helper function for finish_tm_clone_pairs.  Dump a hash table entry\n+   into a VEC in INFO.  */\n+\n+static int\n+dump_tm_clone_to_vec (void **slot, void *info)\n+{\n+  struct tree_map *map = (struct tree_map *) *slot;\n+  VEC(tm_alias_pair,heap) **tm_alias_pairs\n+    = (VEC(tm_alias_pair, heap) **) info;\n+  tm_alias_pair *p;\n+\n+  p = VEC_safe_push (tm_alias_pair, heap, *tm_alias_pairs, NULL);\n+  p->from = map->base.from;\n+  p->to = map->to;\n+  p->uid = DECL_UID (p->from);\n+  return 1;\n+}\n+\n+/* Dump the actual pairs to the .tm_clone_table section.  */\n+\n+static void\n+dump_tm_clone_pairs (VEC(tm_alias_pair,heap) *tm_alias_pairs)\n+{\n+  unsigned i;\n+  tm_alias_pair *p;\n+  bool switched = false;\n+\n+  FOR_EACH_VEC_ELT (tm_alias_pair, tm_alias_pairs, i, p)\n+    {\n+      tree src = p->from;\n+      tree dst = p->to;\n+      struct cgraph_node *src_n = cgraph_get_node (src);\n+      struct cgraph_node *dst_n = cgraph_get_node (dst);\n+\n+      /* The function ipa_tm_create_version() marks the clone as needed if\n+\t the original function was needed.  But we also mark the clone as\n+\t needed if we ever called the clone indirectly through\n+\t TM_GETTMCLONE.  If neither of these are true, we didn't generate\n+\t a clone, and we didn't call it indirectly... no sense keeping it\n+\t in the clone table.  */\n+      if (!dst_n || !dst_n->needed)\n+\tcontinue;\n+\n+      /* This covers the case where we have optimized the original\n+\t function away, and only access the transactional clone.  */\n+      if (!src_n || !src_n->needed)\n+\tcontinue;\n+\n+      if (!switched)\n+\t{\n+\t  switch_to_section (get_named_section (NULL, \".tm_clone_table\", 3));\n+\t  assemble_align (POINTER_SIZE);\n+\t  switched = true;\n+\t}\n+\n+      assemble_integer (XEXP (DECL_RTL (src), 0),\n+\t\t\tPOINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+      assemble_integer (XEXP (DECL_RTL (dst), 0),\n+\t\t\tPOINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+    }\n+}\n+\n+/* Helper comparison function for qsorting by the DECL_UID stored in\n+   alias_pair->emitted_diags.  */\n+\n+static int\n+tm_alias_pair_cmp (const void *x, const void *y)\n+{\n+  const tm_alias_pair *p1 = (const tm_alias_pair *) x;\n+  const tm_alias_pair *p2 = (const tm_alias_pair *) y;\n+  if (p1->uid < p2->uid)\n+    return -1;\n+  if (p1->uid > p2->uid)\n+    return 1;\n+  return 0;\n+}\n+\n+void\n+finish_tm_clone_pairs (void)\n+{\n+  VEC(tm_alias_pair,heap) *tm_alias_pairs = NULL;\n+\n+  if (tm_clone_hash == NULL)\n+    return;\n+\n+  /* We need a determenistic order for the .tm_clone_table, otherwise\n+     we will get bootstrap comparison failures, so dump the hash table\n+     to a vector, sort it, and dump the vector.  */\n+\n+  /* Dump the hashtable to a vector.  */\n+  htab_traverse_noresize (tm_clone_hash, dump_tm_clone_to_vec,\n+\t\t\t  (void *) &tm_alias_pairs);\n+  /* Sort it.  */\n+  VEC_qsort (tm_alias_pair, tm_alias_pairs, tm_alias_pair_cmp);\n+\n+  /* Dump it.  */\n+  dump_tm_clone_pairs (tm_alias_pairs);\n+\n+  htab_delete (tm_clone_hash);\n+  tm_clone_hash = NULL;\n+  VEC_free (tm_alias_pair, heap, tm_alias_pairs);\n+}\n+\n+\n /* Emit an assembler directive to set symbol for DECL visibility to\n    the visibility type VIS, which must not be VISIBILITY_DEFAULT.  */\n "}, {"sha": "df131629f2b3f7b49dd1ff6e3026ec1cd189a1e6", "filename": "include/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,12 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* demangle.h (enum gnu_v3_ctor_kinds): Add gnu_v3_object_ctor_group.\n+\t(enum gnu_v3_dtor_kinds): Add gnu_v3_object_dtor_group.\n+\t(DEMANGLE_COMPONENT_TRANSACTION_CLONE): New.\n+\t(DEMANGLE_COMPONENT_NONTRANSACTION_CLONE): New.\n+\n 2011-10-21  Ulrich Drepper  <drepper@gmail.com>\n \n \t* obstack.h [!GNUC] (obstack_free): Avoid cast to int."}, {"sha": "98b11d796f4ffcdcbe77905768e1e95bd053ca57", "filename": "include/demangle.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -172,7 +172,8 @@ ada_demangle (const char *mangled, int options);\n enum gnu_v3_ctor_kinds {\n   gnu_v3_complete_object_ctor = 1,\n   gnu_v3_base_object_ctor,\n-  gnu_v3_complete_object_allocating_ctor\n+  gnu_v3_complete_object_allocating_ctor,\n+  gnu_v3_object_ctor_group\n };\n \n /* Return non-zero iff NAME is the mangled form of a constructor name\n@@ -186,7 +187,8 @@ extern enum gnu_v3_ctor_kinds\n enum gnu_v3_dtor_kinds {\n   gnu_v3_deleting_dtor = 1,\n   gnu_v3_complete_object_dtor,\n-  gnu_v3_base_object_dtor\n+  gnu_v3_base_object_dtor,\n+  gnu_v3_object_dtor_group\n };\n \n /* Return non-zero iff NAME is the mangled form of a destructor name\n@@ -401,6 +403,13 @@ enum demangle_component_type\n   DEMANGLE_COMPONENT_DEFAULT_ARG,\n   /* An unnamed type.  */\n   DEMANGLE_COMPONENT_UNNAMED_TYPE,\n+  /* A transactional clone.  This has one subtree, the encoding for\n+     which it is providing alternative linkage.  */\n+  DEMANGLE_COMPONENT_TRANSACTION_CLONE,\n+  /* A non-transactional clone entry point.  In the i386/x86_64 abi,\n+     the unmangled symbol of a tm_callable becomes a thunk and the\n+     non-transactional function version is mangled thus.  */\n+  DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,\n   /* A pack expansion.  */\n   DEMANGLE_COMPONENT_PACK_EXPANSION,\n   /* A cloned function.  */"}, {"sha": "a269a0efed812b15e9ce1884ba81042c6b8e1ba3", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -1,3 +1,17 @@\n+2011-11-07  Richard Henderson  <rth@redhat.com>\n+\n+\tMerged from transactional-memory.\n+\n+\t* cp-demangle.c (cplus_demangle_fill_ctor): Accept\n+\tgnu_v3_object_ctor_group.\n+\t(cplus_demangle_fill_dtor): Accept gnu_v3_object_dtor_group.\n+\t(d_ctor_dtor_name): Recognize gnu_v3_object_ctor_group\n+\tand gnu_v3_object_dtor_group.\n+\t(d_dump): Handle DEMANGLE_COMPONENT_TRANSACTION_CLONE\n+\tand DEMANGLE_COMPONENT_NONTRANSACTION_CLONE.\n+\t(d_make_comp, d_print_comp): Likewise.\n+\t(d_special_name): Generate them.\n+\n 2011-11-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/48370"}, {"sha": "0f1166be48ccee90adce883f7f143415fc1dcb37", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -585,6 +585,12 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n       printf (\"hidden alias\\n\");\n       break;\n+    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n+      printf (\"transaction clone\\n\");\n+      break;\n+    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n+      printf (\"non-transaction clone\\n\");\n+      break;\n     case DEMANGLE_COMPONENT_RESTRICT:\n       printf (\"restrict\\n\");\n       break;\n@@ -732,7 +738,7 @@ cplus_demangle_fill_ctor (struct demangle_component *p,\n   if (p == NULL\n       || name == NULL\n       || (int) kind < gnu_v3_complete_object_ctor\n-      || (int) kind > gnu_v3_complete_object_allocating_ctor)\n+      || (int) kind > gnu_v3_object_ctor_group)\n     return 0;\n   p->type = DEMANGLE_COMPONENT_CTOR;\n   p->u.s_ctor.kind = kind;\n@@ -751,7 +757,7 @@ cplus_demangle_fill_dtor (struct demangle_component *p,\n   if (p == NULL\n       || name == NULL\n       || (int) kind < gnu_v3_deleting_dtor\n-      || (int) kind > gnu_v3_base_object_dtor)\n+      || (int) kind > gnu_v3_object_dtor_group)\n     return 0;\n   p->type = DEMANGLE_COMPONENT_DTOR;\n   p->u.s_dtor.kind = kind;\n@@ -823,6 +829,8 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_GUARD:\n     case DEMANGLE_COMPONENT_REFTEMP:\n     case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n+    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n+    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n     case DEMANGLE_COMPONENT_POINTER:\n     case DEMANGLE_COMPONENT_REFERENCE:\n     case DEMANGLE_COMPONENT_RVALUE_REFERENCE:\n@@ -1762,6 +1770,8 @@ d_java_resource (struct d_info *di)\n                   ::= GR <name>\n \t\t  ::= GA <encoding>\n \t\t  ::= Gr <resource name>\n+\t\t  ::= GTt <encoding>\n+\t\t  ::= GTn <encoding>\n */\n \n static struct demangle_component *\n@@ -1856,6 +1866,23 @@ d_special_name (struct d_info *di)\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_HIDDEN_ALIAS,\n \t\t\t      d_encoding (di, 0), NULL);\n \n+\tcase 'T':\n+\t  switch (d_next_char (di))\n+\t    {\n+\t    case 'n':\n+\t      return d_make_comp (di, DEMANGLE_COMPONENT_NONTRANSACTION_CLONE,\n+\t\t\t\t  d_encoding (di, 0), NULL);\n+\t    default:\n+\t      /* ??? The proposal is that other letters (such as 'h') stand\n+\t\t for different variants of transaction cloning, such as\n+\t\t compiling directly for hardware transaction support.  But\n+\t\t they still should all be transactional clones of some sort\n+\t\t so go ahead and call them that.  */\n+\t    case 't':\n+\t      return d_make_comp (di, DEMANGLE_COMPONENT_TRANSACTION_CLONE,\n+\t\t\t\t  d_encoding (di, 0), NULL);\n+\t    }\n+\n \tcase 'r':\n \t  return d_java_resource (di);\n \n@@ -1939,6 +1966,9 @@ d_ctor_dtor_name (struct d_info *di)\n \t  case '3':\n \t    kind = gnu_v3_complete_object_allocating_ctor;\n \t    break;\n+\t  case '5':\n+\t    kind = gnu_v3_object_ctor_group;\n+\t    break;\n \t  default:\n \t    return NULL;\n \t  }\n@@ -1961,6 +1991,9 @@ d_ctor_dtor_name (struct d_info *di)\n \t  case '2':\n \t    kind = gnu_v3_base_object_dtor;\n \t    break;\n+\t  case '5':\n+\t    kind = gnu_v3_object_dtor_group;\n+\t    break;\n \t  default:\n \t    return NULL;\n \t  }\n@@ -3935,6 +3968,16 @@ d_print_comp (struct d_print_info *dpi, int options,\n       d_print_comp (dpi, options, d_left (dc));\n       return;\n \n+    case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n+      d_append_string (dpi, \"transaction clone for \");\n+      d_print_comp (dpi, options, d_left (dc));\n+      return;\n+\n+    case DEMANGLE_COMPONENT_NONTRANSACTION_CLONE:\n+      d_append_string (dpi, \"non-transaction clone for \");\n+      d_print_comp (dpi, options, d_left (dc));\n+      return;\n+\n     case DEMANGLE_COMPONENT_SUB_STD:\n       d_append_buffer (dpi, dc->u.s_string.string, dc->u.s_string.len);\n       return;"}, {"sha": "cd5a723f2bc8cb572ff2351b3ffbf7f3bf33a45a", "filename": "libitm/ChangeLog", "status": "added", "additions": 916, "deletions": 0, "changes": 916, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,916 @@\n+2011-11-05  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* method-wbetl.cc: Update copyright notice.\n+\t* aatree.cc: Same.\n+\t* util.cc: Same.\n+\t* libitm.h: Same.\n+\t* memset.cc: Same.\n+\t* eh_cpp.cc: Same.\n+\t* barrier.tpl: Same.\n+\t* useraction.cc: Same.\n+\t* stmlock.h: Same.\n+\t* memcpy.cc: Same.\n+\t* common.h: Same.\n+\t* config/generic/tls.cc: Same.\n+\t* config/generic/cacheline.h: Same.\n+\t* config/generic/cachepage.h: Same.\n+\t* config/generic/cacheline.cc: Same.\n+\t* config/generic/unaligned.h: Same.\n+\t* config/x86/cacheline.h: Same.\n+\t* config/x86/cacheline.cc: Same.\n+\t* config/x86/unaligned.h: Same.\n+\t* config/alpha/cacheline.h: Same.\n+\t* config/alpha/unaligned.h: Same.\n+\t* config/alpha/sjlj.S: Same.\n+\t* config/posix/cachepage.cc: Same.\n+\t* config/linux/futex.h: Same.\n+\t* config/linux/alpha/futex_bits.h: Same.\n+\n+2011-11-04  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm.texi: No cover text and invariant sections.\n+\n+2011-11-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* local_type_traits: New file.\n+\t* libitm_i.h: Use it.  Use C headers, not C++ wrappers.\n+\n+2011-11-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* configure.ac: Don't test for gfortran.\n+\t* configure: Rebuild.\n+\n+\t* testsuite/lib/libitm.exp: Don't include gfortran-dg.exp.\n+\t* testsuite/libitm.c++/c++.exp: Don't use gfortran-dg-runtest.\n+\n+2011-11-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* testsuite/libitm.c/memcpy-1.c: Add copyright notice.\n+\t* testsuite/libitm.c/memset-1.c: Same.\n+\t* testsuite/libitm.c/c.exp: Same.\n+\t* testsuite/lib/libitm-dg.exp: Same.\n+\t* testsuite/lib/libitm.exp: Same.\n+\t* testsuite/libitm.c++/c++.exp: Same.\n+\n+2011-11-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* testsuite/config/default.exp: Update copyright date.\n+\t* configure.ac: Add copyright info.\n+\t* configure.tgt: Same.\n+\n+2011-11-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* testsuite/libitm.c/reentrant.c: XFAIL.\n+\t* testsuite/libitm.c++/static_ctor.C: XFAIL.\n+\n+2011-10-29  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_thread::rollback): Add aborting flag and\n+\thandle aborts.\n+\t(_ITM_abortTransaction): Handle aborts of outer transactions.\n+\t* libitm_i.h: Same.\n+\t* eh_cpp.cc (GTM::gtm_thread::revert_cpp_exceptions): Fix assertion.\n+\t* libitm.texi: Document aborts of outer transactions.\n+\t* testsuite/libitm.c/cancel.c: New file.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* testsuite/*: Change __transaction to __transaction_atomic or\n+\t__transaction_relaxed.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/linux/x86/tls.h (abi_disp): Make TLS slot read volatile.\n+\t(gtm_thr): Same.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h: Add gl_wt dispatch.\n+\t* retry.cc (parse_default_method): Same.\n+\t* method-gl.cc: New file.\n+\t* Makefile.am: Use method-gl.cc.\n+\t* Makefile.in: Rebuild.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_thread::trycommit): Ensure privatization\n+\tsafety if requested by a TM method.\n+\t* dispatch.h (GTM::abi_dispatch::trycommit): Add parameter for\n+\tprivatization safety.\n+\t* method-serial.cc: Same.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h: Renamed gtm_local_undo to gtm_undolog_entry.\n+\t(GTM::gtm_thread): Renamed local_undo to undolog. Renamed\n+\tundolog-related member functions from *_local to *_undolog.\n+\t* local.cc (gtm_thread::commit_undolog): Same.\n+\t* beginend.cc (GTM::gtm_thread::trycommit): Same.\n+\t(GTM::gtm_thread::rollback): Roll back undolog before\n+\tdispatch-specific rollback.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* retry.cc (GTM::gtm_thread::decide_retry_strategy): Handle\n+\tre-initialization of the current method group.\n+\t* libitm_i.h (GTM::gtm_restart_reason): Add restart reason for this.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* alloc.cc (commit_allocations_2): Do not free transaction-local\n+\tmemory when committing a nested transaction.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* method-serial.cc (GTM::gtm_thread::serialirr_mode): Fixed: Use\n+\tserial-irrevocable dispatch, not serial.\n+\n+2011-10-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h (GTM::gtm_restart_reason): Re-arrange and clean up\n+\tdeclarations.\n+\t* dispatch.h (GTM::abi_dispatch::begin_or_restart): New.\n+\t* method-serial.cc: Implement begin_or_restart().\n+\t* beginend.cc (GTM::gtm_thread::begin_transaction): Call\n+\tdispatch-specific begin_or_restart().\n+\t(GTM::gtm_thread::restart): Same.\n+\n+2011-08-23  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* retry.cc (GTM::gtm_thread::decide_retry_strategy): Cleanup. Fix\n+\trestarting without switching to serial mode.\n+\t(GTM::gtm_thread::decide_begin_dispatch): Let the caller set the\n+\ttransaction state. Choose closed-nesting alternative if available.\n+\t(GTM::gtm_thread::set_default_dispatch): New.\n+\t(parse_default_method): New.\n+\t(GTM::gtm_thread::number_of_threads_changed): New.\n+\t* method-serial.cc (GTM::serial_mg): New method group class.\n+\t(GTM::serialirr_dispatch): Belongs to serial_mg. Remove reinit and\n+\tfini.\n+\t(GTM::serial_dispatch): Same.\n+\t(GTM::serialirr_onwrite_dispatch): Same.\n+\t(GTM::gtm_thread::serialirr_mode): Remove calls to fini.\n+\t* beginend.cc (GTM::gtm_thread::~gtm_thread): Maintain number of\n+\tregistered threads.\n+\t(GTM::gtm_thread::gtm_thread): Same.\n+\t(_ITM_abortTransaction): Remove calls to abi_dispatch::fini().\n+\t(GTM::gtm_thread::trycommit): Same. Reset number of restarts.\n+\t(GTM::gtm_thread::begin_transaction): Let decide_begin_dispatch()\n+\tchoose dispatch but set state according to dispatch here.\n+\t* dispatch.h (GTM::abi_dispatch::fini): Move to method group.\n+\t(GTM::method_group): New class.\n+\t(GTM::abi_dispatch): Add comments. Maintain pointer to method_group.\n+\t* libitm_i.h (GTM::gtm_thread): Add declarations for new members.\n+\t* libitm.texi: Document TM methods, method groups, method life cycle.\n+\tRename method sets to method groups.\n+\n+2011-08-23  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/x86/tls.h: Moved to ...\n+\t* config/linux/x86/tls.h: ... here.\n+\n+2011-08-23  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/x86/tls.h: Use __x86_64__ instead of __LP64__.\n+\tAdd X32 support.\n+\t* config/x86/sjlj.S: Same.\n+\n+2011-08-19  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/linux/rwlock.h: New file.\n+\t* config/linux/rwlock.c: New file.\n+\t* configure.ac: Reenable futex support (undo SVN rev 157758).\n+\t* Makefile.am: Same.\n+\t* configure.tgt: Same.\n+\t* config/linux/alpha/futex_bits.h: Same.\n+\t* config/linux/futex.h: Same. Return number of woken processes.\n+\t* config/linux/futex.cc: Same.\n+\t(futex_wait): Remove spinning.\n+\t* config/linux/x86/futex_bits.h: Same. Set futex timeout to zero.\n+\tUse __x86_64__ instead of __LP64__.\n+\t* aclocal.m4: Include generic futex checks.\n+\t* configure: Rebuild.\n+\t* Makefile.in: Rebuild.\n+\t* testsuite/Makefile.in: Rebuild.\n+\t* beginend.cc: Include pthread.h.\n+\t* config/posix/cachepage.cc: Same.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/x86/tls.h (gtm_tx, set_gtm_tx, setup_gtm_thr): Removed.\n+\t(abi_disp, set_abi_disp): Move to tx's TLS slot.\n+\t(set_gtm_thr): New.\n+\t* config/generic/tls.h (gtm_tx, set_gtm_tx, setup_gtm_thr): Removed.\n+\t(set_gtm_thr): New.\n+\t(GTM::gtm_thread::thread_num): Removed.\n+\t(GTM::gtm_thread): Renamed to GTM::gtm_thread_tls.\n+\t* libitm_i.h (GTM::gtm_transaction): Renamed to GTM::gtm_thread. More\n+\ttx-to-thread renaming.\n+\t* beginend.cc: Adapted to tx-to-thread renaming.\n+\t(GTM::gtm_thread::~gtm_thread): Extracted from thread_exit_handler().\n+\t(GTM::gtm_thread::gtm_thread): Extracted from begin_transaction().\n+\t* query.cc (_ITM_getTransactionId, _ITM_inTransaction): Renamed\n+\tgtm_transaction to gtm_thread.\n+\t(_ITM_getThreadnum): Removed. Not supported anymore.\n+\t* testsuite/libitm.c/notx.c (main): Removed _ITM_getThreadnum call.\n+\t* libitm.texi: Documented that _ITM_getThreadnum is not supported.\n+\t* useraction.cc: Renamed gtm_transaction to gtm_thread. Adapted to\n+\tgtm_tx-to-gtm_thr renaming if necessary.\n+\t* eh_cpp.cc: Same.\n+\t* local.cc: Same.\n+\t* retry.cc: Same.\n+\t* clone.cc: Same.\n+\t* alloc.cc: Same.\n+\t* alloc_c.cc: Same.\n+\t* alloc_cpp.cc: Same.\n+\t* method-serial.cc: Same.\n+\t* config/generic/tls.cc: Same.\n+\t* config/posix/rwlock.h (gtm_rwlock): Same.\n+\t* config/posix/rwlock.cc: Same. Adapted to more tx-to-thread renaming.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/posix/rwlock.cc (gtm_rwlock::read_lock): Changed locking\n+\timplementation.\n+\t(gtm_rwlock::read_unlock): Same.\n+\t(gtm_rwlock::write_lock_generic): New. Generalized from ...\n+\t(gtm_rwlock::write_lock, gtm_rwlock::write_upgrade): ... these.\n+\t* libitm_i.h (GTM::gtm_transaction): Added shared_state.\n+\t* config/posix/rwlock.h (GTM::gtm_rwlock): Removed a_reader and\n+\tw_upgrade. Replaced by per-transaction flags (in shared_state).\n+\tAdded c_confirmed_writers.\n+\t(GTM::gtm_rwlock::read_lock, GTM::gtm_rwlock::read_unlock,\n+\tGTM::gtm_rwlock::write_upgrade): Add tx parameter.\n+\t* retry.cc (GTM::gtm_transaction::decide_retry_strategy): Same.\n+\t* method-serial.cc (GTM::gtm_transaction::serialirr_mode): Same.\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction,\n+\t_ITM_abortTransaction, GTM::gtm_transaction::trycommit): Same.\n+\t* libitm.texi: Document locking conventions and implementations in\n+\tlibitm.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h (next_tx): Add list of all threads' transaction.\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction): Register\n+\ttransaction with list of transactions and ...\n+\t(thread_exit_handler): ... deregister here.\n+\t* config/alpha/target.h: Add HW_CACHELINE_SIZE setting.\n+\t* config/x86/target.h: Same.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* testsuite/libitm.c++/static_ctor.C: New file.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* testsuite/libitm.c/reentrant.c: New file.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/generic/tls.h: Remove the free list for transactions and ...\n+\t* beginend.cc (GTM::gtm_transaction::operator new): ... allocate ...\n+\t(GTM::gtm_transaction::operator delete): ... and release here.\n+\t(thread_exit_handler): New. Delete tx when thread terminates.\n+\t(thread_exit_init): New.\n+\t(GTM::gtm_transaction::begin_transaction): Set up on-exit handler.\n+\t* testsuite/libitm.c/txrelease.c: New file.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* query.cc (_ITM_getThreadnum): Set up gtm_thread if necessary.\n+\t* testsuite/libitm.c/notx.c: New file.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/generic/tls.h (gtm_thread): Move local_tid from here ...\n+\t* libitm_i.h (local_tid): ... to here.\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction): Same.\n+\t(GTM::gtm_transaction::operator new): Set up gtm_thread if necessary.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* retry.cc (GTM::gtm_transaction::decide_begin_dispatch): Use\n+\tserialirr_onwrite_dispatch as new default for now.\n+\t* method-serial.cc (serialirr_onwrite_dispatch): New.\n+\t(GTM::dispatch_serialirr_onwrite): New.\n+\t* libitm_i.h: Same.\n+\n+2011-08-12  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_transaction::rollback): Roll back tx id as well.\n+\t* query.cc (_ITM_getTransactionId): There is no active transaction if\n+\tthe current nesting level is zero.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_transaction::rollback): Fix nesting level\n+\trollback.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* retry.cc (GTM::gtm_transaction::decide_begin_dispatch): Get\n+\ttransaction properties from the caller instead of from the\n+\ttransaction object.\n+\t* libitm_i.h: Same.\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction): Same.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* local.cc (gtm_transaction::rollback_local): Support closed nesting.\n+\t* eh_cpp.cc (GTM::gtm_transaction::revert_cpp_exceptions): Same.\n+\t* dispatch.h: Same.\n+\t* method-serial.cc: Same.\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction): Change to\n+\tflat nesting as default, and closed nesting on demand.\n+\t(GTM::gtm_transaction::rollback): Same.\n+\t(_ITM_abortTransaction): Same.\n+\t(GTM::gtm_transaction::restart): Same.\n+\t(GTM::gtm_transaction::trycommit): Same.\n+\t(GTM::gtm_transaction::trycommit_and_finalize): Removed.\n+\t(choose_code_path): New.\n+\t(GTM::gtm_transaction_cp::save): New.\n+\t(GTM::gtm_transaction_cp::commit): New.\n+\t* query.cc (_ITM_inTransaction): Support flat nesting.\n+\t* libitm_i.h (GTM::gtm_transaction_cp): New helper struct for nesting.\n+\t(GTM::gtm_transaction): Support flat and closed nesting.\n+\t* alloc.cc (commit_allocations_2): New.\n+\t(commit_cb_data): New helper struct.\n+\t(GTM::gtm_transaction::commit_allocations): Handle nested\n+\tcommits/rollbacks.\n+\t* libitm.texi: Update user action section, add description of nesting.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h: Add closed nesting as restart reason.\n+\t* retry.cc (GTM::gtm_transaction::decide_retry_strategy): Same.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* useraction.cc: Use vector instead of list to store actions.\n+\tAlso support partial rollbacks for closed nesting.\n+\t* libitm_i.h (GTM::gtm_transaction::user_action): Same.\n+\t* beginend.cc: Same.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* dispatch.h (GTM::abi_dispatch): Add can_run_uninstrumented_code and\n+\tclosed_nesting flags, as well as a closed nesting alternative.\n+\t* method-serial.cc: Same.\n+\t(serial_dispatch): Renamed to serialirr_dispatch.\n+\t(GTM::dispatch_serialirr): Same.\n+\t(serial_dispatch_ul): Renamed to serial_dispatch.\n+\t(GTM::dispatch_serial): Same.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm.h (_ITM_codeProperties): Change pr_hasElse to the ABI's value.\n+\n+2011-07-28  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* aatree.h (aa_tree::remove): New.\n+\t(aa_tree::operator new): Add placement new.\n+\n+2011-07-02  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* containers.h: New file.\n+\t* util.cc (xmalloc, xrealloc): Accept cacheline-alloc flag.\n+\t* libitm_i.h (xmalloc, xrealloc): Moved declarations from here ...\n+\t* common.h: ... to here.\n+\t(local_undo): Use GTM::vector for gtm_transaction::local_undo.\n+\t* local.cc: Same.\n+\n+2011-06-30  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h (STATE_ABORTING): Remove.\n+\t* beginend.cc (_ITM_abortTransaction): Same.\n+\t(GTM::gtm_transaction::trycommit_and_finalize): Same.\n+\t* libitm.h (_ITM_registerThrownObject, _ITM_tryCommitTransaction): Remove.\n+\t(_ITM_rollbackTransaction): Remove.\n+\t* beginend.cc: Same.\n+\t* libitm.map: Same.\n+\t* libitm.texi: Document these ABI changes.\n+\n+2011-06-30  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm.texi: New file.\n+\t* Makefile.am: Add libitm.texi.\n+\t* Makefile.in: Rebuild.\n+\n+2011-06-30  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* libitm_i.h: Move parts to common.h and dispatch.h.\n+\t* common.h: New file.\n+\t* dispatch.h: New file, new dispatch class.\n+\tRename GTM::abi_dispatch::lock_type to ls_modifier.\n+\tRenameGTM::abi_dispatch::NOLOCK to NONTXNAL.\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction): Delegate mode\n+\tdecision to retry.cc.\n+\t* retry.cc (GTM::gtm_transaction::decide_retry_strategy): Use serial mode\n+\tonly.\n+\t(GTM::gtm_transaction::decide_begin_dispatch): Same.\n+\t* method-serial.cc: Adapt to new dispatch. Add serial mode with undo\n+\tlogging.\n+\t* barrier.cc: Use new barriers definitions.\n+\t(abi_dispatch::memmove_overlap_check): New.\n+\t* config/x86/x86_sse.cc: Same.\n+\t* config/x86/x86_avx.cc: Same.\n+\t* Makefile.am: Don't build readonly and wbetl methods, memset.cc and\n+\tmemcpy.cc.\n+\t* Makefile.in: Rebuild.\n+\t* method-readonly.cc: Remove.\n+\t* method-wbetl.cc: Rename GTM::abi_dispatch::lock_type to ls_modifier.\n+\tRename GTM::abi_dispatch::NOLOCK to NONTXNAL.\n+\n+2011-06-30  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* alloc_c.cc (_ITM_dropReferences): Don't support it anymore.\n+\t* testsuite/libitm.c++/dropref.C: _ITM_dropReferences is expected to fail.\n+\t* testsuite/libitm.c/dropref-2.c: Same.\n+\t* testsuite/libitm.c/dropref.c: Same.\n+\n+2011-06-30  Torvald Riegel  <triegel@redhat.com>\n+\n+\t* config/generic/tls.h (gtm_disp): Rename to abi_disp.\n+\t* config/generic/tls.h (set_gtm_disp): Rename to set_abi_disp.\n+\t* libitm_i.h: Rename gtm_dispatch to abi_dispatch.\n+\t* alloc_c.cc: Same.\n+\t* barrier.tpl: Same.\n+\t* beginend.c: Same.\n+\t* config/generic/tls.h: Same.\n+\t* config/x86/tls.h: Same.\n+\t* libitm_i.h: Same.\n+\t* memcpy.cc: Same.\n+\t* memset.cc: Same.\n+\t* method-readonly.cc: Same.\n+\t* method-serial.cc: Same.\n+\t* method-wbetl.cc: Same.\n+\t* retry.cc: Same.\n+\n+2011-03-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/posix/rwlock.cc (write_upgrade): Add missing case.\n+\tFrom Patrik Marlier <patrick.marlier@unine.ch>.\n+\n+2011-02-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* acinclude.m4 (LIBITM_CHECK_SIZE_T_MANGLING): New.\n+\t* configure.ac: Use it.\n+\t* configure, config.h.in: Rebuild.\n+\t* alloc_cpp.cc (_ZnwX): Use MANGLE_SIZE_T in constructing the name.\n+\t(_ZnaX, _ZnwXRKSt9nothrow_t, _ZnaXRKSt9nothrow_t, _ZGTtnwX,\n+\t_ZGTtnaX, _ZGTtnwXRKSt9nothrow_t, _ZGTtnaXRKSt9nothrow_t): Likewise.\n+\t* libitm.map: Use wildcards to match size_t mangling.\n+\n+2010-12-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* beginend.cc (GTM::gtm_transaction::begin_transaction): Allocate\n+\tblocks of TIDs per thread.\n+\t* config/generic/tls.h (struct gtm_thread): Add local_tid member.\n+\t(setup_gtm_thr): Return the thread structure.\n+\t* config/x86/tls.h (setup_gtm_thr): Likewise.\n+\n+2010-12-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* clone.cc (table_lock): Remove.\n+\t(find_clone): Don't take it.\n+\t(ExcludeTransaction): New helper class.\n+\t(_ITM_registerTMCloneTable): Use it.\n+\t(_ITM_deregisterTMCloneTable): Likewise.\n+\n+2010-12-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/x86/tls.h: New file.\n+\n+2010-07-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.am (AM_CXXFLAGS): Add -funwind-tables.\n+\t* Makefile.in: Rebuild.\n+\n+2010-07-13  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* method-wbetl.cc (trydropreference): Fix source line.\n+\n+2010-07-13  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* libitm.h: Add comment.\n+\t* libitm_i.h (begin_transaction): Add ITM_REGPARM.\n+\n+2010-07-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* configure.ac: Call LIBITM_CHECK_64BIT_SYNC_BUILTINS.\n+\t* beginend.cc (begin_transaction): If 64-bit sync builtins are not\n+\tavailable, use pthread mutexes.\n+\t* acinclude.m4 (LIBITM_CHECK_64BIT_SYNC_BUILTINS): New.\n+\t* config.h.in: Regenerate.\n+\t* configure: Regenerate.\n+\n+2010-07-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* libitm.h (ITM_PURE): Define.\n+\tDeclare _ITM_malloc, _ITM_calloc, and _ITM_free.\n+\n+2010-06-28  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* method-wbetl.cc (class wbetl_dispatch): Add trydropreference.\n+\t(validate): Add comment.\n+\t(trydropreference): New.\n+\t* method-readonly.cc (class readonly_dispatch): Add\n+\ttrydropreference.\n+\t* alloc_c.cc (_ITM_dropReferences): Remove const attribute.\n+\tCall trydropreference().\n+\t* libitm.h (_ITM_dropReferences): Remove const attribute.\n+\t* method-serial.cc (class serial_dispatch): Add trydropreference.\n+\t* libitm_i.h (struct gtm_dispatch): Add trydropreference.\n+\n+2010-06-28  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* memcpy.cc (do_memcpy): Comment.\n+\n+2010-06-25  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* barrier.tpl: Add comments throughout.\n+\n+2010-06-24  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* method-wbetl.cc (struct w_entry): Add comments.\n+\t(trycommit): Same.\n+\t(rollback): Same.\n+\n+2010-06-24  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* alloc_c.cc (_ITM_dropReferences): New.\n+\t* libitm.map (_ITM_dropReferences): Add.\n+\t* libitm.h (_ITM_dropReferences): Add transaction_pure attribute.\n+\t* libitm_i.h (struct gtm_transaction): Declare\n+\tdrop_references_allocations and drop_references_local.\n+\t* local.cc (rollback_local): Ignore memory when applicable.\n+\t(drop_references_local): New.\n+\n+2010-06-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* barrier.tpl, beginend.cc, clone.cc, tls.h, memcpy.cc,\n+\tmemset.cc, method-serial.cc: Revert the 2010-06-16 change.\n+\t* config/x86/target.h (struct gtm_jmpbuf): Change CFA type to void*.\n+\t* config/alpha/target.h: Likewise.\n+\t* config/generic/tls.cc (gtm_mask_stack): Use it.\n+\n+2010-06-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/posix/cachepage.cc (gtm_cacheline_page::operator new): Use\n+\ta mutex instead of trying a lock-free compare-and-swap on the list.\n+\t(gtm_cacheline_page::operator delete): Likewise.\n+\n+2010-06-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* method-wbetl.cc (wbetl_dispatch::trycommit): Discard changes\n+\tthat overlap the libitm stack.\n+\t* barrier.tpl: Mark incoming stack.\n+\t* beginend.cc (_ITM_rollbackTransaction, _ITM_abortTransaction,\n+\t_ITM_commitTransaction, _ITM_commitTransactionEH): Likewise.\n+\t* clone.cc (_ITM_getTMCloneOrIrrevocable): Likewise.\n+\t* memcpy.cc, memset.cc: Likewise.\n+\t* method-serial.cc (_ITM_changeTransactionMode): Likewise.\n+\t* config/generic/tls.h (gtm_thread): Add stack_top member.\n+\t(gtm_stack_top, set_gtm_stack_top, struct gtm_stack_marker): New.\n+\t* libitm_i.h (gtm_mask_stack): Declare.\n+\t* config/generic/tls.cc: New file.\n+\t* Makefile.am (libitm_la_SOURCES): Add it.\n+\t(AM_CXXFLAGS): Turn off exceptions.\n+\t* Makefile.in: Rebuild.\n+\n+2010-06-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* alloc.cc (struct gtm_alloc_action): Move definition ...\n+\t* libitm_i.h: ... here.\n+\t(class gtm_transaction): Declare new and delete.\n+\t* beginend.cc (alloc_tx): Reformulate as operator new.\n+\t(free_tx): Reformulate as operator delete.\n+\t* config/generic/tls.h (gtm_thread): Change free_tx member to void *.\n+\n+2010-06-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* clone.cc (clone_entry_compare): Fix typo.\n+\tFrom Patrik Marlier <patrick.marlier@unine.ch>.\n+\n+2010-05-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* alloc_c.cc (_ITM_malloc, _ITM_calloc, _ITM_free): Wrap functions\n+\tin extern \"C\".\n+\n+2010-05-07  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* libitm_i.h (struct gtm_transaction): Remove\n+\tget_allocation_size.\n+\t(record_allocation): Remove size parameter.\n+\t* libitm.map (_ITM_realloc): Remove.\n+\t* alloc_c.cc (_ITM_realloc): Remove.\n+\t(_ITM_malloc): Remove size argument to record_allocation.\n+\t(_ITM_calloc): Same.\n+\t* alloc_cpp.cc (_ZGTtnwm): Same.\n+\t(_ZGTtnwmRKSt9nothrow_t): Same.\n+\t(_ZGTtnam): Same.\n+\t(_ZGTtnamRKSt9nothrow_t): Same.\n+\t* alloc.cc (struct gtm_alloc_action): Remove size.\n+\t(get_allocation_size): Remove.\n+\t(commit_allocations): Add comment.\n+\t(record_allocation): Remove size parameter.\n+\t(forget_allocation): Remove set of size.\n+\n+2010-04-19  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.am (abi_version): New.\n+\t(AM_CXXFLAGS): Pass abi_version.\n+\t* Makefile.in: Regenerate.\n+\t* config/x86/unaligned.h: Remove always_inline kludge for vectors.\n+\n+2010-04-06  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* clone.cc (_ITM_getTMCloneOrIrrevocable): Rename from\n+\t_ITM_getTMCloneOrIrrevokable.\n+\t* libitm.h (_ITM_getTMCloneOrIrrevocable): Same.\n+\t* libitm.map (_ITM_getTMCloneOrIrrevocable): Same.\n+\n+2010-03-26  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* configure.ac: Remove Linux futex support.\n+\t* configure.tgt (config_path): Same.\n+\t* Makefile.am: Same.\n+\t* config/linux: Remove entire directory.\n+\t* configure: Rebuild.\n+\t* Makefile.in: Rebuild.\n+\t* testsuite/Makefile.in: Rebuild.\n+\n+2010-03-09  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* retry.cc (decide_retry_strategy): Set state to STATE_SERIAL when\n+\tswitching to serial mode.\n+\t* beginend.cc (trycommit_and_finalize): Unlock serial_lock.\n+\n+2010-03-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* configure.tgt: Add emacs -*- tags.\n+\t* barrier.tpl: Same.\n+\n+2010-02-23  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.am: Rename serial.cc to method-serial.cc.\n+\t* Makefile.in: Regenerate with automake 1.11.1.\n+\t* testsuite/Makefile.in: Same.\n+\t* aclocal.m4: Regenerate with aclocal 1.11.1.\n+\t* method-serial.cc: Rename from serial.cc.\n+\t* libitm_i.h (struct gtm_transaction): Update comment on\n+\tserialirr_mode.\n+\n+2010-02-22  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* libitm_i.h (GTM_longjmp): Add ITM_REGPARM.\n+\t* config/linux/rwlock.h (class gtm_rwlock): Add comments.\n+\n+2010-02-11  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* configure: Rebuild.\n+\n+2009-11-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* Rewrite everything in C++.\n+\n+2009-11-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/x86/x86_sse.c, config/x86/x86_avx.c: New files.\n+\t* Makefile.am (libitm_la_SOURCES): Add them.\n+\t* configure.ac (ARCH_X86): New conditional.\n+\t* Makefile.in, configure: Rebuild.\n+\t* configure.tgt: Set up ARCH; do cflags setup at the same time.\n+\tMove futex setup into \"other system configury\" case.\n+\t* local.c (rollback_local): Merge into ...\n+\t(GTM_rollback_local): ... here.\n+\t(GTM_LB): Rename from GTM_alloc_local; do the memcpy here.\n+\t(_ITM_LB): Define as an alias to GTM_LB.\n+\n+2009-11-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* method-readonly.c: New file.\n+\t* Makefile.am (libitm_la_SOURCES): Add it.\n+\t* Makefile.in: Rebuild.\n+\t* beginend.c (gtm_stmlock_array, gtm_clock): New.\n+\t(GTM_begin_transaction): Use dispatch_readonly for read-only txn.\n+\t* libitm_i.h (gtm_stmlock, gtm_version): Move from method-wbetl.c.\n+\t(GTM_VERSION_MAX, GTM_VERSION_INVALID, gtm_stmlock_owned_p,\n+\tgtm_stmlock_set_owned, gtm_stmlock_get_addr,\n+\tgtm_stmlock_get_version, gtm_stmlock_set_version, LOCK_ARRAY_SIZE,\n+\tgtm_stmlock_array, gtm_get_stmlock, gtm_clock, RESTART_NOT_READONLY,\n+\tgtm_get_clock, gtm_inc_clock): New.\n+\t* method-wbetl.c (gtm_version, gtm_stmlock, OWNED_MASK, VERSION_MAX,\n+\tLOCK_GET_OWNED, LOCK_SET_ADDR, LOCK_GET_ADDR, LOCK_GET_TIMESTAMP,\n+\tLOCK_SET_TIMESTAMP, LOCK_ARRAY_SIZE, LOCK_MASK, LOCK_IDX, GET_LOCK,\n+\tlocks, gclock, CLOCK, GET_CLOCK, FETCH_AND_INC_CLOCK): Remove and\n+\treplace uses with new libitm_i.h symbols.\n+\t(dispatch_wbetl): Rename from wbetl_dispatch.\n+\t* retry.c (GTM_decide_retry_strategy): If RESTART_NOT_READONLY, move\n+\taway from dispatch_readonly; abort if the beginTransaction call\n+\tasserted that the transaction was readonly.\n+\n+2009-11-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* memset.c: New file.\n+\t* Makefile.am (libitm_la_SOURCES): Add it.\n+\t* Makefile.in: Rebuild.\n+\t* testsuite/libitm.c/memset-1.c: New.\n+\n+2009-11-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* dispatch.c: Remove file.\n+\t* useraction.c (struct gtm_user_action): Move from libitm.h.\n+\t* serial.c (GTM_null_read_lock, GTM_null_write_lock): New.\n+\t(serial_memset, serial_memmove, serial_memcpy): Remove.\n+\t(serial_W*, serial_R*): Remove.\n+\t(serial_dispatch): Update to match.\n+\t* configure.ac: Move Werror down below configure checks.  Don't\n+\tcheck for sys/loadavg.h, do check for malloc.h.  Don't check for\n+\tgetloadavg and clock_gettime; do check for memalign, posix_memalign.\n+\tUse GCC_AC_FUNC_MMAP_BLACKLIST\n+\t* libitm.h: Split out all internal items to...\n+\t* libitm_i.h: ... here.  New file.\n+\t* copymask.c: New file.\n+\t* local.c (struct gtm_local_undo): Move from libitm.h.\n+\t(GTM_alloc_local): Rename from alloc_local; export.\n+\t* memcpy.c: New file.\n+\t* alloc_c.c (_ITM_realloc): Use _ITM_memcpyRnWt directly.\n+\t* config/posix/page.c: New file.\n+\t* config/posix/target_tls.h: Remove file.\n+\t* barrier.c: New file.\n+\t* Makefile.am (libitm_la_SOURCES): Add barrier.c, memcpy.c,\n+\tcopymask.c, page.c.\n+\t* alloc.c (struct gtm_alloc_action): Move from libitm.h.\n+\t* method-wbetl.c: Rewrite for new cacheline methods.\n+\t* Makefile.in, configure, testsuite/Makefile.in, config.h.in: Rebuild.\n+\n+\t* config/alpha/sjlj.S: Fix typo.\n+\t* config/alpha/target_i.h: Copy functions from alpha/target.h.\n+\t* config/alpha/copymask.c: New file.\n+\t* config/alpha/target.h (CACHELINE_SIZE): New.\n+\t(STRICT_ALIGNMENT, PAGE_SIZE, FIXED_PAGE_SIZE): New.\n+\n+\t* config/x86/target_i.h: Copy functions from x86/target.h.\n+\t* config/x86/copymask.c: New file.\n+\t* config/x86/target.h (_ITM_ALL_TARGET_TYPES): Remove.\n+\t(CACHELINE_SIZE, STRICT_ALIGNMENT): New.\n+\t(PAGE_SIZE, FIXED_PAGE_SIZE): New.\n+\t* config/x86/target_tls.h: Move contents to target_i.h.\n+\n+\t* testsuite/libitm.c/clone-1.c: Include libitm.h.\n+\t* testsuite/libitm.c/memcpy-1.c: New.\n+\n+2009-10-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.am (CCAS, CCASFLAGS, LTCCASCOMPILE): Remove.\n+\t(AM_CCASFLAGS): New.\n+\t* configure.ac: Add AM_PROG_AS.  Use m4_rename_force for\n+\tsaving/restoring _AC_ARG_VAR_PRECIOUS.\n+\t* Makefile.in, aclocal.m4, config.h.in, configure,\n+\ttestsuite/Makefile.in: Rebuild with automake 1.11; autoconf 2.64.\n+\n+2009-10-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* testsuite/*: Update for new compiler syntax.\n+\n+2009-10-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* libitm.h (_ITM_abortReason): Add outerAbort.\n+\n+2009-08-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* libitm.map (_ITM_commitTransactionEH, _ITM_cxa_allocate_exception,\n+\t_ITM_cxa_begin_catch, _ITM_cxa_end_catch, _ITM_cxa_throw): Export.\n+\t* method-wbetl.c (struct w_entry): Remove mask.\n+\t(wbetl_write, wbetl_load): Return pointer to word containing the data;\n+\tadjust all callers.\n+\n+2009-07-22  Richard Henderson  <rth@redhat.com>\n+\n+\t* eh_cpp.c: New file.\n+\t* Makefile.am (libitm_la_SOURCES): Add it.\n+\t* Makefile.in: Rebuild.\n+\t* beginend.c (GTM_rollback_transaction): Undo exception state.\n+\t(GTM_trycommit_transaction): Mark inline.\n+\t(GTM_trycommit_and_finalize_transaction): Split out from ...\n+\t(_ITM_commitTransaction): ... here.\n+\t(_ITM_commitTransactionEH): New function.\n+\t* libitm.h (struct gtm_transaction): Add cxa_catch_count,\n+\tcxa_unthrown, eh_in_flight; reorder.\n+\n+\t* testsuite/libitm.c++/c++.exp: New.\n+\t* testsuite/libitm.c++/eh-1.C: New.\n+\n+\t* aatree.c (aa_free): Remove REGPARM.\n+\t* aatree.h: Remove all REGPARM.\n+\n+2009-07-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* aatree.c, aatree.h, alloc.c, alloc_c.c, alloc_cpp.c: New files.\n+\t* Makefile.am (libitm_la_SOURCES): Add them.\n+\t* Makefile.in: Rebuild.\n+\t* beginend.c (GTM_rollback_transaction): Use GTM_commit_allocations.\n+\t(GTM_trycommit_transaction): Likewise.\n+\t* libitm.h: Include aatree.h\n+\t(struct gtm_alloc_action): New.\n+\t(struct gtm_transaction): Add alloc_actions.\n+\t(GTM_record_allocation, GTM_forget_allocation): Declare.\n+\t(GTM_get_allocation_size, GTM_commit_allocations): Declare.\n+\t* libitm.map (_ITM_malloc, _ITM_calloc, _ITM_realloc, _ITM_free,\n+\t_ZGTtnwm, _ZGTtnam, _ZGTtdlPv, _ZGTtdaPv, _ZGTtnwmRKSt9nothrow_t,\n+\t_ZGTtnamRKSt9nothrow_t, _ZGTtdlPvRKSt9nothrow_t,\n+\t_ZGTtdaPvRKSt9nothrow_t): Export.\n+\n+2009-07-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* target_tls.h: Move ...\n+\t* config/posix/target_tls.h: ... here.\n+\n+2009-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/x86/target.h (atomic_write_barrier): Use sfence if available.\n+\n+2009-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* Update to GPL3.\n+\n+2009-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* libitm.h (struct gtm_transaction): Widen id to _ITM_transactionId_t.\n+\t* beginend.c (global_tid): Widen to _ITM_transactionId_t.\n+\n+\t* configure.tgt: Don't use -ftls-model for x86 linux.\n+\t* libitm.h: Include target.h after standard includes.\n+\t(_gtm_thr): Rename from gtm_thr.\n+\t(setup_gtm_thr, gtm_thr, gtm_tx, set_gtm_tx): New.\n+\t(gtm_disp, set_gtm_disp): New.\n+\t* beginend.c, dispatch.c, local.c, method-wbetl.c, query.c,\n+\tretry.c, serial.c, useraction.c: Use accessor functions throughout.\n+\t* config/alpha/target_tls.h, config/x86/target_tls.h: New files.\n+\n+2009-07-07  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/linux/rwlock.c (EZ): New define.  Use it throughout.\n+\n+2009-07-06  Richard Henderson  <rth@redhat.com>\n+\n+\t* libitm.h (_ITM_SRCLOCATION_DECL_1, _ITM_SRCLOCATION_DECL_2): Remove.\n+\t(_ITM_SRCLOCATION_DEFN_1, _ITM_SRCLOCATION_DEFN_2): Remove.\n+\t(_ITM_beginTransaction): Take variadic arguments.\n+\t(_ITM_registerThrownObject): Declare.\n+\t* beginend.c, serial.c: Update.\n+\t* libitm.map: Add _ITM_registerThrownObject.\n+\n+2009-01-28  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.am (libitm_la_SOURCES): Add clone.c.\n+\t* Makefile.in: Rebuild.\n+\t* beginend.c (_ITM_abortTransaction): Abort if irrevokable.\n+\t(GTM_restart_transaction): Fix uninstrumented code check.\n+\t* retry.c (GTM_decide_retry_strategy): Add serial check.\n+\t* serial.c (GTM_serialmode): Add irrevokable variable.  Don't\n+\tautomatically go irrevokable when in serial mode.\n+\t* clone.c: New file.\n+\t* libitm.h, libitm.map: Update.\n+\n+2009-01-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.am (LTCCASCOMPILE): Define.\n+\t(libitm_la_SOURCES): Add methid-wbetl.c.\n+\t* testsuite/Makefile.am: New\n+\t* configure.ac: Add testsuite/Makefile.\n+\t* Makefile.in, testsuite/Makefile.in, configure: Regenerate.\n+\t* beginend.c (GTM_begin_transaction): Install wbetl_dispatch.\n+\t(_ITM_abortTransaction): Finalize implementation method; pass\n+\ttransaction properties to longjmp.\n+\t(GTM_restart_transaction): Split out from ...\n+\t(_ITM_commitTransaction): ... here.\n+\t* config/linux/x86/futex_bits.h (cpu_relax, atomic_write_barrier):\n+\tMove to config/x86/target.h.\n+\t* config/linux/alpha/futex_bits.h: New.\n+\t* config/x86/sjlj.S (GTM_longjmp): Fix 64-bit input register.\n+\t* config/x86/target.h: Disable target types for 32-bit.\n+\t* config/alpha/sjlj.S, config/alpha/target.h: New.\n+\t* libitm.h (struct gtm_dispatch): Add init, fini.\n+\t(enum restart_reason): New.\n+\t(struct gtm_transaction): Add method and restarts.\n+\t* retry.c (GTM_decide_retry_strategy): Implement.\n+\t* serial.c (serial_init, serial_fini): New.\n+\t(GTM_serialmode): Finialize outgoing method.\n+\t* method-wbetl.c: New.\n+\n+2008-12-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/x86/target.h (_ITM_ALL_TARGET_TYPES, _ITM_TYPE_ATTR): New.\n+\t* configure.tgt (i386-*, x86_64-*): Don't force SSE.\n+\t* dispatch.c (_ITM_##R##T, _ITM_##W##T): Use _ITM_TYPE_ATTR.\n+\t* libitm.h (_ITM_ALL_TARGET_TYPES, _ITM_TYPE_ATTR): Provide default.\n+\t(_ITM_TYPE_M64, _ITM_TYPE_M128, _ITM_TYPE_M256): Move to x86 header.\n+\t(_ITM_ALL_TYPES): Use _ITM_ALL_TARGET_TYPES.\n+\t* local.c (_ITM_L##T): Use _ITM_TYPE_ATTR.\n+\t* serial.c (serial_R##T, serial_W##T): Likewise.\n+\n+2008-11-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* Initial commit."}, {"sha": "69234099b6cfc4d7c9e2b519417cfb3189cc3528", "filename": "libitm/Makefile.am", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FMakefile.am?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,98 @@\n+## Process this file with automake to produce Makefile.in\n+\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+SUBDIRS = testsuite\n+\n+## May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+abi_version = -fabi-version=4\n+\n+config_path = @config_path@\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) $(top_srcdir)\n+\n+fincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/finclude\n+libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n+\n+vpath % $(strip $(search_path))\n+\n+AM_CPPFLAGS = $(addprefix -I, $(search_path))\n+AM_CFLAGS = $(XCFLAGS)\n+AM_CXXFLAGS = -std=gnu++0x -funwind-tables -fno-exceptions -fno-rtti \\\n+\t$(XCFLAGS) $(abi_version)\n+AM_CCASFLAGS = $(XCFLAGS)\n+AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n+\n+toolexeclib_LTLIBRARIES = libitm.la\n+nodist_toolexeclib_HEADERS = libitm.spec\n+\n+if LIBITM_BUILD_VERSIONED_SHLIB\n+libitm_version_script = -Wl,--version-script,$(top_srcdir)/libitm.map\n+else\n+libitm_version_script =\n+endif\n+libitm_version_info = -version-info $(libtool_VERSION)\n+\n+# Force link with C, not C++.  For now, while we're using C++ we don't\n+# want or need libstdc++.\n+libitm_la_LINK = $(LINK)\n+libitm_la_LDFLAGS = $(libitm_version_info) $(libitm_version_script) \\\n+        -no-undefined\n+\n+libitm_la_SOURCES = \\\n+\taatree.cc alloc.cc alloc_c.cc alloc_cpp.cc barrier.cc beginend.cc \\\n+\tclone.cc cacheline.cc cachepage.cc eh_cpp.cc local.cc \\\n+\tquery.cc retry.cc rwlock.cc useraction.cc util.cc \\\n+\tsjlj.S tls.cc method-serial.cc method-gl.cc\n+\n+if ARCH_X86\n+libitm_la_SOURCES += x86_sse.cc x86_avx.cc\n+x86_sse.lo : XCFLAGS += -msse\n+x86_avx.lo : XCFLAGS += -mavx\n+endif\n+\n+if ARCH_FUTEX\n+libitm_la_SOURCES += futex.cc\n+endif\n+\n+# Automake Documentation:\n+# If your package has Texinfo files in many directories, you can use the\n+# variable TEXINFO_TEX to tell Automake where to find the canonical\n+# `texinfo.tex' for your package. The value of this variable should be\n+# the relative path from the current `Makefile.am' to `texinfo.tex'.\n+TEXINFO_TEX   = ../gcc/doc/include/texinfo.tex\n+\n+# Defines info, dvi, pdf and html targets\n+MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include\n+info_TEXINFOS = libitm.texi\n+\n+# AM_CONDITIONAL on configure option --generated-files-in-srcdir\n+if GENINSRC\n+STAMP_GENINSRC = stamp-geninsrc\n+else\n+STAMP_GENINSRC =\n+endif\n+\n+# AM_CONDITIONAL on configure check ACX_CHECK_PROG_VER([MAKEINFO])\n+if BUILD_INFO\n+STAMP_BUILD_INFO = stamp-build-info\n+else\n+STAMP_BUILD_INFO =\n+endif\n+\n+\n+all-local: $(STAMP_GENINSRC)\n+\n+stamp-geninsrc: libitm.info\n+\tcp -p $(top_builddir)/libitm.info $(srcdir)/libitm.info\n+\t@touch $@\n+\n+libitm.info: $(STAMP_BUILD_INFO)\n+\n+stamp-build-info: libitm.texi\n+\t$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) -o libitm.info $(srcdir)/libitm.texi\n+\t@touch $@\n+\n+\n+CLEANFILES = $(STAMP_GENINSRC) $(STAMP_BUILD_INFO) libitm.info\n+MAINTAINERCLEANFILES = $(srcdir)/libitm.info"}, {"sha": "7dc864b3087e5e522df1602a1e91508db85fe970", "filename": "libitm/Makefile.in", "status": "added", "additions": 1283, "deletions": 0, "changes": 1283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2FMakefile.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,1283 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+@ARCH_X86_TRUE@am__append_1 = x86_sse.cc x86_avx.cc\n+@ARCH_FUTEX_TRUE@am__append_2 = futex.cc\n+subdir = .\n+DIST_COMMON = $(am__configure_deps) $(srcdir)/../config.guess \\\n+\t$(srcdir)/../config.sub $(srcdir)/../depcomp \\\n+\t$(srcdir)/../install-sh $(srcdir)/../ltmain.sh \\\n+\t$(srcdir)/../missing $(srcdir)/../mkinstalldirs \\\n+\t$(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/config.h.in $(srcdir)/libitm.spec.in \\\n+\t$(top_srcdir)/configure ChangeLog\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/enable.m4 \\\n+\t$(top_srcdir)/../config/futex.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/mmap.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../ltoptions.m4 \\\n+\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n+\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n+\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = config.h\n+CONFIG_CLEAN_FILES = libitm.spec\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+libitm_la_LIBADD =\n+am__libitm_la_SOURCES_DIST = aatree.cc alloc.cc alloc_c.cc \\\n+\talloc_cpp.cc barrier.cc beginend.cc clone.cc cacheline.cc \\\n+\tcachepage.cc eh_cpp.cc local.cc query.cc retry.cc rwlock.cc \\\n+\tuseraction.cc util.cc sjlj.S tls.cc method-serial.cc \\\n+\tmethod-gl.cc x86_sse.cc x86_avx.cc futex.cc\n+@ARCH_X86_TRUE@am__objects_1 = x86_sse.lo x86_avx.lo\n+@ARCH_FUTEX_TRUE@am__objects_2 = futex.lo\n+am_libitm_la_OBJECTS = aatree.lo alloc.lo alloc_c.lo alloc_cpp.lo \\\n+\tbarrier.lo beginend.lo clone.lo cacheline.lo cachepage.lo \\\n+\teh_cpp.lo local.lo query.lo retry.lo rwlock.lo useraction.lo \\\n+\tutil.lo sjlj.lo tls.lo method-serial.lo method-gl.lo \\\n+\t$(am__objects_1) $(am__objects_2)\n+libitm_la_OBJECTS = $(am_libitm_la_OBJECTS)\n+DEFAULT_INCLUDES = -I.@am__isrc@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n+LTCPPASCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n+CXXLD = $(CXX)\n+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libitm_la_SOURCES)\n+DIST_SOURCES = $(am__libitm_la_SOURCES_DIST)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+INFO_DEPS = libitm.info\n+am__TEXINFO_TEX_DIR = $(srcdir)/../gcc/doc/include\n+DVIS = libitm.dvi\n+PDFS = libitm.pdf\n+PSS = libitm.ps\n+HTMLS = libitm.html\n+TEXINFOS = libitm.texi\n+TEXI2DVI = texi2dvi\n+TEXI2PDF = $(TEXI2DVI) --pdf --batch\n+MAKEINFOHTML = $(MAKEINFO) --html\n+AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)\n+DVIPS = dvips\n+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n+\thtml-recursive info-recursive install-data-recursive \\\n+\tinstall-dvi-recursive install-exec-recursive \\\n+\tinstall-html-recursive install-info-recursive \\\n+\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n+\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n+\tps-recursive uninstall-recursive\n+HEADERS = $(nodist_toolexeclib_HEADERS)\n+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n+  distclean-recursive maintainer-clean-recursive\n+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n+\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \\\n+\tdistdir dist dist-all distcheck\n+ETAGS = etags\n+CTAGS = ctags\n+DIST_SUBDIRS = $(SUBDIRS)\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+am__remove_distdir = \\\n+  { test ! -d \"$(distdir)\" \\\n+    || { find \"$(distdir)\" -type d ! -perm -200 -exec chmod u+w {} ';' \\\n+         && rm -fr \"$(distdir)\"; }; }\n+am__relativize = \\\n+  dir0=`pwd`; \\\n+  sed_first='s,^\\([^/]*\\)/.*$$,\\1,'; \\\n+  sed_rest='s,^[^/]*/*,,'; \\\n+  sed_last='s,^.*/\\([^/]*\\)$$,\\1,'; \\\n+  sed_butlast='s,/*[^/]*$$,,'; \\\n+  while test -n \"$$dir1\"; do \\\n+    first=`echo \"$$dir1\" | sed -e \"$$sed_first\"`; \\\n+    if test \"$$first\" != \".\"; then \\\n+      if test \"$$first\" = \"..\"; then \\\n+        dir2=`echo \"$$dir0\" | sed -e \"$$sed_last\"`/\"$$dir2\"; \\\n+        dir0=`echo \"$$dir0\" | sed -e \"$$sed_butlast\"`; \\\n+      else \\\n+        first2=`echo \"$$dir2\" | sed -e \"$$sed_first\"`; \\\n+        if test \"$$first2\" = \"$$first\"; then \\\n+          dir2=`echo \"$$dir2\" | sed -e \"$$sed_rest\"`; \\\n+        else \\\n+          dir2=\"../$$dir2\"; \\\n+        fi; \\\n+        dir0=\"$$dir0\"/\"$$first\"; \\\n+      fi; \\\n+    fi; \\\n+    dir1=`echo \"$$dir1\" | sed -e \"$$sed_rest\"`; \\\n+  done; \\\n+  reldir=\"$$dir2\"\n+DIST_ARCHIVES = $(distdir).tar.gz\n+GZIP_ENV = --best\n+distuninstallcheck_listfiles = find . -type f -print\n+distcleancheck_listfiles = find . -type f -print\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CXX = @CXX@\n+CXXCPP = @CXXCPP@\n+CXXDEPMODE = @CXXDEPMODE@\n+CXXFLAGS = @CXXFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FC = @FC@\n+FCFLAGS = @FCFLAGS@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAINT = @MAINT@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OPT_LDFLAGS = @OPT_LDFLAGS@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PERL = @PERL@\n+RANLIB = @RANLIB@\n+SECTION_LDFLAGS = @SECTION_LDFLAGS@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+XCFLAGS = @XCFLAGS@\n+XLDFLAGS = @XLDFLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_CXX = @ac_ct_CXX@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+ac_ct_FC = @ac_ct_FC@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+config_path = @config_path@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+link_itm = @link_itm@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+SUBDIRS = testsuite\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+abi_version = -fabi-version=4\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) $(top_srcdir)\n+fincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/finclude\n+libsubincludedir = $(libdir)/gcc/$(target_alias)/$(gcc_version)/include\n+AM_CPPFLAGS = $(addprefix -I, $(search_path))\n+AM_CFLAGS = $(XCFLAGS)\n+AM_CXXFLAGS = -std=gnu++0x -funwind-tables -fno-exceptions -fno-rtti \\\n+\t$(XCFLAGS) $(abi_version)\n+\n+AM_CCASFLAGS = $(XCFLAGS)\n+AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n+toolexeclib_LTLIBRARIES = libitm.la\n+nodist_toolexeclib_HEADERS = libitm.spec\n+@LIBITM_BUILD_VERSIONED_SHLIB_FALSE@libitm_version_script = \n+@LIBITM_BUILD_VERSIONED_SHLIB_TRUE@libitm_version_script = -Wl,--version-script,$(top_srcdir)/libitm.map\n+libitm_version_info = -version-info $(libtool_VERSION)\n+\n+# Force link with C, not C++.  For now, while we're using C++ we don't\n+# want or need libstdc++.\n+libitm_la_LINK = $(LINK)\n+libitm_la_LDFLAGS = $(libitm_version_info) $(libitm_version_script) \\\n+        -no-undefined\n+\n+libitm_la_SOURCES = aatree.cc alloc.cc alloc_c.cc alloc_cpp.cc \\\n+\tbarrier.cc beginend.cc clone.cc cacheline.cc cachepage.cc \\\n+\teh_cpp.cc local.cc query.cc retry.cc rwlock.cc useraction.cc \\\n+\tutil.cc sjlj.S tls.cc method-serial.cc method-gl.cc \\\n+\t$(am__append_1) $(am__append_2)\n+\n+# Automake Documentation:\n+# If your package has Texinfo files in many directories, you can use the\n+# variable TEXINFO_TEX to tell Automake where to find the canonical\n+# `texinfo.tex' for your package. The value of this variable should be\n+# the relative path from the current `Makefile.am' to `texinfo.tex'.\n+TEXINFO_TEX = ../gcc/doc/include/texinfo.tex\n+\n+# Defines info, dvi, pdf and html targets\n+MAKEINFOFLAGS = -I $(srcdir)/../gcc/doc/include\n+info_TEXINFOS = libitm.texi\n+@GENINSRC_FALSE@STAMP_GENINSRC = \n+\n+# AM_CONDITIONAL on configure option --generated-files-in-srcdir\n+@GENINSRC_TRUE@STAMP_GENINSRC = stamp-geninsrc\n+@BUILD_INFO_FALSE@STAMP_BUILD_INFO = \n+\n+# AM_CONDITIONAL on configure check ACX_CHECK_PROG_VER([MAKEINFO])\n+@BUILD_INFO_TRUE@STAMP_BUILD_INFO = stamp-build-info\n+CLEANFILES = $(STAMP_GENINSRC) $(STAMP_BUILD_INFO) libitm.info\n+MAINTAINERCLEANFILES = $(srcdir)/libitm.info\n+all: config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n+\n+.SUFFIXES:\n+.SUFFIXES: .S .cc .dvi .lo .o .obj .ps\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+config.h: stamp-h1\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n+\telse :; fi\n+\n+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n+$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n+\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f config.h stamp-h1\n+libitm.spec: $(top_builddir)/config.status $(srcdir)/libitm.spec.in\n+\tcd $(top_builddir) && $(SHELL) ./config.status $@\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libitm.la: $(libitm_la_OBJECTS) $(libitm_la_DEPENDENCIES) \n+\t$(libitm_la_LINK) -rpath $(toolexeclibdir) $(libitm_la_OBJECTS) $(libitm_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/aatree.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc_c.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alloc_cpp.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/barrier.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/beginend.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cacheline.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cachepage.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/clone.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eh_cpp.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/futex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/local.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/method-gl.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/method-serial.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/query.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/retry.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rwlock.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sjlj.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tls.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/useraction.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/x86_avx.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/x86_sse.Plo@am__quote@\n+\n+.S.o:\n+@am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCCAS_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(CPPASCOMPILE) -c -o $@ $<\n+\n+.S.obj:\n+@am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCCAS_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.S.lo:\n+@am__fastdepCCAS_TRUE@\t$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCCAS_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(LTCPPASCOMPILE) -c -o $@ $<\n+\n+.cc.o:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ $<\n+\n+.cc.obj:\n+@am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.cc.lo:\n+@am__fastdepCXX_TRUE@\t$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCXX_FALSE@\t$(LTCXXCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+\n+libitm.dvi: libitm.texi  \n+\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n+\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \\\n+\t$(TEXI2DVI) -o $@ `test -f 'libitm.texi' || echo '$(srcdir)/'`libitm.texi\n+\n+libitm.pdf: libitm.texi  \n+\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n+\tMAKEINFO='$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir)' \\\n+\t$(TEXI2PDF) -o $@ `test -f 'libitm.texi' || echo '$(srcdir)/'`libitm.texi\n+\n+libitm.html: libitm.texi  \n+\trm -rf $(@:.html=.htp)\n+\tif $(MAKEINFOHTML) $(AM_MAKEINFOHTMLFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) \\\n+\t -o $(@:.html=.htp) `test -f 'libitm.texi' || echo '$(srcdir)/'`libitm.texi; \\\n+\tthen \\\n+\t  rm -rf $@; \\\n+\t  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \\\n+\t    mv $(@:.html=) $@; else mv $(@:.html=.htp) $@; fi; \\\n+\telse \\\n+\t  if test ! -d $(@:.html=.htp) && test -d $(@:.html=); then \\\n+\t    rm -rf $(@:.html=); else rm -Rf $(@:.html=.htp) $@; fi; \\\n+\t  exit 1; \\\n+\tfi\n+.dvi.ps:\n+\tTEXINPUTS=\"$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS\" \\\n+\t$(DVIPS) -o $@ $<\n+\n+uninstall-dvi-am:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(DVIS)'; test -n \"$(dvidir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" rm -f '$(DESTDIR)$(dvidir)/$$f'\"; \\\n+\t  rm -f \"$(DESTDIR)$(dvidir)/$$f\"; \\\n+\tdone\n+\n+uninstall-html-am:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(HTMLS)'; test -n \"$(htmldir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" rm -rf '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t  rm -rf \"$(DESTDIR)$(htmldir)/$$f\"; \\\n+\tdone\n+\n+uninstall-info-am:\n+\t@$(PRE_UNINSTALL)\n+\t@if test -d '$(DESTDIR)$(infodir)' && \\\n+\t    (install-info --version && \\\n+\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n+\t  list='$(INFO_DEPS)'; \\\n+\t  for file in $$list; do \\\n+\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n+\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' --remove '$(DESTDIR)$(infodir)/$$relfile'\"; \\\n+\t    if install-info --info-dir=\"$(DESTDIR)$(infodir)\" --remove \"$(DESTDIR)$(infodir)/$$relfile\"; \\\n+\t    then :; else test ! -f \"$(DESTDIR)$(infodir)/$$relfile\" || exit 1; fi; \\\n+\t  done; \\\n+\telse :; fi\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(INFO_DEPS)'; \\\n+\tfor file in $$list; do \\\n+\t  relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n+\t  relfile_i=`echo \"$$relfile\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  (if test -d \"$(DESTDIR)$(infodir)\" && cd \"$(DESTDIR)$(infodir)\"; then \\\n+\t     echo \" cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]\"; \\\n+\t     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \\\n+\t   else :; fi); \\\n+\tdone\n+\n+uninstall-pdf-am:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(PDFS)'; test -n \"$(pdfdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" rm -f '$(DESTDIR)$(pdfdir)/$$f'\"; \\\n+\t  rm -f \"$(DESTDIR)$(pdfdir)/$$f\"; \\\n+\tdone\n+\n+uninstall-ps-am:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(PSS)'; test -n \"$(psdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" rm -f '$(DESTDIR)$(psdir)/$$f'\"; \\\n+\t  rm -f \"$(DESTDIR)$(psdir)/$$f\"; \\\n+\tdone\n+\n+dist-info: $(INFO_DEPS)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n+\tlist='$(INFO_DEPS)'; \\\n+\tfor base in $$list; do \\\n+\t  case $$base in \\\n+\t    $(srcdir)/*) base=`echo \"$$base\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+\t  esac; \\\n+\t  if test -f $$base; then d=.; else d=$(srcdir); fi; \\\n+\t  base_i=`echo \"$$base\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  for file in $$d/$$base $$d/$$base-[0-9] $$d/$$base-[0-9][0-9] $$d/$$base_i[0-9] $$d/$$base_i[0-9][0-9]; do \\\n+\t    if test -f $$file; then \\\n+\t      relfile=`expr \"$$file\" : \"$$d/\\(.*\\)\"`; \\\n+\t      test -f \"$(distdir)/$$relfile\" || \\\n+\t\tcp -p $$file \"$(distdir)/$$relfile\"; \\\n+\t    else :; fi; \\\n+\t  done; \\\n+\tdone\n+\n+mostlyclean-aminfo:\n+\t-rm -rf libitm.aux libitm.cp libitm.cps libitm.fn libitm.fns libitm.ky \\\n+\t  libitm.kys libitm.log libitm.pg libitm.pgs libitm.tmp \\\n+\t  libitm.toc libitm.tp libitm.tps libitm.vr libitm.vrs\n+\n+clean-aminfo:\n+\t-test -z \"libitm.dvi libitm.pdf libitm.ps libitm.html\" \\\n+\t|| rm -rf libitm.dvi libitm.pdf libitm.ps libitm.html\n+\n+maintainer-clean-aminfo:\n+\t@list='$(INFO_DEPS)'; for i in $$list; do \\\n+\t  i_i=`echo \"$$i\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  echo \" rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]\"; \\\n+\t  rm -f $$i $$i-[0-9] $$i-[0-9][0-9] $$i_i[0-9] $$i_i[0-9][0-9]; \\\n+\tdone\n+install-nodist_toolexeclibHEADERS: $(nodist_toolexeclib_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(toolexeclibdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-nodist_toolexeclibHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibdir)\" && rm -f $$files\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+$(RECURSIVE_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+$(RECURSIVE_CLEAN_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\tcase \"$@\" in \\\n+\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n+\t  *) list='$(SUBDIRS)' ;; \\\n+\tesac; \\\n+\trev=''; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = \".\"; then :; else \\\n+\t    rev=\"$$subdir $$rev\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\trev=\"$$rev .\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+ctags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n+\tdone\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n+\t  include_option=--etags-include; \\\n+\t  empty_fix=.; \\\n+\telse \\\n+\t  include_option=--include; \\\n+\t  empty_fix=; \\\n+\tfi; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test ! -f $$subdir/TAGS || \\\n+\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t$(am__remove_distdir)\n+\ttest -d \"$(distdir)\" || mkdir \"$(distdir)\"\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test -d \"$(distdir)/$$subdir\" \\\n+\t    || $(MKDIR_P) \"$(distdir)/$$subdir\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    dir1=$$subdir; dir2=\"$(distdir)/$$subdir\"; \\\n+\t    $(am__relativize); \\\n+\t    new_distdir=$$reldir; \\\n+\t    dir1=$$subdir; dir2=\"$(top_distdir)\"; \\\n+\t    $(am__relativize); \\\n+\t    new_top_distdir=$$reldir; \\\n+\t    echo \" (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=\"$$new_top_distdir\" distdir=\"$$new_distdir\" \\\\\"; \\\n+\t    echo \"     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)\"; \\\n+\t    ($(am__cd) $$subdir && \\\n+\t      $(MAKE) $(AM_MAKEFLAGS) \\\n+\t        top_distdir=\"$$new_top_distdir\" \\\n+\t        distdir=\"$$new_distdir\" \\\n+\t\tam__remove_distdir=: \\\n+\t\tam__skip_length_check=: \\\n+\t\tam__skip_mode_fix=: \\\n+\t        distdir) \\\n+\t      || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t$(MAKE) $(AM_MAKEFLAGS) \\\n+\t  top_distdir=\"$(top_distdir)\" distdir=\"$(distdir)\" \\\n+\t  dist-info\n+\t-test -n \"$(am__skip_mode_fix)\" \\\n+\t|| find \"$(distdir)\" -type d ! -perm -755 \\\n+\t\t-exec chmod u+rwx,go+rx {} \\; -o \\\n+\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \\; \\\n+\t|| chmod -R a+r \"$(distdir)\"\n+dist-gzip: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+dist-bzip2: distdir\n+\ttardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2\n+\t$(am__remove_distdir)\n+\n+dist-lzma: distdir\n+\ttardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma\n+\t$(am__remove_distdir)\n+\n+dist-xz: distdir\n+\ttardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz\n+\t$(am__remove_distdir)\n+\n+dist-tarZ: distdir\n+\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n+\t$(am__remove_distdir)\n+\n+dist-shar: distdir\n+\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n+\t$(am__remove_distdir)\n+\n+dist-zip: distdir\n+\t-rm -f $(distdir).zip\n+\tzip -rq $(distdir).zip $(distdir)\n+\t$(am__remove_distdir)\n+\n+dist dist-all: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\tcase '$(DIST_ARCHIVES)' in \\\n+\t*.tar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\\\n+\t*.tar.bz2*) \\\n+\t  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\\\n+\t*.tar.lzma*) \\\n+\t  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\\\n+\t*.tar.xz*) \\\n+\t  xz -dc $(distdir).tar.xz | $(am__untar) ;;\\\n+\t*.tar.Z*) \\\n+\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n+\t*.shar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\\\n+\t*.zip*) \\\n+\t  unzip $(distdir).zip ;;\\\n+\tesac\n+\tchmod -R a-w $(distdir); chmod a+w $(distdir)\n+\tmkdir $(distdir)/_build\n+\tmkdir $(distdir)/_inst\n+\tchmod a-w $(distdir)\n+\ttest -d $(distdir)/_build || exit 0; \\\n+\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n+\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n+\t  && am__cwd=`pwd` \\\n+\t  && $(am__cd) $(distdir)/_build \\\n+\t  && ../configure --srcdir=.. --prefix=\"$$dc_install_base\" \\\n+\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n+\t        distuninstallcheck \\\n+\t  && chmod -R a-w \"$$dc_install_base\" \\\n+\t  && ({ \\\n+\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n+\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n+\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n+\t  && rm -rf \"$$dc_destdir\" \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n+\t  && rm -rf $(DIST_ARCHIVES) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \\\n+\t  && cd \"$$am__cwd\" \\\n+\t  || exit 1\n+\t$(am__remove_distdir)\n+\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n+\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n+\t  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'\n+distuninstallcheck:\n+\t@$(am__cd) '$(distuninstallcheck_dir)' \\\n+\t&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \\\n+\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n+\t        if test -n \"$(DESTDIR)\"; then \\\n+\t          echo \"  (check DESTDIR support)\"; \\\n+\t        fi ; \\\n+\t        $(distuninstallcheck_listfiles) ; \\\n+\t        exit 1; } >&2\n+distcleancheck: distclean\n+\t@if test '$(srcdir)' = . ; then \\\n+\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n+\t  exit 1 ; \\\n+\tfi\n+\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n+\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n+\t       $(distcleancheck_listfiles) ; \\\n+\t       exit 1; } >&2\n+check-am: all-am\n+check: check-recursive\n+all-am: Makefile $(INFO_DEPS) $(LTLIBRARIES) all-multi $(HEADERS) \\\n+\t\tconfig.h all-local\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-recursive\n+install-exec: install-exec-recursive\n+install-data: install-data-recursive\n+uninstall: uninstall-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-recursive\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\t-test -z \"$(CLEANFILES)\" || rm -f $(CLEANFILES)\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+\t-test -z \"$(MAINTAINERCLEANFILES)\" || rm -f $(MAINTAINERCLEANFILES)\n+clean: clean-multi clean-recursive\n+\n+clean-am: clean-aminfo clean-generic clean-libtool \\\n+\tclean-toolexeclibLTLIBRARIES mostlyclean-am\n+\n+distclean: distclean-multi distclean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-recursive\n+\n+dvi-am: $(DVIS)\n+\n+html: html-recursive\n+\n+html-am: $(HTMLS)\n+\n+info: info-recursive\n+\n+info-am: $(INFO_DEPS)\n+\n+install-data-am: install-info-am\n+\n+install-dvi: install-dvi-recursive\n+\n+install-dvi-am: $(DVIS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(dvidir)\" || $(MKDIR_P) \"$(DESTDIR)$(dvidir)\"\n+\t@list='$(DVIS)'; test -n \"$(dvidir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(dvidir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(dvidir)\" || exit $$?; \\\n+\tdone\n+install-exec-am: install-multi install-nodist_toolexeclibHEADERS \\\n+\tinstall-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-recursive\n+\n+install-html-am: $(HTMLS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(htmldir)\" || $(MKDIR_P) \"$(DESTDIR)$(htmldir)\"\n+\t@list='$(HTMLS)'; list2=; test -n \"$(htmldir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\" || test -d \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  $(am__strip_dir) \\\n+\t  if test -d \"$$d$$p\"; then \\\n+\t    echo \" $(MKDIR_P) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(MKDIR_P) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n+\t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n+\t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\" || exit $$?; \\\n+\t  else \\\n+\t    list2=\"$$list2 $$d$$p\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { echo \"$$list2\" | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(htmldir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(htmldir)\" || exit $$?; \\\n+\tdone; }\n+install-info: install-info-recursive\n+\n+install-info-am: $(INFO_DEPS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(infodir)\" || $(MKDIR_P) \"$(DESTDIR)$(infodir)\"\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`; \\\n+\tlist='$(INFO_DEPS)'; test -n \"$(infodir)\" || list=; \\\n+\tfor file in $$list; do \\\n+\t  case $$file in \\\n+\t    $(srcdir)/*) file=`echo \"$$file\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+\t  esac; \\\n+\t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  file_i=`echo \"$$file\" | sed 's|\\.info$$||;s|$$|.i|'`; \\\n+\t  for ifile in $$d/$$file $$d/$$file-[0-9] $$d/$$file-[0-9][0-9] \\\n+\t               $$d/$$file_i[0-9] $$d/$$file_i[0-9][0-9] ; do \\\n+\t    if test -f $$ifile; then \\\n+\t      echo \"$$ifile\"; \\\n+\t    else : ; fi; \\\n+\t  done; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(infodir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(infodir)\" || exit $$?; done\n+\t@$(POST_INSTALL)\n+\t@if (install-info --version && \\\n+\t     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \\\n+\t  list='$(INFO_DEPS)'; test -n \"$(infodir)\" || list=; \\\n+\t  for file in $$list; do \\\n+\t    relfile=`echo \"$$file\" | sed 's|^.*/||'`; \\\n+\t    echo \" install-info --info-dir='$(DESTDIR)$(infodir)' '$(DESTDIR)$(infodir)/$$relfile'\";\\\n+\t    install-info --info-dir=\"$(DESTDIR)$(infodir)\" \"$(DESTDIR)$(infodir)/$$relfile\" || :;\\\n+\t  done; \\\n+\telse : ; fi\n+install-man:\n+\n+install-pdf: install-pdf-recursive\n+\n+install-pdf-am: $(PDFS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(pdfdir)\" || $(MKDIR_P) \"$(DESTDIR)$(pdfdir)\"\n+\t@list='$(PDFS)'; test -n \"$(pdfdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(pdfdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(pdfdir)\" || exit $$?; done\n+install-ps: install-ps-recursive\n+\n+install-ps-am: $(PSS)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(psdir)\" || $(MKDIR_P) \"$(DESTDIR)$(psdir)\"\n+\t@list='$(PSS)'; test -n \"$(psdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(psdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(psdir)\" || exit $$?; done\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-aminfo \\\n+\tmaintainer-clean-generic\n+\n+mostlyclean: mostlyclean-multi mostlyclean-recursive\n+\n+mostlyclean-am: mostlyclean-aminfo mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool\n+\n+pdf: pdf-recursive\n+\n+pdf-am: $(PDFS)\n+\n+ps: ps-recursive\n+\n+ps-am: $(PSS)\n+\n+uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \\\n+\tuninstall-nodist_toolexeclibHEADERS uninstall-pdf-am \\\n+\tuninstall-ps-am uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n+\tclean-multi ctags-recursive distclean-multi install-am \\\n+\tinstall-multi install-strip maintainer-clean-multi \\\n+\tmostlyclean-multi tags-recursive\n+\n+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n+\tall all-am all-local all-multi am--refresh check check-am \\\n+\tclean clean-aminfo clean-generic clean-libtool clean-multi \\\n+\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive dist \\\n+\tdist-all dist-bzip2 dist-gzip dist-info dist-lzma dist-shar \\\n+\tdist-tarZ dist-xz dist-zip distcheck distclean \\\n+\tdistclean-compile distclean-generic distclean-hdr \\\n+\tdistclean-libtool distclean-multi distclean-tags \\\n+\tdistcleancheck distdir distuninstallcheck dvi dvi-am html \\\n+\thtml-am info info-am install install-am install-data \\\n+\tinstall-data-am install-dvi install-dvi-am install-exec \\\n+\tinstall-exec-am install-html install-html-am install-info \\\n+\tinstall-info-am install-man install-multi \\\n+\tinstall-nodist_toolexeclibHEADERS install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip \\\n+\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n+\tinstalldirs installdirs-am maintainer-clean \\\n+\tmaintainer-clean-aminfo maintainer-clean-generic \\\n+\tmaintainer-clean-multi mostlyclean mostlyclean-aminfo \\\n+\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n+\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n+\tuninstall uninstall-am uninstall-dvi-am uninstall-html-am \\\n+\tuninstall-info-am uninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-pdf-am uninstall-ps-am \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+\n+vpath % $(strip $(search_path))\n+@ARCH_X86_TRUE@x86_sse.lo : XCFLAGS += -msse\n+@ARCH_X86_TRUE@x86_avx.lo : XCFLAGS += -mavx\n+\n+all-local: $(STAMP_GENINSRC)\n+\n+stamp-geninsrc: libitm.info\n+\tcp -p $(top_builddir)/libitm.info $(srcdir)/libitm.info\n+\t@touch $@\n+\n+libitm.info: $(STAMP_BUILD_INFO)\n+\n+stamp-build-info: libitm.texi\n+\t$(MAKEINFO) $(AM_MAKEINFOFLAGS) $(MAKEINFOFLAGS) -I $(srcdir) -o libitm.info $(srcdir)/libitm.texi\n+\t@touch $@\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "da8c27407f4b38339253b84b4946cdedd6ca40e6", "filename": "libitm/aatree.cc", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Faatree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Faatree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Faatree.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,222 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+// Implements an AA tree (http://en.wikipedia.org/wiki/AA_tree) with an\n+// integer key, and data attached to the node via flexible array member.\n+\n+#include \"libitm_i.h\"\n+\n+namespace GTM HIDDEN {\n+\n+// The code for rebalancing the tree is greatly simplified by never\n+// having to check for null pointers.  Instead, leaf node links point\n+// to this node, NIL, which points to itself.\n+const aa_node_base aa_node_base::s_nil(0);\n+\n+\n+// Remove left horizontal links.  Swap the pointers of horizontal left links.\n+\n+aa_node_base *\n+aa_node_base::skew ()\n+{\n+  aa_node_base *l = this->link(L);\n+  if (this->m_level != 0 && l->m_level == this->m_level)\n+    {\n+      this->set_link(L, l->link(R));\n+      l->set_link(R, this);\n+      return l;\n+    }\n+  return this;\n+}\n+\n+\n+// Remove consecutive horizontal links.  Take the middle node,\n+// elevate it, and return it.\n+\n+aa_node_base *\n+aa_node_base::split ()\n+{\n+  aa_node_base *r = this->link(R);\n+  if (this->m_level != 0 && r->link(R)->m_level == this->m_level)\n+    {\n+      this->set_link(R, r->link(L));\n+      r->set_link(L, this);\n+      r->m_level += 1;\n+      return r;\n+    }\n+  return this;\n+}\n+\n+// Decrease the level of THIS to be one more than the level of its children.\n+\n+void\n+aa_node_base::decrease_level ()\n+{\n+  aa_node_base *l = this->link(L);\n+  aa_node_base *r = this->link(R);\n+  level_type llev = l->m_level;\n+  level_type rlev = r->m_level;\n+  level_type should_be = (llev < rlev ? llev : rlev) + 1;\n+\n+  if (should_be < this->m_level)\n+    {\n+      this->m_level = should_be;\n+      if (should_be < rlev)\n+\tr->m_level = should_be;\n+    }\n+}\n+\n+// Find and return the node in the tree with key K.\n+\n+template<typename KEY>\n+typename aa_tree_key<KEY>::node_ptr\n+aa_tree_key<KEY>::find(KEY k) const\n+{\n+  node_ptr t = m_tree;\n+  if (t != 0)\n+    do\n+      {\n+\tif (t->key == k)\n+\t  return t;\n+\tt = t->link(k > t->key);\n+      }\n+    while (!t->is_nil());\n+  return 0;\n+}\n+\n+// Insert N into T and rebalance.  Return the new balanced tree.\n+\n+template<typename KEY>\n+typename aa_tree_key<KEY>::node_ptr\n+aa_tree_key<KEY>::insert_1 (node_ptr t, node_ptr n)\n+{\n+  bool dir = n->key > t->key;\n+  node_ptr c = t->link(dir);\n+\n+  // Insert the node, recursively.\n+  if (c->is_nil())\n+    c = n;\n+  else\n+    c = insert_1 (c, n);\n+  t->set_link(dir, c);\n+\n+  // Rebalance the tree, as needed.\n+  t = t->skew();\n+  t = t->split();\n+\n+  return t;\n+}\n+\n+template<typename KEY>\n+void\n+aa_tree_key<KEY>::insert(node_ptr n)\n+{\n+  if (m_tree == 0)\n+    m_tree = n;\n+  else\n+    m_tree = insert_1 (m_tree, n);\n+}\n+\n+// Delete K from T and rebalance.  Return the new balanced tree.\n+\n+template<typename KEY>\n+typename aa_tree_key<KEY>::node_ptr\n+aa_tree_key<KEY>::erase_1 (node_ptr t, KEY k, node_ptr *pfree)\n+{\n+  node_ptr r;\n+  bool dir;\n+\n+  // If this is the node we're looking for, delete it.  Else recurse.\n+  if (k == t->key)\n+    {\n+      node_ptr l, sub, end;\n+\n+      l = t->link(node::L);\n+      r = t->link(node::R);\n+\n+      if (pfree)\n+\t*pfree = t;\n+\n+      // If this is a leaf node, simply remove the node.  Otherwise,\n+      // we have to find either a predecessor or a successor node to\n+      // replace this one.\n+      if (l->is_nil())\n+\t{\n+\t  if (r->is_nil())\n+\t    return r;\n+\t  sub = r, dir = node::L;\n+\t}\n+      else\n+\tsub = l, dir = node::R;\n+\n+      // Find the successor or predecessor.\n+      for (end = sub; !end->link(dir)->is_nil(); end = end->link(dir))\n+\tcontinue;\n+\n+      // Remove it (but don't free) from the subtree.\n+      sub = erase_1 (sub, end->key, 0);\n+\n+      // Replace T with the successor we just extracted.\n+      end->set_link(!dir, sub);\n+      t = end;\n+    }\n+  else\n+    {\n+      dir = k > t->key;\n+      t->set_link(dir, erase_1 (t->link(dir), k, pfree));\n+    }\n+\n+  // Rebalance the tree.\n+  t->decrease_level();\n+  t = t->skew();\n+  r = t->link(node::R)->skew();\n+  t->set_link(node::R, r);\n+  r->set_link(node::R, r->link(node::R)->skew());\n+  t = t->split ();\n+  t->set_link(node::R, t->link(node::R)->split());\n+\n+  return t;\n+}\n+\n+template<typename KEY>\n+typename aa_tree_key<KEY>::node_ptr\n+aa_tree_key<KEY>::erase (KEY k)\n+{\n+  node_ptr t = m_tree;\n+  if (t == 0)\n+    return 0;\n+\n+  node_ptr do_free = 0;\n+  t = erase_1 (t, k, &do_free);\n+  if (t->is_nil())\n+    t = 0;\n+  m_tree = t;\n+  return do_free;\n+}\n+\n+// Instantiate key classes.\n+\n+template class aa_tree_key<uintptr_t>;\n+\n+} // namespace GTM"}, {"sha": "a4de8da903d6e3c1d8ef26a75b360ada0bc3f06b", "filename": "libitm/aatree.h", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Faatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Faatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Faatree.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,215 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Implements an AA tree (http://en.wikipedia.org/wiki/AA_tree) with an\n+   integer key, and data attached to the node via flexible array member.  */\n+\n+#ifndef LIBITM_AATREE_H\n+#define LIBITM_AATREE_H 1\n+\n+namespace GTM HIDDEN {\n+\n+template<typename KEY> class aa_tree_key;\n+\n+class aa_node_base\n+{\n+ public:\n+  static const bool L = false;\n+  static const bool R = true;\n+\n+ private:\n+  typedef unsigned int level_type;\n+\n+  aa_node_base *m_link[2];\n+  level_type m_level;\n+\n+  static const aa_node_base s_nil;\n+\n+ public:\n+  aa_node_base(level_type l = 1)\n+    : m_link { const_cast<aa_node_base *>(&s_nil),\n+\t       const_cast<aa_node_base *>(&s_nil) },\n+      m_level(l)\n+  { }\n+\n+  bool is_nil() const { return this == &s_nil; }\n+\n+  aa_node_base * link(bool d) { return m_link[d]; }\n+  void set_link(bool d, aa_node_base *val) { m_link[d] = val; }\n+\n+  aa_node_base *skew();\n+  aa_node_base *split();\n+  void decrease_level();\n+\n+  static void *operator new (size_t s) { return xmalloc (s); }\n+  static void operator delete (void *p) { free (p); }\n+};\n+\n+template<typename KEY>\n+struct aa_node_key : public aa_node_base\n+{\n+  typedef aa_node_base base;\n+\n+  KEY key;\n+\n+  explicit aa_node_key(KEY k) : key(k) { }\n+\n+  aa_node_key * link(bool d)\n+  {\n+    return static_cast<aa_node_key *>(base::link(d));\n+  }\n+\n+  aa_node_key *skew() { return static_cast<aa_node_key *>(base::skew()); }\n+  aa_node_key *split() { return static_cast<aa_node_key *>(base::split()); }\n+};\n+\n+template<typename KEY, typename DATA>\n+struct aa_node : public aa_node_key<KEY>\n+{\n+  typedef aa_node_key<KEY> base;\n+\n+  DATA data;\n+\n+  explicit aa_node(KEY k) : base(k) { }\n+\n+  aa_node * link(bool d)\n+  {\n+    return static_cast<aa_node *>(base::link(d));\n+  }\n+};\n+\n+template<typename KEY>\n+class aa_tree_key\n+{\n+ public:\n+  typedef aa_node_key<KEY> node;\n+  typedef node *node_ptr;\n+\n+ protected:\n+  node_ptr m_tree;\n+\n+ protected:\n+  aa_tree_key() : m_tree(0) { }\n+\n+  node_ptr find(KEY k) const;\n+\n+  static node_ptr insert_1 (node_ptr t, node_ptr n);\n+  void insert(node_ptr n);\n+\n+  static node_ptr erase_1 (node_ptr t, KEY k, node_ptr *pfree);\n+  node_ptr erase(KEY k);\n+};\n+\n+extern template class aa_tree_key<uintptr_t>;\n+\n+template<typename KEY, typename DATA>\n+class aa_tree : public aa_tree_key<KEY>\n+{\n+ public:\n+  typedef aa_tree_key<KEY> base;\n+  typedef aa_node<KEY, DATA> node;\n+  typedef node *node_ptr;\n+\n+  typedef void (*trav_callback)(KEY, DATA *, void *);\n+\n+ private:\n+  static void clear_1 (node_ptr);\n+  static void traverse_1 (node_ptr, trav_callback, void *);\n+\n+ public:\n+  aa_tree() = default;\n+  ~aa_tree() { clear(); }\n+\n+  static void *operator new (size_t s, aa_tree<KEY, DATA>* p) { return p; }\n+\n+  DATA *find(KEY k) const\n+  {\n+    node_ptr n = static_cast<node_ptr>(base::find (k));\n+    return n ? &n->data : 0;\n+  }\n+\n+  DATA *insert(KEY k)\n+  {\n+    node_ptr n = new node(k);\n+    base::insert(n);\n+    return &n->data;\n+  }\n+\n+  void erase(KEY k)\n+  {\n+    node_ptr n = static_cast<node_ptr>(base::erase (k));\n+    delete n;\n+  }\n+\n+  node_ptr remove(KEY k, DATA** data)\n+  {\n+    node_ptr n = static_cast<node_ptr>(base::erase (k));\n+    *data = (n ? &n->data : 0);\n+    return n;\n+  }\n+\n+  void clear()\n+  {\n+    node_ptr n = static_cast<node_ptr>(this->m_tree);\n+    if (n)\n+      {\n+\tthis->m_tree = 0;\n+\tclear_1 (n);\n+      }\n+  }\n+\n+  void traverse (trav_callback cb, void *cb_data)\n+  {\n+    node_ptr t = static_cast<node_ptr>(this->m_tree);\n+    if (t != 0)\n+      traverse_1 (t, cb, cb_data);\n+  }\n+};\n+\n+\n+template<typename KEY, typename DATA>\n+void\n+aa_tree<KEY, DATA>::clear_1 (node_ptr t)\n+{\n+  if (t->is_nil())\n+    return;\n+  clear_1 (t->link(node::L));\n+  clear_1 (t->link(node::R));\n+  delete t;\n+}\n+\n+template<typename KEY, typename DATA>\n+void\n+aa_tree<KEY, DATA>::traverse_1 (node_ptr t, trav_callback cb, void *cb_data)\n+{\n+  if (t->is_nil())\n+    return;\n+  cb (t->key, &t->data, cb_data);\n+  traverse_1 (t->link(node::L), cb, cb_data);\n+  traverse_1 (t->link(node::R), cb, cb_data);\n+}\n+\n+} // namespace GTM\n+\n+#endif // LIBITM_AATREE_H"}, {"sha": "8fcde4b57ad24e5b86ae871afbafa4db3c2c8bb9", "filename": "libitm/acinclude.m4", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Facinclude.m4?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,343 @@\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libgfortran.\n+\n+dnl Check whether the target supports __sync_*_compare_and_swap.\n+AC_DEFUN([LIBITM_CHECK_SYNC_BUILTINS], [\n+  AC_CACHE_CHECK([whether the target supports __sync_*_compare_and_swap],\n+\t\t libitm_cv_have_sync_builtins, [\n+  AC_TRY_LINK([], [int foo, bar; bar = __sync_val_compare_and_swap(&foo, 0, 1);],\n+\t      libitm_cv_have_sync_builtins=yes, libitm_cv_have_sync_builtins=no)])\n+  if test $libitm_cv_have_sync_builtins = yes; then\n+    AC_DEFINE(HAVE_SYNC_BUILTINS, 1,\n+\t      [Define to 1 if the target supports __sync_*_compare_and_swap])\n+  fi])\n+\n+dnl Check whether the target supports 64-bit __sync_*_compare_and_swap.\n+AC_DEFUN([LIBITM_CHECK_64BIT_SYNC_BUILTINS], [\n+  AC_CACHE_CHECK([whether the target supports 64-bit __sync_*_compare_and_swap],\n+\t\t libitm_cv_have_64bit_sync_builtins, [\n+  AC_TRY_LINK([#include <stdint.h>],\n+    [uint64_t foo, bar;\n+     bar = __sync_val_compare_and_swap(&foo, 0, 1);],\n+    libitm_cv_have_64bit_sync_builtins=yes,\n+    libitm_cv_have_64bit_sync_builtins=no)])\n+    if test $libitm_cv_have_64bit_sync_builtins = yes; then\n+      AC_DEFINE(HAVE_64BIT_SYNC_BUILTINS, 1,\n+\t        [Define to 1 if the target supports 64-bit __sync_*_compare_and_swap])\n+  fi])\n+\n+dnl Check whether the target supports hidden visibility.\n+AC_DEFUN([LIBITM_CHECK_ATTRIBUTE_VISIBILITY], [\n+  AC_CACHE_CHECK([whether the target supports hidden visibility],\n+\t\t libitm_cv_have_attribute_visibility, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_COMPILE([void __attribute__((visibility(\"hidden\"))) foo(void) { }],\n+\t\t [], libitm_cv_have_attribute_visibility=yes,\n+\t\t libitm_cv_have_attribute_visibility=no)\n+  CFLAGS=\"$save_CFLAGS\"])\n+  if test $libitm_cv_have_attribute_visibility = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_VISIBILITY, 1,\n+      [Define to 1 if the target supports __attribute__((visibility(...))).])\n+  fi])\n+\n+dnl Check whether the target supports dllexport\n+AC_DEFUN([LIBITM_CHECK_ATTRIBUTE_DLLEXPORT], [\n+  AC_CACHE_CHECK([whether the target supports dllexport],\n+\t\t libitm_cv_have_attribute_dllexport, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_COMPILE([void __attribute__((dllexport)) foo(void) { }],\n+\t\t [], libitm_cv_have_attribute_dllexport=yes,\n+\t\t libitm_cv_have_attribute_dllexport=no)\n+  CFLAGS=\"$save_CFLAGS\"])\n+  if test $libitm_cv_have_attribute_dllexport = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_DLLEXPORT, 1,\n+      [Define to 1 if the target supports __attribute__((dllexport)).])\n+  fi])\n+\n+dnl Check whether the target supports symbol aliases.\n+AC_DEFUN([LIBITM_CHECK_ATTRIBUTE_ALIAS], [\n+  AC_CACHE_CHECK([whether the target supports symbol aliases],\n+\t\t libitm_cv_have_attribute_alias, [\n+  AC_TRY_LINK([\n+void foo(void) { }\n+extern void bar(void) __attribute__((alias(\"foo\")));],\n+    [bar();], libitm_cv_have_attribute_alias=yes, libitm_cv_have_attribute_alias=no)])\n+  if test $libitm_cv_have_attribute_alias = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_ALIAS, 1,\n+      [Define to 1 if the target supports __attribute__((alias(...))).])\n+  fi])\n+\n+dnl Check how size_t is mangled.\n+AC_DEFUN([LIBITM_CHECK_SIZE_T_MANGLING], [\n+  AC_CACHE_CHECK([how size_t is mangled],\n+                 libitm_cv_size_t_mangling, [\n+    AC_TRY_COMPILE([], [extern __SIZE_TYPE__ x; extern unsigned long x;],\n+\t           [libitm_cv_size_t_mangling=m], [\n+      AC_TRY_COMPILE([], [extern __SIZE_TYPE__ x; extern unsigned int x;],\n+\t             [libitm_cv_size_t_mangling=j], [\n+        AC_TRY_COMPILE([],\n+\t\t       [extern __SIZE_TYPE__ x; extern unsigned long long x;],\n+\t               [libitm_cv_size_t_mangling=y], [\n+          AC_TRY_COMPILE([],\n+\t\t\t [extern __SIZE_TYPE__ x; extern unsigned short x;],\n+\t\t\t [libitm_cv_size_t_mangling=t],\n+\t\t         [libitm_cv_size_t_mangling=x])\n+\t])\n+      ])\n+    ])\n+  ])\n+  if test $libitm_cv_size_t_mangling = x; then\n+    AC_MSG_ERROR([Unknown underlying type for size_t])\n+  fi\n+  AC_DEFINE_UNQUOTED(MANGLE_SIZE_T, [$libitm_cv_size_t_mangling],\n+    [Define to the letter to which size_t is mangled.])\n+])\n+\n+sinclude(../libtool.m4)\n+dnl The lines below arrange for aclocal not to bring an installed\n+dnl libtool.m4 into aclocal.m4, while still arranging for automake to\n+dnl add a definition of LIBTOOL to Makefile.in.\n+ifelse(,,,[AC_SUBST(LIBTOOL)\n+AC_DEFUN([AM_PROG_LIBTOOL])\n+AC_DEFUN([AC_LIBTOOL_DLOPEN])\n+AC_DEFUN([AC_PROG_LD])\n+])\n+\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libstdc++-v3.\n+\n+dnl\n+dnl LIBITM_ENABLE\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING)\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, permit a|b|c)\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, SHELL-CODE-HANDLER)\n+dnl\n+dnl See docs/html/17_intro/configury.html#enable for documentation.\n+dnl\n+m4_define([LIBITM_ENABLE],[dnl\n+m4_define([_g_switch],[--enable-$1])dnl\n+m4_define([_g_help],[AC_HELP_STRING(_g_switch$3,[$4 @<:@default=$2@:>@])])dnl\n+ AC_ARG_ENABLE($1,_g_help,\n+  m4_bmatch([$5],\n+   [^permit ],\n+     [[\n+      case \"$enableval\" in\n+       m4_bpatsubst([$5],[permit ])) ;;\n+       *) AC_MSG_ERROR(Unknown argument to enable/disable $1) ;;\n+          dnl Idea for future:  generate a URL pointing to\n+          dnl \"onlinedocs/configopts.html#whatever\"\n+      esac\n+     ]],\n+   [^$],\n+     [[\n+      case \"$enableval\" in\n+       yes|no) ;;\n+       *) AC_MSG_ERROR(Argument to enable/disable $1 must be yes or no) ;;\n+      esac\n+     ]],\n+   [[$5]]),\n+  [enable_]m4_bpatsubst([$1],-,_)[=][$2])\n+m4_undefine([_g_switch])dnl\n+m4_undefine([_g_help])dnl\n+])\n+\n+\n+dnl\n+dnl If GNU ld is in use, check to see if tricky linker opts can be used.  If\n+dnl the native linker is in use, all variables will be defined to something\n+dnl safe (like an empty string).\n+dnl\n+dnl Defines:\n+dnl  SECTION_LDFLAGS='-Wl,--gc-sections' if possible\n+dnl  OPT_LDFLAGS='-Wl,-O1' if possible\n+dnl  LD (as a side effect of testing)\n+dnl Sets:\n+dnl  with_gnu_ld\n+dnl  libitm_gnu_ld_version (possibly)\n+dnl\n+dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will\n+dnl set libitm_gnu_ld_version to 12345.  Zeros cause problems.\n+dnl\n+AC_DEFUN([LIBITM_CHECK_LINKER_FEATURES], [\n+  # If we're not using GNU ld, then there's no point in even trying these\n+  # tests.  Check for that first.  We should have already tested for gld\n+  # by now (in libtool), but require it now just to be safe...\n+  test -z \"$SECTION_LDFLAGS\" && SECTION_LDFLAGS=''\n+  test -z \"$OPT_LDFLAGS\" && OPT_LDFLAGS=''\n+  AC_REQUIRE([AC_PROG_LD])\n+  AC_REQUIRE([AC_PROG_AWK])\n+\n+  # The name set by libtool depends on the version of libtool.  Shame on us\n+  # for depending on an impl detail, but c'est la vie.  Older versions used\n+  # ac_cv_prog_gnu_ld, but now it's lt_cv_prog_gnu_ld, and is copied back on\n+  # top of with_gnu_ld (which is also set by --with-gnu-ld, so that actually\n+  # makes sense).  We'll test with_gnu_ld everywhere else, so if that isn't\n+  # set (hence we're using an older libtool), then set it.\n+  if test x${with_gnu_ld+set} != xset; then\n+    if test x${ac_cv_prog_gnu_ld+set} != xset; then\n+      # We got through \"ac_require(ac_prog_ld)\" and still not set?  Huh?\n+      with_gnu_ld=no\n+    else\n+      with_gnu_ld=$ac_cv_prog_gnu_ld\n+    fi\n+  fi\n+\n+  # Start by getting the version number.  I think the libtool test already\n+  # does some of this, but throws away the result.\n+  changequote(,)\n+  ldver=`$LD --version 2>/dev/null | head -1 | \\\n+         sed -e 's/GNU ld \\(version \\)\\{0,1\\}\\(([^)]*) \\)\\{0,1\\}\\([0-9.][0-9.]*\\).*/\\3/'`\n+  changequote([,])\n+  libitm_gnu_ld_version=`echo $ldver | \\\n+         $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`\n+\n+  # Set --gc-sections.\n+  if test \"$with_gnu_ld\" = \"notbroken\"; then\n+    # GNU ld it is!  Joy and bunny rabbits!\n+\n+    # All these tests are for C++; save the language and the compiler flags.\n+    # Need to do this so that g++ won't try to link in libstdc++\n+    ac_test_CFLAGS=\"${CFLAGS+set}\"\n+    ac_save_CFLAGS=\"$CFLAGS\"\n+    CFLAGS='-x c++  -Wl,--gc-sections'\n+\n+    # Check for -Wl,--gc-sections\n+    # XXX This test is broken at the moment, as symbols required for linking\n+    # are now in libsupc++ (not built yet).  In addition, this test has\n+    # cored on solaris in the past.  In addition, --gc-sections doesn't\n+    # really work at the moment (keeps on discarding used sections, first\n+    # .eh_frame and now some of the glibc sections for iconv).\n+    # Bzzzzt.  Thanks for playing, maybe next time.\n+    AC_MSG_CHECKING([for ld that supports -Wl,--gc-sections])\n+    AC_TRY_RUN([\n+     int main(void)\n+     {\n+       try { throw 1; }\n+       catch (...) { };\n+       return 0;\n+     }\n+    ], [ac_sectionLDflags=yes],[ac_sectionLDflags=no], [ac_sectionLDflags=yes])\n+    if test \"$ac_test_CFLAGS\" = set; then\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    else\n+      # this is the suspicious part\n+      CFLAGS=''\n+    fi\n+    if test \"$ac_sectionLDflags\" = \"yes\"; then\n+      SECTION_LDFLAGS=\"-Wl,--gc-sections $SECTION_LDFLAGS\"\n+    fi\n+    AC_MSG_RESULT($ac_sectionLDflags)\n+  fi\n+\n+  # Set linker optimization flags.\n+  if test x\"$with_gnu_ld\" = x\"yes\"; then\n+    OPT_LDFLAGS=\"-Wl,-O1 $OPT_LDFLAGS\"\n+  fi\n+\n+  AC_SUBST(SECTION_LDFLAGS)\n+  AC_SUBST(OPT_LDFLAGS)\n+])\n+\n+\n+dnl\n+dnl Add version tags to symbols in shared library (or not), additionally\n+dnl marking other symbols as private/local (or not).\n+dnl\n+dnl --enable-symvers=style adds a version script to the linker call when\n+dnl       creating the shared library.  The choice of version script is\n+dnl       controlled by 'style'.\n+dnl --disable-symvers does not.\n+dnl  +  Usage:  LIBITM_ENABLE_SYMVERS[(DEFAULT)]\n+dnl       Where DEFAULT is either 'yes' or 'no'.  Passing `yes' tries to\n+dnl       choose a default style based on linker characteristics.  Passing\n+dnl       'no' disables versioning.\n+dnl\n+AC_DEFUN([LIBITM_ENABLE_SYMVERS], [\n+\n+LIBITM_ENABLE(symvers,yes,[=STYLE],\n+  [enables symbol versioning of the shared library],\n+  [permit yes|no|gnu])\n+\n+# If we never went through the LIBITM_CHECK_LINKER_FEATURES macro, then we\n+# don't know enough about $LD to do tricks...\n+AC_REQUIRE([LIBITM_CHECK_LINKER_FEATURES])\n+# FIXME  The following test is too strict, in theory.\n+if test $enable_shared = no ||\n+        test \"x$LD\" = x ||\n+        test x$libitm_gnu_ld_version = x; then\n+  enable_symvers=no\n+fi\n+\n+# Check to see if libgcc_s exists, indicating that shared libgcc is possible.\n+if test $enable_symvers != no; then\n+  AC_MSG_CHECKING([for shared libgcc])\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=' -lgcc_s'\n+  AC_TRY_LINK(, [return 0;], libitm_shared_libgcc=yes, libitm_shared_libgcc=no)\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+  if test $libitm_shared_libgcc = no; then\n+    cat > conftest.c <<EOF\n+int main (void) { return 0; }\n+EOF\n+changequote(,)dnl\n+    libitm_libgcc_s_suffix=`${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \\\n+\t\t\t     -shared -shared-libgcc -o conftest.so \\\n+\t\t\t     conftest.c -v 2>&1 >/dev/null \\\n+\t\t\t     | sed -n 's/^.* -lgcc_s\\([^ ]*\\) .*$/\\1/p'`\n+changequote([,])dnl\n+    rm -f conftest.c conftest.so\n+    if test x${libitm_libgcc_s_suffix+set} = xset; then\n+      CFLAGS=\" -lgcc_s$libitm_libgcc_s_suffix\"\n+      AC_TRY_LINK(, [return 0;], libitm_shared_libgcc=yes)\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    fi\n+  fi\n+  AC_MSG_RESULT($libitm_shared_libgcc)\n+fi\n+\n+# For GNU ld, we need at least this version.  The format is described in\n+# LIBITM_CHECK_LINKER_FEATURES above.\n+libitm_min_gnu_ld_version=21400\n+# XXXXXXXXXXX libitm_gnu_ld_version=21390\n+\n+# Check to see if unspecified \"yes\" value can win, given results above.\n+# Change \"yes\" into either \"no\" or a style name.\n+if test $enable_symvers = yes; then\n+  if test $with_gnu_ld = yes &&\n+     test $libitm_shared_libgcc = yes;\n+  then\n+    if test $libitm_gnu_ld_version -ge $libitm_min_gnu_ld_version ; then\n+      enable_symvers=gnu\n+    else\n+      # The right tools, the right setup, but too old.  Fallbacks?\n+      AC_MSG_WARN(=== Linker version $libitm_gnu_ld_version is too old for)\n+      AC_MSG_WARN(=== full symbol versioning support in this release of GCC.)\n+      AC_MSG_WARN(=== You would need to upgrade your binutils to version)\n+      AC_MSG_WARN(=== $libitm_min_gnu_ld_version or later and rebuild GCC.)\n+      if test $libitm_gnu_ld_version -ge 21200 ; then\n+        # Globbing fix is present, proper block support is not.\n+        dnl AC_MSG_WARN([=== Dude, you are soooo close.  Maybe we can fake it.])\n+        dnl enable_symvers=???\n+        AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+        enable_symvers=no\n+      else\n+        # 2.11 or older.\n+        AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+        enable_symvers=no\n+      fi\n+    fi\n+  else\n+    # just fail for now\n+    AC_MSG_WARN([=== You have requested some kind of symbol versioning, but])\n+    AC_MSG_WARN([=== either you are not using a supported linker, or you are])\n+    AC_MSG_WARN([=== not building a shared libgcc_s (which is required).])\n+    AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+    enable_symvers=no\n+  fi\n+fi\n+\n+AM_CONDITIONAL(LIBITM_BUILD_VERSIONED_SHLIB, test $enable_symvers != no)\n+AC_MSG_NOTICE(versioning on shared library symbols is $enable_symvers)\n+])"}, {"sha": "6dcccdfae16ae4b52b33ea9e9d3fa6e09afd35df", "filename": "libitm/aclocal.m4", "status": "added", "additions": 1007, "deletions": 0, "changes": 1007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Faclocal.m4?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,1007 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# Figure out how to run the assembler.                      -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_PROG_AS\n+# ----------\n+AC_DEFUN([AM_PROG_AS],\n+[# By default we simply use the C compiler to build assembly code.\n+AC_REQUIRE([AC_PROG_CC])\n+test \"${CCAS+set}\" = set || CCAS=$CC\n+test \"${CCASFLAGS+set}\" = set || CCASFLAGS=$CFLAGS\n+AC_ARG_VAR([CCAS],      [assembler compiler command (defaults to CC)])\n+AC_ARG_VAR([CCASFLAGS], [assembler compiler flags (defaults to CFLAGS)])\n+_AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl\n+])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless `enable' is passed literally.\n+# For symmetry, `disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n+\t\t\t  (and sometimes confusing) to the casual installer],\n+      [USE_MAINTAINER_MODE=$enableval],\n+      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/acx.m4])\n+m4_include([../config/depstand.m4])\n+m4_include([../config/enable.m4])\n+m4_include([../config/futex.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/mmap.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../config/stdint.m4])\n+m4_include([../config/tls.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])\n+m4_include([acinclude.m4])"}, {"sha": "ec36269e6c883e76a43d4532157a33a336ee609f", "filename": "libitm/alloc.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Falloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Falloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Falloc.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,129 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+\n+namespace GTM HIDDEN {\n+\n+void\n+gtm_thread::record_allocation (void *ptr, void (*free_fn)(void *))\n+{\n+  uintptr_t iptr = (uintptr_t) ptr;\n+\n+  gtm_alloc_action *a = this->alloc_actions.find(iptr);\n+  if (a == 0)\n+    a = this->alloc_actions.insert(iptr);\n+\n+  a->free_fn = free_fn;\n+  a->allocated = true;\n+}\n+\n+void\n+gtm_thread::forget_allocation (void *ptr, void (*free_fn)(void *))\n+{\n+  uintptr_t iptr = (uintptr_t) ptr;\n+\n+  gtm_alloc_action *a = this->alloc_actions.find(iptr);\n+  if (a == 0)\n+    a = this->alloc_actions.insert(iptr);\n+\n+  a->free_fn = free_fn;\n+  a->allocated = false;\n+}\n+\n+namespace {\n+struct commit_cb_data {\n+  aa_tree<uintptr_t, gtm_alloc_action>* parent;\n+  bool revert_p;\n+};\n+}\n+\n+static void\n+commit_allocations_2 (uintptr_t key, gtm_alloc_action *a, void *data)\n+{\n+  void *ptr = (void *)key;\n+  commit_cb_data *cb_data = static_cast<commit_cb_data *>(data);\n+\n+  if (cb_data->revert_p)\n+    {\n+      // Roll back nested allocations.\n+      if (a->allocated)\n+\ta->free_fn (ptr);\n+    }\n+  else\n+    {\n+      if (a->allocated)\n+\t{\n+\t  // Add nested allocations to parent transaction.\n+\t  gtm_alloc_action* a_parent = cb_data->parent->insert(key);\n+\t  *a_parent = *a;\n+\t}\n+      else\n+\t{\n+\t  // ??? We could eliminate a parent allocation that matches this\n+\t  // memory release, if we had support for removing all accesses\n+\t  // to this allocation from the transaction's undo and redo logs\n+\t  // (otherwise, the parent transaction's undo or redo might write to\n+\t  // data that is already shared again because of calling free()).\n+\t  // We don't have this support currently, and the benefit of this\n+\t  // optimization is unknown, so just add it to the parent.\n+\t  gtm_alloc_action* a_parent;\n+\t  a_parent = cb_data->parent->insert(key);\n+\t  *a_parent = *a;\n+\t}\n+    }\n+}\n+\n+static void\n+commit_allocations_1 (uintptr_t key, gtm_alloc_action *a, void *cb_data)\n+{\n+  void *ptr = (void *)key;\n+  uintptr_t revert_p = (uintptr_t) cb_data;\n+\n+  if (a->allocated == revert_p)\n+    a->free_fn (ptr);\n+}\n+\n+/* Permanently commit allocated memory during transaction.\n+\n+   REVERT_P is true if instead of committing the allocations, we want\n+   to roll them back (and vice versa).  */\n+void\n+gtm_thread::commit_allocations (bool revert_p,\n+    aa_tree<uintptr_t, gtm_alloc_action>* parent)\n+{\n+  if (parent)\n+    {\n+      commit_cb_data cb_data;\n+      cb_data.parent = parent;\n+      cb_data.revert_p = revert_p;\n+      this->alloc_actions.traverse (commit_allocations_2, &cb_data);\n+    }\n+  else\n+    this->alloc_actions.traverse (commit_allocations_1,\n+\t\t\t\t  (void *)(uintptr_t)revert_p);\n+  this->alloc_actions.clear ();\n+}\n+\n+} // namespace GTM"}, {"sha": "c0cf263a05392ebb4f1efd297aee6597a8cc1b26", "filename": "libitm/alloc_c.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Falloc_c.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Falloc_c.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Falloc_c.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,72 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+\n+\n+using namespace GTM;\n+\n+extern \"C\" {\n+\n+/* Wrap: malloc (size_t sz)  */\n+void *\n+_ITM_malloc (size_t sz)\n+{\n+  void *r = malloc (sz);\n+  if (r)\n+    gtm_thr()->record_allocation (r, free);\n+  return r;\n+}\n+\n+/* Wrap: calloc (size_t nm, size_t sz)  */\n+void *\n+_ITM_calloc (size_t nm, size_t sz)\n+{\n+  void *r = calloc (nm, sz);\n+  if (r)\n+    gtm_thr()->record_allocation (r, free);\n+  return r;\n+}\n+\n+/* Wrap:  free (void *ptr)  */\n+void\n+_ITM_free (void *ptr)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, free);\n+}\n+\n+/* Forget any internal references to PTR.  */\n+\n+__attribute__((transaction_pure))\n+void ITM_REGPARM\n+_ITM_dropReferences (void *ptr, size_t len)\n+{\n+  // The semantics of _ITM_dropReferences are not sufficiently defined in the\n+  // ABI specification, so it does not make sense to support it right now. See\n+  // the libitm documentation for details.\n+  GTM_fatal(\"_ITM_dropReferences is not supported\");\n+}\n+\n+} // extern \"C\""}, {"sha": "59d8b7374eb29d0ec4f76aea923f37c6955e9817", "filename": "libitm/alloc_cpp.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Falloc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Falloc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Falloc_cpp.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,152 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+\n+using namespace GTM;\n+\n+/* Mangling the names by hand requires that we know how size_t is handled.\n+   We've gotten the letter from autoconf, now substitute it into the names.\n+   Everything below uses X as a placeholder for clarity.  */\n+\n+#define S1(x,y)\t\t\tx##y\n+#define S(x,y)\t\t\tS1(x,y)\n+\n+#define _ZnwX\t\t\tS(_Znw,MANGLE_SIZE_T)\n+#define _ZnaX\t\t\tS(_Zna,MANGLE_SIZE_T)\n+#define _ZnwXRKSt9nothrow_t\tS(S(_Znw,MANGLE_SIZE_T),RKSt9nothrow_t)\n+#define _ZnaXRKSt9nothrow_t\tS(S(_Zna,MANGLE_SIZE_T),RKSt9nothrow_t)\n+\n+#define _ZGTtnwX\t\tS(_ZGTtnw,MANGLE_SIZE_T)\n+#define _ZGTtnaX\t\tS(_ZGTtna,MANGLE_SIZE_T)\n+#define _ZGTtnwXRKSt9nothrow_t\tS(S(_ZGTtnw,MANGLE_SIZE_T),RKSt9nothrow_t)\n+#define _ZGTtnaXRKSt9nothrow_t\tS(S(_ZGTtna,MANGLE_SIZE_T),RKSt9nothrow_t)\n+\n+/* Everything from libstdc++ is weak, to avoid requiring that library\n+   to be linked into plain C applications using libitm.so.  */\n+\n+extern \"C\" {\n+\n+extern void *_ZnwX (size_t) __attribute__((weak));\n+extern void _ZdlPv (void *) __attribute__((weak));\n+extern void *_ZnaX (size_t) __attribute__((weak));\n+extern void _ZdaPv (void *) __attribute__((weak));\n+\n+typedef const struct nothrow_t { } *c_nothrow_p;\n+\n+extern void *_ZnwXRKSt9nothrow_t (size_t, c_nothrow_p) __attribute__((weak));\n+extern void _ZdlPvRKSt9nothrow_t (void *, c_nothrow_p) __attribute__((weak));\n+extern void *_ZnaXRKSt9nothrow_t (size_t, c_nothrow_p) __attribute__((weak));\n+extern void _ZdaPvRKSt9nothrow_t (void *, c_nothrow_p) __attribute__((weak));\n+\n+/* Wrap the delete nothrow symbols for usage with a single argument.\n+   Perhaps should have a configure type check for this, because the\n+   std::nothrow_t reference argument is unused (empty class), and most\n+   targets don't actually need that second argument.  So we _could_\n+   invoke these functions as if they were a single argument free.  */\n+static void\n+del_opnt (void *ptr)\n+{\n+  _ZdlPvRKSt9nothrow_t (ptr, NULL);\n+}\n+\n+static void\n+del_opvnt (void *ptr)\n+{\n+  _ZdaPvRKSt9nothrow_t (ptr, NULL);\n+}\n+\n+/* Wrap: operator new (std::size_t sz)  */\n+void *\n+_ZGTtnwX (size_t sz)\n+{\n+  void *r = _ZnwX (sz);\n+  if (r)\n+    gtm_thr()->record_allocation (r, _ZdlPv);\n+  return r;\n+}\n+\n+/* Wrap: operator new (std::size_t sz, const std::nothrow_t&)  */\n+void *\n+_ZGTtnwXRKSt9nothrow_t (size_t sz, c_nothrow_p nt)\n+{\n+  void *r = _ZnwXRKSt9nothrow_t (sz, nt);\n+  if (r)\n+    gtm_thr()->record_allocation (r, del_opnt);\n+  return r;\n+}\n+\n+/* Wrap: operator new[] (std::size_t sz)  */\n+void *\n+_ZGTtnaX (size_t sz)\n+{\n+  void *r = _ZnaX (sz);\n+  if (r)\n+    gtm_thr()->record_allocation (r, _ZdaPv);\n+  return r;\n+}\n+\n+/* Wrap: operator new[] (std::size_t sz, const std::nothrow_t& nothrow)  */\n+void *\n+_ZGTtnaXRKSt9nothrow_t (size_t sz, c_nothrow_p nt)\n+{\n+  void *r = _ZnaXRKSt9nothrow_t (sz, nt);\n+  if (r)\n+    gtm_thr()->record_allocation (r, del_opvnt);\n+  return r;\n+}\n+\n+/* Wrap: operator delete(void* ptr)  */\n+void\n+_ZGTtdlPv (void *ptr)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, _ZdlPv);\n+}\n+\n+/* Wrap: operator delete (void *ptr, const std::nothrow_t&)  */\n+void\n+_ZGTtdlPvRKSt9nothrow_t (void *ptr, c_nothrow_p nt UNUSED)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, del_opnt);\n+}\n+\n+/* Wrap: operator delete[] (void *ptr)  */\n+void\n+_ZGTtdaPv (void *ptr)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, _ZdaPv);\n+}\n+\n+/* Wrap: operator delete[] (void *ptr, const std::nothrow_t&)  */\n+void\n+_ZGTtdaPvRKSt9nothrow_t (void *ptr, c_nothrow_p nt UNUSED)\n+{\n+  if (ptr)\n+    gtm_thr()->forget_allocation (ptr, del_opvnt);\n+}\n+\n+} // extern \"C\""}, {"sha": "a536d0f862f8b54618c9d865d3a1e2e976548302", "filename": "libitm/barrier.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fbarrier.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fbarrier.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbarrier.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,44 @@\n+/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+\n+using namespace GTM;\n+\n+bool abi_dispatch::memmove_overlap_check(void *dst, const void *src,\n+    size_t size, ls_modifier dst_mod, ls_modifier src_mod)\n+{\n+  if (dst_mod == NONTXNAL || src_mod == NONTXNAL)\n+    {\n+      if (((uintptr_t)dst <= (uintptr_t)src ?\n+\t  (uintptr_t)dst + size > (uintptr_t)src :\n+\t  (uintptr_t)src + size > (uintptr_t)dst))\n+\tGTM::GTM_fatal(\"_ITM_memmove overlapping and t/nt is not allowed\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+CREATE_DISPATCH_FUNCTIONS(GTM::abi_disp()->, )\n+"}, {"sha": "dcf101356e673b208f302e03b87416e94483be00", "filename": "libitm/barrier.tpl", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fbarrier.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fbarrier.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbarrier.tpl?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,170 @@\n+/* -*- c++ -*- */\n+/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"unaligned.h\"\n+\n+namespace {\n+\n+using namespace GTM;\n+\n+template<typename T>\n+T do_read (const T *ptr, abi_dispatch::lock_type lock)\n+{\n+  //\n+  // Find the cacheline that holds the current value of *PTR.\n+  //\n+  abi_dispatch *disp = abi_disp();\n+  uintptr_t iptr = reinterpret_cast<uintptr_t>(ptr);\n+  // Normalize PTR by chopping off the bottom bits so we can search\n+  // for PTR in the cacheline hash.\n+  uintptr_t iline = iptr & -CACHELINE_SIZE;\n+  // The position in the resulting cacheline where *PTR is actually stored.\n+  uintptr_t iofs = iptr & (CACHELINE_SIZE - 1);\n+  const gtm_cacheline *pline = reinterpret_cast<const gtm_cacheline *>(iline);\n+  // Search for the actual cacheline that holds the current value of *PTR.\n+  const gtm_cacheline *line = disp->read_lock(pline, lock);\n+\n+  // Point to the position in the cacheline where *PTR is stored.\n+  ptr = reinterpret_cast<const T *>(&line->b[iofs]);\n+\n+  // Straight up loads, because we're either aligned, or we don't care\n+  // about alignment.\n+  //\n+  // If we require alignment on type T, do a straight load if we're\n+  // aligned.  Otherwise do a straight load IFF the load fits entirely\n+  // in this cacheline.  That is, it won't span multiple cachelines.\n+  if (__builtin_expect (strict_alignment<T>::value\n+\t\t\t? (iofs & (sizeof (T) - 1)) == 0\n+\t\t\t: iofs + sizeof(T) <= CACHELINE_SIZE, 1))\n+    {\n+    do_normal_load:\n+      return *ptr;\n+    }\n+  // If alignment on T is necessary, but we're unaligned, yet we fit\n+  // entirely in this cacheline... do the unaligned load dance.\n+  else if (__builtin_expect (strict_alignment<T>::value\n+\t\t\t     && iofs + sizeof(T) <= CACHELINE_SIZE, 1))\n+    {\n+    do_unaligned_load:\n+      return unaligned_load<T>(ptr);\n+    }\n+  // Otherwise, this load will span multiple cachelines.\n+  else\n+    {\n+      // Get the following cacheline for the rest of the data.\n+      const gtm_cacheline *line2 = disp->read_lock(pline + 1, lock);\n+\n+      // If the two cachelines are adjacent, just load it all in one\n+      // swoop.\n+      if (line2 == line + 1)\n+\t{\n+\t  if (!strict_alignment<T>::value)\n+\t    goto do_normal_load;\n+\t  else\n+\t    goto do_unaligned_load;\n+\t}\n+      else\n+\t{\n+\t  // Otherwise, ask the backend to load from two different\n+\t  // cachelines.\n+\t  return unaligned_load2<T>(line, line2, iofs);\n+\t}\n+    }\n+}\n+\n+template<typename T>\n+void do_write (T *ptr, T val, abi_dispatch::lock_type lock)\n+{\n+  // Note: See comments for do_read() above for hints on this\n+  // function.  Ideally we should abstract out a lot out of these two\n+  // functions, and avoid all this duplication.\n+\n+  abi_dispatch *disp = abi_disp();\n+  uintptr_t iptr = reinterpret_cast<uintptr_t>(ptr);\n+  uintptr_t iline = iptr & -CACHELINE_SIZE;\n+  uintptr_t iofs = iptr & (CACHELINE_SIZE - 1);\n+  gtm_cacheline *pline = reinterpret_cast<gtm_cacheline *>(iline);\n+  gtm_cacheline_mask m = ((gtm_cacheline_mask)2 << (sizeof(T) - 1)) - 1;\n+  abi_dispatch::mask_pair pair = disp->write_lock(pline, lock);\n+\n+  ptr = reinterpret_cast<T *>(&pair.line->b[iofs]);\n+\n+  if (__builtin_expect (strict_alignment<T>::value\n+\t\t\t? (iofs & (sizeof (val) - 1)) == 0\n+\t\t\t: iofs + sizeof(val) <= CACHELINE_SIZE, 1))\n+    {\n+      *pair.mask |= m << iofs;\n+    do_normal_store:\n+      *ptr = val;\n+    }\n+  else if (__builtin_expect (strict_alignment<T>::value\n+\t\t\t     && iofs + sizeof(val) <= CACHELINE_SIZE, 1))\n+    {\n+      *pair.mask |= m << iofs;\n+    do_unaligned_store:\n+      unaligned_store<T>(ptr, val);\n+    }\n+  else\n+    {\n+      *pair.mask |= m << iofs;\n+      abi_dispatch::mask_pair pair2 = disp->write_lock(pline + 1, lock);\n+\n+      uintptr_t ileft = CACHELINE_SIZE - iofs;\n+      *pair2.mask |= m >> ileft;\n+\n+      if (pair2.line == pair.line + 1)\n+\t{\n+\t  if (!strict_alignment<T>::value)\n+\t    goto do_normal_store;\n+\t  else\n+\t    goto do_unaligned_store;\n+\t}\n+      else\n+\tunaligned_store2<T>(pair.line, pair2.line, iofs, val);\n+    }\n+}\n+\n+} /* anonymous namespace */\n+\n+#define ITM_READ(T, LOCK)\t\t\t\t\t\t\\\n+  _ITM_TYPE_##T ITM_REGPARM _ITM_##LOCK##T (const _ITM_TYPE_##T *ptr)\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    return do_read (ptr, abi_dispatch::LOCK);\t\t\t\t\\\n+  }\n+\n+#define ITM_WRITE(T, LOCK)\t\t\t\t\t\t\\\n+  void ITM_REGPARM _ITM_##LOCK##T (_ITM_TYPE_##T *ptr, _ITM_TYPE_##T val) \\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    do_write (ptr, val, abi_dispatch::LOCK);\t\t\t\t\\\n+  }\n+\n+#define ITM_BARRIERS(T)\t\t\\\n+  ITM_READ(T, R)\t\t\\\n+  ITM_READ(T, RaR)\t\t\\\n+  ITM_READ(T, RaW)\t\t\\\n+  ITM_READ(T, RfW)\t\t\\\n+  ITM_WRITE(T, W)\t\t\\\n+  ITM_WRITE(T, WaR)\t\t\\\n+  ITM_WRITE(T, WaW)"}, {"sha": "a26697567a3e68f5f9a6b241bbf734d6f27d5360", "filename": "libitm/beginend.cc", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fbeginend.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fbeginend.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fbeginend.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,536 @@\n+/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+#include <pthread.h>\n+\n+\n+using namespace GTM;\n+\n+#if !defined(HAVE_ARCH_GTM_THREAD) || !defined(HAVE_ARCH_GTM_THREAD_DISP)\n+extern __thread gtm_thread_tls _gtm_thr_tls;\n+#endif\n+\n+gtm_rwlock GTM::gtm_thread::serial_lock;\n+gtm_thread *GTM::gtm_thread::list_of_threads = 0;\n+unsigned GTM::gtm_thread::number_of_threads = 0;\n+\n+gtm_stmlock GTM::gtm_stmlock_array[LOCK_ARRAY_SIZE];\n+gtm_version GTM::gtm_clock;\n+\n+/* ??? Move elsewhere when we figure out library initialization.  */\n+uint64_t GTM::gtm_spin_count_var = 1000;\n+\n+static _ITM_transactionId_t global_tid;\n+\n+// Provides a on-thread-exit callback used to release per-thread data.\n+static pthread_key_t thr_release_key;\n+static pthread_once_t thr_release_once = PTHREAD_ONCE_INIT;\n+\n+\n+/* Allocate a transaction structure.  */\n+void *\n+GTM::gtm_thread::operator new (size_t s)\n+{\n+  void *tx;\n+\n+  assert(s == sizeof(gtm_thread));\n+\n+  tx = xmalloc (sizeof (gtm_thread), true);\n+  memset (tx, 0, sizeof (gtm_thread));\n+\n+  return tx;\n+}\n+\n+/* Free the given transaction. Raises an error if the transaction is still\n+   in use.  */\n+void\n+GTM::gtm_thread::operator delete(void *tx)\n+{\n+  free(tx);\n+}\n+\n+static void\n+thread_exit_handler(void *)\n+{\n+  gtm_thread *thr = gtm_thr();\n+  if (thr)\n+    delete thr;\n+  set_gtm_thr(0);\n+}\n+\n+static void\n+thread_exit_init()\n+{\n+  if (pthread_key_create(&thr_release_key, thread_exit_handler))\n+    GTM_fatal(\"Creating thread release TLS key failed.\");\n+}\n+\n+\n+GTM::gtm_thread::~gtm_thread()\n+{\n+  if (nesting > 0)\n+    GTM_fatal(\"Thread exit while a transaction is still active.\");\n+\n+  // Deregister this transaction.\n+  serial_lock.write_lock ();\n+  gtm_thread **prev = &list_of_threads;\n+  for (; *prev; prev = &(*prev)->next_thread)\n+    {\n+      if (*prev == this)\n+\t{\n+\t  *prev = (*prev)->next_thread;\n+\t  break;\n+\t}\n+    }\n+  number_of_threads--;\n+  number_of_threads_changed(number_of_threads + 1, number_of_threads);\n+  serial_lock.write_unlock ();\n+}\n+\n+GTM::gtm_thread::gtm_thread ()\n+{\n+  // This object's memory has been set to zero by operator new, so no need\n+  // to initialize any of the other primitive-type members that do not have\n+  // constructors.\n+  shared_state = ~(typeof shared_state)0;\n+\n+  // Register this transaction with the list of all threads' transactions.\n+  serial_lock.write_lock ();\n+  next_thread = list_of_threads;\n+  list_of_threads = this;\n+  number_of_threads++;\n+  number_of_threads_changed(number_of_threads - 1, number_of_threads);\n+  serial_lock.write_unlock ();\n+\n+  if (pthread_once(&thr_release_once, thread_exit_init))\n+    GTM_fatal(\"Initializing thread release TLS key failed.\");\n+  // Any non-null value is sufficient to trigger destruction of this\n+  // transaction when the current thread terminates.\n+  if (pthread_setspecific(thr_release_key, this))\n+    GTM_fatal(\"Setting thread release TLS key failed.\");\n+}\n+\n+\n+\n+#ifndef HAVE_64BIT_SYNC_BUILTINS\n+static pthread_mutex_t global_tid_lock = PTHREAD_MUTEX_INITIALIZER;\n+#endif\n+\n+static inline uint32_t choose_code_path(uint32_t prop, abi_dispatch *disp)\n+{\n+  if ((prop & pr_uninstrumentedCode) && disp->can_run_uninstrumented_code())\n+    return a_runUninstrumentedCode;\n+  else\n+    return a_runInstrumentedCode;\n+}\n+\n+uint32_t\n+GTM::gtm_thread::begin_transaction (uint32_t prop, const gtm_jmpbuf *jb)\n+{\n+  static const _ITM_transactionId_t tid_block_size = 1 << 16;\n+\n+  gtm_thread *tx;\n+  abi_dispatch *disp;\n+  uint32_t ret;\n+\n+  // ??? pr_undoLogCode is not properly defined in the ABI. Are barriers\n+  // omitted because they are not necessary (e.g., a transaction on thread-\n+  // local data) or because the compiler thinks that some kind of global\n+  // synchronization might perform better?\n+  if (unlikely(prop & pr_undoLogCode))\n+    GTM_fatal(\"pr_undoLogCode not supported\");\n+\n+  tx = gtm_thr();\n+  if (unlikely(tx == NULL))\n+    {\n+      // Create the thread object. The constructor will also set up automatic\n+      // deletion on thread termination.\n+      tx = new gtm_thread();\n+      set_gtm_thr(tx);\n+    }\n+\n+  if (tx->nesting > 0)\n+    {\n+      // This is a nested transaction.\n+      // Check prop compatibility:\n+      // The ABI requires pr_hasNoFloatUpdate, pr_hasNoVectorUpdate,\n+      // pr_hasNoIrrevocable, pr_aWBarriersOmitted, pr_RaRBarriersOmitted, and\n+      // pr_hasNoSimpleReads to hold for the full dynamic scope of a\n+      // transaction. We could check that these are set for the nested\n+      // transaction if they are also set for the parent transaction, but the\n+      // ABI does not require these flags to be set if they could be set,\n+      // so the check could be too strict.\n+      // ??? For pr_readOnly, lexical or dynamic scope is unspecified.\n+\n+      if (prop & pr_hasNoAbort)\n+\t{\n+\t  // We can use flat nesting, so elide this transaction.\n+\t  if (!(prop & pr_instrumentedCode))\n+\t    {\n+\t      if (!(tx->state & STATE_SERIAL) ||\n+\t\t  !(tx->state & STATE_IRREVOCABLE))\n+\t\ttx->serialirr_mode();\n+\t    }\n+\t  // Increment nesting level after checking that we have a method that\n+\t  // allows us to continue.\n+\t  tx->nesting++;\n+\t  return choose_code_path(prop, abi_disp());\n+\t}\n+\n+      // The transaction might abort, so use closed nesting if possible.\n+      // pr_hasNoAbort has lexical scope, so the compiler should really have\n+      // generated an instrumented code path.\n+      assert(prop & pr_instrumentedCode);\n+\n+      // Create a checkpoint of the current transaction.\n+      gtm_transaction_cp *cp = tx->parent_txns.push();\n+      cp->save(tx);\n+      new (&tx->alloc_actions) aa_tree<uintptr_t, gtm_alloc_action>();\n+\n+      // Check whether the current method actually supports closed nesting.\n+      // If we can switch to another one, do so.\n+      // If not, we assume that actual aborts are infrequent, and rather\n+      // restart in _ITM_abortTransaction when we really have to.\n+      disp = abi_disp();\n+      if (!disp->closed_nesting())\n+\t{\n+\t  // ??? Should we elide the transaction if there is no alternative\n+\t  // method that supports closed nesting? If we do, we need to set\n+\t  // some flag to prevent _ITM_abortTransaction from aborting the\n+\t  // wrong transaction (i.e., some parent transaction).\n+\t  abi_dispatch *cn_disp = disp->closed_nesting_alternative();\n+\t  if (cn_disp)\n+\t    {\n+\t      disp = cn_disp;\n+\t      set_abi_disp(disp);\n+\t    }\n+\t}\n+    }\n+  else\n+    {\n+      // Outermost transaction\n+      disp = tx->decide_begin_dispatch (prop);\n+      if (disp == dispatch_serialirr() || disp == dispatch_serial())\n+\t{\n+\t  tx->state = STATE_SERIAL;\n+\t  if (disp == dispatch_serialirr())\n+\t    tx->state |= STATE_IRREVOCABLE;\n+\t  serial_lock.write_lock ();\n+\t}\n+      else\n+\tserial_lock.read_lock (tx);\n+\n+      set_abi_disp (disp);\n+    }\n+\n+  // Initialization that is common for outermost and nested transactions.\n+  tx->prop = prop;\n+  tx->nesting++;\n+\n+  tx->jb = *jb;\n+\n+  // As long as we have not exhausted a previously allocated block of TIDs,\n+  // we can avoid an atomic operation on a shared cacheline.\n+  if (tx->local_tid & (tid_block_size - 1))\n+    tx->id = tx->local_tid++;\n+  else\n+    {\n+#ifdef HAVE_64BIT_SYNC_BUILTINS\n+      tx->id = __sync_add_and_fetch (&global_tid, tid_block_size);\n+      tx->local_tid = tx->id + 1;\n+#else\n+      pthread_mutex_lock (&global_tid_lock);\n+      global_tid += tid_block_size;\n+      tx->id = global_tid;\n+      tx->local_tid = tx->id + 1;\n+      pthread_mutex_unlock (&global_tid_lock);\n+#endif\n+    }\n+\n+  // Run dispatch-specific restart code. Retry until we succeed.\n+  GTM::gtm_restart_reason rr;\n+  while ((rr = disp->begin_or_restart()) != NO_RESTART)\n+    {\n+      tx->decide_retry_strategy(rr);\n+      disp = abi_disp();\n+    }\n+\n+  // Determine the code path to run. Only irrevocable transactions cannot be\n+  // restarted, so all other transactions need to save live variables.\n+  ret = choose_code_path(prop, disp);\n+  if (!(tx->state & STATE_IRREVOCABLE))\n+    ret |= a_saveLiveVariables;\n+  return ret;\n+}\n+\n+\n+void\n+GTM::gtm_transaction_cp::save(gtm_thread* tx)\n+{\n+  // Save everything that we might have to restore on restarts or aborts.\n+  jb = tx->jb;\n+  undolog_size = tx->undolog.size();\n+  memcpy(&alloc_actions, &tx->alloc_actions, sizeof(alloc_actions));\n+  user_actions_size = tx->user_actions.size();\n+  id = tx->id;\n+  prop = tx->prop;\n+  cxa_catch_count = tx->cxa_catch_count;\n+  cxa_unthrown = tx->cxa_unthrown;\n+  disp = abi_disp();\n+  nesting = tx->nesting;\n+}\n+\n+void\n+GTM::gtm_transaction_cp::commit(gtm_thread* tx)\n+{\n+  // Restore state that is not persistent across commits. Exception handling,\n+  // information, nesting level, and any logs do not need to be restored on\n+  // commits of nested transactions. Allocation actions must be committed\n+  // before committing the snapshot.\n+  tx->jb = jb;\n+  memcpy(&tx->alloc_actions, &alloc_actions, sizeof(alloc_actions));\n+  tx->id = id;\n+  tx->prop = prop;\n+}\n+\n+\n+void\n+GTM::gtm_thread::rollback (gtm_transaction_cp *cp, bool aborting)\n+{\n+  // The undo log is special in that it used for both thread-local and shared\n+  // data. Because of the latter, we have to roll it back before any\n+  // dispatch-specific rollback (which handles synchronization with other\n+  // transactions).\n+  rollback_undolog (cp ? cp->undolog_size : 0);\n+\n+  // Perform dispatch-specific rollback.\n+  abi_disp()->rollback (cp);\n+\n+  // Roll back all actions that are supposed to happen around the transaction.\n+  rollback_user_actions (cp ? cp->user_actions_size : 0);\n+  commit_allocations (true, (cp ? &cp->alloc_actions : 0));\n+  revert_cpp_exceptions (cp);\n+\n+  if (cp)\n+    {\n+      // We do not yet handle restarts of nested transactions. To do that, we\n+      // would have to restore some state (jb, id, prop, nesting) not to the\n+      // checkpoint but to the transaction that was started from this\n+      // checkpoint (e.g., nesting = cp->nesting + 1);\n+      assert(aborting);\n+      // Roll back the rest of the state to the checkpoint.\n+      jb = cp->jb;\n+      id = cp->id;\n+      prop = cp->prop;\n+      if (cp->disp != abi_disp())\n+\tset_abi_disp(cp->disp);\n+      memcpy(&alloc_actions, &cp->alloc_actions, sizeof(alloc_actions));\n+      nesting = cp->nesting;\n+    }\n+  else\n+    {\n+      // Roll back to the outermost transaction.\n+      // Restore the jump buffer and transaction properties, which we will\n+      // need for the longjmp used to restart or abort the transaction.\n+      if (parent_txns.size() > 0)\n+\t{\n+\t  jb = parent_txns[0].jb;\n+\t  id = parent_txns[0].id;\n+\t  prop = parent_txns[0].prop;\n+\t}\n+      // Reset the transaction. Do not reset this->state, which is handled by\n+      // the callers. Note that if we are not aborting, we reset the\n+      // transaction to the point after having executed begin_transaction\n+      // (we will return from it), so the nesting level must be one, not zero.\n+      nesting = (aborting ? 0 : 1);\n+      parent_txns.clear();\n+    }\n+\n+  if (this->eh_in_flight)\n+    {\n+      _Unwind_DeleteException ((_Unwind_Exception *) this->eh_in_flight);\n+      this->eh_in_flight = NULL;\n+    }\n+}\n+\n+void ITM_REGPARM\n+_ITM_abortTransaction (_ITM_abortReason reason)\n+{\n+  gtm_thread *tx = gtm_thr();\n+\n+  assert (reason == userAbort || reason == (userAbort | outerAbort));\n+  assert ((tx->prop & pr_hasNoAbort) == 0);\n+\n+  if (tx->state & gtm_thread::STATE_IRREVOCABLE)\n+    abort ();\n+\n+  // Roll back to innermost transaction.\n+  if (tx->parent_txns.size() > 0 && !(reason & outerAbort))\n+    {\n+      // If the current method does not support closed nesting but we are\n+      // nested and must only roll back the innermost transaction, then\n+      // restart with a method that supports closed nesting.\n+      abi_dispatch *disp = abi_disp();\n+      if (!disp->closed_nesting())\n+\ttx->restart(RESTART_CLOSED_NESTING);\n+\n+      // The innermost transaction is a closed nested transaction.\n+      gtm_transaction_cp *cp = tx->parent_txns.pop();\n+      uint32_t longjmp_prop = tx->prop;\n+      gtm_jmpbuf longjmp_jb = tx->jb;\n+\n+      tx->rollback (cp, true);\n+\n+      // Jump to nested transaction (use the saved jump buffer).\n+      GTM_longjmp (&longjmp_jb, a_abortTransaction | a_restoreLiveVariables,\n+\t  longjmp_prop);\n+    }\n+  else\n+    {\n+      // There is no nested transaction or an abort of the outermost\n+      // transaction was requested, so roll back to the outermost transaction.\n+      tx->rollback (0, true);\n+\n+      // Aborting an outermost transaction finishes execution of the whole\n+      // transaction. Therefore, reset transaction state.\n+      if (tx->state & gtm_thread::STATE_SERIAL)\n+\tgtm_thread::serial_lock.write_unlock ();\n+      else\n+\tgtm_thread::serial_lock.read_unlock (tx);\n+      tx->state = 0;\n+\n+      GTM_longjmp (&tx->jb, a_abortTransaction | a_restoreLiveVariables,\n+\t  tx->prop);\n+    }\n+}\n+\n+bool\n+GTM::gtm_thread::trycommit ()\n+{\n+  nesting--;\n+\n+  // Skip any real commit for elided transactions.\n+  if (nesting > 0 && (parent_txns.size() == 0 ||\n+      nesting > parent_txns[parent_txns.size() - 1].nesting))\n+    return true;\n+\n+  if (nesting > 0)\n+    {\n+      // Commit of a closed-nested transaction. Remove one checkpoint and add\n+      // any effects of this transaction to the parent transaction.\n+      gtm_transaction_cp *cp = parent_txns.pop();\n+      commit_allocations(false, &cp->alloc_actions);\n+      cp->commit(this);\n+      return true;\n+    }\n+\n+  // Commit of an outermost transaction.\n+  gtm_word priv_time = 0;\n+  if (abi_disp()->trycommit (priv_time))\n+    {\n+      // The transaction is now inactive. Everything that we still have to do\n+      // will not synchronize with other transactions anymore.\n+      if (state & gtm_thread::STATE_SERIAL)\n+\tgtm_thread::serial_lock.write_unlock ();\n+      else\n+\tgtm_thread::serial_lock.read_unlock (this);\n+      state = 0;\n+\n+      // We can commit the undo log after dispatch-specific commit and after\n+      // making the transaction inactive because we only have to reset\n+      // gtm_thread state.\n+      commit_undolog ();\n+      // Reset further transaction state.\n+      cxa_catch_count = 0;\n+      cxa_unthrown = NULL;\n+      restart_total = 0;\n+\n+      // Ensure privatization safety, if necessary.\n+      if (priv_time)\n+\t{\n+\t  // TODO Don't just spin but also block using cond vars / futexes\n+\t  // here. Should probably be integrated with the serial lock code.\n+\t  // TODO For C++0x atomics, the loads of other threads' shared_state\n+\t  // should have acquire semantics (together with releases for the\n+\t  // respective updates). But is this unnecessary overhead because\n+\t  // weaker barriers are sufficient?\n+\t  for (gtm_thread *it = gtm_thread::list_of_threads; it != 0;\n+\t      it = it->next_thread)\n+\t    {\n+\t      if (it == this) continue;\n+\t      while (it->shared_state < priv_time)\n+\t\tcpu_relax();\n+\t    }\n+\t}\n+\n+      // After ensuring privatization safety, we execute potentially\n+      // privatizing actions (e.g., calling free()). User actions are first.\n+      commit_user_actions ();\n+      commit_allocations (false, 0);\n+\n+      return true;\n+    }\n+  return false;\n+}\n+\n+void ITM_NORETURN\n+GTM::gtm_thread::restart (gtm_restart_reason r)\n+{\n+  // Roll back to outermost transaction. Do not reset transaction state because\n+  // we will continue executing this transaction.\n+  rollback ();\n+  decide_retry_strategy (r);\n+\n+  // Run dispatch-specific restart code. Retry until we succeed.\n+  abi_dispatch* disp = abi_disp();\n+  GTM::gtm_restart_reason rr;\n+  while ((rr = disp->begin_or_restart()) != NO_RESTART)\n+    {\n+      decide_retry_strategy(rr);\n+      disp = abi_disp();\n+    }\n+\n+  GTM_longjmp (&jb,\n+      choose_code_path(prop, disp) | a_restoreLiveVariables, prop);\n+}\n+\n+void ITM_REGPARM\n+_ITM_commitTransaction(void)\n+{\n+  gtm_thread *tx = gtm_thr();\n+  if (!tx->trycommit ())\n+    tx->restart (RESTART_VALIDATE_COMMIT);\n+}\n+\n+void ITM_REGPARM\n+_ITM_commitTransactionEH(void *exc_ptr)\n+{\n+  gtm_thread *tx = gtm_thr();\n+  if (!tx->trycommit ())\n+    {\n+      tx->eh_in_flight = exc_ptr;\n+      tx->restart (RESTART_VALIDATE_COMMIT);\n+    }\n+}"}, {"sha": "cfb7f40850fbfa568a4c9b01d7c4d7471bf213cb", "filename": "libitm/clone.cc", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fclone.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fclone.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fclone.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,184 @@\n+/* Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+\n+using namespace GTM;\n+\n+struct clone_entry\n+{\n+  void *orig, *clone;\n+};\n+\n+struct clone_table\n+{\n+  clone_entry *table;\n+  size_t size;\n+  clone_table *next;\n+};\n+\n+static clone_table *all_tables;\n+\n+static void *\n+find_clone (void *ptr)\n+{\n+  clone_table *table;\n+\n+  for (table = all_tables; table ; table = table->next)\n+    {\n+      clone_entry *t = table->table;\n+      size_t lo = 0, hi = table->size, i;\n+\n+      /* Quick test for whether PTR is present in this table.  */\n+      if (ptr < t[0].orig || ptr > t[hi - 1].orig)\n+\tcontinue;\n+\n+      /* Otherwise binary search.  */\n+      while (lo < hi)\n+\t{\n+\t  i = (lo + hi) / 2;\n+\t  if (ptr < t[i].orig)\n+\t    hi = i;\n+\t  else if (ptr > t[i].orig)\n+\t    lo = i + 1;\n+\t  else\n+\t    return t[i].clone;\n+\t}\n+\n+      /* Given the quick test above, if we don't find the entry in\n+\t this table then it doesn't exist.  */\n+      break;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+void * ITM_REGPARM\n+_ITM_getTMCloneOrIrrevocable (void *ptr)\n+{\n+  void *ret = find_clone (ptr);\n+  if (ret)\n+    return ret;\n+\n+  gtm_thr()->serialirr_mode ();\n+\n+  return ptr;\n+}\n+\n+void * ITM_REGPARM\n+_ITM_getTMCloneSafe (void *ptr)\n+{\n+  void *ret = find_clone (ptr);\n+  if (ret == NULL)\n+    abort ();\n+  return ret;\n+}\n+\n+static int\n+clone_entry_compare (const void *a, const void *b)\n+{\n+  const clone_entry *aa = (const clone_entry *)a;\n+  const clone_entry *bb = (const clone_entry *)b;\n+\n+  if (aa->orig < bb->orig)\n+    return -1;\n+  else if (aa->orig > bb->orig)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+namespace {\n+\n+// Within find_clone, we know that we are inside a transaction.  Because\n+// of that, we have already synchronized with serial_lock.  By taking the\n+// serial_lock for write, we exclude all transactions while we make this\n+// change to the clone tables, without having to synchronize on a separate\n+// lock.  Do be careful not to attempt a recursive write lock.\n+\n+class ExcludeTransaction\n+{\n+  bool do_lock;\n+\n+ public:\n+  ExcludeTransaction()\n+  {\n+    gtm_thread *tx = gtm_thr();\n+    do_lock = !(tx && (tx->state & gtm_thread::STATE_SERIAL));\n+\n+    if (do_lock)\n+      gtm_thread::serial_lock.write_lock ();\n+  }\n+\n+  ~ExcludeTransaction()\n+  {\n+    if (do_lock)\n+      gtm_thread::serial_lock.write_unlock ();\n+  }\n+};\n+\n+} // end anon namespace\n+\n+\n+void\n+_ITM_registerTMCloneTable (void *xent, size_t size)\n+{\n+  clone_entry *ent = static_cast<clone_entry *>(xent);\n+  clone_table *table;\n+\n+  table = (clone_table *) xmalloc (sizeof (clone_table));\n+  table->table = ent;\n+  table->size = size;\n+\n+  qsort (ent, size, sizeof (clone_entry), clone_entry_compare);\n+\n+  // Hold the serial_lock while we update the ALL_TABLES datastructure.\n+  {\n+    ExcludeTransaction exclude;\n+    table->next = all_tables;\n+    all_tables = table;\n+  }\n+}\n+\n+void\n+_ITM_deregisterTMCloneTable (void *xent)\n+{\n+  clone_entry *ent = static_cast<clone_entry *>(xent);\n+  clone_table *tab;\n+\n+  // Hold the serial_lock while we update the ALL_TABLES datastructure.\n+  {\n+    ExcludeTransaction exclude;\n+    clone_table **pprev;\n+\n+    for (pprev = &all_tables;\n+\t tab = *pprev, tab->table != ent;\n+\t pprev = &tab->next)\n+      continue;\n+    *pprev = tab->next;\n+  }\n+\n+  free (tab);\n+}"}, {"sha": "14d0efb40ba8dcb9d76e08f8a909476aa3c039af", "filename": "libitm/common.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fcommon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fcommon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fcommon.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright (C) 2008, 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The following are internal implementation functions and definitions.\n+   To distinguish them from those defined by the Intel ABI, they all\n+   begin with GTM/gtm.  */\n+\n+#ifndef COMMON_H\n+#define COMMON_H 1\n+\n+#define UNUSED\t\t__attribute__((unused))\n+#define ALWAYS_INLINE\t__attribute__((always_inline))\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# define HIDDEN\t\t__attribute__((visibility(\"hidden\")))\n+#else\n+# define HIDDEN\n+#endif\n+\n+#define likely(X)\t__builtin_expect((X) != 0, 1)\n+#define unlikely(X)\t__builtin_expect((X), 0)\n+\n+namespace GTM HIDDEN {\n+\n+// Locally defined protected allocation functions.\n+//\n+// To avoid dependency on libstdc++ new/delete, as well as to not\n+// interfere with the wrapping of the global new/delete we wrap for\n+// the user in alloc_cpp.cc, use class-local versions that defer\n+// to malloc/free.  Recall that operator new/delete does not go through\n+// normal lookup and so we cannot simply inject a version into the\n+// GTM namespace.\n+// If separate_cl is true, the allocator will try to return memory that is on\n+// cache lines that are not shared with any object used by another thread.\n+extern void * xmalloc (size_t s, bool separate_cl = false)\n+  __attribute__((malloc, nothrow));\n+extern void * xrealloc (void *p, size_t s, bool separate_cl = false)\n+  __attribute__((malloc, nothrow));\n+\n+} // namespace GTM\n+\n+\n+#endif // COMMON_H"}, {"sha": "af13264db69484b3ae7d665b553737f8086d3946", "filename": "libitm/config.h.in", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig.h.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,159 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n+/* Define to 1 if the target supports 64-bit __sync_*_compare_and_swap */\n+#undef HAVE_64BIT_SYNC_BUILTINS\n+\n+/* Define to 1 if the target supports __attribute__((alias(...))). */\n+#undef HAVE_ATTRIBUTE_ALIAS\n+\n+/* Define to 1 if the target supports __attribute__((dllexport)). */\n+#undef HAVE_ATTRIBUTE_DLLEXPORT\n+\n+/* Define to 1 if the target supports __attribute__((visibility(...))). */\n+#undef HAVE_ATTRIBUTE_VISIBILITY\n+\n+/* Define if the POSIX Semaphores do not work on your system. */\n+#undef HAVE_BROKEN_POSIX_SEMAPHORES\n+\n+/* Define to 1 if the target assembler supports thread-local storage. */\n+#undef HAVE_CC_TLS\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <malloc.h> header file. */\n+#undef HAVE_MALLOC_H\n+\n+/* Define to 1 if you have the `memalign' function. */\n+#undef HAVE_MEMALIGN\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define if mmap with MAP_ANON(YMOUS) works. */\n+#undef HAVE_MMAP_ANON\n+\n+/* Define if mmap of /dev/zero works. */\n+#undef HAVE_MMAP_DEV_ZERO\n+\n+/* Define if read-only mmap of a plain file works. */\n+#undef HAVE_MMAP_FILE\n+\n+/* Define to 1 if you have the `posix_memalign' function. */\n+#undef HAVE_POSIX_MEMALIGN\n+\n+/* Define to 1 if you have the <semaphore.h> header file. */\n+#undef HAVE_SEMAPHORE_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the `strtoull' function. */\n+#undef HAVE_STRTOULL\n+\n+/* Define to 1 if the target supports __sync_*_compare_and_swap */\n+#undef HAVE_SYNC_BUILTINS\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#undef HAVE_SYS_TIME_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if the target supports thread-local storage. */\n+#undef HAVE_TLS\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to 1 if GNU symbol versioning is used for libitm. */\n+#undef LIBITM_GNU_SYMBOL_VERSIONING\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Define to the letter to which size_t is mangled. */\n+#undef MANGLE_SIZE_T\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* The size of `char', as computed by sizeof. */\n+#undef SIZEOF_CHAR\n+\n+/* The size of `int', as computed by sizeof. */\n+#undef SIZEOF_INT\n+\n+/* The size of `long', as computed by sizeof. */\n+#undef SIZEOF_LONG\n+\n+/* The size of `short', as computed by sizeof. */\n+#undef SIZEOF_SHORT\n+\n+/* The size of `void *', as computed by sizeof. */\n+#undef SIZEOF_VOID_P\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Define if you can safely include both <string.h> and <strings.h>. */\n+#undef STRING_WITH_STRINGS\n+\n+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */\n+#undef TIME_WITH_SYS_TIME\n+\n+/* Version number of package */\n+#undef VERSION\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif\n+\n+#ifndef WORDS_BIGENDIAN\n+#define WORDS_BIGENDIAN 0\n+#endif"}, {"sha": "5e38486b7134c9b07e8e935d6ef06efc49ff9df6", "filename": "libitm/config/alpha/cacheline.h", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Falpha%2Fcacheline.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,122 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBITM_ALPHA_CACHELINE_H\n+#define LIBITM_ALPHA_CACHELINE_H 1\n+\n+// A cacheline is the smallest unit with which locks are associated.\n+// The current implementation of the _ITM_[RW] barriers assumes that\n+// all data types can fit (aligned) within a cachline, which means\n+// in practice sizeof(complex long double) is the smallest cacheline size.\n+// It ought to be small enough for efficient manipulation of the\n+// modification mask, below.\n+#define CACHELINE_SIZE 64\n+\n+#ifdef __alpha_bwx__\n+# include \"config/generic/cacheline.h\"\n+#else\n+// If we don't have byte-word stores, then we'll never be able to\n+// adjust *all* of the byte loads/stores to be truely atomic.  So\n+// only guarantee 4-byte aligned values atomicly stored, exactly\n+// like the native system.  Use byte zap instructions to accelerate\n+// sub-word masked stores.\n+\n+namespace GTM HIDDEN {\n+\n+// A gtm_cacheline_mask stores a modified bit for every modified byte\n+// in the cacheline with which it is associated.\n+typedef sized_integral<CACHELINE_SIZE / 8>::type gtm_cacheline_mask;\n+\n+union gtm_cacheline\n+{\n+  // Byte access to the cacheline.\n+  unsigned char b[CACHELINE_SIZE] __attribute__((aligned(CACHELINE_SIZE)));\n+\n+  // Larger sized access to the cacheline.\n+  uint16_t u16[CACHELINE_SIZE / sizeof(uint16_t)];\n+  uint32_t u32[CACHELINE_SIZE / sizeof(uint32_t)];\n+  uint64_t u64[CACHELINE_SIZE / sizeof(uint64_t)];\n+  gtm_word w[CACHELINE_SIZE / sizeof(gtm_word)];\n+\n+  // Store S into D, but only the bytes specified by M.\n+  static void store_mask(uint32_t *d, uint32_t s, uint8_t m);\n+  static void store_mask(uint64_t *d, uint64_t s, uint8_t m);\n+\n+  // Copy S to D, but only the bytes specified by M.\n+  static void copy_mask (gtm_cacheline * __restrict d,\n+\t\t\t const gtm_cacheline * __restrict s,\n+\t\t\t gtm_cacheline_mask m);\n+\n+  // A write barrier to emit after (a series of) copy_mask.\n+  static void copy_mask_wb () { atomic_write_barrier(); }\n+};\n+\n+inline void ALWAYS_INLINE\n+gtm_cacheline::store_mask (uint32_t *d, uint32_t s, uint8_t m)\n+{\n+  const uint8_t tm = (1 << sizeof(uint32_t)) - 1;\n+\n+  m &= tm;\n+  if (__builtin_expect (m, tm))\n+    {\n+      if (__builtin_expect (m == tm, 1))\n+\t*d = s;\n+      else\n+\t*d = __builtin_alpha_zap (*d, m) | __builtin_alpha_zapnot (s, m);\n+    }\n+}\n+\n+inline void ALWAYS_INLINE\n+gtm_cacheline::store_mask (uint64_t *d, uint64_t s, uint8_t m)\n+{\n+  if (__builtin_expect (m, 0xff))\n+    {\n+      if (__builtin_expect (m == 0xff, 1))\n+\t*d = s;\n+      else\n+\t{\n+\t  typedef uint32_t *p32 __attribute__((may_alias));\n+\t  p32 d32 = reinterpret_cast<p32>(d);\n+\n+\t  if ((m & 0x0f) == 0x0f)\n+\t    {\n+\t      d32[0] = s;\n+\t      m &= 0xf0;\n+\t    }\n+\t  else if ((m & 0xf0) == 0xf0)\n+\t    {\n+\t      d32[1] = s >> 32;\n+\t      m &= 0x0f;\n+\t    }\n+\n+\t  if (m)\n+\t    *d = __builtin_alpha_zap (*d, m) | __builtin_alpha_zapnot (s, m);\n+\t}\n+    }\n+}\n+\n+} // namespace GTM\n+\n+#endif // __alpha_bwx__\n+#endif // LIBITM_ALPHA_CACHELINE_H"}, {"sha": "d60a82df62b89875cda2f0cbcfc5b863b4ce48b1", "filename": "libitm/config/alpha/sjlj.S", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Fsjlj.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Fsjlj.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Falpha%2Fsjlj.S?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,108 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\t.text\n+\t.align 4\n+\t.globl\t_ITM_beginTransaction\n+\t.ent\t_ITM_beginTransaction\n+\n+#define FRAME\t144\n+\n+_ITM_beginTransaction:\n+\tldgp\t$29, 0($27)\n+\tsubq\t$30, FRAME, $30\n+\t.frame\t$30, FRAME, $26, 0\n+\t.mask\t0x04000000, 0\n+\tstq\t$26, 0($30)\n+\t.prologue 1\n+\n+\tstq\t$9, 8($30)\n+\tstq\t$10, 16($30)\n+\taddq\t$30, FRAME, $0\n+\tstq\t$11, 24($30)\n+\n+\tstq\t$12, 32($30)\n+\tstq\t$13, 40($30)\n+\tstq\t$14, 48($30)\n+\tstq\t$15, 56($30)\n+\n+\tstq\t$0, 64($30)\n+\tstt\t$f2, 72($30)\n+\tstt\t$f3, 80($30)\n+\tstt\t$f4, 88($30)\n+\n+\tstt\t$f5, 96($30)\n+\tstt\t$f6, 104($30)\n+\tstt\t$f7, 112($30)\n+\tstt\t$f8, 120($30)\n+\n+\tstt\t$f9, 128($30)\n+\tmov\t$30, $17\n+#ifdef __PIC__\n+\tunop\n+\tbsr\t$26, GTM_begin_transaction !samegp\n+#else\n+\tjsr\t$26, GTM_begin_transaction\n+\tldgp\t$29, 0($26)\n+#endif\n+\n+\tldq\t$26, 0($30)\n+\taddq\t$30, FRAME, $30\n+\tret\n+.end _ITM_beginTransaction\n+\n+\t.align 4\n+\t.globl\tGTM_longjmp\n+\t.hidden\tGTM_longjmp\n+\t.ent\tGTM_longjmp\n+\n+GTM_longjmp:\n+\t.prologue 0\n+\tldq\t$26, 0($16)\n+\tldq\t$9, 8($16)\n+\tldq\t$10, 16($16)\n+\tldq\t$11, 24($16)\n+\n+\tldq\t$12, 32($16)\n+\tldq\t$13, 40($16)\n+\tldq\t$14, 48($16)\n+\tldq\t$15, 56($16)\n+\n+\tldq\t$1, 64($16)\n+\tldt\t$f2, 72($16)\n+\tldt\t$f3, 80($16)\n+\tldt\t$f4, 88($16)\n+\n+\tldt\t$f5, 96($16)\n+\tldt\t$f6, 104($16)\n+\tldt\t$f7, 112($16)\n+\tldt\t$f8, 120($16)\n+\n+\tldt\t$f9, 128($16)\n+\tmov\t$17, $0\n+\tmov\t$1, $30\n+\tret\n+.end GTM_longjmp\n+\n+.section .note.GNU-stack, \"\", @progbits"}, {"sha": "121546f5f52d19a15c8edc0a529743112eeba76f", "filename": "libitm/config/alpha/target.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Falpha%2Ftarget.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,60 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+namespace GTM HIDDEN {\n+\n+typedef struct gtm_jmpbuf\n+{\n+  unsigned long pc;\n+  unsigned long s[7];\n+  void *cfa;\n+  unsigned long f[8];\n+} gtm_jmpbuf;\n+\n+/* Alpha generally uses a fixed page size of 8K.  */\n+#define PAGE_SIZE\t8192\n+#define FIXED_PAGE_SIZE\t1\n+\n+/* The size of one line in hardware caches (in bytes). */\n+#define HW_CACHELINE_SIZE 64\n+\n+static inline void\n+cpu_relax (void)\n+{\n+  __asm volatile (\"\" : : : \"memory\");\n+}\n+\n+static inline void\n+atomic_read_barrier (void)\n+{\n+  __sync_synchronize ();\n+}\n+\n+static inline void\n+atomic_write_barrier (void)\n+{\n+  __asm volatile (\"wmb\" : : : \"memory\");\n+}\n+\n+} // namespace GTM"}, {"sha": "3d091aee22838d178edbfba0fd0ca9c14ccf1cdb", "filename": "libitm/config/alpha/unaligned.h", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Funaligned.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Falpha%2Funaligned.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Falpha%2Funaligned.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,118 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBITM_ALPHA_UNALIGNED_H\n+#define LIBITM_ALPHA_UNALIGNED_H 1\n+\n+#define HAVE_ARCH_UNALIGNED_LOAD2_U2 1\n+#define HAVE_ARCH_UNALIGNED_LOAD2_U4 1\n+#define HAVE_ARCH_UNALIGNED_LOAD2_U8 1\n+\n+#ifndef __alpha_bwx__\n+#define HAVE_ARCH_UNALIGNED_STORE2_U2 1\n+#endif\n+#define HAVE_ARCH_UNALIGNED_STORE2_U4 1\n+#define HAVE_ARCH_UNALIGNED_STORE2_U8 1\n+\n+#include \"config/generic/unaligned.h\"\n+\n+namespace GTM HIDDEN {\n+\n+template<>\n+inline uint16_t ALWAYS_INLINE\n+unaligned_load2<uint16_t>(const gtm_cacheline *c1,\n+\t\t\t  const gtm_cacheline *c2, size_t ofs)\n+{\n+  uint64_t v1 = c1->u64[CACHELINE_SIZE / sizeof(uint64_t) - 1];\n+  uint64_t v2 = c2->u64[0];\n+\n+  return __builtin_alpha_extwl (v1, ofs) | __builtin_alpha_extwh (v2, ofs);\n+}\n+\n+template<>\n+inline uint32_t ALWAYS_INLINE\n+unaligned_load2<uint32_t>(const gtm_cacheline *c1,\n+\t\t\t  const gtm_cacheline *c2, size_t ofs)\n+{\n+  uint64_t v1 = c1->u64[CACHELINE_SIZE / sizeof(uint64_t) - 1];\n+  uint64_t v2 = c2->u64[0];\n+\n+  return __builtin_alpha_extll (v1, ofs) + __builtin_alpha_extlh (v2, ofs);\n+}\n+\n+template<>\n+inline uint64_t ALWAYS_INLINE\n+unaligned_load2<uint64_t>(const gtm_cacheline *c1,\n+\t\t\t  const gtm_cacheline *c2, size_t ofs)\n+{\n+  uint64_t v1 = c1->u64[CACHELINE_SIZE / sizeof(uint64_t) - 1];\n+  uint64_t v2 = c2->u64[0];\n+\n+  return __builtin_alpha_extql (v1, ofs) | __builtin_alpha_extqh (v2, ofs);\n+}\n+\n+#ifndef __alpha_bwx__\n+template<>\n+inline void\n+unaligned_store2<uint16_t>(gtm_cacheline *c1, gtm_cacheline *c2,\n+\t\t\t   size_t ofs, uint16_t val)\n+{\n+  uint32_t vl = (uint32_t)val << 24, vh = val >> 8;\n+\n+  gtm_cacheline::store_mask (&c1->u32[CACHELINE_SIZE / 4 - 1], vl, 4);\n+  gtm_cacheline::store_mask (&c2->u32[0], vh, 1);\n+}\n+#endif\n+\n+template<>\n+inline void\n+unaligned_store2<uint32_t>(gtm_cacheline *c1, gtm_cacheline *c2,\n+\t\t\t   size_t ofs, uint32_t val)\n+{\n+  uint64_t vl = __builtin_alpha_insll (val, ofs);\n+  uint64_t ml = __builtin_alpha_insll (~0u, ofs);\n+  uint64_t vh = __builtin_alpha_inslh (val, ofs);\n+  uint64_t mh = __builtin_alpha_inslh (~0u, ofs);\n+\n+  gtm_cacheline::store_mask (&c1->u64[CACHELINE_SIZE / 8 - 1], vl, ml);\n+  gtm_cacheline::store_mask (&c2->u64[0], vh, mh);\n+}\n+\n+template<>\n+inline void\n+unaligned_store2<uint64_t>(gtm_cacheline *c1, gtm_cacheline *c2,\n+\t\t\t   size_t ofs, uint64_t val)\n+{\n+  uint64_t vl = __builtin_alpha_insql (val, ofs);\n+  uint64_t ml = __builtin_alpha_insql (~0u, ofs);\n+  uint64_t vh = __builtin_alpha_insqh (val, ofs);\n+  uint64_t mh = __builtin_alpha_insqh (~0u, ofs);\n+\n+  gtm_cacheline::store_mask (&c1->u64[CACHELINE_SIZE / 8 - 1], vl, ml);\n+  gtm_cacheline::store_mask (&c2->u64[0], vh, mh);\n+}\n+\n+} // namespace GTM\n+\n+#endif // LIBITM_ALPHA_UNALIGNED_H"}, {"sha": "108ffba303785a24e018241c137b5855208a161b", "filename": "libitm/config/generic/cacheline.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Fcacheline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Fcacheline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Fcacheline.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,49 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libitm_i.h\"\n+\n+\n+namespace GTM HIDDEN {\n+\n+void\n+gtm_cacheline::copy_mask (gtm_cacheline * __restrict d,\n+\t\t\t  const gtm_cacheline * __restrict s,\n+\t\t\t  gtm_cacheline_mask m)\n+{\n+  const size_t n = sizeof (gtm_word);\n+\n+  if (m == (gtm_cacheline_mask) -1)\n+    {\n+      *d = *s;\n+      return;\n+    }\n+  if (__builtin_expect (m == 0, 0))\n+    return;\n+\n+  for (size_t i = 0; i < CACHELINE_SIZE / n; ++i, m >>= n)\n+    store_mask (&d->w[i], s->w[i], m);\n+}\n+\n+} // namespace GTM"}, {"sha": "0a5af761d6e6fa6a502c8cfb3cb09b3c95c29906", "filename": "libitm/config/generic/cacheline.h", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Fcacheline.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,107 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBITM_CACHELINE_H\n+#define LIBITM_CACHELINE_H 1\n+\n+namespace GTM HIDDEN {\n+\n+// A cacheline is the smallest unit with which locks are associated.\n+// The current implementation of the _ITM_[RW] barriers assumes that\n+// all data types can fit (aligned) within a cachline, which means\n+// in practice sizeof(complex long double) is the smallest cacheline size.\n+// It ought to be small enough for efficient manipulation of the\n+// modification mask, below.\n+#ifndef CACHELINE_SIZE\n+# define CACHELINE_SIZE 32\n+#endif\n+\n+// A gtm_cacheline_mask stores a modified bit for every modified byte\n+// in the cacheline with which it is associated.\n+typedef sized_integral<CACHELINE_SIZE / 8>::type gtm_cacheline_mask;\n+\n+union gtm_cacheline\n+{\n+  // Byte access to the cacheline.\n+  unsigned char b[CACHELINE_SIZE] __attribute__((aligned(CACHELINE_SIZE)));\n+\n+  // Larger sized access to the cacheline.\n+  uint16_t u16[CACHELINE_SIZE / sizeof(uint16_t)];\n+  uint32_t u32[CACHELINE_SIZE / sizeof(uint32_t)];\n+  uint64_t u64[CACHELINE_SIZE / sizeof(uint64_t)];\n+  gtm_word w[CACHELINE_SIZE / sizeof(gtm_word)];\n+\n+  // Store S into D, but only the bytes specified by M.\n+  template<typename T> static void store_mask (T *d, T s, uint8_t m);\n+\n+  // Copy S to D, but only the bytes specified by M.\n+  static void copy_mask (gtm_cacheline * __restrict d,\n+\t\t\t const gtm_cacheline * __restrict s,\n+\t\t\t gtm_cacheline_mask m);\n+\n+  // A write barrier to emit after (a series of) copy_mask.\n+  // When we're emitting non-temporal stores, the normal strong\n+  // ordering of the machine doesn't apply.\n+  static void copy_mask_wb () { atomic_write_barrier(); }\n+};\n+\n+template<typename T>\n+inline void\n+gtm_cacheline::store_mask (T *d, T s, uint8_t m)\n+{\n+  const uint8_t tm = (1 << sizeof(T)) - 1;\n+\n+  if (__builtin_expect (m & tm, tm))\n+    {\n+      if (__builtin_expect ((m & tm) == tm, 1))\n+\t*d = s;\n+      else\n+\t{\n+\t  const int half = sizeof(T) / 2;\n+\t  typedef typename sized_integral<half>::type half_t;\n+\t  half_t *dhalf = reinterpret_cast<half_t *>(d);\n+\t  half_t s1, s2;\n+\n+\t  if (WORDS_BIGENDIAN)\n+\t    s1 = s >> half*8, s2 = s;\n+\t  else\n+\t    s1 = s, s2 = s >> half*8;\n+\n+\t  store_mask (dhalf, s1, m);\n+\t  store_mask (dhalf + 1, s2, m >> half);\n+\t}\n+    }\n+}\n+\n+template<>\n+inline void ALWAYS_INLINE\n+gtm_cacheline::store_mask<uint8_t> (uint8_t *d, uint8_t s, uint8_t m)\n+{\n+  if (m & 1)\n+    *d = s;\n+}\n+\n+} // namespace GTM\n+\n+#endif // LIBITM_CACHELINE_H"}, {"sha": "a5472f3831b13feb67d4270f52188ff048391b0c", "filename": "libitm/config/generic/cachepage.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Fcachepage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Fcachepage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Fcachepage.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d", "patch": "@@ -0,0 +1,77 @@\n+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Transactional Memory Library (libitm).\n+\n+   Libitm is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libitm is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBITM_CACHEPAGE_H\n+#define LIBITM_CACHEPAGE_H 1\n+\n+namespace GTM HIDDEN {\n+\n+// A \"page\" worth of saved cachelines plus modification masks.  This\n+// arrangement is intended to minimize the overhead of alignment.  The\n+// PAGE_SIZE defined by the target must be a constant for this to work,\n+// which means that this definition may not be the same as the real\n+// system page size.  An additional define of FIXED_PAGE_SIZE by the\n+// target indicates that PAGE_SIZE exactly matches the system page size.\n+\n+#ifndef PAGE_SIZE\n+#define PAGE_SIZE 4096\n+#endif\n+\n+struct gtm_cacheline_page\n+{\n+  static const size_t LINES\n+    = ((PAGE_SIZE - sizeof(gtm_cacheline_page *))\n+       / (CACHELINE_SIZE + sizeof(gtm_cacheline_mask)));\n+\n+  gtm_cacheline lines[LINES] __attribute__((aligned(PAGE_SIZE)));\n+  gtm_cacheline_mask masks[LINES];\n+  gtm_cacheline_page *prev;\n+\n+  static gtm_cacheline_page *\n+  page_for_line (gtm_cacheline *c)\n+  {\n+    return (gtm_cacheline_page *)((uintptr_t)c & -PAGE_SIZE);\n+  }\n+\n+  gtm_cacheline_mask *\n+  mask_for_line (gtm_cacheline *c)\n+  {\n+    size_t index = c - &this->lines[0];\n+    return &this->masks[index];\n+  }\n+\n+  static gtm_cacheline_mask *\n+  mask_for_page_line (gtm_cacheline *c)\n+  {\n+    gtm_cacheline_page *p = page_for_line (c);\n+    return p->mask_for_line (c);\n+  }\n+\n+  static void *operator new (size_t);\n+  static void operator delete (void *);\n+};\n+\n+} // namespace GTM\n+\n+#endif // LIBITM_CACHEPAGE_H"}, {"sha": "3e82cff0902c6c7656130a3f67e8647168ddb941", "filename": "libitm/config/generic/tls.cc", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Ftls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Ftls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Ftls.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "e282e54817b5d4e45a12c19b64930317295763b6", "filename": "libitm/config/generic/tls.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Ftls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Ftls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Ftls.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "50cb13bd277b49127554aca285b14775100e9e61", "filename": "libitm/config/generic/unaligned.h", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Funaligned.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fgeneric%2Funaligned.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fgeneric%2Funaligned.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "997bf0b3cff55e6115fded717ebbc56fb63ab77a", "filename": "libitm/config/linux/alpha/futex_bits.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Falpha%2Ffutex_bits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Falpha%2Ffutex_bits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Falpha%2Ffutex_bits.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "45c9db62dbb8e679c8017eaf9e8db824dc697412", "filename": "libitm/config/linux/futex.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Ffutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Ffutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Ffutex.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "326c0f56eede849b1b45ada7ac834329db64063c", "filename": "libitm/config/linux/futex.h", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Ffutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Ffutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Ffutex.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "c1e935ea5b21f26bf6c2dbca60bf6e72e43f0d3a", "filename": "libitm/config/linux/rwlock.cc", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "7e6229b73f2926b92da4c138383c545d07f16f14", "filename": "libitm/config/linux/rwlock.h", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Frwlock.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "9a6b102cd7afab2b17f64538a028a496b7706338", "filename": "libitm/config/linux/x86/futex_bits.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Fx86%2Ffutex_bits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Fx86%2Ffutex_bits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Fx86%2Ffutex_bits.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "01f7c27bcb3637186767dc4b5adae05e423312ea", "filename": "libitm/config/linux/x86/tls.h", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Fx86%2Ftls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Flinux%2Fx86%2Ftls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Flinux%2Fx86%2Ftls.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "128cd5435aeb08647820d2137339b4124ab7bd47", "filename": "libitm/config/posix/cachepage.cc", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fposix%2Fcachepage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fposix%2Fcachepage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Fcachepage.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "f3793830e1203814b4f21105a6f1647541dc9ea9", "filename": "libitm/config/posix/rwlock.cc", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fposix%2Frwlock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fposix%2Frwlock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "f538bd059a2ce7b6ccd7d79e0a6b0cc8283431c4", "filename": "libitm/config/posix/rwlock.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fposix%2Frwlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fposix%2Frwlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fposix%2Frwlock.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "2e49a35595322f022c92149486d7478c0157ff9a", "filename": "libitm/config/x86/cacheline.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fcacheline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fcacheline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fcacheline.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "15a95b0be5bd537701f4bcac4ea39b5bbbe9c335", "filename": "libitm/config/x86/cacheline.h", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fcacheline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fcacheline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fcacheline.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "725ffec80574ca5dd5f56c66a7e9bc5f1c398147", "filename": "libitm/config/x86/sjlj.S", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fsjlj.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fsjlj.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fsjlj.S?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "197faebe2d4e71f549fb4959ed085657e332335e", "filename": "libitm/config/x86/target.h", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Ftarget.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "01abc47dccb387cf0c9fb3f89e64a2119f91c038", "filename": "libitm/config/x86/unaligned.h", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Funaligned.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Funaligned.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Funaligned.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "9d1ddfb3ee895ad0b229e09bd64ffc0ff716e48b", "filename": "libitm/config/x86/x86_avx.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fx86_avx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fx86_avx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fx86_avx.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "7440c949cb7644216390be706180d9c9382134f7", "filename": "libitm/config/x86/x86_sse.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fx86_sse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfig%2Fx86%2Fx86_sse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfig%2Fx86%2Fx86_sse.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "08d2993e06e74536979bb69f0683c91be568ebbc", "filename": "libitm/configure", "status": "added", "additions": 20249, "deletions": 0, "changes": 20249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "7f35b154529f70dbf4f10fdff64349795216fc2c", "filename": "libitm/configure.ac", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.ac?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "efc01e095aa26ccc7e46f5aa42793b7d268668aa", "filename": "libitm/configure.tgt", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fconfigure.tgt?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "e8aa94bb4f4218cc61830ad060d5e49bc9a5a576", "filename": "libitm/containers.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fcontainers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fcontainers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fcontainers.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "dbf05e4da37271674602e5a993b58b91cc949048", "filename": "libitm/dispatch.h", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fdispatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fdispatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fdispatch.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "7cba97cc48c566b6459605343332c6405df00a78", "filename": "libitm/eh_cpp.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Feh_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Feh_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Feh_cpp.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "80ae96dedb99e92990de35724bf4059e629aa287", "filename": "libitm/libitm.h", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "49d0b1b5ebbe8ce32df981a520657af05e3d803e", "filename": "libitm/libitm.map", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.map?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "eccc091fbdcfb31b49231757af4824eca294e6f9", "filename": "libitm/libitm.spec.in", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.spec.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.spec.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.spec.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "b31657f7f97afe2402a9620b688c607c261081c0", "filename": "libitm/libitm.texi", "status": "added", "additions": 739, "deletions": 0, "changes": 739, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm.texi?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "c188fa5f43f55c04ef2446db6412483d44b1e796", "filename": "libitm/libitm_i.h", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flibitm_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flibitm_i.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "fab73c508956a899a581f2b1c1664a5a3e497782", "filename": "libitm/local.cc", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flocal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flocal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flocal.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "8349cd502634fdc295a8aecf7b59850d621a36c4", "filename": "libitm/local_type_traits", "status": "added", "additions": 1901, "deletions": 0, "changes": 1901, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flocal_type_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Flocal_type_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Flocal_type_traits?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "9919e6a9afaceb02de99742576fa01c9edff454f", "filename": "libitm/memcpy.cc", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmemcpy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmemcpy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmemcpy.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "3a627dd6c7d17f7876135a2776777ff8cd365f62", "filename": "libitm/memset.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmemset.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmemset.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmemset.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "60c266267790599f99735144c4d2fe186f9cafc7", "filename": "libitm/method-gl.cc", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmethod-gl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmethod-gl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-gl.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "5e85653a2f450295cc582e266690b813975dc495", "filename": "libitm/method-serial.cc", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmethod-serial.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmethod-serial.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-serial.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "093d1c769f199bf751c3e951afd622cf071f8efc", "filename": "libitm/method-wbetl.cc", "status": "added", "additions": 628, "deletions": 0, "changes": 628, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmethod-wbetl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fmethod-wbetl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fmethod-wbetl.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "ce72f702046d72ba2ae8b6230a50518b86662f3b", "filename": "libitm/query.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fquery.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fquery.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fquery.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "decd7731b46282ede4e79805d34c5d2ef8c53601", "filename": "libitm/retry.cc", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fretry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fretry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fretry.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "f115a417da20e94188536eb56dec7c3fee62030c", "filename": "libitm/stmlock.h", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fstmlock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fstmlock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fstmlock.h?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "561b7e25448e27f1236ee70a80b0ce5110194ef7", "filename": "libitm/testsuite/Makefile.am", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2FMakefile.am?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "ed1f314e0d61d429a6decdef016e20dbbc098dab", "filename": "libitm/testsuite/Makefile.in", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2FMakefile.in?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "b5e53fc792e249e874c292d27895cac8d24c2d7e", "filename": "libitm/testsuite/config/default.exp", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Fconfig%2Fdefault.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Fconfig%2Fdefault.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Fconfig%2Fdefault.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "f684ce899eff3bd51f9027402ca61cb64dbaa807", "filename": "libitm/testsuite/lib/libitm-dg.exp", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flib%2Flibitm-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flib%2Flibitm-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flib%2Flibitm-dg.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "701120aa557e50463890f88691b9d1f7e73e611a", "filename": "libitm/testsuite/lib/libitm.exp", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flib%2Flibitm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flib%2Flibitm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flib%2Flibitm.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "d30e9455c165a80f4f3e3a31f437c3f382c63022", "filename": "libitm/testsuite/libitm.c++/c++.exp", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fc%2B%2B.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "c9bdfff32cfc0ccf5058bfe5d79d43e33b1d69a0", "filename": "libitm/testsuite/libitm.c++/dropref.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fdropref.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fdropref.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fdropref.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "49e2213e1ff9d508802615309c961b0d447b9a5d", "filename": "libitm/testsuite/libitm.c++/eh-1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Feh-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Feh-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Feh-1.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "1ba751687bac1fcf2c51d3155507a12ef5d47c36", "filename": "libitm/testsuite/libitm.c++/static_ctor.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fstatic_ctor.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fstatic_ctor.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fstatic_ctor.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "8c65508656ae49cd141712306d0ea4a9e9ae89c9", "filename": "libitm/testsuite/libitm.c++/throwdown.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fthrowdown.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fthrowdown.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2B%2B%2Fthrowdown.C?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "f7229a5bcdf4e46c33524a1a5f739c7ef05e9adc", "filename": "libitm/testsuite/libitm.c/c.exp", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fc.exp?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "28276db07a109f4f82059620f537286bcb1d4f22", "filename": "libitm/testsuite/libitm.c/cancel.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fcancel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fcancel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fcancel.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "03e62664d80ca37511169c3b01168e6c02898b36", "filename": "libitm/testsuite/libitm.c/clone-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fclone-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fclone-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fclone-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "5bb2726dbd963fa58a8926cc41957e6fb31de411", "filename": "libitm/testsuite/libitm.c/dropref-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fdropref-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fdropref-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fdropref-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "c9bdfff32cfc0ccf5058bfe5d79d43e33b1d69a0", "filename": "libitm/testsuite/libitm.c/dropref.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fdropref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fdropref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fdropref.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "e4b56573b26d45da8da1f9f2daca93a4205d5f59", "filename": "libitm/testsuite/libitm.c/memcpy-1.c", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fmemcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fmemcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fmemcpy-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "87bf6c62322a8b7e86f2e6a4398a78bac976d583", "filename": "libitm/testsuite/libitm.c/memset-1.c", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fmemset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fmemset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fmemset-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "999da025a82d5804fa0db67b536b7e537056adbd", "filename": "libitm/testsuite/libitm.c/notx.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fnotx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fnotx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fnotx.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "007bbaab741eba48da0f937d84299aaf12688ea9", "filename": "libitm/testsuite/libitm.c/reentrant.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Freentrant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Freentrant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Freentrant.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "de41740d49af44f2eaa8c33a96e365a557120b38", "filename": "libitm/testsuite/libitm.c/simple-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fsimple-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fsimple-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fsimple-1.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "e92c917340d9653ba8ee96c462de7c830321b3dd", "filename": "libitm/testsuite/libitm.c/simple-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fsimple-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Fsimple-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Fsimple-2.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "7bf04343d5787651110825a75762bd6024f7436f", "filename": "libitm/testsuite/libitm.c/txrelease.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Ftxrelease.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Ftestsuite%2Flibitm.c%2Ftxrelease.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Ftestsuite%2Flibitm.c%2Ftxrelease.c?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "952bbd991b455161da29874836c69350726fe370", "filename": "libitm/useraction.cc", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fuseraction.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Fuseraction.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Fuseraction.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "afd37e41731a4a058992d46e685ceccd37c2d83c", "filename": "libitm/util.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Futil.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libitm%2Futil.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libitm%2Futil.cc?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "51abac9fe057a5d9a78f599aa858e9c4684fa48a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "13f06ef456829e2b4569096d0fdcbd7e406332a0", "filename": "libstdc++-v3/config/abi/pre/gnu-versioned-namespace.ver", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu-versioned-namespace.ver?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "ce56120c9603d6699d9d8faeb8b2d58c963cb970", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}, {"sha": "c8e661d5788e49da521797172a9495c773febde7", "filename": "libstdc++-v3/libsupc++/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a35513e4e73ec9c6f24e791d344308ad3ed030d/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2FMakefile.am?ref=0a35513e4e73ec9c6f24e791d344308ad3ed030d"}]}