{"sha": "23782cc3783c2040847d5f21d774436e1ecc8535", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM3ODJjYzM3ODNjMjA0MDg0N2Q1ZjIxZDc3NDQzNmUxZWNjODUzNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-11-03T15:18:50Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-11-03T15:18:50Z"}, "message": "re PR tree-optimization/46009 (?: vectorized, very similar if is not)\n\n\tPR tree-optimization/46009\n\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Call\n\tcond_if_else_store_replacement if bb1 and bb2 have the same\n\tsingle successor.\n\t(cond_store_replacement): Use gimple_assign_single_p, don't\n\tcheck if rhs is SSA_NAME or invariant.  Call release_defs for\n\tassign.\n\t(cond_if_else_store_replacement): New function.\n\n\t* gcc.dg/vect/pr46009.c: New function.\n\nFrom-SVN: r166251", "tree": {"sha": "059bf88d3d7061144003b1f54c1c90062b165a56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/059bf88d3d7061144003b1f54c1c90062b165a56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23782cc3783c2040847d5f21d774436e1ecc8535", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23782cc3783c2040847d5f21d774436e1ecc8535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23782cc3783c2040847d5f21d774436e1ecc8535", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23782cc3783c2040847d5f21d774436e1ecc8535/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2996c17fcb14e2865a8a26ce636d6afdc9a13d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2996c17fcb14e2865a8a26ce636d6afdc9a13d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2996c17fcb14e2865a8a26ce636d6afdc9a13d6c"}], "stats": {"total": 242, "additions": 227, "deletions": 15}, "files": [{"sha": "73198e3dc7a8885e0f5da4d0d25124c145c8c761", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23782cc3783c2040847d5f21d774436e1ecc8535", "patch": "@@ -1,3 +1,14 @@\n+2010-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/46009\n+\t* tree-ssa-phiopt.c (tree_ssa_phiopt_worker): Call\n+\tcond_if_else_store_replacement if bb1 and bb2 have the same\n+\tsingle successor.\n+\t(cond_store_replacement): Use gimple_assign_single_p, don't\n+\tcheck if rhs is SSA_NAME or invariant.  Call release_defs for\n+\tassign.\n+\t(cond_if_else_store_replacement): New function.\n+\n 2010-11-03  Richard Guenther  <rguenther@suse.de>\n \n \t* opts.c (finish_options): Properly check for all WHOPR"}, {"sha": "c9ca8a361cae5db3e56c93ea2508756fd53059c1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=23782cc3783c2040847d5f21d774436e1ecc8535", "patch": "@@ -1,3 +1,8 @@\n+2010-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/46009\n+\t* gcc.dg/vect/pr46009.c: New function.\n+\n 2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tImplemented -fobjc-std=objc1 flag."}, {"sha": "457dd37907ac71d105792bec3fa95947ba5c76d1", "filename": "gcc/testsuite/gcc.dg/vect/pr46009.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46009.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46009.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr46009.c?ref=23782cc3783c2040847d5f21d774436e1ecc8535", "patch": "@@ -0,0 +1,74 @@\n+/* PR tree-optimization/46009 */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int a[1024] __attribute__((aligned));\n+int b[1024] __attribute__((aligned));\n+int c[1024] __attribute__((aligned));\n+int d[1024] __attribute__((aligned));\n+int e[1024] __attribute__((aligned));\n+\n+void __attribute__((noinline))\n+foo (void)\n+{\n+  int i, g;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      g = a[i] + b[i] + c[i] * d[i];;\n+      e[i] = g < 10 ? 1 : g;\n+    }\n+}\n+\n+void __attribute__((noinline))\n+bar (void)\n+{\n+  int i, g;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      g = a[i] + b[i] + c[i] * d[i];;\n+      if (g < 10)\n+\te[i] = 1;\n+      else\n+\te[i] = g;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+  check_vect ();\n+  for (i = 0; i < 1024; i++)\n+    {\n+      asm volatile (\"\" : \"+r\" (i));\n+      a[i] = i % 10;\n+      b[i] = i % 10;\n+      c[i] = 1;\n+      d[i] = -1;\n+      e[i] = -1;\n+    }\n+  foo ();\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int g;\n+      asm volatile (\"\" : \"+r\" (i));\n+      g = 2 * (i % 10) - 1;\n+      if (e[i] != (g < 10 ? 1 : g))\n+\tabort ();\n+      e[i] = -1;\n+    }\n+  bar ();\n+  for (i = 0; i < 1024; i++)\n+    {\n+      int g;\n+      asm volatile (\"\" : \"+r\" (i));\n+      g = 2 * (i % 10) - 1;\n+      if (e[i] != (g < 10 ? 1 : g))\n+\tabort ();\n+    }\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\"  } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "d197bdd207ac471038024adf5e2836ff7b0bd20c", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 137, "deletions": 15, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23782cc3783c2040847d5f21d774436e1ecc8535/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=23782cc3783c2040847d5f21d774436e1ecc8535", "patch": "@@ -1,6 +1,6 @@\n /* Optimization of PHI nodes by converting them into straightline code.\n-   Copyright (C) 2004, 2005, 2006, 2007, 2008 Free Software Foundation,\n-   Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -47,6 +47,7 @@ static bool abs_replacement (basic_block, basic_block,\n \t\t\t     edge, edge, gimple, tree, tree);\n static bool cond_store_replacement (basic_block, basic_block, edge, edge,\n \t\t\t\t    struct pointer_set_t *);\n+static bool cond_if_else_store_replacement (basic_block, basic_block, basic_block);\n static struct pointer_set_t * get_non_trapping (void);\n static void replace_phi_edge_with_variable (basic_block, edge, gimple, tree);\n \n@@ -149,7 +150,7 @@ tree_ssa_phiopt (void)\n      bb0:\n        if (cond) goto bb2; else goto bb1;\n      bb1:\n-       *p = RHS\n+       *p = RHS;\n      bb2:\n \n    with\n@@ -160,10 +161,28 @@ tree_ssa_phiopt (void)\n        condtmp' = *p;\n      bb2:\n        condtmp = PHI <RHS, condtmp'>\n-       *p = condtmp\n+       *p = condtmp;\n \n    This transformation can only be done under several constraints,\n-   documented below.  */\n+   documented below.  It also replaces:\n+\n+     bb0:\n+       if (cond) goto bb2; else goto bb1;\n+     bb1:\n+       *p = RHS1;\n+       goto bb3;\n+     bb2:\n+       *p = RHS2;\n+     bb3:\n+\n+   with\n+\n+     bb0:\n+       if (cond) goto bb3; else goto bb1;\n+     bb1:\n+     bb3:\n+       condtmp = PHI <RHS1, RHS2>\n+       *p = condtmp;  */\n \n static unsigned int\n tree_ssa_cs_elim (void)\n@@ -248,8 +267,23 @@ tree_ssa_phiopt_worker (bool do_store_elim)\n \t  e1 = e2;\n \t  e2 = e_tmp;\n \t}\n+      else if (do_store_elim\n+\t       && EDGE_SUCC (bb1, 0)->dest == EDGE_SUCC (bb2, 0)->dest)\n+\t{\n+\t  basic_block bb3 = EDGE_SUCC (bb1, 0)->dest;\n+\n+\t  if (!single_succ_p (bb1)\n+\t      || (EDGE_SUCC (bb1, 0)->flags & EDGE_FALLTHRU) == 0\n+\t      || !single_succ_p (bb2)\n+\t      || (EDGE_SUCC (bb2, 0)->flags & EDGE_FALLTHRU) == 0\n+\t      || EDGE_COUNT (bb3->preds) != 2)\n+\t    continue;\n+\t  if (cond_if_else_store_replacement (bb1, bb2, bb3))\n+\t    cfgchanged = true;\n+\t  continue;\n+\t}\n       else\n-        continue;\n+\tcontinue;      \n \n       e1 = EDGE_SUCC (bb1, 0);\n \n@@ -1190,26 +1224,20 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   gimple newphi, new_stmt;\n   gimple_stmt_iterator gsi;\n   source_location locus;\n-  enum tree_code code;\n \n   /* Check if middle_bb contains of only one store.  */\n   if (!assign\n-      || gimple_code (assign) != GIMPLE_ASSIGN)\n+      || !gimple_assign_single_p (assign))\n     return false;\n \n   locus = gimple_location (assign);\n   lhs = gimple_assign_lhs (assign);\n   rhs = gimple_assign_rhs1 (assign);\n   if (TREE_CODE (lhs) != MEM_REF\n-      || TREE_CODE (TREE_OPERAND (lhs, 0)) != SSA_NAME)\n-    return false;\n-\n-  /* RHS is either a single SSA_NAME or a constant of register type. */\n-  code = gimple_assign_rhs_code (assign);\n-  if (get_gimple_rhs_class (code) != GIMPLE_SINGLE_RHS\n-      || (code != SSA_NAME && !is_gimple_min_invariant (rhs))\n+      || TREE_CODE (TREE_OPERAND (lhs, 0)) != SSA_NAME\n       || !is_gimple_reg_type (TREE_TYPE (lhs)))\n     return false;\n+\n   /* Prove that we can move the store down.  We could also check\n      TREE_THIS_NOTRAP here, but in that case we also could move stores,\n      whose value is not available readily, which we want to avoid.  */\n@@ -1221,6 +1249,7 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   gsi = gsi_for_stmt (assign);\n   unlink_stmt_vdef (assign);\n   gsi_remove (&gsi, true);\n+  release_defs (assign);\n \n   /* 2) Create a temporary where we can store the old content\n         of the memory touched by the store, if we need to.  */\n@@ -1263,6 +1292,99 @@ cond_store_replacement (basic_block middle_bb, basic_block join_bb,\n   return true;\n }\n \n+/* Do the main work of conditional store replacement.  We already know\n+   that the recognized pattern looks like so:\n+\n+   split:\n+     if (cond) goto THEN_BB; else goto ELSE_BB (edge E1)\n+   THEN_BB:\n+     X = Y;\n+     goto JOIN_BB;\n+   ELSE_BB:\n+     X = Z;\n+     fallthrough (edge E0)\n+   JOIN_BB:\n+     some more\n+\n+   We check that THEN_BB and ELSE_BB contain only one store\n+   that the stores have a \"simple\" RHS.  */\n+\n+static bool\n+cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n+\t\t\t\tbasic_block join_bb)\n+{\n+  gimple then_assign = last_and_only_stmt (then_bb);\n+  gimple else_assign = last_and_only_stmt (else_bb);\n+  tree lhs_base, lhs, then_rhs, else_rhs;\n+  source_location then_locus, else_locus;\n+  gimple_stmt_iterator gsi;\n+  gimple newphi, new_stmt;\n+\n+  /* Check if then_bb and else_bb contain only one store each.  */\n+  if (then_assign == NULL\n+      || !gimple_assign_single_p (then_assign)\n+      || else_assign == NULL\n+      || !gimple_assign_single_p (else_assign))\n+    return false;\n+\n+  lhs = gimple_assign_lhs (then_assign);\n+  if (!is_gimple_reg_type (TREE_TYPE (lhs))\n+      || !operand_equal_p (lhs, gimple_assign_lhs (else_assign), 0))\n+    return false;\n+\n+  lhs_base = get_base_address (lhs);\n+  if (lhs_base == NULL_TREE\n+      || (!DECL_P (lhs_base) && TREE_CODE (lhs_base) != MEM_REF))\n+    return false;\n+\n+  then_rhs = gimple_assign_rhs1 (then_assign);\n+  else_rhs = gimple_assign_rhs1 (else_assign);\n+  then_locus = gimple_location (then_assign);\n+  else_locus = gimple_location (else_assign);\n+\n+  /* Now we've checked the constraints, so do the transformation:\n+     1) Remove the stores.  */\n+  gsi = gsi_for_stmt (then_assign);\n+  unlink_stmt_vdef (then_assign);\n+  gsi_remove (&gsi, true);\n+  release_defs (then_assign);\n+\n+  gsi = gsi_for_stmt (else_assign);\n+  unlink_stmt_vdef (else_assign);\n+  gsi_remove (&gsi, true);\n+  release_defs (else_assign);\n+\n+  /* 2) Create a temporary where we can store the old content\n+\tof the memory touched by the store, if we need to.  */\n+  if (!condstoretemp || TREE_TYPE (lhs) != TREE_TYPE (condstoretemp))\n+    {\n+      condstoretemp = create_tmp_reg (TREE_TYPE (lhs), \"cstore\");\n+      get_var_ann (condstoretemp);\n+    }\n+  add_referenced_var (condstoretemp);\n+\n+  /* 3) Create a PHI node at the join block, with one argument\n+\tholding the old RHS, and the other holding the temporary\n+\twhere we stored the old memory contents.  */\n+  newphi = create_phi_node (condstoretemp, join_bb);\n+  add_phi_arg (newphi, then_rhs, EDGE_SUCC (then_bb, 0), then_locus);\n+  add_phi_arg (newphi, else_rhs, EDGE_SUCC (else_bb, 0), else_locus);\n+\n+  new_stmt = gimple_build_assign (lhs, PHI_RESULT (newphi));\n+\n+  /* 4) Insert that PHI node.  */\n+  gsi = gsi_after_labels (join_bb);\n+  if (gsi_end_p (gsi))\n+    {\n+      gsi = gsi_last_bb (join_bb);\n+      gsi_insert_after (&gsi, new_stmt, GSI_NEW_STMT);\n+    }\n+  else\n+    gsi_insert_before (&gsi, new_stmt, GSI_NEW_STMT);\n+\n+  return true;\n+}\n+\n /* Always do these optimizations if we have SSA\n    trees to work on.  */\n static bool"}]}