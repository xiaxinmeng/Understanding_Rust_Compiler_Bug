{"sha": "73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNjZDUxNGFiNWFjM2Q3M2YwYTllOGZjZjcyZmFkMWE4NTllNTAyMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-05-27T09:14:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-05-27T09:14:30Z"}, "message": "trans.c (gnat_to_gnu): Convert the count to the unsigned version of its base type before proceeding.\n\n\t* gcc-interface/trans.c (gnat_to_gnu) <Shift operations>: Convert the\n\tcount to the unsigned version of its base type before proceeding.\n\nFrom-SVN: r271646", "tree": {"sha": "b5dc73d98aedcd120f7b6282703e128a6cdb8e7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5dc73d98aedcd120f7b6282703e128a6cdb8e7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022/comments", "author": null, "committer": null, "parents": [{"sha": "3aad84a49e51a0cd5bfae5176c5311303ebfb8a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aad84a49e51a0cd5bfae5176c5311303ebfb8a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aad84a49e51a0cd5bfae5176c5311303ebfb8a7"}], "stats": {"total": 66, "additions": 37, "deletions": 29}, "files": [{"sha": "b07c2ce3e1e4310405528931fc90df31e4e6ecfb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022", "patch": "@@ -1,3 +1,8 @@\n+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/trans.c (gnat_to_gnu) <Shift operations>: Convert the\n+\tcount to the unsigned version of its base type before proceeding.\n+\n 2019-05-16  Martin Sebor  <msebor@redhat.com>\n \n \t* gcc-interface/trans.c (check_inlining_for_nested_subprog): Quote"}, {"sha": "4df0dfaae02d8bd73074a288a628a36ef0fd90f5", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 32, "deletions": 29, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=73cd514ab5ac3d73f0a9e8fcf72fad1a859e5022", "patch": "@@ -7422,7 +7422,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \tenum tree_code code = gnu_codes[kind];\n \tbool ignore_lhs_overflow = false;\n \tlocation_t saved_location = input_location;\n-\ttree gnu_type;\n+\ttree gnu_type, gnu_max_shift = NULL_TREE;\n \n \t/* Fix operations set up for boolean types in GNU_CODES above.  */\n \tif (Is_Modular_Integer_Type (Underlying_Type (Etype (gnat_node))))\n@@ -7445,6 +7445,17 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_rhs = gnat_to_gnu (Right_Opnd (gnat_node));\n \tgnu_type = gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n+\t/* If this is a shift, take the count as unsigned since that is what\n+\t   most machines do and will generate simpler adjustments below.  */\n+\tif (IN (kind, N_Op_Shift))\n+\t  {\n+\t    tree gnu_count_type\n+\t      = gnat_unsigned_type_for (get_base_type (TREE_TYPE (gnu_rhs)));\n+\t    gnu_rhs = convert (gnu_count_type, gnu_rhs);\n+\t    gnu_max_shift\n+\t      = convert (TREE_TYPE (gnu_rhs), TYPE_SIZE (gnu_type));\n+\t  }\n+\n \t/* Pending generic support for efficient vector logical operations in\n \t   GCC, convert vectors to their representative array type view and\n \t   fallthrough.  */\n@@ -7468,25 +7479,20 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t/* If this is a shift whose count is not guaranteed to be correct,\n \t   we need to adjust the shift count.  */\n-\tif (IN (kind, N_Op_Shift) && !Shift_Count_OK (gnat_node))\n-\t  {\n-\t    tree gnu_count_type = get_base_type (TREE_TYPE (gnu_rhs));\n-\t    tree gnu_max_shift\n-\t      = convert (gnu_count_type, TYPE_SIZE (gnu_type));\n-\n-\t    if (kind == N_Op_Rotate_Left || kind == N_Op_Rotate_Right)\n-\t      gnu_rhs = build_binary_op (TRUNC_MOD_EXPR, gnu_count_type,\n-\t\t\t\t\t gnu_rhs, gnu_max_shift);\n-\t    else if (kind == N_Op_Shift_Right_Arithmetic)\n-\t      gnu_rhs\n-\t\t= build_binary_op\n-\t\t  (MIN_EXPR, gnu_count_type,\n-\t\t   build_binary_op (MINUS_EXPR,\n-\t\t\t\t    gnu_count_type,\n-\t\t\t\t    gnu_max_shift,\n-\t\t\t\t    build_int_cst (gnu_count_type, 1)),\n-\t\t   gnu_rhs);\n-\t  }\n+\tif ((kind == N_Op_Rotate_Left || kind == N_Op_Rotate_Right)\n+\t    && !Shift_Count_OK (gnat_node))\n+\t  gnu_rhs = build_binary_op (TRUNC_MOD_EXPR, TREE_TYPE (gnu_rhs),\n+\t\t\t\t     gnu_rhs, gnu_max_shift);\n+\telse if (kind == N_Op_Shift_Right_Arithmetic\n+\t\t && !Shift_Count_OK (gnat_node))\n+\t  gnu_rhs\n+\t    = build_binary_op (MIN_EXPR, TREE_TYPE (gnu_rhs),\n+\t\t\t       build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (gnu_rhs),\n+\t\t\t\t\t\tgnu_max_shift,\n+\t\t\t\t\t\tbuild_int_cst\n+\t\t\t\t\t\t(TREE_TYPE (gnu_rhs), 1)),\n+\t\t\t       gnu_rhs);\n \n \t/* For right shifts, the type says what kind of shift to do,\n \t   so we may need to choose a different type.  In this case,\n@@ -7533,18 +7539,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t/* If this is a logical shift with the shift count not verified,\n \t   we must return zero if it is too large.  We cannot compensate\n-\t   above in this case.  */\n+\t   beforehand in this case.  */\n \tif ((kind == N_Op_Shift_Left || kind == N_Op_Shift_Right)\n \t    && !Shift_Count_OK (gnat_node))\n \t  gnu_result\n-\t    = build_cond_expr\n-\t      (gnu_type,\n-\t       build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t\tgnu_rhs,\n-\t\t\t\tconvert (TREE_TYPE (gnu_rhs),\n-\t\t\t\t\t TYPE_SIZE (gnu_type))),\n-\t       build_int_cst (gnu_type, 0),\n-\t       gnu_result);\n+\t    = build_cond_expr (gnu_type,\n+\t\t\t       build_binary_op (GE_EXPR, boolean_type_node,\n+\t\t\t\t\t\tgnu_rhs, gnu_max_shift),\n+\t\t\t       build_int_cst (gnu_type, 0),\n+\t\t\t       gnu_result);\n       }\n       break;\n "}]}