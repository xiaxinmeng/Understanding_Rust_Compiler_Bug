{"sha": "01d93568e892e196fbc28454f9f9e3553cbfcd7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFkOTM1NjhlODkyZTE5NmZiYzI4NDU0ZjlmOWUzNTUzY2JmY2Q3ZQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-08-30T09:02:01Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2009-08-30T09:02:01Z"}, "message": "pack.m4 (pack_'rtype_code`): Use count_0 for counting true values in a logical array.\n\n2009-08-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\t* m4/pack.m4 (pack_'rtype_code`): Use count_0 for counting true\n\tvalues in a logical array.  Mark bounds checking tests as\n\tunlikely.\n\t* intrinsics/pack_generic.c (pack_internal): Likewise.\n\t* runtime/bounds.c (count_0):  Fix off-by-one error in detecting\n\tempty arrays.\n\t* generated/pack_c4.c: Regenerated.\n\t* generated/pack_c8.c: Regenerated.\n\t* generated/pack_c10.c: Regenerated.\n\t* generated/pack_c16.c: Regenerated.\n\t* generated/pack_i1.c: Regenerated.\n\t* generated/pack_i16.c: Regenerated.\n\t* generated/pack_i2.c: Regenerated.\n\t* generated/pack_i4.c: Regenerated.\n\t* generated/pack_i8.c: Regenerated.\n\t* generated/pack_r4.c: Regenerated.\n\t* generated/pack_r8.c: Regenerated.\n\t* generated/pack_r10.c: Regenerated.\n\t* generated/pack_r16.c: Regenerated.\n\nFrom-SVN: r151225", "tree": {"sha": "6f3af1ff5e03befb8f48fd165af7da8a30aacf8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f3af1ff5e03befb8f48fd165af7da8a30aacf8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01d93568e892e196fbc28454f9f9e3553cbfcd7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d93568e892e196fbc28454f9f9e3553cbfcd7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01d93568e892e196fbc28454f9f9e3553cbfcd7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01d93568e892e196fbc28454f9f9e3553cbfcd7e/comments", "author": null, "committer": null, "parents": [{"sha": "26ef2b4293ed8aa1d1cea04015d6d06dce5fd9d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26ef2b4293ed8aa1d1cea04015d6d06dce5fd9d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26ef2b4293ed8aa1d1cea04015d6d06dce5fd9d5"}], "stats": {"total": 947, "additions": 95, "deletions": 852}, "files": [{"sha": "f1ac312833b6bba84e759ffecd338ba73cbed815", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -1,3 +1,25 @@\n+2009-08-30  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\t* m4/pack.m4 (pack_'rtype_code`): Use count_0 for counting true\n+\tvalues in a logical array.  Mark bounds checking tests as\n+\tunlikely.\n+\t* intrinsics/pack_generic.c (pack_internal): Likewise.\n+\t* runtime/bounds.c (count_0):  Fix off-by-one error in detecting\n+\tempty arrays.\n+\t* generated/pack_c4.c: Regenerated.\n+\t* generated/pack_c8.c: Regenerated.\n+\t* generated/pack_c10.c: Regenerated.\n+\t* generated/pack_c16.c: Regenerated.\n+\t* generated/pack_i1.c: Regenerated.\n+\t* generated/pack_i16.c: Regenerated.\n+\t* generated/pack_i2.c: Regenerated.\n+\t* generated/pack_i4.c: Regenerated.\n+\t* generated/pack_i8.c: Regenerated.\n+\t* generated/pack_r4.c: Regenerated.\n+\t* generated/pack_r8.c: Regenerated.\n+\t* generated/pack_r10.c: Regenerated.\n+\t* generated/pack_r16.c: Regenerated.\n+\n 2009-08-25  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR libfortran/34670"}, {"sha": "cc66c538e1c065e2fc80d4522e663bc1978fd49c", "filename": "libgfortran/generated/pack_c10.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c10.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "9397262dd06d698f0bbb015e1db6239a78a80b15", "filename": "libgfortran/generated/pack_c16.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c16.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "093bdcc9a1d00c021d260ca2019a1a6b071b2457", "filename": "libgfortran/generated/pack_c4.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c4.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "7971e2ba1358f53d678405ef207e919ea48d69bd", "filename": "libgfortran/generated/pack_c8.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_c8.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "3e4647dbd5595a8fbcbdd773375fa75b51ede09c", "filename": "libgfortran/generated/pack_i1.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i1.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "99d3491c38f2859b8e5ff05a9cc2a606cfd32899", "filename": "libgfortran/generated/pack_i16.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i16.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "e796d169f76f199f62afbd7708c42654677cd153", "filename": "libgfortran/generated/pack_i2.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i2.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "91ce99fe4fd46fc146b635c014b605de36955a81", "filename": "libgfortran/generated/pack_i4.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i4.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "e49d8c29e95be438401838561e2a8f90aa8ec422", "filename": "libgfortran/generated/pack_i8.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_i8.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "f70c932640e1a849ca8fc82b5eb08c49cf45282b", "filename": "libgfortran/generated/pack_r10.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r10.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "ff2ad6e7eed654b88b7a663f8dbb6ad851327246", "filename": "libgfortran/generated/pack_r16.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r16.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "0c08b8c8c94d32a4f8c1f0607051e4adeb8cd088", "filename": "libgfortran/generated/pack_r4.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r4.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "2b307e29a2b7e8fe9dbe5c7bac903cbde3bc4f81", "filename": "libgfortran/generated/pack_r8.c", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fgenerated%2Fpack_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fpack_r8.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -138,7 +138,7 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -155,62 +155,10 @@ pack_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "eb52f069d407a01bc9213168574e5f4c590d46b6", "filename": "libgfortran/intrinsics/pack_generic.c", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fintrinsics%2Fpack_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fintrinsics%2Fpack_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fpack_generic.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -132,7 +132,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n   if (mstride[0] == 0)\n     mstride[0] = mask_kind;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -147,58 +147,7 @@ pack_internal (gfc_array_char *ret, const gfc_array_char *array,\n \t{\n \t  /* We have to count the true elements in MASK.  */\n \n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n+\t  total = count_0 (mask);\n \t}\n \n       if (ret->data == NULL)"}, {"sha": "c5fd2fd817d05da60719170e1502a634bdfbad5f", "filename": "libgfortran/m4/pack.m4", "status": "modified", "additions": 5, "deletions": 57, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fm4%2Fpack.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fm4%2Fpack.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fpack.m4?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -139,7 +139,7 @@ pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n   else\n     sptr = array->data;\n \n-  if (ret->data == NULL || compile_options.bounds_check)\n+  if (ret->data == NULL || unlikely (compile_options.bounds_check))\n     {\n       /* Count the elements, either for allocating memory or\n \t for bounds checking.  */\n@@ -156,62 +156,10 @@ pack_'rtype_code` ('rtype` *ret, const 'rtype` *array,\n \t    }\n \t}\n       else\n-\t{\n-\t  /* We have to count the true elements in MASK.  */\n-\n-\t  /* TODO: We could speed up pack easily in the case of only\n-\t     few .TRUE. entries in MASK, by keeping track of where we\n-\t     would be in the source array during the initial traversal\n-\t     of MASK, and caching the pointers to those elements. Then,\n-\t     supposed the number of elements is small enough, we would\n-\t     only have to traverse the list, and copy those elements\n-\t     into the result array. In the case of datatypes which fit\n-\t     in one of the integer types we could also cache the\n-\t     value instead of a pointer to it.\n-\t     This approach might be bad from the point of view of\n-\t     cache behavior in the case where our cache is not big\n-\t     enough to hold all elements that have to be copied.  */\n-\n-\t  const GFC_LOGICAL_1 *m = mptr;\n-\n-\t  total = 0;\n-\t  if (zero_sized)\n-\t    m = NULL;\n-\n-\t  while (m)\n-\t    {\n-\t      /* Test this element.  */\n-\t      if (*m)\n-\t\ttotal++;\n-\n-\t      /* Advance to the next element.  */\n-\t      m += mstride[0];\n-\t      count[0]++;\n-\t      n = 0;\n-\t      while (count[n] == extent[n])\n-\t\t{\n-\t\t  /* When we get to the end of a dimension, reset it\n-\t\t     and increment the next dimension.  */\n-\t\t  count[n] = 0;\n-\t\t  /* We could precalculate this product, but this is a\n-\t\t     less frequently used path so probably not worth\n-\t\t     it.  */\n-\t\t  m -= mstride[n] * extent[n];\n-\t\t  n++;\n-\t\t  if (n >= dim)\n-\t\t    {\n-\t\t      /* Break out of the loop.  */\n-\t\t      m = NULL;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      count[n]++;\n-\t\t      m += mstride[n];\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n+        {\n+      \t  /* We have to count the true elements in MASK.  */\n+\t  total = count_0 (mask);\n+        }\n \n       if (ret->data == NULL)\n \t{"}, {"sha": "35bfa1e2a465177c548e75dcc1ac24455a6d87c5", "filename": "libgfortran/runtime/bounds.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fruntime%2Fbounds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01d93568e892e196fbc28454f9f9e3553cbfcd7e/libgfortran%2Fruntime%2Fbounds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2Fbounds.c?ref=01d93568e892e196fbc28454f9f9e3553cbfcd7e", "patch": "@@ -237,7 +237,7 @@ index_type count_0 (const gfc_array_l1 * array)\n       extent[n] = GFC_DESCRIPTOR_EXTENT(array,n);\n       count[n] = 0;\n \n-      if (extent[n] < 0)\n+      if (extent[n] <= 0)\n \treturn 0;\n     }\n "}]}