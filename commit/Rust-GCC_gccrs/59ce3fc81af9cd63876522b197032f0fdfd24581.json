{"sha": "59ce3fc81af9cd63876522b197032f0fdfd24581", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTljZTNmYzgxYWY5Y2Q2Mzg3NjUyMmIxOTcwMzJmMGZkZmQyNDU4MQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-15T17:27:29Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-04-15T17:27:29Z"}, "message": "(IS_ID, IS_PROTOCOL_QUALIFIED_ID, IS_SUPER): New type checking macros.\n\n(IS_ID, IS_PROTOCOL_QUALIFIED_ID, IS_SUPER): New type\n        checking macros.\n        (objc_comptypes, build_message_expr, gen_declspecs): Use them.\n(IS_ID, IS_PROTOCOL_QUALIFIED_ID, IS_SUPER): New type\n        checking macros.\n        (objc_comptypes, build_message_expr, gen_declspecs): Use them.\n(gen_declarator): Don't use strcpy's return value.\n(build_message_expr): Allow any type that matches\n        objc_class_type.\n(get_class_reference): We already have a name.\n(build_objc_string): Use TREE_SET_CODE instead of\n        assigning to TREE_CODE.\n        (build_objc_string_object): Ditto.\n\nFrom-SVN: r4158", "tree": {"sha": "58d1339cf61fd8a0f714cadddd0d82b5ab49e1cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58d1339cf61fd8a0f714cadddd0d82b5ab49e1cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59ce3fc81af9cd63876522b197032f0fdfd24581", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ce3fc81af9cd63876522b197032f0fdfd24581", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59ce3fc81af9cd63876522b197032f0fdfd24581", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59ce3fc81af9cd63876522b197032f0fdfd24581/comments", "author": null, "committer": null, "parents": [{"sha": "469778e2760f7169a0d94fbae49e25e73246dc76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/469778e2760f7169a0d94fbae49e25e73246dc76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/469778e2760f7169a0d94fbae49e25e73246dc76"}], "stats": {"total": 108, "additions": 57, "deletions": 51}, "files": [{"sha": "d2cb9609bac442285bf7a4839ed6e97bc3bfb815", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 57, "deletions": 51, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59ce3fc81af9cd63876522b197032f0fdfd24581/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59ce3fc81af9cd63876522b197032f0fdfd24581/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=59ce3fc81af9cd63876522b197032f0fdfd24581", "patch": "@@ -334,6 +334,7 @@ static char* TAG_EXECCLASS;\n #define TREE_STATIC_TEMPLATE(record_type) (TREE_PUBLIC (record_type))\n #define TYPED_OBJECT(type) \\\n        (TREE_CODE (type) == RECORD_TYPE && TREE_STATIC_TEMPLATE (type))\n+\n /* Some commonly used instances of \"identifier_node\".  */\n \n static tree self_id, ucmd_id;\n@@ -344,6 +345,15 @@ static tree objc_get_class_decl, objc_get_meta_class_decl;\n static tree super_type, selector_type, id_type, objc_class_type;\n static tree instance_type, protocol_type;\n \n+/* Type checking macros.  */\n+\n+#define IS_ID(TYPE) \\\n+  (TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (id_type))\n+#define IS_PROTOCOL_QUALIFIED_ID(TYPE) \\\n+  (IS_ID (TYPE) && TYPE_PROTOCOL_LIST (TYPE))\n+#define IS_SUPER(TYPE) \\\n+  (super_type && TYPE_MAIN_VARIANT (TYPE) == TYPE_MAIN_VARIANT (super_type))\n+\n static tree class_chain = NULLT;\n static tree alias_chain = NULLT;\n static tree interface_chain = NULLT;\n@@ -665,10 +675,8 @@ objc_comptypes (lhs, rhs, reflexive)\n       && TREE_CODE (rhs) == POINTER_TYPE\n       && TREE_CODE (TREE_TYPE (rhs)) == RECORD_TYPE)\n     {\n-      int lhs_is_proto = (TYPE_MAIN_VARIANT (lhs) == TYPE_MAIN_VARIANT (id_type)\n-\t\t\t  && TYPE_PROTOCOL_LIST (lhs));\n-      int rhs_is_proto = (TYPE_MAIN_VARIANT (rhs) == TYPE_MAIN_VARIANT (id_type)\n-\t\t\t  && TYPE_PROTOCOL_LIST (rhs));\n+      int lhs_is_proto = IS_PROTOCOL_QUALIFIED_ID (lhs);\n+      int rhs_is_proto = IS_PROTOCOL_QUALIFIED_ID (rhs);\n \n       if (lhs_is_proto)\n         {\n@@ -1112,7 +1120,7 @@ build_objc_string (len, str)\n {\n   tree s = build_string (len, str);\n \n-  TREE_CODE (s) = OBJC_STRING_CST;\n+  TREE_SET_CODE (s, OBJC_STRING_CST);\n   return s;\n }\n \n@@ -1144,7 +1152,7 @@ build_objc_string_object (strings)\n \n   /* combine_strings will work for OBJC_STRING_CST's too.  */\n   string = combine_strings (strings);\n-  TREE_CODE (string) = STRING_CST;\n+  TREE_SET_CODE (string, STRING_CST);\n   length = TREE_STRING_LENGTH (string) - 1;\n \n   /* & ((NXConstantString) {0, string, length})  */\n@@ -1855,7 +1863,7 @@ get_class_reference (ident)\n     {\n       tree params;\n \n-      add_class_reference (CLASS_NAME (ident));\n+      add_class_reference (ident);\n \n       params = build_tree_list (NULLT,\n \t\t\t\tmy_build_string (IDENTIFIER_LENGTH (ident) + 1,\n@@ -2535,9 +2543,9 @@ hack_method_prototype (nst_methods, tmp_decl)\n   tree parms;\n \n   /* Hack to avoid problem with static typing of self arg. */\n-  TREE_CODE (nst_methods) = CLASS_METHOD_DECL;\n+  TREE_SET_CODE (nst_methods, CLASS_METHOD_DECL);\n   start_method_def (nst_methods);\n-  TREE_CODE (nst_methods) = INSTANCE_METHOD_DECL;\n+  TREE_SET_CODE (nst_methods, INSTANCE_METHOD_DECL);\n \n   if (METHOD_ADD_ARGS (nst_methods) == (tree) 1)\n     parms = get_parm_info (0); /* we have a `, ...' */\n@@ -4106,16 +4114,11 @@ get_arg_type_list (meth, context, superflag)\n \n   /* receiver type */\n   if (flag_next_runtime && superflag)\n-    {\n-      arglist = build_tree_list (NULLT, super_type);\n-    }\n+    arglist = build_tree_list (NULLT, super_type);\n+  else if (context == METHOD_DEF)\n+    arglist = build_tree_list (NULLT, TREE_TYPE (self_decl));\n   else\n-    {\n-      if (context == METHOD_DEF)\n-\targlist = build_tree_list (NULLT, TREE_TYPE (self_decl));\n-      else\n-\targlist = build_tree_list (NULLT, id_type);\n-    }\n+    arglist = build_tree_list (NULLT, id_type);\n \n   /* selector type - will eventually change to `int' */\n   chainon (arglist, build_tree_list (NULLT, selector_type));\n@@ -4171,27 +4174,29 @@ check_duplicates (hsh)\n   return meth;\n }\n \n+/* If RECEIVER is a class reference, return the identifier node for the\n+   referenced class.  RECEIVER is created by get_class_reference, so we\n+   check the exact form created depending on which runtimes are used.  */\n+\n static tree\n receiver_is_class_object (receiver)\n       tree receiver;\n {\n+  tree chain, exp, arg;\n   if (flag_next_runtime)\n     {\n-      tree chain;\n+      /* The receiver is a variable created by build_class_reference_decl.  */\n       if (TREE_CODE (receiver) == VAR_DECL\n \t  && TREE_TYPE (receiver) == objc_class_type)\n-\t/* Look up the identifier corresponding to this string decl. */\n-\tfor (chain = class_names_chain; chain; chain = TREE_CHAIN (chain))\n+\t/* Look up the identifier. */\n+\tfor (chain = cls_ref_chain; chain; chain = TREE_CHAIN (chain))\n \t  if (TREE_PURPOSE (chain) == receiver)\n \t    return TREE_VALUE (chain);\n     }\n   else\n     {\n-      /* The receiver is a function call that returns an id...\n-\t ...check if it is a call to objc_getClass, if so, give it\n-\t special treatment.  */\n-      tree exp, arg;\n-\n+      /* The receiver is a function call that returns an id.  Check if\n+\t it is a call to objc_getClass, if so, pick up the class name.  */\n       if ((exp = TREE_OPERAND (receiver, 0))\n \t  && TREE_CODE (exp) == ADDR_EXPR\n \t  && (exp = TREE_OPERAND (exp, 0))\n@@ -4200,14 +4205,15 @@ receiver_is_class_object (receiver)\n \t  /* we have a call to objc_getClass! */\n \t  && (arg = TREE_OPERAND (receiver, 1))\n \t  && TREE_CODE (arg) == TREE_LIST\n-\t  && (arg = TREE_VALUE (arg))\n-\t  && TREE_CODE (arg) == NOP_EXPR\n-\t  && (arg = TREE_OPERAND (arg, 0))\n-\t  && TREE_CODE (arg) == ADDR_EXPR\n-\t  && (arg = TREE_OPERAND (arg, 0))\n-\t  && TREE_CODE (arg) == STRING_CST)\n-\t/* finally, we have the class name */\n-\treturn get_identifier (TREE_STRING_POINTER (arg));\n+\t  && (arg = TREE_VALUE (arg)))\n+\t{\n+\t  STRIP_NOPS (arg);\n+\t  if (TREE_CODE (arg) == ADDR_EXPR\n+\t      && (arg = TREE_OPERAND (arg, 0))\n+\t      && TREE_CODE (arg) == STRING_CST)\n+\t    /* finally, we have the class name */\n+\t    return get_identifier (TREE_STRING_POINTER (arg));\n+\t}\n     }\n   return 0;\n }\n@@ -4256,7 +4262,7 @@ build_message_expr (mess)\n \n   /* determine receiver type */\n   rtype = TREE_TYPE (receiver);\n-  super = (TREE_TYPE (receiver) == super_type);\n+  super = IS_SUPER (rtype);\n \n   if (! super)\n     {\n@@ -4265,14 +4271,13 @@ build_message_expr (mess)\n       else if (TREE_CODE (rtype) == POINTER_TYPE\n \t       && TREE_STATIC_TEMPLATE (TREE_TYPE (rtype)))\n \tstatically_typed = 1;\n-      /* classfix -smn */\n       else if ((flag_next_runtime\n-\t\t|| (TREE_CODE (receiver) == CALL_EXPR\n-\t\t    && TYPE_MAIN_VARIANT (rtype) == TYPE_MAIN_VARIANT (id_type)))\n+\t\t|| (TREE_CODE (receiver) == CALL_EXPR && IS_ID (rtype)))\n \t       && (class_ident = receiver_is_class_object (receiver)))\n \t;\n-      else if (TYPE_MAIN_VARIANT (rtype) != TYPE_MAIN_VARIANT (id_type)\n-\t       && TYPE_MAIN_VARIANT (rtype) != TYPE_MAIN_VARIANT (objc_class_type))\n+      else if (! IS_ID (rtype)\n+\t       /* Allow any type that matches objc_class_type.  */\n+\t       && ! comptypes (rtype, objc_class_type))\n \t{\n \t  bzero (errbuf, BUFSIZE);\n \t  warning (\"invalid receiver type `%s'\",\n@@ -4330,8 +4335,7 @@ build_message_expr (mess)\n \n   /* Determine operation return type.  */\n \n-  if (super_type != 0\n-      && TYPE_MAIN_VARIANT (rtype) == TYPE_MAIN_VARIANT (super_type))\n+  if (IS_SUPER (rtype))\n     {\n       tree iface;\n \n@@ -4451,8 +4455,7 @@ build_message_expr (mess)\n \t\t   IDENTIFIER_POINTER (sel_name));\n \t}\n     }\n-  else if (TYPE_MAIN_VARIANT (rtype) == TYPE_MAIN_VARIANT (id_type)\n-\t   && TYPE_PROTOCOL_LIST (rtype))\n+  else if (IS_PROTOCOL_QUALIFIED_ID (rtype))\n     {\n       /* An anonymous object that has been qualified with a protocol.  */\n \n@@ -6606,8 +6609,7 @@ is_complex_decl (type)\n {\n   return (TREE_CODE (type) == ARRAY_TYPE\n \t  || TREE_CODE (type) == FUNCTION_TYPE\n-\t  || (TREE_CODE (type) == POINTER_TYPE\n-\t      && TYPE_MAIN_VARIANT (type) != TYPE_MAIN_VARIANT (id_type)));\n+\t  || (TREE_CODE (type) == POINTER_TYPE && ! IS_ID (type)));\n }\n \n \f\n@@ -6752,7 +6754,8 @@ gen_declarator (decl, buf, name)\n \tcase ARRAY_TYPE:\n \tcase FUNCTION_TYPE:\n \tcase POINTER_TYPE:\n-\t  str = strcpy (buf, name);\n+\t  strcpy (buf, name);\n+\t  str = buf;\n \n \t  /* this clause is done iteratively...rather than recursively */\n \t  do\n@@ -6782,13 +6785,17 @@ gen_declarator (decl, buf, name)\n \n \tcase IDENTIFIER_NODE:\n \t  /* will only happen if we are processing a \"raw\" expr-decl. */\n-\t  return strcpy (buf, IDENTIFIER_POINTER (decl));\n+\t  strcpy (buf, IDENTIFIER_POINTER (decl));\n+\t  return buf;\n \t}\n \n       return str;\n     }\n   else\t\t\t/* we have an abstract declarator or a _DECL node */\n-    return strcpy (buf, name);\n+    {\n+      strcpy (buf, name);\n+      return buf;\n+    }\n }\n \n static void\n@@ -6864,8 +6871,7 @@ gen_declspecs (declspecs, buf, raw)\n \t      strcat (buf, IDENTIFIER_POINTER (DECL_NAME (aspec)));\n \t    }\n \t  /* NEW!!! */\n-\t  else if (TREE_CODE (aspec) == POINTER_TYPE\n-\t\t   && TYPE_MAIN_VARIANT (aspec) == TYPE_MAIN_VARIANT (id_type))\n+\t  else if (IS_ID (aspec))\n \t    {\n \t      tree protocol_list = TYPE_PROTOCOL_LIST (aspec);\n "}]}