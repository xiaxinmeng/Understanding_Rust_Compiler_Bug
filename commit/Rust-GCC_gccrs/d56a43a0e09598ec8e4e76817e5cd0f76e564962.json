{"sha": "d56a43a0e09598ec8e4e76817e5cd0f76e564962", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2YTQzYTBlMDk1OThlYzhlNGU3NjgxN2U1Y2QwZjc2ZTU2NDk2Mg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "Andreas.Krebbel@de.ibm.com", "date": "2014-05-05T07:55:26Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2014-05-05T07:55:26Z"}, "message": "target.def: Add new target hook.\n\n2014-05-05  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* target.def: Add new target hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_keep_leaf_when_profiled): Add prototype.\n\t* targhooks.c (default_keep_leaf_when_profiled): New function.\n\n\t* config/s390/s390.c (s390_keep_leaf_when_profiled): New function.\n\t(TARGET_KEEP_LEAF_WHEN_PROFILED): Define.\n\n2014-05-05  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n\n\t* gcc.target/s390/leaf-profile.c: New testcase.\n\nFrom-SVN: r210061", "tree": {"sha": "17925abdca6968e0293ace7cac7077c037baa800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17925abdca6968e0293ace7cac7077c037baa800"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d56a43a0e09598ec8e4e76817e5cd0f76e564962", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56a43a0e09598ec8e4e76817e5cd0f76e564962", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d56a43a0e09598ec8e4e76817e5cd0f76e564962", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d56a43a0e09598ec8e4e76817e5cd0f76e564962/comments", "author": null, "committer": null, "parents": [{"sha": "f668cd6f2be34526a20dcedff00cac876c6760c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f668cd6f2be34526a20dcedff00cac876c6760c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f668cd6f2be34526a20dcedff00cac876c6760c6"}], "stats": {"total": 67, "additions": 66, "deletions": 1}, "files": [{"sha": "66068c3baad777ddf05a5069d8400edf9a5bb750", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -1,3 +1,13 @@\n+2014-05-05  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* target.def: Add new target hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_keep_leaf_when_profiled): Add prototype.\n+\t* targhooks.c (default_keep_leaf_when_profiled): New function.\n+\n+\t* config/s390/s390.c (s390_keep_leaf_when_profiled): New function.\n+\t(TARGET_KEEP_LEAF_WHEN_PROFILED): Define.\n+\n 2014-05-05  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/60363"}, {"sha": "557f0dbc6e5d514b67c2a91dedce10ead86ab20e", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -10160,6 +10160,14 @@ s390_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n     return const0_rtx;\n }\n \n+/* We call mcount before the function prologue.  So a profiled leaf\n+   function should stay a leaf function.  */\n+\n+static bool\n+s390_keep_leaf_when_profiled ()\n+{\n+  return true;\n+}\n \n /* Output assembly code for the trampoline template to\n    stdio stream FILE.\n@@ -12163,6 +12171,9 @@ s390_option_override (void)\n #undef TARGET_LIBCALL_VALUE\n #define TARGET_LIBCALL_VALUE s390_libcall_value\n \n+#undef TARGET_KEEP_LEAF_WHEN_PROFILED\n+#define TARGET_KEEP_LEAF_WHEN_PROFILED s390_keep_leaf_when_profiled\n+\n #undef TARGET_FIXED_CONDITION_CODE_REGS\n #define TARGET_FIXED_CONDITION_CODE_REGS s390_fixed_condition_code_regs\n "}, {"sha": "cdc272e0254bba59a043413a1cf153848be3b9c4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -4953,6 +4953,10 @@ Define this macro if the code for function profiling should come before\n the function prologue.  Normally, the profiling code comes after.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_KEEP_LEAF_WHEN_PROFILED (void)\n+This target hook returns true if the target wants the leaf flag for the current function to stay true even if it calls mcount.  This might make sense for targets using the leaf flag only to determine whether a stack frame needs to be generated or not and for which the call to mcount is generated before the function prologue.\n+@end deftypefn\n+\n @node Tail Calls\n @subsection Permitting tail calls\n @cindex tail calls"}, {"sha": "efd49639848c85274332df2be385dd2f6b2b2fc2", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -3963,6 +3963,8 @@ Define this macro if the code for function profiling should come before\n the function prologue.  Normally, the profiling code comes after.\n @end defmac\n \n+@hook TARGET_KEEP_LEAF_WHEN_PROFILED\n+\n @node Tail Calls\n @subsection Permitting tail calls\n @cindex tail calls"}, {"sha": "cf649fbd1559d7b6689a7b936f45843291b435d1", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -4241,7 +4241,9 @@ leaf_function_p (void)\n {\n   rtx insn;\n \n-  if (crtl->profile || profile_arc_flag)\n+  /* Some back-ends (e.g. s390) want leaf functions to stay leaf\n+     functions even if they call mcount.  */\n+  if (crtl->profile && !targetm.keep_leaf_when_profiled ())\n     return 0;\n \n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))"}, {"sha": "793f12ddfe1a1194d1a69d7c28647c4901324db5", "filename": "gcc/target.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -2658,6 +2658,18 @@ The default version of this hook use the target macro\\n\\\n  bool, (void),\n  default_profile_before_prologue)\n \n+/* Return true if a leaf function should stay leaf even with profiling\n+   enabled.  */\n+DEFHOOK\n+(keep_leaf_when_profiled,\n+ \"This target hook returns true if the target wants the leaf flag for\\\n+ the current function to stay true even if it calls mcount.  This might\\\n+ make sense for targets using the leaf flag only to determine whether a\\\n+ stack frame needs to be generated or not and for which the call to\\\n+ mcount is generated before the function prologue.\",\n+ bool, (void),\n+ default_keep_leaf_when_profiled)\n+\n /* Modify and return the identifier of a DECL's external name,\n    originally identified by ID, as required by the target,\n    (eg, append @nn to windows32 stdcall function names)."}, {"sha": "0be1978aa5ff1731100831935f4210dac721906e", "filename": "gcc/targhooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -1447,6 +1447,15 @@ default_get_reg_raw_mode (int regno)\n   return reg_raw_mode[regno];\n }\n \n+/* Return true if a leaf function should stay leaf even with profiling\n+   enabled.  */\n+\n+bool\n+default_keep_leaf_when_profiled ()\n+{\n+  return false;\n+}\n+\n /* Return true if the state of option OPTION should be stored in PCH files\n    and checked by default_pch_valid_p.  Store the option's current state\n    in STATE if so.  */"}, {"sha": "dbaa1dc5f5c312876efbc896ae1d8d3ffa8366d9", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -195,6 +195,7 @@ extern int default_jump_align_max_skip (rtx);\n extern section * default_function_section(tree decl, enum node_frequency freq,\n \t\t\t\t\t  bool startup, bool exit);\n extern enum machine_mode default_get_reg_raw_mode (int);\n+extern bool default_keep_leaf_when_profiled ();\n \n extern void *default_get_pch_validity (size_t *);\n extern const char *default_pch_valid_p (const void *, size_t);"}, {"sha": "ce105724f6960339343ac654723668285787741b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -1,3 +1,7 @@\n+2014-05-05  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n+\n+\t* gcc.target/s390/leaf-profile.c: New testcase.\n+\n 2014-05-05  Andreas Krebbel  <Andreas.Krebbel@de.ibm.com>\n \n \t* gcc.dg/hoist-register-pressure-1.c: Replace int with long."}, {"sha": "604774007575d9a4396fd37308daf0a0a996586b", "filename": "gcc/testsuite/gcc.target/s390/leaf-profile.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fleaf-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d56a43a0e09598ec8e4e76817e5cd0f76e564962/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fleaf-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fleaf-profile.c?ref=d56a43a0e09598ec8e4e76817e5cd0f76e564962", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z900 -pg\" } */\n+\n+int\n+foo ()\n+{\n+}\n+/* Make sure no stack frame is generated.  */\n+/* { dg-final { scan-assembler-not \"ahi\" { target s390-*-* } } } */\n+/* { dg-final { scan-assembler-not \"aghi\" { target s390x-*-* } } } */"}]}