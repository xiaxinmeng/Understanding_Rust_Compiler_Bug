{"sha": "bb9a388dad84486a075d822e4bed05a74faab780", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI5YTM4OGRhZDg0NDg2YTA3NWQ4MjJlNGJlZDA1YTc0ZmFhYjc4MA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-05-19T01:28:56Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-05-19T01:28:56Z"}, "message": "* cgraph.c (hash_node, eq_node, cgraph_node, cgraph_remove_node)\n\t(cgraph_varpool_hash_node, eq_cgraph_varpool_node)\n\t(cgraph_varpool_node):\n\tUse DECL_UID for the key, not DECL_ASSEMBLER_NAME.\n\t(cgraph_function_possibly_inlined_p): Use the decl itself for\n\tthe key, not DECL_ASSEMBLER_NAME.\n\t(change_decl_assembler_name): No need to muck with the hash tables.\n\t(cgraph_node_for_identifier, cgraph_varpool_node_for_identifier):\n\tDelete.\n\t* cgraphunit.c (cgraph_mark_inline_edge): Use the decl itself\n\tfor the key, not DECL_ASSEMBLER_NAME.\n\t* cgraph.h: Remove prototypes of deleted functions.\n\t* varasm.c (mark_referenced): Just set TREE_SYMBOL_REFERENCED.\n\t(mark_decl_referenced): New function.\n\t* tree.h: Prototype mark_decl_referenced.\n\t* final.c (output_addr_const) <case SYMBOL_REF>: Call\n\tmark_decl_referenced before assemble_name.\n\t* c-decl.c (finish_decl): Use mark_decl_referenced.\ncp:\n\t* decl.c (cp_finish_decl): Use mark_decl_referenced.\n\t* decl2.c (maybe_make_one_only): Likewise.\n\t* method.c (use_thunk): Likewise.\n\nFrom-SVN: r82015", "tree": {"sha": "3b98c8b6def01f3ffef6ee0dc67f9968797dce2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b98c8b6def01f3ffef6ee0dc67f9968797dce2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb9a388dad84486a075d822e4bed05a74faab780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9a388dad84486a075d822e4bed05a74faab780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb9a388dad84486a075d822e4bed05a74faab780", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb9a388dad84486a075d822e4bed05a74faab780/comments", "author": null, "committer": null, "parents": [{"sha": "5b200ac2c7278c022c23a684589df1b31a40a153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b200ac2c7278c022c23a684589df1b31a40a153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b200ac2c7278c022c23a684589df1b31a40a153"}], "stats": {"total": 220, "additions": 71, "deletions": 149}, "files": [{"sha": "74e1c531a49b14ae7395c4c6222bcf864a57f613", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -1,3 +1,24 @@\n+2004-05-18  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* cgraph.c (hash_node, eq_node, cgraph_node, cgraph_remove_node)\n+\t(cgraph_varpool_hash_node, eq_cgraph_varpool_node)\n+\t(cgraph_varpool_node):\n+\tUse DECL_UID for the key, not DECL_ASSEMBLER_NAME.\n+\t(cgraph_function_possibly_inlined_p): Use the decl itself for\n+\tthe key, not DECL_ASSEMBLER_NAME.\n+\t(change_decl_assembler_name): No need to muck with the hash tables.\n+\t(cgraph_node_for_identifier, cgraph_varpool_node_for_identifier):\n+\tDelete.\n+\t* cgraphunit.c (cgraph_mark_inline_edge): Use the decl itself\n+\tfor the key, not DECL_ASSEMBLER_NAME.\n+\t* cgraph.h: Remove prototypes of deleted functions.\n+\t* varasm.c (mark_referenced): Just set TREE_SYMBOL_REFERENCED.\n+\t(mark_decl_referenced): New function.\n+\t* tree.h: Prototype mark_decl_referenced.\n+\t* final.c (output_addr_const) <case SYMBOL_REF>: Call\n+\tmark_decl_referenced before assemble_name.\n+\t* c-decl.c (finish_decl): Use mark_decl_referenced.\n+\n 2004-05-18  Andrew Pinski  <pinskia@physics.uc.edu>\n \t    Jeff Law <law@redhat.com>\n "}, {"sha": "e2c5a97a7f7094bec72c75fcc8dbb8afca8dd06d", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -2981,7 +2981,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \n   /* If this was marked 'used', be sure it will be output.  */\n   if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    mark_referenced (DECL_ASSEMBLER_NAME (decl));\n+    mark_decl_referenced (decl);\n \n   if (TREE_CODE (decl) == TYPE_DECL)\n     {"}, {"sha": "5e44b55d8d14761afa4e99432a31080c04dffb91", "filename": "gcc/cgraph.c", "status": "modified", "additions": 21, "deletions": 122, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -99,8 +99,9 @@ The varpool data structure:\n /* Hash table used to convert declarations into nodes.  */\n static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n \n-/* We destructively update callgraph during inlining and thus we need to\n-   keep information on whether inlining happened separately.  */\n+/* We destructively update the callgraph during inlining, thus we need to\n+   keep a separate table with information on whether inlining happened.\n+   ??? Do this with a bit in the DECL instead of a hash table.  */\n htab_t cgraph_inline_hash;\n \n /* The linked list of cgraph nodes.  */\n@@ -138,18 +139,15 @@ static int eq_node (const void *, const void *);\n static hashval_t\n hash_node (const void *p)\n {\n-  return ((hashval_t)\n-\t  IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME\n-\t\t\t\t (((struct cgraph_node *) p)->decl)));\n+  return ((hashval_t) DECL_UID (((struct cgraph_node *) p)->decl));\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n eq_node (const void *p1, const void *p2)\n {\n-  return ((DECL_ASSEMBLER_NAME (((struct cgraph_node *) p1)->decl)) ==\n-\t  (tree) p2);\n+  return (DECL_UID (((struct cgraph_node *) p1)->decl) == (unsigned int)p2);\n }\n \n /* Allocate new callgraph node and insert it into basic data structures.  */\n@@ -183,9 +181,10 @@ cgraph_node (tree decl)\n     cgraph_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n \n   slot = (struct cgraph_node **)\n-    htab_find_slot_with_hash (cgraph_hash, DECL_ASSEMBLER_NAME (decl),\n-\t\t\t      IDENTIFIER_HASH_VALUE\n-\t\t\t        (DECL_ASSEMBLER_NAME (decl)), INSERT);\n+    htab_find_slot_with_hash (cgraph_hash,\n+\t\t\t      (void *)DECL_UID (decl),\n+\t\t\t      (hashval_t)DECL_UID (decl),\n+\t\t\t      INSERT);\n   if (*slot)\n     return *slot;\n \n@@ -218,26 +217,6 @@ cgraph_edge (struct cgraph_node *node, tree call_expr)\n   return e;\n }\n \n-/* Try to find existing function for identifier ID.  */\n-struct cgraph_node *\n-cgraph_node_for_identifier (tree id)\n-{\n-  struct cgraph_node **slot;\n-\n-  if (TREE_CODE (id) != IDENTIFIER_NODE)\n-    abort ();\n-\n-  if (!cgraph_hash)\n-    return NULL;\n-\n-  slot = (struct cgraph_node **)\n-    htab_find_slot_with_hash (cgraph_hash, id,\n-\t\t\t      IDENTIFIER_HASH_VALUE (id), NO_INSERT);\n-  if (!slot)\n-    return NULL;\n-  return *slot;\n-}\n-\n /* Create edge from CALLER to CALLEE in the cgraph.  */\n \n struct cgraph_edge *\n@@ -347,9 +326,10 @@ cgraph_remove_node (struct cgraph_node *node)\n   if (node->next)\n     node->next->previous = node->previous;\n   slot = \n-    htab_find_slot_with_hash (cgraph_hash, DECL_ASSEMBLER_NAME (node->decl),\n-\t\t\t      IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME\n-\t\t\t\t\t\t     (node->decl)), NO_INSERT);\n+    htab_find_slot_with_hash (cgraph_hash,\n+\t\t\t      (void *)DECL_UID (node->decl),\n+\t\t\t      (hashval_t)DECL_UID (node->decl),\n+\t\t\t      NO_INSERT);\n   if (*slot == node)\n     {\n       if (node->next_clone)\n@@ -552,18 +532,17 @@ dump_cgraph (FILE *f)\n static hashval_t\n cgraph_varpool_hash_node (const void *p)\n {\n-  return ((hashval_t)\n-\t  IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME\n-\t\t\t\t (((struct cgraph_varpool_node *) p)->decl)));\n+  return ((hashval_t) DECL_UID (((struct cgraph_varpool_node *) p)->decl));\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n \n static int\n eq_cgraph_varpool_node (const void *p1, const void *p2)\n {\n-  return ((DECL_ASSEMBLER_NAME (((struct cgraph_varpool_node *) p1)->decl)) ==\n-\t  (tree) p2);\n+  return (DECL_UID (((struct cgraph_varpool_node *) p1)->decl)\n+\t  == (unsigned int) p2);\n+\n }\n \n /* Return cgraph_varpool node assigned to DECL.  Create new one when needed.  */\n@@ -580,8 +559,9 @@ cgraph_varpool_node (tree decl)\n     cgraph_varpool_hash = htab_create_ggc (10, cgraph_varpool_hash_node,\n \t\t\t\t           eq_cgraph_varpool_node, NULL);\n   slot = (struct cgraph_varpool_node **)\n-    htab_find_slot_with_hash (cgraph_varpool_hash, DECL_ASSEMBLER_NAME (decl),\n-\t\t\t      IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME (decl)),\n+    htab_find_slot_with_hash (cgraph_varpool_hash,\n+\t\t\t      (void *)DECL_UID (decl),\n+\t\t\t      (hashval_t)DECL_UID (decl),\n \t\t\t      INSERT);\n   if (*slot)\n     return *slot;\n@@ -597,10 +577,6 @@ cgraph_varpool_node (tree decl)\n void\n change_decl_assembler_name (tree decl, tree name)\n {\n-  struct cgraph_node *node = NULL;\n-  struct cgraph_varpool_node *vnode = NULL;\n-  void **slot;\n-\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n     {\n       SET_DECL_ASSEMBLER_NAME (decl, name);\n@@ -613,83 +589,7 @@ change_decl_assembler_name (tree decl, tree name)\n       && DECL_RTL_SET_P (decl))\n     warning (\"%D renamed after being referenced in assembly\", decl);\n \n-  if (TREE_CODE (decl) == FUNCTION_DECL && cgraph_hash)\n-    {\n-      /* Take a look whether declaration is in the cgraph structure.  */\n-      slot = \n-\thtab_find_slot_with_hash (cgraph_hash, DECL_ASSEMBLER_NAME (decl),\n-\t\t\t\t   IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME\n-\t\t\t\t\t\t\t  (decl)), NO_INSERT);\n-      if (slot)\n-\tnode = *slot;\n-\n-      /* It is, verify that we are the canonical node for this decl.  */\n-      if (node && node->decl == decl)\n-\t{\n-\t  node = *slot;\n-\t  htab_clear_slot (cgraph_hash, slot);\n-      \t }\n-       else\n-\t node = NULL;\n-    }\n-  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl) && cgraph_varpool_hash)\n-    {\n-      /* Take a look whether declaration is in the cgraph structure.  */\n-      slot = \n-\thtab_find_slot_with_hash (cgraph_varpool_hash, DECL_ASSEMBLER_NAME (decl),\n-\t\t\t\t   IDENTIFIER_HASH_VALUE (DECL_ASSEMBLER_NAME\n-\t\t\t\t\t\t\t  (decl)), NO_INSERT);\n-      if (slot)\n-\tvnode = *slot;\n-\n-      /* It is, verify that we are the canonical vnode for this decl.  */\n-      if (vnode && vnode->decl == decl)\n-\t{\n-\t  vnode = *slot;\n-\t  htab_clear_slot (cgraph_varpool_hash, slot);\n-      \t }\n-       else\n-\t vnode = NULL;\n-    }\n   SET_DECL_ASSEMBLER_NAME (decl, name);\n-  if (node)\n-    {\n-      slot = \n-\thtab_find_slot_with_hash (cgraph_hash, name,\n-\t\t\t\t  IDENTIFIER_HASH_VALUE (name), INSERT);\n-      if (*slot)\n-\tabort ();\n-      *slot = node;\n-    }\n-  if (vnode)\n-    {\n-      slot = \n-\thtab_find_slot_with_hash (cgraph_varpool_hash, name,\n-\t\t\t\t  IDENTIFIER_HASH_VALUE (name), INSERT);\n-      if (*slot)\n-\tabort ();\n-      *slot = vnode;\n-    }\n-}\n-\n-/* Try to find existing function for identifier ID.  */\n-struct cgraph_varpool_node *\n-cgraph_varpool_node_for_identifier (tree id)\n-{\n-  struct cgraph_varpool_node **slot;\n-\n-  if (TREE_CODE (id) != IDENTIFIER_NODE)\n-    abort ();\n-\n-  if (!cgraph_varpool_hash)\n-    return NULL;\n-\n-  slot = (struct cgraph_varpool_node **)\n-    htab_find_slot_with_hash (cgraph_varpool_hash, id,\n-\t\t\t      IDENTIFIER_HASH_VALUE (id), NO_INSERT);\n-  if (!slot)\n-    return NULL;\n-  return *slot;\n }\n \n /* Notify finalize_compilation_unit that given node is reachable\n@@ -767,8 +667,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n     return (DECL_INLINE (decl) && !flag_really_no_inline);\n   if (!cgraph_inline_hash)\n     return false;\n-  return (htab_find_slot (cgraph_inline_hash, DECL_ASSEMBLER_NAME (decl),\n-\t\t\t  NO_INSERT) != NULL);\n+  return (htab_find_slot (cgraph_inline_hash, decl, NO_INSERT) != NULL);\n }\n \n /* Create clone of E in the node N represented by CALL_EXPR the callgraph.  */"}, {"sha": "353027907830b2f97db56fd277e9adb2a4e8a089", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -164,7 +164,6 @@ struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t        tree);\n struct cgraph_node *cgraph_node (tree decl);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree call_expr);\n-struct cgraph_node *cgraph_node_for_identifier (tree id);\n bool cgraph_calls_p (tree, tree);\n struct cgraph_local_info *cgraph_local_info (tree);\n struct cgraph_global_info *cgraph_global_info (tree);\n@@ -174,7 +173,6 @@ struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *, struct cgraph_node\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *);\n \n struct cgraph_varpool_node *cgraph_varpool_node (tree decl);\n-struct cgraph_varpool_node *cgraph_varpool_node_for_identifier (tree id);\n void cgraph_varpool_mark_needed_node (struct cgraph_varpool_node *);\n void cgraph_varpool_finalize_decl (tree);\n bool cgraph_varpool_assemble_pending_decls (void);"}, {"sha": "fcd85b49a31bfa706e597eebb9f8e64519ed89a9", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -1076,9 +1076,8 @@ cgraph_mark_inline_edge (struct cgraph_edge *e)\n       if (!cgraph_inline_hash)\n         cgraph_inline_hash = htab_create_ggc (42, htab_hash_pointer,\n \t\t\t\t\t      htab_eq_pointer, NULL);\n-      slot = htab_find_slot (cgraph_inline_hash,\n-\t\t\t     DECL_ASSEMBLER_NAME (e->callee->decl), INSERT);\n-      *slot = DECL_ASSEMBLER_NAME (e->callee->decl);\n+      slot = htab_find_slot (cgraph_inline_hash, e->callee->decl, INSERT);\n+      *slot = e->callee->decl;\n     }\n   e->callee->global.inlined = true;\n "}, {"sha": "89c1922c5a4ad1ea69f649eee18f3a34302fbafc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -1,3 +1,9 @@\n+2004-05-18  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* decl.c (cp_finish_decl): Use mark_decl_referenced.\n+\t* decl2.c (maybe_make_one_only): Likewise.\n+\t* method.c (use_thunk): Likewise.\n+\n 2004-05-18  Jason Merrill  <jason@redhat.com>\n \n \t* class.c (build_base_path): Tidy a bit."}, {"sha": "6407aedf22834b188edc807833444b5a500939d8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -4912,7 +4912,7 @@ cp_finish_decl (tree decl, tree init, tree asmspec_tree, int flags)\n \n   /* If this was marked 'used', be sure it will be output.  */\n   if (lookup_attribute (\"used\", DECL_ATTRIBUTES (decl)))\n-    mark_referenced (DECL_ASSEMBLER_NAME (decl));\n+    mark_decl_referenced (decl);\n }\n \n /* This is here for a midend callback from c-common.c.  */"}, {"sha": "dfe4b0d2e283d9bb832a5a893ee25ec70ef0c151", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -1450,7 +1450,7 @@ maybe_make_one_only (tree decl)\n \t{\n \t  DECL_COMDAT (decl) = 1;\n \t  /* Mark it needed so we don't forget to emit it.  */\n-\t  mark_referenced (DECL_ASSEMBLER_NAME (decl));\n+\t  mark_decl_referenced (decl);\n \t}\n     }\n }"}, {"sha": "efd0e06269cc57b99f119469b731550cff40b203", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -353,7 +353,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n      this translation unit.  */\n   TREE_ADDRESSABLE (function) = 1;\n   mark_used (function);\n-  mark_referenced (DECL_ASSEMBLER_NAME (function));\n+  mark_decl_referenced (function);\n   if (!emit_p)\n     return;\n \n@@ -495,7 +495,7 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \n       /* Since we want to emit the thunk, we explicitly mark its name as\n \t referenced.  */\n-      mark_referenced (DECL_ASSEMBLER_NAME (thunk_fndecl));\n+      mark_decl_referenced (thunk_fndecl);\n \n       /* But we don't want debugging information about it.  */\n       DECL_IGNORED_P (thunk_fndecl) = 1;"}, {"sha": "ef1eeb2928298eb40e05102829b9a481f821f673", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -3252,6 +3252,8 @@ output_addr_const (FILE *file, rtx x)\n       break;\n \n     case SYMBOL_REF:\n+      if (SYMBOL_REF_DECL (x))\n+\tmark_decl_referenced (SYMBOL_REF_DECL (x));\n #ifdef ASM_OUTPUT_SYMBOL_REF\n       ASM_OUTPUT_SYMBOL_REF (file, x);\n #else"}, {"sha": "da881a298ebc79f07740267c0b662c5626529132", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -3654,6 +3654,7 @@ extern void variable_section (tree, int);\n enum tls_model decl_tls_model (tree);\n extern void resolve_unique_section (tree, int, int);\n extern void mark_referenced (tree);\n+extern void mark_decl_referenced (tree);\n extern void notice_global_symbol (tree);\n \n /* In stmt.c */"}, {"sha": "96d264a2fe1b74cf71a66cf740aa10c15163ad48", "filename": "gcc/varasm.c", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb9a388dad84486a075d822e4bed05a74faab780/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=bb9a388dad84486a075d822e4bed05a74faab780", "patch": "@@ -1685,29 +1685,25 @@ assemble_label (const char *name)\n   ASM_OUTPUT_LABEL (asm_out_file, name);\n }\n \n-/* Set the symbol_referenced flag for ID and notify callgraph code.  */\n+/* Set the symbol_referenced flag for ID.  */\n void\n mark_referenced (tree id)\n {\n-  if (!TREE_SYMBOL_REFERENCED (id))\n-    {\n-      struct cgraph_node *node;\n-      struct cgraph_varpool_node *vnode;\n-\n-      if (!cgraph_global_info_ready)\n-\t{\n-\t  node = cgraph_node_for_identifier (id);\n-\t  if (node)\n-\t    cgraph_mark_needed_node (node);\n-\t}\n-\n-      vnode = cgraph_varpool_node_for_identifier (id);\n-      if (vnode)\n-\tcgraph_varpool_mark_needed_node (vnode);\n-    }\n   TREE_SYMBOL_REFERENCED (id) = 1;\n }\n \n+/* Set the symbol_referenced flag for DECL and notify callgraph.  */\n+void\n+mark_decl_referenced (tree decl)\n+{\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    cgraph_mark_needed_node (cgraph_node (decl));\n+  else if (TREE_CODE (decl) == VAR_DECL)\n+    cgraph_varpool_mark_needed_node (cgraph_varpool_node (decl));\n+  /* else do nothing - we can get various sorts of CST nodes here,\n+     which do not need to be marked.  */\n+}\n+\n /* Output to FILE a reference to the assembler name of a C-level name NAME.\n    If NAME starts with a *, the rest of NAME is output verbatim.\n    Otherwise NAME is transformed in an implementation-defined way"}]}