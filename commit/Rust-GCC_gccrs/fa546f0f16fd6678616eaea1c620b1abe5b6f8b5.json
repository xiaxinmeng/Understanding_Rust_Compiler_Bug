{"sha": "fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmE1NDZmMGYxNmZkNjY3ODYxNmVhZWExYzYyMGIxYWJlNWI2ZjhiNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-12-22T03:27:00Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-12-22T03:27:00Z"}, "message": "compiler: improve escape analysis diagnostics\n    \n    This CL brings escape analysis diagnostics closer to the gc\n    compiler's. This makes porting and debugging escape analysis\n    code easier. A few changes:\n    \n    - In the gc compiler, the variable expression is represented\n      with the variable node itself (ONAME), the location of which\n      is the location of definition. We add a definition_location\n      method to Node, and make use of it when the gc compiler emits\n      diagnostics at the definition locations.\n    \n    - In the gc compiler, methods are named T.M or (*T).M. Add the\n      type to the method name when possible.\n    \n    - Print \"moved to heap\" messages only for variables.\n    \n    - Reduce some duplicated diagnostics.\n    \n    - Print \"does not escape\" messages in more situations which the\n      gc compiler does.\n    \n    - Remove the special handling for closure numbers. In gofrontend,\n      closures are named \"$nested#\" where # is a global counter\n      starting from 0, whereas in the gc compiler they are named\n      \"outer.func#\" where # is a per-function counter starting from\n      1. We tried to adjust the closure name to better matching the\n      ones in the gc compiler, however, it cannot match exactly\n      because of the difference of the counter. Instead, just print\n      \"outer.$nested#\".\n    \n    Reviewed-on: https://go-review.googlesource.com/83875\n\nFrom-SVN: r255967", "tree": {"sha": "892b43b84034703019bbd9603fb9addb85180bab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/892b43b84034703019bbd9603fb9addb85180bab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/comments", "author": null, "committer": null, "parents": [{"sha": "18408e962e5afb9cb3f45f897cc8dd1f9b91417f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18408e962e5afb9cb3f45f897cc8dd1f9b91417f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18408e962e5afb9cb3f45f897cc8dd1f9b91417f"}], "stats": {"total": 144, "additions": 97, "deletions": 47}, "files": [{"sha": "e3908c17c1e76d012ed67bd960743e3952cad50d", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "patch": "@@ -1,4 +1,4 @@\n-97eb3f61cf1c2cc01b9db6ed20e39bc04573c207\n+66de779004bdaafefc27e4132324a47d86a0f122\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "abdca820515a35a3eb7b14b1b2da6a050a93256b", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 92, "deletions": 32, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "patch": "@@ -53,6 +53,38 @@ Node::location() const\n     return Linemap::unknown_location();\n }\n \n+// A helper for reporting; return the location where the underlying\n+// object is defined.\n+\n+Location\n+Node::definition_location() const\n+{\n+  if (this->object() != NULL && !this->object()->is_sink())\n+    {\n+      Named_object* no = this->object();\n+      if (no->is_variable() || no->is_result_variable())\n+        return no->location();\n+    }\n+  else if (this->expr() != NULL)\n+    {\n+      Var_expression* ve = this->expr()->var_expression();\n+      if (ve != NULL)\n+        {\n+          Named_object* no = ve->named_object();\n+          if (no->is_variable() || no->is_result_variable())\n+            return no->location();\n+        }\n+      Enclosed_var_expression* eve = this->expr()->enclosed_var_expression();\n+      if (eve != NULL)\n+        {\n+          Named_object* no = eve->variable();\n+          if (no->is_variable() || no->is_result_variable())\n+            return no->location();\n+        }\n+    }\n+  return this->location();\n+}\n+\n // To match the cmd/gc debug output, strip away the packed prefixes on functions\n // and variable/expressions.\n \n@@ -133,7 +165,10 @@ Node::ast_format(Gogo* gogo) const\n       Ast_dump_context::dump_to_stream(s, &ss);\n     }\n \n-  return strip_packed_prefix(gogo, ss.str());\n+  std::string s = strip_packed_prefix(gogo, ss.str());\n+\n+  // trim trailing space\n+  return s.substr(0, s.find_last_not_of(' ') + 1);\n }\n \n // A helper for debugging; return this node's detailed format string.\n@@ -563,25 +598,44 @@ debug_function_name(Named_object* fn)\n   if (fn == NULL)\n     return \"<S>\";\n \n-  if (!fn->is_function()\n-      || fn->func_value()->enclosing() == NULL)\n+  if (!fn->is_function())\n     return Gogo::unpack_hidden_name(fn->name());\n+  if (fn->func_value()->enclosing() == NULL)\n+    {\n+      std::string fnname = Gogo::unpack_hidden_name(fn->name());\n+      if (fn->func_value()->is_method())\n+        {\n+          // Methods in gc compiler are named \"T.m\" or \"(*T).m\" where\n+          // T is the receiver type. Add the receiver here.\n+          Type* rt = fn->func_value()->type()->receiver()->type();\n+          switch (rt->classification())\n+            {\n+              case Type::TYPE_NAMED:\n+                fnname = rt->named_type()->name() + \".\" + fnname;\n+                break;\n+\n+              case Type::TYPE_POINTER:\n+                {\n+                  Named_type* nt = rt->points_to()->named_type();\n+                  if (nt != NULL)\n+                    fnname = \"(*\" + nt->name() + \").\" + fnname;\n+                  break;\n+                }\n+\n+              default:\n+                break;\n+            }\n+        }\n+      return fnname;\n+    }\n \n-  // Closures are named \".$nested#\" where # starts from 0 to distinguish\n-  // between closures.  The cmd/gc closures are named in the format\n-  // \"enclosing.func#\" where # starts from 1.  If this is a closure, format\n-  // its name to match cmd/gc.\n+  // Closures are named \".$nested#\" where # is a global counter. Add outer\n+  // function name for better distinguishing. This is also closer to what\n+  // gc compiler prints, \"outer.func#\".\n   Named_object* enclosing = fn->func_value()->enclosing();\n-\n-  // Extract #.\n   std::string name = Gogo::unpack_hidden_name(fn->name());\n-  int closure_num = Gogo::nested_function_num(fn->name());\n-  closure_num++;\n-\n-  name = Gogo::unpack_hidden_name(enclosing->name());\n-  char buf[200];\n-  snprintf(buf, sizeof buf, \"%s.func%d\", name.c_str(), closure_num);\n-  return buf;\n+  std::string outer_name = Gogo::unpack_hidden_name(enclosing->name());\n+  return outer_name + \".\" + name;\n }\n \n // Return the name of the current function.\n@@ -740,7 +794,7 @@ Gogo::analyze_escape()\n \t       ++n)\n \t    {\n \t      Node::Escape_state* state = (*n)->state(context, NULL);\n-\t      if (((*n)->encoding() & ESCAPE_MASK) == int(Node::ESCAPE_NONE))\n+\t      if ((*n)->encoding() == Node::ESCAPE_NONE)\n \t\tgo_inform((*n)->location(), \"%s %s does not escape\",\n \t\t\t  strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n \t\t\t  (*n)->ast_format(this).c_str());\n@@ -2315,9 +2369,10 @@ Gogo::assign_connectivity(Escape_context* context, Named_object* fn)\n       if (fn->package() != NULL)\n \tparam_node->set_encoding(Node::ESCAPE_HEAP);\n       else\n-\tparam_node->set_encoding(Node::ESCAPE_NONE);\n-\n-      // TODO(cmang): Track this node in no_escape list.\n+        {\n+          param_node->set_encoding(Node::ESCAPE_NONE);\n+          context->track(param_node);\n+        }\n     }\n \n   Escape_analysis_loop el;\n@@ -2452,13 +2507,13 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       if (debug_level != 0)\n \t{\n \t  if (debug_level == 1)\n-\t    go_inform(src->location(),\n+\t    go_inform(src->definition_location(),\n \t\t      \"leaking param: %s to result %s level=%d\",\n \t\t      src->ast_format(gogo).c_str(),\n \t\t      dst->ast_format(gogo).c_str(),\n \t\t      level.value());\n \t  else\n-\t    go_inform(src->location(),\n+\t    go_inform(src->definition_location(),\n \t\t      \"leaking param: %s to result %s level={%d %d}\",\n \t\t      src->ast_format(gogo).c_str(),\n \t\t      dst->ast_format(gogo).c_str(),\n@@ -2500,7 +2555,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t\t   Node::ESCAPE_NONE);\n       src->set_encoding(enc);\n       if (debug_level != 0)\n-\tgo_inform(src->location(), \"mark escaped content: %s\",\n+\tgo_inform(src->definition_location(), \"mark escaped content: %s\",\n \t\t  src->ast_format(gogo).c_str());\n     }\n \n@@ -2510,6 +2565,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n   bool src_leaks = (level.value() <= 0\n \t\t    && level.suffix_value() <= 0\n \t\t    && dst_state->loop_depth < mod_loop_depth);\n+  // old src encoding, used to prevent duplicate error messages\n+  int osrcesc = src->encoding();\n \n   if (src_is_param\n       && (src_leaks || dst_state->loop_depth < 0)\n@@ -2521,14 +2578,15 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t    Node::max_encoding((src->encoding() | ESCAPE_CONTENT_ESCAPES),\n \t\t\t       Node::ESCAPE_NONE);\n \t  src->set_encoding(enc);\n-\t  if (debug_level != 0)\n-\t    go_inform(src->location(), \"leaking param content: %s\",\n+\t  if (debug_level != 0 && osrcesc != src->encoding())\n+\t    go_inform(src->definition_location(), \"leaking param content: %s\",\n \t\t      src->ast_format(gogo).c_str());\n \t}\n       else\n \t{\n \t  if (debug_level != 0)\n-\t    go_inform(src->location(), \"leaking param\");\n+\t    go_inform(src->definition_location(), \"leaking param: %s\",\n+                      src->ast_format(gogo).c_str());\n \t  src->set_encoding(Node::ESCAPE_SCOPE);\n \t}\n     }\n@@ -2563,10 +2621,12 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (src_leaks)\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n-\t      if (debug_level != 0)\n+\t      if (debug_level != 0 && osrcesc != src->encoding())\n \t\t{\n-\t\t  go_inform(underlying->location(), \"moved to heap: %s\",\n-                            underlying_node->ast_format(gogo).c_str());\n+                  if (underlying->var_expression() != NULL)\n+                    go_inform(underlying_node->definition_location(),\n+                              \"moved to heap: %s\",\n+                              underlying_node->ast_format(gogo).c_str());\n \n \t\t  if (debug_level > 1)\n \t\t    go_inform(src->location(),\n@@ -2606,7 +2666,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (src_leaks)\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n-\t      if (debug_level != 0)\n+\t      if (debug_level != 0 && osrcesc != src->encoding())\n \t\tgo_inform(src->location(), \"%s escapes to heap\",\n \t\t\t  src->ast_format(gogo).c_str());\n \t      extra_loop_depth = mod_loop_depth;\n@@ -2652,7 +2712,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t      if (src_leaks)\n \t\t\t{\n \t\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n-\t\t\t  if (debug_level != 0)\n+\t\t\t  if (debug_level != 0 && osrcesc != src->encoding())\n \t\t\t    go_inform(src->location(), \"%s escapes to heap\",\n \t\t\t\t      src->ast_format(gogo).c_str());\n \t\t\t  extra_loop_depth = mod_loop_depth;\n@@ -2680,7 +2740,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t{\n \t  // Calls to Runtime::NEW get lowered into an allocation expression.\n \t  src->set_encoding(Node::ESCAPE_HEAP);\n-\t  if (debug_level != 0)\n+\t  if (debug_level != 0 && osrcesc != src->encoding())\n \t    go_inform(src->location(), \"%s escapes to heap\",\n                       src->ast_format(gogo).c_str());\n \t}"}, {"sha": "04247fe35cc8e744858437a027250093c00c2512", "filename": "gcc/go/gofrontend/escape.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "patch": "@@ -193,6 +193,10 @@ class Node\n   Location\n   location() const;\n \n+  // Return the location where the node's underlying object is defined.\n+  Location\n+  definition_location() const;\n+\n   // Return this node's AST formatted string.\n   std::string\n   ast_format(Gogo*) const;"}, {"sha": "8fb263bd165ce7fde31b499a585ae34e3155682f", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "patch": "@@ -827,10 +827,6 @@ class Gogo\n   static std::string\n   nested_function_name();\n \n-  // Return the index of a nested function name.\n-  static int\n-  nested_function_num(const std::string&);\n-\n   // Return the name to use for a sink funciton.\n   std::string\n   sink_function_name();"}, {"sha": "5feea1244435f2643505638fcacfd790b8d2ba98", "filename": "gcc/go/gofrontend/names.cc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fa546f0f16fd6678616eaea1c620b1abe5b6f8b5/gcc%2Fgo%2Fgofrontend%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fnames.cc?ref=fa546f0f16fd6678616eaea1c620b1abe5b6f8b5", "patch": "@@ -232,16 +232,6 @@ Gogo::nested_function_name()\n   return buf;\n }\n \n-// Return the index of a nested function name.\n-\n-int\n-Gogo::nested_function_num(const std::string& name)\n-{\n-  std::string n(Gogo::unpack_hidden_name(name));\n-  go_assert(n.compare(0, 7, \"$nested\") == 0);\n-  return strtol(n.substr(7).c_str(), NULL, 0);\n-}\n-\n // Return the name to use for a sink function, a function whose name\n // is simply underscore.  We don't really need these functions but we\n // do have to generate them for error checking."}]}