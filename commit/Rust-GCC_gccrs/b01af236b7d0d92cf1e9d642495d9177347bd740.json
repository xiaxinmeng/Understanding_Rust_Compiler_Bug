{"sha": "b01af236b7d0d92cf1e9d642495d9177347bd740", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjAxYWYyMzZiN2QwZDkyY2YxZTlkNjQyNDk1ZDkxNzczNDdiZDc0MA==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@google.com", "date": "2016-12-06T11:28:09Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2016-12-06T11:28:09Z"}, "message": "variant (visit): Make visit constexpr.\n\n\t* include/std/variant (visit): Make visit constexpr. Also cleanup\n\t__get_alternative and __storage, since we don't support reference/void\n\talternatives any more.\n\t* testsuite/20_util/variant/compile.cc: Add tests.\n\nFrom-SVN: r243295", "tree": {"sha": "7f0ce37f889944d73231296ffa53c7648bd8ceb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f0ce37f889944d73231296ffa53c7648bd8ceb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b01af236b7d0d92cf1e9d642495d9177347bd740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01af236b7d0d92cf1e9d642495d9177347bd740", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b01af236b7d0d92cf1e9d642495d9177347bd740", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01af236b7d0d92cf1e9d642495d9177347bd740/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "458ef69052224b5d3d2c78cfbe0a0e0ec85a4193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/458ef69052224b5d3d2c78cfbe0a0e0ec85a4193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/458ef69052224b5d3d2c78cfbe0a0e0ec85a4193"}], "stats": {"total": 310, "additions": 154, "deletions": 156}, "files": [{"sha": "1d47e38dd96836ac4047ddc66dd5e13eff501d40", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01af236b7d0d92cf1e9d642495d9177347bd740/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01af236b7d0d92cf1e9d642495d9177347bd740/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b01af236b7d0d92cf1e9d642495d9177347bd740", "patch": "@@ -1,3 +1,10 @@\n+2016-11-27  Tim Shen  <timshen@google.com>\n+\n+\t* include/std/variant (visit): Make visit constexpr. Also cleanup\n+\t__get_alternative and __storage, since we don't support reference/void\n+\talternatives any more.\n+\t* testsuite/20_util/variant/compile.cc: Add tests.\n+\n 2016-12-07  Tim Shen  <timshen@google.com>\n \n \t* include/bits/enable_special_members.h: Make"}, {"sha": "dd6109dc046862b7de9fba7af839e4d1d08b85eb", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 131, "deletions": 156, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01af236b7d0d92cf1e9d642495d9177347bd740/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01af236b7d0d92cf1e9d642495d9177347bd740/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=b01af236b7d0d92cf1e9d642495d9177347bd740", "patch": "@@ -41,10 +41,33 @@\n #include <bits/functexcept.h>\n #include <bits/move.h>\n #include <bits/functional_hash.h>\n+#include <bits/invoke.h>\n #include <ext/aligned_buffer.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace __detail\n+{\n+namespace __variant\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<size_t _Np, typename... _Types>\n+    struct _Nth_type;\n+\n+  template<size_t _Np, typename _First, typename... _Rest>\n+    struct _Nth_type<_Np, _First, _Rest...>\n+    : _Nth_type<_Np-1, _Rest...> { };\n+\n+  template<typename _First, typename... _Rest>\n+    struct _Nth_type<0, _First, _Rest...>\n+    { using type = _First; };\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace __variant\n+} // namespace __detail\n+\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename... _Types> class tuple;\n@@ -99,6 +122,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   constexpr size_t variant_npos = -1;\n \n+  template<size_t _Np, typename... _Types>\n+    constexpr variant_alternative_t<_Np, variant<_Types...>>&\n+    get(variant<_Types...>&);\n+\n+  template<size_t _Np, typename... _Types>\n+    constexpr variant_alternative_t<_Np, variant<_Types...>>&&\n+    get(variant<_Types...>&&);\n+\n+  template<size_t _Np, typename... _Types>\n+    constexpr variant_alternative_t<_Np, variant<_Types...>> const&\n+    get(const variant<_Types...>&);\n+\n+  template<size_t _Np, typename... _Types>\n+    constexpr variant_alternative_t<_Np, variant<_Types...>> const&&\n+    get(const variant<_Types...>&&);\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n \n namespace __detail\n@@ -119,41 +158,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::integral_constant<size_t, is_same_v<_Tp, _First>\n \t? 0 : __index_of_v<_Tp, _Rest...> + 1> {};\n \n-  // Extract _From's qualifiers and references and apply it to _To.\n-  // __reserved_type_map<const int&, char> is const char&.\n-  template<typename _From, typename _To>\n-    struct __reserved_type_map_impl\n-    { using type = _To; };\n-\n-  template<typename _From, typename _To>\n-    using __reserved_type_map =\n-      typename __reserved_type_map_impl<_From, _To>::type;\n-\n-  template<typename _From, typename _To>\n-    struct __reserved_type_map_impl<_From&, _To>\n-    { using type = add_lvalue_reference_t<__reserved_type_map<_From, _To>>; };\n-\n-  template<typename _From, typename _To>\n-    struct __reserved_type_map_impl<_From&&, _To>\n-    { using type = add_rvalue_reference_t<__reserved_type_map<_From, _To>>; };\n-\n-  template<typename _From, typename _To>\n-    struct __reserved_type_map_impl<const _From, _To>\n-    { using type = add_const_t<__reserved_type_map<_From, _To>>; };\n-\n-  template<typename _From, typename _To>\n-    struct __reserved_type_map_impl<volatile _From, _To>\n-    { using type = add_volatile_t<__reserved_type_map<_From, _To>>; };\n-\n-  template<typename _From, typename _To>\n-    struct __reserved_type_map_impl<const volatile _From, _To>\n-    { using type = add_cv_t<__reserved_type_map<_From, _To>>; };\n-\n-  // This abstraction might be useful for future features,\n-  // e.g. boost::recursive_wrapper.\n-  template<typename _Alternative>\n-    using __storage = _Alternative;\n-\n   // _Uninitialized<T> is guaranteed to be a literal type, even if T is not.\n   // We have to do this, because [basic.types]p10.5.3 (n4606) is not implemented\n   // yet. When it's implemented, _Uninitialized<T> can be changed to the alias\n@@ -210,16 +214,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __gnu_cxx::__aligned_membuf<_Type> _M_storage;\n     };\n \n-  // Given a qualified storage type, return the desired reference.\n-  // For example, variant<int>&& stores the int as __storage<int>, and\n-  // _Qualified_storage will be __storage<int>&&.\n-  template<typename _Qualified_storage>\n-    decltype(auto)\n-    __get_alternative(void* __ptr)\n+  template<typename _Ref>\n+    _Ref __ref_cast(void* __ptr)\n     {\n-      using _Storage = decay_t<_Qualified_storage>;\n-      return __reserved_type_map<_Qualified_storage, _Storage>(\n-\t*static_cast<_Storage*>(__ptr));\n+      return static_cast<_Ref>(*static_cast<remove_reference_t<_Ref>*>(__ptr));\n     }\n \n   template<typename _Union>\n@@ -242,7 +240,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Lhs, typename _Rhs>\n     constexpr void\n     __erased_ctor(void* __lhs, void* __rhs)\n-    { ::new (__lhs) decay_t<_Lhs>(__get_alternative<_Rhs>(__rhs)); }\n+    { ::new (__lhs) remove_reference_t<_Lhs>(__ref_cast<_Rhs>(__rhs)); }\n \n   template<typename _Variant, size_t _Np>\n     constexpr void\n@@ -256,14 +254,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Lhs, typename _Rhs>\n     constexpr void\n     __erased_assign(void* __lhs, void* __rhs)\n-    { __get_alternative<_Lhs>(__lhs) = __get_alternative<_Rhs>(__rhs); }\n+    { __ref_cast<_Lhs>(__lhs) = __ref_cast<_Rhs>(__rhs); }\n \n   template<typename _Lhs, typename _Rhs>\n     constexpr void\n     __erased_swap(void* __lhs, void* __rhs)\n     {\n       using std::swap;\n-      swap(__get_alternative<_Lhs>(__lhs), __get_alternative<_Rhs>(__rhs));\n+      swap(__ref_cast<_Lhs>(__lhs), __ref_cast<_Rhs>(__rhs));\n     }\n \n   template<typename _Variant, size_t _Np>\n@@ -285,7 +283,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     constexpr size_t\n     __erased_hash(void* __t)\n-    { return std::hash<decay_t<_Tp>>{}(__get_alternative<_Tp>(__t)); }\n+    {\n+      return std::hash<remove_cv_t<remove_reference_t<_Tp>>>{}(\n+\t  __ref_cast<_Tp>(__t));\n+    }\n \n   // Defines members and ctors.\n   template<typename... _Types>\n@@ -389,8 +390,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (__rhs._M_valid())\n \t  {\n \t    static constexpr void (*_S_vtable[])(void*, void*) =\n-\t      { &__erased_ctor<__storage<_Types>&,\n-\t\t\t       const __storage<_Types>&>... };\n+\t      { &__erased_ctor<_Types&, const _Types&>... };\n \t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n \t    this->_M_index = __rhs._M_index;\n \t  }\n@@ -402,7 +402,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tif (__rhs._M_valid())\n \t  {\n \t    static constexpr void (*_S_vtable[])(void*, void*) =\n-\t      { &__erased_ctor<__storage<_Types>&, __storage<_Types>&&>... };\n+\t      { &__erased_ctor<_Types&, _Types&&>... };\n \t    _S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n \t    this->_M_index = __rhs._M_index;\n \t  }\n@@ -422,8 +422,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__rhs._M_valid())\n \t      {\n \t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__erased_assign<__storage<_Types>&,\n-\t\t\t\t     const __storage<_Types>&>... };\n+\t\t  { &__erased_assign<_Types&, const _Types&>... };\n \t\t_S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n \t      }\n \t  }\n@@ -469,8 +468,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (__rhs._M_valid())\n \t      {\n \t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__erased_assign<__storage<_Types>&,\n-\t\t\t\t     __storage<_Types>&&>... };\n+\t\t  { &__erased_assign<_Types&, _Types&&>... };\n \t\t_S_vtable[__rhs._M_index](_M_storage(), __rhs._M_storage());\n \t      }\n \t  }\n@@ -555,20 +553,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     void* __get_storage(_Variant&& __v)\n     { return __v._M_storage(); }\n \n-  // A helper used to create variadic number of _To types.\n-  template<typename _From, typename _To>\n-    using _To_type = _To;\n-\n-  // Call the actual visitor.\n-  // _Args are qualified storage types.\n-  template<typename _Visitor, typename... _Args>\n-    decltype(auto)\n-    __visit_invoke(_Visitor&& __visitor, _To_type<_Args, void*>... __ptrs)\n-    {\n-      return std::forward<_Visitor>(__visitor)(\n-\t  __get_alternative<_Args>(__ptrs)...);\n-    }\n-\n   // Used for storing multi-dimensional vtable.\n   template<typename _Tp, size_t... _Dimensions>\n     struct _Multi_array\n@@ -592,108 +576,115 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   // Creates a multi-dimensional vtable recursively.\n-  // _Variant_tuple is initially the input from visit(), and gets gradually\n-  // consumed.\n-  // _Arg_tuple is enumerated alternative sequence, represented by a\n-  // qualified storage.\n   //\n   // For example,\n   // visit([](auto, auto){},\n-  //       variant<int, char>(),\n-  //       variant<float, double, long double>())\n+  //       variant<int, char>(),  // typedef'ed as V1\n+  //       variant<float, double, long double>())  // typedef'ed as V2\n   // will trigger instantiations of:\n-  // __gen_vtable_impl<_Multi_array<void(*)(void*, void*), 2, 3>,\n-  //                   tuple<variant<int, char>,\n-  //                         variant<float, double, long double>>,\n-  //                   tuple<>>\n-  //   __gen_vtable_impl<_Multi_array<void(*)(void*, void*), 3>,\n-  //                     tuple<variant<float, double, long double>>,\n-  //                     tuple<int>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n-  //                       tuple<>,\n-  //                       tuple<int, float>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n-  //                       tuple<>,\n-  //                       tuple<int, double>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n-  //                       tuple<>,\n-  //                       tuple<int, long double>>\n-  //   __gen_vtable_impl<_Multi_array<void(*)(void*, void*), 3>,\n-  //                     tuple<variant<float, double, long double>>,\n-  //                     tuple<char>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n-  //                       tuple<>,\n-  //                       tuple<char, float>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n-  //                       tuple<>,\n-  //                       tuple<char, double>>\n-  //     __gen_vtable_impl<_Multi_array<void(*)(void*, void*)>,\n-  //                       tuple<>,\n-  //                       tuple<char, long double>>\n+  // __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 2, 3>,\n+  //                   tuple<V1&&, V2&&>, std::index_sequence<>>\n+  //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,\n+  //                     tuple<V1&&, V2&&>, std::index_sequence<0>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>\n+  //   __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&), 3>,\n+  //                     tuple<V1&&, V2&&>, std::index_sequence<1>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>\n+  //     __gen_vtable_impl<_Multi_array<void(*)(V1&&, V2&&)>,\n+  //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>\n   // The returned multi-dimensional vtable can be fast accessed by the visitor\n   // using index calculation.\n-  template<typename _Array_type, typename _Variant_tuple, typename _Arg_tuple>\n+  template<typename _Array_type, typename _Variant_tuple, typename _Index_seq>\n     struct __gen_vtable_impl;\n \n-  template<typename _Array_type, typename _First, typename... _Rest,\n-\t   typename... _Args>\n-    struct __gen_vtable_impl<_Array_type, tuple<_First, _Rest...>,\n-\t\t\t     tuple<_Args...>>\n+  template<typename _Result_type, typename _Visitor, size_t... __unused,\n+\t   typename... _Variants, size_t... __indices>\n+    struct __gen_vtable_impl<\n+\t_Multi_array<_Result_type (*)(_Visitor, _Variants...), __unused...>,\n+\ttuple<_Variants...>, std::index_sequence<__indices...>>\n     {\n+      using _Next =\n+\t  remove_reference_t<typename _Nth_type<sizeof...(__indices),\n+\t\t\t     _Variants...>::type>;\n+      using _Array_type =\n+\t  _Multi_array<_Result_type (*)(_Visitor, _Variants...), __unused...>;\n+\n       static constexpr _Array_type\n       _S_apply()\n       {\n \t_Array_type __vtable{};\n \t_S_apply_all_alts(\n-\t  __vtable, make_index_sequence<variant_size_v<decay_t<_First>>>());\n+\t  __vtable, make_index_sequence<variant_size_v<_Next>>());\n \treturn __vtable;\n       }\n \n-      template<size_t... __indices>\n+      template<size_t... __var_indices>\n \tstatic constexpr void\n-\t_S_apply_all_alts(_Array_type& __vtable, index_sequence<__indices...>)\n-\t{ (_S_apply_single_alt<__indices>(__vtable._M_arr[__indices]), ...); }\n+\t_S_apply_all_alts(_Array_type& __vtable,\n+\t\t\t  std::index_sequence<__var_indices...>)\n+\t{\n+\t  (_S_apply_single_alt<__var_indices>(\n+\t     __vtable._M_arr[__var_indices]), ...);\n+\t}\n \n       template<size_t __index, typename _Tp>\n \tstatic constexpr void\n \t_S_apply_single_alt(_Tp& __element)\n \t{\n-\t  using _Alternative = variant_alternative_t<__index, decay_t<_First>>;\n-\t  using _Qualified_storage = __reserved_type_map<\n-\t    _First, __storage<_Alternative>>;\n+\t  using _Alternative = variant_alternative_t<__index, _Next>;\n \t  __element = __gen_vtable_impl<\n-\t    decay_t<decltype(__element)>, tuple<_Rest...>,\n-\t    tuple<_Args..., _Qualified_storage>>::_S_apply();\n+\t    remove_reference_t<\n+\t      decltype(__element)>, tuple<_Variants...>,\n+\t      std::index_sequence<__indices..., __index>>::_S_apply();\n \t}\n     };\n \n-  template<typename _Result_type, typename _Visitor, typename... _Args>\n+  template<typename _Result_type, typename _Visitor, typename... _Variants,\n+\t   size_t... __indices>\n     struct __gen_vtable_impl<\n-      _Multi_array<_Result_type (*)(_Visitor, _To_type<_Args, void*>...)>,\n-\t\t   tuple<>, tuple<_Args...>>\n+      _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,\n+\t\t   tuple<_Variants...>, std::index_sequence<__indices...>>\n     {\n       using _Array_type =\n-\t_Multi_array<_Result_type (*)(_Visitor&&, _To_type<_Args, void*>...)>;\n+\t  _Multi_array<_Result_type (*)(_Visitor&&, _Variants...)>;\n+\n+      decltype(auto)\n+      static constexpr __visit_invoke(_Visitor&& __visitor, _Variants... __vars)\n+      {\n+\treturn __invoke(std::forward<_Visitor>(__visitor),\n+\t\t\tstd::get<__indices>(\n+\t\t\t    std::forward<_Variants>(__vars))...);\n+      }\n \n       static constexpr auto\n       _S_apply()\n-      { return _Array_type{&__visit_invoke<_Visitor, _Args...>}; }\n+      { return _Array_type{&__visit_invoke}; }\n     };\n \n   template<typename _Result_type, typename _Visitor, typename... _Variants>\n     struct __gen_vtable\n     {\n-      using _Func_ptr =\n-\t_Result_type (*)(_Visitor&&, _To_type<_Variants, void*>...);\n+      using _Func_ptr = _Result_type (*)(_Visitor&&, _Variants...);\n       using _Array_type =\n-\t_Multi_array<_Func_ptr, variant_size_v<decay_t<_Variants>>...>;\n+\t  _Multi_array<_Func_ptr,\n+\t\t       variant_size_v<remove_reference_t<_Variants>>...>;\n \n       static constexpr _Array_type\n       _S_apply()\n       {\n-\treturn __gen_vtable_impl<\n-\t  _Array_type, tuple<_Variants...>, tuple<>>::_S_apply();\n+\treturn __gen_vtable_impl<_Array_type, tuple<_Variants...>,\n+\t\t\t\t std::index_sequence<>>::_S_apply();\n       }\n+\n+      static constexpr auto _S_vtable = _S_apply();\n     };\n \n   template<size_t _Np, typename _Tp>\n@@ -722,22 +713,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;\n     }\n \n-  template<size_t _Np, typename... _Types>\n-    constexpr variant_alternative_t<_Np, variant<_Types...>>&\n-    get(variant<_Types...>&);\n-\n-  template<size_t _Np, typename... _Types>\n-    constexpr variant_alternative_t<_Np, variant<_Types...>>&&\n-    get(variant<_Types...>&&);\n-\n-  template<size_t _Np, typename... _Types>\n-    constexpr variant_alternative_t<_Np, variant<_Types...>> const&\n-    get(const variant<_Types...>&);\n-\n-  template<size_t _Np, typename... _Types>\n-    constexpr variant_alternative_t<_Np, variant<_Types...>> const&&\n-    get(const variant<_Types...>&&);\n-\n   template<typename _Tp, typename... _Types>\n     constexpr inline _Tp& get(variant<_Types...>& __v)\n     {\n@@ -860,7 +835,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return !(__lhs < __rhs); }\n \n   template<typename _Visitor, typename... _Variants>\n-    decltype(auto) visit(_Visitor&&, _Variants&&...);\n+    constexpr decltype(auto) visit(_Visitor&&, _Variants&&...);\n \n   struct monostate { };\n \n@@ -964,9 +939,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _Tp>\n \tusing __accepted_type = __to_type<__accepted_index<_Tp>>;\n \n-      template<typename _Tp>\n-\tusing __storage = __detail::__variant::__storage<_Tp>;\n-\n       template<typename _Tp>\n \tstatic constexpr size_t __index_of =\n \t  __detail::__variant::__index_of_v<_Tp, _Types...>;\n@@ -1127,8 +1099,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (this->_M_valid())\n \t      {\n \t\tstatic constexpr void (*_S_vtable[])(void*, void*) =\n-\t\t  { &__detail::__variant::__erased_swap<\n-\t\t      __storage<_Types>&, __storage<_Types>&>... };\n+\t\t  { &__detail::__variant::__erased_swap<_Types&, _Types&>... };\n \t\t_S_vtable[__rhs._M_index](this->_M_storage(),\n \t\t\t\t\t  __rhs._M_storage());\n \t      }\n@@ -1268,17 +1239,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Visitor, typename... _Variants>\n-    decltype(auto)\n+    constexpr decltype(auto)\n     visit(_Visitor&& __visitor, _Variants&&... __variants)\n     {\n+      if ((__variants.valueless_by_exception() || ...))\n+\t__throw_bad_variant_access(\"Unexpected index\");\n+\n       using _Result_type =\n \tdecltype(std::forward<_Visitor>(__visitor)(get<0>(__variants)...));\n-      static constexpr auto _S_vtable =\n-\t__detail::__variant::__gen_vtable<\n-\t  _Result_type, _Visitor&&, _Variants&&...>::_S_apply();\n-      auto __func_ptr = _S_vtable._M_access(__variants.index()...);\n+\n+      constexpr auto& __vtable = __detail::__variant::__gen_vtable<\n+\t_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;\n+\n+      auto __func_ptr = __vtable._M_access(__variants.index()...);\n       return (*__func_ptr)(std::forward<_Visitor>(__visitor),\n-\t\t\t   __detail::__variant::__get_storage(__variants)...);\n+\t\t\t   std::forward<_Variants>(__variants)...);\n     }\n \n   template<typename... _Types>\n@@ -1297,7 +1272,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  {\n \t    namespace __edv = __detail::__variant;\n \t    static constexpr size_t (*_S_vtable[])(void*) =\n-\t      { &__edv::__erased_hash<const __edv::__storage<_Types>&>... };\n+\t      { &__edv::__erased_hash<const _Types&>... };\n \t    return hash<size_t>{}(__t.index())\n \t      + _S_vtable[__t.index()](__edv::__get_storage(__t));\n \t  }"}, {"sha": "a8ffaeaaecccbffb688fdcc74c96cfb3314cd326", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b01af236b7d0d92cf1e9d642495d9177347bd740/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b01af236b7d0d92cf1e9d642495d9177347bd740/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=b01af236b7d0d92cf1e9d642495d9177347bd740", "patch": "@@ -275,6 +275,22 @@ void test_visit()\n     };\n     visit(Visitor(), variant<int, char>(), variant<float, double>());\n   }\n+  {\n+    struct Visitor\n+    {\n+      constexpr bool operator()(const int&) { return true; }\n+      constexpr bool operator()(const nonliteral&) { return false; }\n+    };\n+    static_assert(visit(Visitor(), variant<int, nonliteral>(0)), \"\");\n+  }\n+  {\n+    struct Visitor\n+    {\n+      constexpr bool operator()(const int&) { return true; }\n+      constexpr bool operator()(const nonliteral&) { return false; }\n+    };\n+    static_assert(visit(Visitor(), variant<int, nonliteral>(0)), \"\");\n+  }\n }\n \n void test_constexpr()"}]}