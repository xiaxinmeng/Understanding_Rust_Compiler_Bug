{"sha": "987b67bc5502c1c826bcb6c6b41728d6e038c96f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg3YjY3YmM1NTAyYzFjODI2YmNiNmM2YjQxNzI4ZDZlMDM4Yzk2Zg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-06-26T21:21:34Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-26T21:21:34Z"}, "message": "builtins.c, [...]: Use fold_buildN instead of fold (buildN (...)).\n\n\t* builtins.c, c-common.c, c-convert.c, c-decl.c, c-typeck.c,\n\tconvert.c, lambda-code.c, predict.c, tree-cfg.c,\n\ttree-complex.c, tree-data-ref.c, tree-if-conv.c,\n\ttree-mudflap.c, tree-scalar-evolution.c, tree-ssa-ccp.c,\n\ttree-ssa-loop-ivcanon.c, tree-ssa-loop-ivopts.c,\n\ttree-ssa-loop-manip.c, tree-ssa-phiopt.c, tree-ssa-pre.c,\n\ttree-vect-analyze.c, tree-vect-transform.c, tree-vectorizer.c,\n\ttree.c: Use fold_buildN instead of fold (buildN (...)).\n\nFrom-SVN: r101338", "tree": {"sha": "2b44df571f1322c6e8919fb2cb0153a1b07bc292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b44df571f1322c6e8919fb2cb0153a1b07bc292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/987b67bc5502c1c826bcb6c6b41728d6e038c96f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987b67bc5502c1c826bcb6c6b41728d6e038c96f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/987b67bc5502c1c826bcb6c6b41728d6e038c96f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/987b67bc5502c1c826bcb6c6b41728d6e038c96f/comments", "author": null, "committer": null, "parents": [{"sha": "d967c45e83d3d79e100f88a5ed26c63c33e91754", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d967c45e83d3d79e100f88a5ed26c63c33e91754", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d967c45e83d3d79e100f88a5ed26c63c33e91754"}], "stats": {"total": 458, "additions": 234, "deletions": 224}, "files": [{"sha": "305ab250f53b3e61d5f6e40d492ab61a2abc7b06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -3,6 +3,15 @@\n \t* cfg.c, tree-vect-transform.c, tree.def: Fix comment typos.\n \t* doc/invoke.texi: Fix typos.\n \n+\t* builtins.c, c-common.c, c-convert.c, c-decl.c, c-typeck.c,\n+\tconvert.c, lambda-code.c, predict.c, tree-cfg.c,\n+\ttree-complex.c, tree-data-ref.c, tree-if-conv.c,\n+\ttree-mudflap.c, tree-scalar-evolution.c, tree-ssa-ccp.c,\n+\ttree-ssa-loop-ivcanon.c, tree-ssa-loop-ivopts.c,\n+\ttree-ssa-loop-manip.c, tree-ssa-phiopt.c, tree-ssa-pre.c,\n+\ttree-vect-analyze.c, tree-vect-transform.c, tree-vectorizer.c,\n+\ttree.c: Use fold_buildN instead of fold (buildN (...)).\n+\n 2005-06-26  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/install.texi (Specific): Do not specify the concrete"}, {"sha": "c966c0e0da306016b4dbb8b1da10ea85c61687c4", "filename": "gcc/builtins.c", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -3342,7 +3342,7 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t\t\t\t    &c, dest_align))\n \t    return 0;\n \n-\t  val = fold (build1 (CONVERT_EXPR, unsigned_char_type_node, val));\n+\t  val = fold_build1 (CONVERT_EXPR, unsigned_char_type_node, val);\n \t  val_rtx = expand_expr (val, NULL_RTX, VOIDmode, 0);\n \t  val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n \t\t\t       val_rtx);\n@@ -3727,8 +3727,8 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n       return 0;\n \n     /* The actual new length parameter is MIN(len,arg3).  */\n-    len = fold (build2 (MIN_EXPR, TREE_TYPE (len), len,\n-\t\t\tfold_convert (TREE_TYPE (len), arg3)));\n+    len = fold_build2 (MIN_EXPR, TREE_TYPE (len), len,\n+\t\t       fold_convert (TREE_TYPE (len), arg3));\n \n     /* If we don't have POINTER_TYPE, call the function.  */\n     if (arg1_align == 0 || arg2_align == 0)\n@@ -3825,7 +3825,7 @@ expand_builtin_strcat (tree arglist, tree type, rtx target, enum machine_mode mo\n \t\t\t\t\t\t\t\t dst)));\n \t      /* Create (dst + (cast) strlen (dst)).  */\n \t      newdst = fold_convert (TREE_TYPE (dst), newdst);\n-\t      newdst = fold (build2 (PLUS_EXPR, TREE_TYPE (dst), dst, newdst));\n+\t      newdst = fold_build2 (PLUS_EXPR, TREE_TYPE (dst), dst, newdst);\n \n \t      /* Prepend the new dst argument.  */\n \t      arglist = tree_cons (NULL_TREE, newdst, arglist);\n@@ -4009,7 +4009,7 @@ stabilize_va_list (tree valist, int needs_lvalue)\n \t    return valist;\n \n \t  pt = build_pointer_type (va_list_type_node);\n-\t  valist = fold (build1 (ADDR_EXPR, pt, valist));\n+\t  valist = fold_build1 (ADDR_EXPR, pt, valist);\n \t  TREE_SIDE_EFFECTS (valist) = 1;\n \t}\n \n@@ -4141,11 +4141,11 @@ std_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n   if (PAD_VARARGS_DOWN && !integer_zerop (rounded_size))\n     {\n       /* Small args are padded downward.  */\n-      t = fold (build2 (GT_EXPR, sizetype, rounded_size, size_int (align)));\n-      t = fold (build3 (COND_EXPR, sizetype, t, size_zero_node,\n-\t\t\tsize_binop (MINUS_EXPR, rounded_size, type_size)));\n+      t = fold_build2 (GT_EXPR, sizetype, rounded_size, size_int (align));\n+      t = fold_build3 (COND_EXPR, sizetype, t, size_zero_node,\n+\t\t       size_binop (MINUS_EXPR, rounded_size, type_size));\n       t = fold_convert (TREE_TYPE (addr), t);\n-      addr = fold (build2 (PLUS_EXPR, TREE_TYPE (addr), addr, t));\n+      addr = fold_build2 (PLUS_EXPR, TREE_TYPE (addr), addr, t);\n     }\n \n   /* Compute new value for AP.  */\n@@ -5129,8 +5129,8 @@ expand_builtin_signbit (tree exp, rtx target)\n     if (fmt->has_signed_zero && HONOR_SIGNED_ZEROS (fmode))\n       return 0;\n \n-    arg = fold (build2 (LT_EXPR, TREE_TYPE (exp), arg,\n-\t\t\tbuild_real (TREE_TYPE (arg), dconst0)));\n+    arg = fold_build2 (LT_EXPR, TREE_TYPE (exp), arg,\n+\t\t       build_real (TREE_TYPE (arg), dconst0));\n     return expand_expr (arg, target, VOIDmode, EXPAND_NORMAL);\n   }\n \n@@ -6626,7 +6626,7 @@ fold_fixed_mathfn (tree fndecl, tree arglist)\n   /* If argument is already integer valued, and we don't need to worry\n      about setting errno, there's no need to perform rounding.  */\n   if (! flag_errno_math && integer_valued_real_p (arg))\n-    return fold (build1 (FIX_TRUNC_EXPR, TREE_TYPE (TREE_TYPE (fndecl)), arg));\n+    return fold_build1 (FIX_TRUNC_EXPR, TREE_TYPE (TREE_TYPE (fndecl)), arg);\n \n   if (optimize)\n     {\n@@ -6687,10 +6687,10 @@ fold_builtin_cabs (tree arglist, tree type)\n   /* If either part is zero, cabs is fabs of the other.  */\n   if (TREE_CODE (arg) == COMPLEX_EXPR\n       && real_zerop (TREE_OPERAND (arg, 0)))\n-    return fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg, 1)));\n+    return fold_build1 (ABS_EXPR, type, TREE_OPERAND (arg, 1));\n   if (TREE_CODE (arg) == COMPLEX_EXPR\n       && real_zerop (TREE_OPERAND (arg, 1)))\n-    return fold (build1 (ABS_EXPR, type, TREE_OPERAND (arg, 0)));\n+    return fold_build1 (ABS_EXPR, type, TREE_OPERAND (arg, 0));\n \n   /* Don't do this when optimizing for size.  */\n   if (flag_unsafe_math_optimizations\n@@ -6704,17 +6704,17 @@ fold_builtin_cabs (tree arglist, tree type)\n \n \t  arg = builtin_save_expr (arg);\n \n-\t  rpart = fold (build1 (REALPART_EXPR, type, arg));\n-\t  ipart = fold (build1 (IMAGPART_EXPR, type, arg));\n+\t  rpart = fold_build1 (REALPART_EXPR, type, arg);\n+\t  ipart = fold_build1 (IMAGPART_EXPR, type, arg);\n \n \t  rpart = builtin_save_expr (rpart);\n \t  ipart = builtin_save_expr (ipart);\n \n-\t  result = fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t fold (build2 (MULT_EXPR, type,\n-\t\t\t\t\t       rpart, rpart)),\n-\t\t\t\t fold (build2 (MULT_EXPR, type,\n-\t\t\t\t\t       ipart, ipart))));\n+\t  result = fold_build2 (PLUS_EXPR, type,\n+\t\t\t\tfold_build2 (MULT_EXPR, type,\n+\t\t\t\t\t     rpart, rpart),\n+\t\t\t\tfold_build2 (MULT_EXPR, type,\n+\t\t\t\t\t     ipart, ipart));\n \n \t  arglist = build_tree_list (NULL_TREE, result);\n \t  return build_function_call_expr (sqrtfn, arglist);\n@@ -6754,9 +6754,9 @@ fold_builtin_sqrt (tree arglist, tree type)\n   if (flag_unsafe_math_optimizations && BUILTIN_EXPONENT_P (fcode))\n     {\n       tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n-      arg = fold (build2 (MULT_EXPR, type,\n-\t\t\t  TREE_VALUE (TREE_OPERAND (arg, 1)),\n-\t\t\t  build_real (type, dconsthalf)));\n+      arg = fold_build2 (MULT_EXPR, type,\n+\t\t\t TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t build_real (type, dconsthalf));\n       arglist = build_tree_list (NULL_TREE, arg);\n       return build_function_call_expr (expfn, arglist);\n     }\n@@ -6796,8 +6796,8 @@ fold_builtin_sqrt (tree arglist, tree type)\n       tree narg1;\n       if (!tree_expr_nonnegative_p (arg0))\n \targ0 = build1 (ABS_EXPR, type, arg0);\n-      narg1 = fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t    build_real (type, dconsthalf)));\n+      narg1 = fold_build2 (MULT_EXPR, type, arg1,\n+\t\t\t   build_real (type, dconsthalf));\n       arglist = tree_cons (NULL_TREE, arg0,\n \t\t\t   build_tree_list (NULL_TREE, narg1));\n       return build_function_call_expr (powfn, arglist);\n@@ -6829,9 +6829,9 @@ fold_builtin_cbrt (tree arglist, tree type)\n \t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t  const REAL_VALUE_TYPE third_trunc =\n \t    real_value_truncate (TYPE_MODE (type), dconstthird);\n-\t  arg = fold (build2 (MULT_EXPR, type,\n-\t\t\t      TREE_VALUE (TREE_OPERAND (arg, 1)),\n-\t\t\t      build_real (type, third_trunc)));\n+\t  arg = fold_build2 (MULT_EXPR, type,\n+\t\t\t     TREE_VALUE (TREE_OPERAND (arg, 1)),\n+\t\t\t     build_real (type, third_trunc));\n \t  arglist = build_tree_list (NULL_TREE, arg);\n \t  return build_function_call_expr (expfn, arglist);\n \t}\n@@ -6890,8 +6890,8 @@ fold_builtin_cbrt (tree arglist, tree type)\n \t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t      const REAL_VALUE_TYPE dconstroot\n \t\t= real_value_truncate (TYPE_MODE (type), dconstthird);\n-\t      tree narg01 = fold (build2 (MULT_EXPR, type, arg01,\n-\t\t\t\t\t  build_real (type, dconstroot)));\n+\t      tree narg01 = fold_build2 (MULT_EXPR, type, arg01,\n+\t\t\t\t\t build_real (type, dconstroot));\n \t      arglist = tree_cons (NULL_TREE, arg00,\n \t\t\t\t   build_tree_list (NULL_TREE, narg01));\n \t      return build_function_call_expr (powfn, arglist);\n@@ -7412,7 +7412,7 @@ fold_builtin_logarithm (tree fndecl, tree arglist,\n \t      tree logfn;\n \t      arglist = build_tree_list (NULL_TREE, x);\n \t      logfn = build_function_call_expr (fndecl, arglist);\n-\t      return fold (build2 (MULT_EXPR, type, exponent, logfn));\n+\t      return fold_build2 (MULT_EXPR, type, exponent, logfn);\n \t    }\n \t}\n     }\n@@ -7455,8 +7455,8 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \n       /* Optimize pow(x,-1.0) = 1.0/x.  */\n       if (REAL_VALUES_EQUAL (c, dconstm1))\n-\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t     build_real (type, dconst1), arg0));\n+\treturn fold_build2 (RDIV_EXPR, type,\n+\t\t\t    build_real (type, dconst1), arg0);\n \n       /* Optimize pow(x,0.5) = sqrt(x).  */\n       if (flag_unsafe_math_optimizations\n@@ -7512,7 +7512,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n         {\n \t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n \t  tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t  arg = fold (build2 (MULT_EXPR, type, arg, arg1));\n+\t  arg = fold_build2 (MULT_EXPR, type, arg, arg1);\n \t  arglist = build_tree_list (NULL_TREE, arg);\n \t  return build_function_call_expr (expfn, arglist);\n \t}\n@@ -7521,8 +7521,8 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n       if (BUILTIN_SQRT_P (fcode))\n         {\n \t  tree narg0 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t  tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t     build_real (type, dconsthalf)));\n+\t  tree narg1 = fold_build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t    build_real (type, dconsthalf));\n \n \t  arglist = tree_cons (NULL_TREE, narg0,\n \t\t\t       build_tree_list (NULL_TREE, narg1));\n@@ -7537,8 +7537,8 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \t    {\n \t      const REAL_VALUE_TYPE dconstroot\n \t\t= real_value_truncate (TYPE_MODE (type), dconstthird);\n-\t      tree narg1 = fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t\t build_real (type, dconstroot)));\n+\t      tree narg1 = fold_build2 (MULT_EXPR, type, arg1,\n+\t\t\t\t\tbuild_real (type, dconstroot));\n \t      arglist = tree_cons (NULL_TREE, arg,\n \t\t\t\t   build_tree_list (NULL_TREE, narg1));\n \t      return build_function_call_expr (fndecl, arglist);\n@@ -7551,7 +7551,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n         {\n \t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n-\t  tree narg1 = fold (build2 (MULT_EXPR, type, arg01, arg1));\n+\t  tree narg1 = fold_build2 (MULT_EXPR, type, arg01, arg1);\n \t  arglist = tree_cons (NULL_TREE, arg00,\n \t\t\t       build_tree_list (NULL_TREE, narg1));\n \t  return build_function_call_expr (fndecl, arglist);\n@@ -7601,8 +7601,8 @@ fold_builtin_powi (tree fndecl ATTRIBUTE_UNUSED, tree arglist, tree type)\n \n       /* Optimize pow(x,-1) = 1.0/x.  */\n       if (c == -1)\n-\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t     build_real (type, dconst1), arg0));\n+\treturn fold_build2 (RDIV_EXPR, type,\n+\t\t\t   build_real (type, dconst1), arg0);\n     }\n \n   return NULL_TREE;\n@@ -7731,11 +7731,11 @@ fold_builtin_mempcpy (tree arglist, tree type, int endp)\n \t    return omit_one_operand (type, dest, len);\n \n \t  if (endp == 2)\n-\t    len = fold (build2 (MINUS_EXPR, TREE_TYPE (len), len,\n-\t\t\t\tssize_int (1)));\n+\t    len = fold_build2 (MINUS_EXPR, TREE_TYPE (len), len,\n+\t\t\t       ssize_int (1));\n       \n \t  len = fold_convert (TREE_TYPE (dest), len);\n-\t  len = fold (build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len));\n+\t  len = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n \t  return fold_convert (type, len);\n \t}\n     }\n@@ -7919,7 +7919,7 @@ fold_builtin_memcmp (tree arglist)\n \t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n \t\t\t\t\t\t      arg2)));\n-      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      return fold_build2 (MINUS_EXPR, integer_type_node, ind1, ind2);\n     }\n \n   return 0;\n@@ -7978,7 +7978,7 @@ fold_builtin_strcmp (tree arglist)\n \t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n \t\t\t\t\t\t      arg2)));\n-      return fold (build1 (NEGATE_EXPR, integer_type_node, temp));\n+      return fold_build1 (NEGATE_EXPR, integer_type_node, temp);\n     }\n \n   return 0;\n@@ -8050,7 +8050,7 @@ fold_builtin_strncmp (tree arglist)\n \t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n \t\t\t\t\t\t      arg2)));\n-      return fold (build1 (NEGATE_EXPR, integer_type_node, temp));\n+      return fold_build1 (NEGATE_EXPR, integer_type_node, temp);\n     }\n \n   /* If len parameter is one, return an expression corresponding to\n@@ -8067,7 +8067,7 @@ fold_builtin_strncmp (tree arglist)\n \t\t\t\tbuild1 (INDIRECT_REF, cst_uchar_node,\n \t\t\t\t\tfold_convert (cst_uchar_ptr_node,\n \t\t\t\t\t\t      arg2)));\n-      return fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n+      return fold_build2 (MINUS_EXPR, integer_type_node, ind1, ind2);\n     }\n \n   return 0;\n@@ -8104,8 +8104,8 @@ fold_builtin_signbit (tree fndecl, tree arglist)\n \n   /* If ARG's format doesn't have signed zeros, return \"arg < 0.0\".  */\n   if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg))))\n-    return fold (build2 (LT_EXPR, type, arg,\n-\t\t\t build_real (TREE_TYPE (arg), dconst0)));\n+    return fold_build2 (LT_EXPR, type, arg,\n+\t\t\tbuild_real (TREE_TYPE (arg), dconst0));\n \n   return NULL_TREE;\n }\n@@ -8147,7 +8147,7 @@ fold_builtin_copysign (tree fndecl, tree arglist, tree type)\n      Remember to evaluate Y for side-effects.  */\n   if (tree_expr_nonnegative_p (arg2))\n     return omit_one_operand (type,\n-\t\t\t     fold (build1 (ABS_EXPR, type, arg1)),\n+\t\t\t     fold_build1 (ABS_EXPR, type, arg1),\n \t\t\t     arg2);\n \n   /* Strip sign changing operations for the first argument.  */\n@@ -8176,8 +8176,8 @@ fold_builtin_isascii (tree arglist)\n       arg = build2 (BIT_AND_EXPR, integer_type_node, arg,\n \t\t    build_int_cst (NULL_TREE,\n \t\t\t\t   ~ (unsigned HOST_WIDE_INT) 0x7f));\n-      arg = fold (build2 (EQ_EXPR, integer_type_node,\n-\t\t\t  arg, integer_zero_node));\n+      arg = fold_build2 (EQ_EXPR, integer_type_node,\n+\t\t\t arg, integer_zero_node);\n \n       if (in_gimple_form && !TREE_CONSTANT (arg))\n         return NULL_TREE;\n@@ -8198,8 +8198,8 @@ fold_builtin_toascii (tree arglist)\n       /* Transform toascii(c) -> (c & 0x7f).  */\n       tree arg = TREE_VALUE (arglist);\n \n-      return fold (build2 (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t\t   build_int_cst (NULL_TREE, 0x7f)));\n+      return fold_build2 (BIT_AND_EXPR, integer_type_node, arg,\n+\t\t\t  build_int_cst (NULL_TREE, 0x7f));\n     }\n }\n \n@@ -8249,7 +8249,7 @@ fold_builtin_fabs (tree arglist, tree type)\n   arg = fold_convert (type, arg);\n   if (TREE_CODE (arg) == REAL_CST)\n     return fold_abs_const (arg, type);\n-  return fold (build1 (ABS_EXPR, type, arg));\n+  return fold_build1 (ABS_EXPR, type, arg);\n }\n \n /* Fold a call to abs, labs, llabs or imaxabs.  */\n@@ -8266,7 +8266,7 @@ fold_builtin_abs (tree arglist, tree type)\n   arg = fold_convert (type, arg);\n   if (TREE_CODE (arg) == INTEGER_CST)\n     return fold_abs_const (arg, type);\n-  return fold (build1 (ABS_EXPR, type, arg));\n+  return fold_build1 (ABS_EXPR, type, arg);\n }\n \n /* Fold a call to __builtin_isnan(), __builtin_isinf, __builtin_finite.\n@@ -8346,7 +8346,7 @@ fold_builtin_classify (tree fndecl, tree arglist, int builtin_index)\n \t}\n \n       arg = builtin_save_expr (arg);\n-      return fold (build2 (UNORDERED_EXPR, type, arg, arg));\n+      return fold_build2 (UNORDERED_EXPR, type, arg, arg);\n \n     default:\n       gcc_unreachable ();\n@@ -8421,13 +8421,13 @@ fold_builtin_unordered_cmp (tree fndecl, tree arglist,\n     {\n       if (!MODE_HAS_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n \treturn omit_two_operands (type, integer_zero_node, arg0, arg1);\n-      return fold (build2 (UNORDERED_EXPR, type, arg0, arg1));\n+      return fold_build2 (UNORDERED_EXPR, type, arg0, arg1);\n     }\n \n   code = MODE_HAS_NANS (TYPE_MODE (TREE_TYPE (arg0))) ? unordered_code\n \t\t\t\t\t\t      : ordered_code;\n-  return fold (build1 (TRUTH_NOT_EXPR, type,\n-\t\t       fold (build2 (code, type, arg0, arg1))));\n+  return fold_build1 (TRUTH_NOT_EXPR, type,\n+\t\t      fold_build2 (code, type, arg0, arg1));\n }\n \n /* Used by constant folding to simplify calls to builtin functions.  EXP is\n@@ -8536,23 +8536,23 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     case BUILT_IN_CONJF:\n     case BUILT_IN_CONJL:\n       if (validate_arglist (arglist, COMPLEX_TYPE, VOID_TYPE))\n-\treturn fold (build1 (CONJ_EXPR, type, TREE_VALUE (arglist)));\n+\treturn fold_build1 (CONJ_EXPR, type, TREE_VALUE (arglist));\n       break;\n \n     case BUILT_IN_CREAL:\n     case BUILT_IN_CREALF:\n     case BUILT_IN_CREALL:\n       if (validate_arglist (arglist, COMPLEX_TYPE, VOID_TYPE))\n-        return non_lvalue (fold (build1 (REALPART_EXPR, type,\n-\t\t\t\t\t TREE_VALUE (arglist))));\n+        return non_lvalue (fold_build1 (REALPART_EXPR, type,\n+\t\t\t\t\tTREE_VALUE (arglist)));\n       break;\n \n     case BUILT_IN_CIMAG:\n     case BUILT_IN_CIMAGF:\n     case BUILT_IN_CIMAGL:\n       if (validate_arglist (arglist, COMPLEX_TYPE, VOID_TYPE))\n-        return non_lvalue (fold (build1 (IMAGPART_EXPR, type,\n-\t\t\t\t\t TREE_VALUE (arglist))));\n+        return non_lvalue (fold_build1 (IMAGPART_EXPR, type,\n+\t\t\t\t\tTREE_VALUE (arglist)));\n       break;\n \n     case BUILT_IN_CABS:\n@@ -8961,8 +8961,8 @@ fold_builtin_strstr (tree arglist, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, build_int_cst (TREE_TYPE (s1), r - p1)));\n+\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n \t  return fold_convert (type, tem);\n \t}\n \n@@ -9031,8 +9031,8 @@ fold_builtin_strchr (tree arglist, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, build_int_cst (TREE_TYPE (s1), r - p1)));\n+\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n \t  return fold_convert (type, tem);\n \t}\n       return 0;\n@@ -9086,8 +9086,8 @@ fold_builtin_strrchr (tree arglist, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, build_int_cst (TREE_TYPE (s1), r - p1)));\n+\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n \t  return fold_convert (type, tem);\n \t}\n \n@@ -9145,8 +9145,8 @@ fold_builtin_strpbrk (tree arglist, tree type)\n \t    return build_int_cst (TREE_TYPE (s1), 0);\n \n \t  /* Return an offset into the constant string argument.  */\n-\t  tem = fold (build2 (PLUS_EXPR, TREE_TYPE (s1),\n-\t\t\t      s1, build_int_cst (TREE_TYPE (s1), r - p1)));\n+\t  tem = fold_build2 (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t     s1, build_int_cst (TREE_TYPE (s1), r - p1));\n \t  return fold_convert (type, tem);\n \t}\n "}, {"sha": "6b753dcb5d3ba2700a0ff6f750a98b94d10849ce", "filename": "gcc/c-common.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -1812,7 +1812,7 @@ min_precision (tree value, int unsignedp)\n      a bit-wise negation, so use that operation instead.  */\n \n   if (tree_int_cst_sgn (value) < 0)\n-    value = fold (build1 (BIT_NOT_EXPR, TREE_TYPE (value), value));\n+    value = fold_build1 (BIT_NOT_EXPR, TREE_TYPE (value), value);\n \n   /* Return the number of bits needed, taking into account the fact\n      that we need one more bit for a signed than unsigned type.  */\n@@ -2309,7 +2309,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n-  return fold (build2 (resultcode, result_type, ptrop, intop));\n+  return fold_build2 (resultcode, result_type, ptrop, intop);\n }\n \f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n@@ -2425,10 +2425,10 @@ c_common_truthvalue_conversion (tree expr)\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n-      return fold (build3 (COND_EXPR, truthvalue_type_node,\n+      return fold_build3 (COND_EXPR, truthvalue_type_node,\n \t\tTREE_OPERAND (expr, 0),\n \t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 1)),\n-\t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 2))));\n+\t\tc_common_truthvalue_conversion (TREE_OPERAND (expr, 2)));\n \n     case CONVERT_EXPR:\n       /* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE,\n@@ -2837,7 +2837,7 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n      TYPE_IS_SIZETYPE means that certain things (like overflow) will\n      never happen.  However, this node should really have type\n      `size_t', which is just a typedef for an ordinary integer type.  */\n-  value = fold (build1 (NOP_EXPR, size_type_node, value));\n+  value = fold_build1 (NOP_EXPR, size_type_node, value);\n   gcc_assert (!TYPE_IS_SIZETYPE (TREE_TYPE (value)));\n \n   return value;\n@@ -2887,7 +2887,7 @@ c_alignof_expr (tree expr)\n   else\n     return c_alignof (TREE_TYPE (expr));\n \n-  return fold (build1 (NOP_EXPR, size_type_node, t));\n+  return fold_build1 (NOP_EXPR, size_type_node, t);\n }\n \f\n /* Handle C and C++ default attributes.  */\n@@ -5759,7 +5759,7 @@ fold_offsetof_1 (tree expr)\n       if (TREE_CODE (t) == INTEGER_CST && tree_int_cst_sgn (t) < 0)\n \t{\n \t  code = MINUS_EXPR;\n-\t  t = fold (build1 (NEGATE_EXPR, TREE_TYPE (t), t));\n+\t  t = fold_build1 (NEGATE_EXPR, TREE_TYPE (t), t);\n \t}\n       t = convert (sizetype, t);\n       off = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (TREE_TYPE (expr)), t);"}, {"sha": "8b783838b1c678989f1344b229e6fcdc1f27eed7", "filename": "gcc/c-convert.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -76,7 +76,7 @@ convert (tree type, tree expr)\n     return expr;\n \n   if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (expr)))\n-    return fold (build1 (NOP_EXPR, type, expr));\n+    return fold_build1 (NOP_EXPR, type, expr);\n   if (TREE_CODE (TREE_TYPE (expr)) == ERROR_MARK)\n     return error_mark_node;\n   if (TREE_CODE (TREE_TYPE (expr)) == VOID_TYPE)\n@@ -103,9 +103,9 @@ convert (tree type, tree expr)\n       /* If it returns a NOP_EXPR, we must fold it here to avoid\n \t infinite recursion between fold () and convert ().  */\n       if (TREE_CODE (t) == NOP_EXPR)\n-\treturn fold (build1 (NOP_EXPR, type, TREE_OPERAND (t, 0)));\n+\treturn fold_build1 (NOP_EXPR, type, TREE_OPERAND (t, 0));\n       else\n-\treturn fold (build1 (NOP_EXPR, type, t));\n+\treturn fold_build1 (NOP_EXPR, type, t);\n     }\n   if (code == POINTER_TYPE || code == REFERENCE_TYPE)\n     return fold (convert_to_pointer (type, e));"}, {"sha": "4d487926e5c56b29577c41ee2fa8b0d174430fde", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -4180,10 +4180,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       - 1.  Do the calculation in index_type, so that\n \t\t       if it is a variable the computations will be\n \t\t       done in the proper mode.  */\n-\t\t    itype = fold (build2 (MINUS_EXPR, index_type,\n-\t\t\t\t\t  convert (index_type, size),\n-\t\t\t\t\t  convert (index_type,\n-\t\t\t\t\t\t   size_one_node)));\n+\t\t    itype = fold_build2 (MINUS_EXPR, index_type,\n+\t\t\t\t\t convert (index_type, size),\n+\t\t\t\t\t convert (index_type,\n+\t\t\t\t\t\t  size_one_node));\n \n \t\t    /* If that overflowed, the array is too big.  ??? \n \t\t       While a size of INT_MAX+1 technically shouldn't"}, {"sha": "483beb8c7cf2fea2f0f5ef2206f841ce6bbd0299", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -2050,7 +2050,7 @@ build_function_call (tree function, tree params)\n \t\t\t\t\t  build_constructor (return_type,\n \t\t\t\t\t\t\t     NULL_TREE));\n \t  else\n-\t    rhs = fold (build1 (NOP_EXPR, return_type, integer_zero_node));\n+\t    rhs = fold_build1 (NOP_EXPR, return_type, integer_zero_node);\n \n \t  return build2 (COMPOUND_EXPR, return_type, trap, rhs);\n \t}\n@@ -2477,7 +2477,7 @@ pointer_diff (tree op0, tree op1)\n   op1 = c_size_in_bytes (target_type);\n \n   /* Divide by the size, in easiest possible way.  */\n-  return fold (build2 (EXACT_DIV_EXPR, restype, op0, convert (restype, op1)));\n+  return fold_build2 (EXACT_DIV_EXPR, restype, op0, convert (restype, op1));\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -2595,15 +2595,15 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \treturn TREE_REALPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\treturn fold (build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+\treturn fold_build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n \treturn arg;\n \n     case IMAGPART_EXPR:\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \treturn TREE_IMAGPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\treturn fold (build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+\treturn fold_build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       else\n \treturn convert (TREE_TYPE (arg), integer_zero_node);\n "}, {"sha": "e3a94783f044381e4a8f731570b3ac0955f666b9", "filename": "gcc/convert.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -290,8 +290,8 @@ convert_to_real (tree type, tree expr)\n \n     case COMPLEX_TYPE:\n       return convert (type,\n-\t\t      fold (build1 (REALPART_EXPR,\n-\t\t\t\t    TREE_TYPE (TREE_TYPE (expr)), expr)));\n+\t\t      fold_build1 (REALPART_EXPR,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)), expr));\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -607,9 +607,9 @@ convert_to_integer (tree type, tree expr)\n \t\t    else\n \t\t      typex = lang_hooks.types.signed_type (typex);\n \t\t    return convert (type,\n-\t\t\t\t    fold (build2 (ex_form, typex,\n-\t\t\t\t\t\t  convert (typex, arg0),\n-\t\t\t\t\t\t  convert (typex, arg1))));\n+\t\t\t\t    fold_build2 (ex_form, typex,\n+\t\t\t\t\t\t convert (typex, arg0),\n+\t\t\t\t\t\t convert (typex, arg1)));\n \t\t  }\n \t      }\n \t  }\n@@ -640,9 +640,9 @@ convert_to_integer (tree type, tree expr)\n \t\telse\n \t\t  typex = lang_hooks.types.signed_type (typex);\n \t\treturn convert (type,\n-\t\t\t\tfold (build1 (ex_form, typex,\n-\t\t\t\t\t      convert (typex,\n-\t\t\t\t\t\t       TREE_OPERAND (expr, 0)))));\n+\t\t\t\tfold_build1 (ex_form, typex,\n+\t\t\t\t\t     convert (typex,\n+\t\t\t\t\t\t      TREE_OPERAND (expr, 0))));\n \t      }\n \t  }\n \n@@ -660,9 +660,9 @@ convert_to_integer (tree type, tree expr)\n \tcase COND_EXPR:\n \t  /* It is sometimes worthwhile to push the narrowing down through\n \t     the conditional and never loses.  */\n-\t  return fold (build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n-\t\t\t       convert (type, TREE_OPERAND (expr, 1)),\n-\t\t\t       convert (type, TREE_OPERAND (expr, 2))));\n+\t  return fold_build3 (COND_EXPR, type, TREE_OPERAND (expr, 0),\n+\t\t\t      convert (type, TREE_OPERAND (expr, 1)),\n+\t\t\t      convert (type, TREE_OPERAND (expr, 2)));\n \n \tdefault:\n \t  break;\n@@ -675,8 +675,8 @@ convert_to_integer (tree type, tree expr)\n \n     case COMPLEX_TYPE:\n       return convert (type,\n-\t\t      fold (build1 (REALPART_EXPR,\n-\t\t\t\t    TREE_TYPE (TREE_TYPE (expr)), expr)));\n+\t\t      fold_build1 (REALPART_EXPR,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)), expr));\n \n     case VECTOR_TYPE:\n       if (!tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (TREE_TYPE (expr))))\n@@ -716,22 +716,22 @@ convert_to_complex (tree type, tree expr)\n \tif (TYPE_MAIN_VARIANT (elt_type) == TYPE_MAIN_VARIANT (subtype))\n \t  return expr;\n \telse if (TREE_CODE (expr) == COMPLEX_EXPR)\n-\t  return fold (build2 (COMPLEX_EXPR, type,\n-\t\t\t       convert (subtype, TREE_OPERAND (expr, 0)),\n-\t\t\t       convert (subtype, TREE_OPERAND (expr, 1))));\n+\t  return fold_build2 (COMPLEX_EXPR, type,\n+\t\t\t      convert (subtype, TREE_OPERAND (expr, 0)),\n+\t\t\t      convert (subtype, TREE_OPERAND (expr, 1)));\n \telse\n \t  {\n \t    expr = save_expr (expr);\n \t    return\n-\t      fold (build2 (COMPLEX_EXPR, type,\n-\t\t\t    convert (subtype,\n-\t\t\t\t     fold (build1 (REALPART_EXPR,\n-\t\t\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t\t\t   expr))),\n-\t\t\t    convert (subtype,\n-\t\t\t\t     fold (build1 (IMAGPART_EXPR,\n-\t\t\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t\t\t\t   expr)))));\n+\t      fold_build2 (COMPLEX_EXPR, type,\n+\t\t\t   convert (subtype,\n+\t\t\t\t    fold_build1 (REALPART_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t\t expr)),\n+\t\t\t   convert (subtype,\n+\t\t\t\t    fold_build1 (IMAGPART_EXPR,\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t\t\t expr)));\n \t  }\n       }\n "}, {"sha": "29b3e5ae708837ce08ff68f236286c9cef1dcf6d", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -1592,7 +1592,7 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \t  /* newname = coefficient * induction_variable */\n \t  coeffmult = build_int_cst (type, LBV_COEFFICIENTS (lbv)[i]);\n \t  stmt = build (MODIFY_EXPR, void_type_node, resvar,\n-\t\t\tfold (build (MULT_EXPR, type, iv, coeffmult)));\n+\t\t\tfold_build2 (MULT_EXPR, type, iv, coeffmult));\n \n \t  newname = make_ssa_name (resvar, stmt);\n \t  TREE_OPERAND (stmt, 0) = newname;\n@@ -1694,7 +1694,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t\t{\n \t\t  coeff = build_int_cst (type,\n \t\t\t\t\t LLE_COEFFICIENTS (lle)[i]);\n-\t\t  mult = fold (build (MULT_EXPR, type, iv, coeff));\n+\t\t  mult = fold_build2 (MULT_EXPR, type, iv, coeff);\n \t\t}\n \n \t      /* newname = mult */\n@@ -1735,7 +1735,7 @@ lle_to_gcc_expression (lambda_linear_expression lle,\n \t      else\n \t\t{\n \t\t  coeff = build_int_cst (type, invcoeff);\n-\t\t  mult = fold (build (MULT_EXPR, type, invar, coeff));\n+\t\t  mult = fold_build2 (MULT_EXPR, type, invar, coeff);\n \t\t}\n \n \t      /* newname = mult */"}, {"sha": "305ada6c4f2f393843a6dea4738239ed5a27e85f", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -994,7 +994,7 @@ expr_expected_value (tree expr, bitmap visited)\n       op1 = expr_expected_value (TREE_OPERAND (expr, 1), visited);\n       if (!op1)\n \treturn NULL;\n-      res = fold (build (TREE_CODE (expr), TREE_TYPE (expr), op0, op1));\n+      res = fold_build2 (TREE_CODE (expr), TREE_TYPE (expr), op0, op1);\n       if (TREE_CONSTANT (res))\n \treturn res;\n       return NULL;\n@@ -1005,7 +1005,7 @@ expr_expected_value (tree expr, bitmap visited)\n       op0 = expr_expected_value (TREE_OPERAND (expr, 0), visited);\n       if (!op0)\n \treturn NULL;\n-      res = fold (build1 (TREE_CODE (expr), TREE_TYPE (expr), op0));\n+      res = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr), op0);\n       if (TREE_CONSTANT (res))\n \treturn res;\n       return NULL;"}, {"sha": "42dabb9a83e5965138cf29166ba8c9d6e21efcc0", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -4965,7 +4965,7 @@ gimplify_build3 (block_stmt_iterator *bsi, enum tree_code code,\n {\n   tree ret;\n \n-  ret = fold (build3 (code, type, a, b, c));\n+  ret = fold_build3 (code, type, a, b, c);\n   STRIP_NOPS (ret);\n \n   return gimplify_val (bsi, type, ret);\n@@ -4980,7 +4980,7 @@ gimplify_build2 (block_stmt_iterator *bsi, enum tree_code code,\n {\n   tree ret;\n \n-  ret = fold (build2 (code, type, a, b));\n+  ret = fold_build2 (code, type, a, b);\n   STRIP_NOPS (ret);\n \n   return gimplify_val (bsi, type, ret);\n@@ -4995,7 +4995,7 @@ gimplify_build1 (block_stmt_iterator *bsi, enum tree_code code, tree type,\n {\n   tree ret;\n \n-  ret = fold (build1 (code, type, a));\n+  ret = fold_build1 (code, type, a);\n   STRIP_NOPS (ret);\n \n   return gimplify_val (bsi, type, ret);"}, {"sha": "8be916ab94a9d3986cc5617bdf518c76aadafcd8", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -938,7 +938,7 @@ expand_complex_div_wide (block_stmt_iterator *bsi, tree inner_type,\n   /* Examine |br| < |bi|, and branch.  */\n   t1 = gimplify_build1 (bsi, ABS_EXPR, inner_type, br);\n   t2 = gimplify_build1 (bsi, ABS_EXPR, inner_type, bi);\n-  cond = fold (build (LT_EXPR, boolean_type_node, t1, t2));\n+  cond = fold_build2 (LT_EXPR, boolean_type_node, t1, t2);\n   STRIP_NOPS (cond);\n \n   bb_cond = bb_true = bb_false = bb_join = NULL;"}, {"sha": "d48f020a495e58cad543c0e19643603bc89d1148", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -190,7 +190,7 @@ tree_fold_divides_p (tree type,\n {\n   /* Determines whether (A == gcd (A, B)).  */\n   return integer_zerop \n-    (fold (build (MINUS_EXPR, type, a, tree_fold_gcd (a, b))));\n+    (fold_build2 (MINUS_EXPR, type, a, tree_fold_gcd (a, b)));\n }\n \n /* Compute the greatest common denominator of two numbers using\n@@ -487,17 +487,17 @@ estimate_niter_from_size_of_data (struct loop *loop,\n       || TREE_CODE (element_size) != INTEGER_CST)\n     return;\n \n-  data_size = fold (build2 (EXACT_DIV_EXPR, integer_type_node, \n-\t\t\t    array_size, element_size));\n+  data_size = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n+\t\t\t   array_size, element_size);\n \n   if (init != NULL_TREE\n       && step != NULL_TREE\n       && TREE_CODE (init) == INTEGER_CST\n       && TREE_CODE (step) == INTEGER_CST)\n     {\n-      estimation = fold (build2 (CEIL_DIV_EXPR, integer_type_node, \n-\t\t\t\t fold (build2 (MINUS_EXPR, integer_type_node, \n-\t\t\t\t\t       data_size, init)), step));\n+      estimation = fold_build2 (CEIL_DIV_EXPR, integer_type_node,\n+\t\t\t\tfold_build2 (MINUS_EXPR, integer_type_node,\n+\t\t\t\t\t     data_size, init), step);\n \n       record_estimate (loop, estimation, boolean_true_node, stmt);\n     }\n@@ -920,10 +920,11 @@ analyze_siv_subscript_cst_affine (tree chrec_a,\n \t\t      (integer_type_node, CHREC_RIGHT (chrec_b), difference))\n \t\t    {\n \t\t      *overlaps_a = integer_zero_node;\n-\t\t      *overlaps_b = fold \n-\t\t\t(build (EXACT_DIV_EXPR, integer_type_node, \n-\t\t\t\tfold (build1 (ABS_EXPR, integer_type_node, difference)), \n-\t\t\t\tCHREC_RIGHT (chrec_b)));\n+\t\t      *overlaps_b = fold_build2 (EXACT_DIV_EXPR, integer_type_node,\n+\t\t\t\t\t\t fold_build1 (ABS_EXPR,\n+\t\t\t\t\t\t\t      integer_type_node,\n+\t\t\t\t\t\t\t      difference),\n+\t\t\t\t\t\t CHREC_RIGHT (chrec_b));\n \t\t      *last_conflicts = integer_one_node;\n \t\t      return;\n \t\t    }"}, {"sha": "11f0ca10b7a5f95bde28f14aa3d4798c360d243b", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -582,8 +582,8 @@ add_to_predicate_list (basic_block bb, tree new_cond)\n   tree cond = bb->aux;\n \n   if (cond)\n-    cond = fold (build (TRUTH_OR_EXPR, boolean_type_node,\n-\t\t\tunshare_expr (cond), new_cond));\n+    cond = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t\t\tunshare_expr (cond), new_cond);\n   else\n     cond = new_cond;\n "}, {"sha": "aa7c8fd2bc715a54a195006ffd0bf14c987fcc9d", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -659,9 +659,9 @@ mf_build_check_statement_for (tree base, tree limit,\n   u = tree_cons (NULL_TREE, dirflag, u);\n   /* NB: we pass the overall [base..limit] range to mf_check.  */\n   u = tree_cons (NULL_TREE, \n-                 fold (build (PLUS_EXPR, integer_type_node,\n-                              fold (build (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base)),\n-                              integer_one_node)),\n+                 fold_build2 (PLUS_EXPR, integer_type_node,\n+\t\t\t      fold_build2 (MINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n+\t\t\t      integer_one_node),\n                  u);\n   u = tree_cons (NULL_TREE, mf_base, u);\n   t = build_function_call_expr (mf_check_fndecl, u);\n@@ -812,27 +812,27 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n \t    if (elt)\n \t      elt = build1 (ADDR_EXPR, build_pointer_type TREE_TYPE (elt), elt);\n             addr = fold_convert (ptr_type_node, elt ? elt : base);\n-            addr = fold (build (PLUS_EXPR, ptr_type_node,\n-                                addr, fold_convert (ptr_type_node,\n-                                                    byte_position (field))));           \n+            addr = fold_build2 (PLUS_EXPR, ptr_type_node,\n+\t\t\t\taddr, fold_convert (ptr_type_node,\n+\t\t\t\t\t\t    byte_position (field)));\n           }\n         else\n           addr = build1 (ADDR_EXPR, build_pointer_type (type), t);\n \n-        limit = fold (build (MINUS_EXPR, mf_uintptr_type,\n-                             fold (build2 (PLUS_EXPR, mf_uintptr_type, \n-                                           convert (mf_uintptr_type, addr), \n-                                           size)),\n-                             integer_one_node));\n+        limit = fold_build2 (MINUS_EXPR, mf_uintptr_type,\n+                             fold_build2 (PLUS_EXPR, mf_uintptr_type,\n+\t\t\t\t\t  convert (mf_uintptr_type, addr),\n+\t\t\t\t\t  size),\n+                             integer_one_node);\n       }\n       break;\n \n     case INDIRECT_REF:\n       addr = TREE_OPERAND (t, 0);\n       base = addr;\n-      limit = fold (build (MINUS_EXPR, ptr_type_node,\n-                           fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n-                           integer_one_node));\n+      limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n+                           fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n+                           integer_one_node);\n       break;\n \n     case TARGET_MEM_REF:\n@@ -869,12 +869,12 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n \n         addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n         addr = convert (ptr_type_node, addr);\n-        addr = fold (build (PLUS_EXPR, ptr_type_node, addr, ofs));\n+        addr = fold_build2 (PLUS_EXPR, ptr_type_node, addr, ofs);\n \n         base = addr;\n-        limit = fold (build (MINUS_EXPR, ptr_type_node,\n-                             fold (build (PLUS_EXPR, ptr_type_node, base, size)),\n-                             integer_one_node));\n+        limit = fold_build2 (MINUS_EXPR, ptr_type_node,\n+                             fold_build2 (PLUS_EXPR, ptr_type_node, base, size),\n+                             integer_one_node);\n       }\n       break;\n "}, {"sha": "2470cc1b51b10f145af5ed27609bf38e4134c280", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -2109,8 +2109,8 @@ instantiate_parameters_1 (struct loop *loop, tree chrec,\n \t  && op2 == TREE_OPERAND (chrec, 2))\n \treturn chrec;\n \n-      return fold (build (TREE_CODE (chrec),\n-\t\t\t  TREE_TYPE (chrec), op0, op1, op2));\n+      return fold_build3 (TREE_CODE (chrec),\n+\t\t\t  TREE_TYPE (chrec), op0, op1, op2);\n \n     case 2:\n       op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n@@ -2126,7 +2126,7 @@ instantiate_parameters_1 (struct loop *loop, tree chrec,\n       if (op0 == TREE_OPERAND (chrec, 0)\n \t  && op1 == TREE_OPERAND (chrec, 1))\n \treturn chrec;\n-      return fold (build (TREE_CODE (chrec), TREE_TYPE (chrec), op0, op1));\n+      return fold_build2 (TREE_CODE (chrec), TREE_TYPE (chrec), op0, op1);\n \t    \n     case 1:\n       op0 = instantiate_parameters_1 (loop, TREE_OPERAND (chrec, 0),\n@@ -2135,7 +2135,7 @@ instantiate_parameters_1 (struct loop *loop, tree chrec,\n         return chrec_dont_know;\n       if (op0 == TREE_OPERAND (chrec, 0))\n \treturn chrec;\n-      return fold (build1 (TREE_CODE (chrec), TREE_TYPE (chrec), op0));\n+      return fold_build1 (TREE_CODE (chrec), TREE_TYPE (chrec), op0);\n \n     case 0:\n       return chrec;"}, {"sha": "71385ddeffdc70af4e5da76858282807575b1bc6", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -1145,9 +1145,9 @@ visit_assignment (tree stmt, tree *output_p)\n     if (TREE_CODE (orig_lhs) == VIEW_CONVERT_EXPR\n \t&& val.lattice_val == CONSTANT)\n       {\n-\ttree w = fold (build1 (VIEW_CONVERT_EXPR,\n-\t\t\t       TREE_TYPE (TREE_OPERAND (orig_lhs, 0)),\n-\t\t\t       val.value));\n+\ttree w = fold_build1 (VIEW_CONVERT_EXPR,\n+\t\t\t      TREE_TYPE (TREE_OPERAND (orig_lhs, 0)),\n+\t\t\t      val.value);\n \n \torig_lhs = TREE_OPERAND (orig_lhs, 0);\n \tif (w && is_gimple_min_invariant (w))\n@@ -1855,7 +1855,7 @@ maybe_fold_stmt_addition (tree expr)\n     {\n       if (TYPE_UNSIGNED (TREE_TYPE (op1)))\n \treturn NULL;\n-      op1 = fold (build1 (NEGATE_EXPR, TREE_TYPE (op1), op1));\n+      op1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (op1), op1);\n       /* ??? In theory fold should always produce another integer.  */\n       if (TREE_CODE (op1) != INTEGER_CST)\n \treturn NULL;"}, {"sha": "f4f44759f9be627b0d5e2914103341ea7aae2df9", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -95,9 +95,9 @@ create_canonical_iv (struct loop *loop, edge exit, tree niter)\n      with a modulo arithmetics.  */\n \n   type = TREE_TYPE (niter);\n-  niter = fold (build2 (PLUS_EXPR, type,\n-\t\t\tniter,\n-\t\t\tbuild_int_cst (type, 1)));\n+  niter = fold_build2 (PLUS_EXPR, type,\n+\t\t       niter,\n+\t\t       build_int_cst (type, 1));\n   incr_at = bsi_last (in->src);\n   create_iv (niter,\n \t     fold_convert (type, integer_minus_one_node),\n@@ -275,8 +275,8 @@ canonicalize_loop_induction_variables (struct loops *loops, struct loop *loop,\n       /* The result of number_of_iterations_in_loop is by one higher than\n \t we expect (i.e. it returns number of executions of the exit\n \t condition, not of the loop latch edge).  */\n-      niter = fold (build2 (MINUS_EXPR, TREE_TYPE (niter), niter,\n-\t\t\t    build_int_cst (TREE_TYPE (niter), 1)));\n+      niter = fold_build2 (MINUS_EXPR, TREE_TYPE (niter), niter,\n+\t\t\t   build_int_cst (TREE_TYPE (niter), 1));\n     }\n   else\n     {"}, {"sha": "acc1ae9c4f0dd33d70be2390252a300b3138e52b", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -3053,7 +3053,7 @@ get_computation_aff (struct loop *loop,\n \n   /* We may need to shift the value if we are after the increment.  */\n   if (stmt_after_increment (loop, cand, at))\n-    cbase = fold (build2 (PLUS_EXPR, uutype, cbase, cstep));\n+    cbase = fold_build2 (PLUS_EXPR, uutype, cbase, cstep);\n \n   /* use = ubase - ratio * cbase + ratio * var.\n \n@@ -3913,9 +3913,9 @@ iv_value (struct iv *iv, tree niter)\n   tree type = TREE_TYPE (iv->base);\n \n   niter = fold_convert (type, niter);\n-  val = fold (build2 (MULT_EXPR, type, iv->step, niter));\n+  val = fold_build2 (MULT_EXPR, type, iv->step, niter);\n \n-  return fold (build2 (PLUS_EXPR, type, iv->base, val));\n+  return fold_build2 (PLUS_EXPR, type, iv->base, val);\n }\n \n /* Computes value of candidate CAND at position AT in iteration NITER.  */\n@@ -3927,7 +3927,7 @@ cand_value_at (struct loop *loop, struct iv_cand *cand, tree at, tree niter)\n   tree type = TREE_TYPE (cand->iv->base);\n \n   if (stmt_after_increment (loop, cand, at))\n-    val = fold (build2 (PLUS_EXPR, type, val, cand->iv->step));\n+    val = fold_build2 (PLUS_EXPR, type, val, cand->iv->step);\n \n   return val;\n }\n@@ -4026,9 +4026,9 @@ may_eliminate_iv (struct ivopts_data *data,\n   else\n     wider_type = nit_type;\n \n-  if (!integer_nonzerop (fold (build2 (GE_EXPR, boolean_type_node,\n-\t\t\t\t       fold_convert (wider_type, period),\n-\t\t\t\t       fold_convert (wider_type, nit)))))\n+  if (!integer_nonzerop (fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t      fold_convert (wider_type, period),\n+\t\t\t\t      fold_convert (wider_type, nit))))\n     return false;\n \n   *bound = cand_value_at (loop, cand, use->stmt, nit);"}, {"sha": "cbd03b73061df421ea886241bb92a83c1b8fd6a7", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -75,7 +75,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n     {\n       if (TYPE_UNSIGNED (TREE_TYPE (step)))\n \t{\n-\t  step1 = fold (build1 (NEGATE_EXPR, TREE_TYPE (step), step));\n+\t  step1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);\n \t  if (tree_int_cst_lt (step1, step))\n \t    {\n \t      incr_op = MINUS_EXPR;\n@@ -88,7 +88,7 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \t      && may_negate_without_overflow_p (step))\n \t    {\n \t      incr_op = MINUS_EXPR;\n-\t      step = fold (build1 (NEGATE_EXPR, TREE_TYPE (step), step));\n+\t      step = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);\n \t    }\n \t}\n     }"}, {"sha": "2f8594866915675a6ee81805e36984ca76aca4a6", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -724,8 +724,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\treturn false;\n \n \t      /* We need BOUND <= LARGER.  */\n-\t      if (!integer_nonzerop (fold (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t   bound, larger))))\n+\t      if (!integer_nonzerop (fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  bound, larger)))\n \t\treturn false;\n \t    }\n \t  else if (operand_equal_for_phi_arg_p (arg_false, smaller))\n@@ -749,8 +749,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\treturn false;\n \n \t      /* We need BOUND >= SMALLER.  */\n-\t      if (!integer_nonzerop (fold (build2 (GE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t   bound, smaller))))\n+\t      if (!integer_nonzerop (fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  bound, smaller)))\n \t\treturn false;\n \t    }\n \t  else\n@@ -783,8 +783,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\treturn false;\n \n \t      /* We need BOUND >= LARGER.  */\n-\t      if (!integer_nonzerop (fold (build2 (GE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t   bound, larger))))\n+\t      if (!integer_nonzerop (fold_build2 (GE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  bound, larger)))\n \t\treturn false;\n \t    }\n \t  else if (operand_equal_for_phi_arg_p (arg_true, smaller))\n@@ -808,8 +808,8 @@ minmax_replacement (basic_block cond_bb, basic_block middle_bb,\n \t\treturn false;\n \n \t      /* We need BOUND <= SMALLER.  */\n-\t      if (!integer_nonzerop (fold (build2 (LE_EXPR, boolean_type_node,\n-\t\t\t\t\t\t   bound, smaller))))\n+\t      if (!integer_nonzerop (fold_build2 (LE_EXPR, boolean_type_node,\n+\t\t\t\t\t\t  bound, smaller)))\n \t\treturn false;\n \t    }\n \t  else"}, {"sha": "eab18d34a16cadb816c7d5bc2273e0e57f6cf9ad", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -1528,8 +1528,8 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \n \tif (op2)\t  \n \t  genop2 = find_or_generate_expression (block, op2, stmts);\n-\tfolded = fold (build (TREE_CODE (expr), TREE_TYPE (expr),\n-\t\t\t      genop0, genarglist, genop2));\n+\tfolded = fold_build3 (TREE_CODE (expr), TREE_TYPE (expr),\n+\t\t\t      genop0, genarglist, genop2);\n \tbreak;\n \t\n \t\n@@ -1543,17 +1543,17 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \ttree op2 = TREE_OPERAND (expr, 1);\n \ttree genop1 = find_or_generate_expression (block, op1, stmts);\n \ttree genop2 = find_or_generate_expression (block, op2, stmts);\n-\tfolded = fold (build (TREE_CODE (expr), TREE_TYPE (expr), \n-\t\t\t      genop1, genop2));\n+\tfolded = fold_build2 (TREE_CODE (expr), TREE_TYPE (expr), \n+\t\t\t      genop1, genop2);\n \tbreak;\n       }\n \n     case tcc_unary:\n       {\n \ttree op1 = TREE_OPERAND (expr, 0);\n \ttree genop1 = find_or_generate_expression (block, op1, stmts);\n-\tfolded = fold (build (TREE_CODE (expr), TREE_TYPE (expr), \n-\t\t\t      genop1));\n+\tfolded = fold_build1 (TREE_CODE (expr), TREE_TYPE (expr), \n+\t\t\t      genop1);\n \tbreak;\n       }\n "}, {"sha": "f37b7311150df05cba5ecd0d3923375b226adb58", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -279,9 +279,9 @@ vect_analyze_offset_expr (tree expr,\n \n   /* Compute offset.  */\n   *initial_offset = fold_convert (ssizetype, \n-\t\t\t\t  fold (build2 (code, TREE_TYPE (left_offset), \n-\t\t\t\t\t\tleft_offset, \n-\t\t\t\t\t\tright_offset)));\n+\t\t\t\t  fold_build2 (code, TREE_TYPE (left_offset),\n+\t\t\t\t\t       left_offset,\n+\t\t\t\t\t       right_offset));\n   return true;\n }\n "}, {"sha": "2de9ce63d2dd871544234c1c0b07a517b7c714d3", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -210,17 +210,17 @@ vect_create_addr_base_for_vector_ref (tree stmt,\n     {\n       tree tmp = create_tmp_var (TREE_TYPE (base_offset), \"offset\");\n       add_referenced_tmp_var (tmp);\n-      offset = fold (build2 (MULT_EXPR, TREE_TYPE (offset), offset, \n-\t\t\t     STMT_VINFO_VECT_STEP (stmt_info)));\n-      base_offset = fold (build2 (PLUS_EXPR, TREE_TYPE (base_offset), \n-\t\t\t\t  base_offset, offset));\n+      offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset), offset,\n+\t\t\t    STMT_VINFO_VECT_STEP (stmt_info));\n+      base_offset = fold_build2 (PLUS_EXPR, TREE_TYPE (base_offset),\n+\t\t\t\t base_offset, offset);\n       base_offset = force_gimple_operand (base_offset, &new_stmt, false, tmp);  \n       append_to_statement_list_force (new_stmt, new_stmt_list);\n     }\n   \n   /* base + base_offset */\n-  addr_base = fold (build2 (PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base, \n-\t\t\t    base_offset));\n+  addr_base = fold_build2 (PLUS_EXPR, TREE_TYPE (data_ref_base), data_ref_base,\n+\t\t\t   base_offset);\n \n   /* addr_expr = addr_base */\n   addr_expr = vect_get_new_vect_var (scalar_ptr_type, vect_pointer_var,\n@@ -2601,9 +2601,9 @@ vect_update_init_of_dr (struct data_reference *dr, tree niters)\n   stmt_vec_info stmt_info = vinfo_for_stmt (DR_STMT (dr));\n   tree offset = STMT_VINFO_VECT_INIT_OFFSET (stmt_info);\n       \n-  niters = fold (build2 (MULT_EXPR, TREE_TYPE (niters), niters, \n-\t\t\t STMT_VINFO_VECT_STEP (stmt_info)));\n-  offset = fold (build2 (PLUS_EXPR, TREE_TYPE (offset), offset, niters));\n+  niters = fold_build2 (MULT_EXPR, TREE_TYPE (niters), niters,\n+\t\t\tSTMT_VINFO_VECT_STEP (stmt_info));\n+  offset = fold_build2 (PLUS_EXPR, TREE_TYPE (offset), offset, niters);\n   STMT_VINFO_VECT_INIT_OFFSET (stmt_info) = offset;\n }\n \n@@ -2675,8 +2675,8 @@ vect_do_peeling_for_alignment (loop_vec_info loop_vinfo, struct loops *loops)\n \n   /* Update number of times loop executes.  */\n   n_iters = LOOP_VINFO_NITERS (loop_vinfo);\n-  LOOP_VINFO_NITERS (loop_vinfo) = fold (build2 (MINUS_EXPR,\n-\t\tTREE_TYPE (n_iters), n_iters, niters_of_prolog_loop));\n+  LOOP_VINFO_NITERS (loop_vinfo) = fold_build2 (MINUS_EXPR,\n+\t\tTREE_TYPE (n_iters), n_iters, niters_of_prolog_loop);\n \n   /* Update the init conditions of the access functions of all data refs.  */\n   vect_update_inits_of_drs (loop_vinfo, niters_of_prolog_loop);"}, {"sha": "cf16f66628a6a84611157a47d88425abdaa317f9", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -1139,7 +1139,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   add_bb_to_loop (bb_before_second_loop, first_loop->outer);\n \n   pre_condition =\n-    fold (build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node));\n+    fold_build2 (LE_EXPR, boolean_type_node, first_niters, integer_zero_node);\n   skip_e = slpeel_add_loop_guard (bb_before_first_loop, pre_condition,\n                                   bb_before_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard1 (skip_e, first_loop,\n@@ -1178,7 +1178,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop, struct loops *loops,\n   add_bb_to_loop (bb_after_second_loop, second_loop->outer);\n \n   pre_condition = \n-\tfold (build2 (EQ_EXPR, boolean_type_node, first_niters, niters));\n+\tfold_build2 (EQ_EXPR, boolean_type_node, first_niters, niters);\n   skip_e = slpeel_add_loop_guard (bb_between_loops, pre_condition,\n                                   bb_after_second_loop, bb_before_first_loop);\n   slpeel_update_phi_nodes_for_guard2 (skip_e, second_loop,"}, {"sha": "e7565e2cd7433b0991d4a2a7df8ff0c0b520ea88", "filename": "gcc/tree.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/987b67bc5502c1c826bcb6c6b41728d6e038c96f/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=987b67bc5502c1c826bcb6c6b41728d6e038c96f", "patch": "@@ -1632,7 +1632,7 @@ array_type_nelts (tree type)\n \n   return (integer_zerop (min)\n \t  ? max\n-\t  : fold (build2 (MINUS_EXPR, TREE_TYPE (max), max, min)));\n+\t  : fold_build2 (MINUS_EXPR, TREE_TYPE (max), max, min));\n }\n \f\n /* If arg is static -- a reference to an object in static storage -- then\n@@ -2053,8 +2053,8 @@ substitute_in_expr (tree exp, tree f, tree r)\n      if (op0 == TREE_OPERAND (exp, 0))\n        return exp;\n \n-     new = fold (build3 (COMPONENT_REF, TREE_TYPE (exp),\n-\t\t\t op0, TREE_OPERAND (exp, 1), NULL_TREE));\n+     new = fold_build3 (COMPONENT_REF, TREE_TYPE (exp),\n+\t\t\top0, TREE_OPERAND (exp, 1), NULL_TREE);\n    }\n   else\n     switch (TREE_CODE_CLASS (code))\n@@ -2079,7 +2079,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    if (op0 == TREE_OPERAND (exp, 0))\n \t      return exp;\n \n-\t    new = fold (build1 (code, TREE_TYPE (exp), op0));\n+\t    new = fold_build1 (code, TREE_TYPE (exp), op0);\n \t    break;\n \n \t  case 2:\n@@ -2089,7 +2089,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n \t      return exp;\n \n-\t    new = fold (build2 (code, TREE_TYPE (exp), op0, op1));\n+\t    new = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n \t    break;\n \n \t  case 3:\n@@ -2101,7 +2101,7 @@ substitute_in_expr (tree exp, tree f, tree r)\n \t\t&& op2 == TREE_OPERAND (exp, 2))\n \t      return exp;\n \n-\t    new = fold (build3 (code, TREE_TYPE (exp), op0, op1, op2));\n+\t    new = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n \t    break;\n \n \t  default:\n@@ -2157,7 +2157,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \tif (POINTER_TYPE_P (TREE_TYPE (elt))\n \t    && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (elt)))\n \t\t== need_type))\n-\t  return fold (build1 (INDIRECT_REF, need_type, elt));\n+\t  return fold_build1 (INDIRECT_REF, need_type, elt);\n \n       /* If we didn't find it, return the original PLACEHOLDER_EXPR.  If it\n \t survives until RTL generation, there will be an error.  */\n@@ -2199,7 +2199,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t    if (op0 == TREE_OPERAND (exp, 0))\n \t      return exp;\n \t    else\n-\t      return fold (build1 (code, TREE_TYPE (exp), op0));\n+\t      return fold_build1 (code, TREE_TYPE (exp), op0);\n \n \t  case 2:\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n@@ -2208,7 +2208,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n \t      return exp;\n \t    else\n-\t      return fold (build2 (code, TREE_TYPE (exp), op0, op1));\n+\t      return fold_build2 (code, TREE_TYPE (exp), op0, op1);\n \n \t  case 3:\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n@@ -2219,7 +2219,7 @@ substitute_placeholder_in_expr (tree exp, tree obj)\n \t\t&& op2 == TREE_OPERAND (exp, 2))\n \t      return exp;\n \t    else\n-\t      return fold (build3 (code, TREE_TYPE (exp), op0, op1, op2));\n+\t      return fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n \n \t  case 4:\n \t    op0 = SUBSTITUTE_PLACEHOLDER_IN_EXPR (TREE_OPERAND (exp, 0), obj);\n@@ -6371,16 +6371,16 @@ tree_fold_gcd (tree a, tree b)\n     return a;\n \n   if (tree_int_cst_sgn (a) == -1)\n-    a = fold (build2 (MULT_EXPR, type, a,\n-\t\t      convert (type, integer_minus_one_node)));\n+    a = fold_build2 (MULT_EXPR, type, a,\n+\t\t     convert (type, integer_minus_one_node));\n \n   if (tree_int_cst_sgn (b) == -1)\n-    b = fold (build2 (MULT_EXPR, type, b,\n-\t\t      convert (type, integer_minus_one_node)));\n+    b = fold_build2 (MULT_EXPR, type, b,\n+\t\t     convert (type, integer_minus_one_node));\n \n   while (1)\n     {\n-      a_mod_b = fold (build2 (FLOOR_MOD_EXPR, type, a, b));\n+      a_mod_b = fold_build2 (FLOOR_MOD_EXPR, type, a, b);\n \n       if (!TREE_INT_CST_LOW (a_mod_b)\n \t  && !TREE_INT_CST_HIGH (a_mod_b))"}]}