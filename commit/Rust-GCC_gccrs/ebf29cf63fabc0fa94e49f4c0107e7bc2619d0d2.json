{"sha": "ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJmMjljZjYzZmFiYzBmYTk0ZTQ5ZjRjMDEwN2U3YmMyNjE5ZDBkMg==", "commit": {"author": {"name": "Keith Seitz", "email": "keiths@redhat.com", "date": "2006-09-22T02:12:12Z"}, "committer": {"name": "Keith Seitz", "email": "kseitz@gcc.gnu.org", "date": "2006-09-22T02:12:12Z"}, "message": "jvmti.cc (_Jv_JVMTI_DisposeEnvironment): Check for enabled events.\n\n        * jvmti.cc (_Jv_JVMTI_DisposeEnvironment): Check for enabled\n        events.\n        (check_enabled_event): New function.\n        (check_enabled_events): New function.\n        (post_event): New function.\n        (_Jv_JVMTI_SetEventNotificationMode): New function.\n        (_Jv_JVMTI_SetEventCallbacks): New function.\n        (_Jv_JVMTI_Interface): Define SetEventNotificationMode and\n        SetEventCallbacks members.\n        * include/jvmti-int.h: New file.\n        * include/jvmti_md.h (EVENT_SLOTS) [__GCJ_JNI_IMP__]: Define.\n        (_CLASSPATH_JVMTIENV_CONTENTS) [__GCJ_JNI_IMPL__]: Define.\n        * testsuite/libjava.jvmti/events.java: New file.\n        * testsuite/libjava.jvmti/events.out: New file.\n        * testsuite/libjava.jvmti/natevents.cc: New file.\n\nFrom-SVN: r117133", "tree": {"sha": "dc10194c5e3de3be031b390e9eb5e63ac548d9d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc10194c5e3de3be031b390e9eb5e63ac548d9d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/comments", "author": {"login": "shtiek", "id": 107581324, "node_id": "U_kgDOBmmPjA", "avatar_url": "https://avatars.githubusercontent.com/u/107581324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shtiek", "html_url": "https://github.com/shtiek", "followers_url": "https://api.github.com/users/shtiek/followers", "following_url": "https://api.github.com/users/shtiek/following{/other_user}", "gists_url": "https://api.github.com/users/shtiek/gists{/gist_id}", "starred_url": "https://api.github.com/users/shtiek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shtiek/subscriptions", "organizations_url": "https://api.github.com/users/shtiek/orgs", "repos_url": "https://api.github.com/users/shtiek/repos", "events_url": "https://api.github.com/users/shtiek/events{/privacy}", "received_events_url": "https://api.github.com/users/shtiek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14c7148908aa7b4880d5e812234619b596510fce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14c7148908aa7b4880d5e812234619b596510fce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14c7148908aa7b4880d5e812234619b596510fce"}], "stats": {"total": 1432, "additions": 1429, "deletions": 3}, "files": [{"sha": "a396f8094926a560673c033ddec80b5e71573c8f", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -1,3 +1,21 @@\n+2006-09-21  Keith Seitz  <keiths@redhat.com>\n+\n+\t* jvmti.cc (_Jv_JVMTI_DisposeEnvironment): Check for enabled\n+\tevents.\n+\t(check_enabled_event): New function.\n+\t(check_enabled_events): New function.\n+\t(post_event): New function.\n+\t(_Jv_JVMTI_SetEventNotificationMode): New function.\n+\t(_Jv_JVMTI_SetEventCallbacks): New function.\n+\t(_Jv_JVMTI_Interface): Define SetEventNotificationMode and\n+\tSetEventCallbacks members.\n+\t* include/jvmti-int.h: New file.\n+\t* include/jvmti_md.h (EVENT_SLOTS) [__GCJ_JNI_IMP__]: Define.\n+\t(_CLASSPATH_JVMTIENV_CONTENTS) [__GCJ_JNI_IMPL__]: Define.\n+\t* testsuite/libjava.jvmti/events.java: New file.\n+\t* testsuite/libjava.jvmti/events.out: New file.\n+\t* testsuite/libjava.jvmti/natevents.cc: New file. \n+\n 2006-09-21  Sandro Tolaini  <tolaini@libero.it>\n \n \t* configure.ac: Don't use darwin-signal.h as signal handler for"}, {"sha": "36e0da8042d2921e11bbdf9ac8677fdfe56b09c5", "filename": "libjava/include/jvmti-int.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Finclude%2Fjvmti-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Finclude%2Fjvmti-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvmti-int.h?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -0,0 +1,85 @@\n+/* jvmti-int.h -- Internal JVMTI definitions\n+   Copyright (C) 2006 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n+\n+#ifndef __GCJ_JVTMI_INT_H__\n+#define __GCJ_JVMTI_INT_H__\n+\n+/* A macro to map jvmtiEvent to an index in thread[] and enabled[]\n+   in the jvmtiEnv. This will only work if the order of events listed\n+   in jvmtiEvent and jvmtiEventCallbacks is kept the same (which should\n+   not be a problem). */\n+#define EVENT_INDEX(jvmtievent) (int)(jvmtievent - JVMTI_EVENT_VM_INIT)\n+\n+/* A few globals to help limit the impact of JVMTI on normal operations.\n+   False means no JVMTI environment requested that event type. */\n+namespace JVMTI\n+{\n+  bool VMInit;\n+  bool VMDeath;\n+  bool ThreadStart;\n+  bool ThreadEnd;\n+  bool ClassFileLoadHook;\n+  bool ClassLoad;\n+  bool ClassPrepare;\n+  bool VMStart;\n+  bool Exception;\n+  bool ExceptionCatch;\n+  bool SingleStep;\n+  bool FramePop;\n+  bool Breakpoint;\n+  bool FieldAccess;\n+  bool FieldModification;\n+  bool MethodEntry;\n+  bool MethodExit;\n+  bool NativeMethodBind;\n+  bool CompiledMethodLoad;\n+  bool CompiledMethodUnload;\n+  bool DynamicCodeGenerated;\n+  bool DataDumpRequest;\n+  bool reserved72;\n+  bool MonitorWait;\n+  bool MonitorWaited;\n+  bool MonitorContendedEnter;\n+  bool MonitorContendedEntered;\n+  bool reserved77;\n+  bool reserved78;\n+  bool reserved79;\n+  bool reserved80;\n+  bool GarbageCollectionStart;\n+  bool GarbageCollectionFinish;\n+  bool ObjectFree;\n+  bool VMObjectAlloc;\n+};\n+\n+/* A macro to test whether an event should be posted to JVMTI.*/\n+#define JVMTI_REQUESTED_EVENT(Event) __builtin_expect (JVMTI::Event, false)\n+\n+/* Post the event to requesting JVMTI environments.\n+\n+   For speed, this function should only be called after \n+   JVMTI_REQUESTED_EVENT is checked. */\n+extern void _Jv_JVMTI_PostEvent (jvmtiEvent type, jthread event_thread,\t\t\t\t ...);\n+#endif /* __GCJ_JVMTI_INT_H__ */"}, {"sha": "549d42151d3358118fdd6750a682ea0e592edc55", "filename": "libjava/include/jvmti_md.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Finclude%2Fjvmti_md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Finclude%2Fjvmti_md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvmti_md.h?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -27,6 +27,32 @@ executable file might be covered by the GNU General Public License. */\n #ifndef __GCJ_JVMTI_MD_H__\n #define __GCJ_JVMTI_MD_H__\n \n-// nothing\n+#ifdef __GCJ_JNI_IMPL__\n+\n+/* If __GCJ_JNI_IMPL__ is defined, then we assume that we're building\n+   libgcj itself, and we include functions which should not be exposed\n+   to JVMTI users. */\n+\n+/* The number of event slots needed to keep track of event reporting\n+   constraints for an environment. This will only work if the order of\n+   events listed in jvmtiEvent and jvmtiEventCallbacks is kept the same\n+   (which should not be a problem). */\n+#define EVENT_SLOTS \\\n+  (int)(JVMTI_EVENT_VM_OBJECT_ALLOC - JVMTI_EVENT_VM_INIT + 1)\n+\n+/* Contents of the jvmtiEnv; but only inside the implementation. */\n+#define _CLASSPATH_JVMTIENV_CONTENTS\t\t\t\t\t\\\n+  /* Event handlers registered via SetEventCallbacks */\t\t\t\\\n+  jvmtiEventCallbacks callbacks;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Array of event thread for which to report event. */\t\t\\\n+  /* NULL means all threads. One for each callback.   */\t\t\\\n+  jthread thread[EVENT_SLOTS];\t\t\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  /* Array of notification modes for callbacks. */\t\t\t\\\n+  /* One for each callback.                     */\t\t\t\\\n+  bool enabled[EVENT_SLOTS];\n+\n+#endif /* __GCJ_JNI_IMPL__ */\n \n #endif /* __GCJ_JVMTI_MD_H__ */"}, {"sha": "5adc2cde15949e3d693009962095b20714d19a41", "filename": "libjava/jvmti.cc", "status": "modified", "additions": 684, "deletions": 2, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Fjvmti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Fjvmti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjvmti.cc?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -15,6 +15,7 @@ details.  */\n #include <java-threads.h>\n #include <java-gc.h>\n #include <jvmti.h>\n+#include \"jvmti-int.h\"\n \n #include <gcj/method.h>\n \n@@ -32,6 +33,9 @@ details.  */\n #include <java/util/HashMap.h>\n #include <java/net/URL.h>\n \n+static void check_enabled_events (void);\n+static void check_enabled_event (jvmtiEvent);\n+\n extern struct JNINativeInterface _Jv_JNIFunctions;\n \n struct _Jv_rawMonitorID\n@@ -519,6 +523,9 @@ _Jv_JVMTI_DisposeEnvironment (jvmtiEnv *env)\n     }\n \n   _Jv_Free (env);\n+\n+  check_enabled_events ();\n+\n   return JVMTI_ERROR_NONE;\n }\n \n@@ -665,6 +672,300 @@ _Jv_JVMTI_GetObjectSize (MAYBE_UNUSED jvmtiEnv *env, jobject object,\n   return JVMTI_ERROR_NONE;\n }\n \n+/* An event is enabled only if it has both an event handler\n+   and it is enabled in the environment. */\n+static void\n+check_enabled_event (jvmtiEvent type)\n+{\n+  bool *enabled;\n+  int offset;\n+\n+#define GET_OFFSET(Event)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      enabled = &JVMTI::Event;\t\t\t\t\\\n+      offset = offsetof (jvmtiEventCallbacks, Event);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+  switch (type)\n+    {\n+    case JVMTI_EVENT_VM_INIT:\n+      GET_OFFSET (VMInit);\n+      break;\n+\n+    case JVMTI_EVENT_VM_DEATH:\n+      GET_OFFSET (VMDeath);\n+      break;\n+\n+    case JVMTI_EVENT_THREAD_START:\n+      GET_OFFSET (ThreadStart);\n+      break;\n+\n+    case JVMTI_EVENT_THREAD_END:\n+      GET_OFFSET (ThreadEnd);\n+      break;\n+\n+    case JVMTI_EVENT_CLASS_FILE_LOAD_HOOK:\n+      GET_OFFSET (ClassFileLoadHook);\n+      break;\n+\n+    case JVMTI_EVENT_CLASS_LOAD:\n+      GET_OFFSET (ClassLoad);\n+      break;\n+\n+    case JVMTI_EVENT_CLASS_PREPARE:\n+      GET_OFFSET (ClassPrepare);\n+      break;\n+\n+    case JVMTI_EVENT_VM_START:\n+      GET_OFFSET (VMStart);\n+      break;\n+\n+    case JVMTI_EVENT_EXCEPTION:\n+      GET_OFFSET (Exception);\n+      break;\n+\n+    case JVMTI_EVENT_EXCEPTION_CATCH:\n+      GET_OFFSET (ExceptionCatch);\n+      break;\n+\n+    case JVMTI_EVENT_SINGLE_STEP:\n+      GET_OFFSET (SingleStep);\n+      break;\n+\n+    case JVMTI_EVENT_FRAME_POP:\n+      GET_OFFSET (FramePop);\n+      break;\n+\n+    case JVMTI_EVENT_BREAKPOINT:\n+      GET_OFFSET (Breakpoint);\n+      break;\n+\n+    case JVMTI_EVENT_FIELD_ACCESS:\n+      GET_OFFSET (FieldAccess);\n+      break;\n+\n+    case JVMTI_EVENT_FIELD_MODIFICATION:\n+      GET_OFFSET (FieldModification);\n+      break;\n+\n+    case JVMTI_EVENT_METHOD_ENTRY:\n+      GET_OFFSET (MethodEntry);\n+      break;\n+\n+    case JVMTI_EVENT_METHOD_EXIT:\n+      GET_OFFSET (MethodExit);\n+      break;\n+\n+    case JVMTI_EVENT_NATIVE_METHOD_BIND:\n+      GET_OFFSET (NativeMethodBind);\n+      break;\n+\n+    case JVMTI_EVENT_COMPILED_METHOD_LOAD:\n+      GET_OFFSET (CompiledMethodLoad);\n+      break;\n+\n+    case JVMTI_EVENT_COMPILED_METHOD_UNLOAD:\n+      GET_OFFSET (CompiledMethodUnload);\n+      break;\n+\n+    case JVMTI_EVENT_DYNAMIC_CODE_GENERATED:\n+      GET_OFFSET (DynamicCodeGenerated);\n+      break;\n+\n+    case JVMTI_EVENT_DATA_DUMP_REQUEST:\n+      GET_OFFSET (DataDumpRequest);\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_WAIT:\n+      GET_OFFSET (MonitorWait);\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_WAITED:\n+      GET_OFFSET (MonitorWaited);\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:\n+      GET_OFFSET (MonitorContendedEnter);\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:\n+      GET_OFFSET (MonitorContendedEntered);\n+      break;\n+\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_START:\n+      GET_OFFSET (GarbageCollectionStart);\n+      break;\n+\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:\n+      GET_OFFSET (GarbageCollectionFinish);\n+      break;\n+\n+    case JVMTI_EVENT_OBJECT_FREE:\n+      GET_OFFSET (ObjectFree);\n+      break;\n+\n+    case JVMTI_EVENT_VM_OBJECT_ALLOC:\n+      GET_OFFSET (VMObjectAlloc);\n+      break;\n+\n+    default:\n+      fprintf (stderr,\n+\t       \"libgcj: check_enabled_event for unknown JVMTI event (%d)\\n\",\n+\t       (int) type);\n+      return;\n+    }\n+#undef GET_OFFSET\n+\n+  int index = EVENT_INDEX (type); // safe since caller checks this\n+\n+  JvSynchronize dummy (_envListLock);\n+  struct jvmti_env_list *e;\n+  FOREACH_ENVIRONMENT (e)\n+    {\n+      char *addr\n+\t= reinterpret_cast<char *> (&e->env->callbacks) + offset;\n+      void **callback = reinterpret_cast<void **> (addr);\n+      if (e->env->enabled[index] && *callback != NULL)\n+\t{\n+\t  *enabled = true;\n+\t  return;\n+\t}\n+    }\n+\n+  *enabled = false;\n+}\n+\n+static void\n+check_enabled_events ()\n+{\n+  check_enabled_event (JVMTI_EVENT_VM_INIT);\n+  check_enabled_event (JVMTI_EVENT_VM_DEATH);\n+  check_enabled_event (JVMTI_EVENT_THREAD_START);\n+  check_enabled_event (JVMTI_EVENT_THREAD_END);\n+  check_enabled_event (JVMTI_EVENT_CLASS_FILE_LOAD_HOOK);\n+  check_enabled_event (JVMTI_EVENT_CLASS_LOAD);\n+  check_enabled_event (JVMTI_EVENT_CLASS_PREPARE);\n+  check_enabled_event (JVMTI_EVENT_VM_START);\n+  check_enabled_event (JVMTI_EVENT_EXCEPTION);\n+  check_enabled_event (JVMTI_EVENT_EXCEPTION_CATCH);\n+  check_enabled_event (JVMTI_EVENT_SINGLE_STEP);\n+  check_enabled_event (JVMTI_EVENT_FRAME_POP);\n+  check_enabled_event (JVMTI_EVENT_BREAKPOINT);\n+  check_enabled_event (JVMTI_EVENT_FIELD_ACCESS);\n+  check_enabled_event (JVMTI_EVENT_FIELD_MODIFICATION);\n+  check_enabled_event (JVMTI_EVENT_METHOD_ENTRY);\n+  check_enabled_event (JVMTI_EVENT_METHOD_EXIT);\n+  check_enabled_event (JVMTI_EVENT_NATIVE_METHOD_BIND);\n+  check_enabled_event (JVMTI_EVENT_COMPILED_METHOD_LOAD);\n+  check_enabled_event (JVMTI_EVENT_COMPILED_METHOD_UNLOAD);\n+  check_enabled_event (JVMTI_EVENT_DYNAMIC_CODE_GENERATED);\n+  check_enabled_event (JVMTI_EVENT_DATA_DUMP_REQUEST);\n+  check_enabled_event (JVMTI_EVENT_MONITOR_WAIT);\n+  check_enabled_event (JVMTI_EVENT_MONITOR_WAITED);\n+  check_enabled_event (JVMTI_EVENT_MONITOR_CONTENDED_ENTER);\n+  check_enabled_event (JVMTI_EVENT_MONITOR_CONTENDED_ENTERED);\n+  check_enabled_event (JVMTI_EVENT_GARBAGE_COLLECTION_START);\n+  check_enabled_event (JVMTI_EVENT_GARBAGE_COLLECTION_FINISH);\n+  check_enabled_event (JVMTI_EVENT_OBJECT_FREE);\n+  check_enabled_event (JVMTI_EVENT_VM_OBJECT_ALLOC);\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_SetEventNotificationMode (jvmtiEnv *env, jvmtiEventMode mode,\n+\t\t\t\t    jvmtiEvent type, jthread event_thread, ...)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD | JVMTI_PHASE_LIVE);\n+\n+  if (event_thread != NULL)\n+    {\n+      using namespace java::lang;\n+      Thread *t = reinterpret_cast<Thread *> (event_thread);\n+      THREAD_CHECK_VALID (t);\n+      THREAD_CHECK_IS_ALIVE (t);\n+    }\n+\n+  bool enabled;\n+  switch (mode)\n+    {\n+    case JVMTI_DISABLE:\n+      enabled = false;\n+      break;\n+    case JVMTI_ENABLE:\n+      enabled = true;\n+      break;\n+\n+    default:\n+      return JVMTI_ERROR_ILLEGAL_ARGUMENT;\n+    }\n+\n+  switch (type)\n+    {\n+    case JVMTI_EVENT_VM_INIT:\n+    case JVMTI_EVENT_VM_DEATH:\n+    case JVMTI_EVENT_THREAD_START:\n+    case JVMTI_EVENT_VM_START:\n+    case JVMTI_EVENT_COMPILED_METHOD_LOAD:\n+    case JVMTI_EVENT_COMPILED_METHOD_UNLOAD:\n+    case JVMTI_EVENT_DYNAMIC_CODE_GENERATED:\n+    case JVMTI_EVENT_DATA_DUMP_REQUEST:\n+      ILLEGAL_ARGUMENT (event_thread != NULL);\n+      break;\n+\n+    case JVMTI_EVENT_THREAD_END:\n+    case JVMTI_EVENT_CLASS_FILE_LOAD_HOOK:\n+    case JVMTI_EVENT_CLASS_LOAD:\n+    case JVMTI_EVENT_CLASS_PREPARE:\n+    case JVMTI_EVENT_EXCEPTION:\n+    case JVMTI_EVENT_EXCEPTION_CATCH:\n+    case JVMTI_EVENT_SINGLE_STEP:\n+    case JVMTI_EVENT_FRAME_POP:\n+    case JVMTI_EVENT_BREAKPOINT:\n+    case JVMTI_EVENT_FIELD_ACCESS:\n+    case JVMTI_EVENT_FIELD_MODIFICATION:\n+    case JVMTI_EVENT_METHOD_ENTRY:\n+    case JVMTI_EVENT_METHOD_EXIT:\n+    case JVMTI_EVENT_NATIVE_METHOD_BIND:\n+    case JVMTI_EVENT_MONITOR_WAIT:\n+    case JVMTI_EVENT_MONITOR_WAITED:\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_START:\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:\n+    case JVMTI_EVENT_OBJECT_FREE:\n+    case JVMTI_EVENT_VM_OBJECT_ALLOC:\n+      break;\n+\n+    default:\n+      return JVMTI_ERROR_INVALID_EVENT_TYPE;\n+    }\n+\n+  env->thread[EVENT_INDEX(type)] = event_thread;\n+  env->enabled[EVENT_INDEX(type)] = enabled;\n+  check_enabled_event (type);\n+  return JVMTI_ERROR_NONE;\n+}\n+\n+static jvmtiError JNICALL\n+_Jv_JVMTI_SetEventCallbacks (jvmtiEnv *env,\n+\t\t\t     const jvmtiEventCallbacks *callbacks,\n+\t\t\t     jint size_of_callbacks)\n+{\n+  REQUIRE_PHASE (env, JVMTI_PHASE_ONLOAD | JVMTI_PHASE_LIVE);\n+  ILLEGAL_ARGUMENT (size_of_callbacks < 0);\n+\n+  // Copy the list of callbacks into the environment\n+  memcpy (&env->callbacks, callbacks, sizeof (jvmtiEventCallbacks));\n+\n+  /* Check which events are now enabeld (JVMTI makes no requirements\n+     about the order in which SetEventCallbacks and SetEventNotifications\n+     are called. So we must check all events here. */\n+  check_enabled_events ();\n+\n+  return JVMTI_ERROR_NONE;\n+}\n+\n jvmtiError\n _Jv_JVMTI_GetErrorName (MAYBE_UNUSED jvmtiEnv *env, jvmtiError error,\n \t\t\tchar **name_ptr)\n@@ -884,7 +1185,7 @@ _Jv_JVMTI_GetErrorName (MAYBE_UNUSED jvmtiEnv *env, jvmtiError error,\n struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n {\n   RESERVED,\t\t\t// reserved1\n-  UNIMPLEMENTED,\t\t// SetEventNotification\n+  _Jv_JVMTI_SetEventNotificationMode, // SetEventNotificationMode\n   RESERVED,\t\t\t// reserved3\n   UNIMPLEMENTED,\t\t// GetAllThreads\n   _Jv_JVMTI_SuspendThread,\t// SuspendThread\n@@ -1004,7 +1305,7 @@ struct _Jv_jvmtiEnv _Jv_JVMTI_Interface =\n   RESERVED,\t\t\t// reserved119\n   _Jv_JVMTI_SetJNIFunctionTable, // SetJNIFunctionTable\n   _Jv_JVMTI_GetJNIFunctionTable, // GetJNIFunctionTable\n-  UNIMPLEMENTED,\t\t// SetEventCallbacks\n+  _Jv_JVMTI_SetEventCallbacks,\t// SetEventCallbacks\n   UNIMPLEMENTED,\t\t// GenerateEvents\n   UNIMPLEMENTED,\t\t// GetExtensionFunctions\n   UNIMPLEMENTED,\t\t// GetExtensionEvents\n@@ -1072,4 +1373,385 @@ _Jv_JVMTI_Init ()\n {\n   _jvmtiEnvironments = NULL;\n   _envListLock = new java::lang::Object ();\n+\n+  // No environments, so this should set all JVMTI:: members to false\n+  check_enabled_events ();\n+}\n+\n+static void\n+post_event (jvmtiEnv *env, jvmtiEvent type, jthread event_thread, va_list args)\n+{\n+#define ARG(Type,Name) Type Name = (Type) va_arg (args, Type)\n+\n+#define GET_BOOLEAN_ARG(Name)\t\t\t\\\n+  ARG (int, b);\t\t\t\t\t\\\n+  jboolean Name = (b == 0) ? false : true\n+\n+#define GET_CHAR_ARG(Name)\t\t\t\\\n+  ARG (int, c);\t\t\t\t\t\\\n+  char Name = static_cast<char> (c)\n+\n+  switch (type)\n+    {\n+    case JVMTI_EVENT_VM_INIT:\n+      if (env->callbacks.VMInit != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  env->callbacks.VMInit (env, jni_env, event_thread);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_VM_DEATH:\n+      if (env->callbacks.VMDeath != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  env->callbacks.VMDeath (env, jni_env);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_THREAD_START:\n+      if (env->callbacks.ThreadStart != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  env->callbacks.ThreadStart (env, jni_env, event_thread);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_THREAD_END:\n+      if (env->callbacks.ThreadEnd != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  env->callbacks.ThreadEnd (env, jni_env, event_thread);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_CLASS_FILE_LOAD_HOOK:\n+      if (env->callbacks.ClassFileLoadHook != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jclass, class_being_redefined);\n+\t  ARG (jobject, loader);\n+\t  ARG (const char *, name);\n+\t  ARG (jobject, protection_domain);\n+\t  ARG (jint, class_data_len);\n+\t  ARG (const unsigned char *, class_data);\n+\t  ARG (jint *, new_class_data_len);\n+\t  ARG (unsigned char **, new_class_data);\n+\t  env->callbacks.ClassFileLoadHook (env, jni_env,\n+\t\t\t\t\t    class_being_redefined, loader,\n+\t\t\t\t\t    name, protection_domain,\n+\t\t\t\t\t    class_data_len, class_data,\n+\t\t\t\t\t    new_class_data_len,\n+\t\t\t\t\t    new_class_data);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_CLASS_LOAD:\n+      if (env->callbacks.ClassLoad != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jclass, klass);\n+\t  env->callbacks.ClassLoad (env, jni_env, event_thread, klass);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_CLASS_PREPARE:\n+      if (env->callbacks.ClassPrepare != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jclass, klass);\n+\t  env->callbacks.ClassPrepare (env, jni_env, event_thread, klass);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_VM_START:\n+      if (env->callbacks.VMStart != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  env->callbacks.VMStart (env, jni_env);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_EXCEPTION:\n+      if (env->callbacks.Exception != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (jlocation, location);\n+\t  ARG (jobject, exception);\n+\t  ARG (jmethodID, catch_method);\n+\t  ARG (jlocation, catch_location);\n+\t  env->callbacks.Exception (env, jni_env, event_thread, method,\n+\t\t\t\t    location, exception, catch_method,\n+\t\t\t\t    catch_location);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_EXCEPTION_CATCH:\n+      if (env->callbacks.ExceptionCatch != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (jlocation, location);\n+\t  ARG (jobject, exception);\n+\t  env->callbacks.ExceptionCatch (env, jni_env, event_thread, method,\n+\t\t\t\t\t location, exception);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_SINGLE_STEP:\n+      if (env->callbacks.SingleStep != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (jlocation, location);\n+\t  env->callbacks.SingleStep (env, jni_env, event_thread, method,\n+\t\t\t\t     location);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_FRAME_POP:\n+      if (env->callbacks.FramePop != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  GET_BOOLEAN_ARG (was_popped_by_exception);\n+\t  env->callbacks.FramePop (env, jni_env, event_thread, method,\n+\t\t\t\t   was_popped_by_exception);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_BREAKPOINT:\n+      if (env->callbacks.Breakpoint != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (jlocation, location);\n+\t  env->callbacks.Breakpoint (env, jni_env, event_thread, method,\n+\t\t\t\t     location);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_FIELD_ACCESS:\n+      if (env->callbacks.FieldAccess != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (jlocation, location);\n+\t  ARG (jclass, field_class);\n+\t  ARG (jobject, object);\n+\t  ARG (jfieldID, field);\n+\t  env->callbacks.FieldAccess (env, jni_env, event_thread, method,\n+\t\t\t\t      location, field_class, object, field);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_FIELD_MODIFICATION:\n+      if (env->callbacks.FieldModification != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (jlocation, location);\n+\t  ARG (jclass, field_class);\n+\t  ARG (jobject, object);\n+\t  ARG (jfieldID, field);\n+\t  GET_CHAR_ARG (signature_type);\n+\t  ARG (jvalue, new_value);\n+\t  env->callbacks.FieldModification (env, jni_env, event_thread, method,\n+\t\t\t\t\t    location, field_class, object,\n+\t\t\t\t\t    field, signature_type, new_value);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_METHOD_ENTRY:\n+      if (env->callbacks.MethodEntry != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  env->callbacks.MethodEntry (env, jni_env, event_thread, method);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_METHOD_EXIT:\n+      if (env->callbacks.MethodExit != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  GET_BOOLEAN_ARG (was_popped_by_exception);\n+\t  ARG (jvalue, return_value);\n+\t  env->callbacks.MethodExit (env, jni_env, event_thread, method,\n+\t\t\t\t     was_popped_by_exception, return_value);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_NATIVE_METHOD_BIND:\n+      if (env->callbacks.NativeMethodBind != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jmethodID, method);\n+\t  ARG (void *, address);\n+\t  ARG (void **, new_address_ptr);\n+\t  env->callbacks.NativeMethodBind (env, jni_env, event_thread, method,\n+\t\t\t\t\t   address, new_address_ptr);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_COMPILED_METHOD_LOAD:\n+      if (env->callbacks.CompiledMethodLoad != NULL)\n+\t{\n+\t  ARG (jmethodID, method);\n+\t  ARG (jint, code_size);\n+\t  ARG (const void *, code_addr);\n+\t  ARG (jint, map_length);\n+\t  ARG (const jvmtiAddrLocationMap *, map);\n+\t  ARG (const void *, compile_info);\n+\t  env->callbacks.CompiledMethodLoad (env, method, code_size, code_addr,\n+\t\t\t\t\t     map_length, map, compile_info);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_COMPILED_METHOD_UNLOAD:\n+      if (env->callbacks.CompiledMethodUnload != NULL)\n+\t{\n+\t  ARG (jmethodID, method);\n+\t  ARG (const void *, code_addr);\n+\t  env->callbacks.CompiledMethodUnload (env, method, code_addr);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_DYNAMIC_CODE_GENERATED:\n+      if (env->callbacks.DynamicCodeGenerated != NULL)\n+\t{\n+\t  ARG (const char *, name);\n+\t  ARG (const void *, address);\n+\t  ARG (jint, length);\n+\t  env->callbacks.DynamicCodeGenerated (env, name, address, length);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_DATA_DUMP_REQUEST:\n+      if (env->callbacks.DataDumpRequest != NULL)\n+\t{\n+\t  env->callbacks.DataDumpRequest (env);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_WAIT:\n+      if (env->callbacks.MonitorWait != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jobject, object);\n+\t  ARG (jlong, timeout);\n+\t  env->callbacks.MonitorWait (env, jni_env, event_thread, object,\n+\t\t\t\t      timeout);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_WAITED:\n+      if (env->callbacks.MonitorWaited != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jobject, object);\n+\t  GET_BOOLEAN_ARG (timed_out);\n+\t  env->callbacks.MonitorWaited (env, jni_env, event_thread, object,\n+\t\t\t\t\ttimed_out);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:\n+      if (env->callbacks.MonitorContendedEnter != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jobject, object);\n+\t  env->callbacks.MonitorContendedEnter (env, jni_env, event_thread,\n+\t\t\t\t\t\tobject);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:\n+      if (env->callbacks.MonitorContendedEntered != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jobject, object);\n+\t  env->callbacks.MonitorContendedEntered (env, jni_env, event_thread,\n+\t\t\t\t\t\t  object);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_START:\n+      if (env->callbacks.GarbageCollectionStart != NULL)\n+\t{\n+\t  env->callbacks.GarbageCollectionStart (env);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:\n+      if (env->callbacks.GarbageCollectionFinish != NULL)\n+\t{\n+\t  env->callbacks.GarbageCollectionFinish (env);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_OBJECT_FREE:\n+      if (env->callbacks.ObjectFree != NULL)\n+\t{\n+\t  ARG (jlong, tag);\n+\t  env->callbacks.ObjectFree (env, tag);\n+\t}\n+      break;\n+\n+    case JVMTI_EVENT_VM_OBJECT_ALLOC:\n+      if (env->callbacks.VMObjectAlloc != NULL)\n+\t{\n+\t  ARG (JNIEnv *, jni_env);\n+\t  ARG (jobject, object);\n+\t  ARG (jclass, object_class);\n+\t  ARG (jlong, size);\n+\t  env->callbacks.VMObjectAlloc (env, jni_env, event_thread,\n+\t\t\t\t\tobject, object_class, size);\n+\t}\n+      break;\n+\n+    default:\n+      fprintf (stderr, \"libgcj: post of unknown JVMTI event (%d)\\n\",\n+\t       (int) type);\n+      break;\n+    }\n+  va_end (args);\n+#undef ARG\n+#undef GET_BOOLEAN_ARG\n+#undef GET_CHAR_ARG\n+}\n+\n+/* Post an event to requesting JVMTI environments\n+ *\n+ * This function should not be called without consulting the\n+ * JVMTI_REQUESTED_EVENT macro first (for speed). It does no real\n+ * harm (other than kill speed), since this function will still\n+ * only send the event if it was properly requested by an environment.\n+ */ \n+void\n+_Jv_JVMTI_PostEvent (jvmtiEvent type, jthread event_thread, ...)\n+{\n+  va_list args;\n+  va_start (args, event_thread);\n+\n+  JvSynchronize dummy (_envListLock);\n+  struct jvmti_env_list *e;\n+  FOREACH_ENVIRONMENT (e)\n+    {\n+      /* Events are only posted if the event was explicitly enabled,\n+\t it has a registered event handler, and the event thread\n+\t matches (either globally or restricted to a specific thread).\n+\t Here we check all but the event handler, which will be handled\n+\t by post_event. */\n+      if (e->env->enabled[EVENT_INDEX(type)]\n+\t  && (e->env->thread[EVENT_INDEX(type)] == NULL\n+\t      || e->env->thread[EVENT_INDEX(type)] == event_thread))\n+\t{\n+\t  post_event (e->env, type, event_thread, args);\n+\t}\n+    }\n+\n+  va_end (args);\n }"}, {"sha": "05deeeb2371e233a1edd07f73eda32300c170d41", "filename": "libjava/testsuite/libjava.jvmti/events.java", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Ftestsuite%2Flibjava.jvmti%2Fevents.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Ftestsuite%2Flibjava.jvmti%2Fevents.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Fevents.java?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -0,0 +1,12 @@\n+// Test JVMTI event notifications\n+\n+public class events\n+{\n+  public static native void do_events_tests ();\n+\n+  public static void main (String[] args)\n+  {\n+    System.out.println (\"JVMTI event notification tests\");\n+    do_events_tests ();\n+  }\n+}"}, {"sha": "0f6c0b0e41c0b3e01f1f54ebbbd61a302de83f09", "filename": "libjava/testsuite/libjava.jvmti/events.out", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Ftestsuite%2Flibjava.jvmti%2Fevents.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Ftestsuite%2Flibjava.jvmti%2Fevents.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Fevents.out?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -0,0 +1,59 @@\n+JVMTI event notification tests\n+- enable tests -\n+created JVMTI environment #0\n+created JVMTI environment #1\n+created JVMTI environment #2\n+setting callbacks for envs\n+RequestedEvents: \n+enable VM_INIT for env0, env1, env2\n+RequestedEvents: VMInit,\n+enable VM_DEATH for env1,env2\n+RequestedEvents: VMInit,VMDeath,\n+enable THREAD_END for env2\n+RequestedEvents: VMInit,VMDeath,ThreadEnd,\n+disposing of env1\n+RequestedEvents: VMInit,VMDeath,ThreadEnd,\n+disposing of env0\n+RequestedEvents: VMInit,VMDeath,ThreadEnd,\n+disable VMInit in env2\n+RequestedEvents: VMDeath,ThreadEnd,\n+clear VMDeath callback in env2\n+RequestedEvents: ThreadEnd,\n+sending VMInit\n+sending ThreadEnd\n+ThreadEndCB jni_env=0x5678 thread=0x1234\n+sending VMDeath\n+disposing of env2\n+RequestedEvents: \n+- callback arg tests -\n+RequestedEvents: VMInit,VMDeath,ThreadStart,ThreadEnd,ClassFileLoadHook,ClassLoad,ClassPrepare,VMStart,Exception,ExceptionCatch,SingleStep,FramePop,Breakpoint,FieldAccess,FieldModification,MethodEntry,MethodExit,NativeMethodBind,CompiledMethodLoad,CompiledMethodUnload,DynamicCodeGenerated,DataDumpRequest,MonitorWait,MonitorWaited,MonitorContendedEnter,MonitorContendedEntered,GarbageCollectionStart,GarbageCollectionFinish,ObjectFree,VMObjectAlloc,\n+VMInitCB jni_env=0x1 thread=0x2\n+VMDeathCB jni_env=0x1\n+ThreadStartCB jni_env=0x1 thread=0x2\n+ThreadEndCB jni_env=0x1 thread=0x2\n+ClassFileLoadHookCB jni_env=0x1 class_being_redefined=0x2 loader=0x3 name=4 protection_domain=0x5 class_data_len=6 class_data=0x7 new_class_data_len=0x8 new_class_data=0x9\n+ClassLoadCB jni_env=0x1 thread=0x2 klass=0x3\n+ClassPrepareCB jni_env=0x1 thread=0x2 klass=0x3\n+VMStartCB jni_env=0x1\n+ExceptionCB jni_env=0x1 thread=0x2 method=0x3 location=0x4 exception=0x5 catch_method=0x6 catch_location=0x7\n+ExceptionCatchCB jni_env=0x1 thread=0x2 method=0x3 location=0x4 exception=0x5\n+SingleStepCB jni_env=0x1 thread=0x2 method=0x3 location=0x4\n+FramePopCB jni_env=0x1 thread=0x2 method=0x3 was_pooped_by_exception=1\n+BreakpointCB  jni_env=0x1 thread=0x2 method=0x3 location=0x4\n+FieldAccessCB jni_env=0x1 thread=0x2 method=0x3 location=0x4 field_klass=0x5 object=0x6 field=0x7\n+FieldModificationCB  jni_env=0x1 thread=0x2 method=0x3 location=0x4 field_klass=0x5 object=0x6 field=0x7 signature_type=8 new_value=9\n+MethodEntryCB jni_env=0x1 thread=0x2 method=0x3\n+MethodExitCB jni_env=0x1 thread=0x2 method=0x3 was_popped_by_exception=1 return_value=5\n+NativeMethodBindCB jni_env=0x1 thread=0x2 method=0x3 address=0x4 new_address_ptr=0x5\n+CompiledMethodLoadCB method=0x1 code_size=0x2 code_addr=0x3 map_length=4 map=0x5 compile_info=0x6\n+CompiledMethodUnloadCB method=0x1 code_addr=0x2\n+DynamicCodeGeneratedCB name=1 address=0x2 length=3\n+DataDumpRequestCB\n+MonitorWaitCB jni_env=0x1 thread=0x2 object=0x3 timeout=4\n+MonitorWaitedCB jni_env=0x1 thread=0x2 object=0x3 timed_out=1\n+MonitorContendedEnterCB jni_env=0x1 thread=0x2 object=0x3\n+MonitorContendedEnteredCB jni_env=0x1 thread=0x2 object=0x3\n+GarbageCollectionStartCB\n+GarbageCollectionFinishCB\n+ObjectFreeCB tag=1\n+VMObjectAllocCB jni_env=0x1 thread=0x2 object=0x3 object_klass=0x4 size=5"}, {"sha": "d5720bb648c676f176681abf7ef8f1a83ea387ff", "filename": "libjava/testsuite/libjava.jvmti/natevents.cc", "status": "added", "additions": 544, "deletions": 0, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Ftestsuite%2Flibjava.jvmti%2Fnatevents.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2/libjava%2Ftestsuite%2Flibjava.jvmti%2Fnatevents.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.jvmti%2Fnatevents.cc?ref=ebf29cf63fabc0fa94e49f4c0107e7bc2619d0d2", "patch": "@@ -0,0 +1,544 @@\n+#include <gcj/cni.h>\n+\n+#include <jvm.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+\n+#include \"jvmti-int.h\"\n+#include \"events.h\"\n+\n+static jvmtiEnv *env = NULL;\n+\n+void\n+print_events ()\n+{\n+#define DO(X)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (JVMTI_REQUESTED_EVENT (X))\t\t\\\n+\tprintf (#X \",\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+  printf (\"RequestedEvents: \");\n+  DO (VMInit);\n+  DO (VMDeath);\n+  DO (ThreadStart);\n+  DO (ThreadEnd);\n+  DO (ClassFileLoadHook);\n+  DO (ClassLoad);\n+  DO (ClassPrepare);\n+  DO (VMStart);\n+  DO (Exception);\n+  DO (ExceptionCatch);\n+  DO (SingleStep);\n+  DO (FramePop);\n+  DO (Breakpoint);\n+  DO (FieldAccess);\n+  DO (FieldModification);\n+  DO (MethodEntry);\n+  DO (MethodExit);\n+  DO (NativeMethodBind);\n+  DO (CompiledMethodLoad);\n+  DO (CompiledMethodUnload);\n+  DO (DynamicCodeGenerated);\n+  DO (DataDumpRequest);\n+  DO (MonitorWait);\n+  DO (MonitorWaited);\n+  DO (MonitorContendedEnter);\n+  DO (MonitorContendedEntered);\n+  DO (GarbageCollectionStart);\n+  DO (GarbageCollectionFinish);\n+  DO (ObjectFree);\n+  DO (VMObjectAlloc);\n+  printf (\"\\n\");\n+#undef DO\n+}\n+\n+static void\n+VMInitCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread)\n+{\n+  printf (\"VMInitCB jni_env=%p thread=%p\\n\", jni_env, thread);\n+}\n+\n+static void\n+VMDeathCB (jvmtiEnv *env, JNIEnv *jni_env)\n+{\n+  printf (\"VMDeathCB jni_env=%p\\n\", jni_env);\n+}\n+\n+static void\n+ThreadStartCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread)\n+{\n+  printf (\"ThreadStartCB jni_env=%p thread=%p\\n\", jni_env, thread);\n+}\n+\n+static void\n+ThreadEndCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread)\n+{\n+  printf (\"ThreadEndCB jni_env=%p thread=%p\\n\", jni_env, thread);\n+}\n+\n+static void\n+ClassFileLoadHookCB (jvmtiEnv *env, JNIEnv *jni_env,\n+\t\t     jclass class_being_redefined, jobject loader,\n+\t\t     const char *name, jobject protection_domain,\n+\t\t     jint class_data_len, const unsigned char *class_data,\n+\t\t     jint *new_class_data_len, unsigned char **new_class_data)\n+{\n+  printf (\"ClassFileLoadHookCB jni_env=%p class_being_redefined=%p loader=%p\",\n+\t  jni_env, class_being_redefined, loader);\n+  printf (\" name=%s protection_domain=%p class_data_len=%d class_data=%p\",\n+\t  name, protection_domain, (int) class_data_len, class_data);\n+  printf (\" new_class_data_len=%p new_class_data=%p\\n\", new_class_data_len,\n+\t  new_class_data);\n+}\n+\n+static void\n+ClassLoadCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jclass klass)\n+{\n+  printf (\"ClassLoadCB jni_env=%p thread=%p klass=%p\\n\", jni_env, thread,\n+\t  klass);\n+}\n+\n+static void\n+ClassPrepareCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jclass klass)\n+{\n+  printf (\"ClassPrepareCB jni_env=%p thread=%p klass=%p\\n\", jni_env,\n+\t  thread, klass);\n+}\n+\n+static void\n+VMStartCB (jvmtiEnv *env, JNIEnv *jni_env)\n+{\n+  printf (\"VMStartCB jni_env=%p\\n\", jni_env);\n+}\n+\n+static void\n+ExceptionCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jmethodID method,\n+\t     jlocation location, jobject exception, jmethodID catch_method,\n+\t     jlocation catch_location)\n+{\n+  printf (\"ExceptionCB jni_env=%p thread=%p method=%p location=%p\", jni_env,\n+\t  thread, method, location);\n+  printf (\" exception=%p catch_method=%p catch_location=%p\\n\", exception,\n+\t  catch_method, catch_location);\n+}\n+\n+static void\n+ExceptionCatchCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t  jmethodID method, jlocation location, jobject exception)\n+{\n+  printf (\"ExceptionCatchCB jni_env=%p thread=%p method=%p location=%p\",\n+\t  jni_env, thread, method, location);\n+  printf (\" exception=%p\\n\", exception);\n+}\n+\n+static void\n+SingleStepCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jmethodID method,\n+\t      jlocation location)\n+{\n+  printf (\"SingleStepCB jni_env=%p thread=%p method=%p location=%p\\n\", \n+\t  jni_env, thread, method, location);\n+}\n+\n+static void\n+FramePopCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jmethodID method,\n+\t    jboolean was_popped_by_exception)\n+{\n+  printf (\"FramePopCB jni_env=%p thread=%p method=%p\", jni_env, thread,\n+\t  method);\n+  printf (\" was_pooped_by_exception=%d\\n\", (was_popped_by_exception ?\n+\t\t\t\t\t    1 : 0));\n+}\n+\n+static void\n+BreakpointCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jmethodID method,\n+\t      jlocation location)\n+{\n+  printf (\"BreakpointCB  jni_env=%p thread=%p method=%p location=%p\\n\",\n+\t  jni_env, thread, method, location);\n+}\n+\n+static void\n+FieldAccessCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t       jmethodID method, jlocation location, jclass field_klass,\n+\t       jobject object, jfieldID field)\n+{\n+  printf (\"FieldAccessCB jni_env=%p thread=%p method=%p location=%p\",\n+\t  jni_env, thread, method, location);\n+  printf (\" field_klass=%p object=%p field=%p\\n\", field_klass, object, field);\n+}\n+\n+static void\n+FieldModificationCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t     jmethodID method, jlocation location, jclass field_klass,\n+\t\t     jobject object, jfieldID field, char signature_type,\n+\t\t     jvalue new_value)\n+\n+{\n+  printf (\"FieldModificationCB  jni_env=%p thread=%p method=%p location=%p\",\n+\t  jni_env, thread, method, location);\n+  printf (\" field_klass=%p object=%p field=%p signature_type=%c\", field_klass,\n+\t  object, field, signature_type);\n+  printf (\" new_value=%d\\n\", (int) new_value.i);\n+}\n+\n+static void\n+MethodEntryCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t       jmethodID method)\n+{\n+  printf (\"MethodEntryCB jni_env=%p thread=%p method=%p\\n\", jni_env, thread,\n+\t  method);\n+}\n+\n+static void\n+MethodExitCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t      jmethodID method, jboolean was_popped_by_exception,\n+\t      jvalue return_value)\n+{\n+  printf (\"MethodExitCB jni_env=%p thread=%p method=%p\", jni_env, thread,\n+\t  method);\n+  printf (\" was_popped_by_exception=%d return_value=%d\\n\",\n+\t  (was_popped_by_exception) ? 1 : 0, (int) return_value.i);\n+}\n+\n+static void\n+NativeMethodBindCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t    jmethodID method, void *address, void **new_address_ptr)\n+{\n+  printf (\"NativeMethodBindCB jni_env=%p thread=%p method=%p\", jni_env,\n+\t  thread, method);\n+  printf (\" address=%p new_address_ptr=%p\\n\", address, new_address_ptr);\n+}\n+\n+static void\n+CompiledMethodLoadCB (jvmtiEnv *env, jmethodID method, jint code_size,\n+\t\t      const void *code_addr, jint map_length,\n+\t\t      const jvmtiAddrLocationMap *map,\n+\t\t      const void *compile_info)\n+{\n+  printf (\"CompiledMethodLoadCB method=%p code_size=%p code_addr=%p\",\n+\t  method, code_size, code_addr);\n+  printf (\" map_length=%d map=%p compile_info=%p\\n\", (int) map_length, map,\n+\t  compile_info);\n+}\n+\n+static void\n+CompiledMethodUnloadCB (jvmtiEnv *env, jmethodID method, const void *code_addr)\n+{\n+  printf (\"CompiledMethodUnloadCB method=%p code_addr=%p\\n\", method, \n+\t  code_addr);\n+}\n+\n+static void\n+DynamicCodeGeneratedCB (jvmtiEnv *env, const char *name, const void *address,\n+\t\t\tjint length)\n+{\n+  printf (\"DynamicCodeGeneratedCB name=%s address=%p length=%d\\n\", name,\n+\t  address, (int) length);\n+}\n+\n+static void\n+DataDumpRequestCB (jvmtiEnv *env)\n+{\n+  printf (\"DataDumpRequestCB\\n\");\n+}\n+\n+static void\n+MonitorWaitCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread, jobject object,\n+\t       jlong timeout)\n+{\n+  printf (\"MonitorWaitCB jni_env=%p thread=%p object=%p timeout=%ld\\n\",\n+\t  jni_env, thread, object, (long) timeout);\n+}\n+\n+static void\n+MonitorWaitedCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t jobject object, jboolean timed_out)\n+{\n+  printf (\"MonitorWaitedCB jni_env=%p thread=%p object=%p timed_out=%d\\n\",\n+\t  jni_env, thread, object, (timed_out) ? 1 : 0);\n+}\n+\n+static void\n+MonitorContendedEnterCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t\t jobject object)\n+{\n+  printf (\"MonitorContendedEnterCB jni_env=%p thread=%p object=%p\\n\",\n+\t  jni_env, thread, object);\n+}\n+\n+static void\n+MonitorContendedEnteredCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t\t   jobject object)\n+{\n+  printf (\"MonitorContendedEnteredCB jni_env=%p thread=%p object=%p\\n\",\n+\t  jni_env, thread, object);\n+}\n+\n+static void\n+GarbageCollectionStartCB (jvmtiEnv *env)\n+{\n+  printf (\"GarbageCollectionStartCB\\n\");\n+}\n+\n+static void\n+GarbageCollectionFinishCB (jvmtiEnv *env)\n+{\n+  printf (\"GarbageCollectionFinishCB\\n\");\n+}\n+\n+static void\n+ObjectFreeCB (jvmtiEnv *env, jlong tag)\n+{\n+  printf (\"ObjectFreeCB tag=%ld\\n\", (long) tag);\n+}\n+\n+static void\n+VMObjectAllocCB (jvmtiEnv *env, JNIEnv *jni_env, jthread thread,\n+\t\t jobject object, jclass object_klass, jlong size)\n+{\n+  printf (\"VMObjectAllocCB jni_env=%p thread=%p object=%p\", jni_env,\n+\t  thread, object);\n+  printf (\" object_klass=%p size=%ld\\n\", object_klass, (long) size);\n+}\n+\n+static void\n+do_enable_tests ()\n+{\n+  printf (\"- enable tests -\\n\");\n+  JavaVM *vm = _Jv_GetJavaVM ();\n+  jvmtiEnv *env[3];\n+  int i;\n+  for (i = 0; i < 3; ++i)\n+    {\n+      vm->GetEnv (reinterpret_cast<void **> (&env[i]), JVMTI_VERSION_1_0);\n+      printf (\"created JVMTI environment #%d\\n\", i);\n+    }\n+\n+  jvmtiEventCallbacks callbacks;\n+  memset (&callbacks, 0, sizeof (jvmtiEventCallbacks));\n+\n+  printf (\"setting callbacks for envs\\n\");\n+  callbacks.VMInit = VMInitCB;\n+  env[0]->SetEventCallbacks (&callbacks, sizeof (callbacks));\n+  callbacks.VMDeath = VMDeathCB;\n+  env[1]->SetEventCallbacks (&callbacks, sizeof (callbacks));\n+  callbacks.ThreadEnd = ThreadEndCB;\n+  env[2]->SetEventCallbacks (&callbacks, sizeof (callbacks));\n+  print_events ();\n+\n+  printf (\"enable VM_INIT for env0, env1, env2\\n\");\n+  env[0]->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  env[1]->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  env[2]->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  print_events ();\n+\n+  printf (\"enable VM_DEATH for env1,env2\\n\");\n+  env[1]->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  env[2]->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  print_events ();\n+\n+  /* Used to use a non-NULL event thread, but that causes problems\n+     when SetEventNotificationMode tries to validate the thread. */\n+  printf (\"enable THREAD_END for env2\\n\");\n+  env[2]->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_THREAD_END,\n+\t\t\t\t    NULL);\n+  print_events ();\n+\n+  printf (\"disposing of env1\\n\");\n+  env[1]->DisposeEnvironment ();\n+  print_events ();\n+\n+  printf (\"disposing of env0\\n\");\n+  env[0]->DisposeEnvironment ();\n+  print_events ();\n+\n+  printf (\"disable VMInit in env2\\n\");\n+  env[2]->SetEventNotificationMode (JVMTI_DISABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  print_events ();\n+\n+  printf (\"clear VMDeath callback in env2\\n\");\n+  callbacks.VMDeath = NULL;\n+  env[2]->SetEventCallbacks (&callbacks, sizeof (callbacks));\n+  print_events ();\n+\n+  printf (\"sending VMInit\\n\");\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_INIT, (jthread) 0x1234,\n+\t\t       (JNIEnv *) 0x5678);\n+\n+  printf (\"sending ThreadEnd\\n\");\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_THREAD_END, (jthread) 0x1234,\n+\t\t       (JNIEnv *) 0x5678);\n+\n+  /* See comment above re: SetEventNotificationMode and validity\n+     checking\n+  printf (\"sending ThreadEnd (no match)\\n\");\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_THREAD_END, (jthread) 0x4321,\n+\t\t       (JNIEnv *) 0x5678);\n+  */\n+\n+  printf (\"sending VMDeath\\n\");\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_DEATH, (jthread) NULL,\n+\t\t       (JNIEnv *) 0x5678);\n+\n+  printf (\"disposing of env2\\n\");\n+  env[2]->DisposeEnvironment ();\n+  print_events ();\n+}\n+\n+static void\n+do_callback_arg_tests ()\n+{\n+  printf (\"- callback arg tests -\\n\");\n+  JavaVM *vm = _Jv_GetJavaVM ();\n+  jvmtiEnv *env;\n+  vm->GetEnv (reinterpret_cast<void **> (&env), JVMTI_VERSION_1_0);\n+\n+  // Define all the callbacks\n+#define DEFINE(Event) callbacks.Event = Event ## CB;\n+  jvmtiEventCallbacks callbacks;\n+  DEFINE(VMInit);\n+  DEFINE(VMDeath);\n+  DEFINE(ThreadStart);\n+  DEFINE(ThreadEnd);\n+  DEFINE(ClassFileLoadHook);\n+  DEFINE(ClassLoad);\n+  DEFINE(ClassPrepare);\n+  DEFINE(VMStart);\n+  DEFINE(Exception);\n+  DEFINE(ExceptionCatch);\n+  DEFINE(SingleStep);\n+  DEFINE(FramePop);\n+  DEFINE(Breakpoint);\n+  DEFINE(FieldAccess);\n+  DEFINE(FieldModification);\n+  DEFINE(MethodEntry);\n+  DEFINE(MethodExit);\n+  DEFINE(NativeMethodBind);\n+  DEFINE(CompiledMethodLoad);\n+  DEFINE(CompiledMethodUnload);\n+  DEFINE(DynamicCodeGenerated);\n+  DEFINE(DataDumpRequest);\n+  DEFINE(MonitorWait);\n+  DEFINE(MonitorWaited);\n+  DEFINE(MonitorContendedEnter);\n+  DEFINE(MonitorContendedEntered);\n+  DEFINE(GarbageCollectionStart);\n+  DEFINE(GarbageCollectionFinish);\n+  DEFINE(ObjectFree);\n+  DEFINE(VMObjectAlloc);\n+#undef DEFINE\n+  env->SetEventCallbacks (&callbacks, sizeof (callbacks));\n+\n+  // Enable all the callbacks\n+#define ENABLE(Event)\t\t\t\t\t\t\t\\\n+  env->SetEventNotificationMode (JVMTI_ENABLE, JVMTI_EVENT_ ## Event, NULL)\n+  ENABLE (VM_INIT);\n+  ENABLE (VM_DEATH);\n+  ENABLE (THREAD_START);\n+  ENABLE (THREAD_END);\n+  ENABLE (CLASS_FILE_LOAD_HOOK);\n+  ENABLE (CLASS_LOAD);\n+  ENABLE (CLASS_PREPARE);\n+  ENABLE (VM_START);\n+  ENABLE (EXCEPTION);\n+  ENABLE (EXCEPTION_CATCH);\n+  ENABLE (SINGLE_STEP);\n+  ENABLE (FRAME_POP);\n+  ENABLE (BREAKPOINT);\n+  ENABLE (FIELD_ACCESS);\n+  ENABLE (FIELD_MODIFICATION);\n+  ENABLE (METHOD_ENTRY);\n+  ENABLE (METHOD_EXIT);\n+  ENABLE (NATIVE_METHOD_BIND);\n+  ENABLE (COMPILED_METHOD_LOAD);\n+  ENABLE (COMPILED_METHOD_UNLOAD);\n+  ENABLE (DYNAMIC_CODE_GENERATED);\n+  ENABLE (DATA_DUMP_REQUEST);\n+  ENABLE (MONITOR_WAIT);\n+  ENABLE (MONITOR_WAITED);\n+  ENABLE (MONITOR_CONTENDED_ENTER);\n+  ENABLE (MONITOR_CONTENDED_ENTERED);\n+  ENABLE (GARBAGE_COLLECTION_START);\n+  ENABLE (GARBAGE_COLLECTION_FINISH);\n+  ENABLE (OBJECT_FREE);\n+  ENABLE (VM_OBJECT_ALLOC);\n+\n+  // All events should now be enabled.\n+  print_events ();\n+\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_INIT, (jthread) 0x2, (JNIEnv *) 0x1);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_DEATH, (jthread) 0x2, (JNIEnv *) 0x1);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_THREAD_START, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_THREAD_END, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, (jthread) 0xb00,\n+\t\t       (JNIEnv *) 0x1, (jclass) 0x2, (jobject) 0x3,\n+\t\t       \"4\", (jobject) 0x5, (jint) 6,\n+\t\t       (const unsigned char *) 0x7, (jint *) 0x8,\n+\t\t       (unsigned char **) 0x9);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_CLASS_LOAD, (jthread) 0x2, (JNIEnv *) 0x1,\n+\t\t       (jclass) 0x3);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_CLASS_PREPARE, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jclass) 0x3);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_START, (jthread) 0xb00, (JNIEnv *) 0x1);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_EXCEPTION, (jthread) 0x2, (JNIEnv *) 0x1,\n+\t\t       (jmethodID) 0x3, (jlocation) 0x4, (jobject) 0x5,\n+\t\t       (jmethodID) 0x6, (jlocation) 0x7);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_EXCEPTION_CATCH, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jmethodID) 0x3, (jlocation) 0x4,\n+\t\t       (jobject) 0x5);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_SINGLE_STEP, (jthread) 0x2, (JNIEnv *) 0x1,\n+\t\t       (jmethodID) 0x3, (jlocation) 0x4);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_FRAME_POP, (jthread) 0x2, (JNIEnv *) 0x1,\n+\t\t       (jmethodID) 0x3, 4);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_BREAKPOINT, (jthread) 0x2, (JNIEnv *) 0x1,\n+\t\t       (jmethodID) 0x3, (jlocation) 0x4);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_FIELD_ACCESS, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jmethodID) 0x3, (jlocation) 0x4,\n+\t\t       (jclass) 0x5, (jobject) 0x6, (jfieldID) 0x7);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_FIELD_MODIFICATION, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jmethodID) 0x3, (jlocation) 0x4,\n+\t\t       (jclass) 0x5, (jobject) 0x6, (jfieldID) 0x7,\n+\t\t       (int) '8', (/*jvalue*/ jobject) 0x9);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_METHOD_ENTRY, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jmethodID) 0x3);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_METHOD_EXIT, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jmethodID) 0x3, 4, /*jvalue*/ 5);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_NATIVE_METHOD_BIND, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jmethodID) 0x3, (void *) 0x4,\n+\t\t       (void **) 0x5);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_COMPILED_METHOD_LOAD, (jthread) 0xb00,\n+\t\t       (jmethodID) 0x1, (jint) 2, (const void *) 0x3,\n+\t\t       (jint) 4, (const jvmtiAddrLocationMap *) 0x5,\n+\t\t       (const void *) 0x6);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_COMPILED_METHOD_UNLOAD, (jthread) 0xb00,\n+\t\t       (jmethodID) 0x1, (const void *) 0x2);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_DYNAMIC_CODE_GENERATED, (jthread) 0xb00,\n+\t\t       \"1\", (const void *) 0x2, (jint) 3);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_DATA_DUMP_REQUEST, (jthread) 0xb00);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_MONITOR_WAIT, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jobject) 0x3, (jlong) 4);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_MONITOR_WAITED, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jobject) 0x3, (int) 4);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_MONITOR_CONTENDED_ENTER, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jobject) 0x3);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jobject) 0x3);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_GARBAGE_COLLECTION_START, (jthread) 0xb00);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, (jthread) 0xb00);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_OBJECT_FREE, (jthread) 0xb00, (jlong) 1);\n+  _Jv_JVMTI_PostEvent (JVMTI_EVENT_VM_OBJECT_ALLOC, (jthread) 0x2,\n+\t\t       (JNIEnv *) 0x1, (jobject) 0x3, (jclass) 0x4,\n+\t\t       (jlong) 5);\n+}\n+\n+void\n+events::do_events_tests ()\n+{\n+  do_enable_tests ();\n+  do_callback_arg_tests ();\n+}"}]}