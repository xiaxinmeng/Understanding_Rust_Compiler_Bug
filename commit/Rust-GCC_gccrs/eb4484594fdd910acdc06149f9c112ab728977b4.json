{"sha": "eb4484594fdd910acdc06149f9c112ab728977b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI0NDg0NTk0ZmRkOTEwYWNkYzA2MTQ5ZjljMTEyYWI3Mjg5NzdiNA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-02T01:42:58Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1997-05-02T01:42:58Z"}, "message": "91th Cygnus<->FSF quick merge\n\nFrom-SVN: r14007", "tree": {"sha": "d15683fdd007eaa7a6e42cb25ad13d7a80886862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d15683fdd007eaa7a6e42cb25ad13d7a80886862"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb4484594fdd910acdc06149f9c112ab728977b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4484594fdd910acdc06149f9c112ab728977b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb4484594fdd910acdc06149f9c112ab728977b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb4484594fdd910acdc06149f9c112ab728977b4/comments", "author": null, "committer": null, "parents": [{"sha": "ebcf525f58c8bf78b8ee10c7cd4aed0ee26ff604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebcf525f58c8bf78b8ee10c7cd4aed0ee26ff604", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebcf525f58c8bf78b8ee10c7cd4aed0ee26ff604"}], "stats": {"total": 280, "additions": 146, "deletions": 134}, "files": [{"sha": "d4231c18d2b0ca107b6e5860c6c0dc659c23249d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -1,3 +1,46 @@\n+Thu May  1 18:26:37 1997  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_exception_blocks): Ensure that we flow through\n+ \tthe end of the exception region for the exception specification.\n+  \tMove exception region for the exception specification in, so that\n+ \tit doesn't protect the parm cleanup.  Remove some obsolete code.\n+  \t* decl.c (store_parm_decls): Likewise.\n+\t(finish_function): Likewise.\n+\n+Tue Apr 29 15:38:54 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* init.c (build_new): Fix nothrow handling.\n+\n+Tue Apr 29 14:29:50 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* init.c (emit_base_init): Don't warn about the initialization\n+\tlist for an artificial member.\n+\n+Fri Apr 25 17:47:59 1997  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* expr.c (do_case): Handle !START case for the error msg.\n+\n+Fri Apr 25 11:55:23 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c, lang-options.h: New option -Weffc++.\n+\t* class.c, decl.c, init.c, typeck.c: Move Effective C++ warnings\n+\tto -Weffc++.\n+\n+\t* decl2.c (finish_prevtable_vardecl): Change NO_LINKAGE_HEURISTICS\n+ \tto MULTIPLE_SYMBOL_SPACES.\n+\n+Wed Apr 23 18:06:50 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* method.c (emit_thunk, generic case): Set current_function_is_thunk.\n+\n+\t* method.c (emit_thunk, macro case): Set up DECL_RESULT.\n+\n+\t* typeck.c (c_expand_return): Don't complain about returning void\n+\tto void in an artificial function.\n+\t* method.c (make_thunk): Change settings of READONLY/VOLATILE, \n+\tdon't set DECL_RESULT, set DECL_ARTIFICIAL.\n+\t(emit_thunk, generic code): Also set up DECL_LANG_SPECIFIC. \n+\n Wed Apr 23 14:43:06 1997  Mike Stump  <mrs@cygnus.com>\n \n \t* init.c (init_decl_processing): Add supoprt for setjmp/longjmp based"}, {"sha": "8cddd980608411803e1acae1d06c1165614e286a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -3587,7 +3587,7 @@ finish_struct_1 (t, warn_anon)\n     }\n \n   /* Effective C++ rule 11.  */\n-  if (has_pointers && extra_warnings\n+  if (has_pointers && warn_ecpp\n       && ! (TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n       cp_warning (\"`%#T' has pointer data members\", t);"}, {"sha": "96dd1470a35c70dab540b2092f0e5205b7594e46", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -238,7 +238,12 @@ extern int warn_nonvdtor;\n \n extern int warn_pmf2ptr;\n \n+/* Nonzero means warn about violation of some Effective C++ style rules.  */\n+\n+extern int warn_ecpp;\n+\n /* Non-zero means warn when a function is declared extern and later inline.  */\n+\n extern int warn_extern_inline;\n \n /* Nonzero means to treat bitfields as unsigned unless they say `signed'.  */"}, {"sha": "749a2f35a4286e88fce972e5f4da6e09f9caf910", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 25, "deletions": 42, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -10137,7 +10137,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \n \t  /* More Effective C++ rule 6.  */\n-\t  if (extra_warnings\n+\t  if (warn_ecpp\n \t      && (name == ansi_opname[(int) POSTINCREMENT_EXPR]\n \t\t  || name == ansi_opname[(int) POSTDECREMENT_EXPR]))\n \t    {\n@@ -10182,7 +10182,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t    }\n \n \t  /* More Effective C++ rule 7.  */\n-\t  if (extra_warnings\n+\t  if (warn_ecpp\n \t      && (name == ansi_opname [TRUTH_ANDIF_EXPR]\n \t\t  || name == ansi_opname [TRUTH_ORIF_EXPR]\n \t\t  || name == ansi_opname [COMPOUND_EXPR]))\n@@ -10191,7 +10191,7 @@ grok_op_properties (decl, virtualp, friendp)\n \t}\n \n       /* Effective C++ rule 23.  */\n-      if (extra_warnings\n+      if (warn_ecpp\n \t  && list_length (argtypes) == 3\n \t  && (name == ansi_opname [PLUS_EXPR]\n \t      || name == ansi_opname [MINUS_EXPR]\n@@ -10499,7 +10499,7 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n \t  /* Effective C++ rule 14.  The case of virtual functions but\n \t     non-virtual dtor is handled in finish_struct_1.  */\n-\t  if (warn_nonvdtor && ! TYPE_VIRTUAL_P (basetype)\n+\t  if (warn_ecpp && ! TYPE_VIRTUAL_P (basetype)\n \t      && TYPE_HAS_DESTRUCTOR (basetype))\n \t    cp_warning (\"base class `%#T' has a non-virtual destructor\",\n \t\t\tbasetype);\n@@ -11030,7 +11030,7 @@ start_function (declspecs, declarator, attrs, pre_parsed_p)\n     warning (\"return-type defaults to `int'\");\n \n   /* Effective C++ rule 15.  See also c_expand_return.  */\n-  if (extra_warnings\n+  if (warn_ecpp\n       && DECL_NAME (decl1) == ansi_opname[(int) MODIFY_EXPR]\n       && TREE_TYPE (fntype) == void_type_node)\n     cp_warning (\"`operator=' should return a reference to `*this'\");\n@@ -11379,10 +11379,22 @@ store_parm_decls ()\n   if (! processing_template_decl)\n     expand_function_start (fndecl, parms_have_cleanups);\n \n+  current_function_parms_stored = 1;\n+\n+  /* If this function is `main', emit a call to `__main'\n+     to run global initializers, etc.  */\n+  if (DECL_NAME (fndecl)\n+      && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 4\n+      && strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), \"main\") == 0\n+      && DECL_CONTEXT (fndecl) == NULL_TREE)\n+    {\n+      expand_main_function ();\n+    }\n+\n   /* Now that we have initialized the parms, we can start their\n      cleanups.  We cannot do this before, since expand_decl_cleanup\n      should not be called before the parm can be used.  */\n-  if (parms_have_cleanups\n+  if (cleanups\n       && ! processing_template_decl)      \n     {\n       for (cleanups = nreverse (cleanups); cleanups; cleanups = TREE_CHAIN (cleanups))\n@@ -11402,41 +11414,13 @@ store_parm_decls ()\n       expand_start_bindings (0);\n     }\n \n-  current_function_parms_stored = 1;\n-\n-  /* If this function is `main', emit a call to `__main'\n-     to run global initializers, etc.  */\n-  if (DECL_NAME (fndecl)\n-      && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) == 4\n-      && strcmp (IDENTIFIER_POINTER (DECL_NAME (fndecl)), \"main\") == 0\n-      && DECL_CONTEXT (fndecl) == NULL_TREE)\n-    {\n-      expand_main_function ();\n-    }\n-\n-  /* Take care of exception handling things. */\n   if (! processing_template_decl && flag_exceptions)\n     {\n-      rtx insns;\n-      start_sequence ();\n-\n-#if 0\n-      /* Mark the start of a stack unwinder if we need one.  */\n-      start_eh_unwinder ();\n-#endif\n-\n-#if 0\n       /* Do the starting of the exception specifications, if we have any.  */\n       if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n \texpand_start_eh_spec ();\n-#endif\n-\n-      insns = get_insns ();\n-      end_sequence ();\n-\n-      if (insns)\n-\tstore_after_parms (insns);\n     }\n+\n   last_dtor_insn = get_last_insn ();\n }\n \n@@ -11881,6 +11865,9 @@ finish_function (lineno, call_poplevel, nested)\n \t       && ! DECL_NAME (DECL_RESULT (current_function_decl)))\n \tno_return_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n+      if (flag_exceptions)\n+\texpand_exception_blocks ();\n+\n       /* If this function is supposed to return a value, ensure that\n \t we do not fall into the cleanups by mistake.  The end of our\n \t function will look like this:\n@@ -11913,11 +11900,10 @@ finish_function (lineno, call_poplevel, nested)\n \t     to catch cleanup-generated temporaries.  */\n \t  expand_end_bindings (0, 0, 0);\n \t  poplevel (0, 0, 0);\n-\t}\n \n-      if (cleanup_label)\n-\t/* Emit label at beginning of cleanup code for parameters.  */\n-\temit_label (cleanup_label);\n+\t  /* Emit label at beginning of cleanup code for parameters.  */\n+\t  emit_label (cleanup_label);\n+\t}\n \n       /* Get return value into register if that's where it's supposed to be.  */\n       if (original_result_rtx)\n@@ -11937,9 +11923,6 @@ finish_function (lineno, call_poplevel, nested)\n \n       /* Generate rtl for function exit.  */\n       expand_function_end (input_filename, lineno, 1);\n-\n-      if (flag_exceptions)\n-\texpand_exception_blocks ();\n     }\n \n   /* This must come after expand_function_end because cleanups might"}, {"sha": "f7e20640694f42d50bee152d7102c4573eda8a33", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -244,6 +244,10 @@ int warn_synth;\n    into a pointer to (void or function).  */\n int warn_pmf2ptr = 1;\n \n+/* Nonzero means warn about violation of some Effective C++ style rules.  */\n+\n+int warn_ecpp = 0;\n+\n /* Nonzero means `$' can be in an identifier.\n    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */\n \n@@ -579,6 +583,8 @@ lang_decode_option (p)\n \twarn_synth = setting;\n       else if (!strcmp (p, \"pmf-conversions\"))\n \twarn_pmf2ptr = setting;\n+      else if (!strcmp (p, \"effc++\"))\n+\twarn_ecpp = setting;\n       else if (!strcmp (p, \"comment\"))\n \t;\t\t\t/* cpp handles this one.  */\n       else if (!strcmp (p, \"comments\"))\n@@ -2413,7 +2419,7 @@ finish_prevtable_vardecl (prev, vars)\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_template (ctype);\n \n-#ifndef NO_LINKAGE_HEURISTICS\n+#ifndef MULTIPLE_SYMBOL_SPACES\n   if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype)\n       && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {"}, {"sha": "45994ce1748e814d797cbe706a63a40d40fce873", "filename": "gcc/cp/except.c", "status": "modified", "additions": 17, "deletions": 56, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -917,13 +917,11 @@ void\n expand_exception_blocks ()\n {\n   rtx funcend;\n-  rtx insn, insns;\n-  rtx eh_spec_insns = NULL_RTX;\n+  rtx insns;\n \n   start_sequence ();\n \n   funcend = gen_label_rtx ();\n-  emit_jump (funcend);\n \n   start_sequence ();\n \n@@ -935,32 +933,26 @@ expand_exception_blocks ()\n \n   insns = get_insns ();\n   end_sequence ();\n-  \n-  /* Do this after we expand leftover cleanups, so that the expand_eh_region_end\n-     that expand_end_eh_spec does will match the right expand_eh_region_start,\n-     and make sure it comes out before the terminate protected region.  */\n+\n+#if 1\n+  /* Do this after we expand leftover cleanups, so that the\n+     expand_eh_region_end that expand_end_eh_spec does will match the\n+     right expand_eh_region_start, and make sure it comes out before\n+     the terminate protected region.  */\n   if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n     {\n-#if 1\n-      {\n-\trtx insns;\n-\t/* New...  */\n-\tstart_sequence ();\n-\texpand_start_eh_spec ();\n-\teh_spec_insns = get_insns ();\n-\tend_sequence ();\n-      }\n-#endif\n-\n-      expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));\n-      push_to_sequence (insns);\n+     expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));\n+     push_to_sequence (insns);\n \n-      /* Now expand any new ones.  */\n-      expand_leftover_cleanups ();\n+     /* Now expand any new ones.  */\n+     expand_leftover_cleanups ();\n \n-      insns = get_insns ();\n-      end_sequence ();\n+     insns = get_insns ();\n+     end_sequence ();\n     }\n+#endif\n+\n+  emit_jump (funcend);\n \n   if (insns)\n     {\n@@ -983,22 +975,6 @@ expand_exception_blocks ()\n       expand_leftover_cleanups ();\n     }\n \n-  {\n-    /* Mark the end of the stack unwinder.  */\n-    rtx unwind_insns;\n-    start_sequence ();\n-#if 0\n-    end_eh_unwinder ();\n-#endif\n-    unwind_insns = get_insns ();\n-    end_sequence ();\n-    if (unwind_insns)\n-      {\n-\tinsns = unwind_insns;\n-\temit_insns (insns);\n-      }\n-  }\n-\n   emit_label (funcend);\n \n   /* Only if we had previous insns do we want to emit the jump around\n@@ -1007,22 +983,7 @@ expand_exception_blocks ()\n     insns = get_insns ();\n   end_sequence ();\n \n-#if 1\n-  if (eh_spec_insns)\n-    emit_insns_after (eh_spec_insns, get_insns ());\n-#else\n-  if (eh_spec_insns)\n-    store_after_parms (eh_spec_insns);\n-#endif\n-\n-  insn = get_last_insn ();\n-  while (GET_CODE (insn) == NOTE\n-\t || (GET_CODE (insn) == INSN\n-\t     && (GET_CODE (PATTERN (insn)) == USE\n-\t\t || GET_CODE (PATTERN (insn)) == CLOBBER)))\n-    insn = PREV_INSN (insn);\n-    \n-  emit_insns_after (insns, insn);\n+  emit_insns (insns);\n }\n \n tree"}, {"sha": "9beee2823ff388ae73bf40b486cc0228551b0169", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -444,6 +444,8 @@ do_case (start, end)\n \t{\n \t  if (end)\n \t    error (\"case label within scope of cleanup or variable array\");\n+\t  else if (! start)\n+\t    error (\"`default' label within scope of cleanup or variable array\");\n \t  else\n \t    cp_error (\"case label `%E' within scope of cleanup or variable array\", start);\n \t}"}, {"sha": "662434eefa2420332a313e8090426b98f714779d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -647,7 +647,8 @@ emit_base_init (t, immediately)\n \t  from_init_list = 0;\n \n \t  /* Effective C++ rule 12.  */\n-\t  if (extra_warnings && init == NULL_TREE\n+\t  if (warn_ecpp && init == NULL_TREE\n+\t      && !DECL_ARTIFICIAL (member)\n \t      && TREE_CODE (TREE_TYPE (member)) != ARRAY_TYPE)\n \t    cp_warning (\"`%D' should be initialized in the member initialization list\", member);\t    \n \t}\n@@ -1895,7 +1896,6 @@ build_offset_ref (type, name)\n \t  tree access;\n \n \t  /* unique functions are handled easily.  */\n-\tunique:\n \t  access = compute_access (basebinfo, t);\n \t  if (access == access_protected_node)\n \t    {\n@@ -2415,10 +2415,12 @@ build_new (placement, decl, init, use_global_new)\n       return error_mark_node;\n     }\n \n-  nothrow = (placement\n-\t     && TREE_TYPE (placement)\n-\t     && IS_AGGR_TYPE (TREE_TYPE (placement))\n-\t     && (TYPE_IDENTIFIER (TREE_TYPE (placement))\n+  /* If the first placement arg is of type nothrow_t, it's allowed to\n+     return 0 on allocation failure.  */\n+  nothrow = (placement && TREE_VALUE (placement)\n+\t     && TREE_TYPE (TREE_VALUE (placement))\n+\t     && IS_AGGR_TYPE (TREE_TYPE (TREE_VALUE (placement)))\n+\t     && (TYPE_IDENTIFIER (TREE_TYPE (TREE_VALUE (placement)))\n \t\t == get_identifier (\"nothrow_t\")));\n \n   check_new = flag_check_new || nothrow;\n@@ -3152,11 +3154,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n      int flags;\n      int use_global_delete;\n {\n-  tree function;\n   tree member;\n   tree expr;\n   tree ref;\n-  int ptr;\n \n   if (addr == error_mark_node)\n     return error_mark_node;\n@@ -3190,7 +3190,6 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n       /* throw away const and volatile on target type of addr */\n       addr = convert_force (build_pointer_type (type), addr, 0);\n       ref = build_indirect_ref (addr, NULL_PTR);\n-      ptr = 1;\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -3221,7 +3220,6 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \taddr = convert_force (build_pointer_type (type), addr, 0);\n \n       ref = build_indirect_ref (addr, NULL_PTR);\n-      ptr = 0;\n     }\n \n   my_friendly_assert (IS_AGGR_TYPE (type), 220);\n@@ -3250,12 +3248,9 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n      of the base classes; otherwise, we must do that here.  */\n   if (TYPE_HAS_DESTRUCTOR (type))\n     {\n-      tree parms = build_tree_list (NULL_TREE, addr);\n-      tree dtor = DECL_MAIN_VARIANT (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1));\n       tree passed_auto_delete;\n       tree do_delete = NULL_TREE;\n       tree ifexp;\n-      int nonnull;\n \n       if (use_global_delete)\n \t{"}, {"sha": "707282dae88493de08c94206267b4e128af06a86", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -102,3 +102,5 @@ Boston, MA 02111-1307, USA.  */\n   \"-Wno-synth\",\n   \"-Wpmf-conversions\",\n   \"-Wno-pmf-conversions\",\n+  \"-Weffc++\",\n+  \"-Wno-effc++\","}, {"sha": "cf26ab1db85d8630d68e559dc3eb08287e53cfd5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -1698,30 +1698,29 @@ make_thunk (function, delta)\n     }\n   if (thunk == NULL_TREE)\n     {\n-      thunk = build_lang_decl (FUNCTION_DECL, thunk_id, TREE_TYPE (func_decl));\n-      DECL_RESULT (thunk)\n-\t= build_decl (RESULT_DECL, 0, TYPE_MAIN_VARIANT (TREE_TYPE (vtable_entry_type)));\n-      TREE_READONLY (thunk) = TYPE_READONLY (TREE_TYPE (vtable_entry_type));\n-      TREE_THIS_VOLATILE (thunk) = TYPE_VOLATILE (TREE_TYPE (vtable_entry_type));\n-      make_function_rtl (thunk);\n+      thunk = build_decl (FUNCTION_DECL, thunk_id, TREE_TYPE (func_decl));\n+      TREE_READONLY (thunk) = TREE_READONLY (func_decl);\n+      TREE_THIS_VOLATILE (thunk) = TREE_THIS_VOLATILE (func_decl);\n       comdat_linkage (thunk);\n       TREE_SET_CODE (thunk, THUNK_DECL);\n       DECL_INITIAL (thunk) = function;\n       THUNK_DELTA (thunk) = delta;\n       DECL_EXTERNAL (thunk) = 1;\n+      DECL_ARTIFICIAL (thunk) = 1;\n       /* So that finish_file can write out any thunks that need to be: */\n       pushdecl_top_level (thunk);\n     }\n   return thunk;\n }\n \n+/* Emit the definition of a C++ multiple inheritance vtable thunk.  */\n+\n void\n emit_thunk (thunk_fndecl)\n      tree thunk_fndecl;\n {\n   tree function = TREE_OPERAND (DECL_INITIAL (thunk_fndecl), 0);\n   int delta = THUNK_DELTA (thunk_fndecl);\n-  char *fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n \n   if (TREE_ASM_WRITTEN (thunk_fndecl))\n     return;\n@@ -1736,21 +1735,31 @@ emit_thunk (thunk_fndecl)\n \n   TREE_SET_CODE (thunk_fndecl, FUNCTION_DECL);\n \n+  {\n #ifdef ASM_OUTPUT_MI_THUNK\n-  current_function_decl = thunk_fndecl;\n-  temporary_allocation ();\n-  assemble_start_function (thunk_fndecl, fnname);\n-  ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n-  assemble_end_function (thunk_fndecl, fnname);\n-  permanent_allocation (1);\n-  current_function_decl = 0;\n+    char *fnname;\n+    current_function_decl = thunk_fndecl;\n+    temporary_allocation ();\n+    DECL_RESULT (thunk_fndecl)\n+      = build_decl (RESULT_DECL, 0, integer_type_node);\n+    make_function_rtl (thunk_fndecl);\n+    fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n+    assemble_start_function (thunk_fndecl, fnname);\n+    ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n+    assemble_end_function (thunk_fndecl, fnname);\n+    permanent_allocation (1);\n+    current_function_decl = 0;\n #else /* ASM_OUTPUT_MI_THUNK */\n-  if (varargs_function_p (function))\n-    cp_error (\"generic thunk code does not work for variadic function `%#D'\",\n-\t      function);\n-  {\n+  /* If we don't have the necessary macro for efficient thunks, generate a\n+     thunk function that just makes a call to the real function.\n+     Unfortunately, this doesn't work for varargs.  */\n+\n     tree a, t;\n \n+    if (varargs_function_p (function))\n+      cp_error (\"generic thunk code fails for method `%#D' which uses `...'\",\n+\t\tfunction);\n+\n     /* Set up clone argument trees for the thunk.  */\n     t = NULL_TREE;\n     for (a = DECL_ARGUMENTS (function); a; a = TREE_CHAIN (a))\n@@ -1763,9 +1772,14 @@ emit_thunk (thunk_fndecl)\n     a = nreverse (t);\n     DECL_ARGUMENTS (thunk_fndecl) = a;\n     DECL_RESULT (thunk_fndecl) = NULL_TREE;\n+    DECL_LANG_SPECIFIC (thunk_fndecl) = DECL_LANG_SPECIFIC (function);\n+    copy_lang_decl (thunk_fndecl);\n+    DECL_INTERFACE_KNOWN (thunk_fndecl) = 1;\n+    DECL_NOT_REALLY_EXTERN (thunk_fndecl) = 1;\n \n     start_function (NULL_TREE, thunk_fndecl, NULL_TREE, 1);\n     store_parm_decls ();\n+    current_function_is_thunk = 1;\n \n     /* Build up the call to the real function.  */\n     t = build_int_2 (delta, -1 * (delta < 0));\n@@ -1779,8 +1793,8 @@ emit_thunk (thunk_fndecl)\n     c_expand_return (t);\n \n     finish_function (lineno, 0, 0);\n-  }\n #endif /* ASM_OUTPUT_MI_THUNK */\n+  }\n \n   TREE_SET_CODE (thunk_fndecl, THUNK_DECL);\n }"}, {"sha": "4aee8a638aa61a80d0b448ec82837c563c4553c6", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb4484594fdd910acdc06149f9c112ab728977b4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=eb4484594fdd910acdc06149f9c112ab728977b4", "patch": "@@ -7105,15 +7105,16 @@ c_expand_return (retval)\n     }\n \n   /* Effective C++ rule 15.  See also start_function.  */\n-  if (extra_warnings\n+  if (warn_ecpp\n       && DECL_NAME (current_function_decl) == ansi_opname[(int) MODIFY_EXPR]\n       && retval != current_class_ref)\n     cp_warning (\"`operator=' should return a reference to `*this'\");\n \n   if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n     {\n       current_function_returns_null = 1;\n-      if (pedantic || TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n+      if ((pedantic && ! DECL_ARTIFICIAL (current_function_decl))\n+\t  || TREE_CODE (TREE_TYPE (retval)) != VOID_TYPE)\n \tpedwarn (\"`return' with a value, in function returning void\");\n       expand_return (retval);\n       return;"}]}