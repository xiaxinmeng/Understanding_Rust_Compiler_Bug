{"sha": "a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTFlZDdiZGJkZDdlMzU0M2Q0NDU2OGM5YjFhMjRkMWRjOGRmNGI2Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-24T13:14:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-24T13:14:57Z"}, "message": "local-alloc.c (qty): New structure and static variable.\n\n\t* local-alloc.c (qty): New structure and static variable.\n\t(qty_phys_reg): Remove, all references changed to qty.\n\t(qty_n_refs): Likewise.\n\t(qty_min_class): Likewise.\n\t(qty_birth): Likewise.\n\t(qty_death): Likewise.\n\t(qty_size): Likewise.\n\t(qty_mode): Likewise.\n\t(qty_n_calls_crossed): Likewise.\n\t(qty_alternate_class): Likewise.\n\t(qty_changes_size): Likewise.\n\t(qty_first_reg): Likewise.\n\t(alloc_qty): Rename variable QTY to QTYNO.\n\t(finf_free_reg): Likewise.\n\t(local_alloc): Allocate qty, do not allocate the removed variables.\n\nFrom-SVN: r30651", "tree": {"sha": "8d66e3b4c6f8cbf44f7f3e5c994a6894ffe18f7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d66e3b4c6f8cbf44f7f3e5c994a6894ffe18f7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67/comments", "author": null, "committer": null, "parents": [{"sha": "7e8a11bb9def439383cc79312e136b9bc8c8bd4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e8a11bb9def439383cc79312e136b9bc8c8bd4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e8a11bb9def439383cc79312e136b9bc8c8bd4d"}], "stats": {"total": 317, "additions": 160, "deletions": 157}, "files": [{"sha": "3b58e9e4206b78bdff80435b6db9e9b5bb48f181", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67", "patch": "@@ -1,3 +1,21 @@\n+Wed Nov 24 14:12:15 MET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* local-alloc.c (qty): New structure and static variable.\n+\t(qty_phys_reg): Remove, all references changed to qty.\n+\t(qty_n_refs): Likewise.\n+\t(qty_min_class): Likewise.\n+\t(qty_birth): Likewise.\n+\t(qty_death): Likewise.\n+\t(qty_size): Likewise.\n+\t(qty_mode): Likewise.\n+\t(qty_n_calls_crossed): Likewise.\n+\t(qty_alternate_class): Likewise.\n+\t(qty_changes_size): Likewise.\n+\t(qty_first_reg): Likewise.\n+\t(alloc_qty): Rename variable QTY to QTYNO.\n+\t(finf_free_reg): Likewise.\n+\t(local_alloc): Allocate qty, do not allocate the removed variables.\n+\n Wed Nov 24 17:26:05 1999  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* config/mips/mips.h (ASM_SPEC): Don't pass -G to the assembler"}, {"sha": "3907a45808cb8deeaeb6aa583c515cf4ffccc375", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 142, "deletions": 157, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=a1ed7bdbdd7e3543d44568c9b1a24d1dc8df4b67", "patch": "@@ -78,100 +78,108 @@ Boston, MA 02111-1307, USA.  */\n \n static int next_qty;\n \n-/* In all the following vectors indexed by quantity number.  */\n+/* Information we maitain about each quantity.  */\n+struct qty\n+{\n+  /* The number of refs to quantity Q.  */\n \n-/* Element Q is the hard reg number chosen for quantity Q,\n-   or -1 if none was found.  */\n+  int n_refs;\n \n-static short *qty_phys_reg;\n+  /* Insn number (counting from head of basic block)\n+     where quantity Q was born.  -1 if birth has not been recorded.  */\n \n-/* We maintain two hard register sets that indicate suggested hard registers\n-   for each quantity.  The first, qty_phys_copy_sugg, contains hard registers\n-   that are tied to the quantity by a simple copy.  The second contains all\n-   hard registers that are tied to the quantity via an arithmetic operation.\n+  int birth;\n \n-   The former register set is given priority for allocation.  This tends to\n-   eliminate copy insns.  */\n+  /* Insn number (counting from head of basic block)\n+     where given quantity died.  Due to the way tying is done,\n+     and the fact that we consider in this pass only regs that die but once,\n+     a quantity can die only once.  Each quantity's life span\n+     is a set of consecutive insns.  -1 if death has not been recorded.  */\n \n-/* Element Q is a set of hard registers that are suggested for quantity Q by\n-   copy insns.  */\n+  int death;\n \n-static HARD_REG_SET *qty_phys_copy_sugg;\n+  /* Number of words needed to hold the data in given quantity.\n+     This depends on its machine mode.  It is used for these purposes:\n+     1. It is used in computing the relative importances of qtys,\n+\twhich determines the order in which we look for regs for them.\n+     2. It is used in rules that prevent tying several registers of\n+\tdifferent sizes in a way that is geometrically impossible\n+\t(see combine_regs).  */\n \n-/* Element Q is a set of hard registers that are suggested for quantity Q by\n-   arithmetic insns.  */\n+  int size;\n \n-static HARD_REG_SET *qty_phys_sugg;\n+  /* Number of times a reg tied to given qty lives across a CALL_INSN.  */\n \n-/* Element Q is the number of suggested registers in qty_phys_copy_sugg.  */\n+  int n_calls_crossed;\n \n-static short *qty_phys_num_copy_sugg;\n+  /* The register number of one pseudo register whose reg_qty value is Q.\n+     This register should be the head of the chain\n+     maintained in reg_next_in_qty.  */\n \n-/* Element Q is the number of suggested registers in qty_phys_sugg.  */\n+  int first_reg;\n \n-static short *qty_phys_num_sugg;\n+  /* Reg class contained in (smaller than) the preferred classes of all\n+     the pseudo regs that are tied in given quantity.\n+     This is the preferred class for allocating that quantity.  */\n+\n+  enum reg_class min_class;\n \n-/* Element Q is the number of refs to quantity Q.  */\n+  /* Register class within which we allocate given qty if we can't get\n+     its preferred class.  */\n \n-static int *qty_n_refs;\n+  enum reg_class alternate_class;\n \n-/* Element Q is a reg class contained in (smaller than) the\n-   preferred classes of all the pseudo regs that are tied in quantity Q.\n-   This is the preferred class for allocating that quantity.  */\n+  /* This holds the mode of the registers that are tied to given qty,\n+     or VOIDmode if registers with differing modes are tied together.  */\n \n-static enum reg_class *qty_min_class;\n+  enum machine_mode mode;\n \n-/* Insn number (counting from head of basic block)\n-   where quantity Q was born.  -1 if birth has not been recorded.  */\n+  /* the hard reg number chosen for given quantity,\n+     or -1 if none was found.  */\n \n-static int *qty_birth;\n+  short phys_reg;\n \n-/* Insn number (counting from head of basic block)\n-   where quantity Q died.  Due to the way tying is done,\n-   and the fact that we consider in this pass only regs that die but once,\n-   a quantity can die only once.  Each quantity's life span\n-   is a set of consecutive insns.  -1 if death has not been recorded.  */\n+  /* Nonzero if this quantity has been used in a SUBREG that changes\n+     its size.  */\n \n-static int *qty_death;\n+  char changes_size;\n \n-/* Number of words needed to hold the data in quantity Q.\n-   This depends on its machine mode.  It is used for these purposes:\n-   1. It is used in computing the relative importances of qtys,\n-      which determines the order in which we look for regs for them.\n-   2. It is used in rules that prevent tying several registers of\n-      different sizes in a way that is geometrically impossible\n-      (see combine_regs).  */\n+};\n \n-static int *qty_size;\n+static struct qty *qty;\n \n-/* This holds the mode of the registers that are tied to qty Q,\n-   or VOIDmode if registers with differing modes are tied together.  */\n+/* These fields are kept separately to speedup their clearing.  */\n \n-static enum machine_mode *qty_mode;\n+/* We maintain two hard register sets that indicate suggested hard registers\n+   for each quantity.  The first, phys_copy_sugg, contains hard registers\n+   that are tied to the quantity by a simple copy.  The second contains all\n+   hard registers that are tied to the quantity via an arithmetic operation.\n \n-/* Number of times a reg tied to qty Q lives across a CALL_INSN.  */\n+   The former register set is given priority for allocation.  This tends to\n+   eliminate copy insns.  */\n \n-static int *qty_n_calls_crossed;\n+/* Element Q is a set of hard registers that are suggested for quantity Q by\n+   copy insns.  */\n \n-/* Register class within which we allocate qty Q if we can't get\n-   its preferred class.  */\n+static HARD_REG_SET *qty_phys_copy_sugg;\n \n-static enum reg_class *qty_alternate_class;\n+/* Element Q is a set of hard registers that are suggested for quantity Q by\n+   arithmetic insns.  */\n+\n+static HARD_REG_SET *qty_phys_sugg;\n+\n+/* Element Q is the number of suggested registers in qty_phys_copy_sugg.  */\n \n-/* Element Q is nonzero if this quantity has been used in a SUBREG\n-   that changes its size.  */\n+static short *qty_phys_num_copy_sugg;\n \n-static char *qty_changes_size;\n+/* Element Q is the number of suggested registers in qty_phys_sugg.  */\n \n-/* Element Q is the register number of one pseudo register whose\n-   reg_qty value is Q.  This register should be the head of the chain\n-   maintained in reg_next_in_qty.  */\n+static short *qty_phys_num_sugg;\n \n-static int *qty_first_reg;\n \n /* If (REG N) has been assigned a quantity number, is a register number\n    of another register assigned the same quantity number, or -1 for the\n-   end of the chain.  qty_first_reg point to the head of this chain.  */\n+   end of the chain.  qty->first_reg point to the head of this chain.  */\n \n static int *reg_next_in_qty;\n \n@@ -278,21 +286,21 @@ alloc_qty (regno, mode, size, birth)\n      enum machine_mode mode;\n      int size, birth;\n {\n-  register int qty = next_qty++;\n+  register int qtyno = next_qty++;\n \n-  reg_qty[regno] = qty;\n+  reg_qty[regno] = qtyno;\n   reg_offset[regno] = 0;\n   reg_next_in_qty[regno] = -1;\n \n-  qty_first_reg[qty] = regno;\n-  qty_size[qty] = size;\n-  qty_mode[qty] = mode;\n-  qty_birth[qty] = birth;\n-  qty_n_calls_crossed[qty] = REG_N_CALLS_CROSSED (regno);\n-  qty_min_class[qty] = reg_preferred_class (regno);\n-  qty_alternate_class[qty] = reg_alternate_class (regno);\n-  qty_n_refs[qty] = REG_N_REFS (regno);\n-  qty_changes_size[qty] = REG_CHANGES_SIZE (regno);\n+  qty[qtyno].first_reg = regno;\n+  qty[qtyno].size = size;\n+  qty[qtyno].mode = mode;\n+  qty[qtyno].birth = birth;\n+  qty[qtyno].n_calls_crossed = REG_N_CALLS_CROSSED (regno);\n+  qty[qtyno].min_class = reg_preferred_class (regno);\n+  qty[qtyno].alternate_class = reg_alternate_class (regno);\n+  qty[qtyno].n_refs = REG_N_REFS (regno);\n+  qty[qtyno].changes_size = REG_CHANGES_SIZE (regno);\n }\n \f\n /* Main entry point of this file.  */\n@@ -326,25 +334,12 @@ local_alloc ()\n      See the declarations of these variables, above,\n      for what they mean.  */\n \n-  qty_phys_reg = (short *) xmalloc (max_qty * sizeof (short));\n+  qty = (struct qty *) xmalloc (max_qty * sizeof (struct qty));\n   qty_phys_copy_sugg\n     = (HARD_REG_SET *) xmalloc (max_qty * sizeof (HARD_REG_SET));\n   qty_phys_num_copy_sugg = (short *) xmalloc (max_qty * sizeof (short));\n   qty_phys_sugg = (HARD_REG_SET *) xmalloc (max_qty * sizeof (HARD_REG_SET));\n   qty_phys_num_sugg = (short *) xmalloc (max_qty * sizeof (short));\n-  qty_birth = (int *) xmalloc (max_qty * sizeof (int));\n-  qty_death = (int *) xmalloc (max_qty * sizeof (int));\n-  qty_first_reg = (int *) xmalloc (max_qty * sizeof (int));\n-  qty_size = (int *) xmalloc (max_qty * sizeof (int));\n-  qty_mode\n-    = (enum machine_mode *) xmalloc (max_qty * sizeof (enum machine_mode));\n-  qty_n_calls_crossed = (int *) xmalloc (max_qty * sizeof (int));\n-  qty_min_class\n-    = (enum reg_class *) xmalloc (max_qty * sizeof (enum reg_class));\n-  qty_alternate_class\n-    = (enum reg_class *) xmalloc (max_qty * sizeof (enum reg_class));\n-  qty_n_refs = (int *) xmalloc (max_qty * sizeof (int));\n-  qty_changes_size = (char *) xmalloc (max_qty * sizeof (char));\n \n   reg_qty = (int *) xmalloc (max_regno * sizeof (int));\n   reg_offset = (char *) xmalloc (max_regno * sizeof (char));\n@@ -413,21 +408,11 @@ local_alloc ()\n       block_alloc (b);\n     }\n \n-  free (qty_phys_reg);\n+  free (qty);\n   free (qty_phys_copy_sugg);\n   free (qty_phys_num_copy_sugg);\n   free (qty_phys_sugg);\n   free (qty_phys_num_sugg);\n-  free (qty_birth);\n-  free (qty_death);\n-  free (qty_first_reg);\n-  free (qty_size);\n-  free (qty_mode);\n-  free (qty_n_calls_crossed);\n-  free (qty_min_class);\n-  free (qty_alternate_class);\n-  free (qty_n_refs);\n-  free (qty_changes_size);\n \n   free (reg_qty);\n   free (reg_offset);\n@@ -1356,10 +1341,10 @@ block_alloc (b)\n     {\n       q = qty_order[i];\n       if (qty_phys_num_sugg[q] != 0 || qty_phys_num_copy_sugg[q] != 0)\n-\tqty_phys_reg[q] = find_free_reg (qty_min_class[q], qty_mode[q], q,\n-\t\t\t\t\t 0, 1, qty_birth[q], qty_death[q]);\n+\tqty[q].phys_reg = find_free_reg (qty[q].min_class, qty[q].mode, q,\n+\t\t\t\t\t 0, 1, qty[q].birth, qty[q].death);\n       else\n-\tqty_phys_reg[q] = -1;\n+\tqty[q].phys_reg = -1;\n     }\n \n   /* Order the qtys so we assign them registers in order of \n@@ -1406,7 +1391,7 @@ block_alloc (b)\n   for (i = 0; i < next_qty; i++)\n     {\n       q = qty_order[i];\n-      if (qty_phys_reg[q] < 0)\n+      if (qty[q].phys_reg < 0)\n \t{\n #ifdef INSN_SCHEDULING\n \t  /* These values represent the adjusted lifetime of a qty so\n@@ -1426,9 +1411,9 @@ block_alloc (b)\n \n \t     If allocation using the extended lifetime fails we will try\n \t     again with the qty's unadjusted lifetime.  */\n-\t  int fake_birth = MAX (0, qty_birth[q] - 2 + qty_birth[q] % 2);\n+\t  int fake_birth = MAX (0, qty[q].birth - 2 + qty[q].birth % 2);\n \t  int fake_death = MIN (insn_number * 2 + 1,\n-\t\t\t\tqty_death[q] + 2 - qty_death[q] % 2);\n+\t\t\t\tqty[q].death + 2 - qty[q].death % 2);\n #endif\n \n \t  if (N_REG_CLASSES > 1)\n@@ -1446,17 +1431,17 @@ block_alloc (b)\n \t\t  && !SMALL_REGISTER_CLASSES)\n \t\t{\n \t\t\n-\t\t  qty_phys_reg[q] = find_free_reg (qty_min_class[q], \n-\t\t\t\t\t\t   qty_mode[q], q, 0, 0,\n+\t\t  qty[q].phys_reg = find_free_reg (qty[q].min_class, \n+\t\t\t\t\t\t   qty[q].mode, q, 0, 0,\n \t\t\t\t\t\t   fake_birth, fake_death);\n-\t\t  if (qty_phys_reg[q] >= 0)\n+\t\t  if (qty[q].phys_reg >= 0)\n \t\t    continue;\n \t\t}\n #endif\n-\t      qty_phys_reg[q] = find_free_reg (qty_min_class[q], \n-\t\t\t\t\t       qty_mode[q], q, 0, 0,\n-\t\t\t\t\t       qty_birth[q], qty_death[q]);\n-\t      if (qty_phys_reg[q] >= 0)\n+\t      qty[q].phys_reg = find_free_reg (qty[q].min_class, \n+\t\t\t\t\t       qty[q].mode, q, 0, 0,\n+\t\t\t\t\t       qty[q].birth, qty[q].death);\n+\t      if (qty[q].phys_reg >= 0)\n \t\tcontinue;\n \t    }\n \n@@ -1465,26 +1450,26 @@ block_alloc (b)\n \t  if (flag_schedule_insns_after_reload\n \t      && !optimize_size\n \t      && !SMALL_REGISTER_CLASSES\n-\t      && qty_alternate_class[q] != NO_REGS)\n-\t    qty_phys_reg[q] = find_free_reg (qty_alternate_class[q],\n-\t\t\t\t\t     qty_mode[q], q, 0, 0,\n+\t      && qty[q].alternate_class != NO_REGS)\n+\t    qty[q].phys_reg = find_free_reg (qty[q].alternate_class,\n+\t\t\t\t\t     qty[q].mode, q, 0, 0,\n \t\t\t\t\t     fake_birth, fake_death);\n #endif\n-\t  if (qty_alternate_class[q] != NO_REGS)\n-\t    qty_phys_reg[q] = find_free_reg (qty_alternate_class[q],\n-\t\t\t\t\t     qty_mode[q], q, 0, 0,\n-\t\t\t\t\t     qty_birth[q], qty_death[q]);\n+\t  if (qty[q].alternate_class != NO_REGS)\n+\t    qty[q].phys_reg = find_free_reg (qty[q].alternate_class,\n+\t\t\t\t\t     qty[q].mode, q, 0, 0,\n+\t\t\t\t\t     qty[q].birth, qty[q].death);\n \t}\n     }\n \n   /* Now propagate the register assignments\n      to the pseudo regs belonging to the qtys.  */\n \n   for (q = 0; q < next_qty; q++)\n-    if (qty_phys_reg[q] >= 0)\n+    if (qty[q].phys_reg >= 0)\n       {\n-\tfor (i = qty_first_reg[q]; i >= 0; i = reg_next_in_qty[i])\n-\t  reg_renumber[i] = qty_phys_reg[q] + reg_offset[i];\n+\tfor (i = qty[q].first_reg; i >= 0; i = reg_next_in_qty[i])\n+\t  reg_renumber[i] = qty[q].phys_reg + reg_offset[i];\n       }\n \n   /* Clean up.  */\n@@ -1509,8 +1494,8 @@ block_alloc (b)\n    QTY_CMP_PRI is also used by qty_sugg_compare.  */\n \n #define QTY_CMP_PRI(q)\t\t\\\n-  ((int) (((double) (floor_log2 (qty_n_refs[q]) * qty_n_refs[q] * qty_size[q]) \\\n-\t  / (qty_death[q] - qty_birth[q])) * 10000))\n+  ((int) (((double) (floor_log2 (qty[q].n_refs) * qty[q].n_refs * qty[q].size) \\\n+\t  / (qty[q].death - qty[q].birth)) * 10000))\n \n static int\n qty_compare (q1, q2)\n@@ -1656,7 +1641,7 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       /* Do not combine with a smaller already-assigned object\n \t if that smaller object is already combined with something bigger.  */\n       || (ssize > usize && ureg >= FIRST_PSEUDO_REGISTER\n-\t  && usize < qty_size[reg_qty[ureg]])\n+\t  && usize < qty[reg_qty[ureg]].size)\n       /* Can't combine if SREG is not a register we can allocate.  */\n       || (sreg >= FIRST_PSEUDO_REGISTER && reg_qty[sreg] == -1)\n       /* Don't combine with a pseudo mentioned in a REG_NO_CONFLICT note.\n@@ -1745,30 +1730,30 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n      are compatible.  */\n \n   if ((already_dead || find_regno_note (insn, REG_DEAD, ureg))\n-      && reg_meets_class_p (sreg, qty_min_class[reg_qty[ureg]]))\n+      && reg_meets_class_p (sreg, qty[reg_qty[ureg]].min_class))\n     {\n       /* Add SREG to UREG's quantity.  */\n       sqty = reg_qty[ureg];\n       reg_qty[sreg] = sqty;\n       reg_offset[sreg] = reg_offset[ureg] + offset;\n-      reg_next_in_qty[sreg] = qty_first_reg[sqty];\n-      qty_first_reg[sqty] = sreg;\n+      reg_next_in_qty[sreg] = qty[sqty].first_reg;\n+      qty[sqty].first_reg = sreg;\n \n-      /* If SREG's reg class is smaller, set qty_min_class[SQTY].  */\n+      /* If SREG's reg class is smaller, set qty[SQTY].min_class.  */\n       update_qty_class (sqty, sreg);\n \n       /* Update info about quantity SQTY.  */\n-      qty_n_calls_crossed[sqty] += REG_N_CALLS_CROSSED (sreg);\n-      qty_n_refs[sqty] += REG_N_REFS (sreg);\n+      qty[sqty].n_calls_crossed += REG_N_CALLS_CROSSED (sreg);\n+      qty[sqty].n_refs += REG_N_REFS (sreg);\n       if (usize < ssize)\n \t{\n \t  register int i;\n \n-\t  for (i = qty_first_reg[sqty]; i >= 0; i = reg_next_in_qty[i])\n+\t  for (i = qty[sqty].first_reg; i >= 0; i = reg_next_in_qty[i])\n \t    reg_offset[i] -= offset;\n \n-\t  qty_size[sqty] = ssize;\n-\t  qty_mode[sqty] = GET_MODE (setreg);\n+\t  qty[sqty].size = ssize;\n+\t  qty[sqty].mode = GET_MODE (setreg);\n \t}\n     }\n   else\n@@ -1791,23 +1776,23 @@ reg_meets_class_p (reg, class)\n \t  || reg_class_subset_p (class, rclass));\n }\n \n-/* Update the class of QTY assuming that REG is being tied to it.  */\n+/* Update the class of QTYNO assuming that REG is being tied to it.  */\n \n static void\n-update_qty_class (qty, reg)\n-     int qty;\n+update_qty_class (qtyno, reg)\n+     int qtyno;\n      int reg;\n {\n   enum reg_class rclass = reg_preferred_class (reg);\n-  if (reg_class_subset_p (rclass, qty_min_class[qty]))\n-    qty_min_class[qty] = rclass;\n+  if (reg_class_subset_p (rclass, qty[qtyno].min_class))\n+    qty[qtyno].min_class = rclass;\n \n   rclass = reg_alternate_class (reg);\n-  if (reg_class_subset_p (rclass, qty_alternate_class[qty]))\n-    qty_alternate_class[qty] = rclass;\n+  if (reg_class_subset_p (rclass, qty[qtyno].alternate_class))\n+    qty[qtyno].alternate_class = rclass;\n \n   if (REG_CHANGES_SIZE (reg))\n-    qty_changes_size[qty] = 1;\n+    qty[qtyno].changes_size = 1;\n }\n \f\n /* Handle something which alters the value of an rtx REG.\n@@ -1870,7 +1855,7 @@ reg_is_born (reg, birth)\n \n       /* If this register has a quantity number, show that it isn't dead.  */\n       if (reg_qty[regno] >= 0)\n-\tqty_death[reg_qty[regno]] = -1;\n+\tqty[reg_qty[regno]].death = -1;\n     }\n }\n \n@@ -1931,7 +1916,7 @@ wipe_dead_reg (reg, output_p)\n     }\n \n   else if (reg_qty[regno] >= 0)\n-    qty_death[reg_qty[regno]] = 2 * this_insn_number + output_p;\n+    qty[reg_qty[regno]].death = 2 * this_insn_number + output_p;\n }\n \f\n /* Find a block of SIZE words of hard regs in reg_class CLASS\n@@ -1940,18 +1925,18 @@ wipe_dead_reg (reg, output_p)\n    and still free between insn BORN_INDEX and insn DEAD_INDEX,\n    and return the number of the first of them.\n    Return -1 if such a block cannot be found. \n-   If QTY crosses calls, insist on a register preserved by calls,\n+   If QTYNO crosses calls, insist on a register preserved by calls,\n    unless ACCEPT_CALL_CLOBBERED is nonzero.\n \n    If JUST_TRY_SUGGESTED is non-zero, only try to see if the suggested\n    register is available.  If not, return -1.  */\n \n static int\n-find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n+find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n \t       born_index, dead_index)\n      enum reg_class class;\n      enum machine_mode mode;\n-     int qty;\n+     int qtyno;\n      int accept_call_clobbered;\n      int just_try_suggested;\n      int born_index, dead_index;\n@@ -1972,12 +1957,12 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n   /* Don't let a pseudo live in a reg across a function call\n      if we might get a nonlocal goto.  */\n   if (current_function_has_nonlocal_label\n-      && qty_n_calls_crossed[qty] > 0)\n+      && qty[qtyno].n_calls_crossed > 0)\n     return -1;\n \n   if (accept_call_clobbered)\n     COPY_HARD_REG_SET (used, call_fixed_reg_set);\n-  else if (qty_n_calls_crossed[qty] == 0)\n+  else if (qty[qtyno].n_calls_crossed == 0)\n     COPY_HARD_REG_SET (used, fixed_reg_set);\n   else\n     COPY_HARD_REG_SET (used, call_used_reg_set);\n@@ -2009,7 +1994,7 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n #endif\n \n #ifdef CLASS_CANNOT_CHANGE_SIZE\n-  if (qty_changes_size[qty])\n+  if (qty[qtyno].changes_size)\n     IOR_HARD_REG_SET (used,\n \t\t      reg_class_contents[(int) CLASS_CANNOT_CHANGE_SIZE]);\n #endif\n@@ -2024,10 +2009,10 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n \n   if (just_try_suggested)\n     {\n-      if (qty_phys_num_copy_sugg[qty] != 0)\n-\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_copy_sugg[qty]);\n+      if (qty_phys_num_copy_sugg[qtyno] != 0)\n+\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_copy_sugg[qtyno]);\n       else\n-\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_sugg[qty]);\n+\tIOR_COMPL_HARD_REG_SET (first_used, qty_phys_sugg[qtyno]);\n     }\n \n   /* If all registers are excluded, we can't do anything.  */\n@@ -2044,7 +2029,7 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n #endif\n       if (! TEST_HARD_REG_BIT (first_used, regno)\n \t  && HARD_REGNO_MODE_OK (regno, mode)\n-\t  && (qty_n_calls_crossed[qty] == 0\n+\t  && (qty[qtyno].n_calls_crossed == 0\n \t      || accept_call_clobbered\n \t      || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t{\n@@ -2072,12 +2057,12 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n   \n   /* If it would be profitable to allocate a call-clobbered register\n      and save and restore it around calls, do that.  */\n-  if (just_try_suggested && qty_phys_num_copy_sugg[qty] != 0\n-      && qty_phys_num_sugg[qty] != 0)\n+  if (just_try_suggested && qty_phys_num_copy_sugg[qtyno] != 0\n+      && qty_phys_num_sugg[qtyno] != 0)\n     {\n       /* Don't try the copy-suggested regs again.  */\n-      qty_phys_num_copy_sugg[qty] = 0;\n-      return find_free_reg (class, mode, qty, accept_call_clobbered, 1,\n+      qty_phys_num_copy_sugg[qtyno] = 0;\n+      return find_free_reg (class, mode, qtyno, accept_call_clobbered, 1,\n \t\t\t    born_index, dead_index);\n     }\n \n@@ -2088,10 +2073,10 @@ find_free_reg (class, mode, qty, accept_call_clobbered, just_try_suggested,\n   if (! accept_call_clobbered\n       && flag_caller_saves\n       && ! just_try_suggested\n-      && qty_n_calls_crossed[qty] != 0\n-      && CALLER_SAVE_PROFITABLE (qty_n_refs[qty], qty_n_calls_crossed[qty]))\n+      && qty[qtyno].n_calls_crossed != 0\n+      && CALLER_SAVE_PROFITABLE (qty[qtyno].n_refs, qty[qtyno].n_calls_crossed))\n     {\n-      i = find_free_reg (class, mode, qty, 1, 0, born_index, dead_index);\n+      i = find_free_reg (class, mode, qtyno, 1, 0, born_index, dead_index);\n       if (i >= 0)\n \tcaller_save_needed = 1;\n       return i;"}]}