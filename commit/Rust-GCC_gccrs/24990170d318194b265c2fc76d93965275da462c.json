{"sha": "24990170d318194b265c2fc76d93965275da462c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ5OTAxNzBkMzE4MTk0YjI2NWMyZmM3NmQ5Mzk2NTI3NWRhNDYyYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2019-07-18T13:56:52Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-07-18T13:56:52Z"}, "message": "[arm] Fix incorrect modes with 'borrow' operations\n\nLooking through the arm backend I noticed that the modes used to pass\ncomparison types into subtract-with-carry operations were being\nincorrectly set.  The result is that the compiler is not truly\nself-consistent.  To clean this up I've introduced a new predicate,\narm_borrow_operation (borrowed from the AArch64 backend) which can\nmatch the comparison type with the required mode and then fixed all\nthe patterns to use this.  The split patterns that were generating\nincorrect modes have all obviously been fixed as well.\n\nThe basic rule for the use of a borrow is:\n- if the condition code was set by a 'subtract-like' operation (subs, cmp),\n  then use CCmode and LTU.\n- if the condition code was by unsigned overflow of addition (adds), then\n  use CC_Cmode and GEU.\n\n\t* config/arm/predicates.md (arm_borrow_operation): New predicate.\n\t* config/arm/arm.c (subdi3_compare1): Use CCmode for the split.\n\t(arm_subdi3, subdi_di_zesidi, subdi_di_sesidi): Likewise.\n\t(subdi_zesidi_zesidi): Likewise.\n\t(negdi2_compare, negdi2_insn): Likewise.\n\t(negdi_extensidi): Likewise.\n\t(negdi_zero_extendsidi): Likewise.\n\t(arm_cmpdi_insn): Likewise.\n\t(subsi3_carryin): Use arm_borrow_operation.\n\t(subsi3_carryin_const): Likewise.\n\t(subsi3_carryin_const0): Likewise.\n\t(subsi3_carryin_compare): Likewise.\n\t(subsi3_carryin_compare_const): Likewise.\n\t(subsi3_carryin_compare_const0): Likewise.\n\t(subsi3_carryin_shift): Likewise.\n\t(rsbsi3_carryin_shift): Likewise.\n\t(negsi2_carryin_compare): Likewise.\n\nFrom-SVN: r273572", "tree": {"sha": "966a7a20f63f71c465144937ba4c8ab02e72595e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/966a7a20f63f71c465144937ba4c8ab02e72595e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24990170d318194b265c2fc76d93965275da462c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24990170d318194b265c2fc76d93965275da462c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24990170d318194b265c2fc76d93965275da462c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24990170d318194b265c2fc76d93965275da462c/comments", "author": null, "committer": null, "parents": [{"sha": "b01659aa867a8fee932ef389f5066495f531da77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b01659aa867a8fee932ef389f5066495f531da77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b01659aa867a8fee932ef389f5066495f531da77"}], "stats": {"total": 140, "additions": 91, "deletions": 49}, "files": [{"sha": "a4a625e7eb039eac0947889930bc263c7e9ee386", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24990170d318194b265c2fc76d93965275da462c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24990170d318194b265c2fc76d93965275da462c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24990170d318194b265c2fc76d93965275da462c", "patch": "@@ -1,3 +1,23 @@\n+2019-07-18  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/predicates.md (arm_borrow_operation): New predicate.\n+\t* config/arm/arm.c (subdi3_compare1): Use CCmode for the split.\n+\t(arm_subdi3, subdi_di_zesidi, subdi_di_sesidi): Likewise.\n+\t(subdi_zesidi_zesidi): Likewise.\n+\t(negdi2_compare, negdi2_insn): Likewise.\n+\t(negdi_extensidi): Likewise.\n+\t(negdi_zero_extendsidi): Likewise.\n+\t(arm_cmpdi_insn): Likewise.\n+\t(subsi3_carryin): Use arm_borrow_operation.\n+\t(subsi3_carryin_const): Likewise.\n+\t(subsi3_carryin_const0): Likewise.\n+\t(subsi3_carryin_compare): Likewise.\n+\t(subsi3_carryin_compare_const): Likewise.\n+\t(subsi3_carryin_compare_const0): Likewise.\n+\t(subsi3_carryin_shift): Likewise.\n+\t(rsbsi3_carryin_shift): Likewise.\n+\t(negsi2_carryin_compare): Likewise.\n+\n 2019-07-18  Bin Cheng  <bin.linux@linux.alibaba.com>\n \n \tPR tree-optimization/91137"}, {"sha": "dcb57372192c2ee4c93a6fd6dfdb771ff66c0e81", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24990170d318194b265c2fc76d93965275da462c/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24990170d318194b265c2fc76d93965275da462c/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=24990170d318194b265c2fc76d93965275da462c", "patch": "@@ -1110,7 +1110,7 @@\n    (parallel [(set (reg:CC CC_REGNUM)\n \t\t   (compare:CC (match_dup 4) (match_dup 5)))\n \t     (set (match_dup 3) (minus:SI (minus:SI (match_dup 4) (match_dup 5))\n-\t\t\t       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))])]\n+\t\t\t       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))])]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -1141,7 +1141,7 @@\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r\")\n \t(minus:SI (minus:SI (match_operand:SI 1 \"reg_or_int_operand\" \"r,I,Pz\")\n \t\t\t    (match_operand:SI 2 \"s_register_operand\" \"r,r,r\"))\n-\t\t  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t  (match_operand:SI 3 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\"\n   \"@\n    sbc%?\\\\t%0, %1, %2\n@@ -1155,9 +1155,10 @@\n \n (define_insn \"*subsi3_carryin_const\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (minus:SI (plus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                           (match_operand:SI 2 \"arm_neg_immediate_operand\" \"L\"))\n-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t(minus:SI (plus:SI\n+\t\t   (match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t   (match_operand:SI 2 \"arm_neg_immediate_operand\" \"L\"))\n+\t\t  (match_operand:SI 3 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\"\n   \"sbc\\\\t%0, %1, #%n2\"\n   [(set_attr \"conds\" \"use\")\n@@ -1166,8 +1167,8 @@\n \n (define_insn \"*subsi3_carryin_const0\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (minus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t(minus:SI (match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t  (match_operand:SI 2 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\"\n   \"sbc\\\\t%0, %1, #0\"\n   [(set_attr \"conds\" \"use\")\n@@ -1176,12 +1177,11 @@\n \n (define_insn \"*subsi3_carryin_compare\"\n   [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                    (match_operand:SI 2 \"s_register_operand\" \"r\")))\n+\t(compare:CC (match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"s_register_operand\" \"r\")))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (minus:SI (minus:SI (match_dup 1)\n-                            (match_dup 2))\n-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t(minus:SI (minus:SI (match_dup 1) (match_dup 2))\n+\t\t  (match_operand:SI 3 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\"\n   \"sbcs\\\\t%0, %1, %2\"\n   [(set_attr \"conds\" \"set\")\n@@ -1190,12 +1190,13 @@\n \n (define_insn \"*subsi3_carryin_compare_const\"\n   [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:SI 1 \"reg_or_int_operand\" \"r\")\n-                    (match_operand:SI 2 \"const_int_I_operand\" \"I\")))\n+\t(compare:CC (match_operand:SI 1 \"reg_or_int_operand\" \"r\")\n+\t\t    (match_operand:SI 2 \"const_int_I_operand\" \"I\")))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (minus:SI (plus:SI (match_dup 1)\n-                           (match_operand:SI 3 \"arm_neg_immediate_operand\" \"L\"))\n-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t(minus:SI (plus:SI\n+\t\t   (match_dup 1)\n+\t\t   (match_operand:SI 3 \"arm_neg_immediate_operand\" \"L\"))\n+\t\t  (match_operand:SI 4 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\n    && (INTVAL (operands[2])\n        == trunc_int_for_mode (-INTVAL (operands[3]), SImode))\"\n@@ -1206,11 +1207,11 @@\n \n (define_insn \"*subsi3_carryin_compare_const0\"\n   [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_operand:SI 1 \"reg_or_int_operand\" \"r\")\n+\t(compare:CC (match_operand:SI 1 \"reg_or_int_operand\" \"r\")\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-        (minus:SI (match_dup 1)\n-                  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t(minus:SI (match_dup 1)\n+\t\t  (match_operand:SI 2 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\"\n   \"sbcs\\\\t%0, %1, #0\"\n   [(set_attr \"conds\" \"set\")\n@@ -1220,28 +1221,28 @@\n (define_insn \"*subsi3_carryin_shift\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (minus:SI\n-\t\t  (match_operand:SI 1 \"s_register_operand\" \"r\")\n-                  (match_operator:SI 2 \"shift_operator\"\n-                   [(match_operand:SI 3 \"s_register_operand\" \"r\")\n-                    (match_operand:SI 4 \"reg_or_int_operand\" \"rM\")]))\n-                 (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t   (match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t   (match_operator:SI 2 \"shift_operator\"\n+\t\t    [(match_operand:SI 3 \"s_register_operand\" \"r\")\n+\t\t     (match_operand:SI 4 \"reg_or_int_operand\" \"rM\")]))\n+\t\t  (match_operand:SI 5 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_32BIT\"\n   \"sbc%?\\\\t%0, %1, %3%S2\"\n   [(set_attr \"conds\" \"use\")\n    (set_attr \"predicable\" \"yes\")\n    (set (attr \"type\") (if_then_else (match_operand 4 \"const_int_operand\" \"\")\n-\t\t      (const_string \"alu_shift_imm\")\n-                     (const_string \"alu_shift_reg\")))]\n+\t\t\t\t    (const_string \"alu_shift_imm\")\n+\t\t\t\t    (const_string \"alu_shift_reg\")))]\n )\n \n (define_insn \"*rsbsi3_carryin_shift\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (minus:SI\n-                  (match_operator:SI 2 \"shift_operator\"\n-                   [(match_operand:SI 3 \"s_register_operand\" \"r\")\n-                    (match_operand:SI 4 \"reg_or_int_operand\" \"rM\")])\n+\t\t   (match_operator:SI 2 \"shift_operator\"\n+\t\t    [(match_operand:SI 3 \"s_register_operand\" \"r\")\n+\t\t     (match_operand:SI 4 \"reg_or_int_operand\" \"rM\")])\n \t\t   (match_operand:SI 1 \"s_register_operand\" \"r\"))\n-                 (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t  (match_operand:SI 5 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_ARM\"\n   \"rsc%?\\\\t%0, %1, %3%S2\"\n   [(set_attr \"conds\" \"use\")\n@@ -1311,7 +1312,7 @@\n \t\t   (compare:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])\n    (set (match_dup 3) (minus:SI (minus:SI (match_dup 4) (match_dup 5))\n-\t\t\t       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t\t       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -1338,7 +1339,7 @@\n \t\t   (compare:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])\n    (set (match_dup 3) (minus:SI (match_dup 4)\n-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t\t\t(ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -1365,7 +1366,7 @@\n    (set (match_dup 3) (minus:SI (minus:SI (match_dup 4)\n                                          (ashiftrt:SI (match_dup 2)\n                                                       (const_int 31)))\n-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+                                (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -1392,7 +1393,7 @@\n \t\t   (compare:CC (match_dup 2) (match_dup 1)))\n \t      (set (match_dup 0) (minus:SI (match_dup 2) (match_dup 1)))])\n    (set (match_dup 3) (minus:SI (minus:SI (const_int 0) (match_dup 4))\n-\t\t\t       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t\t       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -1422,7 +1423,7 @@\n                                 (ashiftrt:SI (match_dup 2)\n                                              (const_int 31))\n                                 (match_dup 4))\n-\t\t\t       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t\t       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -1448,7 +1449,7 @@\n \t\t   (compare:CC (match_dup 1) (match_dup 2)))\n \t      (set (match_dup 0) (minus:SI (match_dup 1) (match_dup 2)))])\n    (set (match_dup 3) (minus:SI (minus:SI (match_dup 1) (match_dup 1))\n-\t\t\t       (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t\t       (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n        operands[3] = gen_highpart (SImode, operands[0]);\n        operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -4661,7 +4662,7 @@\n \t     (set (match_dup 2)\n \t\t  (minus:SI\n \t\t   (minus:SI (const_int 0) (match_dup 3))\n-\t\t   (ltu:SI (reg:CC_C CC_REGNUM)\n+\t\t   (ltu:SI (reg:CC CC_REGNUM)\n \t\t\t   (const_int 0))))])]\n   {\n     operands[2] = gen_highpart (SImode, operands[0]);\n@@ -4703,7 +4704,7 @@\n \t\t   (compare:CC (const_int 0) (match_dup 1)))\n \t      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])\n    (set (match_dup 2) (minus:SI (minus:SI (const_int 0) (match_dup 3))\n-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+                                (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[2] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -4722,7 +4723,7 @@\n    (set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n \t(minus:SI (minus:SI (const_int 0)\n \t\t\t    (match_dup 1))\n-\t\t  (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t  (match_operand:SI 2 \"arm_borrow_operation\" \"\")))]\n   \"TARGET_ARM\"\n   \"rscs\\\\t%0, %1, #0\"\n   [(set_attr \"conds\" \"set\")\n@@ -4799,7 +4800,7 @@\n \t\tasr\tRhi, Rin, #31\n \t\trsbs\tRlo, Rin, #0\n \t\trsc\tRhi, Rhi, #0 (thumb2: sbc Rhi, Rhi, Rhi, lsl #1).  */\n-\trtx cc_reg = gen_rtx_REG (CC_Cmode, CC_REGNUM);\n+\trtx cc_reg = gen_rtx_REG (CCmode, CC_REGNUM);\n \n \temit_insn (gen_rtx_SET (high,\n \t\t\t\tgen_rtx_ASHIFTRT (SImode, operands[1],\n@@ -4861,10 +4862,10 @@\n       ;; since we just need to propagate the carry.\n   \"&& reload_completed\"\n   [(parallel [(set (reg:CC CC_REGNUM)\n-                   (compare:CC (const_int 0) (match_dup 1)))\n-              (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])\n+\t\t   (compare:CC (const_int 0) (match_dup 1)))\n+\t      (set (match_dup 0) (minus:SI (const_int 0) (match_dup 1)))])\n    (set (match_dup 2) (minus:SI (minus:SI (match_dup 2) (match_dup 2))\n-                                (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))]\n+\t\t\t\t(ltu:SI (reg:CC CC_REGNUM) (const_int 0))))]\n   {\n     operands[2] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);\n@@ -7448,12 +7449,12 @@\n   \"#\"   ; \"cmp\\\\t%Q0, %Q1\\;sbcs\\\\t%2, %R0, %R1\"\n   \"&& reload_completed\"\n   [(set (reg:CC CC_REGNUM)\n-        (compare:CC (match_dup 0) (match_dup 1)))\n+\t(compare:CC (match_dup 0) (match_dup 1)))\n    (parallel [(set (reg:CC CC_REGNUM)\n-                   (compare:CC (match_dup 3) (match_dup 4)))\n-              (set (match_dup 2)\n-                   (minus:SI (match_dup 5)\n-\t\t\t     (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))))])]\n+\t\t   (compare:CC (match_dup 3) (match_dup 4)))\n+\t      (set (match_dup 2)\n+\t\t   (minus:SI (match_dup 5)\n+\t\t\t     (ltu:SI (reg:CC CC_REGNUM) (const_int 0))))])]\n   {\n     operands[3] = gen_highpart (SImode, operands[0]);\n     operands[0] = gen_lowpart (SImode, operands[0]);"}, {"sha": "25f86471ded9682f4f63861936c8b7c9a26c6c57", "filename": "gcc/config/arm/predicates.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24990170d318194b265c2fc76d93965275da462c/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24990170d318194b265c2fc76d93965275da462c/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=24990170d318194b265c2fc76d93965275da462c", "patch": "@@ -358,6 +358,27 @@\n (define_special_predicate \"lt_ge_comparison_operator\"\n   (match_code \"lt,ge\"))\n \n+;; Match a \"borrow\" operation for use with SBC.  The precise code will\n+;; depend on the form of the comparison.  This is generally the inverse of\n+;; a carry operation, since the logic of SBC uses \"not borrow\" in it's\n+;; calculation.\n+(define_special_predicate \"arm_borrow_operation\"\n+  (match_code \"geu,ltu\")\n+  {\n+    if (XEXP (op, 1) != const0_rtx)\n+      return false;\n+    rtx op0 = XEXP (op, 0);\n+    if (!REG_P (op0) || REGNO (op0) != CC_REGNUM)\n+      return false;\n+    machine_mode ccmode = GET_MODE (op0);\n+    if (ccmode == CC_Cmode)\n+      return GET_CODE (op) == GEU;\n+    else if (ccmode == CCmode)\n+      return GET_CODE (op) == LTU;\n+    return false;\n+  }\n+)\n+\n ;; The vsel instruction only accepts the ARM condition codes listed below.\n (define_special_predicate \"arm_vsel_comparison_operator\"\n   (and (match_operand 0 \"expandable_comparison_operator\")"}]}