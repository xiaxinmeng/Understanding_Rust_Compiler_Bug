{"sha": "57fb53415ece9fc8ce86848b8ff566348d185d94", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTdmYjUzNDE1ZWNlOWZjOGNlODY4NDhiOGZmNTY2MzQ4ZDE4NWQ5NA==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2005-08-01T07:42:09Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2005-08-01T07:42:09Z"}, "message": "Makefile.in: Add ipcp.c, ipa-prop.h, ipa-prop.c.\n\n\t* Makefile.in: Add ipcp.c, ipa-prop.h, ipa-prop.c. Remove integrate.h\n\tdependency from tree-inline.o.\n\tAdd ipa-prop.h dependency to tree-inline.o and cgraphunit.o.\n        * common.opt: Add ipa-cp flag.\n        * timevar.def: Add IPCP optimization.\n        * tree-optimize.c (init_tree_optimization_passes): Schedule\n\tpass_ipa_cp.\n\t* tree-pass.h (pass_ipa_cp): Declare.\n        * cgraph.h (update_call_expr, cgraph_copy_node_for_versioning,\n        cgraph_function_versioning): New declarations.\n\t* cgraphunit.c: Add include to ipa-prop.h.\n        (update_call_expr, cgraph_copy_node_for_versioning,\n\tcgraph_function_versioning): New functions.\n        * integrate.c (copy_decl_for_inlining): Remove.\n        * tree-inline.c: Remove include to integrate.h, Add include ipa-prop.h.\n        (struct inline_data): Add versioning_p, ipa_info, new fields.\n        (remap_decl, mark_local_for_remap_r, setup_one_parameter,\n\tdeclare_return_variable): Replace calls to copy_decl_for_inlining with\n        copy_decl_for_dup.\n        (copy_body_r, copy_bb, copy_cfg_body, copy_tree_r, inlining_p): Add\n\tversioning support.\n        (copy_decl_for_dup): Rename from copy_decl_for_inlining.\n\tAdd argument VERSIONING.\n        (copy_arguments_for_versioning, copy_static_chain,\n\tfunction_versionable_p, tree_versionable_function_p,\n\ttree_function_versioning, replace_ref_tree): New functions.\n\t* tree-inline.h: Include varray.h.\n        (tree_versionable_function_p,  tree_function_versioning,\n\ttree copy_decl_for_dup): New declarations.\n\nFrom-SVN: r102625", "tree": {"sha": "85e0f4769a0ce6965e726bad05916930c2abcd04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85e0f4769a0ce6965e726bad05916930c2abcd04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/57fb53415ece9fc8ce86848b8ff566348d185d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fb53415ece9fc8ce86848b8ff566348d185d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57fb53415ece9fc8ce86848b8ff566348d185d94", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57fb53415ece9fc8ce86848b8ff566348d185d94/comments", "author": null, "committer": null, "parents": [{"sha": "518dc85936a6b0706be276e004c0d556bca3ef83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/518dc85936a6b0706be276e004c0d556bca3ef83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/518dc85936a6b0706be276e004c0d556bca3ef83"}], "stats": {"total": 288, "additions": 208, "deletions": 80}, "files": [{"sha": "1f090f441e57e679a3057829f4acdb871378e626", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -1,3 +1,58 @@\n+2005-08-01  Razya Ladelsky  <razya@il.ibm.com>\n+\n+        * cgraph.h (update_call_expr, cgraph_copy_node_for_versioning,\n+        cgraph_function_versioning): New declarations.\n+        * cgraphunit.c: Add include to ipa-prop.h.\n+        (update_call_expr, cgraph_copy_node_for_versioning,\n+        cgraph_function_versioning): New functions.\n+        * integrate.c (copy_decl_for_inlining): Remove.\n+        * ipa-prop.h (ipa_replace_map): New struct.\n+        (struct ipa_node): Add ipcp_orig_node, count_scale, new fields.\n+        * ipa-cp.c (ipcp_method_orig_node, ipcp_method_is_cloned,\n+        ipcp_method_set_orig_node, ipcp_cloned_create, ipcp_method_get_scale,\n+        ipcp_method_set_scale, ipcp_method_compute_scale, ipcp_after_propagate,\n+        ipcp_iterate_stage, ipcp_method_scale_print,\n+        ipcp_profile_mt_count_print, ipcp_profile_cs_count_print,\n+        ipcp_profile_edge_print, ipcp_profile_bb_print , ipcp_profile_print,\n+        ipcp_replace_map_create, ipcp_redirect, ipcp_update_callgraph,\n+        ipcp_update_bb_counts, ipcp_update_profiling,\n+        ipcp_update_edges_counts): New functions.\n+        (ipcp_method_cval_init): Remove restriction regarding local methods.\n+        (ipcp_init_stage): Add ipcp_method_compute_scale.\n+        (ipcp_insert_stage): Add versioning.\n+        (ipcp_structures_print): Add ipcp_method_scale_print.\n+        (ipcp_driver): Dump profiling info.\n+        * Makefile.in: Remove integrate.h dependency from tree-inline.o.\n+        Add ipa-prop.h dependency to tree-inline.o and cgraphunit.o.\n+        * tree-inline.c: Remove include to integrate.h, Add include ipa-prop.h.\n+        (struct inline_data): Add versioning_p, ipa_info, new fields.\n+        (remap_decl, mark_local_for_remap_r, setup_one_parameter,\n+        declare_return_variable): Replace calls to copy_decl_for_inlining with\n+        copy_decl_for_dup.\n+        (copy_body_r, copy_bb, copy_cfg_body, copy_tree_r, inlining_p): Add\n+        versioning support.\n+        (copy_decl_for_dup): Rename from copy_decl_for_inlining.\n+        Add argument VERSIONING.\n+        (copy_arguments_for_versioning, copy_static_chain,\n+        function_versionable_p, tree_versionable_function_p,\n+        tree_function_versioning, replace_ref_tree): New functions.\n+        * tree-inline.h: Include varray.h.\n+        (tree_versionable_function_p,  tree_function_versioning,\n+        tree copy_decl_for_dup): New declarations.\n+\n+2005-08-01  Razya Ladelsky  <razya@il.ibm.com>\n+\n+        * ipa-cp.c: New file. Contains IPCP specific functionality.\n+        * ipa-prop.h: New file. Contains structures/definitions that can be\n+        used by several interprocedural data flow optimizations (and also IPCP).\n+        * ipa-prop.c: New file.\n+        * Makefile.in: Add ipa-cp.c, ipa-prop.h, ipa-prop.c.\n+        * common.opt: Add ipa-cp flag.\n+        * timevar.def: Add IPCP optimization.\n+        * tree-optimize.c (init_tree_optimization_passes): Schedule\n+        pass_ipa_cp.\n+        * tree-pass.h (pass_ipa_cp): Declare.\n+\n 2005-08-01  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* dwarf2out.c, fold-const.c, ipa-type-escape.c,"}, {"sha": "c8023300cb3f1da13dae974cd0cb3191a1c878e7", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -975,7 +975,8 @@ OBJS-common = \\\n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n   cgraph.o cgraphunit.o tree-nomudflap.o ipa.o ipa-inline.o                \\\n-  ipa-utils.o ipa-reference.o ipa-pure-const.o ipa-type-escape.o\n+  ipa-utils.o ipa-reference.o ipa-pure-const.o ipa-type-escape.o           \\\n+  ipa-prop.o ipa-cp.o\n \n OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)\n \n@@ -1715,9 +1716,10 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    tree-iterator.h tree-pass.h $(DIAGNOSTIC_H)\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) $(FLAGS_H) $(PARAMS_H) input.h insn-config.h \\\n-   $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n+   $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n    langhooks.h tree-inline.h $(CGRAPH_H) intl.h function.h $(TREE_GIMPLE_H) \\\n-   debug.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h\n+   debug.h $(DIAGNOSTIC_H) $(TREE_FLOW_H) tree-iterator.h tree-mudflap.h \\\n+   ipa-prop.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h real.h tree-iterator.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -2151,8 +2153,15 @@ cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h tree-inline.h toplev.h $(FLAGS_H) $(GGC_H) \\\n    $(TARGET_H) $(CGRAPH_H) intl.h pointer-set.h function.h $(TREE_GIMPLE_H) \\\n    $(TREE_FLOW_H) tree-pass.h $(C_COMMON_H) debug.h $(DIAGNOSTIC_H) \\\n-   $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H)\n+   $(FIBHEAP_H) output.h $(PARAMS_H) $(RTL_H) $(TIMEVAR_H) ipa-prop.h\n ipa.o : ipa.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(CGRAPH_H) \n+ipa-prop.o : ipa-prop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n+   langhooks.h $(GGC_H) target.h $(CGRAPH_H) ipa-prop.h \\\n+   tree-flow.h $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H)\n+ipa-cp.o : ipa-cp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h  \\\n+   langhooks.h target.h $(CGRAPH_H) ipa-prop.h  \\\n+   tree-flow.h $(TM_H) tree-pass.h $(FLAGS_H) $(TREE_H) \\\n+   diagnostic.h\n ipa-inline.o : ipa-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) langhooks.h tree-inline.h $(FLAGS_H) $(CGRAPH_H) intl.h \\\n    $(DIAGNOSTIC_H) $(FIBHEAP_H) $(PARAMS_H) $(TIMEVAR_H) tree-pass.h \\\n@@ -2712,6 +2721,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h $(srcdir)/reload.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n+  $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c\\\n   $(srcdir)/dbxout.c $(srcdir)/dwarf2out.c $(srcdir)/dwarf2asm.c \\\n   $(srcdir)/dojump.c $(srcdir)/tree-profile.c \\\n   $(srcdir)/emit-rtl.c $(srcdir)/except.c $(srcdir)/explow.c $(srcdir)/expr.c \\"}, {"sha": "ccb2cdd3b644bb90d942fbfd0bceaf1e0b518a4b", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -281,6 +281,8 @@ void cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate);\n void cgraph_build_static_cdtor (char which, tree body, int priority);\n void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n+struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n+                                                varray_type, varray_type);\n \n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);"}, {"sha": "a10859dd0bc31c667e5cbe1e1c8b78a33d22dcba", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -162,6 +162,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"c-common.h\"\n #include \"intl.h\"\n #include \"function.h\"\n+#include \"ipa-prop.h\"\n #include \"tree-gimple.h\"\n #include \"tree-pass.h\"\n #include \"output.h\"\n@@ -1368,3 +1369,134 @@ init_cgraph (void)\n {\n   cgraph_dump_file = dump_begin (TDI_cgraph, NULL);\n }\n+\n+/* The edges representing the callers of the NEW_VERSION node were \n+   fixed by cgraph_function_versioning (), now the call_expr in their\n+   respective tree code should be updated to call the NEW_VERSION.  */\n+\n+static void\n+update_call_expr (struct cgraph_node *new_version)\n+{\n+  struct cgraph_edge *e;\n+\n+  gcc_assert (new_version);\n+  for (e = new_version->callers; e; e = e->next_caller)\n+    /* Update the call expr on the edges\n+       to call the new version.  */\n+    TREE_OPERAND (TREE_OPERAND (get_call_expr_in (e->call_stmt), 0), 0) = new_version->decl;\n+}\n+\n+\n+/* Create a new cgraph node which is the new version of\n+   OLD_VERSION node.  REDIRECT_CALLERS holds the callers\n+   edges which should be redirected to point to\n+   NEW_VERSION.  ALL the callees edges of OLD_VERSION\n+   are cloned to the new version node.  Return the new\n+   version node.  */\n+\n+static struct cgraph_node *\n+cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n+\t\t\t\t tree new_decl, varray_type redirect_callers)\n+ {\n+   struct cgraph_node *new_version;\n+   struct cgraph_edge *e, *new_e;\n+   struct cgraph_edge *next_callee;\n+   unsigned i;\n+\n+   gcc_assert (old_version);\n+   \n+   new_version = cgraph_node (new_decl);\n+\n+   new_version->analyzed = true;\n+   new_version->local = old_version->local;\n+   new_version->global = old_version->global;\n+   new_version->rtl = new_version->rtl;\n+   new_version->reachable = true;\n+   new_version->count = old_version->count;\n+\n+   /* Clone the old node callees.  Recursive calls are\n+      also cloned.  */\n+   for (e = old_version->callees;e; e=e->next_callee)\n+     {\n+       new_e = cgraph_clone_edge (e, new_version, e->call_stmt, 0, e->loop_nest, true);\n+       new_e->count = e->count;\n+     }\n+   /* Fix recursive calls.\n+      If OLD_VERSION has a recursive call after the\n+      previous edge cloning, the new version will have an edge\n+      pointing to the old version, which is wrong;\n+      Redirect it to point to the new version. */\n+   for (e = new_version->callees ; e; e = next_callee)\n+     {\n+       next_callee = e->next_callee;\n+       if (e->callee == old_version)\n+\t cgraph_redirect_edge_callee (e, new_version);\n+         \n+       if (!next_callee)\n+\t break;\n+     }\n+   if (redirect_callers)\n+     for (i = 0; i < VARRAY_ACTIVE_SIZE (redirect_callers); i++)\n+       {\n+         e = VARRAY_GENERIC_PTR (redirect_callers, i);\n+\t /* Redirect calls to the old version node\n+\t    to point to it's new version.  */\n+         cgraph_redirect_edge_callee (e, new_version);\n+       }\n+\n+   return new_version;\n+ }\n+\n+ /* Perform function versioning.\n+    Function versioning includes copying of the tree and \n+    a callgraph update (creating a new cgraph node and updating\n+    its callees and callers).\n+\n+    REDIRECT_CALLERS varray includes the edges to be redirected\n+    to the new version.\n+\n+    TREE_MAP is a mapping of tree nodes we want to replace with\n+    new ones (according to results of prior analysis).\n+    OLD_VERSION_NODE is the node that is versioned.\n+    It returns the new version's cgraph node.  */\n+\n+struct cgraph_node *\n+cgraph_function_versioning (struct cgraph_node *old_version_node,\n+\t\t\t    varray_type redirect_callers,\n+\t\t\t    varray_type tree_map)\n+{\n+  tree old_decl = old_version_node->decl;\n+  struct cgraph_node *new_version_node = NULL;\n+  tree new_decl;\n+\n+  if (!tree_versionable_function_p (old_decl))\n+    return NULL;\n+\n+  /* Make a new FUNCTION_DECL tree node for the\n+     new version. */\n+  new_decl = copy_node (old_decl);\n+\n+  /* Create the new version's call-graph node.\n+     and update the edges of the new node. */\n+  new_version_node =\n+    cgraph_copy_node_for_versioning (old_version_node, new_decl,\n+\t\t\t\t     redirect_callers);\n+\n+  /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n+  tree_function_versioning (old_decl, new_decl, tree_map);\n+  /* Update the call_expr on the edges to call the new version node. */\n+  update_call_expr (new_version_node);\n+\n+  /* Update the new version's properties.  \n+     Make The new version visible only within this translation unit.\n+     ??? We cannot use COMDAT linkage because there is no \n+     ABI support for this.  */\n+  DECL_EXTERNAL (new_version_node->decl) = 0;\n+  DECL_ONE_ONLY (new_version_node->decl) = 0;\n+  TREE_PUBLIC (new_version_node->decl) = 0;\n+  DECL_COMDAT (new_version_node->decl) = 0;\n+  new_version_node->local.externally_visible = 0;\n+  new_version_node->local.local = 1;\n+  new_version_node->lowered = true;\n+  return new_version_node;\n+}"}, {"sha": "a993ff915c7ea534e48939523e591f8b135bf169", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -507,6 +507,10 @@ fipa-type-escape\n Common Report Var(flag_ipa_type_escape) Init(0)\n Type based escape and alias analysis\n \n+fipa-cp\n+Common Report Var(flag_ipa_cp)\n+Perform Interprocedural constant propagation\n+\n fivopts\n Common Report Var(flag_ivopts) Init(1)\n Optimize induction variables on trees"}, {"sha": "ee9c1849855d1e97df2ef14016d8ce977fb553be", "filename": "gcc/integrate.c", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -88,82 +88,6 @@ function_attribute_inlinable_p (tree fndecl)\n \n   return true;\n }\n-\f\n-/* Copy NODE (which must be a DECL).  The DECL originally was in the FROM_FN,\n-   but now it will be in the TO_FN.  */\n-\n-tree\n-copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n-{\n-  tree copy;\n-\n-  /* Copy the declaration.  */\n-  if (TREE_CODE (decl) == PARM_DECL || TREE_CODE (decl) == RESULT_DECL)\n-    {\n-      tree type = TREE_TYPE (decl);\n-\n-      /* For a parameter or result, we must make an equivalent VAR_DECL, not a\n-\t new PARM_DECL.  */\n-      copy = build_decl (VAR_DECL, DECL_NAME (decl), type);\n-      TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (decl);\n-      TREE_READONLY (copy) = TREE_READONLY (decl);\n-      TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (decl);\n-      DECL_COMPLEX_GIMPLE_REG_P (copy) = DECL_COMPLEX_GIMPLE_REG_P (decl);\n-    }\n-  else\n-    {\n-      copy = copy_node (decl);\n-      /* The COPY is not abstract; it will be generated in TO_FN.  */\n-      DECL_ABSTRACT (copy) = 0;\n-      lang_hooks.dup_lang_specific_decl (copy);\n-\n-      /* TREE_ADDRESSABLE isn't used to indicate that a label's\n-\t address has been taken; it's for internal bookkeeping in\n-\t expand_goto_internal.  */\n-      if (TREE_CODE (copy) == LABEL_DECL)\n-\t{\n-\t  TREE_ADDRESSABLE (copy) = 0;\n-          LABEL_DECL_UID (copy) = -1;\n-\t}\n-    }\n-\n-  /* Don't generate debug information for the copy if we wouldn't have\n-     generated it for the copy either.  */\n-  DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (decl);\n-  DECL_IGNORED_P (copy) = DECL_IGNORED_P (decl);\n-\n-  /* Set the DECL_ABSTRACT_ORIGIN so the debugging routines know what\n-     declaration inspired this copy.  */\n-  DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (decl);\n-\n-  /* The new variable/label has no RTL, yet.  */\n-  if (CODE_CONTAINS_STRUCT (TREE_CODE (copy), TS_DECL_WRTL) \n-      && !TREE_STATIC (copy) && !DECL_EXTERNAL (copy))\n-    SET_DECL_RTL (copy, NULL_RTX);\n-\n-  /* These args would always appear unused, if not for this.  */\n-  TREE_USED (copy) = 1;\n-\n-  /* Set the context for the new declaration.  */\n-  if (!DECL_CONTEXT (decl))\n-    /* Globals stay global.  */\n-    ;\n-  else if (DECL_CONTEXT (decl) != from_fn)\n-    /* Things that weren't in the scope of the function we're inlining\n-       from aren't in the scope we're inlining to, either.  */\n-    ;\n-  else if (TREE_STATIC (decl))\n-    /* Function-scoped static variables should stay in the original\n-       function.  */\n-    ;\n-  else\n-    /* Ordinary automatic local variables are now in the scope of the\n-       new function.  */\n-    DECL_CONTEXT (copy) = to_fn;\n-\n-  return copy;\n-}\n-\n \f\n /* Given a pointer to some BLOCK node, if the BLOCK_ABSTRACT_ORIGIN for the\n    given BLOCK node is NULL, set the BLOCK_ABSTRACT_ORIGIN for the node so"}, {"sha": "76f5da3988bf3c3a510f4ef1ffc478378ab2fa74", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/57fb53415ece9fc8ce86848b8ff566348d185d94/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=57fb53415ece9fc8ce86848b8ff566348d185d94", "patch": "@@ -433,6 +433,7 @@ init_optimization_passes (void)\n   p = &all_ipa_passes;\n   NEXT_PASS (pass_early_ipa_inline);\n   NEXT_PASS (pass_early_local_passes);\n+  NEXT_PASS (pass_ipa_cp);\n   NEXT_PASS (pass_ipa_inline);\n   NEXT_PASS (pass_ipa_reference);\n   NEXT_PASS (pass_ipa_pure_const); "}]}