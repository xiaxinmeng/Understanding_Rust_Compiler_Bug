{"sha": "cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q4ZWQ2Mjk2NDJiZWJhYTE5YTJmZTU0NGYwYzNlZmNhZmU4MzVmMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-19T05:22:04Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-19T05:22:04Z"}, "message": "cp-tree.h (CLEAR_DECL_C_BIT_FIELD): New macro.\n\n\t* cp-tree.h (CLEAR_DECL_C_BIT_FIELD): New macro.\n\t* class.c (check_bitfield_decl): Turn illegal bitfields into\n\tnon-bitfields.\n\t(dfs_propagate_binfo_offsets): Adjust for new size_binop\n\tsemantics.\n\t(dfs_offset_for_unshared_vbases): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Convert NULL to a\n\tpointer-to-member correctly under the new ABI.\n\t* expr.c (cplus_expand_constant): Don't use cp_convert when\n\tturning an offset into a pointer-to-member.\n\t* init.c (resolve_offset_ref): Don't adjust pointers-to-members\n\twhen dereferencing them under the new ABI.\n\t* typeck.c (get_member_function_from_ptrfunc): Tweak calculation\n\tof pointers-to-members under the new ABI.\n\nFrom-SVN: r32631", "tree": {"sha": "27221340a82ba130909a03491572338e80e9b132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27221340a82ba130909a03491572338e80e9b132"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/comments", "author": null, "committer": null, "parents": [{"sha": "3ca3ce41d7a697163986c9b73b8ee4cb389d65e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca3ce41d7a697163986c9b73b8ee4cb389d65e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca3ce41d7a697163986c9b73b8ee4cb389d65e9"}], "stats": {"total": 209, "additions": 161, "deletions": 48}, "files": [{"sha": "fbaaad904ca2754ea2bb4cf7e84854bd6b291f0f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -1,5 +1,20 @@\n 2000-03-18  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (CLEAR_DECL_C_BIT_FIELD): New macro.\n+\t* class.c (check_bitfield_decl): Turn illegal bitfields into\n+\tnon-bitfields.\n+\t(dfs_propagate_binfo_offsets): Adjust for new size_binop\n+\tsemantics.\n+\t(dfs_offset_for_unshared_vbases): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Convert NULL to a\n+\tpointer-to-member correctly under the new ABI.\n+\t* expr.c (cplus_expand_constant): Don't use cp_convert when\n+\tturning an offset into a pointer-to-member.\n+\t* init.c (resolve_offset_ref): Don't adjust pointers-to-members\n+\twhen dereferencing them under the new ABI.\n+\t* typeck.c (get_member_function_from_ptrfunc): Tweak calculation\n+\tof pointers-to-members under the new ABI.\n+\t\n \t* class.c (check_bitfield_decl): Remove restriction on really long\n \tbitfields.\n \t(layout_class_type): Implement new ABI handling of bitfields"}, {"sha": "02424928d0d1b6af82f9a9139dd2f351d73c4ca5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -3616,22 +3616,20 @@ check_bitfield_decl (field)\n      tree field;\n {\n   tree type = TREE_TYPE (field);\n+  tree w = NULL_TREE;\n \n-  /* Invalid bit-field size done by grokfield.  */\n-  /* Detect invalid bit-field type. Simply checking if TYPE is\n-     integral is insufficient, as that is the array core of the field\n-     type. If TREE_TYPE (field) is integral, then TYPE must be the same.  */\n+  /* Detect invalid bit-field type.  */\n   if (DECL_INITIAL (field)\n       && ! INTEGRAL_TYPE_P (TREE_TYPE (field)))\n     {\n       cp_error_at (\"bit-field `%#D' with non-integral type\", field);\n-      DECL_INITIAL (field) = NULL;\n+      w = error_mark_node;\n     }\n \n   /* Detect and ignore out of range field width.  */\n   if (DECL_INITIAL (field))\n     {\n-      tree w = DECL_INITIAL (field);\n+      w = DECL_INITIAL (field);\n \n       /* Avoid the non_lvalue wrapper added by fold for PLUS_EXPRs.  */\n       STRIP_NOPS (w);\n@@ -3646,17 +3644,17 @@ check_bitfield_decl (field)\n \t{\n \t  cp_error_at (\"bit-field `%D' width not an integer constant\",\n \t\t       field);\n-\t  DECL_INITIAL (field) = NULL_TREE;\n+\t  w = error_mark_node;\n \t}\n       else if (tree_int_cst_sgn (w) < 0)\n \t{\n-\t  DECL_INITIAL (field) = NULL;\n \t  cp_error_at (\"negative width in bit-field `%D'\", field);\n+\t  w = error_mark_node;\n \t}\n       else if (integer_zerop (w) && DECL_NAME (field) != 0)\n \t{\n-\t  DECL_INITIAL (field) = NULL;\n \t  cp_error_at (\"zero width for bit-field `%D'\", field);\n+\t  w = error_mark_node;\n \t}\n       else if (compare_tree_int (w, TYPE_PRECISION (type)) > 0\n \t       && TREE_CODE (type) != ENUMERAL_TYPE\n@@ -3672,30 +3670,37 @@ check_bitfield_decl (field)\n \t\t\t\t\t      TREE_UNSIGNED (type)))))\n \tcp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n \t\t       field, type);\n+    }\n+  \n+  /* Remove the bit-field width indicator so that the rest of the\n+     compiler does not treat that value as an initializer.  */\n+  DECL_INITIAL (field) = NULL_TREE;\n \n-      if (DECL_INITIAL (field))\n-\t{\n-\t  DECL_INITIAL (field) = NULL_TREE;\n-\t  DECL_SIZE (field) = convert (bitsizetype, w);\n-\t  DECL_BIT_FIELD (field) = 1;\n+  if (w != error_mark_node)\n+    {\n+      DECL_SIZE (field) = convert (bitsizetype, w);\n+      DECL_BIT_FIELD (field) = 1;\n \n-\t  if (integer_zerop (w))\n-\t    {\n+      if (integer_zerop (w))\n+\t{\n #ifdef EMPTY_FIELD_BOUNDARY\n-\t      DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n-\t\t\t\t\tEMPTY_FIELD_BOUNDARY);\n+\t  DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n+\t\t\t\t    EMPTY_FIELD_BOUNDARY);\n #endif\n #ifdef PCC_BITFIELD_TYPE_MATTERS\n-\t      if (PCC_BITFIELD_TYPE_MATTERS)\n-\t\tDECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n-\t\t\t\t\t  TYPE_ALIGN (type));\n+\t  if (PCC_BITFIELD_TYPE_MATTERS)\n+\t    DECL_ALIGN (field) = MAX (DECL_ALIGN (field), \n+\t\t\t\t      TYPE_ALIGN (type));\n #endif\n-\t    }\n \t}\n     }\n   else\n-    /* Non-bit-fields are aligned for their type.  */\n-    DECL_ALIGN (field) = MAX (DECL_ALIGN (field), TYPE_ALIGN (type));\n+    {\n+      /* Non-bit-fields are aligned for their type.  */\n+      DECL_BIT_FIELD (field) = 0;\n+      CLEAR_DECL_C_BIT_FIELD (field);\n+      DECL_ALIGN (field) = MAX (DECL_ALIGN (field), TYPE_ALIGN (type));\n+    }\n }\n \n /* FIELD is a non bit-field.  We are finishing the processing for its\n@@ -4678,7 +4683,10 @@ dfs_propagate_binfo_offsets (binfo, data)\n   tree offset = (tree) data;\n \n   /* Update the BINFO_OFFSET for this base.  */\n-  BINFO_OFFSET (binfo) = size_binop (PLUS_EXPR, BINFO_OFFSET (binfo), offset);\n+  BINFO_OFFSET (binfo) = fold (build (PLUS_EXPR,\n+\t\t\t\t      sizetype,\n+\t\t\t\t      BINFO_OFFSET (binfo), \n+\t\t\t\t      offset));\n \n   SET_BINFO_MARKED (binfo);\n \n@@ -4744,8 +4752,7 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n       tree offset;\n       \n       vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), t);\n-      offset = size_binop (MINUS_EXPR, \n-\t\t\t   BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n+      offset = size_diffop (BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n       propagate_binfo_offsets (binfo, offset);\n     }\n "}, {"sha": "3e6f1c98066fd00fcb5591f75bb782efeb266e87", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -2347,6 +2347,8 @@ extern int flag_new_for_scope;\n    && DECL_LANG_SPECIFIC (NODE)->decl_flags.bitfield)\n #define SET_DECL_C_BIT_FIELD(NODE) \\\n   (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->decl_flags.bitfield = 1)\n+#define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n+  (DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE))->decl_flags.bitfield = 0)\n \n /* In a FUNCTION_DECL, nonzero if the function cannot be inlined.  */\n #define DECL_UNINLINABLE(NODE) \\"}, {"sha": "d3c24093b63d38ea4bbd3d8a494bc745556ca2bf", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -240,7 +240,13 @@ cp_convert_to_pointer (type, expr)\n     {\n       if (TYPE_PTRMEMFUNC_P (type))\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n-      expr = build_int_2 (0, 0);\n+\n+      if (flag_new_abi && TYPE_PTRMEM_P (type))\n+\t/* Under the new ABI, a NULL pointer-to-member is represented\n+\t   by -1, not by zero.  */\n+\texpr = build_int_2 (-1, -1);\n+      else\n+\texpr = build_int_2 (0, 0);\n       TREE_TYPE (expr) = type;\n       return expr;\n     }"}, {"sha": "230fa6a154b068d72e1637baaa8ef40537b9ab4b", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -65,11 +65,18 @@ cplus_expand_constant (cst)\n \t\t\t\t\t  bit_position (member),\n \t\t\t\t\t  bitsize_int (BITS_PER_UNIT)));\n \n-\t    /* We offset all pointer to data members by 1 so that we\n-\t       can distinguish between a null pointer to data member\n-\t       and the first data member of a structure.  */\n-\t    offset = size_binop (PLUS_EXPR, offset, size_one_node);\n-\t    cst = cp_convert (type, offset);\n+\t    if (flag_new_abi)\n+\t      /* Under the new ABI, we use -1 to represent the NULL\n+\t\t pointer; non-NULL values simply contain the offset of\n+\t\t the data member.  */\n+\t      ;\n+\t    else\n+\t      /* We offset all pointer to data members by 1 so that we\n+\t\t can distinguish between a null pointer to data member\n+\t\t and the first data member of a structure.  */\n+\t      offset = size_binop (PLUS_EXPR, offset, size_one_node);\n+\n+\t    cst = fold (build1 (NOP_EXPR, type, offset));\n \t  }\n \telse\n \t  {"}, {"sha": "8994f604239271e26d6864c567cd37caf226293f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -1821,11 +1821,13 @@ resolve_offset_ref (exp)\n       addr = convert_pointer_to (basetype, addr);\n       member = cp_convert (ptrdiff_type_node, member);\n \n-      /* Pointer to data members are offset by one, so that a null\n-\t pointer with a real value of 0 is distinguishable from an\n-\t offset of the first member of a structure.  */\n-      member = build_binary_op (MINUS_EXPR, member,\n-\t\t\t\tcp_convert (ptrdiff_type_node, integer_one_node));\n+      if (!flag_new_abi)\n+\t/* Pointer to data members are offset by one, so that a null\n+\t   pointer with a real value of 0 is distinguishable from an\n+\t   offset of the first member of a structure.  */\n+\tmember = build_binary_op (MINUS_EXPR, member,\n+\t\t\t\t  cp_convert (ptrdiff_type_node, \n+\t\t\t\t\t      integer_one_node));\n \n       return build1 (INDIRECT_REF, type,\n \t\t     build (PLUS_EXPR, build_pointer_type (type),"}, {"sha": "43bd1bc4952048f602835043ba25b8838b7178d3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -2858,7 +2858,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t{\n \t  idx = build_binary_op (TRUNC_DIV_EXPR, \n \t\t\t\t build1 (NOP_EXPR, vtable_index_type, e3),\n-\t\t\t\t integer_two_node);\n+\t\t\t\t TYPE_SIZE_UNIT (vtable_entry_type));\n \t  e1 = build_binary_op (BIT_AND_EXPR,\n \t\t\t\tbuild1 (NOP_EXPR, vtable_index_type, e3),\n \t\t\t\tinteger_one_node);\n@@ -6332,11 +6332,12 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n \t}\n       else\n \t{\n-\t  /* Under the new ABI, we set PFN to twice the index, plus\n-\t     one.  */\n+\t  /* Under the new ABI, we set PFN to the vtable offset, plus\n+\t     one, at which the function can be found.  */\n \t  *idx = NULL_TREE;\n \t  *pfn = fold (build (MULT_EXPR, integer_type_node,\n-\t\t\t      DECL_VINDEX (fn), integer_two_node));\n+\t\t\t      DECL_VINDEX (fn), \n+\t\t\t      TYPE_SIZE_UNIT (vtable_entry_type)));\n \t  *pfn = fold (build (PLUS_EXPR, integer_type_node, *pfn,\n \t\t\t      integer_one_node));\n \t  *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),"}, {"sha": "b7a791f0a94fc781d3d8ef80cb5b91077a4c5cdd", "filename": "gcc/testsuite/g++.old-deja/g++.abi/empty.C", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fempty.C?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -0,0 +1,68 @@\n+// Special g++ Options: -w\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+#if defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100\n+\n+struct S0\n+{\n+};\n+\n+struct S1 : public S0\n+{\n+};\n+\n+struct S2 : public S1\n+{\n+  char c;\n+};\n+\n+// In S3, the S1 instance is allocated first at offset zero.  The S2\n+// instance has to be allocated at a subsequent offset; it's first\n+// part is also an S1.\n+\n+struct S3 : public S1, public S2\n+{\n+};\n+\n+struct S4 \n+{\n+  int i;\n+};\n+\n+// In S4, in contrast to S3, S2 is allocated first, and S1 can be\n+// allocated on top of S4.\n+\n+struct S5 : public S2, public S1, public S4\n+{\n+};\n+\n+// The T classes are by-hand layouts that should be equivalent to the\n+// S classes.\n+\n+struct T3\n+{\n+  S1 s1;\n+  S2 s2;\n+};\n+\n+struct T5\n+{\n+  S2 s2;\n+  S4 s4;\n+};\n+\n+int main ()\n+{\n+  if (sizeof (S3) != sizeof (T3))\n+    return 1;\n+  else if (sizeof (S5) != sizeof (T5))\n+    return 2;\n+}\n+\n+#else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */\n+\n+int main () \n+{\n+}\n+\n+#endif /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}, {"sha": "975d9397ded8540ce0946b15308559b970971768", "filename": "gcc/testsuite/g++.old-deja/g++.abi/ptrmem.C", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ed629642bebaa19a2fe544f0c3efcafe835f2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.abi%2Fptrmem.C?ref=cd8ed629642bebaa19a2fe544f0c3efcafe835f2", "patch": "@@ -82,16 +82,16 @@ main ()\n   if (xp->adj != delta)\n     return 8;\n \n-  // For a virtual function, we should see twice the vtable index,\n-  // plus one.  `T::h' is in the third slot: there's the RTTI entry,\n-  // then the two virtual functions.\n+  // For a virtual function, we should see the vtable offset, plus\n+  // one.  `T::h' is in the second slot: the vtable pointer points to\n+  // the first virtual function.\n   y = &T::h;\n-  if ((ptrdiff_t) yp->ptr != 7)\n+  if ((ptrdiff_t) yp->ptr != sizeof (void *) + 1)\n     return 9;\n   if (yp->adj != 0)\n     return 10;\n   x = (sp) y;\n-  if ((ptrdiff_t) xp->ptr != 7)\n+  if ((ptrdiff_t) xp->ptr != sizeof (void *) + 1)\n     return 11;\n   if (xp->adj != delta)\n     return 12;\n@@ -103,9 +103,14 @@ main ()\n   if (__alignof__ (sdp) != __alignof__ (ptrdiff_t))\n     return 14;\n \n+  // The value of a pointer-to-data member should be the offset from\n+  // the start of the structure.\n   sdp z = &S::j;\n-  if ((char *) &s.j - (char *) &s != *((ptrdiff_t *) &z) - 1)\n+  if ((char *) &s.j - (char *) &s != *((ptrdiff_t *) &z))\n     return 15;\n+  z = 0;\n+  if (*((ptrdiff_t *) &z) != -1)\n+    return 16;\n }\n \n #else /* !(defined (__GXX_ABI_VERSION) && __GXX_ABI_VERSION >= 100) */"}]}