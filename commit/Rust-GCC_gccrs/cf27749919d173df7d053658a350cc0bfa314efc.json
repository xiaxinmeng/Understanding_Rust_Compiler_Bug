{"sha": "cf27749919d173df7d053658a350cc0bfa314efc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2YyNzc0OTkxOWQxNzNkZjdkMDUzNjU4YTM1MGNjMGJmYTMxNGVmYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-10-13T08:44:08Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2003-10-13T08:44:08Z"}, "message": "sh.c, [...]: Convert to ISO C90 function declarations and definitions.\n\n\t* config/sh/sh.c, config/sh/sh-protos.h: Convert to\n\tISO C90 function declarations and definitions.\n\nFrom-SVN: r72424", "tree": {"sha": "f391db0fbd83861cefe7ab08874c76766486e938", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f391db0fbd83861cefe7ab08874c76766486e938"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cf27749919d173df7d053658a350cc0bfa314efc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf27749919d173df7d053658a350cc0bfa314efc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf27749919d173df7d053658a350cc0bfa314efc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf27749919d173df7d053658a350cc0bfa314efc/comments", "author": null, "committer": null, "parents": [{"sha": "269e379528abdb4f20494e7830a9912d7d5bc2e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/269e379528abdb4f20494e7830a9912d7d5bc2e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/269e379528abdb4f20494e7830a9912d7d5bc2e5"}], "stats": {"total": 962, "additions": 354, "deletions": 608}, "files": [{"sha": "26bfffb40736343d6b2f903df5239ac96693013c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf27749919d173df7d053658a350cc0bfa314efc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf27749919d173df7d053658a350cc0bfa314efc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cf27749919d173df7d053658a350cc0bfa314efc", "patch": "@@ -2,6 +2,7 @@\n \n \t* config/avr/avr.c, config/avr/avr-protos.h: Convert to\n \tISO C90 function declarations and definitions.\n+\t* config/sh/sh.c, config/sh/sh-protos.h: Likewise.\n \n 2003-10-12  Nathanael Nerode  <neroden@gcc.gnu.org>\n "}, {"sha": "81501b07d4b2c039bc031f48a8508adc989aa97e", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf27749919d173df7d053658a350cc0bfa314efc/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf27749919d173df7d053658a350cc0bfa314efc/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=cf27749919d173df7d053658a350cc0bfa314efc", "patch": "@@ -25,117 +25,117 @@ Boston, MA 02111-1307, USA.  */\n #define GCC_SH_PROTOS_H\n \n #ifdef RTX_CODE\n-extern struct rtx_def *prepare_scc_operands PARAMS ((enum rtx_code));\n+extern struct rtx_def *prepare_scc_operands (enum rtx_code);\n \n /* Declare functions defined in sh.c and used in templates.  */\n \n-extern const char *output_branch PARAMS ((int, rtx, rtx *));\n-extern const char *output_ieee_ccmpeq PARAMS ((rtx, rtx *));\n-extern const char *output_branchy_insn PARAMS ((enum rtx_code, const char *, rtx, rtx *));\n-extern const char *output_movedouble PARAMS ((rtx, rtx[], enum machine_mode));\n-extern const char *output_movepcrel PARAMS ((rtx, rtx[], enum machine_mode));\n-extern const char *output_far_jump PARAMS ((rtx, rtx));\n+extern const char *output_branch (int, rtx, rtx *);\n+extern const char *output_ieee_ccmpeq (rtx, rtx *);\n+extern const char *output_branchy_insn (enum rtx_code, const char *, rtx, rtx *);\n+extern const char *output_movedouble (rtx, rtx[], enum machine_mode);\n+extern const char *output_movepcrel (rtx, rtx[], enum machine_mode);\n+extern const char *output_far_jump (rtx, rtx);\n \n-extern struct rtx_def *sfunc_uses_reg PARAMS ((rtx));\n-extern int barrier_align PARAMS ((rtx));\n-extern int sh_loop_align PARAMS ((rtx));\n-extern int fp_zero_operand PARAMS ((rtx));\n-extern int fp_one_operand PARAMS ((rtx));\n-extern int fp_int_operand PARAMS ((rtx));\n-extern rtx get_fpscr_rtx PARAMS ((void));\n-extern rtx legitimize_pic_address PARAMS ((rtx, enum machine_mode, rtx));\n-extern int nonpic_symbol_mentioned_p PARAMS ((rtx));\n-extern void emit_sf_insn PARAMS ((rtx));\n-extern void emit_df_insn PARAMS ((rtx));\n-extern void print_operand_address PARAMS ((FILE *, rtx));\n-extern void print_operand PARAMS ((FILE *, rtx, int));\n-extern void output_pic_addr_const PARAMS ((FILE *, rtx));\n-extern int expand_block_move PARAMS ((rtx *));\n-extern int prepare_move_operands PARAMS ((rtx[], enum machine_mode mode));\n-extern void from_compare PARAMS ((rtx *, int));\n-extern int shift_insns_rtx PARAMS ((rtx));\n-extern void gen_ashift PARAMS ((int, int, rtx));\n-extern void gen_ashift_hi PARAMS ((int, int, rtx));\n-extern void gen_shifty_op PARAMS ((int, rtx *));\n-extern void gen_shifty_hi_op PARAMS ((int, rtx *));\n-extern int expand_ashiftrt PARAMS ((rtx *));\n-extern int sh_dynamicalize_shift_p PARAMS ((rtx));\n-extern int shl_and_kind PARAMS ((rtx, rtx, int *));\n-extern int shl_and_length PARAMS ((rtx));\n-extern int shl_and_scr_length PARAMS ((rtx));\n-extern int gen_shl_and PARAMS ((rtx, rtx, rtx, rtx));\n-extern int shl_sext_kind PARAMS ((rtx, rtx, int *));\n-extern int shl_sext_length PARAMS ((rtx));\n-extern int gen_shl_sext PARAMS ((rtx, rtx, rtx, rtx));\n-extern rtx gen_datalabel_ref PARAMS ((rtx));\n-extern int regs_used PARAMS ((rtx, int));\n-extern void fixup_addr_diff_vecs PARAMS ((rtx));\n-extern int get_dest_uid PARAMS ((rtx, int));\n-extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n-extern int symbol_ref_operand PARAMS ((rtx, enum machine_mode));\n-extern int tls_symbolic_operand PARAMS ((rtx, enum machine_mode));\n-extern int system_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int general_movsrc_operand PARAMS ((rtx, enum machine_mode));\n-extern int general_movdst_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int fp_arith_reg_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_operand PARAMS ((rtx, enum machine_mode));\n-extern int arith_reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n-extern int logical_operand PARAMS ((rtx, enum machine_mode));\n-extern int tertiary_reload_operand PARAMS ((rtx, enum machine_mode));\n-extern int fpscr_operand PARAMS ((rtx, enum machine_mode));\n-extern int fpul_operand PARAMS ((rtx, enum machine_mode));\n-extern int commutative_float_operator PARAMS ((rtx, enum machine_mode));\n-extern int noncommutative_float_operator PARAMS ((rtx, enum machine_mode));\n-extern int reg_unused_after PARAMS ((rtx, rtx));\n-extern void expand_sf_unop PARAMS ((rtx (*)(rtx, rtx, rtx), rtx *));\n-extern void expand_sf_binop PARAMS ((rtx (*)(rtx, rtx, rtx, rtx), rtx *));\n-extern void expand_df_unop PARAMS ((rtx (*)(rtx, rtx, rtx), rtx *));\n-extern void expand_df_binop PARAMS ((rtx (*)(rtx, rtx, rtx, rtx), rtx *));\n-extern void expand_fp_branch PARAMS ((rtx (*)(void), rtx (*)(void)));\n-extern int sh_insn_length_adjustment PARAMS ((rtx));\n-extern int sh_can_redirect_branch PARAMS ((rtx, rtx));\n-extern void sh_expand_unop_v2sf PARAMS ((enum rtx_code, rtx, rtx));\n-extern void sh_expand_binop_v2sf PARAMS ((enum rtx_code, rtx, rtx, rtx));\n+extern struct rtx_def *sfunc_uses_reg (rtx);\n+extern int barrier_align (rtx);\n+extern int sh_loop_align (rtx);\n+extern int fp_zero_operand (rtx);\n+extern int fp_one_operand (rtx);\n+extern int fp_int_operand (rtx);\n+extern rtx get_fpscr_rtx (void);\n+extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern int nonpic_symbol_mentioned_p (rtx);\n+extern void emit_sf_insn (rtx);\n+extern void emit_df_insn (rtx);\n+extern void print_operand_address (FILE *, rtx);\n+extern void print_operand (FILE *, rtx, int);\n+extern void output_pic_addr_const (FILE *, rtx);\n+extern int expand_block_move (rtx *);\n+extern int prepare_move_operands (rtx[], enum machine_mode mode);\n+extern void from_compare (rtx *, int);\n+extern int shift_insns_rtx (rtx);\n+extern void gen_ashift (int, int, rtx);\n+extern void gen_ashift_hi (int, int, rtx);\n+extern void gen_shifty_op (int, rtx *);\n+extern void gen_shifty_hi_op (int, rtx *);\n+extern int expand_ashiftrt (rtx *);\n+extern int sh_dynamicalize_shift_p (rtx);\n+extern int shl_and_kind (rtx, rtx, int *);\n+extern int shl_and_length (rtx);\n+extern int shl_and_scr_length (rtx);\n+extern int gen_shl_and (rtx, rtx, rtx, rtx);\n+extern int shl_sext_kind (rtx, rtx, int *);\n+extern int shl_sext_length (rtx);\n+extern int gen_shl_sext (rtx, rtx, rtx, rtx);\n+extern rtx gen_datalabel_ref (rtx);\n+extern int regs_used (rtx, int);\n+extern void fixup_addr_diff_vecs (rtx);\n+extern int get_dest_uid (rtx, int);\n+extern void final_prescan_insn (rtx, rtx *, int);\n+extern int symbol_ref_operand (rtx, enum machine_mode);\n+extern int tls_symbolic_operand (rtx, enum machine_mode);\n+extern int system_reg_operand (rtx, enum machine_mode);\n+extern int general_movsrc_operand (rtx, enum machine_mode);\n+extern int general_movdst_operand (rtx, enum machine_mode);\n+extern int arith_reg_operand (rtx, enum machine_mode);\n+extern int fp_arith_reg_operand (rtx, enum machine_mode);\n+extern int arith_operand (rtx, enum machine_mode);\n+extern int arith_reg_or_0_operand (rtx, enum machine_mode);\n+extern int logical_operand (rtx, enum machine_mode);\n+extern int tertiary_reload_operand (rtx, enum machine_mode);\n+extern int fpscr_operand (rtx, enum machine_mode);\n+extern int fpul_operand (rtx, enum machine_mode);\n+extern int commutative_float_operator (rtx, enum machine_mode);\n+extern int noncommutative_float_operator (rtx, enum machine_mode);\n+extern int reg_unused_after (rtx, rtx);\n+extern void expand_sf_unop (rtx (*)(rtx, rtx, rtx), rtx *);\n+extern void expand_sf_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);\n+extern void expand_df_unop (rtx (*)(rtx, rtx, rtx), rtx *);\n+extern void expand_df_binop (rtx (*)(rtx, rtx, rtx, rtx), rtx *);\n+extern void expand_fp_branch (rtx (*)(void), rtx (*)(void));\n+extern int sh_insn_length_adjustment (rtx);\n+extern int sh_can_redirect_branch (rtx, rtx);\n+extern void sh_expand_unop_v2sf (enum rtx_code, rtx, rtx);\n+extern void sh_expand_binop_v2sf (enum rtx_code, rtx, rtx, rtx);\n #ifdef TREE_CODE\n-extern void sh_va_start PARAMS ((tree, rtx));\n-extern rtx sh_va_arg PARAMS ((tree, tree));\n+extern void sh_va_start (tree, rtx);\n+extern rtx sh_va_arg (tree, tree);\n #endif /* TREE_CODE */\n #endif /* RTX_CODE */\n \n #ifdef TREE_CODE\n-extern tree sh_build_va_list PARAMS ((void));\n+extern tree sh_build_va_list (void);\n #endif /* TREE_CODE */\n \n-extern const char *output_jump_label_table PARAMS ((void));\n-extern int sh_handle_pragma PARAMS ((int (*)(void), void (*)(int), const char *));\n-extern struct rtx_def *get_fpscr_rtx PARAMS ((void));\n-extern int sh_media_register_for_return PARAMS ((void));\n-extern void sh_expand_prologue PARAMS ((void));\n-extern void sh_expand_epilogue PARAMS ((void));\n-extern int sh_need_epilogue PARAMS ((void));\n-extern void sh_set_return_address PARAMS ((rtx, rtx));\n-extern int initial_elimination_offset PARAMS ((int, int));\n-extern int fldi_ok PARAMS ((void));\n-extern int sh_pr_n_sets PARAMS ((void));\n-extern int sh_hard_regno_rename_ok PARAMS ((unsigned int, unsigned int));\n-extern int sh_cfun_interrupt_handler_p PARAMS ((void));\n-extern int sh_attr_renesas_p PARAMS ((tree));\n-extern int sh_cfun_attr_renesas_p PARAMS ((void));\n-extern void sh_initialize_trampoline PARAMS ((rtx, rtx, rtx));\n+extern const char *output_jump_label_table (void);\n+extern int sh_handle_pragma (int (*)(void), void (*)(int), const char *);\n+extern struct rtx_def *get_fpscr_rtx (void);\n+extern int sh_media_register_for_return (void);\n+extern void sh_expand_prologue (void);\n+extern void sh_expand_epilogue (void);\n+extern int sh_need_epilogue (void);\n+extern void sh_set_return_address (rtx, rtx);\n+extern int initial_elimination_offset (int, int);\n+extern int fldi_ok (void);\n+extern int sh_pr_n_sets (void);\n+extern int sh_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern int sh_cfun_interrupt_handler_p (void);\n+extern int sh_attr_renesas_p (tree);\n+extern int sh_cfun_attr_renesas_p (void);\n+extern void sh_initialize_trampoline (rtx, rtx, rtx);\n extern bool sh_cannot_change_mode_class\n-\t      PARAMS ((enum machine_mode, enum machine_mode, enum reg_class));\n-extern void sh_mark_label PARAMS ((rtx, int));\n+\t      (enum machine_mode, enum machine_mode, enum reg_class);\n+extern void sh_mark_label (rtx, int);\n extern int sh_register_move_cost\n-  PARAMS ((enum machine_mode mode, enum reg_class, enum reg_class));\n+  (enum machine_mode mode, enum reg_class, enum reg_class);\n \n #ifdef HARD_CONST\n-extern void fpscr_set_from_mem PARAMS ((int, HARD_REG_SET));\n+extern void fpscr_set_from_mem (int, HARD_REG_SET);\n #endif\n \n-extern void sh_pr_interrupt PARAMS ((struct cpp_reader *));\n-extern void sh_pr_trapa PARAMS ((struct cpp_reader *));\n-extern void sh_pr_nosave_low_regs PARAMS ((struct cpp_reader *));\n+extern void sh_pr_interrupt (struct cpp_reader *);\n+extern void sh_pr_trapa (struct cpp_reader *);\n+extern void sh_pr_nosave_low_regs (struct cpp_reader *);\n extern rtx function_symbol (const char *);\n extern rtx sh_get_pr_initial_val (void);\n "}, {"sha": "4207719dc44d49ba1593f2c3d6b7a04eedac487d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 259, "deletions": 514, "changes": 773, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf27749919d173df7d053658a350cc0bfa314efc/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf27749919d173df7d053658a350cc0bfa314efc/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=cf27749919d173df7d053658a350cc0bfa314efc", "patch": "@@ -177,61 +177,60 @@ int assembler_dialect;\n \n static bool shmedia_space_reserved_for_target_registers;\n \n-static void split_branches PARAMS ((rtx));\n-static int branch_dest PARAMS ((rtx));\n-static void force_into PARAMS ((rtx, rtx));\n-static void print_slot PARAMS ((rtx));\n-static rtx add_constant PARAMS ((rtx, enum machine_mode, rtx));\n-static void dump_table PARAMS ((rtx));\n-static int hi_const PARAMS ((rtx));\n-static int broken_move PARAMS ((rtx));\n-static int mova_p PARAMS ((rtx));\n-static rtx find_barrier PARAMS ((int, rtx, rtx));\n-static int noncall_uses_reg PARAMS ((rtx, rtx, rtx *));\n-static rtx gen_block_redirect PARAMS ((rtx, int, int));\n-static void sh_reorg PARAMS ((void));\n+static void split_branches (rtx);\n+static int branch_dest (rtx);\n+static void force_into (rtx, rtx);\n+static void print_slot (rtx);\n+static rtx add_constant (rtx, enum machine_mode, rtx);\n+static void dump_table (rtx);\n+static int hi_const (rtx);\n+static int broken_move (rtx);\n+static int mova_p (rtx);\n+static rtx find_barrier (int, rtx, rtx);\n+static int noncall_uses_reg (rtx, rtx, rtx *);\n+static rtx gen_block_redirect (rtx, int, int);\n+static void sh_reorg (void);\n static void output_stack_adjust (int, rtx, int, HARD_REG_SET *);\n-static rtx frame_insn PARAMS ((rtx));\n-static rtx push PARAMS ((int));\n-static void pop PARAMS ((int));\n-static void push_regs PARAMS ((HARD_REG_SET *, int));\n-static int calc_live_regs PARAMS ((HARD_REG_SET *));\n-static void mark_use PARAMS ((rtx, rtx *));\n-static HOST_WIDE_INT rounded_frame_size PARAMS ((int));\n-static rtx mark_constant_pool_use PARAMS ((rtx));\n+static rtx frame_insn (rtx);\n+static rtx push (int);\n+static void pop (int);\n+static void push_regs (HARD_REG_SET *, int);\n+static int calc_live_regs (HARD_REG_SET *);\n+static void mark_use (rtx, rtx *);\n+static HOST_WIDE_INT rounded_frame_size (int);\n+static rtx mark_constant_pool_use (rtx);\n const struct attribute_spec sh_attribute_table[];\n-static tree sh_handle_interrupt_handler_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree sh_handle_sp_switch_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree sh_handle_trap_exit_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static tree sh_handle_renesas_attribute PARAMS ((tree *, tree, tree, int, bool *));\n-static void sh_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n-static void sh_insert_attributes PARAMS ((tree, tree *));\n-static int sh_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n-static int sh_use_dfa_interface PARAMS ((void));\n-static int sh_issue_rate PARAMS ((void));\n-static bool sh_function_ok_for_sibcall PARAMS ((tree, tree));\n-\n-static bool sh_cannot_modify_jumps_p PARAMS ((void));\n+static tree sh_handle_interrupt_handler_attribute (tree *, tree, tree, int, bool *);\n+static tree sh_handle_sp_switch_attribute (tree *, tree, tree, int, bool *);\n+static tree sh_handle_trap_exit_attribute (tree *, tree, tree, int, bool *);\n+static tree sh_handle_renesas_attribute (tree *, tree, tree, int, bool *);\n+static void sh_output_function_epilogue (FILE *, HOST_WIDE_INT);\n+static void sh_insert_attributes (tree, tree *);\n+static int sh_adjust_cost (rtx, rtx, rtx, int);\n+static int sh_use_dfa_interface (void);\n+static int sh_issue_rate (void);\n+static bool sh_function_ok_for_sibcall (tree, tree);\n+\n+static bool sh_cannot_modify_jumps_p (void);\n static int sh_target_reg_class (void);\n static bool sh_optimize_target_register_callee_saved (bool);\n-static bool sh_ms_bitfield_layout_p PARAMS ((tree));\n-\n-static void sh_init_builtins PARAMS ((void));\n-static void sh_media_init_builtins PARAMS ((void));\n-static rtx sh_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n-static void sh_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n-\t\t\t\t\tHOST_WIDE_INT, tree));\n-static void sh_file_start PARAMS ((void));\n-static int flow_dependent_p PARAMS ((rtx, rtx));\n-static void flow_dependent_p_1 PARAMS ((rtx, rtx, void *));\n-static int shiftcosts PARAMS ((rtx));\n-static int andcosts PARAMS ((rtx));\n-static int addsubcosts PARAMS ((rtx));\n-static int multcosts PARAMS ((rtx));\n-static bool unspec_caller_rtx_p PARAMS ((rtx));\n-static bool sh_cannot_copy_insn_p PARAMS ((rtx));\n-static bool sh_rtx_costs PARAMS ((rtx, int, int, int *));\n-static int sh_address_cost PARAMS ((rtx));\n+static bool sh_ms_bitfield_layout_p (tree);\n+\n+static void sh_init_builtins (void);\n+static void sh_media_init_builtins (void);\n+static rtx sh_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n+static void sh_output_mi_thunk (FILE *, tree, HOST_WIDE_INT, HOST_WIDE_INT, tree);\n+static void sh_file_start (void);\n+static int flow_dependent_p (rtx, rtx);\n+static void flow_dependent_p_1 (rtx, rtx, void *);\n+static int shiftcosts (rtx);\n+static int andcosts (rtx);\n+static int addsubcosts (rtx);\n+static int multcosts (rtx);\n+static bool unspec_caller_rtx_p (rtx);\n+static bool sh_cannot_copy_insn_p (rtx);\n+static bool sh_rtx_costs (rtx, int, int, int *);\n+static int sh_address_cost (rtx);\n static int shmedia_target_regs_stack_space (HARD_REG_SET *);\n static int shmedia_reserve_space_for_target_registers_p (int, HARD_REG_SET *);\n static int shmedia_target_regs_stack_adjust (HARD_REG_SET *);\n@@ -240,13 +239,13 @@ struct save_schedule_s;\n static struct save_entry_s *sh5_schedule_saves (HARD_REG_SET *,\n \t\t\t\t\t\tstruct save_schedule_s *, int);\n \n-static bool sh_promote_prototypes PARAMS ((tree));\n-static rtx sh_struct_value_rtx PARAMS ((tree, int));\n-static bool sh_return_in_memory PARAMS ((tree, tree));\n-static rtx sh_builtin_saveregs PARAMS ((void));\n-static void sh_setup_incoming_varargs PARAMS ((CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int));\n-static bool sh_strict_argument_naming PARAMS ((CUMULATIVE_ARGS *));\n-static bool sh_pretend_outgoing_varargs_named PARAMS ((CUMULATIVE_ARGS *));\n+static bool sh_promote_prototypes (tree);\n+static rtx sh_struct_value_rtx (tree, int);\n+static bool sh_return_in_memory (tree, tree);\n+static rtx sh_builtin_saveregs (void);\n+static void sh_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode, tree, int *, int);\n+static bool sh_strict_argument_naming (CUMULATIVE_ARGS *);\n+static bool sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *);\n \n \f\n /* Initialize the GCC target structure.  */\n@@ -351,9 +350,7 @@ struct gcc_target targetm = TARGET_INITIALIZER;\n /* Print the operand address in x to the stream.  */\n \n void\n-print_operand_address (stream, x)\n-     FILE *stream;\n-     rtx x;\n+print_operand_address (FILE *stream, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -426,10 +423,7 @@ print_operand_address (stream, x)\n    'o'  output an operator.  */\n \n void\n-print_operand (stream, x, code)\n-     FILE *stream;\n-     rtx x;\n-     int code;\n+print_operand (FILE *stream, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -638,8 +632,7 @@ print_operand (stream, x, code)\n \f\n /* Like force_operand, but guarantees that VALUE ends up in TARGET.  */\n static void\n-force_into (value, target)\n-     rtx value, target;\n+force_into (rtx value, rtx target)\n {\n   value = force_operand (value, target);\n   if (! rtx_equal_p (value, target))\n@@ -654,8 +647,7 @@ force_into (value, target)\n    OPERANDS[3] is the alignment safe to use.  */\n \n int\n-expand_block_move (operands)\n-     rtx *operands;\n+expand_block_move (rtx *operands)\n {\n   int align = INTVAL (operands[3]);\n   int constp = (GET_CODE (operands[2]) == CONST_INT);\n@@ -770,9 +762,7 @@ expand_block_move (operands)\n    operands must be in a register.  */\n \n int\n-prepare_move_operands (operands, mode)\n-     rtx operands[];\n-     enum machine_mode mode;\n+prepare_move_operands (rtx operands[], enum machine_mode mode)\n {\n   if ((mode == SImode || mode == DImode)\n       && flag_pic\n@@ -909,8 +899,7 @@ prepare_move_operands (operands, mode)\n /* Prepare the operands for an scc instruction; make sure that the\n    compare has been done.  */\n rtx\n-prepare_scc_operands (code)\n-     enum rtx_code code;\n+prepare_scc_operands (enum rtx_code code)\n {\n   rtx t_reg = gen_rtx_REG (SImode, T_REG);\n   enum rtx_code oldcode = code;\n@@ -974,9 +963,7 @@ prepare_scc_operands (code)\n /* Called from the md file, set up the operands of a compare instruction.  */\n \n void\n-from_compare (operands, code)\n-     rtx *operands;\n-     int code;\n+from_compare (rtx *operands, int code)\n {\n   enum machine_mode mode = GET_MODE (sh_compare_op0);\n   rtx insn;\n@@ -1022,10 +1009,8 @@ from_compare (operands, code)\n    to take care when we see overlapping source and dest registers.  */\n \n const char *\n-output_movedouble (insn, operands, mode)\n-     rtx insn ATTRIBUTE_UNUSED;\n-     rtx operands[];\n-     enum machine_mode mode;\n+output_movedouble (rtx insn ATTRIBUTE_UNUSED, rtx operands[],\n+\t\t   enum machine_mode mode)\n {\n   rtx dst = operands[0];\n   rtx src = operands[1];\n@@ -1100,18 +1085,15 @@ output_movedouble (insn, operands, mode)\n    into a sequence where putting the slot insn at the end wouldn't work.  */\n \n static void\n-print_slot (insn)\n-     rtx insn;\n+print_slot (rtx insn)\n {\n   final_scan_insn (XVECEXP (insn, 0, 1), asm_out_file, optimize, 0, 1);\n \n   INSN_DELETED_P (XVECEXP (insn, 0, 1)) = 1;\n }\n \n const char *\n-output_far_jump (insn, op)\n-     rtx insn;\n-     rtx op;\n+output_far_jump (rtx insn, rtx op)\n {\n   struct { rtx lab, reg, op; } this;\n   rtx braf_base_lab = NULL_RTX;\n@@ -1205,10 +1187,7 @@ static int lf = 100;\n /* Output code for ordinary branches.  */\n \n const char *\n-output_branch (logic, insn, operands)\n-     int logic;\n-     rtx insn;\n-     rtx *operands;\n+output_branch (int logic, rtx insn, rtx *operands)\n {\n   switch (get_attr_length (insn))\n     {\n@@ -1293,11 +1272,8 @@ output_branch (logic, insn, operands)\n }\n \n const char *\n-output_branchy_insn (code, template, insn, operands)\n-     enum rtx_code code;\n-     const char *template;\n-     rtx insn;\n-     rtx *operands;\n+output_branchy_insn (enum rtx_code code, const char *template,\n+\t\t     rtx insn, rtx *operands)\n {\n   rtx next_insn = NEXT_INSN (insn);\n \n@@ -1337,16 +1313,15 @@ output_branchy_insn (code, template, insn, operands)\n }\n \n const char *\n-output_ieee_ccmpeq (insn, operands)\n-     rtx insn, *operands;\n+output_ieee_ccmpeq (rtx insn, rtx *operands)\n {\n   return output_branchy_insn (NE, \"bt\\t%l9\\\\;fcmp/eq\\t%1,%0\", insn, operands);\n }\n \f\n /* Output the start of the assembler file.  */\n \n static void\n-sh_file_start ()\n+sh_file_start (void)\n {\n   default_file_start ();\n \n@@ -1380,8 +1355,7 @@ sh_file_start ()\n /* Check if PAT includes UNSPEC_CALLER unspec pattern.  */\n \n static bool\n-unspec_caller_rtx_p (pat)\n-     rtx pat;\n+unspec_caller_rtx_p (rtx pat)\n {\n   switch (GET_CODE (pat))\n     {\n@@ -1406,8 +1380,7 @@ unspec_caller_rtx_p (pat)\n    that generates an unique label.  */\n \n static bool\n-sh_cannot_copy_insn_p (insn)\n-     rtx insn;\n+sh_cannot_copy_insn_p (rtx insn)\n {\n   rtx pat;\n \n@@ -1478,8 +1451,7 @@ static const short ext_shift_amounts[32][4] = {\n    of arbitrary constant shift instructions.  */\n \n int\n-shift_insns_rtx (insn)\n-     rtx insn;\n+shift_insns_rtx (rtx insn)\n {\n   rtx set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n   int shift_count = INTVAL (XEXP (set_src, 1));\n@@ -1500,8 +1472,7 @@ shift_insns_rtx (insn)\n /* Return the cost of a shift.  */\n \n static inline int\n-shiftcosts (x)\n-     rtx x;\n+shiftcosts (rtx x)\n {\n   int value;\n \n@@ -1540,8 +1511,7 @@ shiftcosts (x)\n /* Return the cost of an AND operation.  */\n \n static inline int\n-andcosts (x)\n-     rtx x;\n+andcosts (rtx x)\n {\n   int i;\n \n@@ -1580,8 +1550,7 @@ andcosts (x)\n /* Return the cost of an addition or a subtraction.  */\n \n static inline int\n-addsubcosts (x)\n-     rtx x;\n+addsubcosts (rtx x)\n {\n   /* Adding a register is a single cycle insn.  */\n   if (GET_CODE (XEXP (x, 1)) == REG\n@@ -1621,8 +1590,7 @@ addsubcosts (x)\n \n /* Return the cost of a multiply.  */\n static inline int\n-multcosts (x)\n-     rtx x ATTRIBUTE_UNUSED;\n+multcosts (rtx x ATTRIBUTE_UNUSED)\n {\n   if (TARGET_SHMEDIA)\n     return 3;\n@@ -1651,9 +1619,7 @@ multcosts (x)\n    scanned.  In either case, *TOTAL contains the cost result.  */\n \n static bool\n-sh_rtx_costs (x, code, outer_code, total)\n-     rtx x;\n-     int code, outer_code, *total;\n+sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   switch (code)\n     {\n@@ -1745,8 +1711,7 @@ sh_rtx_costs (x, code, outer_code, total)\n    since it increases pressure on r0.  */\n \n static int\n-sh_address_cost (X)\n-     rtx X;\n+sh_address_cost (rtx X)\n {\n   return (GET_CODE (X) == PLUS\n \t  && ! CONSTANT_P (XEXP (X, 1))\n@@ -1756,10 +1721,7 @@ sh_address_cost (X)\n /* Code to expand a shift.  */\n \n void\n-gen_ashift (type, n, reg)\n-     int type;\n-     int n;\n-     rtx reg;\n+gen_ashift (int type, int n, rtx reg)\n {\n   /* Negative values here come from the shift_amounts array.  */\n   if (n < 0)\n@@ -1791,10 +1753,7 @@ gen_ashift (type, n, reg)\n /* Same for HImode */\n \n void\n-gen_ashift_hi (type, n, reg)\n-     int type;\n-     int n;\n-     rtx reg;\n+gen_ashift_hi (int type, int n, rtx reg)\n {\n   /* Negative values here come from the shift_amounts array.  */\n   if (n < 0)\n@@ -1835,9 +1794,7 @@ gen_ashift_hi (type, n, reg)\n    shift instructions.  */\n    \n void\n-gen_shifty_op (code, operands)\n-     int code;\n-     rtx *operands;\n+gen_shifty_op (int code, rtx *operands)\n {\n   int value = INTVAL (operands[2]);\n   int max, i;\n@@ -1883,13 +1840,11 @@ gen_shifty_op (code, operands)\n    matter.  */\n \n void\n-gen_shifty_hi_op (code, operands)\n-     int code;\n-     rtx *operands;\n+gen_shifty_hi_op (int code, rtx *operands)\n {\n   int value = INTVAL (operands[2]);\n   int max, i;\n-  void (*gen_fun) PARAMS ((int, int, rtx));\n+  void (*gen_fun) (int, int, rtx);\n \n   /* This operation is used by and_shl for SImode values with a few\n      high bits known to be cleared.  */\n@@ -1919,8 +1874,7 @@ gen_shifty_hi_op (code, operands)\n /* ??? Rewrite to use super-optimizer sequences.  */\n \n int\n-expand_ashiftrt (operands)\n-     rtx *operands;\n+expand_ashiftrt (rtx *operands)\n {\n   rtx sym;\n   rtx wrk;\n@@ -1991,8 +1945,7 @@ expand_ashiftrt (operands)\n }\n \n int\n-sh_dynamicalize_shift_p (count)\n-     rtx count;\n+sh_dynamicalize_shift_p (rtx count)\n {\n   return shift_insns[INTVAL (count)] > 1 + SH_DYNAMIC_SHIFT_COST;\n }\n@@ -2018,9 +1971,7 @@ sh_dynamicalize_shift_p (count)\n   shift_amounts for the last shift value that is to be used before the\n   sign extend.  */\n int\n-shl_and_kind (left_rtx, mask_rtx, attrp)\n-     rtx left_rtx, mask_rtx;\n-     int *attrp;\n+shl_and_kind (rtx left_rtx, rtx mask_rtx, int *attrp)\n {\n   unsigned HOST_WIDE_INT mask, lsb, mask2, lsb2;\n   int left = INTVAL (left_rtx), right;\n@@ -2138,8 +2089,7 @@ shl_and_kind (left_rtx, mask_rtx, attrp)\n /* This is used in length attributes of the unnamed instructions\n    corresponding to shl_and_kind return values of 1 and 2.  */\n int\n-shl_and_length (insn)\n-     rtx insn;\n+shl_and_length (rtx insn)\n {\n   rtx set_src, left_rtx, mask_rtx;\n   int attributes[3];\n@@ -2154,8 +2104,7 @@ shl_and_length (insn)\n /* This is used in length attribute of the and_shl_scratch instruction.  */\n \n int\n-shl_and_scr_length (insn)\n-     rtx insn;\n+shl_and_scr_length (rtx insn)\n {\n   rtx set_src = SET_SRC (XVECEXP (PATTERN (insn), 0, 0));\n   int len = shift_insns[INTVAL (XEXP (set_src, 1))];\n@@ -2172,14 +2121,13 @@ extern int rtx_equal_function_value_matters;\n    method of generating them, i.e. returned zero.  */\n \n int\n-gen_shl_and (dest, left_rtx, mask_rtx, source)\n-     rtx dest, left_rtx, mask_rtx, source;\n+gen_shl_and (rtx dest, rtx left_rtx, rtx mask_rtx, rtx source)\n {\n   int attributes[3];\n   unsigned HOST_WIDE_INT mask;\n   int kind = shl_and_kind (left_rtx, mask_rtx, attributes);\n   int right, total_shift;\n-  void (*shift_gen_fun) PARAMS ((int, rtx*)) = gen_shifty_hi_op;\n+  void (*shift_gen_fun) (int, rtx*) = gen_shifty_hi_op;\n \n   right = attributes[0];\n   total_shift = INTVAL (left_rtx) + right;\n@@ -2305,9 +2253,7 @@ gen_shl_and (dest, left_rtx, mask_rtx, source)\n   If COSTP is nonzero, assign the calculated cost to *COSTP.  */\n \n int\n-shl_sext_kind (left_rtx, size_rtx, costp)\n-     rtx left_rtx, size_rtx;\n-     int *costp;\n+shl_sext_kind (rtx left_rtx, rtx size_rtx, int *costp)\n {\n   int left, size, insize, ext;\n   int cost = 0, best_cost;\n@@ -2401,8 +2347,7 @@ shl_sext_kind (left_rtx, size_rtx, costp)\n    implementing this pattern.  */\n \n int\n-shl_sext_length (insn)\n-     rtx insn;\n+shl_sext_length (rtx insn)\n {\n   rtx set_src, left_rtx, size_rtx;\n   int cost;\n@@ -2417,8 +2362,7 @@ shl_sext_length (insn)\n /* Generate rtl for this pattern */\n \n int\n-gen_shl_sext (dest, left_rtx, size_rtx, source)\n-     rtx dest, left_rtx, size_rtx, source;\n+gen_shl_sext (rtx dest, rtx left_rtx, rtx size_rtx, rtx source)\n {\n   int kind;\n   int left, size, insize, cost;\n@@ -2539,8 +2483,7 @@ gen_shl_sext (dest, left_rtx, size_rtx, source)\n /* Prefix a symbol_ref name with \"datalabel\".  */\n \n rtx\n-gen_datalabel_ref (sym)\n-     rtx sym;\n+gen_datalabel_ref (rtx sym)\n {\n   if (GET_CODE (sym) == LABEL_REF)\n     return gen_rtx_CONST (GET_MODE (sym),\n@@ -2643,10 +2586,7 @@ static int pool_window_last;\n /* Add a constant to the pool and return its label.  */\n \n static rtx\n-add_constant (x, mode, last_value)\n-     rtx x;\n-     enum machine_mode mode;\n-     rtx last_value;\n+add_constant (rtx x, enum machine_mode mode, rtx last_value)\n {\n   int i;\n   rtx lab, new, ref, newref;\n@@ -2718,8 +2658,7 @@ add_constant (x, mode, last_value)\n /* Output the literal table.  */\n \n static void\n-dump_table (scan)\n-     rtx scan;\n+dump_table (rtx scan)\n {\n   int i;\n   int need_align = 1;\n@@ -2890,8 +2829,7 @@ dump_table (scan)\n    mov.w instead of a mov.l.  */\n \n static int\n-hi_const (src)\n-     rtx src;\n+hi_const (rtx src)\n {\n   return (GET_CODE (src) == CONST_INT\n \t  && INTVAL (src) >= -32768\n@@ -2905,8 +2843,7 @@ hi_const (src)\n    need to fix it if the input value is CONST_OK_FOR_I08.  */\n \n static int\n-broken_move (insn)\n-     rtx insn;\n+broken_move (rtx insn)\n {\n   if (GET_CODE (insn) == INSN)\n     {\n@@ -2947,8 +2884,7 @@ broken_move (insn)\n }\n \n static int\n-mova_p (insn)\n-     rtx insn;\n+mova_p (rtx insn)\n {\n   return (GET_CODE (insn) == INSN\n \t  && GET_CODE (PATTERN (insn)) == SET\n@@ -2963,9 +2899,7 @@ mova_p (insn)\n    the range.  */\n \n static rtx\n-find_barrier (num_mova, mova, from)\n-     int num_mova;\n-     rtx mova, from;\n+find_barrier (int num_mova, rtx mova, rtx from)\n {\n   int count_si = 0;\n   int count_hi = 0;\n@@ -3207,8 +3141,7 @@ find_barrier (num_mova, mova, from)\n    register is not used anywhere else in this instruction - except as the\n    destination of a set, return this register; else, return 0.  */\n rtx\n-sfunc_uses_reg (insn)\n-     rtx insn;\n+sfunc_uses_reg (rtx insn)\n {\n   int i;\n   rtx pattern, part, reg_part, reg;\n@@ -3246,10 +3179,7 @@ sfunc_uses_reg (insn)\n    is set by INSN.  */\n \n static int\n-noncall_uses_reg (reg, insn, set)\n-     rtx reg;\n-     rtx insn;\n-     rtx *set;\n+noncall_uses_reg (rtx reg, rtx insn, rtx *set)\n {\n   rtx pattern, reg2;\n \n@@ -3334,8 +3264,7 @@ noncall_uses_reg (reg, insn, set)\n    registers 0..15, respectively, are used as outputs, or are clobbered.\n    IS_DEST should be set to 16 if X is the destination of a SET, else to 0.  */\n int\n-regs_used (x, is_dest)\n-     rtx x; int is_dest;\n+regs_used (rtx x, int is_dest)\n {\n   enum rtx_code code;\n   const char *fmt;\n@@ -3411,9 +3340,7 @@ regs_used (x, is_dest)\n    If a blocking instruction is made or recognized, return it.  */\n    \n static rtx\n-gen_block_redirect (jump, addr, need_block)\n-     rtx jump;\n-     int addr, need_block;\n+gen_block_redirect (rtx jump, int addr, int need_block)\n {\n   int dead = 0;\n   rtx prev = prev_nonnote_insn (jump);\n@@ -3572,11 +3499,10 @@ struct far_branch\n   int address;\n };\n \n-static void gen_far_branch PARAMS ((struct far_branch *));\n+static void gen_far_branch (struct far_branch *);\n enum mdep_reorg_phase_e mdep_reorg_phase;\n static void\n-gen_far_branch (bp)\n-     struct far_branch *bp;\n+gen_far_branch (struct far_branch *bp)\n {\n   rtx insn = bp->insert_place;\n   rtx jump;\n@@ -3612,8 +3538,7 @@ gen_far_branch (bp)\n \n /* Fix up ADDR_DIFF_VECs.  */\n void\n-fixup_addr_diff_vecs (first)\n-     rtx first;\n+fixup_addr_diff_vecs (rtx first)\n {\n   rtx insn;\n \n@@ -3657,8 +3582,7 @@ fixup_addr_diff_vecs (first)\n /* BARRIER_OR_LABEL is either a BARRIER or a CODE_LABEL immediately following\n    a barrier.  Return the base 2 logarithm of the desired alignment.  */\n int\n-barrier_align (barrier_or_label)\n-     rtx barrier_or_label;\n+barrier_align (rtx barrier_or_label)\n {\n   rtx next = next_real_insn (barrier_or_label), pat, prev;\n   int slot, credit, jump_to_next = 0;\n@@ -3778,8 +3702,7 @@ barrier_align (barrier_or_label)\n    Applying loop alignment to small constant or switch tables is a waste\n    of space, so we suppress this too.  */\n int\n-sh_loop_align (label)\n-     rtx label;\n+sh_loop_align (rtx label)\n {\n   rtx next = label;\n \n@@ -3800,7 +3723,7 @@ sh_loop_align (label)\n    scheduling.  */\n \n static void\n-sh_reorg ()\n+sh_reorg (void)\n {\n   rtx first, insn, mova = NULL_RTX;\n   int num_mova;\n@@ -4253,9 +4176,7 @@ sh_reorg ()\n }\n \n int\n-get_dest_uid (label, max_uid)\n-     rtx label;\n-     int max_uid;\n+get_dest_uid (rtx label, int max_uid)\n {\n   rtx dest = next_real_insn (label);\n   int dest_uid;\n@@ -4284,8 +4205,7 @@ get_dest_uid (label, max_uid)\n    find branches with common targets more easily.  */\n \n static void\n-split_branches (first)\n-     rtx first;\n+split_branches (rtx first)\n {\n   rtx insn;\n   struct far_branch **uid_branch, *far_branch_list = 0;\n@@ -4509,10 +4429,8 @@ split_branches (first)\n    does not bother to update them.  */\n \n void\n-final_prescan_insn (insn, opvec, noperands)\n-     rtx insn;\n-     rtx *opvec ATTRIBUTE_UNUSED;\n-     int noperands ATTRIBUTE_UNUSED;\n+final_prescan_insn (rtx insn, rtx *opvec ATTRIBUTE_UNUSED,\n+\t\t    int noperands ATTRIBUTE_UNUSED)\n {\n   if (TARGET_DUMPISIZE)\n     fprintf (asm_out_file, \"\\n! at %04x\\n\", INSN_ADDRESSES (INSN_UID (insn)));\n@@ -4548,7 +4466,7 @@ final_prescan_insn (insn, opvec, noperands)\n    only be labels.  */\n \n const char *\n-output_jump_label_table ()\n+output_jump_label_table (void)\n {\n   int i;\n \n@@ -4691,8 +4609,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n }\n \n static rtx\n-frame_insn (x)\n-     rtx x;\n+frame_insn (rtx x)\n {\n   x = emit_insn (x);\n   RTX_FRAME_RELATED_P (x) = 1;\n@@ -4702,8 +4619,7 @@ frame_insn (x)\n /* Output RTL to push register RN onto the stack.  */\n \n static rtx\n-push (rn)\n-     int rn;\n+push (int rn)\n {\n   rtx x;\n   if (rn == FPUL_REG)\n@@ -4732,8 +4648,7 @@ push (rn)\n /* Output RTL to pop register RN from the stack.  */\n \n static void\n-pop (rn)\n-     int rn;\n+pop (int rn)\n {\n   rtx x;\n   if (rn == FPUL_REG)\n@@ -4761,9 +4676,7 @@ pop (rn)\n /* Generate code to push the regs specified in the mask.  */\n \n static void\n-push_regs (mask, interrupt_handler)\n-     HARD_REG_SET *mask;\n-     int interrupt_handler;\n+push_regs (HARD_REG_SET *mask, int interrupt_handler)\n {\n   int i;\n   int skip_fpscr = 0;\n@@ -4850,8 +4763,7 @@ shmedia_target_regs_stack_adjust (HARD_REG_SET *live_regs_mask)\n    make sure that all the regs it clobbers are safe too.  */\n \n static int\n-calc_live_regs (live_regs_mask)\n-     HARD_REG_SET *live_regs_mask;\n+calc_live_regs (HARD_REG_SET *live_regs_mask)\n {\n   int reg;\n   int count;\n@@ -4993,8 +4905,7 @@ calc_live_regs (live_regs_mask)\n    stack for register saves.  Return the frame size, padded\n    appropriately so that the stack stays properly aligned.  */\n static HOST_WIDE_INT\n-rounded_frame_size (pushed)\n-     int pushed;\n+rounded_frame_size (int pushed)\n {\n   HOST_WIDE_INT size = get_frame_size ();\n   HOST_WIDE_INT align = STACK_BOUNDARY / BITS_PER_UNIT;\n@@ -5006,7 +4917,7 @@ rounded_frame_size (pushed)\n    unchanged along the whole function.  We set it up as the return\n    value in the prologue.  */\n int\n-sh_media_register_for_return ()\n+sh_media_register_for_return (void)\n {\n   int regno;\n   int tr0_used;\n@@ -5151,7 +5062,7 @@ sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n }\n \n void\n-sh_expand_prologue ()\n+sh_expand_prologue (void)\n {\n   HARD_REG_SET live_regs_mask;\n   int d, i;\n@@ -5510,7 +5421,7 @@ sh_expand_prologue ()\n }\n \n void\n-sh_expand_epilogue ()\n+sh_expand_epilogue (void)\n {\n   HARD_REG_SET live_regs_mask;\n   int d, i;\n@@ -5763,7 +5674,7 @@ sh_expand_epilogue ()\n static int sh_need_epilogue_known = 0;\n \n int\n-sh_need_epilogue ()\n+sh_need_epilogue (void)\n {\n   if (! sh_need_epilogue_known)\n     {\n@@ -5782,8 +5693,7 @@ sh_need_epilogue ()\n    TEMP is available as a scratch register, if needed.  */\n \n void\n-sh_set_return_address (ra, tmp)\n-     rtx ra, tmp;\n+sh_set_return_address (rtx ra, rtx tmp)\n {\n   HARD_REG_SET live_regs_mask;\n   int d;\n@@ -5849,17 +5759,16 @@ sh_set_return_address (ra, tmp)\n /* Clear variables at function end.  */\n \n static void\n-sh_output_function_epilogue (file, size)\n-     FILE *file ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT size ATTRIBUTE_UNUSED;\n+sh_output_function_epilogue (FILE *file ATTRIBUTE_UNUSED,\n+\t\t\t     HOST_WIDE_INT size ATTRIBUTE_UNUSED)\n {\n   trap_exit = pragma_interrupt = pragma_trapa = pragma_nosave_low_regs = 0;\n   sh_need_epilogue_known = 0;\n   sp_switch = NULL_RTX;\n }\n \n static rtx\n-sh_builtin_saveregs ()\n+sh_builtin_saveregs (void)\n {\n   /* First unnamed integer register.  */\n   int first_intreg = current_function_args_info.arg_count[(int) SH_ARG_INT];\n@@ -6003,7 +5912,7 @@ sh_builtin_saveregs ()\n /* Define the `__builtin_va_list' type for the ABI.  */\n \n tree\n-sh_build_va_list ()\n+sh_build_va_list (void)\n {\n   tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n   tree record;\n@@ -6047,9 +5956,7 @@ sh_build_va_list ()\n /* Implement `va_start' for varargs and stdarg.  */\n \n void\n-sh_va_start (valist, nextarg)\n-     tree valist;\n-     rtx nextarg;\n+sh_va_start (tree valist, rtx nextarg)\n {\n   tree f_next_o, f_next_o_limit, f_next_fp, f_next_fp_limit, f_next_stack;\n   tree next_o, next_o_limit, next_fp, next_fp_limit, next_stack;\n@@ -6126,8 +6033,7 @@ sh_va_start (valist, nextarg)\n /* Implement `va_arg'.  */\n \n rtx\n-sh_va_arg (valist, type)\n-     tree valist, type;\n+sh_va_arg (tree valist, tree type)\n {\n   HOST_WIDE_INT size, rsize;\n   tree tmp, pptr_type_node;\n@@ -6329,8 +6235,7 @@ sh_va_arg (valist, type)\n }\n \n static bool\n-sh_promote_prototypes (type)\n-     tree type;\n+sh_promote_prototypes (tree type)\n {\n   if (TARGET_HITACHI)\n     return 0;\n@@ -6359,11 +6264,8 @@ sh_promote_prototypes (type)\n \n \n rtx\n-sh_function_arg (ca, mode, type, named)\n-     CUMULATIVE_ARGS *ca;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+sh_function_arg (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t tree type, int named)\n {\n   if (! TARGET_SH5 && mode == VOIDmode)\n     return GEN_INT (ca->renesas_abi ? 1 : 0);\n@@ -6450,11 +6352,8 @@ sh_function_arg (ca, mode, type, named)\n    available.)  */\n \n void\n-sh_function_arg_advance (ca, mode, type, named)\n-     CUMULATIVE_ARGS *ca;\n-     enum machine_mode mode;\n-     tree type;\n-     int named;\n+sh_function_arg_advance (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n+\t\t\t tree type, int named)\n {\n  if (ca->force_mem)\n    ca->force_mem = 0;\n@@ -6604,19 +6503,15 @@ sh_function_arg_advance (ca, mode, type, named)\n    the address is passed like an invisible argument, but one that is always\n    passed in memory.  */\n static rtx\n-sh_struct_value_rtx (fndecl, incoming)\n-     tree fndecl;\n-     int incoming ATTRIBUTE_UNUSED;\n+sh_struct_value_rtx (tree fndecl, int incoming ATTRIBUTE_UNUSED)\n {\n   if (TARGET_HITACHI || sh_attr_renesas_p (fndecl))\n     return 0;\n   return gen_rtx_REG (Pmode, 2);\n }\n \n static bool\n-sh_return_in_memory (type, fndecl)\n-     tree type;\n-     tree fndecl;\n+sh_return_in_memory (tree type, tree fndecl)\n {\n   if (TARGET_SH5)\n     {\n@@ -6639,27 +6534,24 @@ sh_return_in_memory (type, fndecl)\n    later.  Fortunately, we already have two flags that are part of struct\n    function that tell if a function uses varargs or stdarg.  */\n static void\n-sh_setup_incoming_varargs (ca, mode, type, pretend_arg_size, second_time)\n-     CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     tree type ATTRIBUTE_UNUSED;\n-     int *pretend_arg_size ATTRIBUTE_UNUSED;\n-     int second_time ATTRIBUTE_UNUSED;\n+sh_setup_incoming_varargs (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n+\t\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   tree type ATTRIBUTE_UNUSED,\n+\t\t\t   int *pretend_arg_size ATTRIBUTE_UNUSED,\n+\t\t\t   int second_time ATTRIBUTE_UNUSED)\n {\n   if (! current_function_stdarg)\n     abort ();\n }\n \n static bool\n-sh_strict_argument_naming (ca)\n-     CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED;\n+sh_strict_argument_naming (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED)\n {\n   return TARGET_SH5;\n }\n \n static bool\n-sh_pretend_outgoing_varargs_named (ca)\n-     CUMULATIVE_ARGS *ca;\n+sh_pretend_outgoing_varargs_named (CUMULATIVE_ARGS *ca)\n {\n   return ! (TARGET_HITACHI || ca->renesas_abi) && ! TARGET_SH5;\n }\n@@ -6669,9 +6561,7 @@ sh_pretend_outgoing_varargs_named (ca)\n    the other its replacement, at the start of a routine.  */\n \n int\n-initial_elimination_offset (from, to)\n-     int from;\n-     int to;\n+initial_elimination_offset (int from, int to)\n {\n   int regs_saved;\n   int regs_saved_rounding = 0;\n@@ -6751,32 +6641,27 @@ initial_elimination_offset (from, to)\n    compiler.  */\n \n void\n-sh_pr_interrupt (pfile)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+sh_pr_interrupt (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   pragma_interrupt = 1;\n }\n \n void\n-sh_pr_trapa (pfile)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+sh_pr_trapa (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   pragma_interrupt = pragma_trapa = 1;\n }\n \n void\n-sh_pr_nosave_low_regs (pfile)\n-     struct cpp_reader *pfile ATTRIBUTE_UNUSED;\n+sh_pr_nosave_low_regs (struct cpp_reader *pfile ATTRIBUTE_UNUSED)\n {\n   pragma_nosave_low_regs = 1;\n }\n \n /* Generate 'handle_interrupt' attribute for decls */\n \n static void\n-sh_insert_attributes (node, attributes)\n-     tree node;\n-     tree * attributes;\n+sh_insert_attributes (tree node, tree *attributes)\n {\n   if (! pragma_interrupt\n       || TREE_CODE (node) != FUNCTION_DECL)\n@@ -6820,12 +6705,10 @@ const struct attribute_spec sh_attribute_table[] =\n /* Handle an \"interrupt_handler\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-sh_handle_interrupt_handler_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+sh_handle_interrupt_handler_attribute (tree *node, tree name,\n+\t\t\t\t       tree args ATTRIBUTE_UNUSED,\n+\t\t\t\t       int flags ATTRIBUTE_UNUSED,\n+\t\t\t\t       bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -6845,12 +6728,8 @@ sh_handle_interrupt_handler_attribute (node, name, args, flags, no_add_attrs)\n /* Handle an \"sp_switch\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-sh_handle_sp_switch_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+sh_handle_sp_switch_attribute (tree *node, tree name, tree args,\n+\t\t\t       int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -6884,12 +6763,8 @@ sh_handle_sp_switch_attribute (node, name, args, flags, no_add_attrs)\n /* Handle an \"trap_exit\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n static tree\n-sh_handle_trap_exit_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node;\n-     tree name;\n-     tree args;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs;\n+sh_handle_trap_exit_attribute (tree *node, tree name, tree args,\n+\t\t\t       int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) != FUNCTION_DECL)\n     {\n@@ -6920,20 +6795,18 @@ sh_handle_trap_exit_attribute (node, name, args, flags, no_add_attrs)\n }\n \n static tree\n-sh_handle_renesas_attribute (node, name, args, flags, no_add_attrs)\n-     tree *node ATTRIBUTE_UNUSED;\n-     tree name ATTRIBUTE_UNUSED;\n-     tree args ATTRIBUTE_UNUSED;\n-     int flags ATTRIBUTE_UNUSED;\n-     bool *no_add_attrs ATTRIBUTE_UNUSED;\n+sh_handle_renesas_attribute (tree *node ATTRIBUTE_UNUSED,\n+\t\t\t     tree name ATTRIBUTE_UNUSED,\n+\t\t\t     tree args ATTRIBUTE_UNUSED,\n+\t\t\t     int flags ATTRIBUTE_UNUSED,\n+\t\t\t     bool *no_add_attrs ATTRIBUTE_UNUSED)\n {\n   return NULL_TREE;\n }\n \n /* True if __attribute__((renesas)) or -mrenesas.  */\n int\n-sh_attr_renesas_p (td)\n-     tree td;\n+sh_attr_renesas_p (tree td)\n {\n   if (TARGET_HITACHI)\n     return 1;\n@@ -6948,13 +6821,13 @@ sh_attr_renesas_p (td)\n /* True if __attribute__((renesas)) or -mrenesas, for the current\n    function.  */\n int\n-sh_cfun_attr_renesas_p ()\n+sh_cfun_attr_renesas_p (void)\n {\n   return sh_attr_renesas_p (current_function_decl);\n }\n \n int\n-sh_cfun_interrupt_handler_p ()\n+sh_cfun_interrupt_handler_p (void)\n {\n   return (lookup_attribute (\"interrupt_handler\",\n \t\t\t    DECL_ATTRIBUTES (current_function_decl))\n@@ -6967,9 +6840,7 @@ sh_cfun_interrupt_handler_p ()\n    Used only in general_movsrc_operand.  */\n \n int\n-system_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+system_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (REGNO (op))\n     {\n@@ -6986,9 +6857,7 @@ system_reg_operand (op, mode)\n    invalid as are subregs of system registers.  */\n \n int\n-general_movsrc_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_movsrc_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) == MEM)\n     {\n@@ -7022,9 +6891,7 @@ general_movsrc_operand (op, mode)\n    Same as general_operand, but no preinc allowed.  */\n \n int\n-general_movdst_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_movdst_operand (rtx op, enum machine_mode mode)\n {\n   /* Only pre dec allowed.  */\n   if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)\n@@ -7036,9 +6903,7 @@ general_movdst_operand (op, mode)\n /* Returns 1 if OP is a normal arithmetic register.  */\n \n int\n-arith_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_reg_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     {\n@@ -7063,9 +6928,7 @@ arith_reg_operand (op, mode)\n    because this would lead to missing sign extensions when truncating from\n    DImode to SImode.  */\n int\n-arith_reg_dest (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_reg_dest (rtx op, enum machine_mode mode)\n {\n   if (mode == DImode && GET_CODE (op) == SUBREG\n       && GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))) < 8)\n@@ -7074,9 +6937,7 @@ arith_reg_dest (op, mode)\n }\n \n int\n-int_gpr_dest (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+int_gpr_dest (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -7089,9 +6950,7 @@ int_gpr_dest (op, mode)\n }\n \n int\n-fp_arith_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fp_arith_reg_operand (rtx op, enum machine_mode mode)\n {\n   if (register_operand (op, mode))\n     {\n@@ -7113,9 +6972,7 @@ fp_arith_reg_operand (op, mode)\n /* Returns 1 if OP is a valid source operand for an arithmetic insn.  */\n \n int\n-arith_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_operand (rtx op, enum machine_mode mode)\n {\n   if (arith_reg_operand (op, mode))\n     return 1;\n@@ -7142,9 +6999,7 @@ arith_operand (op, mode)\n /* Returns 1 if OP is a valid source operand for a compare insn.  */\n \n int\n-arith_reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+arith_reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   if (arith_reg_operand (op, mode))\n     return 1;\n@@ -7159,9 +7014,7 @@ arith_reg_or_0_operand (op, mode)\n    that takes either a register or a 6-bit immediate.  */\n \n int\n-shmedia_6bit_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+shmedia_6bit_operand (rtx op, enum machine_mode mode)\n {\n   return (arith_reg_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT && CONST_OK_FOR_I06 (INTVAL (op))));\n@@ -7170,9 +7023,7 @@ shmedia_6bit_operand (op, mode)\n /* Returns 1 if OP is a valid source operand for a logical operation.  */\n \n int\n-logical_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+logical_operand (rtx op, enum machine_mode mode)\n {\n   if (arith_reg_operand (op, mode))\n     return 1;\n@@ -7191,9 +7042,7 @@ logical_operand (op, mode)\n }\n \n int\n-and_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+and_operand (rtx op, enum machine_mode mode)\n {\n   if (logical_operand (op, mode))\n     return 1;\n@@ -7211,8 +7060,7 @@ and_operand (op, mode)\n /* Nonzero if OP is a floating point value with value 0.0.  */\n \n int\n-fp_zero_operand (op)\n-     rtx op;\n+fp_zero_operand (rtx op)\n {\n   REAL_VALUE_TYPE r;\n \n@@ -7226,8 +7074,7 @@ fp_zero_operand (op)\n /* Nonzero if OP is a floating point value with value 1.0.  */\n \n int\n-fp_one_operand (op)\n-     rtx op;\n+fp_one_operand (rtx op)\n {\n   REAL_VALUE_TYPE r;\n \n@@ -7246,33 +7093,27 @@ fp_one_operand (op)\n    choosing an fldi alternative during reload and thus failing to\n    allocate a scratch register for the constant loading.  */\n int\n-fldi_ok ()\n+fldi_ok (void)\n {\n   return ! TARGET_SH4 || TARGET_FMOVD || reload_completed;\n }\n \n int\n-tertiary_reload_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+tertiary_reload_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   enum rtx_code code = GET_CODE (op);\n   return code == MEM || (TARGET_SH4 && code == CONST_DOUBLE);\n }\n \n int\n-fpscr_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+fpscr_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == REG && REGNO (op) == FPSCR_REG\n \t  && GET_MODE (op) == PSImode);\n }\n \n int\n-fpul_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+fpul_operand (rtx op, enum machine_mode mode)\n {\n   if (TARGET_SHMEDIA)\n     return fp_arith_reg_operand (op, mode);\n@@ -7283,28 +7124,22 @@ fpul_operand (op, mode)\n }\n \n int\n-symbol_ref_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+symbol_ref_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   return (GET_CODE (op) == SYMBOL_REF);\n }\n \n /* Return the TLS type for TLS symbols, 0 for otherwise.  */\n int\n-tls_symbolic_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+tls_symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   if (GET_CODE (op) != SYMBOL_REF)\n     return 0;\n   return SYMBOL_REF_TLS_MODEL (op);\n }\n \n int\n-commutative_float_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+commutative_float_operator (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -7320,9 +7155,7 @@ commutative_float_operator (op, mode)\n }\n \n int\n-noncommutative_float_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+noncommutative_float_operator (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -7338,9 +7171,7 @@ noncommutative_float_operator (op, mode)\n }\n \n int\n-unary_float_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+unary_float_operator (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -7357,9 +7188,7 @@ unary_float_operator (op, mode)\n }\n \n int\n-binary_float_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+binary_float_operator (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -7377,9 +7206,7 @@ binary_float_operator (op, mode)\n }\n \n int\n-binary_logical_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+binary_logical_operator (rtx op, enum machine_mode mode)\n {\n   if (GET_MODE (op) != mode)\n     return 0;\n@@ -7396,17 +7223,13 @@ binary_logical_operator (op, mode)\n }\n \n int\n-equality_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+equality_comparison_operator (rtx op, enum machine_mode mode)\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n \t  && (GET_CODE (op) == EQ || GET_CODE (op) == NE));\n }\n \n-int greater_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+int greater_comparison_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) == mode)\n     return 0;\n@@ -7422,9 +7245,7 @@ int greater_comparison_operator (op, mode)\n     }\n }\n \n-int less_comparison_operator (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+int less_comparison_operator (rtx op, enum machine_mode mode)\n {\n   if (mode != VOIDmode && GET_MODE (op) == mode)\n     return 0;\n@@ -7442,9 +7263,7 @@ int less_comparison_operator (op, mode)\n \n /* Accept pseudos and branch target registers.  */\n int\n-target_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+target_reg_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != DImode\n       || GET_MODE (op) != DImode)\n@@ -7469,9 +7288,7 @@ target_reg_operand (op, mode)\n /* Same as target_reg_operand, except that label_refs and symbol_refs\n    are accepted before reload.  */\n int\n-target_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+target_operand (rtx op, enum machine_mode mode)\n {\n   if (mode != DImode)\n     return 0;\n@@ -7484,9 +7301,7 @@ target_operand (op, mode)\n }\n \n int\n-mextr_bit_offset (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+mextr_bit_offset (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   HOST_WIDE_INT i;\n \n@@ -7497,19 +7312,15 @@ mextr_bit_offset (op, mode)\n }\n \n int\n-extend_reg_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+extend_reg_operand (rtx op, enum machine_mode mode)\n {\n   return (GET_CODE (op) == TRUNCATE\n \t  ? arith_operand\n \t  : arith_reg_operand) (op, mode);\n }\n \n int\n-trunc_hi_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+trunc_hi_operand (rtx op, enum machine_mode mode)\n {\n   enum machine_mode op_mode = GET_MODE (op);\n \n@@ -7520,29 +7331,23 @@ trunc_hi_operand (op, mode)\n }\n \n int\n-extend_reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+extend_reg_or_0_operand (rtx op, enum machine_mode mode)\n {\n   return (GET_CODE (op) == TRUNCATE\n \t  ? arith_operand\n \t  : arith_reg_or_0_operand) (op, mode);\n }\n \n int\n-general_extend_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+general_extend_operand (rtx op, enum machine_mode mode)\n {\n   return (GET_CODE (op) == TRUNCATE\n \t  ? arith_operand\n \t  : nonimmediate_operand) (op, mode);\n }\n \n int\n-inqhi_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+inqhi_operand (rtx op, enum machine_mode mode)\n {\n   if (GET_CODE (op) != TRUNCATE || mode != GET_MODE (op))\n     return 0;\n@@ -7553,9 +7358,7 @@ inqhi_operand (op, mode)\n }\n \n int\n-sh_rep_vec (v, mode)\n-     rtx v;\n-     enum machine_mode mode;\n+sh_rep_vec (rtx v, enum machine_mode mode)\n {\n   int i;\n   rtx x, y;\n@@ -7583,9 +7386,7 @@ sh_rep_vec (v, mode)\n /* Determine if V is a constant vector matching MODE with only one element\n    that is not a sign extension.  Two byte-sized elements count as one.  */\n int\n-sh_1el_vec (v, mode)\n-     rtx v;\n-     enum machine_mode mode;\n+sh_1el_vec (rtx v, enum machine_mode mode)\n {\n   int unit_size;\n   int i, last, least, sign_ix;\n@@ -7616,9 +7417,7 @@ sh_1el_vec (v, mode)\n }\n \n int\n-sh_const_vec (v, mode)\n-     rtx v;\n-     enum machine_mode mode;\n+sh_const_vec (rtx v, enum machine_mode mode)\n {\n   int i;\n \n@@ -7635,8 +7434,7 @@ sh_const_vec (v, mode)\n /* Return the destination address of a branch.  */\n    \n static int\n-branch_dest (branch)\n-     rtx branch;\n+branch_dest (rtx branch)\n {\n   rtx dest = SET_SRC (PATTERN (branch));\n   int dest_uid;\n@@ -7652,9 +7450,7 @@ branch_dest (branch)\n    We assume REG is a reload reg, and therefore does\n    not live past labels.  It may live past calls or jumps though.  */\n int\n-reg_unused_after (reg, insn)\n-     rtx reg;\n-     rtx insn;\n+reg_unused_after (rtx reg, rtx insn)\n {\n   enum rtx_code code;\n   rtx set;\n@@ -7747,7 +7543,7 @@ reg_unused_after (reg, insn)\n \n static GTY(()) rtx fpscr_rtx;\n rtx\n-get_fpscr_rtx ()\n+get_fpscr_rtx (void)\n {\n   if (! fpscr_rtx)\n     {\n@@ -7761,48 +7557,38 @@ get_fpscr_rtx ()\n }\n \n void\n-emit_sf_insn (pat)\n-     rtx pat;\n+emit_sf_insn (rtx pat)\n {\n   emit_insn (pat);\n }\n \n void\n-emit_df_insn (pat)\n-     rtx pat;\n+emit_df_insn (rtx pat)\n {\n   emit_insn (pat);\n }\n \n void\n-expand_sf_unop (fun, operands)\n-     rtx (*fun) PARAMS ((rtx, rtx, rtx));\n-     rtx *operands;\n+expand_sf_unop (rtx (*fun) (rtx, rtx, rtx), rtx *operands)\n {\n   emit_sf_insn ((*fun) (operands[0], operands[1], get_fpscr_rtx ()));\n }\n \n void\n-expand_sf_binop (fun, operands)\n-     rtx (*fun) PARAMS ((rtx, rtx, rtx, rtx));\n-     rtx *operands;\n+expand_sf_binop (rtx (*fun) (rtx, rtx, rtx, rtx), rtx *operands)\n {\n   emit_sf_insn ((*fun) (operands[0], operands[1], operands[2],\n \t\t\t get_fpscr_rtx ()));\n }\n \n void\n-expand_df_unop (fun, operands)\n-     rtx (*fun) PARAMS ((rtx, rtx, rtx));\n-     rtx *operands;\n+expand_df_unop (rtx (*fun) (rtx, rtx, rtx), rtx *operands)\n {\n   emit_df_insn ((*fun) (operands[0], operands[1], get_fpscr_rtx ()));\n }\n \n void\n-expand_df_binop (fun, operands)\n-     rtx (*fun) PARAMS ((rtx, rtx, rtx, rtx));\n-     rtx *operands;\n+expand_df_binop (rtx (*fun) (rtx, rtx, rtx, rtx), rtx *operands)\n {\n   emit_df_insn ((*fun) (operands[0], operands[1], operands[2],\n \t\t\t get_fpscr_rtx ()));\n@@ -7836,8 +7622,7 @@ f(double a)\n    same basic block.  */\n \n static void \n-mark_use (x, reg_set_block)\n-     rtx x, *reg_set_block;\n+mark_use (rtx x, rtx *reg_set_block)\n {\n   enum rtx_code code;\n \n@@ -7889,7 +7674,7 @@ mark_use (x, reg_set_block)\n     }\n }\n \f\n-static rtx get_free_reg PARAMS ((HARD_REG_SET));\n+static rtx get_free_reg (HARD_REG_SET);\n \n /* This function returns a register to use to load the address to load\n    the fpscr from.  Currently it always returns r1 or r7, but when we are\n@@ -7906,8 +7691,7 @@ __complex__ long long f (double d) { if (d == 0) return 2; else return 3; }\n    the middle.  */\n \n static rtx\n-get_free_reg (regs_live)\n-     HARD_REG_SET regs_live;\n+get_free_reg (HARD_REG_SET regs_live)\n {\n   if (! TEST_HARD_REG_BIT (regs_live, 1))\n     return gen_rtx_REG (Pmode, 1);\n@@ -7923,9 +7707,7 @@ get_free_reg (regs_live)\n /* This function will set the fpscr from memory. \n    MODE is the mode we are setting it to.  */\n void\n-fpscr_set_from_mem (mode, regs_live)\n-     int mode;\n-     HARD_REG_SET regs_live;\n+fpscr_set_from_mem (int mode, HARD_REG_SET regs_live)\n {\n   enum attr_fp_mode fp_mode = mode;\n   rtx addr_reg = get_free_reg (regs_live);\n@@ -7942,8 +7724,7 @@ fpscr_set_from_mem (mode, regs_live)\n #endif\n \n int\n-sh_insn_length_adjustment (insn)\n-     rtx insn;\n+sh_insn_length_adjustment (rtx insn)\n {\n   /* Instructions with unfilled delay slots take up an extra two bytes for\n      the nop in the delay slot.  */\n@@ -8026,8 +7807,7 @@ sh_insn_length_adjustment (insn)\n /* Return TRUE if X references a SYMBOL_REF or LABEL_REF whose symbol\n    isn't protected by a PIC unspec.  */\n int\n-nonpic_symbol_mentioned_p (x)\n-     rtx x;\n+nonpic_symbol_mentioned_p (rtx x)\n {\n   register const char *fmt;\n   register int i;\n@@ -8072,10 +7852,8 @@ nonpic_symbol_mentioned_p (x)\n /* Convert a non-PIC address in `orig' to a PIC address using @GOT or\n    @GOTOFF in `reg'.  */\n rtx\n-legitimize_pic_address (orig, mode, reg)\n-     rtx orig;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     rtx reg;\n+legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\trtx reg)\n {\n   if (tls_symbolic_operand (orig, Pmode))\n     return orig;\n@@ -8103,8 +7881,7 @@ legitimize_pic_address (orig, mode, reg)\n /* Mark the use of a constant in the literal table. If the constant\n    has multiple labels, make it unique.  */\n static rtx\n-mark_constant_pool_use (x)\n-     rtx x;\n+mark_constant_pool_use (rtx x)\n {\n   rtx insn, lab, pattern;\n \n@@ -8170,9 +7947,7 @@ mark_constant_pool_use (x)\n    of an unconditional jump BRANCH2.  We only want to do this if the\n    resulting branch will have a short displacement.  */\n int \n-sh_can_redirect_branch (branch1, branch2)\n-     rtx branch1;\n-     rtx branch2;\n+sh_can_redirect_branch (rtx branch1, rtx branch2)\n {\n   if (flag_expensive_optimizations && simplejump_p (branch2))\n     {\n@@ -8204,9 +7979,8 @@ sh_can_redirect_branch (branch1, branch2)\n \n /* Return nonzero if register old_reg can be renamed to register new_reg.  */\n int\n-sh_hard_regno_rename_ok (old_reg, new_reg)\n-     unsigned int old_reg ATTRIBUTE_UNUSED;\n-     unsigned int new_reg;\n+sh_hard_regno_rename_ok (unsigned int old_reg ATTRIBUTE_UNUSED,\n+\t\t\t unsigned int new_reg)\n {\n \n /* Interrupt functions can only use registers that have already been\n@@ -8227,11 +8001,7 @@ sh_hard_regno_rename_ok (old_reg, new_reg)\n    the same cost as a data-dependence.  The return value should be\n    the new value for COST.  */\n static int\n-sh_adjust_cost (insn, link, dep_insn, cost)\n-     rtx insn;\n-     rtx link ATTRIBUTE_UNUSED;\n-     rtx dep_insn;\n-     int cost;\n+sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)\n {\n   rtx reg, use_pat;\n \n@@ -8337,8 +8107,7 @@ sh_adjust_cost (insn, link, dep_insn, cost)\n /* Check if INSN is flow-dependent on DEP_INSN.  Can also be used to check\n    if DEP_INSN is anti-flow dependent on INSN.  */\n static int\n-flow_dependent_p (insn, dep_insn)\n-     rtx insn, dep_insn;\n+flow_dependent_p (rtx insn, rtx dep_insn)\n {\n   rtx tmp = PATTERN (insn);\n \n@@ -8348,10 +8117,7 @@ flow_dependent_p (insn, dep_insn)\n \n /* A helper function for flow_dependent_p called through note_stores.  */\n static void\n-flow_dependent_p_1 (x, pat, data)\n-     rtx x;\n-     rtx pat ATTRIBUTE_UNUSED;\n-     void *data;\n+flow_dependent_p_1 (rtx x, rtx pat ATTRIBUTE_UNUSED, void *data)\n {\n   rtx * pinsn = (rtx *) data;\n \n@@ -8364,15 +8130,15 @@ flow_dependent_p_1 (x, pat, data)\n    do not look like function calls to leaf_function_p.  Hence we must\n    do this extra check.  */\n int\n-sh_pr_n_sets ()\n+sh_pr_n_sets (void)\n {\n   return REG_N_SETS (TARGET_SHMEDIA ? PR_MEDIA_REG : PR_REG);\n }\n \n /* This Function returns nonzero if the DFA based scheduler interface\n    is to be used.  At present this is supported for the SH4 only.  */\n static int\n-sh_use_dfa_interface()\n+sh_use_dfa_interface(void)\n {\n   if (TARGET_HARD_SH4)\n     return 1;\n@@ -8383,7 +8149,7 @@ sh_use_dfa_interface()\n /* This function returns \"2\" to indicate dual issue for the SH4\n    processor.  To be used by the DFA pipeline description.  */\n static int\n-sh_issue_rate()\n+sh_issue_rate(void)\n {\n   if (TARGET_SUPERSCALAR)\n     return 2;\n@@ -8394,7 +8160,7 @@ sh_issue_rate()\n /* SHmedia requires registers for branches, so we can't generate new\n    branches past reload.  */\n static bool\n-sh_cannot_modify_jumps_p ()\n+sh_cannot_modify_jumps_p (void)\n {\n   return (TARGET_SHMEDIA && (reload_in_progress || reload_completed));\n }\n@@ -8436,8 +8202,7 @@ sh_ms_bitfield_layout_p (record_type)\n    CXT is an RTX for the static chain value for the function.  */\n \n void\n-sh_initialize_trampoline (tramp, fnaddr, cxt)\n-     rtx tramp, fnaddr, cxt;\n+sh_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt)\n {\n   if (TARGET_SHMEDIA64)\n     {\n@@ -8594,9 +8359,7 @@ sh_initialize_trampoline (tramp, fnaddr, cxt)\n    own stack frame, so it must not pass pointers or references to\n    these arguments to other functions by means of sibling calls.  */\n static bool\n-sh_function_ok_for_sibcall (decl, exp)\n-     tree decl;\n-     tree exp ATTRIBUTE_UNUSED;\n+sh_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   return (decl \n \t  && (! TARGET_SHCOMPACT\n@@ -8764,7 +8527,7 @@ static const struct builtin_description bdesc[] =\n };\n \n static void\n-sh_media_init_builtins ()\n+sh_media_init_builtins (void)\n {\n   tree shared[SH_BLTIN_NUM_SHARED_SIGNATURES];\n   const struct builtin_description *d;\n@@ -8818,7 +8581,7 @@ sh_media_init_builtins ()\n }\n \n static void\n-sh_init_builtins ()\n+sh_init_builtins (void)\n {\n   if (TARGET_SHMEDIA)\n     sh_media_init_builtins ();\n@@ -8831,12 +8594,8 @@ sh_init_builtins ()\n    IGNORE is nonzero if the value is to be ignored.  */\n \n static rtx\n-sh_expand_builtin (exp, target, subtarget, mode, ignore)\n-     tree exp;\n-     rtx target;\n-     rtx subtarget ATTRIBUTE_UNUSED;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-     int ignore;\n+sh_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t   enum machine_mode mode ATTRIBUTE_UNUSED, int ignore)\n {\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -8909,27 +8668,23 @@ sh_expand_builtin (exp, target, subtarget, mode, ignore)\n }\n \n void\n-sh_expand_unop_v2sf (code, op0, op1)\n-     enum rtx_code code;\n-     rtx op0, op1;\n+sh_expand_unop_v2sf (enum rtx_code code, rtx op0, rtx op1)\n {\n   rtx sel0 = const0_rtx;\n   rtx sel1 = const1_rtx;\n-  rtx (*fn) PARAMS ((rtx, rtx, rtx, rtx, rtx)) = gen_unary_sf_op;\n+  rtx (*fn) (rtx, rtx, rtx, rtx, rtx) = gen_unary_sf_op;\n   rtx op = gen_rtx_fmt_e (code, SFmode, op1);\n \n   emit_insn ((*fn) (op0, op1, op, sel0, sel0));\n   emit_insn ((*fn) (op0, op1, op, sel1, sel1));\n }\n \n void\n-sh_expand_binop_v2sf (code, op0, op1, op2)\n-     enum rtx_code code;\n-     rtx op0, op1, op2;\n+sh_expand_binop_v2sf (enum rtx_code code, rtx op0, rtx op1, rtx op2)\n {\n   rtx sel0 = const0_rtx;\n   rtx sel1 = const1_rtx;\n-  rtx (*fn) PARAMS ((rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx))\n+  rtx (*fn) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx)\n     = gen_binary_sf_op;\n   rtx op = gen_rtx_fmt_ee (code, SFmode, op1, op2);\n \n@@ -8940,9 +8695,8 @@ sh_expand_binop_v2sf (code, op0, op1, op2)\n /* Return the class of registers for which a mode change from FROM to TO\n    is invalid.  */\n bool\n-sh_cannot_change_mode_class (from, to, class)\n-     enum machine_mode from, to;\n-     enum reg_class class;\n+sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n+\t\t\t     enum reg_class class)\n {\n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n@@ -8965,9 +8719,7 @@ sh_cannot_change_mode_class (from, to, class)\n    that label is used.  */\n \n void\n-sh_mark_label (address, nuses)\n-     rtx address;\n-     int nuses;\n+sh_mark_label (rtx address, int nuses)\n {\n   if (GOTOFF_P (address))\n     {\n@@ -8990,9 +8742,8 @@ sh_mark_label (address, nuses)\n    register information here is not used for SFmode.  */\n \n int\n-sh_register_move_cost (mode, srcclass, dstclass)\n-     enum machine_mode mode;\n-     enum reg_class srcclass, dstclass;\n+sh_register_move_cost (enum machine_mode mode,\n+\t\t       enum reg_class srcclass, enum reg_class dstclass)\n {\n   if (dstclass == T_REGS || dstclass == PR_REGS)\n     return 10;\n@@ -9048,20 +8799,17 @@ sh_register_move_cost (mode, srcclass, dstclass)\n /* Like register_operand, but take into account that SHMEDIA can use\n    the constant zero like a general register.  */\n int\n-sh_register_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n+sh_register_operand (rtx op, enum machine_mode mode)\n {\n   if (op == CONST0_RTX (mode) && TARGET_SHMEDIA)\n     return 1;\n   return register_operand (op, mode);\n }\n \n-static rtx emit_load_ptr PARAMS ((rtx, rtx));\n+static rtx emit_load_ptr (rtx, rtx);\n \n static rtx\n-emit_load_ptr (reg, addr)\n-     rtx reg, addr;\n+emit_load_ptr (rtx reg, rtx addr)\n {\n   rtx mem = gen_rtx_MEM (ptr_mode, addr);\n \n@@ -9071,12 +8819,9 @@ emit_load_ptr (reg, addr)\n }\n \n void\n-sh_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n-     FILE *file;\n-     tree thunk_fndecl ATTRIBUTE_UNUSED;\n-     HOST_WIDE_INT delta;\n-     HOST_WIDE_INT vcall_offset;\n-     tree function;\n+sh_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n+\t\t    HOST_WIDE_INT delta, HOST_WIDE_INT vcall_offset,\n+\t\t    tree function)\n {\n   CUMULATIVE_ARGS cum;\n   int structure_value_byref = 0;"}]}