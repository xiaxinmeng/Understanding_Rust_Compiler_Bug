{"sha": "c5126ce8cae4f14194414e266be91fdc4b756807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUxMjZjZThjYWU0ZjE0MTk0NDE0ZTI2NmJlOTFmZGM0Yjc1NjgwNw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T07:14:24Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T07:14:24Z"}, "message": "poly_int: vect_nunits_for_cost\n\nThis patch adds a function for getting the number of elements in\na vector for cost purposes, which is always constant.  It makes\nit possible for a later patch to change GET_MODE_NUNITS and\nTYPE_VECTOR_SUBPARTS to a poly_int.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (vect_nunits_for_cost): New function.\n\t* tree-vect-loop.c (vect_model_reduction_cost): Use it.\n\t* tree-vect-slp.c (vect_analyze_slp_cost_1): Likewise.\n\t(vect_analyze_slp_cost): Likewise.\n\t* tree-vect-stmts.c (vect_model_store_cost): Likewise.\n\t(vect_model_load_cost): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r256128", "tree": {"sha": "29831b5b373d49c9f075dd2deed5f3e977c7e9fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29831b5b373d49c9f075dd2deed5f3e977c7e9fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5126ce8cae4f14194414e266be91fdc4b756807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5126ce8cae4f14194414e266be91fdc4b756807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5126ce8cae4f14194414e266be91fdc4b756807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5126ce8cae4f14194414e266be91fdc4b756807/comments", "author": null, "committer": null, "parents": [{"sha": "4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b6068eadcf9801b9ef4e5f1b7b6354947c27ca8"}], "stats": {"total": 73, "additions": 53, "deletions": 20}, "files": [{"sha": "52a10ad2305a10629d0f0d25fb37cd5c389cd527", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5126ce8cae4f14194414e266be91fdc4b756807", "patch": "@@ -1,3 +1,14 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* tree-vectorizer.h (vect_nunits_for_cost): New function.\n+\t* tree-vect-loop.c (vect_model_reduction_cost): Use it.\n+\t* tree-vect-slp.c (vect_analyze_slp_cost_1): Likewise.\n+\t(vect_analyze_slp_cost): Likewise.\n+\t* tree-vect-stmts.c (vect_model_store_cost): Likewise.\n+\t(vect_model_load_cost): Likewise.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "c58a08d8d383873d565ffdf12e88e7a20ec3d679", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=c5126ce8cae4f14194414e266be91fdc4b756807", "patch": "@@ -3854,13 +3854,15 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t}\n       else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n \t{\n-\t  unsigned nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\t  unsigned estimated_nunits = vect_nunits_for_cost (vectype);\n \t  /* Extraction of scalar elements.  */\n-\t  epilogue_cost += add_stmt_cost (target_cost_data, 2 * nunits,\n+\t  epilogue_cost += add_stmt_cost (target_cost_data,\n+\t\t\t\t\t  2 * estimated_nunits,\n \t\t\t\t\t  vec_to_scalar, stmt_info, 0,\n \t\t\t\t\t  vect_epilogue);\n \t  /* Scalar max reductions via COND_EXPR / MAX_EXPR.  */\n-\t  epilogue_cost += add_stmt_cost (target_cost_data, 2 * nunits - 3,\n+\t  epilogue_cost += add_stmt_cost (target_cost_data,\n+\t\t\t\t\t  2 * estimated_nunits - 3,\n \t\t\t\t\t  scalar_stmt, stmt_info, 0,\n \t\t\t\t\t  vect_epilogue);\n \t}"}, {"sha": "d41056932da79aa35999b676092956351fa9a0a9", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=c5126ce8cae4f14194414e266be91fdc4b756807", "patch": "@@ -1730,8 +1730,8 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t\t\t\t\t    &n_perms);\n \t      record_stmt_cost (body_cost_vec, n_perms, vec_perm,\n \t\t\t\tstmt_info, 0, vect_body);\n-\t      unsigned nunits\n-\t\t= TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n+\t      unsigned assumed_nunits\n+\t\t= vect_nunits_for_cost (STMT_VINFO_VECTYPE (stmt_info));\n \t      /* And adjust the number of loads performed.  This handles\n \t         redundancies as well as loads that are later dead.  */\n \t      auto_sbitmap perm (GROUP_SIZE (stmt_info));\n@@ -1742,7 +1742,7 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t      bool load_seen = false;\n \t      for (i = 0; i < GROUP_SIZE (stmt_info); ++i)\n \t\t{\n-\t\t  if (i % nunits == 0)\n+\t\t  if (i % assumed_nunits == 0)\n \t\t    {\n \t\t      if (load_seen)\n \t\t\tncopies_for_cost++;\n@@ -1755,7 +1755,7 @@ vect_analyze_slp_cost_1 (slp_instance instance, slp_tree node,\n \t\tncopies_for_cost++;\n \t      gcc_assert (ncopies_for_cost\n \t\t\t  <= (GROUP_SIZE (stmt_info) - GROUP_GAP (stmt_info)\n-\t\t\t      + nunits - 1) / nunits);\n+\t\t\t      + assumed_nunits - 1) / assumed_nunits);\n \t      poly_uint64 uf = SLP_INSTANCE_UNROLLING_FACTOR (instance);\n \t      ncopies_for_cost *= estimated_poly_value (uf);\n \t    }\n@@ -1868,24 +1868,26 @@ vect_analyze_slp_cost (slp_instance instance, void *data)\n     assumed_vf = vect_vf_for_cost (STMT_VINFO_LOOP_VINFO (stmt_info));\n   else\n     assumed_vf = 1;\n-  unsigned nunits = TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info));\n   /* For reductions look at a reduction operand in case the reduction\n      operation is widening like DOT_PROD or SAD.  */\n+  tree vectype_for_cost = STMT_VINFO_VECTYPE (stmt_info);\n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n       switch (gimple_assign_rhs_code (stmt))\n \t{\n \tcase DOT_PROD_EXPR:\n \tcase SAD_EXPR:\n-\t  nunits = TYPE_VECTOR_SUBPARTS (get_vectype_for_scalar_type\n-\t\t\t\t(TREE_TYPE (gimple_assign_rhs1 (stmt))));\n+\t  vectype_for_cost = get_vectype_for_scalar_type\n+\t    (TREE_TYPE (gimple_assign_rhs1 (stmt)));\n \t  break;\n \tdefault:;\n \t}\n     }\n-  ncopies_for_cost = least_common_multiple (nunits,\n-\t\t\t\t\t    group_size * assumed_vf) / nunits;\n+  unsigned int assumed_nunits = vect_nunits_for_cost (vectype_for_cost);\n+  ncopies_for_cost = (least_common_multiple (assumed_nunits,\n+\t\t\t\t\t     group_size * assumed_vf)\n+\t\t      / assumed_nunits);\n \n   prologue_cost_vec.create (10);\n   body_cost_vec.create (10);"}, {"sha": "6ca3a16c4fcea3b790475213f23e643ba66e84ea", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=c5126ce8cae4f14194414e266be91fdc4b756807", "patch": "@@ -958,18 +958,25 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   /* Costs of the stores.  */\n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_GATHER_SCATTER)\n-    /* N scalar stores plus extracting the elements.  */\n-    inside_cost += record_stmt_cost (body_cost_vec,\n-\t\t\t\t     ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t     scalar_store, stmt_info, 0, vect_body);\n+    {\n+      /* N scalar stores plus extracting the elements.  */\n+      unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n+      inside_cost += record_stmt_cost (body_cost_vec,\n+\t\t\t\t       ncopies * assumed_nunits,\n+\t\t\t\t       scalar_store, stmt_info, 0, vect_body);\n+    }\n   else\n     vect_get_store_cost (dr, ncopies, &inside_cost, body_cost_vec);\n \n   if (memory_access_type == VMAT_ELEMENTWISE\n       || memory_access_type == VMAT_STRIDED_SLP)\n-    inside_cost += record_stmt_cost (body_cost_vec,\n-\t\t\t\t     ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n-\t\t\t\t     vec_to_scalar, stmt_info, 0, vect_body);\n+    {\n+      /* N scalar stores plus extracting the elements.  */\n+      unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n+      inside_cost += record_stmt_cost (body_cost_vec,\n+\t\t\t\t       ncopies * assumed_nunits,\n+\t\t\t\t       vec_to_scalar, stmt_info, 0, vect_body);\n+    }\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1089,8 +1096,9 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n     {\n       /* N scalar loads plus gathering them into a vector.  */\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+      unsigned int assumed_nunits = vect_nunits_for_cost (vectype);\n       inside_cost += record_stmt_cost (body_cost_vec,\n-\t\t\t\t       ncopies * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t       ncopies * assumed_nunits,\n \t\t\t\t       scalar_load, stmt_info, 0, vect_body);\n     }\n   else"}, {"sha": "f6938e4f60f64ffb82f13ddcc0c3a9f9be1a44fc", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5126ce8cae4f14194414e266be91fdc4b756807/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c5126ce8cae4f14194414e266be91fdc4b756807", "patch": "@@ -1154,6 +1154,16 @@ vect_vf_for_cost (loop_vec_info loop_vinfo)\n   return estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n }\n \n+/* Estimate the number of elements in VEC_TYPE for costing purposes.\n+   Pick a reasonable estimate if the exact number isn't known at\n+   compile time.  */\n+\n+static inline unsigned int\n+vect_nunits_for_cost (tree vec_type)\n+{\n+  return estimated_poly_value (TYPE_VECTOR_SUBPARTS (vec_type));\n+}\n+\n /* Return the size of the value accessed by unvectorized data reference DR.\n    This is only valid once STMT_VINFO_VECTYPE has been calculated for the\n    associated gimple statement, since that guarantees that DR accesses"}]}