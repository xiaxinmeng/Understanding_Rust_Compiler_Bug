{"sha": "f8893e4723c8ce3462bfd1298afde78e5327c260", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg4OTNlNDcyM2M4Y2UzNDYyYmZkMTI5OGFmZGU3OGU1MzI3YzI2MA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-09-09T01:19:15Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-09-09T01:19:15Z"}, "message": "c-tree.h (enum c_declarator_kind, [...]): New.\n\n\t* c-tree.h (enum c_declarator_kind, struct c_arg_info, struct\n\tc_declarator, struct c_type_name, struct c_parm): New.\n\t(build_array_declarator, set_array_declarator_inner,\n\tget_parm_info, grokfield, groktypename, grokparm, push_parm_decl,\n\tstart_function, start_decl, build_c_parm, build_attrs_declarator,\n\tbuild_function_declarator, make_pointer_declarator, c_cast_expr,\n\tstore_parm_decls_newstyle, c_expr_sizeof_type): Update prototypes.\n\t(build_id_declarator): New.\n\t* c-typeck.c (c_cast_expr, c_expr_sizeof_type): Update to new\n\tstructures.\n\t* c-decl.c (ARG_INFO_PARMS, ARG_INFO_TAGS, ARG_INFO_TYPES,\n\tARG_INFO_OTHERS): Remove.\n\t(build_id_declarator): New.\n\t(build_array_declarator, set_array_declarator_inner, groktypename,\n\tstart_decl, grokparm, push_parm_decl, grokparms, get_parm_info,\n\tgrokfield, start_function, store_parm_decls_newstyle,\n\tstore_parm_decls_oldstyle, store_parm_decls,\n\tbuild_c_parm, build_attrs_declarator, build_function_declarator,\n\tmake_pointer_declarator, grokdeclarator): Update to new\n\tstructures.\n\t* c-parse.in (%union): Add arginfotype, dtrtype, typenametype and\n\tparmtype.\n\t(declarator, notype_declarator, after_type_declarator,\n\tparm_declarator, parm_declarator_starttypename,\n\tparm_declarator_nostarttypename, array_declarator, typename,\n\tabsdcl, absdcl1, absdcl1_ea, absdcl1_noea, direct_absdcl1,\n\tabsdcl_maybe_attribute, parm, firstparm, parms, parmlist,\n\tparmlist_1, parmlist_2, parmlist_or_identifiers,\n\tparmlist_or_identifiers_1): Use these types.\n\t(primary, after_type_declarator, parm_declarator_starttypename,\n\tnotype_declarator, component_decl, component_declarator,\n\tcomponent_notype_declarator, typename, absdcl,\n\tabsdcl_maybe_attribute, absdcl1_ea, direct_absdcl1, parmlist_1,\n\tparmlist_2, parmlist_or_identifiers_1): Update to new structures.\n\nobjc:\n\t* objc-act.c (objc_start_function, really_start_method,\n\tobjc_get_parm_info, start_method_def): Update to new arg_info\n\tstructures.\n\nFrom-SVN: r87217", "tree": {"sha": "b2e10c479b481502bc955872a928817f6c0ba1b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2e10c479b481502bc955872a928817f6c0ba1b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8893e4723c8ce3462bfd1298afde78e5327c260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8893e4723c8ce3462bfd1298afde78e5327c260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8893e4723c8ce3462bfd1298afde78e5327c260", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8893e4723c8ce3462bfd1298afde78e5327c260/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc4b653be6451211226018f96146a1eaa439b6cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4b653be6451211226018f96146a1eaa439b6cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4b653be6451211226018f96146a1eaa439b6cd"}], "stats": {"total": 684, "additions": 446, "deletions": 238}, "files": [{"sha": "dd214e76ec856a2cfc853088ad484b7d4635bc90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -1,3 +1,40 @@\n+2004-09-09  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-tree.h (enum c_declarator_kind, struct c_arg_info, struct\n+\tc_declarator, struct c_type_name, struct c_parm): New.\n+\t(build_array_declarator, set_array_declarator_inner,\n+\tget_parm_info, grokfield, groktypename, grokparm, push_parm_decl,\n+\tstart_function, start_decl, build_c_parm, build_attrs_declarator,\n+\tbuild_function_declarator, make_pointer_declarator, c_cast_expr,\n+\tstore_parm_decls_newstyle, c_expr_sizeof_type): Update prototypes.\n+\t(build_id_declarator): New.\n+\t* c-typeck.c (c_cast_expr, c_expr_sizeof_type): Update to new\n+\tstructures.\n+\t* c-decl.c (ARG_INFO_PARMS, ARG_INFO_TAGS, ARG_INFO_TYPES,\n+\tARG_INFO_OTHERS): Remove.\n+\t(build_id_declarator): New.\n+\t(build_array_declarator, set_array_declarator_inner, groktypename,\n+\tstart_decl, grokparm, push_parm_decl, grokparms, get_parm_info,\n+\tgrokfield, start_function, store_parm_decls_newstyle,\n+\tstore_parm_decls_oldstyle, store_parm_decls,\n+\tbuild_c_parm, build_attrs_declarator, build_function_declarator,\n+\tmake_pointer_declarator, grokdeclarator): Update to new\n+\tstructures.\n+\t* c-parse.in (%union): Add arginfotype, dtrtype, typenametype and\n+\tparmtype.\n+\t(declarator, notype_declarator, after_type_declarator,\n+\tparm_declarator, parm_declarator_starttypename,\n+\tparm_declarator_nostarttypename, array_declarator, typename,\n+\tabsdcl, absdcl1, absdcl1_ea, absdcl1_noea, direct_absdcl1,\n+\tabsdcl_maybe_attribute, parm, firstparm, parms, parmlist,\n+\tparmlist_1, parmlist_2, parmlist_or_identifiers,\n+\tparmlist_or_identifiers_1): Use these types.\n+\t(primary, after_type_declarator, parm_declarator_starttypename,\n+\tnotype_declarator, component_decl, component_declarator,\n+\tcomponent_notype_declarator, typename, absdcl,\n+\tabsdcl_maybe_attribute, absdcl1_ea, direct_absdcl1, parmlist_1,\n+\tparmlist_2, parmlist_or_identifiers_1): Update to new structures.\n+\n 2004-09-09  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-tree.h (C_DECL_USED, parser_obstack, in_alignof, in_sizeof,"}, {"sha": "2f0334414db5b67c12edd65209c52a2185cf94b7", "filename": "gcc/c-decl.c", "status": "modified", "additions": 194, "deletions": 179, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -91,13 +91,6 @@ static tree enum_next_value;\n \n static int enum_overflow;\n \n-/* These #defines are for clarity in working with the information block\n-   returned by get_parm_info.  */\n-#define ARG_INFO_PARMS(args)  TREE_PURPOSE(args)\n-#define ARG_INFO_TAGS(args)   TREE_VALUE(args)\n-#define ARG_INFO_TYPES(args)  TREE_CHAIN(args)\n-#define ARG_INFO_OTHERS(args) TREE_TYPE(args)\n-\n /* The file and line that the prototype came from if this is an\n    old-style definition; used for diagnostics in\n    store_parm_decls_oldstyle.  */\n@@ -107,7 +100,7 @@ static location_t current_function_prototype_locus;\n /* The argument information structure for the function currently being\n    defined.  */\n \n-static GTY(()) tree current_function_arg_info;\n+static struct c_arg_info *current_function_arg_info;\n \n /* The obstack on which parser and related data structures, which are\n    not live beyond their top-level declaration or definition, are\n@@ -405,8 +398,9 @@ static GTY(()) tree static_dtors;\n /* Forward declarations.  */\n static tree lookup_name_in_scope (tree, struct c_scope *);\n static tree c_make_fname_decl (tree, int);\n-static tree grokdeclarator (tree, tree, enum decl_context, bool, tree *);\n-static tree grokparms (tree, bool);\n+static tree grokdeclarator (const struct c_declarator *, tree,\n+\t\t\t    enum decl_context, bool, tree *);\n+static tree grokparms (struct c_arg_info *, bool);\n static void layout_array_type (tree);\n \f\n /* States indicating how grokdeclarator() should handle declspecs marked\n@@ -2752,20 +2746,21 @@ shadow_tag_warned (tree declspecs, int warned)\n    true if \"static\" is inside the [], false otherwise.  VLA_UNSPEC_P\n    is true if the array is [*], a VLA of unspecified length which is\n    nevertheless a complete type (not currently implemented by GCC),\n-   false otherwise.  The declarator is constructed as an ARRAY_REF\n-   (to be decoded by grokdeclarator), whose operand 0 is what's on the\n-   left of the [] (filled by in set_array_declarator_inner) and operand 1\n-   is the expression inside; whose TREE_TYPE is the type qualifiers and\n-   which has TREE_STATIC set if \"static\" is used.  */\n+   false otherwise.  The field for the contained declarator is left to be\n+   filled in by set_array_declarator_inner.  */\n \n-tree\n+struct c_declarator *\n build_array_declarator (tree expr, tree quals, bool static_p,\n \t\t\tbool vla_unspec_p)\n {\n-  tree decl;\n-  decl = build_nt (ARRAY_REF, NULL_TREE, expr, NULL_TREE, NULL_TREE);\n-  TREE_TYPE (decl) = quals;\n-  TREE_STATIC (decl) = (static_p ? 1 : 0);\n+  struct c_declarator *declarator = XOBNEW (&parser_obstack,\n+\t\t\t\t\t    struct c_declarator);\n+  declarator->kind = cdk_array;\n+  declarator->declarator = 0;\n+  declarator->u.array.dimen = expr;\n+  declarator->u.array.quals = quals;\n+  declarator->u.array.static_p = static_p;\n+  declarator->u.array.vla_unspec_p = vla_unspec_p;\n   if (pedantic && !flag_isoc99)\n     {\n       if (static_p || quals != NULL_TREE)\n@@ -2775,21 +2770,23 @@ build_array_declarator (tree expr, tree quals, bool static_p,\n     }\n   if (vla_unspec_p)\n     warning (\"GCC does not yet properly implement `[*]' array declarators\");\n-  return decl;\n+  return declarator;\n }\n \n-/* Set the type of an array declarator.  DECL is the declarator, as\n-   constructed by build_array_declarator; TYPE is what appears on the left\n-   of the [] and goes in operand 0.  ABSTRACT_P is true if it is an\n-   abstract declarator, false otherwise; this is used to reject static and\n-   type qualifiers in abstract declarators, where they are not in the\n-   C99 grammar.  */\n+/* Set the contained declarator of an array declarator.  DECL is the\n+   declarator, as constructed by build_array_declarator; INNER is what\n+   appears on the left of the [].  ABSTRACT_P is true if it is an\n+   abstract declarator, false otherwise; this is used to reject static\n+   and type qualifiers in abstract declarators, where they are not in\n+   the C99 grammar (subject to possible change in DR#289).  */\n \n-tree\n-set_array_declarator_inner (tree decl, tree type, bool abstract_p)\n+struct c_declarator *\n+set_array_declarator_inner (struct c_declarator *decl,\n+\t\t\t    struct c_declarator *inner, bool abstract_p)\n {\n-  TREE_OPERAND (decl, 0) = type;\n-  if (abstract_p && (TREE_TYPE (decl) != NULL_TREE || TREE_STATIC (decl)))\n+  decl->declarator = inner;\n+  if (abstract_p && (decl->u.array.quals != NULL_TREE\n+\t\t     || decl->u.array.static_p))\n     error (\"static or type qualifiers in abstract declarator\");\n   return decl;\n }\n@@ -2876,22 +2873,20 @@ split_specs_attrs (tree specs_attrs, tree *declspecs, tree *prefix_attributes)\n /* Decode a \"typename\", such as \"int **\", returning a ..._TYPE node.  */\n \n tree\n-groktypename (tree type_name)\n+groktypename (struct c_type_name *type_name)\n {\n+  tree type;\n   tree specs, attrs;\n \n-  if (TREE_CODE (type_name) != TREE_LIST)\n-    return type_name;\n+  split_specs_attrs (type_name->specs, &specs, &attrs);\n \n-  split_specs_attrs (TREE_PURPOSE (type_name), &specs, &attrs);\n-\n-  type_name = grokdeclarator (TREE_VALUE (type_name), specs, TYPENAME, false,\n-\t\t\t     NULL);\n+  type = grokdeclarator (type_name->declarator, specs, TYPENAME, false,\n+\t\t\t NULL);\n \n   /* Apply attributes.  */\n-  decl_attributes (&type_name, attrs, 0);\n+  decl_attributes (&type, attrs, 0);\n \n-  return type_name;\n+  return type;\n }\n \n /* Decode a declarator in an ordinary declaration or data definition.\n@@ -2910,7 +2905,8 @@ groktypename (tree type_name)\n    grokfield and not through here.  */\n \n tree\n-start_decl (tree declarator, tree declspecs, bool initialized, tree attributes)\n+start_decl (struct c_declarator *declarator, tree declspecs,\n+\t    bool initialized, tree attributes)\n {\n   tree decl;\n   tree tem;\n@@ -3023,13 +3019,13 @@ start_decl (tree declarator, tree declspecs, bool initialized, tree attributes)\n   if (TREE_CODE (decl) == FUNCTION_DECL\n       && targetm.calls.promote_prototypes (TREE_TYPE (decl)))\n     {\n-      tree ce = declarator;\n+      struct c_declarator *ce = declarator;\n \n-      if (TREE_CODE (ce) == INDIRECT_REF)\n-\tce = TREE_OPERAND (declarator, 0);\n-      if (TREE_CODE (ce) == CALL_EXPR)\n+      if (ce->kind == cdk_pointer)\n+\tce = declarator->declarator;\n+      if (ce->kind == cdk_function)\n \t{\n-\t  tree args = TREE_PURPOSE (TREE_OPERAND (ce, 1));\n+\t  tree args = ce->u.arg_info->parms;\n \t  for (; args; args = TREE_CHAIN (args))\n \t    {\n \t      tree type = TREE_TYPE (args);\n@@ -3348,13 +3344,12 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n /* Given a parsed parameter declaration, decode it into a PARM_DECL.  */\n \n tree\n-grokparm (tree parm)\n+grokparm (const struct c_parm *parm)\n {\n-  tree decl = grokdeclarator (TREE_VALUE (TREE_PURPOSE (parm)),\n-\t\t\t      TREE_PURPOSE (TREE_PURPOSE (parm)),\n-\t\t\t      PARM, false, NULL);\n+  tree decl = grokdeclarator (parm->declarator, parm->specs, PARM, false,\n+\t\t\t      NULL);\n \n-  decl_attributes (&decl, TREE_VALUE (parm), 0);\n+  decl_attributes (&decl, parm->attrs, 0);\n \n   return decl;\n }\n@@ -3363,14 +3358,12 @@ grokparm (tree parm)\n    and push that on the current scope.  */\n \n void\n-push_parm_decl (tree parm)\n+push_parm_decl (const struct c_parm *parm)\n {\n   tree decl;\n \n-  decl = grokdeclarator (TREE_VALUE (TREE_PURPOSE (parm)),\n-\t\t\t TREE_PURPOSE (TREE_PURPOSE (parm)),\n-\t\t\t PARM, false, NULL);\n-  decl_attributes (&decl, TREE_VALUE (parm), 0);\n+  decl = grokdeclarator (parm->declarator, parm->specs, PARM, false, NULL);\n+  decl_attributes (&decl, parm->attrs, 0);\n \n   decl = pushdecl (decl);\n \n@@ -3664,7 +3657,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n    and `extern' are interpreted.  */\n \n static tree\n-grokdeclarator (tree declarator, tree declspecs,\n+grokdeclarator (const struct c_declarator *declarator, tree declspecs,\n \t\tenum decl_context decl_context, bool initialized, tree *width)\n {\n   int specbits = 0;\n@@ -3683,41 +3676,42 @@ grokdeclarator (tree declarator, tree declspecs,\n   const char *name, *orig_name;\n   tree typedef_type = 0;\n   int funcdef_flag = 0;\n-  enum tree_code innermost_code = ERROR_MARK;\n+  bool funcdef_syntax = false;\n   int size_varies = 0;\n   tree decl_attr = NULL_TREE;\n   tree array_ptr_quals = NULL_TREE;\n   int array_parm_static = 0;\n   tree returned_attrs = NULL_TREE;\n   bool bitfield = width != NULL;\n   tree element_type;\n-  tree arg_info = NULL_TREE;\n+  struct c_arg_info *arg_info = 0;\n \n   if (decl_context == FUNCDEF)\n     funcdef_flag = 1, decl_context = NORMAL;\n \n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n   {\n-    tree decl = declarator;\n+    const struct c_declarator *decl = declarator;\n     name = 0;\n \n     while (decl)\n-      switch (TREE_CODE (decl))\n+      switch (decl->kind)\n \t{\n-\tcase ARRAY_REF:\n-\tcase INDIRECT_REF:\n-\tcase CALL_EXPR:\n-\t  innermost_code = TREE_CODE (decl);\n-\t  decl = TREE_OPERAND (decl, 0);\n+\tcase cdk_function:\n+\tcase cdk_array:\n+\tcase cdk_pointer:\n+\t  funcdef_syntax = (decl->kind == cdk_function);\n+\t  decl = decl->declarator;\n \t  break;\n \n-\tcase TREE_LIST:\n-\t  decl = TREE_VALUE (decl);\n+\tcase cdk_attrs:\n+\t  decl = decl->declarator;\n \t  break;\n \n-\tcase IDENTIFIER_NODE:\n-\t  name = IDENTIFIER_POINTER (decl);\n+\tcase cdk_id:\n+\t  if (decl->u.id)\n+\t    name = IDENTIFIER_POINTER (decl->u.id);\n \t  decl = 0;\n \t  break;\n \n@@ -3732,7 +3726,7 @@ grokdeclarator (tree declarator, tree declspecs,\n   /* A function definition's declarator must have the form of\n      a function declarator.  */\n \n-  if (funcdef_flag && innermost_code != CALL_EXPR)\n+  if (funcdef_flag && !funcdef_syntax)\n     return 0;\n \n   /* If this looks like a function definition, make it one,\n@@ -4163,22 +4157,22 @@ grokdeclarator (tree declarator, tree declspecs,\n      Descend through it, creating more complex types, until we reach\n      the declared identifier (or NULL_TREE, in an absolute declarator).  */\n \n-  while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE)\n+  while (declarator && declarator->kind != cdk_id)\n     {\n       if (type == error_mark_node)\n \t{\n-\t  declarator = TREE_OPERAND (declarator, 0);\n+\t  declarator = declarator->declarator;\n \t  continue;\n \t}\n \n-      /* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]),\n-\t an INDIRECT_REF (for *...),\n-\t a CALL_EXPR (for ...(...)),\n-\t a TREE_LIST (for nested attributes),\n-\t an identifier (for the name being declared)\n-\t or a null pointer (for the place in an absolute declarator\n+      /* Each level of DECLARATOR is either a cdk_array (for ...[..]),\n+\t a cdk_pointer (for *...),\n+\t a cdk_function (for ...(...)),\n+\t a cdk_attrs (for nested attributes),\n+\t or a cdk_id (for the name being declared\n+\t or the place in an absolute declarator\n \t where the name was omitted).\n-\t For the last two cases, we have just exited the loop.\n+\t For the last case, we have just exited the loop.\n \n \t At this point, TYPE is the type of elements of an array,\n \t or for a function to return, or for a pointer to point to.\n@@ -4196,43 +4190,40 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  array_parm_static = 0;\n \t}\n \n-      switch (TREE_CODE (declarator))\n+      switch (declarator->kind)\n \t{\n-\tcase TREE_LIST:\n+\tcase cdk_attrs:\n \t  {\n-\t    /* We encode a declarator with embedded attributes using a\n-\t       TREE_LIST.  */\n-\t    tree attrs = TREE_PURPOSE (declarator);\n-\t    tree inner_decl;\n+\t    /* A declarator with embedded attributes.  */\n+\t    tree attrs = declarator->u.attrs;\n+\t    const struct c_declarator *inner_decl;\n \t    int attr_flags = 0;\n-\t    declarator = TREE_VALUE (declarator);\n+\t    declarator = declarator->declarator;\n \t    inner_decl = declarator;\n-\t    while (inner_decl != NULL_TREE\n-\t\t   && TREE_CODE (inner_decl) == TREE_LIST)\n-\t      inner_decl = TREE_VALUE (inner_decl);\n-\t    if (inner_decl == NULL_TREE\n-\t\t|| TREE_CODE (inner_decl) == IDENTIFIER_NODE)\n+\t    while (inner_decl->kind == cdk_attrs)\n+\t      inner_decl = inner_decl->declarator;\n+\t    if (inner_decl->kind == cdk_id)\n \t      attr_flags |= (int) ATTR_FLAG_DECL_NEXT;\n-\t    else if (TREE_CODE (inner_decl) == CALL_EXPR)\n+\t    else if (inner_decl->kind == cdk_function)\n \t      attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;\n-\t    else if (TREE_CODE (inner_decl) == ARRAY_REF)\n+\t    else if (inner_decl->kind == cdk_array)\n \t      attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;\n \t    returned_attrs = decl_attributes (&type,\n \t\t\t\t\t      chainon (returned_attrs, attrs),\n \t\t\t\t\t      attr_flags);\n \t    break;\n \t  }\n-\tcase ARRAY_REF:\n+\tcase cdk_array:\n \t  {\n \t    tree itype = NULL_TREE;\n-\t    tree size = TREE_OPERAND (declarator, 1);\n+\t    tree size = declarator->u.array.dimen;\n \t    /* The index is a signed object `sizetype' bits wide.  */\n \t    tree index_type = c_common_signed_type (sizetype);\n \n-\t    array_ptr_quals = TREE_TYPE (declarator);\n-\t    array_parm_static = TREE_STATIC (declarator);\n+\t    array_ptr_quals = declarator->u.array.quals;\n+\t    array_parm_static = declarator->u.array.static_p;\n \t    \n-\t    declarator = TREE_OPERAND (declarator, 0);\n+\t    declarator = declarator->declarator;\n \n \t    /* Check for some types that there cannot be arrays of.  */\n \t    \n@@ -4375,7 +4366,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t\tTYPE_SIZE (type) = bitsize_zero_node;\n \t\tTYPE_SIZE_UNIT (type) = size_zero_node;\n \t      }\n-\t    else if (declarator && TREE_CODE (declarator) == INDIRECT_REF)\n+\t    else if (declarator->kind == cdk_pointer)\n \t      /* We can never complete an array type which is the\n \t         target of a pointer, so go ahead and lay it out.  */\n \t      layout_type (type);\n@@ -4389,7 +4380,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t      }\n \t    break;\n \t  }\n-\tcase CALL_EXPR:\n+\tcase cdk_function:\n \t  {\n \t    /* Say it's a definition only for the declarator closest\n \t       to the identifier, apart possibly from some\n@@ -4398,10 +4389,10 @@ grokdeclarator (tree declarator, tree declspecs,\n \t    tree arg_types;\n \t    if (funcdef_flag)\n \t      {\n-\t\ttree t = TREE_OPERAND (declarator, 0);\n-\t\twhile (TREE_CODE (t) == TREE_LIST)\n-\t\t  t = TREE_VALUE (t);\n-\t\treally_funcdef = (TREE_CODE (t) == IDENTIFIER_NODE);\n+\t\tconst struct c_declarator *t = declarator->declarator;\n+\t\twhile (t->kind == cdk_attrs)\n+\t\t  t = t->declarator;\n+\t\treally_funcdef = (t->kind == cdk_id);\n \t      }\n \n \t    /* Declaring a function type.  Make sure we have a valid\n@@ -4425,7 +4416,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \n \t    /* Construct the function type and go to the next\n \t       inner layer of declarator.  */\n-\t    arg_info = TREE_OPERAND (declarator, 1);\n+\t    arg_info = declarator->u.arg_info;\n \t    arg_types = grokparms (arg_info, really_funcdef);\n \n \t    /* Type qualifiers before the return type of the function\n@@ -4448,22 +4439,22 @@ grokdeclarator (tree declarator, tree declspecs,\n \t    type_quals = TYPE_UNQUALIFIED;\n \t    \n \t    type = build_function_type (type, arg_types);\n-\t    declarator = TREE_OPERAND (declarator, 0);\n+\t    declarator = declarator->declarator;\n \t    \n \t    /* Set the TYPE_CONTEXTs for each tagged type which is local to\n \t       the formal parameter list of this FUNCTION_TYPE to point to\n \t       the FUNCTION_TYPE node itself.  */\n \t    {\n \t      tree link;\n \t      \n-\t      for (link = ARG_INFO_TAGS (arg_info);\n+\t      for (link = arg_info->tags;\n \t\t   link;\n \t\t   link = TREE_CHAIN (link))\n \t\tTYPE_CONTEXT (TREE_VALUE (link)) = type;\n \t    }\n \t    break;\n \t  }\n-\tcase INDIRECT_REF:\n+\tcase cdk_pointer:\n \t  {\n \t    /* Merge any constancy or volatility into the target type\n \t       for the pointer.  */\n@@ -4480,15 +4471,15 @@ grokdeclarator (tree declarator, tree declspecs,\n \t    \n \t    /* Process a list of type modifier keywords (such as const\n \t       or volatile) that were given inside the `*'.  */\n-\t    if (TREE_TYPE (declarator))\n+\t    if (declarator->u.pointer_quals)\n \t      {\n \t\ttree typemodlist;\n \t\tint erred = 0;\n \t\t\n \t\tconstp = 0;\n \t\tvolatilep = 0;\n \t\trestrictp = 0;\n-\t\tfor (typemodlist = TREE_TYPE (declarator); typemodlist;\n+\t\tfor (typemodlist = declarator->u.pointer_quals; typemodlist;\n \t\t     typemodlist = TREE_CHAIN (typemodlist))\n \t\t  {\n \t\t    tree qualifier = TREE_VALUE (typemodlist);\n@@ -4525,7 +4516,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t\t\t      | (volatilep ? TYPE_QUAL_VOLATILE : 0));\n \t      }\n \t    \n-\t    declarator = TREE_OPERAND (declarator, 0);\n+\t    declarator = declarator->declarator;\n \t    break;\n \t  }\n \tdefault:\n@@ -4559,7 +4550,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \tpedwarn (\"ISO C forbids qualified function types\");\n       if (type_quals)\n \ttype = c_build_qualified_type (type, type_quals);\n-      decl = build_decl (TYPE_DECL, declarator, type);\n+      decl = build_decl (TYPE_DECL, declarator->u.id, type);\n       if ((specbits & (1 << (int) RID_SIGNED))\n \t  || (typedef_decl && C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n@@ -4691,7 +4682,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \n \ttype_as_written = type;\n \n-\tdecl = build_decl (PARM_DECL, declarator, type);\n+\tdecl = build_decl (PARM_DECL, declarator->u.id, type);\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n@@ -4728,7 +4719,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  type = build_array_type (c_build_qualified_type (TREE_TYPE (type),\n \t\t\t\t\t\t\t   type_quals),\n \t\t\t\t   TYPE_DOMAIN (type));\n-\tdecl = build_decl (FIELD_DECL, declarator, type);\n+\tdecl = build_decl (FIELD_DECL, declarator->u.id, type);\n \tDECL_NONADDRESSABLE_P (decl) = bitfield;\n \n \tif (size_varies)\n@@ -4755,7 +4746,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t      error (\"invalid storage class for function `%s'\", name);\n \t  }\n \n-\tdecl = build_decl (FUNCTION_DECL, declarator, type);\n+\tdecl = build_decl (FUNCTION_DECL, declarator->u.id, type);\n \tdecl = build_decl_attribute_variant (decl, decl_attr);\n \n \tDECL_LANG_SPECIFIC (decl) = GGC_CNEW (struct lang_decl);\n@@ -4792,7 +4783,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t  C_FUNCTION_IMPLICIT_INT (decl) = 1;\n \n \t/* Record presence of `inline', if it is reasonable.  */\n-\tif (MAIN_NAME_P (declarator))\n+\tif (MAIN_NAME_P (declarator->u.id))\n \t  {\n \t    if (inlinep)\n \t      warning (\"cannot inline function `main'\");\n@@ -4845,8 +4836,8 @@ grokdeclarator (tree declarator, tree declspecs,\n \t   the 'extern' declaration is taken to refer to that decl.) */\n \tif (extern_ref && current_scope != file_scope)\n \t  {\n-\t    tree global_decl  = identifier_global_value (declarator);\n-\t    tree visible_decl = lookup_name (declarator);\n+\t    tree global_decl  = identifier_global_value (declarator->u.id);\n+\t    tree visible_decl = lookup_name (declarator->u.id);\n \n \t    if (global_decl\n \t\t&& global_decl != visible_decl\n@@ -4856,7 +4847,7 @@ grokdeclarator (tree declarator, tree declspecs,\n \t\t     \"'extern'\");\n \t  }\n \n-\tdecl = build_decl (VAR_DECL, declarator, type);\n+\tdecl = build_decl (VAR_DECL, declarator->u.id, type);\n \tif (size_varies)\n \t  C_DECL_VARIABLE_SIZE (decl) = 1;\n \n@@ -4948,9 +4939,9 @@ grokdeclarator (tree declarator, tree declspecs,\n    when FUNCDEF_FLAG is false.  */\n \n static tree\n-grokparms (tree arg_info, bool funcdef_flag)\n+grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n {\n-  tree arg_types = ARG_INFO_TYPES (arg_info);\n+  tree arg_types = arg_info->types;\n \n   if (warn_strict_prototypes && arg_types == 0 && !funcdef_flag\n       && !in_system_header)\n@@ -4964,8 +4955,8 @@ grokparms (tree arg_info, bool funcdef_flag)\n       if (! funcdef_flag)\n \tpedwarn (\"parameter names (without types) in function declaration\");\n \n-      ARG_INFO_PARMS (arg_info) = ARG_INFO_TYPES (arg_info);\n-      ARG_INFO_TYPES (arg_info) = 0;\n+      arg_info->parms = arg_info->types;\n+      arg_info->types = 0;\n       return 0;\n     }\n   else\n@@ -4978,7 +4969,7 @@ grokparms (tree arg_info, bool funcdef_flag)\n \t the scope of the declaration, so the types can never be\n \t completed, and no call can be compiled successfully.  */\n \n-      for (parm = ARG_INFO_PARMS (arg_info), typelt = arg_types, parmno = 1;\n+      for (parm = arg_info->parms, typelt = arg_types, parmno = 1;\n \t   parm;\n \t   parm = TREE_CHAIN (parm), typelt = TREE_CHAIN (typelt), parmno++)\n \t{\n@@ -5015,26 +5006,20 @@ grokparms (tree arg_info, bool funcdef_flag)\n     }\n }\n \n-/* Take apart the current scope and return a tree_list node with info\n-   on a parameter list just parsed.  This tree_list node should be\n-   examined using the ARG_INFO_* macros, defined above:\n-\n-     ARG_INFO_PARMS:  a list of parameter decls.\n-     ARG_INFO_TAGS:   a list of structure, union and enum tags defined.\n-     ARG_INFO_TYPES:  a list of argument types to go in the FUNCTION_TYPE.\n-     ARG_INFO_OTHERS: a list of non-parameter decls (notably enumeration\n-                      constants) defined with the parameters.\n+/* Take apart the current scope and return a c_arg_info structure with\n+   info on a parameter list just parsed.\n \n-   This tree_list node is later fed to 'grokparms' and 'store_parm_decls'.\n+   This structure is later fed to 'grokparms' and 'store_parm_decls'.\n \n    ELLIPSIS being true means the argument list ended in '...' so don't\n    append a sentinel (void_list_node) to the end of the type-list.  */\n \n-tree\n+struct c_arg_info *\n get_parm_info (bool ellipsis)\n {\n   struct c_binding *b = current_scope->bindings;\n-  tree arg_info = make_node (TREE_LIST);\n+  struct c_arg_info *arg_info = XOBNEW (&parser_obstack,\n+\t\t\t\t\tstruct c_arg_info);\n   tree parms    = 0;\n   tree tags     = 0;\n   tree types    = 0;\n@@ -5043,6 +5028,11 @@ get_parm_info (bool ellipsis)\n   static bool explained_incomplete_types = false;\n   bool gave_void_only_once_err = false;\n \n+  arg_info->parms = 0;\n+  arg_info->tags = 0;\n+  arg_info->types = 0;\n+  arg_info->others = 0;\n+\n   /* The bindings in this scope must not get put into a block.\n      We will take care of deleting the binding nodes.  */\n   current_scope->bindings = 0;\n@@ -5070,7 +5060,7 @@ get_parm_info (bool ellipsis)\n       if (ellipsis)\n \terror (\"'void' must be the only parameter\");\n \n-      ARG_INFO_TYPES (arg_info) = void_list_node;\n+      arg_info->types = void_list_node;\n       return arg_info;\n     }\n \n@@ -5191,10 +5181,10 @@ get_parm_info (bool ellipsis)\n       b = free_binding_and_advance (b);\n     }\n \n-  ARG_INFO_PARMS  (arg_info) = parms;\n-  ARG_INFO_TAGS   (arg_info) = tags;\n-  ARG_INFO_TYPES  (arg_info) = types;\n-  ARG_INFO_OTHERS (arg_info) = others;\n+  arg_info->parms = parms;\n+  arg_info->tags = tags;\n+  arg_info->types = types;\n+  arg_info->others = others;\n   return arg_info;\n }\n \f\n@@ -5283,7 +5273,7 @@ start_struct (enum tree_code code, tree name)\n   return ref;\n }\n \n-/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)\n+/* Process the specs, declarator and width (NULL if omitted)\n    of a structure component, returning a FIELD_DECL node.\n    WIDTH is non-NULL for bit-fields only, and is an INTEGER_CST node.\n \n@@ -5292,11 +5282,12 @@ start_struct (enum tree_code code, tree name)\n    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */\n \n tree\n-grokfield (tree declarator, tree declspecs, tree width)\n+grokfield (struct c_declarator *declarator, tree declspecs, tree width)\n {\n   tree value;\n \n-  if (declarator == NULL_TREE && width == NULL_TREE)\n+  if (declarator->kind == cdk_id && declarator->u.id == NULL_TREE\n+      && width == NULL_TREE)\n     {\n       /* This is an unnamed decl.\n \n@@ -5925,7 +5916,8 @@ build_enumerator (tree name, tree value)\n    yyparse to report a parse error.  */\n \n int\n-start_function (tree declspecs, tree declarator, tree attributes)\n+start_function (tree declspecs, struct c_declarator *declarator,\n+\t\ttree attributes)\n {\n   tree decl1, old_decl;\n   tree restype, resdecl;\n@@ -6137,12 +6129,9 @@ start_function (tree declspecs, tree declarator, tree attributes)\n    need only record them as in effect and complain if any redundant\n    old-style parm decls were written.  */\n static void\n-store_parm_decls_newstyle (tree fndecl, tree arg_info)\n+store_parm_decls_newstyle (tree fndecl, const struct c_arg_info *arg_info)\n {\n   tree decl;\n-  tree parms  = ARG_INFO_PARMS  (arg_info);\n-  tree tags   = ARG_INFO_TAGS   (arg_info);\n-  tree others = ARG_INFO_OTHERS (arg_info);\n \n   if (current_scope->bindings)\n     {\n@@ -6158,13 +6147,13 @@ store_parm_decls_newstyle (tree fndecl, tree arg_info)\n      (this happens when a function definition has just an ellipsis in\n      its parameter list).  */\n   else if (warn_traditional && !in_system_header && !current_function_scope\n-\t   && ARG_INFO_TYPES (arg_info) != error_mark_node)\n+\t   && arg_info->types != error_mark_node)\n     warning (\"%Jtraditional C rejects ISO C style function definitions\",\n \t     fndecl);\n \n   /* Now make all the parameter declarations visible in the function body.\n      We can bypass most of the grunt work of pushdecl.  */\n-  for (decl = parms; decl; decl = TREE_CHAIN (decl))\n+  for (decl = arg_info->parms; decl; decl = TREE_CHAIN (decl))\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n@@ -6175,10 +6164,10 @@ store_parm_decls_newstyle (tree fndecl, tree arg_info)\n     }\n \n   /* Record the parameter list in the function declaration.  */\n-  DECL_ARGUMENTS (fndecl) = parms;\n+  DECL_ARGUMENTS (fndecl) = arg_info->parms;\n \n   /* Now make all the ancillary declarations visible, likewise.  */\n-  for (decl = others; decl; decl = TREE_CHAIN (decl))\n+  for (decl = arg_info->others; decl; decl = TREE_CHAIN (decl))\n     {\n       DECL_CONTEXT (decl) = current_function_decl;\n       if (DECL_NAME (decl))\n@@ -6187,7 +6176,7 @@ store_parm_decls_newstyle (tree fndecl, tree arg_info)\n     }\n \n   /* And all the tag declarations.  */\n-  for (decl = tags; decl; decl = TREE_CHAIN (decl))\n+  for (decl = arg_info->tags; decl; decl = TREE_CHAIN (decl))\n     if (TREE_PURPOSE (decl))\n       bind (TREE_PURPOSE (decl), TREE_VALUE (decl), current_scope,\n \t    /*invisible=*/false, /*nested=*/false);\n@@ -6197,11 +6186,11 @@ store_parm_decls_newstyle (tree fndecl, tree arg_info)\n    definitions (separate parameter list and declarations).  */\n \n static void\n-store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n+store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n {\n   struct c_binding *b;\n   tree parm, decl, last;\n-  tree parmids = ARG_INFO_PARMS (arg_info);\n+  tree parmids = arg_info->parms;\n \n   /* We use DECL_WEAK as a flag to show which parameters have been\n      seen already, since it is not used on PARM_DECL.  */\n@@ -6419,7 +6408,7 @@ store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n    function declaration.  */\n \n void\n-store_parm_decls_from (tree arg_info)\n+store_parm_decls_from (struct c_arg_info *arg_info)\n {\n   current_function_arg_info = arg_info;\n   store_parm_decls ();\n@@ -6439,15 +6428,15 @@ store_parm_decls (void)\n   bool proto;\n \n   /* The argument information block for FNDECL.  */\n-  tree arg_info = current_function_arg_info;\n+  struct c_arg_info *arg_info = current_function_arg_info;\n   current_function_arg_info = 0;\n \n   /* True if this definition is written with a prototype.  Note:\n      despite C99 6.7.5.3p14, we can *not* treat an empty argument\n      list in a function definition as equivalent to (void) -- an\n      empty argument list specifies the function has no parameters,\n      but only (void) sets up a prototype for future calls.  */\n-  proto = ARG_INFO_TYPES (arg_info) != 0;\n+  proto = arg_info->types != 0;\n \n   if (proto)\n     store_parm_decls_newstyle (fndecl, arg_info);\n@@ -6865,52 +6854,78 @@ build_void_list_node (void)\n   return t;\n }\n \n-/* Return a structure for a parameter with the given SPECS, ATTRS and\n-   DECLARATOR.  */\n+/* Return a c_parm structure with the given SPECS, ATTRS and DECLARATOR.  */\n \n-tree\n-build_c_parm (tree specs, tree attrs, tree declarator)\n+struct c_parm *\n+build_c_parm (tree specs, tree attrs, struct c_declarator *declarator)\n {\n-  return build_tree_list (build_tree_list (specs, declarator), attrs);\n+  struct c_parm *ret = XOBNEW (&parser_obstack, struct c_parm);\n+  ret->specs = specs;\n+  ret->attrs = attrs;\n+  ret->declarator = declarator;\n+  return ret;\n }\n \n /* Return a declarator with nested attributes.  TARGET is the inner\n    declarator to which these attributes apply.  ATTRS are the\n    attributes.  */\n \n-tree\n-build_attrs_declarator (tree attrs, tree target)\n+struct c_declarator *\n+build_attrs_declarator (tree attrs, struct c_declarator *target)\n {\n-  return tree_cons (attrs, target, NULL_TREE);\n+  struct c_declarator *ret = XOBNEW (&parser_obstack, struct c_declarator);\n+  ret->kind = cdk_attrs;\n+  ret->declarator = target;\n+  ret->u.attrs = attrs;\n+  return ret;\n }\n \n /* Return a declarator for a function with arguments specified by ARGS\n    and return type specified by TARGET.  */\n \n-tree\n-build_function_declarator (tree args, tree target)\n+struct c_declarator *\n+build_function_declarator (struct c_arg_info *args,\n+\t\t\t   struct c_declarator *target)\n {\n-  return build_nt (CALL_EXPR, target, args, NULL_TREE);\n+  struct c_declarator *ret = XOBNEW (&parser_obstack, struct c_declarator);\n+  ret->kind = cdk_function;\n+  ret->declarator = target;\n+  ret->u.arg_info = args;\n+  return ret;\n+}\n+\n+/* Return a declarator for the identifier IDENT (which may be\n+   NULL_TREE for an abstract declarator).  */\n+\n+struct c_declarator *\n+build_id_declarator (tree ident)\n+{\n+  struct c_declarator *ret = XOBNEW (&parser_obstack, struct c_declarator);\n+  ret->kind = cdk_id;\n+  ret->declarator = 0;\n+  ret->u.id = ident;\n+  return ret;\n }\n \n /* Return something to represent absolute declarators containing a *.\n    TARGET is the absolute declarator that the * contains.\n    TYPE_QUALS_ATTRS is a list of modifiers such as const or volatile\n    to apply to the pointer type, represented as identifiers, possible mixed\n-   with attributes.\n+   with attributes.  */\n \n-   We return an INDIRECT_REF whose \"contents\" are TARGET (inside a TREE_LIST,\n-   if attributes are present) and whose type is the modifier list.  */\n-\n-tree\n-make_pointer_declarator (tree type_quals_attrs, tree target)\n+struct c_declarator *\n+make_pointer_declarator (tree type_quals_attrs, struct c_declarator *target)\n {\n   tree quals, attrs;\n-  tree itarget = target;\n+  struct c_declarator *itarget = target;\n+  struct c_declarator *ret = XOBNEW (&parser_obstack, struct c_declarator);\n   split_specs_attrs (type_quals_attrs, &quals, &attrs);\n   if (attrs != NULL_TREE)\n     itarget = build_attrs_declarator (attrs, target);\n-  return build1 (INDIRECT_REF, quals, itarget);\n+  ret->kind = cdk_pointer;\n+  ret->declarator = itarget;\n+  ret->u.pointer_quals = quals;\n+  return ret;\n }\n \n /* Synthesize a function which calls all the global ctors or global"}, {"sha": "9a0b4d27e684634776292287305cba1b582f5df8", "filename": "gcc/c-parse.in", "status": "modified", "additions": 60, "deletions": 28, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -100,6 +100,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n %start program\n \n %union {long itype; tree ttype; void *otype; struct c_expr exprtype;\n+\tstruct c_arg_info *arginfotype; struct c_declarator *dtrtype;\n+\tstruct c_type_name *typenametype; struct c_parm *parmtype;\n \tenum tree_code code; location_t location; }\n \n /* All identifiers that are not reserved words\n@@ -217,25 +219,27 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n %type <ttype> c99_block_start c99_block_lineno_labeled_stmt\n %type <ttype> if_statement_1 if_statement_2\n-%type <ttype> declarator\n-%type <ttype> notype_declarator after_type_declarator\n-%type <ttype> parm_declarator\n-%type <ttype> parm_declarator_starttypename parm_declarator_nostarttypename\n-%type <ttype> array_declarator\n+%type <dtrtype> declarator\n+%type <dtrtype> notype_declarator after_type_declarator\n+%type <dtrtype> parm_declarator\n+%type <dtrtype> parm_declarator_starttypename parm_declarator_nostarttypename\n+%type <dtrtype> array_declarator\n \n %type <ttype> structsp_attr structsp_nonattr\n %type <ttype> component_decl_list component_decl_list2\n %type <ttype> component_decl components components_notype component_declarator\n %type <ttype> component_notype_declarator\n %type <ttype> enumlist enumerator\n %type <ttype> struct_head union_head enum_head\n-%type <ttype> typename absdcl absdcl1 absdcl1_ea absdcl1_noea\n-%type <ttype> direct_absdcl1 absdcl_maybe_attribute\n+%type <typenametype> typename\n+%type <dtrtype> absdcl absdcl1 absdcl1_ea absdcl1_noea direct_absdcl1\n+%type <parmtype> absdcl_maybe_attribute\n %type <ttype> condition xexpr for_cond_expr for_incr_expr\n-%type <ttype> parms parm firstparm identifiers\n+%type <parmtype> parm firstparm\n+%type <ttype> identifiers\n \n-%type <ttype> parmlist parmlist_1 parmlist_2\n-%type <ttype> parmlist_or_identifiers parmlist_or_identifiers_1\n+%type <arginfotype> parms parmlist parmlist_1 parmlist_2\n+%type <arginfotype> parmlist_or_identifiers parmlist_or_identifiers_1\n %type <ttype> identifiers_or_typenames\n \n %type <itype> setspecs setspecs_fp extension\n@@ -655,12 +659,12 @@ primary:\n \t\t  $$.original_code = ERROR_MARK; }\n \t| '(' typename ')' '{'\n \t\t{ start_init (NULL_TREE, NULL, 0);\n-\t\t  $2 = groktypename ($2);\n-\t\t  really_start_incremental_init ($2); }\n+\t\t  $<ttype>$ = groktypename ($2);\n+\t\t  really_start_incremental_init ($<ttype>$); }\n \t  initlist_maybe_comma '}'  %prec UNARY\n \t\t{ struct c_expr init = pop_init_level (0);\n \t\t  tree constructor = init.value;\n-\t\t  tree type = $2;\n+\t\t  tree type = $<ttype>5;\n \t\t  finish_init ();\n \t\t  maybe_warn_string_init (type, init);\n \n@@ -1653,8 +1657,10 @@ after_type_declarator:\n \t| '*' maybe_type_quals_attrs after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t| TYPENAME\n+\t\t{ $$ = build_id_declarator ($1); }\n @@ifobjc\n \t| OBJECTNAME\n+\t\t{ $$ = build_id_declarator ($1); }\n @@end_ifobjc\n \t;\n \n@@ -1673,8 +1679,10 @@ parm_declarator_starttypename:\n \t| parm_declarator_starttypename array_declarator  %prec '.'\n \t\t{ $$ = set_array_declarator_inner ($2, $1, false); }\n \t| TYPENAME\n+\t\t{ $$ = build_id_declarator ($1); }\n @@ifobjc\n \t| OBJECTNAME\n+\t\t{ $$ = build_id_declarator ($1); }\n @@end_ifobjc\n \t;\n \n@@ -1704,6 +1712,7 @@ notype_declarator:\n \t| notype_declarator array_declarator  %prec '.'\n \t\t{ $$ = set_array_declarator_inner ($2, $1, false); }\n \t| IDENTIFIER\n+\t\t{ $$ = build_id_declarator ($1); }\n \t;\n \n struct_head:\n@@ -1837,7 +1846,8 @@ component_decl:\n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C doesn't support unnamed structs/unions\");\n \n-\t\t  $$ = grokfield(NULL, current_declspecs, NULL_TREE);\n+\t\t  $$ = grokfield (build_id_declarator (NULL_TREE),\n+\t\t\t\t  current_declspecs, NULL_TREE);\n \t\t  POP_DECLSPEC_STACK; }\n \t| declspecs_nosc_nots setspecs components_notype\n \t\t{ $$ = $3;\n@@ -1876,7 +1886,8 @@ component_declarator:\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($4, all_prefix_attributes), 0); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2.value);\n+\t\t{ $$ = grokfield (build_id_declarator (NULL_TREE),\n+\t\t\t\t  current_declspecs, $2.value);\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($3, all_prefix_attributes), 0); }\n \t;\n@@ -1891,7 +1902,8 @@ component_notype_declarator:\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($4, all_prefix_attributes), 0); }\n \t| ':' expr_no_commas maybe_attribute\n-\t\t{ $$ = grokfield (NULL_TREE, current_declspecs, $2.value);\n+\t\t{ $$ = grokfield (build_id_declarator (NULL_TREE),\n+\t\t\t\t  current_declspecs, $2.value);\n \t\t  decl_attributes (&$$,\n \t\t\t\t   chainon ($3, all_prefix_attributes), 0); }\n \t;\n@@ -1923,19 +1935,21 @@ typename:\n \t\t{ pending_xref_error ();\n \t\t  $<ttype>$ = $1; }\n \t  absdcl\n-\t\t{ $$ = build_tree_list ($<ttype>2, $3); }\n+\t\t{ $$ = XOBNEW (&parser_obstack, struct c_type_name);\n+\t\t  $$->specs = $<ttype>2;\n+\t\t  $$->declarator = $3; }\n \t;\n \n absdcl:   /* an absolute declarator */\n \t/* empty */\n-\t\t{ $$ = NULL_TREE; }\n+\t\t{ $$ = build_id_declarator (NULL_TREE); }\n \t| absdcl1\n \t;\n \n absdcl_maybe_attribute:   /* absdcl maybe_attribute, but not just attributes */\n \t/* empty */\n \t\t{ $$ = build_c_parm (current_declspecs, all_prefix_attributes,\n-\t\t\t\t     NULL_TREE); }\n+\t\t\t\t     build_id_declarator (NULL_TREE)); }\n \t| absdcl1\n \t\t{ $$ = build_c_parm (current_declspecs, all_prefix_attributes,\n \t\t\t\t     $1); }\n@@ -1958,7 +1972,8 @@ absdcl1_noea:\n \n absdcl1_ea:\n \t  '*' maybe_type_quals_attrs\n-\t\t{ $$ = make_pointer_declarator ($2, NULL_TREE); }\n+\t\t{ $$ = make_pointer_declarator\n+\t\t    ($2, build_id_declarator (NULL_TREE)); }\n \t| '*' maybe_type_quals_attrs absdcl1_ea\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n \t;\n@@ -1971,9 +1986,11 @@ direct_absdcl1:\n \t| direct_absdcl1 array_declarator\n \t\t{ $$ = set_array_declarator_inner ($2, $1, true); }\n \t| '(' parmlist\n-\t\t{ $$ = build_function_declarator ($2, NULL_TREE); }\n+\t\t{ $$ = build_function_declarator\n+\t\t    ($2, build_id_declarator (NULL_TREE)); }\n \t| array_declarator\n-\t\t{ $$ = set_array_declarator_inner ($1, NULL_TREE, true); }\n+\t\t{ $$ = set_array_declarator_inner\n+\t\t    ($1, build_id_declarator (NULL_TREE), true); }\n \t;\n \n /* The [...] part of a declarator for an array type.  */\n@@ -2519,17 +2536,28 @@ parmlist_1:\n \t  parmlist_1\n \t\t{ $$ = $6; }\n \t| error ')'\n-\t\t{ $$ = make_node (TREE_LIST); }\n+\t\t{ $$ = XOBNEW (&parser_obstack, struct c_arg_info);\n+\t\t  $$->parms = 0;\n+\t\t  $$->tags = 0;\n+\t\t  $$->types = 0;\n+\t\t  $$->others = 0; }\n \t;\n \n /* This is what appears inside the parens in a function declarator.\n-   Is value is represented in the format that grokdeclarator expects.  */\n+   Its value is represented in the format that grokdeclarator expects.  */\n parmlist_2:  /* empty */\n-\t\t{ $$ = make_node (TREE_LIST); }\n+\t\t{ $$ = XOBNEW (&parser_obstack, struct c_arg_info);\n+\t\t  $$->parms = 0;\n+\t\t  $$->tags = 0;\n+\t\t  $$->types = 0;\n+\t\t  $$->others = 0; }\n \t| ELLIPSIS\n-\t\t{ $$ = make_node (TREE_LIST); \n+\t\t{ $$ = XOBNEW (&parser_obstack, struct c_arg_info);\n+\t\t  $$->parms = 0;\n+\t\t  $$->tags = 0;\n+\t\t  $$->others = 0;\n \t\t  /* Suppress -Wold-style-definition for this case.  */\n-\t\t  TREE_CHAIN ($$) = error_mark_node;\n+\t\t  $$->types = error_mark_node;\n \t\t  error (\"ISO C requires a named argument before `...'\");\n \t\t}\n \t| parms\n@@ -2614,7 +2642,11 @@ parmlist_or_identifiers:\n parmlist_or_identifiers_1:\n \t  parmlist_1\n \t| identifiers ')'\n-\t\t{ $$ = tree_cons (NULL_TREE, NULL_TREE, $1);\n+\t\t{ $$ = XOBNEW (&parser_obstack, struct c_arg_info);\n+\t\t  $$->parms = 0;\n+\t\t  $$->tags = 0;\n+\t\t  $$->types = $1;\n+\t\t  $$->others = 0;\n \n \t\t  /* Make sure we have a parmlist after attributes.  */\n \t\t  if ($<ttype>-1 != 0)"}, {"sha": "09f679ef8b1e927daad30fd2cdd041663d330159", "filename": "gcc/c-tree.h", "status": "modified", "additions": 98, "deletions": 17, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -131,6 +131,81 @@ struct c_expr\n   enum tree_code original_code;\n };\n \n+/* The various kinds of declarators in C.  */\n+enum c_declarator_kind {\n+  /* An identifier.  */\n+  cdk_id,\n+  /* A function.  */\n+  cdk_function,\n+  /* An array.  */\n+  cdk_array,\n+  /* A pointer.  */\n+  cdk_pointer,\n+  /* Parenthesized declarator with nested attributes.  */\n+  cdk_attrs\n+};\n+\n+/* Information about the parameters in a function declarator.  */\n+struct c_arg_info {\n+  /* A list of parameter decls.  */\n+  tree parms;\n+  /* A list of structure, union and enum tags defined.  */\n+  tree tags;\n+  /* A list of argument types to go in the FUNCTION_TYPE.  */\n+  tree types;\n+  /* A list of non-parameter decls (notably enumeration constants)\n+     defined with the parameters.  */\n+  tree others;\n+};\n+\n+/* A declarator.  */\n+struct c_declarator {\n+  /* The kind of declarator.  */\n+  enum c_declarator_kind kind;\n+  /* Except for cdk_id, the contained declarator.  For cdk_id, NULL.  */\n+  struct c_declarator *declarator;\n+  union {\n+    /* For identifiers, an IDENTIFIER_NODE or NULL_TREE if an abstract\n+       declarator.  */\n+    tree id;\n+    /* For functions.  */\n+    struct c_arg_info *arg_info;\n+    /* For arrays.  */\n+    struct {\n+      /* The array dimension, or NULL for [] and [*].  */\n+      tree dimen;\n+      /* The qualifiers (and attributes, currently ignored) inside [].  */\n+      tree quals;\n+      /* Whether [static] was used.  */\n+      BOOL_BITFIELD static_p : 1;\n+      /* Whether [*] was used.  */\n+      BOOL_BITFIELD vla_unspec_p : 1;\n+    } array;\n+    /* For pointers, the qualifiers on the pointer type.  */\n+    tree pointer_quals;\n+    /* For attributes.  */\n+    tree attrs;\n+  } u;\n+};\n+\n+/* A type name.  */\n+struct c_type_name {\n+  /* The declaration specifiers.  */\n+  tree specs;\n+  /* The declarator.  */\n+  struct c_declarator *declarator;\n+};\n+\n+/* A parameter.  */\n+struct c_parm {\n+  /* The declaration specifiers, minus any prefix attributes.  */\n+  tree specs;\n+  /* The attributes.  */\n+  tree attrs;\n+  /* The declarator.  */\n+  struct c_declarator *declarator;\n+};\n+\n /* Save and restore the variables in this file and elsewhere\n    that keep track of the progress of compilation of the current function.\n    Used for nested functions.  */\n@@ -141,7 +216,7 @@ struct language_function GTY(())\n   tree x_break_label;\n   tree x_cont_label;\n   struct c_switch * GTY((skip)) x_switch_stack;\n-  tree arg_info;\n+  struct c_arg_info * GTY((skip)) arg_info;\n   int returns_value;\n   int returns_null;\n   int returns_abnormally;\n@@ -171,7 +246,7 @@ extern void c_expand_body (tree);\n extern void c_init_decl_processing (void);\n extern void c_dup_lang_specific_decl (tree);\n extern void c_print_identifier (FILE *, tree, int);\n-extern tree build_array_declarator (tree, tree, bool, bool);\n+extern struct c_declarator *build_array_declarator (tree, tree, bool, bool);\n extern tree build_enumerator (tree, tree);\n extern void check_for_loop_decls (void);\n extern void mark_forward_parm_decls (void);\n@@ -184,36 +259,42 @@ extern void finish_decl (tree, tree, tree);\n extern tree finish_enum (tree, tree, tree);\n extern void finish_function (void);\n extern tree finish_struct (tree, tree, tree);\n-extern tree get_parm_info (bool);\n-extern tree grokfield (tree, tree, tree);\n+extern struct c_arg_info *get_parm_info (bool);\n+extern tree grokfield (struct c_declarator *, tree, tree);\n extern void split_specs_attrs (tree, tree *, tree *);\n-extern tree groktypename (tree);\n-extern tree grokparm (tree);\n+extern tree groktypename (struct c_type_name *);\n+extern tree grokparm (const struct c_parm *);\n extern tree implicitly_declare (tree);\n extern void keep_next_level (void);\n extern tree lookup_name (tree);\n extern void pending_xref_error (void);\n extern void c_push_function_context (struct function *);\n extern void c_pop_function_context (struct function *);\n-extern void push_parm_decl (tree);\n+extern void push_parm_decl (const struct c_parm *);\n extern tree pushdecl_top_level (tree);\n-extern tree set_array_declarator_inner (tree, tree, bool);\n+extern struct c_declarator *set_array_declarator_inner (struct c_declarator *,\n+\t\t\t\t\t\t\tstruct c_declarator *,\n+\t\t\t\t\t\t\tbool);\n extern tree builtin_function (const char *, tree, int, enum built_in_class,\n \t\t\t      const char *, tree);\n extern void shadow_tag (tree);\n extern void shadow_tag_warned (tree, int);\n extern tree start_enum (tree);\n-extern int  start_function (tree, tree, tree);\n-extern tree start_decl (tree, tree, bool, tree);\n+extern int  start_function (tree, struct c_declarator *, tree);\n+extern tree start_decl (struct c_declarator *, tree, bool, tree);\n extern tree start_struct (enum tree_code, tree);\n extern void store_parm_decls (void);\n-extern void store_parm_decls_from (tree);\n+extern void store_parm_decls_from (struct c_arg_info *);\n extern tree xref_tag (enum tree_code, tree);\n extern int c_expand_decl (tree);\n-extern tree build_c_parm (tree, tree, tree);\n-extern tree build_attrs_declarator (tree, tree);\n-extern tree build_function_declarator (tree, tree);\n-extern tree make_pointer_declarator (tree, tree);\n+extern struct c_parm *build_c_parm (tree, tree, struct c_declarator *);\n+extern struct c_declarator *build_attrs_declarator (tree,\n+\t\t\t\t\t\t    struct c_declarator *);\n+extern struct c_declarator *build_function_declarator (struct c_arg_info *,\n+\t\t\t\t\t\t       struct c_declarator *);\n+extern struct c_declarator *build_id_declarator (tree);\n+extern struct c_declarator *make_pointer_declarator (tree,\n+\t\t\t\t\t\t     struct c_declarator *);\n \n /* in c-objc-common.c */\n extern int c_disregard_inline_limits (tree);\n@@ -252,13 +333,13 @@ extern tree build_external_ref (tree, int);\n extern void record_maybe_used_decl (tree);\n extern void pop_maybe_used (bool);\n extern struct c_expr c_expr_sizeof_expr (struct c_expr);\n-extern struct c_expr c_expr_sizeof_type (tree);\n+extern struct c_expr c_expr_sizeof_type (struct c_type_name *);\n extern struct c_expr parser_build_binary_op (enum tree_code, struct c_expr,\n \t\t\t\t\t     struct c_expr);\n extern void readonly_error (tree, const char *);\n extern tree build_conditional_expr (tree, tree, tree);\n extern tree build_compound_expr (tree, tree);\n-extern tree c_cast_expr (tree, tree);\n+extern tree c_cast_expr (struct c_type_name *, tree);\n extern tree build_c_cast (tree, tree);\n extern tree build_modify_expr (tree, enum tree_code, tree);\n extern void store_init_value (tree, tree);"}, {"sha": "1bab69565bb5f3139c656e5bab7204f7476eddc5", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -1859,7 +1859,7 @@ c_expr_sizeof_expr (struct c_expr expr)\n    name passed to sizeof (rather than the type itself).  */\n \n struct c_expr\n-c_expr_sizeof_type (tree t)\n+c_expr_sizeof_type (struct c_type_name *t)\n {\n   tree type;\n   struct c_expr ret;\n@@ -3217,15 +3217,16 @@ build_c_cast (tree type, tree expr)\n \n /* Interpret a cast of expression EXPR to type TYPE.  */\n tree\n-c_cast_expr (tree type, tree expr)\n+c_cast_expr (struct c_type_name *type_name, tree expr)\n {\n+  tree type;\n   int saved_wsp = warn_strict_prototypes;\n \n   /* This avoids warnings about unprototyped casts on\n      integers.  E.g. \"#define SIG_DFL (void(*)())0\".  */\n   if (TREE_CODE (expr) == INTEGER_CST)\n     warn_strict_prototypes = 0;\n-  type = groktypename (type);\n+  type = groktypename (type_name);\n   warn_strict_prototypes = saved_wsp;\n \n   return build_c_cast (type, expr);"}, {"sha": "bfee61589e660132b20f4e3e0ecc99e22c7cf160", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -1,3 +1,9 @@\n+2004-09-09  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* objc-act.c (objc_start_function, really_start_method,\n+\tobjc_get_parm_info, start_method_def): Update to new arg_info\n+\tstructures.\n+\n 2004-09-07  Ziemowit Laski  <zlaski@apple.com>\n \n \t* Make-lang.in (objc/objc-parse.o): Depend on $(C_COMMON_H) instead of"}, {"sha": "f115ba44fd1e1548c669054b6a642009c49c6101", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8893e4723c8ce3462bfd1298afde78e5327c260/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=f8893e4723c8ce3462bfd1298afde78e5327c260", "patch": "@@ -156,7 +156,11 @@ static tree start_class (enum tree_code, tree, tree, tree);\n static tree continue_class (tree);\n static void finish_class (tree);\n static void start_method_def (tree);\n+#ifdef OBJCPLUS\n static void objc_start_function (tree, tree, tree, tree);\n+#else\n+static void objc_start_function (tree, tree, tree, struct c_arg_info *);\n+#endif\n static tree start_protocol (enum tree_code, tree, tree);\n static tree build_method_decl (enum tree_code, tree, tree, tree);\n static tree objc_add_method (tree, tree, int);\n@@ -244,12 +248,20 @@ static void encode_gnu_bitfield (int, tree, int);\n static void encode_type (tree, int, int);\n static void encode_field_decl (tree, int, int);\n \n+#ifdef OBJCPLUS\n static void really_start_method (tree, tree);\n+#else\n+static void really_start_method (tree, struct c_arg_info *);\n+#endif\n static int objc_types_are_equivalent (tree, tree);\n static int comp_proto_with_proto (tree, tree);\n static tree get_arg_type_list (tree, int, int);\n static void objc_push_parm (tree);\n+#ifdef OBJCPLUS\n static tree objc_get_parm_info (int);\n+#else\n+static struct c_arg_info *objc_get_parm_info (int);\n+#endif\n static void synth_self_and_ucmd_args (void);\n \n /* Utilities for debugging and error diagnostics.  */\n@@ -7338,16 +7350,22 @@ objc_push_parm (tree parm)\n /* Retrieve the formal paramter list constructed via preceding calls to\n    objc_push_parm().  */\n \n-static tree\n #ifdef OBJCPLUS\n+static tree\n objc_get_parm_info (int have_ellipsis ATTRIBUTE_UNUSED)\n #else\n+static struct c_arg_info *\n objc_get_parm_info (int have_ellipsis)\n #endif\n {\n+#ifdef OBJCPLUS\n   tree parm_info = objc_parmlist;\n+  objc_parmlist = NULL_TREE;\n \n-#ifndef OBJCPLUS\n+  return parm_info;\n+#else\n+  tree parm_info = objc_parmlist;\n+  struct c_arg_info *arg_info;\n   /* The C front-end requires an elaborate song and dance at\n      this point.  */\n   push_scope ();\n@@ -7360,12 +7378,11 @@ objc_get_parm_info (int have_ellipsis)\n       pushdecl (parm_info);\n       parm_info = next;\n     }\n-  parm_info = get_parm_info (have_ellipsis);\n+  arg_info = get_parm_info (have_ellipsis);\n   pop_scope ();\n-#endif\n   objc_parmlist = NULL_TREE;\n-\n-  return parm_info;\n+  return arg_info;\n+#endif\n }\n \n /* Synthesize the formal parameters 'id self' and 'SEL _cmd' needed for ObjC\n@@ -7400,6 +7417,11 @@ static void\n start_method_def (tree method)\n {\n   tree parmlist;\n+#ifdef OBJCPLUS\n+  tree parm_info;\n+#else\n+  struct c_arg_info *parm_info;\n+#endif\n   int have_ellipsis = 0;\n \n   /* Required to implement _msgSuper.  */\n@@ -7434,9 +7456,9 @@ start_method_def (tree method)\n \thave_ellipsis = 1;\n     }\n \n-  parmlist = objc_get_parm_info (have_ellipsis);\n+  parm_info = objc_get_parm_info (have_ellipsis);\n \n-  really_start_method (objc_method_context, parmlist);\n+  really_start_method (objc_method_context, parm_info);\n }\n \n static void\n@@ -7509,11 +7531,19 @@ comp_proto_with_proto (tree proto1, tree proto2)\n }\n \n static void\n-objc_start_function (tree name, tree type, tree attrs, tree params)\n+objc_start_function (tree name, tree type, tree attrs,\n+#ifdef OBJCPLUS\n+\t\t     tree params\n+#else\n+\t\t     struct c_arg_info *params\n+#endif\n+\t\t     )\n {\n   tree fndecl = build_decl (FUNCTION_DECL, name, type);\n \n+#ifdef OBJCPLUS\n   DECL_ARGUMENTS (fndecl) = params;\n+#endif\n   DECL_INITIAL (fndecl) = error_mark_node;\n   DECL_EXTERNAL (fndecl) = 0;\n   TREE_STATIC (fndecl) = 1;\n@@ -7532,7 +7562,7 @@ objc_start_function (tree name, tree type, tree attrs, tree params)\n     = build_decl (RESULT_DECL, NULL_TREE,\n \t\t  TREE_TYPE (TREE_TYPE (current_function_decl)));\n   start_fname_decls ();\n-  store_parm_decls_from (DECL_ARGUMENTS (current_function_decl));\n+  store_parm_decls_from (params);\n #endif\n \n   TREE_USED (current_function_decl) = 1;\n@@ -7545,7 +7575,13 @@ objc_start_function (tree name, tree type, tree attrs, tree params)\n    - If we have a prototype, check for type consistency.  */\n \n static void\n-really_start_method (tree method, tree parmlist)\n+really_start_method (tree method,\n+#ifdef OBJCPLUS\n+\t\t     tree parmlist\n+#else\n+\t\t     struct c_arg_info *parmlist\n+#endif\n+\t\t     )\n {\n   tree ret_type, meth_type;\n   tree method_id;"}]}