{"sha": "d38207955c35124725ee6a92a06b8074851f0a82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDM4MjA3OTU1YzM1MTI0NzI1ZWU2YTkyYTA2YjgwNzQ4NTFmMGE4Mg==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2013-01-29T14:21:40Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-01-29T14:21:40Z"}, "message": "errout.ads, errout.adb (Get_Ignore_Errors): New subprogram.\n\n2013-01-29  Javier Miranda  <miranda@adacore.com>\n\n\t* errout.ads, errout.adb (Get_Ignore_Errors): New subprogram.\n\t* opt.ads (Warn_On_Overlap): Update documentation.\n\t* sem_aggr.adb (Resolve_Aggregate, Resolve_Extension_Aggregate):\n\tCheck function writable actuals.\n\t* sem_ch3.adb (Build_Derived_Record_Type,\n\tRecord_Type_Declaration): Check function writable actuals.\n\t* sem_ch4.adb (Analyze_Range): Check function writable actuals.\n\t* sem_ch5.adb (Analyze_Assignment): Remove code of the initial\n\timplementation of AI05-0144.\n\t* sem_ch6.adb (Analyze_Function_Return,\n\t(Analyze_Procedure_Call.Analyze_Call_And_Resolve): Remove code\n\tof the initial implementation of AI05-0144.\n\t* sem_res.adb (Resolve): Remove code of the initial implementation.\n\t(Resolve_Actuals): Call Check_Function_Writable_Actuals and remove call\n\tof the initial implementation.\n\t(Resolve_Arithmetic_Op, Resolve_Logical_Op,\n\tResolve_Membership_Op): Check function writable actuals.\n\t* sem_util.ad[sb] (Actuals_In_Call): Removed\n\t(Check_Order_Dependence): Removed (Save_Actual): Removed\n\t(Check_Function_Writable_Actuals): New subprogram.\n\t* usage.adb (Usage): Update documentation.\n\t* warnsw.adb (Set_Warning_Switch): Enable warn_on_overlap when\n\tsetting all warnings.\n\nFrom-SVN: r195540", "tree": {"sha": "f452b28b650e2d7ebca465fde894f5d5ca4fd0a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f452b28b650e2d7ebca465fde894f5d5ca4fd0a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d38207955c35124725ee6a92a06b8074851f0a82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38207955c35124725ee6a92a06b8074851f0a82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d38207955c35124725ee6a92a06b8074851f0a82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d38207955c35124725ee6a92a06b8074851f0a82/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54bb89caeab2b2ce71f935e2f290fa1402942529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54bb89caeab2b2ce71f935e2f290fa1402942529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54bb89caeab2b2ce71f935e2f290fa1402942529"}], "stats": {"total": 843, "additions": 667, "deletions": 176}, "files": [{"sha": "f25b41c432106255235d8beebd38eef59f52a6d8", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -1,3 +1,29 @@\n+2013-01-29  Javier Miranda  <miranda@adacore.com>\n+\n+\t* errout.ads, errout.adb (Get_Ignore_Errors): New subprogram.\n+\t* opt.ads (Warn_On_Overlap): Update documentation.\n+\t* sem_aggr.adb (Resolve_Aggregate, Resolve_Extension_Aggregate):\n+\tCheck function writable actuals.\n+\t* sem_ch3.adb (Build_Derived_Record_Type,\n+\tRecord_Type_Declaration): Check function writable actuals.\n+\t* sem_ch4.adb (Analyze_Range): Check function writable actuals.\n+\t* sem_ch5.adb (Analyze_Assignment): Remove code of the initial\n+\timplementation of AI05-0144.\n+\t* sem_ch6.adb (Analyze_Function_Return,\n+\t(Analyze_Procedure_Call.Analyze_Call_And_Resolve): Remove code\n+\tof the initial implementation of AI05-0144.\n+\t* sem_res.adb (Resolve): Remove code of the initial implementation.\n+\t(Resolve_Actuals): Call Check_Function_Writable_Actuals and remove call\n+\tof the initial implementation.\n+\t(Resolve_Arithmetic_Op, Resolve_Logical_Op,\n+\tResolve_Membership_Op): Check function writable actuals.\n+\t* sem_util.ad[sb] (Actuals_In_Call): Removed\n+\t(Check_Order_Dependence): Removed (Save_Actual): Removed\n+\t(Check_Function_Writable_Actuals): New subprogram.\n+\t* usage.adb (Usage): Update documentation.\n+\t* warnsw.adb (Set_Warning_Switch): Enable warn_on_overlap when\n+\tsetting all warnings.\n+\n 2013-01-29  Robert Dewar  <dewar@adacore.com>\n \n \t* a-calend-vms.adb: Minor comment fix."}, {"sha": "d9973eb2cd56d422b81b3dfdd2b8b18f31a480b0", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1458,6 +1458,15 @@ package body Errout is\n       return S;\n    end First_Sloc;\n \n+   -----------------------\n+   -- Get_Ignore_Errors --\n+   -----------------------\n+\n+   function Get_Ignore_Errors return Boolean is\n+   begin\n+      return Errors_Must_Be_Ignored;\n+   end Get_Ignore_Errors;\n+\n    ----------------\n    -- Initialize --\n    ----------------"}, {"sha": "1dd232bed6e566a8c660454be0efb01e5b0a3c35", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -746,6 +746,9 @@ package Errout is\n    --  where the expression is parenthesized, an attempt is made to include\n    --  the parentheses (i.e. to return the location of the initial paren).\n \n+   function Get_Ignore_Errors return Boolean;\n+   --  Return True if all error calls are ignored.\n+\n    procedure Purge_Messages (From : Source_Ptr; To : Source_Ptr)\n      renames Erroutc.Purge_Messages;\n    --  All error messages whose location is in the range From .. To (not"}, {"sha": "e2a97e2d434a8b8916663286fb60b692a18cdaa4", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1595,8 +1595,9 @@ package Opt is\n \n    Warn_On_Overlap : Boolean := False;\n    --  GNAT\n-   --  Set to True to generate warnings when a writable actual which is not\n-   --  a by-copy type overlaps with another actual in a subprogram call.\n+   --  Set to True to generate warnings when a writable actual overlaps with\n+   --  another actual in a subprogram call. This applies only in modes before\n+   --  Ada 2012. Starting with Ada 2012, such overlaps are illegal.\n    --  Modified by use of -gnatw.i/.I.\n \n    Warn_On_Questionable_Missing_Parens : Boolean := True;"}, {"sha": "58f98f5ab9a8d4ed4b4143dcbeafa92010bf4303", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1252,6 +1252,8 @@ package body Sem_Aggr is\n          Set_Etype (N, Aggr_Subtyp);\n          Set_Analyzed (N);\n       end if;\n+\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Aggregate;\n \n    -----------------------------\n@@ -2816,6 +2818,8 @@ package body Sem_Aggr is\n       else\n          Error_Msg_N (\"no unique type for this aggregate\",  A);\n       end if;\n+\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Extension_Aggregate;\n \n    ------------------------------"}, {"sha": "5ccfe801fa9739d88fef1a434cf26f9962a2ff37", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -8061,6 +8061,8 @@ package body Sem_Ch3 is\n          Set_Last_Entity\n            (Class_Wide_Type (Derived_Type), Last_Entity (Derived_Type));\n       end if;\n+\n+      Check_Function_Writable_Actuals (N);\n    end Build_Derived_Record_Type;\n \n    ------------------------\n@@ -19678,6 +19680,8 @@ package body Sem_Ch3 is\n       then\n          Derive_Progenitor_Subprograms (T, T);\n       end if;\n+\n+      Check_Function_Writable_Actuals (N);\n    end Record_Type_Declaration;\n \n    ----------------------------"}, {"sha": "421cd81b5c38f3da01bed453c52de1445add1c3a", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -3611,6 +3611,8 @@ package body Sem_Ch4 is\n          Check_Universal_Expression (L);\n          Check_Universal_Expression (H);\n       end if;\n+\n+      Check_Function_Writable_Actuals (N);\n    end Analyze_Range;\n \n    -----------------------"}, {"sha": "2e8f3a7b2f070642963dbf4074cc9344f58c4aa9", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -692,7 +692,6 @@ package body Sem_Ch5 is\n       --  checks have been applied.\n \n       Note_Possible_Modification (Lhs, Sure => True);\n-      Check_Order_Dependence;\n \n       --  ??? a real accessibility check is needed when ???\n "}, {"sha": "7d67850f6ab5953da95a9f0269bce5c1d2f49205", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -978,10 +978,6 @@ package body Sem_Ch6 is\n                          & \"null-excluding return??\",\n                Reason => CE_Null_Not_Allowed);\n          end if;\n-\n-         --  Apply checks suggested by AI05-0144 (dangerous order dependence)\n-\n-         Check_Order_Dependence;\n       end if;\n    end Analyze_Function_Return;\n \n@@ -1266,11 +1262,6 @@ package body Sem_Ch6 is\n          if Nkind (N) = N_Procedure_Call_Statement then\n             Analyze_Call (N);\n             Resolve (N, Standard_Void_Type);\n-\n-            --  Apply checks suggested by AI05-0144\n-\n-            Check_Order_Dependence;\n-\n          else\n             Analyze (N);\n          end if;"}, {"sha": "9a4084b05f112eeb7725524eacad19aba472a6cc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2864,18 +2864,6 @@ package body Sem_Res is\n             return;\n          end if;\n \n-         --  AI05-144-2: Check dangerous order dependence within an expression\n-         --  that is not a subexpression. Exclude RHS of an assignment, because\n-         --  both sides may have side-effects and the check must be performed\n-         --  over the statement.\n-\n-         if Nkind (Parent (N)) not in N_Subexpr\n-           and then Nkind (Parent (N)) /= N_Assignment_Statement\n-           and then Nkind (Parent (N)) /= N_Procedure_Call_Statement\n-         then\n-            Check_Order_Dependence;\n-         end if;\n-\n          --  The expression is definitely NOT overloaded at this point, so\n          --  we reset the Is_Overloaded flag to avoid any confusion when\n          --  reanalyzing the node.\n@@ -3378,6 +3366,7 @@ package body Sem_Res is\n \n    begin\n       Check_Argument_Order;\n+      Check_Function_Writable_Actuals (N);\n \n       if Present (First_Actual (N)) then\n          Check_Prefixed_Call;\n@@ -3776,21 +3765,6 @@ package body Sem_Res is\n                end if;\n             end if;\n \n-            --  Save actual for subsequent check on order dependence, and\n-            --  indicate whether actual is modifiable. For AI05-0144-2.\n-\n-            --  If this is a call to a reference function that is the result\n-            --  of expansion, as in element iterator loops, this does not lead\n-            --  to a dangerous order dependence: only subsequent use of the\n-            --  denoted element might, in some enclosing call.\n-\n-            if not Has_Implicit_Dereference (Etype (Nam))\n-              or else Comes_From_Source (N)\n-            then\n-               Save_Actual (A, Ekind (F) /= E_In_Parameter);\n-            end if;\n-\n-            --  For mode IN, if actual is an entity, and the type of the formal\n             --  has warnings suppressed, then we reset Never_Set_In_Source for\n             --  the calling entity. The reason for this is to catch cases like\n             --  GNAT.Spitbol.Patterns.Vstring_Var where the called subprogram\n@@ -5108,6 +5082,7 @@ package body Sem_Res is\n \n       Check_Unset_Reference (L);\n       Check_Unset_Reference (R);\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Arithmetic_Op;\n \n    ------------------\n@@ -7632,6 +7607,8 @@ package body Sem_Res is\n             end if;\n          end;\n       end if;\n+\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Logical_Op;\n \n    ---------------------------\n@@ -7729,6 +7706,7 @@ package body Sem_Res is\n \n       if Present (Alternatives (N)) then\n          Resolve_Set_Membership;\n+         Check_Function_Writable_Actuals (N);\n          return;\n \n       elsif not Is_Overloaded (R)\n@@ -7793,6 +7771,7 @@ package body Sem_Res is\n       end if;\n \n       Eval_Membership_Op (N);\n+      Check_Function_Writable_Actuals (N);\n    end Resolve_Membership_Op;\n \n    ------------------"}, {"sha": "c467f50ac9f29b606a8fbfc8be9f868472893f94", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 585, "deletions": 114, "changes": 699, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -57,7 +57,6 @@ with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Style;\n with Stringt;  use Stringt;\n-with Table;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -96,30 +95,6 @@ package body Sem_Util is\n    subtype NCT_Header_Num is Int range 0 .. 511;\n    --  Defines range of headers in hash tables (512 headers)\n \n-   ----------------------------------\n-   -- Order Dependence (AI05-0144) --\n-   ----------------------------------\n-\n-   --  Each actual in a call is entered into the table below. A flag indicates\n-   --  whether the corresponding formal is OUT or IN OUT. Each top-level call\n-   --  (procedure call, condition, assignment) examines all the actuals for a\n-   --  possible order dependence. The table is reset after each such check.\n-   --  The actuals to be checked in a call to Check_Order_Dependence are at\n-   --  positions 1 .. Last.\n-\n-   type Actual_Name is record\n-      Act         : Node_Id;\n-      Is_Writable : Boolean;\n-   end record;\n-\n-   package Actuals_In_Call is new Table.Table (\n-      Table_Component_Type => Actual_Name,\n-      Table_Index_Type     => Int,\n-      Table_Low_Bound      => 0,\n-      Table_Initial        => 10,\n-      Table_Increment      => 100,\n-      Table_Name           => \"Actuals\");\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -1245,6 +1220,590 @@ package body Sem_Util is\n       end if;\n    end Cannot_Raise_Constraint_Error;\n \n+   -------------------------------------\n+   -- Check_Function_Writable_Actuals --\n+   -------------------------------------\n+\n+   procedure Check_Function_Writable_Actuals (N : Node_Id) is\n+      Writable_Actuals_List : Elist_Id := No_Elist;\n+      Identifiers_List      : Elist_Id := No_Elist;\n+      Error_Node            : Node_Id  := Empty;\n+\n+      procedure Collect_Identifiers (N : Node_Id);\n+      --  In a single traversal of subtree N collect in Writable_Actuals_List\n+      --  all the actuals of functions with writable actuals, and in the list\n+      --  Identifiers_List collect all the identifiers that are not actuals of\n+      --  functions with writable actuals. If a writable actual is referenced\n+      --  twice as writable actual then Error_Node is set to reference its\n+      --  second occurrence, the error is reported, and the tree traversal\n+      --  is abandoned.\n+\n+      function Get_Function_Id (Call : Node_Id) return Entity_Id;\n+      --  Return the entity associated with the function call\n+\n+      procedure Preanalyze_Without_Errors (N : Node_Id);\n+      --  Preanalyze N without reporting errors\n+\n+      -------------------------\n+      -- Collect_Identifiers --\n+      -------------------------\n+\n+      procedure Collect_Identifiers (N : Node_Id) is\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result;\n+         --  Process a single node during the tree traversal to collect the\n+         --  writable actuals of functions and all the identifiers which are\n+         --  not writable actuals of functions.\n+\n+         function Contains (List : Elist_Id; N : Node_Id) return Boolean;\n+         --  Returns True if List has a node whose Entity is Entity (N)\n+\n+         -------------------------\n+         -- Check_Function_Call --\n+         -------------------------\n+\n+         function Check_Node (N : Node_Id) return Traverse_Result is\n+            Is_Writable_Actual : Boolean := False;\n+\n+         begin\n+            if Nkind (N) = N_Identifier then\n+\n+               --  No analysis possible if the entity is not decorated\n+\n+               if No (Entity (N)) then\n+                  return Skip;\n+\n+               --  We don't collect identifiers of packages, called functions,\n+               --  etc.\n+\n+               elsif Ekind_In (Entity (N),\n+                       E_Package,\n+                       E_Function,\n+                       E_Procedure,\n+                       E_Entry)\n+               then\n+                  return Skip;\n+\n+               --  Analyze if N is a writable actual of a function\n+\n+               elsif Nkind (Parent (N)) = N_Function_Call then\n+                  declare\n+                     Call   : constant Node_Id   := Parent (N);\n+                     Id     : constant Entity_Id := Get_Function_Id (Call);\n+                     Actual : Node_Id;\n+                     Formal : Node_Id;\n+\n+                  begin\n+                     Formal := First_Formal (Id);\n+                     Actual := First_Actual (Call);\n+                     while Present (Actual) and then Present (Formal) loop\n+                        if Actual = N then\n+                           if Ekind_In (Formal, E_Out_Parameter,\n+                                                E_In_Out_Parameter)\n+                           then\n+                              Is_Writable_Actual := True;\n+                           end if;\n+\n+                           exit;\n+                        end if;\n+\n+                        Next_Formal (Formal);\n+                        Next_Actual (Actual);\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               if Is_Writable_Actual then\n+                  if Contains (Writable_Actuals_List, N) then\n+                     Error_Msg_N\n+                       (\"conflict of writable function parameter in \"\n+                        & \"construct with arbitrary order of evaluation\", N);\n+                     Error_Node := N;\n+                     return Abandon;\n+                  end if;\n+\n+                  if Writable_Actuals_List = No_Elist then\n+                     Writable_Actuals_List := New_Elmt_List;\n+                  end if;\n+\n+                  Append_Elmt (N, Writable_Actuals_List);\n+               else\n+                  if Identifiers_List = No_Elist then\n+                     Identifiers_List := New_Elmt_List;\n+                  end if;\n+\n+                  Append_Unique_Elmt (N, Identifiers_List);\n+               end if;\n+            end if;\n+\n+            return OK;\n+         end Check_Node;\n+\n+         --------------\n+         -- Contains --\n+         --------------\n+\n+         function Contains\n+           (List : Elist_Id;\n+            N    : Node_Id) return Boolean\n+         is\n+            pragma Assert (Nkind (N) in N_Has_Entity);\n+\n+            Elmt : Elmt_Id;\n+         begin\n+            if List = No_Elist then\n+               return False;\n+            end if;\n+\n+            Elmt := First_Elmt (List);\n+            loop\n+               if No (Elmt) then\n+                  return False;\n+               elsif Entity (Node (Elmt)) = Entity (N) then\n+                  return True;\n+               else\n+                  Next_Elmt (Elmt);\n+               end if;\n+            end loop;\n+         end Contains;\n+\n+         ------------------\n+         -- Do_Traversal --\n+         ------------------\n+\n+         procedure Do_Traversal is new Traverse_Proc (Check_Node);\n+         --  The traversal procedure\n+\n+      --  Start of processing for Collect_Identifiers\n+\n+      begin\n+         if Present (Error_Node) then\n+            return;\n+         end if;\n+\n+         if Nkind (N) in N_Subexpr\n+           and then Is_Static_Expression (N)\n+         then\n+            return;\n+         end if;\n+\n+         Do_Traversal (N);\n+      end Collect_Identifiers;\n+\n+      ---------------------\n+      -- Get_Function_Id --\n+      ---------------------\n+\n+      function Get_Function_Id (Call : Node_Id) return Entity_Id is\n+         Nam : constant Node_Id := Name (Call);\n+         Id  : Entity_Id;\n+      begin\n+         if Nkind (Nam) = N_Explicit_Dereference then\n+            Id := Etype (Nam);\n+            pragma Assert (Ekind (Id) = E_Subprogram_Type);\n+\n+         elsif Nkind (Nam) = N_Selected_Component then\n+            Id := Entity (Selector_Name (Nam));\n+\n+         elsif Nkind (Nam) = N_Indexed_Component then\n+            Id := Entity (Selector_Name (Prefix (Nam)));\n+\n+         else\n+            Id := Entity (Nam);\n+         end if;\n+\n+         return Id;\n+      end Get_Function_Id;\n+\n+      ---------------------------\n+      -- Preanalyze_Expression --\n+      ---------------------------\n+\n+      procedure Preanalyze_Without_Errors (N : Node_Id) is\n+         Status : constant Boolean := Get_Ignore_Errors;\n+      begin\n+         Set_Ignore_Errors (True);\n+         Preanalyze (N);\n+         Set_Ignore_Errors (Status);\n+      end Preanalyze_Without_Errors;\n+\n+   --  Start of processing for Check_Function_Writable_Actuals\n+\n+   begin\n+      if Ada_Version < Ada_2012\n+        or else (not (Nkind (N) in N_Op)\n+                   and then not (Nkind (N) in N_Membership_Test)\n+                   and then not Nkind_In (N,\n+                                  N_Range,\n+                                  N_Aggregate,\n+                                  N_Extension_Aggregate,\n+                                  N_Full_Type_Declaration,\n+                                  N_Function_Call,\n+                                  N_Procedure_Call_Statement,\n+                                  N_Entry_Call_Statement))\n+        or else (Nkind (N) = N_Full_Type_Declaration\n+                   and then not Is_Record_Type (Defining_Identifier (N)))\n+      then\n+         return;\n+      end if;\n+\n+      --  If a construct C has two or more direct constituents that are names\n+      --  or expressions whose evaluation may occur in an arbitrary order, at\n+      --  least one of which contains a function call with an in out or out\n+      --  parameter, then the construct is legal only if: for each name N that\n+      --  is passed as a parameter of mode in out or out to some inner function\n+      --  call C2 (not including the construct C itself), there is no other\n+      --  name anywhere within a direct constituent of the construct C other\n+      --  than the one containing C2, that is known to refer to the same\n+      --  object (RM 6.4.1(6.17/3)).\n+\n+      case Nkind (N) is\n+         when N_Range =>\n+            Collect_Identifiers (Low_Bound (N));\n+            Collect_Identifiers (High_Bound (N));\n+\n+         when N_Op | N_Membership_Test =>\n+            declare\n+               Expr : Node_Id;\n+            begin\n+               Collect_Identifiers (Left_Opnd (N));\n+\n+               if Present (Right_Opnd (N)) then\n+                  Collect_Identifiers (Right_Opnd (N));\n+               end if;\n+\n+               if Nkind_In (N, N_In, N_Not_In)\n+                 and then Present (Alternatives (N))\n+               then\n+                  Expr := First (Alternatives (N));\n+                  while Present (Expr) loop\n+                     Collect_Identifiers (Expr);\n+\n+                     Next (Expr);\n+                  end loop;\n+               end if;\n+            end;\n+\n+         when N_Full_Type_Declaration =>\n+            declare\n+               function Get_Record_Part (N : Node_Id) return Node_Id;\n+               --  Return the record part of this record type definition\n+\n+               function Get_Record_Part (N : Node_Id) return Node_Id is\n+                  Type_Def : constant Node_Id := Type_Definition (N);\n+               begin\n+                  if Nkind (Type_Def) = N_Derived_Type_Definition then\n+                     return Record_Extension_Part (Type_Def);\n+                  else\n+                     return Type_Def;\n+                  end if;\n+               end Get_Record_Part;\n+\n+               Comp   : Node_Id;\n+               Def_Id : Entity_Id := Defining_Identifier (N);\n+               Rec    : Node_Id   := Get_Record_Part (N);\n+            begin\n+               --  No need to perform any analysis if the record has no\n+               --  components\n+\n+               if No (Rec) or else No (Component_List (Rec)) then\n+                  return;\n+               end if;\n+\n+               --  Collect the identifiers starting from the deepest\n+               --  derivation. Done to report the error in the deepest\n+               --  derivation.\n+\n+               loop\n+                  if Present (Component_List (Rec)) then\n+                     Comp := First (Component_Items (Component_List (Rec)));\n+                     while Present (Comp) loop\n+                        if Nkind (Comp) = N_Component_Declaration\n+                          and then Present (Expression (Comp))\n+                        then\n+                           Collect_Identifiers (Expression (Comp));\n+                        end if;\n+\n+                        Next (Comp);\n+                     end loop;\n+                  end if;\n+\n+                  exit when No (Underlying_Type (Etype (Def_Id)))\n+                    or else Base_Type (Underlying_Type (Etype (Def_Id)))\n+                              = Def_Id;\n+\n+                  Def_Id := Base_Type (Underlying_Type (Etype (Def_Id)));\n+                  Rec := Get_Record_Part (Parent (Def_Id));\n+               end loop;\n+            end;\n+\n+         when N_Subprogram_Call      |\n+              N_Entry_Call_Statement =>\n+            declare\n+               Id     : constant Entity_Id := Get_Function_Id (N);\n+               Formal : Node_Id;\n+               Actual : Node_Id;\n+\n+            begin\n+               Formal := First_Formal (Id);\n+               Actual := First_Actual (N);\n+               while Present (Actual) and then Present (Formal) loop\n+                  if Ekind_In (Formal, E_Out_Parameter,\n+                                       E_In_Out_Parameter)\n+                  then\n+                     Collect_Identifiers (Actual);\n+                  end if;\n+\n+                  Next_Formal (Formal);\n+                  Next_Actual (Actual);\n+               end loop;\n+            end;\n+\n+         when N_Aggregate           |\n+              N_Extension_Aggregate =>\n+            declare\n+               Assoc     : Node_Id;\n+               Choice    : Node_Id;\n+               Comp_Expr : Node_Id;\n+\n+            begin\n+               --  Handle the N_Others_Choice of array aggregates with static\n+               --  bounds. There is no need to perform this analysis in\n+               --  aggregates without static bounds since we cannot evaluate\n+               --  if the N_Others_Choice covers several elements. There is\n+               --  no need to handle the N_Others choice of record aggregates\n+               --  since at this stage it has been already expanded by\n+               --  Resolve_Record_Aggregate.\n+\n+               if Is_Array_Type (Etype (N))\n+                 and then Nkind (N) = N_Aggregate\n+                 and then Present (Aggregate_Bounds (N))\n+                 and then Compile_Time_Known_Bounds (Etype (N))\n+                 and then Expr_Value (High_Bound (Aggregate_Bounds (N)))\n+                            > Expr_Value (Low_Bound (Aggregate_Bounds (N)))\n+               then\n+                  declare\n+                     Count_Components   : Uint := Uint_0;\n+                     Num_Components     : Uint;\n+                     Others_Assoc       : Node_Id;\n+                     Others_Choice      : Node_Id := Empty;\n+                     Others_Box_Present : Boolean := False;\n+\n+                  begin\n+                     --  Count positional associations\n+\n+                     if Present (Expressions (N)) then\n+                        Comp_Expr := First (Expressions (N));\n+                        while Present (Comp_Expr) loop\n+                           Count_Components := Count_Components + 1;\n+                           Next (Comp_Expr);\n+                        end loop;\n+                     end if;\n+\n+                     --  Count the rest of elements and locate the N_Others\n+                     --  choice (if any)\n+\n+                     Assoc := First (Component_Associations (N));\n+                     while Present (Assoc) loop\n+                        Choice := First (Choices (Assoc));\n+                        while Present (Choice) loop\n+                           if Nkind (Choice) = N_Others_Choice then\n+                              Others_Assoc       := Assoc;\n+                              Others_Choice      := Choice;\n+                              Others_Box_Present := Box_Present (Assoc);\n+\n+                           --  Count several components\n+\n+                           elsif Nkind_In (Choice, N_Range,\n+                                                   N_Subtype_Indication)\n+                             or else (Is_Entity_Name (Choice)\n+                                        and then Is_Type (Entity (Choice)))\n+                           then\n+                              declare\n+                                 L, H : Node_Id;\n+                              begin\n+                                 Get_Index_Bounds (Choice, L, H);\n+                                 pragma Assert\n+                                   (Compile_Time_Known_Value (L)\n+                                      and then Compile_Time_Known_Value (H));\n+                                 Count_Components :=\n+                                   Count_Components\n+                                     + Expr_Value (H) - Expr_Value (L) + 1;\n+                              end;\n+\n+                           --  Count single component. No other case available\n+                           --  since we are handling an aggregate with static\n+                           --  bounds.\n+\n+                           else\n+                              pragma Assert (Is_Static_Expression (Choice)\n+                                or else Nkind (Choice) = N_Identifier\n+                                or else Nkind (Choice) = N_Integer_Literal);\n+\n+                              Count_Components := Count_Components + 1;\n+                           end if;\n+\n+                           Next (Choice);\n+                        end loop;\n+\n+                        Next (Assoc);\n+                     end loop;\n+\n+                     Num_Components :=\n+                       Expr_Value (High_Bound (Aggregate_Bounds (N)))\n+                         - Expr_Value (Low_Bound (Aggregate_Bounds (N)))\n+                         + 1;\n+\n+                     pragma Assert (Count_Components <= Num_Components);\n+\n+                     --  Handle the N_Others choice if it covers several\n+                     --  components\n+\n+                     if Present (Others_Choice)\n+                       and then (Num_Components - Count_Components) > 1\n+                     then\n+                        if not Others_Box_Present then\n+\n+                           --  At this stage, if expansion is active, the\n+                           --  expression of the others choice has not been\n+                           --  analyzed. Hence we generate a duplicate and\n+                           --  we analyze it silently to have available the\n+                           --  minimum decoration required to collect the\n+                           --  identifiers.\n+\n+                           if not Expander_Active then\n+                              Comp_Expr := Expression (Others_Assoc);\n+                           else\n+                              Comp_Expr :=\n+                                New_Copy_Tree (Expression (Others_Assoc));\n+                              Preanalyze_Without_Errors (Comp_Expr);\n+                           end if;\n+\n+                           Collect_Identifiers (Comp_Expr);\n+\n+                           if Writable_Actuals_List /= No_Elist then\n+\n+                              --  As suggested by Robert, at current stage we\n+                              --  report occurrences of this case as warnings.\n+\n+                              Error_Msg_N\n+                                (\"conflict of writable function parameter in \"\n+                                 & \"construct with arbitrary order of \"\n+                                 & \"evaluation?\",\n+                                 Node (First_Elmt (Writable_Actuals_List)));\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end;\n+               end if;\n+\n+               --  Handle ancestor part of extension aggregates\n+\n+               if Nkind (N) = N_Extension_Aggregate then\n+                  Collect_Identifiers (Ancestor_Part (N));\n+               end if;\n+\n+               --  Handle positional associations\n+\n+               if Present (Expressions (N)) then\n+                  Comp_Expr := First (Expressions (N));\n+                  while Present (Comp_Expr) loop\n+                     if not Is_Static_Expression (Comp_Expr) then\n+                        Collect_Identifiers (Comp_Expr);\n+                     end if;\n+\n+                     Next (Comp_Expr);\n+                  end loop;\n+               end if;\n+\n+               --  Handle discrete associations\n+\n+               if Present (Component_Associations (N)) then\n+                  Assoc := First (Component_Associations (N));\n+                  while Present (Assoc) loop\n+\n+                     if not Box_Present (Assoc) then\n+                        Choice := First (Choices (Assoc));\n+                        while Present (Choice) loop\n+\n+                           --  For now we skip discriminants since it requires\n+                           --  performing the analysis in two phases: first one\n+                           --  analyzing discriminants and second one analyzing\n+                           --  the rest of components since discriminants are\n+                           --  evaluated prior to components: too much extra\n+                           --  work to detect a corner case???\n+\n+                           if Nkind (Choice) in N_Has_Entity\n+                             and then Present (Entity (Choice))\n+                             and then Ekind (Entity (Choice))\n+                                        = E_Discriminant\n+                           then\n+                              null;\n+\n+                           elsif Box_Present (Assoc) then\n+                              null;\n+\n+                           else\n+                              if not Analyzed (Expression (Assoc)) then\n+                                 Comp_Expr :=\n+                                   New_Copy_Tree (Expression (Assoc));\n+                                 Preanalyze_Without_Errors (Comp_Expr);\n+                              else\n+                                 Comp_Expr := Expression (Assoc);\n+                              end if;\n+\n+                              Collect_Identifiers (Comp_Expr);\n+                           end if;\n+\n+                           Next (Choice);\n+                        end loop;\n+                     end if;\n+\n+                     Next (Assoc);\n+                  end loop;\n+               end if;\n+            end;\n+\n+         when others =>\n+            return;\n+      end case;\n+\n+      --  No further action needed if we already reported an error\n+\n+      if Present (Error_Node) then\n+         return;\n+      end if;\n+\n+      --  Check if some writable argument of a function is referenced\n+\n+      if Writable_Actuals_List /= No_Elist\n+        and then Identifiers_List /= No_Elist\n+      then\n+         declare\n+            Elmt_1 : Elmt_Id;\n+            Elmt_2 : Elmt_Id;\n+\n+         begin\n+            Elmt_1 := First_Elmt (Writable_Actuals_List);\n+            while Present (Elmt_1) loop\n+               Elmt_2 := First_Elmt (Identifiers_List);\n+               while Present (Elmt_2) loop\n+                  if Entity (Node (Elmt_1)) = Entity (Node (Elmt_2)) then\n+                     Error_Msg_N\n+                       (\"conflict of writable function parameter in construct \"\n+                        & \"with arbitrary order of evaluation\",\n+                        Node (Elmt_1));\n+                  end if;\n+\n+                  Next_Elmt (Elmt_2);\n+               end loop;\n+\n+               Next_Elmt (Elmt_1);\n+            end loop;\n+         end;\n+      end if;\n+   end Check_Function_Writable_Actuals;\n+\n    --------------------------------\n    -- Check_Implicit_Dereference --\n    --------------------------------\n@@ -1529,65 +2088,6 @@ package body Sem_Util is\n       end if;\n    end Check_Nested_Access;\n \n-   ----------------------------\n-   -- Check_Order_Dependence --\n-   ----------------------------\n-\n-   procedure Check_Order_Dependence is\n-      Act1 : Node_Id;\n-      Act2 : Node_Id;\n-\n-   begin\n-      if Ada_Version < Ada_2012 then\n-         return;\n-      end if;\n-\n-      --  Ada 2012 AI05-0144-2: Dangerous order dependence. Actuals in nested\n-      --  calls within a construct have been collected. If one of them is\n-      --  writable and overlaps with another one, evaluation of the enclosing\n-      --  construct is nondeterministic. This is illegal in Ada 2012, but is\n-      --  treated as a warning for now.\n-\n-      for J in 1 .. Actuals_In_Call.Last loop\n-         if Actuals_In_Call.Table (J).Is_Writable then\n-            Act1 := Actuals_In_Call.Table (J).Act;\n-\n-            if Nkind (Act1) = N_Attribute_Reference then\n-               Act1 := Prefix (Act1);\n-            end if;\n-\n-            for K in 1 .. Actuals_In_Call.Last loop\n-               if K /= J then\n-                  Act2 := Actuals_In_Call.Table (K).Act;\n-\n-                  if Nkind (Act2) = N_Attribute_Reference then\n-                     Act2 := Prefix (Act2);\n-                  end if;\n-\n-                  if Actuals_In_Call.Table (K).Is_Writable\n-                    and then K < J\n-                  then\n-                     --  Already checked\n-\n-                     null;\n-\n-                  elsif Denotes_Same_Object (Act1, Act2)\n-                    and then Parent (Act1) /= Parent (Act2)\n-                  then\n-                     Error_Msg_N\n-                       (\"result may differ if evaluated \"\n-                        & \"after other actual in expression??\", Act1);\n-                  end if;\n-               end if;\n-            end loop;\n-         end if;\n-      end loop;\n-\n-      --  Remove checked actuals from table\n-\n-      Actuals_In_Call.Set_Last (0);\n-   end Check_Order_Dependence;\n-\n    ------------------------------------------\n    -- Check_Potentially_Blocking_Operation --\n    ------------------------------------------\n@@ -12595,35 +13095,6 @@ package body Sem_Util is\n       end if;\n    end Same_Value;\n \n-   -----------------\n-   -- Save_Actual --\n-   -----------------\n-\n-   procedure Save_Actual (N : Node_Id;  Writable : Boolean := False) is\n-   begin\n-      if Ada_Version < Ada_2012 then\n-         return;\n-\n-      elsif Is_Entity_Name (N)\n-        or else\n-          Nkind_In (N, N_Indexed_Component, N_Selected_Component, N_Slice)\n-        or else\n-          (Nkind (N) = N_Attribute_Reference\n-            and then Attribute_Name (N) = Name_Access)\n-\n-      then\n-         --  We are only interested in IN OUT parameters of inner calls\n-\n-         if not Writable\n-           or else Nkind (Parent (N)) = N_Function_Call\n-           or else Nkind (Parent (N)) in N_Op\n-         then\n-            Actuals_In_Call.Increment_Last;\n-            Actuals_In_Call.Table (Actuals_In_Call.Last) := (N, Writable);\n-         end if;\n-      end if;\n-   end Save_Actual;\n-\n    ------------------------\n    -- Scope_Is_Transient --\n    ------------------------"}, {"sha": "0a9ff0af8f5b7a7084e780dd978cf9b270662805", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -178,6 +178,17 @@ package Sem_Util is\n    --  not necessarily mean that CE could be raised, but a response of True\n    --  means that for sure CE cannot be raised.\n \n+   procedure Check_Function_Writable_Actuals (N : Node_Id);\n+   --  (Ada 2012): If the construct N has two or more direct constituents that\n+   --  are names or expressions whose evaluation may occur in an arbitrary\n+   --  order, at least one of which contains a function call with an in out or\n+   --  out parameter, then the construct is legal only if: for each name that\n+   --  is passed as a parameter of mode in out or out to some inner function\n+   --  call C2 (not including the construct N itself), there is no other name\n+   --  anywhere within a direct constituent of the construct C other than\n+   --  the one containing C2, that is known to refer to the same object (RM\n+   --  6.4.1(6.17/3)).\n+\n    procedure Check_Implicit_Dereference (Nam : Node_Id; Typ : Entity_Id);\n    --  AI05-139-2: Accessors and iterators for containers. This procedure\n    --  checks whether T is a reference type, and if so it adds an interprettion\n@@ -215,11 +226,6 @@ package Sem_Util is\n    --  is accessed inside a nested procedure, and set Has_Up_Level_Access flag\n    --  accordingly. This is currently only enabled for VM_Target /= No_VM.\n \n-   procedure Check_Order_Dependence;\n-   --  Examine the actuals in a top-level call to determine whether aliasing\n-   --  between two actuals, one of which is writable, can make the call\n-   --  order-dependent.\n-\n    procedure Check_Potentially_Blocking_Operation (N : Node_Id);\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n@@ -1404,11 +1410,6 @@ package Sem_Util is\n    --  are only partially ordered, so Scope_Within_Or_Same (A,B) and\n    --  Scope_Within_Or_Same (B,A) can both be False for a given pair A,B.\n \n-   procedure Save_Actual (N : Node_Id; Writable : Boolean := False);\n-   --  Enter an actual in a call in a table global, for subsequent check of\n-   --  possible order dependence in the presence of IN OUT parameters for\n-   --  functions in Ada 2012 (or access parameters in older language versions).\n-\n    function Scope_Within (Scope1, Scope2 : Entity_Id) return Boolean;\n    --  Like Scope_Within_Or_Same, except that this function returns\n    --  False in the case where Scope1 and Scope2 are the same scope."}, {"sha": "08a41c280694807452c7a4d5c576a47720de456c", "filename": "gcc/ada/usage.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fusage.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fusage.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fusage.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                B o d y                                   --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -502,8 +502,8 @@ begin\n    Write_Line (\"        .H*  turn off warnings for holes in records\");\n    Write_Line (\"        i*+  turn on warnings for implementation unit\");\n    Write_Line (\"        I    turn off warnings for implementation unit\");\n-   Write_Line (\"        .i   turn on warnings for overlapping actuals\");\n-   Write_Line (\"        .I*  turn off warnings for overlapping actuals\");\n+   Write_Line (\"        .i*+ turn on warnings for overlapping actuals\");\n+   Write_Line (\"        .I   turn off warnings for overlapping actuals\");\n    Write_Line (\"        j+   turn on warnings for obsolescent \" &\n                                                   \"(annex J) feature\");\n    Write_Line (\"        J*   turn off warnings for obsolescent \" &"}, {"sha": "c194b3182c1b1e43142f3a3a1110ff93571b7123", "filename": "gcc/ada/warnsw.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fwarnsw.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d38207955c35124725ee6a92a06b8074851f0a82/gcc%2Fada%2Fwarnsw.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fwarnsw.adb?ref=d38207955c35124725ee6a92a06b8074851f0a82", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1999-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1999-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -292,6 +292,7 @@ package body Warnsw is\n             Warn_On_Non_Local_Exception         := True;\n             Warn_On_Object_Renames_Function     := True;\n             Warn_On_Obsolescent_Feature         := True;\n+            Warn_On_Overlap                     := True;\n             Warn_On_Parameter_Order             := True;\n             Warn_On_Questionable_Missing_Parens := True;\n             Warn_On_Redundant_Constructs        := True;"}]}