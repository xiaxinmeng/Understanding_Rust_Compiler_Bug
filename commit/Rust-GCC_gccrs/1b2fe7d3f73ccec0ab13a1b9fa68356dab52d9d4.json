{"sha": "1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIyZmU3ZDNmNzNjY2VjMGFiMTNhMWI5ZmE2ODM1NmRhYjUyZDlkNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-09-18T19:12:22Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-09-18T19:12:22Z"}, "message": "[PATCH] avail_exprs is no longer file scoped\n\n\t* tree-ssa-dom.c (avail_exprs): No longer file scoped.  Bury\n\tit into the avail_exprs_stack class.\n\t(pass_dominator::execute): Corresponding changes to declaration\n\tand initialization of avail_exprs.  Pass avail_exprs to\n\tdump_dominator_optimization_stats.\n\t(record_cond): Extract avail_exprs from avail_exprs_stack.\n\t(lookup_avail_expr): Similarly.\n\t(htab_staticstics): Remove unnecessary prototype.  Move to earlier\n\tposition in file.\n\t(dump_dominator_optimization_stats): Make static and prototype.\n\tAdd argument for the hash table to dump.\n\t(debug_dominator_optimization_stats): Remove.\n\t* tree-ssa-dom.h (dump_dominator_optimization_stats): Remove\n\tprototype.\n\t(debug_dominator_optimization_stats): Similarly.\n\t* tree-ssa-scopedtables.h (class avail_exprs_stack): Add missing\n\t\"void\" in prototype for pop_to_marker method.  Add accessor method\n\tfor the underlying avail_exprs table.\n\n\t* tree-ssa-threadedge.c: Remove trailing whitespace.\n\nFrom-SVN: r227921", "tree": {"sha": "ef3a3f2d651a8a3df1740bb1002c0178bde1c455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef3a3f2d651a8a3df1740bb1002c0178bde1c455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/comments", "author": null, "committer": null, "parents": [{"sha": "5877e54ea0ab4f38f9046a12633de4fa6671e925", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5877e54ea0ab4f38f9046a12633de4fa6671e925", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5877e54ea0ab4f38f9046a12633de4fa6671e925"}], "stats": {"total": 107, "additions": 60, "deletions": 47}, "files": [{"sha": "d46088083c373565d5a8065f89429571966f7f10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "patch": "@@ -1,3 +1,27 @@\n+2015-09-18  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/47679\n+\t* tree-ssa-dom.c (avail_exprs): No longer file scoped.  Bury\n+\tit into the avail_exprs_stack class.\n+\t(pass_dominator::execute): Corresponding changes to declaration\n+\tand initialization of avail_exprs.  Pass avail_exprs to\n+\tdump_dominator_optimization_stats.\n+\t(record_cond): Extract avail_exprs from avail_exprs_stack.\n+\t(lookup_avail_expr): Similarly.\n+\t(htab_staticstics): Remove unnecessary prototype.  Move to earlier\n+\tposition in file.\n+\t(dump_dominator_optimization_stats): Make static and prototype.\n+\tAdd argument for the hash table to dump.\n+\t(debug_dominator_optimization_stats): Remove.\n+\t* tree-ssa-dom.h (dump_dominator_optimization_stats): Remove\n+\tprototype.\n+\t(debug_dominator_optimization_stats): Similarly.\n+\t* tree-ssa-scopedtables.h (class avail_exprs_stack): Add missing\n+\t\"void\" in prototype for pop_to_marker method.  Add accessor method\n+\tfor the underlying avail_exprs table.\n+\t\n+\t* tree-ssa-threadedge.c: Remove trailing whitespace.\n+\n 2014-09-18  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* config/pa/pa-protos.h (pa_cint_ok_for_move): Change argument type to"}, {"sha": "bf5e8a116ab16d87e2c8b4dda40ab8b7d8972198", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "patch": "@@ -78,15 +78,6 @@ struct edge_info\n   vec<cond_equivalence> cond_equivalences;\n };\n \n-/* Hash table with expressions made available during the renaming process.\n-   When an assignment of the form X_i = EXPR is found, the statement is\n-   stored in this table.  If the same expression EXPR is later found on the\n-   RHS of another statement, it is replaced with X_i (thus performing\n-   global redundancy elimination).  Similarly as we pass through conditionals\n-   we record the conditional itself as having either a true or false value\n-   in this table.  */\n-static hash_table<expr_elt_hasher> *avail_exprs;\n-\n /* Unwindable equivalences, both const/copy and expression varieties.  */\n static const_and_copies *const_and_copies;\n static avail_exprs_stack *avail_exprs_stack;\n@@ -114,15 +105,16 @@ static struct opt_stats_d opt_stats;\n /* Local functions.  */\n static void optimize_stmt (basic_block, gimple_stmt_iterator);\n static tree lookup_avail_expr (gimple, bool);\n-static void htab_statistics (FILE *,\n-\t\t\t     const hash_table<expr_elt_hasher> &);\n static void record_cond (cond_equivalence *);\n static void record_equality (tree, tree);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n static void eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n+static void dump_dominator_optimization_stats (FILE *file,\n+\t\t\t\t\t       hash_table<expr_elt_hasher> *);\n+\n \n /* Free the edge_info data attached to E, if it exists.  */\n \n@@ -548,7 +540,8 @@ pass_dominator::execute (function *fun)\n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n   /* Create our hash tables.  */\n-  avail_exprs = new hash_table<expr_elt_hasher> (1024);\n+  hash_table<expr_elt_hasher> *avail_exprs\n+    = new hash_table<expr_elt_hasher> (1024);\n   avail_exprs_stack = new class avail_exprs_stack (avail_exprs);\n   const_and_copies = new class const_and_copies ();\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n@@ -671,7 +664,7 @@ pass_dominator::execute (function *fun)\n \n   /* Debugging dumps.  */\n   if (dump_file && (dump_flags & TDF_STATS))\n-    dump_dominator_optimization_stats (dump_file);\n+    dump_dominator_optimization_stats (dump_file, avail_exprs);\n \n   loop_optimizer_finalize ();\n \n@@ -1008,10 +1001,22 @@ record_equivalences_from_incoming_edge (basic_block bb)\n     record_temporary_equivalences (e);\n }\n \n+/* Dump statistics for the hash table HTAB.  */\n+\n+static void\n+htab_statistics (FILE *file, const hash_table<expr_elt_hasher> &htab)\n+{\n+  fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n+\t   (long) htab.size (),\n+\t   (long) htab.elements (),\n+\t   htab.collisions ());\n+}\n+\n /* Dump SSA statistics on FILE.  */\n \n-void\n-dump_dominator_optimization_stats (FILE *file)\n+static void\n+dump_dominator_optimization_stats (FILE *file,\n+\t\t\t\t   hash_table<expr_elt_hasher> *avail_exprs)\n {\n   fprintf (file, \"Total number of statements:                   %6ld\\n\\n\",\n \t   opt_stats.num_stmts);\n@@ -1025,27 +1030,6 @@ dump_dominator_optimization_stats (FILE *file)\n }\n \n \n-/* Dump SSA statistics on stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_dominator_optimization_stats (void)\n-{\n-  dump_dominator_optimization_stats (stderr);\n-}\n-\n-\n-/* Dump statistics for the hash table HTAB.  */\n-\n-static void\n-htab_statistics (FILE *file, const hash_table<expr_elt_hasher> &htab)\n-{\n-  fprintf (file, \"size %ld, %ld elements, %f collision/search ratio\\n\",\n-\t   (long) htab.size (),\n-\t   (long) htab.elements (),\n-\t   htab.collisions ());\n-}\n-\n-\n /* Enter condition equivalence into the expression hash table.\n    This indicates that a conditional expression has a known\n    boolean value.  */\n@@ -1056,6 +1040,7 @@ record_cond (cond_equivalence *p)\n   class expr_hash_elt *element = new expr_hash_elt (&p->cond, p->value);\n   expr_hash_elt **slot;\n \n+  hash_table<expr_elt_hasher> *avail_exprs = avail_exprs_stack->avail_exprs ();\n   slot = avail_exprs->find_slot_with_hash (element, element->hash (), INSERT);\n   if (*slot == NULL)\n     {\n@@ -1917,6 +1902,7 @@ lookup_avail_expr (gimple stmt, bool insert)\n     return NULL_TREE;\n \n   /* Finally try to find the expression in the main expression hash table.  */\n+  hash_table<expr_elt_hasher> *avail_exprs = avail_exprs_stack->avail_exprs ();\n   slot = avail_exprs->find_slot (&element, (insert ? INSERT : NO_INSERT));\n   if (slot == NULL)\n     {"}, {"sha": "7ecdaf10b2b299495368365193950be297eccdd9", "filename": "gcc/tree-ssa-dom.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-dom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-dom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.h?ref=1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "patch": "@@ -20,8 +20,6 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_TREE_SSA_DOM_H\n #define GCC_TREE_SSA_DOM_H\n \n-extern void dump_dominator_optimization_stats (FILE *);\n-extern void debug_dominator_optimization_stats (void);\n extern bool simple_iv_increment_p (gimple);\n \n #endif /* GCC_TREE_SSA_DOM_H */"}, {"sha": "152df51937ff592dff410444ca33072c26ef8dd3", "filename": "gcc/tree-ssa-scopedtables.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-scopedtables.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-scopedtables.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.h?ref=1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "patch": "@@ -122,11 +122,16 @@ class avail_exprs_stack\n \n   /* Restore the AVAIL_EXPRs table to its state when the last marker\n      was pushed.  */\n-  void pop_to_marker ();\n+  void pop_to_marker (void);\n \n   /* Record a single available expression that can be unwound.  */\n   void record_expr (expr_hash_elt_t, expr_hash_elt_t, char);\n \n+  /* Get the underlying hash table.  Would this be better as\n+     class inheritance?  */\n+  hash_table<expr_elt_hasher> *avail_exprs (void)\n+    { return m_avail_exprs; }\n+\n  private:\n   vec<std::pair<expr_hash_elt_t, expr_hash_elt_t> > m_stack;\n   hash_table<expr_elt_hasher> *m_avail_exprs;"}, {"sha": "48c4ca765db8e37ee09b250e30e7a6ab05efa4f2", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=1b2fe7d3f73ccec0ab13a1b9fa68356dab52d9d4", "patch": "@@ -94,12 +94,12 @@ potentially_threadable_block (basic_block bb)\n   /* Special case.  We can get blocks that are forwarders, but are\n      not optimized away because they forward from outside a loop\n      to the loop header.   We want to thread through them as we can\n-     sometimes thread to the loop exit, which is obviously profitable. \n+     sometimes thread to the loop exit, which is obviously profitable.\n      the interesting case here is when the block has PHIs.  */\n   if (gsi_end_p (gsi_start_nondebug_bb (bb))\n       && !gsi_end_p (gsi_start_phis (bb)))\n     return true;\n-  \n+\n   /* If BB has a single successor or a single predecessor, then\n      there is no threading opportunity.  */\n   if (single_succ_p (bb) || single_pred_p (bb))\n@@ -148,7 +148,7 @@ lhs_of_dominating_assert (tree op, basic_block bb, gimple stmt)\n    edge E.  Record unwind information for the equivalences onto STACK.\n \n    If a PHI which prevents threading is encountered, then return FALSE\n-   indicating we should not thread this edge, else return TRUE. \n+   indicating we should not thread this edge, else return TRUE.\n \n    If SRC_MAP/DST_MAP exist, then mark the source and destination SSA_NAMEs\n    of any equivalences recorded.  We use this to make invalidation after\n@@ -423,10 +423,10 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t}\n \n       /* Record the context sensitive equivalence if we were able\n-\t to simplify this statement. \n+\t to simplify this statement.\n \n \t If we have traversed a backedge at some point during threading,\n-\t then always enter something here.  Either a real equivalence, \n+\t then always enter something here.  Either a real equivalence,\n \t or a NULL_TREE equivalence which is effectively invalidation of\n \t prior equivalences.  */\n       if (cached_lhs\n@@ -1238,7 +1238,7 @@ thread_through_normal_block (edge e,\n       /* Second case.  */\n       return -1;\n     }\n-  \n+\n   /* If we stopped at a COND_EXPR or SWITCH_EXPR, see if we know which arm\n      will be taken.  */\n   if (gimple_code (stmt) == GIMPLE_COND\n@@ -1285,7 +1285,7 @@ thread_through_normal_block (edge e,\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n-\t     VRP. \n+\t     VRP.\n \n \t     We don't want to thread back to a block we have already\n  \t     visited.  This may be overly conservative.  */\n@@ -1445,7 +1445,7 @@ thread_across_edge (gcond *dummy_cond,\n \tconst_and_copies->push_marker ();\n \tif (avail_exprs_stack)\n \t  avail_exprs_stack->push_marker ();\n-     \n+\n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n \tbitmap_set_bit (visited, e->src->index);"}]}