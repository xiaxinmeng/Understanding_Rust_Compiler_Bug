{"sha": "326bc2de1db63451ba0918858cc8a691f36bf216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI2YmMyZGUxZGI2MzQ1MWJhMDkxODg1OGNjOGE2OTFmMzZiZjIxNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-08-09T06:03:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1994-08-09T06:03:07Z"}, "message": "pa.c (hppa_legitimize_address): Do nothing with function label arithmetic.\n\n\t* pa.c (hppa_legitimize_address): Do nothing with function label\n\tarithmetic.\n\t(emit_move_sequence): Split up function label arithmetic so that\n\tfunction's address is loaded first, then constant part is added to\n\tthe function's address.\n\t(is_function_label_plus_const): New function.\n\nFrom-SVN: r7882", "tree": {"sha": "089d5a753c4949ba0bee19f5a9c6867d71284dff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/089d5a753c4949ba0bee19f5a9c6867d71284dff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/326bc2de1db63451ba0918858cc8a691f36bf216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326bc2de1db63451ba0918858cc8a691f36bf216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/326bc2de1db63451ba0918858cc8a691f36bf216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326bc2de1db63451ba0918858cc8a691f36bf216/comments", "author": null, "committer": null, "parents": [{"sha": "6ce47c075f882002192a9b68c9c31ff04d2efe06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce47c075f882002192a9b68c9c31ff04d2efe06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce47c075f882002192a9b68c9c31ff04d2efe06"}], "stats": {"total": 50, "additions": 47, "deletions": 3}, "files": [{"sha": "2ec1d8b33e523acf7939d4009118455f86c57718", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326bc2de1db63451ba0918858cc8a691f36bf216/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326bc2de1db63451ba0918858cc8a691f36bf216/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=326bc2de1db63451ba0918858cc8a691f36bf216", "patch": "@@ -611,9 +611,12 @@ hppa_legitimize_address (x, oldx, mode)\n   if (GET_CODE (x) == CONST)\n     x = XEXP (x, 0);\n \n+  /* Note we must reject symbols which represent function addresses\n+     since the assembler/linker can't handle arithmetic on plabels.  */\n   if (GET_CODE (x) == PLUS\n       && GET_CODE (XEXP (x, 1)) == CONST_INT\n-      && (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+      && ((GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n+\t   && !FUNCTION_NAME_P (XSTR (XEXP (x, 0), 0)))\n \t  || GET_CODE (XEXP (x, 0)) == REG))\n     {\n       rtx int_part, ptr_reg;\n@@ -892,13 +895,32 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t     cse and loop optimizations.  */\n \t  else\n \t    {\n-\t      rtx temp, set;\n+\t      rtx temp, set, const_part = NULL;\n \n \t      if (reload_in_progress || reload_completed)\n \t\ttemp = scratch_reg ? scratch_reg : operand0;\n \t      else\n \t\ttemp = gen_reg_rtx (mode);\n \n+\t      /* Argh.  The assembler and linker can't handle arithmetic\n+\t\t involving plabels.  We'll have to split up operand1 here\n+\t\t if it's a function label involved in an arithmetic\n+\t\t expression.  Luckily, this only happens with addition\n+\t\t of constants to plabels, which simplifies the test.  */\n+\t     if (GET_CODE (operand1) == CONST\n+\t\t && GET_CODE (XEXP (operand1, 0)) == PLUS\n+\t\t && function_label_operand (XEXP (XEXP (operand1, 0), 0),\n+\t\t\t\t\t    Pmode))\n+\t\t{\n+\t\t  /* Save away the constant part of the expression.  */\n+\t\t  const_part = XEXP (XEXP (operand1, 0), 1);\n+\t\t  if (GET_CODE (const_part) != CONST_INT)\n+\t\t    abort ();\n+\n+\t\t  /* Set operand1 to just the SYMBOL_REF.  */\n+\t\t  operand1 = XEXP (XEXP (operand1, 0), 0);\n+\t\t}\n+\n \t      if (ishighonly)\n \t\tset = gen_rtx (SET, mode, operand0, temp);\n \t      else\n@@ -910,6 +932,12 @@ emit_move_sequence (operands, mode, scratch_reg)\n \t\t\t\t  temp,\n \t\t\t\t  gen_rtx (HIGH, mode, operand1)));\n \t      emit_insn (set);\n+\n+\t      /* Add back in the constant part if needed.  */\n+\t      if (const_part != NULL)\n+\t\temit_insn (gen_rtx (SET, mode, operand0,\n+\t\t\t\t    plus_constant (operand0,\n+\t\t\t\t\t\t   XEXP (const_part, 0))));\n \t      return 1;\n \t    }\n \t  return 1;\n@@ -3794,13 +3822,29 @@ hppa_encode_label (sym)\n }\n \n int\n-function_label_operand  (op, mode)\n+function_label_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n   return GET_CODE (op) == SYMBOL_REF && FUNCTION_NAME_P (XSTR (op, 0));\n }\n \n+/* Returns 1 if OP is a function label involved in a simple addition\n+   with a constant.  Used to keep certain patterns from matching\n+   during instruction combination.  */\n+int\n+is_function_label_plus_const (op)\n+     rtx op;\n+{\n+  /* Strip off any CONST.  */\n+  if (GET_CODE (op) == CONST)\n+    op = XEXP (op, 0);\n+\n+  return (GET_CODE (op) == PLUS\n+\t  && function_label_operand (XEXP (op, 0), Pmode)\n+\t  && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+}\n+\n /* Returns 1 if the 6 operands specified in OPERANDS are suitable for\n    use in fmpyadd instructions.  */\n int"}]}