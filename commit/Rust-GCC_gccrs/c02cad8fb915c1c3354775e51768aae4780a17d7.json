{"sha": "c02cad8fb915c1c3354775e51768aae4780a17d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyY2FkOGZiOTE1YzFjMzM1NDc3NWU1MTc2OGFhZTQ3ODBhMTdkNw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.co.uk", "date": "2000-12-01T16:34:09Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2000-12-01T16:34:09Z"}, "message": "Add a frontend function for reload_reg_free_for_value_p; need to check all\nregisters in a multi-reg value.\n\nFrom-SVN: r37916", "tree": {"sha": "b8f97e68eabdb4905fa30449390ec3f1db3590c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8f97e68eabdb4905fa30449390ec3f1db3590c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c02cad8fb915c1c3354775e51768aae4780a17d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02cad8fb915c1c3354775e51768aae4780a17d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c02cad8fb915c1c3354775e51768aae4780a17d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c02cad8fb915c1c3354775e51768aae4780a17d7/comments", "author": null, "committer": null, "parents": [{"sha": "53895717b4af66f271416daadb87c2d70042369d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53895717b4af66f271416daadb87c2d70042369d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53895717b4af66f271416daadb87c2d70042369d"}], "stats": {"total": 122, "additions": 72, "deletions": 50}, "files": [{"sha": "fde8d068d7681e891125b55b00ba0c10771d3363", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02cad8fb915c1c3354775e51768aae4780a17d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02cad8fb915c1c3354775e51768aae4780a17d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c02cad8fb915c1c3354775e51768aae4780a17d7", "patch": "@@ -5,6 +5,10 @@\n \t(try_combine, can_combine_p, combinable_i3pat): Delete old\n \tSMALL_REGISTER_CLASSES tests.\n \n+\t* reload1.c (free_for_value_p): New function, frontend to\n+\treload_reg_free_for_value_p.  All callers of the latter now call\n+\tthis function with an additional mode argument.\n+\n 2000-12-01  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/sh/sh.c (shiftcosts): Don't get INTVAL before testing"}, {"sha": "e0fa2b9adc36f09edbcb137f71585d2952023f02", "filename": "gcc/reload1.c", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c02cad8fb915c1c3354775e51768aae4780a17d7/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c02cad8fb915c1c3354775e51768aae4780a17d7/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=c02cad8fb915c1c3354775e51768aae4780a17d7", "patch": "@@ -413,6 +413,9 @@ static int reload_reg_free_p\t\tPARAMS ((unsigned int, int,\n \t\t\t\t\t\t enum reload_type));\n static int reload_reg_free_for_value_p\tPARAMS ((int, int, enum reload_type,\n \t\t\t\t\t\t rtx, rtx, int, int));\n+static int free_for_value_p\t\tPARAMS ((int, enum machine_mode, int,\n+\t\t\t\t\t\t enum reload_type, rtx, rtx,\n+\t\t\t\t\t\t int, int));\n static int reload_reg_reaches_end_p\tPARAMS ((unsigned int, int,\n \t\t\t\t\t\t enum reload_type));\n static int allocate_reload_reg\t\tPARAMS ((struct insn_chain *, int,\n@@ -4650,25 +4653,8 @@ rtx reload_override_in[MAX_RELOADS];\n    or -1 if we did not need a register for this reload.  */\n int reload_spill_index[MAX_RELOADS];\n \n-/* Return 1 if the value in reload reg REGNO, as used by a reload\n-   needed for the part of the insn specified by OPNUM and TYPE,\n-   may be used to load VALUE into it.\n-\n-   Other read-only reloads with the same value do not conflict\n-   unless OUT is non-zero and these other reloads have to live while\n-   output reloads live.\n-   If OUT is CONST0_RTX, this is a special case: it means that the\n-   test should not be for using register REGNO as reload register, but\n-   for copying from register REGNO into the reload register.\n+/* Subroutine of free_for_value_p, used to check a single register.  */\n \n-   RELOADNUM is the number of the reload we want to load this value for;\n-   a reload does not conflict with itself.\n-\n-   When IGNORE_ADDRESS_RELOADS is set, we can not have conflicts with\n-   reloads that load an address for the very reload we are considering.\n-\n-   The caller has to make sure that there is no conflict with the return\n-   register.  */\n static int\n reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t\t     ignore_address_reloads)\n@@ -4883,6 +4869,48 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n   return 1;\n }\n \n+/* Return 1 if the value in reload reg REGNO, as used by a reload\n+   needed for the part of the insn specified by OPNUM and TYPE,\n+   may be used to load VALUE into it.\n+\n+   MODE is the mode in which the register is used, this is needed to\n+   determine how many hard regs to test.\n+\n+   Other read-only reloads with the same value do not conflict\n+   unless OUT is non-zero and these other reloads have to live while\n+   output reloads live.\n+   If OUT is CONST0_RTX, this is a special case: it means that the\n+   test should not be for using register REGNO as reload register, but\n+   for copying from register REGNO into the reload register.\n+\n+   RELOADNUM is the number of the reload we want to load this value for;\n+   a reload does not conflict with itself.\n+\n+   When IGNORE_ADDRESS_RELOADS is set, we can not have conflicts with\n+   reloads that load an address for the very reload we are considering.\n+\n+   The caller has to make sure that there is no conflict with the return\n+   register.  */\n+\n+static int\n+free_for_value_p (regno, mode, opnum, type, value, out, reloadnum,\n+\t\t  ignore_address_reloads)\n+     int regno;\n+     enum machine_mode mode;\n+     int opnum;\n+     enum reload_type type;\n+     rtx value, out;\n+     int reloadnum;\n+     int ignore_address_reloads;\n+{\n+  int nregs = HARD_REGNO_NREGS (regno, mode);\n+  while (nregs-- > 0)\n+    if (! reload_reg_free_for_value_p (regno, opnum, type, value, out,\n+\t\t\t\t       reloadnum, ignore_address_reloads))\n+      return 0;\n+  return 1;\n+}\n+\n /* Determine whether the reload reg X overlaps any rtx'es used for\n    overriding inheritance.  Return nonzero if so.  */\n \n@@ -5039,11 +5067,9 @@ allocate_reload_reg (chain, r, last_reload)\n \t\t   /* We check reload_reg_used to make sure we\n \t\t      don't clobber the return register.  */\n \t\t   && ! TEST_HARD_REG_BIT (reload_reg_used, regnum)\n-\t\t   && reload_reg_free_for_value_p (regnum,\n-\t\t\t\t\t\t   rld[r].opnum,\n-\t\t\t\t\t\t   rld[r].when_needed,\n-\t\t\t\t\t\t   rld[r].in,\n-\t\t\t\t\t\t   rld[r].out, r, 1)))\n+\t\t   && free_for_value_p (regnum, rld[r].mode, rld[r].opnum,\n+\t\t\t\t\trld[r].when_needed, rld[r].in,\n+\t\t\t\t\trld[r].out, r, 1)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], regnum)\n \t      && HARD_REGNO_MODE_OK (regnum, rld[r].mode)\n \t      /* Look first for regs to share, then for unshared.  But\n@@ -5386,10 +5412,9 @@ choose_reload_regs (chain)\n \t\t      && (rld[r].nregs == max_group_size\n \t\t\t  || ! TEST_HARD_REG_BIT (reg_class_contents[(int) group_class],\n \t\t\t\t\t\t  i))\n-\t\t      && reload_reg_free_for_value_p (i, rld[r].opnum,\n-\t\t\t\t\t\t      rld[r].when_needed,\n-\t\t\t\t\t\t      rld[r].in,\n-\t\t\t\t\t\t      const0_rtx, r, 1))\n+\t\t      && free_for_value_p (i, rld[r].mode, rld[r].opnum,\n+\t\t\t\t\t   rld[r].when_needed, rld[r].in,\n+\t\t\t\t\t   const0_rtx, r, 1))\n \t\t    {\n \t\t      /* If a group is needed, verify that all the subsequent\n \t\t\t registers still have their values intact.  */\n@@ -5422,9 +5447,10 @@ choose_reload_regs (chain)\n \t\t\t      break;\n \n \t\t\t  if (i1 != n_earlyclobbers\n-\t\t\t      || ! (reload_reg_free_for_value_p\n-\t\t\t\t    (i, rld[r].opnum, rld[r].when_needed,\n-\t\t\t\t     rld[r].in, rld[r].out, r, 1))\n+\t\t\t      || ! (free_for_value_p (i, rld[r].mode,\n+\t\t\t\t\t\t      rld[r].opnum,\n+\t\t\t\t\t\t      rld[r].when_needed, rld[r].in,\n+\t\t\t\t\t\t      rld[r].out, r, 1))\n \t\t\t      /* Don't use it if we'd clobber a pseudo reg.  */\n \t\t\t      || (TEST_HARD_REG_BIT (reg_used_in_insn, i)\n \t\t\t\t  && rld[r].out\n@@ -5528,10 +5554,9 @@ choose_reload_regs (chain)\n \t\t and of the desired class.  */\n \t      if (equiv != 0\n \t\t  && ((TEST_HARD_REG_BIT (reload_reg_used_at_all, regno)\n-\t\t       && ! reload_reg_free_for_value_p (regno, rld[r].opnum,\n-\t\t\t\t\t\t\t rld[r].when_needed,\n-\t\t\t\t\t\t\t rld[r].in,\n-\t\t\t\t\t\t\t rld[r].out, r, 1))\n+\t\t       && ! free_for_value_p (regno, rld[r].mode,\n+\t\t\t\t\t      rld[r].opnum, rld[r].when_needed,\n+\t\t\t\t\t      rld[r].in, rld[r].out, r, 1))\n \t\t      || ! TEST_HARD_REG_BIT (reg_class_contents[(int) rld[r].class],\n \t\t\t\t\t      regno)))\n \t\tequiv = 0;\n@@ -5749,13 +5774,11 @@ choose_reload_regs (chain)\n \t    check_reg = reload_override_in[r];\n \t  else\n \t    continue;\n-\t  if (! reload_reg_free_for_value_p (true_regnum (check_reg),\n-\t\t\t\t\t     rld[r].opnum,\n-\t\t\t\t\t     rld[r].when_needed,\n-\t\t\t\t\t     rld[r].in,\n-\t\t\t\t\t     (reload_inherited[r]\n-\t\t\t\t\t      ? rld[r].out : const0_rtx),\n-\t\t\t\t\t     r, 1))\n+\t  if (! free_for_value_p (true_regnum (check_reg), rld[r].mode,\n+\t\t\t\t  rld[r].opnum, rld[r].when_needed, rld[r].in,\n+\t\t\t\t  (reload_inherited[r]\n+\t\t\t\t   ? rld[r].out : const0_rtx),\n+\t\t\t\t  r, 1))\n \t    {\n \t      if (pass)\n \t\tcontinue;\n@@ -6079,10 +6102,8 @@ emit_input_reload_insns (chain, rl, old, j)\n \n       /* Don't use OLDEQUIV if any other reload changes it at an\n \t earlier stage of this insn or at this stage.  */\n-      if (! reload_reg_free_for_value_p (regno, rl->opnum,\n-\t\t\t\t\t rl->when_needed,\n-\t\t\t\t\t rl->in, const0_rtx, j,\n-\t\t\t\t\t 0))\n+      if (! free_for_value_p (regno, rl->mode, rl->opnum, rl->when_needed,\n+\t\t\t      rl->in, const0_rtx, j, 0))\n \toldequiv = 0;\n \n       /* If it is no cheaper to copy from OLDEQUIV into the\n@@ -6232,11 +6253,8 @@ emit_input_reload_insns (chain, rl, old, j)\n \t   /* This is unsafe if some other reload\n \t      uses the same reg first.  */\n \t   && ! conflicts_with_override (reloadreg)\n-\t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n-\t\t\t\t\t   rl->opnum,\n-\t\t\t\t\t   rl->when_needed,\n-\t\t\t\t\t   old, rl->out,\n-\t\t\t\t\t   j, 0))\n+\t   && free_for_value_p (REGNO (reloadreg), rl->mode, rl->opnum,\n+\t\t\t\trl->when_needed, old, rl->out, j, 0))\n     {\n       rtx temp = PREV_INSN (insn);\n       while (temp && GET_CODE (temp) == NOTE)"}]}