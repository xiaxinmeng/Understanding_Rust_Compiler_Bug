{"sha": "e6450c11b26d746328554ba8041577e173fad8f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0NTBjMTFiMjZkNzQ2MzI4NTU0YmE4MDQxNTc3ZTE3M2ZhZDhmMQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-05-20T19:32:30Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-05-20T19:32:30Z"}, "message": "re PR middle-end/45098 (Missed induction variable optimization)\n\n2011-05-20  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/45098\n\t* tree-ssa-loop-ivopts.c: Include expmed.h.\n\t(get_shiftadd_cost): New function.\n\t(force_expr_to_var_cost): Declare forward.  Use get_shiftadd_cost.\n\nFrom-SVN: r173976", "tree": {"sha": "1f233a18162e37104b6ee5701d99be2439c4499f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f233a18162e37104b6ee5701d99be2439c4499f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6450c11b26d746328554ba8041577e173fad8f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6450c11b26d746328554ba8041577e173fad8f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6450c11b26d746328554ba8041577e173fad8f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6450c11b26d746328554ba8041577e173fad8f1/comments", "author": null, "committer": null, "parents": [{"sha": "0e8b84ec02f16c1560f81eaf971f4deb8e3223ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e8b84ec02f16c1560f81eaf971f4deb8e3223ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e8b84ec02f16c1560f81eaf971f4deb8e3223ad"}], "stats": {"total": 66, "additions": 66, "deletions": 0}, "files": [{"sha": "124c86c53a9ec06249614dd54f1f593e5a975901", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6450c11b26d746328554ba8041577e173fad8f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6450c11b26d746328554ba8041577e173fad8f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6450c11b26d746328554ba8041577e173fad8f1", "patch": "@@ -1,3 +1,10 @@\n+2011-05-20  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/45098\n+\t* tree-ssa-loop-ivopts.c: Include expmed.h.\n+\t(get_shiftadd_cost): New function.\n+\t(force_expr_to_var_cost): Declare forward.  Use get_shiftadd_cost.\n+\n 2011-05-20  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR bootstrap/49086"}, {"sha": "69df4b62b77a78dbe6a6531aa95dcf40fe5fe9a3", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6450c11b26d746328554ba8041577e173fad8f1/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6450c11b26d746328554ba8041577e173fad8f1/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=e6450c11b26d746328554ba8041577e173fad8f1", "patch": "@@ -92,6 +92,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-ssa-propagate.h\"\n \n+/* FIXME: add_cost and zero_cost defined in exprmed.h conflict with local uses.\n+ */\n+#include \"expmed.h\"\n+#undef add_cost\n+#undef zero_cost\n+\n /* FIXME: Expressions are expanded to RTL in this pass to determine the\n    cost of different addressing modes.  This should be moved to a TBD\n    interface between the GIMPLE and RTL worlds.  */\n@@ -377,6 +383,8 @@ struct iv_ca_delta\n \n static VEC(tree,heap) *decl_rtl_to_reset;\n \n+static comp_cost force_expr_to_var_cost (tree, bool);\n+\n /* Number of uses recorded in DATA.  */\n \n static inline unsigned\n@@ -3506,6 +3514,42 @@ get_address_cost (bool symbol_present, bool var_present,\n   return new_cost (cost + acost, complexity);\n }\n \n+ /* Calculate the SPEED or size cost of shiftadd EXPR in MODE.  MULT is the\n+    the EXPR operand holding the shift.  COST0 and COST1 are the costs for\n+    calculating the operands of EXPR.  Returns true if successful, and returns\n+    the cost in COST.  */\n+\n+static bool\n+get_shiftadd_cost (tree expr, enum machine_mode mode, comp_cost cost0,\n+                   comp_cost cost1, tree mult, bool speed, comp_cost *cost)\n+{\n+  comp_cost res;\n+  tree op1 = TREE_OPERAND (expr, 1);\n+  tree cst = TREE_OPERAND (mult, 1);\n+  tree multop = TREE_OPERAND (mult, 0);\n+  int m = exact_log2 (int_cst_value (cst));\n+  int maxm = MIN (BITS_PER_WORD, GET_MODE_BITSIZE (mode));\n+  int sa_cost;\n+\n+  if (!(m >= 0 && m < maxm))\n+    return false;\n+\n+  sa_cost = (TREE_CODE (expr) != MINUS_EXPR\n+             ? shiftadd_cost[speed][mode][m]\n+             : (mult == op1\n+                ? shiftsub1_cost[speed][mode][m]\n+                : shiftsub0_cost[speed][mode][m]));\n+  res = new_cost (sa_cost, 0);\n+  res = add_costs (res, mult == op1 ? cost0 : cost1);\n+\n+  STRIP_NOPS (multop);\n+  if (!is_gimple_val (multop))\n+    res = add_costs (res, force_expr_to_var_cost (multop, speed));\n+\n+  *cost = res;\n+  return true;\n+}\n+\n /* Estimates cost of forcing expression EXPR into a variable.  */\n \n static comp_cost\n@@ -3631,6 +3675,21 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case MINUS_EXPR:\n     case NEGATE_EXPR:\n       cost = new_cost (add_cost (mode, speed), 0);\n+      if (TREE_CODE (expr) != NEGATE_EXPR)\n+        {\n+          tree mult = NULL_TREE;\n+          comp_cost sa_cost;\n+          if (TREE_CODE (op1) == MULT_EXPR)\n+            mult = op1;\n+          else if (TREE_CODE (op0) == MULT_EXPR)\n+            mult = op0;\n+\n+          if (mult != NULL_TREE\n+              && TREE_CODE (TREE_OPERAND (mult, 1)) == INTEGER_CST\n+              && get_shiftadd_cost (expr, mode, cost0, cost1, mult, speed,\n+                                    &sa_cost))\n+            return sa_cost;\n+        }\n       break;\n \n     case MULT_EXPR:"}]}