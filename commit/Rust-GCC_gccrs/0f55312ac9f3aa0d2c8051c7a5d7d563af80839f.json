{"sha": "0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY1NTMxMmFjOWYzYWEwZDJjODA1MWM3YTVkN2Q1NjNhZjgwODM5Zg==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2007-12-16T00:08:17Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2007-12-16T00:08:17Z"}, "message": "patch_tester.sh: New.\n\n2007-12-15  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* patch_tester.sh: New.\n\t* prepare_patch.sh: New.\n\nFrom-SVN: r130981", "tree": {"sha": "ff5a580c67f4ed69e7b1868e14933c0ebbc8d3cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff5a580c67f4ed69e7b1868e14933c0ebbc8d3cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bcbdde3288fa6001007f25c46717cfcfe22cffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bcbdde3288fa6001007f25c46717cfcfe22cffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bcbdde3288fa6001007f25c46717cfcfe22cffa"}], "stats": {"total": 555, "additions": 555, "deletions": 0}, "files": [{"sha": "197221d67b1c2e2e827af381815ebe7f0b5f452b", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "patch": "@@ -1,3 +1,8 @@\n+2007-12-15  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* patch_tester.sh: New.\n+\t* prepare_patch.sh: New.\n+\n 2007-11-26  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* compare-debug: Introduce -p flag to preserve .stripped files."}, {"sha": "9866b3d0d3e9ec26b9e8ab4b88749f5618889024", "filename": "contrib/patch_tester.sh", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/contrib%2Fpatch_tester.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/contrib%2Fpatch_tester.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fpatch_tester.sh?ref=0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "patch": "@@ -0,0 +1,454 @@\n+#!/bin/sh\n+\n+# Tests a set of patches from a directory.\n+# Copyright (C) 2007  Free Software Foundation, Inc.\n+# Contributed by Sebastian Pop <sebastian.pop@amd.com>\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+\n+cat <<EOF\n+\n+WARNING: This script should only be fed with patches from known\n+         authorized and trusted sources.  Don't even think about\n+         hooking it up to a raw feed from the gcc-patches list or\n+         you'll regret it.\n+\n+EOF\n+\n+args=$@\n+\n+dashj=\n+default_standby=1\n+standby=$default_standby\n+default_watermark=0.60\n+watermark=$default_watermark\n+savecompilers=false\n+nogpg=false\n+\n+usage() {\n+    cat <<EOF\n+patch_tester.sh [-j<N>] [-standby N] [-watermark N] [-savecompilers] [-nogpg]\n+                <source_dir> [patches_dir [state_dir [build_dir]]]\n+\n+    J is the flag passed to make.  Default is empty string.\n+\n+    STANDBY is the number of minutes between checks for new patches in\n+    PATCHES_DIR.  Default is ${default_standby} minutes.\n+\n+    WATERMARK is the 5 minute average system charge under which a new\n+    compile can start.  Default is ${default_watermark}.  Note that the comparison \n+    is done in lexicographical order, so don't forget the leading 0.\n+\n+    SAVECOMPILERS copies the compilers in the same directory as the\n+    test results for the non patched version.  Default is not copy.\n+\n+    NOGPG can be used to avoid checking the GPG signature of patches.\n+\n+    SOURCE_DIR is the directory containing GCC's toplevel configure.\n+\n+    PATCHES_DIR is the directory containing the patches to be tested.\n+    Default is SOURCE_DIR/patches.\n+\n+    STATE_DIR is where the tester maintains its internal state.\n+    Default is SOURCE_DIR/state.\n+\n+    BUILD_DIR is the build tree, a temporary directory that this\n+    script will delete and recreate.  Default is SOURCE_DIR/obj.\n+\n+EOF\n+    exit 1\n+}\n+\n+while [ $# -ne 0 ]; do\n+    case $1 in\n+\t-j*)\n+\t    dashj=$1; shift\n+\t    ;;\n+\t-standby)\n+\t    [[ $# > 2 ]] || usage\n+\t    standby=$2; shift; shift\n+\t    ;;\n+\t-watermark)\n+\t    [[ $# > 2 ]] || usage\n+\t    watermark=$2; shift; shift\n+\t    ;;\n+\t-savecompilers)\n+\t    savecompilers=true; shift\n+\t    ;;\n+\t-nogpg)\n+\t    nogpg=true; shift\n+\t    ;;\n+\t-*) \n+\t    echo \"Invalid option: $1\"\n+\t    usage\n+\t    ;;\n+\t*)\n+\t    break\n+\t    ;;\n+    esac\n+done\n+\n+test $# -eq 0 && usage\n+\n+SOURCE=$1\n+PATCHES=\n+STATE=\n+BUILD=\n+\n+if [[ $# < 2 ]]; then\n+    PATCHES=$SOURCE/patches\n+else\n+    PATCHES=$2\n+fi\n+if [[ $# < 3 ]]; then\n+    STATE=$SOURCE/state\n+else\n+    STATE=$3\n+fi\n+if [[ $# < 4 ]]; then\n+    BUILD=$SOURCE/obj\n+else\n+    BUILD=$4\n+fi\n+\n+[ -d $PATCHES ] || mkdir -p $PATCHES\n+[ -d $STATE ] || mkdir -p $STATE\n+[ -d $STATE/patched ] || mkdir -p $STATE/patched\n+[ -d $SOURCE ] || mkdir -p $SOURCE\n+[ -f $SOURCE/config.guess ] || {\n+    cd $SOURCE\n+    svn -q co svn://gcc.gnu.org/svn/gcc/trunk .\n+}\n+\n+VERSION=`svn info $SOURCE | grep \"^Revision:\" | sed -e \"s/^Revision://g\" -e \"s/ //g\"`\n+\n+exec >> $STATE/tester.log 2>&1 || exit 1\n+set -x\n+\n+TESTING=$STATE/testing\n+REPORT=$TESTING/report\n+PRISTINE=$TESTING/pristine\n+PATCHED=$TESTING/patched\n+PATCH=\n+TARGET=`$SOURCE/config.guess || exit 1` \n+TESTLOGS=\"gcc/testsuite/gcc/gcc.sum\n+gcc/testsuite/gfortran/gfortran.sum\n+gcc/testsuite/g++/g++.sum\n+gcc/testsuite/objc/objc.sum\n+$TARGET/libstdc++-v3/testsuite/libstdc++.sum\n+$TARGET/libffi/testsuite/libffi.sum\n+$TARGET/libjava/testsuite/libjava.sum\n+$TARGET/libgomp/testsuite/libgomp.sum\n+$TARGET/libmudflap/testsuite/libmudflap.sum\"\n+COMPILERS=\"gcc/cc1\n+gcc/cc1obj\n+gcc/cc1plus\n+gcc/f951\n+gcc/jc1\n+gcc/gnat1\n+gcc/tree1\"\n+\n+now () {\n+    echo `TZ=UTC date +\"%Y_%m_%d_%H_%M_%S\"`\n+}\n+\n+report () {\n+    echo \"Checker: (`now`): $@\" >> $REPORT\n+}\n+\n+freport () {\n+    if [ -s $1 ]; then\n+\treport \"(cat $1\"\n+\tcat $1 >> $REPORT\n+\treport \"tac)\"\n+    fi\n+}\n+\n+cleanup () {\n+    cd $SOURCE\n+\n+    # FORNOW: Until this script is not committed to trunk, save and restore it.\n+    mv $SOURCE/contrib/patch_tester.sh $STATE\n+    svn cleanup && svn revert -R . && svn st | cut -d' ' -f5- | xargs rm -v\n+    mv $STATE/patch_tester.sh $SOURCE/contrib/\n+}\n+\n+selfexec () {\n+    exec ${CONFIG_SHELL-/bin/sh} $SOURCE/contrib/patch_tester.sh $args\n+}\n+\n+update () {\n+    svn_branch=`grep \"^branch:\" $PATCH | sed -e \"s/^branch://g\" -e \"s/ //g\"`\n+    if [ x$svn_branch = x ]; then\n+\tsvn_branch=trunk\n+    fi\n+\n+    svn_revision=`grep \"^revision:\" $PATCH | sed -e \"s/^revision://g\" -e \"s/ //g\"`\n+    if [ x$svn_revision = x ]; then\n+\tsvn_revision=HEAD\n+    fi\n+\n+    cleanup\n+    cd $SOURCE\n+    case $svn_branch in\n+\ttrunk)\n+\t    if ! svn switch -r $svn_revision svn://gcc.gnu.org/svn/gcc/trunk &> $TESTING/svn ; then\n+\t\treport \"failed to update svn sources with\"\n+\t\treport \"svn switch -r $svn_revision svn://gcc.gnu.org/svn/gcc/trunk\"\n+\t\tfreport $TESTING/svn\n+\t\treturn 1\n+\t    fi\n+\t    ;;\n+\n+\tsvn://gcc.gnu.org/svn/gcc/*)\n+\t    if ! svn switch -r $svn_revision $svn_branch &> $TESTING/svn ; then\n+\t\treport \"failed to update svn sources with\"\n+\t\treport \"svn switch -r $svn_revision $svn_branch\"\n+\t\tfreport $TESTING/svn\n+\t\treturn 1\n+\t    fi\n+\t    ;;\n+\n+\t*)\n+\t    if ! svn switch -r $svn_revision svn://gcc.gnu.org/svn/gcc/branches/$svn_branch &> $TESTING/svn ; then\n+\t\treport \"failed to update svn sources with\"\n+\t\treport \"svn switch -r $svn_revision svn://gcc.gnu.org/svn/gcc/branches/$svn_branch\"\n+\t\tfreport $TESTING/svn\n+\t\treturn 1\n+\t    fi\n+\t    ;;\n+    esac\n+\n+    current_version=`svn info $SOURCE | grep \"^Revision:\" | sed -e \"s/^Revision://g\" -e \"s/ //g\"`\n+    if [[ $VERSION < $current_version ]]; then\n+\tif [ -f $SOURCE/contrib/patch_tester.sh ]; then\n+\t    selfexec\n+\tfi\n+    fi\n+\n+    return 0\n+}\n+\n+apply_patch () {\n+    if [ $nogpg = false ]; then\n+\tif ! gpg --batch --verify $PATCH &> $TESTING/gpgverify ; then\n+\t    report \"your patch failed to verify:\"\n+\t    freport $TESTING/gpgverify\n+\t    return 1\n+\tfi\n+    fi\n+\n+    # Detect if the patch was created in toplev GCC.\n+    grep \"^Index: \" $PATCH | grep \"gcc/\"\n+    if [ $? = 0 ]; then\n+\tcd $SOURCE\n+\tif ! patch -p0 < $PATCH &> $TESTING/patching ; then\n+\t    report \"your patch failed to apply:\"\n+\t    freport $TESTING/patching\n+\t    return 1\n+\tfi\n+    else\n+\tcd $SOURCE/gcc\n+\tif ! patch -p0 < $PATCH &> $TESTING/patching ; then\n+\t    report \"your patch failed to apply:\"\n+\t    freport $TESTING/patching\n+\t    return 1\n+\tfi\n+    fi\n+}\n+\n+save_compilers () {\n+    for COMPILER in $COMPILERS ; do\n+\tif [ -f $BUILD/$COMPILER ]; then\n+\t    cp $BUILD/$COMPILER $PRISTINE\n+\tfi\n+    done\n+}\n+\n+bootntest () {\n+    rm -rf $BUILD\n+    mkdir $BUILD\n+    cd $BUILD\n+\n+    CONFIG_OPTIONS=`grep \"^configure:\" $PATCH | sed -e \"s/^configure://g\"`\n+    if ! $SOURCE/configure $CONFIG_OPTIONS &> $1/configure ; then\n+\treport \"configure failed with:\"\n+\tfreport $1/configure\n+\treturn 1\n+    fi\n+\n+    if ! make $dashj `grep \"^make:\" $PATCH | sed -e \"s/^make://g\"` bootstrap &> $1/bootstrap ; then\n+\treport \"bootstrap failed with last lines:\"\n+\ttail -30 $1/bootstrap > $1/last_bootstrap\n+\tfreport $1/last_bootstrap\n+\treport \"grep --context=20 Error bootstrap:\"\n+\tgrep --context=20 Error $1/bootstrap > $1/bootstrap_error\n+\tfreport $1/bootstrap_error\n+\treturn 1\n+    fi\n+\n+    CHECK_OPTIONS=`grep \"^check:\" $PATCH | sed -e \"s/^check://g\"`\n+    make $dashj $CHECK_OPTIONS -k check &> $1/check\n+\n+    for LOG in $TESTLOGS ; do\n+\tif [ -f $BUILD/$LOG ]; then\n+\t    mv $BUILD/$LOG $1\n+\t    mv `echo \"$BUILD/$LOG\" | sed -e \"s/\\.sum/\\.log/g\"` $1\n+\tfi\n+    done\n+\n+    return 0\n+}\n+\n+bootntest_patched () {\n+    cleanup\n+    mkdir -p $PATCHED\n+    apply_patch && bootntest $PATCHED\n+    return $?\n+}\n+\n+# Build the pristine tree with exactly the same options as the patch under test.\n+bootntest_pristine () {\n+    cleanup\n+    current_branch=`svn info $SOURCE | grep \"^URL:\" | sed -e \"s/URL: //g\" -e \"s/svn:\\/\\/gcc.gnu.org\\/svn\\/gcc\\///g\"`\n+    current_version=`svn info $SOURCE | grep \"^Revision:\" | sed -e \"s/^Revision://g\" -e \"s/ //g\"`\n+    PRISTINE=$STATE/$current_branch/$current_version\n+\n+    if [ -d $PRISTINE ]; then\n+\tln -s $PRISTINE $TESTING/pristine\n+\treturn 0\n+    else\n+\tmkdir -p $PRISTINE\n+\tln -s $PRISTINE $TESTING/pristine\n+\tbootntest $PRISTINE\n+\tRETVAL=$?\n+\tif [ $RETVAL = 0 -a $savecompilers = true ]; then\n+\t    save_compilers\n+\tfi\n+\treturn $RETVAL\n+    fi\n+}\n+\n+regtest () {\n+    touch $1/report\n+    touch $1/passes\n+    touch $1/failed\n+    touch $1/regress\n+\n+    for LOG in $TESTLOGS ; do\n+\tNLOG=`basename $LOG`\n+\tif [ -f $1/$NLOG ]; then\n+\t    awk '/^FAIL: / { print \"'$NLOG'\",$2; }' $1/$NLOG\n+\tfi\n+    done | sort | uniq > $1/failed\n+\n+    comm -12 $1/failed $1/passes >> $1/regress\n+    NUMREGRESS=`wc -l < $1/regress | tr -d ' '`\n+\n+    if [ $NUMREGRESS -eq 0 ] ; then\n+\tfor LOG in $TESTLOGS ; do\n+\t    NLOG=`basename $LOG`\n+\t    if [ -f $1/$NLOG ] ; then\n+\t\tawk '/^PASS: / { print \"'$NLOG'\",$2; }' $1/$NLOG\n+\t    fi\n+\tdone | sort | uniq | comm -23 - $1/failed > $1/passes\n+\techo \"there are no regressions with your patch.\" >> $1/report\n+    else\n+\techo \"with your patch there are $NUMREGRESS regressions.\" >> $1/report\n+\techo \"list of regressions with your patch:\" >> $1/report\n+\tcat $1/regress >> $1/report\n+    fi\n+}\n+\n+contrib_compare_tests () {\n+    report \"comparing logs with contrib/compare_tests:\"\n+    for LOG in $TESTLOGS ; do\n+ \tNLOG=`basename $LOG`\n+ \tif [ -f $PRISTINE/$NLOG -a -f $PATCHED/$NLOG ]; then\n+ \t    $SOURCE/contrib/compare_tests $PRISTINE/$NLOG $PATCHED/$NLOG > $TESTING/compare_$NLOG\n+ \t    freport $TESTING/compare_$NLOG\n+ \tfi\n+    done\n+}\n+\n+compare_passes () {\n+    regtest $PRISTINE\n+    cp $PRISTINE/passes $PATCHED\n+    regtest $PATCHED\n+    freport $PATCHED/report\n+    report \"FAILs with patched version:\"\n+    freport $PATCHED/failed\n+    report \"FAILs with pristine version:\"\n+    freport $PRISTINE/failed\n+\n+    # contrib_compare_tests\n+}\n+\n+write_report () {\n+    backup_patched=$STATE/patched/`now`\n+    report \"The files used for the validation of your patch are stored in $backup_patched on the tester machine.\"\n+\n+    EMAIL=`grep \"^email:\" $PATCH | sed -e \"s/^email://g\" -e \"s/ //g\"`\n+    if [ x$EMAIL != x ]; then\n+\tmutt -s \"[regtest] Results for `basename $PATCH` on $TARGET\" -i $REPORT -a $PATCH $EMAIL\n+    fi\n+\n+    mv $TESTING $backup_patched\n+}\n+\n+announce () {\n+    EMAIL=`grep \"^email:\" $PATCH | sed -e \"s/^email://g\" -e \"s/ //g\"`\n+    if [ x$EMAIL != x ]; then\n+\n+\tSTART_REPORT=$TESTING/start_report\n+\techo \"Hi, \" >> $START_REPORT\n+\techo \"I'm the automatic tester running on $TARGET.\" >> $START_REPORT\n+\techo \"I just started to look at your patch `basename $PATCH`.\" >> $START_REPORT\n+\techo \"Bye, your automatic tester.\" >> $START_REPORT\n+\tmutt -s \"[regtest] Starting bootstrap for `basename $PATCH` on $TARGET\" -i $START_REPORT $EMAIL\n+    fi\n+}\n+\n+# After selfexec, $TESTING is already set up.  \n+if [ -d $TESTING ]; then\n+    # The only file in $TESTING is the patch.\n+    PATCH=`ls -rt -1 $TESTING | head -1`\n+    PATCH=$TESTING/$PATCH\n+    if [ -f $PATCH ]; then\n+\tbootntest_patched && bootntest_pristine && compare_passes\n+\twrite_report\n+    fi\n+fi\n+\n+while true; do\n+    PATCH=`ls -rt -1 $PATCHES | head -1`\n+    if [ x$PATCH = x ]; then\n+\tsleep ${standby}m\n+    else\n+\tsysload=`uptime | cut -d, -f 5`\n+\tif [[ $sysload > $watermark ]]; then\n+\t    # Wait a bit when system load is too high.\n+\t    sleep ${standby}m\n+\telse\n+\t    mkdir -p $TESTING\n+\t    mv $PATCHES/$PATCH $TESTING/\n+\t    PATCH=$TESTING/$PATCH\n+\n+\t    announce\n+\t    update && bootntest_patched && bootntest_pristine && compare_passes\n+\t    write_report\n+\tfi\n+    fi\n+done"}, {"sha": "5770e5ade9d4aae5bb4a63af07c5fffce89f0e44", "filename": "contrib/prepare_patch.sh", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/contrib%2Fprepare_patch.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f55312ac9f3aa0d2c8051c7a5d7d563af80839f/contrib%2Fprepare_patch.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fprepare_patch.sh?ref=0f55312ac9f3aa0d2c8051c7a5d7d563af80839f", "patch": "@@ -0,0 +1,96 @@\n+#!/bin/sh\n+#set -x\n+\n+# Prepares a patch for the patch tester.\n+# Copyright (C) 2007  Free Software Foundation, Inc.\n+# Contributed by Sebastian Pop <sebastian.pop@amd.com>\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+\n+usage() {\n+    cat <<EOF\n+prepare_patch.sh <source_dir> [patches_dir]\n+\n+    SOURCE_DIR is the directory containing GCC's toplevel configure.\n+\n+    PATCHES_DIR is the directory where the patch will be copied to.\n+    Default is SOURCE_DIR/patches.\n+\n+EOF\n+    exit 1\n+}\n+\n+test $# -eq 0 && usage\n+\n+SOURCE=$1\n+PATCHES=\n+\n+if [[ \"$#\" < 2 ]]; then\n+    PATCHES=$SOURCE/patches\n+else\n+    PATCHES=$2\n+fi\n+\n+[ -f $SOURCE/config.guess ] || usage\n+[ -d $PATCHES ] || mkdir -p $PATCHES\n+\n+echo \"Enter a name for this patch: \"\n+read name\n+PATCH=$PATCHES/`TZ=UTC date +\"%Y_%m_%d_%H_%M_%S\"`_$name.diff\n+\n+echo \"Enter the email where the report should be sent: \"\n+read email\n+echo \"email:$email\" >> $PATCH\n+\n+branch=`svn info $SOURCE | grep URL: | sed -e \"s/^URL: //g\"`\n+echo \"Enter svn branch (svn info in $SOURCE reports $branch, default is trunk): \"\n+read svn_branch\n+if [ x$svn_branch = x ]; then\n+    svn_branch=trunk\n+fi\n+echo \"branch:$svn_branch\" >> $PATCH\n+\n+revision=`svn info $SOURCE | grep Revision: | sed -e \"s/^Revision: //g\"`\n+echo \"Enter svn revision (svn info in $SOURCE reports $revision, default is HEAD): \"\n+read svn_revision\n+if [ x$svn_revision = x ]; then\n+    svn_revision=HEAD\n+fi\n+echo \"revision:$svn_revision\" >> $PATCH\n+\n+echo \"Enter configure options: \"\n+read configure_options\n+echo \"configure:$configure_options\" >> $PATCH\n+\n+echo \"Enter make options: \"\n+read make_options\n+echo \"make:$make_options\" >> $PATCH\n+\n+echo \"Enter make check options: \"\n+read check_options\n+echo \"check:$check_options\" >> $PATCH\n+\n+echo \"\" >> $PATCH\n+\n+svn diff $SOURCE | tee -a $PATCH\n+\n+cat <<EOF\n+\n+You can now edit your patch, include a ChangeLog, and before\n+submitting to the patch tester, don't forget to sign it with:\n+\n+  gpg --clearsign $PATCH\n+\n+EOF"}]}