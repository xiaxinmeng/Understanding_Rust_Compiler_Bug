{"sha": "0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0ZjI3NzBmZjE0ZWUxMzliOWY1ZDBhYTE2YzE1MDdlYjYwY2I1NQ==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-09-21T19:04:09Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2010-09-21T19:04:09Z"}, "message": "re PR fortran/45648 (Unnecessary temporary for transpose calls as actual argument.)\n\n2010-09-21  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/45648\n\t* trans-array.c (gfc_conv_expr_descriptor): Calculate dim out of n and\n\tinfo->dim.\n\n\tPR fortran/45648\n\t* trans-array.c (gfc_conv_expr_descriptor): Unset full if we are\n\taccessing dimensions in reversed order. \n\n\tPR fortran/45648\n\t* trans-array.c (gfc_conv_expr_descriptor): Special case noncopying\n\tintrinsic function call. \n\n\t* trans-array.c (gfc_conv_expr_descriptor): Remove ss lookup.\n\tUpdate asserts accordingly.\n\n\tPR fortran/45648\n\t* trans.h (gfc_se): New field force_tmp. \n\t* trans-expr.c (gfc_conv_procedure_call): Check for argument alias\n\tand set parmse.force_tmp if some alias is found. \n\t* trans-array.c (gfc_conv_expr_descriptor): Force a temporary creation\n\tif se->force_tmp is set. \n\n2010-09-21  Mikael Morin  <mikael@gcc.gnu.org>\n\n\tPR fortran/45648\n\t* gfortran.dg/inline_transpose_1.f90: Update temporary's locations\n\tand counts. Add non-elemental function call check.\n\n\tPR fortran/45648\n\t* gfortran.dg/inline_transpose_1.f90: Add function calls with aliasing\n\targuments checks. Update temporary counts.\n\t* gfortran.dg/transpose_optimization_1.f90: New.\n\nFrom-SVN: r164494", "tree": {"sha": "aa4f4a282ac80b91b29b28096d4af2a6ad0d5e3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa4f4a282ac80b91b29b28096d4af2a6ad0d5e3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/comments", "author": null, "committer": null, "parents": [{"sha": "5e68c77aff8d9c984668f8932e54b28d02456bba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e68c77aff8d9c984668f8932e54b28d02456bba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e68c77aff8d9c984668f8932e54b28d02456bba"}], "stats": {"total": 337, "additions": 284, "deletions": 53}, "files": [{"sha": "33eb6393ec9365432100e9d5d90b234608bb7e7f", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -1,3 +1,27 @@\n+2010-09-21  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/45648\n+\t* trans-array.c (gfc_conv_expr_descriptor): Calculate dim out of n and\n+\tinfo->dim.\n+\n+\tPR fortran/45648\n+\t* trans-array.c (gfc_conv_expr_descriptor): Unset full if we are\n+\taccessing dimensions in reversed order. \n+\n+\tPR fortran/45648\n+\t* trans-array.c (gfc_conv_expr_descriptor): Special case noncopying\n+\tintrinsic function call. \n+\n+\t* trans-array.c (gfc_conv_expr_descriptor): Remove ss lookup.\n+\tUpdate asserts accordingly.\n+\n+\tPR fortran/45648\n+\t* trans.h (gfc_se): New field force_tmp. \n+\t* trans-expr.c (gfc_conv_procedure_call): Check for argument alias\n+\tand set parmse.force_tmp if some alias is found. \n+\t* trans-array.c (gfc_conv_expr_descriptor): Force a temporary creation\n+\tif se->force_tmp is set. \n+\n 2010-09-20  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/45438"}, {"sha": "310a42b00f3475a1ce039ce63746d8c69fcfbaa9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 62, "deletions": 31, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -5136,7 +5136,6 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n }\n \n \n-\n /* Convert an array for passing as an actual argument.  Expressions and\n    vector subscripts are evaluated and stored in a temporary, which is then\n    passed.  For whole arrays the descriptor is passed.  For array sections\n@@ -5158,13 +5157,18 @@ get_array_charlen (gfc_expr *expr, gfc_se *se)\n \t EXPR is the right-hand side of a pointer assignment and\n \t se->expr is the descriptor for the previously-evaluated\n \t left-hand side.  The function creates an assignment from\n-\t EXPR to se->expr.  */\n+\t EXPR to se->expr.  \n+\n+\n+   The se->force_tmp flag disables the non-copying descriptor optimization\n+   that is used for transpose. It may be used in cases where there is an\n+   alias between the transpose argument and another argument in the same\n+   function call.  */\n \n void\n gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n {\n   gfc_loopinfo loop;\n-  gfc_ss *secss;\n   gfc_ss_info *info;\n   int need_tmp;\n   int n;\n@@ -5175,7 +5179,9 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n   tree offset;\n   int full;\n   bool subref_array_target = false;\n+  gfc_expr *arg;\n \n+  gcc_assert (ss != NULL);\n   gcc_assert (ss != gfc_ss_terminator);\n \n   /* Special case things we know we can pass easily.  */\n@@ -5185,22 +5191,21 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       /* If we have a linear array section, we can pass it directly.\n \t Otherwise we need to copy it into a temporary.  */\n \n-      /* Find the SS for the array section.  */\n-      secss = ss;\n-      while (secss != gfc_ss_terminator && secss->type != GFC_SS_SECTION)\n-\tsecss = secss->next;\n-\n-      gcc_assert (secss != gfc_ss_terminator);\n-      info = &secss->data.info;\n+      gcc_assert (ss->type == GFC_SS_SECTION);\n+      gcc_assert (ss->expr == expr);\n+      info = &ss->data.info;\n \n       /* Get the descriptor for the array.  */\n-      gfc_conv_ss_descriptor (&se->pre, secss, 0);\n+      gfc_conv_ss_descriptor (&se->pre, ss, 0);\n       desc = info->descriptor;\n \n       subref_array_target = se->direct_byref && is_subref_array (expr);\n       need_tmp = gfc_ref_needs_temporary_p (expr->ref)\n \t\t\t&& !subref_array_target;\n \n+      if (se->force_tmp)\n+\tneed_tmp = 1;\n+\n       if (need_tmp)\n \tfull = 0;\n       else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n@@ -5215,6 +5220,14 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       else\n \tfull = gfc_full_array_ref_p (info->ref, NULL);\n \n+      if (full)\n+\tfor (n = 0; n < info->dimen; n++)\n+\t  if (info->dim[n] != n)\n+\t    {\n+\t      full = 0;\n+\t      break;\n+\t    }\n+\n       if (full)\n \t{\n \t  if (se->direct_byref && !se->byref_noassign)\n@@ -5245,30 +5258,45 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       break;\n       \n     case EXPR_FUNCTION:\n+\n+      /* We don't need to copy data in some cases.  */\n+      arg = gfc_get_noncopying_intrinsic_argument (expr);\n+      if (arg)\n+\t{\n+\t  /* This is a call to transpose...  */\n+\t  gcc_assert (expr->value.function.isym->id == GFC_ISYM_TRANSPOSE);\n+\t  /* ... which has already been handled by the scalarizer, so\n+\t     that we just need to get its argument's descriptor.  */\n+\t  gfc_conv_expr_descriptor (se, expr->value.function.actual->expr, ss);\n+\t  return;\n+\t}\n+\n       /* A transformational function return value will be a temporary\n \t array descriptor.  We still need to go through the scalarizer\n \t to create the descriptor.  Elemental functions ar handled as\n \t arbitrary expressions, i.e. copy to a temporary.  */\n-      secss = ss;\n-      /* Look for the SS for this function.  */\n-      while (secss != gfc_ss_terminator\n-\t     && (secss->type != GFC_SS_FUNCTION || secss->expr != expr))\n-      \tsecss = secss->next;\n \n       if (se->direct_byref)\n \t{\n-\t  gcc_assert (secss != gfc_ss_terminator);\n+\t  gcc_assert (ss->type == GFC_SS_FUNCTION && ss->expr == expr);\n \n \t  /* For pointer assignments pass the descriptor directly.  */\n-\t  se->ss = secss;\n+\t  if (se->ss == NULL)\n+\t    se->ss = ss;\n+\t  else\n+\t    gcc_assert (se->ss == ss);\n \t  se->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n \t  gfc_conv_expr (se, expr);\n \t  return;\n \t}\n \n-      if (secss == gfc_ss_terminator)\n+      if (ss->expr != expr)\n \t{\n \t  /* Elemental function.  */\n+\t  gcc_assert ((expr->value.function.esym != NULL\n+\t\t       && expr->value.function.esym->attr.elemental)\n+\t\t      || (expr->value.function.isym != NULL\n+\t\t\t  && expr->value.function.isym->elemental));\n \t  need_tmp = 1;\n \t  if (expr->ts.type == BT_CHARACTER\n \t\t&& expr->ts.u.cl->length->expr_type != EXPR_CONSTANT)\n@@ -5279,7 +5307,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       else\n \t{\n \t  /* Transformational function.  */\n-\t  info = &secss->data.info;\n+\t  info = &ss->data.info;\n \t  need_tmp = 0;\n \t}\n       break;\n@@ -5292,24 +5320,26 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t{\n \t  need_tmp = 0;\n \t  info = &ss->data.info;\n-\t  secss = ss;\n \t}\n       else\n \t{\n \t  need_tmp = 1;\n-\t  secss = NULL;\n \t  info = NULL;\n \t}\n       break;\n \n     default:\n       /* Something complicated.  Copy it into a temporary.  */\n       need_tmp = 1;\n-      secss = NULL;\n       info = NULL;\n       break;\n     }\n \n+  /* If we are creating a temporary, we don't need to bother about aliases\n+     anymore.  */\n+  if (need_tmp)\n+    se->force_tmp = 0;\n+\n   gfc_init_loopinfo (&loop);\n \n   /* Associate the SS with the loop.  */\n@@ -5421,7 +5451,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \tse->string_length =  gfc_get_expr_charlen (expr);\n \n       desc = info->descriptor;\n-      gcc_assert (secss && secss != gfc_ss_terminator);\n       if (se->direct_byref && !se->byref_noassign)\n \t{\n \t  /* For pointer assignments we fill in the destination.  */\n@@ -5439,12 +5468,11 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t}\n \n       offset = gfc_index_zero_node;\n-      dim = 0;\n \n       /* The following can be somewhat confusing.  We have two\n          descriptors, a new one and the original array.\n          {parm, parmtype, dim} refer to the new one.\n-         {desc, type, n, secss, loop} refer to the original, which maybe\n+         {desc, type, n, loop} refer to the original, which maybe\n          a descriptorless array.\n          The bounds of the scalarization are the bounds of the section.\n          We don't have to worry about numeric overflows when calculating\n@@ -5479,9 +5507,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t    }\n \t  else\n \t    {\n-\t      /* Check we haven't somehow got out of sync.  */\n-\t      gcc_assert (info->dim[dim] == n);\n-\n \t      /* Evaluate and remember the start of the section.  */\n \t      start = info->start[n];\n \t      stride = gfc_evaluate_now (stride, &loop.pre);\n@@ -5505,6 +5530,14 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Vector subscripts need copying and are handled elsewhere.  */\n \t  if (info->ref)\n \t    gcc_assert (info->ref->u.ar.dimen_type[n] == DIMEN_RANGE);\n+ \n+\t  /* look for the corresponding scalarizer dimension: dim.  */\n+\t  for (dim = 0; dim < ndim; dim++)\n+\t    if (info->dim[dim] == n)\n+\t      break;\n+\n+\t  /* loop exited early: the DIM being looked for has been found.  */\n+\t  gcc_assert (dim < ndim);\n \n \t  /* Set the new lower bound.  */\n \t  from = loop.from[dim];\n@@ -5559,8 +5592,6 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n \t  /* Store the new stride.  */\n \t  gfc_conv_descriptor_stride_set (&loop.pre, parm,\n \t\t\t\t\t  gfc_rank_cst[dim], stride);\n-\n-\t  dim++;\n \t}\n \n       if (se->data_not_needed)"}, {"sha": "a6837c95e9006e38d2a2ea6b4742b2109726df89", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -2770,7 +2770,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n \n int\n gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n-\t\t\t gfc_actual_arglist * arg, gfc_expr * expr,\n+\t\t\t gfc_actual_arglist * args, gfc_expr * expr,\n \t\t\t VEC(tree,gc) *append_args)\n {\n   gfc_interface_mapping mapping;\n@@ -2789,6 +2789,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   VEC(tree,gc) *stringargs;\n   tree result = NULL;\n   gfc_formal_arglist *formal;\n+  gfc_actual_arglist *arg;\n   int has_alternate_specifier = 0;\n   bool need_interface_mapping;\n   bool callee_alloc;\n@@ -2809,7 +2810,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   gfc_clear_ts (&ts);\n \n   if (sym->from_intmod == INTMOD_ISO_C_BINDING\n-      && conv_isocbinding_procedure (se, sym, arg))\n+      && conv_isocbinding_procedure (se, sym, args))\n     return 0;\n \n   gfc_is_proc_ptr_comp (expr, &comp);\n@@ -2859,7 +2860,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     }\n \n   /* Evaluate the arguments.  */\n-  for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n+  for (arg = args; arg != NULL;\n+       arg = arg->next, formal = formal ? formal->next : NULL)\n     {\n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n@@ -3040,6 +3042,24 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t      else\n \t\tf = f || !sym->attr.always_explicit;\n \n+\t      /* If the argument is a function call that may not create\n+\t\t a temporary for the result, we have to check that we\n+\t\t can do it, i.e. that there is no alias between this \n+\t\t argument and another one.  */\n+\t      if (gfc_get_noncopying_intrinsic_argument (e) != NULL)\n+\t\t{\n+\t\t  sym_intent intent;\n+\n+\t\t  if (fsym != NULL)\n+\t\t    intent = fsym->attr.intent;\n+\t\t  else\n+\t\t    intent = INTENT_UNKNOWN;\n+\n+\t\t  if (gfc_check_fncall_dependency (e, intent, sym, args,\n+\t\t\t\t\t\t   NOT_ELEMENTAL))\n+\t\t    parmse.force_tmp = 1;\n+\t\t}\n+\n \t      if (e->expr_type == EXPR_VARIABLE\n \t\t    && is_subref_array (e))\n \t\t/* The actual argument is a component reference to an"}, {"sha": "a883cf5582d6cd40f346820cfbad0807268d6d92", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -81,6 +81,11 @@ typedef struct gfc_se\n   /* If set, gfc_conv_procedure_call does not put byref calls into se->pre.  */\n   unsigned no_function_call:1;\n \n+  /* If set, we will force the creation of a temporary. Useful to disable\n+     non-copying procedure argument passing optimizations, when some function\n+     args alias.  */\n+  unsigned force_tmp:1;\n+\n   /* Scalarization parameters.  */\n   struct gfc_se *parent;\n   struct gfc_ss *ss;"}, {"sha": "a1d8eb03cd07065ec31460098b5c116856363085", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -1,3 +1,14 @@\n+2010-09-21  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/45648\n+\t* gfortran.dg/inline_transpose_1.f90: Update temporary's locations\n+\tand counts. Add non-elemental function call check.\n+\n+\tPR fortran/45648\n+\t* gfortran.dg/inline_transpose_1.f90: Add function calls with aliasing\n+\targuments checks. Update temporary counts.\n+\t* gfortran.dg/transpose_optimization_1.f90: New.\n+\n 2010-09-21  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \tMerge from 'apple/trunk' branch on FSF servers."}, {"sha": "a364842517c1d2855455ec7c554908fc471cf8a2", "filename": "gcc/testsuite/gfortran.dg/inline_transpose_1.f90", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_transpose_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_transpose_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finline_transpose_1.f90?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -61,10 +61,10 @@\n   if (u /= v) call abort\n \n \n-  a = foo(transpose(c)) ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  a = foo(transpose(c))\n   if (any(a /= p+1)) call abort\n \n-  write(u,*) foo(transpose(c))    ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  write(u,*) foo(transpose(c))    ! { dg-warning \"Creating array temporary\" }\n   write(v,*) p+1\n   if (u /= v) call abort\n \n@@ -77,10 +77,10 @@\n   if (u /= v) call abort\n \n \n-  e = foo(transpose(e))     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  e = foo(transpose(e))     ! { dg-warning \"Creating array temporary\" }\n   if (any(e /= 2*s+1)) call abort\n \n-  write(u,*) transpose(foo(transpose(e))-1)     ! 2 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  write(u,*) transpose(foo(transpose(e))-1)     ! { dg-warning \"Creating array temporary\" }\n   write(v,*) 2*s+1\n   if (u /= v) call abort\n \n@@ -141,28 +141,46 @@\n   if (u /= v) call abort\n \n \n-  if (any(transpose(matmul(a,c)) /= matmul(transpose(c), transpose(a)))) call abort      ! 4 temps, should be 2 { dg-warning \"Creating array temporary\" }\n+  if (any(transpose(matmul(a,c)) /= matmul(transpose(c), transpose(a)))) call abort      ! 2 temps { dg-warning \"Creating array temporary\" }\n \n   write(u,*) transpose(matmul(a,c))     ! { dg-warning \"Creating array temporary\" }\n-  write(v,*) matmul(transpose(c), transpose(a))     ! 3 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  write(v,*) matmul(transpose(c), transpose(a))     ! { dg-warning \"Creating array temporary\" }\n   if (u /= v) call abort\n \n \n-  if (any(transpose(matmul(e,a)) /= matmul(transpose(a), transpose(e)))) call abort     ! 4 temps, should be 2 { dg-warning \"Creating array temporary\" }\n+  if (any(transpose(matmul(e,a)) /= matmul(transpose(a), transpose(e)))) call abort     ! 2 temps { dg-warning \"Creating array temporary\" }\n \n   write(u,*) transpose(matmul(e,a))     ! { dg-warning \"Creating array temporary\" }\n-  write(v,*) matmul(transpose(a), transpose(e))     ! 3 temps, should be 1 { dg-warning \"Creating array temporary\" }\n+  write(v,*) matmul(transpose(a), transpose(e))     ! { dg-warning \"Creating array temporary\" }\n   if (u /= v) call abort\n \n \n-  call baz (transpose(a))       ! Unnecessary { dg-warning \"Creating array temporary\" }\n+  call baz (transpose(a))\n \n-  call toto (f, transpose (e))\n-  if (any (f /= 4 * s + 12)) call abort\n \n-  call toto (f, transpose (f))          ! { dg-warning \"Creating array temporary\" }\n-  if (any (f /= 8 * r + 24)) call abort\n+  call toto1 (a, transpose (c))\n+  if (any (a /= 2 * p + 12)) call abort\n \n+  call toto1 (e, transpose (e))          ! { dg-warning \"Creating array temporary\" }\n+  if (any (e /= 4 * s + 12)) call abort\n+\n+\n+  call toto2 (c, transpose (a))\n+  if (any (c /= 2 * q + 13)) call abort\n+\n+  call toto2 (e, transpose(e))           ! { dg-warning \"Creating array temporary\" }\n+  if (any (e /= 4 * r + 13)) call abort\n+\n+  call toto2 (e, transpose(transpose(e)))           ! { dg-warning \"Creating array temporary\" }\n+  if (any (e /= 4 * r + 14)) call abort\n+\n+\n+  call toto3 (e, transpose(e))\n+  if (any (e /= 4 * r + 14)) call abort\n+\n+\n+  call titi (nx, e, transpose(e))           ! { dg-warning \"Creating array temporary\" }\n+  if (any (e /= 4 * s + 17)) call abort\n \n   contains\n \n@@ -182,22 +200,38 @@ subroutine baz (x)\n     integer, intent(in) :: x(:,:)\n   end subroutine baz\n \n-  elemental subroutine toto (x, y)\n+  elemental subroutine toto1 (x, y)\n     integer, intent(out) :: x\n     integer, intent(in)  :: y\n     x = y + y\n-  end subroutine toto\n+  end subroutine toto1\n+\n+  subroutine toto2 (x, y)\n+    integer, dimension(:,:), intent(out) :: x\n+    integer, dimension(:,:), intent(in)  :: y\n+    x = y + 1\n+  end subroutine toto2\n+\n+  subroutine toto3 (x, y)\n+    integer, dimension(:,:), intent(in) :: x, y\n+  end subroutine toto3\n \n end\n+\n+subroutine titi (n, x, y)\n+  integer :: n, x(n,n), y(n,n)\n+  x = y + 3\n+end subroutine titi\n+\n ! No call to transpose\n ! { dg-final { scan-tree-dump-times \"_gfortran_transpose\" 0 \"original\" } }\n !\n-! 34 temporaries\n-! { dg-final { scan-tree-dump-times \"struct\\[^\\\\n\\]*atmp\" 34 \"original\" } }\n+! 24 temporaries\n+! { dg-final { scan-tree-dump-times \"struct\\[^\\\\n\\]*atmp\" 24 \"original\" } }\n !\n ! 2 tests optimized out\n-! { dg-final { scan-tree-dump-times \"_gfortran_abort\" 34 \"original\" } }\n-! { # Commented out as failing at -O0: dg-final { scan-tree-dump-times \"_gfortran_abort\" 32 \"optimized\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_abort\" 39 \"original\" } }\n+! { # Commented out as failing at -O0: dg-final { scan-tree-dump-times \"_gfortran_abort\" 37 \"optimized\" } }\n !\n ! cleanup\n ! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "885ff7c2034999ce99c8f0f453171a437b16e9fa", "filename": "gcc/testsuite/gfortran.dg/transpose_optimization_1.f90", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftranspose_optimization_1.f90?ref=0b4f2770ff14ee139b9f5d0aa16c1507eb60cb55", "patch": "@@ -0,0 +1,106 @@\n+! { dg-do compile }\n+! { dg-options \"-Warray-temporaries -fdump-tree-original\" }\n+!\n+! PR fortran/45648\n+! Non-copying descriptor transpose optimization (for function call args).\n+!\n+! Contributed by Richard Sandiford <richard@codesourcery.com>\n+\n+module foo\n+  interface\n+    subroutine ext1 (a, b)\n+      real, intent (in), dimension (:, :) :: a, b\n+    end subroutine ext1\n+    subroutine ext2 (a, b)\n+      real, intent (in), dimension (:, :) :: a\n+      real, intent (out), dimension (:, :) :: b\n+    end subroutine ext2\n+    subroutine ext3 (a, b)\n+      real, dimension (:, :) :: a, b\n+    end subroutine ext3\n+  end interface\n+contains\n+  ! No temporary needed here.\n+  subroutine test1 (n, a, b, c)\n+    integer :: n\n+    real, dimension (n, n) :: a, b, c\n+    a = matmul (transpose (b), c)\n+  end subroutine test1\n+\n+  ! No temporary either, as we know the arguments to matmul are intent(in)\n+  subroutine test2 (n, a, b)\n+    integer :: n\n+    real, dimension (n, n) :: a, b\n+    a = matmul (transpose (b), b)\n+  end subroutine test2\n+\n+  ! No temporary needed.\n+  subroutine test3 (n, a, b, c)\n+    integer :: n\n+    real, dimension (n, n) :: a, c\n+    real, dimension (n+4, n+4) :: b\n+    a = matmul (transpose (b (2:n+1, 3:n+2)), c)\n+  end subroutine test3\n+\n+  ! A temporary is needed for the result of either the transpose or matmul.\n+  subroutine test4 (n, a, b)\n+    integer :: n\n+    real, dimension (n, n) :: a, b\n+    a = matmul (transpose (a), b)       ! { dg-warning \"Creating array temporary\" }\n+  end subroutine test4\n+\n+  ! The temporary is needed here since the second argument to imp1\n+  ! has unknown intent.\n+  subroutine test5 (n, a)\n+    integer :: n\n+    real, dimension (n, n) :: a\n+    call imp1 (transpose (a), a)        ! { dg-warning \"Creating array temporary\" }\n+  end subroutine test5\n+\n+  ! No temporaries are needed here; imp1 can't modify either argument.\n+  ! We have to pack the arguments, however. \n+  subroutine test6 (n, a, b)\n+    integer :: n\n+    real, dimension (n, n) :: a, b\n+    call imp1 (transpose (a), transpose (b))    ! { dg-warning \"Creating array temporary\" }\n+  end subroutine test6\n+\n+  ! No temporaries are needed here; imp1 can't modify either argument.\n+  ! We don't have to pack the arguments. \n+  subroutine test6_bis (n, a, b)\n+    integer :: n\n+    real, dimension (n, n) :: a, b\n+    call ext3 (transpose (a), transpose (b))\n+  end subroutine test6_bis\n+\n+  ! No temporary is neede here; the second argument is intent(in).\n+  subroutine test7 (n, a)\n+    integer :: n\n+    real, dimension (n, n) :: a\n+    call ext1 (transpose (a), a)\n+  end subroutine test7\n+\n+  ! The temporary is needed here though.\n+  subroutine test8 (n, a)\n+    integer :: n\n+    real, dimension (n, n) :: a\n+    call ext2 (transpose (a), a)        ! { dg-warning \"Creating array temporary\" } \n+  end subroutine test8\n+\n+  ! Silly, but we don't need any temporaries here.\n+  subroutine test9 (n, a)\n+    integer :: n\n+    real, dimension (n, n) :: a\n+    call ext1 (transpose (transpose (a)), a)\n+  end subroutine test9\n+\n+  ! The outer transpose needs a temporary; the inner one doesn't.\n+  subroutine test10 (n, a)\n+    integer :: n\n+    real, dimension (n, n) :: a\n+    call ext2 (transpose (transpose (a)), a)    ! { dg-warning \"Creating array temporary\" }\n+  end subroutine test10\n+end module foo\n+\n+! { dg-final { scan-tree-dump-times \"struct\\[^\\\\n\\]*atmp\" 4 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}