{"sha": "4c998ca548aa95e48f095604e96732de8d03de1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5OThjYTU0OGFhOTVlNDhmMDk1NjA0ZTk2NzMyZGU4ZDAzZGUxYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-11-02T11:29:50Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-11-02T11:29:50Z"}, "message": "tree-ssa-coalesce.c (struct coalesce_list): Add obstack member.\n\n2018-11-02  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-coalesce.c (struct coalesce_list): Add obstack member.\n\t(pop_cost_one_pair): Do not free pair.\n\t(pop_best_coalesce): Likewise.\n\t(create_coalesce_list): Initialize obstack.\n\t(delete_coalesce_list): Free obstack.\n\t(find_coalesce_pair): Obstack-allocate coalesce pairs.\n\t(add_cost_one_coalesce): Likewise.\n\t(struct live_track): Remove bitmap pointer indirections.\n\t(new_live_track): Adjust.\n\t(delete_live_track): Likewise.\n\t(live_track_remove_partition): Likewise.\n\t(live_track_add_partition): Likewise.\n\t(live_track_live_p): Likewise.\n\t(live_track_process_def): Likewise.\n\t(live_track_clear_base_vars): Likewise.\n\nFrom-SVN: r265745", "tree": {"sha": "f60d7df8d0187882da6a04a1a4e8a9bf2346d738", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f60d7df8d0187882da6a04a1a4e8a9bf2346d738"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c998ca548aa95e48f095604e96732de8d03de1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c998ca548aa95e48f095604e96732de8d03de1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c998ca548aa95e48f095604e96732de8d03de1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c998ca548aa95e48f095604e96732de8d03de1c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4155777d7394cb929f2ad5d86045415bff5c85ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4155777d7394cb929f2ad5d86045415bff5c85ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4155777d7394cb929f2ad5d86045415bff5c85ff"}], "stats": {"total": 66, "additions": 42, "deletions": 24}, "files": [{"sha": "6aa860d121d164cbf2ba91aa28abfea1ddf7f316", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c998ca548aa95e48f095604e96732de8d03de1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c998ca548aa95e48f095604e96732de8d03de1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c998ca548aa95e48f095604e96732de8d03de1c", "patch": "@@ -1,3 +1,21 @@\n+2018-11-02  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-coalesce.c (struct coalesce_list): Add obstack member.\n+\t(pop_cost_one_pair): Do not free pair.\n+\t(pop_best_coalesce): Likewise.\n+\t(create_coalesce_list): Initialize obstack.\n+\t(delete_coalesce_list): Free obstack.\n+\t(find_coalesce_pair): Obstack-allocate coalesce pairs.\n+\t(add_cost_one_coalesce): Likewise.\n+\t(struct live_track): Remove bitmap pointer indirections.\n+\t(new_live_track): Adjust.\n+\t(delete_live_track): Likewise.\n+\t(live_track_remove_partition): Likewise.\n+\t(live_track_add_partition): Likewise.\n+\t(live_track_live_p): Likewise.\n+\t(live_track_process_def): Likewise.\n+\t(live_track_clear_base_vars): Likewise.\n+\n 2018-11-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (gcc_cv_as_sparc_register_op): Remove."}, {"sha": "6ae9bb90eface0c1916cb7608b1dbee91f7464d9", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c998ca548aa95e48f095604e96732de8d03de1c/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c998ca548aa95e48f095604e96732de8d03de1c/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=4c998ca548aa95e48f095604e96732de8d03de1c", "patch": "@@ -135,6 +135,7 @@ struct coalesce_list\n   coalesce_pair **sorted;\t/* List when sorted.  */\n   int num_sorted;\t\t/* Number in the sorted list.  */\n   cost_one_pair *cost_one_list;/* Single use coalesces with cost 1.  */\n+  obstack ob;\n };\n \n #define NO_BEST_COALESCE\t-1\n@@ -226,8 +227,6 @@ pop_cost_one_pair (coalesce_list *cl, int *p1, int *p2)\n   *p2 = ptr->second_element;\n   cl->cost_one_list = ptr->next;\n \n-  free (ptr);\n-\n   return 1;\n }\n \n@@ -251,7 +250,6 @@ pop_best_coalesce (coalesce_list *cl, int *p1, int *p2)\n   *p1 = node->first_element;\n   *p2 = node->second_element;\n   ret = node->cost;\n-  free (node);\n \n   return ret;\n }\n@@ -273,6 +271,7 @@ create_coalesce_list (void)\n   list->sorted = NULL;\n   list->num_sorted = 0;\n   list->cost_one_list = NULL;\n+  gcc_obstack_init (&list->ob);\n   return list;\n }\n \n@@ -287,6 +286,7 @@ delete_coalesce_list (coalesce_list *cl)\n   cl->list = NULL;\n   free (cl->sorted);\n   gcc_assert (cl->num_sorted == 0);\n+  obstack_free (&cl->ob, NULL);\n   free (cl);\n }\n \n@@ -328,7 +328,7 @@ find_coalesce_pair (coalesce_list *cl, int p1, int p2, bool create)\n \n   if (!*slot)\n     {\n-      struct coalesce_pair * pair = XNEW (struct coalesce_pair);\n+      struct coalesce_pair * pair = XOBNEW (&cl->ob, struct coalesce_pair);\n       gcc_assert (cl->sorted == NULL);\n       pair->first_element = p.first_element;\n       pair->second_element = p.second_element;\n@@ -346,7 +346,7 @@ add_cost_one_coalesce (coalesce_list *cl, int p1, int p2)\n {\n   cost_one_pair *pair;\n \n-  pair = XNEW (cost_one_pair);\n+  pair = XOBNEW (&cl->ob, cost_one_pair);\n   pair->first_element = p1;\n   pair->second_element = p2;\n   pair->next = cl->cost_one_list;\n@@ -677,8 +677,8 @@ ssa_conflicts_dump (FILE *file, ssa_conflicts *ptr)\n struct live_track\n {\n   bitmap_obstack obstack;\t/* A place to allocate our bitmaps.  */\n-  bitmap live_base_var;\t\t/* Indicates if a basevar is live.  */\n-  bitmap *live_base_partitions;\t/* Live partitions for each basevar.  */\n+  bitmap_head live_base_var;\t\t/* Indicates if a basevar is live.  */\n+  bitmap_head *live_base_partitions;\t/* Live partitions for each basevar.  */\n   var_map map;\t\t\t/* Var_map being used for partition mapping.  */\n };\n \n@@ -695,14 +695,14 @@ new_live_track (var_map map)\n   /* Make sure there is a partition view in place.  */\n   gcc_assert (map->partition_to_base_index != NULL);\n \n-  ptr = (live_track *) xmalloc (sizeof (live_track));\n+  ptr = XNEW (live_track);\n   ptr->map = map;\n   lim = num_basevars (map);\n   bitmap_obstack_initialize (&ptr->obstack);\n-  ptr->live_base_partitions = (bitmap *) xmalloc (sizeof (bitmap *) * lim);\n-  ptr->live_base_var = BITMAP_ALLOC (&ptr->obstack);\n+  ptr->live_base_partitions = XNEWVEC (bitmap_head, lim);\n+  bitmap_initialize (&ptr->live_base_var, &ptr->obstack);\n   for (x = 0; x < lim; x++)\n-    ptr->live_base_partitions[x] = BITMAP_ALLOC (&ptr->obstack);\n+    bitmap_initialize (&ptr->live_base_partitions[x], &ptr->obstack);\n   return ptr;\n }\n \n@@ -713,8 +713,8 @@ static void\n delete_live_track (live_track *ptr)\n {\n   bitmap_obstack_release (&ptr->obstack);\n-  free (ptr->live_base_partitions);\n-  free (ptr);\n+  XDELETEVEC (ptr->live_base_partitions);\n+  XDELETE (ptr);\n }\n \n \n@@ -726,10 +726,10 @@ live_track_remove_partition (live_track *ptr, int partition)\n   int root;\n \n   root = basevar_index (ptr->map, partition);\n-  bitmap_clear_bit (ptr->live_base_partitions[root], partition);\n+  bitmap_clear_bit (&ptr->live_base_partitions[root], partition);\n   /* If the element list is empty, make the base variable not live either.  */\n-  if (bitmap_empty_p (ptr->live_base_partitions[root]))\n-    bitmap_clear_bit (ptr->live_base_var, root);\n+  if (bitmap_empty_p (&ptr->live_base_partitions[root]))\n+    bitmap_clear_bit (&ptr->live_base_var, root);\n }\n \n \n@@ -743,9 +743,9 @@ live_track_add_partition (live_track *ptr, int partition)\n   root = basevar_index (ptr->map, partition);\n   /* If this base var wasn't live before, it is now.  Clear the element list\n      since it was delayed until needed.  */\n-  if (bitmap_set_bit (ptr->live_base_var, root))\n-    bitmap_clear (ptr->live_base_partitions[root]);\n-  bitmap_set_bit (ptr->live_base_partitions[root], partition);\n+  if (bitmap_set_bit (&ptr->live_base_var, root))\n+    bitmap_clear (&ptr->live_base_partitions[root]);\n+  bitmap_set_bit (&ptr->live_base_partitions[root], partition);\n \n }\n \n@@ -774,8 +774,8 @@ live_track_live_p (live_track *ptr, tree var)\n   if (p != NO_PARTITION)\n     {\n       root = basevar_index (ptr->map, p);\n-      if (bitmap_bit_p (ptr->live_base_var, root))\n-\treturn bitmap_bit_p (ptr->live_base_partitions[root], p);\n+      if (bitmap_bit_p (&ptr->live_base_var, root))\n+\treturn bitmap_bit_p (&ptr->live_base_partitions[root], p);\n     }\n   return false;\n }\n@@ -819,9 +819,9 @@ live_track_process_def (live_track *ptr, tree def, ssa_conflicts *graph)\n \n   /* If the bitmap isn't empty now, conflicts need to be added.  */\n   root = basevar_index (ptr->map, p);\n-  if (bitmap_bit_p (ptr->live_base_var, root))\n+  if (bitmap_bit_p (&ptr->live_base_var, root))\n     {\n-      b = ptr->live_base_partitions[root];\n+      b = &ptr->live_base_partitions[root];\n       EXECUTE_IF_SET_IN_BITMAP (b, 0, x, bi)\n         ssa_conflicts_add (graph, p, x);\n     }\n@@ -850,7 +850,7 @@ live_track_clear_base_vars (live_track *ptr)\n   /* Simply clear the live base list.  Anything marked as live in the element\n      lists will be cleared later if/when the base variable ever comes alive\n      again.  */\n-  bitmap_clear (ptr->live_base_var);\n+  bitmap_clear (&ptr->live_base_var);\n }\n \n "}]}