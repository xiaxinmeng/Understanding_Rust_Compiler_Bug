{"sha": "07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczMDhjZGIwYzg2NWI4NDYzOTZhZjRlYmUwN2NjYzlmM2E2ZjNmMw==", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2020-03-05T01:57:10Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-08T04:44:50Z"}, "message": "AVX512FP16: Add ABI test for ymm.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/abi-avx512fp16-ymm.exp:\n\tNew exp file.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/args.h: New header.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/avx512fp16-ymm-check.h:\n\tLikewise.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S: New.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/test_m256_returning.c:\n\tNew test.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/test_passing_m256.c: Likewise.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/test_passing_structs.c:\n\tLikewise.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/test_passing_unions.c:\n\tLikewise.\n\t* gcc.target/x86_64/abi/avx512fp16/m256h/test_varargs-m256.c: Likewise.", "tree": {"sha": "98062d3184103d976d86b0a7bab9ca99383fc9da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98062d3184103d976d86b0a7bab9ca99383fc9da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22ce16ffa434bf28892668089af00cdd0f96c03c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22ce16ffa434bf28892668089af00cdd0f96c03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22ce16ffa434bf28892668089af00cdd0f96c03c"}], "stats": {"total": 1345, "additions": 1345, "deletions": 0}, "files": [{"sha": "ecf673bf7962c29363482e29da4b39b10662bdfa", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/abi-avx512fp16-ymm.exp", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fabi-avx512fp16-ymm.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fabi-avx512fp16-ymm.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fabi-avx512fp16-ymm.exp?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,45 @@\n+# Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# The x86-64 ABI testsuite needs one additional assembler file for most\n+# testcases.  For simplicity we will just link it into each test.\n+\n+load_lib c-torture.exp\n+load_lib target-supports.exp\n+load_lib torture-options.exp\n+load_lib file-format.exp\n+\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || [is-effective-target ia32]\n+     || [gcc_target_object_format] != \"elf\"\n+     || ![is-effective-target avx512fp16] } then {\n+  return\n+}\n+\n+\n+torture-init\n+set-torture-options $C_TORTURE_OPTIONS\n+set additional_flags \"-W -Wall -Wno-abi -mavx512fp16\"\n+\n+foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {\n+    if {[runtest_file_p $runtests $src]} {\n+\tc-torture-execute [list $src \\\n+\t\t\t\t$srcdir/$subdir/asm-support.S] \\\n+\t\t\t\t$additional_flags\n+    }\n+}\n+\n+torture-finish"}, {"sha": "136db48c1446be685be1ff0fddea277b187ccd57", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/args.h", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fargs.h?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,182 @@\n+#ifndef INCLUDED_ARGS_H\n+#define INCLUDED_ARGS_H\n+\n+#include <immintrin.h>\n+#include <string.h>\n+\n+/* Assertion macro.  */\n+#define assert(test) if (!(test)) abort()\n+\n+#ifdef __GNUC__\n+#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n+#else\n+#define ATTRIBUTE_UNUSED\n+#endif\n+\n+/* This defines the calling sequences for integers and floats.  */\n+#define I0 rdi\n+#define I1 rsi\n+#define I2 rdx\n+#define I3 rcx\n+#define I4 r8\n+#define I5 r9\n+#define F0 ymm0\n+#define F1 ymm1\n+#define F2 ymm2\n+#define F3 ymm3\n+#define F4 ymm4\n+#define F5 ymm5\n+#define F6 ymm6\n+#define F7 ymm7\n+\n+typedef union {\n+  _Float16 __Float16[16];\n+  float _float[8];\n+  double _double[4];\n+  long _long[4];\n+  int _int[8];\n+  unsigned long _ulong[4];\n+  __m64 _m64[4];\n+  __m128 _m128[2];\n+  __m256 _m256[1];\n+  __m256h _m256h[1];\n+} YMM_T;\n+\n+typedef union {\n+  float _float;\n+  double _double;\n+  long double _ldouble;\n+  unsigned long _ulong[2];\n+} X87_T;\n+extern void (*callthis)(void);\n+extern unsigned long rax,rbx,rcx,rdx,rsi,rdi,rsp,rbp,r8,r9,r10,r11,r12,r13,r14,r15;\n+YMM_T ymm_regs[16];\n+X87_T x87_regs[8];\n+extern volatile unsigned long volatile_var;\n+extern void snapshot (void);\n+extern void snapshot_ret (void);\n+#define WRAP_CALL(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot)\n+#define WRAP_RET(N) \\\n+  (callthis = (void (*)()) (N), (typeof (&N)) snapshot_ret)\n+\n+/* Clear all integer registers.  */\n+#define clear_int_hardware_registers \\\n+  asm __volatile__ (\"xor %%rax, %%rax\\n\\t\" \\\n+\t\t    \"xor %%rbx, %%rbx\\n\\t\" \\\n+\t\t    \"xor %%rcx, %%rcx\\n\\t\" \\\n+\t\t    \"xor %%rdx, %%rdx\\n\\t\" \\\n+\t\t    \"xor %%rsi, %%rsi\\n\\t\" \\\n+\t\t    \"xor %%rdi, %%rdi\\n\\t\" \\\n+\t\t    \"xor %%r8, %%r8\\n\\t\" \\\n+\t\t    \"xor %%r9, %%r9\\n\\t\" \\\n+\t\t    \"xor %%r10, %%r10\\n\\t\" \\\n+\t\t    \"xor %%r11, %%r11\\n\\t\" \\\n+\t\t    \"xor %%r12, %%r12\\n\\t\" \\\n+\t\t    \"xor %%r13, %%r13\\n\\t\" \\\n+\t\t    \"xor %%r14, %%r14\\n\\t\" \\\n+\t\t    \"xor %%r15, %%r15\\n\\t\" \\\n+\t\t    ::: \"rax\", \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\", \"r8\", \\\n+\t\t    \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\");\n+\n+/* This is the list of registers available for passing arguments. Not all of\n+   these are used or even really available.  */\n+struct IntegerRegisters\n+{\n+  unsigned long rax, rbx, rcx, rdx, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15;\n+};\n+struct FloatRegisters\n+{\n+  double mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7;\n+  long double st0, st1, st2, st3, st4, st5, st6, st7;\n+  YMM_T ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7, ymm8, ymm9,\n+        ymm10, ymm11, ymm12, ymm13, ymm14, ymm15;\n+};\n+\n+/* Implemented in scalarargs.c  */\n+extern struct IntegerRegisters iregs;\n+extern struct FloatRegisters fregs;\n+extern unsigned int num_iregs, num_fregs;\n+\n+#define check_int_arguments do { \\\n+  assert (num_iregs <= 0 || iregs.I0 == I0); \\\n+  assert (num_iregs <= 1 || iregs.I1 == I1); \\\n+  assert (num_iregs <= 2 || iregs.I2 == I2); \\\n+  assert (num_iregs <= 3 || iregs.I3 == I3); \\\n+  assert (num_iregs <= 4 || iregs.I4 == I4); \\\n+  assert (num_iregs <= 5 || iregs.I5 == I5); \\\n+  } while (0)\n+\n+#define check_char_arguments check_int_arguments\n+#define check_short_arguments check_int_arguments\n+#define check_long_arguments check_int_arguments\n+\n+/* Clear register struct.  */\n+#define clear_struct_registers \\\n+  rax = rbx = rcx = rdx = rdi = rsi = rbp = rsp \\\n+    = r8 = r9 = r10 = r11 = r12 = r13 = r14 = r15 = 0; \\\n+  memset (&iregs, 0, sizeof (iregs)); \\\n+  memset (&fregs, 0, sizeof (fregs)); \\\n+  memset (ymm_regs, 0, sizeof (ymm_regs)); \\\n+  memset (x87_regs, 0, sizeof (x87_regs));\n+\n+/* Clear both hardware and register structs for integers.  */\n+#define clear_int_registers \\\n+  clear_struct_registers \\\n+  clear_int_hardware_registers\n+\n+/* TODO: Do the checking.  */\n+#define check_f_arguments(T) do { \\\n+  assert (num_fregs <= 0 || fregs.ymm0._ ## T [0] == ymm_regs[0]._ ## T [0]); \\\n+  assert (num_fregs <= 1 || fregs.ymm1._ ## T [0] == ymm_regs[1]._ ## T [0]); \\\n+  assert (num_fregs <= 2 || fregs.ymm2._ ## T [0] == ymm_regs[2]._ ## T [0]); \\\n+  assert (num_fregs <= 3 || fregs.ymm3._ ## T [0] == ymm_regs[3]._ ## T [0]); \\\n+  assert (num_fregs <= 4 || fregs.ymm4._ ## T [0] == ymm_regs[4]._ ## T [0]); \\\n+  assert (num_fregs <= 5 || fregs.ymm5._ ## T [0] == ymm_regs[5]._ ## T [0]); \\\n+  assert (num_fregs <= 6 || fregs.ymm6._ ## T [0] == ymm_regs[6]._ ## T [0]); \\\n+  assert (num_fregs <= 7 || fregs.ymm7._ ## T [0] == ymm_regs[7]._ ## T [0]); \\\n+  } while (0)\n+\n+#define check_float_arguments check_f_arguments(float)\n+#define check_double_arguments check_f_arguments(double)\n+\n+#define check_vector_arguments(T,O) do { \\\n+  assert (num_fregs <= 0 \\\n+\t  || memcmp (((char *) &fregs.ymm0) + (O), \\\n+\t\t     &ymm_regs[0], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 1 \\\n+\t  || memcmp (((char *) &fregs.ymm1) + (O), \\\n+\t\t     &ymm_regs[1], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 2 \\\n+\t  || memcmp (((char *) &fregs.ymm2) + (O), \\\n+\t\t     &ymm_regs[2], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 3 \\\n+\t  || memcmp (((char *) &fregs.ymm3) + (O), \\\n+\t\t     &ymm_regs[3], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 4 \\\n+\t  || memcmp (((char *) &fregs.ymm4) + (O), \\\n+\t\t     &ymm_regs[4], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 5 \\\n+\t  || memcmp (((char *) &fregs.ymm5) + (O), \\\n+\t\t     &ymm_regs[5], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 6 \\\n+\t  || memcmp (((char *) &fregs.ymm6) + (O), \\\n+\t\t     &ymm_regs[6], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  assert (num_fregs <= 7 \\\n+\t  || memcmp (((char *) &fregs.ymm7) + (O), \\\n+\t\t     &ymm_regs[7], \\\n+\t\t     sizeof (__ ## T) - (O)) == 0); \\\n+  } while (0)\n+\n+#define check_m64_arguments check_vector_arguments(m64, 0)\n+#define check_m128_arguments check_vector_arguments(m128, 0)\n+#define check_m256_arguments check_vector_arguments(m256, 0)\n+\n+#endif /* INCLUDED_ARGS_H  */"}, {"sha": "73a59191d6d07ea6995417246187586b8fefc6de", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/asm-support.S", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fasm-support.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fasm-support.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Fasm-support.S?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,81 @@\n+\t.text\n+\t.p2align 4,,15\n+.globl snapshot\n+\t.type\tsnapshot, @function\n+snapshot:\n+.LFB3:\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rbx, rbx(%rip)\n+\tmovq\t%rcx, rcx(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tmovq\t%rdi, rdi(%rip)\n+\tmovq\t%rsi, rsi(%rip)\n+\tmovq\t%rbp, rbp(%rip)\n+\tmovq\t%rsp, rsp(%rip)\n+\tmovq\t%r8, r8(%rip)\n+\tmovq\t%r9, r9(%rip)\n+\tmovq\t%r10, r10(%rip)\n+\tmovq\t%r11, r11(%rip)\n+\tmovq\t%r12, r12(%rip)\n+\tmovq\t%r13, r13(%rip)\n+\tmovq\t%r14, r14(%rip)\n+\tmovq\t%r15, r15(%rip)\n+\tvmovdqu\t%ymm0, ymm_regs+0(%rip)\n+\tvmovdqu\t%ymm1, ymm_regs+32(%rip)\n+\tvmovdqu\t%ymm2, ymm_regs+64(%rip)\n+\tvmovdqu\t%ymm3, ymm_regs+96(%rip)\n+\tvmovdqu\t%ymm4, ymm_regs+128(%rip)\n+\tvmovdqu\t%ymm5, ymm_regs+160(%rip)\n+\tvmovdqu\t%ymm6, ymm_regs+192(%rip)\n+\tvmovdqu\t%ymm7, ymm_regs+224(%rip)\n+\tvmovdqu\t%ymm8, ymm_regs+256(%rip)\n+\tvmovdqu\t%ymm9, ymm_regs+288(%rip)\n+\tvmovdqu\t%ymm10, ymm_regs+320(%rip)\n+\tvmovdqu\t%ymm11, ymm_regs+352(%rip)\n+\tvmovdqu\t%ymm12, ymm_regs+384(%rip)\n+\tvmovdqu\t%ymm13, ymm_regs+416(%rip)\n+\tvmovdqu\t%ymm14, ymm_regs+448(%rip)\n+\tvmovdqu\t%ymm15, ymm_regs+480(%rip)\n+\tjmp\t*callthis(%rip)\n+.LFE3:\n+\t.size\tsnapshot, .-snapshot\n+\n+\t.p2align 4,,15\n+.globl snapshot_ret\n+\t.type\tsnapshot_ret, @function\n+snapshot_ret:\n+\tmovq\t%rdi, rdi(%rip)\n+\tsubq\t$8, %rsp\n+\tcall\t*callthis(%rip)\n+\taddq\t$8, %rsp\n+\tmovq\t%rax, rax(%rip)\n+\tmovq\t%rdx, rdx(%rip)\n+\tvmovdqu\t%ymm0, ymm_regs+0(%rip)\n+\tvmovdqu\t%ymm1, ymm_regs+32(%rip)\n+\tfstpt\tx87_regs(%rip)\n+\tfstpt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs+16(%rip)\n+\tfldt\tx87_regs(%rip)\n+\tret\n+\t.size\tsnapshot_ret, .-snapshot_ret\n+\n+\t.comm\tcallthis,8,8\n+\t.comm\trax,8,8\n+\t.comm\trbx,8,8\n+\t.comm\trcx,8,8\n+\t.comm\trdx,8,8\n+\t.comm\trsi,8,8\n+\t.comm\trdi,8,8\n+\t.comm\trsp,8,8\n+\t.comm\trbp,8,8\n+\t.comm\tr8,8,8\n+\t.comm\tr9,8,8\n+\t.comm\tr10,8,8\n+\t.comm\tr11,8,8\n+\t.comm\tr12,8,8\n+\t.comm\tr13,8,8\n+\t.comm\tr14,8,8\n+\t.comm\tr15,8,8\n+\t.comm\tymm_regs,512,32\n+\t.comm\tx87_regs,128,32\n+\t.comm   volatile_var,8,8"}, {"sha": "6a55030c0d4d00de336d3782548c9c0e323d1fb5", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/avx512fp16-ymm-check.h", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Favx512fp16-ymm-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Favx512fp16-ymm-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Favx512fp16-ymm-check.h?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,3 @@\n+#define AVX512VL(ebx) (ebx & bit_AVX512VL)\n+#define XSTATE_MASK (XSTATE_SSE | XSTATE_YMM | XSTATE_OPMASK)\n+#include \"../avx512fp16-check.h\""}, {"sha": "48e0139f416eccf442a304b3d7b53401865fedcf", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/test_m256_returning.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_m256_returning.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_m256_returning.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_m256_returning.c?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,54 @@\n+#include <stdio.h>\n+#include \"avx512fp16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+__m256\n+fun_test_returning___m256 (void)\n+{\n+  volatile_var++;\n+  return (__m256){73,0,0,0,0,0,0,0};\n+}\n+\n+__m256h\n+fun_test_returning___m256h (void)\n+{\n+  volatile_var++;\n+  return (__m256h){1.1f16,2.1f16,3.1f16,4.1f16,\n+                   5.1f16,6.1f16,7.1f16,8.1f16,\n+                   9.1f16,10.1f16,11.1f16,12.1f16,\n+\t\t   13.1f16,14.1f16,15.1f16,16.1f16};\n+}\n+\n+__m256 test_256;\n+__m256h test_256h;\n+\n+static void\n+do_test (void)\n+{\n+  unsigned failed = 0;\n+  YMM_T ymmt1, ymmt2;\n+\n+  clear_struct_registers;\n+  test_256 = (__m256){73,0,0,0,0,0,0,0};\n+  ymmt1._m256[0] = test_256;\n+  ymmt2._m256[0] = WRAP_RET (fun_test_returning___m256)();\n+  if (memcmp (&ymmt1, &ymmt2, sizeof (ymmt2)) != 0)\n+    printf (\"fail m256\\n\"), failed++;\n+\n+  clear_struct_registers;\n+  test_256h = (__m256h){1.1f16,2.1f16,3.1f16,4.1f16,\n+                        5.1f16,6.1f16,7.1f16,8.1f16,\n+                        9.1f16,10.1f16,11.1f16,12.1f16,\n+\t\t\t13.1f16,14.1f16,15.1f16,16.1f16};\n+  ymmt1._m256h[0] = test_256h;\n+  ymmt2._m256h[0] = WRAP_RET (fun_test_returning___m256h)();\n+  if (memcmp (&ymmt1, &ymmt2, sizeof (ymmt2)) != 0)\n+    printf (\"fail m256h\\n\"), failed++;\n+\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "bfa80d616eef20f43bee36feae8f04045c1ab951", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/test_passing_m256.c", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_m256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_m256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_m256.c?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,370 @@\n+#include <stdio.h>\n+#include \"avx512fp16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct\n+{\n+  YMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15,\n+    i16, i17, i18, i19, i20, i21, i22, i23;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+fun_check_passing_m256_8_values (__m256 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256);\n+  compare (values.i1, i1, __m256);\n+  compare (values.i2, i2, __m256);\n+  compare (values.i3, i3, __m256);\n+  compare (values.i4, i4, __m256);\n+  compare (values.i5, i5, __m256);\n+  compare (values.i6, i6, __m256);\n+  compare (values.i7, i7, __m256);\n+}\n+\n+fun_check_passing_m256h_8_values (__m256h i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256h i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256h);\n+  compare (values.i1, i1, __m256h);\n+  compare (values.i2, i2, __m256h);\n+  compare (values.i3, i3, __m256h);\n+  compare (values.i4, i4, __m256h);\n+  compare (values.i5, i5, __m256h);\n+  compare (values.i6, i6, __m256h);\n+  compare (values.i7, i7, __m256h);\n+}\n+\n+void\n+fun_check_passing_m256_8_regs (__m256 i0 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i1 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i2 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i3 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i4 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i5 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i6 ATTRIBUTE_UNUSED,\n+\t\t\t       __m256 i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+void\n+fun_check_passing_m256h_8_regs (__m256h i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256h i7 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+void\n+fun_check_passing_m256_20_values (__m256 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t  __m256 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256);\n+  compare (values.i1, i1, __m256);\n+  compare (values.i2, i2, __m256);\n+  compare (values.i3, i3, __m256);\n+  compare (values.i4, i4, __m256);\n+  compare (values.i5, i5, __m256);\n+  compare (values.i6, i6, __m256);\n+  compare (values.i7, i7, __m256);\n+  compare (values.i8, i8, __m256);\n+  compare (values.i9, i9, __m256);\n+  compare (values.i10, i10, __m256);\n+  compare (values.i11, i11, __m256);\n+  compare (values.i12, i12, __m256);\n+  compare (values.i13, i13, __m256);\n+  compare (values.i14, i14, __m256);\n+  compare (values.i15, i15, __m256);\n+  compare (values.i16, i16, __m256);\n+  compare (values.i17, i17, __m256);\n+  compare (values.i18, i18, __m256);\n+  compare (values.i19, i19, __m256);\n+}\n+\n+void\n+fun_check_passing_m256h_20_values (__m256h i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t   __m256h i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check argument values.  */\n+  compare (values.i0, i0, __m256h);\n+  compare (values.i1, i1, __m256h);\n+  compare (values.i2, i2, __m256h);\n+  compare (values.i3, i3, __m256h);\n+  compare (values.i4, i4, __m256h);\n+  compare (values.i5, i5, __m256h);\n+  compare (values.i6, i6, __m256h);\n+  compare (values.i7, i7, __m256h);\n+  compare (values.i8, i8, __m256h);\n+  compare (values.i9, i9, __m256h);\n+  compare (values.i10, i10, __m256h);\n+  compare (values.i11, i11, __m256h);\n+  compare (values.i12, i12, __m256h);\n+  compare (values.i13, i13, __m256h);\n+  compare (values.i14, i14, __m256h);\n+  compare (values.i15, i15, __m256h);\n+  compare (values.i16, i16, __m256h);\n+  compare (values.i17, i17, __m256h);\n+  compare (values.i18, i18, __m256h);\n+  compare (values.i19, i19, __m256h);\n+}\n+\n+void\n+fun_check_passing_m256_20_regs (__m256 i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t__m256 i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+void\n+fun_check_passing_m256h_20_regs (__m256h i0 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i1 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i2 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i3 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i4 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i5 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i6 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i7 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i8 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i9 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i10 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i11 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i12 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i13 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i14 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i15 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i16 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i17 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i18 ATTRIBUTE_UNUSED,\n+\t\t\t\t __m256h i19 ATTRIBUTE_UNUSED)\n+{\n+  /* Check register contents.  */\n+  check_m256_arguments;\n+}\n+\n+#define def_check_passing8(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _func1, _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7); \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7);\n+\n+#define def_check_passing20(_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, \\\n+\t\t\t    _i8, _i9, _i10, _i11, _i12, _i13, _i14, \\\n+\t\t\t    _i15, _i16, _i17, _i18, _i19, _func1, \\\n+\t\t\t    _func2, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  values.i10.TYPE[0] = _i10; \\\n+  values.i11.TYPE[0] = _i11; \\\n+  values.i12.TYPE[0] = _i12; \\\n+  values.i13.TYPE[0] = _i13; \\\n+  values.i14.TYPE[0] = _i14; \\\n+  values.i15.TYPE[0] = _i15; \\\n+  values.i16.TYPE[0] = _i16; \\\n+  values.i17.TYPE[0] = _i17; \\\n+  values.i18.TYPE[0] = _i18; \\\n+  values.i19.TYPE[0] = _i19; \\\n+  WRAP_CALL(_func1) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, \\\n+\t\t     _i9, _i10, _i11, _i12, _i13, _i14, _i15, \\\n+\t\t     _i16, _i17, _i18, _i19); \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  fregs.F4.TYPE[0] = _i4; \\\n+  fregs.F5.TYPE[0] = _i5; \\\n+  fregs.F6.TYPE[0] = _i6; \\\n+  fregs.F7.TYPE[0] = _i7; \\\n+  num_fregs = 8; \\\n+  WRAP_CALL(_func2) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, \\\n+\t\t     _i9, _i10, _i11, _i12, _i13, _i14, _i15, \\\n+\t\t     _i16, _i17, _i18, _i19);\n+\n+void\n+test_m256_on_stack ()\n+{\n+  __m256 x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m256){32 + i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m256-8\";\n+  def_check_passing8 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],\n+\t\t      fun_check_passing_m256_8_values,\n+\t\t      fun_check_passing_m256_8_regs, _m256);\n+}\n+\n+void\n+test_m256h_on_stack ()\n+{\n+  __m256h x[8];\n+  int i;\n+  for (i = 0; i < 8; i++)\n+    x[i] = (__m256h){1.1f16 + i, 2.1f16 + i, 3.1f16 + i, 4.1f16 + i,\n+\t             5.1f16 + i, 6.1f16 + i, 7.1f16 + i, 8.1f16 + i,\n+\t             9.1f16 + i, 10.1f16 + i, 11.1f16 + i, 12.1f16 + i,\n+\t             13.1f16 + i, 14.1f16 + i, 15.1f16 + i, 16.1f16 + i};\n+  pass = \"m256h-8\";\n+  def_check_passing8 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7],\n+\t\t      fun_check_passing_m256h_8_values,\n+\t\t      fun_check_passing_m256h_8_regs, _m256h);\n+}\n+\n+void\n+test_too_many_m256 ()\n+{\n+  __m256 x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m256){32 + i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m256-20\";\n+  def_check_passing20 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8],\n+\t\t       x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16],\n+\t\t       x[17], x[18], x[19], fun_check_passing_m256_20_values,\n+\t\t       fun_check_passing_m256_20_regs, _m256);\n+}\n+\n+void\n+test_too_many_m256h ()\n+{\n+  __m256h x[20];\n+  int i;\n+  for (i = 0; i < 20; i++)\n+    x[i] = (__m256h){1.1f16 + i, 2.1f16 + i, 3.1f16 + i, 4.1f16 + i,\n+\t             5.1f16 + i, 6.1f16 + i, 7.1f16 + i, 8.1f16 + i,\n+\t             9.1f16 + i, 10.1f16 + i, 11.1f16 + i, 12.1f16 + i,\n+\t             13.1f16 + i, 14.1f16 + i, 15.1f16 + i, 16.1f16 + i};\n+  pass = \"m256h-20\";\n+  def_check_passing20 (x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8],\n+\t\t       x[9], x[10], x[11], x[12], x[13], x[14], x[15], x[16],\n+\t\t       x[17], x[18], x[19], fun_check_passing_m256h_20_values,\n+\t\t       fun_check_passing_m256h_20_regs, _m256h);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  test_m256_on_stack ();\n+  test_too_many_m256 ();\n+  test_m256h_on_stack ();\n+  test_too_many_m256h ();\n+  if (failed)\n+    abort ();\n+}"}, {"sha": "eff10badd6ba58b7568657a8bdfb59d095b361ce", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/test_passing_structs.c", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_structs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_structs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_structs.c?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,113 @@\n+#include \"avx512fp16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+struct m256_struct\n+{\n+  __m256 x;\n+};\n+\n+struct m256_2_struct\n+{\n+  __m256 x1, x2;\n+};\n+\n+struct m256h_struct\n+{\n+  __m256h x;\n+};\n+\n+struct m256h_2_struct\n+{\n+  __m256h x1, x2;\n+};\n+\n+/* Check that the struct is passed as the individual members in fregs.  */\n+void\n+check_struct_passing1 (struct m256_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t       struct m256_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_struct_passing2 (struct m256_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+40);\n+}\n+\n+void\n+check_struct_passing1h (struct m256h_struct ms1 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms2 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms3 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms4 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms5 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms6 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms7 ATTRIBUTE_UNUSED,\n+\t\t        struct m256h_struct ms8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_struct_passing2h (struct m256h_2_struct ms ATTRIBUTE_UNUSED)\n+{\n+  /* Check the passing on the stack by comparing the address of the\n+     stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&ms.x1 == rsp+8);\n+  assert ((unsigned long)&ms.x2 == rsp+40);\n+}\n+\n+static void\n+do_test (void)\n+{\n+  struct m256_struct m256s [8];\n+  struct m256h_struct m256hs [8];\n+  struct m256_2_struct m256_2s = { \n+      { 48.394, 39.3, -397.9, 3484.9, -8.394, -93.3, 7.9, 84.94 },\n+      { -8.394, -3.3, -39.9, 34.9, 7.9, 84.94, -48.394, 39.3 }\n+  };\n+  struct m256h_2_struct m256h_2s = { \n+      { 47.364f16, 36.3f16, -367.6f16, 3474.6f16, -7.364f16, -63.3f16, 7.6f16, 74.64f16,\n+        57.865f16, 86.8f16, -867.6f16, 8575.6f16, -7.865f16, -68.8f16, 7.6f16, 75.65f16  },\n+      { -7.364f16, -3.3f16, -36.6f16, 34.6f16, 7.6f16, 74.64f16, -47.364f16, 36.3f16,\n+        -8.364f16, -3.3f16, -36.6f16, 34.6f16, 8.6f16, 84.64f16, -48.364f16, 36.3f16  }\n+  };\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      m256s[i].x = (__m256){32+i, 0, i, 0, -i, 0, i - 12, i + 8};\n+\n+      m256hs[i].x = (__m256h){33+i, 0, i, 0, -i, 0, i - 11, i + 9,\n+                              31+i, 2, i, 3, -i, 4, i - 10, i + 7};\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.ymm0)[i]._m256[0] = m256s[i].x;\n+  num_fregs = 8;\n+  WRAP_CALL (check_struct_passing1)(m256s[0], m256s[1], m256s[2], m256s[3],\n+\t\t\t\t    m256s[4], m256s[5], m256s[6], m256s[7]);\n+  WRAP_CALL (check_struct_passing2)(m256_2s);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.ymm0)[i]._m256h[0] = m256hs[i].x;\n+  num_fregs = 8;\n+  WRAP_CALL (check_struct_passing1h)(m256hs[0], m256hs[1], m256hs[2], m256hs[3],\n+\t\t\t\t    m256hs[4], m256hs[5], m256hs[6], m256hs[7]);\n+  WRAP_CALL (check_struct_passing2h)(m256h_2s);\n+}"}, {"sha": "76f300c3e5d939c50bf7e26744f2c54f465edbf4", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/test_passing_unions.c", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_unions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_unions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_passing_unions.c?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,337 @@\n+#include \"avx512fp16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+unsigned int num_iregs, num_fregs;\n+\n+union un1\n+{\n+  __m256 x;\n+  float f;\n+};\n+\n+union un2\n+{\n+  __m256 x;\n+  double d;\n+};\n+\n+union un3\n+{\n+  __m256 x;\n+  __m128 v;\n+};\n+\n+union un4\n+{\n+  __m256 x;\n+  long double ld;\n+};\n+\n+union un5\n+{\n+  __m256 x;\n+  int i;\n+};\n+\n+union un1a\n+{\n+  __m256 x;\n+  _Float16 f;\n+};\n+\n+union un1h\n+{\n+  __m256h x;\n+  float f;\n+};\n+\n+union un1hh\n+{\n+  __m256h x;\n+  _Float16 f;\n+};\n+\n+union un2h\n+{\n+  __m256h x;\n+  double d;\n+};\n+\n+union un3h\n+{\n+  __m256h x;\n+  __m128 v;\n+};\n+\n+union un4h\n+{\n+  __m256h x;\n+  long double ld;\n+};\n+\n+union un5h\n+{\n+  __m256h x;\n+  int i;\n+};\n+\n+void\n+check_union_passing1(union un1 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un1 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing1a(union un1a u1 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u2 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u3 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u4 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u5 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u6 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u7 ATTRIBUTE_UNUSED,\n+\t\t      union un1a u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing1h(union un1h u1 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u2 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u3 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u4 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u5 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u6 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u7 ATTRIBUTE_UNUSED,\n+\t\t      union un1h u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing1hh(union un1hh u1 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u2 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u3 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u4 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u5 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u6 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u7 ATTRIBUTE_UNUSED,\n+\t\t       union un1hh u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing2(union un2 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un2 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing2h(union un2h u1 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u2 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u3 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u4 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u5 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u6 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u7 ATTRIBUTE_UNUSED,\n+\t\t      union un2h u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing3(union un3 u1 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u2 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u3 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u4 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u5 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u6 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u7 ATTRIBUTE_UNUSED,\n+\t\t     union un3 u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing3h(union un3h u1 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u2 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u3 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u4 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u5 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u6 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u7 ATTRIBUTE_UNUSED,\n+\t\t      union un3h u8 ATTRIBUTE_UNUSED)\n+{\n+  check_m256_arguments;\n+}\n+\n+void\n+check_union_passing4(union un4 u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.ld == rsp+8);\n+}\n+\n+void\n+check_union_passing4h(union un4h u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.ld == rsp+8);\n+}\n+\n+void\n+check_union_passing5(union un5 u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.i == rsp+8);\n+}\n+\n+void\n+check_union_passing5h(union un5h u ATTRIBUTE_UNUSED)\n+{\n+   /* Check the passing on the stack by comparing the address of the\n+      stack elements to the expected place on the stack.  */\n+  assert ((unsigned long)&u.x == rsp+8);\n+  assert ((unsigned long)&u.i == rsp+8);\n+}\n+\n+#define check_union_passing1 WRAP_CALL(check_union_passing1)\n+#define check_union_passing2 WRAP_CALL(check_union_passing2)\n+#define check_union_passing3 WRAP_CALL(check_union_passing3)\n+#define check_union_passing4 WRAP_CALL(check_union_passing4)\n+#define check_union_passing5 WRAP_CALL(check_union_passing5)\n+\n+#define check_union_passing1h WRAP_CALL(check_union_passing1h)\n+#define check_union_passing1a WRAP_CALL(check_union_passing1a)\n+#define check_union_passing1hh WRAP_CALL(check_union_passing1hh)\n+#define check_union_passing2h WRAP_CALL(check_union_passing2h)\n+#define check_union_passing3h WRAP_CALL(check_union_passing3h)\n+#define check_union_passing4h WRAP_CALL(check_union_passing4h)\n+#define check_union_passing5h WRAP_CALL(check_union_passing5h)\n+\n+static void\n+do_test (void)\n+{\n+  union un1 u1[8];\n+  union un2 u2[8];\n+  union un3 u3[8];\n+  union un4 u4;\n+  union un5 u5;\n+  union un1a u1a[8];\n+  union un1h u1h[8];\n+  union un1hh u1hh[8];\n+  union un2h u2h[8];\n+  union un3h u3h[8];\n+  union un4h u4h;\n+  union un5h u5h;\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1[i].x = (__m256){32+i, 0, i, 0, -i, 0, i - 12, i + 8};\n+      u1h[i].x = (__m256h){32+i, 0, i, 0, -i, 0, i - 12, i + 8,\n+                           33+i, 1, i, 2, -i, 4, i - 11, i + 9};\n+    }\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.ymm0)[i]._m256[0] = u1[i].x;\n+  num_fregs = 8;\n+  check_union_passing1(u1[0], u1[1], u1[2], u1[3],\n+\t\t       u1[4], u1[5], u1[6], u1[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1a[i].x = u1[i].x;\n+      (&fregs.ymm0)[i]._m256[0] = u1a[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing1a(u1a[0], u1a[1], u1a[2], u1a[3],\n+\t\t        u1a[4], u1a[5], u1a[6], u1a[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    (&fregs.ymm0)[i]._m256h[0] = u1h[i].x;\n+  num_fregs = 8;\n+  check_union_passing1h(u1h[0], u1h[1], u1h[2], u1h[3],\n+\t\t        u1h[4], u1h[5], u1h[6], u1h[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u1hh[i].x = u1h[i].x;\n+      (&fregs.ymm0)[i]._m256h[0] = u1hh[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing1hh(u1hh[0], u1hh[1], u1hh[2], u1hh[3],\n+\t\t         u1hh[4], u1hh[5], u1hh[6], u1hh[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u2[i].x = u1[i].x;\n+      (&fregs.ymm0)[i]._m256[0] = u2[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing2(u2[0], u2[1], u2[2], u2[3],\n+\t\t       u2[4], u2[5], u2[6], u2[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u2h[i].x = u1h[i].x;\n+      (&fregs.ymm0)[i]._m256h[0] = u2h[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing2h(u2h[0], u2h[1], u2h[2], u2h[3],\n+\t\t        u2h[4], u2h[5], u2h[6], u2h[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u3[i].x = u1[i].x;\n+      (&fregs.ymm0)[i]._m256[0] = u3[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing3(u3[0], u3[1], u3[2], u3[3],\n+\t\t       u3[4], u3[5], u3[6], u3[7]);\n+\n+  clear_struct_registers;\n+  for (i = 0; i < 8; i++)\n+    {\n+      u3h[i].x = u1h[i].x;\n+      (&fregs.ymm0)[i]._m256h[0] = u3h[i].x;\n+    }\n+  num_fregs = 8;\n+  check_union_passing3h(u3h[0], u3h[1], u3h[2], u3h[3],\n+\t\t        u3h[4], u3h[5], u3h[6], u3h[7]);\n+\n+  check_union_passing4(u4);\n+  check_union_passing5(u5);\n+\n+  check_union_passing4h(u4h);\n+  check_union_passing5h(u5h);\n+}"}, {"sha": "f15adb4a33bb930fe2c59fc3cdfce8b483e618c1", "filename": "gcc/testsuite/gcc.target/x86_64/abi/avx512fp16/m256h/test_varargs-m256.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_varargs-m256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07308cdb0c865b846396af4ebe07ccc9f3a6f3f3/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_varargs-m256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fx86_64%2Fabi%2Favx512fp16%2Fm256h%2Ftest_varargs-m256.c?ref=07308cdb0c865b846396af4ebe07ccc9f3a6f3f3", "patch": "@@ -0,0 +1,160 @@\n+/* Test variable number of 256-bit vector arguments passed to functions.  */\n+\n+#include <stdio.h>\n+#include \"avx512fp16-ymm-check.h\"\n+#include \"args.h\"\n+\n+struct IntegerRegisters iregs;\n+struct FloatRegisters fregs;\n+\n+/* This struct holds values for argument checking.  */\n+struct \n+{\n+  YMM_T i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+} values;\n+\n+char *pass;\n+int failed = 0;\n+\n+#undef assert\n+#define assert(c) do { \\\n+  if (!(c)) {failed++; printf (\"failed %s\\n\", pass); } \\\n+} while (0)\n+\n+#define compare(X1,X2,T) do { \\\n+  assert (memcmp (&X1, &X2, sizeof (T)) == 0); \\\n+} while (0)\n+\n+void\n+fun_check_passing_m256_varargs (__m256 i0, __m256 i1, __m256 i2,\n+\t\t\t\t__m256 i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m256 *argp;\n+\n+  compare (values.i0, i0, __m256);\n+  compare (values.i1, i1, __m256);\n+  compare (values.i2, i2, __m256);\n+  compare (values.i3, i3, __m256);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m256 *)(((char *) fp) + 8);\n+\n+  /* Check __m256 arguments passed on stack.  */\n+  compare (values.i4, argp[0], __m256);\n+  compare (values.i5, argp[1], __m256);\n+  compare (values.i6, argp[2], __m256);\n+  compare (values.i7, argp[3], __m256);\n+  compare (values.i8, argp[4], __m256);\n+  compare (values.i9, argp[5], __m256);\n+\n+  /* Check register contents.  */\n+  compare (fregs.ymm0, ymm_regs[0], __m256);\n+  compare (fregs.ymm1, ymm_regs[1], __m256);\n+  compare (fregs.ymm2, ymm_regs[2], __m256);\n+  compare (fregs.ymm3, ymm_regs[3], __m256);\n+}\n+\n+void\n+fun_check_passing_m256h_varargs (__m256h i0, __m256h i1, __m256h i2,\n+\t\t\t\t __m256h i3, ...)\n+{\n+  /* Check argument values.  */\n+  void **fp = __builtin_frame_address (0);\n+  void *ra = __builtin_return_address (0);\n+  __m256h *argp;\n+\n+  compare (values.i0, i0, __m256h);\n+  compare (values.i1, i1, __m256h);\n+  compare (values.i2, i2, __m256h);\n+  compare (values.i3, i3, __m256h);\n+\n+  /* Get the pointer to the return address on stack.  */\n+  while (*fp != ra)\n+    fp++;\n+\n+  /* Skip the return address stack slot.  */\n+  argp = (__m256h *)(((char *) fp) + 8);\n+\n+  /* Check __m256h arguments passed on stack.  */\n+  compare (values.i4, argp[0], __m256h);\n+  compare (values.i5, argp[1], __m256h);\n+  compare (values.i6, argp[2], __m256h);\n+  compare (values.i7, argp[3], __m256h);\n+  compare (values.i8, argp[4], __m256h);\n+  compare (values.i9, argp[5], __m256h);\n+\n+  /* Check register contents.  */\n+  compare (fregs.ymm0, ymm_regs[0], __m256h);\n+  compare (fregs.ymm1, ymm_regs[1], __m256h);\n+  compare (fregs.ymm2, ymm_regs[2], __m256h);\n+  compare (fregs.ymm3, ymm_regs[3], __m256h);\n+}\n+\n+#define def_check_int_passing_varargs(_i0, _i1, _i2, _i3, _i4, _i5, \\\n+\t\t\t\t      _i6, _i7, _i8, _i9, \\\n+\t\t\t\t      _func, TYPE) \\\n+  values.i0.TYPE[0] = _i0; \\\n+  values.i1.TYPE[0] = _i1; \\\n+  values.i2.TYPE[0] = _i2; \\\n+  values.i3.TYPE[0] = _i3; \\\n+  values.i4.TYPE[0] = _i4; \\\n+  values.i5.TYPE[0] = _i5; \\\n+  values.i6.TYPE[0] = _i6; \\\n+  values.i7.TYPE[0] = _i7; \\\n+  values.i8.TYPE[0] = _i8; \\\n+  values.i9.TYPE[0] = _i9; \\\n+  clear_struct_registers; \\\n+  fregs.F0.TYPE[0] = _i0; \\\n+  fregs.F1.TYPE[0] = _i1; \\\n+  fregs.F2.TYPE[0] = _i2; \\\n+  fregs.F3.TYPE[0] = _i3; \\\n+  WRAP_CALL(_func) (_i0, _i1, _i2, _i3, _i4, _i5, _i6, _i7, _i8, _i9);\n+\n+void\n+test_m256_varargs (void)\n+{\n+  __m256 x[10];\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m256){32+i, 0, 0, 0, 0, 0, 0, 0};\n+  pass = \"m256-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m256_varargs,\n+\t\t\t\t _m256);\n+}\n+\n+void\n+test_m256h_varargs (void)\n+{\n+  __m256h x[10];\n+  int i;\n+  for (i = 0; i < 10; i++)\n+    x[i] = (__m256h) {\n+        1.1f16 + i, 2.2f16 + i, 3.3f16 + i, 4.4f16 + i,\n+\t5.5f16 + i, 6.6f16 + i, 7.7f16 + i, 8.8f16 + i,\n+\t9.9f16 + i, 10.10f16 + i, 11.11f16 + i, 12.12f16 + i,\n+\t13.13f16 + i, 14.14f16 + i, 15.15f16 + i, 16.16f16 + i\n+    };\n+  pass = \"m256h-varargs\";\n+  def_check_int_passing_varargs (x[0], x[1], x[2], x[3], x[4], x[5],\n+\t\t\t\t x[6], x[7], x[8], x[9],\n+\t\t\t\t fun_check_passing_m256h_varargs,\n+\t\t\t\t _m256h);\n+}\n+\n+void\n+do_test (void)\n+{\n+  test_m256_varargs ();\n+  test_m256h_varargs ();\n+  if (failed)\n+    abort ();\n+}"}]}