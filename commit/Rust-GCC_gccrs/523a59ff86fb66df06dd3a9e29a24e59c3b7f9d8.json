{"sha": "523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIzYTU5ZmY4NmZiNjZkZjA2ZGQzYTllMjlhMjRlNTljM2I3ZjlkOA==", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2018-07-20T18:18:25Z"}, "committer": {"name": "Qing Zhao", "email": "qinzhao@gcc.gnu.org", "date": "2018-07-20T18:18:25Z"}, "message": "Give up the inlining expansion for strcmp/strncmp/memcmp on a target where the...\n\n\nGive up the inlining expansion for strcmp/strncmp/memcmp on a target \nwhere the type of the call has same or narrower presicion than unsigned\nchar.\nChange char to unsigned char for strcmp/strncmp when expand them to\na sequence of byte comparisons.\n \nDue to C standard section 7.24.4:\n\nThe sign of a nonzero value returned by the comparison functions memcmp,\nstrcmp, and strncmp is determined by the sign of the difference between \nthe values of the first pair of characters (both interpreted as unsigned \nchar) that differ in the objects being compared.\n\nbootstraped and tested on both X86 and Aarch64. no regression.\n\nFrom-SVN: r262907", "tree": {"sha": "54fb67ddff4aec02c1d0cf9cdfb1ba404382a5c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54fb67ddff4aec02c1d0cf9cdfb1ba404382a5c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cba563f71dbc137a6c0ba7c10bc8fef90203ea0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba563f71dbc137a6c0ba7c10bc8fef90203ea0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba563f71dbc137a6c0ba7c10bc8fef90203ea0c"}], "stats": {"total": 49, "additions": 36, "deletions": 13}, "files": [{"sha": "ea88fa147b82769023054dd63fdfaba16e12c936", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "patch": "@@ -1,3 +1,16 @@\n+2018-07-20  Qing Zhao  <qing.zhao@oracle.com>\n+\n+\t* builtins.c (expand_builtin_memcmp): Delete the last parameter for\n+\tcall to inline_expand_builtin_string_cmp.\n+\t(expand_builtin_strcmp): Likewise.\n+\t(expand_builtin_strncmp): Likewise.\n+\t(inline_string_cmp): Delete the last parameter, change char_type_node\n+\tto unsigned_char_type_node for strcmp/strncmp, add conversions to the\n+\ttwo operands.\n+\t(inline_expand_builtin_string_cmp): Delete the last parameter, give up\n+\tthe inlining expansion on target where the type of the call has same or \n+\tnarrower precision than unsigned char.\n+\n 2018-07-20  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (OBJS): Add json.o and optinfo-emit-json.o."}, {"sha": "493c9374167ddb867cd87d70ab3699d9f0c036d1", "filename": "gcc/builtins.c", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=523a59ff86fb66df06dd3a9e29a24e59c3b7f9d8", "patch": "@@ -119,7 +119,7 @@ static rtx expand_builtin_next_arg (void);\n static rtx expand_builtin_va_start (tree);\n static rtx expand_builtin_va_end (tree);\n static rtx expand_builtin_va_copy (tree);\n-static rtx inline_expand_builtin_string_cmp (tree, rtx, bool);\n+static rtx inline_expand_builtin_string_cmp (tree, rtx);\n static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, scalar_int_mode);\n@@ -4472,7 +4472,7 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n \n   if (!result_eq && fcode != BUILT_IN_BCMP && no_overflow)\n     {\n-      result = inline_expand_builtin_string_cmp (exp, target, true);\n+      result = inline_expand_builtin_string_cmp (exp, target);\n       if (result)\n \treturn result;\n     }\n@@ -4551,7 +4551,7 @@ expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n \n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n-  result = inline_expand_builtin_string_cmp (exp, target, false);\n+  result = inline_expand_builtin_string_cmp (exp, target);\n   if (result)\n     return result;\n \n@@ -4670,7 +4670,7 @@ expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \n   /* Due to the performance benefit, always inline the calls first.  */\n   rtx result = NULL_RTX;\n-  result = inline_expand_builtin_string_cmp (exp, target, false);\n+  result = inline_expand_builtin_string_cmp (exp, target);\n   if (result)\n     return result;\n \n@@ -6764,22 +6764,24 @@ expand_builtin_goacc_parlevel_id_size (tree exp, rtx target, int ignore)\n   \n    to: (assume const_str_n is 2, i.e., arg2 is a constant string)\n \n-   target = var_str[0] - const_str[0];\n+   target = (int) (unsigned char) var_str[0]\n+\t    - (int) (unsigned char) const_str[0];\n    if (target != 0)\n      goto ne_label;\n      ...\n-   target = var_str[length - 2] - const_str[length - 2];\n+   target = (int) (unsigned char) var_str[length - 2]\n+\t    - (int) (unsigned char) const_str[length - 2];\n    if (target != 0)\n      goto ne_label;\n-   target = var_str[length - 1] - const_str[length - 1];\n+   target = (int) (unsigned char) var_str[length - 1]\n+\t    - (int) (unsigned char) const_str[length - 1];\n    ne_label:\n   */\n \n static rtx\n inline_string_cmp (rtx target, tree var_str, const char *const_str,\n \t\t   unsigned HOST_WIDE_INT length,\n-\t\t   int const_str_n, machine_mode mode,\n-\t\t   bool is_memcmp)\n+\t\t   int const_str_n, machine_mode mode)\n {\n   HOST_WIDE_INT offset = 0;\n   rtx var_rtx_array\n@@ -6788,7 +6790,7 @@ inline_string_cmp (rtx target, tree var_str, const char *const_str,\n   rtx const_rtx = NULL_RTX;\n   rtx result = target ? target : gen_reg_rtx (mode);\n   rtx_code_label *ne_label = gen_label_rtx ();\n-  tree unit_type_node = is_memcmp ? unsigned_char_type_node : char_type_node;\n+  tree unit_type_node = unsigned_char_type_node;\n   scalar_int_mode unit_mode\n     = as_a <scalar_int_mode> TYPE_MODE (unit_type_node);\n \n@@ -6802,8 +6804,10 @@ inline_string_cmp (rtx target, tree var_str, const char *const_str,\n       rtx op0 = (const_str_n == 1) ? const_rtx : var_rtx;\n       rtx op1 = (const_str_n == 1) ? var_rtx : const_rtx;\n \n+      op0 = convert_modes (mode, unit_mode, op0, 1);\n+      op1 = convert_modes (mode, unit_mode, op1, 1);\n       result = expand_simple_binop (mode, MINUS, op0, op1,\n-\t\t\t\t    result, is_memcmp ? 1 : 0, OPTAB_WIDEN);\n+\t\t\t\t    result, 1, OPTAB_WIDEN);\n       if (i < length - 1)\n \temit_cmp_and_jump_insns (result, CONST0_RTX (mode), NE, NULL_RTX,\n \t    \t\t\t mode, true, ne_label);\n@@ -6822,7 +6826,7 @@ inline_string_cmp (rtx target, tree var_str, const char *const_str,\n    TARGET if that's convenient.\n    If the call is not been inlined, return NULL_RTX.  */\n static rtx\n-inline_expand_builtin_string_cmp (tree exp, rtx target, bool is_memcmp)\n+inline_expand_builtin_string_cmp (tree exp, rtx target)\n {\n   tree fndecl = get_callee_fndecl (exp);\n   enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n@@ -6833,6 +6837,12 @@ inline_expand_builtin_string_cmp (tree exp, rtx target, bool is_memcmp)\n \t\t       || fcode == BUILT_IN_STRNCMP\n \t\t       || fcode == BUILT_IN_MEMCMP);\n \n+  /* On a target where the type of the call (int) has same or narrower presicion\n+     than unsigned char, give up the inlining expansion.  */\n+  if (TYPE_PRECISION (unsigned_char_type_node)\n+      >= TYPE_PRECISION (TREE_TYPE (exp)))\n+    return NULL_RTX;\n+\n   tree arg1 = CALL_EXPR_ARG (exp, 0);\n   tree arg2 = CALL_EXPR_ARG (exp, 1);\n   tree len3_tree = is_ncmp ? CALL_EXPR_ARG (exp, 2) : NULL_TREE;\n@@ -6879,7 +6889,7 @@ inline_expand_builtin_string_cmp (tree exp, rtx target, bool is_memcmp)\n   /* Now, start inline expansion the call.  */\n   return inline_string_cmp (target, (const_str_n == 1) ? arg2 : arg1,\n \t\t\t    (const_str_n == 1) ? src_str1 : src_str2, length,\n-\t\t\t    const_str_n, mode, is_memcmp);\n+\t\t\t    const_str_n, mode);\n }\n \n /* Expand an expression EXP that calls a built-in function,"}]}