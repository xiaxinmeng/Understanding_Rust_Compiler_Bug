{"sha": "020b286c769f4dc8a6b45491351f6bc2e69d7a7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIwYjI4NmM3NjlmNGRjOGE2YjQ1NDkxMzUxZjZiYzJlNjlkN2E3Zg==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-03-11T17:04:14Z"}, "committer": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2021-03-15T15:54:29Z"}, "message": "coroutines : Handle rethrow from unhandled_exception [PR98704].\n\nAlthough there is still some discussion in CWG 2451 on this, the\nimplementors are agreed on the intent.\n\nWhen promise.unhandled_exception () is entered, the coroutine is\nconsidered to be still running - returning from the method will\ncause the final await expression to be evaluated.\n\nIf the method throws, that action is considered to make the\ncoroutine suspend (since, otherwise, it would be impossible to\nreclaim its resources, since one cannot destroy a running coro).\n\nThe wording issue is to do with how to represent the place at\nwhich the coroutine should be considered suspended.\n\nFor the implementation here, that place is immediately before the\npromise life-time ends. A handler for the rethrown exception, can\nthus call xxxx.destroy() which will run DTORs for the promise and\nany parameter copies [as needed] then the coroutine frame will be\ndeallocated.\n\nAt present, we also set \"done=true\" in this case (for compatibility\nwith other current implementations).  One might consider 'done()'\nto be misleading in the case of an abnormal termination - that is\nalso part of the CWG 2451 discussion.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/98704\n\t* coroutines.cc (build_actor_fn): Make destroy index 1\n\tcorrespond to the abnormal unhandled_exception() exit.\n\tSubstitute the proxy for the resume index.\n\t(coro_rewrite_function_body): Arrange to reset the resume\n\tindex and make done = true for a rethrown exception from\n\tunhandled_exception ().\n\t(morph_fn_to_coro): Adjust calls to build_actor_fn and\n\tcoro_rewrite_function_body.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/98704\n\t* g++.dg/coroutines/torture/pr98704.C: New test.", "tree": {"sha": "2d88556fada972c97c6015daa0a7d5c79f52d36b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d88556fada972c97c6015daa0a7d5c79f52d36b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/020b286c769f4dc8a6b45491351f6bc2e69d7a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/020b286c769f4dc8a6b45491351f6bc2e69d7a7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/020b286c769f4dc8a6b45491351f6bc2e69d7a7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/020b286c769f4dc8a6b45491351f6bc2e69d7a7f/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26e0eb1071e318728bcd33f28d055729ac48792c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26e0eb1071e318728bcd33f28d055729ac48792c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26e0eb1071e318728bcd33f28d055729ac48792c"}], "stats": {"total": 166, "additions": 145, "deletions": 21}, "files": [{"sha": "ea714da146b0096696d3b31cbadc04f59818d06b", "filename": "gcc/cp/coroutines.cc", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020b286c769f4dc8a6b45491351f6bc2e69d7a7f/gcc%2Fcp%2Fcoroutines.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020b286c769f4dc8a6b45491351f6bc2e69d7a7f/gcc%2Fcp%2Fcoroutines.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcoroutines.cc?ref=020b286c769f4dc8a6b45491351f6bc2e69d7a7f", "patch": "@@ -2145,7 +2145,7 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n \t\ttree orig, hash_map<tree, param_info> *param_uses,\n \t\thash_map<tree, local_var_info> *local_var_uses,\n \t\tvec<tree, va_gc> *param_dtor_list, tree resume_fn_field,\n-\t\tunsigned body_count, tree frame_size)\n+\t\ttree resume_idx_field, unsigned body_count, tree frame_size)\n {\n   verify_stmt_tree (fnbody);\n   /* Some things we inherit from the original function.  */\n@@ -2267,6 +2267,17 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   b = coro_build_cvt_void_expr_stmt (b, loc);\n   add_stmt (b);\n \n+  /* The destroy point numbered #1 is special, in that it is reached from a\n+     coroutine that is suspended after re-throwing from unhandled_exception().\n+     This label just invokes the cleanup of promise, param copies and the\n+     frame itself.  */\n+  tree del_promise_label\n+    = create_named_label_with_ctx (loc, \"coro.delete.promise\", actor);\n+  b = build_case_label (build_int_cst (short_unsigned_type_node, 1), NULL_TREE,\n+\t\t\tcreate_anon_label_with_ctx (loc, actor));\n+  add_stmt (b);\n+  add_stmt (build_stmt (loc, GOTO_EXPR, del_promise_label));\n+\n   short unsigned lab_num = 3;\n   for (unsigned destr_pt = 0; destr_pt < body_count; destr_pt++)\n     {\n@@ -2371,9 +2382,10 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   p_data.to = ap;\n   cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n \n-  /* Set the actor pointer to null, so that 'done' will work.\n-     Resume from here is UB anyway - although a 'ready' await will\n-     branch to the final resume, and fall through to the destroy.  */\n+  /* The rewrite of the function adds code to set the __resume field to\n+     nullptr when the coroutine is done and also the index to zero when\n+     calling an unhandled exception.  These are represented by two proxies\n+     in the function, so rewrite them to the proper frame access.  */\n   tree resume_m\n     = lookup_member (coro_frame_type, get_identifier (\"__resume\"),\n \t\t     /*protect=*/1, /*want_type=*/0, tf_warning_or_error);\n@@ -2383,12 +2395,14 @@ build_actor_fn (location_t loc, tree coro_frame_type, tree actor, tree fnbody,\n   p_data.to = res_x;\n   cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n \n+  p_data.from = resume_idx_field;\n+  p_data.to = rat;\n+  cp_walk_tree (&fnbody, replace_proxy, &p_data, NULL);\n+\n   /* Add in our function body with the co_returns rewritten to final form.  */\n   add_stmt (fnbody);\n \n   /* now do the tail of the function.  */\n-  tree del_promise_label\n-    = create_named_label_with_ctx (loc, \"coro.delete.promise\", actor);\n   r = build_stmt (loc, LABEL_EXPR, del_promise_label);\n   add_stmt (r);\n \n@@ -4022,9 +4036,9 @@ act_des_fn (tree orig, tree fn_type, tree coro_frame_ptr, const char* name)\n /* Re-write the body as per [dcl.fct.def.coroutine] / 5.  */\n \n static tree\n-coro_rewrite_function_body (location_t fn_start, tree fnbody,\n-\t\t\t    tree orig, tree resume_fn_ptr_type,\n-\t\t\t    tree& resume_fn_field, tree& fs_label)\n+coro_rewrite_function_body (location_t fn_start, tree fnbody, tree orig,\n+\t\t\t    tree resume_fn_ptr_type, tree& resume_fn_field,\n+\t\t\t    tree& resume_idx_field, tree& fs_label)\n {\n   /* This will be our new outer scope.  */\n   tree update_body = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);\n@@ -4068,6 +4082,25 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody,\n   tree return_void\n     = get_coroutine_return_void_expr (current_function_decl, fn_start, false);\n \n+  /* We will need to be able to set the resume function pointer to nullptr\n+     to signal that the coroutine is 'done'.  */\n+  resume_fn_field\n+    = build_lang_decl (VAR_DECL, get_identifier (\"resume.fn.ptr.proxy\"),\n+\t\t       resume_fn_ptr_type);\n+  DECL_ARTIFICIAL (resume_fn_field) = true;\n+  tree zero_resume\n+    = build1 (CONVERT_EXPR, resume_fn_ptr_type, integer_zero_node);\n+  zero_resume\n+    = build2 (INIT_EXPR, resume_fn_ptr_type, resume_fn_field, zero_resume);\n+  /* Likewise, the resume index needs to be reset.  */\n+  resume_idx_field\n+    = build_lang_decl (VAR_DECL, get_identifier (\"resume.index.proxy\"),\n+\t\t       short_unsigned_type_node);\n+  DECL_ARTIFICIAL (resume_idx_field) = true;\n+  tree zero_resume_idx = build_int_cst (short_unsigned_type_node, 0);\n+  zero_resume_idx = build2 (INIT_EXPR, short_unsigned_type_node,\n+\t\t\t    resume_idx_field, zero_resume_idx);\n+\n   if (flag_exceptions)\n     {\n       /* Build promise.unhandled_exception();  */\n@@ -4126,7 +4159,13 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody,\n       IF_SCOPE (not_iarc_if) = NULL;\n       not_iarc_if = do_poplevel (iarc_scope);\n       add_stmt (not_iarc_if);\n-      /* ... else call the promise unhandled exception method.  */\n+      /* ... else call the promise unhandled exception method\n+\t but first we set done = true and the resume index to 0.\n+\t If the unhandled exception method returns, then we continue\n+\t to the final await expression (which duplicates the clearing of\n+\t the field). */\n+      finish_expr_stmt (zero_resume);\n+      finish_expr_stmt (zero_resume_idx);\n       ueh = maybe_cleanup_point_expr_void (ueh);\n       add_stmt (ueh);\n       finish_handler (handler);\n@@ -4163,14 +4202,6 @@ coro_rewrite_function_body (location_t fn_start, tree fnbody,\n   /* Before entering the final suspend point, we signal that this point has\n      been reached by setting the resume function pointer to zero (this is\n      what the 'done()' builtin tests) as per the current ABI.  */\n-  resume_fn_field\n-    = build_lang_decl (VAR_DECL, get_identifier (\"resume.fn.ptr.proxy\"),\n-\t\t       resume_fn_ptr_type);\n-  DECL_ARTIFICIAL (resume_fn_field) = true;\n-  tree zero_resume\n-    = build1 (CONVERT_EXPR, resume_fn_ptr_type, integer_zero_node);\n-  zero_resume\n-    = build2 (INIT_EXPR, resume_fn_ptr_type, resume_fn_field, zero_resume);\n   finish_expr_stmt (zero_resume);\n   finish_expr_stmt (build_init_or_final_await (fn_start, true));\n   BIND_EXPR_BODY (update_body) = pop_stmt_list (BIND_EXPR_BODY (update_body));\n@@ -4314,9 +4345,11 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n      the requirements for the coroutine frame.  */\n \n   tree resume_fn_field = NULL_TREE;\n+  tree resume_idx_field = NULL_TREE;\n   tree fs_label = NULL_TREE;\n-  fnbody = coro_rewrite_function_body (fn_start, fnbody, orig, act_des_fn_ptr,\n-\t\t\t\t       resume_fn_field, fs_label);\n+  fnbody = coro_rewrite_function_body (fn_start, fnbody, orig,\n+\t\t\t\t       act_des_fn_ptr, resume_fn_field,\n+\t\t\t\t       resume_idx_field, fs_label);\n   /* Build our dummy coro frame layout.  */\n   coro_frame_type = begin_class_definition (coro_frame_type);\n \n@@ -5198,7 +5231,7 @@ morph_fn_to_coro (tree orig, tree *resumer, tree *destroyer)\n   /* Build the actor...  */\n   build_actor_fn (fn_start, coro_frame_type, actor, fnbody, orig, param_uses,\n \t\t  &local_var_uses, param_dtor_list, resume_fn_field,\n-\t\t  body_aw_points.await_number, frame_size);\n+\t\t  resume_idx_field, body_aw_points.await_number, frame_size);\n \n   /* Destroyer ... */\n   build_destroy_fn (fn_start, coro_frame_type, destroy, actor);"}, {"sha": "15db250b4a2012370878e61dc7231f944f56d803", "filename": "gcc/testsuite/g++.dg/coroutines/torture/pr98704.C", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/020b286c769f4dc8a6b45491351f6bc2e69d7a7f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr98704.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/020b286c769f4dc8a6b45491351f6bc2e69d7a7f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr98704.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcoroutines%2Ftorture%2Fpr98704.C?ref=020b286c769f4dc8a6b45491351f6bc2e69d7a7f", "patch": "@@ -0,0 +1,91 @@\n+//  { dg-do run }\n+#include \"../coro.h\"\n+\n+#include <stdexcept>\n+\n+int frame_live = 0;\n+int promise_live = 0;\n+int task_live = 0;\n+\n+struct Task\n+{\n+    struct promise_type;\n+    using handle = std::coroutine_handle<promise_type>;\n+\n+    struct promise_type\n+    {\n+        promise_type () { promise_live++; PRINT (\"promise_type ()\"); }\n+        ~promise_type () { promise_live--; PRINT (\"~promise_type ()\"); }\n+        void* operator new(size_t sz) {\n+            PRINT(\"operator new()\");\n+            frame_live++;\n+            return ::operator new(sz);\n+        }\n+        void operator delete(void* p, size_t sz) {\n+            PRINT(\"operator delete\");\n+            frame_live--;\n+            return ::operator delete(p, sz);\n+        }\n+\n+        Task get_return_object() { return handle::from_promise(*this); }\n+        auto initial_suspend() noexcept { return std::suspend_always{}; }\n+        auto final_suspend() noexcept { return std::suspend_always{}; }\n+        void return_void() noexcept {}\n+\n+        auto yield_value(int x) noexcept\n+        {\n+            PRINTF (\"yield_value(%d)\\n\", x);\n+            return std::suspend_always{};\n+        }\n+\n+        void unhandled_exception()\n+        {\n+            PRINT (\"unhandled_exception()\");\n+            throw;\n+        }\n+    };\n+\n+    Task(handle h) : coro(h) { task_live++; PRINT (\"Task(handle h)\"); }\n+    ~Task() { task_live--; PRINT (\"~Task()\"); if (coro) coro.destroy(); }\n+\n+    handle coro;\n+};\n+\n+Task myco()\n+{\n+    co_yield 42;\n+    throw std::out_of_range(\"TEST EXCEPTION\");\n+}\n+\n+int main()\n+{\n+  {\n+    Task task = myco();\n+    PRINT (\"START\");\n+    try {\n+        PRINTF (\"done #0 = %d\\n\", task.coro.done());\n+        if (task.coro.done())\n+          abort();\n+        task.coro.resume(); // will yield 42\n+        PRINTF (\"done #1 = %d\\n\", task.coro.done());\n+        if (task.coro.done())\n+          abort();        \n+        task.coro.resume(); // will throw exception\n+        PRINT (\"should not be reached\");\n+        abort ();\n+    }\n+    catch (const std::exception&) {\n+        PRINTF (\"done exc = %d\\n\", task.coro.done());\n+        if (!task.coro.done())\n+          abort();        \n+    }\n+    if (!task.coro.done())\n+      abort();        \n+  } // should cause cause the destroy () to run.\n+  if (task_live || promise_live || frame_live)\n+    {\n+      PRINTF (\"task_live = %d, promise_live = %d, frame_live = %d\\n\",\n+               task_live, promise_live, frame_live);\n+      abort ();\n+    }\n+}"}]}