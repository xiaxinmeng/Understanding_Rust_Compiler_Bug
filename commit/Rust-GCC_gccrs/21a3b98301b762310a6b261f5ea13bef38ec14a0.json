{"sha": "21a3b98301b762310a6b261f5ea13bef38ec14a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFhM2I5ODMwMWI3NjIzMTBhNmIyNjFmNWVhMTNiZWYzOGVjMTRhMA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-03-09T16:40:30Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-03-09T16:40:30Z"}, "message": "calls.c (load_register_parameters): New function.\n\n        * calls.c (load_register_parameters): New function.\n        (expand_call): Use it.\n\nFrom-SVN: r25658", "tree": {"sha": "3a14d77d3464393454eeaf4611134cf54ebfd0bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a14d77d3464393454eeaf4611134cf54ebfd0bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21a3b98301b762310a6b261f5ea13bef38ec14a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a3b98301b762310a6b261f5ea13bef38ec14a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21a3b98301b762310a6b261f5ea13bef38ec14a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21a3b98301b762310a6b261f5ea13bef38ec14a0/comments", "author": null, "committer": null, "parents": [{"sha": "43f854cf4806ffd8dd254fa90a983b42674e6597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43f854cf4806ffd8dd254fa90a983b42674e6597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43f854cf4806ffd8dd254fa90a983b42674e6597"}], "stats": {"total": 160, "additions": 88, "deletions": 72}, "files": [{"sha": "6bd6b96ef1857c64d7ed024249b244a1728d27e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21a3b98301b762310a6b261f5ea13bef38ec14a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21a3b98301b762310a6b261f5ea13bef38ec14a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21a3b98301b762310a6b261f5ea13bef38ec14a0", "patch": "@@ -25,6 +25,9 @@ Tue Mar  9 09:33:16 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n Tue Mar  9 02:08:17 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* calls.c (load_register_parameters): New function.\n+\t(expand_call): Use it.\n+\n \t* calls.c (expand_call): Slightly reorganize code.\n \n \t* calls.c (compute_argument_addresses): New function."}, {"sha": "185b0e123755e6774cb260cf7b5444a30f8d1c95", "filename": "gcc/calls.c", "status": "modified", "additions": 85, "deletions": 72, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21a3b98301b762310a6b261f5ea13bef38ec14a0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21a3b98301b762310a6b261f5ea13bef38ec14a0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=21a3b98301b762310a6b261f5ea13bef38ec14a0", "patch": "@@ -155,7 +155,9 @@ static void initialize_argument_information\tPROTO ((int,\n static void compute_argument_addresses\t\tPROTO ((struct arg_data *,\n \t\t\t\t\t\t\trtx, int));\n static rtx rtx_for_function_call\t\tPROTO ((tree, tree));\n-\t\t\t\t\t\t\t\n+static void load_register_parameters\t\tPROTO ((struct arg_data *,\n+\t\t\t\t\t\t\tint, rtx *));\n+\n #if defined(ACCUMULATE_OUTGOING_ARGS) && defined(REG_PARM_STACK_SPACE)\n static rtx save_fixed_argument_area\tPROTO ((int, rtx, int *, int *));\n static void restore_fixed_argument_area\tPROTO ((rtx, rtx, int, int));\n@@ -1416,6 +1418,86 @@ rtx_for_function_call (fndecl, exp)\n   return funexp;\n }\n \n+/* Do the register loads required for any wholly-register parms or any\n+   parms which are passed both on the stack and in a register.  Their\n+   expressions were already evaluated. \n+\n+   Mark all register-parms as living through the call, putting these USE\n+   insns in the CALL_INSN_FUNCTION_USAGE field.  */\n+\n+static void\n+load_register_parameters (args, num_actuals, call_fusage)\n+     struct arg_data *args;\n+     int num_actuals;\n+     rtx *call_fusage;\n+{\n+  int i, j;\n+\n+#ifdef LOAD_ARGS_REVERSED\n+  for (i = num_actuals - 1; i >= 0; i--)\n+#else\n+  for (i = 0; i < num_actuals; i++)\n+#endif\n+    {\n+      rtx reg = args[i].reg;\n+      int partial = args[i].partial;\n+      int nregs;\n+\n+      if (reg)\n+\t{\n+\t  /* Set to non-negative if must move a word at a time, even if just\n+\t     one word (e.g, partial == 1 && mode == DFmode).  Set to -1 if\n+\t     we just use a normal move insn.  This value can be zero if the\n+\t     argument is a zero size structure with no fields.  */\n+\t  nregs = (partial ? partial\n+\t\t   : (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n+\t\t      ? ((int_size_in_bytes (TREE_TYPE (args[i].tree_value))\n+\t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\t\t      : -1));\n+\n+\t  /* Handle calls that pass values in multiple non-contiguous\n+\t     locations.  The Irix 6 ABI has examples of this.  */\n+\n+\t  if (GET_CODE (reg) == PARALLEL)\n+\t    {\n+\t      emit_group_load (reg, args[i].value,\n+\t\t\t       int_size_in_bytes (TREE_TYPE (args[i].tree_value)),\n+\t\t\t       (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n+\t\t\t\t/ BITS_PER_UNIT));\n+\t    }\n+\n+\t  /* If simple case, just do move.  If normal partial, store_one_arg\n+\t     has already loaded the register for us.  In all other cases,\n+\t     load the register(s) from memory.  */\n+\n+\t  else if (nregs == -1)\n+\t    emit_move_insn (reg, args[i].value);\n+\n+\t  /* If we have pre-computed the values to put in the registers in\n+\t     the case of non-aligned structures, copy them in now.  */\n+\n+\t  else if (args[i].n_aligned_regs != 0)\n+\t    for (j = 0; j < args[i].n_aligned_regs; j++)\n+\t      emit_move_insn (gen_rtx_REG (word_mode, REGNO (reg) + j),\n+\t\t\t      args[i].aligned_regs[j]);\n+\n+\t  else if (partial == 0 || args[i].pass_on_stack)\n+\t    move_block_to_reg (REGNO (reg),\n+\t\t\t       validize_mem (args[i].value), nregs,\n+\t\t\t       args[i].mode);\n+\n+\t  /* Handle calls that pass values in multiple non-contiguous\n+\t     locations.  The Irix 6 ABI has examples of this.  */\n+\t  if (GET_CODE (reg) == PARALLEL)\n+\t    use_group_regs (call_fusage, reg);\n+\t  else if (nregs == -1)\n+\t    use_reg (call_fusage, reg);\n+\t  else\n+\t    use_regs (call_fusage, REGNO (reg), nregs == 0 ? 1 : nregs);\n+\t}\n+    }\n+}\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -1530,7 +1612,7 @@ expand_call (exp, target, ignore)\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   rtx call_fusage = 0;\n   register tree p;\n-  register int i, j;\n+  register int i;\n \n   /* The value of the function call can be put in a hard register.  But\n      if -fcheck-memory-usage, code which invokes functions (and thus\n@@ -2182,76 +2264,7 @@ expand_call (exp, target, ignore)\n \n   funexp = prepare_call_address (funexp, fndecl, &call_fusage, reg_parm_seen);\n \n-  /* Now do the register loads required for any wholly-register parms or any\n-     parms which are passed both on the stack and in a register.  Their\n-     expressions were already evaluated. \n-\n-     Mark all register-parms as living through the call, putting these USE\n-     insns in the CALL_INSN_FUNCTION_USAGE field.  */\n-\n-#ifdef LOAD_ARGS_REVERSED\n-  for (i = num_actuals - 1; i >= 0; i--)\n-#else\n-  for (i = 0; i < num_actuals; i++)\n-#endif\n-    {\n-      rtx reg = args[i].reg;\n-      int partial = args[i].partial;\n-      int nregs;\n-\n-      if (reg)\n-\t{\n-\t  /* Set to non-negative if must move a word at a time, even if just\n-\t     one word (e.g, partial == 1 && mode == DFmode).  Set to -1 if\n-\t     we just use a normal move insn.  This value can be zero if the\n-\t     argument is a zero size structure with no fields.  */\n-\t  nregs = (partial ? partial\n-\t\t   : (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode\n-\t\t      ? ((int_size_in_bytes (TREE_TYPE (args[i].tree_value))\n-\t\t\t  + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n-\t\t      : -1));\n-\n-\t  /* Handle calls that pass values in multiple non-contiguous\n-\t     locations.  The Irix 6 ABI has examples of this.  */\n-\n-\t  if (GET_CODE (reg) == PARALLEL)\n-\t    {\n-\t      emit_group_load (reg, args[i].value,\n-\t\t\t       int_size_in_bytes (TREE_TYPE (args[i].tree_value)),\n-\t\t\t       (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n-\t\t\t\t/ BITS_PER_UNIT));\n-\t    }\n-\n-\t  /* If simple case, just do move.  If normal partial, store_one_arg\n-\t     has already loaded the register for us.  In all other cases,\n-\t     load the register(s) from memory.  */\n-\n-\t  else if (nregs == -1)\n-\t    emit_move_insn (reg, args[i].value);\n-\n-\t  /* If we have pre-computed the values to put in the registers in\n-\t     the case of non-aligned structures, copy them in now.  */\n-\n-\t  else if (args[i].n_aligned_regs != 0)\n-\t    for (j = 0; j < args[i].n_aligned_regs; j++)\n-\t      emit_move_insn (gen_rtx_REG (word_mode, REGNO (reg) + j),\n-\t\t\t      args[i].aligned_regs[j]);\n-\n-\t  else if (partial == 0 || args[i].pass_on_stack)\n-\t    move_block_to_reg (REGNO (reg),\n-\t\t\t       validize_mem (args[i].value), nregs,\n-\t\t\t       args[i].mode);\n-\n-\t  /* Handle calls that pass values in multiple non-contiguous\n-\t     locations.  The Irix 6 ABI has examples of this.  */\n-\t  if (GET_CODE (reg) == PARALLEL)\n-\t    use_group_regs (&call_fusage, reg);\n-\t  else if (nregs == -1)\n-\t    use_reg (&call_fusage, reg);\n-\t  else\n-\t    use_regs (&call_fusage, REGNO (reg), nregs == 0 ? 1 : nregs);\n-\t}\n-    }\n+  load_register_parameters (args, num_actuals, &call_fusage);\n \n   /* Perform postincrements before actually calling the function.  */\n   emit_queue ();"}]}