{"sha": "7b1ac803d3fa6873c336109b1f68be1b62f31300", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IxYWM4MDNkM2ZhNjg3M2MzMzYxMDliMWY2OGJlMWI2MmYzMTMwMA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-05-26T10:16:03Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-05-26T10:16:03Z"}, "message": "haifa-sched.c (schedule-block): Reorder the inner scheduling loop to reduce duplication...\n\n\t* haifa-sched.c (schedule-block): Reorder the inner scheduling loop\n\tto reduce duplication, and to achieve a slightly more logical order\n\tof operations.\n\nFrom-SVN: r174271", "tree": {"sha": "d0d5023c30e3e4f8e883955f147e9ae4411449df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0d5023c30e3e4f8e883955f147e9ae4411449df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b1ac803d3fa6873c336109b1f68be1b62f31300", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1ac803d3fa6873c336109b1f68be1b62f31300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b1ac803d3fa6873c336109b1f68be1b62f31300", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b1ac803d3fa6873c336109b1f68be1b62f31300/comments", "author": null, "committer": null, "parents": [{"sha": "1aa9438fdb536c081195b462c7d7be9f82004a73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aa9438fdb536c081195b462c7d7be9f82004a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aa9438fdb536c081195b462c7d7be9f82004a73"}], "stats": {"total": 154, "additions": 68, "deletions": 86}, "files": [{"sha": "d6bfc8011edccdad574de176a46376a04bf6140a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1ac803d3fa6873c336109b1f68be1b62f31300/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1ac803d3fa6873c336109b1f68be1b62f31300/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7b1ac803d3fa6873c336109b1f68be1b62f31300", "patch": "@@ -1,3 +1,9 @@\n+2011-05-26  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* haifa-sched.c (schedule-block): Reorder the inner scheduling loop\n+\tto reduce duplication, and to achieve a slightly more logical order\n+\tof operations.\n+\n 2011-05-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/49161"}, {"sha": "6b949b41179a392b215d413e5312d7bbbf242610", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 62, "deletions": 86, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b1ac803d3fa6873c336109b1f68be1b62f31300/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b1ac803d3fa6873c336109b1f68be1b62f31300/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7b1ac803d3fa6873c336109b1f68be1b62f31300", "patch": "@@ -3066,63 +3066,77 @@ schedule_block (basic_block *target_bb)\n \t}\n       while (advance > 0);\n \n-      prune_ready_list (temp_state, true);\n+      if (ready.n_ready > 0)\n+\tprune_ready_list (temp_state, true);\n       if (ready.n_ready == 0)\n-        continue;\n+\tcontinue;\n \n-      if (sort_p)\n+      first_cycle_insn_p = true;\n+      cycle_issued_insns = 0;\n+      can_issue_more = issue_rate;\n+      for (;;)\n \t{\n-\t  /* Sort the ready list based on priority.  */\n-\t  ready_sort (&ready);\n+\t  rtx insn;\n+\t  int cost;\n+\t  bool asm_p = false;\n \n-\t  if (sched_verbose >= 2)\n+\t  if (sort_p && ready.n_ready > 0)\n \t    {\n-\t      fprintf (sched_dump, \";;\\t\\tReady list after ready_sort:  \");\n-\t      debug_ready_list (&ready);\n+\t      /* Sort the ready list based on priority.  This must be\n+\t\t done every iteration through the loop, as schedule_insn\n+\t\t may have readied additional insns that will not be\n+\t\t sorted correctly.  */\n+\t      ready_sort (&ready);\n+\n+\t      if (sched_verbose >= 2)\n+\t\t{\n+\t\t  fprintf (sched_dump, \";;\\t\\tReady list after ready_sort:  \");\n+\t\t  debug_ready_list (&ready);\n+\t\t}\n \t    }\n-\t}\n \n-      /* We don't want md sched reorder to even see debug isns, so put\n-\t them out right away.  */\n-      if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n-\t{\n-\t  while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n+\t  /* We don't want md sched reorder to even see debug isns, so put\n+\t     them out right away.  */\n+\t  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))\n+\t      && (*current_sched_info->schedule_more_p) ())\n \t    {\n-\t      rtx insn = ready_remove_first (&ready);\n-\t      gcc_assert (DEBUG_INSN_P (insn));\n-\t      (*current_sched_info->begin_schedule_ready) (insn);\n-\t      VEC_safe_push (rtx, heap, scheduled_insns, insn);\n-\t      last_scheduled_insn = insn;\n-\t      advance = schedule_insn (insn);\n-\t      gcc_assert (advance == 0);\n-\t      if (ready.n_ready > 0)\n-\t\tready_sort (&ready);\n+\t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n+\t\t{\n+\t\t  rtx insn = ready_remove_first (&ready);\n+\t\t  gcc_assert (DEBUG_INSN_P (insn));\n+\t\t  (*current_sched_info->begin_schedule_ready) (insn);\n+\t\t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n+\t\t  last_scheduled_insn = insn;\n+\t\t  advance = schedule_insn (insn);\n+\t\t  gcc_assert (advance == 0);\n+\t\t  if (ready.n_ready > 0)\n+\t\t    ready_sort (&ready);\n+\t\t}\n \t    }\n \n-\t  if (!ready.n_ready)\n-\t    continue;\n-\t}\n-\n-      /* Allow the target to reorder the list, typically for\n-\t better instruction bundling.  */\n-      if (sort_p && targetm.sched.reorder\n-\t  && (ready.n_ready == 0\n-\t      || !SCHED_GROUP_P (ready_element (&ready, 0))))\n-\tcan_issue_more =\n-\t  targetm.sched.reorder (sched_dump, sched_verbose,\n-\t\t\t\t ready_lastpos (&ready),\n-\t\t\t\t &ready.n_ready, clock_var);\n-      else\n-\tcan_issue_more = issue_rate;\n+\t  if (first_cycle_insn_p && !ready.n_ready)\n+\t    break;\n \n-      first_cycle_insn_p = true;\n-      cycle_issued_insns = 0;\n-      for (;;)\n-\t{\n-\t  rtx insn;\n-\t  int cost;\n-\t  bool asm_p = false;\n+\t  /* Allow the target to reorder the list, typically for\n+\t     better instruction bundling.  */\n+\t  if (sort_p\n+\t      && (ready.n_ready == 0\n+\t\t  || !SCHED_GROUP_P (ready_element (&ready, 0))))\n+\t    {\n+\t      if (first_cycle_insn_p && targetm.sched.reorder)\n+\t\tcan_issue_more\n+\t\t  = targetm.sched.reorder (sched_dump, sched_verbose,\n+\t\t\t\t\t   ready_lastpos (&ready),\n+\t\t\t\t\t   &ready.n_ready, clock_var);\n+\t      else if (!first_cycle_insn_p && targetm.sched.reorder2)\n+\t\tcan_issue_more\n+\t\t  = targetm.sched.reorder2 (sched_dump, sched_verbose,\n+\t\t\t\t\t    ready.n_ready\n+\t\t\t\t\t    ? ready_lastpos (&ready) : NULL,\n+\t\t\t\t\t    &ready.n_ready, clock_var);\n+\t    }\n \n+\trestart_choose_ready:\n \t  if (sched_verbose >= 2)\n \t    {\n \t      fprintf (sched_dump, \";;\\tReady list (t = %3d):  \",\n@@ -3164,8 +3178,7 @@ schedule_block (basic_block *target_bb)\n \t\t/* Finish cycle.  */\n \t\tbreak;\n \t      if (res > 0)\n-\t\t/* Restart choose_ready ().  */\n-\t\tcontinue;\n+\t\tgoto restart_choose_ready;\n \n \t      gcc_assert (insn != NULL_RTX);\n \t    }\n@@ -3207,7 +3220,7 @@ schedule_block (basic_block *target_bb)\n \t       insn from the split block.  */\n \t    {\n \t      TODO_SPEC (insn) = (TODO_SPEC (insn) & ~SPECULATIVE) | HARD_DEP;\n-\t      continue;\n+\t      goto restart_choose_ready;\n \t    }\n \n \t  /* DECISION is made.  */\n@@ -3256,45 +3269,8 @@ schedule_block (basic_block *target_bb)\n \t    break;\n \n \t  first_cycle_insn_p = false;\n-\n-\t  if (ready.n_ready > 0)\n-            prune_ready_list (temp_state, false);\n-\n-\t  /* Sort the ready list based on priority.  This must be\n-\t     redone here, as schedule_insn may have readied additional\n-\t     insns that will not be sorted correctly.  */\n \t  if (ready.n_ready > 0)\n-\t    ready_sort (&ready);\n-\n-\t  /* Quickly go through debug insns such that md sched\n-\t     reorder2 doesn't have to deal with debug insns.  */\n-\t  if (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0))\n-\t      && (*current_sched_info->schedule_more_p) ())\n-\t    {\n-\t      while (ready.n_ready && DEBUG_INSN_P (ready_element (&ready, 0)))\n-\t\t{\n-\t\t  insn = ready_remove_first (&ready);\n-\t\t  gcc_assert (DEBUG_INSN_P (insn));\n-\t\t  (*current_sched_info->begin_schedule_ready) (insn);\n-\t\t  VEC_safe_push (rtx, heap, scheduled_insns, insn);\n-\t\t  advance = schedule_insn (insn);\n-\t\t  last_scheduled_insn = insn;\n-\t\t  gcc_assert (advance == 0);\n-\t\t  if (ready.n_ready > 0)\n-\t\t    ready_sort (&ready);\n-\t\t}\n-\t    }\n-\n-\t  if (targetm.sched.reorder2\n-\t      && (ready.n_ready == 0\n-\t\t  || !SCHED_GROUP_P (ready_element (&ready, 0))))\n-\t    {\n-\t      can_issue_more =\n-\t\ttargetm.sched.reorder2 (sched_dump, sched_verbose,\n-\t\t\t\t\tready.n_ready\n-\t\t\t\t\t? ready_lastpos (&ready) : NULL,\n-\t\t\t\t\t&ready.n_ready, clock_var);\n-\t    }\n+\t    prune_ready_list (temp_state, false);\n \t}\n     }\n "}]}