{"sha": "139e5e08924a01bb85498a6eab33436c519ef78f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM5ZTVlMDg5MjRhMDFiYjg1NDk4YTZlYWIzMzQzNmM1MTllZjc4Zg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-02T01:42:33Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-02T01:42:33Z"}, "message": "(expand_unop): Handle complex negate and abs val.\n\n(init_optabs): Set up libcalls for complex abs.\n(init_complex_libcalls): New function.\n\nFrom-SVN: r2305", "tree": {"sha": "76508584099faa5ec5ef7660d8a8a3ce2042203c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76508584099faa5ec5ef7660d8a8a3ce2042203c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/139e5e08924a01bb85498a6eab33436c519ef78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/139e5e08924a01bb85498a6eab33436c519ef78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/139e5e08924a01bb85498a6eab33436c519ef78f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/139e5e08924a01bb85498a6eab33436c519ef78f/comments", "author": null, "committer": null, "parents": [{"sha": "aa59a86918dc12f7243acc74b7419d042bf08ddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa59a86918dc12f7243acc74b7419d042bf08ddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa59a86918dc12f7243acc74b7419d042bf08ddc"}], "stats": {"total": 111, "additions": 97, "deletions": 14}, "files": [{"sha": "22c3b28c18e9b4a725acfbe364e47bfc3d567f50", "filename": "gcc/optabs.c", "status": "modified", "additions": 97, "deletions": 14, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/139e5e08924a01bb85498a6eab33436c519ef78f/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/139e5e08924a01bb85498a6eab33436c519ef78f/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=139e5e08924a01bb85498a6eab33436c519ef78f", "patch": "@@ -180,10 +180,8 @@ rtx fixunstfsi_libfunc;\n rtx fixunstfdi_libfunc;\n rtx fixunstfti_libfunc;\n \n-#ifdef GPC\n /* from emit-rtl.c */\n-extern rtx gen_highpart();\n-#endif\n+extern rtx gen_highpart ();\n \n /* Indexed by the rtx-code for a conditional (eg. EQ, LT,...)\n    gives the gen_function to make a branch to test that condition.  */\n@@ -1386,19 +1384,9 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n   register rtx temp;\n   rtx last = get_last_insn ();\n   rtx pat;\n-#ifdef GPC\n-  enum machine_mode submode;\n-#endif\n \n   class = GET_MODE_CLASS (mode);\n \n-#ifdef GPC\n-  if (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT)\n-    submode = mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n-\t\t\t     class == MODE_COMPLEX_INT ?\n-\t\t\t       MODE_INT : MODE_FLOAT, 0);\n-#endif /* GPC */\n-\n   op0 = protect_from_queue (op0, 0);\n \n   if (flag_force_mem)\n@@ -1527,6 +1515,86 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n       return target;\n     }\n \n+  /* Open-code the complex negation operation.  */\n+  else if (unoptab == neg_optab\n+\t   && (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT))\n+    {\n+      rtx target_piece;\n+      rtx x;\n+      rtx seq;\n+\n+      /* Find the correct mode for the real and imaginary parts */\n+      enum machine_mode submode\n+\t= mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t\t class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n+\t\t\t 0);\n+\n+      if (submode == BLKmode)\n+\tabort ();\n+\n+      if (target == 0)\n+\ttarget = gen_reg_rtx (mode);\n+      \n+      start_sequence ();\n+\n+      target_piece = gen_highpart (submode, target);\n+      x = expand_unop (submode, unoptab,\n+\t\t       gen_highpart (submode, op0),\n+\t\t       target_piece, unsignedp);\n+      if (target_piece != x)\n+\temit_move_insn (target_piece, x);\n+\n+      target_piece = gen_lowpart (submode, target);\n+      x = expand_unop (submode, unoptab,\n+\t\t       gen_lowpart (submode, op0),\n+\t\t       target_piece, unsignedp);\n+      if (target_piece != x)\n+\temit_move_insn (target_piece, x);\n+\n+      seq = gen_sequence ();\n+      end_sequence ();\n+\n+      emit_no_conflict_block (seq, target, op0, 0,\n+\t\t\t      gen_rtx (unoptab->code, mode, op0));\n+      return target;\n+    }\n+\n+  /* Open-code the complex absolute-value operation\n+     if we can open-code sqrt.  Otherwise it's not worth while.  */\n+  else if (unoptab == abs_optab\n+\t   && (class == MODE_COMPLEX_FLOAT || class == MODE_COMPLEX_INT))\n+    {\n+      /* Find the correct mode for the real and imaginary parts */\n+      enum machine_mode submode\n+\t= mode_for_size (GET_MODE_UNIT_SIZE (mode) * BITS_PER_UNIT,\n+\t\t\t class == MODE_COMPLEX_INT ? MODE_INT : MODE_FLOAT,\n+\t\t\t 0);\n+\n+      if (submode == BLKmode)\n+\tabort ();\n+\n+      if (sqrt_optab->handlers[(int) submode].insn_code != CODE_FOR_nothing)\n+\t{\n+\t  rtx real, imag, total;\n+\n+\t  real = gen_highpart (submode, op0);\n+\t  imag = gen_lowpart (submode, op0);\n+\t  /* Square both parts.  */\n+\t  real = expand_mult (mode, real, real, NULL_RTX, 0);\n+\t  imag = expand_mult (mode, imag, imag, NULL_RTX, 0);\n+\t  /* Sum the parts.  */\n+\t  total = expand_binop (submode, add_optab, real, imag, 0,\n+\t\t\t\t0, OPTAB_LIB_WIDEN);\n+\t  /* Get sqrt in TARGET.  Set TARGET to where the result is.  */\n+\t  target = expand_unop (submode, sqrt_optab, total, target, 0);\n+\t  if (target == 0)\n+\t    delete_insns_since (last);\n+\t  else\n+\t    return target;\n+\t}\n+    }\n+\n+  /* Now try a library call in this mode.  */\n   if (unoptab->handlers[(int) mode].libfunc)\n     {\n       rtx insns;\n@@ -3574,6 +3642,20 @@ init_floating_libfuncs (optable, opname, suffix)\n   init_libfuncs (optable, SFmode, TFmode, opname, suffix);\n }\n \n+/* Initialize the libfunc fields of an entire group of entries in some\n+   optab which correspond to all complex floating modes.  The parameters\n+   have the same meaning as similarly named ones for the `init_libfuncs'\n+   routine.  (See above).  */\n+\n+static void\n+init_complex_libfuncs (optable, opname, suffix)\n+    register optab optable;\n+    register char *opname;\n+    register char suffix;\n+{\n+  init_libfuncs (optable, SCmode, TCmode, opname, suffix);\n+}\n+\n /* Call this once to initialize the contents of the optabs\n    appropriately for the current target machine.  */\n \n@@ -4477,8 +4559,9 @@ init_optabs ()\n   if (HAVE_abstf2)\n     abs_optab->handlers[(int) TFmode].insn_code = CODE_FOR_abstf2;\n #endif\n-  /* No library calls here!  If there is no abs instruction,\n+  /* No library calls here for real types.  If there is no abs instruction,\n      expand_expr will generate a conditional negation.  */\n+  init_complex_libfuncs (abs_optab, \"abs\", '2');\n \n #ifdef HAVE_sqrtqi2\n   if (HAVE_sqrtqi2)"}]}