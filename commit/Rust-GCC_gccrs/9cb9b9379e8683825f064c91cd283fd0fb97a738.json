{"sha": "9cb9b9379e8683825f064c91cd283fd0fb97a738", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNiOWI5Mzc5ZTg2ODM4MjVmMDY0YzkxY2QyODNmZDBmYjk3YTczOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-06-04T16:38:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-06-04T16:38:50Z"}, "message": "lto.c (hash_canonical_type): Use tree_code_for_canonical_type_merging.\n\n\n\t* lto.c (hash_canonical_type): Use tree_code_for_canonical_type_merging.\n\n\t* tree.h (tree_code_for_canonical_type_merging): New function.\n\t* tree.c (gimple_canonical_types_compatible_p): Use\n\ttree_code_for_canonical_type_merging..\n\t* gcc.dg/lto/c-compatible-types_0.c: New testcase.\n\t* gcc.dg/lto/c-compatible-types_1.c: New testcase.\n\nFrom-SVN: r224135", "tree": {"sha": "c8294be6e931cc9efefd835049d806e5c39a7f5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8294be6e931cc9efefd835049d806e5c39a7f5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cb9b9379e8683825f064c91cd283fd0fb97a738", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb9b9379e8683825f064c91cd283fd0fb97a738", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cb9b9379e8683825f064c91cd283fd0fb97a738", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cb9b9379e8683825f064c91cd283fd0fb97a738/comments", "author": null, "committer": null, "parents": [{"sha": "19cd26a6b937349161ef2f7ae6bf41cee61bc81b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19cd26a6b937349161ef2f7ae6bf41cee61bc81b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19cd26a6b937349161ef2f7ae6bf41cee61bc81b"}], "stats": {"total": 88, "additions": 86, "deletions": 2}, "files": [{"sha": "a5ca74fa78481667bca3de49241fc8edd24ff06d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -1,3 +1,9 @@\n+2015-06-04  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree.h (tree_code_for_canonical_type_merging): New function.\n+\t* tree.c (gimple_canonical_types_compatible_p): Use\n+\ttree_code_for_canonical_type_merging..\n+\n 2015-06-04  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR c++/66192"}, {"sha": "2d6ddf5cdc721fb96c84b4cef6e43fcc513bb713", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -1,3 +1,7 @@\n+2015-06-04  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (hash_canonical_type): Use tree_code_for_canonical_type_merging.\n+\n 2015-06-03  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto.c (iterative_hash_canonical_type,"}, {"sha": "498eb80450f9e4d3dbbae4a6ba7965e3786ba5a3", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -319,7 +319,7 @@ hash_canonical_type (tree type)\n      smaller sets; when searching for existing matching types to merge,\n      only existing types having the same features as the new type will be\n      checked.  */\n-  hstate.add_int (TREE_CODE (type));\n+  hstate.add_int (tree_code_for_canonical_type_merging (TREE_CODE (type)));\n   hstate.add_int (TYPE_MODE (type));\n \n   /* Incorporate common features of numerical types.  */"}, {"sha": "a64729a648fa8e0ba37436a2087cf2746be514af", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -1,3 +1,13 @@\n+2015-06-04  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/lto/c-compatible-types_0.c: New testcase.\n+\t* gcc.dg/lto/c-compatible-types_1.c: New testcase.\n+\n+2015-06-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (iterative_hash_canonical_type,\n+\tgimple_register_canonical_type): only hash main variants of types\n+\n 2015-06-04  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/advsimd-intrinsics.exp:"}, {"sha": "ca33de2186916dcdc7b15fb66187d9f1dbf7e0b1", "filename": "gcc/testsuite/gcc.dg/lto/c-compatible-types_0.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types_0.c?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3\" } */\n+/* { dg-skip-if \"require -fno-short-enums to work\" {target short_enums} } */\n+\n+/* By C standard Each enumerated type shall be compatible with char, a  signed\n+   integer, type, or an unsigned integer type. The choice of type is\n+   implementation-defined.  Check that enum and unsigned int match.  */\n+unsigned int a;\n+unsigned int *b;\n+void t();\n+\n+void reset ()\n+{\n+  asm(\"\":\"=r\"(a):\"0\"(0));\n+}\n+int\n+main()\n+{\n+  asm(\"\":\"=r\"(a):\"0\"(1));\n+  asm(\"\":\"=r\"(b):\"0\"(&a));\n+  t();\n+  return 0;\n+}"}, {"sha": "ff0d16e31117c76e18753fbcb89b26a93e83e625", "filename": "gcc/testsuite/gcc.dg/lto/c-compatible-types_1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2Fc-compatible-types_1.c?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -0,0 +1,19 @@\n+enum a {test1, test2};\n+enum a a;\n+enum a *b;\n+\n+void reset (void);\n+\n+void\n+t()\n+{\n+  if (a != test2)\n+    __builtin_abort ();\n+  if (*b != test2)\n+    __builtin_abort ();\n+  reset ();\n+  if (a != test1)\n+    __builtin_abort ();\n+  if (*b != test1)\n+    __builtin_abort ();\n+}"}, {"sha": "b3244050d7a81b2cca7d31b9c007daf5b3f4733e", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -12930,7 +12930,8 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n     return TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n \n   /* Can't be the same type if the types don't have the same code.  */\n-  if (TREE_CODE (t1) != TREE_CODE (t2))\n+  if (tree_code_for_canonical_type_merging (TREE_CODE (t1))\n+      != tree_code_for_canonical_type_merging (TREE_CODE (t2)))\n     return false;\n \n   /* Qualifiers do not matter for canonical type comparison purposes.  */"}, {"sha": "ca5e68100dad886469fc53a62cdf788cab255822", "filename": "gcc/tree.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cb9b9379e8683825f064c91cd283fd0fb97a738/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9cb9b9379e8683825f064c91cd283fd0fb97a738", "patch": "@@ -4598,6 +4598,27 @@ extern int tree_map_base_marked_p (const void *);\n extern void DEBUG_FUNCTION verify_type (const_tree t);\n extern bool gimple_canonical_types_compatible_p (const_tree, const_tree,\n \t\t\t\t\t\t bool trust_type_canonical = true);\n+/* Return simplified tree code of type that is used for canonical type merging.  */\n+inline enum tree_code\n+tree_code_for_canonical_type_merging (enum tree_code code)\n+{\n+  /* By C standard, each enumerated type shall be compatible with char,\n+     a signed integer, or an unsigned integer.  The choice of type is\n+     implementation defined (in our case it depends on -fshort-enum).\n+\n+     For this reason we make no distinction between ENUMERAL_TYPE and INTEGER\n+     type and compare only by their signedness and precision.  */\n+  if (code == ENUMERAL_TYPE)\n+    return INTEGER_TYPE;\n+  /* To allow inter-operability between languages having references and\n+     C, we consider reference types and pointers alike.  Note that this is\n+     not strictly necessary for C-Fortran 2008 interoperability because\n+     Fortran define C_PTR type that needs to be compatible with C pointers\n+     and we handle this one as ptr_type_node.  */\n+  if (code == REFERENCE_TYPE)\n+    return POINTER_TYPE;\n+  return code;\n+}\n \n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);"}]}