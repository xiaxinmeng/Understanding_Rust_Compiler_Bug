{"sha": "097f0bcf651b735f9dcf517e6c00630da9e40a8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk3ZjBiY2Y2NTFiNzM1ZjlkY2Y1MTdlNmMwMDYzMGRhOWU0MGE4YQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-06-02T19:36:14Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-06-02T19:36:14Z"}, "message": "regex_compiler.h (__detail::_BracketMatcher): Reorder members to avoid wasted space when not using a cache.\n\n\t* include/bits/regex_compiler.h (__detail::_BracketMatcher): Reorder\n\tmembers to avoid wasted space when not using a cache.\n\t(__detail::_BracketMatcher::_M_ready()): Sort and deduplicate set.\n\t* include/bits/regex_compiler.tcc\n\t(__detail::_BracketMatcher::_M_apply(_CharT, false_type)): Use binary\n\tsearch on set.\n\t* include/bits/regex_executor.h (__detail::_Executor::_Match_mode):\n\tNew enumeration type to indicate match mode.\n\t(__detail::_Executor::_State_info): New type holding members only\n\tneeded in BFS-mode. Replace unique_ptr<vector<bool>> with\n\tunique_ptr<bool[]>.\n\t(__detail::_Executor::_M_rep_once_more, __detail::_Executor::_M_dfs):\n\tReplace template parameter with run-time function parameter.\n\t(__detail::_Executor::_M_main): Likewise. Dispatch to ...\n\t(__detail::_Executor::_M_main_dispatch): New overloaded functions to\n\timplement DFS and BFS mode.\n\t* include/bits/regex_executor.tcc (__detail::_Executor::_M_main):\n\tSplit implementation into ...\n\t(__detail::_Executor::_M_main_dispatch): New overloaded functions.\n\t(__detail::_Executor::_M_lookahead): Create nested executor on stack.\n\t(__detail::_Executor::_M_rep_once_more): Pass match mode as function\n\targument instead of template argument.\n\t(__detail::_Executor::_M_dfs): Likewise.\n\t* include/bits/regex_scanner.tcc: Fix typos in comments.\n\t* testsuite/performance/28_regex/range.cc: New.\n\nFrom-SVN: r211143", "tree": {"sha": "ee0541ddd6a618216ef62242a2df4be566a14a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee0541ddd6a618216ef62242a2df4be566a14a2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/097f0bcf651b735f9dcf517e6c00630da9e40a8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f0bcf651b735f9dcf517e6c00630da9e40a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/097f0bcf651b735f9dcf517e6c00630da9e40a8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/097f0bcf651b735f9dcf517e6c00630da9e40a8a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d732cca67aff483c9f31ef0385f141d0aea54e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d732cca67aff483c9f31ef0385f141d0aea54e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d732cca67aff483c9f31ef0385f141d0aea54e2"}], "stats": {"total": 398, "additions": 253, "deletions": 145}, "files": [{"sha": "df15a78672c4eb617a278d0c22b8594249334533", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -9,6 +9,32 @@\n \t* testsuite/30_threads/async/forced_unwind.cc: New.\n \t* testsuite/30_threads/packaged_task/forced_unwind.cc: New.\n \n+\t* include/bits/regex_compiler.h (__detail::_BracketMatcher): Reorder\n+\tmembers to avoid wasted space when not using a cache.\n+\t(__detail::_BracketMatcher::_M_ready()): Sort and deduplicate set.\n+\t* include/bits/regex_compiler.tcc\n+\t(__detail::_BracketMatcher::_M_apply(_CharT, false_type)): Use binary\n+\tsearch on set.\n+\t* include/bits/regex_executor.h (__detail::_Executor::_Match_mode):\n+\tNew enumeration type to indicate match mode.\n+\t(__detail::_Executor::_State_info): New type holding members only\n+\tneeded in BFS-mode. Replace unique_ptr<vector<bool>> with\n+\tunique_ptr<bool[]>.\n+\t(__detail::_Executor::_M_rep_once_more, __detail::_Executor::_M_dfs):\n+\tReplace template parameter with run-time function parameter.\n+\t(__detail::_Executor::_M_main): Likewise. Dispatch to ...\n+\t(__detail::_Executor::_M_main_dispatch): New overloaded functions to\n+\timplement DFS and BFS mode.\n+\t* include/bits/regex_executor.tcc (__detail::_Executor::_M_main):\n+\tSplit implementation into ...\n+\t(__detail::_Executor::_M_main_dispatch): New overloaded functions.\n+\t(__detail::_Executor::_M_lookahead): Create nested executor on stack.\n+\t(__detail::_Executor::_M_rep_once_more): Pass match mode as function\n+\targument instead of template argument.\n+\t(__detail::_Executor::_M_dfs): Likewise.\n+\t* include/bits/regex_scanner.tcc: Fix typos in comments.\n+\t* testsuite/performance/28_regex/range.cc: New.\n+\n 2014-06-02  R\u00fcdiger Sonderfeld  <ruediger@c-plusplus.de>\n \t    Jonathan Wakely  <jwakely@redhat.com>\n "}, {"sha": "a81f51750dc99fe2745f2e7781d4438b13c02927", "filename": "libstdc++-v3/include/bits/regex.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.tcc?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -32,7 +32,7 @@\n // If _GLIBCXX_REGEX_USE_THOMPSON_NFA is defined, the thompson NFA\n // algorithm will be used. This algorithm is not enabled by default,\n // and cannot be used if the regex contains back-references, but has better\n-// (polynomial instead of exponential) worst case performace.\n+// (polynomial instead of exponential) worst case performance.\n // See __regex_algo_impl below.\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "ca116de53af4fd998b571646740b85d081e3cfd6", "filename": "libstdc++-v3/include/bits/regex_compiler.h", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.h?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -43,7 +43,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _BracketMatcher;\n \n   /**\n-   * @brief Builds an NFA from an input iterator interval.\n+   * @brief Builds an NFA from an input iterator range.\n    *\n    * The %_TraitsT type should fulfill requirements [28.3].\n    */\n@@ -329,7 +329,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       operator()(_CharT __ch) const\n       {\n \t_GLIBCXX_DEBUG_ASSERT(_M_is_ready);\n-\treturn _M_apply(__ch, _IsChar());\n+\treturn _M_apply(__ch, _UseCache());\n       }\n \n       void\n@@ -400,21 +400,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_ready()\n       {\n-\t_M_make_cache(_IsChar());\n+\tstd::sort(_M_char_set.begin(), _M_char_set.end());\n+\tauto __end = std::unique(_M_char_set.begin(), _M_char_set.end());\n+\t_M_char_set.erase(__end, _M_char_set.end());\n+\t_M_make_cache(_UseCache());\n #ifdef _GLIBCXX_DEBUG\n \t_M_is_ready = true;\n #endif\n       }\n \n     private:\n-      typedef typename is_same<_CharT, char>::type _IsChar;\n+      // Currently we only use the cache for char\n+      typedef typename std::is_same<_CharT, char>::type _UseCache;\n+\n+      static constexpr size_t\n+      _S_cache_size() { return 1ul << (sizeof(_CharT) * __CHAR_BIT__); }\n+\n       struct _Dummy { };\n-      typedef typename conditional<_IsChar::value,\n-\t\t\t\t   std::bitset<1 << (8 * sizeof(_CharT))>,\n-\t\t\t\t   _Dummy>::type _CacheT;\n-      typedef typename make_unsigned<_CharT>::type _UnsignedCharT;\n+      typedef typename std::conditional<_UseCache::value,\n+\t\t\t\t\tstd::bitset<_S_cache_size()>,\n+\t\t\t\t\t_Dummy>::type _CacheT;\n+      typedef typename std::make_unsigned<_CharT>::type _UnsignedCharT;\n \n-    private:\n       bool\n       _M_apply(_CharT __ch, false_type) const;\n \n@@ -425,17 +432,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_make_cache(true_type)\n       {\n-\tfor (size_t __i = 0; __i < _M_cache.size(); __i++)\n-\t  _M_cache[static_cast<_UnsignedCharT>(__i)] =\n-\t    _M_apply(__i, false_type());\n+\tfor (unsigned __i = 0; __i < _M_cache.size(); __i++)\n+\t  _M_cache[__i] = _M_apply(static_cast<_CharT>(__i), false_type());\n       }\n \n       void\n       _M_make_cache(false_type)\n       { }\n \n     private:\n-      _CacheT                                   _M_cache;\n       std::vector<_CharT>                       _M_char_set;\n       std::vector<_StringT>                     _M_equiv_set;\n       std::vector<pair<_StrTransT, _StrTransT>> _M_range_set;\n@@ -444,6 +449,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _TransT                                   _M_translator;\n       const _TraitsT&                           _M_traits;\n       bool                                      _M_is_non_matching;\n+      _CacheT\t\t\t\t\t_M_cache;\n #ifdef _GLIBCXX_DEBUG\n       bool                                      _M_is_ready;\n #endif"}, {"sha": "0df10cc1a8b6d40a49a920cebe528d104d87a305", "filename": "libstdc++-v3/include/bits/regex_compiler.tcc", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_compiler.tcc?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -37,9 +37,9 @@\n // When compiling, states are *chained* instead of tree- or graph-constructed.\n // It's more like structured programs: there's if statement and loop statement.\n //\n-// For alternative structure(say \"a|b\"), aka \"if statement\", two branchs should\n-// be constructed. However, these two shall merge to an \"end_tag\" at the end of\n-// this operator:\n+// For alternative structure (say \"a|b\"), aka \"if statement\", two branches\n+// should be constructed. However, these two shall merge to an \"end_tag\" at\n+// the end of this operator:\n //\n //                branch1\n //              /        \\\n@@ -151,7 +151,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else if (_M_match_token(_ScannerT::_S_token_line_end))\n \t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa._M_insert_line_end()));\n       else if (_M_match_token(_ScannerT::_S_token_word_bound))\n-\t// _M_value[0] == 'n' means it's negtive, say \"not word boundary\".\n+\t// _M_value[0] == 'n' means it's negative, say \"not word boundary\".\n \t_M_stack.push(_StateSeqT(_M_nfa, _M_nfa.\n \t      _M_insert_word_bound(_M_value[0] == 'n')));\n       else if (_M_match_token(_ScannerT::_S_token_subexpr_lookahead_begin))\n@@ -256,7 +256,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      auto __end = _M_nfa._M_insert_dummy();\n \t      // _M_alt is the \"match more\" branch, and _M_next is the\n \t      // \"match less\" one. Switch _M_alt and _M_next of all created\n-\t      // nodes. This is a hacking but IMO works well.\n+\t      // nodes. This is a hack but IMO works well.\n \t      std::stack<_StateIdT> __stack;\n \t      for (long __i = 0; __i < __n; ++__i)\n \t\t{\n@@ -511,12 +511,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _BracketMatcher<_TraitsT, __icase, __collate>::\n     _M_apply(_CharT __ch, false_type) const\n     {\n-      bool __ret = false;\n-      if (std::find(_M_char_set.begin(), _M_char_set.end(),\n-\t\t    _M_translator._M_translate(__ch))\n-\t  != _M_char_set.end())\n-\t__ret = true;\n-      else\n+      bool __ret = std::binary_search(_M_char_set.begin(), _M_char_set.end(),\n+\t\t\t\t      _M_translator._M_translate(__ch));\n+      if (!__ret)\n \t{\n \t  auto __s = _M_translator._M_transform(__ch);\n \t  for (auto& __it : _M_range_set)"}, {"sha": "1991c0007a1aee3f1ea6466f18d206734eb2993e", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 73, "deletions": 26, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -42,8 +42,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   /**\n-   * @brief Takes a regex and an input string in and\n-   * do the matching.\n+   * @brief Takes a regex and an input string and does the matching.\n    *\n    * The %_Executor class has two modes: DFS mode and BFS mode, controlled\n    * by the template parameter %__dfs_mode.\n@@ -52,6 +51,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   bool __dfs_mode>\n     class _Executor\n     {\n+      using __search_mode = integral_constant<bool, __dfs_mode>;\n+      using __dfs = true_type;\n+      using __bfs = false_type;\n+\n+      enum class _Match_mode : unsigned char { _Exact, _Prefix };\n+\n     public:\n       typedef typename iterator_traits<_BiIter>::value_type _CharT;\n       typedef basic_regex<_CharT, _TraitsT>                 _RegexT;\n@@ -71,49 +76,50 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_re(__re),\n       _M_nfa(*__re._M_automaton),\n       _M_results(__results),\n-      _M_match_queue(__dfs_mode ? nullptr\n-\t\t     : new vector<pair<_StateIdT, _ResultsVec>>()),\n       _M_rep_count(_M_nfa.size()),\n-      _M_visited(__dfs_mode ? nullptr : new vector<bool>(_M_nfa.size())),\n+      _M_states(_M_nfa._M_start(), _M_nfa.size()),\n       _M_flags((__flags & regex_constants::match_prev_avail)\n \t       ? (__flags\n \t\t  & ~regex_constants::match_not_bol\n \t\t  & ~regex_constants::match_not_bow)\n-\t       : __flags),\n-      _M_start_state(_M_nfa._M_start())\n+\t       : __flags)\n       { }\n \n-      // Set matched when string exactly match the pattern.\n+      // Set matched when string exactly matches the pattern.\n       bool\n       _M_match()\n       {\n \t_M_current = _M_begin;\n-\treturn _M_main<true>();\n+\treturn _M_main(_Match_mode::_Exact);\n       }\n \n       // Set matched when some prefix of the string matches the pattern.\n       bool\n       _M_search_from_first()\n       {\n \t_M_current = _M_begin;\n-\treturn _M_main<false>();\n+\treturn _M_main(_Match_mode::_Prefix);\n       }\n \n       bool\n       _M_search();\n \n     private:\n-      template<bool __match_mode>\n-\tvoid\n-\t_M_rep_once_more(_StateIdT);\n+      void\n+      _M_rep_once_more(_Match_mode __match_mode, _StateIdT);\n \n-      template<bool __match_mode>\n-\tvoid\n-\t_M_dfs(_StateIdT __start);\n+      void\n+      _M_dfs(_Match_mode __match_mode, _StateIdT __start);\n \n-      template<bool __match_mode>\n-\tbool\n-\t_M_main();\n+      bool\n+      _M_main(_Match_mode __match_mode)\n+      { return _M_main_dispatch(__match_mode, __search_mode{}); }\n+\n+      bool\n+      _M_main_dispatch(_Match_mode __match_mode, __dfs);\n+\n+      bool\n+      _M_main_dispatch(_Match_mode __match_mode, __bfs);\n \n       bool\n       _M_is_word(_CharT __ch) const\n@@ -144,6 +150,53 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\n       _M_lookahead(_State<_TraitsT> __state);\n \n+       // Holds additional information used in BFS-mode.\n+      template<typename _SearchMode, typename _ResultsVec>\n+\tstruct _State_info;\n+\n+      template<typename _ResultsVec>\n+\tstruct _State_info<__bfs, _ResultsVec>\n+\t{\n+\t  explicit\n+\t  _State_info(_StateIdT __start, size_t __n)\n+\t  : _M_start(__start), _M_visited_states(new bool[__n]())\n+\t  { }\n+\n+\t  bool _M_visited(_StateIdT __i)\n+\t  {\n+\t    if (_M_visited_states[__i])\n+\t      return true;\n+\t    _M_visited_states[__i] = true;\n+\t    return false;\n+\t  }\n+\n+\t  void _M_queue(_StateIdT __i, const _ResultsVec& __res)\n+\t  { _M_match_queue.emplace_back(__i, __res); }\n+\n+\t  // Saves states that need to be considered for the next character.\n+\t  vector<pair<_StateIdT, _ResultsVec>>\t_M_match_queue;\n+\t  // Indicates which states are already visited.\n+\t  unique_ptr<bool[]>\t\t\t_M_visited_states;\n+\t  // To record current solution.\n+\t  _StateIdT _M_start;\n+\t};\n+\n+      template<typename _ResultsVec>\n+\tstruct _State_info<__dfs, _ResultsVec>\n+\t{\n+\t  explicit\n+\t  _State_info(_StateIdT __start, size_t) : _M_start(__start)\n+\t  { }\n+\n+\t  // Dummy implementations for DFS mode.\n+\t  bool _M_visited(_StateIdT) const { return false; }\n+\t  void _M_queue(_StateIdT, const _ResultsVec&) { }\n+\n+\t  // To record current solution.\n+\t  _StateIdT _M_start;\n+\t};\n+\n+\n     public:\n       _ResultsVec                                           _M_cur_results;\n       _BiIter                                               _M_current;\n@@ -152,15 +205,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       const _RegexT&                                        _M_re;\n       const _NFAT&                                          _M_nfa;\n       _ResultsVec&                                          _M_results;\n-      // Used in BFS, saving states that need to be considered for the next\n-      // character.\n-      unique_ptr<vector<pair<_StateIdT, _ResultsVec>>>      _M_match_queue;\n-      // Used in BFS, indicating that which state is already visited.\n       vector<pair<_BiIter, int>>                            _M_rep_count;\n-      unique_ptr<vector<bool>>                              _M_visited;\n+      _State_info<__search_mode, _ResultsVec>\t\t    _M_states;\n       _FlagT                                                _M_flags;\n-      // To record current solution.\n-      _StateIdT                                             _M_start_state;\n       // Do we have a solution so far?\n       bool                                                  _M_has_sol;\n     };"}, {"sha": "aefa8f4713776a600691eabecf96b502151d7f9f", "filename": "libstdc++-v3/include/bits/regex_executor.tcc", "status": "modified", "additions": 79, "deletions": 89, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.tcc?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -35,7 +35,7 @@ namespace __detail\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n-    bool __dfs_mode>\n+\t   bool __dfs_mode>\n     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n     _M_search()\n     {\n@@ -45,36 +45,48 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       do\n \t{\n \t  _M_current = __cur;\n-\t  if (_M_main<false>())\n+\t  if (_M_main(_Match_mode::_Prefix))\n \t    return true;\n \t}\n       // Continue when __cur == _M_end\n       while (__cur++ != _M_end);\n       return false;\n     }\n \n-  // This function operates in different modes, DFS mode or BFS mode, indicated\n-  // by template parameter __dfs_mode. See _M_main for details.\n+  // The _M_main function operates in different modes, DFS mode or BFS mode,\n+  // indicated by template parameter __dfs_mode, and dispatches to one of the\n+  // _M_main_dispatch overloads.\n   //\n   // ------------------------------------------------------------\n   //\n   // DFS mode:\n   //\n   // It applies a Depth-First-Search (aka backtracking) on given NFA and input\n   // string.\n-  // At the very beginning the executor stands in the start state, then it tries\n-  // every possible state transition in current state recursively. Some state\n-  // transitions consume input string, say, a single-char-matcher or a\n+  // At the very beginning the executor stands in the start state, then it\n+  // tries every possible state transition in current state recursively. Some\n+  // state transitions consume input string, say, a single-char-matcher or a\n   // back-reference matcher; some don't, like assertion or other anchor nodes.\n-  // When the input is exhausted and/or the current state is an accepting state,\n-  // the whole executor returns true.\n+  // When the input is exhausted and/or the current state is an accepting\n+  // state, the whole executor returns true.\n   //\n   // TODO: This approach is exponentially slow for certain input.\n   //       Try to compile the NFA to a DFA.\n   //\n   // Time complexity: \\Omega(match_length), O(2^(_M_nfa.size()))\n   // Space complexity: \\theta(match_results.size() + match_length)\n   //\n+  template<typename _BiIter, typename _Alloc, typename _TraitsT,\n+\t   bool __dfs_mode>\n+    bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n+    _M_main_dispatch(_Match_mode __match_mode, __dfs)\n+    {\n+      _M_has_sol = false;\n+      _M_cur_results = _M_results;\n+      _M_dfs(__match_mode, _M_states._M_start);\n+      return _M_has_sol;\n+    }\n+\n   // ------------------------------------------------------------\n   //\n   // BFS mode:\n@@ -84,11 +96,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   //\n   // It first computes epsilon closure (states that can be achieved without\n   // consuming characters) for every state that's still matching,\n-  // using the same DFS algorithm, but doesn't re-enter states (find a true in\n-  // _M_visited), nor follows _S_opcode_match.\n+  // using the same DFS algorithm, but doesn't re-enter states (using\n+  // _M_states._M_visited to check), nor follow _S_opcode_match.\n   //\n-  // Then apply DFS using every _S_opcode_match (in _M_match_queue) as the start\n-  // state.\n+  // Then apply DFS using every _S_opcode_match (in _M_states._M_match_queue)\n+  // as the start state.\n   //\n   // It significantly reduces potential duplicate states, so has a better\n   // upper bound; but it requires more overhead.\n@@ -98,60 +110,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Space complexity: \\Omega(_M_nfa.size() + match_results.size())\n   //                   O(_M_nfa.size() * match_results.size())\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n-    bool __dfs_mode>\n-  template<bool __match_mode>\n+\t   bool __dfs_mode>\n     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n-    _M_main()\n+    _M_main_dispatch(_Match_mode __match_mode, __bfs)\n     {\n-      if (__dfs_mode)\n+      _M_states._M_queue(_M_states._M_start, _M_results);\n+      bool __ret = false;\n+      while (1)\n \t{\n \t  _M_has_sol = false;\n-\t  _M_cur_results = _M_results;\n-\t  _M_dfs<__match_mode>(_M_start_state);\n-\t  return _M_has_sol;\n-\t}\n-      else\n-\t{\n-\t  _M_match_queue->push_back(make_pair(_M_start_state, _M_results));\n-\t  bool __ret = false;\n-\t  while (1)\n+\t  if (_M_states._M_match_queue.empty())\n+\t    break;\n+\t  std::fill_n(_M_states._M_visited_states.get(), _M_nfa.size(), false);\n+\t  auto __old_queue = std::move(_M_states._M_match_queue);\n+\t  for (auto& __task : __old_queue)\n \t    {\n-\t      _M_has_sol = false;\n-\t      if (_M_match_queue->empty())\n-\t\tbreak;\n-\t      _M_visited->assign(_M_visited->size(), false);\n-\t      auto _M_old_queue = std::move(*_M_match_queue);\n-\t      for (auto __task : _M_old_queue)\n-\t\t{\n-\t\t  _M_cur_results = __task.second;\n-\t\t  _M_dfs<__match_mode>(__task.first);\n-\t\t}\n-\t      if (!__match_mode)\n-\t\t__ret |= _M_has_sol;\n-\t      if (_M_current == _M_end)\n-\t\tbreak;\n-\t      ++_M_current;\n+\t      _M_cur_results = std::move(__task.second);\n+\t      _M_dfs(__match_mode, __task.first);\n \t    }\n-\t  if (__match_mode)\n-\t    __ret = _M_has_sol;\n-\t  return __ret;\n+\t  if (__match_mode == _Match_mode::_Prefix)\n+\t    __ret |= _M_has_sol;\n+\t  if (_M_current == _M_end)\n+\t    break;\n+\t  ++_M_current;\n \t}\n+      if (__match_mode == _Match_mode::_Exact)\n+\t__ret = _M_has_sol;\n+      return __ret;\n     }\n \n   // Return whether now match the given sub-NFA.\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n-    bool __dfs_mode>\n+\t   bool __dfs_mode>\n     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n     _M_lookahead(_State<_TraitsT> __state)\n     {\n       _ResultsVec __what(_M_cur_results.size());\n-      auto __sub = std::unique_ptr<_Executor>(new _Executor(_M_current,\n-\t\t\t\t\t\t\t    _M_end,\n-\t\t\t\t\t\t\t    __what,\n-\t\t\t\t\t\t\t    _M_re,\n-\t\t\t\t\t\t\t    _M_flags));\n-      __sub->_M_start_state = __state._M_alt;\n-      if (__sub->_M_search_from_first())\n+      _Executor __sub(_M_current, _M_end, __what, _M_re, _M_flags);\n+      __sub._M_states._M_start = __state._M_alt;\n+      if (__sub._M_search_from_first())\n \t{\n \t  for (size_t __i = 0; __i < __what.size(); __i++)\n \t    if (__what[__i].matched)\n@@ -169,9 +166,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // we need to spare one more time for potential group capture.\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n     bool __dfs_mode>\n-  template<bool __match_mode>\n     void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n-    _M_rep_once_more(_StateIdT __i)\n+    _M_rep_once_more(_Match_mode __match_mode, _StateIdT __i)\n     {\n       const auto& __state = _M_nfa[__i];\n       auto& __rep_count = _M_rep_count[__i];\n@@ -180,32 +176,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  auto __back = __rep_count;\n \t  __rep_count.first = _M_current;\n \t  __rep_count.second = 1;\n-\t  _M_dfs<__match_mode>(__state._M_alt);\n+\t  _M_dfs(__match_mode, __state._M_alt);\n \t  __rep_count = __back;\n \t}\n       else\n \t{\n \t  if (__rep_count.second < 2)\n \t    {\n \t      __rep_count.second++;\n-\t      _M_dfs<__match_mode>(__state._M_alt);\n+\t      _M_dfs(__match_mode, __state._M_alt);\n \t      __rep_count.second--;\n \t    }\n \t}\n     };\n \n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n-    bool __dfs_mode>\n-  template<bool __match_mode>\n+\t   bool __dfs_mode>\n     void _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n-    _M_dfs(_StateIdT __i)\n+    _M_dfs(_Match_mode __match_mode, _StateIdT __i)\n     {\n-      if (!__dfs_mode)\n-\t{\n-\t  if ((*_M_visited)[__i])\n-\t    return;\n-\t  (*_M_visited)[__i] = true;\n-\t}\n+      if (_M_states._M_visited(__i))\n+\treturn;\n \n       const auto& __state = _M_nfa[__i];\n       // Every change on _M_cur_results and _M_current will be rolled back after\n@@ -221,33 +212,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // Greedy.\n \t    if (!__state._M_neg)\n \t      {\n-\t\t_M_rep_once_more<__match_mode>(__i);\n+\t\t_M_rep_once_more(__match_mode, __i);\n \t\t// If it's DFS executor and already accepted, we're done.\n \t\tif (!__dfs_mode || !_M_has_sol)\n-\t\t  _M_dfs<__match_mode>(__state._M_next);\n+\t\t  _M_dfs(__match_mode, __state._M_next);\n \t      }\n \t    else // Non-greedy mode\n \t      {\n \t\tif (__dfs_mode)\n \t\t  {\n \t\t    // vice-versa.\n-\t\t    _M_dfs<__match_mode>(__state._M_next);\n+\t\t    _M_dfs(__match_mode, __state._M_next);\n \t\t    if (!_M_has_sol)\n-\t\t      _M_rep_once_more<__match_mode>(__i);\n+\t\t      _M_rep_once_more(__match_mode, __i);\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    // DON'T attempt anything, because there's already another\n-\t\t    // state with higher priority accepted. This state cannot be\n-\t\t    // better by attempting its next node.\n+\t\t    // state with higher priority accepted. This state cannot\n+\t\t    // be better by attempting its next node.\n \t\t    if (!_M_has_sol)\n \t\t      {\n-\t\t\t_M_dfs<__match_mode>(__state._M_next);\n+\t\t\t_M_dfs(__match_mode, __state._M_next);\n \t\t\t// DON'T attempt anything if it's already accepted. An\n \t\t\t// accepted state *must* be better than a solution that\n \t\t\t// matches a non-greedy quantifier one more time.\n \t\t\tif (!_M_has_sol)\n-\t\t\t  _M_rep_once_more<__match_mode>(__i);\n+\t\t\t  _M_rep_once_more(__match_mode, __i);\n \t\t      }\n \t\t  }\n \t      }\n@@ -258,7 +249,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    auto& __res = _M_cur_results[__state._M_subexpr];\n \t    auto __back = __res.first;\n \t    __res.first = _M_current;\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t    __res.first = __back;\n \t  }\n \t  break;\n@@ -268,42 +259,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    auto __back = __res;\n \t    __res.second = _M_current;\n \t    __res.matched = true;\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t    __res = __back;\n \t  }\n \t  break;\n \tcase _S_opcode_line_begin_assertion:\n \t  if (_M_at_begin())\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t  break;\n \tcase _S_opcode_line_end_assertion:\n \t  if (_M_at_end())\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t  break;\n \tcase _S_opcode_word_boundary:\n \t  if (_M_word_boundary(__state) == !__state._M_neg)\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t  break;\n \t// Here __state._M_alt offers a single start node for a sub-NFA.\n \t// We recursively invoke our algorithm to match the sub-NFA.\n \tcase _S_opcode_subexpr_lookahead:\n \t  if (_M_lookahead(__state) == !__state._M_neg)\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t  break;\n \tcase _S_opcode_match:\n \t  if (__dfs_mode)\n \t    {\n \t      if (_M_current != _M_end && __state._M_matches(*_M_current))\n \t\t{\n \t\t  ++_M_current;\n-\t\t  _M_dfs<__match_mode>(__state._M_next);\n+\t\t  _M_dfs(__match_mode, __state._M_next);\n \t\t  --_M_current;\n \t\t}\n \t    }\n \t  else\n \t    if (__state._M_matches(*_M_current))\n-\t      _M_match_queue->push_back(make_pair(__state._M_next,\n-\t\t\t\t\t\t  _M_cur_results));\n+\t      _M_states._M_queue(__state._M_next, _M_cur_results);\n \t  break;\n \t// First fetch the matched result from _M_cur_results as __submatch;\n \t// then compare it with\n@@ -328,19 +318,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  {\n \t\t    auto __backup = _M_current;\n \t\t    _M_current = __last;\n-\t\t    _M_dfs<__match_mode>(__state._M_next);\n+\t\t    _M_dfs(__match_mode, __state._M_next);\n \t\t    _M_current = __backup;\n \t\t  }\n \t\telse\n-\t\t  _M_dfs<__match_mode>(__state._M_next);\n+\t\t  _M_dfs(__match_mode, __state._M_next);\n \t      }\n \t  }\n \t  break;\n \tcase _S_opcode_accept:\n \t  if (__dfs_mode)\n \t    {\n \t      _GLIBCXX_DEBUG_ASSERT(!_M_has_sol);\n-\t      if (__match_mode)\n+\t      if (__match_mode == _Match_mode::_Exact)\n \t\t_M_has_sol = _M_current == _M_end;\n \t      else\n \t\t_M_has_sol = true;\n@@ -355,7 +345,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      if (_M_current == _M_begin\n \t\t  && (_M_flags & regex_constants::match_not_null))\n \t\tbreak;\n-\t      if (!__match_mode || _M_current == _M_end)\n+\t      if (__match_mode == _Match_mode::_Prefix || _M_current == _M_end)\n \t\tif (!_M_has_sol)\n \t\t  {\n \t\t    _M_has_sol = true;\n@@ -364,9 +354,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t  break;\n \tcase _S_opcode_alternative:\n-\t  _M_dfs<__match_mode>(__state._M_alt);\n+\t  _M_dfs(__match_mode, __state._M_alt);\n \t  if (!__dfs_mode || !_M_has_sol)\n-\t    _M_dfs<__match_mode>(__state._M_next);\n+\t    _M_dfs(__match_mode, __state._M_next);\n \t  break;\n \tdefault:\n \t  _GLIBCXX_DEBUG_ASSERT(false);\n@@ -375,7 +365,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Return whether now is at some word boundary.\n   template<typename _BiIter, typename _Alloc, typename _TraitsT,\n-    bool __dfs_mode>\n+\t   bool __dfs_mode>\n     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::\n     _M_word_boundary(_State<_TraitsT> __state) const\n     {"}, {"sha": "818e47b5670005ffb24be9598adf37ff3c7f1c99", "filename": "libstdc++-v3/include/bits/regex_scanner.tcc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_scanner.tcc?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -227,14 +227,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t}\n       // In POSIX, when encountering \"[]\" or \"[^]\", the ']' is interpreted\n-      // literally. So \"[]]\" or \"[^]]\" is valid regex. See the testcases\n+      // literally. So \"[]]\" and \"[^]]\" are valid regexes. See the testcases\n       // `*/empty_range.cc`.\n       else if (__c == ']' && (_M_is_ecma() || !_M_at_bracket_start))\n \t{\n \t  _M_token = _S_token_bracket_end;\n \t  _M_state = _S_state_normal;\n \t}\n-      // ECMAScirpt and awk permmits escaping in bracket.\n+      // ECMAScript and awk permits escaping in bracket.\n       else if (__c == '\\\\' && (_M_is_ecma() || _M_is_awk()))\n \t(this->*_M_eat_escape)();\n       else\n@@ -344,7 +344,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n \t  _M_token = _S_token_hex_num;\n \t}\n-      // ECMAScript recongnizes multi-digit back-references.\n+      // ECMAScript recognizes multi-digit back-references.\n       else if (_M_ctype.is(_CtypeT::digit, __c))\n \t{\n \t  _M_value.assign(1, __c);\n@@ -392,6 +392,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else\n \t{\n #ifdef __STRICT_ANSI__\n+\t  // POSIX says it is undefined to escape ordinary characters\n \t  __throw_regex_error(regex_constants::error_escape);\n #else\n \t  _M_token = _S_token_ord_char;\n@@ -435,8 +436,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__throw_regex_error(regex_constants::error_escape);\n     }\n \n-  // Eats a character class or throwns an exception.\n-  // __ch cound be ':', '.' or '=', _M_current is the char after ']' when\n+  // Eats a character class or throws an exception.\n+  // __ch could be ':', '.' or '=', _M_current is the char after ']' when\n   // returning.\n   template<typename _CharT>\n     void"}, {"sha": "891cc2e2621591da95bf602f6fc996fed8c4a43a", "filename": "libstdc++-v3/testsuite/performance/28_regex/range.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/097f0bcf651b735f9dcf517e6c00630da9e40a8a/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F28_regex%2Frange.cc?ref=097f0bcf651b735f9dcf517e6c00630da9e40a8a", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <regex>\n+#include <testsuite_performance.h>\n+\n+using namespace __gnu_test;\n+\n+int main()\n+{\n+  time_counter time;\n+  resource_counter resource;\n+\n+  start_counters(time, resource);\n+\n+  // this should get compiled to just L\"[abcd]\"\n+  auto re = std::wregex(L'[' + std::wstring(300, L'a') + L\"bc\"\n+                        + std::wstring(1000, 'a') + L\"d]\");\n+  bool ok = true;\n+  for (int i = 0; i < 100000; ++i)\n+    ok = ok && (std::regex_match(L\"b\", re) && std::regex_match(L\"d\", re));\n+\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"\", time, resource);\n+\n+  return ok ? 0 : 1;\n+}"}]}