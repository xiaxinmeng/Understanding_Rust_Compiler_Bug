{"sha": "cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I5YTFkOWJiNjNiNjhkNjA0ZGRlOTlhOTE2ZTQ4ZWI1MTcxZGQ3ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-03-25T19:20:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-03-25T19:20:34Z"}, "message": "re PR rtl-optimization/10056 ([HP-PA] ICE at -O2 when building c++ code from doxygen)\n\n\tPR opt/10056\n\t* cfglayout.c (fixup_reorder_chain):  Fix dealing with the conditional\n\tjump jumping to the next instruction.\n\t* cfgrtl.c (force_nonfallthru_and_redirect):  Likewise.\n\nFrom-SVN: r64854", "tree": {"sha": "0e69de262d22541befef3a9f7c91b5a102b2a66c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e69de262d22541befef3a9f7c91b5a102b2a66c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/comments", "author": null, "committer": null, "parents": [{"sha": "dcb0eee2a208c8283d8ae7dc59747664b33efcce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcb0eee2a208c8283d8ae7dc59747664b33efcce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcb0eee2a208c8283d8ae7dc59747664b33efcce"}], "stats": {"total": 73, "additions": 70, "deletions": 3}, "files": [{"sha": "ff7624a8ec67f4f174b3686322a76be53e52e69e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "patch": "@@ -1,3 +1,10 @@\n+Mon Mar 24 20:03:03 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR opt/10056\n+\t* cfglayout.c (fixup_reorder_chain):  Fix dealing with the conditional\n+\tjump jumping to the next instruction.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect):  Likewise.\n+\n 2003-03-25  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* doc/passes.texi (Passes): Properly document that we do not"}, {"sha": "c95ac3845356e6b7b3b921581b1caf24a05d378d", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "patch": "@@ -465,11 +465,43 @@ fixup_reorder_chain ()\n \t\t      && e_fall->dest == EXIT_BLOCK_PTR))\n \t\tcontinue;\n \n+\t      /* The degenerated case of conditional jump jumping to the next\n+\t\t instruction can happen on target having jumps with side\n+\t\t effects.  \n+\n+\t\t Create temporarily the duplicated edge representing branch.\n+\t\t It will get unidentified by force_nonfallthru_and_redirect\n+\t\t that would otherwise get confused by fallthru edge not pointing\n+\t\t to the next basic block.  */\n+\t      if (!e_taken)\n+\t\t{\n+\t\t  rtx note;\n+\t\t  edge e_fake;\n+\n+\t\t  e_fake = unchecked_make_edge (bb, e_fall->dest, 0);\n+\n+\t\t  if (!redirect_jump (bb->end, block_label (bb), 0))\n+\t\t    abort ();\n+\t\t  note = find_reg_note (bb->end, REG_BR_PROB, NULL_RTX);\n+\t\t  if (note)\n+\t\t    {\n+\t\t      int prob = INTVAL (XEXP (note, 0));\n+\n+\t\t      e_fake->probability = prob;\n+\t\t      e_fake->count = e_fall->count * prob / REG_BR_PROB_BASE;\n+\t\t      e_fall->probability -= e_fall->probability;\n+\t\t      e_fall->count -= e_fake->count;\n+\t\t      if (e_fall->probability < 0)\n+\t\t\te_fall->probability = 0;\n+\t\t      if (e_fall->count < 0)\n+\t\t\te_fall->count = 0;\n+\t\t    }\n+\t\t}\n \t      /* There is one special case: if *neither* block is next,\n \t\t such as happens at the very end of a function, then we'll\n \t\t need to add a new unconditional jump.  Choose the taken\n \t\t edge based on known or assumed probability.  */\n-\t      if (RBI (bb)->next != e_taken->dest)\n+\t      else if (RBI (bb)->next != e_taken->dest)\n \t\t{\n \t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n "}, {"sha": "5e47236b4cea58448478ec2ed245f0ae2d4c477c", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9a1d9bb63b68d604dde99a916e48eb5171dd7e/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=cb9a1d9bb63b68d604dde99a916e48eb5171dd7e", "patch": "@@ -78,7 +78,7 @@ static void commit_one_edge_insertion\tPARAMS ((edge, int));\n static bool try_redirect_by_replacing_jump PARAMS ((edge, basic_block));\n static rtx last_loop_beg_note\t\tPARAMS ((rtx));\n static bool back_edge_of_syntactic_loop_p PARAMS ((basic_block, basic_block));\n-static basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n+basic_block force_nonfallthru_and_redirect PARAMS ((edge, basic_block));\n \f\n /* Return true if NOTE is not one of the ones that must be kept paired,\n    so that we may simply delete it.  */\n@@ -930,7 +930,7 @@ redirect_edge_and_branch (e, target)\n /* Like force_nonfallthru below, but additionally performs redirection\n    Used by redirect_edge_and_branch_force.  */\n \n-static basic_block\n+basic_block\n force_nonfallthru_and_redirect (e, target)\n      edge e;\n      basic_block target;\n@@ -940,6 +940,34 @@ force_nonfallthru_and_redirect (e, target)\n   edge new_edge;\n   int abnormal_edge_flags = 0;\n \n+  /* In the case the last instruction is conditional jump to the next\n+     instruction, first redirect the jump itself and then continue\n+     by creating an basic block afterwards to redirect fallthru edge.  */\n+  if (e->src != ENTRY_BLOCK_PTR && e->dest != EXIT_BLOCK_PTR\n+      && any_condjump_p (e->src->end)\n+      && JUMP_LABEL (e->src->end) == e->dest->head)\n+    {\n+      rtx note;\n+      edge b = make_edge (e->src, target, 0);\n+\n+      if (!redirect_jump (e->src->end, block_label (target), 0))\n+\tabort ();\n+      note = find_reg_note (e->src->end, REG_BR_PROB, NULL_RTX);\n+      if (note)\n+\t{\n+\t  int prob = INTVAL (XEXP (note, 0));\n+\n+\t  b->probability = prob;\n+\t  b->count = e->count * prob / REG_BR_PROB_BASE;\n+\t  e->probability -= e->probability;\n+\t  e->count -= b->count;\n+\t  if (e->probability < 0)\n+\t    e->probability = 0;\n+\t  if (e->count < 0)\n+\t    e->count = 0;\n+\t}\n+    }\n+\n   if (e->flags & EDGE_ABNORMAL)\n     {\n       /* Irritating special case - fallthru edge to the same block as abnormal"}]}