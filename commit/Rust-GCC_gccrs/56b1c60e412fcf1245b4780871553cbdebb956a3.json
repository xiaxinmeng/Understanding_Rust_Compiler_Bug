{"sha": "56b1c60e412fcf1245b4780871553cbdebb956a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiMWM2MGU0MTJmY2YxMjQ1YjQ3ODA4NzE1NTNjYmRlYmI5NTZhMw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2016-11-23T14:51:02Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2016-11-23T14:51:02Z"}, "message": "backport: hsa-builtins.def: New file.\n\nMerge from HSA branch to trunk\n\n2016-11-23  Martin Jambor  <mjambor@suse.cz>\n\t    Martin Liska  <mliska@suse.cz>\n\ngcc/\n\t* hsa-builtins.def: New file.\n\t* Makefile.in (BUILTINS_DEF): Add hsa-builtins.def dependency.\n\t* builtins.def: Include hsa-builtins.def.\n\t(DEF_HSA_BUILTIN): New macro.\n\t* dumpfile.h (OPTGROUP_OPENMP): Define.\n\t* dumpfile.c (optgroup_options): Added OPTGROUP_OPENMP.\n\t* gimple.h (gf_mask): Added elements GF_OMP_FOR_GRID_INTRA_GROUP and\n\tGF_OMP_FOR_GRID_GROUP_ITER.\n\t(gimple_omp_for_grid_phony): Added checking assert.\n\t(gimple_omp_for_set_grid_phony): Likewise.\n\t(gimple_omp_for_grid_intra_group): New function.\n\t(gimple_omp_for_set_grid_intra_group): Likewise.\n\t(gimple_omp_for_grid_group_iter): Likewise.\n\t(gimple_omp_for_set_grid_group_iter): Likewise.\n\t* omp-low.c (check_omp_nesting_restrictions): Allow GRID loop where\n\tpreviosuly only distribute loop was permitted.\n\t(lower_lastprivate_clauses): Allow non tcc_comparison predicates.\n\t(grid_get_kernel_launch_attributes): Support multiple HSA grid\n\tdimensions.\n\t(grid_expand_omp_for_loop): Likewise and also support standalone\n\tdistribute constructs.  New parameter INTRA_GROUP, updated both users.\n\t(grid_expand_target_grid_body): Support standalone distribute\n\tconstructs.\n\t(pass_data_expand_omp): Changed optinfo_flags to OPTGROUP_OPENMP.\n\t(pass_data_expand_omp_ssa): Likewise.\n\t(pass_data_omp_device_lower): Likewsie.\n\t(pass_data_lower_omp): Likewise.\n\t(pass_data_diagnose_omp_blocks): Likewise.\n\t(pass_data_oacc_device_lower): Likewise.\n\t(pass_data_omp_target_link): Likewise.\n\t(grid_lastprivate_predicate): New function.\n\t(lower_omp_for_lastprivate): Call grid_lastprivate_predicate for\n\tgridified loops.\n\t(lower_omp_for): Support standalone distribute constructs.\n\t(grid_prop): New type.\n\t(grid_safe_assignment_p): Check for assignments to group_sizes, new\n\tparameter GRID.\n\t(grid_seq_only_contains_local_assignments): New parameter GRID, pass\n\tit to callee.\n\t(grid_find_single_omp_among_assignments_1): Likewise, improve missed\n\toptimization info messages.\n\t(grid_find_single_omp_among_assignments): Likewise.\n\t(grid_find_ungridifiable_statement): Do not bail out for SIMDs.\n\t(grid_parallel_clauses_gridifiable): New function.\n\t(grid_inner_loop_gridifiable_p): Likewise.\n\t(grid_dist_follows_simple_pattern): Likewise.\n\t(grid_gfor_follows_tiling_pattern): Likewise.\n\t(grid_call_permissible_in_distribute_p): Likewise.\n\t(grid_handle_call_in_distribute): Likewise.\n\t(grid_dist_follows_tiling_pattern): Likewise.\n\t(grid_target_follows_gridifiable_pattern): Support standalone distribute\n\tconstructs.\n\t(grid_var_segment): New enum.\n\t(grid_mark_variable_segment): New function.\n\t(grid_copy_leading_local_assignments): Call grid_mark_variable_segment\n\tif a new argument says so.\n\t(grid_process_grid_body): New function.\n\t(grid_eliminate_combined_simd_part): Likewise.\n\t(grid_mark_tiling_loops): Likewise.\n\t(grid_mark_tiling_parallels_and_loops): Likewise.\n\t(grid_process_kernel_body_copy): Support standalone distribute\n\tconstructs.\n\t(grid_attempt_target_gridification): New grid variable holding overall\n\tgridification state.  Support standalone distribute constructs and\n\tcollapse clauses.\n\t* doc/optinfo.texi (Optimization groups): Document OPTGROUP_OPENMP.\n\t* hsa.h (hsa_bb): Add method method append_phi.\n\t(hsa_insn_br): Renamed to hsa_insn_cbr, renamed all\n\toccurences in all files too.\n\t(hsa_insn_br): New class, now the ancestor of hsa_incn_cbr.\n\t(is_a_helper <hsa_insn_br *>::test): New function.\n\t(is_a_helper <hsa_insn_cbr *>::test): Adjust to only cover conditional\n\tbranch instructions.\n\t(hsa_insn_signal): Make a direct descendant of\n\thsa_insn_basic.  Add memorder constructor parameter and\n\tm_memory_order and m_signalop member variables.\n\t(hsa_insn_queue): Changed constructor parameters to common form.\n\tAdded m_segment and m_memory_order member variables.\n\t(hsa_summary_t): Add private member function\n\tprocess_gpu_implementation_attributes.\n\t(hsa_function_summary): Rename m_binded_function to\n\tm_bound_function.\n\t(hsa_insn_basic_p): Remove typedef.\n\t(hsa_op_with_type): Change hsa_insn_basic_p into plain pointers.\n\t(hsa_op_reg_p): Remove typedef.\n\t(hsa_function_representation): Change hsa_op_reg_p into plain\n\tpointers.\n\t(hsa_insn_phi): Removed new and delete operators.\n\t(hsa_insn_br): Likewise.\n\t(hsa_insn_cbr): Likewise.\n\t(hsa_insn_sbr): Likewise.\n\t(hsa_insn_cmp): Likewise.\n\t(hsa_insn_mem): Likewise.\n\t(hsa_insn_atomic): Likewise.\n\t(hsa_insn_signal): Likewise.\n\t(hsa_insn_seg): Likewise.\n\t(hsa_insn_call): Likewise.\n\t(hsa_insn_arg_block): Likewise.\n\t(hsa_insn_comment): Likewise.\n\t(hsa_insn_srctype): Likewise.\n\t(hsa_insn_packed): Likewise.\n\t(hsa_insn_cvt): Likewise.\n\t(hsa_insn_alloca): Likewise.\n\t* hsa.c (hsa_destroy_insn): Also handle instances of hsa_insn_br.\n\t(process_gpu_implementation_attributes): New function.\n\t(link_functions): Move some functionality into it.  Adjust after\n\trenaming m_binded_functions to m_bound_functions.\n\t(hsa_insn_basic::op_output_p): Add BRIG_OPCODE_DEBUGTRAP\n\tto the list of instructions with no output registers.\n\t(get_in_type): Return this if it is a register of\n\tmatching size.\n\t(hsa_get_declaration_name): Moved to...\n        * hsa-gen.c (hsa_get_declaration_name): ...here.  Allocate\n\ttemporary string on an obstack instead from ggc.\n\t(query_hsa_grid): Renamed to query_hsa_grid_dim, reimplemented, cut\n\tdown to two overloads.\n\t(hsa_allocp_operand_address): Removed.\n\t(hsa_allocp_operand_immed): Likewise.\n\t(hsa_allocp_operand_reg): Likewise.\n\t(hsa_allocp_operand_code_list): Likewise.\n\t(hsa_allocp_operand_operand_list): Likewise.\n\t(hsa_allocp_inst_basic): Likewise.\n\t(hsa_allocp_inst_phi): Likewise.\n\t(hsa_allocp_inst_mem): Likewise.\n\t(hsa_allocp_inst_atomic): Likewise.\n\t(hsa_allocp_inst_signal): Likewise.\n\t(hsa_allocp_inst_seg): Likewise.\n\t(hsa_allocp_inst_cmp): Likewise.\n\t(hsa_allocp_inst_br): Likewise.\n\t(hsa_allocp_inst_sbr): Likewise.\n\t(hsa_allocp_inst_call): Likewise.\n\t(hsa_allocp_inst_arg_block): Likewise.\n\t(hsa_allocp_inst_comment): Likewise.\n\t(hsa_allocp_inst_queue): Likewise.\n\t(hsa_allocp_inst_srctype): Likewise.\n\t(hsa_allocp_inst_packed): Likewise.\n\t(hsa_allocp_inst_cvt): Likewise.\n\t(hsa_allocp_inst_alloca): Likewise.\n\t(hsa_allocp_bb): Likewise.\n\t(hsa_obstack): New.\n\t(hsa_init_data_for_cfun): Initialize obstack.\n\t(hsa_deinit_data_for_cfun): Release memory of the obstack.\n\t(hsa_op_immed::operator new): Use obstack instead of object_allocator.\n\t(hsa_op_reg::operator new): Likewise.\n\t(hsa_op_address::operator new): Likewise.\n\t(hsa_op_code_list::operator new): Likewise.\n\t(hsa_op_operand_list::operator new): Likewise.\n\t(hsa_insn_basic::operator new): Likewise.\n\t(hsa_insn_phi::operator new): Likewise.\n\t(hsa_insn_br::operator new): Likewise.\n\t(hsa_insn_sbr::operator new): Likewise.\n\t(hsa_insn_cmp::operator new): Likewise.\n\t(hsa_insn_mem::operator new): Likewise.\n\t(hsa_insn_atomic::operator new): Likewise.\n\t(hsa_insn_signal::operator new): Likewise.\n\t(hsa_insn_seg::operator new): Likewise.\n\t(hsa_insn_call::operator new): Likewise.\n\t(hsa_insn_arg_block::operator new): Likewise.\n\t(hsa_insn_comment::operator new): Likewise.\n\t(hsa_insn_srctype::operator new): Likewise.\n\t(hsa_insn_packed::operator new): Likewise.\n\t(hsa_insn_cvt::operator new): Likewise.\n\t(hsa_insn_alloca::operator new): Likewise.\n\t(hsa_init_new_bb): Likewise.\n\t(hsa_bb::append_phi): New function.\n\t(gen_hsa_phi_from_gimple_phi): Use it.\n\t(get_symbol_for_decl): Fix dinstinguishing between\n\tglobal and local functions.  Put local variables into a segment\n\taccording to their attribute or static flag, if there is one.\n\t(hsa_insn_br::hsa_insn_br): New.\n\t(hsa_insn_br::operator new): Likewise.\n\t(hsa_insn_cbr::hsa_insn_cbr): Set width via ancestor constructor.\n\t(query_hsa_grid_nodim): New function.\n\t(multiply_grid_dim_characteristics): Likewise.\n\t(gen_get_num_threads): Likewise.\n\t(gen_get_num_teams): Reimplemented.\n\t(gen_get_team_num): Likewise.\n\t(gen_hsa_insns_for_known_library_call): Updated calls to the above\n\thelper functions.\n\t(get_memory_order_name): Removed.\n\t(get_memory_order): Likewise.\n\t(hsa_memorder_from_tree): New function.\n\t(gen_hsa_ternary_atomic_for_builtin): Renamed to\n\tgen_hsa_atomic_for_builtin, can also create signals.\n\t(gen_hsa_insns_for_call): Handle many new builtins.  Adjust to use\n\thsa_memory_order_from_tree and gen_hsa_atomic_for_builtin.\n\t(hsa_insn_atomic): Fix function comment.\n\t(hsa_insn_signal::hsa_insn_signal): Fix comment.  Update call to\n\tancestor constructor and initialization of new member variables.\n\t(hsa_insn_queue::hsa_insn_queue): Added initialization of new\n\tmember variables.\n\t(hsa_get_host_function): Handle functions with no bound CPU\n\timplementation.  Fix binded to bound.\n\t(get_brig_function_name): Likewise.\n\t(HSA_SORRY_ATV): Remove semicolon after macro.\n\t(HSA_SORRY_AT): Likewise.\n\t(omp_simple_builtin::generate): Add missing semicolons.\n\t(hsa_insn_phi::operator new): Removed.\n\t(hsa_insn_br::operator new): Likewise.\n\t(hsa_insn_cbr::operator new): Likewise.\n\t(hsa_insn_sbr::operator new): Likewise.\n\t(hsa_insn_cmp::operator new): Likewise.\n\t(hsa_insn_mem::operator new): Likewise.\n\t(hsa_insn_atomic::operator new): Likewise.\n\t(hsa_insn_signal::operator new): Likewise.\n\t(hsa_insn_seg::operator new): Likewise.\n\t(hsa_insn_call::operator new): Likewise.\n\t(hsa_insn_arg_block::operator new): Likewise.\n\t(hsa_insn_comment::operator new): Likewise.\n\t(hsa_insn_srctype::operator new): Likewise.\n\t(hsa_insn_packed::operator new): Likewise.\n\t(hsa_insn_cvt::operator new): Likewise.\n\t(hsa_insn_alloca::operator new): Likewise.\n\t(get_symbol_for_decl): Accept CONST_DECLs, put them to\n\treadonly segment.\n\t(gen_hsa_addr): Also process CONST_DECLs.\n\t(gen_hsa_addr_insns): Process CONST_DECLs by creating private\n\tcopies.\n\t(gen_hsa_unary_operation): Make sure the function does\n\tnot use bittype source type for firstbit and lastbit operations.\n\t(gen_hsa_popcount_to_dest): Make sure the function uses a bittype\n\tsource type.\n\t* hsa-brig.c (emit_insn_operands): Cope with zero operands in an\n\tinstruction.\n\t(emit_branch_insn): Renamed to emit_cond_branch_insn.\n\tEmit the width stored in the class.\n\t(emit_generic_branch_insn): New function.\n\t(emit_insn): Call emit_generic_branch_insn.\n\t(emit_signal_insn): Remove obsolete comment.  Update\n\tmember variable name, pick a type according to profile.\n\t(emit_alloca_insn): Remove obsolete comment.\n\t(emit_atomic_insn): Likewise.\n\t(emit_queue_insn): Get segment and memory order from the IR object.\n\t(hsa_brig_section): Make allocate_new_chunk, chunks\n\tand cur_chunk provate, add a default NULL parameter to add method.\n\t(hsa_brig_section::add): Added a new parameter, store pointer to\n\toutput data there if it is non-NULL.\n\t(emit_function_directives): Use this new parameter instead of\n\tcalculating the pointer itself, fix function comment.\n\t(hsa_brig_emit_function): Add forgotten endian conversion.\n\t(hsa_output_kernels): Remove unnecessary building of\n\tkernel_dependencies_vector_type.\n\t(emit_immediate_operand): Declare.\n\t(emit_directive_variable): Also emit initializers of CONST_DECLs.\n\t(gen_hsa_insn_for_internal_fn_call): Also handle IFN_RSQRT.\n\t(verify_function_arguments): Properly detect variadic\n\targuments.\n\t* hsa-dump.c (hsa_width_specifier_name): New function.\n\t(dump_hsa_insn_1): Dump generic branch instructions, update signal\n\tmember variable name.  Special dumping for queue objects.\n\t* ipa-hsa.c (process_hsa_functions): Adjust after renaming\n\tm_binded_functions to m_bound_functions.  Copy externally visible flag\n\tto the node.\n\t(ipa_hsa_write_summary): Likewise.\n\t(ipa_hsa_read_section): Likewise.\n\n\n\tgcc/fortran/\n        * f95-lang.c (DEF_HSA_BUILTIN): New macro.\n\ngcc/testsuite/\n\t* c-c++-common/gomp/gridify-1.c: Update scan string.\n\t* gfortran.dg/gomp/gridify-1.f90: Likewise.\n\t* c-c++-common/gomp/gridify-2.c: New test.\n\t* c-c++-common/gomp/gridify-3.c: Likewise.\n\nlibgomp/\n\t* testsuite/libgomp.hsa.c/bits-insns.c: New test.\n\t* testsuite/libgomp.hsa.c/tiling-1.c: Likewise.\n\t* testsuite/libgomp.hsa.c/tiling-2.c: Likewise.\n\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r242761", "tree": {"sha": "3a3e101ec1a0e1bdd140db82245f5884d841c62f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a3e101ec1a0e1bdd140db82245f5884d841c62f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b1c60e412fcf1245b4780871553cbdebb956a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b1c60e412fcf1245b4780871553cbdebb956a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b1c60e412fcf1245b4780871553cbdebb956a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b1c60e412fcf1245b4780871553cbdebb956a3/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f6cdfe826444e1a0b52b271588fbef5c2a4bac4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6cdfe826444e1a0b52b271588fbef5c2a4bac4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6cdfe826444e1a0b52b271588fbef5c2a4bac4d"}], "stats": {"total": 4041, "additions": 2996, "deletions": 1045}, "files": [{"sha": "f082b0aa6cb5fb248d2d3b790364aee35aa23153", "filename": "gcc/ChangeLog", "status": "modified", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -1,3 +1,262 @@\n+2016-11-23  Martin Jambor  <mjambor@suse.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\t* hsa-builtins.def: New file.\n+\t* Makefile.in (BUILTINS_DEF): Add hsa-builtins.def dependency.\n+\t* builtins.def: Include hsa-builtins.def.\n+\t(DEF_HSA_BUILTIN): New macro.\n+\t* dumpfile.h (OPTGROUP_OPENMP): Define.\n+\t* dumpfile.c (optgroup_options): Added OPTGROUP_OPENMP.\n+\t* gimple.h (gf_mask): Added elements GF_OMP_FOR_GRID_INTRA_GROUP and\n+\tGF_OMP_FOR_GRID_GROUP_ITER.\n+\t(gimple_omp_for_grid_phony): Added checking assert.\n+\t(gimple_omp_for_set_grid_phony): Likewise.\n+\t(gimple_omp_for_grid_intra_group): New function.\n+\t(gimple_omp_for_set_grid_intra_group): Likewise.\n+\t(gimple_omp_for_grid_group_iter): Likewise.\n+\t(gimple_omp_for_set_grid_group_iter): Likewise.\n+\t* omp-low.c (check_omp_nesting_restrictions): Allow GRID loop where\n+\tpreviosuly only distribute loop was permitted.\n+\t(lower_lastprivate_clauses): Allow non tcc_comparison predicates.\n+\t(grid_get_kernel_launch_attributes): Support multiple HSA grid\n+\tdimensions.\n+\t(grid_expand_omp_for_loop): Likewise and also support standalone\n+\tdistribute constructs.  New parameter INTRA_GROUP, updated both users.\n+\t(grid_expand_target_grid_body): Support standalone distribute\n+\tconstructs.\n+\t(pass_data_expand_omp): Changed optinfo_flags to OPTGROUP_OPENMP.\n+\t(pass_data_expand_omp_ssa): Likewise.\n+\t(pass_data_omp_device_lower): Likewsie.\n+\t(pass_data_lower_omp): Likewise.\n+\t(pass_data_diagnose_omp_blocks): Likewise.\n+\t(pass_data_oacc_device_lower): Likewise.\n+\t(pass_data_omp_target_link): Likewise.\n+\t(grid_lastprivate_predicate): New function.\n+\t(lower_omp_for_lastprivate): Call grid_lastprivate_predicate for\n+\tgridified loops.\n+\t(lower_omp_for): Support standalone distribute constructs.\n+\t(grid_prop): New type.\n+\t(grid_safe_assignment_p): Check for assignments to group_sizes, new\n+\tparameter GRID.\n+\t(grid_seq_only_contains_local_assignments): New parameter GRID, pass\n+\tit to callee.\n+\t(grid_find_single_omp_among_assignments_1): Likewise, improve missed\n+\toptimization info messages.\n+\t(grid_find_single_omp_among_assignments): Likewise.\n+\t(grid_find_ungridifiable_statement): Do not bail out for SIMDs.\n+\t(grid_parallel_clauses_gridifiable): New function.\n+\t(grid_inner_loop_gridifiable_p): Likewise.\n+\t(grid_dist_follows_simple_pattern): Likewise.\n+\t(grid_gfor_follows_tiling_pattern): Likewise.\n+\t(grid_call_permissible_in_distribute_p): Likewise.\n+\t(grid_handle_call_in_distribute): Likewise.\n+\t(grid_dist_follows_tiling_pattern): Likewise.\n+\t(grid_target_follows_gridifiable_pattern): Support standalone distribute\n+\tconstructs.\n+\t(grid_var_segment): New enum.\n+\t(grid_mark_variable_segment): New function.\n+\t(grid_copy_leading_local_assignments): Call grid_mark_variable_segment\n+\tif a new argument says so.\n+\t(grid_process_grid_body): New function.\n+\t(grid_eliminate_combined_simd_part): Likewise.\n+\t(grid_mark_tiling_loops): Likewise.\n+\t(grid_mark_tiling_parallels_and_loops): Likewise.\n+\t(grid_process_kernel_body_copy): Support standalone distribute\n+\tconstructs.\n+\t(grid_attempt_target_gridification): New grid variable holding overall\n+\tgridification state.  Support standalone distribute constructs and\n+\tcollapse clauses.\n+\t* doc/optinfo.texi (Optimization groups): Document OPTGROUP_OPENMP.\n+\t* hsa.h (hsa_bb): Add method method append_phi.\n+\t(hsa_insn_br): Renamed to hsa_insn_cbr, renamed all\n+\toccurences in all files too.\n+\t(hsa_insn_br): New class, now the ancestor of hsa_incn_cbr.\n+\t(is_a_helper <hsa_insn_br *>::test): New function.\n+\t(is_a_helper <hsa_insn_cbr *>::test): Adjust to only cover conditional\n+\tbranch instructions.\n+\t(hsa_insn_signal): Make a direct descendant of\n+\thsa_insn_basic.  Add memorder constructor parameter and\n+\tm_memory_order and m_signalop member variables.\n+\t(hsa_insn_queue): Changed constructor parameters to common form.\n+\tAdded m_segment and m_memory_order member variables.\n+\t(hsa_summary_t): Add private member function\n+\tprocess_gpu_implementation_attributes.\n+\t(hsa_function_summary): Rename m_binded_function to\n+\tm_bound_function.\n+\t(hsa_insn_basic_p): Remove typedef.\n+\t(hsa_op_with_type): Change hsa_insn_basic_p into plain pointers.\n+\t(hsa_op_reg_p): Remove typedef.\n+\t(hsa_function_representation): Change hsa_op_reg_p into plain\n+\tpointers.\n+\t(hsa_insn_phi): Removed new and delete operators.\n+\t(hsa_insn_br): Likewise.\n+\t(hsa_insn_cbr): Likewise.\n+\t(hsa_insn_sbr): Likewise.\n+\t(hsa_insn_cmp): Likewise.\n+\t(hsa_insn_mem): Likewise.\n+\t(hsa_insn_atomic): Likewise.\n+\t(hsa_insn_signal): Likewise.\n+\t(hsa_insn_seg): Likewise.\n+\t(hsa_insn_call): Likewise.\n+\t(hsa_insn_arg_block): Likewise.\n+\t(hsa_insn_comment): Likewise.\n+\t(hsa_insn_srctype): Likewise.\n+\t(hsa_insn_packed): Likewise.\n+\t(hsa_insn_cvt): Likewise.\n+\t(hsa_insn_alloca): Likewise.\n+\t* hsa.c (hsa_destroy_insn): Also handle instances of hsa_insn_br.\n+\t(process_gpu_implementation_attributes): New function.\n+\t(link_functions): Move some functionality into it.  Adjust after\n+\trenaming m_binded_functions to m_bound_functions.\n+\t(hsa_insn_basic::op_output_p): Add BRIG_OPCODE_DEBUGTRAP\n+\tto the list of instructions with no output registers.\n+\t(get_in_type): Return this if it is a register of\n+\tmatching size.\n+\t(hsa_get_declaration_name): Moved to...\n+        * hsa-gen.c (hsa_get_declaration_name): ...here.  Allocate\n+\ttemporary string on an obstack instead from ggc.\n+\t(query_hsa_grid): Renamed to query_hsa_grid_dim, reimplemented, cut\n+\tdown to two overloads.\n+\t(hsa_allocp_operand_address): Removed.\n+\t(hsa_allocp_operand_immed): Likewise.\n+\t(hsa_allocp_operand_reg): Likewise.\n+\t(hsa_allocp_operand_code_list): Likewise.\n+\t(hsa_allocp_operand_operand_list): Likewise.\n+\t(hsa_allocp_inst_basic): Likewise.\n+\t(hsa_allocp_inst_phi): Likewise.\n+\t(hsa_allocp_inst_mem): Likewise.\n+\t(hsa_allocp_inst_atomic): Likewise.\n+\t(hsa_allocp_inst_signal): Likewise.\n+\t(hsa_allocp_inst_seg): Likewise.\n+\t(hsa_allocp_inst_cmp): Likewise.\n+\t(hsa_allocp_inst_br): Likewise.\n+\t(hsa_allocp_inst_sbr): Likewise.\n+\t(hsa_allocp_inst_call): Likewise.\n+\t(hsa_allocp_inst_arg_block): Likewise.\n+\t(hsa_allocp_inst_comment): Likewise.\n+\t(hsa_allocp_inst_queue): Likewise.\n+\t(hsa_allocp_inst_srctype): Likewise.\n+\t(hsa_allocp_inst_packed): Likewise.\n+\t(hsa_allocp_inst_cvt): Likewise.\n+\t(hsa_allocp_inst_alloca): Likewise.\n+\t(hsa_allocp_bb): Likewise.\n+\t(hsa_obstack): New.\n+\t(hsa_init_data_for_cfun): Initialize obstack.\n+\t(hsa_deinit_data_for_cfun): Release memory of the obstack.\n+\t(hsa_op_immed::operator new): Use obstack instead of object_allocator.\n+\t(hsa_op_reg::operator new): Likewise.\n+\t(hsa_op_address::operator new): Likewise.\n+\t(hsa_op_code_list::operator new): Likewise.\n+\t(hsa_op_operand_list::operator new): Likewise.\n+\t(hsa_insn_basic::operator new): Likewise.\n+\t(hsa_insn_phi::operator new): Likewise.\n+\t(hsa_insn_br::operator new): Likewise.\n+\t(hsa_insn_sbr::operator new): Likewise.\n+\t(hsa_insn_cmp::operator new): Likewise.\n+\t(hsa_insn_mem::operator new): Likewise.\n+\t(hsa_insn_atomic::operator new): Likewise.\n+\t(hsa_insn_signal::operator new): Likewise.\n+\t(hsa_insn_seg::operator new): Likewise.\n+\t(hsa_insn_call::operator new): Likewise.\n+\t(hsa_insn_arg_block::operator new): Likewise.\n+\t(hsa_insn_comment::operator new): Likewise.\n+\t(hsa_insn_srctype::operator new): Likewise.\n+\t(hsa_insn_packed::operator new): Likewise.\n+\t(hsa_insn_cvt::operator new): Likewise.\n+\t(hsa_insn_alloca::operator new): Likewise.\n+\t(hsa_init_new_bb): Likewise.\n+\t(hsa_bb::append_phi): New function.\n+\t(gen_hsa_phi_from_gimple_phi): Use it.\n+\t(get_symbol_for_decl): Fix dinstinguishing between\n+\tglobal and local functions.  Put local variables into a segment\n+\taccording to their attribute or static flag, if there is one.\n+\t(hsa_insn_br::hsa_insn_br): New.\n+\t(hsa_insn_br::operator new): Likewise.\n+\t(hsa_insn_cbr::hsa_insn_cbr): Set width via ancestor constructor.\n+\t(query_hsa_grid_nodim): New function.\n+\t(multiply_grid_dim_characteristics): Likewise.\n+\t(gen_get_num_threads): Likewise.\n+\t(gen_get_num_teams): Reimplemented.\n+\t(gen_get_team_num): Likewise.\n+\t(gen_hsa_insns_for_known_library_call): Updated calls to the above\n+\thelper functions.\n+\t(get_memory_order_name): Removed.\n+\t(get_memory_order): Likewise.\n+\t(hsa_memorder_from_tree): New function.\n+\t(gen_hsa_ternary_atomic_for_builtin): Renamed to\n+\tgen_hsa_atomic_for_builtin, can also create signals.\n+\t(gen_hsa_insns_for_call): Handle many new builtins.  Adjust to use\n+\thsa_memory_order_from_tree and gen_hsa_atomic_for_builtin.\n+\t(hsa_insn_atomic): Fix function comment.\n+\t(hsa_insn_signal::hsa_insn_signal): Fix comment.  Update call to\n+\tancestor constructor and initialization of new member variables.\n+\t(hsa_insn_queue::hsa_insn_queue): Added initialization of new\n+\tmember variables.\n+\t(hsa_get_host_function): Handle functions with no bound CPU\n+\timplementation.  Fix binded to bound.\n+\t(get_brig_function_name): Likewise.\n+\t(HSA_SORRY_ATV): Remove semicolon after macro.\n+\t(HSA_SORRY_AT): Likewise.\n+\t(omp_simple_builtin::generate): Add missing semicolons.\n+\t(hsa_insn_phi::operator new): Removed.\n+\t(hsa_insn_br::operator new): Likewise.\n+\t(hsa_insn_cbr::operator new): Likewise.\n+\t(hsa_insn_sbr::operator new): Likewise.\n+\t(hsa_insn_cmp::operator new): Likewise.\n+\t(hsa_insn_mem::operator new): Likewise.\n+\t(hsa_insn_atomic::operator new): Likewise.\n+\t(hsa_insn_signal::operator new): Likewise.\n+\t(hsa_insn_seg::operator new): Likewise.\n+\t(hsa_insn_call::operator new): Likewise.\n+\t(hsa_insn_arg_block::operator new): Likewise.\n+\t(hsa_insn_comment::operator new): Likewise.\n+\t(hsa_insn_srctype::operator new): Likewise.\n+\t(hsa_insn_packed::operator new): Likewise.\n+\t(hsa_insn_cvt::operator new): Likewise.\n+\t(hsa_insn_alloca::operator new): Likewise.\n+\t(get_symbol_for_decl): Accept CONST_DECLs, put them to\n+\treadonly segment.\n+\t(gen_hsa_addr): Also process CONST_DECLs.\n+\t(gen_hsa_addr_insns): Process CONST_DECLs by creating private\n+\tcopies.\n+\t(gen_hsa_unary_operation): Make sure the function does\n+\tnot use bittype source type for firstbit and lastbit operations.\n+\t(gen_hsa_popcount_to_dest): Make sure the function uses a bittype\n+\tsource type.\n+\t* hsa-brig.c (emit_insn_operands): Cope with zero operands in an\n+\tinstruction.\n+\t(emit_branch_insn): Renamed to emit_cond_branch_insn.\n+\tEmit the width stored in the class.\n+\t(emit_generic_branch_insn): New function.\n+\t(emit_insn): Call emit_generic_branch_insn.\n+\t(emit_signal_insn): Remove obsolete comment.  Update\n+\tmember variable name, pick a type according to profile.\n+\t(emit_alloca_insn): Remove obsolete comment.\n+\t(emit_atomic_insn): Likewise.\n+\t(emit_queue_insn): Get segment and memory order from the IR object.\n+\t(hsa_brig_section): Make allocate_new_chunk, chunks\n+\tand cur_chunk provate, add a default NULL parameter to add method.\n+\t(hsa_brig_section::add): Added a new parameter, store pointer to\n+\toutput data there if it is non-NULL.\n+\t(emit_function_directives): Use this new parameter instead of\n+\tcalculating the pointer itself, fix function comment.\n+\t(hsa_brig_emit_function): Add forgotten endian conversion.\n+\t(hsa_output_kernels): Remove unnecessary building of\n+\tkernel_dependencies_vector_type.\n+\t(emit_immediate_operand): Declare.\n+\t(emit_directive_variable): Also emit initializers of CONST_DECLs.\n+\t(gen_hsa_insn_for_internal_fn_call): Also handle IFN_RSQRT.\n+\t(verify_function_arguments): Properly detect variadic\n+\targuments.\n+\t* hsa-dump.c (hsa_width_specifier_name): New function.\n+\t(dump_hsa_insn_1): Dump generic branch instructions, update signal\n+\tmember variable name.  Special dumping for queue objects.\n+\t* ipa-hsa.c (process_hsa_functions): Adjust after renaming\n+\tm_binded_functions to m_bound_functions.  Copy externally visible flag\n+\tto the node.\n+\t(ipa_hsa_write_summary): Likewise.\n+\t(ipa_hsa_read_section): Likewise.\n+\n 2016-11-23  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/78396"}, {"sha": "df4f64f7c284539450632ccc4c1993f41216ebc5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -911,7 +911,8 @@ RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params-enum.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n-\tgtm-builtins.def sanitizer.def cilkplus.def cilk-builtins.def\n+\tgtm-builtins.def sanitizer.def cilkplus.def cilk-builtins.def \\\n+\thsa-builtins.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_CORE_H = tree-core.h coretypes.h all-tree.def tree.def \\"}, {"sha": "6766975fdf922508c61e26c0ebdaed066b23f8aa", "filename": "gcc/builtins.def", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -201,6 +201,19 @@ along with GCC; see the file COPYING3.  If not see\n \t\t|| flag_cilkplus \\\n \t\t|| flag_offload_abi != OFFLOAD_ABI_UNSET))\n \n+#undef DEF_HSA_BUILTIN\n+#ifdef ENABLE_HSA\n+#define DEF_HSA_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\t\\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+               false, false, true, ATTRS, false, \\\n+\t       (!flag_disable_hsa))\n+#else\n+#define DEF_HSA_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\t\\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+               false, false, true, ATTRS, false, \\\n+\t       (false))\n+#endif\n+\n /* Builtin used by implementation of Cilk Plus.  Most of these are decomposed\n    by the compiler but a few are implemented in libcilkrts.  */ \n #undef DEF_CILK_BUILTIN_STUB\n@@ -968,6 +981,9 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* Offloading and Multi Processing builtins.  */\n #include \"omp-builtins.def\"\n \n+/* Heterogeneous Systems Architecture.  */\n+#include \"hsa-builtins.def\"\n+\n /* Cilk keywords builtins.  */\n #include \"cilk-builtins.def\"\n "}, {"sha": "20ca560ff4289ef532cf9e29c58bb8c3ba8694c0", "filename": "gcc/doc/optinfo.texi", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fdoc%2Foptinfo.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fdoc%2Foptinfo.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Foptinfo.texi?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -59,6 +59,9 @@ Loop optimization passes. Enabled by @option{-loop}.\n @item OPTGROUP_INLINE\n Inlining passes. Enabled by @option{-inline}.\n \n+@item OPTGROUP_OPENMP\n+OpenMP passes. Enabled by @option{-openmp}.\n+\n @item OPTGROUP_VEC\n Vectorization passes. Enabled by @option{-vec}.\n "}, {"sha": "5b23c3f77a8e97e17904c6851af122a2ec864d19", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -138,6 +138,7 @@ static const struct dump_option_value_info optgroup_options[] =\n   {\"ipa\", OPTGROUP_IPA},\n   {\"loop\", OPTGROUP_LOOP},\n   {\"inline\", OPTGROUP_INLINE},\n+  {\"openmp\", OPTGROUP_OPENMP},\n   {\"vec\", OPTGROUP_VEC},\n   {\"optall\", OPTGROUP_ALL},\n   {NULL, 0}"}, {"sha": "f366228f465a51c77808ee0a24f324e0e0fc28b7", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -98,7 +98,8 @@ enum tree_dump_index\n #define OPTGROUP_LOOP        (1 << 2)   /* Loop optimization passes */\n #define OPTGROUP_INLINE      (1 << 3)   /* Inlining passes */\n #define OPTGROUP_VEC         (1 << 4)   /* Vectorization passes */\n-#define OPTGROUP_OTHER       (1 << 5)   /* All other passes */\n+#define OPTGROUP_OPENMP      (1 << 5)\t/* OpenMP specific transformations */\n+#define OPTGROUP_OTHER       (1 << 6)   /* All other passes */\n #define OPTGROUP_ALL\t     (OPTGROUP_IPA | OPTGROUP_LOOP | OPTGROUP_INLINE \\\n                               | OPTGROUP_VEC | OPTGROUP_OTHER)\n "}, {"sha": "adeb08da896b0e53cd206609ac6e62014c82d81b", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -1,3 +1,7 @@\n+2016-11-23  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* f95-lang.c (DEF_HSA_BUILTIN): New macro.\n+\n 2016-11-22  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/78479"}, {"sha": "22d29daf08debc9edecedb6d9e0819f4ed109532", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -1224,6 +1224,17 @@ gfc_init_builtin_functions (void)\n #undef DEF_GOMP_BUILTIN\n     }\n \n+#ifdef ENABLE_HSA\n+  if (!flag_disable_hsa)\n+    {\n+#undef DEF_HSA_BUILTIN\n+#define DEF_HSA_BUILTIN(code, name, type, attr) \\\n+      gfc_define_builtin (\"__builtin_\" name, builtin_types[type], \\\n+\t\t\t  code, name, attr);\n+#include \"../hsa-builtins.def\"\n+    }\n+#endif\n+\n   gfc_define_builtin (\"__builtin_trap\", builtin_types[BT_FN_VOID],\n \t\t      BUILT_IN_TRAP, NULL, ATTR_NOTHROW_LEAF_LIST);\n   TREE_THIS_VOLATILE (builtin_decl_explicit (BUILT_IN_TRAP)) = 1;"}, {"sha": "0d0296e3f16a4503f5af86f73e1c179fcd7f0226", "filename": "gcc/gimple.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -163,7 +163,13 @@ enum gf_mask {\n     GF_OMP_FOR_KIND_CILKSIMD\t= GF_OMP_FOR_SIMD | 1,\n     GF_OMP_FOR_COMBINED\t\t= 1 << 4,\n     GF_OMP_FOR_COMBINED_INTO\t= 1 << 5,\n+    /* The following flag must not be used on GF_OMP_FOR_KIND_GRID_LOOP loop\n+       statements.  */\n     GF_OMP_FOR_GRID_PHONY\t= 1 << 6,\n+    /* The following two flags should only be set on GF_OMP_FOR_KIND_GRID_LOOP\n+       loop statements.  */\n+    GF_OMP_FOR_GRID_INTRA_GROUP\t= 1 << 6,\n+    GF_OMP_FOR_GRID_GROUP_ITER  = 1 << 7,\n     GF_OMP_TARGET_KIND_MASK\t= (1 << 4) - 1,\n     GF_OMP_TARGET_KIND_REGION\t= 0,\n     GF_OMP_TARGET_KIND_DATA\t= 1,\n@@ -5143,6 +5149,8 @@ gimple_omp_for_set_pre_body (gimple *gs, gimple_seq pre_body)\n static inline bool\n gimple_omp_for_grid_phony (const gomp_for *omp_for)\n {\n+  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n+\t\t       != GF_OMP_FOR_KIND_GRID_LOOP);\n   return (gimple_omp_subcode (omp_for) & GF_OMP_FOR_GRID_PHONY) != 0;\n }\n \n@@ -5151,12 +5159,61 @@ gimple_omp_for_grid_phony (const gomp_for *omp_for)\n static inline void\n gimple_omp_for_set_grid_phony (gomp_for *omp_for, bool value)\n {\n+  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n+\t\t       != GF_OMP_FOR_KIND_GRID_LOOP);\n   if (value)\n     omp_for->subcode |= GF_OMP_FOR_GRID_PHONY;\n   else\n     omp_for->subcode &= ~GF_OMP_FOR_GRID_PHONY;\n }\n \n+/* Return the kernel_intra_group of a GRID_LOOP OMP_FOR statement.  */\n+\n+static inline bool\n+gimple_omp_for_grid_intra_group (const gomp_for *omp_for)\n+{\n+  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n+\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n+  return (gimple_omp_subcode (omp_for) & GF_OMP_FOR_GRID_INTRA_GROUP) != 0;\n+}\n+\n+/* Set kernel_intra_group flag of OMP_FOR to VALUE.  */\n+\n+static inline void\n+gimple_omp_for_set_grid_intra_group (gomp_for *omp_for, bool value)\n+{\n+  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n+\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n+  if (value)\n+    omp_for->subcode |= GF_OMP_FOR_GRID_INTRA_GROUP;\n+  else\n+    omp_for->subcode &= ~GF_OMP_FOR_GRID_INTRA_GROUP;\n+}\n+\n+/* Return true if iterations of a grid OMP_FOR statement correspond to HSA\n+   groups.  */\n+\n+static inline bool\n+gimple_omp_for_grid_group_iter (const gomp_for *omp_for)\n+{\n+  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n+\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n+  return (gimple_omp_subcode (omp_for) & GF_OMP_FOR_GRID_GROUP_ITER) != 0;\n+}\n+\n+/* Set group_iter flag of OMP_FOR to VALUE.  */\n+\n+static inline void\n+gimple_omp_for_set_grid_group_iter (gomp_for *omp_for, bool value)\n+{\n+  gcc_checking_assert (gimple_omp_for_kind (omp_for)\n+\t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n+  if (value)\n+    omp_for->subcode |= GF_OMP_FOR_GRID_GROUP_ITER;\n+  else\n+    omp_for->subcode &= ~GF_OMP_FOR_GRID_GROUP_ITER;\n+}\n+\n /* Return the clauses associated with OMP_PARALLEL GS.  */\n \n static inline tree"}, {"sha": "acd91647cc62f8e4893bee3f2c41b00d1b7c219a", "filename": "gcc/hsa-brig.c", "status": "modified", "additions": 76, "deletions": 64, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -161,19 +161,21 @@ class hsa_brig_section\n   /* The size of the header of the section without any padding.  */\n   unsigned header_byte_delta;\n \n-  /* Buffers of binary data, each containing BRIG_CHUNK_MAX_SIZE bytes.  */\n-  vec <struct hsa_brig_data_chunk> chunks;\n-\n-  /* More convenient access to the last chunk from the vector above.  */\n-  struct hsa_brig_data_chunk *cur_chunk;\n-\n-  void allocate_new_chunk ();\n   void init (const char *name);\n   void release ();\n   void output ();\n-  unsigned add (const void *data, unsigned len);\n+  unsigned add (const void *data, unsigned len, void **output = NULL);\n   void round_size_up (int factor);\n   void *get_ptr_by_offset (unsigned int offset);\n+\n+private:\n+  void allocate_new_chunk ();\n+\n+  /* Buffers of binary data, each containing BRIG_CHUNK_MAX_SIZE bytes.  */\n+  vec <struct hsa_brig_data_chunk> chunks;\n+\n+  /* More convenient access to the last chunk from the vector above.  */\n+  struct hsa_brig_data_chunk *cur_chunk;\n };\n \n static struct hsa_brig_section brig_data, brig_code, brig_operand;\n@@ -271,18 +273,22 @@ hsa_brig_section::output ()\n }\n \n /* Add to the stream LEN bytes of opaque binary DATA.  Return the offset at\n-   which it was stored.  */\n+   which it was stored.  If OUTPUT is not NULL, store into it the pointer to\n+   the place where DATA was actually stored.  */\n \n unsigned\n-hsa_brig_section::add (const void *data, unsigned len)\n+hsa_brig_section::add (const void *data, unsigned len, void **output)\n {\n   unsigned offset = total_size;\n \n   gcc_assert (len <= BRIG_CHUNK_MAX_SIZE);\n   if (cur_chunk->size > (BRIG_CHUNK_MAX_SIZE - len))\n     allocate_new_chunk ();\n \n-  memcpy (cur_chunk->data + cur_chunk->size, data, len);\n+  char *dst = cur_chunk->data + cur_chunk->size;\n+  memcpy (dst, data, len);\n+  if (output)\n+    *output = dst;\n   cur_chunk->size += len;\n   total_size += len;\n \n@@ -565,6 +571,7 @@ enqueue_op (hsa_op_base *op)\n   return ret;\n }\n \n+static void emit_immediate_operand (hsa_op_immed *imm);\n \n /* Emit directive describing a symbol if it has not been emitted already.\n    Return the offset of the directive.  */\n@@ -603,7 +610,14 @@ emit_directive_variable (struct hsa_symbol *symbol)\n     }\n \n   dirvar.name = lendian32 (name_offset);\n-  dirvar.init = 0;\n+\n+  if (symbol->m_decl && TREE_CODE (symbol->m_decl) == CONST_DECL)\n+    {\n+      hsa_op_immed *tmp = new hsa_op_immed (DECL_INITIAL (symbol->m_decl));\n+      dirvar.init = lendian32 (enqueue_op (tmp));\n+    }\n+  else\n+    dirvar.init = 0;\n   dirvar.type = lendian16 (symbol->m_type);\n   dirvar.segment = symbol->m_segment;\n   dirvar.align = symbol->m_align;\n@@ -626,16 +640,20 @@ emit_directive_variable (struct hsa_symbol *symbol)\n   return symbol->m_directive_offset;\n }\n \n-/* Emit directives describing either a function declaration or\n-   definition F.  */\n+/* Emit directives describing either a function declaration or definition F and\n+   return the produced BrigDirectiveExecutable structure.  The function does\n+   not take into account any instructions when calculating nextModuleEntry\n+   field of the produced BrigDirectiveExecutable structure so when emitting\n+   actual definitions, this field needs to be updated after all of the function\n+   is actually added to the code section.  */\n \n static BrigDirectiveExecutable *\n emit_function_directives (hsa_function_representation *f, bool is_declaration)\n {\n   struct BrigDirectiveExecutable fndir;\n   unsigned name_offset, inarg_off, scoped_off, next_toplev_off;\n   int count = 0;\n-  BrigDirectiveExecutable *ptr_to_fndir;\n+  void *ptr_to_fndir;\n   hsa_symbol *sym;\n \n   if (!f->m_declaration_p)\n@@ -693,17 +711,7 @@ emit_function_directives (hsa_function_representation *f, bool is_declaration)\n       *slot = int_fn;\n     }\n \n-  brig_code.add (&fndir, sizeof (fndir));\n-  /* terrible hack: we need to set instCount after we emit all\n-     insns, but we need to emit directive in order, and we emit directives\n-     during insn emitting.  So we need to emit the FUNCTION directive\n-     early, then the insns, and then we need to set instCount, so remember\n-     a pointer to it, in some horrible way.  cur_chunk.data+size points\n-     directly to after fndir here.  */\n-  ptr_to_fndir\n-      = (BrigDirectiveExecutable *)(brig_code.cur_chunk->data\n-\t\t\t\t    + brig_code.cur_chunk->size\n-\t\t\t\t    - sizeof (fndir));\n+  brig_code.add (&fndir, sizeof (fndir), &ptr_to_fndir);\n \n   if (f->m_output_arg)\n     emit_directive_variable (f->m_output_arg);\n@@ -724,7 +732,7 @@ emit_function_directives (hsa_function_representation *f, bool is_declaration)\n \t}\n     }\n \n-  return ptr_to_fndir;\n+  return (BrigDirectiveExecutable *) ptr_to_fndir;\n }\n \n /* Emit a label directive for the given HBB.  We assume it is about to start on\n@@ -1237,20 +1245,20 @@ emit_insn_operands (hsa_insn_basic *insn)\n     operand_offsets;\n \n   unsigned l = insn->operand_count ();\n-  operand_offsets.safe_grow (l);\n-\n-  for (unsigned i = 0; i < l; i++)\n-    operand_offsets[i] = lendian32 (enqueue_op (insn->get_op (i)));\n \n   /* We have N operands so use 4 * N for the byte_count.  */\n   uint32_t byte_count = lendian32 (4 * l);\n-\n   unsigned offset = brig_data.add (&byte_count, sizeof (byte_count));\n-  brig_data.add (operand_offsets.address (),\n-\t\t l * sizeof (BrigOperandOffset32_t));\n+  if (l > 0)\n+    {\n+      operand_offsets.safe_grow (l);\n+      for (unsigned i = 0; i < l; i++)\n+\toperand_offsets[i] = lendian32 (enqueue_op (insn->get_op (i)));\n \n+      brig_data.add (operand_offsets.address (),\n+\t\t     l * sizeof (BrigOperandOffset32_t));\n+    }\n   brig_data.round_size_up (4);\n-\n   return offset;\n }\n \n@@ -1334,20 +1342,16 @@ emit_signal_insn (hsa_insn_signal *mem)\n {\n   struct BrigInstSignal repr;\n \n-  /* This is necessary because of the erroneous typedef of\n-     BrigMemoryModifier8_t which introduces padding which may then contain\n-     random stuff (which we do not want so that we can test things don't\n-     change).  */\n   memset (&repr, 0, sizeof (repr));\n   repr.base.base.byteCount = lendian16 (sizeof (repr));\n   repr.base.base.kind = lendian16 (BRIG_KIND_INST_SIGNAL);\n   repr.base.opcode = lendian16 (mem->m_opcode);\n   repr.base.type = lendian16 (mem->m_type);\n   repr.base.operands = lendian32 (emit_insn_operands (mem));\n \n-  repr.memoryOrder = mem->m_memoryorder;\n-  repr.signalOperation = mem->m_atomicop;\n-  repr.signalType = BRIG_TYPE_SIG64;\n+  repr.memoryOrder = mem->m_memory_order;\n+  repr.signalOperation = mem->m_signalop;\n+  repr.signalType = hsa_machine_large_p () ? BRIG_TYPE_SIG64 : BRIG_TYPE_SIG32;\n \n   brig_code.add (&repr, sizeof (repr));\n   brig_insn_count++;\n@@ -1368,10 +1372,6 @@ emit_atomic_insn (hsa_insn_atomic *mem)\n   else\n     addr = as_a <hsa_op_address *> (mem->get_op (1));\n \n-  /* This is necessary because of the erroneous typedef of\n-     BrigMemoryModifier8_t which introduces padding which may then contain\n-     random stuff (which we do not want so that we can test things don't\n-     change).  */\n   memset (&repr, 0, sizeof (repr));\n   repr.base.base.byteCount = lendian16 (sizeof (repr));\n   repr.base.base.kind = lendian16 (BRIG_KIND_INST_ATOMIC);\n@@ -1448,10 +1448,6 @@ emit_alloca_insn (hsa_insn_alloca *alloca)\n   struct BrigInstMem repr;\n   gcc_checking_assert (alloca->operand_count () == 2);\n \n-  /* This is necessary because of the erroneous typedef of\n-     BrigMemoryModifier8_t which introduces padding which may then contain\n-     random stuff (which we do not want so that we can test things don't\n-     change).  */\n   memset (&repr, 0, sizeof (repr));\n   repr.base.base.byteCount = lendian16 (sizeof (repr));\n   repr.base.base.kind = lendian16 (BRIG_KIND_INST_MEM);\n@@ -1497,11 +1493,29 @@ emit_cmp_insn (hsa_insn_cmp *cmp)\n   brig_insn_count++;\n }\n \n-/* Emit an HSA branching instruction and all necessary directives, schedule\n-   necessary operands for writing.  */\n+/* Emit an HSA generic branching/sycnronization instruction.  */\n+\n+static void\n+emit_generic_branch_insn (hsa_insn_br *br)\n+{\n+  struct BrigInstBr repr;\n+  repr.base.base.byteCount = lendian16 (sizeof (repr));\n+  repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n+  repr.base.opcode = lendian16 (br->m_opcode);\n+  repr.width = br->m_width;\n+  repr.base.type = lendian16 (br->m_type);\n+  repr.base.operands = lendian32 (emit_insn_operands (br));\n+  memset (&repr.reserved, 0, sizeof (repr.reserved));\n+\n+  brig_code.add (&repr, sizeof (repr));\n+  brig_insn_count++;\n+}\n+\n+/* Emit an HSA conditional branching instruction and all necessary directives,\n+   schedule necessary operands for writing.  */\n \n static void\n-emit_branch_insn (hsa_insn_br *br)\n+emit_cond_branch_insn (hsa_insn_cbr *br)\n {\n   struct BrigInstBr repr;\n \n@@ -1514,7 +1528,7 @@ emit_branch_insn (hsa_insn_br *br)\n   repr.base.base.byteCount = lendian16 (sizeof (repr));\n   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);\n   repr.base.opcode = lendian16 (br->m_opcode);\n-  repr.width = BRIG_WIDTH_1;\n+  repr.width = br->m_width;\n   /* For Conditional jumps the type is always B1.  */\n   repr.base.type = lendian16 (BRIG_TYPE_B1);\n \n@@ -1730,8 +1744,8 @@ emit_queue_insn (hsa_insn_queue *insn)\n   repr.base.base.kind = lendian16 (BRIG_KIND_INST_QUEUE);\n   repr.base.opcode = lendian16 (insn->m_opcode);\n   repr.base.type = lendian16 (insn->m_type);\n-  repr.segment = BRIG_SEGMENT_GLOBAL;\n-  repr.memoryOrder = BRIG_MEMORY_ORDER_SC_RELEASE;\n+  repr.segment = insn->m_segment;\n+  repr.memoryOrder = insn->m_memory_order;\n   repr.base.operands = lendian32 (emit_insn_operands (insn));\n   brig_data.round_size_up (4);\n   brig_code.add (&repr, sizeof (repr));\n@@ -1886,8 +1900,8 @@ emit_insn (hsa_insn_basic *insn)\n     emit_segment_insn (seg);\n   else if (hsa_insn_cmp *cmp = dyn_cast <hsa_insn_cmp *> (insn))\n     emit_cmp_insn (cmp);\n-  else if (hsa_insn_br *br = dyn_cast <hsa_insn_br *> (insn))\n-    emit_branch_insn (br);\n+  else if (hsa_insn_cbr *br = dyn_cast <hsa_insn_cbr *> (insn))\n+    emit_cond_branch_insn (br);\n   else if (hsa_insn_sbr *sbr = dyn_cast <hsa_insn_sbr *> (insn))\n     {\n       if (switch_instructions == NULL)\n@@ -1896,6 +1910,8 @@ emit_insn (hsa_insn_basic *insn)\n       switch_instructions->safe_push (sbr);\n       emit_switch_insn (sbr);\n     }\n+  else if (hsa_insn_br *br = dyn_cast <hsa_insn_br *> (insn))\n+    emit_generic_branch_insn (br);\n   else if (hsa_insn_arg_block *block = dyn_cast <hsa_insn_arg_block *> (insn))\n     emit_arg_block_insn (block);\n   else if (hsa_insn_call *call = dyn_cast <hsa_insn_call *> (insn))\n@@ -2006,7 +2022,7 @@ hsa_brig_emit_function (void)\n       prev_bb = bb;\n     }\n   perhaps_emit_branch (prev_bb, NULL);\n-  ptr_to_fndir->nextModuleEntry = brig_code.total_size;\n+  ptr_to_fndir->nextModuleEntry = lendian32 (brig_code.total_size);\n \n   /* Fill up label references for all sbr instructions.  */\n   if (switch_instructions)\n@@ -2225,11 +2241,6 @@ hsa_output_kernels (tree *host_func_table, tree *kernels)\n       tree gridified_kernel_p_tree = build_int_cstu (boolean_type_node,\n \t\t\t\t\t\t     gridified_kernel_p);\n       unsigned count = 0;\n-\n-      kernel_dependencies_vector_type\n-\t= build_array_type (build_pointer_type (char_type_node),\n-\t\t\t    build_index_type (size_int (0)));\n-\n       vec<constructor_elt, va_gc> *kernel_dependencies_vec = NULL;\n       if (hsa_decl_kernel_dependencies)\n \t{\n@@ -2279,6 +2290,7 @@ hsa_output_kernels (tree *host_func_table, tree *kernels)\n       if (count > 0)\n \t{\n \t  ASM_GENERATE_INTERNAL_LABEL (tmp_name, \"__hsa_dependencies_list\", i);\n+\t  gcc_checking_assert (kernel_dependencies_vector_type);\n \t  tree dependencies_list = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n \t\t\t\t\t       get_identifier (tmp_name),\n \t\t\t\t\t       kernel_dependencies_vector_type);"}, {"sha": "cc0409e6b8ab854c8e943bb86641808c32dc2f9d", "filename": "gcc/hsa-builtins.def", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-builtins.def?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -0,0 +1,39 @@\n+/* This file contains the definitions and documentation for the\n+   Offloading and Multi Processing builtins used in the GNU compiler.\n+   Copyright (C) 2005-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Before including this file, you should define a macro:\n+\n+     DEF_HSA_BUILTIN (ENUM, NAME, TYPE, ATTRS)\n+\n+   See builtins.def for details.  */\n+\n+/* The reason why they aren't in gcc/builtins.def is that the Fortran front end\n+   doesn't source those.  */\n+\n+DEF_HSA_BUILTIN (BUILT_IN_HSA_WORKGROUPID, \"hsa_workgroupid\",\n+\t  \t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_HSA_BUILTIN (BUILT_IN_HSA_WORKITEMID, \"hsa_workitemid\",\n+\t  \t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_HSA_BUILTIN (BUILT_IN_HSA_WORKITEMABSID, \"hsa_workitemabsid\",\n+\t  \t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_HSA_BUILTIN (BUILT_IN_HSA_GRIDSIZE, \"hsa_gridsize\",\n+\t\t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)\n+DEF_HSA_BUILTIN (BUILT_IN_HSA_CURRENTWORKGROUPSIZE, \"hsa_currentworkgroupsize\",\n+\t\t BT_FN_UINT_UINT, ATTR_CONST_NOTHROW_LEAF_LIST)"}, {"sha": "813218b652d6f2d2455bb76ca6520b188ab7980f", "filename": "gcc/hsa-dump.c", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-dump.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -621,6 +621,88 @@ hsa_m_atomicop_name (enum BrigAtomicOperation op)\n     }\n }\n \n+/* Return textual name for atomic operation.  */\n+\n+static const char *\n+hsa_width_specifier_name (BrigWidth8_t width)\n+{\n+  switch (width)\n+    {\n+    case BRIG_WIDTH_NONE:\n+      return \"none\";\n+    case BRIG_WIDTH_1:\n+      return \"1\";\n+    case BRIG_WIDTH_2:\n+      return \"2\";\n+    case BRIG_WIDTH_4:\n+      return \"4\";\n+    case BRIG_WIDTH_8:\n+      return \"8\";\n+    case BRIG_WIDTH_16:\n+      return \"16\";\n+    case BRIG_WIDTH_32:\n+      return \"32\";\n+    case BRIG_WIDTH_64:\n+      return \"64\";\n+    case BRIG_WIDTH_128:\n+      return \"128\";\n+    case BRIG_WIDTH_256:\n+      return \"256\";\n+    case BRIG_WIDTH_512:\n+      return \"512\";\n+    case BRIG_WIDTH_1024:\n+      return \"1024\";\n+    case BRIG_WIDTH_2048:\n+      return \"2048\";\n+    case BRIG_WIDTH_4096:\n+      return \"4096\";\n+    case BRIG_WIDTH_8192:\n+      return \"8192\";\n+    case BRIG_WIDTH_16384:\n+      return \"16384\";\n+    case BRIG_WIDTH_32768:\n+      return \"32768\";\n+    case BRIG_WIDTH_65536:\n+      return \"65536\";\n+    case BRIG_WIDTH_131072:\n+      return \"131072\";\n+    case BRIG_WIDTH_262144:\n+      return \"262144\";\n+    case BRIG_WIDTH_524288:\n+      return \"524288\";\n+    case BRIG_WIDTH_1048576:\n+      return \"1048576\";\n+    case BRIG_WIDTH_2097152:\n+      return \"2097152\";\n+    case BRIG_WIDTH_4194304:\n+      return \"4194304\";\n+    case BRIG_WIDTH_8388608:\n+      return \"8388608\";\n+    case BRIG_WIDTH_16777216:\n+      return \"16777216\";\n+    case BRIG_WIDTH_33554432:\n+      return \"33554432\";\n+    case BRIG_WIDTH_67108864:\n+      return \"67108864\";\n+    case BRIG_WIDTH_134217728:\n+      return \"134217728\";\n+    case BRIG_WIDTH_268435456:\n+      return \"268435456\";\n+    case BRIG_WIDTH_536870912:\n+      return \"536870912\";\n+    case BRIG_WIDTH_1073741824:\n+      return \"1073741824\";\n+    case BRIG_WIDTH_2147483648:\n+      return \"2147483648\";\n+    case BRIG_WIDTH_WAVESIZE:\n+      return \"wavesize\";\n+    case BRIG_WIDTH_ALL:\n+      return \"all\";\n+    default:\n+      return \"UNKNOWN_WIDTH\";\n+    }\n+}\n+\n /* Dump textual representation of HSA IL register REG to file F.  */\n \n static void\n@@ -793,9 +875,9 @@ dump_hsa_insn_1 (FILE *f, hsa_insn_basic *insn, int *indent)\n       hsa_insn_signal *mem = as_a <hsa_insn_signal *> (insn);\n \n       fprintf (f, \"%s\", hsa_opcode_name (mem->m_opcode));\n-      fprintf (f, \"_%s\", hsa_m_atomicop_name (mem->m_atomicop));\n-      if (mem->m_memoryorder != BRIG_MEMORY_ORDER_NONE)\n-\tfprintf (f, \"_%s\", hsa_memsem_name (mem->m_memoryorder));\n+      fprintf (f, \"_%s\", hsa_m_atomicop_name (mem->m_signalop));\n+      if (mem->m_memory_order != BRIG_MEMORY_ORDER_NONE)\n+\tfprintf (f, \"_%s\", hsa_memsem_name (mem->m_memory_order));\n       fprintf (f, \"_%s \", hsa_type_name (mem->m_type));\n \n       dump_hsa_operands (f, mem);\n@@ -884,9 +966,9 @@ dump_hsa_insn_1 (FILE *f, hsa_insn_basic *insn, int *indent)\n       fprintf (f, \", \");\n       dump_hsa_operand (f, cmp->get_op (2));\n     }\n-  else if (is_a <hsa_insn_br *> (insn))\n+  else if (is_a <hsa_insn_cbr *> (insn))\n     {\n-      hsa_insn_br *br = as_a <hsa_insn_br *> (insn);\n+      hsa_insn_cbr *br = as_a <hsa_insn_cbr *> (insn);\n       basic_block target = NULL;\n       edge_iterator ei;\n       edge e;\n@@ -921,6 +1003,12 @@ dump_hsa_insn_1 (FILE *f, hsa_insn_basic *insn, int *indent)\n \t    fprintf (f, \", \");\n \t}\n     }\n+  else if (is_a <hsa_insn_br *> (insn))\n+    {\n+      hsa_insn_br *br = as_a <hsa_insn_br *> (insn);\n+      fprintf (f, \"%s_width(%s) \", hsa_opcode_name (br->m_opcode),\n+\t       hsa_width_specifier_name (br->m_width));\n+    }\n   else if (is_a <hsa_insn_arg_block *> (insn))\n     {\n       hsa_insn_arg_block *arg_block = as_a <hsa_insn_arg_block *> (insn);\n@@ -1018,6 +1106,15 @@ dump_hsa_insn_1 (FILE *f, hsa_insn_basic *insn, int *indent)\n \n       dump_hsa_operands (f, insn);\n     }\n+  else if (hsa_insn_queue *qi = dyn_cast <hsa_insn_queue *> (insn))\n+    {\n+      fprintf (f, \"%s_%s_%s_%s \", hsa_opcode_name (qi->m_opcode),\n+\t       hsa_seg_name (qi->m_segment),\n+\t       hsa_memsem_name (qi->m_memory_order),\n+\t       hsa_type_name (qi->m_type));\n+\n+      dump_hsa_operands (f, qi);\n+    }\n   else\n     {\n       fprintf (f, \"%s_%s \", hsa_opcode_name (insn->m_opcode),"}, {"sha": "a88294ecd4f71a60643b54d3dd3c8b46075b2e5c", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 488, "deletions": 426, "changes": 914, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"gimple-pretty-print.h\"\n #include \"diagnostic-core.h\"\n-#include \"alloc-pool.h\"\n #include \"gimple-ssa.h\"\n #include \"tree-phinodes.h\"\n #include \"stringpool.h\"\n@@ -72,7 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n \t\t    HSA_SORRY_MSG)) \\\n       inform (location, message, __VA_ARGS__); \\\n   } \\\n-  while (false);\n+  while (false)\n \n /* Same as previous, but highlight a location.  */\n \n@@ -84,7 +83,7 @@ along with GCC; see the file COPYING3.  If not see\n \t\t    HSA_SORRY_MSG)) \\\n       inform (location, message); \\\n   } \\\n-  while (false);\n+  while (false)\n \n /* Default number of threads used by kernel dispatch.  */\n \n@@ -127,31 +126,7 @@ struct hsa_queue\n   uint64_t id;\n };\n \n-/* Alloc pools for allocating basic hsa structures such as operands,\n-   instructions and other basic entities.  */\n-static object_allocator<hsa_op_address> *hsa_allocp_operand_address;\n-static object_allocator<hsa_op_immed> *hsa_allocp_operand_immed;\n-static object_allocator<hsa_op_reg> *hsa_allocp_operand_reg;\n-static object_allocator<hsa_op_code_list> *hsa_allocp_operand_code_list;\n-static object_allocator<hsa_op_operand_list> *hsa_allocp_operand_operand_list;\n-static object_allocator<hsa_insn_basic> *hsa_allocp_inst_basic;\n-static object_allocator<hsa_insn_phi> *hsa_allocp_inst_phi;\n-static object_allocator<hsa_insn_mem> *hsa_allocp_inst_mem;\n-static object_allocator<hsa_insn_atomic> *hsa_allocp_inst_atomic;\n-static object_allocator<hsa_insn_signal> *hsa_allocp_inst_signal;\n-static object_allocator<hsa_insn_seg> *hsa_allocp_inst_seg;\n-static object_allocator<hsa_insn_cmp> *hsa_allocp_inst_cmp;\n-static object_allocator<hsa_insn_br> *hsa_allocp_inst_br;\n-static object_allocator<hsa_insn_sbr> *hsa_allocp_inst_sbr;\n-static object_allocator<hsa_insn_call> *hsa_allocp_inst_call;\n-static object_allocator<hsa_insn_arg_block> *hsa_allocp_inst_arg_block;\n-static object_allocator<hsa_insn_comment> *hsa_allocp_inst_comment;\n-static object_allocator<hsa_insn_queue> *hsa_allocp_inst_queue;\n-static object_allocator<hsa_insn_srctype> *hsa_allocp_inst_srctype;\n-static object_allocator<hsa_insn_packed> *hsa_allocp_inst_packed;\n-static object_allocator<hsa_insn_cvt> *hsa_allocp_inst_cvt;\n-static object_allocator<hsa_insn_alloca> *hsa_allocp_inst_alloca;\n-static object_allocator<hsa_bb> *hsa_allocp_bb;\n+static struct obstack hsa_obstack;\n \n /* List of pointers to all instructions that come from an object allocator.  */\n static vec <hsa_insn_basic *> hsa_instructions;\n@@ -486,52 +461,7 @@ static void\n hsa_init_data_for_cfun ()\n {\n   hsa_init_compilation_unit_data ();\n-  hsa_allocp_operand_address\n-    = new object_allocator<hsa_op_address> (\"HSA address operands\");\n-  hsa_allocp_operand_immed\n-    = new object_allocator<hsa_op_immed> (\"HSA immediate operands\");\n-  hsa_allocp_operand_reg\n-    = new object_allocator<hsa_op_reg> (\"HSA register operands\");\n-  hsa_allocp_operand_code_list\n-    = new object_allocator<hsa_op_code_list> (\"HSA code list operands\");\n-  hsa_allocp_operand_operand_list\n-    = new object_allocator<hsa_op_operand_list> (\"HSA operand list operands\");\n-  hsa_allocp_inst_basic\n-    = new object_allocator<hsa_insn_basic> (\"HSA basic instructions\");\n-  hsa_allocp_inst_phi\n-    = new object_allocator<hsa_insn_phi> (\"HSA phi operands\");\n-  hsa_allocp_inst_mem\n-    = new object_allocator<hsa_insn_mem> (\"HSA memory instructions\");\n-  hsa_allocp_inst_atomic\n-    = new object_allocator<hsa_insn_atomic> (\"HSA atomic instructions\");\n-  hsa_allocp_inst_signal\n-    = new object_allocator<hsa_insn_signal> (\"HSA signal instructions\");\n-  hsa_allocp_inst_seg\n-    = new object_allocator<hsa_insn_seg> (\"HSA segment conversion \"\n-\t\t\t\t\t  \"instructions\");\n-  hsa_allocp_inst_cmp\n-    = new object_allocator<hsa_insn_cmp> (\"HSA comparison instructions\");\n-  hsa_allocp_inst_br\n-    = new object_allocator<hsa_insn_br> (\"HSA branching instructions\");\n-  hsa_allocp_inst_sbr\n-    = new object_allocator<hsa_insn_sbr> (\"HSA switch branching instructions\");\n-  hsa_allocp_inst_call\n-    = new object_allocator<hsa_insn_call> (\"HSA call instructions\");\n-  hsa_allocp_inst_arg_block\n-    = new object_allocator<hsa_insn_arg_block> (\"HSA arg block instructions\");\n-  hsa_allocp_inst_comment\n-    = new object_allocator<hsa_insn_comment> (\"HSA comment instructions\");\n-  hsa_allocp_inst_queue\n-    = new object_allocator<hsa_insn_queue> (\"HSA queue instructions\");\n-  hsa_allocp_inst_srctype\n-    = new object_allocator<hsa_insn_srctype> (\"HSA source type instructions\");\n-  hsa_allocp_inst_packed\n-    = new object_allocator<hsa_insn_packed> (\"HSA packed instructions\");\n-  hsa_allocp_inst_cvt\n-    = new object_allocator<hsa_insn_cvt> (\"HSA convert instructions\");\n-  hsa_allocp_inst_alloca\n-    = new object_allocator<hsa_insn_alloca> (\"HSA alloca instructions\");\n-  hsa_allocp_bb = new object_allocator<hsa_bb> (\"HSA basic blocks\");\n+  gcc_obstack_init (&hsa_obstack);\n }\n \n /* Deinitialize HSA subsystem and free all allocated memory.  */\n@@ -565,29 +495,7 @@ hsa_deinit_data_for_cfun (void)\n       omp_simple_builtins = NULL;\n     }\n \n-  delete hsa_allocp_operand_address;\n-  delete hsa_allocp_operand_immed;\n-  delete hsa_allocp_operand_reg;\n-  delete hsa_allocp_operand_code_list;\n-  delete hsa_allocp_operand_operand_list;\n-  delete hsa_allocp_inst_basic;\n-  delete hsa_allocp_inst_phi;\n-  delete hsa_allocp_inst_atomic;\n-  delete hsa_allocp_inst_mem;\n-  delete hsa_allocp_inst_signal;\n-  delete hsa_allocp_inst_seg;\n-  delete hsa_allocp_inst_cmp;\n-  delete hsa_allocp_inst_br;\n-  delete hsa_allocp_inst_sbr;\n-  delete hsa_allocp_inst_call;\n-  delete hsa_allocp_inst_arg_block;\n-  delete hsa_allocp_inst_comment;\n-  delete hsa_allocp_inst_queue;\n-  delete hsa_allocp_inst_srctype;\n-  delete hsa_allocp_inst_packed;\n-  delete hsa_allocp_inst_cvt;\n-  delete hsa_allocp_inst_alloca;\n-  delete hsa_allocp_bb;\n+  obstack_free (&hsa_obstack, NULL);\n   delete hsa_cfun;\n }\n \n@@ -873,6 +781,49 @@ hsa_needs_cvt (BrigType16_t dtype, BrigType16_t stype)\n   return false;\n }\n \n+/* Return declaration name if it exists or create one from UID if it does not.\n+   If DECL is a local variable, make UID part of its name.  */\n+\n+const char *\n+hsa_get_declaration_name (tree decl)\n+{\n+  if (!DECL_NAME (decl))\n+    {\n+      char buf[64];\n+      snprintf (buf, 64, \"__hsa_anon_%u\", DECL_UID (decl));\n+      size_t len = strlen (buf);\n+      char *copy = (char *) obstack_alloc (&hsa_obstack, len + 1);\n+      memcpy (copy, buf, len + 1);\n+      return copy;\n+    }\n+\n+  tree name_tree;\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      || (TREE_CODE (decl) == VAR_DECL && is_global_var (decl)))\n+    name_tree = DECL_ASSEMBLER_NAME (decl);\n+  else\n+    name_tree = DECL_NAME (decl);\n+\n+  const char *name = IDENTIFIER_POINTER (name_tree);\n+  /* User-defined assembly names have prepended asterisk symbol.  */\n+  if (name[0] == '*')\n+    name++;\n+\n+  if ((TREE_CODE (decl) == VAR_DECL)\n+      && decl_function_context (decl))\n+    {\n+      size_t len = strlen (name);\n+      char *buf = (char *) alloca (len + 32);\n+      snprintf (buf, len + 32, \"%s_%u\", name, DECL_UID (decl));\n+      len = strlen (buf);\n+      char *copy = (char *) obstack_alloc (&hsa_obstack, len + 1);\n+      memcpy (copy, buf, len + 1);\n+      return copy;\n+    }\n+  else\n+    return name;\n+}\n+\n /* Lookup or create the associated hsa_symbol structure with a given VAR_DECL\n    or lookup the hsa_structure corresponding to a PARM_DECL.  */\n \n@@ -884,11 +835,13 @@ get_symbol_for_decl (tree decl)\n \n   gcc_assert (TREE_CODE (decl) == PARM_DECL\n \t      || TREE_CODE (decl) == RESULT_DECL\n-\t      || VAR_P (decl));\n+\t      || TREE_CODE (decl) == VAR_DECL\n+\t      || TREE_CODE (decl) == CONST_DECL);\n \n   dummy.m_decl = decl;\n \n-  bool is_in_global_vars = VAR_P (decl) && is_global_var (decl);\n+  bool is_in_global_vars = ((TREE_CODE (decl) == VAR_DECL)\n+\t\t\t    && !decl_function_context (decl));\n \n   if (is_in_global_vars)\n     slot = hsa_global_variable_symbols->find_slot (&dummy, INSERT);\n@@ -925,11 +878,14 @@ get_symbol_for_decl (tree decl)\n   else\n     {\n       hsa_symbol *sym;\n-      gcc_assert (VAR_P (decl));\n+      /* PARM_DECLs and RESULT_DECL should be already in m_local_symbols.  */\n+      gcc_assert (TREE_CODE (decl) == VAR_DECL\n+\t\t  || TREE_CODE (decl) == CONST_DECL);\n       BrigAlignment8_t align = hsa_object_alignment (decl);\n \n       if (is_in_global_vars)\n \t{\n+\t  gcc_checking_assert (TREE_CODE (decl) != CONST_DECL);\n \t  sym = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_GLOBAL,\n \t\t\t\tBRIG_LINKAGE_PROGRAM, true,\n \t\t\t\tBRIG_ALLOCATION_PROGRAM, align);\n@@ -951,12 +907,25 @@ get_symbol_for_decl (tree decl)\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (decl)))\n \t    align = MAX ((BrigAlignment8_t) BRIG_ALIGNMENT_8, align);\n \n-\t  /* PARM_DECL and RESULT_DECL should be already in m_local_symbols.  */\n-\t  gcc_assert (VAR_P (decl));\n+\t  BrigAllocation allocation = BRIG_ALLOCATION_AUTOMATIC;\n+\t  BrigSegment8_t segment;\n+\t  if (TREE_CODE (decl) == CONST_DECL)\n+\t    {\n+\t      segment = BRIG_SEGMENT_READONLY;\n+\t      allocation = BRIG_ALLOCATION_AGENT;\n+\t    }\n+\t  else if (lookup_attribute (\"hsa_group_segment\",\n+\t\t\t\t     DECL_ATTRIBUTES (decl)))\n+\t    segment = BRIG_SEGMENT_GROUP;\n+\t  else if (TREE_STATIC (decl)\n+\t\t   || lookup_attribute (\"hsa_global_segment\",\n+\t\t\t\t\tDECL_ATTRIBUTES (decl)))\n+\t    segment = BRIG_SEGMENT_GLOBAL;\n+\t  else\n+\t    segment = BRIG_SEGMENT_PRIVATE;\n \n-\t  sym = new hsa_symbol (BRIG_TYPE_NONE, BRIG_SEGMENT_PRIVATE,\n-\t\t\t\tBRIG_LINKAGE_FUNCTION);\n-\t  sym->m_align = align;\n+\t  sym = new hsa_symbol (BRIG_TYPE_NONE, segment, BRIG_LINKAGE_FUNCTION,\n+\t\t\t\tfalse, allocation, align);\n \t  sym->fillup_for_decl (decl);\n \t  hsa_cfun->m_private_variables.safe_push (sym);\n \t}\n@@ -978,7 +947,7 @@ hsa_get_host_function (tree decl)\n   gcc_assert (s->m_kind != HSA_NONE);\n   gcc_assert (s->m_gpu_implementation_p);\n \n-  return s->m_binded_function->decl;\n+  return s->m_bound_function ? s->m_bound_function->decl : NULL;\n }\n \n /* Return true if function DECL has a host equivalent function.  */\n@@ -989,8 +958,10 @@ get_brig_function_name (tree decl)\n   tree d = decl;\n \n   hsa_function_summary *s = hsa_summaries->get (cgraph_node::get_create (d));\n-  if (s->m_kind != HSA_NONE && s->m_gpu_implementation_p)\n-    d = s->m_binded_function->decl;\n+  if (s->m_kind != HSA_NONE\n+      && s->m_gpu_implementation_p\n+      && s->m_bound_function)\n+    d = s->m_bound_function->decl;\n \n   /* IPA split can create a function that has no host equivalent.  */\n   if (d == NULL)\n@@ -1066,6 +1037,14 @@ hsa_op_with_type::get_in_type (BrigType16_t dtype, hsa_bb *hbb)\n       dest = new hsa_op_reg (dtype);\n       hbb->append_insn (new hsa_insn_cvt (dest, this));\n     }\n+  else if (is_a <hsa_op_reg *> (this))\n+    {\n+      /* In the end, HSA registers do not really have types, only sizes, so if\n+\t the sizes match, we can use the register directly.  */\n+      gcc_checking_assert (hsa_type_bit_size (dtype)\n+\t\t\t   == hsa_type_bit_size (m_type));\n+      return this;\n+    }\n   else\n     {\n       dest = new hsa_op_reg (m_type);\n@@ -1128,12 +1107,12 @@ hsa_op_immed::hsa_op_immed ()\n {\n }\n \n-/* New operator to allocate immediate operands from pool alloc.  */\n+/* New operator to allocate immediate operands from obstack.  */\n \n void *\n-hsa_op_immed::operator new (size_t)\n+hsa_op_immed::operator new (size_t size)\n {\n-  return hsa_allocp_operand_immed->allocate_raw ();\n+  return obstack_alloc (&hsa_obstack, size);\n }\n \n /* Destructor.  */\n@@ -1160,12 +1139,12 @@ hsa_op_reg::hsa_op_reg (BrigType16_t t)\n {\n }\n \n-/* New operator to allocate a register from pool alloc.  */\n+/* New operator to allocate a register from obstack.  */\n \n void *\n-hsa_op_reg::operator new (size_t)\n+hsa_op_reg::operator new (size_t size)\n {\n-  return hsa_allocp_operand_reg->allocate_raw ();\n+  return obstack_alloc (&hsa_obstack, size);\n }\n \n /* Verify register operand.  */\n@@ -1244,12 +1223,12 @@ hsa_op_address::hsa_op_address (hsa_op_reg *r, HOST_WIDE_INT offset)\n {\n }\n \n-/* New operator to allocate address operands from pool alloc.  */\n+/* New operator to allocate address operands from obstack.  */\n \n void *\n-hsa_op_address::operator new (size_t)\n+hsa_op_address::operator new (size_t size)\n {\n-  return hsa_allocp_operand_address->allocate_raw ();\n+  return obstack_alloc (&hsa_obstack, size);\n }\n \n /* Constructor of an operand referring to HSAIL code.  */\n@@ -1269,12 +1248,12 @@ hsa_op_code_list::hsa_op_code_list (unsigned elements)\n   m_offsets.safe_grow_cleared (elements);\n }\n \n-/* New operator to allocate code list operands from pool alloc.  */\n+/* New operator to allocate code list operands from obstack.  */\n \n void *\n-hsa_op_code_list::operator new (size_t)\n+hsa_op_code_list::operator new (size_t size)\n {\n-  return hsa_allocp_operand_code_list->allocate_raw ();\n+  return obstack_alloc (&hsa_obstack, size);\n }\n \n /* Constructor of an operand representing an operand list.\n@@ -1287,12 +1266,12 @@ hsa_op_operand_list::hsa_op_operand_list (unsigned elements)\n   m_offsets.safe_grow (elements);\n }\n \n-/* New operator to allocate operand list operands from pool alloc.  */\n+/* New operator to allocate operand list operands from obstack.  */\n \n void *\n-hsa_op_operand_list::operator new (size_t)\n+hsa_op_operand_list::operator new (size_t size)\n {\n-  return hsa_allocp_operand_operand_list->allocate_raw ();\n+  return obstack_alloc (&hsa_obstack, size);\n }\n \n hsa_op_operand_list::~hsa_op_operand_list ()\n@@ -1437,12 +1416,12 @@ hsa_insn_basic::hsa_insn_basic (unsigned nops, int opc, BrigType16_t t,\n   hsa_instructions.safe_push (this);\n }\n \n-/* New operator to allocate basic instruction from pool alloc.  */\n+/* New operator to allocate basic instruction from obstack.  */\n \n void *\n-hsa_insn_basic::operator new (size_t)\n+hsa_insn_basic::operator new (size_t size)\n {\n-  return hsa_allocp_inst_basic->allocate_raw ();\n+  return obstack_alloc (&hsa_obstack, size);\n }\n \n /* Verify the instruction.  */\n@@ -1495,32 +1474,27 @@ hsa_insn_phi::hsa_insn_phi (unsigned nops, hsa_op_reg *dst)\n   dst->set_definition (this);\n }\n \n-/* New operator to allocate PHI instruction from pool alloc.  */\n+/* Constructor of class representing instructions for control flow and\n+   sychronization,   */\n \n-void *\n-hsa_insn_phi::operator new (size_t)\n+hsa_insn_br::hsa_insn_br (unsigned nops, int opc, BrigType16_t t,\n+\t\t\t  BrigWidth8_t width, hsa_op_base *arg0,\n+\t\t\t  hsa_op_base *arg1, hsa_op_base *arg2,\n+\t\t\t  hsa_op_base *arg3)\n+  : hsa_insn_basic (nops, opc, t, arg0, arg1, arg2, arg3),\n+    m_width (width)\n {\n-  return hsa_allocp_inst_phi->allocate_raw ();\n }\n \n /* Constructor of class representing instruction for conditional jump, CTRL is\n    the control register determining whether the jump will be carried out, the\n    new instruction is automatically added to its uses list.  */\n \n-hsa_insn_br::hsa_insn_br (hsa_op_reg *ctrl)\n-  : hsa_insn_basic (1, BRIG_OPCODE_CBR, BRIG_TYPE_B1, ctrl),\n-    m_width (BRIG_WIDTH_1)\n+hsa_insn_cbr::hsa_insn_cbr (hsa_op_reg *ctrl)\n+  : hsa_insn_br (1, BRIG_OPCODE_CBR, BRIG_TYPE_B1, BRIG_WIDTH_1, ctrl)\n {\n }\n \n-/* New operator to allocate branch instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_br::operator new (size_t)\n-{\n-  return hsa_allocp_inst_br->allocate_raw ();\n-}\n-\n /* Constructor of class representing instruction for switch jump, CTRL is\n    the index register.  */\n \n@@ -1531,14 +1505,6 @@ hsa_insn_sbr::hsa_insn_sbr (hsa_op_reg *index, unsigned jump_count)\n {\n }\n \n-/* New operator to allocate switch branch instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_sbr::operator new (size_t)\n-{\n-  return hsa_allocp_inst_sbr->allocate_raw ();\n-}\n-\n /* Replace all occurrences of OLD_BB with NEW_BB in the statements\n    jump table.  */\n \n@@ -1565,14 +1531,6 @@ hsa_insn_cmp::hsa_insn_cmp (BrigCompareOperation8_t cmp, BrigType16_t t,\n {\n }\n \n-/* New operator to allocate compare instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_cmp::operator new (size_t)\n-{\n-  return hsa_allocp_inst_cmp->allocate_raw ();\n-}\n-\n /* Constructor of classes representing memory accesses.  OPC is the opcode (must\n    be BRIG_OPCODE_ST or BRIG_OPCODE_LD) and T is the type.  The instruction\n    operands are provided as ARG0 and ARG1.  */\n@@ -1598,18 +1556,9 @@ hsa_insn_mem::hsa_insn_mem (unsigned nops, int opc, BrigType16_t t,\n {\n }\n \n-/* New operator to allocate memory instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_mem::operator new (size_t)\n-{\n-  return hsa_allocp_inst_mem->allocate_raw ();\n-}\n-\n-/* Constructor of class representing atomic instructions and signals.  OPC is\n-   the principal opcode, aop is the specific atomic operation opcode.  T is the\n-   type of the instruction.  The instruction operands\n-   are provided as ARG[0-3].  */\n+/* Constructor of class representing atomic instructions.  OPC is the principal\n+   opcode, AOP is the specific atomic operation opcode.  T is the type of the\n+   instruction.  The instruction operands are provided as ARG[0-3].  */\n \n hsa_insn_atomic::hsa_insn_atomic (int nops, int opc,\n \t\t\t\t  enum BrigAtomicOperation aop,\n@@ -1627,34 +1576,18 @@ hsa_insn_atomic::hsa_insn_atomic (int nops, int opc,\n \t\t       opc == BRIG_OPCODE_SIGNALNORET);\n }\n \n-/* New operator to allocate signal instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_atomic::operator new (size_t)\n-{\n-  return hsa_allocp_inst_atomic->allocate_raw ();\n-}\n-\n /* Constructor of class representing signal instructions.  OPC is the prinicpal\n-   opcode, sop is the specific signal operation opcode.  T is the type of the\n+   opcode, SOP is the specific signal operation opcode.  T is the type of the\n    instruction.  The instruction operands are provided as ARG[0-3].  */\n \n hsa_insn_signal::hsa_insn_signal (int nops, int opc,\n \t\t\t\t  enum BrigAtomicOperation sop,\n-\t\t\t\t  BrigType16_t t, hsa_op_base *arg0,\n-\t\t\t\t  hsa_op_base *arg1, hsa_op_base *arg2,\n-\t\t\t\t  hsa_op_base *arg3)\n-  : hsa_insn_atomic (nops, opc, sop, t, BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE,\n-\t\t     arg0, arg1, arg2, arg3)\n-{\n-}\n-\n-/* New operator to allocate signal instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_signal::operator new (size_t)\n+\t\t\t\t  BrigType16_t t, BrigMemoryOrder memorder,\n+\t\t\t\t  hsa_op_base *arg0, hsa_op_base *arg1,\n+\t\t\t\t  hsa_op_base *arg2, hsa_op_base *arg3)\n+  : hsa_insn_basic (nops, opc, t, arg0, arg1, arg2, arg3),\n+    m_memory_order (memorder), m_signalop (sop)\n {\n-  return hsa_allocp_inst_signal->allocate_raw ();\n }\n \n /* Constructor of class representing segment conversion instructions.  OPC is\n@@ -1672,14 +1605,6 @@ hsa_insn_seg::hsa_insn_seg (int opc, BrigType16_t dest, BrigType16_t srct,\n   gcc_checking_assert (opc == BRIG_OPCODE_STOF || opc == BRIG_OPCODE_FTOS);\n }\n \n-/* New operator to allocate address conversion instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_seg::operator new (size_t)\n-{\n-  return hsa_allocp_inst_seg->allocate_raw ();\n-}\n-\n /* Constructor of class representing a call instruction.  CALLEE is the tree\n    representation of the function being called.  */\n \n@@ -1696,14 +1621,6 @@ hsa_insn_call::hsa_insn_call (hsa_internal_fn *fn)\n {\n }\n \n-/* New operator to allocate call instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_call::operator new (size_t)\n-{\n-  return hsa_allocp_inst_call->allocate_raw ();\n-}\n-\n hsa_insn_call::~hsa_insn_call ()\n {\n   for (unsigned i = 0; i < m_input_args.length (); i++)\n@@ -1724,14 +1641,6 @@ hsa_insn_arg_block::hsa_insn_arg_block (BrigKind brig_kind,\n {\n }\n \n-/* New operator to allocate argument block instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_arg_block::operator new (size_t)\n-{\n-  return hsa_allocp_inst_arg_block->allocate_raw ();\n-}\n-\n hsa_insn_comment::hsa_insn_comment (const char *s)\n   : hsa_insn_basic (0, BRIG_KIND_DIRECTIVE_COMMENT)\n {\n@@ -1743,14 +1652,6 @@ hsa_insn_comment::hsa_insn_comment (const char *s)\n   m_comment = buf;\n }\n \n-/* New operator to allocate comment instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_comment::operator new (size_t)\n-{\n-  return hsa_allocp_inst_comment->allocate_raw ();\n-}\n-\n hsa_insn_comment::~hsa_insn_comment ()\n {\n   gcc_checking_assert (m_comment);\n@@ -1759,17 +1660,14 @@ hsa_insn_comment::~hsa_insn_comment ()\n }\n \n /* Constructor of class representing the queue instruction in HSAIL.  */\n-hsa_insn_queue::hsa_insn_queue (int nops, BrigOpcode opcode)\n-  : hsa_insn_basic (nops, opcode, BRIG_TYPE_U64)\n-{\n-}\n \n-/* New operator to allocate source type instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_srctype::operator new (size_t)\n+hsa_insn_queue::hsa_insn_queue (int nops, int opcode, BrigSegment segment,\n+\t\t\t\tBrigMemoryOrder memory_order,\n+\t\t\t\thsa_op_base *arg0, hsa_op_base *arg1,\n+\t\t\t\thsa_op_base *arg2, hsa_op_base *arg3)\n+  : hsa_insn_basic (nops, opcode, BRIG_TYPE_U64, arg0, arg1, arg2, arg3),\n+    m_segment (segment), m_memory_order (memory_order)\n {\n-  return hsa_allocp_inst_srctype->allocate_raw ();\n }\n \n /* Constructor of class representing the source type instruction in HSAIL.  */\n@@ -1782,14 +1680,6 @@ hsa_insn_srctype::hsa_insn_srctype (int nops, BrigOpcode opcode,\n     m_source_type (srct)\n {}\n \n-/* New operator to allocate packed instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_packed::operator new (size_t)\n-{\n-  return hsa_allocp_inst_packed->allocate_raw ();\n-}\n-\n /* Constructor of class representing the packed instruction in HSAIL.  */\n \n hsa_insn_packed::hsa_insn_packed (int nops, BrigOpcode opcode,\n@@ -1801,29 +1691,13 @@ hsa_insn_packed::hsa_insn_packed (int nops, BrigOpcode opcode,\n   m_operand_list = new hsa_op_operand_list (nops - 1);\n }\n \n-/* New operator to allocate convert instruction from pool alloc.  */\n-\n-void *\n-hsa_insn_cvt::operator new (size_t)\n-{\n-  return hsa_allocp_inst_cvt->allocate_raw ();\n-}\n-\n /* Constructor of class representing the convert instruction in HSAIL.  */\n \n hsa_insn_cvt::hsa_insn_cvt (hsa_op_with_type *dest, hsa_op_with_type *src)\n   : hsa_insn_basic (2, BRIG_OPCODE_CVT, dest->m_type, dest, src)\n {\n }\n \n-/* New operator to allocate alloca from pool alloc.  */\n-\n-void *\n-hsa_insn_alloca::operator new (size_t)\n-{\n-  return hsa_allocp_inst_alloca->allocate_raw ();\n-}\n-\n /* Constructor of class representing the alloca in HSAIL.  */\n \n hsa_insn_alloca::hsa_insn_alloca (hsa_op_with_type *dest,\n@@ -1854,6 +1728,20 @@ hsa_bb::append_insn (hsa_insn_basic *insn)\n     m_first_insn = insn;\n }\n \n+void\n+hsa_bb::append_phi (hsa_insn_phi *hphi)\n+{\n+  hphi->m_bb = m_bb;\n+\n+  hphi->m_prev = m_last_phi;\n+  hphi->m_next = NULL;\n+  if (m_last_phi)\n+    m_last_phi->m_next = hphi;\n+  m_last_phi = hphi;\n+  if (!m_first_phi)\n+    m_first_phi = hphi;\n+}\n+\n /* Insert HSA instruction NEW_INSN immediately before an existing instruction\n    OLD_INSN.  */\n \n@@ -2078,6 +1966,7 @@ gen_hsa_addr (tree ref, hsa_bb *hbb, HOST_WIDE_INT *output_bitsize = NULL,\n     case PARM_DECL:\n     case VAR_DECL:\n     case RESULT_DECL:\n+    case CONST_DECL:\n       gcc_assert (!symbol);\n       symbol = get_symbol_for_decl (ref);\n       addrtype = hsa_get_segment_addr_type (symbol->m_segment);\n@@ -2295,6 +2184,34 @@ gen_hsa_addr_insns (tree val, hsa_op_reg *dest, hsa_bb *hbb)\n     val = TREE_OPERAND (val, 0);\n   addr = gen_hsa_addr (val, hbb);\n \n+  if (TREE_CODE (val) == CONST_DECL\n+      && is_gimple_reg_type (TREE_TYPE (val)))\n+    {\n+      gcc_assert (addr->m_symbol\n+\t\t  && addr->m_symbol->m_segment == BRIG_SEGMENT_READONLY);\n+      /* CONST_DECLs are in readonly segment which however does not have\n+\t addresses convertible to flat segments.  So copy it to a private one\n+\t and take address of that.  */\n+      BrigType16_t csttype\n+\t= mem_type_for_type (hsa_type_for_scalar_tree_type (TREE_TYPE (val),\n+\t\t\t\t\t\t\t    false));\n+      hsa_op_reg *r = new hsa_op_reg (csttype);\n+      hbb->append_insn (new hsa_insn_mem (BRIG_OPCODE_LD, csttype, r,\n+\t\t\t\t\t  new hsa_op_address (addr->m_symbol)));\n+      hsa_symbol *copysym = hsa_cfun->create_hsa_temporary (csttype);\n+      hbb->append_insn (new hsa_insn_mem (BRIG_OPCODE_ST, csttype, r,\n+\t\t\t\t\t  new hsa_op_address (copysym)));\n+      addr->m_symbol = copysym;\n+    }\n+  else if (addr->m_symbol && addr->m_symbol->m_segment == BRIG_SEGMENT_READONLY)\n+    {\n+      HSA_SORRY_ATV (EXPR_LOCATION (val), \"support for HSA does \"\n+\t\t     \"not implement taking addresses of complex \"\n+\t\t     \"CONST_DECLs such as %E\", val);\n+      return;\n+    }\n+\n+\n   convert_addr_to_flat_segment (addr, dest, hbb);\n }\n \n@@ -2324,8 +2241,10 @@ hsa_reg_or_immed_for_gimple_op (tree op, hsa_bb *hbb)\n void\n hsa_build_append_simple_mov (hsa_op_reg *dest, hsa_op_base *src, hsa_bb *hbb)\n {\n-  hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type,\n-\t\t\t\t\t     dest, src);\n+  /* Moves of packed data between registers need to adhere to the same type\n+     rules like when dealing with memory.  */\n+  BrigType16_t tp = mem_type_for_type (dest->m_type);\n+  hsa_insn_basic *insn = new hsa_insn_basic (2, BRIG_OPCODE_MOV, tp, dest, src);\n   if (hsa_op_reg *sreg = dyn_cast <hsa_op_reg *> (src))\n     gcc_assert (hsa_type_bit_size (dest->m_type)\n \t\t== hsa_type_bit_size (sreg->m_type));\n@@ -3054,8 +2973,12 @@ gen_hsa_unary_operation (BrigOpcode opcode, hsa_op_reg *dest,\n   if (opcode == BRIG_OPCODE_MOV && hsa_needs_cvt (dest->m_type, op1->m_type))\n     insn = new hsa_insn_cvt (dest, op1);\n   else if (opcode == BRIG_OPCODE_FIRSTBIT || opcode == BRIG_OPCODE_LASTBIT)\n-    insn = new hsa_insn_srctype (2, opcode, BRIG_TYPE_U32, op1->m_type, NULL,\n-\t\t\t\t op1);\n+    {\n+      BrigType16_t srctype = hsa_type_integer_p (op1->m_type) ? op1->m_type\n+\t: hsa_unsigned_type_for_type (op1->m_type);\n+      insn = new hsa_insn_srctype (2, opcode, BRIG_TYPE_U32, srctype, NULL,\n+\t\t\t\t   op1);\n+    }\n   else\n     {\n       insn = new hsa_insn_basic (2, opcode, dest->m_type, dest, op1);\n@@ -3169,6 +3092,23 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n     case NEGATE_EXPR:\n       opcode = BRIG_OPCODE_NEG;\n       break;\n+    case FMA_EXPR:\n+      /* There is a native HSA instruction for scalar FMAs but not for vector\n+\t ones.  */\n+      if (TREE_CODE (TREE_TYPE (lhs)) == VECTOR_TYPE)\n+\t{\n+\t  hsa_op_reg *dest\n+\t    = hsa_cfun->reg_for_gimple_ssa (gimple_assign_lhs (assign));\n+\t  hsa_op_with_type *op1 = hsa_reg_or_immed_for_gimple_op (rhs1, hbb);\n+\t  hsa_op_with_type *op2 = hsa_reg_or_immed_for_gimple_op (rhs2, hbb);\n+\t  hsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n+\t  hsa_op_reg *tmp = new hsa_op_reg (dest->m_type);\n+\t  gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp, op1, op2, hbb);\n+\t  gen_hsa_binary_operation (BRIG_OPCODE_ADD, dest, tmp, op3, hbb);\n+\t  return;\n+\t}\n+      opcode = BRIG_OPCODE_MAD;\n+      break;\n     case MIN_EXPR:\n       opcode = BRIG_OPCODE_MIN;\n       break;\n@@ -3368,14 +3308,18 @@ gen_hsa_insns_for_operation_assignment (gimple *assign, hsa_bb *hbb)\n   switch (rhs_class)\n     {\n     case GIMPLE_TERNARY_RHS:\n-      gcc_unreachable ();\n+      {\n+\thsa_op_with_type *op3 = hsa_reg_or_immed_for_gimple_op (rhs3, hbb);\n+\thsa_insn_basic *insn = new hsa_insn_basic (4, opcode, dest->m_type, dest,\n+\t\t\t\t\t\t   op1, op2, op3);\n+\thbb->append_insn (insn);\n+      }\n       return;\n \n-      /* Fall through */\n     case GIMPLE_BINARY_RHS:\n       gen_hsa_binary_operation (opcode, dest, op1, op2, hbb);\n       break;\n-      /* Fall through */\n+\n     case GIMPLE_UNARY_RHS:\n       gen_hsa_unary_operation (opcode, dest, op1, hbb);\n       break;\n@@ -3392,14 +3336,14 @@ static void\n gen_hsa_insns_for_cond_stmt (gimple *cond, hsa_bb *hbb)\n {\n   hsa_op_reg *ctrl = new hsa_op_reg (BRIG_TYPE_B1);\n-  hsa_insn_br *cbr;\n+  hsa_insn_cbr *cbr;\n \n   gen_hsa_cmp_insn_from_gimple (gimple_cond_code (cond),\n \t\t\t\tgimple_cond_lhs (cond),\n \t\t\t\tgimple_cond_rhs (cond),\n \t\t\t\tctrl, hbb);\n \n-  cbr = new hsa_insn_br (ctrl);\n+  cbr = new hsa_insn_cbr (ctrl);\n   hbb->append_insn (cbr);\n }\n \n@@ -3476,7 +3420,7 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n   hbb->append_insn (new hsa_insn_basic (3, BRIG_OPCODE_AND, cmp_reg->m_type,\n \t\t\t\t\tcmp_reg, cmp1_reg, cmp2_reg));\n \n-  hbb->append_insn (new hsa_insn_br (cmp_reg));\n+  hbb->append_insn (new hsa_insn_cbr (cmp_reg));\n \n   tree default_label = gimple_switch_default_label (s);\n   basic_block default_label_bb = label_to_block_fn (func,\n@@ -3537,13 +3481,14 @@ gen_hsa_insns_for_switch_stmt (gswitch *s, hsa_bb *hbb)\n static void\n verify_function_arguments (tree decl)\n {\n+  tree type = TREE_TYPE (decl);\n   if (DECL_STATIC_CHAIN (decl))\n     {\n       HSA_SORRY_ATV (EXPR_LOCATION (decl),\n \t\t     \"HSA does not support nested functions: %D\", decl);\n       return;\n     }\n-  else if (!TYPE_ARG_TYPES (TREE_TYPE (decl)))\n+  else if (!TYPE_ARG_TYPES (type) || stdarg_p (type))\n     {\n       HSA_SORRY_ATV (EXPR_LOCATION (decl),\n \t\t     \"HSA does not support functions with variadic arguments \"\n@@ -3839,33 +3784,58 @@ hsa_insn_basic::set_output_in_type (hsa_op_reg *dest, unsigned op_index,\n    HBB.  */\n \n static void\n-query_hsa_grid (hsa_op_reg *dest, BrigType16_t opcode, int dimension,\n-\t\thsa_bb *hbb)\n+query_hsa_grid_dim (hsa_op_reg *dest, int opcode, hsa_op_immed *dimension,\n+\t\t    hsa_bb *hbb)\n {\n-  /* We're using just one-dimensional kernels, so hard-coded\n-     dimension X.  */\n-  hsa_op_immed *imm\n-    = new hsa_op_immed (dimension, (BrigKind16_t) BRIG_TYPE_U32);\n   hsa_insn_basic *insn = new hsa_insn_basic (2, opcode, BRIG_TYPE_U32, NULL,\n-\t\t\t\t\t     imm);\n+\t\t\t\t\t     dimension);\n   hbb->append_insn (insn);\n   insn->set_output_in_type (dest, 0, hbb);\n }\n \n-/* Generate a special HSA-related instruction for gimple STMT.\n-   Instructions are appended to basic block HBB.  */\n+/* Generate instruction OPCODE to query a property of HSA grid along the given\n+   dimension which is an immediate in first argument of STMT.  Store result\n+   into the register corresponding to LHS of STMT and append the instruction to\n+   HBB.  */\n \n static void\n-query_hsa_grid (gimple *stmt, BrigOpcode16_t opcode, int dimension,\n-\t\thsa_bb *hbb)\n+query_hsa_grid_dim (gimple *stmt, int opcode, hsa_bb *hbb)\n {\n   tree lhs = gimple_call_lhs (dyn_cast <gcall *> (stmt));\n   if (lhs == NULL_TREE)\n     return;\n \n+  tree arg = gimple_call_arg (stmt, 0);\n+  unsigned HOST_WIDE_INT dim = 5;\n+  if (tree_fits_uhwi_p (arg))\n+    dim = tree_to_uhwi (arg);\n+  if (dim > 2)\n+    {\n+      HSA_SORRY_AT (gimple_location (stmt),\n+\t\t    \"HSA grid query dimension must be immediate constant 0, 1 \"\n+\t\t    \"or 2\");\n+      return;\n+    }\n+\n+  hsa_op_immed *hdim = new hsa_op_immed (dim, (BrigKind16_t) BRIG_TYPE_U32);\n   hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n+  query_hsa_grid_dim (dest, opcode, hdim, hbb);\n+}\n+\n+/* Generate instruction OPCODE to query a property of HSA grid that is\n+   independent of any dimension.  Store result into the register corresponding\n+   to LHS of STMT and append the instruction to HBB.  */\n \n-  query_hsa_grid (dest, opcode, dimension, hbb);\n+static void\n+query_hsa_grid_nodim (gimple *stmt, BrigOpcode16_t opcode, hsa_bb *hbb)\n+{\n+  tree lhs = gimple_call_lhs (dyn_cast <gcall *> (stmt));\n+  if (lhs == NULL_TREE)\n+    return;\n+  hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n+  BrigType16_t brig_type = hsa_unsigned_type_for_type (dest->m_type);\n+  hsa_insn_basic *insn = new hsa_insn_basic (1, opcode, brig_type, dest);\n+  hbb->append_insn (insn);\n }\n \n /* Emit instructions that set hsa_num_threads according to provided VALUE.\n@@ -4012,6 +3982,44 @@ gen_num_threads_for_dispatch (hsa_bb *hbb)\n   return as_a <hsa_op_reg *> (dest);\n }\n \n+/* Build OPCODE query for all three hsa dimensions, multiply them and store the\n+   result into DEST.  */\n+\n+static void\n+multiply_grid_dim_characteristics (hsa_op_reg *dest, int opcode, hsa_bb *hbb)\n+{\n+  hsa_op_reg *dimx = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (dimx, opcode,\n+\t\t      new hsa_op_immed (0, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+  hsa_op_reg *dimy = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (dimy, opcode,\n+\t\t      new hsa_op_immed (1, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+  hsa_op_reg *dimz = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (dimz, opcode,\n+\t\t      new hsa_op_immed (2, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+  hsa_op_reg *tmp = new hsa_op_reg (dest->m_type);\n+  gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp,\n+\t\t\t    dimx->get_in_type (dest->m_type, hbb),\n+\t\t\t    dimy->get_in_type (dest->m_type, hbb), hbb);\n+  gen_hsa_binary_operation (BRIG_OPCODE_MUL, dest, tmp,\n+\t\t\t    dimz->get_in_type (dest->m_type, hbb), hbb);\n+}\n+\n+/* Emit instructions that assign number of threads to lhs of gimple STMT.\n+   Instructions are appended to basic block HBB.  */\n+\n+static void\n+gen_get_num_threads (gimple *stmt, hsa_bb *hbb)\n+{\n+  if (gimple_call_lhs (stmt) == NULL_TREE)\n+    return;\n+\n+  hbb->append_insn (new hsa_insn_comment (\"omp_get_num_threads\"));\n+  tree lhs = gimple_call_lhs (stmt);\n+  hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n+  multiply_grid_dim_characteristics (dest, BRIG_OPCODE_CURRENTWORKGROUPSIZE,\n+\t\t\t\t     hbb);\n+}\n \n /* Emit instructions that assign number of teams to lhs of gimple STMT.\n    Instructions are appended to basic block HBB.  */\n@@ -4023,15 +4031,9 @@ gen_get_num_teams (gimple *stmt, hsa_bb *hbb)\n     return;\n \n   hbb->append_insn (new hsa_insn_comment (\"omp_get_num_teams\"));\n-\n   tree lhs = gimple_call_lhs (stmt);\n   hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n-  hsa_op_immed *one = new hsa_op_immed (1, dest->m_type);\n-\n-  hsa_insn_basic *basic\n-    = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type, dest, one);\n-\n-  hbb->append_insn (basic);\n+  multiply_grid_dim_characteristics (dest, BRIG_OPCODE_GRIDGROUPS, hbb);\n }\n \n /* Emit instructions that assign a team number to lhs of gimple STMT.\n@@ -4044,15 +4046,42 @@ gen_get_team_num (gimple *stmt, hsa_bb *hbb)\n     return;\n \n   hbb->append_insn (new hsa_insn_comment (\"omp_get_team_num\"));\n-\n   tree lhs = gimple_call_lhs (stmt);\n   hsa_op_reg *dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n-  hsa_op_immed *zero = new hsa_op_immed (0, dest->m_type);\n \n-  hsa_insn_basic *basic\n-    = new hsa_insn_basic (2, BRIG_OPCODE_MOV, dest->m_type, dest, zero);\n-\n-  hbb->append_insn (basic);\n+  hsa_op_reg *gnum_x = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (gnum_x, BRIG_OPCODE_GRIDGROUPS,\n+\t\t      new hsa_op_immed (0, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+  hsa_op_reg *gnum_y = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (gnum_y, BRIG_OPCODE_GRIDGROUPS,\n+\t\t      new hsa_op_immed (1, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+\n+  hsa_op_reg *gno_z = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (gno_z, BRIG_OPCODE_WORKGROUPID,\n+\t\t      new hsa_op_immed (2, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+\n+  hsa_op_reg *tmp1 = new hsa_op_reg (dest->m_type);\n+  gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp1,\n+\t\t\t    gnum_x->get_in_type (dest->m_type, hbb),\n+\t\t\t    gnum_y->get_in_type (dest->m_type, hbb), hbb);\n+  hsa_op_reg *tmp2 = new hsa_op_reg (dest->m_type);\n+  gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp2, tmp1,\n+\t\t\t    gno_z->get_in_type (dest->m_type, hbb), hbb);\n+\n+  hsa_op_reg *gno_y = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (gno_y, BRIG_OPCODE_WORKGROUPID,\n+\t\t      new hsa_op_immed (1, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+  hsa_op_reg *tmp3 = new hsa_op_reg (dest->m_type);\n+  gen_hsa_binary_operation (BRIG_OPCODE_MUL, tmp3,\n+\t\t\t    gnum_x->get_in_type (dest->m_type, hbb),\n+\t\t\t    gno_y->get_in_type (dest->m_type, hbb), hbb);\n+  hsa_op_reg *tmp4 = new hsa_op_reg (dest->m_type);\n+  gen_hsa_binary_operation (BRIG_OPCODE_ADD, tmp4, tmp3, tmp2, hbb);\n+  hsa_op_reg *gno_x = new hsa_op_reg (BRIG_TYPE_U32);\n+  query_hsa_grid_dim (gno_x, BRIG_OPCODE_WORKGROUPID,\n+\t\t      new hsa_op_immed (0, (BrigKind16_t) BRIG_TYPE_U32), hbb);\n+  gen_hsa_binary_operation (BRIG_OPCODE_ADD, dest, tmp4,\n+\t\t\t    gno_x->get_in_type (dest->m_type, hbb), hbb);\n }\n \n /* Emit instructions that get levels-var ICV to lhs of gimple STMT.\n@@ -4263,12 +4292,13 @@ gen_hsa_popcount_to_dest (hsa_op_reg *dest, hsa_op_with_type *arg, hsa_bb *hbb)\n   if (hsa_type_bit_size (arg->m_type) < 32)\n     arg = arg->get_in_type (BRIG_TYPE_B32, hbb);\n \n+  BrigType16_t srctype = hsa_bittype_for_type (arg->m_type);\n   if (!hsa_btype_p (arg->m_type))\n-    arg = arg->get_in_type (hsa_bittype_for_type (arg->m_type), hbb);\n+    arg = arg->get_in_type (srctype, hbb);\n \n   hsa_insn_srctype *popcount\n     = new hsa_insn_srctype (2, BRIG_OPCODE_POPCOUNT, BRIG_TYPE_U32,\n-\t\t\t    arg->m_type, NULL, arg);\n+\t\t\t    srctype, NULL, arg);\n   hbb->append_insn (popcount);\n   popcount->set_output_in_type (dest, 0, hbb);\n }\n@@ -4339,11 +4369,11 @@ omp_simple_builtin::generate (gimple *stmt, hsa_bb *hbb)\n   if (m_sorry)\n     {\n       if (m_warning_message)\n-\tHSA_SORRY_AT (gimple_location (stmt), m_warning_message)\n+\tHSA_SORRY_AT (gimple_location (stmt), m_warning_message);\n       else\n \tHSA_SORRY_ATV (gimple_location (stmt),\n \t\t       \"Support for HSA does not implement calls to %s\\n\",\n-\t\t       m_name)\n+\t\t       m_name);\n     }\n   else if (m_warning_message != NULL)\n     warning_at (gimple_location (stmt), OPT_Whsa, m_warning_message);\n@@ -4398,12 +4428,12 @@ gen_hsa_insns_for_known_library_call (gimple *stmt, hsa_bb *hbb)\n       else if (strcmp (name, \"omp_get_thread_num\") == 0)\n \t{\n \t  hbb->append_insn (new hsa_insn_comment (name));\n-\t  query_hsa_grid (stmt, BRIG_OPCODE_WORKITEMABSID, 0, hbb);\n+\t  query_hsa_grid_nodim (stmt, BRIG_OPCODE_WORKITEMFLATABSID, hbb);\n \t}\n       else if (strcmp (name, \"omp_get_num_threads\") == 0)\n \t{\n \t  hbb->append_insn (new hsa_insn_comment (name));\n-\t  query_hsa_grid (stmt, BRIG_OPCODE_GRIDSIZE, 0, hbb);\n+\t  gen_get_num_threads (stmt, hbb);\n \t}\n       else if (strcmp (name, \"omp_get_num_teams\") == 0)\n \tgen_get_num_teams (stmt, hbb);\n@@ -4589,7 +4619,7 @@ expand_string_operation_builtin (gimple *stmt, hsa_bb *hbb,\n {\n   edge e = split_block (hbb->m_bb, stmt);\n   basic_block condition_bb = e->src;\n-  hbb->append_insn (new hsa_insn_br (misaligned_flag));\n+  hbb->append_insn (new hsa_insn_cbr (misaligned_flag));\n \n   /* Prepare the control flow.  */\n   edge condition_edge = EDGE_SUCC (condition_bb, 0);\n@@ -4718,95 +4748,86 @@ expand_memory_set (gimple *stmt, unsigned HOST_WIDE_INT n,\n   expand_lhs_of_string_op (stmt, n, merge_bb, builtin);\n }\n \n-/* Return string for MEMMODEL.  */\n+/* Store into MEMORDER the memory order specified by tree T, which must be an\n+   integer constant representing a C++ memory order.  If it isn't, issue an HSA\n+   sorry message using LOC and return true, otherwise return false and store\n+   the name of the requested order to *MNAME.  */\n \n-static const char *\n-get_memory_order_name (unsigned memmodel)\n+static bool\n+hsa_memorder_from_tree (tree t, BrigMemoryOrder *memorder, const char **mname,\n+\t\t\tlocation_t loc)\n {\n-  switch (memmodel & MEMMODEL_BASE_MASK)\n+  if (!tree_fits_uhwi_p (t))\n     {\n-    case MEMMODEL_RELAXED:\n-      return \"relaxed\";\n-    case MEMMODEL_CONSUME:\n-      return \"consume\";\n-    case MEMMODEL_ACQUIRE:\n-      return \"acquire\";\n-    case MEMMODEL_RELEASE:\n-      return \"release\";\n-    case MEMMODEL_ACQ_REL:\n-      return \"acq_rel\";\n-    case MEMMODEL_SEQ_CST:\n-      return \"seq_cst\";\n-    default:\n-      return NULL;\n+      HSA_SORRY_ATV (loc, \"support for HSA does not implement memory model %E\",\n+\t\t     t);\n+      return true;\n     }\n-}\n-\n-/* Return memory order according to predefined __atomic memory model\n-   constants.  LOCATION is provided to locate the problematic statement.  */\n \n-static BrigMemoryOrder\n-get_memory_order (unsigned memmodel, location_t location)\n-{\n-  switch (memmodel & MEMMODEL_BASE_MASK)\n+  unsigned HOST_WIDE_INT mm = tree_to_uhwi (t);\n+  switch (mm & MEMMODEL_BASE_MASK)\n     {\n     case MEMMODEL_RELAXED:\n-      return BRIG_MEMORY_ORDER_RELAXED;\n+      *memorder = BRIG_MEMORY_ORDER_RELAXED;\n+      *mname = \"relaxed\";\n+      break;\n     case MEMMODEL_CONSUME:\n       /* HSA does not have an equivalent, but we can use the slightly stronger\n \t ACQUIRE.  */\n+      *memorder = BRIG_MEMORY_ORDER_SC_ACQUIRE;\n+      *mname = \"consume\";\n+      break;\n     case MEMMODEL_ACQUIRE:\n-      return BRIG_MEMORY_ORDER_SC_ACQUIRE;\n+      *memorder = BRIG_MEMORY_ORDER_SC_ACQUIRE;\n+      *mname = \"acquire\";\n+      break;\n     case MEMMODEL_RELEASE:\n-      return BRIG_MEMORY_ORDER_SC_RELEASE;\n+      *memorder = BRIG_MEMORY_ORDER_SC_RELEASE;\n+      *mname = \"release\";\n+      break;\n     case MEMMODEL_ACQ_REL:\n+      *memorder = BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE;\n+      *mname = \"acq_rel\";\n+      break;\n     case MEMMODEL_SEQ_CST:\n       /* Callers implementing a simple load or store need to remove the release\n \t or acquire part respectively.  */\n-      return BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE;\n+      *memorder = BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE;\n+      *mname = \"seq_cst\";\n+      break;\n     default:\n       {\n-\tconst char *mmname = get_memory_order_name (memmodel);\n-\tHSA_SORRY_ATV (location,\n-\t\t       \"support for HSA does not implement the specified \"\n-\t\t       \" memory model%s %s\",\n-\t\t       mmname ? \": \" : \"\", mmname ? mmname : \"\");\n-\treturn BRIG_MEMORY_ORDER_NONE;\n+\tHSA_SORRY_AT (loc, \"support for HSA does not implement the specified \"\n+\t\t      \"memory model\");\n+\treturn true;\n       }\n     }\n+  return false;\n }\n \n-/* Helper function to create an HSA atomic binary operation instruction out of\n-   calls to atomic builtins.  RET_ORIG is true if the built-in is the variant\n-   that return s the value before applying operation, and false if it should\n-   return the value after applying the operation (if it returns value at all).\n-   ACODE is the atomic operation code, STMT is a gimple call to a builtin.  HBB\n-   is the HSA BB to which the instruction should be added.  */\n+/* Helper function to create an HSA atomic operation instruction out of calls\n+   to atomic builtins.  RET_ORIG is true if the built-in is the variant that\n+   return s the value before applying operation, and false if it should return\n+   the value after applying the operation (if it returns value at all).  ACODE\n+   is the atomic operation code, STMT is a gimple call to a builtin.  HBB is\n+   the HSA BB to which the instruction should be added.  If SIGNAL is true, the\n+   created operation will work on HSA signals rather than atomic variables.  */\n \n static void\n-gen_hsa_ternary_atomic_for_builtin (bool ret_orig,\n- \t\t\t\t    enum BrigAtomicOperation acode,\n-\t\t\t\t    gimple *stmt,\n-\t\t\t\t    hsa_bb *hbb)\n+gen_hsa_atomic_for_builtin (bool ret_orig, enum BrigAtomicOperation acode,\n+\t\t\t    gimple *stmt, hsa_bb *hbb, bool signal)\n {\n   tree lhs = gimple_call_lhs (stmt);\n \n   tree type = TREE_TYPE (gimple_call_arg (stmt, 1));\n   BrigType16_t hsa_type = hsa_type_for_scalar_tree_type (type, false);\n   BrigType16_t mtype = mem_type_for_type (hsa_type);\n-  tree model = gimple_call_arg (stmt, 2);\n+  BrigMemoryOrder memorder;\n+  const char *mmname;\n \n-  if (!tree_fits_uhwi_p (model))\n-    {\n-      HSA_SORRY_ATV (gimple_location (stmt),\n-\t\t     \"support for HSA does not implement memory model %E\",\n-\t\t     model);\n-      return;\n-    }\n-\n-  unsigned HOST_WIDE_INT mmodel = tree_to_uhwi (model);\n-\n-  BrigMemoryOrder memorder = get_memory_order (mmodel, gimple_location (stmt));\n+  if (hsa_memorder_from_tree (gimple_call_arg (stmt, 2), &memorder, &mmname,\n+\t\t\t      gimple_location (stmt)))\n+    return;\n \n   /* Certain atomic insns must have Bx memory types.  */\n   switch (acode)\n@@ -4831,13 +4852,13 @@ gen_hsa_ternary_atomic_for_builtin (bool ret_orig,\n \tdest = hsa_cfun->reg_for_gimple_ssa (lhs);\n       else\n \tdest = new hsa_op_reg (hsa_type);\n-      opcode = BRIG_OPCODE_ATOMIC;\n+      opcode = signal ? BRIG_OPCODE_SIGNAL : BRIG_OPCODE_ATOMIC;\n       nops = 3;\n     }\n   else\n     {\n       dest = NULL;\n-      opcode = BRIG_OPCODE_ATOMICNORET;\n+      opcode = signal ? BRIG_OPCODE_SIGNALNORET : BRIG_OPCODE_ATOMICNORET;\n       nops = 2;\n     }\n \n@@ -4852,35 +4873,44 @@ gen_hsa_ternary_atomic_for_builtin (bool ret_orig,\n \t{\n \t  HSA_SORRY_ATV (gimple_location (stmt),\n \t\t\t \"support for HSA does not implement memory model for \"\n-\t\t\t \"ATOMIC_ST: %s\", get_memory_order_name (mmodel));\n+\t\t\t \"ATOMIC_ST: %s\", mmname);\n \t  return;\n \t}\n     }\n \n-  hsa_insn_atomic *atominsn = new hsa_insn_atomic (nops, opcode, acode, mtype,\n-\t\t\t\t\t\t   memorder);\n-\n-  hsa_op_address *addr;\n-  addr = get_address_from_value (gimple_call_arg (stmt, 0), hbb);\n-  if (addr->m_symbol && addr->m_symbol->m_segment == BRIG_SEGMENT_PRIVATE)\n+  hsa_insn_basic *atominsn;\n+  hsa_op_base *tgt;\n+  if (signal)\n     {\n-      HSA_SORRY_AT (gimple_location (stmt),\n-\t\t    \"HSA does not implement atomic operations in private \"\n-\t\t    \"segment\");\n-      return;\n+      atominsn = new hsa_insn_signal (nops, opcode, acode, mtype, memorder);\n+      tgt = hsa_reg_or_immed_for_gimple_op (gimple_call_arg (stmt, 0), hbb);\n     }\n+  else\n+    {\n+      atominsn = new hsa_insn_atomic (nops, opcode, acode, mtype, memorder);\n+      hsa_op_address *addr;\n+      addr = get_address_from_value (gimple_call_arg (stmt, 0), hbb);\n+      if (addr->m_symbol && addr->m_symbol->m_segment == BRIG_SEGMENT_PRIVATE)\n+\t{\n+\t  HSA_SORRY_AT (gimple_location (stmt),\n+\t\t\t\"HSA does not implement atomic operations in private \"\n+\t\t\t\"segment\");\n+\t  return;\n+\t}\n+      tgt = addr;\n+    }\n+\n   hsa_op_base *op = hsa_reg_or_immed_for_gimple_op (gimple_call_arg (stmt, 1),\n \t\t\t\t\t\t    hbb);\n-\n   if (lhs)\n     {\n       atominsn->set_op (0, dest);\n-      atominsn->set_op (1, addr);\n+      atominsn->set_op (1, tgt);\n       atominsn->set_op (2, op);\n     }\n   else\n     {\n-      atominsn->set_op (0, addr);\n+      atominsn->set_op (0, tgt);\n       atominsn->set_op (1, op);\n     }\n \n@@ -4950,6 +4980,10 @@ gen_hsa_insn_for_internal_fn_call (gcall *stmt, hsa_bb *hbb)\n       gen_hsa_unaryop_for_builtin (BRIG_OPCODE_SQRT, stmt, hbb);\n       break;\n \n+    case IFN_RSQRT:\n+      gen_hsa_unaryop_for_builtin (BRIG_OPCODE_NRSQRT, stmt, hbb);\n+      break;\n+\n     case IFN_TRUNC:\n       gen_hsa_unaryop_for_builtin (BRIG_OPCODE_TRUNC, stmt, hbb);\n       break;\n@@ -5068,6 +5102,12 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n   if (!gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n     {\n       tree function_decl = gimple_call_fndecl (stmt);\n+      /* Prefetch pass can create type-mismatching prefetch builtin calls which\n+\t fail the gimple_call_builtin_p test above.  Handle them here.  */\n+      if (DECL_BUILT_IN_CLASS (function_decl)\n+\t  && DECL_FUNCTION_CODE (function_decl) == BUILT_IN_PREFETCH)\n+\treturn;\n+\n       if (function_decl == NULL_TREE)\n \t{\n \t  HSA_SORRY_AT (gimple_location (stmt),\n@@ -5185,21 +5225,14 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n     case BUILT_IN_ATOMIC_LOAD_16:\n       {\n \tBrigType16_t mtype;\n-\thsa_op_address *addr;\n-\taddr = get_address_from_value (gimple_call_arg (stmt, 0), hbb);\n-\ttree model = gimple_call_arg (stmt, 1);\n-\tif (!tree_fits_uhwi_p (model))\n-\t  {\n-\t    HSA_SORRY_ATV (gimple_location (stmt),\n-\t\t\t   \"support for HSA does not implement \"\n-\t\t\t   \"memory model: %E\",\n-\t\t\t   model);\n-\t    return;\n-\t  }\n+\thsa_op_base *src;\n+\tsrc = get_address_from_value (gimple_call_arg (stmt, 0), hbb);\n \n-\tunsigned HOST_WIDE_INT mmodel = tree_to_uhwi (model);\n-\tBrigMemoryOrder memorder = get_memory_order (mmodel,\n-\t\t\t\t\t\t     gimple_location (stmt));\n+\tBrigMemoryOrder memorder;\n+\tconst char *mmname;\n+\tif (hsa_memorder_from_tree (gimple_call_arg (stmt, 1), &memorder,\n+\t\t\t\t    &mmname, gimple_location (stmt)))\n+\t  return;\n \n \tif (memorder == BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE)\n \t  memorder = BRIG_MEMORY_ORDER_SC_ACQUIRE;\n@@ -5210,8 +5243,7 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \t  {\n \t    HSA_SORRY_ATV (gimple_location (stmt),\n \t\t\t   \"support for HSA does not implement \"\n-\t\t\t   \"memory model for ATOMIC_LD: %s\",\n-\t\t\t   get_memory_order_name (mmodel));\n+\t\t\t   \"memory model for atomic loads: %s\", mmname);\n \t    return;\n \t  }\n \n@@ -5229,9 +5261,9 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \t    dest = new hsa_op_reg (mtype);\n \t  }\n \n-\thsa_insn_atomic *atominsn\n-\t  = new hsa_insn_atomic (2, BRIG_OPCODE_ATOMIC, BRIG_ATOMIC_LD, mtype,\n-\t\t\t\t memorder, dest, addr);\n+\thsa_insn_basic *atominsn;\n+\tatominsn = new hsa_insn_atomic (2, BRIG_OPCODE_ATOMIC, BRIG_ATOMIC_LD,\n+\t\t\t\t\tmtype, memorder, dest, src);\n \n \thbb->append_insn (atominsn);\n \tbreak;\n@@ -5242,47 +5274,53 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n     case BUILT_IN_ATOMIC_EXCHANGE_4:\n     case BUILT_IN_ATOMIC_EXCHANGE_8:\n     case BUILT_IN_ATOMIC_EXCHANGE_16:\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_EXCH, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_EXCH, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_FETCH_ADD_1:\n     case BUILT_IN_ATOMIC_FETCH_ADD_2:\n     case BUILT_IN_ATOMIC_FETCH_ADD_4:\n     case BUILT_IN_ATOMIC_FETCH_ADD_8:\n     case BUILT_IN_ATOMIC_FETCH_ADD_16:\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_ADD, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_ADD, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_FETCH_SUB_1:\n     case BUILT_IN_ATOMIC_FETCH_SUB_2:\n     case BUILT_IN_ATOMIC_FETCH_SUB_4:\n     case BUILT_IN_ATOMIC_FETCH_SUB_8:\n     case BUILT_IN_ATOMIC_FETCH_SUB_16:\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_SUB, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_SUB, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_FETCH_AND_1:\n     case BUILT_IN_ATOMIC_FETCH_AND_2:\n     case BUILT_IN_ATOMIC_FETCH_AND_4:\n     case BUILT_IN_ATOMIC_FETCH_AND_8:\n     case BUILT_IN_ATOMIC_FETCH_AND_16:\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_AND, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_AND, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_FETCH_XOR_1:\n     case BUILT_IN_ATOMIC_FETCH_XOR_2:\n     case BUILT_IN_ATOMIC_FETCH_XOR_4:\n     case BUILT_IN_ATOMIC_FETCH_XOR_8:\n     case BUILT_IN_ATOMIC_FETCH_XOR_16:\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_XOR, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_XOR, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_FETCH_OR_1:\n     case BUILT_IN_ATOMIC_FETCH_OR_2:\n     case BUILT_IN_ATOMIC_FETCH_OR_4:\n     case BUILT_IN_ATOMIC_FETCH_OR_8:\n     case BUILT_IN_ATOMIC_FETCH_OR_16:\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_OR, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_OR, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_STORE_1:\n@@ -5291,47 +5329,48 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n     case BUILT_IN_ATOMIC_STORE_8:\n     case BUILT_IN_ATOMIC_STORE_16:\n       /* Since there cannot be any LHS, the first parameter is meaningless.  */\n-      gen_hsa_ternary_atomic_for_builtin (true, BRIG_ATOMIC_ST, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (true, BRIG_ATOMIC_ST, stmt, hbb, false);\n+      break;\n       break;\n \n     case BUILT_IN_ATOMIC_ADD_FETCH_1:\n     case BUILT_IN_ATOMIC_ADD_FETCH_2:\n     case BUILT_IN_ATOMIC_ADD_FETCH_4:\n     case BUILT_IN_ATOMIC_ADD_FETCH_8:\n     case BUILT_IN_ATOMIC_ADD_FETCH_16:\n-      gen_hsa_ternary_atomic_for_builtin (false, BRIG_ATOMIC_ADD, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (false, BRIG_ATOMIC_ADD, stmt, hbb, false);\n       break;\n \n     case BUILT_IN_ATOMIC_SUB_FETCH_1:\n     case BUILT_IN_ATOMIC_SUB_FETCH_2:\n     case BUILT_IN_ATOMIC_SUB_FETCH_4:\n     case BUILT_IN_ATOMIC_SUB_FETCH_8:\n     case BUILT_IN_ATOMIC_SUB_FETCH_16:\n-      gen_hsa_ternary_atomic_for_builtin (false, BRIG_ATOMIC_SUB, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (false, BRIG_ATOMIC_SUB, stmt, hbb, false);\n       break;\n \n     case BUILT_IN_ATOMIC_AND_FETCH_1:\n     case BUILT_IN_ATOMIC_AND_FETCH_2:\n     case BUILT_IN_ATOMIC_AND_FETCH_4:\n     case BUILT_IN_ATOMIC_AND_FETCH_8:\n     case BUILT_IN_ATOMIC_AND_FETCH_16:\n-      gen_hsa_ternary_atomic_for_builtin (false, BRIG_ATOMIC_AND, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (false, BRIG_ATOMIC_AND, stmt, hbb, false);\n       break;\n \n     case BUILT_IN_ATOMIC_XOR_FETCH_1:\n     case BUILT_IN_ATOMIC_XOR_FETCH_2:\n     case BUILT_IN_ATOMIC_XOR_FETCH_4:\n     case BUILT_IN_ATOMIC_XOR_FETCH_8:\n     case BUILT_IN_ATOMIC_XOR_FETCH_16:\n-      gen_hsa_ternary_atomic_for_builtin (false, BRIG_ATOMIC_XOR, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (false, BRIG_ATOMIC_XOR, stmt, hbb, false);\n       break;\n \n     case BUILT_IN_ATOMIC_OR_FETCH_1:\n     case BUILT_IN_ATOMIC_OR_FETCH_2:\n     case BUILT_IN_ATOMIC_OR_FETCH_4:\n     case BUILT_IN_ATOMIC_OR_FETCH_8:\n     case BUILT_IN_ATOMIC_OR_FETCH_16:\n-      gen_hsa_ternary_atomic_for_builtin (false, BRIG_ATOMIC_OR, stmt, hbb);\n+      gen_hsa_atomic_for_builtin (false, BRIG_ATOMIC_OR, stmt, hbb, false);\n       break;\n \n     case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_1:\n@@ -5340,27 +5379,23 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n     case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_8:\n     case BUILT_IN_SYNC_VAL_COMPARE_AND_SWAP_16:\n       {\n-\t/* TODO: Use the appropriate memory model for now.  */\n \ttree type = TREE_TYPE (gimple_call_arg (stmt, 1));\n-\n \tBrigType16_t atype\n \t  = hsa_bittype_for_type (hsa_type_for_scalar_tree_type (type, false));\n-\n-\thsa_insn_atomic *atominsn\n-\t  = new hsa_insn_atomic (4, BRIG_OPCODE_ATOMIC, BRIG_ATOMIC_CAS, atype,\n-\t\t\t\t BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE);\n-\thsa_op_address *addr;\n-\taddr = get_address_from_value (gimple_call_arg (stmt, 0), hbb);\n+\tBrigMemoryOrder memorder = BRIG_MEMORY_ORDER_SC_ACQUIRE_RELEASE;\n+\thsa_insn_basic *atominsn;\n+\thsa_op_base *tgt;\n+\tatominsn = new hsa_insn_atomic (4, BRIG_OPCODE_ATOMIC,\n+\t\t\t\t\tBRIG_ATOMIC_CAS, atype, memorder);\n+\ttgt = get_address_from_value (gimple_call_arg (stmt, 0), hbb);\n \n \tif (lhs != NULL)\n \t  dest = hsa_cfun->reg_for_gimple_ssa (lhs);\n \telse\n \t  dest = new hsa_op_reg (atype);\n \n-\t/* Should check what the memory scope is.  */\n-\tatominsn->m_memoryscope = BRIG_MEMORY_SCOPE_WORKGROUP;\n \tatominsn->set_op (0, dest);\n-\tatominsn->set_op (1, addr);\n+\tatominsn->set_op (1, tgt);\n \n \thsa_op_with_type *op\n \t  = hsa_reg_or_immed_for_gimple_op (gimple_call_arg (stmt, 1), hbb);\n@@ -5371,20 +5406,42 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \thbb->append_insn (atominsn);\n \tbreak;\n       }\n+\n+    case BUILT_IN_HSA_WORKGROUPID:\n+      query_hsa_grid_dim (stmt, BRIG_OPCODE_WORKGROUPID, hbb);\n+      break;\n+    case BUILT_IN_HSA_WORKITEMID:\n+      query_hsa_grid_dim (stmt, BRIG_OPCODE_WORKITEMID, hbb);\n+      break;\n+    case BUILT_IN_HSA_WORKITEMABSID:\n+      query_hsa_grid_dim (stmt, BRIG_OPCODE_WORKITEMABSID, hbb);\n+      break;\n+    case BUILT_IN_HSA_GRIDSIZE:\n+      query_hsa_grid_dim (stmt, BRIG_OPCODE_GRIDSIZE, hbb);\n+      break;\n+    case BUILT_IN_HSA_CURRENTWORKGROUPSIZE:\n+      query_hsa_grid_dim (stmt, BRIG_OPCODE_CURRENTWORKGROUPSIZE, hbb);\n+      break;\n+\n+    case BUILT_IN_GOMP_BARRIER:\n+      hbb->append_insn (new hsa_insn_br (0, BRIG_OPCODE_BARRIER, BRIG_TYPE_NONE,\n+\t\t\t\t\t BRIG_WIDTH_ALL));\n+      break;\n     case BUILT_IN_GOMP_PARALLEL:\n       HSA_SORRY_AT (gimple_location (stmt),\n \t\t    \"support for HSA does not implement non-gridified \"\n \t\t    \"OpenMP parallel constructs.\");\n       break;\n+\n     case BUILT_IN_OMP_GET_THREAD_NUM:\n       {\n-\tquery_hsa_grid (stmt, BRIG_OPCODE_WORKITEMABSID, 0, hbb);\n+\tquery_hsa_grid_nodim (stmt, BRIG_OPCODE_WORKITEMFLATABSID, hbb);\n \tbreak;\n       }\n \n     case BUILT_IN_OMP_GET_NUM_THREADS:\n       {\n-\tquery_hsa_grid (stmt, BRIG_OPCODE_GRIDSIZE, 0, hbb);\n+\tgen_get_num_threads (stmt, hbb);\n \tbreak;\n       }\n     case BUILT_IN_GOMP_TEAMS:\n@@ -5469,9 +5526,19 @@ gen_hsa_insns_for_call (gimple *stmt, hsa_bb *hbb)\n \tgen_hsa_alloca (call, hbb);\n \tbreak;\n       }\n+    case BUILT_IN_PREFETCH:\n+      break;\n     default:\n       {\n-\tgen_hsa_insns_for_direct_call (stmt, hbb);\n+\ttree name_tree = DECL_NAME (fndecl);\n+\tconst char *s = IDENTIFIER_POINTER (name_tree);\n+\tsize_t len = strlen (s);\n+\tif (len > 4 && (strncmp (s, \"__builtin_GOMP_\", 15) == 0))\n+\t  HSA_SORRY_ATV (gimple_location (stmt),\n+\t\t\t \"support for HSA does not implement GOMP function %s\",\n+\t\t\t s);\n+\telse\n+\t  gen_hsa_insns_for_direct_call (stmt, hbb);\n \treturn;\n       }\n     }\n@@ -5601,13 +5668,7 @@ gen_hsa_phi_from_gimple_phi (gimple *phi_stmt, hsa_bb *hbb)\n \t}\n     }\n \n-  hphi->m_prev = hbb->m_last_phi;\n-  hphi->m_next = NULL;\n-  if (hbb->m_last_phi)\n-    hbb->m_last_phi->m_next = hphi;\n-  hbb->m_last_phi = hphi;\n-  if (!hbb->m_first_phi)\n-    hbb->m_first_phi = hphi;\n+  hbb->append_phi (hphi);\n }\n \n /* Constructor of class containing HSA-specific information about a basic\n@@ -5650,7 +5711,8 @@ hsa_bb::~hsa_bb ()\n hsa_bb *\n hsa_init_new_bb (basic_block bb)\n {\n-  return new (*hsa_allocp_bb) hsa_bb (bb);\n+  void *m = obstack_alloc (&hsa_obstack, sizeof (hsa_bb));\n+  return new (m) hsa_bb (bb);\n }\n \n /* Initialize OMP in an HSA basic block PROLOGUE.  */"}, {"sha": "f881e781742e20c926fb7f2f968ec718f2c1011c", "filename": "gcc/hsa.c", "status": "modified", "additions": 21, "deletions": 39, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -170,6 +170,7 @@ hsa_insn_basic::op_output_p (unsigned opnum)\n     case BRIG_OPCODE_SBR:\n     case BRIG_OPCODE_ST:\n     case BRIG_OPCODE_SIGNALNORET:\n+    case BRIG_OPCODE_DEBUGTRAP:\n       /* FIXME: There are probably missing cases here, double check.  */\n       return false;\n     case BRIG_OPCODE_EXPAND:\n@@ -605,8 +606,8 @@ hsa_destroy_insn (hsa_insn_basic *insn)\n {\n   if (hsa_insn_phi *phi = dyn_cast <hsa_insn_phi *> (insn))\n     phi->~hsa_insn_phi ();\n-  else if (hsa_insn_br *br = dyn_cast <hsa_insn_br *> (insn))\n-    br->~hsa_insn_br ();\n+  else if (hsa_insn_cbr *br = dyn_cast <hsa_insn_cbr *> (insn))\n+    br->~hsa_insn_cbr ();\n   else if (hsa_insn_cmp *cmp = dyn_cast <hsa_insn_cmp *> (insn))\n     cmp->~hsa_insn_cmp ();\n   else if (hsa_insn_mem *mem = dyn_cast <hsa_insn_mem *> (insn))\n@@ -621,6 +622,8 @@ hsa_destroy_insn (hsa_insn_basic *insn)\n     block->~hsa_insn_arg_block ();\n   else if (hsa_insn_sbr *sbr = dyn_cast <hsa_insn_sbr *> (insn))\n     sbr->~hsa_insn_sbr ();\n+  else if (hsa_insn_br *br = dyn_cast <hsa_insn_br *> (insn))\n+    br->~hsa_insn_br ();\n   else if (hsa_insn_comment *comment = dyn_cast <hsa_insn_comment *> (insn))\n     comment->~hsa_insn_comment ();\n   else\n@@ -783,32 +786,22 @@ hsa_brig_function_name (const char *p)\n   return buf;\n }\n \n-/* Return declaration name if exists.  */\n+/* Add a flatten attribute and disable vectorization for gpu implementation\n+   function decl GDECL.  */\n \n-const char *\n-hsa_get_declaration_name (tree decl)\n+void hsa_summary_t::process_gpu_implementation_attributes (tree gdecl)\n {\n-  if (!DECL_NAME (decl))\n-    {\n-      char buf[64];\n-      snprintf (buf, 64, \"__hsa_anonymous_%i\", DECL_UID (decl));\n-      const char *ggc_str = ggc_strdup (buf);\n-      return ggc_str;\n-    }\n-\n-  tree name_tree;\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      || (VAR_P (decl) && is_global_var (decl)))\n-    name_tree = DECL_ASSEMBLER_NAME (decl);\n-  else\n-    name_tree = DECL_NAME (decl);\n-\n-  const char *name = IDENTIFIER_POINTER (name_tree);\n-  /* User-defined assembly names have prepended asterisk symbol.  */\n-  if (name[0] == '*')\n-    name++;\n+  DECL_ATTRIBUTES (gdecl)\n+    = tree_cons (get_identifier (\"flatten\"), NULL_TREE,\n+\t\t DECL_ATTRIBUTES (gdecl));\n \n-  return name;\n+  tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (gdecl);\n+  if (fn_opts == NULL_TREE)\n+    fn_opts = optimization_default_node;\n+  fn_opts = copy_node (fn_opts);\n+  TREE_OPTIMIZATION (fn_opts)->x_flag_tree_loop_vectorize = false;\n+  TREE_OPTIMIZATION (fn_opts)->x_flag_tree_slp_vectorize = false;\n+  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (gdecl) = fn_opts;\n }\n \n void\n@@ -827,21 +820,10 @@ hsa_summary_t::link_functions (cgraph_node *gpu, cgraph_node *host,\n   gpu_summary->m_gridified_kernel_p = gridified_kernel_p;\n   host_summary->m_gridified_kernel_p = gridified_kernel_p;\n \n-  gpu_summary->m_binded_function = host;\n-  host_summary->m_binded_function = gpu;\n-\n-  tree gdecl = gpu->decl;\n-  DECL_ATTRIBUTES (gdecl)\n-    = tree_cons (get_identifier (\"flatten\"), NULL_TREE,\n-\t\t DECL_ATTRIBUTES (gdecl));\n+  gpu_summary->m_bound_function = host;\n+  host_summary->m_bound_function = gpu;\n \n-  tree fn_opts = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (gdecl);\n-  if (fn_opts == NULL_TREE)\n-    fn_opts = optimization_default_node;\n-  fn_opts = copy_node (fn_opts);\n-  TREE_OPTIMIZATION (fn_opts)->x_flag_tree_loop_vectorize = false;\n-  TREE_OPTIMIZATION (fn_opts)->x_flag_tree_slp_vectorize = false;\n-  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (gdecl) = fn_opts;\n+  process_gpu_implementation_attributes (gpu->decl);\n \n   /* Create reference between a kernel and a corresponding host implementation\n      to quarantee LTO streaming to a same LTRANS.  */"}, {"sha": "c00ffd577faaa0cacdabaa03d7e397df54598557", "filename": "gcc/hsa.h", "status": "modified", "additions": 70, "deletions": 87, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.h?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -50,7 +50,6 @@ class hsa_insn_basic;\n class hsa_op_address;\n class hsa_op_reg;\n class hsa_bb;\n-typedef hsa_insn_basic *hsa_insn_basic_p;\n \n /* Class representing an input argument, output argument (result) or a\n    variable, that will eventually end up being a symbol directive.  */\n@@ -72,7 +71,8 @@ struct hsa_symbol\n   void fillup_for_decl (tree decl);\n \n   /* Pointer to the original tree, which is PARM_DECL for input parameters and\n-     RESULT_DECL for the output parameters.  */\n+     RESULT_DECL for the output parameters.  Also can be CONST_DECL for Fortran\n+     constants which need to be put into readonly segment.  */\n   tree m_decl;\n \n   /* Name of the symbol, that will be written into output and dumps.  Can be\n@@ -259,11 +259,9 @@ class hsa_op_reg : public hsa_op_with_type\n   /* Set definition where the register is defined.  */\n   void set_definition (hsa_insn_basic *insn);\n   /* Uses of the value while still in SSA.  */\n-  auto_vec <hsa_insn_basic_p> m_uses;\n+  auto_vec <hsa_insn_basic *> m_uses;\n };\n \n-typedef class hsa_op_reg *hsa_op_reg_p;\n-\n /* Report whether or not P is a register operand.  */\n \n template <>\n@@ -490,17 +488,12 @@ class hsa_insn_phi : public hsa_insn_basic\n public:\n   hsa_insn_phi (unsigned nops, hsa_op_reg *dst);\n \n-  void *operator new (size_t);\n-\n   /* Destination.  */\n   hsa_op_reg *m_dest;\n \n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_phi () : hsa_insn_basic (1, HSA_OPCODE_PHI) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is a PHI node.  */\n@@ -513,35 +506,56 @@ is_a_helper <hsa_insn_phi *>::test (hsa_insn_basic *p)\n   return p->m_opcode == HSA_OPCODE_PHI;\n }\n \n-/* HSA instruction for branches.  Currently we explicitely represent only\n-   conditional branches.  */\n-\n+/* HSA instruction for  */\n class hsa_insn_br : public hsa_insn_basic\n {\n public:\n-  hsa_insn_br (hsa_op_reg *ctrl);\n-\n-  void *operator new (size_t);\n+  hsa_insn_br (unsigned nops, int opc, BrigType16_t t, BrigWidth8_t width,\n+\t       hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n+\t       hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n \n-  /* Width as described in HSA documentation.  */\n+  /* Number of work-items affected in the same way by the instruction.  */\n   BrigWidth8_t m_width;\n+\n private:\n   /* Make the default constructor inaccessible.  */\n-  hsa_insn_br () : hsa_insn_basic (1, BRIG_OPCODE_CBR) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n+  hsa_insn_br () : hsa_insn_basic (0, BRIG_OPCODE_BR) {}\n };\n \n-/* Report whether P is a branching instruction.  */\n+/* Return true if P is a branching/synchronization instruction.  */\n \n template <>\n template <>\n inline bool\n is_a_helper <hsa_insn_br *>::test (hsa_insn_basic *p)\n {\n-  return p->m_opcode == BRIG_OPCODE_BR\n-    || p->m_opcode == BRIG_OPCODE_CBR;\n+  return p->m_opcode == BRIG_OPCODE_BARRIER\n+    || p->m_opcode == BRIG_OPCODE_BR;\n+}\n+\n+/* HSA instruction for conditional branches.  Structurally the same as\n+   hsa_insn_br but we represent it specially because of inherent control\n+   flow it represents.  */\n+\n+class hsa_insn_cbr : public hsa_insn_br\n+{\n+public:\n+  hsa_insn_cbr (hsa_op_reg *ctrl);\n+\n+private:\n+  /* Make the default constructor inaccessible.  */\n+  hsa_insn_cbr () : hsa_insn_br (0, BRIG_OPCODE_CBR, BRIG_TYPE_B1,\n+\t\t\t\t BRIG_WIDTH_1) {}\n+};\n+\n+/* Report whether P is a contitional branching instruction.  */\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <hsa_insn_cbr *>::test (hsa_insn_basic *p)\n+{\n+  return p->m_opcode == BRIG_OPCODE_CBR;\n }\n \n /* HSA instruction for switch branches.  */\n@@ -554,8 +568,6 @@ class hsa_insn_sbr : public hsa_insn_basic\n   /* Default destructor.  */\n   ~hsa_insn_sbr ();\n \n-  void *operator new (size_t);\n-\n   void replace_all_labels (basic_block old_bb, basic_block new_bb);\n \n   /* Width as described in HSA documentation.  */\n@@ -570,9 +582,6 @@ class hsa_insn_sbr : public hsa_insn_basic\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_sbr () : hsa_insn_basic (1, BRIG_OPCODE_SBR) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether P is a switch branching instruction.  */\n@@ -594,8 +603,6 @@ class hsa_insn_cmp : public hsa_insn_basic\n \t\thsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n \t\thsa_op_base *arg2 = NULL);\n \n-  void *operator new (size_t);\n-\n   /* Source type should be derived from operand types.  */\n \n   /* The comparison operation.  */\n@@ -606,9 +613,6 @@ class hsa_insn_cmp : public hsa_insn_basic\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_cmp () : hsa_insn_basic (1, BRIG_OPCODE_CMP) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is a comparison instruction.  */\n@@ -628,8 +632,6 @@ class hsa_insn_mem : public hsa_insn_basic\n public:\n   hsa_insn_mem (int opc, BrigType16_t t, hsa_op_base *arg0, hsa_op_base *arg1);\n \n-  void *operator new (size_t);\n-\n   /* Set alignment to VALUE.  */\n \n   void set_align (BrigAlignment8_t value);\n@@ -652,9 +654,6 @@ class hsa_insn_mem : public hsa_insn_basic\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_mem () : hsa_insn_basic (1, BRIG_OPCODE_LD) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is a memory instruction.  */\n@@ -677,7 +676,6 @@ class hsa_insn_atomic : public hsa_insn_mem\n \t\t   BrigType16_t t, BrigMemoryOrder memorder,\n \t\t   hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n \t\t   hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n-  void *operator new (size_t);\n \n   /* The operation itself.  */\n   enum BrigAtomicOperation m_atomicop;\n@@ -691,9 +689,6 @@ class hsa_insn_atomic : public hsa_insn_mem\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_atomic () : hsa_insn_mem (1, BRIG_KIND_NONE, BRIG_TYPE_NONE) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is an atomic instruction.  */\n@@ -709,20 +704,19 @@ is_a_helper <hsa_insn_atomic *>::test (hsa_insn_basic *p)\n \n /* HSA instruction for signal operations.  */\n \n-class hsa_insn_signal : public hsa_insn_atomic\n+class hsa_insn_signal : public hsa_insn_basic\n {\n public:\n   hsa_insn_signal (int nops, int opc, enum BrigAtomicOperation sop,\n-\t\t   BrigType16_t t, hsa_op_base *arg0 = NULL,\n-\t\t   hsa_op_base *arg1 = NULL,\n+\t\t   BrigType16_t t, BrigMemoryOrder memorder,\n+\t\t   hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n \t\t   hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n \n-  void *operator new (size_t);\n+  /* Things like acquire/release/aligned.  */\n+  enum BrigMemoryOrder m_memory_order;\n \n-private:\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n+  /* The operation itself.  */\n+  enum BrigAtomicOperation m_signalop;\n };\n \n /* Report whether or not P is a signal instruction.  */\n@@ -744,18 +738,13 @@ class hsa_insn_seg : public hsa_insn_basic\n   hsa_insn_seg (int opc, BrigType16_t destt, BrigType16_t srct,\n \t\tBrigSegment8_t seg, hsa_op_base *arg0, hsa_op_base *arg1);\n \n-  void *operator new (size_t);\n-\n   /* Source type.  Depends on the source addressing/segment.  */\n   BrigType16_t m_src_type;\n   /* The segment we are converting from or to.  */\n   BrigSegment8_t m_segment;\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_seg () : hsa_insn_basic (1, BRIG_OPCODE_STOF) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is a segment conversion instruction.  */\n@@ -812,8 +801,6 @@ class hsa_insn_call : public hsa_insn_basic\n   /* Default destructor.  */\n   ~hsa_insn_call ();\n \n-  void *operator new (size_t);\n-\n   /* Called function.  */\n   tree m_called_function;\n \n@@ -840,9 +827,6 @@ class hsa_insn_call : public hsa_insn_basic\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_insn_call () : hsa_insn_basic (0, BRIG_OPCODE_CALL) {}\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is a call instruction.  */\n@@ -866,17 +850,11 @@ class hsa_insn_arg_block : public hsa_insn_basic\n public:\n   hsa_insn_arg_block (BrigKind brig_kind, hsa_insn_call * call);\n \n-  void *operator new (size_t);\n-\n   /* Kind of argument block.  */\n   BrigKind m_kind;\n \n   /* Call instruction.  */\n   hsa_insn_call *m_call_insn;\n-private:\n-  /* All objects are deallocated by destroying their pool, so make delete\n-     inaccessible too.  */\n-  void operator delete (void *) {}\n };\n \n /* Report whether or not P is a call block instruction.  */\n@@ -900,8 +878,6 @@ class hsa_insn_comment: public hsa_insn_basic\n   /* Default destructor.  */\n   ~hsa_insn_comment ();\n \n-  void *operator new (size_t);\n-\n   char *m_comment;\n };\n \n@@ -920,10 +896,18 @@ is_a_helper <hsa_insn_comment *>::test (hsa_insn_basic *p)\n class hsa_insn_queue: public hsa_insn_basic\n {\n public:\n-  hsa_insn_queue (int nops, BrigOpcode opcode);\n+  hsa_insn_queue (int nops, int opcode, BrigSegment segment,\n+\t\t  BrigMemoryOrder memory_order,\n+\t\t  hsa_op_base *arg0 = NULL, hsa_op_base *arg1 = NULL,\n+\t\t  hsa_op_base *arg2 = NULL, hsa_op_base *arg3 = NULL);\n \n   /* Destructor.  */\n   ~hsa_insn_queue ();\n+\n+  /* Segment used to refer to the queue.  Must be global or flat.  */\n+  BrigSegment m_segment;\n+  /* Memory order used to specify synchronization.  */\n+  BrigMemoryOrder m_memory_order;\n };\n \n /* Report whether or not P is a queue instruction.  */\n@@ -933,7 +917,12 @@ template <>\n inline bool\n is_a_helper <hsa_insn_queue *>::test (hsa_insn_basic *p)\n {\n-  return (p->m_opcode == BRIG_OPCODE_ADDQUEUEWRITEINDEX);\n+  return (p->m_opcode == BRIG_OPCODE_ADDQUEUEWRITEINDEX\n+\t  || p->m_opcode == BRIG_OPCODE_CASQUEUEWRITEINDEX\n+\t  || p->m_opcode == BRIG_OPCODE_LDQUEUEREADINDEX\n+\t  || p->m_opcode == BRIG_OPCODE_LDQUEUEWRITEINDEX\n+\t  || p->m_opcode == BRIG_OPCODE_STQUEUEREADINDEX\n+\t  || p->m_opcode == BRIG_OPCODE_STQUEUEWRITEINDEX);\n }\n \n /* HSA source type instruction.  */\n@@ -945,9 +934,6 @@ class hsa_insn_srctype: public hsa_insn_basic\n \t\t   BrigType16_t srct, hsa_op_base *arg0, hsa_op_base *arg1,\n \t\t   hsa_op_base *arg2);\n \n-  /* Pool allocator.  */\n-  void *operator new (size_t);\n-\n   /* Source type.  */\n   BrigType16_t m_source_type;\n \n@@ -976,9 +962,6 @@ class hsa_insn_packed : public hsa_insn_srctype\n \t\t   BrigType16_t srct, hsa_op_base *arg0, hsa_op_base *arg1,\n \t\t   hsa_op_base *arg2);\n \n-  /* Pool allocator.  */\n-  void *operator new (size_t);\n-\n   /* Operand list for an operand of the instruction.  */\n   hsa_op_operand_list *m_operand_list;\n \n@@ -1003,9 +986,6 @@ class hsa_insn_cvt: public hsa_insn_basic\n {\n public:\n   hsa_insn_cvt (hsa_op_with_type *dest, hsa_op_with_type *src);\n-\n-  /* Pool allocator.  */\n-  void *operator new (size_t);\n };\n \n /* Report whether or not P is a convert instruction.  */\n@@ -1028,9 +1008,6 @@ class hsa_insn_alloca: public hsa_insn_basic\n \n   /* Required alignment of the allocation.  */\n   BrigAlignment8_t m_align;\n-\n-  /* Pool allocator.  */\n-  void *operator new (size_t);\n };\n \n /* Report whether or not P is an alloca instruction.  */\n@@ -1055,6 +1032,9 @@ class hsa_bb\n   /* Append an instruction INSN into the basic block.  */\n   void append_insn (hsa_insn_basic *insn);\n \n+  /* Add a PHI instruction.  */\n+  void append_phi (hsa_insn_phi *phi);\n+\n   /* The real CFG BB that this HBB belongs to.  */\n   basic_block m_bb;\n \n@@ -1217,7 +1197,7 @@ class hsa_function_representation\n   unsigned m_temp_symbol_count;\n \n   /* SSA names mapping.  */\n-  vec <hsa_op_reg_p> m_ssa_map;\n+  vec <hsa_op_reg *> m_ssa_map;\n \n   /* Flag whether a function needs update of dominators before RA.  */\n   bool m_modified_cfg;\n@@ -1239,9 +1219,9 @@ struct hsa_function_summary\n   hsa_function_kind m_kind;\n \n   /* Pointer to a cgraph node which is a HSA implementation of the function.\n-     In case of the function is a HSA function, the binded function points\n+     In case of the function is a HSA function, the bound function points\n      to the host function.  */\n-  cgraph_node *m_binded_function;\n+  cgraph_node *m_bound_function;\n \n   /* Identifies if the function is an HSA function or a host function.  */\n   bool m_gpu_implementation_p;\n@@ -1252,7 +1232,7 @@ struct hsa_function_summary\n \n inline\n hsa_function_summary::hsa_function_summary (): m_kind (HSA_NONE),\n-  m_binded_function (NULL), m_gpu_implementation_p (false)\n+  m_bound_function (NULL), m_gpu_implementation_p (false)\n {\n }\n \n@@ -1270,6 +1250,9 @@ class hsa_summary_t: public function_summary <hsa_function_summary *>\n \n   void link_functions (cgraph_node *gpu, cgraph_node *host,\n \t\t       hsa_function_kind kind, bool gridified_kernel_p);\n+\n+private:\n+  void process_gpu_implementation_attributes (tree gdecl);\n };\n \n /* OMP simple builtin describes behavior that should be done for"}, {"sha": "0fbe2e2062d9a000a58929eb5a03ec0c05311d7c", "filename": "gcc/ipa-hsa.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fipa-hsa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fipa-hsa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-hsa.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -79,7 +79,7 @@ process_hsa_functions (void)\n       hsa_function_summary *s = hsa_summaries->get (node);\n \n       /* A linked function is skipped.  */\n-      if (s->m_binded_function != NULL)\n+      if (s->m_bound_function != NULL)\n \tcontinue;\n \n       if (s->m_kind != HSA_NONE)\n@@ -90,6 +90,7 @@ process_hsa_functions (void)\n \t    = node->create_virtual_clone (vec <cgraph_edge *> (),\n \t\t\t\t\t  NULL, NULL, \"hsa\");\n \t  TREE_PUBLIC (clone->decl) = TREE_PUBLIC (node->decl);\n+\t  clone->externally_visible = node->externally_visible;\n \n \t  clone->force_output = true;\n \t  hsa_summaries->link_functions (clone, node, s->m_kind, false);\n@@ -107,6 +108,7 @@ process_hsa_functions (void)\n \t    = node->create_virtual_clone (vec <cgraph_edge *> (),\n \t\t\t\t\t  NULL, NULL, \"hsa\");\n \t  TREE_PUBLIC (clone->decl) = TREE_PUBLIC (node->decl);\n+\t  clone->externally_visible = node->externally_visible;\n \n \t  if (!cgraph_local_p (node))\n \t    clone->force_output = true;\n@@ -131,7 +133,7 @@ process_hsa_functions (void)\n \t      hsa_function_summary *dst = hsa_summaries->get (e->callee);\n \t      if (dst->m_kind != HSA_NONE && !dst->m_gpu_implementation_p)\n \t\t{\n-\t\t  e->redirect_callee (dst->m_binded_function);\n+\t\t  e->redirect_callee (dst->m_bound_function);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file,\n \t\t\t     \"Redirecting edge to HSA function: %s->%s\\n\",\n@@ -193,10 +195,10 @@ ipa_hsa_write_summary (void)\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, s->m_kind, 2);\n \t  bp_pack_value (&bp, s->m_gpu_implementation_p, 1);\n-\t  bp_pack_value (&bp, s->m_binded_function != NULL, 1);\n+\t  bp_pack_value (&bp, s->m_bound_function != NULL, 1);\n \t  streamer_write_bitpack (&bp);\n-\t  if (s->m_binded_function)\n-\t    stream_write_tree (ob, s->m_binded_function->decl, true);\n+\t  if (s->m_bound_function)\n+\t    stream_write_tree (ob, s->m_bound_function->decl, true);\n \t}\n     }\n \n@@ -249,7 +251,7 @@ ipa_hsa_read_section (struct lto_file_decl_data *file_data, const char *data,\n       if (has_tree)\n \t{\n \t  tree decl = stream_read_tree (&ib_main, data_in);\n-\t  s->m_binded_function = cgraph_node::get_create (decl);\n+\t  s->m_bound_function = cgraph_node::get_create (decl);\n \t}\n     }\n   lto_free_section_data (file_data, LTO_section_ipa_hsa, NULL, data,"}, {"sha": "3eff4e7f1e85ae7291f0606192616556e6c81bef", "filename": "gcc/omp-low.c", "status": "modified", "additions": 1145, "deletions": 414, "changes": 1559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -3349,8 +3349,8 @@ check_omp_nesting_restrictions (gimple *stmt, omp_context *ctx)\n       else if (gimple_code (ctx->stmt) == GIMPLE_OMP_TEAMS)\n \t{\n \t  if ((gimple_code (stmt) != GIMPLE_OMP_FOR\n-\t       || (gimple_omp_for_kind (stmt)\n-\t\t   != GF_OMP_FOR_KIND_DISTRIBUTE))\n+\t       || ((gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_DISTRIBUTE)\n+\t\t   && (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP)))\n \t      && gimple_code (stmt) != GIMPLE_OMP_PARALLEL)\n \t    {\n \t      error_at (gimple_location (stmt),\n@@ -5560,16 +5560,27 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n     {\n       gcond *stmt;\n       tree label_true, arm1, arm2;\n+      enum tree_code pred_code = TREE_CODE (predicate);\n \n       label = create_artificial_label (UNKNOWN_LOCATION);\n       label_true = create_artificial_label (UNKNOWN_LOCATION);\n-      arm1 = TREE_OPERAND (predicate, 0);\n-      arm2 = TREE_OPERAND (predicate, 1);\n-      gimplify_expr (&arm1, stmt_list, NULL, is_gimple_val, fb_rvalue);\n-      gimplify_expr (&arm2, stmt_list, NULL, is_gimple_val, fb_rvalue);\n+      if (TREE_CODE_CLASS (pred_code) == tcc_comparison)\n+\t{\n+\t  arm1 = TREE_OPERAND (predicate, 0);\n+\t  arm2 = TREE_OPERAND (predicate, 1);\n+\t  gimplify_expr (&arm1, stmt_list, NULL, is_gimple_val, fb_rvalue);\n+\t  gimplify_expr (&arm2, stmt_list, NULL, is_gimple_val, fb_rvalue);\n+\t}\n+      else\n+\t{\n+\t  arm1 = predicate;\n+\t  gimplify_expr (&arm1, stmt_list, NULL, is_gimple_val, fb_rvalue);\n+\t  arm2 = boolean_false_node;\n+\t  pred_code = NE_EXPR;\n+\t}\n       if (maybe_simt)\n \t{\n-\t  c = build2 (TREE_CODE (predicate), boolean_type_node, arm1, arm2);\n+\t  c = build2 (pred_code, boolean_type_node, arm1, arm2);\n \t  c = fold_convert (integer_type_node, c);\n \t  simtcond = create_tmp_var (integer_type_node);\n \t  gimplify_assign (simtcond, c, stmt_list);\n@@ -5582,8 +5593,7 @@ lower_lastprivate_clauses (tree clauses, tree predicate, gimple_seq *stmt_list,\n \t\t\t\t    label_true, label);\n \t}\n       else\n-\tstmt = gimple_build_cond (TREE_CODE (predicate), arm1, arm2,\n-\t\t\t\t  label_true, label);\n+\tstmt = gimple_build_cond (pred_code, arm1, arm2, label_true, label);\n       gimple_seq_add_stmt (stmt_list, stmt);\n       gimple_seq_add_stmt (stmt_list, gimple_build_label (label_true));\n     }\n@@ -13136,7 +13146,6 @@ grid_get_kernel_launch_attributes (gimple_stmt_iterator *gsi,\n \t\t\t\t   gomp_target *tgt_stmt)\n {\n   grid_create_kernel_launch_attr_types ();\n-  tree u32_one = build_one_cst (uint32_type_node);\n   tree lattrs = create_tmp_var (grid_attr_trees->kernel_launch_attributes_type,\n \t\t\t\t\"__kernel_launch_attrs\");\n \n@@ -13161,10 +13170,10 @@ grid_get_kernel_launch_attributes (gimple_stmt_iterator *gsi,\n \n   tree dimref = build3 (COMPONENT_REF, uint32_type_node, lattrs,\n \t\t\tgrid_attr_trees->kernel_lattrs_dimnum_decl, NULL_TREE);\n-  /* At this moment we cannot gridify a loop with a collapse clause.  */\n-  /* TODO: Adjust when we support bigger collapse.  */\n-  gcc_assert (max_dim == 0);\n-  gsi_insert_before (gsi, gimple_build_assign (dimref, u32_one), GSI_SAME_STMT);\n+  gcc_checking_assert (max_dim <= 2);\n+  tree dimensions = build_int_cstu (uint32_type_node, max_dim + 1);\n+  gsi_insert_before (gsi, gimple_build_assign (dimref, dimensions),\n+\t\t     GSI_SAME_STMT);\n   TREE_ADDRESSABLE (lattrs) = 1;\n   return build_fold_addr_expr (lattrs);\n }\n@@ -13810,59 +13819,79 @@ expand_omp_target (struct omp_region *region)\n     }\n }\n \n-/* Expand KFOR loop as a GPGPU kernel, i.e. as a body only with iteration\n-   variable derived from the thread number.  */\n+/* Expand KFOR loop as a HSA grifidied kernel, i.e. as a body only with\n+   iteration variable derived from the thread number.  INTRA_GROUP means this\n+   is an expansion of a loop iterating over work-items within a separate\n+   iteration over groups. */\n \n static void\n-grid_expand_omp_for_loop (struct omp_region *kfor)\n+grid_expand_omp_for_loop (struct omp_region *kfor, bool intra_group)\n {\n-  tree t, threadid;\n-  tree type, itype;\n   gimple_stmt_iterator gsi;\n-  tree n1, step;\n-  struct omp_for_data fd;\n-\n   gomp_for *for_stmt = as_a <gomp_for *> (last_stmt (kfor->entry));\n   gcc_checking_assert (gimple_omp_for_kind (for_stmt)\n \t\t       == GF_OMP_FOR_KIND_GRID_LOOP);\n+  size_t collapse = gimple_omp_for_collapse (for_stmt);\n+  struct omp_for_data_loop *loops\n+    = XALLOCAVEC (struct omp_for_data_loop,\n+                  gimple_omp_for_collapse (for_stmt));\n+  struct omp_for_data fd;\n+\n+  remove_edge (BRANCH_EDGE (kfor->entry));\n   basic_block body_bb = FALLTHRU_EDGE (kfor->entry)->dest;\n \n-  gcc_assert (gimple_omp_for_collapse (for_stmt) == 1);\n   gcc_assert (kfor->cont);\n-  extract_omp_for_data (for_stmt, &fd, NULL);\n-\n-  itype = type = TREE_TYPE (fd.loop.v);\n-  if (POINTER_TYPE_P (type))\n-    itype = signed_type_for (type);\n+  extract_omp_for_data (for_stmt, &fd, loops);\n \n   gsi = gsi_start_bb (body_bb);\n \n-  n1 = fd.loop.n1;\n-  step = fd.loop.step;\n-  n1 = force_gimple_operand_gsi (&gsi, fold_convert (type, n1),\n-\t\t\t\t true, NULL_TREE, true, GSI_SAME_STMT);\n-  step = force_gimple_operand_gsi (&gsi, fold_convert (itype, step),\n-\t\t\t\t   true, NULL_TREE, true, GSI_SAME_STMT);\n-  threadid = build_call_expr (builtin_decl_explicit\n-\t\t\t      (BUILT_IN_OMP_GET_THREAD_NUM), 0);\n-  threadid = fold_convert (itype, threadid);\n-  threadid = force_gimple_operand_gsi (&gsi, threadid, true, NULL_TREE,\n-\t\t\t\t       true, GSI_SAME_STMT);\n+  for (size_t dim = 0; dim < collapse; dim++)\n+    {\n+      tree type, itype;\n+      itype = type = TREE_TYPE (fd.loops[dim].v);\n+      if (POINTER_TYPE_P (type))\n+\titype = signed_type_for (type);\n \n-  tree startvar = fd.loop.v;\n-  t = fold_build2 (MULT_EXPR, itype, threadid, step);\n-  if (POINTER_TYPE_P (type))\n-    t = fold_build_pointer_plus (n1, t);\n-  else\n-    t = fold_build2 (PLUS_EXPR, type, t, n1);\n-  t = fold_convert (type, t);\n-  t = force_gimple_operand_gsi (&gsi, t,\n-\t\t\t\tDECL_P (startvar)\n-\t\t\t\t&& TREE_ADDRESSABLE (startvar),\n-\t\t\t\tNULL_TREE, true, GSI_SAME_STMT);\n-  gassign *assign_stmt = gimple_build_assign (startvar, t);\n-  gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+      tree n1 = fd.loops[dim].n1;\n+      tree step = fd.loops[dim].step;\n+      n1 = force_gimple_operand_gsi (&gsi, fold_convert (type, n1),\n+\t\t\t\t     true, NULL_TREE, true, GSI_SAME_STMT);\n+      step = force_gimple_operand_gsi (&gsi, fold_convert (itype, step),\n+\t\t\t\t       true, NULL_TREE, true, GSI_SAME_STMT);\n+      tree threadid;\n+      if (gimple_omp_for_grid_group_iter (for_stmt))\n+\t{\n+\t  gcc_checking_assert (!intra_group);\n+\t  threadid = build_call_expr (builtin_decl_explicit\n+\t\t\t\t      (BUILT_IN_HSA_WORKGROUPID), 1,\n+\t\t\t\t      build_int_cstu (unsigned_type_node, dim));\n+\t}\n+      else if (intra_group)\n+\tthreadid = build_call_expr (builtin_decl_explicit\n+\t\t\t\t    (BUILT_IN_HSA_WORKITEMID), 1,\n+\t\t\t\t    build_int_cstu (unsigned_type_node, dim));\n+      else\n+\tthreadid = build_call_expr (builtin_decl_explicit\n+\t\t\t\t    (BUILT_IN_HSA_WORKITEMABSID), 1,\n+\t\t\t\t    build_int_cstu (unsigned_type_node, dim));\n+      threadid = fold_convert (itype, threadid);\n+      threadid = force_gimple_operand_gsi (&gsi, threadid, true, NULL_TREE,\n+\t\t\t\t\t   true, GSI_SAME_STMT);\n \n+      tree startvar = fd.loops[dim].v;\n+      tree t = fold_build2 (MULT_EXPR, itype, threadid, step);\n+      if (POINTER_TYPE_P (type))\n+\tt = fold_build_pointer_plus (n1, t);\n+      else\n+\tt = fold_build2 (PLUS_EXPR, type, t, n1);\n+      t = fold_convert (type, t);\n+      t = force_gimple_operand_gsi (&gsi, t,\n+\t\t\t\t    DECL_P (startvar)\n+\t\t\t\t    && TREE_ADDRESSABLE (startvar),\n+\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n+      gassign *assign_stmt = gimple_build_assign (startvar, t);\n+      gsi_insert_before (&gsi, assign_stmt, GSI_SAME_STMT);\n+    }\n   /* Remove the omp for statement */\n   gsi = gsi_last_bb (kfor->entry);\n   gsi_remove (&gsi, true);\n@@ -13873,10 +13902,12 @@ grid_expand_omp_for_loop (struct omp_region *kfor)\n \t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_CONTINUE);\n   gsi_remove (&gsi, true);\n \n-  /* Replace the GIMPLE_OMP_RETURN with a real return.  */\n+  /* Replace the GIMPLE_OMP_RETURN with a barrier, if necessary.  */\n   gsi = gsi_last_bb (kfor->exit);\n   gcc_assert (!gsi_end_p (gsi)\n \t      && gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_RETURN);\n+  if (intra_group)\n+    gsi_insert_before (&gsi, build_omp_barrier (NULL_TREE), GSI_SAME_STMT);\n   gsi_remove (&gsi, true);\n \n   /* Fixup the much simpler CFG.  */\n@@ -13915,7 +13946,7 @@ grid_remap_kernel_arg_accesses (tree *tp, int *walk_subtrees, void *data)\n static void expand_omp (struct omp_region *region);\n \n /* If TARGET region contains a kernel body for loop, remove its region from the\n-   TARGET and expand it in GPGPU kernel fashion. */\n+   TARGET and expand it in HSA gridified kernel fashion. */\n \n static void\n grid_expand_target_grid_body (struct omp_region *target)\n@@ -13957,11 +13988,29 @@ grid_expand_target_grid_body (struct omp_region *target)\n \n   struct omp_region *kfor = *pp;\n   gcc_assert (kfor);\n-  gcc_assert (gimple_omp_for_kind (last_stmt ((kfor)->entry))\n-\t      == GF_OMP_FOR_KIND_GRID_LOOP);\n+  gomp_for *for_stmt = as_a <gomp_for *> (last_stmt (kfor->entry));\n+  gcc_assert (gimple_omp_for_kind (for_stmt) == GF_OMP_FOR_KIND_GRID_LOOP);\n   *pp = kfor->next;\n   if (kfor->inner)\n-    expand_omp (kfor->inner);\n+    {\n+      if (gimple_omp_for_grid_group_iter (for_stmt))\n+\t{\n+\t  struct omp_region **next_pp;\n+\t  for (pp = &kfor->inner; *pp; pp = next_pp)\n+\t    {\n+\t      next_pp = &(*pp)->next;\n+\t      if ((*pp)->type != GIMPLE_OMP_FOR)\n+\t\tcontinue;\n+\t      gomp_for *inner = as_a <gomp_for *> (last_stmt ((*pp)->entry));\n+\t      gcc_assert (gimple_omp_for_kind (inner)\n+\t\t\t  == GF_OMP_FOR_KIND_GRID_LOOP);\n+\t      grid_expand_omp_for_loop (*pp, true);\n+\t      *pp = (*pp)->next;\n+\t      next_pp = pp;\n+\t    }\n+\t}\n+      expand_omp (kfor->inner);\n+    }\n   if (gpukernel->inner)\n     expand_omp (gpukernel->inner);\n \n@@ -13991,8 +14040,7 @@ grid_expand_target_grid_body (struct omp_region *target)\n   struct function *kern_cfun = DECL_STRUCT_FUNCTION (kern_fndecl);\n   kern_cfun->curr_properties = cfun->curr_properties;\n \n-  remove_edge (BRANCH_EDGE (kfor->entry));\n-  grid_expand_omp_for_loop (kfor);\n+  grid_expand_omp_for_loop (kfor, false);\n \n   /* Remove the omp for statement */\n   gimple_stmt_iterator gsi = gsi_last_bb (gpukernel->entry);\n@@ -14351,7 +14399,7 @@ const pass_data pass_data_expand_omp =\n {\n   GIMPLE_PASS, /* type */\n   \"ompexp\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n+  OPTGROUP_OPENMP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_gimple_any, /* properties_required */\n   PROP_gimple_eomp, /* properties_provided */\n@@ -14398,7 +14446,7 @@ const pass_data pass_data_expand_omp_ssa =\n {\n   GIMPLE_PASS, /* type */\n   \"ompexpssa\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n+  OPTGROUP_OPENMP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_cfg | PROP_ssa, /* properties_required */\n   PROP_gimple_eomp, /* properties_provided */\n@@ -15267,6 +15315,46 @@ lower_omp_critical (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n   BLOCK_VARS (block) = gimple_bind_vars (bind);\n }\n \n+/* Return the lastprivate predicate for a given gridified loop described by FD).\n+   TODO: When grid stuff is moved to a separate file, move this too.  */\n+\n+static tree\n+grid_lastprivate_predicate (struct omp_for_data *fd)\n+{\n+  /* When dealing with a gridified loop, we need to check up to three collapsed\n+     iteration variables but they are not actually captured in this fd.\n+     Fortunately, we can easily rely on HSA builtins to get this\n+     information. */\n+\n+  tree id, size;\n+  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_GRID_LOOP\n+      && gimple_omp_for_grid_intra_group (fd->for_stmt))\n+    {\n+      id = builtin_decl_explicit (BUILT_IN_HSA_WORKITEMID);\n+      size = builtin_decl_explicit (BUILT_IN_HSA_CURRENTWORKGROUPSIZE);\n+    }\n+  else\n+    {\n+      id = builtin_decl_explicit (BUILT_IN_HSA_WORKITEMABSID);\n+      size = builtin_decl_explicit (BUILT_IN_HSA_GRIDSIZE);\n+    }\n+  tree cond = NULL;\n+  for (int dim = 0; dim < fd->collapse; dim++)\n+    {\n+      tree dim_tree = build_int_cstu (unsigned_type_node, dim);\n+      tree u1 = build_int_cstu (unsigned_type_node, 1);\n+      tree c2\n+\t= build2 (EQ_EXPR, boolean_type_node,\n+\t\t  build2 (PLUS_EXPR, unsigned_type_node,\n+\t\t\t  build_call_expr (id, 1, dim_tree), u1),\n+\t\t  build_call_expr (size, 1, dim_tree));\n+      if (cond)\n+\tcond = build2 (TRUTH_AND_EXPR, boolean_type_node, cond, c2);\n+      else\n+\tcond = c2;\n+    }\n+  return cond;\n+}\n \n /* A subroutine of lower_omp_for.  Generate code to emit the predicate\n    for a lastprivate clause.  Given a loop control predicate of (V\n@@ -15294,58 +15382,65 @@ lower_omp_for_lastprivate (struct omp_for_data *fd, gimple_seq *body_p,\n \tcond_code = EQ_EXPR;\n     }\n \n-  tree n2 = fd->loop.n2;\n-  if (fd->collapse > 1\n-      && TREE_CODE (n2) != INTEGER_CST\n-      && gimple_omp_for_combined_into_p (fd->for_stmt))\n+  if (gimple_omp_for_kind (fd->for_stmt) == GF_OMP_FOR_KIND_GRID_LOOP\n+      || gimple_omp_for_grid_phony (fd->for_stmt))\n+    cond = grid_lastprivate_predicate (fd);\n+  else\n     {\n-      struct omp_context *taskreg_ctx = NULL;\n-      if (gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n+      tree n2 = fd->loop.n2;\n+      if (fd->collapse > 1\n+\t  && TREE_CODE (n2) != INTEGER_CST\n+\t  && gimple_omp_for_combined_into_p (fd->for_stmt))\n \t{\n-\t  gomp_for *gfor = as_a <gomp_for *> (ctx->outer->stmt);\n-\t  if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_FOR\n-\t      || gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_DISTRIBUTE)\n+\t  struct omp_context *taskreg_ctx = NULL;\n+\t  if (gimple_code (ctx->outer->stmt) == GIMPLE_OMP_FOR)\n \t    {\n-\t      if (gimple_omp_for_combined_into_p (gfor))\n-\t\t{\n-\t\t  gcc_assert (ctx->outer->outer\n-\t\t\t      && is_parallel_ctx (ctx->outer->outer));\n-\t\t  taskreg_ctx = ctx->outer->outer;\n-\t\t}\n-\t      else\n+\t      gomp_for *gfor = as_a <gomp_for *> (ctx->outer->stmt);\n+\t      if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_FOR\n+\t\t  || gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_DISTRIBUTE)\n \t\t{\n-\t\t  struct omp_for_data outer_fd;\n-\t\t  extract_omp_for_data (gfor, &outer_fd, NULL);\n-\t\t  n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);\n+\t\t  if (gimple_omp_for_combined_into_p (gfor))\n+\t\t    {\n+\t\t      gcc_assert (ctx->outer->outer\n+\t\t\t\t  && is_parallel_ctx (ctx->outer->outer));\n+\t\t      taskreg_ctx = ctx->outer->outer;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      struct omp_for_data outer_fd;\n+\t\t      extract_omp_for_data (gfor, &outer_fd, NULL);\n+\t\t      n2 = fold_convert (TREE_TYPE (n2), outer_fd.loop.n2);\n+\t\t    }\n \t\t}\n+\t      else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP)\n+\t\ttaskreg_ctx = ctx->outer->outer;\n \t    }\n-\t  else if (gimple_omp_for_kind (gfor) == GF_OMP_FOR_KIND_TASKLOOP)\n-\t    taskreg_ctx = ctx->outer->outer;\n-\t}\n-      else if (is_taskreg_ctx (ctx->outer))\n-\ttaskreg_ctx = ctx->outer;\n-      if (taskreg_ctx)\n-\t{\n-\t  int i;\n-\t  tree innerc\n-\t    = find_omp_clause (gimple_omp_taskreg_clauses (taskreg_ctx->stmt),\n-\t\t\t       OMP_CLAUSE__LOOPTEMP_);\n-\t  gcc_assert (innerc);\n-\t  for (i = 0; i < fd->collapse; i++)\n+\t  else if (is_taskreg_ctx (ctx->outer))\n+\t    taskreg_ctx = ctx->outer;\n+\t  if (taskreg_ctx)\n \t    {\n+\t      int i;\n+\t      tree taskreg_clauses\n+\t\t= gimple_omp_taskreg_clauses (taskreg_ctx->stmt);\n+\t      tree innerc = find_omp_clause (taskreg_clauses,\n+\t\t\t\t\t     OMP_CLAUSE__LOOPTEMP_);\n+\t      gcc_assert (innerc);\n+\t      for (i = 0; i < fd->collapse; i++)\n+\t\t{\n+\t\t  innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n+\t\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n+\t\t  gcc_assert (innerc);\n+\t\t}\n \t      innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n \t\t\t\t\tOMP_CLAUSE__LOOPTEMP_);\n-\t      gcc_assert (innerc);\n+\t      if (innerc)\n+\t\tn2 = fold_convert (TREE_TYPE (n2),\n+\t\t\t\t   lookup_decl (OMP_CLAUSE_DECL (innerc),\n+\t\t\t\t\t\ttaskreg_ctx));\n \t    }\n-\t  innerc = find_omp_clause (OMP_CLAUSE_CHAIN (innerc),\n-\t\t\t\t    OMP_CLAUSE__LOOPTEMP_);\n-\t  if (innerc)\n-\t    n2 = fold_convert (TREE_TYPE (n2),\n-\t\t\t       lookup_decl (OMP_CLAUSE_DECL (innerc),\n-\t\t\t\t\t    taskreg_ctx));\n \t}\n+      cond = build2 (cond_code, boolean_type_node, fd->loop.v, n2);\n     }\n-  cond = build2 (cond_code, boolean_type_node, fd->loop.v, n2);\n \n   clauses = gimple_omp_for_clauses (fd->for_stmt);\n   stmts = NULL;\n@@ -15514,11 +15609,13 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t\t\t\t\t\tctx);\n \t}\n \n-  if (!gimple_omp_for_grid_phony (stmt))\n+  bool phony_loop = (gimple_omp_for_kind (stmt) != GF_OMP_FOR_KIND_GRID_LOOP\n+\t\t     && gimple_omp_for_grid_phony (stmt));\n+  if (!phony_loop)\n     gimple_seq_add_stmt (&body, stmt);\n   gimple_seq_add_seq (&body, gimple_omp_body (stmt));\n \n-  if (!gimple_omp_for_grid_phony (stmt))\n+  if (!phony_loop)\n     gimple_seq_add_stmt (&body, gimple_build_omp_continue (fd.loop.v,\n \t\t\t\t\t\t\t   fd.loop.v));\n \n@@ -15532,7 +15629,7 @@ lower_omp_for (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \n   body = maybe_catch_exception (body);\n \n-  if (!gimple_omp_for_grid_phony (stmt))\n+  if (!phony_loop)\n     {\n       /* Region exit marker goes at the end of the loop body.  */\n       gimple_seq_add_stmt (&body, gimple_build_omp_return (fd.have_nowait));\n@@ -17516,116 +17613,157 @@ lower_omp (gimple_seq *body, omp_context *ctx)\n   input_location = saved_location;\n }\n \n-/* Returen true if STMT is an assignment of a register-type into a local\n-   VAR_DECL.  */\n+/* Structure describing the basic properties of the loop we ara analyzing\n+   whether it can be gridified and when it is gridified. */\n+\n+struct grid_prop\n+{\n+  /* True when we are doing tiling gridification, i.e. when there is a distinct\n+     distribute loop over groups and a loop construct over work-items.  False\n+     when distribute and parallel for loops form a combined construct.  */\n+  bool tiling;\n+  /* Location of the target construct for optimization information\n+     messages.  */\n+  location_t target_loc;\n+  /* The collapse clause of the involved loops.  Collapse value of all of them\n+     must be the same for gridification to take place.  */\n+  size_t collapse;\n+  /* Group sizes, if requested by the user or NULL if not requested.  */\n+  tree group_sizes[3];\n+};\n+\n+#define GRID_MISSED_MSG_PREFIX \"Will not turn target construct into a \" \\\n+  \"gridified HSA kernel because \"\n+\n+/* Return true if STMT is an assignment of a register-type into a local\n+   VAR_DECL.  If GRID is non-NULL, the assignment additionally must not be to\n+   any of the trees specifying group sizes there.  */\n \n static bool\n-grid_reg_assignment_to_local_var_p (gimple *stmt)\n+grid_safe_assignment_p (gimple *stmt, grid_prop *grid)\n {\n   gassign *assign = dyn_cast <gassign *> (stmt);\n   if (!assign)\n     return false;\n+  if (gimple_clobber_p (assign))\n+    return true;\n   tree lhs = gimple_assign_lhs (assign);\n   if (!VAR_P (lhs)\n       || !is_gimple_reg_type (TREE_TYPE (lhs))\n       || is_global_var (lhs))\n     return false;\n+  if (grid)\n+    for (unsigned i = 0; i < grid->collapse; i++)\n+      if (lhs == grid->group_sizes[i])\n+\treturn false;\n   return true;\n }\n \n /* Return true if all statements in SEQ are assignments to local register-type\n-   variables.  */\n+   variables that do not hold group size information.  */\n \n static bool\n-grid_seq_only_contains_local_assignments (gimple_seq seq)\n+grid_seq_only_contains_local_assignments (gimple_seq seq, grid_prop *grid)\n {\n   if (!seq)\n     return true;\n \n   gimple_stmt_iterator gsi;\n   for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (!grid_reg_assignment_to_local_var_p (gsi_stmt (gsi)))\n+    if (!grid_safe_assignment_p (gsi_stmt (gsi), grid))\n       return false;\n   return true;\n }\n \n-/* Scan statements in SEQ and call itself recursively on any bind.  If during\n-   whole search only assignments to register-type local variables and one\n-   single OMP statement is encountered, return true, otherwise return false.\n-   RET is where we store any OMP statement encountered.  TARGET_LOC and NAME\n-   are used for dumping a note about a failure.  */\n+/* Scan statements in SEQ and call itself recursively on any bind.  GRID\n+   describes hitherto discovered properties of the loop that is evaluated for\n+   possible gridification.  If during whole search only assignments to\n+   register-type local variables (that do not overwrite group size information)\n+   and one single OMP statement is encountered, return true, otherwise return\n+   false.  RET is where we store any OMP statement encountered.  */\n \n static bool\n-grid_find_single_omp_among_assignments_1 (gimple_seq seq, location_t target_loc,\n-\t\t\t\t     const char *name, gimple **ret)\n+grid_find_single_omp_among_assignments_1 (gimple_seq seq, grid_prop *grid,\n+\t\t\t\t\t  const char *name, gimple **ret)\n {\n   gimple_stmt_iterator gsi;\n   for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple *stmt = gsi_stmt (gsi);\n \n-      if (grid_reg_assignment_to_local_var_p (stmt))\n+      if (grid_safe_assignment_p (stmt, grid))\n \tcontinue;\n       if (gbind *bind = dyn_cast <gbind *> (stmt))\n \t{\n \t  if (!grid_find_single_omp_among_assignments_1 (gimple_bind_body (bind),\n-\t\t\t\t\t\t\t target_loc, name, ret))\n+\t\t\t\t\t\t\t grid, name, ret))\n \t      return false;\n \t}\n       else if (is_gimple_omp (stmt))\n \t{\n \t  if (*ret)\n \t    {\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, target_loc,\n-\t\t\t\t \"Will not turn target construct into a simple \"\n-\t\t\t\t \"GPGPU kernel because %s construct contains \"\n-\t\t\t\t \"multiple OpenMP constructs\\n\", name);\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t\t   GRID_MISSED_MSG_PREFIX \"%s construct \"\n+\t\t\t\t   \"contains multiple OpenMP constructs\\n\",\n+\t\t\t\t   name);\n+\t\t  dump_printf_loc (MSG_NOTE, gimple_location (*ret),\n+\t\t\t\t   \"The first OpenMP construct within \"\n+\t\t\t\t   \"a parallel\\n\");\n+\t\t  dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t\t\t   \"The second OpenMP construct within \"\n+\t\t\t\t   \"a parallel\\n\");\n+\t\t}\n \t      return false;\n \t    }\n \t  *ret = stmt;\n \t}\n       else\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, target_loc,\n-\t\t\t     \"Will not turn target construct into a simple \"\n-\t\t\t     \"GPGPU kernel because %s construct contains \"\n-\t\t\t     \"a complex statement\\n\", name);\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"%s construct contains \"\n+\t\t\t       \"a complex statement\\n\", name);\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t\t       \"This statement cannot be analyzed for \"\n+\t\t\t       \"gridification\\n\");\n+\t    }\n \t  return false;\n \t}\n     }\n   return true;\n }\n \n /* Scan statements in SEQ and make sure that it and any binds in it contain\n-   only assignments to local register-type variables and one OMP construct.  If\n-   so, return that construct, otherwise return NULL.  If dumping is enabled and\n-   function fails, use TARGET_LOC and NAME to dump a note with the reason for\n-   failure.  */\n+   only assignments to local register-type variables (that do not overwrite\n+   group size information) and one OMP construct.  If so, return that\n+   construct, otherwise return NULL.  GRID describes hitherto discovered\n+   properties of the loop that is evaluated for possible gridification.  If\n+   dumping is enabled and function fails, use NAME to dump a note with the\n+   reason for failure.  */\n \n static gimple *\n-grid_find_single_omp_among_assignments (gimple_seq seq, location_t target_loc,\n+grid_find_single_omp_among_assignments (gimple_seq seq, grid_prop *grid,\n \t\t\t\t\tconst char *name)\n {\n   if (!seq)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, target_loc,\n-\t\t\t \"Will not turn target construct into a simple \"\n-\t\t\t \"GPGPU kernel because %s construct has empty \"\n-\t\t\t \"body\\n\",\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t GRID_MISSED_MSG_PREFIX \"%s construct has empty body\\n\",\n \t\t\t name);\n       return NULL;\n     }\n \n   gimple *ret = NULL;\n-  if (grid_find_single_omp_among_assignments_1 (seq, target_loc, name, &ret))\n+  if (grid_find_single_omp_among_assignments_1 (seq, grid, name, &ret))\n     {\n       if (!ret && dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, target_loc,\n-\t\t\t \"Will not turn target construct into a simple \"\n-\t\t\t \"GPGPU kernel because %s construct does not contain\"\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t GRID_MISSED_MSG_PREFIX \"%s construct does not contain\"\n \t\t\t \"any other OpenMP construct\\n\", name);\n       return ret;\n     }\n@@ -17668,218 +17806,81 @@ grid_find_ungridifiable_statement (gimple_stmt_iterator *gsi,\n       *handled_ops_p = true;\n       wi->info = stmt;\n       return error_mark_node;\n-\n-    case GIMPLE_OMP_FOR:\n-      if ((gimple_omp_for_kind (stmt) & GF_OMP_FOR_SIMD)\n-\t  && gimple_omp_for_combined_into_p (stmt))\n-\t{\n-\t  *handled_ops_p = true;\n-\t  wi->info = stmt;\n-\t  return error_mark_node;\n-\t}\n-      break;\n-\n     default:\n       break;\n     }\n   return NULL;\n }\n \n-\n-/* If TARGET follows a pattern that can be turned into a gridified GPGPU\n-   kernel, return true, otherwise return false.  In the case of success, also\n-   fill in GROUP_SIZE_P with the requested group size or NULL if there is\n-   none.  */\n+/* Examine clauses of omp parallel statement PAR and if any prevents\n+   gridification, issue a missed-optimization diagnostics and return false,\n+   otherwise return true.  GRID describes hitherto discovered properties of the\n+   loop that is evaluated for possible gridification.  */\n \n static bool\n-grid_target_follows_gridifiable_pattern (gomp_target *target, tree *group_size_p)\n+grid_parallel_clauses_gridifiable (gomp_parallel *par, location_t tloc)\n {\n-  if (gimple_omp_target_kind (target) != GF_OMP_TARGET_KIND_REGION)\n-    return false;\n-\n-  location_t tloc = gimple_location (target);\n-  gimple *stmt\n-    = grid_find_single_omp_among_assignments (gimple_omp_body (target),\n-\t\t\t\t\t      tloc, \"target\");\n-  if (!stmt)\n-    return false;\n-  gomp_teams *teams = dyn_cast <gomp_teams *> (stmt);\n-  tree group_size = NULL;\n-  if (!teams)\n-    {\n-      dump_printf_loc (MSG_NOTE, tloc,\n-\t\t       \"Will not turn target construct into a simple \"\n-\t\t       \"GPGPU kernel because it does not have a sole teams \"\n-\t\t       \"construct in it.\\n\");\n-      return false;\n-    }\n-\n-  tree clauses = gimple_omp_teams_clauses (teams);\n+  tree clauses = gimple_omp_parallel_clauses (par);\n   while (clauses)\n     {\n       switch (OMP_CLAUSE_CODE (clauses))\n \t{\n-\tcase OMP_CLAUSE_NUM_TEAMS:\n+\tcase OMP_CLAUSE_NUM_THREADS:\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because we cannot \"\n-\t\t\t     \"handle num_teams clause of teams \"\n-\t\t\t     \"construct\\n \");\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"because there is \"\n+\t\t\t       \"a num_threads clause of the parallel \"\n+\t\t\t       \"construct\\n\");\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (par),\n+\t\t\t       \"Parallel construct has a num_threads clause\\n\");\n+\t    }\n \t  return false;\n \n \tcase OMP_CLAUSE_REDUCTION:\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because a reduction \"\n-\t\t\t     \"clause is present\\n \");\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because a lastprivate \"\n-\t\t\t     \"clause is present\\n \");\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"a reduction clause\"\n+\t\t\t       \"is present\\n \");\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (par),\n+\t\t\t       \"Parallel construct has a reduction clause\\n\");\n+\t    }\n \t  return false;\n \n-\tcase OMP_CLAUSE_THREAD_LIMIT:\n-\t  group_size = OMP_CLAUSE_OPERAND (clauses, 0);\n-\t  break;\n-\n \tdefault:\n \t  break;\n \t}\n       clauses = OMP_CLAUSE_CHAIN (clauses);\n     }\n+  return true;\n+}\n \n-  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (teams), tloc,\n-\t\t\t\t\t\t \"teams\");\n-  if (!stmt)\n-    return false;\n-  gomp_for *dist = dyn_cast <gomp_for *> (stmt);\n-  if (!dist)\n-    {\n-      dump_printf_loc (MSG_NOTE, tloc,\n-\t\t       \"Will not turn target construct into a simple \"\n-\t\t       \"GPGPU kernel because the teams construct  does not have \"\n-\t\t       \"a sole distribute construct in it.\\n\");\n-      return false;\n-    }\n+/* Examine clauses and the body of omp loop statement GFOR and if something\n+   prevents gridification, issue a missed-optimization diagnostics and return\n+   false, otherwise return true. GRID describes hitherto discovered properties\n+   of the loop that is evaluated for possible gridification.  */\n \n-  gcc_assert (gimple_omp_for_kind (dist) == GF_OMP_FOR_KIND_DISTRIBUTE);\n-  if (!gimple_omp_for_combined_p (dist))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t \"Will not turn target construct into a gridified GPGPU \"\n-\t\t\t \"kernel because we cannot handle a standalone \"\n-\t\t\t \"distribute construct\\n \");\n-      return false;\n-    }\n-  if (dist->collapse > 1)\n+static bool\n+grid_inner_loop_gridifiable_p (gomp_for *gfor, grid_prop *grid)\n+{\n+  if (!grid_seq_only_contains_local_assignments (gimple_omp_for_pre_body (gfor),\n+\t\t\t\t\t\t grid))\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t \"Will not turn target construct into a gridified GPGPU \"\n-\t\t\t \"kernel because the distribute construct contains \"\n-\t\t\t \"collapse clause\\n\");\n-      return false;\n-    }\n-  struct omp_for_data fd;\n-  extract_omp_for_data (dist, &fd, NULL);\n-  if (fd.chunk_size)\n-    {\n-      if (group_size && !operand_equal_p (group_size, fd.chunk_size, 0))\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because the teams \"\n-\t\t\t     \"thread limit is different from distribute \"\n-\t\t\t     \"schedule chunk\\n\");\n-\t  return false;\n-\t}\n-      group_size = fd.chunk_size;\n-    }\n-  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (dist), tloc,\n-\t\t\t\t\t\t \"distribute\");\n-  gomp_parallel *par;\n-  if (!stmt || !(par = dyn_cast <gomp_parallel *> (stmt)))\n-    return false;\n-\n-  clauses = gimple_omp_parallel_clauses (par);\n-  while (clauses)\n-    {\n-      switch (OMP_CLAUSE_CODE (clauses))\n-\t{\n-\tcase OMP_CLAUSE_NUM_THREADS:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a gridified\"\n-\t\t\t     \"GPGPU kernel because there is a num_threads \"\n-\t\t\t     \"clause of the parallel construct\\n\");\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_REDUCTION:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because a reduction \"\n-\t\t\t     \"clause is present\\n \");\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because a lastprivate \"\n-\t\t\t     \"clause is present\\n \");\n-\t  return false;\n-\n-\tdefault:\n-\t  break;\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t   GRID_MISSED_MSG_PREFIX \"the inner loop \"\n+\t\t\t   \"loop bounds computation contains a complex \"\n+\t\t\t   \"statement\\n\");\n+\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t\t   \"Loop construct cannot be analyzed for \"\n+\t\t\t   \"gridification\\n\");\n \t}\n-      clauses = OMP_CLAUSE_CHAIN (clauses);\n-    }\n-\n-  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (par), tloc,\n-\t\t\t\t\t\t \"parallel\");\n-  gomp_for *gfor;\n-  if (!stmt || !(gfor = dyn_cast <gomp_for *> (stmt)))\n-    return false;\n-\n-  if (gimple_omp_for_kind (gfor) != GF_OMP_FOR_KIND_FOR)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t \"Will not turn target construct into a gridified GPGPU \"\n-\t\t\t \"kernel because the inner loop is not a simple for \"\n-\t\t\t \"loop\\n\");\n-      return false;\n-    }\n-  if (gfor->collapse > 1)\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t \"Will not turn target construct into a gridified GPGPU \"\n-\t\t\t \"kernel because the inner loop contains collapse \"\n-\t\t\t \"clause\\n\");\n-      return false;\n-    }\n-\n-  if (!grid_seq_only_contains_local_assignments (gimple_omp_for_pre_body (gfor)))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t \"Will not turn target construct into a gridified GPGPU \"\n-\t\t\t \"kernel because the inner loop pre_body contains\"\n-\t\t\t \"a complex instruction\\n\");\n       return false;\n     }\n \n-  clauses = gimple_omp_for_clauses (gfor);\n+  tree clauses = gimple_omp_for_clauses (gfor);\n   while (clauses)\n     {\n       switch (OMP_CLAUSE_CODE (clauses))\n@@ -17888,36 +17889,35 @@ grid_target_follows_gridifiable_pattern (gomp_target *target, tree *group_size_p\n \t  if (OMP_CLAUSE_SCHEDULE_KIND (clauses) != OMP_CLAUSE_SCHEDULE_AUTO)\n \t    {\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t\t \"Will not turn target construct into a \"\n-\t\t\t\t \"gridified GPGPU kernel because the inner \"\n-\t\t\t\t \"loop has a non-automatic scheduling clause\\n\");\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t\t   GRID_MISSED_MSG_PREFIX \"the inner loop \"\n+\t\t\t\t   \"has a non-automatic schedule clause\\n\");\n+\t\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t\t\t   \"Loop construct has a non automatic \"\n+\t\t\t\t   \"schedule clause\\n\");\n+\t\t}\n \t      return false;\n \t    }\n \t  break;\n \n \tcase OMP_CLAUSE_REDUCTION:\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because a reduction \"\n-\t\t\t     \"clause is present\\n \");\n-\t  return false;\n-\n-\tcase OMP_CLAUSE_LASTPRIVATE:\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a \"\n-\t\t\t     \"gridified GPGPU kernel because a lastprivate \"\n-\t\t\t     \"clause is present\\n \");\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"a reduction \"\n+\t\t\t       \"clause is present\\n \");\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t\t       \"Loop construct has a reduction schedule \"\n+\t\t\t       \"clause\\n\");\n+\t    }\n \t  return false;\n \n \tdefault:\n \t  break;\n \t}\n       clauses = OMP_CLAUSE_CHAIN (clauses);\n     }\n-\n   struct walk_stmt_info wi;\n   memset (&wi, 0, sizeof (wi));\n   if (walk_gimple_seq (gimple_omp_body (gfor),\n@@ -17928,62 +17928,560 @@ grid_target_follows_gridifiable_pattern (gomp_target *target, tree *group_size_p\n       if (dump_enabled_p ())\n \t{\n \t  if (is_gimple_call (bad))\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a gridified \"\n-\t\t\t     \" GPGPU kernel because the inner loop contains \"\n-\t\t\t     \"call to a noreturn function\\n\");\n-\t  if (gimple_code (bad) == GIMPLE_OMP_FOR)\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a gridified \"\n-\t\t\t     \" GPGPU kernel because the inner loop contains \"\n-\t\t\t     \"a simd construct\\n\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"the inner loop contains \"\n+\t\t\t       \"call to a noreturn function\\n\");\n \t  else\n-\t    dump_printf_loc (MSG_NOTE, tloc,\n-\t\t\t     \"Will not turn target construct into a gridified \"\n-\t\t\t     \"GPGPU kernel because the inner loop contains \"\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t     GRID_MISSED_MSG_PREFIX \"the inner loop contains \"\n \t\t\t     \"statement %s which cannot be transformed\\n\",\n \t\t\t     gimple_code_name[(int) gimple_code (bad)]);\n+\t  dump_printf_loc (MSG_NOTE, gimple_location (bad),\n+\t\t\t   \"This statement cannot be analyzed for \"\n+\t\t\t   \"gridification\\n\");\n \t}\n       return false;\n     }\n-\n-  *group_size_p = group_size;\n   return true;\n }\n \n-/* Operand walker, used to remap pre-body declarations according to a hash map\n-   provided in DATA.  */\n+/* Given distribute omp construct represented by DIST, which in the original\n+   source forms a compound construct with a looping construct, return true if it\n+   can be turned into a gridified HSA kernel.  Otherwise return false. GRID\n+   describes hitherto discovered properties of the loop that is evaluated for\n+   possible gridification.  */\n \n-static tree\n-grid_remap_prebody_decls (tree *tp, int *walk_subtrees, void *data)\n+static bool\n+grid_dist_follows_simple_pattern (gomp_for *dist, grid_prop *grid)\n {\n-  tree t = *tp;\n+  location_t tloc = grid->target_loc;\n+  gimple *stmt = grid_find_single_omp_among_assignments (gimple_omp_body (dist),\n+\t\t\t\t\t\t\t grid, \"distribute\");\n+  gomp_parallel *par;\n+  if (!stmt\n+      || !(par = dyn_cast <gomp_parallel *> (stmt))\n+      || !grid_parallel_clauses_gridifiable (par, tloc))\n+    return false;\n \n-  if (DECL_P (t) || TYPE_P (t))\n-    *walk_subtrees = 0;\n-  else\n-    *walk_subtrees = 1;\n+  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (par), grid,\n+\t\t\t\t\t\t \"parallel\");\n+  gomp_for *gfor;\n+  if (!stmt || !(gfor = dyn_cast <gomp_for *> (stmt)))\n+    return false;\n \n-  if (VAR_P (t))\n+  if (gimple_omp_for_kind (gfor) != GF_OMP_FOR_KIND_FOR)\n     {\n-      struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n-      hash_map<tree, tree> *declmap = (hash_map<tree, tree> *) wi->info;\n-      tree *repl = declmap->get (t);\n-      if (repl)\n-\t*tp = *repl;\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t GRID_MISSED_MSG_PREFIX \"the inner loop is not \"\n+\t\t\t \"a simple for loop\\n\");\n+      return false;\n     }\n-  return NULL_TREE;\n+  gcc_assert (gimple_omp_for_collapse (gfor) == grid->collapse);\n+\n+  if (!grid_inner_loop_gridifiable_p (gfor, grid))\n+    return false;\n+\n+  return true;\n }\n \n-/* Copy leading register-type assignments to local variables in SRC to just\n-   before DST, Creating temporaries, adjusting mapping of operands in WI and\n-   remapping operands as necessary.  Add any new temporaries to TGT_BIND.\n-   Return the first statement that does not conform to\n-   grid_reg_assignment_to_local_var_p or NULL.  */\n+/* Given an omp loop statement GFOR, return true if it can participate in\n+   tiling gridification, i.e. in one where the distribute and parallel for\n+   loops do not form a compound statement.  GRID describes hitherto discovered\n+   properties of the loop that is evaluated for possible gridification. */\n \n-static gimple *\n+static bool\n+grid_gfor_follows_tiling_pattern (gomp_for *gfor, grid_prop *grid)\n+{\n+  if (gimple_omp_for_kind (gfor) != GF_OMP_FOR_KIND_FOR)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t   GRID_MISSED_MSG_PREFIX \"an inner loop is not \"\n+\t\t\t   \"a simple for loop\\n\");\n+\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t\t   \"This statement is not a simple for loop\\n\");\n+\t}\n+      return false;\n+    }\n+\n+  if (!grid_inner_loop_gridifiable_p (gfor, grid))\n+    return false;\n+\n+  if (gimple_omp_for_collapse (gfor) != grid->collapse)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t   GRID_MISSED_MSG_PREFIX \"an inner loop does not \"\n+\t\t\t   \"have use the same collapse clause\\n\");\n+\t  dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t\t   \"Loop construct uses a different collapse clause\\n\");\n+\t}\n+      return false;\n+    }\n+\n+  struct omp_for_data fd;\n+  struct omp_for_data_loop *loops\n+    = (struct omp_for_data_loop *)alloca (grid->collapse\n+\t\t\t\t\t  * sizeof (struct omp_for_data_loop));\n+  extract_omp_for_data (gfor, &fd, loops);\n+  for (unsigned i = 0; i < grid->collapse; i++)\n+    {\n+      tree itype, type = TREE_TYPE (fd.loops[i].v);\n+      if (POINTER_TYPE_P (type))\n+\titype = signed_type_for (type);\n+      else\n+\titype = type;\n+\n+      tree n1 = fold_convert (itype, fd.loops[i].n1);\n+      tree n2 = fold_convert (itype, fd.loops[i].n2);\n+      tree t = build_int_cst (itype,\n+\t\t\t      (fd.loops[i].cond_code == LT_EXPR ? -1 : 1));\n+      t = fold_build2 (PLUS_EXPR, itype, fd.loops[i].step, t);\n+      t = fold_build2 (PLUS_EXPR, itype, t, n2);\n+      t = fold_build2 (MINUS_EXPR, itype, t, n1);\n+      if (TYPE_UNSIGNED (itype) && fd.loops[i].cond_code == GT_EXPR)\n+\tt = fold_build2 (TRUNC_DIV_EXPR, itype,\n+\t\t\t fold_build1 (NEGATE_EXPR, itype, t),\n+\t\t\t fold_build1 (NEGATE_EXPR, itype, fd.loops[i].step));\n+      else\n+\tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, fd.loops[i].step);\n+\n+      if (!operand_equal_p (grid->group_sizes[i], t, 0))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute and \"\n+\t\t\t       \"an internal loop do not agree on tile size\\n\");\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (gfor),\n+\t\t\t       \"Loop construct does not seem to loop over \"\n+\t\t\t       \"a tile size\\n\");\n+\t    }\n+\t  return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Facing a call to FNDECL in the body of a distribute construct, return true\n+   if we can handle it or false if it precludes gridification.  */\n+\n+static bool\n+grid_call_permissible_in_distribute_p (tree fndecl)\n+{\n+  if (DECL_PURE_P (fndecl) || TREE_READONLY (fndecl))\n+    return true;\n+\n+  const char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+  if (strstr (name, \"omp_\") != name)\n+    return false;\n+\n+  if ((strcmp (name, \"omp_get_thread_num\") == 0)\n+      || (strcmp (name, \"omp_get_num_threads\") == 0)\n+      || (strcmp (name, \"omp_get_num_teams\") == 0)\n+      || (strcmp (name, \"omp_get_team_num\") == 0)\n+      || (strcmp (name, \"omp_get_level\") == 0)\n+      || (strcmp (name, \"omp_get_active_level\") == 0)\n+      || (strcmp (name, \"omp_in_parallel\") == 0))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Facing a call satisfying grid_call_permissible_in_distribute_p in the body\n+   of a distribute construct that is pointed at by GSI, modify it as necessary\n+   for gridification.  If the statement itself got removed, return true.  */\n+\n+static bool\n+grid_handle_call_in_distribute (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  tree fndecl = gimple_call_fndecl (stmt);\n+  gcc_checking_assert (stmt);\n+  if (DECL_PURE_P (fndecl) || TREE_READONLY (fndecl))\n+    return false;\n+\n+  const char *name = IDENTIFIER_POINTER (DECL_NAME (fndecl));\n+  if ((strcmp (name, \"omp_get_thread_num\") == 0)\n+      || (strcmp (name, \"omp_get_level\") == 0)\n+      || (strcmp (name, \"omp_get_active_level\") == 0)\n+      || (strcmp (name, \"omp_in_parallel\") == 0))\n+    {\n+      tree lhs = gimple_call_lhs (stmt);\n+      if (lhs)\n+\t{\n+\t  gassign *assign\n+\t    = gimple_build_assign (lhs, build_zero_cst (TREE_TYPE (lhs)));\n+\t  gsi_insert_before (gsi, assign, GSI_SAME_STMT);\n+\t}\n+      gsi_remove (gsi, true);\n+      return true;\n+    }\n+\n+  /* The rest of the omp functions can stay as they are, HSA back-end will\n+     handle them correctly.  */\n+  gcc_checking_assert ((strcmp (name, \"omp_get_num_threads\") == 0)\n+\t\t       || (strcmp (name, \"omp_get_num_teams\") == 0)\n+\t\t       || (strcmp (name, \"omp_get_team_num\") == 0));\n+  return false;\n+}\n+\n+/* Given a sequence of statements within a distribute omp construct or a\n+   parallel construct, which in the original source does not form a compound\n+   construct with a looping construct, return true if it does not prevent us\n+   from turning it into a gridified HSA kernel.  Otherwise return false. GRID\n+   describes hitherto discovered properties of the loop that is evaluated for\n+   possible gridification.  IN_PARALLEL must be true if seq is within a\n+   parallel construct and flase if it is only within a distribute\n+   construct.  */\n+\n+static bool\n+grid_dist_follows_tiling_pattern (gimple_seq seq, grid_prop *grid,\n+\t\t\t\t  bool in_parallel)\n+{\n+  gimple_stmt_iterator gsi;\n+  for (gsi = gsi_start (seq); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      if (grid_safe_assignment_p (stmt, grid)\n+\t  || gimple_code (stmt) == GIMPLE_GOTO\n+\t  || gimple_code (stmt) == GIMPLE_LABEL\n+\t  || gimple_code (stmt) == GIMPLE_COND)\n+\tcontinue;\n+      else if (gbind *bind = dyn_cast <gbind *> (stmt))\n+\t{\n+\t  if (!grid_dist_follows_tiling_pattern (gimple_bind_body (bind),\n+\t\t\t\t\t\t grid, in_parallel))\n+\t    return false;\n+\t  continue;\n+\t}\n+      else if (gtry *try_stmt = dyn_cast <gtry *> (stmt))\n+\t{\n+\t  if (gimple_try_kind (try_stmt) == GIMPLE_TRY_CATCH)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t\t   GRID_MISSED_MSG_PREFIX \"the distribute \"\n+\t\t\t\t   \"construct contains a try..catch region\\n\");\n+\t\t  dump_printf_loc (MSG_NOTE, gimple_location (try_stmt),\n+\t\t\t\t   \"This statement cannot be analyzed for \"\n+\t\t\t\t   \"tiled gridification\\n\");\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  if (!grid_dist_follows_tiling_pattern (gimple_try_eval (try_stmt),\n+\t\t\t\t\t\t grid, in_parallel))\n+\t    return false;\n+\t  if (!grid_dist_follows_tiling_pattern (gimple_try_cleanup (try_stmt),\n+\t\t\t\t\t\t grid, in_parallel))\n+\t    return false;\n+\t  continue;\n+\t}\n+      else if (is_gimple_call (stmt))\n+\t{\n+\t  tree fndecl = gimple_call_fndecl (stmt);\n+\t  if (fndecl && grid_call_permissible_in_distribute_p (fndecl))\n+\t    continue;\n+\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute \"\n+\t\t\t       \"construct contains a call\\n\");\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t\t       \"This statement cannot be analyzed for \"\n+\t\t\t       \"tiled gridification\\n\");\n+\t    }\n+\t  return false;\n+\t}\n+      else if (gomp_parallel *par = dyn_cast <gomp_parallel *> (stmt))\n+\t{\n+\t  if (in_parallel)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t\t   GRID_MISSED_MSG_PREFIX \"a parallel \"\n+\t\t\t\t   \"construct contains another parallel \"\n+\t\t\t\t   \"construct\\n\");\n+\t\t  dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t\t\t   \"This parallel construct is nested in \"\n+\t\t\t\t   \"another one\\n\");\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  if (!grid_parallel_clauses_gridifiable (par, grid->target_loc)\n+\t      || !grid_dist_follows_tiling_pattern (gimple_omp_body (par),\n+\t\t\t\t\t\t    grid, true))\n+\t    return false;\n+\t}\n+      else if (gomp_for *gfor = dyn_cast <gomp_for *> (stmt))\n+\t{\n+\t  if (!in_parallel)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\t{\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t\t   GRID_MISSED_MSG_PREFIX \"a loop \"\n+\t\t\t\t   \"construct is not nested within a parallel \"\n+\t\t\t\t   \"construct\\n\");\n+\t\t  dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t\t\t   \"This loop construct is not nested in \"\n+\t\t\t\t   \"a parallel construct\\n\");\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  if (!grid_gfor_follows_tiling_pattern (gfor, grid))\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, grid->target_loc,\n+\t\t\t       GRID_MISSED_MSG_PREFIX \"the distribute \"\n+\t\t\t       \"construct contains a complex statement\\n\");\n+\t      dump_printf_loc (MSG_NOTE, gimple_location (stmt),\n+\t\t\t       \"This statement cannot be analyzed for \"\n+\t\t\t       \"tiled gridification\\n\");\n+\t    }\n+\t  return false;\n+\t}\n+    }\n+    return true;\n+}\n+\n+/* If TARGET follows a pattern that can be turned into a gridified HSA kernel,\n+   return true, otherwise return false.  In the case of success, also fill in\n+   GRID with information describing the kernel grid.  */\n+\n+static bool\n+grid_target_follows_gridifiable_pattern (gomp_target *target, grid_prop *grid)\n+{\n+  if (gimple_omp_target_kind (target) != GF_OMP_TARGET_KIND_REGION)\n+    return false;\n+\n+  location_t tloc = gimple_location (target);\n+  grid->target_loc = tloc;\n+  gimple *stmt\n+    = grid_find_single_omp_among_assignments (gimple_omp_body (target),\n+\t\t\t\t\t      grid, \"target\");\n+  if (!stmt)\n+    return false;\n+  gomp_teams *teams = dyn_cast <gomp_teams *> (stmt);\n+  tree group_size = NULL;\n+  if (!teams)\n+    {\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t       GRID_MISSED_MSG_PREFIX \"it does not have a sole teams \"\n+\t\t       \"construct in it.\\n\");\n+      return false;\n+    }\n+\n+  tree clauses = gimple_omp_teams_clauses (teams);\n+  while (clauses)\n+    {\n+      switch (OMP_CLAUSE_CODE (clauses))\n+\t{\n+\tcase OMP_CLAUSE_NUM_TEAMS:\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t     GRID_MISSED_MSG_PREFIX \"the teams construct \"\n+\t\t\t     \"contains a num_teams clause\\n \");\n+\t  return false;\n+\n+\tcase OMP_CLAUSE_REDUCTION:\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t     GRID_MISSED_MSG_PREFIX \"a reduction \"\n+\t\t\t     \"clause is present\\n \");\n+\t  return false;\n+\n+\tcase OMP_CLAUSE_THREAD_LIMIT:\n+\t  if (!integer_zerop (OMP_CLAUSE_OPERAND (clauses, 0)))\n+\t    group_size = OMP_CLAUSE_OPERAND (clauses, 0);\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+      clauses = OMP_CLAUSE_CHAIN (clauses);\n+    }\n+\n+  stmt = grid_find_single_omp_among_assignments (gimple_omp_body (teams), grid,\n+\t\t\t\t\t\t \"teams\");\n+  if (!stmt)\n+    return false;\n+  gomp_for *dist = dyn_cast <gomp_for *> (stmt);\n+  if (!dist)\n+    {\n+      dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t       GRID_MISSED_MSG_PREFIX \"the teams construct does not \"\n+\t\t       \"have a single distribute construct in it.\\n\");\n+      return false;\n+    }\n+\n+  gcc_assert (gimple_omp_for_kind (dist) == GF_OMP_FOR_KIND_DISTRIBUTE);\n+\n+  grid->collapse = gimple_omp_for_collapse (dist);\n+  if (grid->collapse > 3)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t GRID_MISSED_MSG_PREFIX \"the distribute construct \"\n+\t\t\t \"contains collapse clause with parameter greater \"\n+\t\t\t \"than 3\\n\");\n+      return false;\n+    }\n+\n+  struct omp_for_data fd;\n+  struct omp_for_data_loop *dist_loops\n+    = (struct omp_for_data_loop *)alloca (grid->collapse\n+\t\t\t\t\t  * sizeof (struct omp_for_data_loop));\n+  extract_omp_for_data (dist, &fd, dist_loops);\n+  if (fd.chunk_size)\n+    {\n+      if (group_size && !operand_equal_p (group_size, fd.chunk_size, 0))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t     GRID_MISSED_MSG_PREFIX \"the teams \"\n+\t\t\t     \"thread limit is different from distribute \"\n+\t\t\t     \"schedule chunk\\n\");\n+\t  return false;\n+\t}\n+      group_size = fd.chunk_size;\n+    }\n+  if (group_size && grid->collapse > 1)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t GRID_MISSED_MSG_PREFIX \"group size cannot be \"\n+\t\t\t \"set using thread_limit or schedule clauses \"\n+\t\t\t \"when also using a collapse clause greater than 1\\n\");\n+      return false;\n+    }\n+\n+  if (gimple_omp_for_combined_p (dist))\n+    {\n+      grid->tiling = false;\n+      grid->group_sizes[0] = group_size;\n+      for (unsigned i = 1; i < grid->collapse; i++)\n+\tgrid->group_sizes[i] = NULL;\n+      return grid_dist_follows_simple_pattern (dist, grid);\n+    }\n+  else\n+    {\n+      grid->tiling = true;\n+      if (group_size)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, tloc,\n+\t\t\t     GRID_MISSED_MSG_PREFIX \"group size cannot be set \"\n+\t\t\t     \"using thread_limit or schedule clauses when \"\n+\t\t\t     \"distribute and loop constructs do not form \"\n+\t\t\t     \"one combined construct\\n\");\n+\t  return false;\n+\t}\n+      for (unsigned i = 0; i < grid->collapse; i++)\n+\t{\n+\t  if (fd.loops[i].cond_code == GT_EXPR)\n+\t    grid->group_sizes[i] = fold_build1 (NEGATE_EXPR,\n+\t\t\t\t\t\tTREE_TYPE (fd.loops[i].step),\n+\t\t\t\t\t\tfd.loops[i].step);\n+\t  else\n+\t    grid->group_sizes[i] = fd.loops[i].step;\n+\t}\n+      return grid_dist_follows_tiling_pattern (gimple_omp_body (dist), grid,\n+\t\t\t\t\t       false);\n+    }\n+}\n+\n+/* Operand walker, used to remap pre-body declarations according to a hash map\n+   provided in DATA.  */\n+\n+static tree\n+grid_remap_prebody_decls (tree *tp, int *walk_subtrees, void *data)\n+{\n+  tree t = *tp;\n+\n+  if (DECL_P (t) || TYPE_P (t))\n+    *walk_subtrees = 0;\n+  else\n+    *walk_subtrees = 1;\n+\n+  if (VAR_P (t))\n+    {\n+      struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n+      hash_map<tree, tree> *declmap = (hash_map<tree, tree> *) wi->info;\n+      tree *repl = declmap->get (t);\n+      if (repl)\n+\t*tp = *repl;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Identifiers of segments into which a particular variable should be places\n+   when gridifying.  */\n+\n+enum grid_var_segment {GRID_SEGMENT_PRIVATE, GRID_SEGMENT_GROUP,\n+\t\t       GRID_SEGMENT_GLOBAL};\n+\n+/* Mark VAR so that it is eventually placed into SEGMENT.  Place an artificial\n+   builtin call into SEQ that will make sure the variable is always considered\n+   address taken.  */\n+\n+static void\n+grid_mark_variable_segment (tree var, enum grid_var_segment segment)\n+{\n+  /* Making a non-addressable variables would require that we re-gimplify all\n+     their uses.  Fortunately, we do not have to do this because if they are\n+     not addressable, it means they are not used in atomic or parallel\n+     statements and so relaxed GPU consistency rules mean we can just keep them\n+     private. */\n+  if (!TREE_ADDRESSABLE (var))\n+    return;\n+\n+  switch (segment)\n+    {\n+    case GRID_SEGMENT_GROUP:\n+      DECL_ATTRIBUTES (var) = tree_cons (get_identifier (\"hsa_group_segment\"),\n+\t\t\t\t\t NULL, DECL_ATTRIBUTES (var));\n+      break;\n+    case GRID_SEGMENT_GLOBAL:\n+      DECL_ATTRIBUTES (var) = tree_cons (get_identifier (\"hsa_global_segment\"),\n+\t\t\t\t\t NULL, DECL_ATTRIBUTES (var));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  if (!TREE_STATIC (var))\n+    {\n+      TREE_STATIC (var) = 1;\n+      varpool_node::finalize_decl (var);\n+    }\n+\n+}\n+\n+/* Copy leading register-type assignments to local variables in SRC to just\n+   before DST, Creating temporaries, adjusting mapping of operands in WI and\n+   remapping operands as necessary.  Add any new temporaries to TGT_BIND.\n+   Return the first statement that does not conform to grid_safe_assignment_p\n+   or NULL.  If VAR_SEGMENT is not GRID_SEGMENT_PRIVATE, also mark all\n+   variables in traversed bind statements so that they are put into the\n+   appropriate segment.  */\n+\n+static gimple *\n grid_copy_leading_local_assignments (gimple_seq src, gimple_stmt_iterator *dst,\n-\t\t\t\tgbind *tgt_bind, struct walk_stmt_info *wi)\n+\t\t\t\t     gbind *tgt_bind,\n+\t\t\t\t     enum grid_var_segment var_segment,\n+\t\t\t\t     struct walk_stmt_info *wi)\n {\n   hash_map<tree, tree> *declmap = (hash_map<tree, tree> *) wi->info;\n   gimple_stmt_iterator gsi;\n@@ -17993,13 +18491,17 @@ grid_copy_leading_local_assignments (gimple_seq src, gimple_stmt_iterator *dst,\n       if (gbind *bind = dyn_cast <gbind *> (stmt))\n \t{\n \t  gimple *r = grid_copy_leading_local_assignments\n-\t    (gimple_bind_body (bind), dst, tgt_bind, wi);\n+\t    (gimple_bind_body (bind), dst, tgt_bind, var_segment, wi);\n+\n+\t  if (var_segment != GRID_SEGMENT_PRIVATE)\n+\t    for (tree var = gimple_bind_vars (bind); var; var = DECL_CHAIN (var))\n+\t      grid_mark_variable_segment (var, var_segment);\n \t  if (r)\n \t    return r;\n \t  else\n \t    continue;\n \t}\n-      if (!grid_reg_assignment_to_local_var_p (stmt))\n+      if (!grid_safe_assignment_p (stmt, NULL))\n \treturn stmt;\n       tree lhs = gimple_assign_lhs (as_a <gassign *> (stmt));\n       tree repl = copy_var_decl (lhs, create_tmp_var_name (NULL),\n@@ -18015,43 +18517,262 @@ grid_copy_leading_local_assignments (gimple_seq src, gimple_stmt_iterator *dst,\n   return NULL;\n }\n \n+/* Statement walker function to make adjustments to statements within the\n+   gridifed kernel copy.  */\n+\n+static tree\n+grid_process_grid_body (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n+\t\t\tstruct walk_stmt_info *)\n+{\n+  *handled_ops_p = false;\n+  gimple *stmt = gsi_stmt (*gsi);\n+  if (gimple_code (stmt) == GIMPLE_OMP_FOR\n+      && (gimple_omp_for_kind (stmt) & GF_OMP_FOR_SIMD))\n+  {\n+    gomp_for *loop = as_a <gomp_for *> (stmt);\n+    tree clauses = gimple_omp_for_clauses (loop);\n+    tree cl = find_omp_clause (clauses, OMP_CLAUSE_SAFELEN);\n+    if (cl)\n+      OMP_CLAUSE_SAFELEN_EXPR (cl) = integer_one_node;\n+    else\n+      {\n+\ttree c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);\n+\tOMP_CLAUSE_SAFELEN_EXPR (c) = integer_one_node;\n+\tOMP_CLAUSE_CHAIN (c) = clauses;\n+\tgimple_omp_for_set_clauses (loop, c);\n+      }\n+  }\n+  return NULL_TREE;\n+}\n+\n+/* Given a PARLOOP that is a normal for looping construct but also a part of a\n+   combined construct with a simd loop, eliminate the simd loop.  */\n+\n+static void\n+grid_eliminate_combined_simd_part (gomp_for *parloop)\n+{\n+  struct walk_stmt_info wi;\n+\n+  memset (&wi, 0, sizeof (wi));\n+  wi.val_only = true;\n+  enum gf_mask msk = GF_OMP_FOR_SIMD;\n+  wi.info = (void *) &msk;\n+  walk_gimple_seq (gimple_omp_body (parloop), find_combined_for, NULL, &wi);\n+  gimple *stmt = (gimple *) wi.info;\n+  /* We expect that the SIMD id the only statement in the parallel loop.  */\n+  gcc_assert (stmt\n+\t      && gimple_code (stmt) == GIMPLE_OMP_FOR\n+\t      && (gimple_omp_for_kind (stmt) == GF_OMP_FOR_SIMD)\n+\t      && gimple_omp_for_combined_into_p (stmt)\n+\t      && !gimple_omp_for_combined_p (stmt));\n+  gomp_for *simd = as_a <gomp_for *> (stmt);\n+\n+  /* Copy over the iteration properties because the body refers to the index in\n+     the bottmom-most loop.  */\n+  unsigned i, collapse = gimple_omp_for_collapse (parloop);\n+  gcc_checking_assert (collapse == gimple_omp_for_collapse (simd));\n+  for (i = 0; i < collapse; i++)\n+    {\n+      gimple_omp_for_set_index (parloop, i, gimple_omp_for_index (simd, i));\n+      gimple_omp_for_set_initial (parloop, i, gimple_omp_for_initial (simd, i));\n+      gimple_omp_for_set_final (parloop, i, gimple_omp_for_final (simd, i));\n+      gimple_omp_for_set_incr (parloop, i, gimple_omp_for_incr (simd, i));\n+    }\n+\n+  tree *tgt= gimple_omp_for_clauses_ptr (parloop);\n+  while (*tgt)\n+    tgt = &OMP_CLAUSE_CHAIN (*tgt);\n+\n+  /* Copy over all clauses, except for linaer clauses, which are turned into\n+     private clauses, and all other simd-specificl clauses, which are\n+     ignored.  */\n+  tree *pc = gimple_omp_for_clauses_ptr (simd);\n+  while (*pc)\n+    {\n+      tree c = *pc;\n+      switch (TREE_CODE (c))\n+\t{\n+\tcase OMP_CLAUSE_LINEAR:\n+\t  {\n+\t    tree priv = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_PRIVATE);\n+\t    OMP_CLAUSE_DECL (priv) = OMP_CLAUSE_DECL (c);\n+\t    OMP_CLAUSE_CHAIN (priv) = NULL;\n+\t    *tgt = priv;\n+\t    tgt = &OMP_CLAUSE_CHAIN (priv);\n+\t    pc = &OMP_CLAUSE_CHAIN (c);\n+\t    break;\n+\t  }\n+\n+\tcase OMP_CLAUSE_SAFELEN:\n+\tcase OMP_CLAUSE_SIMDLEN:\n+\tcase OMP_CLAUSE_ALIGNED:\n+\t  pc = &OMP_CLAUSE_CHAIN (c);\n+\t  break;\n+\n+\tdefault:\n+\t  *pc = OMP_CLAUSE_CHAIN (c);\n+\t  OMP_CLAUSE_CHAIN (c) = NULL;\n+\t  *tgt = c;\n+\t  tgt = &OMP_CLAUSE_CHAIN(c);\n+\t  break;\n+\t}\n+    }\n+\n+  /* Finally, throw away the simd and mark the parallel loop as not\n+     combined.  */\n+  gimple_omp_set_body (parloop, gimple_omp_body (simd));\n+  gimple_omp_for_set_combined_p (parloop, false);\n+}\n+\n+/* Statement walker function marking all parallels as grid_phony and loops as\n+   grid ones representing threads of a particular thread group.  */\n+\n+static tree\n+grid_mark_tiling_loops (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n+\t\t\tstruct walk_stmt_info *wi_in)\n+{\n+  *handled_ops_p = false;\n+  if (gomp_for *loop = dyn_cast <gomp_for *> (gsi_stmt (*gsi)))\n+    {\n+      *handled_ops_p = true;\n+      gimple_omp_for_set_kind (loop, GF_OMP_FOR_KIND_GRID_LOOP);\n+      gimple_omp_for_set_grid_intra_group (loop, true);\n+      if (gimple_omp_for_combined_p (loop))\n+\tgrid_eliminate_combined_simd_part (loop);\n+\n+      struct walk_stmt_info body_wi;\n+      memset (&body_wi, 0, sizeof (body_wi));\n+      walk_gimple_seq_mod (gimple_omp_body_ptr (loop),\n+\t\t\t   grid_process_grid_body, NULL, &body_wi);\n+\n+      gbind *bind = (gbind *) wi_in->info;\n+      tree c;\n+      for (c = gimple_omp_for_clauses (loop); c; c = OMP_CLAUSE_CHAIN (c))\n+\tif (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t  {\n+\t    push_gimplify_context ();\n+\t    tree ov = OMP_CLAUSE_DECL (c);\n+\t    tree gv = copy_var_decl (ov, create_tmp_var_name (NULL),\n+\t\t\t\t    TREE_TYPE (ov));\n+\n+\t    grid_mark_variable_segment (gv, GRID_SEGMENT_GROUP);\n+\t    DECL_CONTEXT (gv) = current_function_decl;\n+\t    gimple_bind_append_vars (bind, gv);\n+\t    tree x = lang_hooks.decls.omp_clause_assign_op (c, gv, ov);\n+\t    gimplify_and_add (x, &OMP_CLAUSE_LASTPRIVATE_GIMPLE_SEQ (c));\n+\t    x = lang_hooks.decls.omp_clause_copy_ctor (c, ov, gv);\n+\t    gimple_seq l = NULL;\n+\t    gimplify_and_add (x, &l);\n+\t    gsi_insert_seq_after (gsi, l, GSI_SAME_STMT);\n+\t    pop_gimplify_context (bind);\n+\t  }\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Statement walker function marking all parallels as grid_phony and loops as\n+   grid ones representing threads of a particular thread group.  */\n+\n+static tree\n+grid_mark_tiling_parallels_and_loops (gimple_stmt_iterator *gsi,\n+\t\t\t\t      bool *handled_ops_p,\n+\t\t\t\t      struct walk_stmt_info *wi_in)\n+{\n+  *handled_ops_p = false;\n+  wi_in->removed_stmt = false;\n+  gimple *stmt = gsi_stmt (*gsi);\n+  if (gbind *bind = dyn_cast <gbind *> (stmt))\n+    {\n+      for (tree var = gimple_bind_vars (bind); var; var = DECL_CHAIN (var))\n+\tgrid_mark_variable_segment (var, GRID_SEGMENT_GROUP);\n+    }\n+  else if (gomp_parallel *parallel = dyn_cast <gomp_parallel *> (stmt))\n+    {\n+      *handled_ops_p = true;\n+      gimple_omp_parallel_set_grid_phony (parallel, true);\n+\n+      gbind *new_bind = gimple_build_bind (NULL, NULL, make_node (BLOCK));\n+      gimple_bind_set_body (new_bind, gimple_omp_body (parallel));\n+      gimple_seq s = NULL;\n+      gimple_seq_add_stmt (&s, new_bind);\n+      gimple_omp_set_body (parallel, s);\n+\n+      struct walk_stmt_info wi_par;\n+      memset (&wi_par, 0, sizeof (wi_par));\n+      wi_par.info = new_bind;\n+      walk_gimple_seq_mod (gimple_bind_body_ptr (new_bind),\n+\t\t\t   grid_mark_tiling_loops, NULL, &wi_par);\n+    }\n+  else if (is_a <gcall *> (stmt))\n+    wi_in->removed_stmt = grid_handle_call_in_distribute (gsi);\n+  return NULL_TREE;\n+}\n+\n /* Given freshly copied top level kernel SEQ, identify the individual OMP\n-   components, mark them as part of kernel and return the inner loop, and copy\n-   assignment leading to them just before DST, remapping them using WI and\n-   adding new temporaries to TGT_BIND.  */\n+   components, mark them as part of kernel, copy assignment leading to them\n+   just before DST, remapping them using WI and adding new temporaries to\n+   TGT_BIND, and and return the loop that will be used for kernel dispatch.  */\n \n static gomp_for *\n-grid_process_kernel_body_copy (gimple_seq seq, gimple_stmt_iterator *dst,\n+grid_process_kernel_body_copy (grid_prop *grid, gimple_seq seq,\n+\t\t\t       gimple_stmt_iterator *dst,\n \t\t\t       gbind *tgt_bind, struct walk_stmt_info *wi)\n {\n-  gimple *stmt = grid_copy_leading_local_assignments (seq, dst, tgt_bind, wi);\n+  gimple *stmt = grid_copy_leading_local_assignments (seq, dst, tgt_bind,\n+\t\t\t\t\t\t      GRID_SEGMENT_GLOBAL, wi);\n   gomp_teams *teams = dyn_cast <gomp_teams *> (stmt);\n   gcc_assert (teams);\n   gimple_omp_teams_set_grid_phony (teams, true);\n   stmt = grid_copy_leading_local_assignments (gimple_omp_body (teams), dst,\n-\t\t\t\t\t tgt_bind, wi);\n+\t\t\t\t\t      tgt_bind, GRID_SEGMENT_GLOBAL, wi);\n   gcc_checking_assert (stmt);\n   gomp_for *dist = dyn_cast <gomp_for *> (stmt);\n   gcc_assert (dist);\n   gimple_seq prebody = gimple_omp_for_pre_body (dist);\n   if (prebody)\n-    grid_copy_leading_local_assignments (prebody, dst, tgt_bind, wi);\n-  gimple_omp_for_set_grid_phony (dist, true);\n-  stmt = grid_copy_leading_local_assignments (gimple_omp_body (dist), dst,\n-\t\t\t\t\t tgt_bind, wi);\n-  gcc_checking_assert (stmt);\n+    grid_copy_leading_local_assignments (prebody, dst, tgt_bind,\n+\t\t\t\t\t GRID_SEGMENT_GROUP, wi);\n \n-  gomp_parallel *parallel = as_a <gomp_parallel *> (stmt);\n-  gimple_omp_parallel_set_grid_phony (parallel, true);\n-  stmt = grid_copy_leading_local_assignments (gimple_omp_body (parallel), dst,\n-\t\t\t\t\t tgt_bind, wi);\n-  gomp_for *inner_loop = as_a <gomp_for *> (stmt);\n-  gimple_omp_for_set_kind (inner_loop, GF_OMP_FOR_KIND_GRID_LOOP);\n-  prebody = gimple_omp_for_pre_body (inner_loop);\n-  if (prebody)\n-    grid_copy_leading_local_assignments (prebody, dst, tgt_bind, wi);\n+  if (grid->tiling)\n+    {\n+      gimple_omp_for_set_kind (dist, GF_OMP_FOR_KIND_GRID_LOOP);\n+      gimple_omp_for_set_grid_group_iter (dist, true);\n \n-  return inner_loop;\n+      struct walk_stmt_info wi_tiled;\n+      memset (&wi_tiled, 0, sizeof (wi_tiled));\n+      walk_gimple_seq_mod (gimple_omp_body_ptr (dist),\n+\t\t\t   grid_mark_tiling_parallels_and_loops, NULL,\n+\t\t\t   &wi_tiled);\n+      return dist;\n+    }\n+  else\n+    {\n+      gimple_omp_for_set_grid_phony (dist, true);\n+      stmt = grid_copy_leading_local_assignments (gimple_omp_body (dist), dst,\n+\t\t\t\t\t\t  tgt_bind,\n+\t\t\t\t\t\t  GRID_SEGMENT_PRIVATE, wi);\n+      gcc_checking_assert (stmt);\n+      gomp_parallel *parallel = as_a <gomp_parallel *> (stmt);\n+      gimple_omp_parallel_set_grid_phony (parallel, true);\n+      stmt = grid_copy_leading_local_assignments (gimple_omp_body (parallel),\n+\t\t\t\t\t\t  dst, tgt_bind,\n+\t\t\t\t\t\t  GRID_SEGMENT_PRIVATE, wi);\n+      gomp_for *inner_loop = as_a <gomp_for *> (stmt);\n+      gimple_omp_for_set_kind (inner_loop, GF_OMP_FOR_KIND_GRID_LOOP);\n+      prebody = gimple_omp_for_pre_body (inner_loop);\n+      if (prebody)\n+\tgrid_copy_leading_local_assignments (prebody, dst, tgt_bind,\n+\t\t\t\t\t     GRID_SEGMENT_PRIVATE, wi);\n+\n+      if (gimple_omp_for_combined_p (inner_loop))\n+\tgrid_eliminate_combined_simd_part (inner_loop);\n+      struct walk_stmt_info body_wi;;\n+      memset (&body_wi, 0, sizeof (body_wi));\n+      walk_gimple_seq_mod (gimple_omp_body_ptr (inner_loop),\n+\t\t\t   grid_process_grid_body, NULL, &body_wi);\n+\n+      return inner_loop;\n+    }\n }\n \n /* If TARGET points to a GOMP_TARGET which follows a gridifiable pattern,\n@@ -18064,14 +18785,16 @@ grid_attempt_target_gridification (gomp_target *target,\n \t\t\t\t   gimple_stmt_iterator *gsi,\n \t\t\t\t   gbind *tgt_bind)\n {\n-  tree group_size;\n-  if (!target || !grid_target_follows_gridifiable_pattern (target, &group_size))\n+  /* removed group_size */\n+  grid_prop grid;\n+  memset (&grid, 0, sizeof (grid));\n+  if (!target || !grid_target_follows_gridifiable_pattern (target, &grid))\n     return;\n \n   location_t loc = gimple_location (target);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-\t\t     \"Target construct will be turned into a gridified GPGPU \"\n+\t\t     \"Target construct will be turned into a gridified HSA \"\n \t\t     \"kernel\\n\");\n \n   /* Copy target body to a GPUKERNEL construct:  */\n@@ -18084,8 +18807,8 @@ grid_attempt_target_gridification (gomp_target *target,\n   wi.info = declmap;\n \n   /* Copy assignments in between OMP statements before target, mark OMP\n-     statements within copy appropriatly.  */\n-  gomp_for *inner_loop = grid_process_kernel_body_copy (kernel_seq, gsi,\n+     statements within copy appropriately.  */\n+  gomp_for *inner_loop = grid_process_kernel_body_copy (&grid, kernel_seq, gsi,\n \t\t\t\t\t\t\ttgt_bind, &wi);\n \n   gbind *old_bind = as_a <gbind *> (gimple_seq_first (gimple_omp_body (target)));\n@@ -18100,10 +18823,10 @@ grid_attempt_target_gridification (gomp_target *target,\n     (gimple_bind_body_ptr (as_a <gbind *> (gimple_omp_body (target))),\n      gpukernel);\n \n-  walk_tree (&group_size, grid_remap_prebody_decls, &wi, NULL);\n+  for (size_t i = 0; i < grid.collapse; i++)\n+    walk_tree (&grid.group_sizes[i], grid_remap_prebody_decls, &wi, NULL);\n   push_gimplify_context ();\n-  size_t collapse = gimple_omp_for_collapse (inner_loop);\n-  for (size_t i = 0; i < collapse; i++)\n+  for (size_t i = 0; i < grid.collapse; i++)\n     {\n       tree itype, type = TREE_TYPE (gimple_omp_for_index (inner_loop, i));\n       if (POINTER_TYPE_P (type))\n@@ -18117,12 +18840,12 @@ grid_attempt_target_gridification (gomp_target *target,\n       tree n2 = unshare_expr (gimple_omp_for_final (inner_loop, i));\n       walk_tree (&n2, grid_remap_prebody_decls, &wi, NULL);\n       adjust_for_condition (loc, &cond_code, &n2);\n-      tree step;\n-      step = get_omp_for_step_from_incr (loc,\n-\t\t\t\t\t gimple_omp_for_incr (inner_loop, i));\n-      gimple_seq tmpseq = NULL;\n       n1 = fold_convert (itype, n1);\n       n2 = fold_convert (itype, n2);\n+\n+      tree step\n+\t= get_omp_for_step_from_incr (loc, gimple_omp_for_incr (inner_loop, i));\n+\n       tree t = build_int_cst (itype, (cond_code == LT_EXPR ? -1 : 1));\n       t = fold_build2 (PLUS_EXPR, itype, step, t);\n       t = fold_build2 (PLUS_EXPR, itype, t, n2);\n@@ -18133,15 +18856,23 @@ grid_attempt_target_gridification (gomp_target *target,\n \t\t\t fold_build1 (NEGATE_EXPR, itype, step));\n       else\n \tt = fold_build2 (TRUNC_DIV_EXPR, itype, t, step);\n+      if (grid.tiling)\n+        {\n+          if (cond_code == GT_EXPR)\n+            step = fold_build1 (NEGATE_EXPR, itype, step);\n+          t = fold_build2 (MULT_EXPR, itype, t, step);\n+        }\n+\n       tree gs = fold_convert (uint32_type_node, t);\n+      gimple_seq tmpseq = NULL;\n       gimplify_expr (&gs, &tmpseq, NULL, is_gimple_val, fb_rvalue);\n       if (!gimple_seq_empty_p (tmpseq))\n \tgsi_insert_seq_before (gsi, tmpseq, GSI_SAME_STMT);\n \n       tree ws;\n-      if (i == 0 && group_size)\n+      if (grid.group_sizes[i])\n \t{\n-\t  ws = fold_convert (uint32_type_node, group_size);\n+\t  ws = fold_convert (uint32_type_node, grid.group_sizes[i]);\n \t  tmpseq = NULL;\n \t  gimplify_expr (&ws, &tmpseq, NULL, is_gimple_val, fb_rvalue);\n \t  if (!gimple_seq_empty_p (tmpseq))\n@@ -18262,7 +18993,7 @@ const pass_data pass_data_lower_omp =\n {\n   GIMPLE_PASS, /* type */\n   \"omplower\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n+  OPTGROUP_OPENMP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_gimple_any, /* properties_required */\n   PROP_gimple_lomp | PROP_gimple_lomp_dev, /* properties_provided */\n@@ -18733,7 +19464,7 @@ const pass_data pass_data_diagnose_omp_blocks =\n {\n   GIMPLE_PASS, /* type */\n   \"*diagnose_omp_blocks\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n+  OPTGROUP_OPENMP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_gimple_any, /* properties_required */\n   0, /* properties_provided */\n@@ -20164,7 +20895,7 @@ const pass_data pass_data_oacc_device_lower =\n {\n   GIMPLE_PASS, /* type */\n   \"oaccdevlow\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n+  OPTGROUP_OPENMP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_cfg, /* properties_required */\n   0 /* Possibly PROP_gimple_eomp.  */, /* properties_provided */\n@@ -20267,7 +20998,7 @@ const pass_data pass_data_omp_device_lower =\n {\n   GIMPLE_PASS, /* type */\n   \"ompdevlow\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n+  OPTGROUP_OPENMP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_cfg, /* properties_required */\n   PROP_gimple_lomp_dev, /* properties_provided */\n@@ -20316,7 +21047,7 @@ const pass_data pass_data_omp_target_link =\n {\n   GIMPLE_PASS,\t\t\t/* type */\n   \"omptargetlink\",\t\t/* name */\n-  OPTGROUP_NONE,\t\t/* optinfo_flags */\n+  OPTGROUP_OPENMP,\t\t/* optinfo_flags */\n   TV_NONE,\t\t\t/* tv_id */\n   PROP_ssa,\t\t\t/* properties_required */\n   0,\t\t\t\t/* properties_provided */"}, {"sha": "aeb8accf74c323af12b660a7c852ed0a75b8adf1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -1,3 +1,10 @@\n+2016-11-23  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* c-c++-common/gomp/gridify-1.c: Update scan string.\n+\t* gfortran.dg/gomp/gridify-1.f90: Likewise.\n+\t* c-c++-common/gomp/gridify-2.c: New test.\n+\t* c-c++-common/gomp/gridify-3.c: Likewise.\n+\n 2016-11-23  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/78396"}, {"sha": "f9b03ebd96fcb81cd8182fcdf4bfcacc8fc404b9", "filename": "gcc/testsuite/c-c++-common/gomp/gridify-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-1.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -51,4 +51,4 @@ foo4 (int j, int n, int *a)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"Target construct will be turned into a gridified GPGPU kernel\" 4 \"omplower\" } } */\n+/* { dg-final { scan-tree-dump-times \"Target construct will be turned into a gridified HSA kernel\" 4 \"omplower\" } } */"}, {"sha": "6b5cc9a8a7ddafd8cb553e5ee1377c97821f258e", "filename": "gcc/testsuite/c-c++-common/gomp/gridify-2.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-2.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target offload_hsa } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower-details\" } */\n+\n+#define BLOCK_SIZE 16\n+\n+\n+void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n+   const float*B, const int LDB, const float beta, float*C, const int LDC){\n+\n+#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n+#pragma omp distribute collapse(2)\n+   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE)\n+      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE)\n+\t{\n+//       Each team has a local copy of these mini matrices\n+         float As[BLOCK_SIZE][BLOCK_SIZE];\n+         float Bs[BLOCK_SIZE][BLOCK_SIZE];\n+#pragma omp parallel\n+\t {\n+         int C_row, C_col;\n+         float Cval = 0.0;\n+\n+         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE )\n+\t   {\n+#pragma omp for collapse(2)\n+\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n+               for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t\t {\n+\t\t   C_row = C_row_start + row;\n+\t\t   C_col = C_col_start + col;\n+\t\t   if ((C_row < M) && (kblock + col < K))\n+\t\t     As[row][col] = A[(C_row*LDA)+ kblock + col];\n+\t\t   else\n+\t\t     As[row][col] = 0;\n+\t\t   if ((kblock + row < K) && C_col < N)\n+\t\t     Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n+\t\t   else\n+\t\t     Bs[row][col] = 0;\n+\t\t }\n+\n+#pragma omp for collapse(2)\n+\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n+\t       for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t\t {\n+\t\t   for (int e = 0; e < BLOCK_SIZE; ++e)\n+                     Cval += As[row][e] * Bs[e][col];\n+\t\t }\n+\t   }  /* End for kblock .. */\n+\n+\n+#pragma omp for collapse(2)\n+         for (int row=0 ; row < BLOCK_SIZE ; row++)\n+\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t     {\n+               C_row = C_row_start + row;\n+               C_col = C_col_start + col;\n+\t       if ((C_row < M) && (C_col < N))\n+\t\t C[(C_row*LDC)+C_col] = alpha*Cval + beta*C[(C_row*LDC)+C_col];\n+\n+\t     }\n+         } /* end parallel */\n+      }\t   /* end target teams distribute */\n+}\n+\n+/* { dg-final { scan-tree-dump \"Target construct will be turned into a gridified HSA kernel\" \"omplower\" } } */"}, {"sha": "8dbeaef74cd39551e9cdfff53ea626e8d67e5264", "filename": "gcc/testsuite/c-c++-common/gomp/gridify-3.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fgridify-3.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -0,0 +1,68 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target offload_hsa } */\n+/* { dg-options \"-fopenmp -fdump-tree-omplower-details\" } */\n+\n+#define BLOCK_SIZE 16\n+\n+void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n+   const float*B, const int LDB, const float beta, float*C, const int LDC)\n+{\n+#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n+#pragma omp distribute collapse(2)\n+   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE)\n+      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE)\n+\t{\n+\t  float As[BLOCK_SIZE][BLOCK_SIZE];\n+\t  float Bs[BLOCK_SIZE][BLOCK_SIZE];\n+\t  float Cs[BLOCK_SIZE][BLOCK_SIZE];\n+\t  int C_row, C_col;\n+\n+#pragma omp parallel for collapse(2)\n+         for (int row=0 ; row < BLOCK_SIZE ; row++)\n+\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t     {\n+               Cs[row][col] = 0.0;\n+\t     }\n+\n+\n+         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE )\n+\t   {\n+#pragma omp parallel for collapse(2)\n+\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n+               for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t\t {\n+\t\t   C_row = C_row_start + row;\n+\t\t   C_col = C_col_start + col;\n+\t\t   if ((C_row < M) && (kblock + col < K))\n+\t\t     As[row][col] = A[(C_row*LDA)+ kblock + col];\n+\t\t   else\n+\t\t     As[row][col] = 0;\n+\t\t   if ((kblock + row < K) && C_col < N)\n+\t\t     Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n+\t\t   else\n+\t\t     Bs[row][col] = 0;\n+\t\t }\n+\n+#pragma omp parallel for collapse(2)\n+\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n+               for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t\t {\n+\t\t   for (int e = 0; e < BLOCK_SIZE; ++e)\n+                     Cs[row][col] += As[row][e] * Bs[e][col];\n+\t\t }\n+         }  /* End for kblock .. */\n+\n+\n+#pragma omp parallel for collapse(2)\n+         for (int row=0 ; row < BLOCK_SIZE ; row++)\n+\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t     {\n+               C_row = C_row_start + row;\n+               C_col = C_col_start + col;\n+\t       if ((C_row < M) && (C_col < N))\n+\t\t C[(C_row*LDC)+C_col] = alpha*Cs[row][col] + beta*C[(C_row*LDC)+C_col];\n+\t     }\n+      }\t/* End distribute */\n+}\n+\n+/* { dg-final { scan-tree-dump \"Target construct will be turned into a gridified HSA kernel\" \"omplower\" } } */"}, {"sha": "7def27980bae3e018635029b434186d82853698f", "filename": "gcc/testsuite/gfortran.dg/gomp/gridify-1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgridify-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgridify-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fgridify-1.f90?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -13,4 +13,4 @@ subroutine vector_square(n, a, b)\n !$omp end target teams\n end subroutine vector_square\n \n-! { dg-final { scan-tree-dump \"Target construct will be turned into a gridified GPGPU kernel\" \"omplower\" } }\n+! { dg-final { scan-tree-dump \"Target construct will be turned into a gridified HSA kernel\" \"omplower\" } }"}, {"sha": "16781f9529a0d397567d921df8e275223598677a", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -1,3 +1,9 @@\n+2016-11-23  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* testsuite/libgomp.hsa.c/bits-insns.c: New test.\n+\t* testsuite/libgomp.hsa.c/tiling-1.c: Likewise.\n+\t* testsuite/libgomp.hsa.c/tiling-2.c: Likewise.\n+\n 2016-11-23  Martin Liska  <mliska@suse.cz>\n             Martin Jambor  <mjambor@suse.cz>\n "}, {"sha": "21cac72dac42d50592cf4d5fafe81f51d936051c", "filename": "libgomp/testsuite/libgomp.hsa.c/bits-insns.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbits-insns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbits-insns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Fbits-insns.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -0,0 +1,73 @@\n+#include <math.h>\n+\n+#define N 12\n+\n+int main()\n+{\n+  unsigned int arguments[N] = {0u, 1u, 2u, 3u, 111u, 333u, 444u, 0x80000000u, 0x0000ffffu, 0xf0000000u, 0xff000000u, 0xffffffffu};\n+  int clrsb[N] = {};\n+  int clz[N] = {};\n+  int ctz[N] = {};\n+  int ffs[N] = {};\n+  int parity[N] = {};\n+  int popcount[N] = {};\n+\n+  int ref_clrsb[N] = {};\n+  int ref_clz[N] = {};\n+  int ref_ctz[N] = {};\n+  int ref_ffs[N] = {};\n+  int ref_parity[N] = {};\n+  int ref_popcount[N] = {};\n+\n+  for (unsigned i = 0; i < N; i++)\n+    {\n+      ref_clrsb[i] = __builtin_clrsb (arguments[i]);\n+      ref_clz[i] = __builtin_clz (arguments[i]);\n+      ref_ctz[i] = __builtin_ctz (arguments[i]);\n+      ref_ffs[i] = __builtin_ffs (arguments[i]);\n+      ref_parity[i] = __builtin_parity (arguments[i]);\n+      ref_popcount[i] = __builtin_popcount (arguments[i]);\n+    }\n+\n+  #pragma omp target map(from:clz, ctz, ffs, parity, popcount)\n+  {\n+    for (unsigned i = 0; i < N; i++)\n+    {\n+      clrsb[i] = __builtin_clrsb (arguments[i]);\n+      clz[i] = __builtin_clz (arguments[i]);\n+      ctz[i] = __builtin_ctz (arguments[i]);\n+      ffs[i] = __builtin_ffs (arguments[i]);\n+      parity[i] = __builtin_parity (arguments[i]);\n+      popcount[i] = __builtin_popcount (arguments[i]);\n+    }\n+  }\n+\n+  for (unsigned i = 0; i < N; i++)\n+    if (ref_clrsb[i] != clrsb[i])\n+      __builtin_abort ();\n+\n+  /* CLZ of zero is undefined for zero.  */\n+  for (unsigned i = 1; i < N; i++)\n+    if (ref_clz[i] != clz[i])\n+      __builtin_abort ();\n+\n+  /* Likewise for ctz */\n+  for (unsigned i = 1; i < N; i++)\n+    if (ref_ctz[i] != ctz[i])\n+      __builtin_abort ();\n+\n+  for (unsigned i = 0; i < N; i++)\n+    if (ref_ffs[i] != ffs[i])\n+      __builtin_abort ();\n+\n+  for (unsigned i = 0; i < N; i++)\n+    if (ref_parity[i] != parity[i])\n+      __builtin_abort ();\n+\n+  for (unsigned i = 0; i < N; i++)\n+    if (ref_popcount[i] != popcount[i])\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "9149adc04e9b21f0addf114ef872be570502aa75", "filename": "libgomp/testsuite/libgomp.hsa.c/tiling-1.c", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-1.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -0,0 +1,212 @@\n+/*\n+\n+   matmul.c : Matrix Multiplication with tiling for openmp4 example\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <math.h>\n+\n+#define BLOCK_SIZE 16\n+/*\n+  #define BLOCK_SIZE 32\n+*/\n+#define NSECPERSEC 1000000000L\n+\n+typedef struct {\n+   int width;\n+   int height;\n+   int stride;\n+   int hpad;\n+   float* elements;\n+} Matrix;\n+\n+/* Correctly extract the number of nanoseconds from the two time structures */\n+long int get_nanosecs( struct timespec start_time, struct timespec end_time) {\n+   long int nanosecs;\n+   if ((end_time.tv_nsec-start_time.tv_nsec)<0) nanosecs =\n+      ((((long int) end_time.tv_sec- (long int) start_time.tv_sec )-1)*NSECPERSEC ) +\n+      ( NSECPERSEC + (long int) end_time.tv_nsec - (long int) start_time.tv_nsec) ;\n+   else nanosecs =\n+      (((long int) end_time.tv_sec- (long int) start_time.tv_sec )*NSECPERSEC ) +\n+      ( (long int) end_time.tv_nsec - (long int) start_time.tv_nsec );\n+   return nanosecs;\n+}\n+\n+void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n+     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n+void simple_sgemm_tn(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n+     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n+void  tiled_sgemm_tt(const int M,const int N,const int K,const float alpha, const float*A, const int LDA,\n+     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n+\n+int verify(float* v_res, float* v_ref, int len) {\n+    int passed = 1;\n+    int i;\n+    for (i = 0; i < len; ++i) {\n+        if (fabs(v_res[i] - v_ref[i]) > 0.001*v_ref[i]) {\n+\t  __builtin_abort ();\n+        }\n+    }\n+    return passed;\n+}\n+\n+\n+int main(int argc, char* argv[]){\n+\n+   Matrix A,B,Bt,C,Cref;\n+   int a1,a2,a3,i,j;\n+   struct timespec start_time1, end_time1;\n+   struct timespec start_time2, end_time2;\n+   long int nanosecs,total_ops;\n+   float gflopsTiled,gflopsCPU;\n+\n+   a1 = 35;\n+   a2 = 28;\n+   a3 = 47;\n+\n+   A.height = a1;\n+   A.width = a2;\n+   A.stride = (((A.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   A.hpad = (((A.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   A.elements = (float*)malloc(A.stride * A.hpad* sizeof(float));\n+\n+   B.height = a2;\n+   B.width = a3;\n+   B.stride = (((B.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   B.hpad = (((B.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   B.elements = (float*)malloc(B.stride * B.hpad * sizeof(float));\n+\n+   /* Bt is same as B but stored in column-major order */\n+   Bt.height = B.height;\n+   Bt.width = B.width;\n+   Bt.stride = B.stride;\n+   Bt.hpad = B.hpad;\n+   Bt.elements = (float*)malloc(Bt.stride * Bt.hpad * sizeof(float));\n+\n+   C.height = a1;\n+   C.width = a3;\n+   C.stride = (((C.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   C.hpad = (((C.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   C.elements = (float*)malloc(C.stride * C.hpad * sizeof(float));\n+\n+   Cref.height = a1;\n+   Cref.width = a3;\n+   Cref.stride = (((Cref.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   Cref.hpad = (((Cref.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   Cref.elements = (float*)malloc(Cref.stride * Cref.hpad * sizeof(float));\n+\n+   for(i = 0; i < A.hpad ; i++)\n+      for(j = 0; j < A.stride; j++) {\n+         if (( j<A.width ) && (i<A.height)) {\n+            A.elements[i*A.stride + j] = (i % 3);\n+         } else {\n+            A.elements[i*A.stride + j] = 0.0;\n+         }\n+      }\n+\n+   /*  Initialize B and Bt */\n+   for(i = 0; i < B.hpad ; i++)\n+      for(j = 0; j < B.stride; j++) {\n+         if (( j<B.width ) && (i<B.height)) {\n+            B.elements[i*B.stride+j] = (j % 2);\n+            Bt.elements[j*Bt.stride+i] = B.elements[i*B.stride+j] ;\n+         } else {\n+            B.elements[i*B.stride+j] = 0.0;\n+            Bt.elements[j*Bt.stride+i] = 0.0;\n+         }\n+      }\n+\n+   /* zero C, and Cref */\n+   for(i = 0; i < C.hpad; i++)\n+      for(j = 0; j < C.stride; j++) {\n+         C.elements[i*C.stride+j] = 0.0;\n+         Cref.elements[i*Cref.stride+j] = 0.0;\n+      }\n+\n+   simple_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,Cref.elements,Cref.stride);\n+   tiled_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,C.elements,C.stride);\n+\n+   verify(C.elements, Cref.elements, C.height * C.stride);\n+   return 0;\n+}\n+\n+void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n+const float* B,const int LDB, const float beta,float* C, const int LDC) {\n+   /*  A,B, and C  are in row-major order */\n+   int c_row,c_col,inner;\n+   float sum;\n+   for (c_col  = 0 ;  c_col<N; c_col++ ) {\n+      for (c_row = 0 ; c_row<M; c_row++ ) {\n+         sum = 0.0 ;\n+         for (inner = 0 ; inner<K; inner++ ) {\n+            sum += A[c_row*LDA + inner] * B[inner*LDB + c_col] ;\n+         }\n+         C[c_row*LDC + c_col] = alpha*sum + beta*C[ c_row*LDC + c_col] ;\n+      }\n+   }\n+}\n+\n+/***************************\n+\n+   tiled_sgemm_tt:  Tiled matrix multiplication:\n+\n+***************************/\n+\n+void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n+   const float*B, const int LDB, const float beta, float*C, const int LDC){\n+\n+#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n+#pragma omp distribute collapse(2)\n+   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE)\n+      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE)\n+\t{\n+//       Each team has a local copy of these mini matrices\n+         float As[BLOCK_SIZE][BLOCK_SIZE];\n+         float Bs[BLOCK_SIZE][BLOCK_SIZE];\n+#pragma omp parallel\n+\t {\n+         int C_row, C_col;\n+         float Cval = 0.0;\n+\n+         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE )\n+\t   {\n+#pragma omp for collapse(2)\n+\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n+               for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t\t {\n+\t\t   C_row = C_row_start + row;\n+\t\t   C_col = C_col_start + col;\n+\t\t   if ((C_row < M) && (kblock + col < K))\n+\t\t     As[row][col] = A[(C_row*LDA)+ kblock + col];\n+\t\t   else\n+\t\t     As[row][col] = 0;\n+\t\t   if ((kblock + row < K) && C_col < N)\n+\t\t     Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n+\t\t   else\n+\t\t     Bs[row][col] = 0;\n+\t\t }\n+\n+#pragma omp for collapse(2)\n+\t     for (int row=0 ; row < BLOCK_SIZE ; row++)\n+\t       for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t\t {\n+\t\t   for (int e = 0; e < BLOCK_SIZE; ++e)\n+                     Cval += As[row][e] * Bs[e][col];\n+\t\t }\n+\t   }  /* End for kblock .. */\n+\n+\n+#pragma omp for collapse(2)\n+         for (int row=0 ; row < BLOCK_SIZE ; row++)\n+\t   for (int col=0 ; col < BLOCK_SIZE ; col++)\n+\t     {\n+               C_row = C_row_start + row;\n+               C_col = C_col_start + col;\n+\t       if ((C_row < M) && (C_col < N))\n+\t\t C[(C_row*LDC)+C_col] = alpha*Cval + beta*C[(C_row*LDC)+C_col];\n+\n+\t     }\n+         } /* end parallel */\n+      }\t   /* end target teams distribute */\n+}"}, {"sha": "6e5430455598e9c38f3e97a74529612de372187c", "filename": "libgomp/testsuite/libgomp.hsa.c/tiling-2.c", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b1c60e412fcf1245b4780871553cbdebb956a3/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.hsa.c%2Ftiling-2.c?ref=56b1c60e412fcf1245b4780871553cbdebb956a3", "patch": "@@ -0,0 +1,258 @@\n+/*\n+\n+   matmul.c : Matrix Multiplication with tiling for openmp4 example\n+\n+*/\n+\n+#include <stdlib.h>\n+#include <math.h>\n+\n+#define BLOCK_SIZE 16\n+/*\n+  #define BLOCK_SIZE 32\n+*/\n+#define NSECPERSEC 1000000000L\n+\n+typedef struct {\n+   int width;\n+   int height;\n+   int stride;\n+   int hpad;\n+   float* elements;\n+} Matrix;\n+\n+/* Correctly extract the number of nanoseconds from the two time structures */\n+long int get_nanosecs( struct timespec start_time, struct timespec end_time) {\n+   long int nanosecs;\n+   if ((end_time.tv_nsec-start_time.tv_nsec)<0) nanosecs =\n+      ((((long int) end_time.tv_sec- (long int) start_time.tv_sec )-1)*NSECPERSEC ) +\n+      ( NSECPERSEC + (long int) end_time.tv_nsec - (long int) start_time.tv_nsec) ;\n+   else nanosecs =\n+      (((long int) end_time.tv_sec- (long int) start_time.tv_sec )*NSECPERSEC ) +\n+      ( (long int) end_time.tv_nsec - (long int) start_time.tv_nsec );\n+   return nanosecs;\n+}\n+\n+void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n+     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n+void simple_sgemm_tn(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n+     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n+void  tiled_sgemm_tt(const int M,const int N,const int K,const float alpha, const float*A, const int LDA,\n+     const float* B,const int LDB, const float beta,float* C, const int LDC) ;\n+\n+int verify(float* v_res, float* v_ref, int len) {\n+    int passed = 1;\n+    int i;\n+    for (i = 0; i < len; ++i) {\n+        if (fabs(v_res[i] - v_ref[i]) > 0.001*v_ref[i]) {\n+\t  __builtin_abort ();\n+        }\n+    }\n+    return passed;\n+}\n+\n+\n+int main(int argc, char* argv[]){\n+\n+   Matrix A,B,Bt,C,Cref;\n+   int a1,a2,a3,i,j;\n+   struct timespec start_time1, end_time1;\n+   struct timespec start_time2, end_time2;\n+   long int nanosecs,total_ops;\n+   float gflopsTiled,gflopsCPU;\n+\n+   a1 = 35;\n+   a2 = 28;\n+   a3 = 47;\n+\n+   A.height = a1;\n+   A.width = a2;\n+   A.stride = (((A.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   A.hpad = (((A.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   A.elements = (float*)malloc(A.stride * A.hpad* sizeof(float));\n+\n+   B.height = a2;\n+   B.width = a3;\n+   B.stride = (((B.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   B.hpad = (((B.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   B.elements = (float*)malloc(B.stride * B.hpad * sizeof(float));\n+\n+   /* Bt is same as B but stored in column-major order */\n+   Bt.height = B.height;\n+   Bt.width = B.width;\n+   Bt.stride = B.stride;\n+   Bt.hpad = B.hpad;\n+   Bt.elements = (float*)malloc(Bt.stride * Bt.hpad * sizeof(float));\n+\n+   C.height = a1;\n+   C.width = a3;\n+   C.stride = (((C.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   C.hpad = (((C.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   C.elements = (float*)malloc(C.stride * C.hpad * sizeof(float));\n+\n+   Cref.height = a1;\n+   Cref.width = a3;\n+   Cref.stride = (((Cref.width-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   Cref.hpad = (((Cref.height-1)/BLOCK_SIZE)+1) * BLOCK_SIZE;\n+   Cref.elements = (float*)malloc(Cref.stride * Cref.hpad * sizeof(float));\n+\n+   for(i = 0; i < A.hpad ; i++)\n+      for(j = 0; j < A.stride; j++) {\n+         if (( j<A.width ) && (i<A.height)) {\n+            A.elements[i*A.stride + j] = (i % 3);\n+         } else {\n+            A.elements[i*A.stride + j] = 0.0;\n+         }\n+      }\n+\n+   /*  Initialize B and Bt */\n+   for(i = 0; i < B.hpad ; i++)\n+      for(j = 0; j < B.stride; j++) {\n+         if (( j<B.width ) && (i<B.height)) {\n+            B.elements[i*B.stride+j] = (j % 2);\n+            Bt.elements[j*Bt.stride+i] = B.elements[i*B.stride+j] ;\n+         } else {\n+            B.elements[i*B.stride+j] = 0.0;\n+            Bt.elements[j*Bt.stride+i] = 0.0;\n+         }\n+      }\n+\n+   /* zero C, and Cref */\n+   for(i = 0; i < C.hpad; i++)\n+      for(j = 0; j < C.stride; j++) {\n+         C.elements[i*C.stride+j] = 0.0;\n+         Cref.elements[i*Cref.stride+j] = 0.0;\n+      }\n+\n+   simple_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,Cref.elements,Cref.stride);\n+   tiled_sgemm_tt(A.height,B.width,B.height,1.0,A.elements,A.stride,B.elements,B.stride,1.0,C.elements,C.stride);\n+\n+   verify(C.elements, Cref.elements, C.height * C.stride);\n+   return 0;\n+}\n+\n+void simple_sgemm_tt(const int M,const int N,const int K,const float alpha, const float* A,const int LDA,\n+const float* B,const int LDB, const float beta,float* C, const int LDC) {\n+   /*  A,B, and C  are in row-major order */\n+   int c_row,c_col,inner;\n+   float sum;\n+   for (c_col  = 0 ;  c_col<N; c_col++ ) {\n+      for (c_row = 0 ; c_row<M; c_row++ ) {\n+         sum = 0.0 ;\n+         for (inner = 0 ; inner<K; inner++ ) {\n+            sum += A[c_row*LDA + inner] * B[inner*LDB + c_col] ;\n+         }\n+         C[c_row*LDC + c_col] = alpha*sum + beta*C[ c_row*LDC + c_col] ;\n+      }\n+   }\n+}\n+\n+/***************************\n+\n+   tiled_sgemm_tt:  Tiled matrix multiplication:\n+\n+***************************/\n+\n+void tiled_sgemm_tt(const int M, const int N, const int K, const float alpha, const float*A, const int LDA,\n+   const float*B, const int LDB, const float beta, float*C, const int LDC){\n+\n+#pragma omp target teams map(to:A[M*K],B[K*N]) map(from:C[M*N])\n+#pragma omp distribute collapse(2)\n+   for (int C_row_start=0 ; C_row_start < M ; C_row_start+=BLOCK_SIZE) {\n+      for (int C_col_start=0 ; C_col_start < N ; C_col_start+=BLOCK_SIZE) {\n+\n+// We now have M/BLOCK_SIZE * N/BLOCK_SIZE teams = (M*N)/(BLOCK_SIZE*BLOCK_SIZE)\n+// The grid global dimensions are M,N,1\n+// The grid local dimensions are BLOCK_SIZE,BLOCK_SIZE,1\n+\n+// -------------------------------------------------------------------\n+//      The rest of this code forms the HSAIL kernel with the\n+//      pairs of \"paralell for collapse(2)\" loops repalced with a barrier.\n+//      The kernel initializes these values\n+//      C_row_start = get_group_id(0) * BLOCK_SIZE\n+//      C_col_start = get_group_id(1) * BLOCK_SIZE\n+//      row=get_local_id(0)\n+//      col=get_local_id(1)\n+// -------------------------------------------------------------------\n+\n+//       Each team has a local copy of these mini matrices\n+         float As[BLOCK_SIZE][BLOCK_SIZE];\n+         float Bs[BLOCK_SIZE][BLOCK_SIZE];\n+         float Cs[BLOCK_SIZE][BLOCK_SIZE];\n+         int C_row, C_col;\n+\n+         /* Zero Cs for this BLOCK */\n+// - - - - - - - - - - - - - - - - - - - -\n+// REPLACE NEXT THREE LINES WITH A BARRIER\n+#pragma omp parallel for collapse(2)\n+         for (int row=0 ; row < BLOCK_SIZE ; row++) {\n+            for (int col=0 ; col < BLOCK_SIZE ; col++) {\n+// END BARRIER\n+// - - - - - - - - - - - - - - - - - - - -\n+               Cs[row][col] = 0.0;\n+            }\n+         }\n+\n+         // This kblock loop is run on the master thread of each team\n+         for (int kblock = 0; kblock  < K ; kblock += BLOCK_SIZE ) {\n+\n+            // Copy global memory values to local memory\n+// - - - - - - - - - - - - - - - - - - - -\n+// REPLACE NEXT THREE LINES WITH A BARRIER\n+#pragma omp parallel for collapse(2)\n+            for (int row=0 ; row < BLOCK_SIZE ; row++) {\n+               for (int col=0 ; col < BLOCK_SIZE ; col++) {\n+// END BARRIER\n+// - - - - - - - - - - - - - - - - - - - -\n+                  C_row = C_row_start + row;\n+                  C_col = C_col_start + col;\n+\t\t  if ((C_row < M) && (kblock + col < K))\n+\t\t    As[row][col] = A[(C_row*LDA)+ kblock + col];\n+\t\t  else\n+\t\t    As[row][col] = 0;\n+\t\t  if ((kblock + row < K) && C_col < N)\n+\t\t    Bs[row][col] = B[((kblock+row)*LDB)+ C_col];\n+\t\t  else\n+\t\t    Bs[row][col] = 0;\n+               }\n+            }\n+\n+            // Calculate Cs <- Sum(As X Bs) across all kblocks\n+// - - - - - - - - - - - - - - - - - - - -\n+// REPLACE NEXT THREE LINES WITH A BARRIER\n+#pragma omp parallel for collapse(2)\n+            for (int row=0 ; row < BLOCK_SIZE ; row++) {\n+               for (int col=0 ; col < BLOCK_SIZE ; col++) {\n+// END BARRIER\n+// - - - - - - - - - - - - - - - - - - - -\n+                  for (int e = 0; e < BLOCK_SIZE; ++e)\n+                     Cs[row][col] += As[row][e] * Bs[e][col];\n+                }\n+            }\n+\n+         }  /* End for kblock .. */\n+\n+\n+         // Scale Update actual C from Cs\n+// - - - - - - - - - - - - - - - - - - - -\n+// REPLACE NEXT THREE LINES WITH A BARRIER\n+#pragma omp parallel for collapse(2)\n+         for (int row=0 ; row < BLOCK_SIZE ; row++) {\n+            for (int col=0 ; col < BLOCK_SIZE ; col++) {\n+// END BARRIER\n+// - - - - - - - - - - - - - - - - - - - -\n+               C_row = C_row_start + row;\n+               C_col = C_col_start + col;\n+\t       if ((C_row < M) && (C_col < N)) {\n+\t\t C[(C_row*LDC)+C_col] = alpha*Cs[row][col] + beta*C[(C_row*LDC)+C_col];\n+\t       }\n+            }\n+         }\n+\n+// -------------------------------------------------------------------\n+// This is the end of the kernel\n+\n+      }\n+   }\n+\n+}"}]}