{"sha": "8a5d50bd4837528ad014f967f5c92022b129c6b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE1ZDUwYmQ0ODM3NTI4YWQwMTRmOTY3ZjVjOTIwMjJiMTI5YzZiMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-12-15T18:57:39Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-12-15T18:57:39Z"}, "message": "re PR c++/42358 ([C++0x] Assembler failure on libstdc++-v3/testsuite/23_containers/multimap/init-list.cc with -O0)\n\n\tPR c++/42358\n\t* pt.c (iterative_hash_template_arg): Completely ignore\n\tARGUMENT_PACK_SELECT.\n\nFrom-SVN: r155267", "tree": {"sha": "86a103838b6472b92f30924baf964a34281790d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86a103838b6472b92f30924baf964a34281790d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a5d50bd4837528ad014f967f5c92022b129c6b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a5d50bd4837528ad014f967f5c92022b129c6b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a5d50bd4837528ad014f967f5c92022b129c6b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a5d50bd4837528ad014f967f5c92022b129c6b1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37152770b28e7b8e731e5889872dc576465cf9c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37152770b28e7b8e731e5889872dc576465cf9c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37152770b28e7b8e731e5889872dc576465cf9c4"}], "stats": {"total": 432, "additions": 427, "deletions": 5}, "files": [{"sha": "f00ef8451582d615971048ea7dde1ef2a0ba59cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8a5d50bd4837528ad014f967f5c92022b129c6b1", "patch": "@@ -1,3 +1,9 @@\n+2009-12-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/42358\n+\t* pt.c (iterative_hash_template_arg): Completely ignore\n+\tARGUMENT_PACK_SELECT.\n+\n 2009-12-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/41183"}, {"sha": "24852dd2255338db4764e227d887e5d08c1a28d9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8a5d50bd4837528ad014f967f5c92022b129c6b1", "patch": "@@ -1457,6 +1457,11 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n   if (!TYPE_P (arg))\n     STRIP_NOPS (arg);\n \n+  if (TREE_CODE (arg) == ARGUMENT_PACK_SELECT)\n+    /* We can get one of these when re-hashing a previous entry in the middle\n+       of substituting into a pack expansion.  Just look through it.  */\n+    arg = ARGUMENT_PACK_SELECT_FROM_PACK (arg);\n+\n   code = TREE_CODE (arg);\n   tclass = TREE_CODE_CLASS (code);\n \n@@ -1482,11 +1487,6 @@ iterative_hash_template_arg (tree arg, hashval_t val)\n     case EXPR_PACK_EXPANSION:\n       return iterative_hash_template_arg (PACK_EXPANSION_PATTERN (arg), val);\n \n-    case ARGUMENT_PACK_SELECT:\n-      /* We can get one of these when re-hashing a previous entry in the middle\n-         of substituting into a pack expansion.  Just look through it...  */\n-      arg = ARGUMENT_PACK_SELECT_FROM_PACK (arg);\n-      /* ...and fall through.  */\n     case TYPE_ARGUMENT_PACK:\n     case NONTYPE_ARGUMENT_PACK:\n       return iterative_hash_template_arg (ARGUMENT_PACK_ARGS (arg), val);"}, {"sha": "1549424166859469293e1833bc7b069f1975ef47", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8a5d50bd4837528ad014f967f5c92022b129c6b1", "patch": "@@ -1,3 +1,8 @@\n+2009-12-15  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/42358\n+\t* g++.dg/cpp0x/variadic98.C: New.\n+\n 2009-12-14  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/42373"}, {"sha": "6af599fcaa0083a93f01da156033ca596dcc6d1c", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic98.C", "status": "added", "additions": 411, "deletions": 0, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic98.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a5d50bd4837528ad014f967f5c92022b129c6b1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic98.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic98.C?ref=8a5d50bd4837528ad014f967f5c92022b129c6b1", "patch": "@@ -0,0 +1,411 @@\n+// PR c++/42358\n+// { dg-do assemble }\n+// { dg-options -std=c++0x }\n+\n+typedef __PTRDIFF_TYPE__ ptrdiff_t;\n+typedef __SIZE_TYPE__ size_t;\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+    using ::size_t;\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+    struct __sfinae_types   {\n+\ttypedef char __one;\n+\ttypedef struct {\n+\t} __two;\n+    };\n+    template<typename _Tp, _Tp __v>     struct integral_constant     {\n+\tstatic const _Tp value = __v;\n+\ttypedef _Tp value_type;\n+\ttypedef integral_constant<_Tp, __v> type;\n+    };\n+    typedef integral_constant<bool, false> false_type;\n+    template<typename>     struct remove_cv;\n+    template<typename>     struct __is_void_helper     : public false_type {\n+    };\n+    template<typename _Tp>     struct is_void     : public integral_constant<bool, (__is_void_helper<typename           remove_cv<_Tp>::type>::value)>     {\n+    };\n+    template<typename>     struct is_array     : public false_type {\n+    };\n+    template<typename>     struct is_function     : public false_type {\n+    };\n+    template<typename, unsigned _Uint = 0>     struct extent     : public integral_constant<std::size_t, 0> {\n+    };\n+    template<typename _Tp>     struct remove_const     {\n+\ttypedef _Tp type;\n+    };\n+    template<typename _Tp>     struct remove_volatile     {\n+\ttypedef _Tp type;\n+    };\n+    template<typename _Tp>     struct remove_cv     {\n+\ttypedef typename       remove_const<typename remove_volatile<_Tp>::type>::type type;\n+    };\n+    template<typename>     struct is_lvalue_reference     : public false_type {\n+    };\n+    template<typename>     struct is_rvalue_reference     : public false_type {\n+    };\n+    template<typename _Tp>     struct is_reference     : public integral_constant<bool, (is_lvalue_reference<_Tp>::value           || is_rvalue_reference<_Tp>::value)>     {\n+    };\n+    template<typename _Tp>     struct remove_reference     {\n+\ttypedef _Tp type;\n+    };\n+    template<typename _Tp,     bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>     struct __add_rvalue_reference_helper     {\n+\ttypedef _Tp type;\n+    };\n+    template<typename _Tp>     struct add_rvalue_reference     : public __add_rvalue_reference_helper<_Tp>     {\n+    };\n+    template<typename _Tp>     typename add_rvalue_reference<_Tp>::type declval();\n+    template<typename _From, typename _To,     bool = (is_void<_From>::value || is_void<_To>::value      || is_function<_To>::value || is_array<_To>::value)>     struct __is_convertible_helper     {\n+    };\n+    template<typename _From, typename _To>     struct __is_convertible_helper<_From, _To, false>     : public __sfinae_types     {\n+\tstatic __one __test(_To);\n+\tstatic __two __test(...);\n+\tstatic const bool __value = sizeof(__test(declval<_From>())) == 1;\n+    };\n+    template<typename _From, typename _To>     struct is_convertible     : public integral_constant<bool,           __is_convertible_helper<_From, _To>::__value>     {\n+    };\n+    template<bool, typename _Tp = void>     struct enable_if     {\n+    };\n+    template<typename _Tp>     struct enable_if<true, _Tp>     {\n+\ttypedef _Tp type;\n+    };\n+    template<typename _Tp>     struct identity     {\n+\ttypedef _Tp type;\n+    };\n+    template<typename _Tp>     inline typename enable_if<!is_lvalue_reference<_Tp>::value, _Tp&&>::type     forward(typename std::identity<_Tp>::type& __t)     {\n+    }\n+    template<typename _Tp>     inline typename enable_if<is_lvalue_reference<_Tp>::value, _Tp>::type     forward(typename std::identity<_Tp>::type __t)     {\n+    }\n+    template<typename _Tp>     inline typename std::remove_reference<_Tp>::type&&     move(_Tp&& __t)     {\n+    }\n+    template<class _T1, class _T2>     struct pair     {\n+\ttypedef _T1 first_type;\n+\ttypedef _T2 second_type;\n+\t_T1 first;\n+\t_T2 second;\n+\ttemplate<class _U1, class = typename         std::enable_if<std::is_convertible<_U1, _T1>::value>::type>         pair(_U1&& __x, const _T2& __y)  : first(std::forward<_U1>(__x)),    second(__y) {\n+\t}\n+\ttemplate<class _U2, class = typename         std::enable_if<std::is_convertible<_U2, _T2>::value>::type>         pair(const _T1& __x, _U2&& __y)  : first(__x),    second(std::forward<_U2>(__y)) {\n+\t}\n+\ttemplate<class _U1, class _U2, class = typename         std::enable_if<std::is_convertible<_U1, _T1>::value          && std::is_convertible<_U2, _T2>::value>::type>         pair(_U1&& __x, _U2&& __y)  : first(std::forward<_U1>(__x)),    second(std::forward<_U2>(__y)) {\n+\t}\n+\ttemplate<class _U1, class _U2>         pair(pair<_U1, _U2>&& __p)  : first(std::move(__p.first)),    second(std::move(__p.second)) {\n+\t}\n+\ttemplate<class _U1, class _U2>         pair&         operator=(pair<_U1, _U2>&& __p)  {\n+\t}\n+    };\n+    struct input_iterator_tag {\n+    };\n+    struct output_iterator_tag {\n+    };\n+    struct forward_iterator_tag : public input_iterator_tag {\n+    };\n+    struct bidirectional_iterator_tag : public forward_iterator_tag {\n+    };\n+    template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,            typename _Pointer = _Tp*, typename _Reference = _Tp&>     struct iterator     {\n+\ttypedef _Category iterator_category;\n+\ttypedef _Tp value_type;\n+\ttypedef _Distance difference_type;\n+\ttypedef _Pointer pointer;\n+\ttypedef _Reference reference;\n+    };\n+    template<typename _Iterator>     struct iterator_traits     {\n+\ttypedef typename _Iterator::iterator_category iterator_category;\n+\ttypedef typename _Iterator::value_type value_type;\n+\ttypedef typename _Iterator::difference_type difference_type;\n+\ttypedef typename _Iterator::pointer pointer;\n+\ttypedef typename _Iterator::reference reference;\n+    };\n+    template<typename _Iter>     inline typename iterator_traits<_Iter>::iterator_category     __iterator_category(const _Iter&)     {\n+    }\n+    template<typename _InputIterator>     inline typename iterator_traits<_InputIterator>::difference_type     __distance(_InputIterator __first, _InputIterator __last,                input_iterator_tag)     {\n+    }\n+    template<typename _InputIterator>     inline typename iterator_traits<_InputIterator>::difference_type     distance(_InputIterator __first, _InputIterator __last)     {\n+\treturn std::__distance(__first, __last,         std::__iterator_category(__first));\n+    }\n+    template<typename _Iterator>     class reverse_iterator     : public iterator<typename iterator_traits<_Iterator>::iterator_category,         typename iterator_traits<_Iterator>::value_type,         typename iterator_traits<_Iterator>::difference_type,         typename iterator_traits<_Iterator>::pointer,                       typename iterator_traits<_Iterator>::reference>     {\n+    };\n+    template<typename _Container>     class back_insert_iterator     : public iterator<output_iterator_tag, void, void, void, void>     {\n+    };\n+}\n+namespace __gnu_cxx __attribute__ ((__visibility__ (\"default\"))) {\n+    template<typename _Tp>     class new_allocator     {\n+    public:\n+\ttypedef size_t size_type;\n+\ttypedef ptrdiff_t difference_type;\n+\ttypedef _Tp* pointer;\n+\ttypedef const _Tp* const_pointer;\n+\ttypedef _Tp& reference;\n+\ttypedef const _Tp& const_reference;\n+\ttypedef _Tp value_type;\n+\tnew_allocator() throw() {\n+\t}\n+\tnew_allocator(const new_allocator&) throw() {\n+\t}\n+\ttemplate<typename _Tp1>         new_allocator(const new_allocator<_Tp1>&) throw() {\n+\t}\n+\ttemplate<typename... _Args>         void         construct(pointer __p, _Args&&... __args)  {\n+\t}\n+    };\n+}\n+namespace std __attribute__ ((__visibility__ (\"default\"))) {\n+    template<typename _Tp>     class allocator: public __gnu_cxx::new_allocator<_Tp>     {\n+    public:\n+\ttypedef size_t size_type;\n+\ttypedef ptrdiff_t difference_type;\n+\ttypedef _Tp* pointer;\n+\ttypedef const _Tp* const_pointer;\n+\ttypedef _Tp& reference;\n+\ttypedef const _Tp& const_reference;\n+\ttypedef _Tp value_type;\n+\ttemplate<typename _Tp1>         struct rebind         {\n+\t    typedef allocator<_Tp1> other;\n+\t};\n+\tallocator() throw() {\n+\t}\n+\ttemplate<typename _Tp1>         allocator(const allocator<_Tp1>&) throw() {\n+\t}\n+    };\n+    extern template class allocator<char>;\n+    extern template class allocator<wchar_t>;\n+    template<typename _Arg, typename _Result>     struct unary_function     {\n+\ttypedef _Arg argument_type;\n+\ttypedef _Result result_type;\n+    };\n+    template<typename _Arg1, typename _Arg2, typename _Result>     struct binary_function     {\n+\ttypedef _Arg1 first_argument_type;\n+\ttypedef _Arg2 second_argument_type;\n+\ttypedef _Result result_type;\n+    };\n+    template<typename _Tp>     struct less : public binary_function<_Tp, _Tp, bool>     {\n+\tbool       operator()(const _Tp& __x, const _Tp& __y) const       {\n+\t}\n+    };\n+    template<typename _Pair>     struct _Select1st : public unary_function<_Pair,            typename _Pair::first_type>     {\n+\tconst typename _Pair::first_type&       operator()(const _Pair& __x) const       {\n+\t}\n+    };\n+    struct _Rb_tree_node_base   {\n+\ttypedef _Rb_tree_node_base* _Base_ptr;\n+\ttypedef const _Rb_tree_node_base* _Const_Base_ptr;\n+    };\n+    template<typename _Val>     struct _Rb_tree_node : public _Rb_tree_node_base     {\n+\ttypedef _Rb_tree_node<_Val>* _Link_type;\n+\t_Val _M_value_field;\n+\ttemplate<typename... _Args>         _Rb_tree_node(_Args&&... __args)  : _Rb_tree_node_base(),    _M_value_field(std::forward<_Args>(__args)...) {\n+\t}\n+    };\n+    template<typename _Tp>     struct _Rb_tree_iterator     {\n+\ttypedef _Tp value_type;\n+\ttypedef _Tp& reference;\n+\ttypedef _Tp* pointer;\n+\ttypedef bidirectional_iterator_tag iterator_category;\n+\ttypedef ptrdiff_t difference_type;\n+\ttypedef _Rb_tree_iterator<_Tp> _Self;\n+\ttypedef _Rb_tree_node_base::_Base_ptr _Base_ptr;\n+\ttypedef _Rb_tree_node<_Tp>* _Link_type;\n+\t_Base_ptr _M_node;\n+    };\n+    template<typename _Tp>     struct _Rb_tree_const_iterator     {\n+\ttypedef _Tp value_type;\n+\ttypedef const _Tp& reference;\n+\ttypedef const _Tp* pointer;\n+\ttypedef _Rb_tree_iterator<_Tp> iterator;\n+\ttypedef bidirectional_iterator_tag iterator_category;\n+\ttypedef ptrdiff_t difference_type;\n+\ttypedef _Rb_tree_const_iterator<_Tp> _Self;\n+\ttypedef _Rb_tree_node_base::_Const_Base_ptr _Base_ptr;\n+\ttypedef const _Rb_tree_node<_Tp>* _Link_type;\n+\texplicit       _Rb_tree_const_iterator(_Link_type __x)       : _M_node(__x) {\n+\t}\n+\t_Rb_tree_const_iterator(const iterator& __it)       : _M_node(__it._M_node) {\n+\t}\n+\t_Base_ptr _M_node;\n+    };\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc = allocator<_Val> >     class _Rb_tree     {\n+\ttypedef typename _Alloc::template rebind<_Rb_tree_node<_Val> >::other               _Node_allocator;\n+\ttypedef _Rb_tree_node_base* _Base_ptr;\n+\ttypedef const _Rb_tree_node_base* _Const_Base_ptr;\n+    public:\n+\ttypedef _Key key_type;\n+\ttypedef _Val value_type;\n+\ttypedef value_type* pointer;\n+\ttypedef const value_type* const_pointer;\n+\ttypedef value_type& reference;\n+\ttypedef const value_type& const_reference;\n+\ttypedef _Rb_tree_node<_Val>* _Link_type;\n+\ttypedef const _Rb_tree_node<_Val>* _Const_Link_type;\n+\ttypedef size_t size_type;\n+\ttypedef ptrdiff_t difference_type;\n+\ttypedef _Alloc allocator_type;\n+\t_Node_allocator&       _M_get_Node_allocator()       {\n+\t}\n+\t_Link_type       _M_get_node()       {\n+\t}\n+\ttemplate<typename... _Args>         _Link_type         _M_create_node(_Args&&... __args)  {\n+\t    _Link_type __tmp = _M_get_node();\n+\t    try      {\n+\t\t_M_get_Node_allocator().construct(__tmp,           std::forward<_Args>(__args)...);\n+\t    }\n+\t    catch(...)      {\n+\t    }\n+\t}\n+\ttemplate<typename _Key_compare,         bool _Is_pod_comparator = __is_pod(_Key_compare)>         struct _Rb_tree_impl : public _Node_allocator         {\n+\t    _Key_compare _M_key_compare;\n+\t    _Rb_tree_node_base _M_header;\n+\t    size_type _M_node_count;\n+\t    _Rb_tree_impl(const _Key_compare& __comp, const _Node_allocator& __a)    : _Node_allocator(__a), _M_key_compare(__comp), _M_header(),      _M_node_count(0)    {\n+\t    }\n+\t    void    _M_initialize()    {\n+\t    }\n+\t};\n+\t_Rb_tree_impl<_Compare> _M_impl;\n+\t_Base_ptr&       _M_rightmost()       {\n+\t}\n+\t_Link_type       _M_begin()       {\n+\t}\n+\t_Link_type       _M_end()       {\n+\t}\n+\t_Const_Link_type       _M_end() const       {\n+\t}\n+\tstatic _Link_type       _S_right(_Base_ptr __x)       {\n+\t}\n+\tstatic const_reference       _S_value(_Const_Base_ptr __x)       {\n+\t}\n+\tstatic const _Key&       _S_key(_Const_Base_ptr __x)       {\n+\t    return _KeyOfValue()(_S_value(__x));\n+\t}\n+\ttypedef _Rb_tree_iterator<value_type> iterator;\n+\ttypedef _Rb_tree_const_iterator<value_type> const_iterator;\n+\ttypedef std::reverse_iterator<iterator> reverse_iterator;\n+\ttypedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\titerator       _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __y,    const value_type& __v);\n+\titerator       _M_insert_lower(_Base_ptr __x, _Base_ptr __y, const value_type& __v);\n+\titerator       _M_insert_equal_lower(const value_type& __x);\n+\titerator       _M_lower_bound(_Link_type __x, _Link_type __y,        const _Key& __k);\n+\titerator       _M_upper_bound(_Link_type __x, _Link_type __y,        const _Key& __k);\n+\t_Rb_tree(const _Compare& __comp,         const allocator_type& __a = allocator_type())       : _M_impl(__comp, __a) {\n+\t}\n+\titerator       end()       {\n+\t}\n+\titerator       _M_insert_equal_(const_iterator __position, const value_type& __x);\n+\ttemplate<typename _InputIterator>         void         _M_insert_unique(_InputIterator __first, _InputIterator __last);\n+\ttemplate<typename _InputIterator>         void         _M_insert_equal(_InputIterator __first, _InputIterator __last);\n+\tsize_type       count(const key_type& __k) const;\n+\tpair<iterator, iterator>       equal_range(const key_type& __k);\n+\tpair<const_iterator, const_iterator>       equal_range(const key_type& __k) const;\n+    };\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_(_Const_Base_ptr __x, _Const_Base_ptr __p, const _Val& __v)     {\n+\t_Link_type __z = _M_create_node(__v);\n+    }\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_lower(_Base_ptr __x, _Base_ptr __p, const _Val& __v)     {\n+\t_Link_type __z = _M_create_node(__v);\n+    }\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_equal_lower(const _Val& __v)     {\n+\t_Link_type __x = _M_begin();\n+\t_Link_type __y = _M_end();\n+\treturn _M_insert_lower(__x, __y, __v);\n+    }\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::iterator,   typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::iterator>     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     equal_range(const _Key& __k)     {\n+\t_Link_type __x = _M_begin();\n+\t_Link_type __y = _M_end();\n+\twhile (__x != 0)  {\n+\t    if (_M_impl._M_key_compare(_S_key(__x), __k))      __x = _S_right(__x);\n+\t    else      {\n+\t\t_Link_type __xu(__x), __yu(__y);\n+\t\treturn pair<iterator,             iterator>(_M_lower_bound(__x, __y, __k),         _M_upper_bound(__xu, __yu, __k));\n+\t    }\n+\t}\n+    }\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::const_iterator,   typename _Rb_tree<_Key, _Val, _KeyOfValue,       _Compare, _Alloc>::const_iterator>     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     equal_range(const _Key& __k) const     {\n+\t_Const_Link_type __y = _M_end();\n+\treturn pair<const_iterator, const_iterator>(const_iterator(__y),         const_iterator(__y));\n+    }\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     _M_insert_equal_(const_iterator __position, const _Val& __v)     {\n+\tif (__position._M_node == _M_end())  {\n+\t    if (__position._M_node == _M_rightmost())      return _M_insert_(0, _M_rightmost(), __v);\n+\t    else      return _M_insert_equal_lower(__v);\n+\t}\n+    }\n+    template<typename _Key, typename _Val, typename _KoV,            typename _Cmp, typename _Alloc>     template<class _II>       void       _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::       _M_insert_equal(_II __first, _II __last)       {\n+\tfor (;\n+\t     __first != __last;\n+\t     ++__first)    _M_insert_equal_(end(), *__first);\n+    }\n+    template<typename _Key, typename _Val, typename _KeyOfValue,            typename _Compare, typename _Alloc>     typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::     count(const _Key& __k) const     {\n+\tpair<const_iterator, const_iterator> __p = equal_range(__k);\n+\tconst size_type __n = std::distance(__p.first, __p.second);\n+    }\n+    template<class _E>     class initializer_list     {\n+    public:\n+\ttypedef _E value_type;\n+\ttypedef const _E& reference;\n+\ttypedef const _E& const_reference;\n+\ttypedef size_t size_type;\n+\ttypedef const _E* iterator;\n+\ttypedef const _E* const_iterator;\n+\titerator _M_array;\n+\tsize_type _M_len;\n+\tinitializer_list(const_iterator __a, size_type __l)       : _M_array(__a), _M_len(__l) {\n+\t}\n+\tconst_iterator       begin() const {\n+\t}\n+\tconst_iterator       end() const {\n+\t}\n+    };\n+    template <typename _Key, typename _Tp,      typename _Compare = std::less<_Key>,      typename _Alloc = std::allocator<std::pair<const _Key, _Tp> > >     class multimap     {\n+\ttypedef _Key key_type;\n+\ttypedef _Tp mapped_type;\n+\ttypedef std::pair<const _Key, _Tp> value_type;\n+\ttypedef _Compare key_compare;\n+\ttypedef _Alloc allocator_type;\n+\ttypedef typename _Alloc::value_type _Alloc_value_type;\n+\ttypedef typename _Alloc::template rebind<value_type>::other         _Pair_alloc_type;\n+\ttypedef _Rb_tree<key_type, value_type, _Select1st<value_type>,          key_compare, _Pair_alloc_type> _Rep_type;\n+\t_Rep_type _M_t;\n+    public:\n+\ttypedef typename _Pair_alloc_type::pointer pointer;\n+\ttypedef typename _Pair_alloc_type::const_pointer const_pointer;\n+\ttypedef typename _Pair_alloc_type::reference reference;\n+\ttypedef typename _Pair_alloc_type::const_reference const_reference;\n+\ttypedef typename _Rep_type::iterator iterator;\n+\ttypedef typename _Rep_type::const_iterator const_iterator;\n+\ttypedef typename _Rep_type::size_type size_type;\n+\ttypedef typename _Rep_type::difference_type difference_type;\n+\ttypedef typename _Rep_type::reverse_iterator reverse_iterator;\n+\ttypedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;\n+\tmultimap(initializer_list<value_type> __l,         const _Compare& __comp = _Compare(),         const allocator_type& __a = allocator_type())       : _M_t(__comp, __a)       {\n+\t    _M_t._M_insert_equal(__l.begin(), __l.end());\n+\t}\n+\ttemplate<typename _InputIterator>         multimap(_InputIterator __first, _InputIterator __last)  : _M_t()         {\n+\t}\n+\ttemplate<typename _InputIterator>         multimap(_InputIterator __first, _InputIterator __last,    const _Compare& __comp,    const allocator_type& __a = allocator_type())         : _M_t(__comp, __a)         {\n+\t}\n+\ttemplate<typename _InputIterator>         void         insert(_InputIterator __first, _InputIterator __last)         {\n+\t}\n+\tsize_type       count(const key_type& __x) const       {\n+\t    return _M_t.count(__x);\n+\t}\n+\tstd::pair<iterator, iterator>       equal_range(const key_type& __x)       {\n+\t    return _M_t.equal_range(__x);\n+\t}\n+\ttemplate<typename _K1, typename _T1, typename _C1, typename _A1>         friend bool         operator==(const multimap<_K1, _T1, _C1, _A1>&,      const multimap<_K1, _T1, _C1, _A1>&);\n+\ttemplate<typename _K1, typename _T1, typename _C1, typename _A1>         friend bool         operator<(const multimap<_K1, _T1, _C1, _A1>&,     const multimap<_K1, _T1, _C1, _A1>&);\n+    };\n+}\n+extern \"C\" {\n+    extern void __assert_fail (__const char *__assertion, __const char *__file,       unsigned int __line, __const char *__function)      throw () __attribute__ ((__noreturn__));\n+}\n+using namespace std;\n+int test01() {\n+    typedef multimap<int,double> Container;\n+    typedef Container::iterator iterator;\n+    typedef pair<iterator,iterator> itpair;\n+    Container m({\n+\t\t{\n+\t\t1, 1.0 }\n+\t\t}\n+\t       );\n+    itpair ip = m.equal_range(1);\n+    ((distance(ip.first, ip.second) == 3) ? static_cast<void> (0) : __assert_fail (\"distance(ip.first, ip.second) == 3\", \"/home/richard/src/trunk/libstdc++-v3/testsuite/23_containers/multimap/init-list.cc\", 36, __PRETTY_FUNCTION__));\n+    ((m.count(7) == 2) ? static_cast<void> (0) : __assert_fail (\"m.count(7) == 2\", \"/home/richard/src/trunk/libstdc++-v3/testsuite/23_containers/multimap/init-list.cc\", 54, __PRETTY_FUNCTION__));\n+}"}]}