{"sha": "8f62128d21de91a372394a84ea4da997d5b35e73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY2MjEyOGQyMWRlOTFhMzcyMzk0YTg0ZWE0ZGE5OTdkNWIzNWU3Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-06T10:03:13Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-06T10:03:13Z"}, "message": "i386.c (x86_inter_unit_moves): New variable.\n\n\t* i386.c (x86_inter_unit_moves): New variable.\n\t(ix86_secondary_memory_needed): Fix 64bit case, honor\n\tTARGET_INTER_UNIT_MOVES\n\t* i386.h (x86_inter_unit_moves): Declare.\n\t(TARGET_INTER_UNIT_MOVES): New macro.\n\t* i386.md (movsi_1): Cleanup constraints; disable\n\twhen not doing inter-unit moves.\n\t(movsi_1_nointernunit): New.\n\t(movdi_1_rex64): Fix constraints; deal with SSE->GPR moves.\n\t(movdi_1_rex64_nointerunit): New.\n\t(mivsf_1): disable when not doing inter-unit moves.\n\t(movsf_1_nointerunit): New.\n\n\t* basic-block.h (inside_basic_block_p):  Declare.\n\t* cfgbuild.c (inside_basic_block_p): Make global.\n\t* haifa-sched.c (unlink_other_notes0: Deal with NOT_INSN_BASIC_BLOCK.\n\t* scheudle-ebb.c  (schedule_ebb): Return last basic block of trace;\n\tupdate CFG.\n\t(fix_basic_block_boundaries, add_missing_bbs): New.\n\t(rank): Use profile.\n\t(scheudle_ebbs): Rely on CFG; update coments.\n\nFrom-SVN: r62477", "tree": {"sha": "d48ce6d178524f715563dd56706ee443cb3f0d5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d48ce6d178524f715563dd56706ee443cb3f0d5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f62128d21de91a372394a84ea4da997d5b35e73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f62128d21de91a372394a84ea4da997d5b35e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f62128d21de91a372394a84ea4da997d5b35e73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f62128d21de91a372394a84ea4da997d5b35e73/comments", "author": null, "committer": null, "parents": [{"sha": "6eeabb09a66d8c47f387da7882f86780da50cdd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eeabb09a66d8c47f387da7882f86780da50cdd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eeabb09a66d8c47f387da7882f86780da50cdd8"}], "stats": {"total": 442, "additions": 405, "deletions": 37}, "files": [{"sha": "ea7c3c50214340e7c818c17a29e0caefa3d820b1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -1,3 +1,27 @@\n+Thu Feb  6 00:18:38 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (x86_inter_unit_moves): New variable.\n+\t(ix86_secondary_memory_needed): Fix 64bit case, honor\n+\tTARGET_INTER_UNIT_MOVES\n+\t* i386.h (x86_inter_unit_moves): Declare.\n+\t(TARGET_INTER_UNIT_MOVES): New macro.\n+\t* i386.md (movsi_1): Cleanup constraints; disable\n+\twhen not doing inter-unit moves.\n+\t(movsi_1_nointernunit): New.\n+\t(movdi_1_rex64): Fix constraints; deal with SSE->GPR moves.\n+\t(movdi_1_rex64_nointerunit): New.\n+\t(mivsf_1): disable when not doing inter-unit moves.\n+\t(movsf_1_nointerunit): New.\n+\n+\t* basic-block.h (inside_basic_block_p):  Declare.\n+\t* cfgbuild.c (inside_basic_block_p): Make global.\n+\t* haifa-sched.c (unlink_other_notes0: Deal with NOT_INSN_BASIC_BLOCK.\n+\t* scheudle-ebb.c  (schedule_ebb): Return last basic block of trace;\n+\tupdate CFG.\n+\t(fix_basic_block_boundaries, add_missing_bbs): New.\n+\t(rank): Use profile.\n+\t(scheudle_ebbs): Rely on CFG; update coments.\n+\n 2003-02-05  Geoffrey Keating  <geoffk@apple.com>\n \n \t* Makefile.in (host_hook_obj): New."}, {"sha": "680bba505fcc87749587133c8a5c766eb81f779d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -613,6 +613,7 @@ extern void fixup_abnormal_edges\tPARAMS ((void));\n extern bool can_hoist_insn_p\t\tPARAMS ((rtx, rtx, regset));\n extern rtx hoist_insn_after\t\tPARAMS ((rtx, rtx, rtx, rtx));\n extern rtx hoist_insn_to_edge\t\tPARAMS ((rtx, edge, rtx, rtx));\n+extern bool inside_basic_block_p\tPARAMS ((rtx));\n extern bool control_flow_insn_p\t\tPARAMS ((rtx));\n \n /* In dominance.c */"}, {"sha": "d5d1b2009dbcae56d7c5c22886e01f10b81cc849", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -58,12 +58,11 @@ static void make_label_edge\t\tPARAMS ((sbitmap *, basic_block,\n static void make_eh_edge\t\tPARAMS ((sbitmap *, basic_block, rtx));\n static void find_bb_boundaries\t\tPARAMS ((basic_block));\n static void compute_outgoing_frequencies PARAMS ((basic_block));\n-static bool inside_basic_block_p\tPARAMS ((rtx));\n \f\n /* Return true if insn is something that should be contained inside basic\n    block.  */\n \n-static bool\n+bool\n inside_basic_block_p (insn)\n      rtx insn;\n {"}, {"sha": "2c71e1e88d427a2dee7ae697d4010137a6215e55", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -521,6 +521,7 @@ const int x86_sse_typeless_stores = m_ATHLON_K8;\n const int x86_sse_load0_by_pxor = m_PPRO | m_PENT4;\n const int x86_use_ffreep = m_ATHLON_K8;\n const int x86_rep_movl_optimal = m_386 | m_PENT | m_PPRO | m_K6;\n+const int x86_inter_unit_moves = ~(m_ATHLON_K8);\n \n /* In case the average insn count for single function invocation is\n    lower than this constant, emit fast (but longer) prologue and\n@@ -14386,10 +14387,10 @@ ix86_secondary_memory_needed (class1, class2, mode, strict)\n \treturn 1;\n     }\n   return (FLOAT_CLASS_P (class1) != FLOAT_CLASS_P (class2)\n-\t  || (SSE_CLASS_P (class1) != SSE_CLASS_P (class2)\n-\t      && (mode) != SImode)\n-\t  || (MMX_CLASS_P (class1) != MMX_CLASS_P (class2)\n-\t      && (mode) != SImode));\n+\t  || ((SSE_CLASS_P (class1) != SSE_CLASS_P (class2)\n+\t       || MMX_CLASS_P (class1) != MMX_CLASS_P (class2))\n+\t      && ((mode != SImode && (mode != DImode || !TARGET_64BIT))\n+\t\t  || (!TARGET_INTER_UNIT_MOVES && !optimize_size))));\n }\n /* Return the cost of moving data from a register in class CLASS1 to\n    one in class CLASS2."}, {"sha": "8d1b5e428f4b3d266be64eb739bdb723b32f935a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -230,6 +230,7 @@ extern const int x86_arch_always_fancy_math_387, x86_shift1;\n extern const int x86_sse_partial_reg_dependency, x86_sse_partial_regs;\n extern const int x86_sse_typeless_stores, x86_sse_load0_by_pxor;\n extern const int x86_use_ffreep, x86_sse_partial_regs_for_cvtsd2ss;\n+extern const int x86_inter_unit_moves;\n extern int x86_prefetch_sse;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n@@ -282,6 +283,7 @@ extern int x86_prefetch_sse;\n #define TARGET_SHIFT1 (x86_shift1 & CPUMASK)\n #define TARGET_USE_FFREEP (x86_use_ffreep & CPUMASK)\n #define TARGET_REP_MOVL_OPTIMAL (x86_rep_movl_optimal & CPUMASK)\n+#define TARGET_INTER_UNIT_MOVES (x86_inter_unit_moves & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n "}, {"sha": "3bba254dfbe7ead24dce5ad6d3788480c3470817", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 206, "deletions": 13, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -1165,8 +1165,49 @@\n \n (define_insn \"*movsi_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*?a,r,*?a,m,!*y,!rm,!*y,!*Y,!rm,!*Y\")\n-\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin,rm,*y,*y,rm,*Y,*Y\"))]\n-  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n+\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin,*y,*y,rm,*Y,*Y,rm\"))]\n+  \"(TARGET_INTER_UNIT_MOVES || optimize_size)\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_SSEMOV:\n+      if (get_attr_mode (insn) == TImode)\n+        return \"movdqa\\t{%1, %0|%0, %1}\";\n+      return \"movd\\t{%1, %0|%0, %1}\";\n+\n+    case TYPE_MMXMOV:\n+      if (get_attr_mode (insn) == DImode)\n+\treturn \"movq\\t{%1, %0|%0, %1}\";\n+      return \"movd\\t{%1, %0|%0, %1}\";\n+\n+    case TYPE_LEA:\n+      return \"lea{l}\\t{%1, %0|%0, %1}\";\n+\n+    default:\n+      if (flag_pic && !LEGITIMATE_PIC_OPERAND_P (operands[1]))\n+\tabort();\n+      return \"mov{l}\\t{%1, %0|%0, %1}\";\n+    }\n+}\n+  [(set (attr \"type\")\n+     (cond [(eq_attr \"alternative\" \"4,5,6\")\n+\t      (const_string \"mmxmov\")\n+\t    (eq_attr \"alternative\" \"7,8,9\")\n+\t      (const_string \"ssemov\")\n+\t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t (match_operand:SI 1 \"symbolic_operand\" \"\"))\n+\t      (const_string \"lea\")\n+\t   ]\n+\t   (const_string \"imov\")))\n+   (set_attr \"modrm\" \"0,*,0,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,SI,SI,SI,DI,SI,SI,TI,SI,SI\")])\n+\n+(define_insn \"*movsi_1_nointernunit\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=*?a,r,*?a,m,!*y,!m,!*y,!*Y,!m,!*Y\")\n+\t(match_operand:SI 1 \"general_operand\" \"im,rinm,rinm,rin,*y,*y,m,*Y,*Y,m\"))]\n+  \"(!TARGET_INTER_UNIT_MOVES && !optimize_size)\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n   switch (get_attr_type (insn))\n     {\n@@ -1200,7 +1241,7 @@\n \t   ]\n \t   (const_string \"imov\")))\n    (set_attr \"modrm\" \"0,*,0,*,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,SI,SI,SI,SI,SI,DI,TI,SI,SI\")])\n+   (set_attr \"mode\" \"SI,SI,SI,SI,DI,SI,SI,TI,SI,SI\")])\n \n ;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -1931,17 +1972,21 @@\n   \"ix86_split_long_move (operands); DONE;\")\n \n (define_insn \"*movdi_1_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!m*y,!*y,!*Y,!m,!*Y\")\n-\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,m,*Y,*Y,*m\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!*y,!rm,!*y,!*Y,!rm,!*Y\")\n+\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,*y,rm,*Y,*Y,rm\"))]\n   \"TARGET_64BIT\n+   && (TARGET_INTER_UNIT_MOVES || optimize_size)\n    && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n {\n   switch (get_attr_type (insn))\n     {\n     case TYPE_SSEMOV:\n-      if (register_operand (operands[0], DImode)\n-\t  && register_operand (operands[1], DImode))\n+      if (get_attr_mode (insn) == MODE_TI)\n \t  return \"movdqa\\t{%1, %0|%0, %1}\";\n+      /* Moves from and into integer register is done using movd opcode with\n+ \t REX prefix.  */\n+      if (GENERAL_REG_P (operands[0]) || GENERAL_REG_P (operands[1]))\n+\t  return \"movd\\t{%1, %0|%0, %1}\";\n       /* FALLTHRU */\n     case TYPE_MMXMOV:\n       return \"movq\\t{%1, %0|%0, %1}\";\n@@ -1961,9 +2006,9 @@\n     }\n }\n   [(set (attr \"type\")\n-     (cond [(eq_attr \"alternative\" \"5,6\")\n+     (cond [(eq_attr \"alternative\" \"5,6,7\")\n \t      (const_string \"mmxmov\")\n-\t    (eq_attr \"alternative\" \"7,8\")\n+\t    (eq_attr \"alternative\" \"8,9,10\")\n \t      (const_string \"ssemov\")\n \t    (eq_attr \"alternative\" \"4\")\n \t      (const_string \"multi\")\n@@ -1972,9 +2017,55 @@\n \t      (const_string \"lea\")\n \t   ]\n \t   (const_string \"imov\")))\n-   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*\")\n-   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*\")\n-   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI\")])\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI,DI\")])\n+\n+(define_insn \"*movdi_1_rex64_nointerunit\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,mr,!mr,!*y,!m,!*y,!*Y,!m,!*Y\")\n+\t(match_operand:DI 1 \"general_operand\" \"Z,rem,i,re,n,*y,*y,m,*Y,*Y,m\"))]\n+  \"TARGET_64BIT\n+   && (!TARGET_INTER_UNIT_MOVES && !optimize_size)\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+{\n+  switch (get_attr_type (insn))\n+    {\n+    case TYPE_SSEMOV:\n+      if (get_attr_mode (insn) == MODE_TI)\n+\t  return \"movdqa\\t{%1, %0|%0, %1}\";\n+      /* FALLTHRU */\n+    case TYPE_MMXMOV:\n+      return \"movq\\t{%1, %0|%0, %1}\";\n+    case TYPE_MULTI:\n+      return \"#\";\n+    case TYPE_LEA:\n+      return \"lea{q}\\t{%a1, %0|%0, %a1}\";\n+    default:\n+      if (flag_pic && !LEGITIMATE_PIC_OPERAND_P (operands[1]))\n+\tabort ();\n+      if (get_attr_mode (insn) == MODE_SI)\n+\treturn \"mov{l}\\t{%k1, %k0|%k0, %k1}\";\n+      else if (which_alternative == 2)\n+\treturn \"movabs{q}\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"mov{q}\\t{%1, %0|%0, %1}\";\n+    }\n+}\n+  [(set (attr \"type\")\n+     (cond [(eq_attr \"alternative\" \"5,6,7\")\n+\t      (const_string \"mmxmov\")\n+\t    (eq_attr \"alternative\" \"8,9,10\")\n+\t      (const_string \"ssemov\")\n+\t    (eq_attr \"alternative\" \"4\")\n+\t      (const_string \"multi\")\n+ \t    (and (ne (symbol_ref \"flag_pic\") (const_int 0))\n+\t\t (match_operand:DI 1 \"symbolic_operand\" \"\"))\n+\t      (const_string \"lea\")\n+\t   ]\n+\t   (const_string \"imov\")))\n+   (set_attr \"modrm\" \"*,0,0,*,*,*,*,*,*,*,*\")\n+   (set_attr \"length_immediate\" \"*,4,8,*,*,*,*,*,*,*,*\")\n+   (set_attr \"mode\" \"SI,DI,DI,DI,SI,DI,DI,DI,TI,DI,DI\")])\n \n ;; Stores and loads of ax to arbitrary constant address.\n ;; We fake an second form of instruction to force reload to load address\n@@ -2129,7 +2220,109 @@\n (define_insn \"*movsf_1\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#xr,m,f#xr,r#xf,m,x#rf,x#rf,x#rf,m,!*y,!rm,!*y\")\n \t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,C,x,xm#rf,x#rf,rm,*y,*y\"))]\n-  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+  \"(TARGET_INTER_UNIT_MOVES || optimize_size)\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && (reload_in_progress || reload_completed\n+       || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n+       || GET_CODE (operands[1]) != CONST_DOUBLE\n+       || memory_operand (operands[0], SFmode))\" \n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \"fstp\\t%y0\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \"fld%z1\\t%y1\";\n+      else\n+        return \"fst\\t%y0\";\n+\n+    case 1:\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \"fstp%z0\\t%y0\";\n+      else\n+        return \"fst%z0\\t%y0\";\n+\n+    case 2:\n+      switch (standard_80387_constant_p (operands[1]))\n+        {\n+        case 1:\n+\t  return \"fldz\";\n+\tcase 2:\n+\t  return \"fld1\";\n+\t}\n+      abort();\n+\n+    case 3:\n+    case 4:\n+      return \"mov{l}\\t{%1, %0|%0, %1}\";\n+    case 5:\n+      if (get_attr_mode (insn) == MODE_TI)\n+\treturn \"pxor\\t%0, %0\";\n+      else\n+\treturn \"xorps\\t%0, %0\";\n+    case 6:\n+      if (get_attr_mode (insn) == MODE_V4SF)\n+\treturn \"movaps\\t{%1, %0|%0, %1}\";\n+      else\n+\treturn \"movss\\t{%1, %0|%0, %1}\";\n+    case 7:\n+    case 8:\n+      return \"movss\\t{%1, %0|%0, %1}\";\n+\n+    case 9:\n+    case 10:\n+      return \"movd\\t{%1, %0|%0, %1}\";\n+\n+    case 11:\n+      return \"movq\\t{%1, %0|%0, %1}\";\n+\n+    default:\n+      abort();\n+    }\n+}\n+  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,ssemov,ssemov,ssemov,ssemov,mmxmov,mmxmov,mmxmov\")\n+   (set (attr \"mode\")\n+        (cond [(eq_attr \"alternative\" \"3,4,9,10\")\n+\t\t (const_string \"SI\")\n+\t       (eq_attr \"alternative\" \"5\")\n+\t\t (if_then_else\n+\t\t   (and (and (ne (symbol_ref \"TARGET_SSE_LOAD0_BY_PXOR\")\n+\t\t\t    \t (const_int 0))\n+\t\t\t     (ne (symbol_ref \"TARGET_SSE2\")\n+\t\t\t\t (const_int 0)))\n+\t\t\t(eq (symbol_ref \"optimize_size\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_string \"TI\")\n+\t\t   (const_string \"V4SF\"))\n+\t       /* For architectures resolving dependencies on\n+\t\t  whole SSE registers use APS move to break dependency\n+\t\t  chains, otherwise use short move to avoid extra work. \n+\n+\t\t  Do the same for architectures resolving dependencies on\n+\t\t  the parts.  While in DF mode it is better to always handle\n+\t\t  just register parts, the SF mode is different due to lack\n+\t\t  of instructions to load just part of the register.  It is\n+\t\t  better to maintain the whole registers in single format\n+\t\t  to avoid problems on using packed logical operations.  */\n+\t       (eq_attr \"alternative\" \"6\")\n+\t\t (if_then_else\n+\t\t   (ior (ne (symbol_ref \"TARGET_SSE_PARTIAL_REG_DEPENDENCY\")\n+\t\t\t    (const_int 0))\n+\t\t\t(ne (symbol_ref \"TARGET_SSE_PARTIAL_REGS\")\n+\t\t\t    (const_int 0)))\n+\t\t   (const_string \"V4SF\")\n+\t\t   (const_string \"SF\"))\n+\t       (eq_attr \"alternative\" \"11\")\n+\t\t (const_string \"DI\")]\n+\t       (const_string \"SF\")))])\n+\n+(define_insn \"*movsf_1_nointerunit\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#xr,m,f#xr,r#xf,m,x#rf,x#rf,x#rf,m,!*y,!m,!*y\")\n+\t(match_operand:SF 1 \"general_operand\" \"fm#rx,f#rx,G,rmF#fx,Fr#fx,C,x,xm#rf,x#rf,m,*y,*y\"))]\n+  \"(!TARGET_INTER_UNIT_MOVES && !optimize_size)\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n    && (reload_in_progress || reload_completed\n        || (ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_LARGE)\n        || GET_CODE (operands[1]) != CONST_DOUBLE"}, {"sha": "a06c2f9307179f9fd8c17555abb50affa470dfee", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -1246,6 +1246,7 @@ unlink_other_notes (insn, tail)\n       /* See sched_analyze to see how these are handled.  */\n       if (NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_LOOP_END\n+\t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_BASIC_BLOCK\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_BEG\n \t  && NOTE_LINE_NUMBER (insn) != NOTE_INSN_EH_REGION_END)\n \t{"}, {"sha": "c298453f798b32010add40696a04e824ddf86eee", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 165, "deletions": 18, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f62128d21de91a372394a84ea4da997d5b35e73/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=8f62128d21de91a372394a84ea4da997d5b35e73", "patch": "@@ -56,7 +56,9 @@ static const char *ebb_print_insn PARAMS ((rtx, int));\n static int rank PARAMS ((rtx, rtx));\n static int contributes_to_priority PARAMS ((rtx, rtx));\n static void compute_jump_reg_dependencies PARAMS ((rtx, regset));\n-static void schedule_ebb PARAMS ((rtx, rtx));\n+static basic_block schedule_ebb PARAMS ((rtx, rtx));\n+static basic_block fix_basic_block_boundaries PARAMS ((basic_block, basic_block, rtx, rtx));\n+static void add_missing_bbs PARAMS ((rtx, basic_block, basic_block));\n \n /* Return nonzero if there are more insns that should be scheduled.  */\n \n@@ -139,8 +141,17 @@ ebb_print_insn (insn, aligned)\n \n static int\n rank (insn1, insn2)\n-     rtx insn1 ATTRIBUTE_UNUSED, insn2 ATTRIBUTE_UNUSED;\n+     rtx insn1, insn2;\n {\n+  basic_block bb1 = BLOCK_FOR_INSN (insn1);\n+  basic_block bb2 = BLOCK_FOR_INSN (insn2);\n+\n+  if (bb1->count > bb2->count\n+      || bb1->frequency > bb2->frequency)\n+    return -1;\n+  if (bb1->count < bb2->count\n+      || bb1->frequency < bb2->frequency)\n+    return 1;\n   return 0;\n }\n \n@@ -192,18 +203,157 @@ static struct sched_info ebb_sched_info =\n   0, 1\n };\n \f\n+/* It is possible that ebb scheduling elliminated some blocks.\n+   Place blocks from FIRST to LAST before BEFORE.  */\n+\n+static void\n+add_missing_bbs (before, first, last)\n+     rtx before;\n+     basic_block first, last;\n+{\n+  for (; last != first->prev_bb; last = last->prev_bb)\n+    {\n+      before = emit_note_before (NOTE_INSN_BASIC_BLOCK, before);\n+      NOTE_BASIC_BLOCK (before) = last;\n+      last->head = before;\n+      last->end = before;\n+      update_bb_for_insn (last);\n+    }\n+}\n+\n+/* Fixup the CFG after EBB scheduling.  Re-recognize the basic\n+   block boundaries in between HEAD and TAIL and update basic block\n+   structures between BB and LAST.  */\n+\n+static basic_block\n+fix_basic_block_boundaries (bb, last, head, tail)\n+     basic_block bb, last;\n+     rtx head, tail;\n+{\n+  rtx insn = head;\n+  rtx last_inside = bb->head;\n+  rtx aftertail = NEXT_INSN (tail);\n+\n+  head = bb->head;\n+\n+  for (; insn != aftertail; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tabort ();\n+      /* Create new basic blocks just before first insn.  */\n+      if (inside_basic_block_p (insn))\n+\t{\n+\t  if (!last_inside)\n+\t    {\n+\t      rtx note;\n+\n+\t      /* Re-emit the basic block note for newly found BB header.  */\n+\t      if (GET_CODE (insn) == CODE_LABEL)\n+\t\t{\n+\t\t  note = emit_note_after (NOTE_INSN_BASIC_BLOCK, insn);\n+\t\t  head = insn;\n+\t\t  last_inside = note;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  note = emit_note_before (NOTE_INSN_BASIC_BLOCK, insn);\n+\t\t  head = note;\n+\t\t  last_inside = insn;\n+\t\t}\n+\t    }\n+\t  else\n+\t    last_inside = insn;\n+\t}\n+      /* Control flow instruction terminate basic block.  It is possible\n+\t that we've elliminated some basic blocks (made them empty).\n+\t Find the proper basic block using BLOCK_FOR_INSN and arrange things in\n+\t a sensible way by inserting empty basic blocks as needed.  */\n+      if (control_flow_insn_p (insn) || (insn == tail && last_inside))\n+\t{\n+\t  basic_block curr_bb = BLOCK_FOR_INSN (insn);\n+\t  rtx note;\n+\n+\t  if (!control_flow_insn_p (insn))\n+\t    curr_bb = last;\n+\t  if (bb == last->next_bb)\n+\t    {\n+\t      edge f;\n+\t      rtx h;\n+\n+\t      /* An obscure special case, where we do have partially dead\n+\t         instruction scheduled after last control flow instruction.\n+\t         In this case we can create new basic block.  It is\n+\t         always exactly one basic block last in the sequence.  Handle\n+\t         it by splitting the edge and repositioning the block.\n+\t         This is somewhat hackish, but at least avoid cut&paste \n+\n+\t         Safter sollution can be to bring the code into sequence,\n+\t         do the split and re-emit it back in case this will ever\n+\t         trigger problem.  */\n+\t      f = bb->prev_bb->succ;\n+\t      while (f && !(f->flags & EDGE_FALLTHRU))\n+\t\tf = f->succ_next;\n+\n+\t      if (f)\n+\t\t{\n+\t\t  last = curr_bb = split_edge (f);\n+\t\t  h = curr_bb->head;\n+\t\t  curr_bb->head = head;\n+\t\t  curr_bb->end = insn;\n+\t\t  /* Edge splitting created missplaced BASIC_BLOCK note, kill\n+\t\t     it.  */\n+\t\t  delete_insn (h);\n+\t\t}\n+\t      /* It may happen that code got moved past unconditional jump in\n+\t         case the code is completely dead.  Kill it.  */\n+\t      else\n+\t\t{\n+\t\t  rtx next = next_nonnote_insn (insn);\n+\t\t  delete_insn_chain (head, insn);\n+\t\t  /* We keep some notes in the way that may split barrier from the\n+\t\t     jump.  */\n+\t\t  if (GET_CODE (next) == BARRIER)\n+\t\t     {\n+\t\t       emit_barrier_after (prev_nonnote_insn (head));\n+\t\t       delete_insn (next);\n+\t\t     }\n+\t\t  insn = NULL;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      curr_bb->head = head;\n+\t      curr_bb->end = insn;\n+\t      add_missing_bbs (curr_bb->head, bb, curr_bb->prev_bb);\n+\t    }\n+\t  note = GET_CODE (head) == CODE_LABEL ? NEXT_INSN (head) : head;\n+\t  NOTE_BASIC_BLOCK (note) = curr_bb;\n+\t  update_bb_for_insn (curr_bb);\n+\t  bb = curr_bb->next_bb;\n+\t  last_inside = NULL;\n+\t  if (!insn)\n+\t     break;\n+\t}\n+    }\n+  add_missing_bbs (last->next_bb->head, bb, last);\n+  return bb->prev_bb;\n+}\n+\n /* Schedule a single extended basic block, defined by the boundaries HEAD\n    and TAIL.  */\n \n-static void\n+static basic_block\n schedule_ebb (head, tail)\n      rtx head, tail;\n {\n   int n_insns;\n+  basic_block b;\n   struct deps tmp_deps;\n+  basic_block first_bb = BLOCK_FOR_INSN (head);\n+  basic_block last_bb = BLOCK_FOR_INSN (tail);\n \n   if (no_real_insns_p (head, tail))\n-    return;\n+    return BLOCK_FOR_INSN (tail);\n \n   init_deps_global ();\n \n@@ -266,8 +416,10 @@ schedule_ebb (head, tail)\n \n   if (write_symbols != NO_DEBUG)\n     restore_line_notes (head, tail);\n+  b = fix_basic_block_boundaries (first_bb, last_bb, head, tail);\n \n   finish_deps_global ();\n+  return b;\n }\n \n /* The one entry point in this file.  DUMP_FILE is the dump file for\n@@ -309,17 +461,8 @@ schedule_ebbs (dump_file)\n \t      break;\n \t  if (! e)\n \t    break;\n-\t  if (GET_CODE (tail) == JUMP_INSN)\n-\t    {\n-\t      rtx x = find_reg_note (tail, REG_BR_PROB, 0);\n-\t      if (x)\n-\t\t{\n-\t\t  int pred_val = INTVAL (XEXP (x, 0));\n-\t\t  if (pred_val > REG_BR_PROB_BASE / 2)\n-\t\t    break;\n-\t\t}\n-\t    }\n-\n+\t  if (e->probability < REG_BR_PROB_BASE / 2)\n+\t    break;\n \t  bb = bb->next_bb;\n \t}\n \n@@ -337,11 +480,11 @@ schedule_ebbs (dump_file)\n \t    break;\n \t}\n \n-      schedule_ebb (head, tail);\n+      bb = schedule_ebb (head, tail);\n     }\n \n-  /* It doesn't make much sense to try and update life information here - we\n-     probably messed up even the flow graph.  */\n+  /* Updating life info can be done by local propagation over the modified\n+     superblocks.  */\n \n   /* Reposition the prologue and epilogue notes in case we moved the\n      prologue/epilogue insns.  */\n@@ -352,4 +495,8 @@ schedule_ebbs (dump_file)\n     rm_redundant_line_notes ();\n \n   sched_finish ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n }"}]}