{"sha": "6491dbbb8121b9afa1400b9c1143b9eb32b4da65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ5MWRiYmI4MTIxYjlhZmExNDAwYjljMTE0M2I5ZWIzMmI0ZGE2NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T21:08:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-26T21:08:49Z"}, "message": "(reload): Use reg_equiv_address for invalid addresses\nof the form (mem (reg)).\n\nFrom-SVN: r4761", "tree": {"sha": "30c661756c1e8a39f3ca5cc97b9e1462b8efa727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30c661756c1e8a39f3ca5cc97b9e1462b8efa727"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6491dbbb8121b9afa1400b9c1143b9eb32b4da65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6491dbbb8121b9afa1400b9c1143b9eb32b4da65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6491dbbb8121b9afa1400b9c1143b9eb32b4da65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6491dbbb8121b9afa1400b9c1143b9eb32b4da65/comments", "author": null, "committer": null, "parents": [{"sha": "73ebbfdff0d75988af114269be5afe76f6709ab8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73ebbfdff0d75988af114269be5afe76f6709ab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73ebbfdff0d75988af114269be5afe76f6709ab8"}], "stats": {"total": 5, "additions": 4, "deletions": 1}, "files": [{"sha": "b08a38322fa3c122a52e465b094471be057b838c", "filename": "gcc/reload1.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6491dbbb8121b9afa1400b9c1143b9eb32b4da65/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6491dbbb8121b9afa1400b9c1143b9eb32b4da65/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=6491dbbb8121b9afa1400b9c1143b9eb32b4da65", "patch": "@@ -819,7 +819,8 @@ reload (first, global, dumpfile)\n \t and constant, it is probably not addressable because the constant is\n \t out of range, in that case record the address; we will generate\n \t hairy code to compute the address in a register each time it is\n-\t needed.\n+\t needed.  Similarly if it is a hard register, but one that is not\n+\t valid as an address register.\n \n \t If the location is not addressable, but does not have one of the\n \t above forms, assign a stack slot.  We have to do this to avoid the\n@@ -839,6 +840,8 @@ reload (first, global, dumpfile)\n \t\t\t\t\t XEXP (x, 0)))\n \t      reg_equiv_mem[i] = x, reg_equiv_address[i] = 0;\n \t    else if (CONSTANT_P (XEXP (x, 0))\n+\t\t     || (GET_CODE (XEXP (x, 0)) == REG\n+\t\t\t && REGNO (XEXP (x, 0)) < FIRST_PSEUDO_REGISTER)\n \t\t     || (GET_CODE (XEXP (x, 0)) == PLUS\n \t\t\t && GET_CODE (XEXP (XEXP (x, 0), 0)) == REG\n \t\t\t && (REGNO (XEXP (XEXP (x, 0), 0))"}]}