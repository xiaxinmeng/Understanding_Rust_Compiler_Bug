{"sha": "8237beb118c5b5a724a459584975a11c3234c1c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzN2JlYjExOGM1YjVhNzI0YTQ1OTU4NDk3NWExMWMzMjM0YzFjNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2015-10-07T01:46:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2015-10-07T01:46:54Z"}, "message": "re PR c++/67810 (Non-expression recognized as fold expression)\n\n\tPR c++/67810\n\t* parser.c (cp_parser_fold_expr_p): Remove.\n\t(is_binary_op): New.\n\t(cp_parser_fold_expression): Take LHS as parameter.\n\t(cp_parser_primary_expression): Call it after parsing an expression.\n\t(cp_parser_binary_expression, cp_parser_assignment_operator_opt)\n\t(cp_parser_expression): Ignore an operator followed by '...'.\n\t(is_binary_op): New.\n\t* pt.c (tsubst_unary_left_fold, tsubst_binary_left_fold)\n\t(tsubst_unary_right_fold, tsubst_binary_right_fold): Handle errors.\n\nFrom-SVN: r228556", "tree": {"sha": "b4ad303ed518efe8b5b620511f36ee500ddd8383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4ad303ed518efe8b5b620511f36ee500ddd8383"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8237beb118c5b5a724a459584975a11c3234c1c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8237beb118c5b5a724a459584975a11c3234c1c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8237beb118c5b5a724a459584975a11c3234c1c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8237beb118c5b5a724a459584975a11c3234c1c7/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "437d8c80894a5e332b99f72e605050005b4542e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/437d8c80894a5e332b99f72e605050005b4542e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/437d8c80894a5e332b99f72e605050005b4542e5"}], "stats": {"total": 232, "additions": 170, "deletions": 62}, "files": [{"sha": "1b2f6b4cd74cd834b004eb372dfa998ec8b0591e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8237beb118c5b5a724a459584975a11c3234c1c7", "patch": "@@ -1,3 +1,16 @@\n+2015-10-06  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/67810\n+\t* parser.c (cp_parser_fold_expr_p): Remove.\n+\t(is_binary_op): New.\n+\t(cp_parser_fold_expression): Take LHS as parameter.\n+\t(cp_parser_primary_expression): Call it after parsing an expression.\n+\t(cp_parser_binary_expression, cp_parser_assignment_operator_opt)\n+\t(cp_parser_expression): Ignore an operator followed by '...'.\n+\t(is_binary_op): New.\n+\t* pt.c (tsubst_unary_left_fold, tsubst_binary_left_fold)\n+\t(tsubst_unary_right_fold, tsubst_binary_right_fold): Handle errors.\n+\n 2015-10-06  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/67863"}, {"sha": "f9b668ab0cbd70522c65a2646e1ae21901ff9000", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 93, "deletions": 60, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8237beb118c5b5a724a459584975a11c3234c1c7", "patch": "@@ -4339,6 +4339,50 @@ cp_parser_fold_operator (cp_token *token)\n     }\n }\n \n+/* Returns true if CODE indicates a binary expression, which is not allowed in\n+   the LHS of a fold-expression.  More codes will need to be added to use this\n+   function in other contexts.  */\n+\n+static bool\n+is_binary_op (tree_code code)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+\n+    case MODOP_EXPR:\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case LT_EXPR:\n+    case GT_EXPR:\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+\n+    case COMPOUND_EXPR:\n+\n+    case DOTSTAR_EXPR:\n+    case MEMBER_REF:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n /* If the next token is a suitable fold operator, consume it and return as\n    the function above.  */\n \n@@ -4352,41 +4396,6 @@ cp_parser_fold_operator (cp_parser *parser)\n   return code;\n }\n \n-/* Returns true iff we're at the beginning of an N4191 fold-expression, after\n-   the left parenthesis.  Rather than do tentative parsing, we scan the tokens\n-   up to the matching right paren for an ellipsis next to a binary\n-   operator.  */\n-\n-static bool\n-cp_parser_fold_expr_p (cp_parser *parser)\n-{\n-  /* An ellipsis right after the left paren always indicates a\n-     fold-expression.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n-    {\n-      /* But if there isn't a fold operator after the ellipsis,\n-         give a different error.  */\n-      cp_token *token = cp_lexer_peek_nth_token (parser->lexer, 2);\n-      return (cp_parser_fold_operator (token) != ERROR_MARK);\n-    }\n-\n-  /* Otherwise, look for an ellipsis.  */\n-  cp_lexer_save_tokens (parser->lexer);\n-  int ret = cp_parser_skip_to_closing_parenthesis_1 (parser, false,\n-\t\t\t\t\t\t     CPP_ELLIPSIS, false);\n-  bool found = (ret == -1);\n-  if (found)\n-    {\n-      /* We found an ellipsis, is the previous token an operator?  */\n-      cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      --token;\n-      if (cp_parser_fold_operator (token) == ERROR_MARK)\n-\tfound = false;\n-    }\n-  cp_lexer_rollback_tokens (parser->lexer);\n-  return found;\n-}\n-\n /* Parse a fold-expression.\n \n      fold-expression:\n@@ -4397,14 +4406,10 @@ cp_parser_fold_expr_p (cp_parser *parser)\n    Note that the '(' and ')' are matched in primary expression. */\n \n static tree\n-cp_parser_fold_expression (cp_parser *parser)\n+cp_parser_fold_expression (cp_parser *parser, tree expr1)\n {\n   cp_id_kind pidk;\n \n-  if (cxx_dialect < cxx1z && !in_system_header_at (input_location))\n-    pedwarn (input_location, 0, \"fold-expressions only available with \"\n-\t     \"-std=c++1z or -std=gnu++1z\");\n-\n   // Left fold.\n   if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n     {\n@@ -4423,10 +4428,6 @@ cp_parser_fold_expression (cp_parser *parser)\n       return finish_left_unary_fold_expr (expr, op);\n     }\n \n-  tree expr1 = cp_parser_cast_expression (parser, false, false, false, &pidk);\n-  if (expr1 == error_mark_node)\n-    return error_mark_node;\n-\n   const cp_token* token = cp_lexer_peek_token (parser->lexer);\n   int op = cp_parser_fold_operator (parser);\n   if (op == ERROR_MARK)\n@@ -4442,6 +4443,16 @@ cp_parser_fold_expression (cp_parser *parser)\n     }\n   cp_lexer_consume_token (parser->lexer);\n \n+  /* The operands of a fold-expression are cast-expressions, so binary or\n+     conditional expressions are not allowed.  We check this here to avoid\n+     tentative parsing.  */\n+  if (is_binary_op (TREE_CODE (expr1)))\n+    error_at (location_of (expr1),\n+\t      \"binary expression in operand of fold-expression\");\n+  else if (TREE_CODE (expr1) == COND_EXPR)\n+    error_at (location_of (expr1),\n+\t      \"conditional expression in operand of fold-expression\");\n+\n   // Right fold.\n   if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n     return finish_right_unary_fold_expr (expr1, op);\n@@ -4668,22 +4679,31 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  = parser->greater_than_is_operator_p;\n \tparser->greater_than_is_operator_p = true;\n \n-\t// Handle a fold-expression.\n-\tif (cp_parser_fold_expr_p (parser))\n+\tif (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t  /* Left fold expression. */\n+\t  expr = NULL_TREE;\n+\telse\n+\t  /* Parse the parenthesized expression.  */\n+\t  expr = cp_parser_expression (parser, idk, cast_p, decltype_p);\n+\n+\ttoken = cp_lexer_peek_token (parser->lexer);\n+\tif (token->type == CPP_ELLIPSIS || cp_parser_fold_operator (token))\n \t  {\n-\t    tree fold = cp_parser_fold_expression (parser);\n-\t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\t    return fold;\n+\t    expr = cp_parser_fold_expression (parser, expr);\n+\t    if (expr != error_mark_node\n+\t\t&& cxx_dialect < cxx1z\n+\t\t&& !in_system_header_at (input_location))\n+\t      pedwarn (input_location, 0, \"fold-expressions only available \"\n+\t\t       \"with -std=c++1z or -std=gnu++1z\");\n \t  }\n+\telse\n+\t  /* Let the front end know that this expression was\n+\t     enclosed in parentheses. This matters in case, for\n+\t     example, the expression is of the form `A::B', since\n+\t     `&A::B' might be a pointer-to-member, but `&(A::B)' is\n+\t     not.  */\n+\t  expr = finish_parenthesized_expr (expr);\n \n-\t/* Parse the parenthesized expression.  */\n-\texpr = cp_parser_expression (parser, idk, cast_p, decltype_p);\n-\t/* Let the front end know that this expression was\n-\t   enclosed in parentheses. This matters in case, for\n-\t   example, the expression is of the form `A::B', since\n-\t   `&A::B' might be a pointer-to-member, but `&(A::B)' is\n-\t   not.  */\n-\texpr = finish_parenthesized_expr (expr);\n \t/* DR 705: Wrapping an unqualified name in parentheses\n \t   suppresses arg-dependent lookup.  We want to pass back\n \t   CP_ID_KIND_QUALIFIED for suppressing vtable lookup\n@@ -8468,6 +8488,10 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n         }\n \n       new_prec = TOKEN_PRECEDENCE (token);\n+      if (new_prec != PREC_NOT_OPERATOR\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_ELLIPSIS))\n+\t/* This is a fold-expression; handle it later.  */\n+\tnew_prec = PREC_NOT_OPERATOR;\n \n       /* Popping an entry off the stack means we completed a subexpression:\n \t - either we found a token which is not an operator (`>' where it is not\n@@ -8509,6 +8533,9 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t cases such as 3 + 4 + 5 or 3 * 4 + 5.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       lookahead_prec = TOKEN_PRECEDENCE (token);\n+      if (lookahead_prec != PREC_NOT_OPERATOR\n+\t  && cp_lexer_nth_token_is (parser->lexer, 2, CPP_ELLIPSIS))\n+\tlookahead_prec = PREC_NOT_OPERATOR;\n       if (lookahead_prec > new_prec)\n \t{\n \t  /* ... and prepare to parse the RHS of the new, higher priority\n@@ -8824,6 +8851,11 @@ cp_parser_assignment_operator_opt (cp_parser* parser)\n       op = ERROR_MARK;\n     }\n \n+  /* An operator followed by ... is a fold-expression, handled elsewhere.  */\n+  if (op != ERROR_MARK\n+      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_ELLIPSIS))\n+    op = ERROR_MARK;\n+\n   /* If it was an assignment operator, consume it.  */\n   if (op != ERROR_MARK)\n     cp_lexer_consume_token (parser->lexer);\n@@ -8877,9 +8909,10 @@ cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n \texpression = build_x_compound_expr (loc, expression,\n \t\t\t\t\t    assignment_expression,\n \t\t\t\t\t    complain_flags (decltype_p));\n-      /* If the next token is not a comma, then we are done with the\n-\t expression.  */\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n+      /* If the next token is not a comma, or we're in a fold-expression, then\n+\t we are done with the expression.  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n+\t  || cp_lexer_nth_token_is (parser->lexer, 2, CPP_ELLIPSIS))\n \tbreak;\n       /* Consume the `,'.  */\n       loc = cp_lexer_peek_token (parser->lexer)->location;"}, {"sha": "6926557dfc6d2dd7b2e1f7ee900270b5929ea79a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8237beb118c5b5a724a459584975a11c3234c1c7", "patch": "@@ -10632,6 +10632,8 @@ tsubst_unary_left_fold (tree t, tree args, tsubst_flags_t complain,\n                         tree in_decl)\n {\n   tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  if (pack == error_mark_node)\n+    return error_mark_node;\n   if (TREE_VEC_LENGTH (pack) == 0)\n     return expand_empty_fold (t, complain);\n   else\n@@ -10648,7 +10650,11 @@ tsubst_binary_left_fold (tree t, tree args, tsubst_flags_t complain,\n                          tree in_decl)\n {\n   tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  if (pack == error_mark_node)\n+    return error_mark_node;\n   tree init = tsubst_fold_expr_init (t, args, complain, in_decl);\n+  if (init == error_mark_node)\n+    return error_mark_node;\n \n   tree vec = make_tree_vec (TREE_VEC_LENGTH (pack) + 1);\n   TREE_VEC_ELT (vec, 0) = init;\n@@ -10689,6 +10695,8 @@ tsubst_unary_right_fold (tree t, tree args, tsubst_flags_t complain,\n                          tree in_decl)\n {\n   tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  if (pack == error_mark_node)\n+    return error_mark_node;\n   if (TREE_VEC_LENGTH (pack) == 0)\n     return expand_empty_fold (t, complain);\n   else\n@@ -10705,7 +10713,11 @@ tsubst_binary_right_fold (tree t, tree args, tsubst_flags_t complain,\n                          tree in_decl)\n {\n   tree pack = tsubst_fold_expr_pack (t, args, complain, in_decl);\n+  if (pack == error_mark_node)\n+    return error_mark_node;\n   tree init = tsubst_fold_expr_init (t, args, complain, in_decl);\n+  if (init == error_mark_node)\n+    return error_mark_node;\n \n   int n = TREE_VEC_LENGTH (pack);\n   tree vec = make_tree_vec (n + 1);"}, {"sha": "444a8a22a852f7cc21d40551ffc8a03b92dfa763", "filename": "gcc/testsuite/g++.dg/cpp1y/var-templ45.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ45.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ45.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fvar-templ45.C?ref=8237beb118c5b5a724a459584975a11c3234c1c7", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/67810\n+// { dg-do compile { target c++14 } }\n+\n+template <class...>\n+constexpr bool Test = true;\n+\n+template <typename...Ts, bool = (Test<Ts&&...>)>\n+void f();"}, {"sha": "598e55732a612a83fd2b88b8619cb024dcde7949", "filename": "gcc/testsuite/g++.dg/cpp1z/fold2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold2.C?ref=8237beb118c5b5a724a459584975a11c3234c1c7", "patch": "@@ -54,8 +54,8 @@ MAKE_FNS (eq, ==);\n MAKE_FNS (ne, !=);\n MAKE_FNS (lt, <);\n MAKE_FNS (gt, >);\n-MAKE_FNS (le, <);\n-MAKE_FNS (ge, >);\n+MAKE_FNS (le, <=);\n+MAKE_FNS (ge, >=);\n \n MAKE_FNS (land, &&);\n MAKE_FNS (lor, ||);"}, {"sha": "cc073f90aea886c002717f0779ddb7e7035503ac", "filename": "gcc/testsuite/g++.dg/cpp1z/fold6.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8237beb118c5b5a724a459584975a11c3234c1c7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Ffold6.C?ref=8237beb118c5b5a724a459584975a11c3234c1c7", "patch": "@@ -0,0 +1,42 @@\n+// Test that we reject a fold-expression with an LHS that is not a\n+// cast-expression.\n+\n+// { dg-options -std=c++1z }\n+\n+int i;\n+\n+template <int... Is>\n+int f()\n+{\n+  (i ? i : Is + ...);\t\t// { dg-error \"\" }\n+  (i + Is + ...);\t\t// { dg-error \"\" }\n+  (i - Is + ...);\t\t// { dg-error \"\" }\n+  (i * Is + ...);\t\t// { dg-error \"\" }\n+  (i / Is + ...);\t\t// { dg-error \"\" }\n+  (i % Is + ...);\t\t// { dg-error \"\" }\n+  (i ^ Is + ...);\t\t// { dg-error \"\" }\n+  (i | Is + ...);\t\t// { dg-error \"\" }\n+  (i & Is + ...);\t\t// { dg-error \"\" }\n+  (i << Is + ...);\t\t// { dg-error \"\" }\n+  (i >> Is + ...);\t\t// { dg-error \"\" }\n+  (i = Is + ...);\t\t// { dg-error \"\" }\n+  (i += Is + ...);\t\t// { dg-error \"\" }\n+  (i -= Is + ...);\t\t// { dg-error \"\" }\n+  (i *= Is + ...);\t\t// { dg-error \"\" }\n+  (i /= Is + ...);\t\t// { dg-error \"\" }\n+  (i %= Is + ...);\t\t// { dg-error \"\" }\n+  (i ^= Is + ...);\t\t// { dg-error \"\" }\n+  (i |= Is + ...);\t\t// { dg-error \"\" }\n+  (i &= Is + ...);\t\t// { dg-error \"\" }\n+  (i <<= Is + ...);\t\t// { dg-error \"\" }\n+  (i >>= Is + ...);\t\t// { dg-error \"\" }\n+  (i == Is + ...);\t\t// { dg-error \"\" }\n+  (i != Is + ...);\t\t// { dg-error \"\" }\n+  (i < Is + ...);\t\t// { dg-error \"\" }\n+  (i > Is + ...);\t\t// { dg-error \"\" }\n+  (i <= Is + ...);\t\t// { dg-error \"\" }\n+  (i >= Is + ...);\t\t// { dg-error \"\" }\n+  (i && Is + ...);\t\t// { dg-error \"\" }\n+  (i || Is + ...);\t\t// { dg-error \"\" }\n+  (i , Is + ...);\t\t// { dg-error \"\" }\n+}"}]}