{"sha": "6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIxNmY5NGUzN2RiOGRlNWE4NDZjNTk0NWY0YWE1ZjRlMzJhYWVkZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-04-24T06:58:02Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-04-24T06:58:02Z"}, "message": "re PR rtl-optimization/39794 (Miscompile with -O2 -funroll-loops)\n\n\tPR rtl-optimization/39794\n\t* alias.c (canon_true_dependence): Add x_addr argument.\n\t* rtl.h (canon_true_dependence): Adjust prototype.\n\t* cse.c (check_dependence): Adjust canon_true_dependence callers.\n\t* cselib.c (cselib_invalidate_mem): Likewise.\n\t* gcse.c (compute_transp): Likewise.\n\t* dse.c (scan_reads_nospill): Likewise.\n\t(record_store, check_mem_read_rtx): Likewise.  For non-const-or-frame\n\taddresses pass base->val_rtx as mem_addr, for const-or-frame addresses\n\tcanon_base_addr of the group, plus optional offset.\n\t(struct group_info): Rename canon_base_mem to\n\tcanon_base_addr.\n\t(get_group_info): Set canon_base_addr to canon_rtx of base, not\n\tcanon_rtx of base_mem.\n\n\t* gcc.dg/pr39794.c: New test.\n\nFrom-SVN: r146669", "tree": {"sha": "b915c002276568ad8d30cd5e3340544d674fc103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b915c002276568ad8d30cd5e3340544d674fc103"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6de7a512f0e76268d8ff69e51be80527c58d854b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de7a512f0e76268d8ff69e51be80527c58d854b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de7a512f0e76268d8ff69e51be80527c58d854b"}], "stats": {"total": 141, "additions": 115, "deletions": 26}, "files": [{"sha": "a96520a00bfee9c098860a8468ffd8a8217a9680", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -1,3 +1,20 @@\n+2009-04-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/39794\n+\t* alias.c (canon_true_dependence): Add x_addr argument.\n+\t* rtl.h (canon_true_dependence): Adjust prototype.\n+\t* cse.c (check_dependence): Adjust canon_true_dependence callers.\n+\t* cselib.c (cselib_invalidate_mem): Likewise.\n+\t* gcse.c (compute_transp): Likewise.\n+\t* dse.c (scan_reads_nospill): Likewise.\n+\t(record_store, check_mem_read_rtx): Likewise.  For non-const-or-frame\n+\taddresses pass base->val_rtx as mem_addr, for const-or-frame addresses\n+\tcanon_base_addr of the group, plus optional offset.\n+\t(struct group_info): Rename canon_base_mem to\n+\tcanon_base_addr.\n+\t(get_group_info): Set canon_base_addr to canon_rtx of base, not\n+\tcanon_rtx of base_mem.\n+\n 2009-04-23  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config/sh/sh.c (sh_expand_prologue, sh_expand_epilogue):"}, {"sha": "8a20f467905f4e222bf30e5555ca46ee91658d9c", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -2287,14 +2287,13 @@ true_dependence (const_rtx mem, enum machine_mode mem_mode, const_rtx x,\n    Variant of true_dependence which assumes MEM has already been\n    canonicalized (hence we no longer do that here).\n    The mem_addr argument has been added, since true_dependence computed\n-   this value prior to canonicalizing.  */\n+   this value prior to canonicalizing.\n+   If x_addr is non-NULL, it is used in preference of XEXP (x, 0).  */\n \n int\n canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n-\t\t       const_rtx x, bool (*varies) (const_rtx, bool))\n+\t\t       const_rtx x, rtx x_addr, bool (*varies) (const_rtx, bool))\n {\n-  rtx x_addr;\n-\n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n \n@@ -2320,7 +2319,8 @@ canon_true_dependence (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n   if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n \n-  x_addr = get_addr (XEXP (x, 0));\n+  if (! x_addr)\n+    x_addr = get_addr (XEXP (x, 0));\n \n   if (! base_alias_check (x_addr, mem_addr, GET_MODE (x), mem_mode))\n     return 0;"}, {"sha": "3f36a1c83714548d72b38807ef27745612cdfd1c", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -1658,7 +1658,7 @@ check_dependence (rtx *x, void *data)\n {\n   struct check_dependence_data *d = (struct check_dependence_data *) data;\n   if (*x && MEM_P (*x))\n-    return canon_true_dependence (d->exp, d->mode, d->addr, *x,\n+    return canon_true_dependence (d->exp, d->mode, d->addr, *x, NULL_RTX,\n \t\t    \t\t  cse_rtx_varies_p);\n   else\n     return 0;"}, {"sha": "b040231deb5ff894d668bd4dff5d4321117f691a", "filename": "gcc/cselib.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -1,6 +1,6 @@\n /* Common subexpression elimination library for GNU compiler.\n    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008\n+   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -1483,7 +1483,7 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t    }\n \t  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)\n \t      && ! canon_true_dependence (mem_rtx, GET_MODE (mem_rtx), mem_addr,\n-\t\t      \t\t\t  x, cselib_rtx_varies_p))\n+\t\t      \t\t\t  x, NULL_RTX, cselib_rtx_varies_p))\n \t    {\n \t      has_mem = true;\n \t      num_mems++;"}, {"sha": "5ac898ca84a76a6212c52ddee09f03e16200a6c8", "filename": "gcc/dse.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -223,7 +223,7 @@ struct store_info\n   /* This canonized mem.  */\n   rtx mem;\n \n-  /* The result of get_addr on mem.  */\n+  /* Canonized MEM address for use by canon_true_dependence.  */\n   rtx mem_addr;\n \n   /* If this is non-zero, it is the alias set of a spill location.  */\n@@ -476,8 +476,8 @@ struct group_info\n      do read dependency.  */\n   rtx base_mem;\n   \n-  /* Canonized version of base_mem, most likely the same thing.  */\n-  rtx canon_base_mem;\n+  /* Canonized version of base_mem's address.  */\n+  rtx canon_base_addr;\n \n   /* These two sets of two bitmaps are used to keep track of how many\n      stores are actually referencing that position from this base.  We\n@@ -705,7 +705,7 @@ get_group_info (rtx base)\n       gi->rtx_base = base;\n       gi->id = rtx_group_next_id++;\n       gi->base_mem = gen_rtx_MEM (QImode, base);\n-      gi->canon_base_mem = canon_rtx (gi->base_mem);\n+      gi->canon_base_addr = canon_rtx (base);\n       gi->store1_n = BITMAP_ALLOC (NULL);\n       gi->store1_p = BITMAP_ALLOC (NULL);\n       gi->store2_n = BITMAP_ALLOC (NULL);\n@@ -1286,7 +1286,7 @@ static rtx get_stored_val (store_info_t, enum machine_mode, HOST_WIDE_INT,\n static int\n record_store (rtx body, bb_info_t bb_info)\n {\n-  rtx mem, rhs, const_rhs;\n+  rtx mem, rhs, const_rhs, mem_addr;\n   HOST_WIDE_INT offset = 0;\n   HOST_WIDE_INT width = 0;\n   alias_set_type spill_alias_set;\n@@ -1456,6 +1456,23 @@ record_store (rtx body, bb_info_t bb_info)\n   ptr = active_local_stores;\n   last = NULL;\n   redundant_reason = NULL;\n+  mem = canon_rtx (mem);\n+  /* For alias_set != 0 canon_true_dependence should be never called.  */\n+  if (spill_alias_set)\n+    mem_addr = NULL_RTX;\n+  else\n+    {\n+      if (group_id < 0)\n+\tmem_addr = base->val_rtx;\n+      else\n+\t{\n+\t  group_info_t group\n+\t    = VEC_index (group_info_t, rtx_group_vec, group_id);\n+\t  mem_addr = group->canon_base_addr;\n+\t}\n+      if (offset)\n+\tmem_addr = plus_constant (mem_addr, offset);\n+    }\n \n   while (ptr)\n     {\n@@ -1547,13 +1564,13 @@ record_store (rtx body, bb_info_t bb_info)\n \t  if (canon_true_dependence (s_info->mem, \n \t\t\t\t     GET_MODE (s_info->mem),\n \t\t\t\t     s_info->mem_addr,\n-\t\t\t\t     mem, rtx_varies_p))\n+\t\t\t\t     mem, mem_addr, rtx_varies_p))\n \t    {\n \t      s_info->rhs = NULL;\n \t      s_info->const_rhs = NULL;\n \t    }\n \t}\n-      \n+\n       /* An insn can be deleted if every position of every one of\n \t its s_infos is zero.  */\n       if (any_positions_needed_p (s_info)\n@@ -1580,9 +1597,9 @@ record_store (rtx body, bb_info_t bb_info)\n   /* Finish filling in the store_info.  */\n   store_info->next = insn_info->store_rec;\n   insn_info->store_rec = store_info;\n-  store_info->mem = canon_rtx (mem);\n+  store_info->mem = mem;\n   store_info->alias_set = spill_alias_set;\n-  store_info->mem_addr = get_addr (XEXP (mem, 0));\n+  store_info->mem_addr = mem_addr;\n   store_info->cse_base = base;\n   if (width > HOST_BITS_PER_WIDE_INT)\n     {\n@@ -2006,7 +2023,7 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n static int\n check_mem_read_rtx (rtx *loc, void *data)\n {\n-  rtx mem = *loc;\n+  rtx mem = *loc, mem_addr;\n   bb_info_t bb_info;\n   insn_info_t insn_info;\n   HOST_WIDE_INT offset = 0;\n@@ -2058,6 +2075,22 @@ check_mem_read_rtx (rtx *loc, void *data)\n   read_info->end = offset + width;\n   read_info->next = insn_info->read_rec;\n   insn_info->read_rec = read_info;\n+  /* For alias_set != 0 canon_true_dependence should be never called.  */\n+  if (spill_alias_set)\n+    mem_addr = NULL_RTX;\n+  else\n+    {\n+      if (group_id < 0)\n+\tmem_addr = base->val_rtx;\n+      else\n+\t{\n+\t  group_info_t group\n+\t    = VEC_index (group_info_t, rtx_group_vec, group_id);\n+\t  mem_addr = group->canon_base_addr;\n+\t}\n+      if (offset)\n+\tmem_addr = plus_constant (mem_addr, offset);\n+    }\n \n   /* We ignore the clobbers in store_info.  The is mildly aggressive,\n      but there really should not be a clobber followed by a read.  */\n@@ -2128,7 +2161,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t      = canon_true_dependence (store_info->mem, \n \t\t\t\t       GET_MODE (store_info->mem),\n \t\t\t\t       store_info->mem_addr,\n-\t\t\t\t       mem, rtx_varies_p);\n+\t\t\t\t       mem, mem_addr, rtx_varies_p);\n \t  \n \t  else if (group_id == store_info->group_id)\n \t    {\n@@ -2139,7 +2172,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t\t  = canon_true_dependence (store_info->mem, \n \t\t\t\t\t   GET_MODE (store_info->mem),\n \t\t\t\t\t   store_info->mem_addr,\n-\t\t\t\t\t   mem, rtx_varies_p);\n+\t\t\t\t\t   mem, mem_addr, rtx_varies_p);\n \t      \n \t      /* If this read is just reading back something that we just\n \t\t stored, rewrite the read.  */\n@@ -2224,7 +2257,7 @@ check_mem_read_rtx (rtx *loc, void *data)\n \t    remove = canon_true_dependence (store_info->mem, \n \t\t\t\t\t    GET_MODE (store_info->mem),\n \t\t\t\t\t    store_info->mem_addr,\n-\t\t\t\t\t    mem, rtx_varies_p);\n+\t\t\t\t\t    mem, mem_addr, rtx_varies_p);\n \t  \n \t  if (remove)\n \t    {\n@@ -3066,8 +3099,9 @@ scan_reads_nospill (insn_info_t insn_info, bitmap gen, bitmap kill)\n \t\t  if ((read_info->group_id < 0)\n \t\t      && canon_true_dependence (group->base_mem, \n \t\t\t\t\t\tQImode,\n-\t\t\t\t\t\tgroup->canon_base_mem,\n-\t\t\t\t\t\tread_info->mem, rtx_varies_p))\n+\t\t\t\t\t\tgroup->canon_base_addr,\n+\t\t\t\t\t\tread_info->mem, NULL_RTX,\n+\t\t\t\t\t\trtx_varies_p))\n \t\t    {\n \t\t      if (kill)\n \t\t\tbitmap_ior_into (kill, group->group_kill);"}, {"sha": "3195c989c5ee50106d5597761723c57fd41b15db", "filename": "gcc/gcse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -1,7 +1,7 @@\n /* Global common subexpression elimination/Partial redundancy elimination\n    and global constant/copy propagation for GNU compiler.\n    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,\n-   2006, 2007, 2008 Free Software Foundation, Inc.\n+   2006, 2007, 2008, 2009 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2512,7 +2512,7 @@ compute_transp (const_rtx x, int indx, sbitmap *bmap, int set_p)\n \t\t    dest_addr = XEXP (list_entry, 0);\n \n \t\t    if (canon_true_dependence (dest, GET_MODE (dest), dest_addr,\n-\t\t\t\t\t       x, rtx_addr_varies_p))\n+\t\t\t\t\t       x, NULL_RTX, rtx_addr_varies_p))\n \t\t      {\n \t\t\tif (set_p)\n \t\t\t  SET_BIT (bmap[bb_index], indx);"}, {"sha": "b93c129f8af3b3ce53f24bd037bc855afdfed93d", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -2290,7 +2290,7 @@ extern rtx canon_rtx (rtx);\n extern int true_dependence (const_rtx, enum machine_mode, const_rtx, bool (*)(const_rtx, bool));\n extern rtx get_addr (rtx);\n extern int canon_true_dependence (const_rtx, enum machine_mode, rtx, const_rtx,\n-\t\t\t\t  bool (*)(const_rtx, bool));\n+\t\t\t\t  rtx, bool (*)(const_rtx, bool));\n extern int read_dependence (const_rtx, const_rtx);\n extern int anti_dependence (const_rtx, const_rtx);\n extern int output_dependence (const_rtx, const_rtx);"}, {"sha": "bb5ffce71f977411021c0c44c65816d43aedef5c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -1,3 +1,8 @@\n+2009-04-24  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR rtl-optimization/39794\n+\t* gcc.dg/pr39794.c: New test.\n+\n 2009-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/atomic1.adb: New test."}, {"sha": "2702ba79ae673b66f01361359c6da4445e2860e8", "filename": "gcc/testsuite/gcc.dg/pr39794.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39794.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6216f94e37db8de5a846c5945f4aa5f4e32aaedf/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39794.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr39794.c?ref=6216f94e37db8de5a846c5945f4aa5f4e32aaedf", "patch": "@@ -0,0 +1,33 @@\n+/* PR rtl-optimization/39794 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -funroll-loops\" } */\n+\n+extern void abort ();\n+\n+void\n+foo (int *a, int n)\n+{\n+  int i;\n+  for (i = 0; i < n; i++)\n+    {\n+      a[i] *= 2;\n+      a[i + 1] = a[i - 1] + a[i - 2];\n+    }\n+}\n+\n+int a[16];\n+int ref[16] = { 0, 1, 4, 2, 10, 12, 24, 44,\n+\t\t72, 136, 232, 416, 736, 1296, 2304, 2032 };\n+\n+int\n+main ()\n+{\n+  int i;\n+  for (i = 0; i < 16; i++)\n+    a[i] = i;\n+  foo (a + 2, 16 - 3);\n+  for (i = 0; i < 16; i++)\n+    if (ref[i] != a[i])\n+      abort ();\n+  return 0;\n+}"}]}