{"sha": "e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTM3OGRmNmQzOWU3NmJjNWNkYzU2YjNkN2M4YzU3NjAxZmU4ZDZjMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-05-10T20:36:00Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-07-07T09:26:57Z"}, "message": "[Ada] ACATS 4.1H - BC60005 - null exclusion matching for formal subprograms\n\ngcc/ada/\n\n\t* sem_ch6.adb (Check_Conformance): Remove unnecessary (and\n\twrong) code.\n\t* sem_ch8.adb (Check_Null_Exclusion): Post error at proper\n\tlocation.  Introduce new helper Null_Exclusion_Mismatch and fix\n\timplementation wrt formal subprograms used in generic bodies.\n\t(Analyze_Subprogram_Renaming): Fix missing setting of\n\tError_Msg_Sloc.\n\t(Analyze_Object_Renaming): Replace \"in Anonymous_Access_Kind\" by\n\tIs_Anonymous_Access_Type.\n\t* sem_util.adb (Has_Null_Exclusion): Fix handling of\n\tN_Parameter_Specification.\n\t* sem_ch12.adb (Instantiate_Object): Replace \"in\n\tAnonymous_Access_Kind\" by Is_Anonymous_Access_Type.", "tree": {"sha": "1b2b836e029bb96e12ef374a10008c0fcb0c0202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b2b836e029bb96e12ef374a10008c0fcb0c0202"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dae09f9b557b1a38b4743a4213f7ca47c48eec81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dae09f9b557b1a38b4743a4213f7ca47c48eec81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dae09f9b557b1a38b4743a4213f7ca47c48eec81"}], "stats": {"total": 136, "additions": 45, "deletions": 91}, "files": [{"sha": "97e9ab89672583914ada9be8423aa15c560fda22", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "patch": "@@ -11339,9 +11339,8 @@ package body Sem_Ch12 is\n             --  access type.\n \n             if Ada_Version < Ada_2005\n-              or else Ekind (Base_Type (Ftyp)) not in Anonymous_Access_Kind\n-              or else Ekind (Base_Type (Etype (Actual)))\n-                        not in Anonymous_Access_Kind\n+              or else not Is_Anonymous_Access_Type (Base_Type (Ftyp))\n+              or else not Is_Anonymous_Access_Type (Base_Type (Etype (Actual)))\n             then\n                Error_Msg_NE\n                  (\"type of actual does not match type of&\", Actual, Gen_Obj);"}, {"sha": "58736afa7ec1d9c1d753b1cdae712e5460842d50", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "patch": "@@ -5668,7 +5668,6 @@ package body Sem_Ch6 is\n       New_Type           : constant Entity_Id := Etype (New_Id);\n       Old_Formal         : Entity_Id;\n       New_Formal         : Entity_Id;\n-      Access_Types_Match : Boolean;\n       Old_Formal_Base    : Entity_Id;\n       New_Formal_Base    : Entity_Id;\n \n@@ -5869,57 +5868,6 @@ package body Sem_Ch6 is\n             New_Formal_Base := Get_Instance_Of (New_Formal_Base);\n          end if;\n \n-         Access_Types_Match := Ada_Version >= Ada_2005\n-\n-           --  Ensure that this rule is only applied when New_Id is a\n-           --  renaming of Old_Id.\n-\n-           and then Nkind (Parent (Parent (New_Id))) =\n-                      N_Subprogram_Renaming_Declaration\n-           and then Nkind (Name (Parent (Parent (New_Id)))) in N_Has_Entity\n-           and then Present (Entity (Name (Parent (Parent (New_Id)))))\n-           and then Entity (Name (Parent (Parent (New_Id)))) = Old_Id\n-\n-           --  Now handle the allowed access-type case\n-\n-           and then Is_Access_Type (Old_Formal_Base)\n-           and then Is_Access_Type (New_Formal_Base)\n-\n-           --  The type kinds must match. The only exception occurs with\n-           --  multiple generics of the form:\n-\n-           --   generic                    generic\n-           --     type F is private;         type A is private;\n-           --     type F_Ptr is access F;    type A_Ptr is access A;\n-           --     with proc F_P (X : F_Ptr); with proc A_P (X : A_Ptr);\n-           --   package F_Pack is ...      package A_Pack is\n-           --                                package F_Inst is\n-           --                                  new F_Pack (A, A_Ptr, A_P);\n-\n-           --  When checking for conformance between the parameters of A_P\n-           --  and F_P, the type kinds of F_Ptr and A_Ptr will not match\n-           --  because the compiler has transformed A_Ptr into a subtype of\n-           --  F_Ptr. We catch this case in the code below.\n-\n-           and then (Ekind (Old_Formal_Base) = Ekind (New_Formal_Base)\n-                      or else\n-                        (Is_Generic_Type (Old_Formal_Base)\n-                          and then Is_Generic_Type (New_Formal_Base)\n-                          and then Is_Internal (New_Formal_Base)\n-                          and then Etype (Etype (New_Formal_Base)) =\n-                                                          Old_Formal_Base))\n-               and then Directly_Designated_Type (Old_Formal_Base) =\n-                                    Directly_Designated_Type (New_Formal_Base)\n-           and then ((Is_Itype (Old_Formal_Base)\n-                       and then (Can_Never_Be_Null (Old_Formal_Base)\n-                                  or else Is_Access_Constant\n-                                            (Old_Formal_Base)))\n-                     or else\n-                      (Is_Itype (New_Formal_Base)\n-                        and then (Can_Never_Be_Null (New_Formal_Base)\n-                                   or else Is_Access_Constant\n-                                             (New_Formal_Base))));\n-\n          --  Types must always match. In the visible part of an instance,\n          --  usual overloading rules for dispatching operations apply, and\n          --  we check base types (not the actual subtypes).\n@@ -5932,7 +5880,6 @@ package body Sem_Ch6 is\n                       T2       => Base_Type (Etype (New_Formal)),\n                       Ctype    => Ctype,\n                       Get_Inst => Get_Inst)\n-               and then not Access_Types_Match\n             then\n                Conformance_Error (\"\\type of & does not match!\", New_Formal);\n                return;\n@@ -5943,7 +5890,6 @@ package body Sem_Ch6 is\n                       T2       => New_Formal_Base,\n                       Ctype    => Ctype,\n                       Get_Inst => Get_Inst)\n-           and then not Access_Types_Match\n          then\n             --  Don't give error message if old type is Any_Type. This test\n             --  avoids some cascaded errors, e.g. in case of a bad spec.\n@@ -5996,10 +5942,8 @@ package body Sem_Ch6 is\n \n                return;\n \n-            --  Part of mode conformance for access types is having the same\n-            --  constant modifier.\n-\n-            elsif Access_Types_Match\n+            elsif Is_Access_Type (Old_Formal_Base)\n+              and then Is_Access_Type (New_Formal_Base)\n               and then Is_Access_Constant (Old_Formal_Base) /=\n                        Is_Access_Constant (New_Formal_Base)\n             then\n@@ -6021,8 +5965,8 @@ package body Sem_Ch6 is\n             --  (access formals in the bodies aren't marked Can_Never_Be_Null).\n \n             if Ada_Version >= Ada_2005\n-              and then Ekind (Etype (Old_Formal)) = E_Anonymous_Access_Type\n-              and then Ekind (Etype (New_Formal)) = E_Anonymous_Access_Type\n+              and then Is_Anonymous_Access_Type (Etype (Old_Formal))\n+              and then Is_Anonymous_Access_Type (Etype (New_Formal))\n               and then\n                 ((Can_Never_Be_Null (Etype (Old_Formal)) /=\n                   Can_Never_Be_Null (Etype (New_Formal))"}, {"sha": "0fcccc9c38319a386abff98f52f2591eece670a6", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "patch": "@@ -1040,8 +1040,8 @@ package body Sem_Ch8 is\n \n          if Nkind (Nam) = N_Type_Conversion\n            and then not Comes_From_Source (Nam)\n-           and then Ekind (Etype (Expression (Nam))) in Anonymous_Access_Kind\n-           and then Ekind (T) not in Anonymous_Access_Kind\n+           and then Is_Anonymous_Access_Type (Etype (Expression (Nam)))\n+           and then not Is_Anonymous_Access_Type (T)\n          then\n             Wrong_Type (Expression (Nam), T); -- Should we give better error???\n          end if;\n@@ -2004,15 +2004,14 @@ package body Sem_Ch8 is\n       --  Ada 2005 (AI-423): Given renaming Ren of subprogram Sub, check the\n       --  following AI rules:\n       --\n-      --    If Ren is a renaming of a formal subprogram and one of its\n-      --    parameters has a null exclusion, then the corresponding formal\n-      --    in Sub must also have one. Otherwise the subtype of the Sub's\n-      --    formal parameter must exclude null.\n+      --    If Ren denotes a generic formal object of a generic unit G, and the\n+      --    renaming (or instantiation containing the actual) occurs within the\n+      --    body of G or within the body of a generic unit declared within the\n+      --    declarative region of G, then the corresponding parameter of G\n+      --    shall have a null_exclusion; Otherwise the subtype of the Sub's\n+      --    formal parameter shall exclude null.\n       --\n-      --    If Ren is a renaming of a formal function and its return\n-      --    profile has a null exclusion, then Sub's return profile must\n-      --    have one. Otherwise the subtype of Sub's return profile must\n-      --    exclude null.\n+      --    Similarly for its return profile.\n \n       procedure Check_SPARK_Primitive_Operation (Subp_Id : Entity_Id);\n       --  Ensure that a SPARK renaming denoted by its entity Subp_Id does not\n@@ -2579,20 +2578,38 @@ package body Sem_Ch8 is\n          Ren_Formal : Entity_Id;\n          Sub_Formal : Entity_Id;\n \n+         function Null_Exclusion_Mismatch\n+           (Renaming : Entity_Id; Renamed : Entity_Id) return Boolean;\n+         --  Return True if there is a null exclusion mismatch between\n+         --  Renaming and Renamed, False otherwise.\n+\n+         -----------------------------\n+         -- Null_Exclusion_Mismatch --\n+         -----------------------------\n+\n+         function Null_Exclusion_Mismatch\n+           (Renaming : Entity_Id; Renamed : Entity_Id) return Boolean is\n+         begin\n+            return Has_Null_Exclusion (Parent (Renaming))\n+              and then\n+                not (Has_Null_Exclusion (Parent (Renamed))\n+                      or else (Can_Never_Be_Null (Etype (Renamed))\n+                                and then not\n+                                  (Is_Formal_Subprogram (Sub)\n+                                   and then In_Generic_Body (Current_Scope))));\n+         end Null_Exclusion_Mismatch;\n+\n       begin\n          --  Parameter check\n \n          Ren_Formal := First_Formal (Ren);\n          Sub_Formal := First_Formal (Sub);\n          while Present (Ren_Formal) and then Present (Sub_Formal) loop\n-            if Has_Null_Exclusion (Parent (Ren_Formal))\n-              and then\n-                not (Has_Null_Exclusion (Parent (Sub_Formal))\n-                      or else Can_Never_Be_Null (Etype (Sub_Formal)))\n-            then\n+            if Null_Exclusion_Mismatch (Ren_Formal, Sub_Formal) then\n+               Error_Msg_Sloc := Sloc (Sub_Formal);\n                Error_Msg_NE\n-                 (\"`NOT NULL` required for parameter &\",\n-                  Parent (Sub_Formal), Sub_Formal);\n+                 (\"`NOT NULL` required for parameter &#\",\n+                  Ren_Formal, Sub_Formal);\n             end if;\n \n             Next_Formal (Ren_Formal);\n@@ -2603,13 +2620,10 @@ package body Sem_Ch8 is\n \n          if Nkind (Parent (Ren)) = N_Function_Specification\n            and then Nkind (Parent (Sub)) = N_Function_Specification\n-           and then Has_Null_Exclusion (Parent (Ren))\n-           and then not (Has_Null_Exclusion (Parent (Sub))\n-                          or else Can_Never_Be_Null (Etype (Sub)))\n+           and then Null_Exclusion_Mismatch (Ren, Sub)\n          then\n-            Error_Msg_N\n-              (\"return must specify `NOT NULL`\",\n-               Result_Definition (Parent (Sub)));\n+            Error_Msg_Sloc := Sloc (Sub);\n+            Error_Msg_N (\"return must specify `NOT NULL`#\", Ren);\n          end if;\n       end Check_Null_Exclusion;\n \n@@ -3454,10 +3468,6 @@ package body Sem_Ch8 is\n             then\n                Check_Mode_Conformant (New_S, Old_S);\n             end if;\n-\n-            if Is_Actual and then Error_Posted (New_S) then\n-               Error_Msg_NE (\"invalid actual subprogram: & #!\", N, Old_S);\n-            end if;\n          end if;\n \n          if No (Rename_Spec) then"}, {"sha": "44ed3e61dac84732dc4316898cfa2adceae6fbe0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e378df6d39e76bc5cdc56b3d7c8c57601fe8d6c0", "patch": "@@ -12066,7 +12066,8 @@ package body Sem_Util is\n \n          when N_Parameter_Specification =>\n             if Nkind (Parameter_Type (N)) = N_Access_Definition then\n-               return Null_Exclusion_Present (Parameter_Type (N));\n+               return Null_Exclusion_Present (Parameter_Type (N))\n+                 or else Null_Exclusion_Present (N);\n             else\n                return Null_Exclusion_Present (N);\n             end if;"}]}