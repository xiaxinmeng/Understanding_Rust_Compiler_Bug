{"sha": "b19058080955faaad5744d69288cb1de24078083", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjE5MDU4MDgwOTU1ZmFhYWQ1NzQ0ZDY5Mjg4Y2IxZGUyNDA3ODA4Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-23T00:17:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-23T00:17:07Z"}, "message": "re PR lto/65475 (ICE in odr_vtable_hasher::equal (Segmentation fault))\n\n\n\tPR ipa/65475\n\t* ipa-devirt.c: Include demangle.h\n\t(odr_type_d): Add field rtti_broken.\n\t(odr_subtypes_equivalent_p): Do not require name to match.\n\t(compare_virtual_tables): Fix typo; if type already has ODR violation,\n\tbypass the tests; be ready for function referneces in vtables that are\n\tnot DECL_VIRTUAL; make warnings to be OPT_Wodr.\n\t(warn_odr): Give up for nameless types.\n\t(warn_types_mismatch): Report mismatch in mangled names;\n\treport mismatch in anonymous namespaces; look into component types to\n\tgive useful error; report when mismatch is dragged in from other ODR\n\ttype.\n\t(odr_types_equivalent_p): Match types for being polymorphic; avoid\n\tduplicated diagnostics.\n\t(add_type_duplicate): Reorder checks so more informative ones come\n\tfirst; fix typo; do not output \"the extra base is defined here\" when\n\twe did not warn.\n\t(BINFO_N_BASE_BINFOS): Relax sanity check.\n\t* g++.dg/lto/pr65475b_0.C: New testcase.\n\t* g++.dg/lto/pr65475b_1.C: New testcase.\n\t* g++.dg/lto/pr65475c_0.C: New testcase.\n\t* g++.dg/lto/pr65475c_1.C: New testcase.\n\nFrom-SVN: r221582", "tree": {"sha": "ee6d9b6bb0477a6ca9579d2865403daaf915389e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee6d9b6bb0477a6ca9579d2865403daaf915389e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b19058080955faaad5744d69288cb1de24078083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19058080955faaad5744d69288cb1de24078083", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b19058080955faaad5744d69288cb1de24078083", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b19058080955faaad5744d69288cb1de24078083/comments", "author": null, "committer": null, "parents": [{"sha": "67e00dabd9dc1a02cdbfcddd6e4619d69d214de7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67e00dabd9dc1a02cdbfcddd6e4619d69d214de7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67e00dabd9dc1a02cdbfcddd6e4619d69d214de7"}], "stats": {"total": 813, "additions": 713, "deletions": 100}, "files": [{"sha": "02562e34e3537f096d90d1e45c6840cb428ab210", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -1,5 +1,25 @@\n-2015-03-22  Martin Liska  <mliska@suse.cz>\n+2015-03-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/65475\n+\t* ipa-devirt.c: Include demangle.h\n+\t(odr_type_d): Add field rtti_broken.\n+\t(odr_subtypes_equivalent_p): Do not require name to match.\n+\t(compare_virtual_tables): Fix typo; if type already has ODR violation,\n+\tbypass the tests; be ready for function referneces in vtables that are\n+\tnot DECL_VIRTUAL; make warnings to be OPT_Wodr.\n+\t(warn_odr): Give up for nameless types.\n+\t(warn_types_mismatch): Report mismatch in mangled names;\n+\treport mismatch in anonymous namespaces; look into component types to\n+\tgive useful error; report when mismatch is dragged in from other ODR\n+\ttype.\n+\t(odr_types_equivalent_p): Match types for being polymorphic; avoid\n+\tduplicated diagnostics.\n+\t(add_type_duplicate): Reorder checks so more informative ones come\n+\tfirst; fix typo; do not output \"the extra base is defined here\" when\n+\twe did not warn.\n+\t(BINFO_N_BASE_BINFOS): Relax sanity check.\n \n+2015-03-22  Martin Liska  <mliska@suse.cz>\n \t    Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (def_builtin): Set deferred_isa_values for"}, {"sha": "5e08431d4276edce34d44aaf5d48242d836374d5", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 278, "deletions": 99, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -166,6 +166,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"stor-layout.h\"\n #include \"intl.h\"\n+#include \"demangle.h\"\n \n /* Hash based set of pairs of types.  */\n typedef struct\n@@ -239,6 +240,8 @@ struct GTY(()) odr_type_d\n   bool all_derivations_known;\n   /* Did we report ODR violation here?  */\n   bool odr_violated;\n+  /* Set when virtual table without RTTI previaled table with.  */\n+  bool rtti_broken;\n };\n \n /* Return TRUE if all derived types of T are known and thus\n@@ -673,8 +676,6 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n     return false;\n   if ((TYPE_NAME (t1) == NULL_TREE) != (TYPE_NAME (t2) == NULL_TREE))\n     return false;\n-  if (TYPE_NAME (t1) && DECL_NAME (TYPE_NAME (t1)) != DECL_NAME (TYPE_NAME (t2)))\n-    return false;\n \n   type_pair pair={t1,t2};\n   if (TYPE_UID (t1) > TYPE_UID (t2))\n@@ -694,6 +695,7 @@ void\n compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n {\n   int n1, n2;\n+\n   if (DECL_VIRTUAL_P (prevailing->decl) != DECL_VIRTUAL_P (vtable->decl))\n     {\n       odr_violation_reported = true;\n@@ -715,6 +717,17 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n     }\n   if (!prevailing->definition || !vtable->definition)\n     return;\n+\n+  /* If we do not stream ODR type info, do not bother to do useful compare.  */\n+  if (!TYPE_BINFO (DECL_CONTEXT (vtable->decl))\n+      || !polymorphic_type_binfo_p (TYPE_BINFO (DECL_CONTEXT (vtable->decl))))\n+    return;\n+\n+  odr_type class_type = get_odr_type (DECL_CONTEXT (vtable->decl), true);\n+\n+  if (class_type->odr_violated)\n+    return;\n+\n   for (n1 = 0, n2 = 0; true; n1++, n2++)\n     {\n       struct ipa_ref *ref1, *ref2;\n@@ -730,13 +743,16 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t     && (end1\n \t         || (DECL_ASSEMBLER_NAME (ref1->referred->decl)\n \t\t     != DECL_ASSEMBLER_NAME (ref2->referred->decl)\n-\t             && DECL_VIRTUAL_P (ref1->referred->decl)))\n-\t     && !DECL_VIRTUAL_P (ref2->referred->decl))\n+\t             && TREE_CODE (ref1->referred->decl) == FUNCTION_DECL))\n+\t     && TREE_CODE (ref2->referred->decl) != FUNCTION_DECL)\n \t{\n-\t  if (warning_at (DECL_SOURCE_LOCATION\n-\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n-\t\t\t  \"virtual table of type %qD contains RTTI information\",\n-\t\t\t  DECL_CONTEXT (vtable->decl)))\n+\t  if (!class_type->rtti_broken\n+\t      && warning_at (DECL_SOURCE_LOCATION\n+\t\t\t      (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+\t\t\t     OPT_Wodr,\n+\t\t\t     \"virtual table of type %qD contains RTTI \"\n+\t\t\t     \"information\",\n+\t\t\t     DECL_CONTEXT (vtable->decl)))\n \t    {\n \t      inform (DECL_SOURCE_LOCATION\n \t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n@@ -745,6 +761,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t      inform (DECL_SOURCE_LOCATION\n \t\t\t(TYPE_NAME (DECL_CONTEXT (prevailing->decl))),\n \t\t      \"RTTI will not work on this type\");\n+\t      class_type->rtti_broken = true;\n \t    }\n \t  n2++;\n           end2 = !vtable->iterate_reference (n2, ref2);\n@@ -753,11 +770,11 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t     && (end2\n \t         || (DECL_ASSEMBLER_NAME (ref2->referred->decl)\n \t\t     != DECL_ASSEMBLER_NAME (ref1->referred->decl)\n-\t             && DECL_VIRTUAL_P (ref2->referred->decl)))\n-\t     && !DECL_VIRTUAL_P (ref1->referred->decl))\n+\t             && TREE_CODE (ref2->referred->decl) == FUNCTION_DECL))\n+\t     && TREE_CODE (ref1->referred->decl) != FUNCTION_DECL)\n \t{\n \t  n1++;\n-          end1 = !vtable->iterate_reference (n1, ref1);\n+          end1 = !prevailing->iterate_reference (n1, ref1);\n \t}\n \n       /* Finished?  */\n@@ -770,8 +787,10 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t     is not output too often.  */\n \t  if (DECL_SIZE (prevailing->decl) != DECL_SIZE (vtable->decl))\n \t    {\n+\t      class_type->odr_violated = true;\n \t      if (warning_at (DECL_SOURCE_LOCATION\n-\t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+\t\t\t      OPT_Wodr,\n \t\t\t      \"virtual table of type %qD violates \"\n \t\t\t      \"one definition rule  \",\n \t\t\t      DECL_CONTEXT (vtable->decl)))\n@@ -791,13 +810,16 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t      == DECL_ASSEMBLER_NAME (ref2->referred->decl))\n \t    continue;\n \n+\t  class_type->odr_violated = true;\n+\n \t  /* If the loops above stopped on non-virtual pointer, we have\n \t     mismatch in RTTI information mangling.  */\n-\t  if (!DECL_VIRTUAL_P (ref1->referred->decl)\n-\t      && !DECL_VIRTUAL_P (ref2->referred->decl))\n+\t  if (TREE_CODE (ref1->referred->decl) != FUNCTION_DECL\n+\t      && TREE_CODE (ref2->referred->decl) != FUNCTION_DECL)\n \t    {\n \t      if (warning_at (DECL_SOURCE_LOCATION\n-\t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+\t\t\t      OPT_Wodr,\n \t\t\t      \"virtual table of type %qD violates \"\n \t\t\t      \"one definition rule  \",\n \t\t\t      DECL_CONTEXT (vtable->decl)))\n@@ -813,12 +835,6 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t     or virtual method.  If one points to virtual table and other to\n \t     method we can complain the same way as if one table was shorter\n \t     than other pointing out the extra method.  */\n-\t  gcc_assert (DECL_VIRTUAL_P (ref1->referred->decl)\n-\t\t      && (TREE_CODE (ref1->referred->decl) == FUNCTION_DECL\n-\t\t          || TREE_CODE (ref1->referred->decl) == VAR_DECL));\n-\t  gcc_assert (DECL_VIRTUAL_P (ref2->referred->decl)\n-\t\t      && (TREE_CODE (ref2->referred->decl) == FUNCTION_DECL\n-\t\t          || TREE_CODE (ref2->referred->decl) == VAR_DECL));\n \t  if (TREE_CODE (ref1->referred->decl)\n \t      != TREE_CODE (ref2->referred->decl))\n \t    {\n@@ -829,6 +845,8 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t    }\n \t}\n \n+      class_type->odr_violated = true;\n+\n       /* Complain about size mismatch.  Either we have too many virutal\n  \t functions or too many virtual table pointers.  */\n       if (end1 || end2)\n@@ -841,7 +859,8 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n \t      ref1 = ref2;\n \t    }\n \t  if (warning_at (DECL_SOURCE_LOCATION\n-\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t    (TYPE_NAME (DECL_CONTEXT (vtable->decl))),\n+\t\t\t  OPT_Wodr,\n \t\t\t  \"virtual table of type %qD violates \"\n \t\t\t  \"one definition rule\",\n \t\t\t  DECL_CONTEXT (vtable->decl)))\n@@ -871,7 +890,7 @@ compare_virtual_tables (varpool_node *prevailing, varpool_node *vtable)\n       /* And in the last case we have either mistmatch in between two virtual\n \t methods or two virtual table pointers.  */\n       if (warning_at (DECL_SOURCE_LOCATION\n-\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), 0,\n+\t\t\t(TYPE_NAME (DECL_CONTEXT (vtable->decl))), OPT_Wodr,\n \t\t      \"virtual table of type %qD violates \"\n \t\t      \"one definition rule  \",\n \t\t      DECL_CONTEXT (vtable->decl)))\n@@ -914,8 +933,9 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n   if (warned)\n     *warned = false;\n \n-  if (!warn)\n+  if (!warn || !TYPE_NAME(t1))\n     return;\n+\n   if (!warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (t1)), OPT_Wodr,\n \t\t   \"type %qT violates one definition rule\",\n \t\t   t1))\n@@ -964,7 +984,132 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n void\n warn_types_mismatch (tree t1, tree t2)\n {\n+  /* If types have names and they are different, it is most informative to\n+     output those.  */\n+  if (TYPE_NAME (t1) && TYPE_NAME (t2)\n+      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t1))\n+      && DECL_ASSEMBLER_NAME_SET_P (TYPE_NAME (t2))\n+      && DECL_ASSEMBLER_NAME (TYPE_NAME (t1))\n+\t != DECL_ASSEMBLER_NAME (TYPE_NAME (t2)))\n+    {\n+      char *name1 = xstrdup (cplus_demangle\n+\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (t1))),\n+\t  DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES));\n+      char *name2 = cplus_demangle\n+\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (TYPE_NAME (t2))),\n+\t  DMGL_PARAMS | DMGL_ANSI | DMGL_TYPES);\n+      if (name1 && name2 && strcmp (name1, name2))\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n+\t\t  \"type name %<%s%> should match type name %<%s%>\",\n+\t\t  name1, name2);\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n+\t\t  \"the incompatible type is defined here\");\n+\t  free (name1);\n+\t  return;\n+\t}\n+      free (name1);\n+    }\n+  /* It is a quite common bug to reference anonymous namespace type in\n+     non-anonymous namespace class.  */\n+  if (type_in_anonymous_namespace_p (t1)\n+      || type_in_anonymous_namespace_p (t2))\n+    {\n+      if (!type_in_anonymous_namespace_p (t1))\n+\t{\n+\t  tree tmp = t1;;\n+\t  t1 = t2;\n+\t  t2 = tmp;\n+\t}\n+      if (TYPE_NAME (t1) && TYPE_NAME (t2))\n+\t{\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n+\t\t  \"type %qT defined in anonymous namespace can not match \"\n+\t\t  \"type %qT\",\n+\t\t  t1, t2);\n+\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n+\t\t  \"the incompatible type defined in anonymous namespace in \"\n+\t\t  \"another translation unit\");\n+\t}\n+      else\n+\tinform (UNKNOWN_LOCATION,\n+\t\t\"types in anonymous namespace does not match across \"\n+\t\t\"translation unit boundary\");\n+      return;\n+    }\n+  /* A tricky case are component types.  Often they appear the same in source\n+     code and the mismatch is dragged in by type they are build from.\n+     Look for those differences in subtypes and try to be informative.  In other\n+     cases just output nothing because the source code is probably different\n+     and in this case we already output a all necessary info.  */\n   if (!TYPE_NAME (t1) || !TYPE_NAME (t2))\n+    {\n+      if (TREE_CODE (t1) == TREE_CODE (t2))\n+\t{\n+\t  hash_set<type_pair,pair_traits> visited;\n+\t  if (TREE_CODE (t1) == ARRAY_TYPE\n+\t      && COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2))\n+\t    {\n+\t      tree i1 = TYPE_DOMAIN (t1);\n+\t      tree i2 = TYPE_DOMAIN (t2);\n+\t\n+\t      if (i1 && i2\n+\t\t  && TYPE_MAX_VALUE (i1)\n+\t\t  && TYPE_MAX_VALUE (i2)\n+\t\t  && !operand_equal_p (TYPE_MAX_VALUE (i1),\n+\t\t\t\t       TYPE_MAX_VALUE (i2), 0))\n+\t\t{\n+\t\t  inform (UNKNOWN_LOCATION,\n+\t\t\t  \"array types have different bounds\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t  if ((POINTER_TYPE_P (t1) || TREE_CODE (t1) == ARRAY_TYPE)\n+\t      && !odr_subtypes_equivalent_p (TREE_TYPE (t1),\n+\t\t\t\t\t     TREE_TYPE (t2),\n+\t\t\t\t\t     &visited))\n+\t    warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t  else if (TREE_CODE (t1) == METHOD_TYPE\n+\t\t   || TREE_CODE (t1) == FUNCTION_TYPE)\n+\t    {\n+\t      tree parms1, parms2;\n+\t      int count = 1;\n+\n+\t      if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t      &visited))\n+\t\t{\n+\t\t  inform (UNKNOWN_LOCATION, \"return value type mismatch\");\n+\t\t  warn_types_mismatch (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t\t  return;\n+\t\t}\n+\t      for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t\t   parms1 && parms2;\n+\t\t   parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2),\n+\t\t   count++)\n+\t\t{\n+\t\t  if (!odr_subtypes_equivalent_p\n+\t\t      (TREE_VALUE (parms1), TREE_VALUE (parms2), &visited))\n+\t\t    {\n+\t\t      inform (UNKNOWN_LOCATION,\n+\t\t\t      \"type mismatch in parameter %i\", count);\n+\t\t      warn_types_mismatch (TREE_VALUE (parms1),\n+\t\t\t\t\t   TREE_VALUE (parms2));\n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      if (parms1 || parms2)\n+\t\t{\n+\t\t  inform (UNKNOWN_LOCATION,\n+\t\t\t  \"types have different parameter counts\");\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n+  /* This should not happen but if it does, the warning would not be helpful.\n+     TODO: turn it into assert next stage1.  */\n+  if (TYPE_NAME (t1) == TYPE_NAME (t2))\n     return;\n   /* In Firefox it is a common bug to have same types but in\n      different namespaces.  Be a bit more informative on\n@@ -979,12 +1124,19 @@ warn_types_mismatch (tree t1, tree t2)\n \t    \"type %qT should match type %qT but is defined \"\n \t    \"in different namespace  \",\n \t    t1, t2);\n+  else if (types_odr_comparable (t1, t2, true)\n+\t   && types_same_for_odr (t1, t2, true))\n+    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n+\t    \"type %qT should match type %qT that itself violate \"\n+\t    \"one definition rule\",\n+\t    t1, t2);\n   else\n     inform (DECL_SOURCE_LOCATION (TYPE_NAME (t1)),\n \t    \"type %qT should match type %qT\",\n \t    t1, t2);\n-  inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n-\t  \"the incompatible type is defined here\");\n+  if (DECL_SOURCE_LOCATION (TYPE_NAME (t2)) > BUILTINS_LOCATION)\n+    inform (DECL_SOURCE_LOCATION (TYPE_NAME (t2)),\n+\t    \"the incompatible type is defined here\");\n }\n \n /* Compare T1 and T2, report ODR violations if WARN is true and set\n@@ -1232,6 +1384,20 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t/* For aggregate types, all the fields must be the same.  */\n \tif (COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2))\n \t  {\n+\t    if (TYPE_BINFO (t1) && TYPE_BINFO (t2)\n+\t        && polymorphic_type_binfo_p (TYPE_BINFO (t1))\n+\t\t   != polymorphic_type_binfo_p (TYPE_BINFO (t2)))\n+\t      {\n+\t\tif (polymorphic_type_binfo_p (TYPE_BINFO (t1)))\n+\t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\t\t    G_(\"a type defined in another translation unit \"\n+\t\t\t       \"is not polymorphic\"));\n+\t\telse\n+\t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n+\t\t\t    G_(\"a type defined in another translation unit \"\n+\t\t\t       \"is polymorphic\"));\n+\t\treturn false;\n+\t      }\n \t    for (f1 = TYPE_FIELDS (t1), f2 = TYPE_FIELDS (t2);\n \t\t f1 || f2;\n \t\t f1 = TREE_CHAIN (f1), f2 = TREE_CHAIN (f2))\n@@ -1303,8 +1469,8 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\t    G_(\"a type with different virtual table pointers\"\n \t\t\t       \" is defined in another translation unit\"));\n-\t\tif ((f1 && DECL_ARTIFICIAL (f1))\n-\t\t    || (f2 && DECL_ARTIFICIAL (f2)))\n+\t\telse if ((f1 && DECL_ARTIFICIAL (f1))\n+\t\t         || (f2 && DECL_ARTIFICIAL (f2)))\n \t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\t    G_(\"a type with different bases is defined \"\n \t\t\t       \"in another translation unit\"));\n@@ -1408,6 +1574,7 @@ add_type_duplicate (odr_type val, tree type)\n {\n   bool build_bases = false;\n   bool prevail = false;\n+  bool odr_must_violate = false;\n \n   if (!val->types_set)\n     val->types_set = new hash_set<tree>;\n@@ -1469,27 +1636,7 @@ add_type_duplicate (odr_type val, tree type)\n   gcc_assert (in_lto_p);\n   vec_safe_push (val->types, type);\n \n-  /* First we compare memory layout.  */\n-  if (!odr_types_equivalent_p (val->type, type,\n-\t\t\t       !flag_ltrans && !val->odr_violated,\n-\t\t\t       &warned, &visited))\n-    {\n-      merge = false;\n-      odr_violation_reported = true;\n-      val->odr_violated = true;\n-      if (symtab->dump_file)\n-\t{\n-\t  fprintf (symtab->dump_file, \"ODR violation\\n\");\n-\n-\t  print_node (symtab->dump_file, \"\", val->type, 0);\n-\t  putc ('\\n',symtab->dump_file);\n-\t  print_node (symtab->dump_file, \"\", type, 0);\n-\t  putc ('\\n',symtab->dump_file);\n-\t}\n-    }\n-\n-  /* Next sanity check that bases are the same.  If not, we will end\n-     up producing wrong answers.  */\n+  /* If both are class types, compare the bases.  */\n   if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n       && TREE_CODE (val->type) == RECORD_TYPE\n       && TREE_CODE (type) == RECORD_TYPE\n@@ -1498,25 +1645,28 @@ add_type_duplicate (odr_type val, tree type)\n       if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n \t  != BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n \t{\n-\t  if (!warned && !val->odr_violated)\n+\t  if (!flag_ltrans && !warned && !val->odr_violated)\n \t    {\n \t      tree extra_base;\n \t      warn_odr (type, val->type, NULL, NULL, !warned, &warned,\n \t\t\t\"a type with the same name but different \"\n \t\t\t\"number of polymorphic bases is \"\n \t\t\t\"defined in another translation unit\");\n-\t      if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n-\t\t  > BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n-\t\textra_base = BINFO_BASE_BINFO\n-\t\t\t     (TYPE_BINFO (type),\n-\t\t\t      BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)));\n-\t      else\n-\t\textra_base = BINFO_BASE_BINFO\n-\t\t\t     (TYPE_BINFO (val->type),\n-\t\t\t      BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n-\t      tree extra_base_type = BINFO_TYPE (extra_base);\n-\t      inform (DECL_SOURCE_LOCATION (TYPE_NAME (extra_base_type)),\n-\t\t      \"the extra base is defined here\");\n+\t      if (warned)\n+\t\t{\n+\t\t  if (BINFO_N_BASE_BINFOS (TYPE_BINFO (type))\n+\t\t      > BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)))\n+\t\t    extra_base = BINFO_BASE_BINFO\n+\t\t\t\t (TYPE_BINFO (type),\n+\t\t\t\t  BINFO_N_BASE_BINFOS (TYPE_BINFO (val->type)));\n+\t\t  else\n+\t\t    extra_base = BINFO_BASE_BINFO\n+\t\t\t\t (TYPE_BINFO (val->type),\n+\t\t\t\t  BINFO_N_BASE_BINFOS (TYPE_BINFO (type)));\n+\t\t  tree extra_base_type = BINFO_TYPE (extra_base);\n+\t\t  inform (DECL_SOURCE_LOCATION (TYPE_NAME (extra_base_type)),\n+\t\t\t  \"the extra base is defined here\");\n+\t\t}\n \t    }\n \t  base_mismatch = true;\n \t}\n@@ -1570,10 +1720,10 @@ add_type_duplicate (odr_type val, tree type)\n \t\t   but not for TYPE2 we possibly missed a base when recording\n \t\t   VAL->type earlier.\n \t\t   Be sure this does not happen.  */\n-\t\tgcc_assert (TYPE_BINFO (type2)\n-\t\t\t    || !polymorphic_type_binfo_p (TYPE_BINFO (type1))\n-\t\t\t    || build_bases\n-\t\t\t    || val->odr_violated);\n+\t\tif (TYPE_BINFO (type1)\n+\t\t    && polymorphic_type_binfo_p (TYPE_BINFO (type1))\n+\t\t    && !build_bases)\n+\t\t  odr_must_violate = true;\n \t        break;\n \t      }\n \t    /* One base is polymorphic and the other not.\n@@ -1583,38 +1733,15 @@ add_type_duplicate (odr_type val, tree type)\n \t\t     && polymorphic_type_binfo_p (TYPE_BINFO (type1))\n \t\t        != polymorphic_type_binfo_p (TYPE_BINFO (type2)))\n \t      {\n-\t\tgcc_assert (val->odr_violated);\n+\t\tif (!warned && !val->odr_violated)\n+\t\t  warn_odr (type, val->type, NULL, NULL,\n+\t\t\t    !warned, &warned,\n+\t\t\t    \"a base of the type is polymorphic only in one \"\n+\t\t\t    \"translation unit\");\n \t\tbase_mismatch = true;\n \t\tbreak;\n \t      }\n \t  }\n-#ifdef ENABLE_CHECKING\n-      /* Sanity check that all bases will be build same way again.  */\n-      if (!base_mismatch && val->bases.length ())\n-\t{\n-\t  unsigned int num_poly_bases = 0;\n-\t  unsigned int j;\n-\n-\t  for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n-\t    if (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n-\t\t\t\t\t     (TYPE_BINFO (type), i)))\n-\t      num_poly_bases++;\n-\t  gcc_assert (num_poly_bases == val->bases.length ());\n-\t  for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n-\t       i++)\n-\t    if (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n-\t\t\t\t\t   (TYPE_BINFO (type), i)))\n-\t      {\n-\t\todr_type base = get_odr_type\n-\t\t\t\t   (BINFO_TYPE\n-\t\t\t\t      (BINFO_BASE_BINFO (TYPE_BINFO (type),\n-\t\t\t\t\t\t\t i)),\n-\t\t\t\t    true);\n-\t\tgcc_assert (val->bases[j] == base);\n-\t\tj++;\n-\t      }\n-\t}\n-#endif\n       if (base_mismatch)\n \t{\n \t  merge = false;\n@@ -1633,6 +1760,59 @@ add_type_duplicate (odr_type val, tree type)\n \t}\n     }\n \n+  /* Next compare memory layout.  */\n+  if (!odr_types_equivalent_p (val->type, type,\n+\t\t\t       !flag_ltrans && !val->odr_violated && !warned,\n+\t\t\t       &warned, &visited))\n+    {\n+      merge = false;\n+      odr_violation_reported = true;\n+      val->odr_violated = true;\n+      if (symtab->dump_file)\n+\t{\n+\t  fprintf (symtab->dump_file, \"ODR violation\\n\");\n+\n+\t  print_node (symtab->dump_file, \"\", val->type, 0);\n+\t  putc ('\\n',symtab->dump_file);\n+\t  print_node (symtab->dump_file, \"\", type, 0);\n+\t  putc ('\\n',symtab->dump_file);\n+\t}\n+    }\n+  gcc_assert (val->odr_violated || !odr_must_violate);\n+  /* Sanity check that all bases will be build same way again.  */\n+#ifdef ENABLE_CHECKING\n+  if (COMPLETE_TYPE_P (type) && COMPLETE_TYPE_P (val->type)\n+      && TREE_CODE (val->type) == RECORD_TYPE\n+      && TREE_CODE (type) == RECORD_TYPE\n+      && TYPE_BINFO (val->type) && TYPE_BINFO (type)\n+      && !val->odr_violated\n+      && !base_mismatch && val->bases.length ())\n+    {\n+      unsigned int num_poly_bases = 0;\n+      unsigned int j;\n+\n+      for (i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type)); i++)\n+\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n+\t\t\t\t\t (TYPE_BINFO (type), i)))\n+\t  num_poly_bases++;\n+      gcc_assert (num_poly_bases == val->bases.length ());\n+      for (j = 0, i = 0; i < BINFO_N_BASE_BINFOS (TYPE_BINFO (type));\n+\t   i++)\n+\tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO\n+\t\t\t\t       (TYPE_BINFO (type), i)))\n+\t  {\n+\t    odr_type base = get_odr_type\n+\t\t\t       (BINFO_TYPE\n+\t\t\t\t  (BINFO_BASE_BINFO (TYPE_BINFO (type),\n+\t\t\t\t\t\t     i)),\n+\t\t\t\ttrue);\n+\t    gcc_assert (val->bases[j] == base);\n+\t    j++;\n+\t  }\n+    }\n+#endif\n+\n+\n   /* Regularize things a little.  During LTO same types may come with\n      different BINFOs.  Either because their virtual table was\n      not merged by tree merging and only later at decl merging or\n@@ -1794,7 +1974,7 @@ get_odr_type (tree type, bool insert)\n       tree binfo = TYPE_BINFO (type);\n       unsigned int i;\n \n-      gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) = type);\n+      gcc_assert (BINFO_TYPE (TYPE_BINFO (val->type)) == type);\n   \n       val->all_derivations_known = type_all_derivations_known_p (type);\n       for (i = 0; i < BINFO_N_BASE_BINFOS (binfo); i++)\n@@ -1803,10 +1983,9 @@ get_odr_type (tree type, bool insert)\n \t   determine ODR equivalency of these during LTO.  */\n \tif (polymorphic_type_binfo_p (BINFO_BASE_BINFO (binfo, i)))\n \t  {\n-\t    odr_type base = get_odr_type (BINFO_TYPE (BINFO_BASE_BINFO (binfo,\n-\t\t\t\t\t\t\t\t\ti)),\n-\t\t\t\t\t  true);\n-\t    gcc_assert (TYPE_MAIN_VARIANT (base->type) == base->type);\n+\t    tree base_type= BINFO_TYPE (BINFO_BASE_BINFO (binfo, i));\n+\t    odr_type base = get_odr_type (base_type, true);\n+\t    gcc_assert (TYPE_MAIN_VARIANT (base_type) == base_type);\n \t    base->derived_types.safe_push (val);\n \t    val->bases.safe_push (base);\n \t    if (base->id > base_id)"}, {"sha": "d9747487b42a1323fe34d04466fd457d6807945a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -1,3 +1,11 @@\n+2015-03-22  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/65475\n+\t* g++.dg/lto/pr65475b_0.C: New testcase.\n+\t* g++.dg/lto/pr65475b_1.C: New testcase.\n+\t* g++.dg/lto/pr65475c_0.C: New testcase.\n+\t* g++.dg/lto/pr65475c_1.C: New testcase.\n+\n 2015-03-21  Tobias Burnus  <burnus@net-b.de>\n \n \t* gfortran.dg/coarray_38.f90: New."}, {"sha": "c29b2e1e5cb0b9ddc7cf7ab16e09baee3e9b507b", "filename": "gcc/testsuite/g++.dg/lto/pr65475b_0.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475b_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475b_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475b_0.C?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-lto-do link } */\n+/* { dg-options \"-O2  -Wno-odr\" } */\n+/* { dg-extra-ld-options { -O2 -Wno-odr -r -nostdlib } } */\n+namespace std {\n+class exception {};\n+class runtime_error : exception {\n+  virtual char m_fn1();\n+} a;\n+}"}, {"sha": "29cb46199282e558a303f36eca21e824d2b57e42", "filename": "gcc/testsuite/g++.dg/lto/pr65475b_1.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475b_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475b_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475b_1.C?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -0,0 +1,7 @@\n+namespace std {\n+class exception {\n+  virtual char m_fn1();\n+};\n+class runtime_error : exception {\n+} b;\n+}"}, {"sha": "8e1d8bcc83daff9f93a2ea68cbe39d7a18ad6e51", "filename": "gcc/testsuite/g++.dg/lto/pr65475c_0.C", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_0.C?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -0,0 +1,156 @@\n+/* { dg-lto-do link } */\n+/* { dg-lto-options \"-O2  -w\" } */\n+/* { dg-extra-ld-options { -O2 -Wno-odr -r -nostdlib } } */\n+namespace std\n+{\n+template < class > struct char_traits;\n+typedef long streamsize;\n+template < typename, typename > class basic_streambuf;\n+template < typename > class A;\n+template < typename, typename > class basic_ostream;\n+template < typename _CharT, typename =\n+           char_traits < _CharT > >class istreambuf_iterator;\n+template < typename _CharT, typename =\n+           char_traits < _CharT > >class ostreambuf_iterator;\n+template < typename > class ctype;\n+template < typename _CharT, typename =\n+           istreambuf_iterator < _CharT > >class num_get;\n+template < typename _CharT, typename =\n+           ostreambuf_iterator < _CharT > >class num_put;\n+}\n+typedef int _Atomic_word;\n+namespace std\n+{\n+class locale\n+{\n+    class facet;\n+    class _Impl;\n+    _Impl *_M_impl;\n+};\n+class locale::facet\n+{\n+    _Atomic_word _M_refcount;\n+protected:\n+    virtual ~ facet ();\n+};\n+enum _Ios_Fmtflags\n+{   _S_boolalpha = 1, _S_dec, _S_fixed = 1 << 2, _S_hex =\n+        1 << 3, _S_internal = 1 << 4, _S_left = 1 << 5, _S_oct =\n+            1 << 6, _S_right = 1 << 7, _S_scientific = 1 << 8, _S_showbase =\n+                1 << 9, _S_showpoint = 1 << 10, _S_showpos = 1 << 11, _S_skipws =\n+                    1 << 12, _S_unitbuf = 1 << 13, _S_uppercase = 1 << 14, _S_adjustfield =\n+                        _S_left | _S_right | _S_internal, _S_basefield =\n+                            _S_dec | _S_oct | _S_hex, _S_floatfield =\n+                                _S_scientific | _S_fixed, _S_ios_fmtflags_end = 1 << 16\n+};\n+enum _Ios_Iostate\n+{   _S_goodbit, _S_badbit, _S_eofbit, _S_failbit =\n+        1 << 2, _S_ios_iostate_end = 1 << 16\n+};\n+class ios_base\n+{\n+    typedef _Ios_Fmtflags fmtflags;\n+    typedef _Ios_Iostate iostate;\n+    streamsize _M_precision;\n+    streamsize _M_width;\n+    fmtflags _M_flags;\n+    iostate _M_exception;\n+    iostate _M_streambuf_state;\n+    struct _Callback_list;\n+    _Callback_list *_M_callbacks;\n+    struct _Words\n+    {\n+        void *_M_pword;\n+        long _M_iword;\n+    } _M_word_zero;\n+    enum\n+    { _S_local_word_size = 8 };\n+    _Words _M_local_word[_S_local_word_size];\n+    int _M_word_size;\n+    _Words *_M_word;\n+    locale _M_ios_locale;\n+    virtual ~ ios_base ();\n+};\n+template < typename, typename > class istreambuf_iterator\n+{\n+    typedef A < char_traits < wchar_t > >istream_type;\n+};\n+template < typename, typename > class ostreambuf_iterator\n+{\n+    typedef basic_ostream < wchar_t, char_traits < wchar_t > >ostream_type;\n+};\n+template < typename, typename > class num_get:locale::facet\n+{\n+public:\n+    typedef istreambuf_iterator < wchar_t > iter_type;\n+};\n+template < typename, typename > class num_put:locale::facet\n+{\n+public:\n+    typedef ostreambuf_iterator < wchar_t > iter_type;\n+};\n+template < typename, typename > class basic_ios:ios_base\n+{\n+    typedef wchar_t char_type;\n+    basic_ostream < wchar_t, char_traits < wchar_t > >*_M_tie;\n+    char_type _M_fill;\n+    bool _M_fill_init;\n+    basic_streambuf < wchar_t, char_traits < wchar_t > >*_M_streambuf;\n+    ctype < wchar_t > *_M_ctype;\n+    num_put < wchar_t > *_M_num_put;\n+    num_get < wchar_t > *_M_num_get;\n+};\n+template < typename, typename > class basic_ostream:virtual basic_ios < wchar_t,\n+    char_traits < wchar_t >\n+    >\n+{\n+    typedef basic_ios __ios_type;\n+};\n+template < typename > class A:basic_ios < wchar_t, int >\n+{\n+};\n+class B:A < char_traits < wchar_t > >, basic_ostream < wchar_t,\n+    char_traits < wchar_t > >\n+{\n+};\n+}\n+\n+class C:\n+    std::num_put <\n+    wchar_t >\n+{\n+public:\n+    C (int);\n+    iter_type\n+    do_put_out;\n+};\n+class\n+    D:\n+    std::num_get <\n+    wchar_t >\n+{\n+public:\n+    D (int);\n+    iter_type\n+    do_get_in;\n+};\n+template < typename > void\n+install_formatting_facets (std::locale, int p2)\n+{\n+    (C (p2));\n+}\n+\n+template < typename > void\n+install_parsing_facets (std::locale, int p2)\n+{\n+    (D (p2));\n+}\n+\n+std::locale a;\n+int b;\n+void\n+create_formatting ()\n+{\n+    install_formatting_facets < wchar_t > (a, b);\n+    install_parsing_facets < wchar_t > (a, b);\n+}"}, {"sha": "b63ff9b225bd39cad678167563c8fd41e4f89855", "filename": "gcc/testsuite/g++.dg/lto/pr65475c_1.C", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b19058080955faaad5744d69288cb1de24078083/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fpr65475c_1.C?ref=b19058080955faaad5744d69288cb1de24078083", "patch": "@@ -0,0 +1,234 @@\n+namespace std\n+{\n+  template < class _CharT > struct char_traits;\n+  typedef long streamsize;\n+  template < typename _CharT, typename _Traits =\n+    char_traits < _CharT > >class basic_ostream;\n+  template < typename _CharT, typename _Traits =\n+    char_traits < _CharT > >class Trans_NS___cxx11_basic_ostringstream;\n+  template < typename _CharT, typename _Traits =\n+    char_traits < _CharT > >class istreambuf_iterator;\n+  template < typename _CharT, typename _Traits =\n+    char_traits < _CharT > >class ostreambuf_iterator;\n+}\n+namespace std\n+{\n+  template < typename _CharT, typename _InIter =\n+    istreambuf_iterator < _CharT > >class num_get;\n+  template < typename _CharT, typename _OutIter =\n+    ostreambuf_iterator < _CharT > >class num_put;\n+  struct iterator\n+  {\n+  };\n+}\n+typedef int _Atomic_word;\n+namespace std\n+{\n+  class locale\n+  {\n+  public:class facet;\n+    class _Impl;\n+      template < typename _Facet > locale ( const locale & __other,\n+\t\t\t\t\t    _Facet * __f );\n+  private:  _Impl * _M_impl;\n+  };\n+  class locale::facet\n+  {\n+    mutable _Atomic_word _M_refcount;\n+  protected:  explicit facet ( void ) throw (  );\n+      virtual ~ facet (  );\n+  };\n+  enum _Ios_Fmtflags\n+  {\n+    _S_boolalpha = 1 << 0, _S_dec, _S_fixed = 1 << 2, _S_hex =\n+      1 << 3, _S_internal = 1 << 4, _S_left = 1 << 5, _S_oct =\n+      1 << 6, _S_right = 1 << 7, _S_scientific = 1 << 8, _S_showbase =\n+      1 << 9, _S_showpoint = 1 << 10, _S_showpos = 1 << 11, _S_skipws =\n+      1 << 12, _S_unitbuf = 1 << 13, _S_uppercase = 1 << 14, _S_adjustfield =\n+      _S_left | _S_right | _S_internal, _S_basefield =\n+      _S_dec | _S_oct | _S_hex, _S_floatfield =\n+      _S_scientific | _S_fixed, _S_ios_fmtflags_end = 1 << 16\n+  };\n+  enum _Ios_Openmode\n+  {\n+    _S_out\n+  };\n+  enum _Ios_Iostate\n+  {\n+    _S_goodbit, _S_badbit, _S_eofbit, _S_failbit =\n+      1 << 2, _S_ios_iostate_end = 1 << 16\n+  };\n+  class ios_base\n+  {\n+  public:typedef _Ios_Fmtflags fmtflags;\n+    typedef _Ios_Iostate iostate;\n+  protected:  streamsize _M_precision;\n+    streamsize _M_width;\n+    fmtflags _M_flags;\n+    iostate _M_exception;\n+    iostate _M_streambuf_state;\n+    struct _Callback_list;\n+    _Callback_list *_M_callbacks;\n+    struct _Words\n+    {\n+      void *_M_pword;\n+      long _M_iword;\n+    };\n+    _Words _M_word_zero;\n+    enum\n+    {\n+      _S_local_word_size = 8\n+    };\n+    _Words _M_local_word[_S_local_word_size];\n+    int _M_word_size;\n+    _Words *_M_word;\n+    locale _M_ios_locale;\n+      virtual ~ ios_base (  );\n+  };\n+  template < typename _CharT, typename _Traits > class basic_streambuf;\n+template < typename _CharT, typename _Traits > class ostreambuf_iterator:public\n+    iterator\n+  {\n+    typedef basic_ostream < wchar_t, _Traits > ostream_type;\n+  };\n+  class __ctype_abstract_base:public locale::facet\n+  {\n+  };\n+template < typename _CharT > class ctype:public __ctype_abstract_base\n+  {\n+  };\n+  class Trans_NS___cxx11_numpunct:public locale::facet\n+  {\n+  };\n+template < typename _CharT, typename _InIter > class num_get:public locale::\n+    facet\n+  {\n+  };\n+template < typename _CharT, typename _OutIter > class num_put:public locale::\n+    facet\n+  {\n+  public:typedef int char_type;\n+    typedef std::ostreambuf_iterator < wchar_t,\n+      std::char_traits < wchar_t > >iter_type;\n+  };\n+template < typename _CharT, typename _Traits > class basic_ios:public\n+    ios_base\n+  {\n+  public:typedef wchar_t char_type;\n+    typedef num_get < wchar_t, istreambuf_iterator < wchar_t,\n+      _Traits > >__num_get_type;\n+  protected:basic_ostream < wchar_t, _Traits > *_M_tie;\n+    mutable char_type _M_fill;\n+    mutable bool _M_fill_init;\n+    basic_streambuf < wchar_t, _Traits > *_M_streambuf;\n+    const ctype < wchar_t > *_M_ctype;\n+    const num_put < wchar_t, ostreambuf_iterator < wchar_t,\n+      _Traits > >*_M_num_put;\n+    const __num_get_type *_M_num_get;\n+  };\n+template < typename _CharT, typename _Traits > class basic_ostream:virtual public basic_ios < wchar_t,\n+    _Traits\n+    >\n+  {\n+  };\n+}\n+typedef enum\n+{\n+  posix\n+}\n+value_type;\n+static const unsigned int wchar_t_facet = 1 << 1;\n+class shared_ptr\n+{\n+};\n+namespace std \n+{\n+template < typename _CharT, typename _Traits > class Trans_NS___cxx11_basic_ostringstream:public basic_ostream < wchar_t,\n+    _Traits\n+    >\n+  {\n+  public:explicit Trans_NS___cxx11_basic_ostringstream ( void );\n+  };\n+}\n+class base_num_format:public\n+  std::num_put <\n+  wchar_t >\n+{\n+public:typedef typename\n+    std::num_put <\n+    wchar_t >::iter_type\n+    iter_type;\n+  typedef wchar_t\n+    char_type;\n+  base_num_format ( unsigned long refs = 0 );\n+  iter_type\n+    do_put_out;\n+  std::ios_base &\n+    do_put_ios;\n+  char_type\n+    do_put_fill;\n+  unsigned long long\n+    do_put_val;\n+  virtual iter_type\n+  do_put ( void ) const\n+  {\n+    return\n+    do_real_put ( do_put_out, do_put_ios, do_put_fill, do_put_val );\n+  }\n+private:template <\n+    typename\n+    ValueType >\n+    iter_type\n+  do_real_put ( iter_type out, std::ios_base & ios, char_type fill,\n+\t\tValueType val ) const\n+  {\n+    switch ( 0 )\n+      case posix:\n+      {\n+\ttypedef\n+\t  std::Trans_NS___cxx11_basic_ostringstream <\n+\t  char_type >\n+\t  sstream_type;\n+\tsstream_type\n+\t  ss;\n+      }\n+  }\n+};\n+class\n+  base_num_parse:\n+  public\n+  std::num_get <\n+  wchar_t >\n+{\n+private:};\n+class\n+  num_format:\n+  public\n+  base_num_format\n+{\n+public:typedef wchar_t\n+    iter_type;\n+  num_format ( shared_ptr lc, unsigned long refs = 0 )\n+  {\n+  }\n+};\n+class\n+  num_punct_posix:\n+  public\n+  std::Trans_NS___cxx11_numpunct\n+{\n+};\n+template < typename CharType >\n+  std::locale create_formatting_impl ( std::locale const &in, shared_ptr lc )\n+{\n+  std::locale tmp = std::locale ( tmp, new num_format ( lc ) );\n+}\n+shared_ptr create_formatting_lc;\n+unsigned int create_formatting_type;\n+void\n+create_formatting ( std::locale const &in )\n+{\n+  switch ( create_formatting_type )\n+    case wchar_t_facet:\n+    create_formatting_impl < wchar_t > ( in, create_formatting_lc );\n+}"}]}