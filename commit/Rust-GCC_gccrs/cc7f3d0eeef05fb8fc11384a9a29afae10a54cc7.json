{"sha": "cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2M3ZjNkMGVlZWYwNWZiOGZjMTEzODRhOWEyOWFmYWUxMGE1NGNjNw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2015-06-17T20:36:42Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2015-06-17T20:36:42Z"}, "message": "C++11 allocator support for std::list.\n\n\tPR libstdc++/55409\n\t* include/bits/list.tcc (_List_base::_M_clear()): Use allocator traits.\n\t(list::list(const list&)): Use allocator propagation trait. Use\n\t_M_assign_dispatch to copy elements.\n\t* include/bits/stl_list.h (_List_node): Use __aligned_membuf in C++11.\n\t(_List_node::_M_valptr()): Add accessor for stored value.\n\t(_List_iterator, _List_const_iterator, _List_base): Use _M_valptr().\n\t(_List_base, list): Use allocator traits.\n\t(_List_base::_M_get_Tp_allocator, _List_base::get_allocator): Remove.\n\t(_List_base::_M_move_nodes): New function.\n\t(_List_base(_List_base&&)): Use _M_move_nodes.\n\t(_List_base(_List_base&&, _Node_alloc_type&&)): New constructor.\n\t(list::_M_create_node, list::_M_erase, list::max_size): Use allocator\n\ttraits.\n\t(list(size_type)): Add allocator parameter.\n\t(list(const list&)): Use allocator propagation trait.\n\t(list(const list&, const allocator_type&)): New constructor.\n\t(list(list&&, const allocator_type&)): Likewise.\n\t(list::operator=(list&&), list::swap(list&)): Use allocator\n\tpropagation traits.\n\t(list::_M_move_assign): New functions.\n\t* include/debug/list: Add allocator-extended constructors.\n\t* include/profile/list: Likewise.\n\t* python/libstdcxx/v6/printers.py (get_value_from_list_node): New\n\tfunction to get value from _List_node.\n\t(StdListPrinter): Use get_value_from_list_node.\n\t* testsuite/23_containers/list/allocator/copy.cc: New.\n\t* testsuite/23_containers/list/allocator/copy_assign.cc: New.\n\t* testsuite/23_containers/list/allocator/minimal.cc: New.\n\t* testsuite/23_containers/list/allocator/move.cc: New.\n\t* testsuite/23_containers/list/allocator/move_assign.cc: New.\n\t* testsuite/23_containers/list/allocator/noexcept.cc: New.\n\t* testsuite/23_containers/list/allocator/swap.cc: New.\n\t* testsuite/23_containers/list/requirements/dr438/assign_neg.cc:\n\tAdjust dg-prune-output line number.\n\t* testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc:\n\tLikewise.\n\t* testsuite/23_containers/list/requirements/dr438/insert_neg.cc:\n\tLikewise.\n\nFrom-SVN: r224580", "tree": {"sha": "9d672c64476f379d076c01024a112af142202b6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d672c64476f379d076c01024a112af142202b6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "917ad3c6853ae16b6e1fb1b75573ad23f67accd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917ad3c6853ae16b6e1fb1b75573ad23f67accd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917ad3c6853ae16b6e1fb1b75573ad23f67accd7"}], "stats": {"total": 794, "additions": 681, "deletions": 113}, "files": [{"sha": "345bf945ded75b4f102fc67ffc11ad6f25e4a383", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -1,5 +1,45 @@\n 2015-06-17  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/55409\n+\t* include/bits/list.tcc (_List_base::_M_clear()): Use allocator traits.\n+\t(list::list(const list&)): Use allocator propagation trait. Use\n+\t_M_assign_dispatch to copy elements.\n+\t* include/bits/stl_list.h (_List_node): Use __aligned_membuf in C++11.\n+\t(_List_node::_M_valptr()): Add accessor for stored value.\n+\t(_List_iterator, _List_const_iterator, _List_base): Use _M_valptr().\n+\t(_List_base, list): Use allocator traits.\n+\t(_List_base::_M_get_Tp_allocator, _List_base::get_allocator): Remove.\n+\t(_List_base::_M_move_nodes): New function.\n+\t(_List_base(_List_base&&)): Use _M_move_nodes.\n+\t(_List_base(_List_base&&, _Node_alloc_type&&)): New constructor.\n+\t(list::_M_create_node, list::_M_erase, list::max_size): Use allocator\n+\ttraits.\n+\t(list(size_type)): Add allocator parameter.\n+\t(list(const list&)): Use allocator propagation trait.\n+\t(list(const list&, const allocator_type&)): New constructor.\n+\t(list(list&&, const allocator_type&)): Likewise.\n+\t(list::operator=(list&&), list::swap(list&)): Use allocator\n+\tpropagation traits.\n+\t(list::_M_move_assign): New functions.\n+\t* include/debug/list: Add allocator-extended constructors.\n+\t* include/profile/list: Likewise.\n+\t* python/libstdcxx/v6/printers.py (get_value_from_list_node): New\n+\tfunction to get value from _List_node.\n+\t(StdListPrinter): Use get_value_from_list_node.\n+\t* testsuite/23_containers/list/allocator/copy.cc: New.\n+\t* testsuite/23_containers/list/allocator/copy_assign.cc: New.\n+\t* testsuite/23_containers/list/allocator/minimal.cc: New.\n+\t* testsuite/23_containers/list/allocator/move.cc: New.\n+\t* testsuite/23_containers/list/allocator/move_assign.cc: New.\n+\t* testsuite/23_containers/list/allocator/noexcept.cc: New.\n+\t* testsuite/23_containers/list/allocator/swap.cc: New.\n+\t* testsuite/23_containers/list/requirements/dr438/assign_neg.cc:\n+\tAdjust dg-prune-output line number.\n+\t* testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/list/requirements/dr438/insert_neg.cc:\n+\tLikewise.\n+\n \t* include/bits/forward_list.h\n \t(_Fwd_list_base(const _Node_alloc_type&)): Change parameter to\n \trvalue-reference."}, {"sha": "714d9b522a783e7a7df2a13ffd14dd4b62537de9", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -71,10 +71,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n \t{\n \t  _Node* __tmp = static_cast<_Node*>(__cur);\n \t  __cur = __tmp->_M_next;\n+\t  _Tp* __val = __tmp->_M_valptr();\n #if __cplusplus >= 201103L\n-\t  _M_get_Node_allocator().destroy(__tmp);\n+\t  _Node_alloc_traits::destroy(_M_get_Node_allocator(), __val);\n #else\n-\t  _M_get_Tp_allocator().destroy(std::__addressof(__tmp->_M_data));\n+\t  _Tp_alloc_type(_M_get_Node_allocator()).destroy(__val);\n #endif\n \t  _M_put_node(__tmp);\n \t}\n@@ -267,17 +268,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     {\n       if (this != std::__addressof(__x))\n \t{\n-\t  iterator __first1 = begin();\n-\t  iterator __last1 = end();\n-\t  const_iterator __first2 = __x.begin();\n-\t  const_iterator __last2 = __x.end();\n-\t  for (; __first1 != __last1 && __first2 != __last2;\n-\t       ++__first1, ++__first2)\n-\t    *__first1 = *__first2;\n-\t  if (__first2 == __last2)\n-\t    erase(__first1, __last1);\n-\t  else\n-\t    insert(__last1, __first2, __last2);\n+#if __cplusplus >= 201103L\n+\t  if (_Node_alloc_traits::_S_propagate_on_copy_assign())\n+\t    {\n+              auto& __this_alloc = this->_M_get_Node_allocator();\n+              auto& __that_alloc = __x._M_get_Node_allocator();\n+              if (!_Node_alloc_traits::_S_always_equal()\n+\t          && __this_alloc != __that_alloc)\n+\t        {\n+\t\t  // replacement allocator cannot free existing storage\n+\t\t  clear();\n+\t\t}\n+\t      std::__alloc_on_copy(__this_alloc, __that_alloc);\n+            }\n+#endif\n+\t  _M_assign_dispatch(__x.begin(), __x.end(), __false_type());\n \t}\n       return *this;\n     }"}, {"sha": "6a729fb992e6f04ff39497b12cbe0c0142c72405", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 136, "deletions": 90, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -57,8 +57,11 @@\n #define _STL_LIST_H 1\n \n #include <bits/concept_check.h>\n+#include <ext/alloc_traits.h>\n #if __cplusplus >= 201103L\n #include <initializer_list>\n+#include <bits/allocated_ptr.h>\n+#include <ext/aligned_buffer.h>\n #endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n@@ -105,14 +108,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n   template<typename _Tp>\n     struct _List_node : public __detail::_List_node_base\n     {\n-      ///< User's data.\n-      _Tp _M_data;\n-\n #if __cplusplus >= 201103L\n-      template<typename... _Args>\n-        _List_node(_Args&&... __args)\n-\t: __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...) \n-        { }\n+      __gnu_cxx::__aligned_membuf<_Tp> _M_storage;\n+      _Tp*       _M_valptr()       { return _M_storage._M_ptr(); }\n+      _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }\n+#else\n+      _Tp _M_data;\n+      _Tp*       _M_valptr()       { return std::__addressof(_M_data); }\n+      _Tp const* _M_valptr() const { return std::__addressof(_M_data); }\n #endif\n     };\n \n@@ -144,14 +147,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_const_cast() const _GLIBCXX_NOEXCEPT\n       { return *this; }\n \n-      // Must downcast from _List_node_base to _List_node to get to _M_data.\n+      // Must downcast from _List_node_base to _List_node to get to value.\n       reference\n       operator*() const _GLIBCXX_NOEXCEPT\n-      { return static_cast<_Node*>(_M_node)->_M_data; }\n+      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }\n \n       pointer\n       operator->() const _GLIBCXX_NOEXCEPT\n-      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }\n+      { return static_cast<_Node*>(_M_node)->_M_valptr(); }\n \n       _Self&\n       operator++() _GLIBCXX_NOEXCEPT\n@@ -228,15 +231,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n       _M_const_cast() const _GLIBCXX_NOEXCEPT\n       { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }\n \n-      // Must downcast from List_node_base to _List_node to get to\n-      // _M_data.\n+      // Must downcast from List_node_base to _List_node to get to value.\n       reference\n       operator*() const _GLIBCXX_NOEXCEPT\n-      { return static_cast<_Node*>(_M_node)->_M_data; }\n+      { return *static_cast<_Node*>(_M_node)->_M_valptr(); }\n \n       pointer\n       operator->() const _GLIBCXX_NOEXCEPT\n-      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }\n+      { return static_cast<_Node*>(_M_node)->_M_valptr(); }\n \n       _Self&\n       operator++() _GLIBCXX_NOEXCEPT\n@@ -298,23 +300,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n     class _List_base\n     {\n     protected:\n-      // NOTA BENE\n-      // The stored instance is not actually of \"allocator_type\"'s\n-      // type.  Instead we rebind the type to\n-      // Allocator<List_node<Tp>>, which according to [20.1.5]/4\n-      // should probably be the same.  List_node<Tp> is not the same\n-      // size as Tp (it's two pointers larger), and specializations on\n-      // Tp may go unused because List_node<Tp> is being bound\n-      // instead.\n-      //\n-      // We put this to the test in the constructors and in\n-      // get_allocator, where we use conversions between\n-      // allocator_type and _Node_alloc_type. The conversion is\n-      // required by table 32 in [20.1.5].\n-      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other\n-        _Node_alloc_type;\n-\n-      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n+      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template\n+\trebind<_Tp>::other\t\t\t\t_Tp_alloc_type;\n+      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>\t_Tp_alloc_traits;\n+      typedef typename _Tp_alloc_traits::template\n+\trebind<_List_node<_Tp> >::other _Node_alloc_type;\n+      typedef __gnu_cxx::__alloc_traits<_Node_alloc_type> _Node_alloc_traits;\n \n       static size_t\n       _S_distance(const __detail::_List_node_base* __first,\n@@ -338,7 +329,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t__detail::_List_node_base _M_node;\n #endif\n \n-\t_List_impl()\n+\t_List_impl() _GLIBCXX_NOEXCEPT\n \t: _Node_alloc_type(), _M_node()\n \t{ }\n \n@@ -347,7 +338,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t{ }\n \n #if __cplusplus >= 201103L\n-\t_List_impl(_Node_alloc_type&& __a) _GLIBCXX_NOEXCEPT\n+\t_List_impl(_Node_alloc_type&& __a) noexcept\n \t: _Node_alloc_type(std::move(__a)), _M_node()\n \t{ }\n #endif\n@@ -356,21 +347,21 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       _List_impl _M_impl;\n \n #if _GLIBCXX_USE_CXX11_ABI\n-      size_t _M_get_size() const { return _M_impl._M_node._M_data; }\n+      size_t _M_get_size() const { return *_M_impl._M_node._M_valptr(); }\n \n-      void _M_set_size(size_t __n) { _M_impl._M_node._M_data = __n; }\n+      void _M_set_size(size_t __n) { *_M_impl._M_node._M_valptr() = __n; }\n \n-      void _M_inc_size(size_t __n) { _M_impl._M_node._M_data += __n; }\n+      void _M_inc_size(size_t __n) { *_M_impl._M_node._M_valptr() += __n; }\n \n-      void _M_dec_size(size_t __n) { _M_impl._M_node._M_data -= __n; }\n+      void _M_dec_size(size_t __n) { *_M_impl._M_node._M_valptr() -= __n; }\n \n       size_t\n       _M_distance(const __detail::_List_node_base* __first,\n \t\t  const __detail::_List_node_base* __last) const\n       { return _S_distance(__first, __last); }\n \n       // return the stored size\n-      size_t _M_node_count() const { return _M_impl._M_node._M_data; }\n+      size_t _M_node_count() const { return *_M_impl._M_node._M_valptr(); }\n #else\n       // dummy implementations used when the size is not stored\n       size_t _M_get_size() const { return 0; }\n@@ -387,32 +378,24 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       }\n #endif\n \n-      _List_node<_Tp>*\n+      typename _Node_alloc_traits::pointer\n       _M_get_node()\n-      { return _M_impl._Node_alloc_type::allocate(1); }\n+      { return _Node_alloc_traits::allocate(_M_impl, 1); }\n \n       void\n-      _M_put_node(_List_node<_Tp>* __p) _GLIBCXX_NOEXCEPT\n-      { _M_impl._Node_alloc_type::deallocate(__p, 1); }\n+      _M_put_node(typename _Node_alloc_traits::pointer __p) _GLIBCXX_NOEXCEPT\n+      { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }\n \n   public:\n       typedef _Alloc allocator_type;\n \n       _Node_alloc_type&\n       _M_get_Node_allocator() _GLIBCXX_NOEXCEPT\n-      { return *static_cast<_Node_alloc_type*>(&_M_impl); }\n+      { return _M_impl; }\n \n       const _Node_alloc_type&\n       _M_get_Node_allocator() const _GLIBCXX_NOEXCEPT\n-      { return *static_cast<const _Node_alloc_type*>(&_M_impl); }\n-\n-      _Tp_alloc_type\n-      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT\n-      { return _Tp_alloc_type(_M_get_Node_allocator()); }\n-\n-      allocator_type\n-      get_allocator() const _GLIBCXX_NOEXCEPT\n-      { return allocator_type(_M_get_Node_allocator()); }\n+      { return _M_impl; }\n \n       _List_base()\n       : _M_impl()\n@@ -425,6 +408,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n #if __cplusplus >= 201103L\n       _List_base(_List_base&& __x) noexcept\n       : _M_impl(std::move(__x._M_get_Node_allocator()))\n+      { _M_move_nodes(std::move(__x)); }\n+\n+      _List_base(_List_base&& __x, _Node_alloc_type&& __a)\n+      : _M_impl(std::move(__a))\n+      {\n+\tif (__x._M_get_Node_allocator() == _M_get_Node_allocator())\n+\t  _M_move_nodes(std::move(__x));\n+\telse\n+\t  _M_init(); // Caller must move individual elements.\n+      }\n+\n+      void\n+      _M_move_nodes(_List_base&& __x)\n       {\n \tauto* const __xnode = std::__addressof(__x._M_impl._M_node);\n \tif (__xnode->_M_next == __xnode)\n@@ -513,16 +509,18 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \n       typedef _List_base<_Tp, _Alloc>                    _Base;\n       typedef typename _Base::_Tp_alloc_type\t\t _Tp_alloc_type;\n+      typedef typename _Base::_Tp_alloc_traits\t\t _Tp_alloc_traits;\n       typedef typename _Base::_Node_alloc_type\t\t _Node_alloc_type;\n+      typedef typename _Base::_Node_alloc_traits\t _Node_alloc_traits;\n \n     public:\n       typedef _Tp                                        value_type;\n-      typedef typename _Tp_alloc_type::pointer           pointer;\n-      typedef typename _Tp_alloc_type::const_pointer     const_pointer;\n-      typedef typename _Tp_alloc_type::reference         reference;\n-      typedef typename _Tp_alloc_type::const_reference   const_reference;\n-      typedef _List_iterator<_Tp>                        iterator;\n-      typedef _List_const_iterator<_Tp>                  const_iterator;\n+      typedef typename _Tp_alloc_traits::pointer\t pointer;\n+      typedef typename _Tp_alloc_traits::const_pointer\t const_pointer;\n+      typedef typename _Tp_alloc_traits::reference\t reference;\n+      typedef typename _Tp_alloc_traits::const_reference const_reference;\n+      typedef _List_iterator<_Tp>\t\t\t iterator;\n+      typedef _List_const_iterator<_Tp>\t\t\t const_iterator;\n       typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n       typedef std::reverse_iterator<iterator>            reverse_iterator;\n       typedef size_t                                     size_type;\n@@ -537,7 +535,6 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       using _Base::_M_impl;\n       using _Base::_M_put_node;\n       using _Base::_M_get_node;\n-      using _Base::_M_get_Tp_allocator;\n       using _Base::_M_get_Node_allocator;\n \n       /**\n@@ -553,8 +550,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n \t_Node* __p = this->_M_get_node();\n \t__try\n \t  {\n-\t    _M_get_Tp_allocator().construct\n-\t      (std::__addressof(__p->_M_data), __x);\n+\t    _Tp_alloc_type __alloc(_M_get_Node_allocator());\n+\t    __alloc.construct(__p->_M_valptr(), __x);\n \t  }\n \t__catch(...)\n \t  {\n@@ -568,17 +565,12 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n         _Node*\n         _M_create_node(_Args&&... __args)\n \t{\n-\t  _Node* __p = this->_M_get_node();\n-\t  __try\n-\t    {\n-\t      _M_get_Node_allocator().construct(__p,\n-\t\t\t\t\t\tstd::forward<_Args>(__args)...);\n-\t    }\n-\t  __catch(...)\n-\t    {\n-\t      _M_put_node(__p);\n-\t      __throw_exception_again;\n-\t    }\n+\t  auto __p = this->_M_get_node();\n+\t  auto& __alloc = _M_get_Node_allocator();\n+\t  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};\n+\t  _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),\n+\t\t\t\t\tstd::forward<_Args>(__args)...);\n+\t  __guard = nullptr;\n \t  return __p;\n \t}\n #endif\n@@ -608,13 +600,14 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       /**\n        *  @brief  Creates a %list with default constructed elements.\n        *  @param  __n  The number of elements to initially create.\n+       *  @param  __a  An allocator object.\n        *\n        *  This constructor fills the %list with @a __n default\n        *  constructed elements.\n        */\n       explicit\n-      list(size_type __n)\n-      : _Base()\n+      list(size_type __n, const allocator_type& __a = allocator_type())\n+      : _Base(_Node_alloc_type(__a))\n       { _M_default_initialize(__n); }\n \n       /**\n@@ -653,7 +646,8 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        *  by @a __x.\n        */\n       list(const list& __x)\n-      : _Base(__x._M_get_Node_allocator())\n+      : _Base(_Node_alloc_traits::\n+\t      _S_select_on_copy(__x._M_get_Node_allocator()))\n       { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }\n \n #if __cplusplus >= 201103L\n@@ -679,6 +673,20 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n            const allocator_type& __a = allocator_type())\n       : _Base(_Node_alloc_type(__a))\n       { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }\n+\n+      list(const list& __x, const allocator_type& __a)\n+      : _Base(_Node_alloc_type(__a))\n+      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }\n+\n+      list(list&& __x, const allocator_type& __a)\n+      noexcept(_Node_alloc_traits::_S_always_equal())\n+      : _Base(std::move(__x), _Node_alloc_type(__a))\n+      {\n+\t// If __x is not empty it means its allocator is not equal to __a,\n+\t// so we need to move from each element individually.\n+\tinsert(begin(), std::__make_move_if_noexcept_iterator(__x.begin()),\n+\t\t\tstd::__make_move_if_noexcept_iterator(__x.end()));\n+      }\n #endif\n \n       /**\n@@ -738,11 +746,13 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n       list&\n       operator=(list&& __x)\n+      noexcept(_Node_alloc_traits::_S_nothrow_move())\n       {\n-\t// NB: DR 1204.\n-\t// NB: DR 675.\n-\tthis->clear();\n-\tthis->swap(__x);\n+\tconstexpr bool __move_storage =\n+          _Node_alloc_traits::_S_propagate_on_move_assign()\n+          || _Node_alloc_traits::_S_always_equal();\n+        _M_move_assign(std::move(__x),\n+                       integral_constant<bool, __move_storage>());\n \treturn *this;\n       }\n \n@@ -820,7 +830,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       /// Get a copy of the memory allocation object.\n       allocator_type\n       get_allocator() const _GLIBCXX_NOEXCEPT\n-      { return _Base::get_allocator(); }\n+      { return allocator_type(_Base::_M_get_Node_allocator()); }\n \n       // iterators\n       /**\n@@ -949,7 +959,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       /**  Returns the size() of the largest possible %list.  */\n       size_type\n       max_size() const _GLIBCXX_NOEXCEPT\n-      { return _M_get_Node_allocator().max_size(); }\n+      { return _Node_alloc_traits::max_size(_M_get_Node_allocator()); }\n \n #if __cplusplus >= 201103L\n       /**\n@@ -1342,18 +1352,19 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n        */\n       void\n       swap(list& __x)\n+#if __cplusplus >= 201103L\n+      noexcept(_Node_alloc_traits::_S_nothrow_swap())\n+#endif\n       {\n-\t__detail::_List_node_base::swap(this->_M_impl._M_node, \n-\t\t\t\t\t__x._M_impl._M_node);\n+\t__detail::_List_node_base::swap(this->_M_impl._M_node,\n+\t\t\t\t        __x._M_impl._M_node);\n \n \tsize_t __xsize = __x._M_get_size();\n \t__x._M_set_size(this->_M_get_size());\n \tthis->_M_set_size(__xsize);\n \n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 431. Swapping containers with unequal allocators.\n-\tstd::__alloc_swap<typename _Base::_Node_alloc_type>::\n-\t  _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());\n+\t_Node_alloc_traits::_S_on_swap(this->_M_get_Node_allocator(),\n+                                       __x._M_get_Node_allocator());\n       }\n \n       /**\n@@ -1774,10 +1785,11 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n         __position._M_node->_M_unhook();\n         _Node* __n = static_cast<_Node*>(__position._M_node);\n #if __cplusplus >= 201103L\n-        _M_get_Node_allocator().destroy(__n);\n+\t_Node_alloc_traits::destroy(_M_get_Node_allocator(), __n->_M_valptr());\n #else\n-\t_M_get_Tp_allocator().destroy(std::__addressof(__n->_M_data));\n+\t_Tp_alloc_type(_M_get_Node_allocator()).destroy(__n->_M_valptr());\n #endif\n+\n         _M_put_node(__n);\n       }\n \n@@ -1793,6 +1805,40 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       // Used to implement resize.\n       const_iterator\n       _M_resize_pos(size_type& __new_size) const;\n+\n+#if __cplusplus >= 201103L\n+      void\n+      _M_move_assign(list&& __x, true_type) noexcept\n+      {\n+\tthis->_M_clear();\n+\tif (__x.empty())\n+\t  this->_M_init();\n+\telse\n+\t  {\n+\t    this->_M_impl._M_node._M_next = __x._M_impl._M_node._M_next;\n+\t    this->_M_impl._M_node._M_next->_M_prev = &this->_M_impl._M_node;\n+\t    this->_M_impl._M_node._M_prev = __x._M_impl._M_node._M_prev;\n+\t    this->_M_impl._M_node._M_prev->_M_next = &this->_M_impl._M_node;\n+\t    this->_M_set_size(__x._M_get_size());\n+\t    __x._M_init();\n+\t  }\n+        std::__alloc_on_move(this->_M_get_Node_allocator(),\n+                             __x._M_get_Node_allocator());\n+      }\n+\n+      void\n+      _M_move_assign(list&& __x, false_type)\n+      {\n+\tif (__x._M_get_Node_allocator() == this->_M_get_Node_allocator())\n+          _M_move_assign(std::move(__x), true_type{});\n+        else\n+\t  // The rvalue's allocator cannot be moved, or is not equal,\n+\t  // so we need to individually move each element.\n+\t  _M_assign_dispatch(std::__make_move_if_noexcept_iterator(__x.begin()),\n+\t\t\t     std::__make_move_if_noexcept_iterator(__x.end()),\n+\t\t\t     __false_type{});\n+      }\n+#endif\n     };\n _GLIBCXX_END_NAMESPACE_CXX11\n \n@@ -1903,7 +1949,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       ++__beyond;\n       bool __whole = __first == __beyond;\n       if (__builtin_constant_p (__whole) && __whole)\n-\treturn static_cast<const _Sentinel*>(__last._M_node)->_M_data;\n+\treturn *static_cast<const _Sentinel*>(__last._M_node)->_M_valptr();\n \n       ptrdiff_t __n = 0;\n       while (__first != __last)"}, {"sha": "1562946311bf09b95811de2f7e128fe47a0834cc", "filename": "libstdc++-v3/include/debug/list", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -94,6 +94,12 @@ namespace __debug\n       : _Base(__l, __a) { }\n \n       ~list() = default;\n+\n+      list(const list& __x, const allocator_type& __a)\n+      : _Base(__x, __a) { }\n+\n+      list(list&& __x, const allocator_type& __a)\n+      : _Base(std::move(__x), __a) { }\n #endif\n \n       explicit\n@@ -102,8 +108,8 @@ namespace __debug\n \n #if __cplusplus >= 201103L\n       explicit\n-      list(size_type __n)\n-      : _Base(__n) { }\n+      list(size_type __n, const allocator_type& __a = allocator_type())\n+      : _Base(__n, __a) { }\n \n       list(size_type __n, const _Tp& __value,\n \t   const _Allocator& __a = _Allocator())"}, {"sha": "b5943ee6dfc5dc025b448d2bcd0cc88380f3b9ca", "filename": "libstdc++-v3/include/profile/list", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Flist?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -145,6 +145,12 @@ namespace __profile\n       list(initializer_list<value_type> __l,\n \t   const allocator_type& __a = allocator_type())\n       : _Base(__l, __a) { }\n+\n+      list(const list& __x, const allocator_type& __a)\n+      : _Base(__x, __a) { }\n+\n+      list(list&& __x, const allocator_type& __a)\n+      : _Base(std::move(__x), __a) { }\n #endif\n \n       explicit\n@@ -153,8 +159,8 @@ namespace __profile\n \n #if __cplusplus >= 201103L\n       explicit\n-      list(size_type __n)\n-      : _Base(__n) { }\n+      list(size_type __n, const allocator_type& __a = allocator_type())\n+      : _Base(__n, __a) { }\n \n       list(size_type __n, const _Tp& __value,\n \t   const _Allocator& __a = _Allocator())"}, {"sha": "2d167863ad3f2b3cca723806b9e1dc4ae4da6a0b", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -128,6 +128,22 @@ def to_string (self):\n         return ('std::unique_ptr<%s> containing %s' % (str(v.type.target()),\n                                                        str(v)))\n \n+def get_value_from_list_node(node):\n+    \"\"\"Returns the value held in an _List_node<_Val>\"\"\"\n+    try:\n+        member = node.type.fields()[1].name\n+        if member == '_M_data':\n+            # C++03 implementation, node contains the value as a member\n+            return node['_M_data']\n+        elif member == '_M_storage':\n+            # C++11 implementation, node stores value in __aligned_membuf\n+            p = node['_M_storage']['_M_storage'].address\n+            p = p.cast(node.type.template_argument(0).pointer())\n+            return p.dereference()\n+    except:\n+        pass\n+    raise ValueError(\"Unsupported implementation for %s\" % str(node.type))\n+\n class StdListPrinter:\n     \"Print a std::list\"\n \n@@ -148,7 +164,8 @@ def __next__(self):\n             self.base = elt['_M_next']\n             count = self.count\n             self.count = self.count + 1\n-            return ('[%d]' % count, elt['_M_data'])\n+            val = get_value_from_list_node(elt)\n+            return ('[%d]' % count, val)\n \n     def __init__(self, typename, val):\n         self.typename = typename\n@@ -174,7 +191,8 @@ def __init__(self, typename, val):\n     def to_string(self):\n         nodetype = find_type(self.val.type, '_Node')\n         nodetype = nodetype.strip_typedefs().pointer()\n-        return self.val['_M_node'].cast(nodetype).dereference()['_M_data']\n+        node = self.val['_M_node'].cast(nodetype).dereference()\n+        return get_value_from_list_node(node)\n \n class StdSlistPrinter:\n     \"Print a __gnu_cxx::slist\"\n@@ -440,7 +458,7 @@ def get_value_from_Rb_tree_node(node):\n             # C++03 implementation, node contains the value as a member\n             return node['_M_value_field']\n         elif member == '_M_storage':\n-            # C++11 implementation, node stores value in __aligned_buffer\n+            # C++11 implementation, node stores value in __aligned_membuf\n             p = node['_M_storage']['_M_storage'].address\n             p = p.cast(node.type.template_argument(0).pointer())\n             return p.dereference()"}, {"sha": "8346deee3078899b38cffbf997d85972b105a2cf", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/copy.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fcopy.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,70 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(0 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(v1, alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "1a2aa0a8e2f186f6024d0784d11425762357c4da", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/copy_assign.cc", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fcopy_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fcopy_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fcopy_assign.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,61 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_front(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_front(T());\n+  v2 = v1;\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "f9dbdac4a14a96ae159a547e0707e33d8801bfba", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/minimal.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fminimal.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fminimal.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fminimal.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+bool operator==(const T& l, const T& r) { return l.i == r.i; }\n+bool operator<(const T& l, const T& r) { return l.i < r.i; }\n+\n+using __gnu_test::SimpleAllocator;\n+\n+template class std::list<T, SimpleAllocator<T>>;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef SimpleAllocator<T> alloc_type;\n+  typedef std::allocator_traits<alloc_type> traits_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v(alloc_type{});\n+  v.push_front(T());\n+  VERIFY( v.max_size() < traits_type::max_size(v.get_allocator()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c43c1900beef4f5dedf6030571e139def048289a", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/move.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fmove.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::uneq_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  auto it = v1.begin();\n+  test_type v2(std::move(v1));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef uneq_allocator<T> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1 = { T() };\n+  test_type v2(std::move(v1), alloc_type(2));\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "5bf1b34b76e48838b2e97eb771c32a6929c8e5e5", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/move_assign.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fmove_assign.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_front(T());\n+  v2 = std::move(v1);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  auto it = v1.begin();\n+  test_type v2(alloc_type(2));\n+  v2.push_front(T());\n+  v2 = std::move(v1);\n+  VERIFY(0 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+  VERIFY( it == v2.begin() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "4a84fceb5408be6ea58dc8c688cc6c05485920b5", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/noexcept.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fnoexcept.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fnoexcept.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fnoexcept.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,66 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do compile }\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+namespace __gnu_test\n+{\n+  template<typename U>\n+    inline void\n+    swap(propagating_allocator<U, true>& l, propagating_allocator<U, true>& r)\n+    noexcept(false)\n+    { }\n+}\n+\n+using __gnu_test::propagating_allocator;\n+\n+void test01()\n+{\n+  typedef std::allocator<T> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1;\n+  test_type v2;\n+  // this is a GNU extension for std::allocator\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test02()\n+{\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( !noexcept( v1 = std::move(v2) ), \"Move assign can throw\" );\n+  static_assert( noexcept( v1.swap(v2) ), \"Swap cannot throw\" );\n+}\n+\n+void test03()\n+{\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  test_type v2(alloc_type(2));\n+  static_assert( noexcept( v1 = std::move(v2) ), \"Move assign cannot throw\" );\n+  static_assert( !noexcept( v1.swap(v2) ), \"Swap can throw\" );\n+}"}, {"sha": "2ba08fdfb8487dcb7eda1aea98af8a8361a98d06", "filename": "libstdc++-v3/testsuite/23_containers/list/allocator/swap.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fallocator%2Fswap.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -0,0 +1,80 @@\n+// Copyright (C) 2015 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+struct T { int i; };\n+\n+using __gnu_test::propagating_allocator;\n+\n+// It is undefined behaviour to swap() containers wth unequal allocators\n+// if the allocator doesn't propagate, so ensure the allocators compare\n+// equal, while still being able to test propagation via get_personality().\n+bool\n+operator==(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return true;\n+}\n+\n+bool\n+operator!=(const propagating_allocator<T, false>&,\n+           const propagating_allocator<T, false>&)\n+{\n+  return false;\n+}\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, false> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_front(T());\n+  std::swap(v1, v2);\n+  VERIFY(1 == v1.get_allocator().get_personality());\n+  VERIFY(2 == v2.get_allocator().get_personality());\n+  // swap back so assertions in uneq_allocator::deallocate don't fail\n+  std::swap(v1, v2);\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  typedef propagating_allocator<T, true> alloc_type;\n+  typedef std::list<T, alloc_type> test_type;\n+  test_type v1(alloc_type(1));\n+  v1.push_front(T());\n+  test_type v2(alloc_type(2));\n+  v2.push_front(T());\n+  std::swap(v1, v2);\n+  VERIFY(2 == v1.get_allocator().get_personality());\n+  VERIFY(1 == v2.get_allocator().get_personality());\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "84c74734806d22257e710243d068e9f5c86a2341", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/assign_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fassign_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fassign_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fassign_neg.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-prune-output 1730 }\n+// { dg-prune-output 1741 }\n \n #include <list>\n "}, {"sha": "947029c043ff30b2d8c1fe367fb49e79315cc542", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/constructor_1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Fconstructor_1_neg.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-prune-output 1682 }\n+// { dg-prune-output 1693 }\n \n #include <list>\n "}, {"sha": "54e89328ce0cb0c1b4f3bcfcb64974b30bbdb13f", "filename": "libstdc++-v3/testsuite/23_containers/list/requirements/dr438/insert_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Finsert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Finsert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Frequirements%2Fdr438%2Finsert_neg.cc?ref=cc7f3d0eeef05fb8fc11384a9a29afae10a54cc7", "patch": "@@ -18,7 +18,7 @@\n // <http://www.gnu.org/licenses/>.\n \n // { dg-do compile }\n-// { dg-prune-output 1682 }\n+// { dg-prune-output 1693 }\n \n #include <list>\n "}]}