{"sha": "c01a508e4e8a795f63348accdd04483c9d67197e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAxYTUwOGU0ZThhNzk1ZjYzMzQ4YWNjZGQwNDQ4M2M5ZDY3MTk3ZQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-11-22T08:29:32Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-11-22T08:29:32Z"}, "message": "gcov.texi: Add magic comments for texi2pod.pl.\n\ngcc:\n\t* gcov.texi: Add magic comments for texi2pod.pl.\n\t* Makefile.in: Add rules to generate and install gcov.1.\n\t* gcov.1: New (generated) file.\n\ncontrib:\n\t* gcc_update: Add gcov.1 to the list of generated files.\n\nFrom-SVN: r37649", "tree": {"sha": "3420566535ebb8a4a71c582a8b253189dbef9972", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3420566535ebb8a4a71c582a8b253189dbef9972"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c01a508e4e8a795f63348accdd04483c9d67197e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01a508e4e8a795f63348accdd04483c9d67197e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c01a508e4e8a795f63348accdd04483c9d67197e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c01a508e4e8a795f63348accdd04483c9d67197e/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32a46c30c50b32405129249be4143c1aacb6fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32a46c30c50b32405129249be4143c1aacb6fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b32a46c30c50b32405129249be4143c1aacb6fd6"}], "stats": {"total": 480, "additions": 478, "deletions": 2}, "files": [{"sha": "20d87f86ca309856bfc6b4d299179070d6ede728", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a508e4e8a795f63348accdd04483c9d67197e/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a508e4e8a795f63348accdd04483c9d67197e/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=c01a508e4e8a795f63348accdd04483c9d67197e", "patch": "@@ -1,3 +1,7 @@\n+2000-11-22  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc_update: Add gcov.1 to the list of generated files.\n+\n 2000-11-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* gcc_build: Remove code to put information in a log file."}, {"sha": "f9721d880c99e2ec8edbad7f02d66c129953acb0", "filename": "contrib/gcc_update", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a508e4e8a795f63348accdd04483c9d67197e/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a508e4e8a795f63348accdd04483c9d67197e/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=c01a508e4e8a795f63348accdd04483c9d67197e", "patch": "@@ -67,6 +67,7 @@ gcc/cstamp-h.in: gcc/configure.in gcc/acconfig.h\n gcc/config.in: gcc/cstamp-h.in\n gcc/fixinc/fixincl.x: gcc/fixinc/fixincl.tpl gcc/fixinc/inclhack.def\n gcc/tradcif.c: gcc/tradcif.y\n+gcc/gcov.1: gcc/gcov.texi\n # And then, language-specific files\n gcc/java/parse.h: gcc/java/parse.y\n # And libraries, at last"}, {"sha": "3c4070c4b43df7fac9cb722ebd2e36ecf0c80ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c01a508e4e8a795f63348accdd04483c9d67197e", "patch": "@@ -1,3 +1,9 @@\n+2000-11-22  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcov.texi: Add magic comments for texi2pod.pl.\n+\t* Makefile.in: Add rules to generate and install gcov.1.\n+\t* gcov.1: New (generated) file.\n+\n 2000-11-21  Richard Henderson  <rth@redhat.com>\n \n \t* regrename.c (scan_rtx_reg): Terminate the chain rather than"}, {"sha": "10ad10589d1024155e5ae5c7de20a72698d9f31f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c01a508e4e8a795f63348accdd04483c9d67197e", "patch": "@@ -129,6 +129,8 @@ INSTALL_DATA = @INSTALL_DATA@\n MAKEINFO = @MAKEINFO@\n MAKEINFOFLAGS =\n TEXI2DVI = texi2dvi\n+TEXI2POD = $(srcdir)/../contrib/texi2pod.pl\n+POD2MAN = pod2man --center=\"GNU\" --release=\"gcc-$(version)\" --section=1\n # For GNUmake: let us decide what gets passed to recursive makes.\n MAKEOVERRIDES =\n @SET_MAKE@\n@@ -2171,6 +2173,13 @@ cpp.dvi: $(srcdir)/cpp.texi\n \ttexindex cpp.??\n \tTEXINPUTS=${texidir}:$(srcdir):$$TEXINPUTS tex cpp.texi\n \n+$(srcdir)/gcov.1: $(srcdir)/gcov.texi\n+\t$(TEXI2POD) < $(srcdir)/gcov.texi > gcov.pod\n+\t($(POD2MAN) gcov.pod > $(srcdir)/gcov.1.T$$$$ && \\\n+\t\tmv -f $(srcdir)/gcov.1.T$$$$ $(srcdir)/gcov.1) || \\\n+\t\t(rm -f $(srcdir)/gcov.1.T$$$$ && exit 1)\n+\trm -f gcov.pod\n+\n #\f\n # Deletion of files made during compilation.\n # There are four levels of this:\n@@ -2265,6 +2274,7 @@ distclean: clean $(INTL_DISTCLEAN) lang.distclean\n \t-rm -f cxxmain.c splay-tree.c obstack.c\n \t-rm -f mklibgcc libgcc.map gccbug .gdbinit configargs.h\n \t-rm -f c-tree.info c-tree.info-1 c-tree.info-2 c-tree.info-3\n+\t-rm -f gcov.pod\n \t-rm -f fixinc/Makefile\n \t-rmdir cp f java objc fixinc intl po 2>/dev/null\n \n@@ -2299,6 +2309,7 @@ maintainer-clean:\n \t-rm -f c-parse.y c-parse.c c-parse.output TAGS\n \t-rm -f cpp.info* cpp.??s cpp.*aux\n \t-rm -f gcc.info* gcc.??s gcc.*aux\n+\t-rm -f $(srcdir)/gcov.1\n #\f\n # Entry points `install' and `uninstall'.\n # Also use `install-collect2' to install collect2 when the config files don't.\n@@ -2482,7 +2493,7 @@ install-info: doc installdirs lang.install-info\n \t-chmod a-x $(infodir)/cpp.info* $(infodir)/gcc.info*\n \n # Install the man pages.\n-install-man: installdirs $(srcdir)/gcc.1 $(srcdir)/cpp.1 lang.install-man\n+install-man: installdirs $(srcdir)/gcc.1 $(srcdir)/cpp.1 $(srcdir)/gcov.1 lang.install-man\n \t-if [ -f gcc-cross$(exeext) ] ; then \\\n \t  rm -f $(man1dir)/$(GCC_CROSS_NAME)$(manext); \\\n \t  $(INSTALL_DATA) $(srcdir)/gcc.1 $(man1dir)/$(GCC_CROSS_NAME)$(manext); \\\n@@ -2494,6 +2505,8 @@ install-man: installdirs $(srcdir)/gcc.1 $(srcdir)/cpp.1 lang.install-man\n \tfi\n \t-rm -f $(man1dir)/cpp$(manext)\n \t-$(INSTALL_DATA) $(srcdir)/cpp.1 $(man1dir)/cpp$(manext)\n+\t-rm -f $(man1dir)/gcov$(manext)\n+\t-$(INSTALL_DATA) $(srcdir)/gcov.1 $(man1dir)/gcov$(manext)\n \t-chmod a-x $(man1dir)/cpp$(manext)\n \n # Install the library."}, {"sha": "5884dec2cbac19d8f80fca7b707af5f578816df2", "filename": "gcc/gcov.1", "status": "added", "additions": 414, "deletions": 0, "changes": 414, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2Fgcov.1", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2Fgcov.1", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.1?ref=c01a508e4e8a795f63348accdd04483c9d67197e", "patch": "@@ -0,0 +1,414 @@\n+.\\\" Automatically generated by Pod::Man version 1.1\n+.\\\" Tue Nov 21 17:46:08 2000\n+.\\\"\n+.\\\" Standard preamble:\n+.\\\" ======================================================================\n+.de Sh \\\" Subsection heading\n+.br\n+.if t .Sp\n+.ne 5\n+.PP\n+\\fB\\\\$1\\fR\n+.PP\n+..\n+.de Sp \\\" Vertical space (when we can't use .PP)\n+.if t .sp .5v\n+.if n .sp\n+..\n+.de Ip \\\" List item\n+.br\n+.ie \\\\n(.$>=3 .ne \\\\$3\n+.el .ne 3\n+.IP \"\\\\$1\" \\\\$2\n+..\n+.de Vb \\\" Begin verbatim text\n+.ft CW\n+.nf\n+.ne \\\\$1\n+..\n+.de Ve \\\" End verbatim text\n+.ft R\n+\n+.fi\n+..\n+.\\\" Set up some character translations and predefined strings.  \\*(-- will\n+.\\\" give an unbreakable dash, \\*(PI will give pi, \\*(L\" will give a left\n+.\\\" double quote, and \\*(R\" will give a right double quote.  | will give a\n+.\\\" real vertical bar.  \\*(C+ will give a nicer C++.  Capital omega is used\n+.\\\" to do unbreakable dashes and therefore won't be available.  \\*(C` and\n+.\\\" \\*(C' expand to `' in nroff, nothing in troff, for use with C<>\n+.tr \\(*W-|\\(bv\\*(Tr\n+.ds C+ C\\v'-.1v'\\h'-1p'\\s-2+\\h'-1p'+\\s0\\v'.1v'\\h'-1p'\n+.ie n \\{\\\n+.    ds -- \\(*W-\n+.    ds PI pi\n+.    if (\\n(.H=4u)&(1m=24u) .ds -- \\(*W\\h'-12u'\\(*W\\h'-12u'-\\\" diablo 10 pitch\n+.    if (\\n(.H=4u)&(1m=20u) .ds -- \\(*W\\h'-12u'\\(*W\\h'-8u'-\\\"  diablo 12 pitch\n+.    ds L\" \"\"\n+.    ds R\" \"\"\n+.    ds C` \"\"\n+.    ds C' \"\"\n+'br\\}\n+.el\\{\\\n+.    ds -- \\|\\(em\\|\n+.    ds PI \\(*p\n+.    ds L\" ``\n+.    ds R\" ''\n+'br\\}\n+.\\\"\n+.\\\" If the F register is turned on, we'll generate index entries on stderr\n+.\\\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and\n+.\\\" index entries marked with X<> in POD.  Of course, you'll have to process\n+.\\\" the output yourself in some meaningful fashion.\n+.if \\nF \\{\\\n+.    de IX\n+.    tm Index:\\\\$1\\t\\\\n%\\t\"\\\\$2\"\n+..\n+.    nr % 0\n+.    rr F\n+.\\}\n+.\\\"\n+.\\\" For nroff, turn off justification.  Always turn off hyphenation; it\n+.\\\" makes way too many mistakes in technical documents.\n+.hy 0\n+.if n .na\n+.\\\"\n+.\\\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).\n+.\\\" Fear.  Run.  Save yourself.  No user-serviceable parts.\n+.bd B 3\n+.    \\\" fudge factors for nroff and troff\n+.if n \\{\\\n+.    ds #H 0\n+.    ds #V .8m\n+.    ds #F .3m\n+.    ds #[ \\f1\n+.    ds #] \\fP\n+.\\}\n+.if t \\{\\\n+.    ds #H ((1u-(\\\\\\\\n(.fu%2u))*.13m)\n+.    ds #V .6m\n+.    ds #F 0\n+.    ds #[ \\&\n+.    ds #] \\&\n+.\\}\n+.    \\\" simple accents for nroff and troff\n+.if n \\{\\\n+.    ds ' \\&\n+.    ds ` \\&\n+.    ds ^ \\&\n+.    ds , \\&\n+.    ds ~ ~\n+.    ds /\n+.\\}\n+.if t \\{\\\n+.    ds ' \\\\k:\\h'-(\\\\n(.wu*8/10-\\*(#H)'\\'\\h\"|\\\\n:u\"\n+.    ds ` \\\\k:\\h'-(\\\\n(.wu*8/10-\\*(#H)'\\`\\h'|\\\\n:u'\n+.    ds ^ \\\\k:\\h'-(\\\\n(.wu*10/11-\\*(#H)'^\\h'|\\\\n:u'\n+.    ds , \\\\k:\\h'-(\\\\n(.wu*8/10)',\\h'|\\\\n:u'\n+.    ds ~ \\\\k:\\h'-(\\\\n(.wu-\\*(#H-.1m)'~\\h'|\\\\n:u'\n+.    ds / \\\\k:\\h'-(\\\\n(.wu*8/10-\\*(#H)'\\z\\(sl\\h'|\\\\n:u'\n+.\\}\n+.    \\\" troff and (daisy-wheel) nroff accents\n+.ds : \\\\k:\\h'-(\\\\n(.wu*8/10-\\*(#H+.1m+\\*(#F)'\\v'-\\*(#V'\\z.\\h'.2m+\\*(#F'.\\h'|\\\\n:u'\\v'\\*(#V'\n+.ds 8 \\h'\\*(#H'\\(*b\\h'-\\*(#H'\n+.ds o \\\\k:\\h'-(\\\\n(.wu+\\w'\\(de'u-\\*(#H)/2u'\\v'-.3n'\\*(#[\\z\\(de\\v'.3n'\\h'|\\\\n:u'\\*(#]\n+.ds d- \\h'\\*(#H'\\(pd\\h'-\\w'~'u'\\v'-.25m'\\f2\\(hy\\fP\\v'.25m'\\h'-\\*(#H'\n+.ds D- D\\\\k:\\h'-\\w'D'u'\\v'-.11m'\\z\\(hy\\v'.11m'\\h'|\\\\n:u'\n+.ds th \\*(#[\\v'.3m'\\s+1I\\s-1\\v'-.3m'\\h'-(\\w'I'u*2/3)'\\s-1o\\s+1\\*(#]\n+.ds Th \\*(#[\\s+2I\\s-2\\h'-\\w'I'u*3/5'\\v'-.3m'o\\v'.3m'\\*(#]\n+.ds ae a\\h'-(\\w'a'u*4/10)'e\n+.ds Ae A\\h'-(\\w'A'u*4/10)'E\n+.    \\\" corrections for vroff\n+.if v .ds ~ \\\\k:\\h'-(\\\\n(.wu*9/10-\\*(#H)'\\s-2\\u~\\d\\s+2\\h'|\\\\n:u'\n+.if v .ds ^ \\\\k:\\h'-(\\\\n(.wu*10/11-\\*(#H)'\\v'-.4m'^\\v'.4m'\\h'|\\\\n:u'\n+.    \\\" for low resolution devices (crt and lpr)\n+.if \\n(.H>23 .if \\n(.V>19 \\\n+\\{\\\n+.    ds : e\n+.    ds 8 ss\n+.    ds o a\n+.    ds d- d\\h'-1'\\(ga\n+.    ds D- D\\h'-1'\\(hy\n+.    ds th \\o'bp'\n+.    ds Th \\o'LP'\n+.    ds ae ae\n+.    ds Ae AE\n+.\\}\n+.rm #[ #] #H #V #F C\n+.\\\" ======================================================================\n+.\\\"\n+.IX Title \"GCOV 1\"\n+.TH GCOV 1 \"gcc-2.97\" \"2000-11-21\" \"GNU\"\n+.UC\n+.SH \"NAME\"\n+gcov \\- coverage testing tool\n+.SH \"SYNOPSIS\"\n+.IX Header \"SYNOPSIS\"\n+gcov [\\fB\\-b\\fR] [\\fB\\-c\\fR] [\\fB\\-v\\fR] [\\fB\\-n\\fR] [\\fB\\-l\\fR] [\\fB\\-f\\fR] [\\fB\\-o\\fR \\fIdirectory\\fR] \\fIsourcefile\\fR\n+.SH \"DESCRIPTION\"\n+.IX Header \"DESCRIPTION\"\n+\\&\\f(CW\\*(C`gcov\\*(C'\\fR is a test coverage program.  Use it in concert with \\s-1GNU\\s0\n+\\&\\s-1CC\\s0 to analyze your programs to help create more efficient, faster\n+running code.  You can use \\f(CW\\*(C`gcov\\*(C'\\fR as a profiling tool to help\n+discover where your optimization efforts will best affect your code.  You\n+can also use \\f(CW\\*(C`gcov\\*(C'\\fR along with the other profiling tool,\n+\\&\\f(CW\\*(C`gprof\\*(C'\\fR, to assess which parts of your code use the greatest amount\n+of computing time.\n+.PP\n+Profiling tools help you analyze your code's performance.  Using a\n+profiler such as \\f(CW\\*(C`gcov\\*(C'\\fR or \\f(CW\\*(C`gprof\\*(C'\\fR, you can find out some\n+basic performance statistics, such as:\n+.Ip \"\\(bu\" 4\n+how often each line of code executes\n+.Ip \"\\(bu\" 4\n+what lines of code are actually executed\n+.Ip \"\\(bu\" 4\n+how much computing time each section of code uses\n+.PP\n+Once you know these things about how your code works when compiled, you\n+can look at each module to see which modules should be optimized.\n+\\&\\f(CW\\*(C`gcov\\*(C'\\fR helps you determine where to work on optimization.\n+.PP\n+Software developers also use coverage testing in concert with\n+testsuites, to make sure software is actually good enough for a release.\n+Testsuites can verify that a program works as expected; a coverage\n+program tests to see how much of the program is exercised by the\n+testsuite.  Developers can then determine what kinds of test cases need\n+to be added to the testsuites to create both better testing and a better\n+final product.\n+.PP\n+You should compile your code without optimization if you plan to use\n+\\&\\f(CW\\*(C`gcov\\*(C'\\fR because the optimization, by combining some lines of code\n+into one function, may not give you as much information as you need to\n+look for `hot spots' where the code is using a great deal of computer\n+time.  Likewise, because \\f(CW\\*(C`gcov\\*(C'\\fR accumulates statistics by line (at\n+the lowest resolution), it works best with a programming style that\n+places only one statement on each line.  If you use complicated macros\n+that expand to loops or to other control structures, the statistics are\n+less helpful\\-\\-\\-they only report on the line where the macro call\n+appears.  If your complex macros behave like functions, you can replace\n+them with inline functions to solve this problem.\n+.PP\n+\\&\\f(CW\\*(C`gcov\\*(C'\\fR creates a logfile called \\fI\\fIsourcefile\\fI.gcov\\fR which\n+indicates how many times each line of a source file \\fI\\fIsourcefile\\fI.c\\fR\n+has executed.  You can use these logfiles along with \\f(CW\\*(C`gprof\\*(C'\\fR to aid\n+in fine-tuning the performance of your programs.  \\f(CW\\*(C`gprof\\*(C'\\fR gives\n+timing information you can use along with the information you get from\n+\\&\\f(CW\\*(C`gcov\\*(C'\\fR.\n+.PP\n+\\&\\f(CW\\*(C`gcov\\*(C'\\fR works only on code compiled with \\s-1GNU\\s0 \\s-1CC\\s0.  It is not\n+compatible with any other profiling or test coverage mechanism.\n+.SH \"OPTIONS\"\n+.IX Header \"OPTIONS\"\n+.if n .Ip \"\\f(CW\"\"\\-b\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-b\\fR\" 4\n+.IX Item \"-b\"\n+Write branch frequencies to the output file, and write branch summary\n+info to the standard output.  This option allows you to see how often\n+each branch in your program was taken.\n+.if n .Ip \"\\f(CW\"\"\\-c\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-c\\fR\" 4\n+.IX Item \"-c\"\n+Write branch frequencies as the number of branches taken, rather than \n+the percentage of branches taken.\n+.if n .Ip \"\\f(CW\"\"\\-v\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-v\\fR\" 4\n+.IX Item \"-v\"\n+Display the \\f(CW\\*(C`gcov\\*(C'\\fR version number (on the standard error stream).\n+.if n .Ip \"\\f(CW\"\"\\-n\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-n\\fR\" 4\n+.IX Item \"-n\"\n+Do not create the \\f(CW\\*(C`gcov\\*(C'\\fR output file.\n+.if n .Ip \"\\f(CW\"\"\\-l\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-l\\fR\" 4\n+.IX Item \"-l\"\n+Create long file names for included source files.  For example, if the\n+header file \\fBx.h\\fR contains code, and was included in the file\n+\\&\\fBa.c\\fR, then running \\f(CW\\*(C`gcov\\*(C'\\fR on the file \\fBa.c\\fR will produce\n+an output file called \\fBa.c.x.h.gcov\\fR instead of \\fBx.h.gcov\\fR.\n+This can be useful if \\fBx.h\\fR is included in multiple source files.\n+.if n .Ip \"\\f(CW\"\"\\-f\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-f\\fR\" 4\n+.IX Item \"-f\"\n+Output summaries for each function in addition to the file level summary.\n+.if n .Ip \"\\f(CW\"\"\\-o\"\"\\fR\" 4\n+.el .Ip \"\\f(CW\\-o\\fR\" 4\n+.IX Item \"-o\"\n+The directory where the object files live.  Gcov will search for \\f(CW\\*(C`.bb\\*(C'\\fR,\n+\\&\\f(CW\\*(C`.bbg\\*(C'\\fR, and \\f(CW\\*(C`.da\\*(C'\\fR files in this directory.\n+.PP\n+When using \\f(CW\\*(C`gcov\\*(C'\\fR, you must first compile your program with two\n+special \\s-1GNU\\s0 \\s-1CC\\s0 options: \\fB\\-fprofile-arcs \\-ftest-coverage\\fR.\n+This tells the compiler to generate additional information needed by\n+gcov (basically a flow graph of the program) and also includes\n+additional code in the object files for generating the extra profiling\n+information needed by gcov.  These additional files are placed in the\n+directory where the source code is located.\n+.PP\n+Running the program will cause profile output to be generated.  For each\n+source file compiled with \\-fprofile-arcs, an accompanying \\f(CW\\*(C`.da\\*(C'\\fR\n+file will be placed in the source directory.\n+.PP\n+Running \\f(CW\\*(C`gcov\\*(C'\\fR with your program's source file names as arguments\n+will now produce a listing of the code along with frequency of execution\n+for each line.  For example, if your program is called \\fBtmp.c\\fR, this\n+is what you see when you use the basic \\f(CW\\*(C`gcov\\*(C'\\fR facility:\n+.PP\n+.Vb 5\n+\\&        $ gcc -fprofile-arcs -ftest-coverage tmp.c\n+\\&        $ a.out\n+\\&        $ gcov tmp.c\n+\\&         87.50% of 8 source lines executed in file tmp.c\n+\\&        Creating tmp.c.gcov.\n+.Ve\n+The file \\fItmp.c.gcov\\fR contains output from \\f(CW\\*(C`gcov\\*(C'\\fR. \n+Here is a sample:\n+.PP\n+.Vb 3\n+\\&                        main()\n+\\&                        {\n+\\&                   1      int i, total;\n+.Ve\n+.Vb 1\n+\\&                   1      total = 0;\n+.Ve\n+.Vb 2\n+\\&                  11      for (i = 0; i < 10; i++)\n+\\&                  10        total += i;\n+.Ve\n+.Vb 5\n+\\&                   1      if (total != 45)\n+\\&              ######        printf (\"Failure\\en\");\n+\\&                          else\n+\\&                   1        printf (\"Success\\en\");\n+\\&                   1    }\n+.Ve\n+When you use the \\fB\\-b\\fR option, your output looks like this:\n+.PP\n+.Vb 6\n+\\&        $ gcov -b tmp.c\n+\\&         87.50% of 8 source lines executed in file tmp.c\n+\\&         80.00% of 5 branches executed in file tmp.c\n+\\&         80.00% of 5 branches taken at least once in file tmp.c\n+\\&         50.00% of 2 calls executed in file tmp.c\n+\\&        Creating tmp.c.gcov.\n+.Ve\n+Here is a sample of a resulting \\fItmp.c.gcov\\fR file:\n+.PP\n+.Vb 3\n+\\&                        main()\n+\\&                        {\n+\\&                   1      int i, total;\n+.Ve\n+.Vb 1\n+\\&                   1      total = 0;\n+.Ve\n+.Vb 5\n+\\&                  11      for (i = 0; i < 10; i++)\n+\\&        branch 0 taken = 91%\n+\\&        branch 1 taken = 100%\n+\\&        branch 2 taken = 100%\n+\\&                  10        total += i;\n+.Ve\n+.Vb 9\n+\\&                   1      if (total != 45)\n+\\&        branch 0 taken = 100%\n+\\&              ######        printf (\"Failure\\en\");\n+\\&        call 0 never executed\n+\\&        branch 1 never executed\n+\\&                          else\n+\\&                   1        printf (\"Success\\en\");\n+\\&        call 0 returns = 100%\n+\\&                   1    }\n+.Ve\n+For each basic block, a line is printed after the last line of the basic\n+block describing the branch or call that ends the basic block.  There can\n+be multiple branches and calls listed for a single source line if there\n+are multiple basic blocks that end on that line.  In this case, the\n+branches and calls are each given a number.  There is no simple way to map\n+these branches and calls back to source constructs.  In general, though,\n+the lowest numbered branch or call will correspond to the leftmost construct\n+on the source line.\n+.PP\n+For a branch, if it was executed at least once, then a percentage\n+indicating the number of times the branch was taken divided by the\n+number of times the branch was executed will be printed.  Otherwise, the\n+message ``never executed'' is printed.\n+.PP\n+For a call, if it was executed at least once, then a percentage\n+indicating the number of times the call returned divided by the number\n+of times the call was executed will be printed.  This will usually be\n+100%, but may be less for functions call \\f(CW\\*(C`exit\\*(C'\\fR or \\f(CW\\*(C`longjmp\\*(C'\\fR,\n+and thus may not return every time they are called.\n+.PP\n+The execution counts are cumulative.  If the example program were\n+executed again without removing the \\f(CW\\*(C`.da\\*(C'\\fR file, the count for the\n+number of times each line in the source was executed would be added to\n+the results of the previous \\fIrun\\fR\\|(s).  This is potentially useful in\n+several ways.  For example, it could be used to accumulate data over a\n+number of program runs as part of a test verification suite, or to\n+provide more accurate long-term information over a large number of\n+program runs.\n+.PP\n+The data in the \\f(CW\\*(C`.da\\*(C'\\fR files is saved immediately before the program\n+exits.  For each source file compiled with \\-fprofile-arcs, the profiling\n+code first attempts to read in an existing \\f(CW\\*(C`.da\\*(C'\\fR file; if the file\n+doesn't match the executable (differing number of basic block counts) it\n+will ignore the contents of the file.  It then adds in the new execution\n+counts and finally writes the data to the file.\n+.if n .Sh \"Using \\f(CW\"\"gcov\"\"\\fP with \\s-1GCC\\s0 Optimization\"\n+.el .Sh \"Using \\f(CWgcov\\fP with \\s-1GCC\\s0 Optimization\"\n+.IX Subsection \"Using gcov with GCC Optimization\"\n+If you plan to use \\f(CW\\*(C`gcov\\*(C'\\fR to help optimize your code, you must\n+first compile your program with two special \\s-1GNU\\s0 \\s-1CC\\s0 options:\n+\\&\\fB\\-fprofile-arcs \\-ftest-coverage\\fR.  Aside from that, you can use any\n+other \\s-1GNU\\s0 \\s-1CC\\s0 options; but if you want to prove that every single line\n+in your program was executed, you should not compile with optimization\n+at the same time.  On some machines the optimizer can eliminate some\n+simple code lines by combining them with other lines.  For example, code\n+like this:\n+.PP\n+.Vb 4\n+\\&        if (a != b)\n+\\&          c = 1;\n+\\&        else\n+\\&          c = 0;\n+.Ve\n+can be compiled into one instruction on some machines.  In this case,\n+there is no way for \\f(CW\\*(C`gcov\\*(C'\\fR to calculate separate execution counts\n+for each line because there isn't separate code for each line.  Hence\n+the \\f(CW\\*(C`gcov\\*(C'\\fR output looks like this if you compiled the program with\n+optimization:\n+.PP\n+.Vb 4\n+\\&              100  if (a != b)\n+\\&              100    c = 1;\n+\\&              100  else\n+\\&              100    c = 0;\n+.Ve\n+The output shows that this block of code, combined by optimization,\n+executed 100 times.  In one sense this result is correct, because there\n+was only one instruction representing all four of these lines.  However,\n+the output does not indicate how many times the result was 0 and how\n+many times the result was 1.\n+.SH \"SEE ALSO\"\n+.IX Header \"SEE ALSO\"\n+\\&\\fIgcc\\fR\\|(1) and the Info entry for \\fIgcc\\fR.\n+.SH \"COPYRIGHT\"\n+.IX Header \"COPYRIGHT\"\n+Copyright  1996, 1997, 1999, 2000 Free Software Foundation, Inc.\n+.PP\n+Permission is granted to make and distribute verbatim copies of this\n+manual provided the copyright notice and this permission notice are\n+preserved on all copies.\n+.PP\n+Permission is granted to copy and distribute modified versions of this\n+manual under the conditions for verbatim copying, provided also that the\n+entire resulting derived work is distributed under the terms of a\n+permission notice identical to this one.\n+.PP\n+Permission is granted to copy and distribute translations of this manual\n+into another language, under the above conditions for modified versions,\n+except that this permission notice may be included in translations\n+approved by the Free Software Foundation instead of in the original\n+English."}, {"sha": "f7fd815be4c2d8e7a1f925682236dc4cb93399ba", "filename": "gcc/gcov.texi", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c01a508e4e8a795f63348accdd04483c9d67197e/gcc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.texi?ref=c01a508e4e8a795f63348accdd04483c9d67197e", "patch": "@@ -2,6 +2,30 @@\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n+@ignore\n+@c man begin COPYRIGHT\n+Copyright @copyright{} 1996, 1997, 1999, 2000 Free Software Foundation, Inc.\n+\n+Permission is granted to make and distribute verbatim copies of this\n+manual provided the copyright notice and this permission notice are\n+preserved on all copies.\n+\n+Permission is granted to copy and distribute modified versions of this\n+manual under the conditions for verbatim copying, provided also that the\n+entire resulting derived work is distributed under the terms of a\n+permission notice identical to this one.\n+\n+Permission is granted to copy and distribute translations of this manual\n+into another language, under the above conditions for modified versions,\n+except that this permission notice may be included in translations\n+approved by the Free Software Foundation instead of in the original\n+English.\n+@c man end\n+@c Set file name and title for the man page.\n+@setfilename gcov\n+@settitle coverage testing tool\n+@end ignore\n+\n @node Gcov\n @chapter @code{gcov}: a Test Coverage Program\n \n@@ -19,6 +43,7 @@ This chapter describes version 1.5 of @code{gcov}.\n \n @node Gcov Intro\n @section Introduction to @code{gcov}\n+@c man begin DESCRIPTION\n \n @code{gcov} is a test coverage program.  Use it in concert with @sc{gnu}\n CC to analyze your programs to help create more efficient, faster\n@@ -77,15 +102,27 @@ timing information you can use along with the information you get from\n @code{gcov} works only on code compiled with @sc{gnu} CC.  It is not\n compatible with any other profiling or test coverage mechanism.\n \n+@c man end\n+\n @node Invoking Gcov\n @section Invoking gcov\n \n @smallexample\n gcov [-b] [-c] [-v] [-n] [-l] [-f] [-o directory] @var{sourcefile}\n @end smallexample\n \n+@ignore\n+@c man begin SYNOPSIS\n+gcov [@samp{-b}] [@samp{-c}] [@samp{-v}] [@samp{-n}] [@samp{-l}] [@samp{-f}] [@samp{-o} @var{directory}] @var{sourcefile}\n+@c man end\n+@c man begin SEEALSO\n+gcc(1) and the Info entry for @file{gcc}.\n+@c man end\n+@end ignore\n+\n+@c man begin OPTIONS\n @table @code\n-@item -b \n+@item -b\n Write branch frequencies to the output file, and write branch summary\n info to the standard output.  This option allows you to see how often\n each branch in your program was taken.\n@@ -273,6 +310,7 @@ executed 100 times.  In one sense this result is correct, because there\n was only one instruction representing all four of these lines.  However,\n the output does not indicate how many times the result was 0 and how\n many times the result was 1.\n+@c man end\n \n @node Gcov Data Files\n @section Brief description of @code{gcov} data files"}]}