{"sha": "9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE4MDk4OTcwYTg0ZjJiMWI3YTFlZjk3ZGNkNWZhN2NkMjhkMjdmYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-11T15:52:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-11T15:52:36Z"}, "message": "lto-symtab.c (lto_symtab_free): New function.\n\n\t* lto-symtab.c (lto_symtab_free): New function.\n\t* lto-streamer.h (lto_symtab_free): Declare.\n\n\t* lto-cgraph.c (reachable_from_other_partition_p): Export; do not assume\n\tthat if function is needed it is reachable.\n\t(lto_output_node): See if it the function is reachable or referenced.\n\t(output_cgraph): Update call of lto_output_node.\n\t* lto-streamer.h (reachable_from_other_partition_p): Declare.\n\n\t* lto.c (lto_fixup_decls): Free no longer needed lto_global_var_decls\n\tvector.\n\n\t* lto.c (lto_1_to_1_map): Remove some no longer needed checks.\n\t(lto_promote_cross_file_statics): Never promote DECL_EXTERNAL;\n\tuse reachable_from_other_partition_p and\n\treferenced_from_other_partition_p test.\n\nFrom-SVN: r159280", "tree": {"sha": "3863b58d5473996402091677849e3dda1ca988af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3863b58d5473996402091677849e3dda1ca988af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/comments", "author": null, "committer": null, "parents": [{"sha": "b80531941013cd00875bb5e1c7e56c06ee149ff8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80531941013cd00875bb5e1c7e56c06ee149ff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80531941013cd00875bb5e1c7e56c06ee149ff8"}], "stats": {"total": 79, "additions": 55, "deletions": 24}, "files": [{"sha": "4f370efcb58fedad625bd6144288bd08cd94619c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "patch": "@@ -1,3 +1,16 @@\n+2010-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-symtab.c (lto_symtab_free): New function.\n+\t* lto-streamer.h (lto_symtab_free): Declare.\n+\n+2010-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-cgraph.c (reachable_from_other_partition_p): Export; do not assume\n+\tthat if function is needed it is reachable.\n+\t(lto_output_node): See if it the function is reachable or referenced.\n+\t(output_cgraph): Update call of lto_output_node.\n+\t* lto-streamer.h (reachable_from_other_partition_p): Declare.\n+\n 2010-05-11  Jan Hubicka  <jh@suse.cz>\n \n \t* crtstuff.c (__JCR_LIST__, __DTOR_END__, __JCR_END__, __FRAME_END__):"}, {"sha": "df4d2446a124442b4890a74d1f8866897f2a09cf", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "patch": "@@ -312,12 +312,10 @@ referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set se\n \n /* Return true when node is reachable from other partition.  */\n \n-static bool\n+bool\n reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n {\n   struct cgraph_edge *e;\n-  if (node->needed)\n-    return true;\n   if (!node->analyzed)\n     return false;\n   if (node->global.inlined_to)\n@@ -339,6 +337,7 @@ reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n static void\n lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t\t lto_cgraph_encoder_t encoder, cgraph_node_set set,\n+\t\t varpool_node_set vset,\n \t\t bitmap written_decls)\n {\n   unsigned int tag;\n@@ -400,7 +399,9 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (bp, node->address_taken, 1);\n   bp_pack_value (bp, node->abstract_and_needed, 1);\n   bp_pack_value (bp, tag == LTO_cgraph_analyzed_node\n-\t\t && reachable_from_other_partition_p (node, set), 1);\n+\t\t && !DECL_EXTERNAL (node->decl)\n+\t\t && (reachable_from_other_partition_p (node, set)\n+\t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n   bp_pack_value (bp, node->lowered, 1);\n   bp_pack_value (bp, in_other_partition, 1);\n   bp_pack_value (bp, node->alias, 1);\n@@ -767,7 +768,7 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n   for (i = 0; i < n_nodes; i++)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n-      lto_output_node (ob, node, encoder, set, written_decls);\n+      lto_output_node (ob, node, encoder, set, vset, written_decls);\n     }\n \n   lto_bitmap_free (written_decls);"}, {"sha": "8e99e2d444f8ff15dacf09c41833d1b6974c8aa2", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "patch": "@@ -863,6 +863,8 @@ void input_cgraph (void);\n bool referenced_from_other_partition_p (struct ipa_ref_list *,\n \t\t\t\t        cgraph_node_set,\n \t\t\t\t        varpool_node_set vset);\n+bool reachable_from_other_partition_p (struct cgraph_node *,\n+\t\t\t\t       cgraph_node_set);\n \n \n /* In lto-symtab.c.  */\n@@ -872,6 +874,7 @@ extern void lto_symtab_merge_decls (void);\n extern void lto_symtab_merge_cgraph_nodes (void);\n extern tree lto_symtab_prevailing_decl (tree decl);\n extern enum ld_plugin_symbol_resolution lto_symtab_get_resolution (tree decl);\n+extern void lto_symtab_free (void);\n \n \n /* In lto-opts.c.  */"}, {"sha": "f8349cf763f7d082ab3af067d29e372aec08ac56", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "patch": "@@ -65,6 +65,15 @@ static GTY ((if_marked (\"lto_symtab_entry_marked_p\"),\n \t     param_is (struct lto_symtab_entry_def)))\n   htab_t lto_symtab_identifiers;\n \n+/* Free symtab hashtable.  */\n+\n+void\n+lto_symtab_free (void)\n+{\n+  htab_delete (lto_symtab_identifiers);\n+  lto_symtab_identifiers = NULL;\n+}\n+\n /* Return the hash value of an lto_symtab_entry_t object pointed to by P.  */\n \n static hashval_t"}, {"sha": "6166a8100835436fe4ae724ca0e8ad7b0ed58ea7", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "patch": "@@ -1,3 +1,15 @@\n+2010-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_fixup_decls): Free no longer needed lto_global_var_decls\n+\tvector.\n+\n+2010-05-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_1_to_1_map): Remove some no longer needed checks.\n+\t(lto_promote_cross_file_statics): Never promote DECL_EXTERNAL;\n+\tuse reachable_from_other_partition_p and\n+\treferenced_from_other_partition_p test.\n+\n 2010-05-11  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* lto-coff.c (validate_file): Add x64-coff support."}, {"sha": "9f6ad400cd7f5125f41cefdcb9e5c70e17f30286", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=9a8098970a84f2b1b7a1ef97dcd5fa7cd28d27fc", "patch": "@@ -556,13 +556,11 @@ lto_1_to_1_map (void)\n       if (node->global.inlined_to || node->clone_of)\n \tcontinue;\n       /* Nodes without a body do not need partitioning.  */\n-      if (!node->analyzed || node->same_body_alias)\n+      if (!node->analyzed)\n \tcontinue;\n-      /* We only need to partition the nodes that we read from the\n-\t gimple bytecode files.  */\n+\n       file_data = node->local.lto_file_data;\n-      if (file_data == NULL)\n-\tcontinue;\n+      gcc_assert (!node->same_body_alias && file_data);\n \n       slot = pointer_map_contains (pmap, file_data);\n       if (slot)\n@@ -735,22 +733,13 @@ lto_promote_cross_file_statics (void)\n       for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n \t{\n \t  struct cgraph_node *node = csi_node (csi);\n-\t  bool globalize = node->local.vtable_method;\n-\t  struct cgraph_edge *e;\n \t  if (node->local.externally_visible)\n \t    continue;\n-\t  if (!globalize\n-\t      && referenced_from_other_partition_p (&node->ref_list, set, vset))\n-\t    globalize = true;\n-\t  for (e = node->callers; e && !globalize; e = e->next_caller)\n-\t    {\n-\t      struct cgraph_node *caller = e->caller;\n-\t      if (caller->global.inlined_to)\n-\t\tcaller = caller->global.inlined_to;\n-\t      if (!cgraph_node_in_set_p (caller, set))\n-\t\tglobalize = true;\n-\t    }\n-\t  if (globalize)\n+\t  if (node->clone_of || node->global.inlined_to)\n+\t    continue;\n+\t  if (!DECL_EXTERNAL (node->decl)\n+\t      && (referenced_from_other_partition_p (&node->ref_list, set, vset)\n+\t\t  || reachable_from_other_partition_p (node, set)))\n \t     {\n \t\tgcc_assert (flag_wpa);\n \t\tTREE_PUBLIC (node->decl) = 1;\n@@ -1465,6 +1454,8 @@ lto_fixup_decls (struct lto_file_decl_data **files)\n \tVEC_replace (tree, lto_global_var_decls, i, decl);\n     }\n \n+  VEC_free (tree, gc, lto_global_var_decls);\n+  lto_global_var_decls = NULL;\n   pointer_set_destroy (seen);\n }\n \n@@ -1640,6 +1631,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \t\t\t node->ipa_transforms_to_apply,\n \t\t\t (ipa_opt_pass)&pass_ipa_inline);\n       }\n+  lto_symtab_free ();\n+\n   timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n \n   timevar_push (TV_IPA_LTO_DECL_INIT_IO);"}]}